00:00:06.090 - 00:00:26.230, Speaker A: So, up next, we've got another awesome talk. This one by JeM Gold, also on the Zoro team, titled beyond the edition custom EiE R C 721 drop extensions for fun and profit. So, yeah, really looking forward to this one, Jim. Thank you so much for the time as well. And, yeah, feel free to unmute.
00:00:27.050 - 00:00:28.166, Speaker B: I'll get out of the way so.
00:00:28.188 - 00:00:31.462, Speaker A: You can share your screen, share your video. Yeah, you're already on it. So awesome.
00:00:31.516 - 00:00:46.682, Speaker B: Thanks so much for being here, Jim. Sweet. Thank you so much, Jacob, and thank you, Ian. And I hope that these two talks will pair with each other quite nicely. We didn't plan this, so we'll see how it goes. Let me just share my screen. Awesome.
00:00:46.682 - 00:00:58.720, Speaker B: Perfect. Looks great. Thank you. See my screen get away? Yeah. Sweet. Cool. Beyond the Edition Custom Yasse 721 Drops Extensions for fun and Profit this might be a tongue twister of a talk.
00:00:58.720 - 00:01:37.270, Speaker B: Okay, so we recently launched Zora creator. Zora Creator is the simplest way to create additioned ERC 721 tokens on artist owned contracts. It has a super simple interface, and it's the most user friendly way, we think, to create additions for images, for videos, for audio files, things like that. At its core, Creator is an interface for managing an underlying contract. ERC 721 drop. It's a really good contract. It strikes the balance between being fully featured and customizable.
00:01:37.270 - 00:02:12.120, Speaker B: And it's also extremely gas efficient. When I say gas efficient, obviously price fluctuates based on gas prices, ETH prices, things like that. But earlier this week, it was, you know, in the ballpark of me spending maybe $50 to deploy my own contract and mints for collectors on that contract. Somewhere in the ballpark of $3. This is on ethereum. L One. There's no price savings from being on L2, nothing like that.
00:02:12.120 - 00:02:45.790, Speaker B: This is full fat ethereum. L One. As an artist, I'm old enough to remember February 2020, where minting, even single tokens on other platforms, shared contracts cost hundreds and hundreds of dollars. So, needless to say, this is a really great contract. This isn't a talk hyping up how efficient our contract is out of the box. Ian has already showed you some amazing things you can do with this contract, building your own websites for these contracts. And I want to take us in a different direction.
00:02:45.790 - 00:03:59.190, Speaker B: What if, out of the box, ERC 721 Drop doesn't actually do everything that you need it to do? What if you want to go beyond the functionality available? ERC 721 Drop, for example, has a robust system for managing public sales, with options for sales that are timed or open ended, for sales that are free or paid, available in fixed quantities or maybe unlimited runs. We have lots of options baked into it, but we also have no assumption that this is the only way that you might wish to distribute your NFTs. As an artist, as a creator, as a community, perhaps you might want to gate access to a presale based on holding a threshold of your dow's ERC 20. Perhaps you want to give a discounted mint to collectors of a previous ERC 721 token. If you want to do batch pricing or bundles, things like that, you might want to experiment with pricing on a bonding curve. You might want to prevent people from minting tokens on the Sabbath. These are all good use cases.
00:03:59.190 - 00:04:34.110, Speaker B: The same is true for the content of your tokens. Additions as you've seen them on Creator are pretty simple. They store a reference to one piece of media on IPFS that's whatever it is that goes cool, I can draw on screen whatever it is that goes in here. They store a reference to a piece of media, and that is one piece of media. The same for every token in an addition. And this is great. We use this and we use this ourselves for our drops.
00:04:34.110 - 00:05:20.718, Speaker B: And many, many successful drops have come out using this exact methodology. This is great. But obviously that's not everything that you might want to do with an NFT. Maybe you're a musician and you want to store meaningful metadata on chain with each token. Maybe you've designed a tarot card deck and from an array of images from the whole deck. Maybe you just want to pull one card that was upside down for each mint on the platform, right? Sorry. Maybe you want to pull one randomized image for each token that is minted.
00:05:20.718 - 00:06:21.090, Speaker B: Maybe you're a generative artist and you want to do a project with a live code based renderer and a randomized seed per token along the lines of platforms like Artblocks or FX Hash or our favorite drops like Solvency and Saltgrade. You know the type of drop. Thoughtful handling of metadata is at the heart of every NFT project, and having full creator control of it is absolutely pivotal for creators doing the paradigm pushing work that we are obsessed with at Zora and as individuals. So if you're running into any of these scenarios, you might be tempted to say, oh my God, Zora's contract sucks because it didn't consider my niche and didn't mean specific use case. You might write a new contract from scratch, maybe using base templates from Open Zeppelin or Soulmate. You might fork our contracts, tweaking the code so they work as you like and deploying your own version. This is a hackathon.
00:06:21.090 - 00:07:08.598, Speaker B: These are all completely valid. These are all completely valid approaches, right? Our contracts are on GitHub. They're open source. You can find them and go wild. But we think there's a better way to go about it, a way to keep the majority of ERC 721 drop as it is, and to be able to rely on knowing that you're using the exact same base contract as we do. It's optimized, it's efficient, and it's loaded with features that we think are really useful for creators who are doing industry leading work. It turns out that our additions contracts, as you've seen them on Creator are kind of just the tip of the iceberg, really.
00:07:08.598 - 00:08:21.946, Speaker B: The features that you see on Creator, the ways you can instantiate an addition on this screen is just one option for configurating an extremely customizable architecture of contracts, modular contracts rather than forking ERC 721 and tripping over yourself trying to keep your own domain specific customizations separate from the majority of the Zoro contract logic. Instead, we have a way that you can extend them with discrete, reasonable chunks of logic. These can even be designed in reasonable ways so that when you deploy into mainnet, your internet friends can use them for their projects as well. We've seen a handful of drops using these techniques already, but it's definitely not immediately intuitive going to say it. While the contracts are well designed and easy to read and honestly they have really sick ASCII diagrams in the comments that Ian made. Should check them out if you haven't seen them. There's still a lot of moving pieces and I know from my personal experience that it can be kind of overwhelming trying to figure out which places to poke around in first.
00:08:21.946 - 00:09:06.620, Speaker B: Don't worry, we've got you. For the rest of this talk, we're going to show you how you might get started with two of my favorite pathways for customizing our drops contracts making custom metadata renderers and making custom minting modules. Before I get into it, I want to stress that this is kind of advanced stuff. You might not need anything more than our standard Editions contract deployed straight from Zora Creator. If that's the case for you, that's great. This is just an option available to people who want to push things further than they can get with the out of the box contracts. It's not an insinuation that you have to do things this way or this is what Zora wants you to do.
00:09:06.620 - 00:10:02.666, Speaker B: These are just options available to you. With that said, I think these techniques are really exciting and if you do something based on this, I'm going to be stoked to see it. So bit of both. This is also going to be a pretty solidity heavy talk. You don't need to be a solidity galaxy brain for this talk, but you should probably have done an intro to solidity course. You should probably have understood at least the basics of how an ERC 721 drop works at its core. If if you listen to some of the examples that I shared a few minutes ago and you're like, yes, I want to do that, but maybe you don't have the solidity skills to implement it, that's completely cool.
00:10:02.666 - 00:10:54.654, Speaker B: And I think hackathons are really good opportunities for you to pair up with people who do have that experience and maybe get together and learn a little bit from each other. So I just wanted to share that because this might be a little bit. This is kind of Zora 201 or 301 maybe. Okay. Also, as Max shared earlier, we have a suite of composable tools that you can use kind of whatever level of abstraction that you are comfortable with. So if you don't want to dive in to playing with Zora toys at the contract level, well, you can tap into whatever feels best for you and your level of programming experience. And that might be using our TypeScript client, that might be using the Protocols GraphQL API, that might be using our React hooks, that might just be using Create Zora Co, kind of as it is.
00:10:54.654 - 00:11:38.442, Speaker B: And so I just wanted to share that. Okay, so let's start with custom metadata renderers. As Ian kind of touched upon earlier, the best place to start for this really, is looking at how these contracts are created. Now, the heart of this system is a factory contract called Zura NFT creator v One. As I get into these code leaning slides, I just want to say my slides aren't online just yet. I'm going to format them a little bit more after this talk, and I'll publish them probably sometime this afternoon. So you'll be able to find those on the Zora Engineering Twitter account.
00:11:38.442 - 00:12:31.310, Speaker B: I'll post those there. So I just wanted to say that before I get into filling the screen with code. So we have Zora NFT creator v One, and if you look through that, you might see a function called Create Addition, which I believe Ian was talking about. It contains some pretty standard stuff for instantiating an ERC 721, a name, a symbol, details about the addition size, and about the sales configuration. And then down here at the bottom, I don't know how to change the color of my marker, but that's okay. Down here at the bottom, we have the details that you might expect from if you've created an addition on our website. Basically an animation Uri, an image Uri, and a description.
00:12:31.310 - 00:13:17.878, Speaker B: There's a sibling function in this contract called Create Drop. Similarly, you have all your kind of standard ERC 721 bits and pieces here. Instead, what it does is it asks you for a metadata Uri base and a contract Uri. This is really useful if you have your metadata that lives on a server somewhere, or you have metadata that lives on IPFS based on a Uri base. So you can configure it these ways. You can interact with both of these contracts however you like. Whether that's in Etherscan, whether that's in Foundry, whether that's Ethers.
00:13:17.878 - 00:14:07.050, Speaker B: Personally, I've been deep diving into Foundry recently, and I got over the hurdle, and I love it now. So shout out foundry team. It's my favorite way to play with contracts from my text editor. But if Create Drop or Create Addition don't suit the needs of your project, well, I promised you would go deeper. So let's go a little bit deeper under the hood. Each of these contracts. Call setup drops contract yet again, it's a publicly callable function in Zora NFT creator, and instead of passing in an Image Uri, animation Uri, et cetera to it, what you pass in I wish this highlighter was a different color is an Imetada renderer and a metadata initializer.
00:14:07.050 - 00:15:09.866, Speaker B: So let's figure out what Imetadata renderer is because it's kind of at the heart of all of this. I metadata renderer. It's a really simple interface that we created, has three methods. It returns the Token Uri for a given token, it returns the contract Uri, the general contract information for a given contract, and it has a little function that we'll get into a little bit later that allows you to pass in some data from it, from the factory, or from wherever you initialize it. So looking at Addition metadata renderer, this is the standard thing that we're all kind of familiar with at this point. Maybe the Addition Metadata renderer is just one possible metadata renderer that can be used by any ERC 721 drop. It just so happens that on the Zora Create website we have currently only implemented addition metadata renderer.
00:15:09.866 - 00:15:53.760, Speaker B: There are more coming soon you can create your own, which is, I guess what I'm talking about right now, how Addition Metadata renderer works. It's pretty simple. All we're doing is we have a struct called Token Edition Info and we pass it a description, an Image Uri and an Animation Uri. And then this renderer is shared between different contracts. So multiple drops can use the same renderer without having to deploy it over and over again. And this is really nice that it's nice and gas efficient. 1 second.
00:15:53.760 - 00:16:53.658, Speaker B: Okay, we store this in a mapping from the address, the address per the address of the ERC 721 drop to the token info. And then in Token Uri, if you've done any ERC 721 project before, if you've used Open Zeppelin, if you've done solidity for zombies like anything like that, you've probably kind of seen something like this before. You've seen your Token Uri function that gets passed a Token Uri and returns I need my pointer back. And returns a string. The string is the JSON of the metadata, right? So a simplified version of this contract is that it gets the address of the drop from message sender. Oh, the thing that I should explain is that these drops, basically the drop contract will farm out. It's called tokenuri to the underlying metadata renderer.
00:16:53.658 - 00:18:03.382, Speaker B: So all it's saying is instead of having this tokenuri logic in my drop, I'm just going to store it somewhere else in a different metadata renderer and delegate to that. So we get the address of the drop from message sender, we find our token info struct from that address here. And then like I said, this is just an addition that has the same information per token ID. So that's what we do and then we return it. However, you like to concatenate JSON so you'll see, sorry, addition Metadata Renderer if you take a look at the code, it's all in GitHub and Azora. Addition Metadata Renderer, it implements a couple of other functions. It has some helpers that let for example, like the contract administrator to update some of the information and it has some bits and pieces, it has some events that it admits and such like, but under the hood it's pretty much this it's relatively easy to follow.
00:18:03.382 - 00:19:03.302, Speaker B: So you might want to start by taking a look into that. And with that said, it also means that if we want to create our own metadata renderer, we really just have to follow this pattern of implementing the Imetada renderer interface. This thing going back, we would pass it in when we're calling setup drops contract, we would have a deployed Imadadata renderer and we would pass it in here. So I just want to take a look at some patterns that might be useful. Guess there's no syntax highlighting here. Take a look at some patterns that might be useful if you're creating your own metadata renderer. So one thing is that you might wish to make a metadata renderer that can work with multiple drops.
00:19:03.302 - 00:20:12.750, Speaker B: So instead of having one metadata renderer for one drop, one metadata renderer for another drop deployed, that gets pretty heavy. You might want to say there is a common set of reusable logic that different contracts can use different drops contracts. So what you might want to do is store this is exactly what Addition Metadata Renderer does is we store a mapping from an address of a drop to some data type. That could be a primitive, it could be a string or a boolean or whatever. It could also be a struct like we do in Token edition in the Flow. You might also want to store some data that is mapped both to the drop contract and also token IDs. In that case I would probably do something like a mapping of a mapping or whatever data structure feels good to you in that case to store data on a per token basis.
00:20:12.750 - 00:21:18.626, Speaker B: It also might be the case that you have an extremely, extremely niche metadata renderer and you don't want anyone else to be able to reuse it without redeploying it, in which case go wild. You do you I'm just saying these are some patterns that might be useful if you're implementing a metadata renderer this weekend and you're looking at our code and you're like basically what is this first address parameter? So with that said, let's say you're making a music NFT metadata renderer. I hope someone does. And let's say you have some data that is useful to be stored on a per drop basis, but you also want to have data that can be initialized one time just when the contract is deployed. This is something that we do. We have a library that you're free to use you're free to not use called Shared NFT Logic which handles things like has our JSON helpers and things like that. You're free to use it.
00:21:18.626 - 00:22:04.382, Speaker B: You're also free to use a constructor. You can pass that into the constructor and you're free to use a constructor kind of wherever you like. And this is at the global Metadata Renderer level, kind of a sibling pattern to this. It's like cool. Okay, well, let's say you have your one deployed renderer and you want some custom data to be set for each drop that calls it. Again, we do this in the Addition, Metadata Renderer and a couple of others. So in that case, the way that we handle this to keep the function signature of Imadadata Renderer kind of consistent is to say instead of parameterizing it based on different variables.
00:22:04.382 - 00:22:44.274, Speaker B: What we actually do is we abi encode those variables, whatever shape they are, whatever type they are. I've tried it with like strings and booleans and numbers and such things like that. I presume it works with other things that can be API encoded. We call initialize the data and this is the other parameter that we pass to set up drops contract so we'd pass in our initialization data. Top tip, if you don't need to do this pattern at all, that's great. You can just pass in an empty string when you call this function superchill. You don't need to do this.
00:22:44.274 - 00:23:27.822, Speaker B: This is just an option. But this is really great that this is exactly how we'd know. In this case we want to set a custom image Uri, description animation Uri on a per drop basis. So we were to pass this in bytes data, we abi decode it. It's kind of like destructuring JavaScript. If you haven't done this pattern in solidity before, set whatever data type it is and then we're free to use it helpful. We want another sibling pattern that might be useful is well, this kind of got long is using Metadata Render Admin Check.
00:23:27.822 - 00:24:16.126, Speaker B: So in the case that you have a contract that is owned by a particular account and you wish to have some protected functions in there. So in this case we're just storing mapping from an address to a string called Token Data. So we only want our admin to be able to update this. We have some little helpers that if you just poke around in the Aurodrops contracts repo, you see that this one's called Metadata Render Admin Check and you just import that and then you have a modifier that you can add to your function here. I think that's section, yeah. Cool. Okay.
00:24:16.126 - 00:24:48.860, Speaker B: Onto custom minters. So this is actually really simple. The other one was like kind of complex, also kind of relatively hard to do anything dangerous. Custom Minters I'm just going to say be careful doing this in terms of the code to implement it. It's a relatively simple thing. You also have the potential to rug your whole project. So with great power comes great responsibility, I guess.
00:24:48.860 - 00:25:42.998, Speaker B: Okay, so with that said, all we're going to do to create a custom Minter is from our drop. So this is our drop that we've already deployed. And again, this can be a drop that you've deployed from Etherscan. This can be a drop that you've deployed from UI on Create Zora Co really kind of however you want to do your drop, we have a drop and we just want to grant it a role of mentor. Grant it a role of mentor to the mentor contract. Now, these roles, just using the Open Zeppelin permissions model, these roles can be granted to other externally owned accounts. So you can give this to your friends on the team, then they can rock the project as well to other humans.
00:25:42.998 - 00:26:36.070, Speaker B: And you can also say, you can also grant this to a smart contract. So that's what we're doing when we make a custom Minter. So all that you have to do, if you've granted a Minter contract, this role, whether you've done that in Ether scan or whether you've done that in I do it in Foundry just because I don't like typing the same thing over and over again later. This is in your Minter contract. You can just call admin Mint and it's like a backdoor to Mint into the contract that bypasses all of the traditional sales logic. And again, the nice thing about this is you can reuse them between all different drops. So many different drops can just add these different Minting modules without having to change their underlying ERC 721 drop implementation.
00:26:36.070 - 00:27:08.982, Speaker B: You just grant one of these a specific role and then you're good to go. I'm going to leave the implementation of these up to you because it's extremely domain specific, I guess. And again, I'm just going to say it. You probably want to be testing these functions. We've been using Foundry, writing a load of testing, buzz testing for things like checking prices and stuff that's beyond the scope of this talk. Happy to help you later. But this is basically it.
00:27:08.982 - 00:27:37.678, Speaker B: Now, this contract doesn't implement any particular interface. There's no particular signature that it needs to inherit or anything like that. All we're saying is that we have a function, doesn't have to be called purchase either. By the way, this is just what I've called it. So we have a function called Purchase that implements our custom logic. Now, again, this is the skeleton. You want to fill in the blanks here yourself.
00:27:37.678 - 00:28:05.042, Speaker B: So let's just look at the signature for what I've done. The signature takes a target. And again, this is an address of a drops contract. You could also pass in the target in the constructor, but again, just store it on the contract. But it's kind of nice, again, to have these modular drops or work with anything where your contract is an approved Minter. So you can't call it on any contract. This contract has to be approved.
00:28:05.042 - 00:28:32.270, Speaker B: But there you go. And all we're saying here is exactly like it was in the last slide. Try admin minting to the message sender. Doesn't have to be message sender. It can be whatever you want it to be. Quantity. Is that's part of the signature of Admin Mint here? This line up here or the missing lines, this is the fill in the blanks.
00:28:32.270 - 00:29:01.766, Speaker B: You want to be checking the price that you're letting people Mint for. You want to be checking any logic. If you're token gating something, this is where you token gate. I know. Last weekend for zorotopia in Oakland, we implemented signature minting. So that's where we do our signature checks. Again, all of this is kind of out of the scope of what I have time for in 1 minute or maybe 30 seconds, but we're happy to help you if you have specific details, but this is kind of the fill in the blanks.
00:29:01.766 - 00:30:04.190, Speaker B: It's also the kind of hippie dragons. The other thing that's kind of useful I think, is this little snippet that we have here, which again, I'm going to publish these slides later. All we're doing here is saying if the value that you're purchasing for is greater than zero, basically if we're sending money into our Minter contract, we should just forward that to our dropped contract. Otherwise you're just going to end up with money spread between different contracts and that's kind of messy. So yeah, really implementing Minters is pretty simple and also kind of dangerous, I guess. Be really careful, write your tests, make sure you're only granting that role to contracts you trust, et cetera, et cetera. But that is kind of the modular Zora way of creating these reusable chunks of logic that you can use across all of your projects that you can configure in different ways that you can share with your friends.
00:30:04.190 - 00:30:28.094, Speaker B: And then again, to recap, if you want a custom metadata scheme that doesn't really work with our Drops metadata renderer or our Addition metadata renderer, we're just implementing I metadata renderer and I think that is even more than I have time for right now. Thank you so much. Thank you, Jim.
00:30:28.142 - 00:30:37.380, Speaker A: This is awesome. Yeah, simple and dangerous. Those are two words that blend together, can lead to amazing things and also very explosive things.
00:30:39.830 - 00:30:41.182, Speaker B: Got to live on the edge.
00:30:41.326 - 00:30:57.722, Speaker A: Got to live on the edge. Well, thank you so much for the talk and for the intro there. Again, I think another just back to back awesome talks from the Zara team so far. So lots of amazing resources for people as they build. I love that this one went even deeper than the last talk.
00:30:57.776 - 00:30:59.418, Speaker B: So yeah, I think we did a.
00:30:59.424 - 00:31:04.460, Speaker A: 101, a 201, and now a 301. So thank you so much for being here.
00:31:04.830 - 00:31:20.100, Speaker B: Thank you. Looking forward to seeing what everyone builds and sorry, the last postscript is that if you run into issues with this, please reach out to us. Zora engineering on Twitter. We're not just shit posts and memes. Please ask us for help doing that stuff. So looking forward to seeing what everyone builds. Thank you.
00:31:20.100 - 00:31:21.106, Speaker B: Love it.
00:31:21.128 - 00:31:21.870, Speaker A: Thanks so much, Jen.
