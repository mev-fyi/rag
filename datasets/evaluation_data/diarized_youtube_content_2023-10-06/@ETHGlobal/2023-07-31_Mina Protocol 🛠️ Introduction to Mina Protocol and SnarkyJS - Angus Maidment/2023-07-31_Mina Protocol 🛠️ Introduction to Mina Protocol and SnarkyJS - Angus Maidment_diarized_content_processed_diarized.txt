00:00:07.050 - 00:00:29.558, Speaker A: Brilliant. Sorry for the slight delay in starting. I'm also holding my charger, which I hope I can plug in at some point if I'm low on battery. Hi, everyone, my name is Angus and I'm going to talk to you today about Mina Protocol and Snarky JS. So it's July 21 today. There's my name. Yes.
00:00:29.558 - 00:00:59.262, Speaker A: My name is Angus. I do developer relations and I talk to people about Mina Protocol and tell them about building ZK apps with Snarky JS. I live in Edinburgh. In Scotland? There's a picture of me doing steganography, so blending into the sign. And also if you see the keynote, like, main stage presentation tonight, you might see me in a pickle costume. So you can follow me on Twitter as well, blockchainbeard and send me memes. That would be cool.
00:00:59.262 - 00:01:32.742, Speaker A: Today the structure of the talk will be introduction to Mina protocol and zero knowledge proofs. We're going to talk about Zkaps, how they work with Mina, Snarky JS. That's how you build zkapps. That's the TypeScript library. And we had a program called ZK Ignite, which I'll tell you about, but I think the applications have just finished. But you can still find out about how you can get involved and some next steps, particularly how you can get support for the hackathon this weekend. Right, my bags arrived, so here we go.
00:01:32.742 - 00:02:07.622, Speaker A: Thanks for covering the whole thing up. Asin I thought it was probably easier than trying to explain to him where the adapter was. In my bag, I've got quite like a complex packing system. So, zero knowledge proofs. Who here has heard of CK? Good. Lots of hands going up for those of you who are watching the stream. So I'm going to do a kind of speed run introduction to Zero Knowledge Proofs, just so everyone has the requisite knowledge to be able to understand what Zcaps are and how they work.
00:02:07.622 - 00:02:44.186, Speaker A: So it says here you can use zero knowledge proof to prove and verify information in a private, trustless and decentralized way. So that's good for blockchains. If you know anything about Blockchains as well, a good way to think about it is a good way to think about what you can do with a zero knowledge proof. You can prove to someone that you know something without revealing extra information. Right. And so that can be different in different contexts. A good way of thinking about it is the game where's Wally, that's what the character Wally looks like, he's called Waldo in the American version.
00:02:44.186 - 00:03:40.180, Speaker A: So there's this giant picture of loads of crazy stuff going on in this kind of big map and you got to find this character called Wally. And so if you want to show someone, like, prove to someone else that you know where Wally is, you can show them the map or like, the picture, you can just point to the Wally character, but then that person knows where Wally is as well. Right. So then they can go and say to other people, look, I know where Wally is. So the way to think about what you can do with a zero knowledge proof is you get the Wally map, you get a large piece of like white card, you cut an exact Wally size hole in the card and then you lay it over the map. So then you can show that to someone and say, look, there's Wally, because you can see the little Wally character, but you can't see any of the contextual information around. You don't if you looked at the map after that, then you wouldn't just be able to pick out Wally because you've not seen where he is relative to anything else.
00:03:40.180 - 00:04:39.606, Speaker A: So that's kind of a way that you can think of what zero knowledge proofs can do. And so there's actually lots of use cases that you can use zero knowledge proofs for. Something that people are talking about a lot is using them to increase scalability and do roll ups and things for various different L two S. And so also the idea of having a zkvm where you can kind of write computation and prove it using serenology proofs. It's also good for things like private transactions. Voting identity is here. Identity obviously very important in our digital world, right? The concepts of identity and proving certain things about your identity, but then not revealing all of your information at once is something that you can do with zero knowledge and just this idea as well of verifying computation, right? This is a slide as well.
00:04:39.606 - 00:05:34.198, Speaker A: We're going to take a look at zero knowledge proofs and compare them to some other cryptographic tools that you might have used and take a look at the kind of, what's called the kind of prototypes, I think, for how you use them. So something that you need to know as well about zero knowledge proofs, the proofs that Mina uses, you can verify in constant time. So it's very fast and you don't have to see all the inputs that somebody used to produce the proof. So you can choose, you can keep inputs private or you can make them public. So that's something that's very good for privacy as well, if you want to offer your users privacy and not having to make all their inputs to methods public. So here you go. You've probably used a hash function before.
00:05:34.198 - 00:06:43.770, Speaker A: So in a hash function, you put some data in like as a string, and then you get out this other string, right? And hash functions have a number of properties, but the main thing that we're considering here is the fact that if you have some data and then you put it through a hash function, you can verify someone else, right? You can give somebody else the data, then they can use the hash function. So when you get the same string out, then you know you got the same data, right? So you can verify the integrity of data with a hash function. Similarly, with a public key signature, you can take some data, you can sign it with a private key, and then other people can use the public key to verify this message. Or data has been signed by some private key, right? So then zero knowledge proofs. The way that they work in Mina is you write a computer program. So you give people some code to do some computation and then they do this kind of compilation step and they generate this string called the verification key. Now, when it comes to people using your code, right? So you give them the code that you've written and they run this thing called the prover function.
00:06:43.770 - 00:07:19.754, Speaker A: So this is here in the middle prove, you have a program that you're running and then you have some public inputs and some private inputs that generates the proof, right? The ZK proofs that we're talking about all the time. So that generates a string. That's the proof. And then you can run the verification function, which uses the proof that you've generated when you ran the computation, the public inputs, but not the private inputs. And the verification key that you created when you kind of built your ZK app, right? And that comes out as a boolean. So you can verify that a proof is either valid or not valid. Okay? So, hash function, you put data into it.
00:07:19.754 - 00:08:00.630, Speaker A: But now what we're doing is we're saying using this cryptography, you can let someone prove that they've done some computation, right, that they've run some program. So that's how Mina works, right? We use zero knowledge proofs to verify all the computation that happens, all the transactions that happen. It uses ZK. So that's why the banner downstairs says the world's first ZK blockchain. It's a layer one built entirely using ZKPs. Okay? And as I said already, right, ZKPs are great for privacy and scalability. So Mina has a number of these advantages.
00:08:00.630 - 00:08:44.446, Speaker A: Verifying the state is very quick, so it's constant time, as I said, so you can verify the state. And these proofs stay the same size. And Mina has a feature as well called recursion, where you can kind of use proofs as input to generate new proofs. So the actual blocks in the chain are linked together by having a kind of proof of their state. And then that gets kind of put into the next when you generate the state proof for the next block, you use the previous state as a kind of input. So in that way, you can verify all the blocks leading up to the current block. And it's very fast to verify.
00:08:44.446 - 00:09:21.520, Speaker A: So that also, you may have heard that it's a 22 kilobyte blockchain, so you can verify the state of your account. So you need the state proof, which is like 1. Then there's some metadata, but with 22 can verify the state of your account. On the Miner network and you can sync a node with just that small amount of data. So that's pretty cool. This isn't just stuff that we're kind of telling people about though. There's people doing work, the Nil Foundation are working on this thing.
00:09:21.520 - 00:09:52.566, Speaker A: This kind of way to take a Mina proof and then verify it in the EVM. So then you could imagine doing a bunch of compute using Mina. You create a proof that you've done all this compute and then you can verify that in the EVM and then make things happen in an EVM blockchain, but do all the compute using Mina. So that's going on. We can link you to that. It's still in research phase. We also have openmina.
00:09:52.566 - 00:10:37.830, Speaker A: So this is an actual blockchain node that runs in a web browser, which is pretty cool. So then if you want to build apps and have users use your apps, they can spin up a node in a web browser and they don't have to go through some sort of third party service or node provider or something. So that's cool. So now that I've told you about ZK proofs and how Amina uses them, you're probably wondering how can I build stuff with zero knowledge proofs as well? And that's where we come to ZK apps. Okay? So there's kind of the smart contract functionality. It lets you build what we are calling ZK apps. But there are apps that use zero knowledge proofs.
00:10:37.830 - 00:11:50.846, Speaker A: If you've heard of Ethereum, if you've done development using EVM, the model that the EVM uses is on chain computation. So you verify computation by having all the nodes of the network executing the same code and then they all get the same result, right? So in the diagram here, you've got someone, a user using this computer, they want to use the call some smart contract method. And then all the nodes on the Ethereum network process, they run the method and they apply the updates or whatever. So you're replicating all that computation amongst all these nodes. Now mina is different. So ZK apps actually use off chain computation and then on chain verification. So the way it works is you write some code, the user runs your code, produces the proof that they've run the code, and then the MENA network will take that proof, verify the proof, and then apply the state updates that the user wants to do by using the ZK app.
00:11:50.846 - 00:12:32.362, Speaker A: So that's quite different, right? So all the code is run client side, and then they are passing this proof in a transaction and then the proof gets verified. So it's very different to the EVM kind of model that I just explained. So there are a number of advantages to using off chain computation. Mainly privacy. So, as I said, you can choose which of the inputs that users provide to smart contracts. You can choose to make them public or keep them private. So that's good for privacy.
00:12:32.362 - 00:13:13.392, Speaker A: There's no gas fees as well in the way that you think of them usually. So the cost of using the MENA network doesn't scale with computation. So you can do as much computation as you want and all you have to pay is the single transaction fee to send the proof to the network. So in that way you can do as much compute as you want, you just produce this one proof and then you pay a transaction fee to the network. So no gas fees. That's pretty cool. There's composability as well.
00:13:13.392 - 00:14:25.196, Speaker A: So it allows you to do things. You can design your apps in a way that is kind of modular, but then also you can basically build your own roll ups as well. So this feature that I mentioned earlier called Recursion, so you can take a proof and then you can use that as an input to another proof. So there's some cool things you can do with that and I'm going to tell you a bit more about it later on in the presentation. And then also the idea that because the state proof is small and fast to verify, then the idea is that you can kind of verify that in different places. So you can use Mina to do compute and then verify it in other places or in other blockchains. So just to walk through the kind of process that you need to think about when you're building ZK apps, the way that it works is that compile step that I was talking about earlier, when you generate the verification key and you deploy your ZK app, you send this verification key to the network.
00:14:25.196 - 00:15:20.292, Speaker A: So here there's a box with a key in it that goes to the nodes of the network. So this verification key is public and that's what you use to verify the proof that people generate. So then when a user uses your ZK app here it's hosted@michaelzp.com, so they use your ZK app, they run the code with some inputs and then they generate this proof. Then what happens is they send that proof in a transaction and then the nodes on the network use your verification key from earlier and they say whether that proof is valid or invalid. So if you have a valid proof, there might be some state updates to apply, but then if it's invalid, the transaction gets rejected. So Zkaps are built of methods.
00:15:20.292 - 00:16:21.880, Speaker A: So if you want to build Zkaps for the hackathon, you're going to be writing methods. And there's a kind of diagram here and it's saying that methods have arguments. So inputs you have smart contract state, so you have a very small amount of on chain storage to store state for your smart contract you have some values from the rest of the world, so a database or server or something. And so then when you run a method, the outputs are you can kind of apply updates to your smart contract state or you can apply updates to the state externally as well. So that's kind of what goes in and out of methods. And so if you want to write methods, you're going to need to know Snarky JS. So Snarky JS is a TypeScript library.
00:16:21.880 - 00:17:06.228, Speaker A: So if you want to petition to have it renamed to Snarky TS, you can argue with people on GitHub about it. So then it's the TypeScript library for defining zero knowledge proofs. So you can create there's the low battery warning. You can create, prove and verify zero knowledge proofs. So there's tools that you already know and love if you are familiar with TypeScript. So we have good integration with Visual Studio code IntelliSense, which is very useful. And you can use tools like NPM and Jest for testing.
00:17:06.228 - 00:17:34.832, Speaker A: So the idea of Snarky JS is to make your life easier and to make it easy for you to build apps using ZK. This is the five step kind of quick starter. So all you have to do is an NPM install. There's a CLI tool that is designed to make your life easier as well. It can help you setting up, building and deploying your projects. And then we've got some flyers with this information on it as well. So come to the booth and you can get some.
00:17:34.832 - 00:18:09.884, Speaker A: Otherwise this is in the docs as well, which I'll link you. You know, the idea is here you can kind of get started, install the tools and deploy ZCAP in just five steps. So if you want to write Socky JS Smart contracts, you need to know about field elements. That's the kind of the numbers that you use in zero knowledge cryptography. There's this concept of using finite fields to do operations. So that's the basic unit of data that you need to use. You can store a number almost up to 256 bits.
00:18:09.884 - 00:18:48.040, Speaker A: And so we have a type in Snarky JS called field. And so there's a kind of little example here of how you would declare this constant sum in a programming language that you're familiar with already. You would just use the numbers one and three. But in Snarky JS you need to say, I'm using the field type. So then here that's what's here that's saying make a field, give it the value one. And then it's got a built in method which is add. And then it's saying add this other new field that I'm creating here with a value of three.
00:18:48.040 - 00:19:17.140, Speaker A: So fields, you have to use fields for everything. That's just how the ZK cryptography works. So we also have other built in Types again to make your life as a developer easier. So things like merkel trees, public private keys and signatures, things like that. So these have built in methods as well. So hopefully you should be able to find types and methods to do what you need to do. And if you think one is missing, you should build it and enter it for the hackathon.
00:19:17.140 - 00:20:10.230, Speaker A: This is the basic example, smart contract that comes with the CLI tool. And so I was just going to walk you through it quickly. At the top here, I think if you can see my mouse, this is saying so it's using the state decorator that's saying that you're storing this on chain. So you get eight fields of storage for a ZK app. And so here it's saying we're going to store a number in that state. You kind of create a smart contract by extending the smart contract class. You declare some state that you want to store.
00:20:10.230 - 00:21:10.120, Speaker A: I was trying to scroll down so that you declare what you want to store on chain in the state. And then here is some things where this is setting up the permissions for who can do what and how to interact with the ZK app. So you can read more about permissions in the docs. So the init method initializes your ZK app. So here it's just going to say this state variable that we've declared we're going to set to one. And then there's an update method here that's saying we're going to get that field from the state. We're going to verify that it actually equals the current state and we're going to add two to it.
00:21:10.120 - 00:21:49.670, Speaker A: So then it's saying add two. And then this assert equals this method is then saying we've added two to it and we're going to check that the new state equals the old state plus two. So this is kind of thinking about what you're proving and then it's saying here we're going to set that new state. So when you call this method, then it adds two to the state. And then next time when you look at the state there'll be number plus two there. So that's a very basic example. That's what a smart contract looks like.
00:21:49.670 - 00:23:01.288, Speaker A: I said you earlier that I was going to tell you more about recursion. Recursion is a very cool feature of Snarky JS. So this example has this card game here. Nobody ever mentions it, but so I thought I should start pointing out that it's probably the worst card game ever because everyone has exactly the same cards and I think isn't that one of the most powerful hands you can have in poker, right? So everyone's got like one in a million straight flush or something. So if you imagine a card game, a turn based game, because you can take proofs that you've already created and use them as input for making other proofs, you can have a player. So player one will run the kind of game logic and produce a proof that says I have taken my turn in a way that is valid according to the rules, like the logic of the game. And they can generate a proof that says that they can pass that to pL2 and pL2 can verify the proof so they can verify that player one has taken their turn in a way that is valid.
00:23:01.288 - 00:24:00.384, Speaker A: They can then take their turn, and then when they produce a proof that they've taken their turn, they can use the proof that player one handed them. And so then when they produce a new proof, player three can check that pL2 is taking their turn in a valid way, but also that player one has taken their turn in a valid way as well. So you can kind of imagine passing around the proofs around the players, add infinium or until the game ends. And then also you notice as well that there's no blockchain in the middle here. So you can kind of do this off chain, passing proofs around and verifying things without putting things back on the blockchain until you want to. So in that way, the recursion lets you do a lot of cool things, but you have to think about things in a slightly different way. Here's a couple of examples of things people have been building on Mina for our ZK Ignite program.
00:24:00.384 - 00:24:46.300, Speaker A: So people are doing L2 S to enhance privacy and scalability. Someone's made a keyless wallet, so things that use social recovery and shamir secret sharing. So that's pretty cool. And someone made Biosnarks, which is to do with sharing data in the biotech industry and verifying things as well while keeping sensitive information private. So there's actually a whole list of loads of different projects that people have been building for our ZK Ignite program. We can link you to this kind of list and you can look at that and see what kind of things people have been doing and how they've been doing it for some inspiration. Next Steps for the Hackathon if you want to build stuff, come and talk to us at the booth.
00:24:46.300 - 00:25:16.810, Speaker A: We'll be there to answer questions and talk to you about your ideas. The docs have all the information there. Obviously that's Docs meterproteocol.com. We have a Zkapps Q A channel on our Discord server which is full of people who are really responsive, knowledgeable and helpful. So if you have questions, technical questions, you can go onto the Discord server. It's discord GG Mina protocol. I think that QR code goes to the Discord as well.
00:25:16.810 - 00:25:57.128, Speaker A: And yes, so you can ask your questions on there. There's also the ETH Global Discord server. We have like mina sponsor or sponsor mina channel. And so you can go on there as well and ask questions about things you're trying to do, or book a slot to come and meet someone at the booth or something. And also you can DM me on Twitter blockchainbeard. That's really just something that I put in there to try and get more people to follow me. So thank you for listening and if you have any questions we have about five minutes, do we? No, I've got a timer though, so five minutes? Yes.
00:25:57.128 - 00:26:50.360, Speaker A: Five minutes? No. So you can verify the proof off chain. But if you want to change the state of things on chain, then you need to send it to the network. And one of the nodes needs to verify the proof that you've run a ZK app. Any other questions? Yes. So I think I will answer that question by saying you should come to speak to us afterwards, because we have to finish. But we can talk to you more about how to think about recursion and how you write the code for it.
00:26:50.360 - 00:26:55.700, Speaker A: And if anyone else is interested, come and speak to us as well or see us at the booth. Thank you very much, everyone.
