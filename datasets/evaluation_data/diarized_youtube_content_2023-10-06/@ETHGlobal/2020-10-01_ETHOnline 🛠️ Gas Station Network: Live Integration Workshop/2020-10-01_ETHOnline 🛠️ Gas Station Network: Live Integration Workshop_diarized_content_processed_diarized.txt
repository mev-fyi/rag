00:00:00.170 - 00:01:00.682, Speaker A: Command to start JSN. So JSN is a combination of it is a network of relays and a smart account that coordinates this relays so it shows which relays are currently active and which are not. And this way, clients can find the relay they need interactively and in a decentralized manner. Okay, so after we add this, now we need to actually add support for GSN to our smart contract. So now this is surprisingly easy. So first you add base really recipient, and you inherit from it. And now you need to only implement one method.
00:01:00.682 - 00:02:13.474, Speaker A: It can be a constructor, but we don't do it as a constructor in this demo. So, yeah, so you add set trusted forwarder. And let me talk a little bit about forwarder here. This takes a little bit of history, but your contract will have to trust our system to provide information about who the real sender of the transaction is. And in order to make the impact on this integration on your security smaller, we separate the code that does a signature verification to be an individual contract. So by integrating with JSN, you don't put any trust on any of the JSN contracts. You only trust a single contract that is very small, and it will be strictly audited by everybody that is called forwarder.
00:02:13.474 - 00:03:08.040, Speaker A: And this is the contract that protects your contract. Now you do the last and the most critical thing for your contact everywhere where you use message sender, you replace it with a method MSG underscore MSG sender from base relay recipient. So I hope it's clear so far what we did here. So this method will behind the extract the actual sender. And users don't really create a transaction. They sign message for relay servers to broadcast and relay servers create an actual transaction. Now, of course, this magic happened.
00:04:08.930 - 00:04:42.656, Speaker B: Hey, I think we're going to have to take a moment here and see if we can get him back on. Just stand by. Sorry about that, everyone. Hey, we lost you there a little bit. Alexander, are you able to reshare your screen and then rejoin?
00:04:42.688 - 00:04:50.710, Speaker A: We should be good. I think the zoom just crashed for me. Do you see my screen again?
00:04:51.080 - 00:04:51.540, Speaker B: Yes.
00:04:51.610 - 00:04:54.490, Speaker A: Perfect. Yeah. When did you lose me?
00:04:55.500 - 00:04:57.624, Speaker B: We lost you about two minutes ago.
00:04:57.822 - 00:05:07.470, Speaker A: Two minutes ago? Wow. Okay, I've been talking with myself for some time here. Where was I two minutes ago?
00:05:13.560 - 00:05:15.430, Speaker B: It's hard to say exactly.
00:05:16.200 - 00:06:29.370, Speaker A: All right, so I've been through capture the flag, I've been through replacing message sender with underscore message sender. Okay? And I have been to deploying with truffle migratory get into message sender. I didn't all right, I've been talking a long time. Okay, so I will start again on the capture the flag thing. So we need to inherit from base relay recipient, and it has to implement a method that is called set trusted forwarder. Because as I have been talking probably to myself, in order to minimize security impact of your integration with GSN, we created a very small contract that checks the user signature and tells your contract who the real sender of. The transaction was because we separate sending the transaction on chain and signing a message.
00:06:29.370 - 00:07:08.722, Speaker A: So users end up signing messages for relays, and relays create transactions. So this is why you need to replace underscore like message sender, which is a solidity construct with underscore message sender, which is a method defined in base review recipient. So this is what you do, and now you need to deploy and configure it. So forwarder will be deployed by our command. Line. But you still need to set trusted forwarder on your contract. So these are the steps that you need to integrate.
00:07:08.722 - 00:08:03.746, Speaker A: You need to replace all places where you do message sender with our underscore. Message sender. And you need to set the trusted forwarder address, which will probably be the same address across all networks, and it will be audited by anybody who wants to audit it. And it will be a piece of shared infrastructure we have. An ERC 27 70 describing it, but it's very simple. Next thing your client code needs to know how to interact with relay networks. So you need to replace your Web Three provider that you are probably using in your dev with the one that we provide as part of our library.
00:08:03.746 - 00:08:39.890, Speaker A: So I will bring the import here. So you need relay provider and you may need this method. This is auxiliary method. Resolve configuration and you will want to learn the paymaster address from deployment that our command line does. And after that you have a similar structure where you create a Webster Provider at some place. You replace it with wrapped JSN provider. It wraps an external provider and it turns to our relays.
00:08:39.890 - 00:08:46.600, Speaker A: Am I still online? Can you still hear me?
00:08:48.170 - 00:08:48.920, Speaker B: Yes.
00:08:49.290 - 00:09:18.720, Speaker A: Okay, great. Yeah, I will check that every once in a while. Okay. And I think at this point we should be good to go. Let's see how it goes. And so what has to be done is we should start ganache. We now do the new command, which is Yarn GSN start.
00:09:18.720 - 00:09:58.520, Speaker A: So this command should bring up a relay server. Okay. And let me just to make sure clean. I shouldn't do it right now. Okay, let's put starts right now. Okay, let's hope for some luck here. No luck here.
00:09:58.520 - 00:10:04.454, Speaker A: Weird demo effect as I was expecting.
00:10:04.502 - 00:10:05.660, Speaker B: Let's try again.
00:10:17.710 - 00:10:24.170, Speaker A: See if I did everything correct. I make mistakes.
00:10:25.470 - 00:10:26.220, Speaker B: It.
00:11:06.200 - 00:11:44.140, Speaker A: Think it's better. Okay, it is better. Now let's head to localhost 500,000 and we go MetaMask a little bit. All right. So now I switch to account. It does not have any Ether. And let's see that we can capture the flag now using JSN.
00:11:44.140 - 00:12:20.808, Speaker A: So we see a pop up looks different because we are not creating a transaction. We are not paying fees, we are not sending Ether. We are just signing on this message. And each field here describes something very relevant to our system. But I won't go over them right now. We like everything and we sign and we see that in a few seconds the flag was captured. So we just interacted with on chain smart contract from an account that doesn't hold any ether.
00:12:20.808 - 00:13:35.312, Speaker A: So we believe this is a very powerful point where users who only have keys can start interacting with blockchain immediately. Okay, so at this point we transition to step two of our workshop where gas does not come for free unless you're working on Ganache, on local testnet or any actual testnet. So on testnets we will be deploying contracts that are called Paymasters that are responsible for paying for users transactions and these contracts will be across all testnets. But this is not a solution probably for your DAP because you cannot pay for everybody because your funds will be drained by somebody who wants to maybe DDoS you or is able to steal those funds. So you need to have a firewall, right? So you can decide who gets and who doesn't get transactions for free. And you can implement arbitrary logic there. But the example we are shown here is the simplest we could come up with whitelist.
00:13:35.312 - 00:14:43.822, Speaker A: So you just create a list of contracts who can interact and then they can interact and the rest of them cannot. So in order to add support for that, you can write your own custom Paymaster. We are providing a library of Paymasters ourselves. So in order to add them, you can run again, yarn, add openjsn paymasters and again it's going to take time. So I will pretend that I did it here and I head back to my repo and I just paste it here. Now, next thing is again specific to our current state, we are using Truffle. So normally you would probably not need to do it, but Truffle does not compile contracts that are not directly imported by your project.
00:14:43.822 - 00:15:26.410, Speaker A: So this is just a technical step that we need to import anywhere in our project. The whitelist Paymaster from our repo. This is a Paymaster we'll be deploying and using. Now this Paymaster has a bit more configuration to it. So I will paste this code here. So this is a new part if you are wondering. So we deploy a Paymaster now and we also need to set relay hub address on it and we add a sender who is whitelisted.
00:15:26.410 - 00:15:56.200, Speaker A: So let me paste my address here for a change. Okay, so account two will be whitelisted. Let's do it this way. So this account will be whitelisted. Any other account will not be able to get free transaction. All right, so also our UI now are you with me? Am I online?
00:15:57.930 - 00:15:59.318, Speaker C: Yep, you're all good.
00:15:59.484 - 00:16:56.300, Speaker A: Okay, great. Needs to know the address of this Paymaster as well. So we will be using it. So we just change which Paymaster we are using and we tell our configuration that we are now using a different Paymaster. This should be all you need in order to add support for a custom Paymaster. Let me stop everything and start from a clean state. Okay, so we restart Ganesh, restart JSN and start serving our web page.
00:16:56.300 - 00:18:15.404, Speaker A: And few moments later yeah, we are good to go. Let me again wiggle it around so it doesn't get something cached or whatever. It all right. I am having problems with something I don't even know. All right, I made a horrible mistake here. Shouldn't have removed this line. Sorry for wasting your time.
00:18:15.404 - 00:19:42.700, Speaker A: Interactive copy pasting is a difficult topic. Starting from scratch again, Ganache. It's should work. Okay. And let's see. I will first try to use account that I did not whitelist and I will click the button and hold on a second. Yeah, drawer, could you remind me what was this issue?
00:19:45.230 - 00:19:51.738, Speaker D: I didn't look at the code. Did you resolve? Did you ever set forward the paymaster?
00:19:51.834 - 00:20:14.040, Speaker A: Yeah, I lost some changes. Set, trusted forwarder, righteous. It.
00:20:38.290 - 00:20:39.040, Speaker B: It.
00:21:03.920 - 00:21:47.540, Speaker A: Also, if you're following, you can try all of it. In the report that we are showing right now, there are two pull requests. So these pull requests show you the actual changes that need to be done in case you missed something or I skipped something over when I was offline. Let's see now okay, now it seems to work and I do have the pop up from JSN that asked me to sign for a transaction. But once I sign it, I get the error message directly from my Paymaster that says Sender, not whitelisted. Because I did not whitelist this sender. I did whitelist a different account of mine.
00:21:47.540 - 00:22:40.810, Speaker A: So I should be able to switch to the second account. And this is the one that I did add to whitelist manually. And just for certain, let me refresh and in this case, I really should be able to interact with, blockchain and capture the flag. So with a few hiccups, we showed the process of integrating GSN with Paymaster that allows everything and then Paymaster that allows you to be in control of who gets free transactions and who doesn't. So please give it a try. You can ask us any questions at any time. And let's see.
00:22:45.500 - 00:22:46.250, Speaker B: It.
00:22:47.740 - 00:23:02.848, Speaker A: Any questions? Am I online? Yes.
00:23:02.934 - 00:23:12.230, Speaker C: I see one question from someone named Light client. If you were to estimate how much of GSN is on chain code versus relayer work, what would you say?
00:23:14.200 - 00:24:28.456, Speaker A: All right, in terms of what is the measure, how much of GSN is on chain code? Okay, so on chain code is a big part of it, but we try to keep it simple and small. So the on chain code is responsible for relay registration, handling, stakes and penalization, which also gets you some code. And relayer is like relayers can grow. Relay Hub is our core contract and I don't expect it to grow. And relays can get additional functions that will make it bigger and maybe more useful, more resilient. And the on chain component I think should remain the kernel of the system and I think it's maybe few hundred lines of solidity code for Relay Hub core. I'm curious to know what it would mean for JSON.
00:24:28.456 - 00:25:22.130, Speaker A: Metro transactions became available at level One. Okay, transactions are available at level one of Ethereum mainnet. How viable are they? They are somewhat viable for some use cases. In other use cases they do have extra cost because you go through a number of contracts that enable the system. Of course you acquire a user. You wouldn't acquire any other way because you probably would lose a person if you send them to an exchange saying buy some Ether and come back to my app. But if you need users to make hundreds of transactions, it depends on your cost of.
00:25:24.020 - 00:25:26.050, Speaker D: Alex, may I press on that?
00:25:26.900 - 00:25:27.650, Speaker A: What.
00:25:31.300 - 00:26:05.052, Speaker D: But the question is whether GSN should it be in the layer? If I understand correctly, should it be available at layer L One feature? And maybe it should, maybe it shouldn't, but it will surely take time. GSN is here to add a feature that will take a long time for network like Ethereum to add. It also add a new business model in the market for paymasters and for relayers. It's not something that is so easy.
00:26:05.106 - 00:26:10.030, Speaker A: To add to layer One network on a protocol level. Yeah.
00:26:14.800 - 00:27:45.470, Speaker B: Can can am I being heard? Yes. I will say that we're actually hoping to see protocol level changes that support meta transactions. It will reduce overhead and make things a bit easier on multiple fronts potentially. But yeah, we're currently just doing the best that we have with the current tools of contenders and we are looking forward to seeing changes that will make things a little bit more efficient. It's just that we didn't start out by trying to change the layer one protocol, because that has been very hard historically and it's sometimes easier to get traction on that once you can sort of prove that you have the right way to get things to work and all the pieces come together. And yeah, that's kind of it in a nutshell. It's a little bit speculative because it depends on exactly what type of protocol changes eventually make it into layer one.
00:27:45.470 - 00:27:59.570, Speaker B: But this is something that we're hoping will happen sooner rather than later. Yeah, we'll see.
00:28:07.880 - 00:28:11.540, Speaker C: There's a couple more questions from Light client in the chat.
00:28:12.440 - 00:28:47.010, Speaker E: I think it's probably easier if I just go for voice. Thanks for unmuting me. Yeah, I think that you guys have done the right thing. I think that a lot of teams face a similar problem. People want a solution today and they don't want to wait for a network upgrade that solution to be available and so they work with what they have. But GSN is probably the most robust relayer system that we have so far. And so I think it's really important to know from you guys what it would mean to have metatransactions implemented at the layer one.
00:28:47.010 - 00:29:13.560, Speaker E: What do you need available in these sorts of transactions for it to be beneficial because it's useless if we implement to layer one without being able to ask the people who are going to be using it and make sure it's the right thing. And maybe that's not something that you have the answer for on this call. It might be something maybe we should chat again at another point after you have time to review the EP. But I would be curious if you have any off the cuff thoughts.
00:29:14.380 - 00:30:44.950, Speaker B: Yeah, so my off the cuff thought is that Devil is really in the details and in general we are very supportive and we would like to see this happen as soon as possible. We do see GSN as a prototype for an extension of the ethereum stack, but getting consensus towards that is a big part of why we are working on GSN. Maybe it's easier once you have more use cases that need it and it's kind of easier to get to that to bootstrap that using something like slightly less efficient implementation that does not require a protocol level changes and then okay, this is useful now, but let's make it more efficient. So let's see what is the best way to add it to layer one. And the right place to have discussion is probably just set up a group and discuss it and maybe put together a proposal and get as much feedback as possible from different stakeholders. This is what we tried doing for the previous EIP. We tried getting as many people involved and this is sort of the metatransaction recipient standard and it wasn't easy, it was a lot harder than we expected just to get everybody to agree on that, what that should look like.
00:30:44.950 - 00:30:51.850, Speaker B: But hopefully we learned a little bit about the process and you can do it more efficiently next time around.
00:30:54.860 - 00:31:37.050, Speaker D: I see another question by Derek. Yes. Can it be attacked? Yes, it can be attacked. We did a lot of work to try to minimize the impact of such attacks. GSN in a way is a system where there are relayers, there are paymasters and there are recipient contracts and clients and we try to build a system where neither trust anyone else. You trust code so you have a minimal forwarder code to trust. To a lesser extent the relay hub itself to trust, but otherwise most components don't trust each other.
00:31:37.050 - 00:31:50.430, Speaker D: There is EAP 1613 which is a bit out of date, but it covers most of the possible attacks and how we mitigate them.
00:31:54.160 - 00:32:54.320, Speaker B: Specifically to add to that, because he's asking about also denial of service. It really depends on what you mean by a denial of service attack. Different scenarios have different defenses. The ones that are hardest to mitigate are various gas greasing vectors that we put a lot of work into. It's impossible to get the exposure to zero, but it is possible to do a lot better than a naive implementation. So the goal is to have a meta transaction system where the Asymmetries are tilted in the favor of the defense and not the attackers. And time will tell if we have the right balance, but we think we can make the system as robust as it needs to be for use in the wild.
00:32:59.610 - 00:33:42.660, Speaker A: There is a question about ways to batch many metatransactions on layer one. So we did start to work on a concept where you can batch multiple transactions. It did not involve BLS or Schnor signatures, but I think this is one of the things that can be added on top of JSN as part of a dedicated forwarder that can later be used by DApps that want to support Batching meta transactions, which seems to be a popular approach this time.
00:33:48.550 - 00:34:56.460, Speaker B: It I will add to that that we were initially looking into including Batching as a core feature of the forwarder and we ended up realizing that it made a little bit more sense to keep the forwarder as a minimum viable implementation with the understanding that it would be possible to inherit from the forwarder and implement Batching elsewhere. And then this is not necessarily going to be the only trusted forwarder, but we did up trying to keep the forwarder really so simple that you can just read over it and understand how it works and not have to think about things like the implications of batching. But we do agree that will be very useful for some use cases and it's also something that we designed the GSM to support.
00:34:59.410 - 00:36:03.422, Speaker A: So another question from Michael. Does a Gas Master relayer handle fee bumping for stack transactions, is there not? Yes, relayer server handles bumping the fee for transaction. It sends both management transactions that are not requested by client and the relay transactions with a node that if client signed on a gas price, this is a gas price the paymaster will pay the relayer. So at this point, if relayer needs to pay more for gas to get its nons unstuck, relayer can be at loss on this transaction dollars. So relayers have a way to indicate the minimum gas price they are willing to accept. So this should not happen often. It may probably happen only in a huge and long gas price spikes.
00:36:03.566 - 00:37:14.518, Speaker B: If this happens, I will add to that that because the different components are designed not to trust each other, then painmasters don't necessarily have to trust relay servers, even though that could make things a little bit more efficient. But it would also change or weaken some of the security assumptions that we're making. So this is why we're not just letting relay servers bump up the transaction fee that paymasters are liable for because ultimately the paymasters, they're the one paying for the transactions or they're the ones committing to paying for the transactions. And the relay hub contract in the middle enforces that. But relay servers, they don't want to have to trust the paymasters. So the paymaster says in advance, okay, this is what I'm willing to pay. The relay server is assumed to accept that in advance.
00:37:14.518 - 00:38:54.038, Speaker B: This is something that they can perform the transaction with and if not, not service the transaction. And if they decide to accept this transaction, then they've done that because it's a good deal for them. Like Alex said, it would only maybe break if something has changed very dramatically since they evaluated the profitability of the transaction and when they actually executed, in which case they can unstick themselves. But another mitigation that we've implemented is multi worker support for relays, which means unlike in GSN one where every relay just had one worker address, and that meant that if any transaction got stuck on there, the relay server was stuck indefinitely. With multi worker support, you have multiple addresses tied to a single stake and then that is also useful for preventing relay servers from getting stuck because of gas spike changes. It was one of the things that was really important for us to figure out when the network became a lot more congested has happened recently. And this would also really help for where we expect most of GSN usage to end up, which is on layer twos, where the scaling requirements and the transaction throughput does actually require multi worker support for relays.
00:38:54.038 - 00:39:21.810, Speaker B: So hopefully we've gotten the right balance. So Alex, do you want to show, are we planning on showing anything else or asking people if they have questions regarding integrations that they're considering?
00:39:23.350 - 00:39:49.680, Speaker A: Yeah, I would love to hear from people if they are considering or tried or failed to integrate with JSN and their concerns and address their issues. If you have something you want to show, that's also great. So did anybody try to integrate with JSN or a similar service already?
00:39:59.490 - 00:40:23.640, Speaker B: Alex everybody is on mute, so it'll be hard for them to respond. They might be able to send a message on the chat, but they're also not allowed to actually start working on their projects until Friday. Nobody's going to admit starting before Friday. That's a violation of the rules. They're doing it. They have to keep it a secret. Can't catch them.
00:40:23.640 - 00:40:58.290, Speaker B: So if we don't have anything else, we could just do sort of a brief we could just do a brief overview of how the GSN architecture works so people, when they get started, they have a ballpark idea of what the GSN looks like. In which case, if that makes sense, there's nothing else. I can share my screen and just go over the architecture diagram.
00:40:59.270 - 00:41:00.980, Speaker A: Yeah, that makes sense.
00:41:01.990 - 00:41:17.938, Speaker B: Okay, let's do it. Okay, great. So can you see my screen? Alex?
00:41:18.114 - 00:41:19.980, Speaker A: Yes, I can see your screen.
00:41:21.150 - 00:42:39.010, Speaker B: So this is the architecture for the new GSN two system that was deployed very recently to Mainet and various testnets including Rinkabee and Robston. And essentially we're showing what a transaction looks like when it goes through GSN at different levels. So at the highest level, you have a client that doesn't necessarily have any to pay for gas, but it's a gasless client and it's interacting with recipient contract. So to make this magic work, the client essentially needs to create this metatransaction. A metatransaction is a transaction that someone else pays for and the client it needs to find a relay server. This is a third party that it will provide the transaction to and then the relay server agrees to pay for the graph by wrapping up the client's transaction in a metatransaction. This is a transaction inside a transaction.
00:42:39.010 - 00:43:54.380, Speaker B: That's kind of the trick the metatransactions are based on. And what the GSN does is it helps facilitate this process. So by default, there is going to be a preferred workflow where DApps, they set up their own relay servers and their relay servers provide service for their DAP contracts without any charges. But we don't stop there because then that would be a little bit centralized. And if your relay server goes down, then your front end goes down. So we've implemented a one for all and all for one type scheme where essentially every DApps relay servers also registers into a registry of relay servers where it agrees to service the users of other DApps in exchange for a transaction fee that is configurable. And then what that means is that now taking down the front end of any DAP is as hard as taking down all the DApps that are using the system.
00:43:54.380 - 00:45:28.202, Speaker B: So we've kind of aggregated the availability guarantees that the system provides, but without complicating how much you need to understand upfront, because you don't need to understand how your client would look up relay server from the decentralized registry as long as your relay server is still working. And you also would need to understand what the transaction fee is going to end up because you won't pay your own relay servers a transaction fee or rather your paymaster. So we find a relay server, whether it's our relay server or a fallback from the registry, and we pass the transaction and as part of the transaction we say, okay, here's the paymaster contract that is willing to pay for the transaction. And what the relay server does is it then executes the transaction off chain to see that when the transaction is fully executed, it was reimbursed for the transaction and it did get either rebalanced. So every relay server has an external account or external accounts from which it's paying the immediate gas fees for transactions that it relays and it needs to get that back. So the paymaster contract provides refunds, reimburses the relay server for those fees. So to make sure that happens.
00:45:28.202 - 00:46:13.670, Speaker B: And we don't want relay servers to have to know about and trust paymaster contracts. Then part of the functionality of relay server is just executing the transaction off chain, which is very similar to how you would execute a view function even though it's not actually a view function. And then once the relay server sees yes, it is going to get reimbursed, this is a good deal for it. Then it actually assigns a transaction, immediately returns it back to the client. The client can also take this. Now it's a valid Ethereum transaction, it can broadcast this transaction itself. So the release servers is also going to do that.
00:46:13.670 - 00:47:33.026, Speaker B: And then once this transaction is mined, it will call into the relay hub. Essentially this transaction calls into the relay hub contract. Everything that was before executed off chain is executed on chain and the final destination before the recipient contract is the trusted forwarder contract, which essentially just the minimal contract that includes the logic for verifying the signature of the client. So that's the only thing you're really trusting when you're depending on the trusted forwarder is that it checks the signature, it parses the transaction and checks the signature from the client correctly. And then if the signature works out, then you can get the message sender from the message sender function and not the message sender member. That's the only thing as a recipient that you need to be concerned about. The relay hub does provide guarantees for other participants of the system.
00:47:33.026 - 00:48:23.250, Speaker B: The relay servers, they trust the relay hub instead of having to trust the painmasters Baymasters, trust the relay hub instead of trusting the relay servers. And this is sort of optimized to create the most centralized system. So some apps they won't be able it doesn't make sense for them to run any infrastructure. An example is betting market that is considered illegal in certain jurisdictions. They just developed the app and they completely rely on other people to run the infrastructure like relay servers. So in that case their Paymasters, even if they decide to subsidize users cannot assume that the relay servers are good. Relay servers could be part of an attack and the same for relay servers.
00:48:23.250 - 00:49:08.666, Speaker B: Anyone can. It's a permissionless system, it's designed to be permissionless from the bottom up, but still be as simple as possible and minimize security risks as much as possible. So essentially we took a long look at all the things that slowed down adoption for GSN. One, a lot of that was the complexity of the system, that it was monolithic, that recipient contracts had to include a lot of logic and they had to subsidize the transactions or that was part of the assumption. And because we've broken that apart, who pays for the transaction is separate from who receives the transaction. We can have things like token paymasters and token paymasters, they don't subsidize the transaction. If you have an ERC.
00:49:08.666 - 00:50:38.490, Speaker B: 20 token that can be exchanged on uniswap. For east, a paymaster could make its acceptance of the transaction conditional, and you paying it agreeing to pay the paymaster in tokens. So with an arrangement like that, essentially now any DAP can plug into a token paymaster, and a token paymaster lets all the gas fees be paid in whatever token the user has. So now, if you have Dai, for example, you can just do everything in Dai, and this also opens up other interesting possibilities. So, for example, one of the things we're really excited about is you have privacy use cases where if you want to withdraw from a privacy from a mixer like tornado cash, you would usually need east to do that because otherwise how would you interact with a contract? And in this case, you can sort of commit to paying for the transaction for the withdrawal from part of the withdrawal amount. Hopefully, this opens up a range of possibilities, and we do expect most of the usage to end up on layer twos, because that's where we expect most of DApps to eventually live for gas fee reasons. But this will be something that you can use on layer one for any purpose.
00:50:38.490 - 00:51:33.100, Speaker B: All right, let me just close unshare my screen or ask if there are any questions. Maybe before I unshare my screen, I can just let me see if there are any questions. Are there any questions regarding the architecture or the system or something? Was not clear. Can explain it better maybe? Oh, okay. Hmm. I think my case maybe we're done.
00:51:40.430 - 00:51:50.130, Speaker C: Thank you so much much, you guys. This is a great workshop. Really excited to see what you guys have done and hackers what you all will build using GSN.
00:51:51.350 - 00:51:52.530, Speaker B: Thank you, Heather.
00:51:53.350 - 00:51:55.540, Speaker A: Thank you. Thank you very much.
00:51:56.310 - 00:51:58.030, Speaker B: Thanks, guys. Bye.
