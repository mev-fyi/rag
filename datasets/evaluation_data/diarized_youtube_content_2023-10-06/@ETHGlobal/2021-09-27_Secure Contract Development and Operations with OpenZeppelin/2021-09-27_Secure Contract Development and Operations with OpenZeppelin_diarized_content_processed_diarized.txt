00:00:00.250 - 00:00:02.766, Speaker A: People are piling in. So I'm just admitting everybody.
00:00:02.948 - 00:00:03.742, Speaker B: Welcome, everyone.
00:00:03.796 - 00:00:41.100, Speaker A: We're here at the ETH Global Hackathon, and we have Santiago Palladino from Open Zeppelin. He's going to give a talk on secure contract development and operations. And it's a half hour talk. There be opportunities to ask questions in the chat. There could be a pause in the middle of the presentation to maybe field some questions and then maybe some questions at the end. So feel free to just put them into the zoom chat here. And with that, I will hand it off to Santiago and we can start.
00:00:42.030 - 00:01:07.306, Speaker B: Awesome. Thank you so much, Andrew. Can you confirm me if you can see my screen just in case? Thank you so much. Okay, welcome, everybody. Sandra was saying, my name is Andyo Palladino. I work at Opensupplyn, and today we'll be doing an overview of secure development of operations at the end. Okay, so a couple words about Opens Uplin.
00:01:07.306 - 00:01:54.340, Speaker B: First. Opens Uplin is a security company focused on the blockchain space. We have worked with some of the top projects in the space, and our offering is we provide audit services for smart contracts and protocols. But we also provide an open source and free to use smart contract library, which we'll be reviewing during this talk. And we also built Defender, which is a platform for automation and secure development of contracts. So today we'll be focusing on both contracts and Defender for development and operations. And we'll be doing a very brief overview of the two and showing how you can quickly build some interesting applications combining the two of them.
00:01:54.340 - 00:02:31.866, Speaker B: So that this is not just a token be using. We'll be focusing on this case study. What we'll be doing is whenever a user purchases a particular token on Unisop, just to pick a Vex, we'll be minting an NFT for them, a collectible. So think of it as a way of rewarding users for buying a particular ERC 20. What we'll be doing is we'll be monitoring all activity on A decks. Whenever there is a purchase, we'll mint a collatable token in response to that. And for doing this, we'll be combining both Opens Uplink Contracts and Defender.
00:02:31.866 - 00:03:18.102, Speaker B: And this is just a case study so we can pick one example for guiding all the different components that we'll be viewing today. Okay, so this is more or less what our system will look like for what we want to build today. We'll be keeping an eye on the Uni subcontract that trades Uni and Deep. We'll be using Uni as the YearC 20 that we want to monitor. We'll be looking at all swap events, and in response to that, we'll prepare a transaction that will mint an NFT instance for the original buyer. So let's start with the NFT part. Let's start with actually building the collectible contract.
00:03:18.102 - 00:04:15.866, Speaker B: And for that, we'll be using opens up contracts. Contracts is a set of secure building blocks for solidity and it can be a little bit daunting in terms of how much it has. We have been building Opens Uppling contracts for over five years now and there are really a lot of contracts available for you to pick from. So to try to give a brief overview of what you can find here you can find implementations of the most common token standards. You can use Access Control primitives such as Ownable or Role based Access Control or time locks for additional security which we'll be using Access Control in a minute. We also have support for different proxy flavors. So you can build upgradability into your system, which can be particularly useful in the context of a hackathon, where you need to be modifying your code and updating on a very, very frequent basis.
00:04:15.866 - 00:05:15.358, Speaker B: We also have support for metatransactions, some utilities, for managing signatures, for interface checking, some security building blocks such as emergency poles or reentrancy guards. And we recently added support for Onchain governance. So you can have a contract where your users who hold a particular ERC 20 can vote on whether a particular proposal should be executed or not. In order to make it easy to get started with Opens Up Link contracts, you can use the Opens Uplink Wizard, which is what we're going to do today in order to set up the NFT. So if you just head on to Wizard Opensuppling.com, you'll have an easy to use UI where you can choose between different base contracts such as ERC 20 Cent 21 or 1155, or a Governance contract in case you want to build some sort of on chain voting for your system. For today, we'll just focus on ERC, Send 21.
00:05:15.358 - 00:06:09.790, Speaker B: And the idea is that you can use the wizard to tune fine tune how you want your collectible to work. So for instance, this could be a Defender demo token or let's actually go with it online and you can inject any kind of features you want. For instance, I want my NFT to be mintable and I want the contract itself to manage the IDs so I don't have to worry about that outside the contract. You can also inject emergency Pause, for instance, and you can choose how you want to manage access control. By default, contracts use Ownable, which means that there is a single address that has full control over all privileged, overall privileged actions on the contract. So there is a single address that can choose to Pause or to Mint or when we turn on Upgradability to upgrade the contract. But you can also go with Roles.
00:06:09.790 - 00:07:00.050, Speaker B: That gives you different roles within the contract so you can finally control which addresses have rights to the wallet. So, for example, we'll want to give the Minter role to a hot wallet that we're going to set up for Minting new instances, but we'll want to keep the poster role more tightly controlled. Same goes for upgradability. We'll turn on Upgradability for our contract. So this means that a new upgraded role will get injected and this will be the address set of addresses that have the right to upgrade this contract onto a different implementation. So if you see the contract hold has grown a little bit, but the idea is that you can use this to get started. And this is a fully functioning ERC Send 21 with all the features that we have selected.
00:07:00.050 - 00:07:54.558, Speaker B: Curious that once you are ready to use this, you can either open this on Remix to start working or just copy this to your clipboard and download it into a hardhat or traffic project and start working right away. Now, given that we have selected this contract to be upgradable, it means that we need to deploy it in a certain way. So in order to manage upgradable contracts, we have a set of plugins here we'll be showing just the hardcut one, but there are also Truffle plugins if you prefer. And these plugins give you primitives for both deploying and upgrading Ammidable contracts. So in the case of Hardhat, it's super straightforward. Same goes for Truffle. If you're using Etherjs, the only thing you need to do is get an instance of the Contract Factory, the contract you want to deploy, and just use the Deploy proxy action.
00:07:54.558 - 00:08:58.114, Speaker B: Point to that factory and the plugin will take care of setting everything up for you. Everything means creating an implementation contract and a proxy contract that points to it. And then whenever you need to make a change on the code, you just get the contract factory for the new implementation you want to work with and run an upgrade proxy action using the address of the proxy you had previously deployed. And here again the plan will take care of running all necessary validations, deploying a new implementation contract and updating the proxy to point to the new code. So you can rely on this Upgrade Proxy primitive to keep updating the code of your contract as often as you need while you're developing. And this retains the same address and the same date and balance of the original contract. So again, this allows you to move faster when you're deploying a system also in a long term deployment, it also lets you to fix bugs or add new features iteratively so to wrap up how a development setup may look like, you can just install open Sepling contracts.
00:08:58.114 - 00:09:50.390, Speaker B: Remember to install contracts upgradable if you're going to use Upgradable contracts. This have a slight difference with the vanilla ones so they can be used in upgradability. You can head on to Wizard Opensoft.com to create the contract that you want to start with or set of contracts such as Tokens or Governance contracts, then download the code generated by the wizard in Hard, Hat or Trafu project. And using the Upgrade plugins you can deploy your contracts in an upgradable way using the Deploy Proxy primitive and then using the upgrade to the upgrade command to go to upgrade your contracts to the new versions. So before we jump into operations, let me check if we have any questions so far. If we can elaborate a bit on the permit function and vulnerabilities when using EC recover.
00:09:50.390 - 00:10:13.422, Speaker B: That's a very interesting question. Let's park it for the end. It may take a little bit longer than I would like to do. Deep dive on that one. If we don't have time, head over to the forum from Opensupplane.com and we can carry on the discussion there. And I'm not seeing if we have anything on the Q A.
00:10:13.422 - 00:10:16.340, Speaker B: Andrew, I don't think we have any questions. Right?
00:10:16.710 - 00:10:19.202, Speaker A: No, I think that's it for the moment.
00:10:19.336 - 00:10:22.914, Speaker B: Perfect. Do we know if there are any questions on the YouTube channel, by the way?
00:10:23.112 - 00:10:26.994, Speaker A: No, it's not open for questions.
00:10:27.192 - 00:11:05.454, Speaker B: Perfect. Everything here makes sense. Can you also elaborate a bit more on Upgradable proxies? Yes, absolutely. So when you are setting up your contract on the wizard, you can choose between two different upgradability patterns, transparent and UUPs. UUPs is the one that we have developed more recently. It's a little bit more lightweight and it also gives you greater flexibility when it turns on deciding who has rights to upgrade your contract. So you'll see that on the UUPs pattern there is an upgrade role that you can basically assign any number of addresses to that role and they will have the right to decide how they want to upgrade.
00:11:05.454 - 00:12:16.520, Speaker B: And you also have an authorized upgrade function that you can override and inject whatever logic you want to decide under which conditions an upgrade can go through. If you go with Transparent, the availability logic is not in the implementation contract that you write, but it's hard coded on the Proxy, and there is a single address that's the Proxy admin that has the right to actually run an upgrade. So Transparent gives you less flexibility in terms of deciding who and how can upgrade that's all hard coded on the Proxy itself. We also have another pattern that's not supported on the planes, which is the beacon pattern, which is particularly useful if you want to upgrade multiple instances of the same contract at the same time on a single transaction. Still, if you want to learn more about upgradability, I suggest you go to Docs Opensuppling.com. There is a section specifically dedicated to upgrades where you can get an overview of what plugins are available, what are the differences between the different Proxy patterns and general information on availability. Okay, moving on.
00:12:16.520 - 00:13:11.350, Speaker B: Now that we have our NFT contract ready and deployed yes, I have deployed an instance before the talk. In the interest of time, we can move on to the operations part, and for that we're going to use Defender. Defender is a platform for secure operations automation of smart contracts. And we'll be relying on this for all the automation that's related to Minting new instances of our NFT contract, monitoring the existing, monitoring the uniswap pool, and basically wiring everything together. So what we're going to do is we'll start by creating a secure hot wallet that we'll be using as a Minter. Basically a wallet that will automate and will have rights for creating new instances. We're going to assign the Minter role to this new wallet and then we'll write a small script for actually running the Minting transactions.
00:13:11.350 - 00:14:00.746, Speaker B: And finally we're going to add sentiment monitor on the uniswap that will keep an eye on all trades that are of interest to us and will trigger the Minting operation. So let's jump into Defender and get started. So we'll begin by creating the hot wallet that will have the Minter rights. And that in. Defender is called a relayer in the sense that it relays transactions that you request onto the blockchain. So this is going to be an inonline Minter and we're going to run this on the ring by network. By the way, we support a bunch of different layer ones and layer two support for Arbitram is coming up pretty soon.
00:14:00.746 - 00:14:45.560, Speaker B: So if we want to develop another chain besides strictly theorem, you can also do that using this tool. So under the hooder relayer is just a private key that's assigned to you. You can use this for sending any transactions to the network. The idea is that if you need to set up a custom script that will send transactions on a recurring basis, you don't need to hard code your private key on your server or in your script. You can keep that within Defender and Defender will derive an Ethereum address for you so you can send transactions through it. You also get an API key and secret that you can use for authentication whenever you want to send transactions from any of your scripts. And you can rotate these API keys and secrets as much as you need.
00:14:45.560 - 00:15:54.346, Speaker B: And the thing is that besides just keeping your private key secure, the relayer will also take care of resubmission of any transactions and deciding the best gas price for when you're sending your transaction. The idea is that you can send a transaction using the Defender relay client package if you're using JavaScript and sending transactions pretty straightforward. The idea is that you just choose a speed that you want to attach to your transaction and the relayer will take your figure of attaching a nons, signing the transaction, choosing the gas price and broadcasting it, also resubmitting it to make sure it gets mine. The idea is that you can use the relayer just to say, hey, want this transaction sent and the relayer takes care of the rest. So we have this address that is the ETH online Minter that we'll be using for sending transactions that will take care of Minting our NFT. But in order to do that, we need to give Mint a right on our contract to this new address. So we'll jump onto Admin, which is an interface for managing contracts.
00:15:54.346 - 00:16:41.146, Speaker B: The idea is that whenever you need to fine tune roles, even upgrade contracts or run any kind of privilege operations, you can use this as a UI for managing your contracts. You can just import any contracts you have and start interacting with them from here. In particular, I have already imported the NFT contract that we'll be working on today. You can create a proposal for different kind of actions that you want to run on the contract. In this case, what we're going to do is we're going to grant the Minter role to the ETH Online Minter we have just created here. I'm going to copy the Minter role from the contract. You can use this to quickly inspect the contract state.
00:16:41.146 - 00:17:41.006, Speaker B: This one I have named finder Demo, not ETH Online, and you can choose how you want to execute this transaction. Given that my current MetaMask address has rights for managing roles, I can just send this transaction from my externally owned account. But you could also do this from a moved SIG or from a governance contract, or even via time lock in case you want to enforce a delay on all actions you execute for the sake of the demo. Usually in the context of a hackathon, you'll be managing everything from top of external account. So that's what we're going to use here. You can just provide some information on the action that you are actually running so that other teammates that jump into this understand what kind of action is happening here and can even review it. Let's say if you run this through a multi SIG, you can have other team members review the action and use that to decide on whether they want to approve it or not.
00:17:41.006 - 00:18:40.782, Speaker B: Here, since I'm the only one with the rights to do it, it's pretty straightforward. But still, you can rely on this as a UI for managing administrative actions on your contract and also for keeping a sort of audit trail on the different actions that you have been running on them. Okay, so now we have a hot wallet every layer that has Minter right on our contract. The next step is to actually automate the Minting process. For that, we're going to use an Autotask. You can think of an autotask as a lambda function, as a script that runs within defender, so you don't have to run your own infrastructure or basically spin up your own servers if you want to do small operations. And the idea is that you can upload any code you want, and you're already on an environment that runs Node JS with a bunch of web three related packages.
00:18:40.782 - 00:19:36.230, Speaker B: So you can just upload the code here and start using it right away. In this case, what I have done is I have a small script that creates a new Ethers contract instance at the address of the NFT I have created, I just call Safe Mint on a recipient address that gets injected. We'll see how the recipient gets injected in a second. And note that I'm just using regular ethersjs code here because I'm using the defender relay client ethers integration. So this gives me access to a signer that will take care of routing everything via defender relayer. That way I just run a script as I would normally do, and this will take care of shipping the transaction via the relayer so I don't have to worry about gas prices nonsense, securing the private key. That's all taken care by the relay.
00:19:36.230 - 00:20:15.570, Speaker B: And I can also configure how this autotask is going to operate. I can run this via public webhook, so you can integrate this with any external systems or even your front end. You could set this on a schedule. So for instance, you could have your script run every ten minutes, every hour, however often you need. You can also connect it to a relayer. So in particular, I'm going to connect this to the Earth online Minter relayer we had just created. And so the idea is that whenever you send a transaction from this script, it will get routed via the relayer automatically.
00:20:15.570 - 00:21:07.534, Speaker B: Let's hit the changes. Okay, so now we have a script that whenever it's executed, it's going to use the online Minter hot wallet that we have created for Minting, a new instance of an NFT to a recipient. The last step is to actually wire everything together by actually monitoring the uniswap pool we're interested in and triggering these actions. And we're going to do that by creating a defender sentinel. Sentinels are monitoring agents that operate on a contract. Could be a contract you own or a contract external to your system, such as this case. And you can define what you want to monitor, what you want to be alerted on, and from that you can choose what do you want to happen as an action.
00:21:07.534 - 00:22:07.110, Speaker B: So for instance, I have already created a sentinel that monitors purchases of uni on rigby. This is monitoring the uniswap uni v two uni pool, and it's restricted to look for swap events. So the idea is that when you create a sentinel, you define which contract you're monitoring on which network, and then you can define conditions on what you want to monitor about that contract. You can monitor every single transaction that goes through it, or you can narrow it down to specific events or specific function codes. So here I'm interested only on swap events where the amount that went in this is the amount of ETH that was used in the purchase is at least 0.1 E. And here you can define any conditions you want on the parameters of event, on the arguments of the function, or even on parameters of the transaction itself.
00:22:07.110 - 00:22:59.874, Speaker B: So for instance, I could look only for transactions where gas price is at least one gigaway you can also use this tool here on the right to enter a specific block and find potential matches for this. So you can more easily debug the conditions on your sentinel. Here is that once you have defined which contract you want to monitor and under which conditions, you can also edit what you want to happen whenever a transaction like this is picked. So what we configure here at Sentient Notifications is an email discord message. We could also configure Telegram, Slack or datadog messages. You can basically add several different channels. And we're also triggering an autotask.
00:22:59.874 - 00:23:56.870, Speaker B: This is the autotask that we had defined a couple of minutes ago, and that takes care of Minting new instances whenever it's invoked. So what we're doing here is we basically have a sentinel that's looking at all swap events from a uniswap pair. It's alerting us via different notification channels, but at the end of the day, it invokes an autotask that calls the relayer that we had set up that will send the Mint transaction to our NFT. And this relayer has rights to actually call this Mint method because we use admin for managing the roles of the NFT and actually calling the and allow the relayer to call the Mint function from it. So let's actually test this, see if everything is actually working together. Working together. This is usually the most stressing part of a presentation.
00:23:56.870 - 00:24:36.590, Speaker B: So let's buy zero point 15 worth of uni. Again, this is all ring buy. Okay, let's confirm the swap and see what happens. So, as soon as this transaction gets mined, what should happen is that the Defender sentinel should pick up the swap event. And once it's processed and it verifies that indeed we have, the buyer has spent at least 0.1 E, which is the condition we had defined, it should send a notification via email and discord, which are the two channels that we had defined. It should also invoke the Autotask.
00:24:36.590 - 00:25:18.500, Speaker B: And the Autotask, in response to that will run whatever code we had defined that will invoke the relayer, and the relayer will send the transaction for Minting an NFT. So you have an automated workflow here that whenever something happens, in this case uniswap, you can automatically process that event and trigger any action on that. In this case, it's sending a transaction to an NFT contract, but you can embed any code you want here. You can reach out for external APIs. You also have access to a secret vault I key value stored. And the idea is that you can do all this without having to set up your own infra. You can run all of this directly on Defender and have Defender run everything for you.
00:25:18.500 - 00:25:45.420, Speaker B: So let's see if this works. This is the discord I use for testing. And yes, you can see here that right now, yes, trust me. This is the current time here in Buenos Aires, Argentina. The unique purchases on Rink by sentinel was triggered by this particular address. And we have the link to the transaction that actually made the purchase. Here we can see that we traded zero point 15 E for Uni.
00:25:45.420 - 00:26:24.630, Speaker B: So if we go back to the Autotask, come to the Mint union, let's see if we refresh. Here we have from a minute ago, an Autotask run triggered by Sentinel. And here we can see that these are basically the logs that we emit from our Autotask code. The Autotask received this information from the Sentinel. So this was the event that was captured on Uniswap. This was a swap event, which, with these arguments and from here, we can grab the recipient as the buyer and use them as a recipient. I'm sorry, it's this one.
00:26:24.630 - 00:27:21.286, Speaker B: And we can use this to know who should be the recipient of the NFT. And we use the relayer we had set up earlier for Minting NFT for that address on this transaction. So if we go to Ether Scan to check out this transaction, we can see that, indeed, we have minted an instance of the Defender demo, ERC Send 21. And this transaction was sent from address C 47 40 A, which is the relayer that we had created earlier. So, to wrap up, because we have just a couple of minutes left, what we did today is we used Open Sapling tooling for both development of operations. In terms of developing development, we used Open Sapling contracts as building blocks. We used the ERC Send 21 implementation, along with Access Control, Upgradability, and a couple of other building blocks.
00:27:21.286 - 00:28:21.002, Speaker B: And we use the wizard for setting everything up easily and copy it into a harcut project that we then combine with the Upgradability plugins to deploy the contract in an upgradable way. So that way you can modify the code as often as you want and just keep upgrading the contract, keeping the same address, same balance, and the same state. On the operation side, we use Defender relayer to create a hot wallet. And for simplifying the process of sending transactions, we use Admin for granting rights to that hot wallet, to the contract we have deployed. We uploaded our logic tool to an Autotask, which was just a very short script that grabbed the buyer from a swap event and sent a Mint transaction to the NFT contract. And we use Sentinels for monitoring the Uniswap pool and wiring everything together. So that's the setup that we built today.
00:28:21.002 - 00:28:57.266, Speaker B: Hope that these building blocks are useful for you and what you build as part of it online. A quick reminder, we're hiring. So if you are excited about any of these tools and you're interested in contributing, know that we have open positions for working on all of them. We're also looking for auditors in case you want to get on the security space. And that's it. Remember to jump in on the forum if you want to keep the conversation going or docs, if you want to dive deeper into any of our tools. So that's it for the presentation.
00:28:57.266 - 00:29:05.258, Speaker B: I see that we have a couple questions. Andrew, I know that we're on time, but is it okay if we go over time to go through the Q A?
00:29:05.424 - 00:29:10.134, Speaker A: Yeah, for sure. We can take a few minutes and do it.
00:29:10.272 - 00:29:57.340, Speaker B: Appreciate it. Okay. So is Sentinel equivalent of an API provider like Alchemy Infura? Not exactly. The Sentinel actually relies on Alchemy Infura and a couple of other providers. But the idea is that instead of using it as a provider for querying the blockchain, you define what transactions you're interested in by saying, I want to monitor this contract, I want to monitor these events or these function calls under these conditions. And then you can plug that either to notifications you send via Slack or Discord, or you trigger an Autotask, which is a script that will do whatever you want you instructed to do. So think of it as something that's constantly looking at the blockchain and will alert you of, which are transactions you say that are interesting for you.
00:29:57.340 - 00:30:41.846, Speaker B: Can the Sentinel work with pre deployed contracts that weren't deploying from the Defender ecosystem? Yes, absolutely. It can work with any contract at all. Actually, we just used the Sentinel for monitoring the Uniswap pool, and Uniswap was not deployed from within Defender. Actually, Defender does not let you to deploy contracts. You can deploy contracts either manually as you usually do, or using the Upgradability plugins. Also, can the Sentinel work with functions that don't trigger any events? Excellent question. That works on Mainnet and if I'm not mistaken, Robson, because we depend on a very specific method that's not available on all networks.
00:30:41.846 - 00:31:18.870, Speaker B: Let me check. It's available on Mainet and Mainnet. Robson and Coban. That's it. So if you're on Mainet, Robson, Coban, you can choose to monitor specific functions. If not, you are better off with events. See what other questions can Sentinel Autotask be an alternative for keepers like Gelato network? Yes, in a sense, you can definitely use Sentinel Autotask relayers as a sort of if this, then that for the blockchain you can totally use for that.
00:31:18.870 - 00:32:05.150, Speaker B: I understand that Gelato fills that role as well. As for keepers, we also have integration with chain linkers. That's something we didn't cover during this demo. But if you want to use chain link keepers, you can use Defender Admin for registering your contract on the chain link keepers network and basically monitoring and making sure that the keepers on the network are servicing it. The question is whether you want a more hands on approach where you have full control over the execution and the functions that are being called on your contract. But you're using defender, which is a centralized system, as opposed to relying on a decentralized network such as the keepers network where you incentivize the keepers to call functions in your contract, but you don't. Have direct control of them.
00:32:05.150 - 00:32:31.200, Speaker B: Both approaches are valid for the context of a hackathon. I would suggest going with something where you have more direct control, but it's entirely up to you. Okay. Not sure if we have any other questions that we want to go through or if the answers were clear enough. Okay, seems like we're good.
00:32:31.970 - 00:32:54.474, Speaker A: Cool. All right, Santiago, thanks a ton. That was an awesome presentation. So much information in just 30 minutes. And, everyone, remember, you can continue these questions in the forum@openzeppelin.com if you want to follow up on any of this stuff. And it'll also be posted on the ETH Global YouTube.
00:32:54.474 - 00:33:02.738, Speaker A: This talk, if anyone wants to refer back to it should be up in about an hour or two. All right, everyone, thank you again, Santiago.
00:33:02.914 - 00:33:09.460, Speaker B: Thank you for having me, Andrew. And good luck, everyone, with the hackathon. Bye. Bye, everyone.
