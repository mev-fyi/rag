00:00:00.170 - 00:00:44.470, Speaker A: Hi, everyone. I'm Noah. Maybe hopefully some of you by this time have a somewhat working back end and maybe want to start working on a front end, something to show the judges, show your friends, your mom, whatever. That's kind of what this talk is about. It's about how to build a DAP super easily that works with MetaMask, that works with all kinds of, you know, all the new fancy Web Three providers that some of you may have heard about recently that are coming out, portis, Fortmatic, Ledger, Treasure, things like that. So, yeah, I'm just going to give a brief overview of kind of the state of, I guess, web Three and DAP architecture. And then we'll dive a little bit into this package that I've built, web Three, React.
00:00:44.470 - 00:01:28.834, Speaker A: It's not going to be super chilly, don't worry, but it's just kind of a pattern that I use a lot when I'm building DApps that I've found super useful, and then hopefully you will, too, either to use directly or just to kind of get inspiration from as you're building out your DAPs. So let's see if this works. Does not. All right, I might just do it, like, in this view if that's cool because it didn't seem to want to go okay. So I'm going to talk about kind of each of the four elements of the title, just really briefly, so modern. We want to build things that are very responsive, that feel live, that feel connected to a blockchain, especially in an environment where there's this kind of global network. We want to really feel connected as a user of Adapt.
00:01:28.834 - 00:01:57.506, Speaker A: And so that's a very important idea that we want to kind of have in the back of our heads. DApps, again, the core of what many of you are probably building this weekend is Adapt. You're connected to a blockchain. There's these kind of specific protocols that you have to follow. And so there's this kind of framework that we're operating in. There's a bunch of tooling and packages around DApps. And so we kind of have to pick and choose the appropriate, I guess, tools for what we're trying to do.
00:01:57.506 - 00:02:49.022, Speaker A: React. I chose to write this package that I've written for React just because it is kind of the de facto choice among crypto projects and among a lot of people for writing kind of really responsive stateful, front end, basically. And it's a uniquely well suited package for DAP development because there's a lot of ways you can kind of programmatically write plugins to the blockchain. There's no kind of traditional data architecture like in a traditional front end. There's a back end and you're making data requests and APIs and blah, blah, blah. But with a blockchain, you're making these requests all from the front end. And so there's a lot of ways that React kind of gives you that you can kind of systematize this and make this really kind of systematic and powerful and very extensible.
00:02:49.022 - 00:03:12.534, Speaker A: And then again, web3 react. This is the thing I've written that we're going to talk about a bit at the end here. So before diving into that, I want to talk briefly about just like, again, this whole kind of ecosystem of DApps and front ends and blockchains and things like that. So there's kind of three entities that we can think about in this ecosystem. The first is wallets. The second is just the blockchain itself. And then the third is nodes.
00:03:12.534 - 00:04:01.290, Speaker A: So wallets are a store of a private key that have some methods that you can call on them basically to sign a message, to sign a transaction, things like that. The Ethereum blockchain is of course, I'm not even going to explain that. And then nodes are pieces of software that are running in the cloud somewhere that are connected to other nodes, their peers, that also can kind of read from the blockchain and then broadcast to the blockchain. And so those connections are represented by these arrows. And so the way that communication happens between each of these parties is this thing called the JSON RPC API, which some of you may have heard of. And this is again one of these tooling kind of layers that I mentioned earlier. And it's basically just a way to systematically format data in a way that these parties can understand.
00:04:01.290 - 00:04:38.866, Speaker A: And so wallets, there's many, many wallet providers, right? I mentioned them at the beginning. MetaMask, trezor, ledger, formatic, portis, dapper. You know, there's all these ones and they all basically at the core just this private key that can sign data. And then there's nodes. Again, there's infura there's like Etherscan has nodes. There's all kinds of node providers and they all can talk to each other because of this kind of systematic method of communication called the RPC API, which you can read about online if you want to know more about. And then from adapt's perspective, they're not actually using this RPC API, they're using another layer of abstraction, which is typically ethers JS or Web Three JS.
00:04:38.866 - 00:05:10.640, Speaker A: I'm sure many of you are familiar with these libraries. Probably maybe you're more familiar with the bugs than the actual functionality itself. I spend more time debugging Web Three than I do writing it seriously. But these are basically ways of offering human readable functions that actually produce RPC API calls. And so you don't want to call like s underscore get accounts with some weird parameter list, you just want to call it get accounts some nice JavaScript function that returns you what you want. And so that's what those are. Those are just abstractions for the RPC API, basically.
00:05:10.640 - 00:05:55.040, Speaker A: Okay, so this is the kind of the ecosystem, this is the last infrastructure slide. So we basically want to write a DAP that can facilitate data flowing really smoothly and cleanly between all of these entities. And we want to kind of tie everything together in this really clean kind of bundle, and that's what your DAP really should be. And so without further ado, let's jump into some code. We have about 15 minutes left. Feel free to stop me at any time if I go too fast, too slow, whatever. I want this definitely to be interactive and helpful, so I actually meant to delete all of this? Yeah, sure.
00:05:55.040 - 00:06:17.174, Speaker A: Is that better? Yeah. Okay. Maybe I can hide this or maybe yeah, I'll just make it a little well, that's not going to work. Well, this isn't amazing, but we'll make do I'll just make this a bit smaller? Yeah, I mean, this is okay. Yeah. Okay. All right, so I'm actually going to real quick delete this.
00:06:17.174 - 00:06:30.620, Speaker A: Sorry. This is cheating. You guys can steal my inferior key if you want it's free. You shouldn't, but you're more than welcome to.
00:06:32.910 - 00:06:38.230, Speaker B: Every repo to see any private keys and then check it on main net and steal funds.
00:06:38.310 - 00:06:40.220, Speaker A: Nice. That's good.
00:06:41.090 - 00:06:42.400, Speaker B: It happened to me.
00:06:44.370 - 00:07:03.342, Speaker A: I have a friend who's been bitten by that too. Check out keys lol. This is a risky I'm worried it's just a matter of regeneration. Private keys from zero through FFF. Nice. All right, so we're going to jump in. So this is the package.
00:07:03.342 - 00:07:31.298, Speaker A: There's some docs, it's on GitHub, whatever. And I'll just be referring to it kind of periodically as we do things. So the first kind of core idea of web3 react and of DApps is this connector idea. So connector is a piece of code that communicates with your DAP. And it has two kind of core components, the wallet component and the node component from earlier. Right. It has a connection to a wallet that can sign things, and it has a connection to a data provider, like a node provider.
00:07:31.298 - 00:08:09.826, Speaker A: And so the most obvious of these kind of connectors is, like, injected. So when you visit a website with MetaMask, it injects this web3 provider into your website. And so if you want to connect to that, there's a bunch of ways to do it. I actually have this fun little thing. I don't know how many of you remember this, but if you've written a DAP that works with MetaMask, you probably have seen this piece of code before. This is literally something that runs every 10th of a second on your website. It calls a method on this injected web3 provider to see if the account that you loaded the page with is what is the account that the user has currently selected.
00:08:09.826 - 00:08:33.034, Speaker A: And so this is a trash pattern, really. This is very bad. We don't want to be supporting this. Luckily for us, MetaMask has updated and they have an event that's emitted every time a user changes account. So this is great. And so we want to support this, but we also don't want to, as DApp developers, have to figure out every time MetaMask updates something like this and have to change all of our tooling. And so really we should be using again, just an abstraction layer.
00:08:33.034 - 00:09:19.134, Speaker A: And so what a connector is, or what my web3 react injected connector is, it's just an abstraction layer on top of this MetaMask logic that we have to write consistently. So yeah, without further ado, let's write that injected connector and get this little demo hooked up to my MetaMask right here. So we're going to scroll down and we're going to set up this injected connector basically. So the first thing I'm going to do is I'm going to import connectors from web3 react. Very straightforward. The next thing is I'm going to import this injected connect or I'm going to get out this injected connector object from the connectors thing and then I'm going to initialize it with some parameters. There's more, but for now we'll just enforce that.
00:09:19.134 - 00:10:02.350, Speaker A: The network ID has to be one which is mainnet. So we have this MetaMask connector object and now we need to kind of feed this to basically the interface that is going to allow this to be stateful. And so we need to feed this to react basically so that react can kind of be aware of our connector and then drill down all the appropriate data into our components. And so what I'm going to do is I'm just going to export this kind of connectors object and we're going to use that elsewhere in the app. I think this error is fine. Okay, so that is connectors. And now again, I'm going to delete all of this because sorry, I should have done this earlier.
00:10:02.350 - 00:10:36.310, Speaker A: We're just going to return this. That's fine. Okay, so this is High East New York. I hope this compiles great. So this is a super sorry, that was just ignore that. So this is just like a super basic boilerplate react app. It has this app component.
00:10:36.310 - 00:11:22.886, Speaker A: It can also render maybe something in another component. So if I do this so I'm just going to set this up super basically. So let's have my component say something else fun. I'm a subcomponent. Um, okay, great. So we have this yeah, we have this little subcomponent that's rendered here and we have this kind of top level app component. So this is super standard react stuff.
00:11:22.886 - 00:12:04.738, Speaker A: So now we need to set up again this provider object that I mentioned earlier and that's what's going to let us let react interface with the library which knows about all of our web3 stuff. So the first thing which is actually already done up here is I'm going to import this web3 provider object from Web three react and then I'm going to initialize it at the top level of our app so that all this stuff can be sent down appropriately. And so I'm going to do that here. I'm going to put this web3 provider here for connectors. I'm going to use that connectors object that we exported from the other file and feed it here. And I think it's already imported right here. So that's fine.
00:12:04.738 - 00:12:25.018, Speaker A: Library name. I mentioned web3. React. Maybe you kind of guessed that I'm maybe not the biggest fan. I like ethers. JS It's just a really nice, well written JavaScript library TypeScript library that lets you do a lot of the same things as Web Three JS. And so I'm just going to use that and that's that.
00:12:25.018 - 00:12:54.980, Speaker A: So I'm going to delete this now and then close out our Web Three provider tag and great. It seems the same, like nothing seems different. That's great. But unfortunately we also don't really have any data yet, right? We did this provider setup. We have the MetaMask thing sitting somewhere, but there's no data that's flowing anywhere. So the last thing we need to do is kind of activate our component. And so the way to do that is there's a couple of ways.
00:12:54.980 - 00:13:24.366, Speaker A: The one we're going to use is just very basic. We're going to call this set. Well, in the docs it's different, but there's a bunch of methods. But this set first valid connector method just takes a bunch of strings and it kind of attempts to activate each connector in turn. And so since we only have one, we're just going to try to use MetaMask. So let's put a button here and say activate MetaMask and we click. It does nothing.
00:13:24.366 - 00:13:53.238, Speaker A: And so if we add this on click method, we can have this console log something maybe clicked. What did I do? I didn't wrap this. Okay, great. So let's see. Great. Now when we click it says clicked. And so what we actually want to happen is we want this connector to activate when we click.
00:13:53.238 - 00:14:44.406, Speaker A: And so what I'm going to do there is I'm just going to use this kind of global context. And so the last piece of Web Three React is that once you have everything kind of set up in this way, there's this kind of context object that you can access anywhere in your app and it has these kind of shared attributes that you care about. And so I'm actually going to do this in the subcomponent in this component right here because for reasons that are a bit complicated but whatever, I'm just going to have this activation logic be here. And so in here I'm going to define this context object which I'm getting from this use Web Three React context hook. And so if you don't know about hooks, it's just a way to get stateful logic inside of a function component in react. It's a new kind of thing that was released a couple of months ago. If you don't know about it, don't worry about it.
00:14:44.406 - 00:15:28.386, Speaker A: This is just grabbing some data from our Web Three provider. And so if I just console log this context, we're going to see that it has kind of these methods, right? And these attributes. And so you can see connector, name undefined, connector, undefined, everything's kind of undefined and uninitialized, which is very unhelpful. But then there's also these functions that you can use. And so we're interested in set connector, right? Because we want to activate MetaMask. And so if I just call context set connector here and then feed it what did I call it? Yeah, I called it MetaMask with a cap M. So if I do that, when I click it hopefully should activate.
00:15:28.386 - 00:15:39.960, Speaker A: So let's try it. It did not work. That's always good. Let me just try this.
00:15:47.850 - 00:15:53.340, Speaker B: Requested for the Manmont mission thing because it doesn't inject it based on the version they're using.
00:15:56.160 - 00:16:23.474, Speaker A: Log it after because you're only logging in. Yeah, I see. Yeah. So it actually might only be so let's try this. This really should work. It okay. So it's certainly working.
00:16:23.474 - 00:16:37.990, Speaker A: So let's try. Okay, I'm just going to cheat a little bit. Sorry. Live coding is always a little stressful. So I always have this. And we only have five minutes left. Okay, so I have this little dummy demo.
00:16:37.990 - 00:16:56.698, Speaker A: Honestly, this is what you should use as a boilerplate anyway, because this works as mine thing didn't work. And this is just from the GitHub. You can just click on this. So what this is, is just a super basic demo. So if I click activate injected here. Oh, it works. That activated my MetaMask.
00:16:56.698 - 00:17:28.694, Speaker A: And so you can see my account here and you can see the Network ID of one. And so if I change accounts, there's no polling, I promise. You can see that this updates automatically. And you can use that account update to trigger updates of the account balance of all kinds of things. If the network ID updates, you can use that to reinitialize all your contract objects, et cetera. The patterns for that are actually largely like agnostic of web Three react. Web three react is really just this layer that connects connectors like that.
00:17:28.694 - 00:18:18.054, Speaker A: You talk to MetaMask, for example, and then the rest of your react app. And then once you have this kind of like data flow back and forth of accounts and networks and things like that, then you can kind of write patterns and abstractions that use that data in intelligent ways. And so if I want to, for example, use Justin Fura as a data layer so that when people land on my page, they don't have to have MetaMask. I can just click Activate Network here and you see that there's no account, right? Because Infuria doesn't have any accounts, but Network ID is still one. And so what's actually happening here is that there's this data provider, this node connection that we have that we can access and we can call read methods on the blockchain. We can check account balances, we can check initialize contracts, all these things. And we can display data to our users without actually having to require that they use MetaMask immediately when they load the page.
00:18:18.054 - 00:18:50.206, Speaker A: And so this is really powerful and something that kind of the best DApps are doing these days and is definitely something that I recommend doing. I don't have my treasure with me, but I could activate my treasure here. It pops up with the little modal that maybe you guys know if you've seen that Wallet Connect. Oh, I have it initialized already. If I just local storage clear here. Okay, I broke it. Sorry.
00:18:50.206 - 00:19:20.954, Speaker A: Well, whatever. I'd already connected with Wallet Connect on this site, which is why I did that. But anyway yeah, sorry. Go. Everything is react way all the way. Right? But how well does it scale? How big is your biggest step that you made? Yeah, so I recently joined Uniswap, and uniswap is actually right now, we just migrated three days ago. This is now using Web Three React.
00:19:20.954 - 00:20:02.694, Speaker A: So if you trust uniswap and you've used that and you feel like that is a good pattern, then I guess the proof is in the pudding. The website works. It uses web3 react. And yeah, again, what we're super excited about is if you tried to make a PR against a unisoft code base, it was very hard and people weren't doing it just because it was a bit of spaghetti code. And the good news here is that all of these little buttons, these different patterns of connecting to Web Three are just little modules. They're like 100 lines of code, and they're super extensible, super modular. And so when there's some really cool new Web Three provider that we all love, you don't have to retool your entire DAP.
00:20:02.694 - 00:20:25.514, Speaker A: You can just write a little connector, put another button here, and then boom, you're kind of in. There are some weird edge cases. Like, I couldn't get the demo working here. Just like there are some, I guess, maybe rough things around the edges. But the CoreLogic definitely works. It's been tested in kind of like live DApps. And I would welcome any and all ideas, contributions, et cetera.
00:20:25.514 - 00:20:47.060, Speaker A: And also I'll be around all day today and tomorrow if you have any questions or want ideas or help building out building out your DAP. So I think that's it. I'm going to close out the website where you can find all of the info and docs that I've been displaying here is just Noah's insmeister Web Three React. It's on GitHub. So thank you very much.
