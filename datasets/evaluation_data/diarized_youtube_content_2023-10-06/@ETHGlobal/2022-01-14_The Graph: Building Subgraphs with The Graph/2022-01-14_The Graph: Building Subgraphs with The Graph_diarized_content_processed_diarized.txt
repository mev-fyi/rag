00:00:03.730 - 00:00:19.880, Speaker A: Great. Hi and welcome everyone. Thanks for joining the Graph workshop. Joining us today is Simon and he'll be taking us through building subgraphs on the graph. With that I'll hand it over to Simon to introduce himself and kick the session off.
00:00:21.530 - 00:01:08.140, Speaker B: Thank you so much, Emily. Hello everybody. Yeah, I'm jumping in here for wish she was announced before, but I also did some subgraph development workshop already in person. So that's what I will do now, kind of just virtually. So my name is Simon, I'm a solutions engineer at Edge and Node working on the graph. I'm also one of those being in our discord answering questions and yeah, so I will have a short presentation that go through the theory about subgraph development. Feel free to just interrupt me if you have a question but I hope I can make it so that we in the end have more time for questions.
00:01:08.140 - 00:01:38.370, Speaker B: Yeah, also drop your questions in the chat so you don't have to interrupt and we can go through them later on. All right then I would like to start. All right, so this talk is about subgraph development on the example of an contract.
00:01:39.030 - 00:01:39.442, Speaker C: Yeah.
00:01:39.496 - 00:02:31.300, Speaker B: As this is the NFT hackathon, I think that makes kind of sense. But yeah, to start, eva Bailey, the director of the Graph Foundation once said if you build a DAP for the community but using decentralized components, it's no longer a DAP. A little bit provocative tweet, but somehow I think that's the general sentiment in the web3 space. But let's kind of go through all what's in there. Let's unpack this. So what is adapt? Basically adapt is just a decentralized application. So it is an application that builds upon decentralized components which we know already.
00:02:31.300 - 00:02:59.470, Speaker B: Like the blockchain is a decentralized component. But to be fair and also a little bit to say like decentralization is very hard. So to really be decentralized it needs a lot of stuff. So that's also I think we might have to build workarounds today, but the decentralization should remain the overarching goal. And good news is this is possible. It is already possible. I'll show you in the next slides.
00:02:59.470 - 00:03:36.150, Speaker B: So here we see. This is the initial dev architecture. Like in the beginning when Ethereum was founded, they had this already mind to have an architecture like this. Mainly you have the users on top that browse a user interface that was deployed on IPFS completely. So it's actually a front end only thing that directly communicates with the blockchain. You already know writing transactions to the blockchain. We do that often buying NFTs and other transactions.
00:03:36.150 - 00:03:38.650, Speaker B: But also reading from the blockchain.
00:03:39.230 - 00:03:40.540, Speaker C: As you see here.
00:03:44.350 - 00:04:35.062, Speaker B: We have a decentralized viewer that's directly interactive with the blockchain. But the problem with that architecture is that the blockchain by itself is actually a write, optimized and incentivized database. So reading is slow by meaning on write, optimized and incentivized. Think about if you send a transaction to the blockchain and the whole security of the blockchain by itself that stems from the fact that you pay transaction fees if you pay gas for that transaction. So that it's written by the miners to the blockchain, but reading from the blockchain there is no incentivization to do. So you can read there are this JSON RPC interface but it is not optimized at all. And also there is no incentivization for any node to provide that interface.
00:04:35.062 - 00:05:45.790, Speaker B: In the beginning the idea was like that everybody's running its own node at home. But yeah, I doubt that a lot of people actually do this, but hopefully this will change anyways. When you directly interact with the JSON RPC interface and you want to do something like get token IDs by owners, or you want to have all token IDs from an ERC 721 contract extracted, then you need to write code like this. And I am very much in the team of clean code and this is not clean at all. I mean, this is kind of a forest of awaits and imagine how long that it gets when we have let's say ten tokens or 50 tokens where each of these contract calls maybe takes 1 second to resolve through JSON ARP interface. So this is not a good option. So how can we solve that problem? And you can think about the modern deb architecture where you have on top a user interface.
00:05:45.790 - 00:06:37.586, Speaker B: Again, it's still possible to deploy it through IPFS if it's a front and only thing. And then we have the indexing, we have an indexing protocol like the graph that interacts with the blockchain data. It's not only the Ethereum blockchain anymore, it can also be the roll ups like Arbitrum and optimism, CK sync and so on. And also RV for Ipfso. This is where you can have the data. So with the graph there is actually kind of a read incentivized and optimized component to the descent to the web3 or decentralized app stack that we can use. So by using the graph you could write the same thing like we saw before in a very neat GraphQL query that could look like this.
00:06:37.586 - 00:07:43.522, Speaker B: And yeah, this is how I like to have my front end code actually. So we talked already about the graph. So that is actually where the graph sits in the whole stack and why it is cool. So it's the APIs for vibrant decentralized futures or like an indexing protocol for querium networks like Ethereum and IPFS like indexing blockchain and smart contract data or making it easily accessible for the front ends. Today the graph hosted service, which is a centralized solution at the moment, powers one billing queries per day. But since June it's already like there's the graph decentralized network deployed. So there are 160 indexers who are in this network who are more than happy to index your subgraph to have it like in a fully decentralized way to talk about Bounties.
00:07:43.522 - 00:08:24.646, Speaker B: I can tell you already. Like if you use existing subgraphs on the network, on the decentralized network or if you write the subgraph and you deploy it to the decentralized network, that would be a big plus here for the charging. Other than that, as I said, the graph has two categories for Bounties. First is the best use of existing subgraphs. There are a lot of very interesting subgraphs already on the network. It's from Sora Foundation, super rare and so on and so forth. I can give you a list with those subgraphs if you ask me on discord that are interesting.
00:08:24.646 - 00:08:55.242, Speaker B: And on the right hand side actually what we want to have more or see more is like new subgraphs, like new subgraph developments. Like there are two prices like 2009 in total. And yeah, that's actually wrong. I think it's 1 gram price and one runner up. Anyways, I think it is cool. It makes a lot of sense to use the graph anyways for your projects. So even without the bounty but there are also bounty.
00:08:55.242 - 00:09:01.780, Speaker B: So use the graph. So now the next step is.
00:09:05.030 - 00:09:05.394, Speaker C: Let.
00:09:05.432 - 00:10:04.546, Speaker B: Me walk through the NFT subgraph development. So the first question is like what the heck is a subgraph anyways? For the subgraph you can think about it. Basically it is just a database schema where you define how you want to organize the data for your application. Think about typical NFT subgraph consists of one table with the NFTs in there. Then you have maybe one table with the transfers, one table with the users and then you connect those with relations. So it's basically really a database as we know. Then there is a mapping means this is kind of some logic that can watch the blockchain for transactions or for events, basically for events or calls or even for every block and then gets triggered.
00:10:04.546 - 00:11:11.590, Speaker B: And these mappings then takes the data out from the blockchain and puts it into the database. And then of course we have the blockchain Ethereum or other event compatible chains also near you could try out that you can write subcrafts for them. So simple said on the blockchain you have all these transactions or like the different transactions, they are kind of wildly mixed regardless which protocol that you are using. And then what the graph does is actually kind of sort that take them out and puts them in order so you can quickly query the data that you need. So on a high level the graph looks like this. On top you have the DAP actually that you are building front end tooling. And then the DAP usually kind of send transactions through the blockchain.
00:11:11.590 - 00:12:00.330, Speaker B: Let's say you want to mint an NFT. Then you have a smart contract where you have that NFT on it. Then you send a transaction to that smart contract that actually says hey, I want to mint it. The smart contracts when you interact with it, they emit events and those events will be consumed by the graph node and then sent to the mapping that is deployed, as I said, a part of the subgraph which then in turn will store it here in the data storage on the left hand side. We see then later on when you want to query that data and just send query through that neat GraphQL API that the graph is providing for you and that will go into the graph node and then directly reads from that store from the database. Very quick. So you are very quick.
00:12:00.330 - 00:12:47.718, Speaker B: Like with reading you do not touch the blockchain at all. So that's the whole trick. Yeah, some tips and tricks. So in general you should emit all information that you want to store in the database as events because that is just best practice about how to work with those event source systems. Like the blockchain is do you have those events? And try to avoid these eve calls. Eve calls is in the moment when here data flows in and you need to ask the blockchain again for more data. This makes generally indexing slow.
00:12:47.718 - 00:12:56.540, Speaker B: So try to event all the data that you want to have indexed. Try to emit it.
00:12:59.230 - 00:13:00.134, Speaker C: With events.
00:13:00.182 - 00:13:02.330, Speaker B: Yes, I'm.
00:13:04.750 - 00:13:05.914, Speaker C: Checking the questions.
00:13:06.032 - 00:13:57.200, Speaker B: Can topcraft listen to events from multiple contracts or can one combine multiple subgroups into one mapping? Good question. Yes, one subgroup can index as much contracts as you want. Actually it is just on one chain generally. And you can even have like there are even techniques to start to index new contracts when let's say you have a factory where people kind of can deploy their own Arc 721 contract out of your root contract or something like that. So that's possible. If you go cross chain, then you have to have multiple blockchains like for every chain, one subgraph and then you combine the data in the front end usually.
00:13:58.850 - 00:14:02.610, Speaker C: Next question is that no other talk what's indexed?
00:14:04.310 - 00:14:57.730, Speaker B: No, the indexed is only that only applies to solidity and to the graph to the ethereum node by itself. The graph actually does not care about that. All data in the graph is indexed. Let me continue. Yeah, then you can create entities for important objects or concepts. So for example, one trick here is to say okay, I don't know, I have account. So you have an entity account buys you have an entity account and on that entity you can store the aggregation data like how many NFTs a certain address has that you can store on that.
00:14:57.730 - 00:15:34.634, Speaker B: Or you can start with let's say for NFTs. A good example is you can have a trait entity and then you can store aggregation on those traits and you can select which punk has a hoodie or how many ponks to have a hoodie on the nerf you trade hoodie with ten. So that's a little bit trick here. Try to link the entities together as much as possible. So this gives more use to your subcraft, like maybe even beyond your current use that other people can build upon your subcraft. That's very cool. And I want to also tell you about these NFT standards.
00:15:34.634 - 00:16:16.720, Speaker B: There's a working group that it's worth checking anyways. Also if you plan to go into the contract development but they also have some resources about subgraph development and then the GraphQL online that you can use it's a bit better than the playground that you find on the host service or in the studio. Okay then this question from Muradif is at the Bounty, does the Graph have a native incentive for developers to develop new subgraph? Yes, of course you could apply.
00:16:20.050 - 00:16:20.366, Speaker C: You.
00:16:20.388 - 00:17:22.820, Speaker B: Can apply for a grant at the Graph Foundation. Other than that yeah, I mean there is an incentive on the Graph decentralized network when you deploy a subgraph as a developer you can also be the first that signals on it. By signaling this kind of this correlation LENSCAPE correlation and by being the first one to signal a subgraph, you are probably the one that gets the most of the query fees. So like when that subgraph then receives queries, people pay for query fees and that query fee will be distributed amongst the curators and as the developer you can be the very first curator. There is also a bonding curve but it's a little bit complex. We can maybe go yes, we can go deeper in that topic maybe later but yeah, query fees. Yes.
00:17:22.820 - 00:19:15.814, Speaker B: So then I think also good practices to check about to think about your main questions like how many NFTs are there in total or which queries do you want to send in? Like what do you want to know about your contracts or your protocol? And for NFTs, some that came to my mind by writing is like how many NFTs are there in total? How many NFTs are there with Trade X, who owns which NFTs or who owned it before? Is it really the right one? Then if available the on chain market prices that said for OpenSea it's quite complex to know the prices, their interface or their smart contracts are closed source. So there are some people that try to reverse engineer to get to that data but it's not so easy. But if you look at CryptoPunks and other on chain marketplaces maybe like Torah, you can easily get to that data and then you can have the historic prices. So how the price developed? Like what's the current asking price, what's the current highest bid? If you have also the bids there and other specialities that your NFT might have, like if you have some utility or link to whatever. So this is kind of keeping in mind by planning your subgraph like okay, what are the questions I actually want to answer? Yeah, and then like the NFT schema, like roughly we can model it like this. So you have contract which represents the collection that's actually quite similar. Like that C 721 subgroups that are already deployed are set up.
00:19:15.814 - 00:20:11.058, Speaker B: So I have contract, then you have address of that contract account, how many NFDS are there? You can have a list of owners where you can also have owners count. Maybe here. Then you have an account like people like owner you can have current holdings or also aggregation of the holdings. Then you have an actual NFT like token by itself that token ID. You can store the metadata Uri. I don't know my discord and I can search it up later or simon okay, event interface. Yeah, then you probably want to have an entity that event name you might or might not, it depends.
00:20:11.058 - 00:21:05.420, Speaker B: You want to see when transfers means bid, ask sales whatsoever. Like all these events that can happen on a subgraph block number, block hash, metadata if available, maybe trade if available, statistics about the trade as I said before. So yeah, this would be now the demo. We can install the dependencies, find the contract online, create config JSON, run the graph compiler, create subgraph in subgroup studio. This is the example actually with the open seplins NFT subgraph or no general Open Zeppelin has like subgraph templates that you can use. They are very cool. And here I have prepared live coding how to use it.
00:21:05.420 - 00:21:19.310, Speaker B: That said, the workshop usually is for 1 hour and we are like six minutes. I only have six minutes left, but let's see. Yeah, this will repeat steps.
00:21:21.730 - 00:21:22.480, Speaker C: Yes.
00:21:23.170 - 00:22:14.714, Speaker B: So another thing is token Uri. The thing is the graph cannot or currently cannot actually follow arbitrary Uris like HTPs or whatever. So a very best practice is to avoid these HP Token Uris and try to put metadata on chain. There are different examples of people that did it. I mean, for example, if you look at NFTs that uniswap does for example now in B three exactly done like this. So this is very cool. If you have this on chain, it's also possible then to actually parse it inside of the graph it's much better otherwise, don't forget to make your base Uri changeable.
00:22:14.714 - 00:23:03.754, Speaker B: So if at some point your server goes down or whatever, that you can still change. But I would try to put as much as possible on chain. Yeah, there's also kind of this pattern of bullflow metadata into the subgraph in the beginning. That's also possible. Yeah, there are some ideas we can talk about, but the token Uri actually with the HTP Uri is a bit problem. Sorry we fell like how can we handle network issues, potentially missing events. It is solved by the graph actually for you, like if you write the subgraph, the execution of that subgraph is deterministic.
00:23:03.754 - 00:23:36.882, Speaker B: That means the subgraph there is never a missing event. You always know if something is missing and the subgraph is trying and trying again to index and actually get to that data. But maybe you talk about IPFS. Right. As I said, HTP and HTPs cannot be queried from inside the graph. But what can be queried is IPFS. But the availability of data on IPFS is not guaranteed.
00:23:36.946 - 00:23:37.510, Speaker C: Right.
00:23:37.660 - 00:24:12.146, Speaker B: So there yes, actually, maybe this. So it could be that when you try to download data from IPFS inside your subgraph, that these requests are timing out. The workaround here is the workaround here is to yeah. If you have access to those files, you can try to pin them to the Graphs IPFS node. There are some repos around that can do this. My discord username.
00:24:12.178 - 00:24:17.480, Speaker C: I can quickly show you this one.
00:24:19.850 - 00:24:44.426, Speaker B: Yeah. Okay. Ron, I assume that your thing is but as I said, otherwise, it indexes very deterministically. So there's no missed events or no transaction. It happens on this newer, faster chains, on Polygon or Binance or whatsoever. We saw problems like this, but on Ethereum Main, it just never happens. It's not like once an event is around or once it isn't.
00:24:44.426 - 00:25:03.960, Speaker B: I mean, it's immutable data storage. Okay, we can stay with yeah, I do the live coding. You can drop questions here. I think we can make a little bit longer.
00:25:05.610 - 00:25:06.520, Speaker C: All right.
00:25:09.050 - 00:25:33.550, Speaker B: So how it goes, basically yeah, you create new folder. You go in there. The Graph CLI already have installed.
00:25:35.330 - 00:25:36.080, Speaker C: Check.
00:25:38.230 - 00:25:48.580, Speaker B: This is the latest version. So you should check for the latest version. Actually, that makes sense if you start from scratch. Otherwise, what we have.
00:25:51.590 - 00:25:52.340, Speaker C: This.
00:25:54.470 - 00:26:14.330, Speaker B: Yarn bleeding edge. Now we install just the open zeppelin dependencies and the graph TS and graph CLI. So the helper here are the ones from Open Zeppelin and Graph TS is kind of the types. And graph CLI.
00:26:14.990 - 00:26:15.654, Speaker C: Yeah.
00:26:15.792 - 00:26:19.486, Speaker B: You install the CLI again into the.
00:26:19.508 - 00:26:21.040, Speaker C: Project, if that makes sense.
00:26:25.330 - 00:26:30.334, Speaker B: Yeah, we can in the meantime, we can check here, like what I do.
00:26:30.452 - 00:26:45.014, Speaker C: Usually hash mask subgroups it so I think what we check here is like.
00:26:45.052 - 00:26:50.470, Speaker B: We first get the address, but also.
00:26:50.540 - 00:26:55.846, Speaker C: Like the creator thing.
00:26:55.948 - 00:27:04.378, Speaker B: So we have the address and we have secret for the start block, because we can't tell the start block because we do not want to index before.
00:27:04.464 - 00:27:06.720, Speaker C: That contract actually was deployed. Right?
00:27:09.810 - 00:27:10.560, Speaker B: Yeah.
00:27:13.090 - 00:27:20.530, Speaker C: Can also complete code.
00:27:23.320 - 00:27:24.070, Speaker B: Already.
00:27:28.040 - 00:27:28.612, Speaker C: I think.
00:27:28.666 - 00:27:31.012, Speaker B: Because it's big enough.
00:27:31.066 - 00:27:32.470, Speaker C: Right. So you see.
00:27:35.740 - 00:27:36.744, Speaker B: In a live in.
00:27:36.782 - 00:27:42.330, Speaker C: Person presentation, usually that's too small, but you're all sitting in front of a computer.
00:27:46.220 - 00:27:52.540, Speaker B: Still installing. Let's see if I can make folder.
00:27:57.120 - 00:28:25.790, Speaker C: Just code so we have it for reference. Also, we can create this concept of JSON. Okay.
00:28:26.320 - 00:28:29.388, Speaker B: More or less edit here, as I.
00:28:29.394 - 00:28:40.210, Speaker C: Said, contract address and then.
00:28:42.740 - 00:28:47.040, Speaker B: Start block. Prefilled.
00:28:51.700 - 00:28:54.170, Speaker C: Ink it.
00:28:55.580 - 00:29:01.544, Speaker B: Now we can compile the stuff already. So I'm making this fast.
00:29:01.662 - 00:29:03.930, Speaker C: We have a free to ask any questions.
00:29:04.380 - 00:29:15.592, Speaker B: In the meantime, just I want to show you how easy it is. Okay, so we have a schema.
00:29:15.736 - 00:29:16.984, Speaker C: All right, schema.
00:29:17.112 - 00:29:59.550, Speaker B: Now we have the standard schema. As I said, like before, it's account contract token operate transfers, event transactions. So we have already kind of this is database schema. As you know, basic database schema and subgraph YML file essentially starting point. So you see schema where's the Pegasus again? Where is the contract address? The API then installed through the node modules. And also all these event handlers. You can also check those.
00:30:03.040 - 00:30:03.628, Speaker C: But you.
00:30:03.634 - 00:30:15.856, Speaker B: Can also check event handlers. This is just like now here. It just imports that code. But you can also wrote that code.
00:30:15.878 - 00:30:21.730, Speaker C: By yourself just for quick starting. Yeah.
00:30:23.620 - 00:30:34.626, Speaker B: Description. And usually also add scripts packages.
00:30:34.778 - 00:30:35.480, Speaker C: It.
00:30:45.090 - 00:31:05.940, Speaker B: Already then usually you run yarn coaching. Yarn build coaching. Now takes the Abi and the schema. Yes. And generates some typing files for you.
00:31:06.710 - 00:31:08.870, Speaker C: That helps actually this development.
00:31:09.290 - 00:31:27.360, Speaker B: So you have kind of this neat autocomplete in Vs code and also for schema and yeah, the next step is build. If build compile, it everything is written in assembly script. So it looks like TypeScript, but.
00:31:29.090 - 00:31:29.454, Speaker C: It.
00:31:29.492 - 00:31:59.822, Speaker B: Can be compiled down to Wasn't or WebAssembly. So now we have this thing. It's already compiled. So we have in the build folder, we have subgraph here. This will be actually then deployed. And I think the next step is just Studio. Studio.
00:31:59.822 - 00:32:08.006, Speaker B: I show you the path, how you can deploy the decentralized network that works for Ethereum and Drinkaby. But if you want to develop on.
00:32:08.028 - 00:32:22.190, Speaker C: Other chains, you should still use the host service. For now it's.
00:32:27.170 - 00:32:28.190, Speaker B: Login.
00:32:31.170 - 00:32:41.670, Speaker C: Yeah. Okay. Message. I can say, like.
00:33:11.260 - 00:33:12.280, Speaker B: Studio.
00:33:13.900 - 00:33:17.530, Speaker C: So say.
00:33:19.260 - 00:33:21.160, Speaker B: So I need to authenticate.
00:33:29.760 - 00:33:30.510, Speaker C: This.
00:33:33.120 - 00:33:40.770, Speaker B: Now. It's authenticated now we can just do your employee, I think.
00:33:43.700 - 00:33:44.450, Speaker C: Yes.
00:33:52.340 - 00:33:55.156, Speaker B: It pick a label, you can.
00:33:55.178 - 00:33:59.910, Speaker C: Wrap it up you want maybe just like 12345, whatever.
00:34:00.440 - 00:34:14.040, Speaker B: I mean, not sure how important semblance. So then we have the queries uri. So you receive kind of a preview Uri.
00:34:14.120 - 00:34:40.680, Speaker C: And as I said before, and I think this is now already indexing. Yes.
00:34:41.530 - 00:34:48.726, Speaker B: All right. So it's already indexing playground or details.
00:34:48.758 - 00:34:55.914, Speaker C: I think it's already some entities, something's going on.
00:34:56.032 - 00:35:17.314, Speaker B: But also when we are here, we can check socket. Which tokens do we have? What's the ID, the Uri, then the contract, the name ID symbol owner ID boom. And we already have kind of what.
00:35:17.352 - 00:35:21.178, Speaker C: I said before, this neat interface to the Hashma.
00:35:21.214 - 00:35:40.106, Speaker B: So this works because it's standard compliant contract and we can use the open sapling templates. But you can also then like if you look at this thing here, I.
00:35:40.128 - 00:35:42.170, Speaker C: Can post this chat.
00:35:48.030 - 00:36:12.834, Speaker B: Yeah. Here. The next steps would be kind of to really extend. So you can just copy paste it over and fix those imports and start to really work on it and so on so forth. I also have some other resources here. So like developer Dao has very good resources. Then Nadada is obviously kind of already a legendary guide about full stack Ethereum development.
00:36:12.834 - 00:36:17.542, Speaker B: The crypto punks from Cherry is a good example how you can do stuff.
00:36:17.596 - 00:36:17.766, Speaker C: Then.
00:36:17.788 - 00:36:34.160, Speaker B: As I said, the graphic URL online. The other workshops from now that similar to mine talks dartiscope. Yeah, I think that's it mostly. Any questions?
00:36:39.170 - 00:37:03.000, Speaker A: If anyone has any questions, feel free to unmute and ask now. Otherwise Simon is available in the graph discord. If you would like to chat to him async about anything regarding the workshop or maybe the project that you plan to build out this weekend, don't hesitate to reach out to the Graph team in their sponsored Discord channel.
00:37:05.610 - 00:37:09.640, Speaker B: Yes, come to our channel and talk to us.
00:37:10.250 - 00:37:16.870, Speaker A: Perfect. Thanks so much Simon. And thanks everyone for joining and we will see you in Discord.
00:37:18.890 - 00:37:19.700, Speaker B: Thank you so much.
