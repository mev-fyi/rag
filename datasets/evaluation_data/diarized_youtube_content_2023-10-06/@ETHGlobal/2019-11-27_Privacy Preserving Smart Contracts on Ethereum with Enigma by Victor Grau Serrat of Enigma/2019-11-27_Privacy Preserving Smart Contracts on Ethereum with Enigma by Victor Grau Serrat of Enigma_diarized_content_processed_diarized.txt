00:00:08.450 - 00:00:53.970, Speaker A: Morning everyone. Good morning. Glad to see so many people here on a Saturday morning and so many other good things. But I'm excited you're here with me. I want to quickly get a show of hands for Enigma. People of Spain, how many people have you heard about Enigma before coming to the hackathon or learning anything about in Boston? Okay, so this talk is really packed, but I don't expect that you're going to follow along 100%. But rather I want to give you an overall sense of what it would look like to be hacked on a nickel.
00:00:53.970 - 00:01:32.840, Speaker A: I'll be showing this slide, one beginning in the middle. At the end you have time to go through this. There are one, two, three professed, six or seven of us around. So there's plenty of people to talk to. I'll highlight them at the end. So I'm more interested in keeping up with big picture. And research shows that people will get at most three ideas for any given talk.
00:01:32.840 - 00:02:16.548, Speaker A: So I'm going to focus on trying to hammer three ideas. The first one being if you think about Enigma, think about the privacy layer for Ethereum. So let's talk a little bit about the problem of privacy. Data on the blockchain is public by default. I mean, that's the whole thing where I'm promised about the public ledger and being knowledgeable and whatnot. But this great limits potential applications. Think about all the services that you interact with or that you benefit or that you use in your regular life and the fact that that information there's only information there that you don't want to put in the public blockchain.
00:02:16.548 - 00:03:52.580, Speaker A: And you can think from public records, your final information, your employment history, your salary, your friends, your contact to more mundane things like you are playing a game, say strategy game. And the moment that you reveal your strategy game is over. So you can think about privacy in very important terms, but also in rather trivial terms that allow for interacting things to happen. So Enigma solves precisely that problem where we enable decentralized applications to compute over encrypted data. And you should think about Enigma as a layer two solution where Enigma is the computation layer and we use Ethereum as the verification layer. We use Ethereum as the source of which allows for great scalability too, because you can upload all the computation to this other network and just use Ethereum for coming to a consensus. So Enable Discovery is the first network that publicly enables we call it secret contract, smart contract, where secret contracts you can compute over encrypted data and you have permissionless network economically incentivized in a similar way to proof of state.
00:03:52.580 - 00:05:05.606, Speaker A: And most relevant to this talk and to this event is compatible with Ethereum. And one way of understanding the Enigma network is to talk from the point of view of the different stakeholders involved. So like Ethereum, we have developers who develop and deploy decentralized apps on Enigma, we have users who create tasks to use those DApps and we have workers who execute those tasks, workers being the analogy to the nodes and Ethereum. We use somewhat of a different nomenclature or naming or taxonomy so as not to get confused because we are going from one network to the other all the time. So let's quickly go over the flow of how Enigma works. So developers write different contracts, compile them to bytecode, and then deploy those contracts to the Enigma network. And those contracts are also registered on smart contracts on the Ethereum blockchain to present our source of proof.
00:05:05.606 - 00:05:53.494, Speaker A: So we have to have a record of those contracts over there. So then users interact with these tasks by submitting encrypted data. This create task, a hash of that task again is reported on Ethereum and the task is sent to the Enigma network. Workers receive tasks based on a safe weighted lottery. So the more you take, the more chances you are that you'll be chosen for a given task. Selected worker executes the task and disseminates the results back to the network. And there's an option here for when, with the result of that task, you can call something on Ethereum and hack an Ethereum.
00:05:53.494 - 00:06:34.514, Speaker A: Hence also the interoperability with Ethereum, which we think is a critical component of enabler. I'm harring in this idea privacy in Ethereum. Think about it. So now I'm getting into the hackathon mode where it's like, okay, you have some ideas, you need some privacy in your application. And the beautiful thing is that we are not asking you to rewrite all your application on Enigma. It's almost the opposite. You have your dab, you have your smart contract, you can have all the business logic in your smart contract.
00:06:34.514 - 00:07:07.810, Speaker A: But wait, there's that one function. There's one thing where I need to handle some sensitive data. That's where you call Enigma, Enigma calls you back. So everything else works on Ethereum. But then you can upload the sensitive information to Enigma fairly seamlessly. So the blue boxes are the elements that you as a hacker start to think of, okay, I want to use Enigma, what do I need, what do I have to use? Encrypted inputs. So whatever you send into the network, it's going to be encrypted.
00:07:07.810 - 00:07:48.480, Speaker A: And I'll talk about this. We have a JavaScript library like Web three Ethereum that basically handles all those things to you. You basically say, Send us and these are the parameters and we handle the encryption. So encrypted inputs, there's an encrypted state that can be maintained on the network and that no one have access, that no one can read. And there's an encrypted output as a result. And then there's an Ethereum callback that I mentioned. Okay, so fairly straightforward inputs, outputs and state.
00:07:48.480 - 00:08:48.846, Speaker A: Again, I'm going to be back and forth between these two slides. So let's think about where can you build on Enigma? And this is more of a brainstorming ideas or like at this point your head should start spinning and like oh yeah, I have this idea I was missing this component, what can I do? So, type of things that you can build on Enigma games that require you to hide actions on ethereum. Say rock, paper, scissors. It is impossible to play rock paper scissors on ethereum because I commit scissors. It's like, okay, I'll hit you with a rock, then where's the fun? But now imagine that I play my game. I send my encrypted scissors to the network. You send your encrypted whatever to the network and then the network de encrypts the two place and sends back the output.
00:08:48.846 - 00:09:41.246, Speaker A: Or same with Battleship, right? We all play the matrix with ships on the matrix v one hit three C four. That matrix of where your ships are is the state and the V four S and C three S and V ones are the inputs that you send encrypted to the network. Similar hangman where your actual word is the encrypted state and you send the letters and you can tell whether you hit or not. Cabin your hand with secret locations. Say I tell you, go across the street on this path and when you are at the bar, turn around and you see something. And then you say oh, I saw Mural. So send Mural encrypted to the network.
00:09:41.246 - 00:11:04.190, Speaker A: And then you say okay, now then you decrypt the next space which is go across the street into the store, second aisle. What book do you see? That type of thing. And secret messaging. I think subscriptions is the easier way to get it where you send a payment to the network, we whitelist your message sender address and then when you want to get some information that is stored in the encrypted state, if message sender is whitelisted, then we send you the content, otherwise you don't have access. Okay, so we have a developer environment much like Truffle. And I want to try to keep on with this analogy all the time because really we took Truffle all the source code and then we inserted a bunch of things to compile and migrate secret contracts in parallel to compiling and migrating smart contract. So if you ever use travel to compile, migrate and test smart contracts, then we'll basically do the same with secret contracts.
00:11:04.190 - 00:12:02.350, Speaker A: And in bending slides there will be this thing where if you might be able to follow along again, I think this is too fast. We did this presentation in another conference where there was a bit more time. So if you downloaded that DM, you can go to this folder and you start the network just by running Discovery Start. And this runs the dockerized network in your local host where you have an instance of Ganache that simulates ethereum. And then you have two or three nodes that form the Enigma network where you send tasks they want to encrypt it. So this is a sample output of color by each component, prints that output and helps you figure out what's going on. So this is mostly for debugging and developing.
00:12:02.350 - 00:12:35.226, Speaker A: So what I want to do today is basically two things, like two easy steps. Get introduced to enema in two easy steps, develop a contract, interact with the contract. It's not as easy as it seems. And here's, I guess, the bad news for you is that secret contracts have to be written in Rust. Boy, another language I have to learn. Yeah. No, I know.
00:12:35.226 - 00:13:22.794, Speaker A: There's no way around it. And of course, you want to think that we picked our language for writing secret contracts, not because it was easy, like, easy to use in a hackathon, but boy, it was a robust language that is memory safe, that has good performance, but essentially we preserve the privacy that we assure that the network will give you. So I thought about this talk. It's like, okay, I know learning a new language is Rust. It's almost impossible to do in 36 hours. But you all know some programming language, and I'm just going to hack our way through writing a contract in Rust. I don't expect that anyone will master Rust in a day.
00:13:22.794 - 00:13:55.060, Speaker A: I haven't. I actually haven't even in six months. But at least I'll give you a way on how you can run a secret contract in less than an hour or so. And then we have two developers here that we can help you in writing. But Ryan has been voted the most loving love program language in three years in a row. So join the community, join the love. Okay.
00:13:55.060 - 00:14:30.126, Speaker A: I'm a great believer in learning by doing. So, I'm just going to go through one very specific problem, which is the millionaire's problem. Some of you might be familiar with it, but it's really simple. Alice and Bob are millionaires, and they are obsessed with who is richer as well as not disclosing their net wealth, the net worth. So they want to compare their wealth, neither of one disclosing to the other, what is their worth. So it works something like this. I create a new millionaire's problem.
00:14:30.126 - 00:14:54.098, Speaker A: I have an instance of the millionaire's problem. I add a millionaire, say, Bob million dollars. I add a second millionaire, Alice, $2 million. And then I compute the reaches, and the result should be Alice. Okay. So basically, there's one secret contract. There are two functions, add millionaire and compute.
00:14:54.098 - 00:15:16.474, Speaker A: And there are two inputs and one output. As simple as I guess I'll keep it. No one is following. This is my hack number one. This is our organizational repo. This is one of our repos examples. One contracts.
00:15:16.474 - 00:15:54.394, Speaker A: There's a bunch of contracts that we have written in Rust that we have, I think, done a good job of inline documenting. So I bet that's what that is really simple. But basically you have five or six contracts. We pretty much do whatever is possible in secret contracts. So you can just go there and copy paste. Copy paste. So I'm going to go here and here, and this is this file, and I'm just going to go break it down by line by line.
00:15:54.394 - 00:16:24.290, Speaker A: And this file has about so there's one example. Secret Contract has 80 lines of code. Half of them are common, so we're down to 40. I claim that you only need to write ten of those 40 lines. So can you write ten lines in an hour? I think so. Quickly, just to get you a sense of what Russ is like. And it's fairly similar to C and some Java or TypeScript.
00:16:24.290 - 00:16:47.686, Speaker A: So these type of things is like copy paste. If you don't want to understand what they do, I don't care. Just copy paste. All the secret contracts have these lines at the top and they get you set up. So Rust has a lot of standard libraries that the Execution engine does not support. Execution engine. Think about EVM the Ethereum virtual machine.
00:16:47.686 - 00:17:34.358, Speaker A: There's a lot of things that you cannot do in the Ethereum virtual machine so you cannot do in the Enigma virtual machine. And so all the standard cross functionality does not apply. So we cross out all the standard functionality. Then we bring two packages into scope, one and two. And this one is the one that allows us to interact with the Enigma runtime, which allows us to write and read from the state and print for debugging purposes. So basically, we import it and we want to use everything that's gained this type. And then there's this other package which allows us to define the functions that we can call from the smart contract and write Ethereum callbacks.
00:17:34.358 - 00:18:07.954, Speaker A: Fine, I'll import it. And I want to use all the public interfaces that this package provides. And it allows us to serialize and deserialize inputs into the contract of some custom strike types. Okay, all this comes for free. You just copy this. Then the Enigma state is a hash map, and I need a key to access that HashMap. So that's a string that is called Millionaires.
00:18:07.954 - 00:19:18.422, Speaker A: Okay, now I'll stop here for a moment. This is where I define my data structure for the Enigma state. So it's a structure, and I have two fields, address and net worth, where the first one holds by 32 hash map interaction like an Ethereum, and then also 32 bytes there's. And then you say, oh, how do I come up with these numbers here? At the end, there's the relationship between the grass types and the solidity types. So if you know solidity types, you just have a one to one. I wouldn't say that. And then these are the public functions that I want to define to interact with my contract.
00:19:18.422 - 00:20:43.380, Speaker A: You remember in the scheme I said there are essentially two functions add a millionaire and then compute riches and like every programming languages, you define your inputs. This has no output and this one has no inputs and outputs the hash of the address or the identifier of the million. So then I define my contract and I can have private functions and public functions. So this is just an example of I want to read from the state so I want to get millions. So I'm going to read from the state with my key that I use to get to access the hash map and then this will get me a vector of those structures or the empty vector. Again, you may say, well, the actual language is a little bit weird, it's like, yeah, fine, but you have a lot of examples on how to do the most basic and essential stuff. And then these are the public functions for the contract where it add a millionaire.
00:20:43.380 - 00:21:32.096, Speaker A: So I read all the millionaires that I have already in the state and if it's the first one I'll get an empty vector and so I push the inputs that I got and I write to the state. So this is the core of your contract. I want to add a million. These are like 12345 lines. Can you write five lines and then compute reaches. So this is basically one line where I want to get a match. And this is like typical Rust stuff where I want to get a match for the get millionaires.
00:21:32.096 - 00:22:09.090, Speaker A: The function we saw before, I'm going to iterate through all the results I will find the maximum by key which is net worth of the vector that I get up. And either I'll get an empty vector if I try to call this too soon or I'll get basically a result. And from the result I'll get this field, which is what algons are. It's everything like sort of compressed. But again, talk to us, we know some Rust. We can help you with this cryptographic way of programming. That was it.
00:22:09.090 - 00:22:57.840, Speaker A: So first idea, privacy layer in Ethereum. Think about Enigma. Second idea secret contracts are written in Rust and there's no way around it because it's a very good choice of a language for many other reasons. So now I have this secret contract that I've written and what do I do with it? Much like Truffle compile. I'll run Discovery. Compile. So basically that will turn that secret contract written in Rust into WebAssembly, which is similar to the bytecode that runs on the Ethereum virtual machine.
00:22:57.840 - 00:24:18.430, Speaker A: So I'll end up with file somewhere on my drive and then much like you do Truffle migrate, we'll do discovery migrate and that basically we are using the Truffle migration files to migrate the Enigma contract. And what you need to know is deploy secret contract and you pass a file name. This is the constructor and the amount of gas that I want to use to deploy the contract from account one. These are the Ganache tropical accounts. Running out of time. I want to skip that in the interest of finishing on time and being respectful with the other speakers. But we have an Enigma JavaScript library, again, much like Web 3D library, where you have these functions to your disposal, compute tasks, result, or find the status of the task that you intend to the network.
00:24:18.430 - 00:25:31.194, Speaker A: Okay, so I just want to finish by three ideas. The third idea being that we have a developer environment that we think is fairly user friendly and a good way to get you started. Now, if you have questions, I want to give you resources. So if you want to get started setting up the network with the developer environment, installing it in a virtual machine or in your environment, whatever, come and talk to me that you are past that and you start thinking about writing a contract in Rust. Go and talk to Fred. He's one of our core developers and knows a lot about Rust way more than I do. If you are thinking about potential use cases or places in your application where you need some privacy, go and talk to Ain't Lee and John, who essentially their full time job is thinking about use cases.
00:25:31.194 - 00:26:27.820, Speaker A: So for every use case that you can think, they're going to relate to five or ten more and tell you about five or ten other people who are developing or thought of or working on similar use cases. And if all this is like that was overwhelming, it's like, I'm high in Enigma now, but this sounds cool, I'm not going to do anything on this one. Go and talk to Tor and Aaron and ways of getting involved into the Enigma community. I can think of at least of a handful. Whether it's starting a blockchain university that we can support, being members of the Enigma Collective and becoming ambassadors of Enigma around the world, contributing to the documentation or coding or developing use cases for Enigma, there's a bunch of ways how you can get involved. And with that, I'll finish my talk.
