00:00:03.410 - 00:00:36.094, Speaker A: All right, let's get started. Thank you everyone for joining today. We are hosting this workshop with Nader Debit from the Graph. The workshop will be building rich APIs on top of Ethereum with the Graph. If you want to connect with the team afterward, I invite you to join our discord in the specific sponsor channel. And in the meantime, if you have any questions, please post them in the Zoom chat and Nader will get to them as it goes on. I will let you take it away.
00:00:36.132 - 00:00:55.702, Speaker B: Nader, thank you for the intro. Really excited to be here. Kind of honored to be speaking at an event like this. So thanks for having me. And we have 28 minutes, maybe 30 minutes. So I'm going to try to fly through what I'm going to be doing. It's going to be a combination of a presentation as well as a kind of live coding demo.
00:00:55.702 - 00:01:16.790, Speaker B: And we're going to deploy an API on the graph. It's going to be querying NFT data from Zoro smart contract. So we'll go ahead and jump right in. So I'm going to share my screen and we'll go ahead and get this started. So I have a few slots, not a whole lot. I just want to introduce myself. My name is Nader Dabbit.
00:01:16.790 - 00:02:07.742, Speaker B: I'm a senior developer relations engineer or developer relations engineer at Edge of Node. And I've been here for a few months and I'm kind of fairly new to this whole Web Three ecosystem, but I've fallen in love with it and I'm really excited about all this stuff going on and I just really love learning about a lot of this stuff and building things. Really excited about some of the ideas for the future of the web and things like that. So one of the projects that I became really interested in was the Graph. And one thing led to another and I landed an opportunity to start working with Edge and Node, which was a company that started the Graph a few years ago. And they've since launched Edge and Node. And one of the things that we do is we help support the Graph protocol and that's kind of what I'm here to talk about today.
00:02:07.742 - 00:02:57.498, Speaker B: So the graph is a global API for DFI and web3. But in reality it's kind of like a global API for any public data, any data that is deployed to any decentralized network or any decentralized system. Now, some of the main use cases that people are working with today on the Graph are DeFi and they are a lot of the traditional type of DApps that you see. But in the future we definitely are excited to see a lot of more interesting things that people are already starting to build. Games, ecommerce, all types of stuff. And the Graph is kind of the best way I can kind of describe the Graph is it is a way to deploy decentralized APIs that make querying data from blockchains or any other decentralized networks. Very easy.
00:02:57.498 - 00:03:50.862, Speaker B: And it's kind of an abstraction that allows you to kind of get up and running with something that in the past would have taken you a lot longer to build. And it's also something that would be really tough to build in a decentralized manner. Whereas the Graph allows you to build and deploy these APIs in a decentralized way by taking advantage of the decentralized Graph network. And the network is something that we are currently rolling out as of the end of last year and we have a lot of exciting updates actually coming in the next couple of weeks. So right now there are two kind of main ways to deploy GraphQL APIs using the Graph. One is using a hosted service which is kind of what was deployed when the idea was fleshed out. It's to kind of get a lot of different companies and developers onboarded and so you can still deploy that way.
00:03:50.862 - 00:04:36.806, Speaker B: But what we are all now moving to is the decentralized network. Both of those things are available to work with. Now. We're rolling out some really exciting stuff though in the future for the user interface and things for the decentralized network. But what I'm going to be deploying today is to the hosted service because it's kind of the most mature UI that we have as of this workshop. So in the past, if you were building out an API or building a DAP on top of something like Ethereum, the problem that you might have run into is that you can make single requests to the blockchain. But let's say that you need some historical data, or you need some aggregated data, or you needed a performance query that is going to gather a bunch of data and maybe aggregate it, or do some map reduce or some other type of data access pattern.
00:04:36.806 - 00:05:27.438, Speaker B: Now, in the past you can't just make those queries directly to the blockchain. So what a lot of companies were doing, they were building out their own indexing servers. So they would take a smart contract, they would build a server and they would deploy it to something like AWS and then they would have to build out their own logic that would then go index all the data stored and serve it up in API. Now, the problem with that is that it first of all breaks the whole idea of what decentralization is, but also it's very resource intensive. Now you can kind of understand how you might want to have taken that route if there was no other options. But what the Graph is here to provide is that new indexing layer that allows you to deploy these different APIs in a decentralized manner and deploy a web app, a mobile app, it doesn't really matter. Even you can query these APIs from the back end.
00:05:27.438 - 00:06:24.046, Speaker B: But you deploy your API and you're now having access to all of this very rich data and giving a bunch of really great different data access patterns. And we've seen a lot of success, a lot of growth as of the time I made these slides, which is probably a little bit outdated numbers at the time, but we have over 10,000 lifetime subgraphs deployed by over 18,000 developers and we're seeing over 20 billion queries per month. And I don't know what the exact number is now, but that was kind of a few months ago and a lot of companies are using the Graph now. You've definitely probably interacted with some of these different apps in the past yourself. So things like Uniswap Foundation, Synthetics, all of these are using the Graph in production. And there are also different subgraphs that you can interact with that other people deployed on top of other smart contracts. So the compound is one of those.
00:06:24.046 - 00:07:23.134, Speaker B: You can go into the Graph Explorer, which I'm going to show you in a moment, and kind of see all these different open APIs and play around with them, build out different front ends on top of them, whatever you'd like. It's pretty nice. And once you've deployed your API, you can interact with it in the user interface that we provide, or you can just hit the API endpoint from your app. But it's really nice that you can kind of jump in here and play around with different queries, see what data is there. And if you've ever worked with GraphQL, you kind of know a lot of the benefits that GraphQL provides. But if you haven't, GraphQL is just a really, in my opinion, improved abstraction over on top of Rest and it doesn't really give you the Rest API. As a developer, you're now working with this new API, but it's very good for building modern applications because it allows you to have a lot more efficient queries and a lot more performance and a lot better developer experience, especially for client side developers, which in this case is going to be everyone because we're not building out the server side stuff.
00:07:23.134 - 00:08:15.826, Speaker B: All that stuff is handled for you by the Graph nodes. Now, the Graph network is the decentralized network and this was launched in December of 2020 and we're continuing to improve and iterate on that. And like I mentioned earlier, we have a lot of really cool stuff coming in the next couple of weeks, so keep an eye on that. But what we're going to be working with today is the hosted service, but you can really deploy either way as of today. And the way that the network is powered is with GRT, which are Graph tokens. And you can use these tokens in different ways depending on how you are interacting with the protocol as a curator or an indexer or even a subgraph developer. So let's say you have an idea for a subgraph, an API that you think other people would be interested in using you could build out the subgraph, you can deploy it and then you can actually earn GRT if other people use it.
00:08:15.826 - 00:08:44.998, Speaker B: So a lot of interesting ways to kind of be a participant in the graph network. And as you're going to see, we can build out one of these graphs in just a few minutes. So that's what we're going to do. So we have 20 minutes. I would like to initialize a new subgraph and deploy it and query it from the network and see if we can do this. Now the graph that we're going to be deploying is to query. It's going to be indexing and exposing an API on top of NFT data that is using the Zora Smart Contract.
00:08:44.998 - 00:09:12.280, Speaker B: Now these are the steps for creating and deploying a subgraph. You initialize the subgraph, you define the data sources, which would be the Smart Contract addresses that you want to index. You define the entities that you want to index from those Smart Contracts. So for example, let's say that you have an Ecommerce. A product could be an entity. So you kind of define that entity and then you form that entity and save it into the indexer. And you're going to kind of understand a little bit more about how that works.
00:09:12.280 - 00:09:59.410, Speaker B: You also define your data model, which is very closely tied to the entity. So the entity is actually defined in GraphQL. You configure your assembly script mappings, which actually define the business logic from the data that is coming back from the Smart Contract for what you want to save. And then once you're ready to make initial deployment or an update, you just deploy and within a few seconds, maybe a few moments, you're able to start querying and playing around with the API. So with that being said, we're going to be working off of a workshop that I've actually made open source. So I'm going to be using this as my boilerplate to kind of walk through. But you can also take this and build something yourself and I kind of encourage you to do that if you're interested in learning more about this.
00:09:59.410 - 00:10:30.030, Speaker B: So the URL for this workshop is in my GitHub. So GitHub.com davit three, building a subgraphworkshop. If you go to my GitHub, you'll see that at the very top, the third repository would be that one. I believe that we might be sharing that as well in the discord in just a moment anyway. But what we're going to be doing is we're going to be kind of like walking through this and in a very fast manner because we only have a few minutes. I'll probably be copying pasting code and stuff like that.
00:10:30.030 - 00:11:20.910, Speaker B: But if you're interested in this and you kind of want to try this out yourself, this is all here for you. And in addition to this README, which is kind of like the directions for doing this, there's also an existing code base that you can work with. So this Zora NFT subgraph code base is the contract and all of the subgraph code that we're about to write, you can kind of copy and paste that and deploy it yourself if you would like to as well. All right, so let's go ahead and get started. So before we kind of write any code locally, what we're going to now first go ahead and do is kind of define the graph that we want to or the subgraph that we want to deploy in the graph UI. So I'm here at the graph.com, I'm going to go to my dashboard and I'm going to click on Add subgraph and I'm going to call this ETH global NFTs.
00:11:20.910 - 00:11:59.290, Speaker B: All right. And I'll call this, like, NFT subgraph. And that's all we have to do. We're go ahead, we're ready to go ahead and create this. So I'm going to click Create Subgraph and we're given now an endpoint essentially that we can deploy to. We're given an access token and all we're going to need to now do is initialize a subgraph locally and then we're going to deploy to Davit three Eglobalnfts. So with that being said, we're done with the graph dashboard getting started.
00:11:59.290 - 00:12:51.894, Speaker B: We're going to go to the code base or the README and this kind of walks through everything you need to know. I'm going to be running through it fairly quickly. So you need to install the graph CLI which I already have installed and then you can use graph init to initialize a new subgraph and this is going to kind of generate a bunch of boilerplate for you. Now the command that we're going to run is graph init and we're going to say from Contract and we're going to pass in the contract and then we have really helpful command called Index Events. And Index Events is actually going to look for any events emitted from the smart contract and it's going to go ahead and create some boilerplate for us using the Abis. So this is going to actually generate a lot of nice code for us that we can then modify so we don't have to write a ton of code after this. So I'm going to go ahead and just copy that, go to my command line and here we are in empty directory.
00:12:51.894 - 00:13:26.694, Speaker B: I'm just going to paste this here. So we're saying graph init from Contract, we're passing in the network mainnet. Of course you can also pass in a test network like Ropston or whatever you'd like to work with and then we're passing in the contract name and then Index Events. And this is going to go ahead and scaffold everything we need now for the subgraph name. We already created that. So I can go back to here, copy Dabbit three E global NFTs and we're ready to roll. I can now just accept all the rest of the defaults because I've already kind of passed in all this stuff and we're ready to go.
00:13:26.694 - 00:14:19.378, Speaker B: So that's going to go ahead and create the code locally and we can go ahead and continue on. I'm going to skip over some of this again because of the time constraint and we're going to now go to our schema GraphQL. Now in the schema we're going to be defining the entities that we want to save. So with an ERC 721 you have an entity that's essentially going to hold things like the ID, the token ID, the content, Uri, metadata Uri and so on and so forth. So we're basically going to have a way to index and query all the different NFTs as a token and we're also going to have a way to index and query all the users and then have relationships between the two. So we don't only want to query the tokens, we don't only want to query the users. We might want to say I want to get all the tokens and all the user metadata or vice versa.
00:14:19.378 - 00:14:53.710, Speaker B: And the way that we do that is we use these different directives. So here we have a derived from directive where we're passing in the fields that we want to associate. So in this case we have owner and owner and then we have creator and creator. We also are using this at entity directive. And this is something again specific to the graph that is going to allow us to index this data and build out some code generation for us locally. So if we go back to our terminal, we should see that everything has been created for us. So we see a new directory called ETHGlobal NFTs.
00:14:53.710 - 00:15:28.890, Speaker B: All right? And what we're going to do is we're going to go ahead and open this up in our text editor and we're going to start writing some code. So I copied that GraphQL schema and we're going to use that in just a moment. And in the scaffolding, in the boilerplate that the CLI created for us, we have a few different main areas that you probably need to keep into consideration. One is the schema GraphQL. So I'm going to go ahead and open that. This is where we define all of our entities. We also have the main configuration for the entire subgraph at subgraph YAML.
00:15:28.890 - 00:16:26.142, Speaker B: And this subgraph YAML is really where we're kind of describing everything about this subgraph and I will walk through some of these properties in just a moment and then the last thing that we're going to look at in just a moment is the mappings and I'll talk about what those mean in just a second. Now before we start writing any subgraph configuration, let's go ahead and define the entities that we want. So in this case, we want to index and query tokens and users. And I kind of walked through how some of this stuff worked as far as these directives and stuff and these fields that we're working with and I'm going to go ahead and save that and open up subgraph YAML. Now the subgraph YAML has a bunch of configuration for the things that we're going to be working with. But the main thing to keep in mind is this data sources field and you can have multiple data sources, but in our case, we're just going to have a single data source. And what the graph does once you deploy this subgraph, it's going to kind of go into this data sources field.
00:16:26.142 - 00:17:25.506, Speaker B: It's going to look for all the addresses and it's going to then start indexing and looking at all of the different transactions for this address. And for every time that we find this address or transaction on this address, we're going to then invoke these event handlers and we're going to look for the events that have been emitted essentially. So this address is the Zora smart contract address. So if I go to Etherscan, we'll see that we have this address and this is kind of the data that we're going to be indexing. Now what we can do is we can now also define the start block because let's say we don't want to kind of go through every single block from the very beginning of Ethereum we might want to start at when this contract was deployed, which makes a lot of sense. We can do that. And let's see here, I can go to last and I can say, okay, the start block is going to be this one right here.
00:17:25.506 - 00:18:11.140, Speaker B: So I'm going to go ahead and copy that and I'll even go back to my code base here where we kind of see where we have the start block here. So I can do that just to kind of show you that it is documented here. So we have the start block and so we're working with this contract, the start block and we can continue on. Now the entities that we want to save are going to be defined here. And here we have a token and a user. So let's just go ahead and update that to say token and user. All right, so the last thing that we want to do is we want to define the event handlers that we want to basically interact with and save data from.
00:18:11.140 - 00:19:04.702, Speaker B: So by default, when we passed in index events, it went ahead and looked at the Abis and it saw any events like approval or approve for all and it went ahead and created these event handler boilerplates for us. The only two events that we're kind of interested in are token Uri updated and Transfer. Transfer is going to be kind of what's called when a token is minted or transferred and then the token Uri updated is going to someone changes the metadata from an NFT. This will also be updated and those are the two events that we really need to kind of get most of the data that we're interested in. So we've saved those, we've made those updates. And you see here, I have all this here as well. The next thing that we might want to do is we've already kind of created our schema.
00:19:04.702 - 00:20:03.654, Speaker B: We have our configuration here. What we now need to do is interact and create our business logic, you could say, or the code that we need to write to actually take the data that's passed into these events here. So here we see like when a new transfer is made, we have the address that it's from, probably the address that it's to, and an integer value that we're going to be working with in these mappings. We're going to be kind of handling those events. But before we do that, it would be very nice actually if we had some boilerplate code that we could basically use for type safety. And we can do that actually really easily by running a graph code gen. And graph code gen is actually going to go ahead and look into our schema and it's going to go ahead and create some really nice helper code for us that we can work with.
00:20:03.654 - 00:20:34.346, Speaker B: And if I go now to source, I'm sorry, I generated token schema and token. I'll see that we have some nice code that we can work with. And here if we look at our schema, you'll notice that this resembles our schema. Here where we have a token and a user. Here we have a token and a user. All right, so with that being said, let's go ahead and write our assembly script. Mappings and assembly script is to me like just very close to TypeScript.
00:20:34.346 - 00:21:23.840, Speaker B: So if you've ever written JavaScript, then this is really easy to pick up. So I'm going to go ahead and copy and paste this here. Again, we only have about like eight minutes so I'm not going to walk through everything, but let's go ahead and walk through one of these functions. When this handle transfer function gets invoked, we've defined it here. Whenever this transfer event happens, we're going to be passed in an index address, address and integer. We can kind of go here and see that we are taking this event and then we're basically going to check and see like we basically have that event information here and then all of the different values off of that are available on the event params. So we have the token ID, we have the content Uri and all these other different pieces of data that we can work with.
00:21:23.840 - 00:22:04.858, Speaker B: With that being said, the logic here, the first thing we do is we first go ahead and try to load that token and if it exists, we skip this and we kind of go ahead here and we kind of add additional fields. If it doesn't exist, we go ahead and create the different fields on that token and then we save it. And I think this is kind of the main functionality that you want to make sure that you have. If you want to save something, you just call save on the entity that you're working with. And this is what indexes and saves it into your API. And with that being said, we're kind of done. We can now go back to our code and we can run a build.
00:22:04.858 - 00:23:02.870, Speaker B: And if I run Graph Build, this should go ahead and create a build for us that we can then deploy. And if everything is successful, you'll see that you have build completed and we're ready to deploy. And before we deploy, what we basically need to do is we need to give some authorization from our local machine and stuff so I can say Graph Auth and then I need to pass in the access token. And here we have that access token right here. This was given to us when we created our subgraph. All right, so we've authenticated and now we can go ahead and run Yarn Deploy. And this should go ahead and deploy our subgraph and we should now be able to kind of test it out and just to kind of get an idea around the things that we're going to be querying from, this is what we're going to be querying, these NFTs.
00:23:02.870 - 00:23:45.430, Speaker B: So I like NFTs for these types of demos because it's nice visual data that we can kind of see and look at and stuff. It's a lot better than maybe just some financial data or something. All right, so if everything is deployed successfully, you should see some green check mark and some feedback here. And if I go back here and refresh, we should see that everything is ready. And we see that 12 million blocks have been synced and we're ready to start running some queries. And we see that we have 5494 entities that have been indexed. That means we have 5494 NFTs that we can query.
00:23:45.430 - 00:24:27.974, Speaker B: So let's go ahead and run a query. We're here in the graphical editor that were given to us by the Graph Explorer. And here we see that we have some Content Uris. And this is going to be kind of like the NFT data. We can also pass in arguments so we could say that we want to order direction like descending, and we can say order by ID or something like that or say Token ID. And we're given this in a different direction. So instead of getting the newest stuff, instead of getting the oldest stuff first, we're now getting kind of like the newer stuff.
00:24:27.974 - 00:24:45.146, Speaker B: So let's go ahead and copy this content Uri and see what's there. We have an NFT. Check out one more. Hopefully this is safer work. There we go. I think that's the same one. Yeah, that's the same one that's there.
00:24:45.146 - 00:25:17.622, Speaker B: So maybe if I refresh? Yeah, cool. So our data is coming back in the same way that it is being displayed on zora. That's pretty cool. It only took us a few minutes to deploy our subgraph and that's really it. I mean, one thing that you might do would be to kind of continue iterating. So if you want to make an update, you want to try change a few things, you can do that. All you need to do is make the updates in your code and just run Yarn Deploy again.
00:25:17.622 - 00:25:51.310, Speaker B: And maybe I'm sorry, you might want to do code gen as well if you've changed anything in your GraphQL schema. But anytime you want to redeploy, you just run Yarn Deploy and your deployment is updated. And with that being said, we're kind of getting close on time. So I'll go ahead and drop off or go ahead and end this presentation with a couple of resources, and then I'll be in the discord for the next 15 minutes answering questions. So the workshop is linked here. GitHub.com stabbit three, building a subgraphworkshop.
00:25:51.310 - 00:26:41.054, Speaker B: If you're interested in learning more about the graph, check us out on Twitter, the websites, our docs, and we also have a discord that I recommend checking out. If you're building out things and you want to ask any questions or you want to contribute back to the community, one other thing I would say that I didn't really call out here is we have a very great grants program. So if you're interested in making money and contributing to the ecosystem or being a part of it and getting paid for it and you have some ideas, then check out the graph website. Let's see here. Grants. If I can find the blog post here. This is kind of giving you an idea around how the funding mechanisms work and some of the things that we've contributed to in the past.
00:26:41.054 - 00:26:51.060, Speaker B: So it gives you a good idea around some other ideas that you might have. So, yeah, that's it for me. I just wanted to say thank you so much for checking out my presentation. And that's it.
00:26:52.710 - 00:26:56.920, Speaker A: Thank you, Nader. That was really great and so much information.
00:26:59.210 - 00:27:30.800, Speaker B: Yeah, I see a question that's actually really good, like 12 million blocks. Yeah, the reason that it was so fast is that we gave it a start block, first of all, so it did index that many blocks, but it only indexed the blocks that actually have transactions from that smart contract. So let's say I think we saw 4700 entities, so it actually ran 4700 different. It saved 4000 toms to the database, not 12 million.
00:27:33.350 - 00:27:58.380, Speaker A: Awesome. Yeah, I think that was the main question. And as you were saying, we're running out of time, so anyone please go to the discord channel. Nader is going to be there for the next minutes and we'll be happy to take your questions. And again, during the event, the team are usually there to support you. So as you start running into blockers, feel free to jump in the sponsor channels that's. Why they're there for.
00:27:58.380 - 00:28:06.950, Speaker A: Thank you so much for the session. Nadir thank you, everyone, for showing up. I'll wish you all a really good day. Bye.
