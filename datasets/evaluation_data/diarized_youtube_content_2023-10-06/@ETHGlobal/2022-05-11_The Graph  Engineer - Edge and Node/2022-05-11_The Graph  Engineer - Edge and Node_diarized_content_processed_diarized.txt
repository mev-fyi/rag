00:00:13.120 - 00:00:31.830, Speaker A: Okay. And we are live. Thank you everyone for joining us. For now, we'll be doing a talk about the graph here. If you have any questions, please leave them in the chat window below in zoom. You could also send them in the discord as well. Those will be answered after without further ado, you can go ahead.
00:00:32.280 - 00:01:19.236, Speaker B: All you. All right. Hello everybody. Today we'll be discussing about how to deploy a subgraph on how to deploy a subgraph on the hosted service, as in how to index a smart contract and then deploy a subgraph. We'll be also discussing as to why subgraphs are required, what's the processes of how does it look like and why do you need to use a subgraph to index your particular decentralized application, a particular blockchain. So, I hope you can follow along. And at the end, what we'll be doing is we'll be using the Open Zeppelin subgraph library to deploy an ERC 20 smart contract on the hosted service of the graph.
00:01:19.236 - 00:02:33.616, Speaker B: I hope you're excited. What I'll try to do is in this particular demo, as well as whatever I'm explaining, I would want you guys to also follow along with what I'm trying to say. And by the end of this particular 30, 40 minutes time that I have, I would want you guys also to deploy a subgraph with me. It is that easy and like that quick. So let's just get started, okay? All right, so, indexing blockchains using the graph basically, Eva, who's the director of the Graph Foundation, says that if you build a DAP for a community, but you start with a centralized component for the VCs, it's no longer a decentralized application. So basically, what is a decentralized application? A decentralized application is a DAP only if it does not have single point of failures initially. If you are not scaling that up and the DAP has just, let's say, has about 1000 people using it by that time, it works fine.
00:02:33.616 - 00:03:36.550, Speaker B: But when there is a scale that happens, you normally create software for scale, you create it for millions of people to use it, which eventually will be a thing for Web Three. Millions of people will be using it. And if you use centralized components, it will start breaking up. And you see that many times coming along when there is some kind of a major event that happens that there is breakage in some kind of applications which use centralized stuff in between them. And that's why from the beginning of your decentralized application journey, you should always aim to have applications which don't have central point of failure. Aka, you can also say that you should have a Web Three stack while you're deploying your decentralized application, you should have a Web Three stack which has decentralized values as well as decentralized infrastructure built in so that you can scale it through in the future. Right.
00:03:36.550 - 00:04:37.284, Speaker B: What the graph does, the graph is a way to actually the graph is in a way to the graph actually indexes your particular smart contracts and there are certain ways that we'll be discussing it does that. But why do we need to index a blockchain to get whatever you need in your particular decentralized application. So first of all, you have a decentralized application and it has a user interface that interacts with the smart contract, right? And whenever you interact with the smart contract, you are always publishing some kind of information that you want to show to your particular front end. How do you show that to the front end? One way is to have a centralized server. That is whenever you are interacting with the smart contract, the server will always have a check as to okay, this particular event was fired on the blockchain and I have to index that. First of all, this is very costly. Second of all, this is not scalable vertically as well as horizontally.
00:04:37.284 - 00:05:36.380, Speaker B: And third of all, it's not decentralized. Then again you become an application running on the ethereum networks instead of decentralized application. And for that same reason you should not use this kind of an infrastructure. The second way, which is definitely a little more decentralized, but it is not great in the user interface way that people might want to use is they start calling the blockchain itself for whatever information that they need. And like for example, if you are interacting with uniswap, just imagine how many people are interacting with uniswap every day. If they use this kind of a mechanism, then it's not possible to get the info uniswap page that you see every day at real time. It will take a very long time as well as it is super patchy and the code of this particular thing looks like this super shabby and that is the reason why you have to start using the graph for the same.
00:05:36.380 - 00:06:40.172, Speaker B: So what happens is that you again have a user interface and a decentralized application which has smart contracts that have events on it, right? And how the graph protocol is created is that it is listening to the events in the smart contract, listening to all those events, listening to call handlers as well in the smart contract. And we do all the indexing for you, for your particular smart contract so that whenever your decent sized application requires it in their particular user interface, it can be easily queriable via the GraphQL API. You'll be seeing how it works and stuff like that. But this is in general the architecture of how it happens. I'm not going to discuss this in detail because it is out of scope for this particular small talk. But in general what happens is that your decentralized application does a transaction on the smart contract which has an event, right, and the graph node is actually listening to that particular event and stores that particular information. So whenever stores that particular information via the mapping file.
00:06:40.172 - 00:07:32.224, Speaker B: So whenever you need that particular information, you can query that stored data via the GraphQL API that has created. So going from this you come to something so nice looking via GraphQL APIs like this. You never want to deal with this kind of infrastructure and keep on rupturing the RPC or the full node that you're using. Instead use the graph, create a subgraph, use the graph mechanism and directly you have this kind of query available for you at front time to be queried. So in general, I hope you have understood the Graph is indexing and querying protocol for blockchains in general, explaining it to a five year old. The graph does for web3 what Google does for web two. Whatever you want to search on the Google search bar.
00:07:32.224 - 00:08:32.624, Speaker B: Like if I want to search here, like Eat Global right here, I'll get it over here. Because all the information that Google requires or wants to see is scraped from the web, it is indexed and when you search it, it is just querying that particular stored information to show in the front end right to your particular thing. It is not doing at runtime. What happens is that the information is stored and it's just like when you search it, it's just queried in the back end and shown it to you on the front end. Similarly the Graph has but the Google does it in a centralized way of course, because it's a Web Two application. But what the graph does in a similar way, like what Google does, is all the information of the blockchain is actually indexed and stored in a database. And whenever you require to get that information, it can be queried via GraphQL API.
00:08:32.624 - 00:09:41.652, Speaker B: Of course, in a decentralized way, because the graph does it for web3 and it's called the web Three stack, so it has to go through the decentralized format of the same. Currently there is a Graph hosted service and there is a Graph network. I don't want you guys to be confused with that. So the Graph hosted service is you can call it a SaaS product in which there is one indexer that's currently running and it was introduced in 2019. So to say a product market fit in eventual like decentralization. So you can say the hosted service is when you have a subgraph deployed on the subgraph and it is being queried and there is this whole thing via a SaaS model. While the Graph network is the decentralized version of the Graphs hosted service itself, it was launched in June 2021, that is last year and it's working great as well, but only operates for ethereum subgraphs, right? And you can say instead of one indexer that is on the hosted service, there are about 160 indexers and here it's like a free service while the graph network is definitely decentralized.
00:09:41.652 - 00:10:48.664, Speaker B: And so you pay per query for the same. And eventually the graphs, like the whole ecosystem that we have, has its motive to eventually move towards the graph network itself and eventually make decentralized indexing and querying a reality using decentralized infrastructure which includes indexers 160 plus curators that are also in a very big number and delegators also in the network. And we can discuss about their functionalities separately. But I would suggest you to go through the graph docs to understand how the graph network works. I would really encourage you to do that because it's one of the really cool architectural design that's first time created by us in order to make decentralized indexing and querying a reality. So yeah, suggest you to check that out. But for now what we'll be doing is that we will be first of all understanding what is a subgraph and then creating a subgraph using the Open Zaplin Library.
00:10:48.664 - 00:11:59.632, Speaker B: You can know Open Zapplin Library is for limited type of subgraphs. I wanted to introduce you to that. But if you want to create your own subgraph for your particular decentralized application, there are other videos that you can check it out. So what is a subgraph? Right? So you can say that a particular block has lots and lots of information. I mean, you can say this orange information is of Aave, that red information in that particular block is of let's say Uniswap. The green information is of OpenSea and the blue information is of something else, right? All these are interactions that people do with ethereum blockchain and all of them are coupled and there are multiple blocks that exist. How do you make sure that the graph listens to your particular information, stores that in your particular way and gives you the right API so that you can query just this orange information or just this red information, or if you have created your own decentralized application, just that particular information that is via the subgraph.
00:11:59.632 - 00:12:57.188, Speaker B: The subgraph is you can say the subgraph is in a way a way to tell the graph node that hey dude, I need this particular information from the blockchain. Every time an event is fired via a smart contract of this particular address, please listen to it and store that in the database so that I can query it in the further use and further applications. I hope it's clear. A subgraph, you can say the graph is a marketplace and a subgraph is your particular way to index and store your particular application related to your particular DAP, right? I'll also give you a simple example. Info uniswap page, right? Everybody must have seen this. So we'll just go to the Info uniswap page. This information that you see that comes around in this particular format is also queried via the graph.
00:12:57.188 - 00:14:25.828, Speaker B: We'll just quickly search through it, right? Whatever information you see here see is coming from the graph, right? This particular information comes from the graph itself. So whatever you are seeing in the front end, the data is served by the subgraph created by the Uniswap team to this info page, right? And why is it necessary? I already told you, because without the graph, it would be really tough to index and get things out in the front. I hope this is clear to you guys. I'll also show the subgraph that the Uniswap team has created. Also, there are other projects which have created their own subgraphs. You can create your own subgraph for your particular application, but if you just need to create a dashboard or something like that, you can always resort to going to this particular Uniswap subgraph, right? This one you can always resort to just directly going to this particular API and querying whatever you need, right? Whatever information you need from the whole Uniswap application, which has different, different smart contracts. Either you can create your own subgraph, or you can also use the Uniswap subgraph that's created by the Uniswap team for your particular dashboard, all right? I hope this particular thing is informative to you.
00:14:25.828 - 00:15:46.348, Speaker B: And as I told you, what happens is Uniswap has smart contracts which have events, right? They have created a subgraph to be deployed so that they can see all this information, all this information and get all this information, right? So what they do in the backend is that they have this API and they just query via the GraphQL API, they just query and they get the results which they use in the UI to get whatever information. If you are creating a DAP of your own, then you will have to create your own subgraph for the same, right? And that's what we'll be seeing today. We'll be using the open Zappelin library to create an ERC 20 subgraph. I hope you are all set up with your particular computers. I'll just get started with the setup of our thing. Okay, so prerequisites for the same is that you need to have Graph CLI and Graph TS in your local environment installed globally. So I'll be doing it for you.
00:15:46.348 - 00:16:19.192, Speaker B: So first you have to go to this particular link. I'll be pasting that in the chat, go to the graph. We'll be deploying a subgraph, by the way, on the hosted service and not on the network. All right? So this is the hosted service, I'm on the dashboard. Let's create a new subgraph and let's name it Hack Money. Hack Money. All right, this is demo ERC 20.
00:16:19.192 - 00:16:22.920, Speaker B: ERC 20 subgraph.
00:16:26.000 - 00:16:26.750, Speaker A: Okay?
00:16:28.320 - 00:16:33.150, Speaker B: That's all. If you want to hide, you can also hide it, but right now I'm not.
00:16:36.600 - 00:16:37.424, Speaker A: All right?
00:16:37.562 - 00:17:52.700, Speaker B: So as I told you, you need to, first of all, install the Graph CLI and Graph TS locally, globally, I mean, Graph CLI. I hope you can do that. I'll again paste that link in this, and I hope you're following along with me. I want you guys to really go ahead and create your own first subgraph today. I'm telling you, it's not that tough it's rather very easy and that's why you should do it with me, right? So the second step is Graph in it I'll be using the example code. So for that I'll go for let's see, I'll be doing Graph in it from Example hosted server, right? The reason why we have this products thing is because you have a studio and the hosted service studio is used for the graph network and this hosted services for what we are doing. Right? This looks good for ethereum.
00:17:52.700 - 00:18:04.240, Speaker B: First of all, you have to give your GitHub username minus Pranav hackmoney.
00:18:07.320 - 00:18:07.764, Speaker A: All right?
00:18:07.802 - 00:19:05.396, Speaker B: So it will create a subgraph for me, this will just be a really copy clone subgraph. This is a Gravitar subgraph and in that itself I'll explain you what consists inside that particular subgraph and how you can create your own subgraph as well. It's not that tough, honestly. It's just like telling the graph node that hey, this is my contract, this is all the events that I want to know and can you please gently index that for me? It's that easy. And again, all shout outs to the Graph team for making the stack so easy for the developers, right? So first of all, you see there is a graph YAML file. You can say this is the introduction to your subgraph to the graph node. Telling the graph node that hey dude, this is my smart contract, this is where I want to deploy it.
00:19:05.396 - 00:19:29.230, Speaker B: It is mainnet. You can also do Matic for polygon, you can also do Phantom, whatever. But this one is Mainet. Then the address, right? The second thing is the contract address. This is the contract address. You can also check it out in the Ethereum Ether scan. This is the contract address.
00:19:29.230 - 00:19:52.576, Speaker B: This is how it looks like, right? This is what I'm actually indexing. And these are basically the events that I want to index. All right, I hope this makes sense. And this is the graph YAML file which tells the graph node that this is the information. This is the smart contract. This is where I want to do it and these are the events that I want to do it. Right, then you tell what I want to query.
00:19:52.576 - 00:20:44.388, Speaker B: What at the end I want to see in my particular API, right? So you define the schema, right? When you have a rest API being deployed, you also specify the schema. Similarly, here you specify the schema. Nothing different. And the last part, which is a little different and you have to spend most of your time, is basically this mapping TS file, right? This is where you convert the raw data that you get from the events to the schema file, this particular schema, right? This is where you convert that mapping TS. So you get the raw data, the event data. This is the event, right? New Gravitar is the event. You see that event and convert the raw data into a schema format that you want, right? So this is how you do it.
00:20:44.388 - 00:21:33.664, Speaker B: Today we'll be deploying an ERC 20 smart contract by the Open Zappelin team. And for that I stopped sharing my screen. And for that, what I'll do is first of all install the library terminal NPM install at the rate Open what was the name? I forgot. Let me just open Zeppelin subgraph, right? This is a library that's created by the Open Zeppelin team. You can search more about it here in the docs. See, this is the docs where you can search that. These are the subgraphs that they have created.
00:21:33.664 - 00:21:41.684, Speaker B: They are pretty standard, like they have pretty standard ERC 20 Smart contract. They also have pretty standard ERC 20 Smart contract subgraphs.
00:21:41.732 - 00:21:42.088, Speaker A: Right.
00:21:42.174 - 00:22:49.850, Speaker B: You can understand the importance of creating a subgraph for your particular queries. So by the time it is being deployed, the next thing that we have to do is we'll have to change the YAML file. So this particular YAML file will actually go ahead and what it will do is it will go ahead and index ERC 20 Smart contract, right, which has different credentials and everything. Since I have less time, I'll just go ahead and copy my previous ones that I created. So this is how it looks like there is a start block the ERC 20 Smart contract that I am actually indexing the address of that smart contract. And you can understand, like in the ERC 20 contract there is an approve event, there's a transfer event, right? And for this I don't even need to create a mapping file or a schema file. Why? Because Openzapplin already creates that for me.
00:22:49.850 - 00:23:22.706, Speaker B: It's still downloading. So what I'll do, it's still downloading. So yeah, we'll have to wait for a minute. Till then, if there is any questions. Who pays for the graph computation? It's paper query, Ben. So it's paper query. You pay when you query the APIs on the Graph network on the hosted service.
00:23:22.706 - 00:24:04.606, Speaker B: It is currently paid by the graph community. So that again, progressive, decentralization. We want to make sure people are comfortable with the hosted service and then they move to the network. Right, so, yeah, now that the Open Zappin library is here, so you can go ahead and see. Right? Previously we had to create the schema file as well as the mapping TS file, right. But now we just have to with the Open Zapline library for ERC 20 Smart contract, we don't need to create the mappings and schema file that is already created by the Open Zapplin team. Just like what they do for smart contracts, they have also created subgraphs for the ERC 20 contract.
00:24:04.606 - 00:24:29.398, Speaker B: Right? So what I'm doing is you can go to Open Zaplin no, not this one. This one. Open Zappelin subgraphs, right? And generated. See, you will already find the mapping file here. You will also be able to find the schema file over here. Right, this has both the things, so I don't need to do it right. They have already created the template.
00:24:29.398 - 00:25:04.230, Speaker B: So I'll directly use the template for indexing my ERC 20 contract by giving the address. I don't need to create the schema file, I don't need the mapping file. All that is already there. There are others that open Zaplan has already also created that you can look into by going to this particular website. All right? They have also created for owners contract ERC 721. So if you are creating, let's say, a ERC 721 product or project, you don't need to create your own subgraph, you can use them. Okay, so now what I'll do is deploy it on the hosted service.
00:25:04.230 - 00:25:44.340, Speaker B: Let's go back and see the instructions. First of all, copy this one and go here and access token. Yeah, it's this one. All right, let's first of all, auth again, I'll change this. So in the future I'll go ahead and change this so you guys cannot use it on my behalf. And lastly, I'll deploy it to the hosted service. Here we go.
00:25:44.340 - 00:26:24.680, Speaker B: I'll just copy the information from here. So I copy this subgraph name and yeah, we are all set. So the subgraph will be deployed to the hosted service and I'll be able to query the subgraph however I want it to be. Just waiting for the subgraph to be deployed. Yeah, it's deployed and you can see.
00:26:25.130 - 00:26:25.880, Speaker A: That.
00:26:29.540 - 00:27:10.030, Speaker B: Voila, it is deployed. Now, if I want to query the subgraph, I can do it like accounts, ID, whatever I want to. I can just query it. And if I want to use it in my react front end, I can just go here. Let's say I can also show you go here and let's try to query something. Meta block number. Let's do this one.
00:27:10.030 - 00:27:54.270, Speaker B: All right, let's query the block number using the API and see I can do it right. So you can use this API directly in your react front end or whatever front end and create great dashboards. Create great, like whatever you need to index to the front end using the graphs. I hope you understood the demo as well as had an insight as to how to create a subgraph and how easy it is, and the open Zapulin subgraph library as well. If you have further questions, feel free to tag me on Twitter and ask whatever questions you have. This is my Twitter ID. And I'm quite active there.
00:27:56.560 - 00:28:00.770, Speaker A: Great, thank you. Perfect. Yeah, we do have a question.
00:28:01.780 - 00:28:28.824, Speaker B: Please, go ahead. So is the hosted version also compatible with the API version 0.7? Yeah, it is. By the way, the graph network is compatible with all the API versions above 0.4. That's like 0.5 and above the hosted service is compatible with zero point above 0.5. Okay.
00:28:28.824 - 00:29:14.724, Speaker B: Because there was like I don't know, but the zero point 27, I think maybe it's still in alpha. You're saying zero point 27. Maybe I hit you up on Twitter or discord. Yeah, I think API version on the subgraph right? Subgraph YML file. I'm pretty sure it should be 0.7. I'll hit you up on Twitter or all right.
00:29:14.842 - 00:29:45.630, Speaker A: Yeah. If anyone has any more questions, I think we're losing. Yeah, if there's any further questions, we could take them over to Discord. We do have a global channel for that. With that being said, we do have one more talk with Fuel developing smart contract sway coming soon. Friends. I think we are losing you.
00:29:51.520 - 00:29:52.270, Speaker B: Great.
00:29:52.840 - 00:30:05.090, Speaker A: Okay. Yeah, I don't see any more questions in the chat either, so yeah, we'll love Discord for that. Thank you very much for the workshop and thank you all for tuning in. We do have another talk with Fuel development smart contracts in Sway, so feel free to tune into that.
