00:00:06.330 - 00:00:27.814, Speaker A: In this workshop, we will take a look at how the Graph provides critical infrastructure to web3. And you will then learn how you can create your own API that is tailored to your data requirements. My name is Ariane Arista. You can find me on Twitter. Webtree slipcharts. You can find me in discord. Slim chance 1699.
00:00:27.814 - 00:01:21.240, Speaker A: I'm in the eat global discord. If you need any help with any technical questions and you can also find me upstairs. We are right by the elevator, so drop by our boot if you need any help with your subgraphs. So let me first start with the question that everybody asks me why do we need index data? The blockchain is public, right? But most blockchains are optimized for writing data and not for reading it. And you can imagine the blockchain as a big public library where every day there comes a new truckload of books. And these are not sorted in any way, they're just added to the end of the shelves. And imagine that you go into this library and you want a list of the books with the highest word count.
00:01:21.240 - 00:02:07.270, Speaker A: If you were to do that using a traditional, like RPC, or just connecting to a blockchain RPC, you would need to check every single book, note down the word count, and then create your list. And this is where the graph comes in, as it allows you to index this data beforehand. Let's take a more practical example. A DeFi dashboard. Most of you are familiar with Uniswap, a decentralized protocol for swapping tokens. Some of you might also know that there's a dashboard called Info Uniswap.org, where you can get valuable charts and data about the protocol.
00:02:07.270 - 00:02:48.162, Speaker A: Now, if you were to retrieve this data directly from an RPC, you would need to do a call. For every single time there's a trade, the price would change. So you would need to check the price. And to get a chart like this, you would need to do millions of calls, which would be very resource, heavy read, expensive. So that's why we need to preprocess this data. It would also take you an enormous amount of time because you would need to process this in the front end. So again, index data allows you to have this data in real time.
00:02:48.162 - 00:03:53.190, Speaker A: In your application, all of the data that you see on Info Uniswap.org is provided by the graph. So you might think, who needs the index data? And we found out that that is everyone. We are currently seeing over 64,000 subgraphs have been created on the hosted service, and over 640,000,000,000 queries have been served by the graph. So why are people using the graph? Well, you can create a customized API that is tailored to your data requirements. This includes rich, sorted, filtered and aggregated data, and it allows for fully decentralized and serverless applications. If your DAP relies on a single centralized server, it's just an app.
00:03:53.190 - 00:05:23.050, Speaker A: The graph currently have two services, the hosted service, which is a centralized service run by Edge Node, one of the core developer teams at Graph. It supports 38 different networks near Polygon, BNB and 35 more. We are currently moving to the decentralized network where we currently support Ethereum Mainet. But we believe every DAP deserves decentralized, open APIs to retrieve their data from the blockchain. And we are delivering on that with the current ongoing MIPS program where we are incentivizing indexers to start indexing other blockchains as well. And that is a historic step forward not just for the Graph, but for the entire webtree ecosystem that relies on us and wants us to provide them truly decentralized open APIs and to dive deeper into why do we need decentralization in the infrastructure layer? Well, there's no central point of failure. You never have to call your back end engineer at Sunday morning saying that your server went down.
00:05:23.050 - 00:06:15.440, Speaker A: It is naturally load balanced. The Graph is infinitely scalable and it does so seamlessly. It is geodistributed service. We currently have indexers on every continent with over 200 indexes that are currently on the Graph network. You will never wake up to an email from your service provider saying that your server went down because your service provider have taken a no crypto stance. And most of all, well, this number is a little bit outdated now. We now have 220 indexes, all competing to deliver the highest quality of service to the lowest possible price.
00:06:15.440 - 00:07:31.476, Speaker A: And this is why I am excited about the graph and I hope also you guys will be excited to use the graph this weekend and going forward. So I'm going to stop there and I'm going to ask if you have any questions about the protocol. If not, we can move on to the next part. I'll dive into the subgraph so it's not incentivized for indexers to split their stake over multiple nodes unless they're also running the service in multiple geodistributed locations, which at that point, well, let them because they are just also providing better service to the network. Yeah, let's dive into I've touched a little bit on what the subgraph is. It has three major parts. The subgraph manifest here you define your network, the contacts you want to or the network you want to index, the contacts on that network, the start block, because when you get that blueprint to the indexer, they will start indexing the data from a certain start block.
00:07:31.476 - 00:08:42.330, Speaker A: It can be from the Genesis block or from any other block that you specify and what events, calls or other triggers to listen for on these contracts. The subgraph schema is where you define the data structure that you want to query and this is where you want to think ahead and make it as close as possible to the data requirements of your application. You would have the data structure, the entities, relations between the entities and so on. Then where you will spend the most time as a subgraph developer is in the mapping code. Here you map data from the events that you have specified and to the data structure that you also have specified here. And you would also do any kind of transformation. Aggregation of data will happen in the manifest or in the mappings, but that is written in assembly script, which is very similar to TypeScript, if you work with that.
00:08:42.330 - 00:09:37.302, Speaker A: So let's dive into it. Let's look at how we can create a subgraph in a very short amount of time. So this is the graph. In the graph you have access to what's called a subgraph studio, where you can log in with your MetaMask. I'm already logged in and created a few subgraphs on other workshops. If I wanted to create a new one, I click Create a subgraph. I want to create one for mainnet.
00:09:37.302 - 00:10:00.130, Speaker A: In our case, we want to index. In this workshop shop, I will show you how to index the Basi contract. So the board. Ape Yacht club. Let's call it basi. Bogota, for example. Now you have created this in the subgraph studio.
00:10:00.130 - 00:10:44.460, Speaker A: In the subgraph studio you can see some important information like it is currently undeployed. It is having a subgraph slug, which is the identifier you will use in some of the CLI commands. And you also have a deployment key that you use to identify yourself. So only you can deploy changes and upgrades to this subgraph. What you would do is you would first install the graph CLI. I've already done it on my machine. Then you will initialize your subgraph.
00:10:44.460 - 00:11:46.010, Speaker A: Let me duplicate my screen so it's easier. Now, a cheat code that I like to use is the index events flag. This will create a scaffold code where it's indexing all the events that it finds in a certain contract. It asks us which network or which protocol type that the contract is on. It's an ethereum contract. The subgraph slug, the directory and then which network is it on. And it's on mainnet.
00:11:46.010 - 00:13:20.984, Speaker A: Now the contract address. Save that maybe I'm not connected to the Internet. Let me try again. There you go. Now it's creating a subgraph scaffold for us with scaffold code. Just give it a second. It's a tough time to download things from the internet here.
00:13:20.984 - 00:14:26.592, Speaker A: I believe it maybe if everybody turns off their phones and their laptops. So there we go. No, we can add more contracts. I just wrote no here. So now we have a subgraph in CD Beisi Bogota. So here we can see the three files that I talked about earlier. You have the subgraph YAML, which defines what to index.
00:14:26.592 - 00:15:21.434, Speaker A: And in our case, we are looking at the base contract on Mainet. At this address, I will add a start block as well, because we don't want to wait around for it to index all the way from the Genesis block. So I'm adding that here we have the schema. It is currently pretty sparse. It's a simple indexing of all the four events on this contract. Approval, approval for all ownership, transferred and transfer. And then in the source file you have the mapping file where you see all of these entities are being stored.
00:15:21.434 - 00:16:16.430, Speaker A: And this has already been created just by using the index event flag. And I recommend using that as a way to populate your code with some boilerplate events and entities. Now we are ready to deploy. We can do grab cogen. Now if you go back to the studio, you can see that you would also authenticate your laptop first or your computer first. I've already done that. So I can go all the way ahead and do Graph.
00:16:16.430 - 00:17:52.648, Speaker A: Now it's uploading all the subgraph files to IPFS so that indexers can fetch that data and start using the subgraph as a blueprint to then transform raw blockchain data into the open API. That is a subgraph. But in our case we are just deploying to the studio, which is a centralized service and it's a place to stage and test your subgraphs before deploying it to the decentralized network that's deployed. Let's check it out, let's refresh the page. And the subgraph is already fully synced, already fully populated with data about every single event that has happened on the basic contract. So this is pretty cool. But what really we can do with subgraphs is then go back in and add aggregated data.
00:17:52.648 - 00:19:43.290, Speaker A: Say you want to find out, okay, how many board apes have been traded every month, or what is the total value of what other aggregated data you want to have in your subgraph. You can add that then to the mapping code and then redeploy. So, for example, we can go into the schema and say that we want to simply like now we have all the transfer events but we don't know when they happen. So we could, for example, have a timestamp and then to create the timestamp so you can access it from the mapping code, you would run Graph code gen again. Now it's created the type spores so we can access them in the mapping code. So now I can go in on the handle transfer and save this in entity dot. You see, now it's appearing here timestamp, event timestamp.
00:19:43.290 - 00:21:04.914, Speaker A: So now if I were to redeploy, that's all that is needed to add that to your subgraph code and thus you can reiterate and add more functionality to your subgraph. Is there any questions so far about writing your subgraph? Yeah, and you to read you change something in the Upgradable contract, you'd have to go and change, I guess where the graph is pointing to, which contract is pointing to, is that correct? Yeah. So the question here is if you are using upgradable contracts and in this case you can use something that is called dynamic data sources, which is a way to then change or add more data sources while the subgraph is in production. And that is used for, for example, upgradable contracts. Another use case is factory contracts, like say for example, Uniswap. Every time a new pair is created, you want to create a new data source, which is the new pool. And in that case you would also use dynamic data sources.
00:21:04.914 - 00:22:24.730, Speaker A: It's also called templates somewhere in the documentation, but it would be templates in the manifest, for example. But yeah, I can give you some documentation after this talk if you want to dive deeper into it's. It questions about subgraphs or creating a subgroup. Yeah, so that is, that is correct. And I will show you now how to query subgraphs. And I won't show you the front end code, but I will show you how you can create a GraphQL query and then you can use it depending on what language you're using in the front end application, you can then use that query. If we go back to the graph.com,
00:22:24.730 - 00:23:15.830, Speaker A: as I mentioned earlier, we have a Graph Explorer. Or if you have a decentralized network, you can find subgraphs that is on the decentralized network via the Graph Explorer. We also have the hosted service which has 30,000 Open APIs that you can query. I will show you how to query one of them. So let's for example, say we want to query the synthetics subgraph. For example, here you can create a GraphQL query to test your query. It's not a valid query.
00:23:15.830 - 00:24:30.180, Speaker A: You can save your queries and use them. Let me instead open the endpoint. This takes us to a GraphQL Explorer that allows you to create your own GraphQL queries using a simple checkbox type of interface. So you can, for example, find the Synth holders order by synth and you say you want to have the first ten. And now if the Internet is with us, we can get a query response. So there you have the first ten cent holders ordered by Send and you can yeah, with with our prices here on the hackathon, we have two tracks. One is creating a new subgraph, so a new Open APIs, as I showed you ten minutes ago.
00:24:30.180 - 00:25:16.770, Speaker A: And the other track is using an existing subgraph in your application. And here you see it is very easy to create a query. And the power of using GraphQL is that you can get exactly what you need. So no more than that and no less than that as well. You don't need to have this reiteration that you often have to do with SQL where you have to first maybe find the ID of something and then you need to go back in and find the fields that you are looking for. But you can get everything in one query. Yeah.
00:25:16.770 - 00:26:12.802, Speaker A: What determines so what determines the speed of that the subgraph is indexed? That's a good question. It depends a lot on how you write your mapping code. So there are some patterns that you want to avoid when you are writing a subgraph. For example, you want to avoid doing an excessive amount of eat calls. So in a subgraph you can do eat calls at a block and get the state of the chain at that block. And you want to avoid having an excessive amount. So you don't want to, for example, create a loop where you are looping through a lot of entities and for each of them doing a query to an RPC endpoint.
00:26:12.802 - 00:27:20.170, Speaker A: So you can do that in a subgraph, but you want to limit that. So each query takes around 100 to 200 milliseconds at a ruler tom, so a few of them doesn't matter. But if you are doing 1000 of these and you're doing that every block or every event or every transaction, it's going to be costly when you are indexing a subgroup. Yeah, so the question was querying a pass block or pass range. And unless you have deleted an entity in the subgraph, you can just find it directly here, like synth holders. This will also hold all the syntholders since this started indexing. But there's also a feature called time travel queries that queries the state of a subgraph at any block that you specify.
00:27:20.170 - 00:28:24.582, Speaker A: So say that I want all sent holders at a given block. I can get that using time travel queries. So here you would have block number and then you would write, for example, a block number here. So at this state, this subgroup started indexing at block 5 million and change. So I cannot query block 2333, but any number that I put in that is over this 5 million. Does everybody see my screen, by the way? Cool. Yeah.
00:28:24.582 - 00:29:16.830, Speaker A: What did you mean by cheap? I mean every query. When do you pay that? Yes, so again, we need to differentiate between the decentralized network where you're paying for queries and the hosted service, which is completely free. You will pay for query costs. First of all, with the subgraph that we just created, it's currently on the subgraph studio, which is the staging area, and that is also free to use once you deploy your subgraph to the main net. So let me see the Basi Bogota here. This is the one I just created. This has a development and query URL that you can find here that is completely free to use.
00:29:16.830 - 00:29:55.190, Speaker A: You can also use the playground to play around with it. But once you want to go into production and use this subgraph or use this API, you would go to publish and you would publish it on mainnet. And at that point you will also need a API key to query that subgraph and you will pay query and GRT. Yeah, I'm done. So, yeah, we can take that afterwards.
