00:00:06.090 - 00:00:51.786, Speaker A: Today we're going to be doing a 40 minutes workshop on building full stack DApps. And really my goal here is for people who maybe, you know, there's a lot of protocols in the space, there's a lot of cool projects coming out. But for me, when I first got started in Web Three, I kind of found it hard to find what a Web Three tech stack looks like right now. Like what actually works, what works well together and then piecing together how do I actually make all of these different pieces of the stack talk to each other. So that's what I'm hoping to accomplish today, so that you can leave ready for the hackathon. And I'm going to leave you with some resources that you can fork and clone and it'll help you get started a little bit easier, hopefully. So part of this is going to be a little presentation, kind of just going over some of the basics that I want to communicate and then we're actually going to walk through a project.
00:00:51.786 - 00:01:38.714, Speaker A: I wanted to live code it, but there's just not enough time with what I want to do. So we're actually going to walk through an existing project and then at the end, like I said, there'll be some resources for you to just get started with so really quickly, about Me I do developer relations at Edge and Node, which is the core developer of the Graph Protocol. I've been there for a few months and then I come from a more traditional software background. I was engineering at PayPal on the Checkout Experience for about a year and a half and then I worked at a startup for some time in between PayPal and where I am now, I also took a more traditional path to kind of my career. I studied computer science in college and I've been an educator for six or seven years. Before doing developer relations, I taught kids how to code back where I live, so I've always loved to teach. This is what I love doing.
00:01:38.714 - 00:02:20.150, Speaker A: And now with my job in Devrel, I get to teach adults. So that's just about me. So let's talk about the Web Three stats. So this definition is actually taken from a blog that Edge andOde wrote a few months ago, but it's really clear and really concise and one that I wanted to use here. So when people ask what is the Web Three stack? I think the best answer that I found is the set of protocols that enable you building fully decentralized applications. So that means from beginning to end, there's a set of protocols that allows you to build DApps in a way that there's not any layer where it's like, oh, this is AWS, or you're putting this in some standard database. So it's the set of protocols that allows you to build end to end fully decentralized.
00:02:20.150 - 00:03:04.630, Speaker A: So before we get into kind of what my stack looks like and maybe what I would recommend for now, or at least what I'm building with. I wanted to talk about some of the characteristics and some of the important pieces of the Web Three stack. So as we move on, this will make a little bit more sense. I know we are all really familiar with all of these, so I won't talk through them specifically one by one, but one that I do want to focus on is native digital payments. That's like the one thing that I feel like was really key when I first got into Web Three is when you think about Web Two. Someone put it this way and it made a lot of sense to me. In Web Two we put things like music and movies on the Internet and this whole concept of putting things that were in the real world on the Internet, like in Web Two.
00:03:04.630 - 00:03:37.326, Speaker A: And now we're doing the same thing with Web Three by putting money on the Internet and making money native to the Internet rather than some external thing. And obviously native payments is a huge part of Web Three and why we're all here. There's incentive mechanisms behind a lot of these protocols. So I just kind of wanted to highlight that. And then the other one that I wanted to highlight was self sovereign identities. So, you know, like just today, actually, this morning, the Supreme Court overturned Roe v. Wade and now it's up to states to decide if abortion is legal or illegal in their states.
00:03:37.326 - 00:04:35.086, Speaker A: And someone brought up a good point that there is a period tracking app called Flow. It's an app where women and people with periods can go on there and track their cycles as a way of kind of like no hormone birth control. And the way that it is now, in theory, if you are using this app, your data is owned by Flow and Flow has been caught selling your data. So in theory, right, if you are using this app and the government, like your state government wants to prosecute you for having an illegal abortion, they could take the data from this app and say, look, you usually get your period, I don't know, the 20th of each month. And for the last three months you didn't get a period and now you have a period. So obviously, this is a very niche and specific example that I'm giving. But it's a very real world relevant example today where other people owning our data and having access to our personal data that can then be used against us in the world that we're in now isn't really a world that I think I want to live in specifically as a woman.
00:04:35.086 - 00:05:00.490, Speaker A: Like going through all this. So that's another thing that's really important here. Okay? And now getting to kind of the building blocks that we're going to talk about here as we build out our stack. So kind of the primitives or the building blocks is obviously a blockchain and L1 blockchain development environment. So as I'm listing these out and you're hacking this weekend, start thinking about what you're using for each one. And obviously you don't need every single one of these. It just depends on what you're building.
00:05:00.490 - 00:05:36.082, Speaker A: All of these are specific to a project. But as I'm going through these and you have your idea, think about which ones you're going to need and then think about which ones you might want to use. So as we go through this talk, you can say, okay, I wanted to use this one, but she talked about this. And then you can go back and look at the, do research between them, figure out the trade offs and then pick the best tool. So as I'm going through these, that's what you should be doing. So an L1 blockchain development environment and I'll go over examples of what these are right after this. File storage, off chain data protocols, API for indexing and querying identity, a client oracles.
00:05:36.082 - 00:06:07.920, Speaker A: And then I just grouped all these other protocols. And this is actually also from the edge of node blog post that I'll link at the end if you guys want to read more thoroughly. So I have this little visual here. This is what you should take a picture of if you are going to hack. So this kind of lists out all of the different options in each part of the stack that I just described. So as you're thinking through your project and you're like, for example, I need something for, I need an L two or a side chain, what's going to be the best one for my specific project. You can look through this list and a lot of these people are here actually sponsoring so you can go learn about them.
00:06:07.920 - 00:06:52.154, Speaker A: But as you guys are all taking pictures, you'll see there's lots of options for all the different parts of the stack. And the thing that's important to remember is that there's no one tool, that's the end all be all and it's not the answer to every single thing. You should always take a look at all of the options and decide what's the best one for this specific use case and this specific project. So what I want you to do is don't walk away from this talk being like, oh, what she said is what I should be using in all my projects. This is what I'm using for some specific projects. And you should take this stack and adapt it to your specific project needs, okay? And then some that weren't included in that picture that I do want to include specifically for this hackathon, because they're both sponsors, is Live Peer and Lens. So live, peer, decentralized, video infrastructure.
00:06:52.154 - 00:07:19.980, Speaker A: It allows you basically to build in live streaming to any DAP really easily. So if you're familiar with NextJS, you can literally just enable live streaming and then like Minting Video NFTs just from an API route. And then Lens Decentralized on Custodial social Graph for building composable social applications. There's QR codes there. There's like guides to start each if anyone wants to take a picture. These aren't going to be on another slide, so I'll give you guys a second in case anyone wants to. Okay, cool.
00:07:19.980 - 00:07:57.390, Speaker A: Okay, great. So here's what I'm using for this project that we're going to walk through together. It's called Web Three RSVP and we'll go through it together. But basically the project is a way for you guys know, Eventbrite. It's an events platform where people can create events and then users can go on there and RSVP to different events. The only thing that's different is that you as a user, you have to deposit some Ether and then you'll get that back when you show up. Kind of like what you had to do here, I think, right? Like hackers had to deposit some and you get it back when you actually show up.
00:07:57.390 - 00:08:19.126, Speaker A: And it's basically just to combat the problem of all the lists filling up really fast and then people don't actually show up and these places are half empty. So that's what we're going to go through. So for my l one, I'm using ethereum. For my side chain. I'm using polygon. For the RPC provider, I'm using Inferior in this specific project, but I've recently started using Anchor, and I really like Anchor a lot. For my dev environment, I'm using Hard Hat.
00:08:19.126 - 00:08:35.194, Speaker A: But I've also started using truffle recently. Really recently. It's newer and it has some advantages over Hard Hat for specific projects. So I'm going to start trying to use Truffle more. For off chain storage. I'm using IPFS and web3 storage. For indexing.
00:08:35.194 - 00:08:53.158, Speaker A: I'm using the graph. For identity. I'm using Rainbow Kit and Coinbase wallet. And we're going to talk through what this means in a second. But Rainbow Kit is a way for you to easily offer your users basically that Connect Wallet button at the top. And then for the actual wallet, I'm using Coinbase Wallet, which is also newer. So I was kind of testing that out and have been experimenting with that.
00:08:53.158 - 00:10:00.660, Speaker A: And then finally, for my client, I'm using ethers. JS So now I'm going to walk through this with you guys and what this looks like. Okay, so I'm going to walk through the setup. Let me double check my time, how much time I have. Okay, cool. So I'm going to walk through is the text big enough? Okay, I'm going to walk through the setup for so really what I want is if you're here and you're like, I have a really good idea, but I'm not sure of the nitty gritty. Like, how do you set up an RPC? How do you make your smart contract talk to your front end? How do you do all the little pieces that make everything come together? That's what I'm going to walk through here.
00:10:00.660 - 00:10:50.258, Speaker A: So real quick, I'm going to just show you an overview of the contract. It's so small. Okay. There. Sorry. So like I said, in this contract, we are setting up a struct because in this contract, multiple people should be able to create multiple events, right? So this is the way that we're storing the events in the struct is where we're storing all the things that are related about the event. So for this specific example, we're saving an event ID, the address of the person who created the event, the timestamp of the event, the max capacity of the event, the deposit that needs to be sent in order to RSVP to this event, and this event data CID.
00:10:50.258 - 00:11:24.594, Speaker A: So this event data, CID is related to off chain storage. So, you know, to save things on the blockchain, it costs gas, right? So for this project, I wanted to minimize the number of items that I'm actually saving to the blockchain because, for example, the event description, I don't need to save that on the blockchain. I can save that off chain, save money. It doesn't have any effect on the security or the functionality of the app. So that CID is just for you guys to know that's related to off chain storage. And we'll talk about that in a second. But it's basically the IPFS hash, the reference to our data that's going to come from the front end.
00:11:24.594 - 00:12:02.094, Speaker A: So then we create this mapping where'd you go, okay, so this mapping so this mapping maps the ID and ID to a struct. So here what we're doing is we're creating this collection. It's basically like a dictionary where for every ID, you can find all the information about the event that we just listed, the timestamp, the deposit, the max capacity. And then here we have our functions that do the different things. The first one, the most important one, is creating an event we pass in all of these information, including the CID. So that's something to note. So remember, we're going to have to compute and get the CID before actually calling the smart contract function, which we're going to do in the front end.
00:12:02.094 - 00:12:31.420, Speaker A: So just hold off on that. But then when we do have that, we're going to pass it into this function. This right here creates a unique ID by hashing together a few of the different arguments. Because what you want to do is in a hash table, obviously you want to minimize what are called collisions, where basically you want to have a unique key to every definition. So if you have two that have the same key, you're going to be referencing perhaps the wrong one. So one thing to combat that is to get a really unique ID by hashing together some of the parameters that get passed in. So that's what I do there.
00:12:31.420 - 00:13:27.462, Speaker A: And then here is where you actually create that entry in the dictionary by calling this. And then one thing that you'll notice in my contract is I have a bunch of custom events. So here I'm writing custom events. And the reason why I'm doing that is because in order for my indexing and query layer, which in this case, I'm using the graph in order for it to understand what's going on in my smart contract, the data that I want to expose needs to be exposed via events. So the data that you want to index and query can only be accessed via events. So that's why, you'll see, you might be like, why are you creating an event? And then also, I mean, like creating the actual event with the function. Why are you calling the function Create Event, but then also emitting an event called event called new Event created that are basically exposing the same data, right? But it's because my subgraph, it doesn't have access to my functions, it only has access to my events.
00:13:27.462 - 00:14:01.590, Speaker A: So that's another thing to know if you want an indexing and query layer. And what that does is it allows you on your front end and in this app that I'm going to show you, it allows you to build a dashboard of past events, events that I've RSVP to, events that I've created. It's a way for you to ask questions about your data from this contract. So, for example, how many events have I RSVP to, how many events have I created? And with that data, you could build a dashboard for each user to let them know what events they have coming up, what events have already passed. So in order to do that with the graph, you need to do it via events. So that's what these events do. And you'll notice at the end of each function, I'm actually emitting those events.
00:14:01.590 - 00:14:39.634, Speaker A: Then I have a function called Create New RSVP, where I pick the event based on the ID. So someone, the user passes in the ID, I go locate that one and I say, all right, from now on, we're calling this my event. Then they have to pass in the minimum deposit. The timestamp has to be such that the event hasn't already passed. They get added to this array of RSV peers. And now we have this array of RSV peers, right? But now in order for them to get their ether back, we need to have a mechanism for them to be confirmed or for them to be checked in. So that's what this next function does.
00:14:39.634 - 00:15:15.994, Speaker A: So again, we pass in an event ID, so we know which event we're talking about. We have to make sure that the person calling this function is the owner of the event. Which is why in our struct, when we defined this, we added that in. So all of these little pieces that are there, they're there for a very specific reason, right? And then we loop through the RSVPs. We loop through the RSVPs. So this is Confirm All Attendees, and it just confirms every single one, one by one. So we made this function because, for example, if you guys are all here, and let's just say 50 of you guys are Svp'd, and I counted, and there's exactly 50, I don't want to have to manually confirm everyone one by one.
00:15:15.994 - 00:16:01.632, Speaker A: So I might just want a button. Your users might just want a button to do Confirm All. So that's what this one does. And then down here, we have Confirm specific attendees where you pass in the event ID and then the address of the specific attendee. So let me just show you guys what this looks like on the front end for you to have kind of like a better idea of how this looks. Okay, so this is what it looks like. Here is where the events that get created end up.
00:16:01.632 - 00:16:49.572, Speaker A: And if I connect my wallet and we'll talk about how to do this too, I just kind of want to show you so you know what I'm talking about when I say certain things. If I go here to my RSVPs, I haven't RSVP to anything actually, with this wallet. So let me do that real quick. But this is where it'll show up. And you do this using the graph, using your indexing and query. So if I go to RSVP, actually, I don't know if I even have matic, but I'll just try this real quick. Okay? I don't have enough Matic, okay, but let's just say I RSVP, then it would show up in my dashboard, and then I would be able to create an event.
00:16:49.572 - 00:17:05.960, Speaker A: This is the app that we're talking about. So now let me switch back to the code, okay? And then finally withdraw and claim deposits. I'm not going to walk through this. This is basically for the event owner, for people who didn't show up, for me to take your money because you didn't show up. So I get to keep your deposit. That's what this function does. So now this is our back end, right? This is our smart contract.
00:17:05.960 - 00:17:50.910, Speaker A: But now we need a way to do everything else in our client application. So I'm going to open that code up right now too, okay? Important things to know. So Create Event is the file in our next JS project. That's that page where someone creates an event. God damn it. Here, let me show you. I forgot to show you that.
00:17:50.910 - 00:18:09.206, Speaker A: Oh, man, I stopped the server. Okay, well, it's like a form where you just put in the event name, the event description, all that stuff that we talked about, but some things that aren't in our smart contract struct. So remember, we didn't have like, event name. We didn't store that in the smart contract. We didn't have event description. We didn't store that in the smart contract. But still, it's stuff that we want to show in our app.
00:18:09.206 - 00:18:34.952, Speaker A: But the only difference is that we're not actually storing it on the blockchain. We're storing it off chain with web3 storage. And that's what I'm going to walk through real quick. So let's go down here real quick. So here is this form, blah, blah. So here, event, date and time is where the person fills in the date fills in, the time fills in the max capacity, all that stuff that I talked about. And we save this all in state, react state.
00:18:34.952 - 00:18:55.864, Speaker A: And then what we do is we pass the stuff that is not on chain. So to web3 storage with this call right here. So it's just the next JS route. It's called create event. So let me just pull that up so you can see what that looks like. So an API create event. So it's just a function that initially checks the request.
00:18:55.864 - 00:19:27.080, Speaker A: If it's a post, then it passes it down here. I won't go through this like line by line, but basically all it's doing is it's taking the body of the request and it's pushing it to web3 storage and it returns you a CID. Remember, that's the CID. That's like an IPFS hash reference. And this one is a little longer and a little bit more complicated, I would say, because we're passing in an image, too. So it's not just text, but if this was just text, it would be much simpler. But here I'm passing in like an image, and that's how you get that really cute image.
00:19:27.080 - 00:20:00.446, Speaker A: So let me just show you here. So in create event. Okay, here. So in Create Event, this is where we make that API call. So we say, hey, we've saved everything in state. Here's the body, here's everything that we want to store off chain, the event name, event description, link, and the image. So now that we've stored the stuff off chain, once that response comes back as successful, like, yes, this has been posted to web3 storage.
00:20:00.446 - 00:20:20.692, Speaker A: It's up on IPFS. Now we actually need to make the call to execute the function on the smart contract and pass in the CID. Because remember, in our smart contract, it wants that CID. In order to do that, let me show you real quick. Create event. It needs a CID. So that's why we did this in this order.
00:20:20.692 - 00:20:46.640, Speaker A: Because in order to call this contract, it would be missing an argument if we try to do it the other way. So first we make the API call to web Three storage. Then it returns a CID. And then down here, once it's successful, boom. So once it was successful, then we call Create Event and we pass in the CID. And everything else has already been passed in. And yeah, there we have that.
00:20:46.640 - 00:21:17.956, Speaker A: And then when we're talking about identity, I said I'm using Rainbow Kit and Coinbase wallet. So it's really easy to set up. And I'm actually not going to walk through it because what I have is something better. I created a starter repo where you can just clone it and it has rainbow kit, wagme, tailwind, Next, and a wallet connect function already set up. So the only thing you have to do and I'll walk through it, is basically import your abi. Oh yeah. So for people who don't know how to do that, I did it inside of a Utils folder.
00:21:17.956 - 00:22:07.690, Speaker A: So you just create a folder at the root of your project, call it whatever, I call it Utils, and then you make the name, whatever name of your contract, JSON, and you just paste in the abi from your smart contract. But that's important. So now if we let me show you guys this real quick. Front end starter with this front end starter that you can clone and use for your project, there's this function here called Connect contract. Can you guys see that? Yeah. Connect Contract. And the only thing you have to update is you have to pass in your contract address.
00:22:07.690 - 00:22:47.044, Speaker A: And then once that's in, you'll be able to so for every page that you're on in NextJS, if you want to call a function on your smart contract, you need a way to make that communication between your front end and your smart contract. This utility function does that. So instead of like manually writing this in every file, we abstract this out to a Util and then you can just import that. So here if I go to index, I've already done it for you. So it's already imported. And the only thing you have to do when you're actually ready to call your function and I also added it down here is you just do const. This is called your contract or whatever, and then you call that function that we've created and then that way you can start calling your function.
00:22:47.044 - 00:23:31.580, Speaker A: So this is called RSVP contract. It'll be your contract here and that way you can use it on every page in your Next JS project and you don't have to write the logic to actually connect to your contract that way. Okay, I know that was a lot of talking. Does anyone have any questions up until this point? Okay, so yeah, what you're seeing now is a template. So let me actually, maybe I'll just run it so you can see, but it basically just has everything installed. So it's still like a blank canvas. This is what it looks like.
00:23:31.580 - 00:24:10.010, Speaker A: So it has rainbow kit wagme. Next. JS Tailwind CSS So I'm on the wrong network, but this is a button that'll allow you, I don't know, maybe this is the right network, but it'll allow you to have the Connect to wallet button right away. So you don't have to write any of this logic yourself. And yeah, basically you can just start developing the logic to connect to your contract. Is there the logic to connect to your wallet is there the logic that's built into NextJS that's really great, like routing and all that good stuff is already there and then you basically just have to import your own, you know, is just copying and pasting that into the utils file and then you can start developing. So let me go back here now.
00:24:10.010 - 00:24:49.014, Speaker A: So is there anything I didn't talk about? So let me get into the graph a little bit more. How many of you guys already know how the graph works or you're familiar with it? So so actually not that many people. Okay, cool. So the graph, like I said, I'm going to talk about it six minutes. So the graph is an indexing and query layer and it basically allows you to efficiently read data from the blockchain. So, you know, right now you can go to Etherscan and you can I don't know, what's a popular project, crypto punks. Sure, you can go to any contract, right? And you can read information about that contract.
00:24:49.014 - 00:25:23.202, Speaker A: You can read data from the blockchain, but it's very one at a time. Let me give you an example. Image hash, I don't know. So yeah, you can read data from the blockchain as it is now, but you kind of got to read it like one piece at a time. But if you want to make more sophisticated queries or to ask complex questions about your data, like you want to understand a relationship. So for our thing, maybe I would ask how many users RSVP to this event and showed up, or how many people created an event, have created more than ten events in the last year. Those types of queries you can't really make manually as it stands right now, just directly from the blockchain.
00:25:23.202 - 00:25:59.022, Speaker A: So the graph allows you to do that so it reads all of this data that you're interested in. It indexes all of this data for you so that it's efficient query times when you do ask questions and then it allows you to make queries with GraphQL. So if you're already familiar with GraphQL, it's the same exact query API. You can ask questions the same exact way. And yeah, as a developer, basically what it allows you to do is hydrate your UI with data from the blockchain. And when you're developing smart contracts, a lot of your data is coming from the blockchain that your front end user is going to want to know. Like, for example, what is the deposit amount for this event that's on the blockchain? And we need a way to actually read that.
00:25:59.022 - 00:26:37.270, Speaker A: And the way that we're reading that in this specific case is through a subgraph. So I can show you guys that real quick too, just so you guys get an idea. So if you write in JavaScript or in TypeScript, it's going to feel really familiar because the mappings are written in assembly script and it's basically just like writing JavaScript. And telling and writing the logic for like, I'm interested in this data. This is how you get it, and this is how you construct an object to then send it to your UI. So let me go here subgraph. Okay, so you should be able to understand this because you just saw the whole smart contract.
00:26:37.270 - 00:27:10.950, Speaker A: So let me show you in source mappings. Okay? Is this really small? No, it's not. Okay, so when a new event gets created on the blockchain, right, we need a way to display this on the front end. So the way we do this is we create an object. Maybe I should show you that first. We create an object in our schema. So those who have maybe experienced with databases or with GraphQL, you know what a schema is, but for those who aren't familiar with the schema, it's basically you just defining the objects in your model, if that makes sense.
00:27:10.950 - 00:27:40.050, Speaker A: So, for us, the objects in our model are an event and an account, an RSVP and a confirmation. These are entities that are unique to our project. And if you make a project with a graph, obviously these will be unique to whatever you're building. So, for example, here, this means that I want to be able to query for an event and I want to be able to query for all of these different properties in an event, right? So this is what we're defining. This is like the dictionary. We're saying, I want to be able to do this. But now in the mappings, you actually tell the program how to get this data.
00:27:40.050 - 00:28:15.786, Speaker A: How do you actually form this and construct this object to then return it to your front end? So this is what's going on here. So we say, okay, when an event is created, this is what should execute in order to build that object. For me, I can't really see from here. Yeah. So like the event ID, you can get it from the parameters, the event owner, you can get it again from the blockchain who's the person sending this message. And all of these things you can get from the transactions that were made on the blockchain that you just wrote in your smart contract. But here you're just saying this is the logic for how to find it.
00:28:15.786 - 00:28:42.562, Speaker A: You're just giving them a map. This is how you get it. That's all you're doing. And then, for example, the stuff that is off chain, so stuff that's on IPFS, it's not on the blockchain. There's still a way to get it because there's an IPFS API that'll allow you to do the same thing for IPFS. And the only difference is that because this is metadata we're passing in the event CID so that the program knows where to actually go and fetch this stuff from. And what we're doing there is we're literally just going through this object.
00:28:42.562 - 00:29:25.058, Speaker A: So JSON is a big object and then it has different properties where it's like Name, description. I think those are the two things that we stored off chain image and Link. So all we're doing is we're saying, hey, if this IPFS hash is true, if it's valid, if it doesn't come back as a falsey value, then go ahead. And because it's an object, it's like one level object, there's no nested objects. I'm just going to ask questions and I'm going to say, hey, look for a value called Name, look for a value called Description, look for a value called Link and photo. And when you find it, save it here. And then if these come back to be truthy values again, so if these don't come back as false, like if they're not null or for some reason we spelled it wrong, then this is how we actually construct the object.
00:29:25.058 - 00:29:46.886, Speaker A: We're saying, my event, the big entity, the specific property equals that. That's the construction, that's how you actually make that object. And this just repeats for all the rest of the stuff that we're doing. But that's the big picture. Okay, almost done. Last thing I want to talk about present. Okay, cool.
00:29:46.886 - 00:30:32.018, Speaker A: So we kind of talked about what the stack that I use is. Again, you should take this and apply it to your own project based on what you're building. But I did want to highlight the bounty. So if we talk about building something with the stack that I just referred to, there is what? 204-065-6868 thousand dollars in bounties just with the specific stack that I talked about here and actually forgot to mention radical. But radical is a decentralized GitHub. So they have this product where you can host your code and there's literally a prize for $1,500 just to a project that hosts their code there. You can still host it on GitHub if you want, obviously to keep it forever and for collaborators to use, but you can literally just host your code on GitHub and be eligible for this bounty.
00:30:32.018 - 00:31:01.220, Speaker A: It's like the easiest bounty ever. And then here is that quickstart front end repo where you can just clone it and that way you'll have Rainbow Kit, Wallet, Connect, Wagme, Ethers, Tailwind, next JS. You can clone it. No, sorry. You should fork it first, then clone it and then do your thing on there. I'll pause because people are taking pictures real quick. Yeah.
00:31:01.220 - 00:31:54.798, Speaker A: Does the graph index it? Like, does the graph like listen 24/7 for events? Yes, exactly. So the graph, maybe I should have shown that, but the graph, in addition to the schema that you define in the mappings, you also define events to listen to and basically in order to guarantee that you always have the freshest data and you don't have stale data. Like if today we make a query and there's ten events on the platform, but I create three in the next hour, we need a mechanism to refresh basically and reindex. So the way that you do that is you define some events. So for example, for my contract, right, the event was new Event created. So then we say, okay, when new event created gets emitted, I want you to re execute the mapping which rechecks and loops through all of the metadata and does it over and over and over again until we have the freshest data. So, yes, so that's that front end repo.
00:31:54.798 - 00:32:15.158, Speaker A: I see one more person taking a picture, so I'll let them do it. Got it. Okay, cool. And then the other really cool thing that I want to talk about here is 30 Days of Web Three is something that's being hosted by Women Build Web Three. We're a dow that's pushing forward female engineering talent in Web Three. But this is open to everyone. It's education that's going to be open sourced when it's ready.
00:32:15.158 - 00:32:54.530, Speaker A: It's launching in two weeks and it's a 30 day curriculum to basically hold everyone's hand through developing a full stack DAP and kind of help them build that reference and that mental model for what it means to build a DAP. So that hopefully by the end of this, you'll be able to say, okay, I have my own idea and I've done this once. I just kind of got to remix the contract because now I learned how to do everything else. I just got to remix and tweak small parts, but I know how to build a full stack DAP. And actually I want to pull this up real quick so you can see it kicks off in two weeks and you can register at 30 Days of Web Three XYZ. It's open to everyone. It's free.
00:32:54.530 - 00:33:33.458, Speaker A: And the cool thing is that you're going to build the project that we talked about in this mini workshop here of like, building a Web Three RSVP app. And the even cooler part is that there's going to be live workshops by all of these different amazing developers and developer advocates that are like experts in their specific part of the stack and they're going to come do live workshops like this, but more specific to whatever part we're talking about that day or that week. And this was also built with really amazing support from these orgs and these protocols. So, yeah, there's some FAQs at the bottom TLDR. Yes, you can join if you're a man or anyone can join. It's going to be open source. The time commitment is 30 minutes a day.
00:33:33.458 - 00:34:03.840, Speaker A: This is all online and asynchronous so in theory, you can do this in a weekend if you want. You can do this in a week. We just are dubbing it 30 Days of Web Three because that's the pace that we're going to go at and the pace people can follow if they want to follow along. But you'll be able to do this at any time by yourself. You cool. And then finally thank you. That was it's.
