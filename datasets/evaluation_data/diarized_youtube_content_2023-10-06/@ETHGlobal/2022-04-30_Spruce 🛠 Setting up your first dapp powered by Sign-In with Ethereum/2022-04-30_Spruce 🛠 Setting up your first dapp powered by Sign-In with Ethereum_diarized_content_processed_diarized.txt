00:00:08.410 - 00:00:09.600, Speaker A: No, I'm I'm fine.
00:00:11.010 - 00:00:11.374, Speaker B: Cool.
00:00:11.412 - 00:00:12.398, Speaker A: Let's get started.
00:00:12.564 - 00:00:12.846, Speaker B: Yeah.
00:00:12.868 - 00:00:24.670, Speaker A: Thanks for coming. This is the signing with Ethereum Workshop. So we are going to give you a short intro on Spruce and sign up Ethereum and then go into some live coding sessions.
00:00:25.130 - 00:00:25.494, Speaker B: Yeah.
00:00:25.532 - 00:00:50.662, Speaker A: So we at Spruce. Okay. I'm Oliver. I'm leading the signing with Ethereum Initiative at Spruce. And this is Sam who is a software engineer at Spruce, heavily involved in wallet integration and so on. So at Spruce we let user control their data across the web. So today for keys are primarily used for signing transactions on Ethereum.
00:00:50.662 - 00:01:37.242, Speaker A: But for us at Spruce it's actually more than this. So we see that keys have a larger potential. And one of the use cases where we see keys in wallets being used is for example, for signing with Ethereum. But we also have a decentralized self sovereign data storage solution which is called Kepler, where you can use the sign with Ethereum login assertions more downstream to get access to your self sovereign data. Signing with Ethereum is a standard for signing in users with your user controlled keys, with your Ethereum keys. More specifically, the standard was developed by Spruce together with the Ethereum Foundation and ENS. We followed a very inclusive process.
00:01:37.242 - 00:02:15.270, Speaker A: So we hosted community calls. We have an Ethereum improvement proposal. We have a discord group where we can exchange thoughts and facilitate discussions and problem solving on signing with Ethereum. So you're also invited to join the discord to participate in the discussion. So what is signing with Ethereum? It's used to sign into an application. And an example of how this works, you can go to login Xyc. There's an example that shows you how to use sign in with Ethereum with your Ethereum web3 wallet.
00:02:15.270 - 00:02:58.194, Speaker A: Essentially, it's a very simple process. So first you have to connect your wallet, then you have to create a specific sign in with Ethereum message. It has few fields that I will talk about in a few seconds. And then you get assigned by your web3 wallet and then you essentially authenticate it after you verified the signature and verified the fields. So it really helps you with contextualizing interactions. So I think it will become more and more important. Currently, most DAPs they are just connecting the Ethereum accounts, connecting their wallets.
00:02:58.194 - 00:04:04.822, Speaker A: But you actually also want to log in the users to remember things about the users, like preferences and so on. So you want to get from connected Carl that has to restart the game every time to the session send that continues the game from the last safe state. So before we had signing with Ethereum, the standard, the EIP, we had a couple of different options of how this can be achieved. So these on the left side, there are a few examples of how this was used by different apps. And the goal was really to just merge all these approaches, come up with a unified approach. And on the right side you can see how a signing episode message looks like that complies with the standard. And so really like the standard ERP 4361 was really the job was really to get things done basically to just unify the different approaches so we can actually get better UX from wallets.
00:04:04.822 - 00:04:44.406, Speaker A: So if having a standard like this, we would allow wallets like MetaMask or Tally to render nicer UX when a user wants to sign in, but it also adds security. Specifically, we have some means that allow you to mitigate phishing attacks. So, for example, if you go to Malicious.com and malicious.com generates a sign in message, they would put like Microsoft.com as the domain in it and the wallet needs to sign the message. Then the wallet can detect you are malicious.com,
00:04:44.406 - 00:05:45.898, Speaker A: but you want to sign into another application actually and can warn the user with a UI with an error message, which is very similar to what is done at the moment with browsers and TLS certificates. What flows are currently supported with Simon with Ethereum? So there are two main approaches. So one is what we call direct authentication flow. That's really like, you go to an application, a website, and then you use your MetaMask directly, or more generally your web3 wallet directly to sign the message. We have also another approach, which is we are running a community governed identity provider where I can use existing authentication protocols like Opened, Connect, but this is more like bridge the world between web two and the web3 worlds. I think that's basically it for the introduction. I think we can just go to.
00:05:45.984 - 00:05:48.186, Speaker B: The live coding session because that's the.
00:05:48.208 - 00:05:59.678, Speaker A: Reason why most folks are here. And I will hand over to Sam who will show you a demo of how you can do that. Basically the direct authentication approach where you.
00:05:59.684 - 00:06:02.000, Speaker B: Use MetaMask to sign in.
00:06:14.610 - 00:06:54.598, Speaker C: All right, let me make this a bit bigger. Okay, can you guys see this? Maybe one more. Okay, let me also kill this one. All right, so what I want to show you guys is Login XYZ. So this is the live site. Login XYZ is just a simple implementation of signing with Ethereum. So maybe a bit about the stack.
00:06:54.598 - 00:07:20.740, Speaker C: There's a front end built using Svelte and then the back end is just like a simple express API server. It uses MySQL as a database. And instead of using Login password for user management, we're using Sign with Ethereum. So let's dive in. We could do quick example and then we can just walk through this example. So go sign with ethereum. I hit it.
00:07:20.740 - 00:07:42.010, Speaker C: Let's see. Ask me to sign in with my account, I hit sign and I could vote for my favorite emoji. So previously I voted. It remembers that I voted. So I'm going to hit reset. I'm going to vote again. I'm going to vote for Rainbow submit and it's updated.
00:07:42.010 - 00:08:11.054, Speaker C: So this is the live site. So let's look at our local example and walk through it a little more. So in our local example, let me sign out. There's a couple of security features in the sign out theory message. Like Oliver mentioned. Maybe the first one is a nonce. And that happens, see? So your client should grab a nonce from the server.
00:08:11.054 - 00:08:36.298, Speaker C: This kind of prevents replay attacks every time you're signing. The nonce should be different. So if I go actually, it's probably worth inspecting. Look, network requests. So if I go and connect with MetaMask all right, let's see. Sorry. Of course.
00:08:36.298 - 00:09:02.854, Speaker C: Live demos. I forgot to do something. Anyway, I wanted to show you guys the request to grab the nonce. It's happening locally. It makes a request to this express endpoint to grab the nonce. Just a random number, and it's saved to the session. So if I go back to MetaMask and I sign this message, it logs me in.
00:09:02.854 - 00:09:56.546, Speaker C: So what's actually happening? So, let's see. We're making a sign in request, so we're sending our message and we're sending a signature. So if we look at our server and we look at the sign and request, so we're able to reconstruct the message and verify it, basically by checking the chain. So we basically are able to reconstruct the message using this package CV message. You can reconstruct the message in a variety of ways, but what we do in the core part of this is validating the message, maybe in an existing, like, maybe legacy username password. Maybe we'd hash the password and then say, okay, it doesn't match in our database here. We're checking it on chain.
00:09:56.546 - 00:10:29.982, Speaker C: We're checking the signature. We're checking it's valid if it is valid, or if it's not valid, maybe they just throw an error. Also, we check the nonce that came back so the client reports the nonce it used, and then we checked to make sure that's the same nonce that was signed. So this is just like some simple validation. Make sure this is the user we want. And if it is, we issue a cookie and then we continue with whatever user flow we want. So in this user flow, we're voting.
00:10:29.982 - 00:11:11.680, Speaker C: So now I'm logged in, I got back a session cookie. I'm able to vote, and my vote ideally counts. I introduced a bug on the local instance, so I cannot submit it's. Trying to figure out right before this, but I assure you it does work. So that's kind of just a simple example of how we use this, just like a simple server. So with that, maybe one other thing, kind of what Oliver was mentioning. Some of the work we're working on is, oh, man, so many things.
00:11:11.680 - 00:11:55.322, Speaker C: Just like domain validation. So this is just a way to test MetaMask features. So if you did a sign in Ethereum request, you can have a wallet. This is basically a test build just to see if this works, where you can parse the message, display it in a different way and then sign in versus just a regular signing flow lets users see different things. And then also maybe if there is like a phishing attack, maybe the domain is a mismatch. The wallet can warn the user and say, hey, this signing request, you're not just signing a regular message. There's something up with this message.
00:11:55.322 - 00:12:16.130, Speaker C: It's presenting to be a regular sign request. You can get some warnings and then if you want to sign, you can really agree to it and then sign. So there are a lot of benefits to using this for maybe the ecosystem overall. So with that, I'll leave it to Oliver cool.
00:12:16.200 - 00:12:18.580, Speaker A: I think that Microsoft works.
00:12:41.950 - 00:12:42.314, Speaker B: Right?
00:12:42.352 - 00:13:22.770, Speaker A: So this was the direct presentation demo that uses the web3 wallet directly. So there's no central party in between or something like that. There's also nothing really stored on chain. The interface is really just between the app or the application and the web3 wallet. The nonsense validation generation needs to be handled either by an API or by the DAP itself. I also want to show you a demo of the Open Connect flow. And for this we have prepared a social connection for the off zero marketplace.
00:13:23.350 - 00:13:34.730, Speaker B: So essentially I would try to now switch to the other one, get locations.
00:13:40.510 - 00:13:45.740, Speaker A: My mouse on the window. Try to hit.
00:13:50.830 - 00:13:51.846, Speaker C: Do you want to.
00:13:51.968 - 00:13:53.120, Speaker A: Is it full screen?
00:13:55.570 - 00:13:56.222, Speaker C: Yeah.
00:13:56.356 - 00:14:09.570, Speaker B: Okay. But I think now I have the problem that I can't really see what I'm doing. Okay, let me just mirror my screens. Maybe that's easier.
00:14:25.300 - 00:14:26.640, Speaker A: Is it now mirrored.
00:14:34.020 - 00:14:35.250, Speaker B: So when I.
00:14:38.370 - 00:14:39.920, Speaker A: Write cool.
00:14:40.370 - 00:14:51.794, Speaker B: Okay, so this is the off zero integration. So you can just log into your off zero tenant and then it's really.
00:14:51.832 - 00:14:57.286, Speaker A: Easy to configure signing with Ethereum with off zero. So essentially what you can do is.
00:14:57.308 - 00:15:25.040, Speaker B: You can go to the marketplace, search for Ethereum here. It's a social connection and there's a description of how you would configure CV. So sign up with Ethereum with your off zero application. I can create a new one. Let me just example, just say CB demo. Let's say it's a single page application.
00:15:31.110 - 00:15:32.674, Speaker A: That what I want to do is.
00:15:32.792 - 00:15:43.560, Speaker B: To add the sign up Ethereum login to this CB demo. But first I need to find the social connection here.
00:15:45.130 - 00:15:53.034, Speaker A: So for this, it's actually required to so since this is a community governed Opend Connect provider, that offset connects to.
00:15:53.072 - 00:15:55.194, Speaker B: You would need to register the just.
00:15:55.232 - 00:16:03.150, Speaker A: Created application as an Opend Connect client in the community governed Open Connect provider.
00:16:04.210 - 00:16:09.790, Speaker B: So I can just first click add integration.
00:16:15.570 - 00:16:29.686, Speaker A: What happens is actually that the Opend Connect provider would give me a client ID and a client secret that I need to enter here in the social connection configuration. But first of all, I need to.
00:16:29.708 - 00:16:41.820, Speaker B: Get my off zero domain. And since the registration is based on.
00:16:42.670 - 00:16:44.166, Speaker A: A simple post request.
00:16:44.278 - 00:16:52.554, Speaker B: I can use Curl to register a new client. The ODC server would give me the client configuration.
00:16:52.682 - 00:16:55.470, Speaker A: So essentially, most importantly, the client ID.
00:16:55.540 - 00:17:10.020, Speaker B: And the client secret because this is the stuff that I need to use for the CB configuration. So it's under connections here.
00:17:11.030 - 00:17:15.442, Speaker A: So I disabled Google because by default Google sign in is enabled.
00:17:15.586 - 00:17:25.320, Speaker B: But since you want to use CV, we enabled CV. One SEC.
00:17:27.310 - 00:17:28.698, Speaker A: Since I didn't configure it in the.
00:17:28.704 - 00:18:53.464, Speaker B: First place, I might need to find here again. So add integration already exists. Okay, then I can manage it here. And interesting save changes. And now what is really cool about off zero is that you can actually sorry, I think I did something wrong now. So the wrong browser profile, it connections here. Okay, so I have actually two browser profiles and that's the reason why I got confused here.
00:18:53.464 - 00:19:19.820, Speaker B: So we apologize for that. Client ID and client secret save.
00:19:21.390 - 00:19:24.250, Speaker A: So now my CV connection is configured.
00:19:24.830 - 00:19:52.120, Speaker B: With my CV demo application. I can go to my demo application, go to Quick Start and can just download the configured example for off zero using the CV social connection I just created.
00:20:09.490 - 00:20:22.280, Speaker A: So Offseero provides sample codes for any kind of front end frameworks. Also for supporting different types of architectures, single page applications, but even APIs and.
00:20:22.650 - 00:21:41.820, Speaker B: Just normal backend applications. Oops, so this and then I think I need to also take care of one last step. Since I'm running the demo locally, I need to configure this. It's basically to allow the demo to run from localhost. You need to set an allow list loud callback here and think that's not necessary. Save changes. NPM run surf did work.
00:21:41.820 - 00:21:47.650, Speaker B: Now.
00:21:52.020 - 00:21:55.210, Speaker C: It let's run that.
00:22:04.210 - 00:22:42.050, Speaker B: Yeah, now it works. So if I go to my browser and hit up the page, then this is like the fully configured of zero example. I go to Login and it didn't. Okay, maybe I need to connections. For whatever reason, it's not enabled here. Why is it not enabled here?
00:22:43.300 - 00:22:46.224, Speaker A: It's also like the demo effect, but.
00:22:46.262 - 00:22:47.856, Speaker B: Normally you should be able to just.
00:22:47.958 - 00:23:17.690, Speaker A: I think I hope you get the idea that you can then just add CV as a social connection to your either existing offset application or to a new offset application. And then you have basically an open connect provider that allows you to authenticate with CV and that's it. So that's the openly connect flow compared to the direct authentication flow where you don't need this identity provider in between.
00:23:24.480 - 00:23:31.820, Speaker B: Yeah, sure. So let me just go back to the presentation.
00:23:36.340 - 00:23:37.936, Speaker A: We have five more minutes.
00:23:38.118 - 00:23:41.360, Speaker B: Maybe I can just also conclude the presentation.
00:23:47.460 - 00:24:30.268, Speaker A: Our documentation is on docs login Xyc if you want to learn more about it. So we have CB core packages in different languages, TypeScript, Go, Rust, et cetera. The core packages have a couple of functions. So it's really like therefore creating a signing with a serial message for verifying a message and for passing a message. So it's like the core functionality and then the launch generation and the verification, like triggering the non certification, et cetera is something that you would need to build either in the front end or in the back end. And we also have a bunch of integrations switch browser.
00:24:30.364 - 00:24:33.584, Speaker B: Can you actually see if you go to docs locking XRC?
00:24:33.632 - 00:24:35.028, Speaker A: So you can see here we have.
00:24:35.034 - 00:24:37.808, Speaker B: The core packages in TypeScript, Rust, LXC, et cetera.
00:24:37.904 - 00:25:11.884, Speaker A: But we also have integrations with existing authentication frameworks like next off JS or like you saw the off zero example. We also have added support to different applications which are very common in web Three. So I think a lot of people, a lot of Dows are using discourse. You can use CB. We created a CB plugin for discourse. You can authenticate sign in into your discourse using sign up ethereum. We also have a few Bounties for the hackathon for Bounties.
00:25:11.884 - 00:25:58.780, Speaker A: So one is for creating new use cases that use CV and we have two Bounties for adding CV to existing projects. And we also have a bounty for extending either our CV core libraries or our integrations, like the discourse integration for example. Yeah, sorry that the demo didn't work so well, but I hope you got the idea and you can try them out. If you go to login XYZ, all the code is in our GitHub repositories. So that's basically it. So we want to open the floor for questions if you have some otherwise you can find us also in the hallway outside. Thanks for your attention.
00:25:58.780 - 00:26:24.072, Speaker A: You any questions? Okay, if there are no further questions.
00:26:24.126 - 00:26:26.030, Speaker B: Then thanks a lot and see you see around.
