00:01:33.900 - 00:01:54.904, Speaker A: Sorry. Awesome, everyone. How you doing? My name is Rahat. I'm a developer advocate over at Polygon. So I decided to do this workshop a little bit differently. This is the only slide you will see. That's it.
00:01:54.904 - 00:02:03.210, Speaker A: Everything else is code. Is that cool? I said screw it. We don't need slides. We just need code. You guys are hackers. You guys are developers. This is what we're going to do.
00:02:03.210 - 00:02:29.988, Speaker A: So thank you for coming to my talk. This is all about taking a Web Two browser game and and turning it into a play to earn game. We're going to do something real simple. How many people have played Rock, Paper, Scissors ever in your entire life? So you're aware of the mechanics of rock, paper, scissors? Cool. Awesome. So let me just make sure my code is what I want it to be. Okay? So we got this rock, paper, scissors game here.
00:02:29.988 - 00:02:42.232, Speaker A: Just a simple react application. Nothing big, nothing's going on. All right, if you want me to hit Rock, please put up a Rock Scissors. Put up a peace sign. Paper. Put up a hand. All right.
00:02:42.232 - 00:02:53.612, Speaker A: See to paper. Scissors. Rock. All right. It looks like rock wins. All right, hit Rock, nobody wins. Come on, guys.
00:02:53.612 - 00:03:11.296, Speaker A: All right, one more time. Rock, paper or scissors? Paper Scissors. Okay. All right. Paper again or paper? We lost. Okay, whatever. So nothing huge going on there, right? It's a simple rock paper, scissors game.
00:03:11.296 - 00:03:27.976, Speaker A: This is what the code looks like. Real quick, I'll show you right now. Components. I call this component web two game. So it's just this gigantic switch case with a bunch of if statements. If, paper, Rock, whatever, somebody wins. And I'm just like putting a bunch of things in state.
00:03:27.976 - 00:03:50.604, Speaker A: This is probably not an optimized version of this code. Very crappy version of it, but it gets the point across, right? We have a rock paper scissors game. It exists in the browser. Now, what if we wanted to add some elements of Web Three into this? So I'm opening this up. I call this the Web 2.5 game. Call it Web 2.5
00:03:50.604 - 00:04:35.532, Speaker A: because all we're doing here, we're slapping a web connect wallet connect function onto this. Nothing huge going on. I have this handle wallet connect function pulling the Ethereum object out of the window. What does that mean? As long as I've got a browser injected chrome extension, like MetaMask or something like that, I'll have the Ethereum object, and I can pull that out the window as long as that all is good. I am just doing a couple boilerplate stuff of taking the Web Three provider from Ethers, requesting access to the user's account and getting their address. So let's update that. Let's remove the Web Two game from in here and add the Web 2.5
00:04:35.532 - 00:04:54.480, Speaker A: game. Wrong thing. Okay, come on. Doing this with one hand is, like, wrong thing to do. Okay, cool. So now we got this wallet connect. Right hit connect wallet.
00:04:54.480 - 00:05:08.430, Speaker A: Great. MetaMask pops up next. Connect. Wonderful. All it took was two lines of code. Right, now we slapped a Wallet sign in with Wallet. Can anyone tell me what's wrong with this? Just shout it out.
00:05:08.430 - 00:05:45.444, Speaker A: Exactly. It's not inclusive because not everyone uses MetaMask. People have mobile wallets, people have hardware wallets. If I wanted to go beyond this and make sure that I'm actually being inclusive and bringing people in, I think there was a workshop earlier on Wallet Connect. Definitely recommend using that instead. But for the purposes of this, I'm just kind of looking at one use case, particularly for an injected wallet. But we always want to make sure we're being as inclusive as possible to many different types of people.
00:05:45.444 - 00:06:30.020, Speaker A: So for now, all I'm doing is just I'm saving this address into state. Nothing big. Again, just works the same. Still a web two game, right? How would I turn this into a web three game? Let's take a look at some smart contract code. So this is very simple smart contract. There's not a lot going on here, but just to kind of visualize what's going on, what I want to accomplish here is that I want to take this Rock Paper, Scissors game. I want people to wager some amount of matic on the polygon network and if they lose, if they draw, they lose that matic and if they win, they take the entire amount of matic that's in the pot for themselves.
00:06:30.020 - 00:07:23.596, Speaker A: Right? So a little bit of a gambling rock Paper Scissors implementation of a game, right? So how does this work? So I've got the contract, the game, I've got a private string that is going to take care of who the winner is. Actually, I don't think I'm using this, but whatever. This unsigned integer, which is the balance, which is going to keep track of how much money is actually in here, I've got a few functions. First is this Receive money function is just to send some money over to the contract. Now, I made this public for one reason. I just want to make sure that if at any point in time I decide to put this smart contract onto the blockchain or whatever, I can load it up with money in case if I need somebody to load it up with money so people can actually earn some stuff instead of winning nothing. So just making that a little bit easier.
00:07:23.596 - 00:08:05.620, Speaker A: Using this payable function, solidity has payments baked in natively. You don't need to import any other smart contracts, anything. Everything is like accessible with this payable modifier. So all I'm doing is taking this balance up here, this public balance, and updating it with this message value. Where do I get message value from? Whenever somebody uses their wallet, their MetaMask or anything like that, I can extract the value of whatever amount of money they've wagered or put in there and keep track of that value with this. This message value. Super useful to know in Solidity.
00:08:05.620 - 00:08:55.712, Speaker A: Now I'm doing this get balance function. This might be redundant, but just to kind of give you an idea of how something like this would work, it's just a very plain kind of function. Tells you the current balance of the amount of money that's on this contract, right? Nothing useful. Now we get to the fun part, this play function. So literally all I'm doing, I'm still allowing my front end to decide who the winner is and if they won, if that's true, then I'm going to take the address of the person who is interacting with the contract. So that is available through me, again through this message object. But now it's not a message value doing message sender, which is going to give me the address of whoever is interacting with this contract.
00:08:55.712 - 00:09:41.136, Speaker A: Right? Now I'm going to take that and just going to transfer some money to them. Whatever the current balance is, I'm going to give them that money. If they won, they didn't win. I'm just going to call the receive money function up here and they lose the matic that they wagered, right? So nothing too over detailed. A couple of things wrong with this. One thing I learned from a talk I once listened to is when you're building anything, you're building a SaaS product, you're building a smart contract, whatever your first version of it is, probably not going to be the best version of it. You just want to get something working right.
00:09:41.136 - 00:10:16.188, Speaker A: This works. It does in theory what you need it to do. You can extract money from someone. If they win, you can give them some money. Originally I was thinking about doing the whole game engine on chain, which would have taken me more than 20 minutes, so I didn't do it. What I would do if I wanted to make this completely on chain. Now in JavaScript I'm able to go into an array and just sort of randomly pick out some value like rock, paper, scissors for the opponent value.
00:10:16.188 - 00:11:02.584, Speaker A: In Solidity you cannot do anything randomly. You can do pseudo random numbers, there's different methods, but there's no actual way to do truly randomization or random number generation inside of Solidity. If you wanted to do that, there are some tools out there like chainlink will give you a verifiably random kind of like generated number, things like that. But that has to happen off chain somewhere. So just to kind of emulate that, decided to let you know what, let's let JavaScript kind of handle that part. But if you were to actually go into production with something like this and you want like real random number generation, definitely recommend looking at chainlink. I do not work for chainlink.
00:11:02.584 - 00:11:17.840, Speaker A: They did not endorse this at all. I just like their product. Just wanted to make that clear. So we've got this. Let's deploy this. I've got this here. If I'm deploying from Remix, I go here.
00:11:17.840 - 00:11:37.210, Speaker A: Compile. Looks like there's no problems. I'm going to copy this abi code real quick. Just drop that in here. This Abi JSON, why that's important, I will talk about in just a second. But that's there. And let's go ahead and deploy this injected web three.
00:11:37.210 - 00:11:58.424, Speaker A: Cool. This is my test matic. I don't have this much matic. I wish I did. But let's deploy this. Hit deploy, my MetaMask pops up, and we'll confirm this. And this is being deployed onto the Polygon Mumbai network.
00:11:58.424 - 00:12:31.352, Speaker A: It's one of our test networks for any time you want to test out your smart contracts. Putting things out there. How many people have just worked with Solidity in general, worked on the Ethereum blockchain? Cool. A bunch of you. Okay. Doing things on the Ethereum blockchain and on the Polybomb blockchain, exactly the same. Every tool that you learn, every if you use Hard Hat Foundry, if you use Truffle, if you use a Remix, all of that maps one to one.
00:12:31.352 - 00:13:03.648, Speaker A: It just takes usually one line of configuration. If you're using Hard Hat or Truffle or something like that, all you do is just change the RPC endpoint from the Ethereum endpoint over to a Polygon Mumbai network or Polygon Main net, if that's what you want. But at the end of the day, everything is EVM compatible. Everything you learned stays the same. And again, just maps one to one. That's why it's like we've been really focusing on a good developer experience. We don't want you to learn anything new just to use another blockchain.
00:13:03.648 - 00:13:33.100, Speaker A: Everything maps one to one. This is specifically using our proof of stake blockchain, which many people know as a sidechain. That is not the only product that we have out today. In a few other days, we actually launched a few other things like Polygon Edge. There's a lot of work that the Hermes team is doing as well. And there's a whole suite of products that you can use to build on top of Ethereum. But, yeah, today we're just focusing on our proof of stake blockchain.
00:13:33.100 - 00:13:51.564, Speaker A: So that is out. Let me see where that is. Okay. Sat in here. Contract deployment. Let's view on block Explorer. So this is a testnet transaction.
00:13:51.564 - 00:14:09.210, Speaker A: Great. It was a success. Everything looks good. Let's actually take a look at this deployed contract. So these are some of the functionalities that I could just test before I actually put it into my front end. But hit balance right now says zero. Right.
00:14:09.210 - 00:14:48.550, Speaker A: Remember, I made that receive money public just so I can put some money in here. Let's go ahead and put three matic in here. So if you've done any sort of deployment or work on Solidity before, you'll know that the smallest unit inside of Solidity in reference to Ether is Way. Works the same way on Polygon blockchain. Smallest unit of Matic is also Way, which is like one to the 18th. Zero power or something like that. So three matic that converts over to this much way.
00:14:48.550 - 00:15:13.340, Speaker A: Let's copy that value and drop it in here. Okay, so let me just do 3123-4678. 910, 11, 12, 13, 14, 15, 16, 17, 18. Okay, that's good enough. Okay, so let's hit receive money. Awesome. I'm putting three matic onto this contract.
00:15:13.340 - 00:15:39.670, Speaker A: Confirm and you'll see like, gas fees are very negligible. Confirm that's pending. Let's actually go ahead and look at this contract itself. How do I get to the contract? There it is. Contract. So this is the deployed contract on polygon scan right now, deployed about three minutes ago. Let's just make sure this went through.
00:15:39.670 - 00:15:57.304, Speaker A: Looks like it was successful. I'm going to hit balance. Yes. Three to the 18th power way. A little bit small, hard to see, but hopefully it gets the point across. Right there's three matic inside of this contract. Yeah, there it is.
00:15:57.304 - 00:16:26.464, Speaker A: Three matic. Cool. So now we've confirmed that on this contract, there's three matic that somebody could potentially win if they win this Rock Paper, Scissors game. Let's see how we put that into our front end. So this is going to be a full stack application built with the polygon blockchain in like five minutes, guys. So I'm going to go over to this web three game JS that I have here that uses this other component called Soliditygameengine. JS.
00:16:26.464 - 00:17:10.720, Speaker A: Very bad at naming things, which I'm sure the rest of you are too. We're all developers, right? So how do I actually go and interact with this contract? Right, so I have this old contract here. Let me just delete that. Delete that. I'm going to copy this contract address just so making sure we're going to that same contract. Remember, I saved some Abi code from before and I'm importing that from Abi. What is the abi? What does this do? Traditionally in web two development, I guess, for lack of better terms, the way you would interact with an API, be through like an Http request, fetch axios, something like that, right.
00:17:10.720 - 00:17:53.680, Speaker A: When you're interacting with the blockchain from a front end, like react rather than doing something like using a fetch request, this Abi code is gigantic. JSON file essentially acts like a map for JavaScript to parse through and understand how to interact with the blockchain. So this Abi code corresponds to the compiled bytecode from Solidity. So in order for the Ethereum virtual machine to actually read your smart contract data, that is all compiled to bytecode, which is like machine code. And that is the actual code that is deployed onto the blockchain, not your Solidity code. Your Solidity code is at a very high level. It needs to be compiled down.
00:17:53.680 - 00:18:20.920, Speaker A: So this JSON file is just a map. It just tells JavaScript, okay, this is a function I can use. This is some sort of state. This is some sort of input that a function needs. Et cetera, right? And you'll notice in here there's, like, inputs to find balance, to get the balance, et cetera, all the stuff that we wrote in this nice mapped out format. So that's cool. That's great.
00:18:20.920 - 00:18:59.538, Speaker A: So now we come back to our solidity game engine again. I'm bringing in the Ethers Library. Once I have the Ethers Library in here, again, just some boilerplate code of just, like, making sure I'm connected to the contract. The contract connection requires the contract address, which is what I had before. It requires the abi, and it requires the signer. The signer is simply just again, that address that we had before. Now I need to make an actual transaction, right? The transaction with the blockchain to either check if this person is the winner or not.
00:18:59.538 - 00:19:29.702, Speaker A: So I've hard coded this to just always be one matic. We're just always going to bet one matic. Just keep it simple for the purposes of this demonstration. And I have this piece of state up here. Player is winner by default. It is set to false. And down here again with my very, very poorly written Rock, Paper, Scissors game, what I'm doing here is if I set the winner to be the opponent, I'm setting player to false, transacting the game, et cetera.
00:19:29.702 - 00:20:00.274, Speaker A: And if winning is true, then transacting game will update to be true. So you either win thematic or you lose thematic. So now let's go ahead and update the game. We're moving on from Web 2.5, and let's do web three. Okay, so I've got my React app. Let's hit connect wallet.
00:20:00.274 - 00:20:25.760, Speaker A: All right, now I want to win some matic, so you all going to need to help me rock, Paper, scissors. Let's go. Always rock. All right, he said it first, though, so I'm going to go with rock. All right, so this is on you if I lose money, though. All right? So let's hit rock. No, you lost me some money.
00:20:25.760 - 00:21:03.466, Speaker A: All right, so hit confirm. We just lost one matic. This is fine. Technically, yes, you could do that's if we were making sure that this actually worked properly. We do that on Chain, which in this case, you had to reach for a tool like Chainlink or something like that to do, like, the random number generation here. We're just trusting our players to do the right thing. Let's play again.
00:21:03.466 - 00:21:16.320, Speaker A: Let's try to win this time. Oh, crap. Okay, rock. Papers or anyone? Okay, he did say it first. All right, we're doing a rock again. Always rock. Yes.
00:21:16.320 - 00:21:35.926, Speaker A: All right, so we're going to hit confirm. I had 494 Meta it's pending. See if this works. Do I speed it up. No. Yeah, that's testnet medic. Yeah.
00:21:35.926 - 00:22:08.990, Speaker A: Okay, cool. It updated. I won some money, so cool. That's a very basic implementation of play to earn mechanics set to a browser game. Right? We started off with a simple rock paper, scissors game. We connected everything to a smart contract it's not the most complex application, but it's really just to give you an idea of how you can start incorporating these play to earn mechanics. This is just like a simple kind of like gambling rock, Paper scissors game.
00:22:08.990 - 00:22:52.014, Speaker A: But this is kind of the basis of what games like Axio Infinity, DeFi Kingdoms are kind of like built on. You take the little fundamentals and building blocks, put these together, make it a little bit more complex, test your code unlike me and always test your code and put that onto the blockchain and you've got a play to earn game. Play to earn is something that is getting pretty big right now. All the rage, all the VC funding is trying to find its way into play to earn and all that. So if that's something, I'm pretty sure it's one of the tracks as well for Polygon. So if you want to win some money from us, something you could build. Cool.
00:22:52.014 - 00:23:15.800, Speaker A: I'd like to open this up to questions. Any questions about the code, any questions about any anti implementation polygon in general? Love to open it up to you guys. Anything? You have a question? Can we get Mike? Yeah, I think he's going to give you the mic.
00:23:23.290 - 00:23:24.600, Speaker B: Great, thank you.
00:23:24.970 - 00:23:46.942, Speaker A: Question was, is this code open source anywhere? Can I look at this? Maybe? I want to build something similar. Yep. So this will be open source by later tonight. So I will just post this up again. You can follow me on Twitter at rahat codes. I will tweet this out. But I will also put this in the discord in the Polygon sponsor channel as well.
00:23:46.942 - 00:23:51.120, Speaker A: So both places by later tonight we'll have that up there.
00:23:58.790 - 00:24:17.570, Speaker B: I'm somewhat new to Polygon. I think basically how it works, like layer two and then all the transactions get put into Ethereum blockchain in a bunch. That's how they can have fast transactions and stuff, right?
00:24:17.740 - 00:24:43.730, Speaker A: Yes. This specific implementation is using our Polygon proof of stake slide chain. So rather than doing like proof of work computations, which is going to take more computing power, going to take a little bit more time to do, proof of stake algorithms allow for much quicker transactions. So a lot of that is built on that side of things to get you that better. UX.
00:24:46.470 - 00:24:56.070, Speaker B: Polygon offers pretty cheap fees and fast transactions. So does Solana. What's, like the trade offs?
00:24:57.450 - 00:25:31.550, Speaker A: I couldn't intelligently speak about Solana. So I will say if you're already used to building on top of Ethereum, building on top of anything EVM, the advantage here might be like you don't have to learn anything new. Like with Solana, you have to pick up rust, build smart contracts. So if you already know solidity, if you've already been developing on an EVM blockchain just for developer experience, I go with Polygon.
00:25:33.990 - 00:25:40.500, Speaker B: Do you know if Polygon are going to be affected by the merge? Anything?
00:25:41.110 - 00:26:34.340, Speaker A: Yeah, I think we're actually very happy about the merge. While the proof of stake blockchain will still be a thing will still be available. There's a whole suite of kind of products that we're building and putting out a combination of ZK roll ups, optimistic roll ups as well as just like different tools for just building on top of Ethereum. Our whole thing is just like making Ethereum scalable. So whatever Ethereum does to make that easier for us is just even better. This implementation of putting this on the polygon proof of stake blockchain is just like one way you can interact with polygon ecosystem at large. There's only one of our products so maybe there's a future where our other tools would be more popular because post merge is probably stuff that you'd want to use.
00:26:34.340 - 00:26:48.310, Speaker A: Cool. Anyone else? Do you have a question? No.
00:26:50.600 - 00:26:52.270, Speaker B: Truth. Think something.
00:27:03.890 - 00:27:27.270, Speaker C: About Solana. There is a tool, there is a game that exists that's called degen coin flip. And what it is, it's like you bet an amount what you want and if you lose, you lose this amount and if you win you double your amount. You're winning with a small fee that this contract in Solana is keeping for themselves.
00:27:27.420 - 00:27:28.342, Speaker A: Right? Yeah.
00:27:28.396 - 00:27:30.582, Speaker C: So it exists for Solana something like this?
00:27:30.716 - 00:27:31.400, Speaker A: Yeah.
00:27:31.790 - 00:27:35.146, Speaker C: Implemented yet I don't know if this contract is open or not.
00:27:35.248 - 00:28:13.830, Speaker A: Yeah, I mean this is sort of like a very similar implementation. You're wagering some money, I could add some more to add some fees if I wanted on top of that as well. I could code that into the balance and things like that. But this is going to be more like a basic sort of implementation. But I don't think you need much to add very much more code on top of this to actually get to the end. Know what you were describing there? The basic functionality is there wagering, sending money, things like that. Probably just be like doing a few things like keeping track of fees and things like that.
00:28:13.900 - 00:28:30.578, Speaker C: But what they have on top is like an NFT collection. The revenue from the percentage they are keeping it goes to the NFTs, the wallets of the NFTs.
00:28:30.674 - 00:28:38.640, Speaker A: Nice. Yeah mean those are definitely different functionalities. You can add on top of stuff like that. That's awesome.
00:28:39.410 - 00:28:46.350, Speaker B: What about the main selling points for polygon?
00:28:51.510 - 00:29:30.910, Speaker A: That's really for the proof of stake blockchain cheap and fast. But our other solutions would also leverage the Ethereum security level of security that we have there. Are we out of time? Yeah the selling points for the proof of stake blockchain is there but if you want to leverage the full security of Ethereum and everything like that, you would reach for something like our ZK rollups, optimistic roll ups, some of those other products. So it depends on your use case for what you need. Cool. Thank you for coming by to this workshop. Really appreciate you all.
00:29:30.910 - 00:29:35.420, Speaker A: Thank you for the questions and yeah I will post the code later on tonight. Thank you.
