00:00:12.560 - 00:00:26.470, Speaker A: All right, welcome everyone. Welcome to the stream and today's session on Raiden. I'm Sean on part of the global team, and I'm here joined by Andre from Raiden. Very nice to have you.
00:00:27.240 - 00:00:30.590, Speaker B: Thank you. It's very nice to be as well.
00:00:31.920 - 00:00:34.536, Speaker A: Yeah. So super excited for this one, Andre.
00:00:34.568 - 00:00:35.388, Speaker B: You can feel free to take it.
00:00:35.394 - 00:00:48.450, Speaker A: Away, but as for questions, please feel free to post them either in the YouTube chat or in the zoom chat. We'll answer questions right after the main presentation is up, but feel free to ask questions anytime. Thanks, Don.
00:01:04.110 - 00:02:06.486, Speaker B: Okay. All right, Andrea, I think you're good to go. Okay, so, hello everyone. My name is Andrea Vitor. I'm from Brazil. I'm 29 years old, software engineer, living currently in Sao Paulo and working for BrainBot almost four years now in the rating team, which is one of the first calling solutions for Ethereum. And we will be presenting the results and some code walkthrough and demonstrations over the latest raiding light client, as well as a background on the payment channels, network technology for scaling payments and transfers and presenting the radiant protocol and then some hands on demo.
00:02:06.486 - 00:03:05.290, Speaker B: So, yeah, let's start quickly. Present my screen. I won't ask if you guys are seeing it because it works every time, so I just assumed. So rating, rating protocol and the light client implementation and client. So let's start first with the payment channels. I'll just do a quick intro so everyone is in the same page after this. So, as everyone knows, and this has been the hotspot of the debacle from scaling solutions and blockchain technology, which is late year one scalability issues, which mostly comes out of the requirement for global consensus.
00:03:05.290 - 00:04:50.580, Speaker B: So what this means that everyone needs to agree on the current state of the network, or at least on a given path for a given state in the past, for the state of the light client, of the blockchain state and the account state, balances contract state and so on. So this requirement for global consensus is one of the strength of blockchain technology because it's fully decentralized, but it's also Achilles need because it's hard to actually ensure this consensus in a safe way while still keeping the workflow and the flow of transactions going, sadly. So, yeah, this is mainly caused or the main improvement. And the technology breakthrough from blockchain started with the proof of work algorithm, which allows anyone to propose blocks and to have them accepted over these consensus rules. But they can be reorganized. And proof of work is what dictates what's the latest and most up to date view of the state of the blockchain. And in order to have your transaction safely settled on the blockchain, you need to wait for a specified amount of time, a specified amount of blocks, which means that there will be a low probability of this getting reorganized, your transaction going out.
00:04:50.580 - 00:06:12.886, Speaker B: But of course, this makes the number of transactions and ensuring validating this consensus a bottleneck of the network because global consensus is required. So payment channels is calling solution for layer two which uses layer one deposits to reduce the consensus requirement from global to local. So there are local channels which is an abstraction, those channels are an abstraction and you only need to have consensus over this local channel with your partner. So if you have a channel with someone you only need to agree with them on the current state of your channels or the current tokens or any kind of asset transferred to them back and forth. You don't need to inform and to have everyone agreeing on this state of this local perspective, of this limited set of the blockchain state. In this case it's the channel state, the deposits going in each side of the channel and being transferred back and forth between the partners. So payment channel networks.
00:06:12.886 - 00:07:53.462, Speaker B: They allow you to transfer to nodes that you don't have a direct channel with. Because if you have to open a channel with every peer you want to transfer assets to, this would be extremely slow and also capital inefficient even more than what we already have because you would need to lock the number of channels, the number of tokens in a channel with everyone that you intend to transfer tokens to. So with a network of payment channels instead you are able to keep only a limited number of channels and to mitigate payments through these channels network. So if you are connected with a partner that sometimes is called a hub that have several channels, for example, five channels, or is overall well connected and balanced with the network, you are able to transfer to nodes that you don't have a direct channel with by transferring to them with specific instructions on how to forward these payments forward and to get it to your target. And only after that you would be settling those tokens, they would be forwarding this as well to the next mediator and then the next mediator and so on. So the advantage of payment chain of network is that the troutput or the transactions per second transfers per second in this case increases linearly with the number of participants. Instead of getting hindered by the number of participants and the number of payments and transfers going through the network, this would actually increase linearly with the number of participants.
00:07:53.462 - 00:09:13.678, Speaker B: So as many participants are participating in the network as higher the capacity and the throughput of this network, this layer two network. So here is my example, alice and Bob, they design an example for a channel payment channel. They have a smart contract which dictates how the rules for this payment channel and each side can deposit arc 20 tokens for example on their side of the smart contract and then they deposit only once they open the channel. This is one transaction. They deposit these channels, it's one transaction per each side and after that they can do an unlimited number of transfers going back and forth in these tokens between them without having any on chain transaction. In this meantime of course, as long as these transfers are backed by their respective deposits or their respective balance. So if you have received out tokens from Bob Ellis can actually transfer out that they had deposited plus that Bob had transferred to them, she can transfer to Bob or can transfer to someone else through Bob.
00:09:13.678 - 00:10:15.980, Speaker B: So this is my demonstration of how routing a payment works. So there is a service that will give you a path in this network of well connected nodes and then you'll be able to route payments only through channels, through partners that you have a direct channel with. Right, how the radio network implemented this? So payment channels is a more or less generic idea. This is actually the same idea behind the Lightning network from Bitcoin and Radiant network, as I said, is one of the oldest implementations of a scaling solution for Ethereum on the Ethereum network layer one Ethereum 1.0 so far. So the radio network, how it works, it's mostly composed of a set of contracts deployed on Ethereum Mainet and also on all the testnets, mainly Gurley. It's the main network that we use.
00:10:15.980 - 00:11:43.218, Speaker B: It uses a federation of metrics.org transport servers for off chain communication between nodes and discovery as well as it trusts this federation to be able to connect direct WebRTC peer to peer communication channels between nodes so they can talk more efficiently, faster through those peer to peer RTC channels without actually having to go over the server. But the fallback, the last layer of communication of offshore communication goes over metrics which is very reliable in the sense that it can be reached since it uses Http pooling in the background, it actually can be reached behind net over mobile clients as well as on node JS and several platforms. There are several libraries implemented everywhere in order to communicate with matrix federation of service. This federation currently is not connected to the main matrix.org federation but it's open and currently just a created list. But eventually this will also be registered on chain the list of currently participating nodes in this federation.
00:11:43.218 - 00:13:30.390, Speaker B: The transport servers are free, are provided by community and we ensure that this will continue working. So besides the free transport servers we have a set of incentivized services provided to the network, namely Pet finding and monitoring services. Pet finding is responsible to keep a bird's eye view of the network topology as well as capacities and being able to find the most efficient path towards your given target on this network. And monitoring service of course is responsible for allowing partners to go offline without incurring the risk of losing their received assets because since the payment channels only require local consensus, any node participating on it and willing to keep their received assets would need to be online. That's why we need those monitoring services on Lightning Network, it's called Watchtowers that are going to act on your behalf properly, incentivized, in case it's needed to act, in case the partner has closed the channel while you were offline. So currently we have two major clients implemented already in two different languages. We have the Rating Python implementation which is the first reference implementation mostly focuses on servers and personal computers as well as the Lite client which we call the Light client because it's written TypeScript transpiled to JavaScript and intended to work in browsers and node JS environments.
00:13:30.390 - 00:14:35.740, Speaker B: But it's not a lite client in the sense that it depends on a full client to work. This is actually a full implementation of the Radiant protocol in the form of an SDK or a library that we call Radian TS and two major interfaces for it, user interfaces. So the DAP is a web UI interface, user friendly, and the CLI is a Restful exprs node JS API client which is compatible with the Rating Python Restful API. So it's interchangeably. Both clients can be interchanged accordingly and still be able to work on the same applications together as the back end of any application built using those Raid and Rest API. So yeah, this more or less how it's built the network Scam architecture. So we have a core of nodes that are well connected to each other here in one and two and three.
00:14:35.740 - 00:15:35.310, Speaker B: And we have light clients. Or it could not be Light clients, but any client that is not willing to actually deposit and commit the funds on several channels, instead they open smaller number of channels with the core of the network. In this case, A and B could be Light clients working in the browser. Running the browser and pathfinding serves, as I said, is responsible to keep a view of this whole network topology and be able to find the path between A and B. For example, when A requests it as well as when B receives a transfer, it will be updating monitoring service with the latest balance proof that it's received and then they can go offline safely and monitoring service will act if entry. In this case the partner closed the channel with B while B was offline. So yeah, this is the Rating protocol.
00:15:35.310 - 00:17:35.766, Speaker B: The Rating Protocol mediates transfers on this network of payment solutions using locked transfers or a hashtag lock mechanism where A after getting the pet between him and D, which is a target through B and C, but they only have a channel with B. They then compose a locket transfer to B, having D as target and going through B and C. So B, upon receiving this locket transfer, creates a similar locket transfer to D through C using the same secret hash and then C does the same. When D receives the transfer identifies itself as the target and A as the initiator the target requests the secret for that specific transfer from A and then A can review only to D through transport the secret that hashes to that secret hash for this hash time lock mechanism. And then D can safely reveals this secret to C in order to claim an off chain payment. If C for any reason does not want to cooperate on this off chain protocol and tries, for example, to become unresponsive d can go on chain and register this secret on chain and then they are sure as soon as they have received the secret that they will get paid because if C does not collaborate, they can go on shank register the secret and this will allow them to then later in the future when they want to settle the channel to claim those tokens that were received on this specific transfer. C upon receiving the secret of course needs to now knows that D has the capability of going on chain and requesting this payment if needed.
00:17:35.766 - 00:19:02.018, Speaker B: But to avoid that the need for that, they unlock the transfer to D by sending an unlocked balance proof to D with the same amount that they had previously sent. But now C also knows the secret so they can review back to B, b unlocks to C, then B reviews back to A and A unlocks to B and then you got a payment fully safely mediated payment through this network between A and D without actually then having direct channels between each other. So with only a channel with B, a was able to transfer to D as soon as they knew the route and they managed to perform this off chain protocol through sign up messages between each other. So how the actually A rating transfer workflow works. So the client needs to deposit to UDC if they want to pay for a route from PFS or if they want to have monitoring their channel and they need to go offline for any reason. Of course after depositing to UDC they also need to open a channel in order to transfer tokens through this network. They may check that the target is online in order to that if the target is offline, they don't even need to start the transfer since it's not going to succeed anyway.
00:19:02.018 - 00:20:24.810, Speaker B: Both nodes need to be online in order for the transfer to work and then they need to get a route that if it's a direct transfer. So between partners connected through a direct channel. A direct channel? They don't need to request a route because they know that the partner is or isn't online or if it's a mediated transfer, they request the PFS and pay for this request a small amount with several orders of magnitude cheaper than on chain transactions in order to route this transfer through the network. Then they initiate the transfer. If it succeeds, it should succeed quickly or else it's going to keep retried until it expires for any reason it happens that the transfer expires before succeeding or for example the sender went offline or for any reason. After they come back online, they see that the transfer failed and they are able to sign lock expired message and make their Locket transfer liquid again. So there is a small locking amount, usually around twelve minutes, where these funds are virtually locked in this channel, in this transfer, even if it has not succeeded, did not go through.
00:20:24.810 - 00:21:50.738, Speaker B: But after that they can just expire it and get back their funds and then do whatever they need to do, maybe try another route, maybe withdraw these tokens from the onchain channel upon receiving transfer. Of course, the node needs to update the monetary service if they plan to go offline for any reason. If they are staying online all the time, for example, which is the case for full nodes, they don't need to update the monitoring service. But it is highly advisable since, as I said, this is just local consensus, this is a requirement for this network. So how is the actual large collar and architecture? Its primary target platform are browsers, which contains the most restricted set of interface and it's the most secure. Or they strive to be the most secure platform because it has the highest expositional to clients and to applications, web applications running anywhere in the web. The browsers are quite restrictive on security features and therefore it's hard to make something truly innovative and cryptographically safe to actually work on browsers.
00:21:50.738 - 00:22:43.846, Speaker B: So we choose to target browsers because this limited set of assumptions. So browser tab or a browser application is not always online, it does not have good guarantees on persistency and so on. So our idea is if it works in the browser, it should work anywhere. So the browser is the most limited set of features and after that if it works in browser, it should be easier to have some more relaxed assumptions. For example mobile embedded devices as well as servers and personal computers. We also target node JS since it is a quite common platform denominator and available from IoT devices to servers. And the client is fully written in TypeScript and is typesafe as well.
00:22:43.846 - 00:23:34.466, Speaker B: It's transpired to JavaScript, so it runs whatever the JavaScript code can run. So the SDK or the library radiants is in the base. It communicates with the radiant network and ethereum blockchain and its interface currently is the DAP and the CLI. So yeah, you can use the DAP directly. Those are the main ways for you currently right now to use the DAP, the Light client. So you can use the DAP directly. It's kind of a PayPal like experience where you can redirect the user to the wallet, the Light client DAP where they will perform their transfer so you can pass token, target amount and even payment ID over parameters.
00:23:34.466 - 00:24:55.982, Speaker B: They will perform their transfer on this deployed DAP instance and then you can detect that on your system on the back end and react accordingly, for example by providing them for the resource they just paid. You can also use the CLI which is a Node JS client but this is mostly intended for servers and back end implementations since this needs to be running or should be running 24/7 most of the time. And you can also import and essentially delight client SDK directly. So the Light Client SDK is a quite easy to use API where you can use and implement a fully new client by leveraging the Raiden protocol, risks and algorithms implemented in the Liteclient SDK or Radiant Library which is available on npmjs. So this is the most proof approach but leaves more decisions to the developer. So with whom to open a channel, with how many tokens to deposit on UDC or on a channel and so on. The cons of it is that if it's running on web this mostly uses index DB to keep state because the light client of course since it is not global consensus it's stateful.
00:24:55.982 - 00:25:53.350, Speaker B: So it requires some states to be kept on your client and since this state is isolated by origin or website, if you do that on the web you are going to require from your user to do the onboarding for each instantiation, each implementation, each part, each place where you implement this. Why if you use the Depth directly you can rely on the state being shared. So let's do a quick demo first for the Depth. So let me just refresh this. This is a Depth instance, you can access it at client radiant network and this is a PWA implementation and client. So you can install it on your system and run it fully offline. But let's not do that now.
00:25:53.350 - 00:27:09.358, Speaker B: Once you connect, it will generate a private key which is actually derived from your main MetaMask or whatever provider you are using. Main MetaMask Account this is created by signing this method here which gives you a warning that you should not sign this method outside of this domain. So it's specific per blockchain, per network and per domain and you can just sign it and it will log in and all the tokens and Ether use it for on chain transaction is still offloaded to the main MetaMask main provider account. So you can use it from Gurley here so you can keep your stash still on your main account which is interactively prompted for any transactions being done being made. But of course this subkey account which you can see here is different from my MetaMask account which got generated. This account here can be used only for signing the messages that go back and forth because you can actually use the MetaMask account directly but then you would need to sign several messages in order to perform a single transfer. So let's do a small transfer.
00:27:09.358 - 00:27:43.014, Speaker B: You can see here that I have a single channel with 30 tokens of this test token deposited on it. They state it's open. You can just type an ans address here for example, this is my hub, my partner address. So I'm going to perform a direct transfer since I'm transferring to someone that I already have a ten with. So let's do 0.1. You can see that it skipped selecting the route because these are direct transfers so I don't need to request a route. Then let's perform a transfer.
00:27:43.014 - 00:28:18.900, Speaker B: The secret gets reviewed on Shane, the secret gets reviewed to the partner and then the transfer was successful. This usually takes between half and 4 seconds depending on network conditions. I'm in Brazil right now, the hub is on Germany so it takes around 4 seconds to perform this transfer. But you can see here this is still way faster and was completely free once the user has onboarded. So this is the client. You can manage your channels here. If needed, you can close it and settle it in order to withdraw the tokens from the channel if needed.
00:28:18.900 - 00:29:22.246, Speaker B: Besides this, if you don't want to use the deployed instance of the Light client radiant Network Client, you can also use the Radiant SDK and Radiant S, which is the engine for the radiant protocol here written in TypeScript, as I said, and running fully in the browser, so it's not offloading tasks and responsibilities to a full client somewhere. This is running entirely in the browser, signing out the message cryptographically, verifying on chain events and signatures, everything running in the browser. So here I have the smallest possible raiding light client implementation using the SDK just to showcase how it works. As you can see, this is just the simplest possible HTML with the simplest possible almost package JSON. And this is the whole source code. So yeah, most of it is just this function here main. You can see the whole onboarding process happens here.
00:29:22.246 - 00:30:02.642, Speaker B: I already have this account onboarded but I will show to you guys. So first you need to connect to MetaMask by requesting the account from it. When you do that, if you haven't connected to this website yet, you get notified by MetaMask that this website wants to access your account. You can select the account that you want to provide to offer, then you can instantiate Raiden here. There is a nice utility here where you can just pass the provider. Here we are telling Raiden that we want to use the first MetaMask account for it. You could specify a specific address or private key directly here if you want and so on.
00:30:02.642 - 00:30:53.560, Speaker B: Then we subscribe to channels updates and we start raiding. This will sync the state if needed with the blockchain. If any events was lost in the past, then we can ensure that the service tokens are funded. So the user deposit contract which actually is used to pay for PFS and monitoring service is funded. So here I'm requesting the user how many tokens they want to deposit and then yes, like that. So yeah. And here I can ensure that there is a channel open.
00:30:53.560 - 00:31:23.198, Speaker B: In this case, I'm asking using just window prompt. So it's the simplest possible approach. Just to demonstrate that, I can just ensure that the channel is open here. In this case, I'm suggesting this hub that I just have shown to you guys and then the amount to the post. And once this is done, once the client is started, I can just perform a transfer. So I will show it to you here. I can start.
00:31:23.198 - 00:31:46.178, Speaker B: The client MetaMask will ask me to sign that same method in order to generate the delegated account. This is the terminology generated from the main account. So it's just the hash of the signature of this method here. Once you sign, it will sync. And as you saw, it took like two or 3 seconds to sync with the blockchain. So it's quite fast. Now I can perform transfers.
00:31:46.178 - 00:32:12.270, Speaker B: This simplest dummy application will ask who I want to transfer to. So let's say that I just want to transfer to the hub that I have at Tina with it could be your node. It could be any node online on the blockchain on the radio network. Right now, we have methods to suggest partners here as well. Let's just transfer 0.1 tokens. So it's transferring exchanging messages.
00:32:12.270 - 00:32:53.226, Speaker B: Um yeah, we can see here the transfer was successful. It did not show a dialogue. But we could have just create a dialogue here like alert transfer to show success. But from the logs here, you can see that the transfer was successful. A full fledged client like the DAP will have a proper dialogue as I have shown to you guys. But yeah, this is enough to have your transfer going. So let's try a different one.
00:32:53.226 - 00:33:37.738, Speaker B: Now I'm a data transfer to this other node here that I have online on the same token network, right? So let's copy its address then perform a transfer. I will paste this client here address to it. You can see here the I need to start just reload this because this does not have Fobbacks but on the DAP you have a full fledged application. This is a light client written like 60 lines of 70 lines of code. So yeah, this is simple. But on a full fledged client, you could implement the error handling that you should. So yeah, that's the start.
00:33:37.738 - 00:34:05.650, Speaker B: It syncs quickly. You can perform a transfer, paste the address. Let's see, I want to transfer 0.2 tokens and then it will perform now a mediated transfer because I don't have a direct channel with that node. But this just worked. So you can see here the transfer got received. Even though I don't have a direct channel with that node, I just have a channel with the hub.
00:34:05.650 - 00:34:55.682, Speaker B: So of course their payment channels network is a very powerful approach, especially for IoT and use case that require fast, small and often transfers. And this is the perfect use case for payment channels. And the Light client and radar network is already ready and the main rating Python client is already deployed on Mainet. So you can use it right away, right now. And the Light client is not yet green light to the main net, but you can hack on it on there also if you want. And you can also test it on Gurley as we are doing here. So just start and transfer after you get onboarded, which is the expensive part.
00:34:55.682 - 00:35:30.320, Speaker B: But this is property shared by our second layer solutions. Right now we are trying to check on improving that, but after you are onboarded, the user can perform as many payments as they want free, fast and ship fast, ship and scalability on the radio network of payment channels. That's it for me. Questions, remarks, anything that I could help here? What do you guys think?
00:35:32.530 - 00:35:34.240, Speaker A: You've been a demo. That was awesome.
00:35:35.490 - 00:36:40.814, Speaker B: There was one question if the receiver has to be online yes, the receiver has to be online mainly because it's required that the receiver sign message in order to request the secret from the initiator, or else the initiator is not going to review. If the initiator reviewed the secret to anyone else, they could get robbed. So it's needed to sign this message. And this is what gives the security features of the radio network where you only actually only paid what you sign it for, not what you deposit. So deposit is only a backing of the transfers. Once you have it backed on chain, you can sign the balance proofs off chain and you safely perform those transfers. But yes, without the payment channels, the receiver needs also to be online, but with transfers taking even less than 1 second, this is really not a big problem because we can have subsecond finality on the radio network.
00:36:40.814 - 00:37:18.218, Speaker B: So as soon as the transfer protocol was completed, as soon as you verified the signature of the message that you have received, you can be 100% sure that we will get paid. This is the security feature of this network. So even Ethereum 2.0 solutions, they do not provide this property. So actually we are looking forward to Ethereum 2.0 because it will reduce a lot the cost of onboarding users on our solution. But payment channels, state channels payment channels is a specialization of state channels.
00:37:18.218 - 00:38:03.838, Speaker B: Solutions are actually complementary to charging and roll ups strategies for scaling Ethereum. So we are looking forward to that. They both will work great together. Hopefully more questions. So someone asked here how does raising avoid the gas prices? Well, unfortunately it can't. Yet this is an issue for all second layer scaling solutions. Everyone needs to onboard at some point and to onboard you need to pay gas for that and to offboard you also need to pay gas usually.
00:38:03.838 - 00:38:48.974, Speaker B: So this is a problem that we. Are actively working towards improving because right now you need to pay for onboarding the user. So the user needs to onboard, they need to open a channel on chain, they need to lock the tokens in a deposit on chain, but after they have done that, they perform the transfers fully off chain as often as they needed. You could perform ten transfers per second without bedding an eyelid. So it would work fine. For example for IoT devices working and paying for energy or for paying for megabytes of data downloaded or uploaded or to pay for minutes or even seconds of video. Watch it.
00:38:48.974 - 00:39:32.474, Speaker B: You could implement this roof rating small, scalable, fast payment work great for it. But yeah, to onboard it's still a little bit expensive. Yeah. So I gave here two examples. Mainly you can use the DAP directly as a user or as a developer by pointing the user as a paywall for example to the DAP. And then the user will be able to use their already instantiated light client DAP account in order to pay for your specific request. Or you can implement the SDK directly which opens all the doors possible.
00:39:32.474 - 00:40:50.850, Speaker B: This works on Node JS, this works anywhere that JavaScript can and then you can implement your own client without having to think and to ensure all the safety guarantees that Radiant provides. So the whole Radiant protocol is implemented in the Radiant TS package and you can use this on your application right away. For IoT, for web anywhere browser or JavaScript works, it should work. So you put an X amount paying fees once until you don't spend all X covered for payments. So yes, hopefully if you can lock amount high enough and you have this specific use case where you perform many payments, small payments after several payments of course you already have gained what you would on gas fees if you were doing off those transactions. Clogging the network. Another property of state channels and payment channels is that only the latest transaction goes on chain, so it adds privacy.
00:40:50.850 - 00:41:46.850, Speaker B: No one needs to know every small transfer that you performed. Only the latest final amount is settled on chain and needs to be visible on chain. And even that we are looking on solutions to improving that using zero knowledge alternatives and algorithms for this. So project suggestions for hackathon, I think we have published some of them, jacob has been working on that. There are several alternatives that goes into the direction of integrating raiding with the latest on chain scaling solutions like roll ups. This would be great to see something in that direction. The smart contract part of raiding is just a smart contract.
00:41:46.850 - 00:42:35.990, Speaker B: It's not special in any way, it's just a normal smart contract. So you can optimize that using the standard solutions out there. But if you want to implement also use cases actually using rating for end users, that would be great as well. For example, paywall solutions, pay per view per minute per pay megabyte or maybe even a small robot paying for its energy or its connection link using rating. That would be something quite interesting. Yeah. So Jacob has shared the link that would help on that.
00:42:35.990 - 00:43:35.850, Speaker B: So yeah, about the ARDN token, this is interesting topic. It's mostly related that we wanted to support any token network. Of course, right now it's quite a little bit limited. The number of token networks that can be used on Mainet right now it's Dai and Rapid Eater, but we want to open that for everyone. But not every token is useful for the service providers. So it's important that the service provider use a centralized or shared token that they know that will work regardless of in which token they are serving their services. So this common denominator, this centralization point for value on services provide on the network needs to be stable and that's why we have chosen a specific token for that.
00:43:38.140 - 00:44:00.940, Speaker A: All right, we are a little bit past time. I want to be conscious of everyone's time here. So thanks so much again, Andre, for showing. Very cool presentation, very informative, very educational, very good clear presentation. And as always, if anyone has any questions, please feel free to ask on the Discord sponsored Raiden channel. And I'm really excited to see what everyone builds off of Raiden.
00:44:02.280 - 00:44:10.050, Speaker B: Thank you very much and looking forward to see all your guys, ideas and projects implemented on top of it. Thank.
