00:00:06.250 - 00:00:33.302, Speaker A: Okay, let's begin. Fantastic, guys, welcome to the workshop. My name is Alex Kuholzkam, CEO, co founder of Metal Labs, which is the company behind ZK Sync. And we're going to talk about what ZK Sync is. We're going to talk about ZKsync version two. So we have ZK Sync as a ZK roll up for payments and swaps for basic specialized operations on Mainet since two years, with some 200 million dollar value locked. But that's not what we're excited about.
00:00:33.302 - 00:01:15.202, Speaker A: We really are looking forward to launching Zkync V Two, which is going to be a lot more interesting. So we'll touch on that, what it is, why it's important, and then we will discover user experience, like how it will feel to your end users. If you're going to build on ZK Sync, then we will deep dive into the actual developer perspective, like what it means to build on it, what nuances you have to observe. And then we're going to talk about security aspects because security is the paramount concern of ZKsync. This is why we're building a ZK roll up specifically. And then we will also touch on the ecosystem and some support programs which we can offer from our side. Now.
00:01:15.202 - 00:01:47.086, Speaker A: Okay, so what is ZK sync? ZK sync is an L two powered by ZK EVM. So it has the benefits of EVM. It's fully EVM compatible. You can take anything that is written for EVM in Solidity or Viper or U and just plug and play. And it should work out of box in most cases. It has full web3 API supports your front end, your APIs, your packet services will also work. And the most important thing is that it inherits security from layer one.
00:01:47.086 - 00:03:10.380, Speaker A: What this means is your logic of the contracts and your authorizations by the users are verified not by ZKsync Validators, but by Ethereum itself. Every single transaction that happens on ZKsync is checked by all of the Ethereum Validators through verifying the zero knowledge proof. So you can think of zero knowledge proofs. How many of you are familiar with zero knowledge proofs? Okay, so the zero knowledge proofs are, or snarks more specifically, are protocols, cryptographic protocols that enable compression of computation into a very small piece of data that you can check with simple arithmetic operations, which take something like 30 milliseconds on any smartphone. And you can be sure that the result of the computation we've done on arbitrarily large array of data with arbitrary many steps is valid. You don't have to redo all this computation. You can just check the results, get your, for example, your commitment to state merkel root hash and you will be sure that this new root hash is actually in a new state of the blockchain by applying 1 billion of transactions, like all of the world's financial transactions that happened over the last hour or day or whatever.
00:03:10.380 - 00:03:58.422, Speaker A: This is actually a little magic, but it's just pure math and it's quite easy to understand if you go step by step and see what happens there. But I can give you an intuition for it right now. Just trust me. You only rely on math and smart contracts in the code to verify all of these transactions. So that gives you perfect security from L One. Citizenship resistance is a different property that says that if a user has funds in Layer Two, how likely are they to be able to withdraw it? Even if the Validators are malicious, are not aligned with you like they are trying to censor you specifically. So censorship resistance is enforced through Layer One.
00:03:58.422 - 00:04:42.840, Speaker A: And why I called it l Two and not ZK. Roll up. Because ZK sync v two is a combination of ZK roll up and ZK Porter protocols. It's a fusion, we call it Volition, a hybrid system where users can decide whether their accounts are residing in the Ziki Roller part or in the Ziki Porter part. And by making this choice, they will both enjoy the full security of Ethereum. So all transactions are like Validators, cannot do anything wrong, cannot freeze state, sorry, cannot corrupt the State, cannot execute anything other than the user ask them to execute. But with the Roll up you have full censorship resistance exactly as on layer One.
00:04:42.840 - 00:05:18.898, Speaker A: The protocol guarantees that you will always be able to access your funds in any contract. You will be able to just push them out. On the ZK Porter side, it's more like all or none approach to censorship resistance. The Validators won't be able to censor individual users, but they theoretically could freeze all of the State. And this will stop everyone, prevent everyone from exiting. Which will by the way, also freeze their own stake in Ziki Porter. And Zikk Porter is going to be stake based tokenized system.
00:05:18.898 - 00:05:45.638, Speaker A: So it's going to be a suicidal move for them. But it's very important. Unlike side chains, they cannot steal funds. They cannot say okay, we're going to lose our stake and we're just going to take all of that and sell somewhere else. They can't do that. They can only kill themselves with let the boat sink with all the passengers. So with ZK Roll Up, since you have full 100% censorship resistance from Ethereum, you only enjoy linear throughput boost.
00:05:45.638 - 00:06:31.260, Speaker A: So all the transactions in other words, are going to be N times cheaper, where N is something like 50 or to 100 X. With ZK Porter on the other hand, your throughput is completely unlimited. This is important. You can go to 1 million, 500 million, 1 billion ECT daily fusers. And it will work because Ziki Porter can work in parallel, you will have many instances. All of them will derive security from Ethereum itself. ZK based systems is the only way blockchains can reach the actual world scale of mass adoption to anyone in the world with trustless connection between all of them.
00:06:31.260 - 00:07:41.294, Speaker A: But yeah, you will have your trade off insecurity because you still have to trust validators of specific shards or that we call them to be non suicidal but that's a different assumption. But what's really important Ziki Porter and Ziki roll up accounts will be synchronously interoperable or at least seamlessly interoperable if there are many shards. But if you only have one ZK roll up shard, one ZK Porter Shard you can make calls from one to another and have cheaper transactions. If you're a Porter user but still access all the protocols on the ZK roll up side, which is like just in different way to say like all the protocols on Ethereum, you can have uniswap with liquidity providers that have a lot of capital there that who care about security first and foremost. And you have users like long tail retail users who just want to access these funds and they can do it in the same atomic transactions. They can have instant loans and so on and so on, like flash loans and whatever. It will work.
00:07:41.294 - 00:08:28.922, Speaker A: This and what's the philosophy of ZKsync is the philosophy of Ethereum. We don't want to build a proprietary technology bound, constrained by artificial means. It's going to be all open source with permissive software license and the network itself is going to be owned and governed by the community and if your community finds that the current validator said is malicious they can always fork away because we will also provide the means of mass exit. We'll talk about that. Cool. Now user experience it's really important for user developers to see, to imagine how the users will think about or perceive your system. So we'll start with how they begin using ZKsync.
00:08:28.922 - 00:09:15.146, Speaker A: They start by having funds somewhere else. They have an empty account so they can either receive funds in ZKsync from someone else who is already on ZKsync or they can just bridge them natively from layer one or from exchanges from one ramp. So it's going to be directly on ZK sync native takes ten confirmations. So like 1 minute, two minutes for funds to arrive. Like any message from layer one to layer two passes within ten confirmations and you have native withdrawals to layer one and correspondingly to other roll ups if you need, and this is important on optimistic roll ups, it will take one week at least. On Ziki roll ups it will take your next block. Realistically right now it's hours.
00:09:15.146 - 00:10:07.226, Speaker A: On ZK sync one we think it will go down even to minutes because with higher throughput we will have shorter blocks with a lot more transactions which will still make cost economically to verify on ethereum and the latency will reduce. And you also will have normal bridges custodial to other chains. But those are much less interesting than the native trustless withdrawals to l one which affect NFTs. You cannot do it really with custodial bridges for NFTs you just have to wait like on optimistic roll ups you have to wait one week to withdraw it anywhere else on ZK. It's not an issue now. Okay, so that's Bridging interacting with ZK Sync will work from any wallet, even though it's a ZK roll up. We fully support, we're fully compatible with Ethereum.
00:10:07.226 - 00:10:55.962, Speaker A: So you use ECDSA signatures, can use anything from MetaMask to Coinbase to Argent to trust wallet, whatever you like, they will natively support ERC 20 token transfers. So you just use native interface of your wallet to send funds. And for normal contract interaction, you can also use Ethereum message format, but for some more flexibility. We also support EAP 712 for signing transactions which will look like this. I think you're all familiar, wallets can support it natively to better display it. And we'll have also external tools to better display what you're actually signing there. And this is a big problem for Ethereum because sometimes you need to sign it with a smart contract wallet sorry, with the hardware wallet, so you only see the hash.
00:10:55.962 - 00:11:29.994, Speaker A: So you still need some external mechanism to show you what you're signing. But then transactions are going to be instantly confirmed. Even with decentralized sequencer. We are aiming at subsecond confirmation times four blocks. And you can pay gas in any token, at least at any liquid token, which a validators are willing to accept, which is very important for mass adoption as well. Because if you have users who are joining ethereum layer twos because they just want to have their savings. Not in local pesos, rubles, liras or whatever shit currency they have in their corrupt country.
00:11:29.994 - 00:12:03.954, Speaker A: They can just use USDC USDT stable coins, like stablecoin version of whatever they want, and they can pay fees on those. So for them, they perceive it just like a new bank. They have their dollars there and they don't think if they don't need to learn about Ether gas, it's too complicated. You won't reach masses with this approach. You'll have to make it simple. So that's why UX is at the core of every design decision we're making. At DK Sync we're thinking about end user experience, like how it affect them.
00:12:03.954 - 00:12:47.826, Speaker A: So that's why paying the is an token. Okay, so this is AP 712. And another thing for mass adoption is we're going to support account abstraction natively, which is hugely important for smart contract wallets like Argent and other wallets that are building this experience without having to work with seed phrases, which again would be a massive hurdle for big adoption with a lot of people. So with Argent you don't have that. You just log in with your email, but you still have full custody of the funds. Even if Google Compromised had your secret, they would not be able to take over your account maliciously. You still are in full control.
00:12:47.826 - 00:13:29.838, Speaker A: And there are other approaches to this as well. So this is very important for us to support. Then another thing is some protocols might want to subsidize the gas. Like this happens on dYdX, for example, you don't want to pay any gas at all. All transactions are just one click and you pay maybe some percentage, or maybe you don't have anything when you're paying with a credit card, you don't have fees on the credit card. At least you don't see them right, because the merchants are paying it. So similarly, protocols might choose to abstract it away from users and increase the UX even further this way.
00:13:29.838 - 00:14:16.030, Speaker A: And this is for this account abstraction is necessary. And finally, there are some special use cases like tornado cache or other protocols where you just need it for normal functioning. So right now on Ethereum, it solved with external relayers, which would be a lot more convenient if you had account abstraction. So that's why we decided in Ziki Sync, by default, every account has code and can be upgraded and can be replaced with customizable signature verification. Cool developers perspective. So what it means for you if you want to start building, if you want to try ZK, sing out at current hackathon, you can just take whatever you wrote for Ethereum Mainnet. And most apps should compile and just work out of box without any modifications.
00:14:16.030 - 00:15:07.086, Speaker A: That's essentially just our approach, like make everything plug and play. There are some differences in the way you might want to interact with contracts. We have our own ZKsync SDK written in TypeScript JavaScript Golang python we support multiple right now on the JS, but we will support the plethora of stacks for you to use. And if you just want to use it out of box, like to migrate to start using SDK, all you need is to change your imports. As you can see, the code on the left and the right is exactly the same, but then you can extend it. And for example, this is how paying in a different token will look like. You just specify the token you want to pay.
00:15:07.086 - 00:15:37.910, Speaker A: And there are some other extensions that you can take with ZKsync SDK. You will need it for certain cases that are working inherently different than Ethereum, which we will discuss later. Most important one is deploying contracts. Contract deployment works slightly different on ZKsync compared to Ethereum and App. You first deploy the contract itself, like the contract code, and then you deploy an instance of the contract. So we have native what's it called, like account proxying.
00:15:40.510 - 00:15:44.474, Speaker B: The main difference between deploying contracts is.
00:15:44.512 - 00:15:48.860, Speaker A: That, for instance, you have a factory or.
00:15:52.430 - 00:15:53.530, Speaker B: Other contract.
00:15:55.410 - 00:16:31.080, Speaker A: Let me speak here, because it's recorded in the microphone. So on Ethereum, factories contain the code of the contract and they output the code as a result of their execution, which is a slightly weird approach. But this is how Ethereum works today. In ZKsync, the code must be deployed separately before you run the factory. And the factory only points to an account where the code implementation resides. And then it's copied or rather referenced by the account where you instantiate the contract. So that's why you need to approach it separate way.
00:16:31.080 - 00:16:31.946, Speaker A: Questions?
00:16:32.048 - 00:16:38.314, Speaker B: Yeah. What does that mean for upgradability? Does it add anything new for Upgradability or break anything? Or is it still the same?
00:16:38.432 - 00:17:31.658, Speaker A: It's still the same. You will still deploy your proxy which will contain the logic of upgrades and logic of delegation of your code. And it works the same way. Okay, most things work out of box, but let's see at some differences, some of which are dictated by a different design approach. Some of them are necessary because we have a different architecture with ZKsync. We don't implement bytecode compatible Zkvm, but rather our own version of Zkvm which is optimized for being provable in zero knowledge proofs. And so we compile your code through from Solidity with native Solidity compiler into Yule which is native Ethereum intermediate representation of bytecodes.
00:17:31.658 - 00:18:21.050, Speaker A: Then we compile it from there into using LLVM framework. How many of you are familiar with LLVM? Well, it's a very mature, very well known compiler framework which is used by almost all modern languages from C toaring to Python to Ros to everything. So you just compile it into this intermediate representation of LLVM and from there we compile it to Zkvm which will allow us in the future to also integrate languages like Rust and Golang and whatever. All of them will just work immediately. But okay, so let's look what it means, what design differences we are going to make permanent in ZKsync which will be always diverging from Mainet. Number one is create and create two address deviation. Address derivation will differ because we have a different bytecode.
00:18:21.050 - 00:19:00.470, Speaker A: So if you just do it natively, it will be a different bytecode. So you just have to be aware of that. Although we are also thinking if there are use cases where you want to have the same contract address on different chains, we are considering making this possible. So if you are having this consideration, sorry, if anyone watching this wants this, reach out to us and we can introduce this feature. We're going to deprecate payable and message value. Message value will always be zero. It's perfectly compatible with Ethereum.
00:19:00.470 - 00:19:41.782, Speaker A: Just you have all accounts with zero ETH balances. No account will have Ether balance. So all the calls will happen as though account didn't have or spent all of ETH on gas. Everything is going to be represented as ERC 20, including ETH itself. And the fees are going to be paid in ERC 20 tokens. So this should not affect anything because most applications are supposed to work with both native ETH and ERC 20. Cell destruct is deprecated just the same way as Ethereum is planning this.
00:19:41.782 - 00:20:27.240, Speaker A: There are multiple AAPS for this. So it creates so many problems that it's kind of consensus that it's a bad thing. It should be removed and gas metering will be slightly different, obviously, just as it's the case with all roll ups because we have in layer two operations have different impact on the pricing than in layer one. Storage is for example, very much cheaper. Certain operations will be computationally more heavy, so will they be slightly more expensive and so on. But you can just rely on having the exactly same metering scheme. There are some things that we don't currently support.
00:20:27.240 - 00:21:13.570, Speaker A: So Solidity is not supported in the very early versions that did not have proper yule support. Although on the current testnet Solidity is only supported starting with version 0.8, I think. But earlier versions coming like in the next days or weeks, they are already implemented. Some open leap Zappelin leaps won't work, mostly because of the different way we work with deployment of contracts and we are currently working on making them compatible. So all of that will be rewritten with some special cases, so that most things should work out the box. Some tooling like hardhead plugins need adaptation for the same reasons, and we are also working on that.
00:21:13.570 - 00:22:16.214, Speaker A: And some crypto precompiles, like all crypto precompiles, modular arithmetics, add mode, mool mode and pairings currently do not work, but they will be supported in the next month. Hashes are supported today shot of F six K Chuck perfectly work and are cheap, unlike many other ZK based systems. Everything else will work and even wirepass will be supported. On the front end side or access side, we will support legacy transaction formats. So your front end applications should just work without modifications, unless they deploy contracts. If they deploy contracts, you will need to adjust and you will need to use SDK. Web three API is fully compatible for queries, so you just make the same binary calls, you don't need to change anything.
00:22:16.214 - 00:22:59.240, Speaker A: And we have this custom SDK for more flexibility. And here's how you can get started. Just go to V two docs ZKsync IO and you will have the nice tooling, a nice portal where you can try out things with your MetaMask. Just go to Faucet, get some test tokens and you will have full documentation with samples tutorials how you get started fast. Okay, security. The security model of Ziki Sync is, as I said before, exactly the same as in Ethereum. So the protocol guarantees the full security of layer one.
00:22:59.240 - 00:24:08.278, Speaker A: Full security derived from a layer one. And by insecurity I mean specifically like not violating the rules of the protocol, not executing transactions on the user behalf without their authorization, and not executing like changing the logic, violating the logic of contracts. We discussed Ziggee Rollup and Zig Porter with censorship. Resistance? But what's really important, all these properties are preserved without requiring modifications in your smart contracts, without forcing you to think differently about the security of smart contracts, which is not the case for many other platforms. For example, currently on StarkNet you cannot have the same security properties. You will need to think specifically of how you're going to change your contracts to make them enforceable and what other contracts are you going to access? Are they still going to be available? In the case of data, unavailability event and so on, none of that applies in ZK sync. If you deploy something on Zke roll up you have exactly same properties as layer one period.
00:24:08.278 - 00:25:06.990, Speaker A: Of course if we don't have bugs in implementation or in cryptography, but that's the case for all platforms. I would not trust all of my fortune like a significant fraction of my own money on any of the current L two S for longer period of time. They need some time to get mature, to get stress tests, just to make sure that there are no bugs. But from the protocol perspective you don't have to think about it. And if you have code which is running on layer one which is currently audited, you most likely don't have to make any changes. If it compiles, it will just work. If the compiler doesn't curse with any warnings that there are some things that like you're using self destruct or you're trying to use message value in some specific ways that are requiring you to use it, everything should work like most audits should be preserved.
00:25:06.990 - 00:26:07.262, Speaker A: And finally we are putting efforts into designing mass exit mechanisms. So that goes back to the philosophy which I mentioned earlier. If you have a malicious takeover of the protocol by a group of validators, for whatever reasons, that might even act against their own self interests financially, just to grief users, or maybe they have some political pressure to censor a certain group of users or a certain type of transactions. They can say, we're not going to support this type of business and a large fraction of the users won't agree with it. They should have an ability to exit safely, maybe to a fork of ZKsync or maybe to a different roll up if ZKsync doesn't fit them for whatever purpose. So we are going to provide that. We're going to make sure that the mass exits are as cheap as individual exits for those users.
00:26:07.262 - 00:27:38.554, Speaker A: We can just discuss the mechanism specifically and yeah, all the usual L one security practices will apply and preexist audits are at least we are putting effort, we're designing security aspects in such a way that they should preserve current audits unless we explicitly provide a warning in our compiler. And we're also going to partner with major security firms. If you have a project and you're close to launch and it's really exciting, we might be able to help you with getting earlier slot to audit to build. Our best ecosystem of ZKsync is growing. We have lots and lots of projects coming, but you can have the like all the projects that are coming from Ethereum are thinking about the Migratability of existing use cases, existing applications that might not necessarily take this massive scale into account. So there is a big opportunity to reimagine things with the new features that we have, with account abstraction, with metatransactions, with just taking something and saying how it will work at scale at the early there. And finally we're going to support projects.
00:27:38.554 - 00:29:03.786, Speaker A: We have a big Ziki Dao ecosystem grant program with grants and with investment programs where we're going to support the projects and we'll share more details later. But specifically we are going to offer grants for making things compatible, like for finding gaps in the current developer ecosystem, for something that works on layer one or on other L two s and does not yet work for ZK Sync like the aforementioned hardhead plugins, some open zeppelin leaps, et cetera. So those things will need adaptation and we want this adaptation to be plug and play so the environment will just see oh, you're trying to use this library, so you need to download the ZK Sync version of it library from the same repository, from the same vendor and we're going to specifically offer support for that. So this is the perfect opportunity to do something in this hackathon to participate in this call and that's it. Please follow us for news on Ziki Sync on Twitter. Happy to answer any questions, deep dive into any topic you want discuss. We have our technical product manager here, we have head of marketing here.
00:29:03.786 - 00:29:08.300, Speaker A: Anything you want to know? Sure, please go ahead.
00:29:11.570 - 00:29:39.618, Speaker B: Facilitating user exit so in comparison, maybe with more lightweight roll ups like optimistic roll ups, it doesn't require a lot of computation. So a user can commit like a new state when an exit. Or for ZK roll ups like you need to generate a proof which is like with huge scale, you need like a data center. User doesn't have a data center, so user can exit. Can you please expand? Like on expand?
00:29:39.714 - 00:31:23.160, Speaker A: Sure. I'm going to repeat every question so that it's on the recording. The question is about exits, forced exits for users and in comparison to other more lightweight roll ups like optimistic roll ups that do not require heavy computation of zero knowledge proofs, how can we make sure that the users can always exit without requiring them to have data center computation level requirements? The way it will work is we will have a priority queue on layer one where users can submit transactions with full inputs like transaction signature, like all the witness they have in this transaction. And the priority queue is something that obliges the validators to execute it at the next possible convenience within a certain time frame, within a very short time frame, days or maybe hours. So if there is something in priority queue, it must go through priority, like the validators must do priority queue transactions first and then process all the rest that they get from the users if they don't do this. If they fail to process priority queue requests within this short time frame, then the roll up will enter what we call emergency exit mode which means that it will still accept blocks. The blocks will be accepted from anyone, not just from the set of validators that are whitelisted by their token stake and anyone must like the blocks that will be accepted will have to contain only transactions from the priority queue in predetermined order.
00:31:23.160 - 00:31:58.922, Speaker A: That means we can all work together. Like if you just have your own one transaction there you can generate a block. You as a user can generate a block with just this one transaction and that will not require huge computational resources from you. You can do it on a laptop. You will need to sync full Ethereum node on this laptop and then you will get all the state from ZKsync. You can reconstruct the roll up state in your local database. Requirements are essentially the same as full Ethereum, full node.
00:31:58.922 - 00:33:01.510, Speaker A: Just the laptop will work and then having the state you can execute this block and on the laptop it might take maybe longer, maybe like 1 hour, a few hours depending on what you're doing transaction but you will not need external hardware. Then you can always submit this transaction and the only reason you might not be able to submit this transaction is because someone else produces this block before you. But that's better for you because then you can just abort operation and continue. And this is designed in a way where transactions can also be submitted in batches. And then the assumption is that if there is a censorship it's probably not going to be individual censorship, it's going to be mass censorship by some criteria. So then users can coordinate and withdraw, just deploy their own version of ZKsync fork and withdraw en masses because if you're just one person the priority will likely be sufficient because otherwise you will just stop the roll up. No one else will be able to do anything on the roll up and this is going to mean huge economic loss for the validators.
00:33:01.510 - 00:33:08.780, Speaker A: So they will have to process your transaction. More questions?
00:33:09.870 - 00:33:27.294, Speaker B: How does the pay with any ERC 20 token work? I heard you mentioning like if the validator is accepted, do they just by themselves select new or just select tokens? Like who sets the rules? Which tokens are accepted? How do they do this?
00:33:27.492 - 00:34:15.614, Speaker A: The validators will. So we will start out with so the question is like how the tokens for pain fees are selected and initially all roll ups currently are having centralized sequencers. So there is one system and then for centralized sequencers it's up to the sequencer. As long as we will be running the sequencer it will be just major liquid tokens which we can sell instantly to cover our costs because we're going to be running Ziki sync at roughly the breakeven costs just the same way we do for version one. We're not making any profits, we're just covering the costs. So for us, what's important is just like market liquidity that you can sell. It's not some shitcoin that you're going to be stuck with at some arbitrary price.
00:34:15.614 - 00:34:28.420, Speaker A: And I think that once you have a consensus of validators, the same logic will apply. They will be willing to take any token they can instantly liquidate in this block or in this subsequent blocks. Because why not?
00:34:38.450 - 00:34:44.800, Speaker B: How would you use this functionality in an alternative way, if it is possible?
00:34:47.350 - 00:35:14.954, Speaker A: So you're asking about removing the payable functionality. So by payable I mean native special token in the system. Like Ether is a special token. It has its own special API, which no other token can replicate. Everyone else has to use ERC 20. But Ether has this special first class citizen status. So we're removing that.
00:35:14.954 - 00:35:52.006, Speaker A: We're making all tokens equal. This is a design flow. Essentially in the original ethereum. ERC 20 is somewhat clunky, has huge security risks because you either have to authorize unlimited access for a certain contract and then have one click transactions, or you have to make two confirmations for a transaction. If you just want to spend certain time, a certain amount of ERC 20 tokens. But that's just how it evolved. And we're thinking like with account abstraction, you will be able to mitigate that.
00:35:52.006 - 00:36:44.470, Speaker A: You will be able to also pack together transactions for ERC 20. But back to your question. It will not affect most protocols that are supposed to work with ERC, with tokens. In fact, there are many protocols that only accept ETH as WETH wrapped ETH because they want to treat all tokens in a uniform way. Or maybe does this answer yeah, you can. But you just like imagine a system where no one has Ether balances so you can use it, but it will never be used because no one can send you any money because you don't have native ETH, you only have tokens. But you don't need this ETH to pay gas because you can pay gas with your tokens.
00:36:44.470 - 00:37:15.244, Speaker A: Right? So the functionality can be there, but it will just sit idle and no one is going to use it. You wanted to add something? Just come over here to microphone. Yeah, I just wanted to clarify that if you have a payable function, you can still call it. It's just that the behavior will be the same as calling a non payable one because there is no native ETH. Maybe you can stay here for more questions. Sure.
00:37:15.362 - 00:37:28.176, Speaker B: How are gas fees calculated for non tokens? Is there something like how does it know what the value of die or whatever token would be?
00:37:28.278 - 00:38:19.164, Speaker A: So the question is how are guest fees calculated for non ETH tokens? And the answer is the validators know what the transaction will cost them. They know it in terms of like when they prepare a block, they know what amount of gas they will have to spend and what amount of computational resources they will have to spend on this block. Those two are tracked separately. Gas is like what you will have to pay for verification of your knowledge proofs on Ethereum, which is amortized across all transactions in the block. And then transaction specific costs like paying for storage, paying for events, paying for this and that. Computation is what it takes to actually the part of the producing zero knowledge proofs specifically this transaction. This part is largely negligible.
00:38:19.164 - 00:39:14.130, Speaker A: It will be like fraction of a cent. We have really efficient provers now we have hardware accelerated provers of FPGA GPUs, so those things are all done in parallel and small. But gas price is important. So the validators know, okay, we're going to have to pay for this amount of gas at the end of the block, which they still have to project, like what's the gas price will be in like ten minutes from now and 1 hour from now. So they have to get some margin there and then they see, okay, so we assume we'll have to spend like $5 for this transaction or like one dollars or whatever, like fifty cents. And then they look at the price of the token which you are offering them and they look at depth of the market for that token and they ask themselves for how much of this token do we need to have a guarantee to get $0.50 when we're going to sell it? Right.
00:39:14.130 - 00:39:26.390, Speaker A: This is what the threshold which they will be willing to accept and which their APIs will also render as acceptable price. Yes.
00:39:35.580 - 00:40:02.240, Speaker B: You were basically mentioning something very much like meta transactions, like people paying for the clients you are supporting, because I don't understand account abstraction at all as well. But if you're supporting seven, one two are method transactions supported automatically.
00:40:04.260 - 00:41:04.820, Speaker A: So the question is if I can repeat I'm sure I can repeat the question, but I will just answer maybe. Let's begin with clarifying what is exactly account abstraction. So on Ethereum, every transaction can only be initiated from the, what's it called, externally owned accounts, EOAS accounts that are controlled by ECDSA signatures. A smart contract cannot initiate a transaction. So you cannot initiate a transaction if you don't have ETH on something that is other than EOA. The idea of account abstraction is to allow contracts to implement their own logic of initiating transactions so the users can send some data to the contract, like make a call on a function and let the contract pay gas for this call if the contract believes that this is a legit call. Right.
00:41:04.820 - 00:41:56.340, Speaker A: So the contracts will accept transaction, the contracts will accept calls without the user having any funds, and the contracts will say, oh, this call looks good to me, I'm going to pay for it. And then the validators will see that and will accept this transaction. So that's the idea of account abstraction. So the question was, does it imply that you have meta transactions by default, it depends on your implementation of the contract. The contract might say, yeah, I'm willing to accept certain tokens and do certain manipulations with them. Or you can implement it differently, or you can just say, we're going to pay it from the protocol treasury to subsidize initial usage of the protocol. So even if it's not, we're not making profits, but we're just going to let users use the protocol for free for a while, up to the implementation.
00:41:58.840 - 00:42:01.190, Speaker B: What does the current roadmap look like?
00:42:02.440 - 00:42:20.552, Speaker A: We have milestone based roadmap. So the next milestone for us is to launch Mainet as soon as possible. So the team is completely focused on Mainet. Testnet is running really stable. You can try it out. Everything works really well. We have dozens of teams building already on testnet and preparing to launch.
00:42:20.552 - 00:42:56.724, Speaker A: And for us, it's just pushing out the main net first as ZK roll up. The second step after we launch ZK rollup in mainnet will be adding ZK Porter. We have implementation, we have a local testnet already running internally, but then we're going to add this, enable the integration. So Ziki Porter and ZK Rollup are not two different protocols. They are two different account types, but they are the same protocol. It's just the same state divided in two subtrees. And launching Ziki Porter will simply mean that we will enable this functionality because we will need a token for that.
00:42:56.724 - 00:43:07.508, Speaker A: We need distribution of the token, we need the validators with nodes for these validators, but the protocol itself will remain the one we're launching.
00:43:07.684 - 00:43:26.272, Speaker B: Regarding choosing, if I use MetaMask and I have account one, I can choose when you first do your, how do you choose it?
00:43:26.406 - 00:44:04.412, Speaker A: So the question is, how do you choose accounts on ZK roll up and ZK Porter? And the answer is, first of all, you choose account and it doesn't apply on transaction basis, it applies on account basis. Right. You can have two different accounts. Your accounts on Zkey rollup and Ziki Porter site will have the same address. So what you decide essentially is what you use. Most likely from the user perspective, it will look like just having different networks. So you can connect to ZK rollup network and then you use this account and then you use it from the ZK roll up site.
00:44:04.412 - 00:44:58.094, Speaker A: Or you connect your MetaMask to a ZK Porter network and then the same account with the same address will control a different set of balances. Right? But they have an interesting logic of interconnection, which I can't cover now because I need slides just to show explanation. But for user, it will look like this. So you decide where you go and most likely it will be protocol or like wallet assisted. So Wallets like Argent will just tell you, okay, you're creating it on Ziki Porter and you're going to use it there. Or with universal, wallets like MetaMask will just control it by network. I think we should actually cover more things in the presentation and more benefits of ZK based systems which we currently don't have.
00:44:58.094 - 00:45:49.300, Speaker A: Just one thing that came to my mind while I was talking was that on ZK rollup you can have transaction input that is essentially free, that is very cheap because it's not going to be propagated to Ethereum. So you can have transactions that accept a very long call data, do a lot of computations. This is going to be all cheap sands fraction of a cent and then they only save like make a few storage rights at the end and you will only pay for those storage rights. So you can think the applications can be structured differently because of this gas pricing. So we need to cover this in the future versions any more questions.
00:45:51.350 - 00:45:59.810, Speaker B: Regarding that? Why is that the case? Why would you have some people that make transactions so easily.
00:46:01.690 - 00:46:55.974, Speaker A: Because of the way how zero knowledge proofs work the question was why is that the case? What I just explained and the reason is we have to track two different metrics of pricing. One is call data that we use on Ethereum. This call data is used by all roll ups equally. All roll ups essentially compete for this call data. It's fixed, it's limited. If we use 50% of that, all other roll ups will only have 50% left. Increased demand from any of the roll up will affect everyone else because the gas prices will go up and gas spent on data availability is going to be your main bottleneck for all roll ups that's going to be the most important, most expensive part.
00:46:55.974 - 00:49:04.480, Speaker A: But for us we only use data availability, gas data availability space in the roll up to publish the changes in the state of the roll up we don't use it for anything else. Everything else is just computation of zero knowledge proofs and we only used Ethereum. We use a fixed amount of gas, roughly 1 million gas or 600,000 gas to verify proof of arbitrarily many transactions. If we use Starks, it would be like 5 million gas ten times roughly more but the cost to produce this proof is cheap per transaction on a per transaction basis it's going to be just a fraction of a cent. You had a question just because exactly. So the question is like why roll up offers linear boost and Ziki porter we are claiming unlimited throughput the reason for this is that Ziki roll up is limited by the data availability of Ethereum. So we only have this twelve and a half million gas which means like how many bytes per second? I don't know you need to calculate right? But you need linear amount of this data availability for the linear if you have N transactions you will need N pieces of data to put on this chain and this is going to be remaining limited even with ethereum going towards Dunk sharding.
00:49:04.480 - 00:49:45.020, Speaker A: It will remain limited. It will be larger by some factor n, but it will be still limited. You cannot go and add more and more and more shards in infinite way that will all be committed to in the same Ethereum block. Does this answer the question or not? It has zero to do with zero HPOS. It's all data availability. It's a different resource metric. ZK itself allows you to like we could have if data availability was cheap and limitless, we would not need ZK Porter at all.
00:49:45.020 - 00:50:09.130, Speaker A: We would have ZK rollup that is infinitely scalable. But that's not the case. So we'll need to parallelize data availability at some point. And this is what Porter is for. More questions? Cool. I think then we're done. Thank you guys.
00:50:09.130 - 00:50:30.620, Speaker A: It's.
