00:00:00.330 - 00:00:56.062, Speaker A: Yeah, I guess because it's a fairly small group, we may as well just, like, chat to one another and let's try and build something and put it on the Rweave and see what happens, I guess. Okay, so the Rweave is basically a decentralized storage platform that exposes data over Http. It's pretty much what it does. It also has, like, a database which provides you with a way of indexing tags that are associated with data, but you can use it to do things like this. So you can think of it essentially as like a web, right? Here's an Areweave transaction that has been sent to the network, and we're accessing it through a gateway. And this transaction is then querying the network itself and it's saying, hey, tell me about all the apps on the network that have been submitted with this particular wow, that's a nice sound. With this particular kind of content type.
00:00:56.062 - 00:01:24.422, Speaker A: And then it renders it into what you see here so it looks and feels just like a normal application. So if I log in, for example, I can drop my key file here. So the current trust model for these kinds of applications is pretty simple. It's don't give it a key you don't trust it to use. So you make a new key. You put as many tokens as you're comfortable with the application using inside, and that's basically it. So now we've logged in, we can do normal JavaScript stuff.
00:01:24.422 - 00:01:53.840, Speaker A: So, like, Queerweave is a quora like application built on top of the Rweave. You press the button, it's sent a transaction to the Rweave network now, so if we look on Viewblock, which is a kind of block explorer, it'll take a little while to settle. We can look at old ones. So, for example, this is that's not helpful. Encrypted data. Also. Encrypted data.
00:01:53.840 - 00:02:29.798, Speaker A: All right, here we go. Yeah, that's perfect, actually. So the transaction I sent the network just looks like this one here. So it's got a bunch of tags associated with it and says, I'm voting, and I'm voting up this content here. And then inside the application, what's happening in the background is just querying the network just as you would with any normal web application. And as a consequence, it's finding out how many votes each thing has. It's very, very simple, but it allows you to basically build any kind of web application that you would normally build in a normal web, except in a totally decentralized manner.
00:02:29.798 - 00:03:06.614, Speaker A: So this is going to the Rweave net gateway, but normally on Chrome, if you have the web extension installed, it'll go around the network, it finds nodes, and then when you need a piece of data, it just gets it for you. It's very, very simple. Yeah, and I guess the main use for it here is like, if you have a smart contract that lives in Ethereum, it's basically going to live forever. Right? If you have a UI that goes with that smart contract, say like a web UI, which is like maybe two thirds of smart contract applications. It's going to die at some point. That's not great. So instead you put it on the Rweave and it lives forever as well.
00:03:06.614 - 00:03:35.114, Speaker A: So now you have a permanent UI to go with your permanent backend. It's really simple and you just interact with MetaMask like you do in any other system. So let's just try it. So to get started, if you just go to Awiv.org, you can go to hosting and then say, deploy a page now it'll take you through to the documentation. That's not helpful.
00:03:35.242 - 00:03:35.920, Speaker B: Interesting.
00:03:37.590 - 00:03:40.238, Speaker A: I think it doesn't work. Okay, read the docs.
00:03:40.414 - 00:03:40.754, Speaker B: Fine.
00:03:40.792 - 00:04:25.490, Speaker A: So we go here, we literally just say NPM install, grweave deploy, which is just a deployment tool. And then once we've got it installed, we can just say, let's make a HTML file. HTML. It's going to be tiny text, isn't it? Great. Okay, fine. HTML body, h one one, hello New York. And H one Body HTML.
00:04:25.490 - 00:04:57.126, Speaker A: Okay, cool. And then that is too small. All right, there we go. Good, we can see it. So now we literally just have to say Rweev deploy and then name of the thing, HTML. And then we give it our key file. Except actually mine's already loaded.
00:04:57.126 - 00:04:59.450, Speaker A: So you would just say key file.
00:05:00.990 - 00:05:01.450, Speaker B: Sorry.
00:05:01.520 - 00:05:40.098, Speaker A: Right in the docs here, it points you to you can go to Tokens Rweav.org. It's very simple. Like if you just go there, it's linked to from the website you just put know. Unfortunately we had a continue with GitHub link and we wanted to make one that actually allows you to generate a proof of work in the browser and use that as sort of civil protection. Except the civil protection. There was this problem with doing that in the browser, which is that they're killing all these crypto miners. So if you do that, then they think you're a crypto miner.
00:05:40.098 - 00:05:59.194, Speaker A: It's not great. And also we had a GitHub one, but it turns out GitHub doesn't verify email addresses. So people are just like spamming out once and grabbing free tokens. But if you have a Google account, then you can get five free tokens. It's super simple. And if you don't have a Google account and you don't want to use Google, then just shoot me your address and I'll give you some tokens.
00:05:59.242 - 00:05:59.934, Speaker C: That's fine.
00:06:00.052 - 00:06:00.286, Speaker B: Yeah.
00:06:00.308 - 00:06:07.550, Speaker A: So you go here, you grab a key file like that. You download it and then you would just say key file here. But we won't.
00:06:08.470 - 00:06:08.834, Speaker B: Yeah.
00:06:08.872 - 00:06:44.586, Speaker A: And then we'll just say deploy. So it's asking me for the encryption key for my key file. So it says, yeah, you're going to send this file 62 bytes, blah, blah, blah, blah, blah. The tags will be content. Type this. So one thing that happens in the browser is when you render it with when you access a transaction with the browser of the Http server on the Rweave node, we'll say, okay, I'll take the content type and then I'll give that as a Http header. That means you can upload PDFs or whatever you want, and the browser will react to it in the right way.
00:06:44.586 - 00:07:17.078, Speaker A: Yeah, it says, Are you sure you want to do this? Because you can't take it back. It's just like ethereum. Once it's deployed, it's shared forever. It's literally permanent. And now it says, okay, it'll be there, and we can check the status here. So the key thing maybe has anyone here used IPFS? Okay, so IPFS has this idea that the data should be super fast to write, and very well, they don't have the idea that it should be slow to read. But the practical reality of the matter is it's very, very slow to read.
00:07:17.078 - 00:07:40.000, Speaker A: We have the opposite. So with Rweave, you have to wait for your transaction to be mined into a block. And it says pending here, and it'll do so for a few minutes. But once it is actually mined into a block, it's super fast, so it can get the data to the user in kind of like sub 200 milliseconds, approximately. Whereas, like with IPFS, you might be looking at I mean, we tried it once, it literally took 30 minutes to find a piece of data.
00:07:43.010 - 00:07:43.754, Speaker B: IPFS.
00:07:43.802 - 00:08:23.338, Speaker A: Yeah. So if you don't have the data cached locally on IPFS, it uses Kademia, which was this, like, distributed hash table that was invented in 1999 and hasn't changed very much since. And it's like basically the principle is everybody takes a sort of random key. They mirror routes for a sort of area of addresses, and the longer they're online, the more addresses and locations they get. But when you speak to someone and then they don't give you the data, so, like, that node has gone offline or something, you actually have to wait for it to time out. So it's extremely slow. However, we have the opposite system.
00:08:23.338 - 00:08:37.040, Speaker A: So what we do is we mine data literally into blocks and then we incentivize people for storing blocks. And we require that they rather we don't require that they store all the blocks, so they're just rewarded proportionally to the number of blocks that they do store.
00:08:38.070 - 00:08:38.386, Speaker B: Yeah.
00:08:38.408 - 00:09:09.020, Speaker A: And this means in practice, that almost well, everyone has an incentive to store every block. And storage is cheap, hashing is expensive, and as a consequence, there are very large numbers of replications of a piece of data. So we get rid of the data finding issue, which is like IPFS, when you get started transferring the data, it's very fast, but it's the latency for finding the data that makes it very slow. So we have this system that basically makes the data almost everywhere. As a consequence, it's very easy to find.
00:09:09.470 - 00:09:09.834, Speaker B: Yeah.
00:09:09.872 - 00:09:12.390, Speaker A: And that's how you can get the data in like 200 milliseconds.
00:09:12.470 - 00:09:14.902, Speaker D: Are you storing the data in IPFS?
00:09:14.966 - 00:09:40.594, Speaker A: No, not at all. No, this is completely separate from IPFS. Sorry. Yeah, so we actually have a system for incentivized data finding that we'll deploy before it gets to the point where it becomes slower. But you can also just do next hop routing, basically. So each of the nodes in the network ranks every other node that it speaks to. As a consequence, it builds up this kind of map of who you should speak to first.
00:09:40.594 - 00:10:26.786, Speaker A: And then if you ask for a transaction and it says, oh, sorry, I don't have that transaction, it just sends you to another randomly chosen person down the stream. As a consequence, you just bounce around. So if you hit your browser at it, it'll literally because everything is Http in the system, it'll just redirect you down like a rabbit hole of nodes until you get to one that has it. Sorry, can the data be no. So the thing about Arweave is that it's building a permanent web, like really permanent. So once you put a piece of information that's true, but they can't remove the incentive for storing old data. So there is always an incentive for other people in the network to store it.
00:10:26.808 - 00:10:31.560, Speaker D: Like if the data is big enough and there are portions that are not used.
00:10:32.330 - 00:10:32.742, Speaker B: Yeah.
00:10:32.796 - 00:10:57.050, Speaker A: So actually, what's happening in the background, I'll go to my slides, is we use this block restructure rather than a blockchain. So basically the idea is instead of just including the hash of the last block in the next block, which makes the chain, we also include the entire contents of a randomly chosen previous block. But the thing is, until you get to this block, you don't know what the random recall block is going to be for this block.
00:10:57.130 - 00:10:58.400, Speaker D: What's the block size?
00:10:59.330 - 00:11:39.180, Speaker A: It doesn't actually work like this. It's more about transaction size. So at the moment, the transaction size limit is two megabytes, rather three megabytes. But there's some overhead, except like, in the very near future, we'll push that to about 20 megabytes and then in about a year, we think we can get it to like, terabytes. So what we're doing currently is the proof of access that happens here, right? So you have to have the recall block in order to mine the next block, and you have to prove that you have access to it. The proof at the moment is fairly large and this is why the size has to be fairly small. But it's big enough for most web application, almost all web applications, and that's what it's supposed to be used for.
00:11:39.180 - 00:12:28.780, Speaker A: What we're doing in the future is moving to the system that we call Succinct proofs of access. So it's pretty basic. You take the data inside a transaction, you split it into tiny, like, chunks, we think maybe 128 bytes. Then you generate a merkel tree, and then you put the root of the merkel tree into the transaction rather than the data itself, then you distribute the data off chain using some kind of yeah, we actually think we're probably just going to use BitTorrent for it because it's good and it works. You distribute the data in that way and then you can make a succinct proof that you have access to the data by just giving like five or ten or maybe 2100, doesn't really matter. Different chunks from the data and the merkel root path. Right, so then someone that just has access to the merkel route can say, okay, yeah, that is actually the piece of data inside the system.
00:12:29.230 - 00:12:29.930, Speaker B: Yeah.
00:12:30.080 - 00:12:38.794, Speaker C: So you said it was permanent. When you get it onto the system, if you want to edit the information or do you want to change something, do you have to do something?
00:12:38.832 - 00:13:06.114, Speaker A: Totally mean? Yes is the answer, but it depends on the kind of data as to how you do that. So like if it's a web application, you should just issue another transaction. It's not that big a deal. So these web application cost, like so for example, I think this one was like 0.5 R, which is like so small a fraction of a penny. I can't really calculate it in my head. It's like very cheap.
00:13:06.114 - 00:13:32.990, Speaker A: So the problem is more that you have to wait some period of time and you just make it part of your deployment system. So like when I deploy, I wait 15 minutes approximately, but once I've got it there, then it's super fast and you can actually point users to this in production. Like it's fast enough that they won't really know that they're using any weird decentralized technology. It just looks like a normal web page. You can also hide this stuff behind DNS if you like and still enable TLS.
00:13:33.330 - 00:13:35.630, Speaker D: So how are the reads so fast?
00:13:35.780 - 00:13:36.286, Speaker A: Sorry?
00:13:36.388 - 00:13:37.950, Speaker D: How are the reads so fast?
00:13:38.100 - 00:13:49.522, Speaker A: So it's all down to incentives. So we basically flip the game. Like it's still hard to find data in decentralized networks, but we just make it so that the data is almost everywhere and there's an incentive for people to do that.
00:13:49.576 - 00:13:56.022, Speaker D: Mirroring can you put a number on an average? Like how many copies of data would you have?
00:13:56.076 - 00:14:02.710, Speaker A: Yeah, so if you put a piece of data into it today so if you store your web3 UI on it, you'll get like 400 copies.
00:14:03.130 - 00:14:04.582, Speaker D: Isn't that insane?
00:14:04.726 - 00:14:31.262, Speaker A: Yeah, but so is Bitcoin mining. But I mentioned that because what's happening here is you're making the storage of that data part of the mining process, right? So if you don't have access to that recall block, you can't take part in the hashing competition. So you have an incentive to store that recall block. And because storage is super cheap, you have a larger incentive to optimize that first. So store as much of the block weave as you can before you spend extra money on like, CPUs.
00:14:31.406 - 00:14:33.620, Speaker D: Essentially storage is cheap, but.
00:14:36.150 - 00:14:55.720, Speaker A: Right, yeah. So what we're doing is essentially just offsetting value that the miners were otherwise going to expend on this other expensive process. Like, hashing is a really expensive thing to do and it's completely useless. We just made our proof of work create positive externalities. You can think of it as.
00:14:58.170 - 00:14:58.486, Speaker B: You.
00:14:58.508 - 00:15:21.570, Speaker A: Can warm houses with hashing. That's true. We actually do have a miner, one of the people in our community who comes from Berlin, so he's German, and I can't quite tell if he's joking when he says, no, I am warming up my room. It's really annoying when my minor isn't on because my room gets cold. I can't quite tell if he's joking. The thing with this system is it's actually kind of cool, right. When it gets stretched.
00:15:23.830 - 00:15:24.478, Speaker B: If you don't.
00:15:24.494 - 00:15:36.754, Speaker A: Have the data, you do nothing. So you just don't expend any electricity at all. And subsequently your miner is just like sitting idly, but that's the most efficient way to mine. It's kind of interesting, but it does make your room cold.
00:15:36.802 - 00:15:49.322, Speaker D: CPU mining isn't that bad when you're getting into Asics and all that. That's where you're just wasting energy. A CPU sitting idle is still not doing any good.
00:15:49.376 - 00:15:49.980, Speaker A: Right.
00:15:50.510 - 00:15:52.694, Speaker D: You might as well use that for mining.
00:15:52.822 - 00:15:53.114, Speaker B: Yeah.
00:15:53.152 - 00:16:03.630, Speaker A: So actually what we expect people will do, like when it gets large enough, so at the moment they're just incentivized and they just draw the whole thing. Pretty much everybody, we think that'll actually stretch into the, like, terabytes before that stops.
00:16:06.530 - 00:16:07.182, Speaker B: Yes.
00:16:07.316 - 00:16:16.500, Speaker A: But we think sort of in the longer term, people will probably make kind of group mining systems. So like when the CPU is not mining this, they'll go mine Monora, something like that.
00:16:18.470 - 00:16:23.842, Speaker D: Going back to my first question on how are the reads so far? You said that you're storing like multiple copies.
00:16:23.906 - 00:16:24.520, Speaker B: Yes.
00:16:25.290 - 00:16:29.602, Speaker D: You still have to figure out on which node has got the copyright.
00:16:29.666 - 00:16:30.230, Speaker B: Yeah, exactly.
00:16:30.300 - 00:17:20.962, Speaker A: So the first node you hit, actually a whiteboard would have been way more helpful than that screen. The first node you hit will basically say, okay, do I have the data? If I don't have the data, I send you to you make a kind of exponentially decaying curve and you rank your peers on how likely you expect they are to have the data. And then you pick slightly randomly. Right. So you go down the list and you say, okay, well, 50% chance, I picked the first 125 percent chance, the second 112 and a half percent, and so on. And this essentially sends you around a random route through the network until you find the data. But in order to build up the rankings and why the rankings are so successful at doing this strategy is because we essentially use a system that's kind of like optimistic tit for tat from BitTorrent if you're nodding, not nodding.
00:17:21.026 - 00:17:21.254, Speaker B: Okay.
00:17:21.292 - 00:18:12.786, Speaker A: So, you know, like, the basic principle is if I give data to you you give data to me. And then every so often we just randomly give data to each other. And the equilibrium in this system is just like everybody gives data to each other all the time because you have that small optimistic element, right? As a consequence, you're ranking each other all the time on how fast you give data and the amount of data you have and this kind of thing. So like if you tell me you've got a piece of data, if you deliver it to me in sub millisecond, then I'm going to rank you way higher than the guy that says he's got a piece of data, but it's actually like 5 seconds to get it from him. So each node in the network is building up this kind of off chain reputation for every other node they speak to. And then when I come to you and I say, hey, have you got this transaction and you don't have it, you say, Well, I don't have it, but this guy over here probably does. And because of the random routing, you don't end up in cycles.
00:18:12.786 - 00:18:57.234, Speaker A: You just kind of explore the network until you find it. It's extremely fast, extremely efficient. We're going to change it. So after we do this sort of fast write project, which is the thing I mentioned, that allows you to use succinct proofs of access to write very large amounts of data into the system very quickly. We have this fast find project, which is that when you ask for a piece of data and you don't have it, you essentially send them down the route just like you do now. Except what you also do is you give reputation to the people that routed you to the right person. As a consequence, even if I've not got very much storage, by making really good routes of the network, I can still get a fairly good reputation.
00:18:57.234 - 00:19:30.260, Speaker A: And reputation is good for me because it doesn't just mean that I can access data quickly, but transactions and blocks are distributed according to those ranks, right? So if I end up at the bottom of everyone's ranks, I'm going to be the last person to get the data, the last person to get the block. As a consequence, I'm a really crappy miner. But if I'm the top of the list, it then I actually have an advantage over the rest of the network. In fact, at the bottom of the you just get dropped from the network completely. So you have this incentive to really compete for bandwidth and in the future compete for good routing paths as well.
00:19:30.870 - 00:19:31.620, Speaker B: Yeah.
00:19:33.030 - 00:19:34.980, Speaker A: Does anyone have any questions? I guess.
00:19:37.030 - 00:19:46.950, Speaker D: I saw one of the examples you have using Japhose or Japier zapier.
00:19:50.170 - 00:19:51.078, Speaker B: Oh yeah, sure.
00:19:51.164 - 00:20:25.954, Speaker A: So Zapier is really simple. It's kind of centralized, which makes it bad, but you can at least use it to set up little notification systems. So we have a bunch of bots on our Discord server, for example. There we go. So my homepage is an application built by someone in the community that just called Weavewatcher. Again, it's served from our Weave. It's a Permaweb app itself, and it just goes through the Weave looking for stuff.
00:20:25.954 - 00:20:32.900, Speaker A: And that transaction that we sent a few minutes ago is now here. So this has got an ID. We just put the ID in the thing, and you get that.
00:20:33.510 - 00:20:34.114, Speaker B: Yes.
00:20:34.232 - 00:20:57.898, Speaker A: Zapier. You can get an account with Zapier. You just press this button to sign up to our thing, and then you can make these sort of pipelines. So if there's a new tweet from Donald Trump, for example, someone's been archiving those all the time, it just gets the data, puts it in an Arweave transaction, sends it to the network all the time. And the other way around, you can actually integrate it with, like, hundreds of thousands of different things using that. Not hundreds of thousands, but at least, like, 10,000, I think.
00:20:57.984 - 00:20:58.490, Speaker C: Thank you.
00:20:58.560 - 00:20:59.660, Speaker A: Yeah, no problem.
00:21:00.130 - 00:21:00.542, Speaker B: Yeah.
00:21:00.596 - 00:21:19.862, Speaker A: So in the context of Ethereum, this is just a very, very simple way to store your UI in such a manner that you can actually give that link to people and they can use it, and it doesn't take them five to 30 minutes to load the web page. Like, it still has a really strong user experience, and I think if no questions, we're done.
00:21:19.956 - 00:21:20.614, Speaker D: Thank you.
00:21:20.732 - 00:21:21.062, Speaker B: Cool.
00:21:21.116 - 00:21:42.040, Speaker A: Oh, I guess also we have, like, a interesting we have a bounty, like $1,500 for the best project that stores its UI on Arbiv. It's very simple. Sell it's. Like, you just use it to store your UI. It's just like a normal web application. Okay, thank you.
