00:00:00.970 - 00:00:41.940, Speaker A: Hello, everyone. Just waiting for the live stream to get set up onto YouTube. Hi, everyone. We have Ed here from Arbitram who's going to be doing a workshop on inside Arbitram Nitro Workshop or sorry chat or questions. As always, go into the zoom chat. If you have any questions, definitely ask them and Ed will answer them all at the end. And with that being said, I'll pass the mic off to Ed.
00:00:42.390 - 00:01:20.446, Speaker B: Hey, thanks. Welcome, everybody. Thanks for your time. Today I want to talk about Arbitram Nitro, which is the latest and greatest version of the Arbitrum technology that I hope some of you know and love. Nitro is a top to bottom rewrite of our software stack to make it faster, simpler, and cheaper to operate than our current Arbitrum stack. So Nitro is now on testnet and we're driving toward migrating the Arbitrum mainnet onto the Nitro software stack. So I want to talk about how this works.
00:01:20.446 - 00:02:01.980, Speaker B: We'll go inside and really try to give some idea of how it works on the inside. So I want to start with basically four concepts that I'm going to go over as we talk about how it works. First, that it's an optimistic roll up. Second, that it functions by doing sequencing followed by deterministic execution. That we put gap at the core of the software and that we separate execution from proving. I'm going to go into a lot more detail about what each of these mean, but this is just kind of a roadmap. Okay, so first, optimistic roll up.
00:02:01.980 - 00:02:54.970, Speaker B: What does that mean? Well, first, it's a roll up. And roll ups have gotten a lot of attention lately. Probably one of the big things that drove attention to roll ups is this post by Vitalik about a year and a half ago. Now, basically talking about a roll up centric roadmap for Ethereum. The idea is that roll ups provide a level of scalability and low cost that the Ethereum chain itself has trouble providing. And so Vitalik talks here about a roadmap for Ethereum where Ethereum focuses on enabling rollups. Roll ups provide the execution and storage layer for applications, and Ethereum focuses on being the best underlying layer for roll ups.
00:02:54.970 - 00:03:38.602, Speaker B: So that roll up centric roadmap, what that means is that the kind of technology that Arbitram and Nitro is, is the kind that is in the roadmap for Ethereum to support and to become the main sort of execution layer for Ethereum. So what roll up means, essentially is that the data of your transactions is stored onto the L one Ethereum chain. It's an optimistic roll up because of the way that we settle transactions back to the Ethereum chain. It's an optimistic protocol, which means it's a protocol that is always guaranteed to be correct, but is especially fast and efficient when people behave according to their incentives. And I'll talk more about what that means.
00:03:38.736 - 00:03:44.110, Speaker A: Yes, so sorry to interrupt, but you're not actually screen sharing your slides right now.
00:03:44.180 - 00:03:46.800, Speaker B: Let me screen share. Thank you.
00:03:47.250 - 00:03:48.350, Speaker A: No worries.
00:03:48.930 - 00:03:49.840, Speaker B: All right.
00:03:50.210 - 00:03:53.246, Speaker C: Okay, there you go.
00:03:53.268 - 00:03:56.382, Speaker B: Now you can see it. Okay. An ethereum centric roadmap.
00:03:56.446 - 00:03:56.962, Speaker C: Okay.
00:03:57.096 - 00:04:43.446, Speaker B: The second thing about Nitro is that it operates by doing sequencing, followed by deterministic execution. And this is where we really start to get into the nuts and bolts of how things work. I want to tell the story of how Arbitrum Nitro takes transactions and actually executes them and finalizes them. So it starts with this component called the sequencer. The sequencer is currently a centralized component that's run by our team, the Arbitram team. But we're moving toward a decentralized sequencer approach. The sequencer's only job is to take transactions that are submitted by users and to put them into an order, into a sequence in what order they arrive.
00:04:43.446 - 00:05:12.890, Speaker B: The sequencer follows a first come, first served approach to sequencing. And the only thing that the sequencer is trusted to do is to say in which transactions arrived in what order. There is a mechanism, if the sequencer tries to censor you, that you can bypass it and still get your transactions into the sequence. But I'm going to skip that for simplicity in the explanation. So the sequencer's job, take these transactions that you submit and put them into sequence.
00:05:14.350 - 00:05:15.194, Speaker C: Okay?
00:05:15.392 - 00:06:08.410, Speaker B: Now, once the transactions have been sequenced, now the sequenced transactions can be run through the state transition function. The state transition function is basically a piece of code, a piece of logic that says what each transaction does. And it's a fully deterministic function, meaning that if you give it the same inputs, it will always produce the same output. So the state transition function will take the next transaction in the sequence, and it will take the state of the chain, and it will do that deterministic computation on it. And the result of that will be to update the state. If your transaction does things like move assets around, the state transition function will update the state to record the asset transfers and other things that have happened. And then the state transition function will sometimes emit a layer two Arbitram block.
00:06:08.410 - 00:06:58.634, Speaker B: Okay, so this is how execution happens. Logically. Transactions are put into sequence, and the sequence of transactions are run through the state transition function one at a time. Now, one thing to note about this is because the state transition function is fully deterministic, that once you know the sequence of transactions, that sequence of transactions fully determines how the state will evolve, and it fully determines what the L two blocks will be. And what that means is if you know what the sequence of transactions is, then you, operating all by yourself, can execute the state transition function yourself in your own node and know what the result of computation on the chain is going to be. Right? So everything follows. The sequence of blocks follows in a deterministic way from what this transaction sequence was.
00:06:58.634 - 00:07:45.386, Speaker B: Okay, but how do you find out what the transaction sequence was? Well, the sequencer first publishes a feed of the sequence transactions. Anyone can subscribe to and receive that feed. And the sequencer produces that feed in real time. So you submit a transaction to the sequencer under normal conditions. In less than 1 second, your transaction will be sequenced and will appear on the feed. So that feed is the sequencer's promise as to what the sequence is that it's producing. So if you believe the sequencer's promise, then you know in less than a second what the result of your transaction will be, because you can subscribe to that feed, take the transactions on the feed and run them through the state transition function.
00:07:45.386 - 00:08:24.038, Speaker B: And now you know everything about what the chain is doing. The sequencer will then every few minutes, will take a batch of the sequence transactions and it will batch them together to make a big block of data. It will compress that data for efficiency. And then it will write that compressed data onto the L One ethereum chain. And this records what the transaction sequence is. And as soon as that transaction, that ethereum transaction that records the compressed batch, as soon as that has finality, then the sequence of transactions is final. And then everyone can look at that.
00:08:24.038 - 00:09:17.270, Speaker B: They can execute the state transition function for themselves and know exactly what the chain will do. So this is the when the batched and compressed transactions are written to the L One chain, then all of these transactions have finality because the L two blocks are an inevitable consequence of that batch and the batches previously recorded. Okay, now, so let's talk about finality and how finality works. In this space, there's basically three forms of finality, if you will, in a system like this. The first is what I'll call soft finality, which comes in about 1 second. To get soft finality, you subscribe to that sequencer feed. You compute the state transition function on all of the transactions that come out in the feed, and then you know the result.
00:09:17.270 - 00:09:48.958, Speaker B: And the guarantee is that that is the correct result of what the chain will do, provided that the sequencer's feed is correct. If the sequencer is being honest, the sequencer is making that promise. It has the power to keep that promise. So unless that you have finality within 1 second or less, the second version is hard finality, which comes after about ten minutes. So to get that hard finality, you watch the L One ethereum chain. You look for those compressed batches. You decompress each batch to know the transactions.
00:09:48.958 - 00:10:36.994, Speaker B: You compute the state transition function on there. And then you wait for that compressed batch to have finality on the ethereum chain. And the guarantee there is this is as final as your L One finality assumption, all right? And then finally, there is certification. And this is the process by which the ethereum chain learns what the result of computation is. Now, I said before that anyone who sees the transaction sequence can figure out what the chain does and know the result with certainty and finality. And that's true. So you might ask why doesn't the Ethereum chain know in 1 second or ten minutes what the result is? And the answer is the Ethereum chain doesn't have the computation power that you or your laptop or phone or really anyone has.
00:10:36.994 - 00:11:11.514, Speaker B: Ethereum has a really slow and limited computation capability which is why we're doing this layer two thing in the first place. So Ethereum cannot compute along with the chain even though your laptop can. And so we need to use another method to convince Ethereum what the result is. And that takes days, typically seven days. So in order to see this, you just wait for the L two blocks produced by the Arbitrum chain to be certified on the L one. This is really only used by L one contracts. That is, they're the only entities whose world is constricted.
00:11:11.514 - 00:11:13.950, Speaker B: So they only see what Ethereum knows.
00:11:14.530 - 00:11:15.360, Speaker C: All right?
00:11:16.210 - 00:12:06.906, Speaker B: So that is how sequencing and deterministic execution works. The second piece of this is Geth at the core. The idea here is that in order to have the Arbitram chain be compatible with Ethereum as closely as possible we actually take the core of Geth or Go Ethereum which is the most popular and sort of authoritative Ethereum node. And we take the core of Geth which does EVM emulation and tracks the state, maintains the Ethereum state database and all of that stuff. And we actually build that into Arbitrum nitro. So we use the very same code that Geth uses to do EVM emulation. So that's the geth core.
00:12:06.906 - 00:13:09.406, Speaker B: On top of that Geth core we put a layer which is not to scale here it's actually much thinner that we call ARBOs. So ARBOs basically takes on top of that Geth core and it gives you the few additional things that you need in order to be an L two chain. This is things like making sure that the sequencer gets reimbursed for its Ethereum gas costs. It handles deposits and withdrawals that is, movements of ETH or tokens between Ethereum and the Arbitrum chain and various bookkeeping type functions. And then on top of that we take node functionality. This is things that take your node and they turn it into a server that can respond to RPC requests from your wallet and can do all of the things that an Ethereum node can do in terms of serving the user. So we sometimes refer to this as a kind of geth sandwich.
00:13:09.406 - 00:13:34.250, Speaker B: And the reason for this is that we have the Geth core at the bottom that comes from this very standard Geth Ethereum node. We have this ARBOs layer in the middle which is custom. And then on the top we have the node functionality which again, mostly comes from the Geth code. So that's the Geth sandwich, right? Geth is the bread and this thin ARBOs layer is the payload in the sandwich.
00:13:35.630 - 00:13:36.380, Speaker C: Okay?
00:13:37.710 - 00:14:55.970, Speaker B: Now, the state transition function I talked about before, the part of that takes a transaction and the state and then updates the state and maybe produces a block. Remember that that deterministic function, that's what I've outlined here on this slide in orange. It includes all of the gas core because it is taking care of emulating the ethereum, making sure to emulate Ethereum execution and keep track of the state of the Arbitrum chain just as if it were in Ethereum chain. And then also some pieces of ARBOs, the parts of ARBOs that are needed to keep track of things like deposits and withdrawals and accounting and so on, those are in the state transition function. And so this setup is highly compatible with Ethereum because we use the Geth core for EVM emulation and because we use Geth code at the top as the top bread in the sandwich to be compatible with the network, with the RPC API that Ethereum nodes provide. All right, let me move on to the last piece now, which is separating execution from proving.
00:14:57.930 - 00:14:58.486, Speaker C: Okay?
00:14:58.588 - 00:16:02.230, Speaker B: So remember this piece, right? This is what I just showed you. The blue part is the full node software. The orange part is that state transition function, which is the part that needs to run correctly and reliably and provably in order to guarantee a correct outcome. So we take that blue piece, the entire node, and you can compile it to native code just using a standard compiler. This software is pretty much all written in Go and so we use the standard Go compiler and you can compile that to run on your machine and then you can run that as a node. So if you're running an Arbitram nitro node, you just are running a program that runs on your machine which is compiled from all of this blue stuff and it will do all of the things that you would expect a node to do. We then take separately the orange piece, just that state transition function and we compile that using the same Go compiler.
00:16:02.230 - 00:17:18.898, Speaker B: But instead of compiling two native code that should run directly on your machine, we instead compile it to WASM or WebAssembly format, which is a machine independent and efficiently executable format for expressing code, which is developed by a consortium of companies and developers. And so we use that for proving. So if there is a dispute between different parties in our protocol about what the state transition function this orange outlined code should do, that dispute is resolved or refereed in the context of this WASM code. So the WASM code is the definition of what the correct execution of the code of the state transition function will be. And the beauty of this sort of dual compilation mode is that in ordinary execution, when you're just running a node and the chain is running along, it's running as native code, which is the fastest way to run a geth type functionality. So you get a lot of speed by doing that. But then if there's a dispute and you need to do proving, proving doesn't need to be quite as fast and efficient, but it needs to be extremely portable and reliable and secure, which is what WASM is excellent at.
00:17:18.898 - 00:18:11.618, Speaker B: So we use that for proving. And this is one of the core tricks that allows Nitro to be really fast and also to be fully provable. Okay, let me talk about how the proving mechanism works, because this is part of the secret sauce and in fact, this is the part of Arbitrum that we devised first back in 2014. And there's a question in the chat, which is, if soft finality is 1 second, hard finality is ten minutes, what time frame can I do a dispute within? And the answer is you get seven days to do a dispute. So you have finality very quickly. Finality means that the result of the transaction is inevitable. People can still dispute it because someone could try to make a false claim about what the outcome will be.
00:18:11.618 - 00:19:02.686, Speaker B: But if you're an honest party, you can force if your transaction has finality, that means that you, acting alone, can force the correct outcome of your transaction through our protocol, no matter what everyone else does. If every other person in the world is evil. But you know what the correct outcome of your transaction is, you can force that result. And that's why we say you have finality, because anyone can enforce the correct outcome. Okay, so how does this work? How do we actually prove or resolve disputes? Let me dig into that. And this is how we actually settle the result of transactions back to the ethereum chain. So it starts with Alice, who's just some arbitrary person in the protocol, and Alice makes a claim and she puts down a stake to back that claim.
00:19:02.686 - 00:19:48.542, Speaker B: And her claim is this. She claims that in the current state of the chain, that is the start state, that everyone agrees on, that after the chain executes N blocks, creates N blocks, that the end state will be some particular thing. Now, these states are really just cryptographic hashes of the state, so they're small. But because execution is deterministic, there is a correct answer about what the end state is. So on this diagram, I've drawn the start state in black because everyone agrees that that's correct, that's known correct. And I've drawn the end state in orange to reflect the fact that Alice claims that it's true, but it might or might not be true. So Alice makes this claim.
00:19:48.542 - 00:20:23.774, Speaker B: Then a challenge window opens up a period of time in which everyone can look and see if they agree with what Alice said. And if they do agree, then they don't need to do anything. You could just sit back and wait. And if the challenge period passes after seven days and no one has disagreed with Alice's claim, then Alice's claim will be accepted and the protocol will move forward. And that is the common case Alice has staked on her claim. So her incentive is to make a claim that's correct, and other people would have to stake to dispute it. And if her claim is correct, that would be foolish of them.
00:20:23.774 - 00:21:15.790, Speaker B: But let's say that Bob actually disagrees. Bob responds and he says, no, the start state is the same, but I think the end state is different. And now I've drawn the end state in red to show that we know that Alice and Bob disagree about what the end state is. Alice makes one claim, Bob's makes a different claim, and what the protocol is going to do is identify one of them as being a liar. So how does that work? Well, the first thing Bob does is, in addition to saying what he thinks the end state should be, the protocol forces him to make a claim about what the state is halfway through after N over two blocks. Right? So now Bob logically has made two claims that each are N over two blocks, and now it's Alice's move in the protocol. So Alice has to do one of two things.
00:21:15.790 - 00:21:59.338, Speaker B: She can either say, she can either disagree with Bob's mid state, in which case we're in the top one of Alice's choices here. If she disagrees with Bob's mid state, now you have a situation where she agrees on the start, where the two of them agree on the start state, they disagree on the mid state. So this looks just like the situation up at the top of the slide, except we've cut the number of blocks in half. Alternatively, maybe Alice agrees with Bob's mid state. And in that case, we have the situation at the bottom where Alice and Bob agree on what the mid state is, but they disagree on the end state. And again, this looks like the diagram. Alice's initial claim up at the top, except half is large.
00:21:59.338 - 00:22:33.862, Speaker B: So Alice is going to pick one or the other of those to do, depending on whether she agrees or disagrees with Bob's mid state. And let's say that Alice agrees with Bob's mid state and chooses this one. Okay, so now Alice has done that. That's her response. And now we force her to again break her claim in half by claiming what is the state halfway between halfway through that series of N over two blocks. Well, now that looks like Bob's situation in the middle, except, again, half is large. And so now it's Bob's turn.
00:22:33.862 - 00:23:35.894, Speaker B: He's going to have to identify one of the two sides of Alice's claim and break that in half and so on. And so you can see that in each round of this protocol, we cut the number of blocks under dispute in half. So after a logarithmic number of rounds, we get down to a dispute about a single block. Right? And this is a very efficient protocol because Alice and Bob are doing all the work. There is a contract on the L one ethereum chain, which is the referee in this protocol, but it's just like making sure did Bob post a claim about the midpoint? And did Alice say whether she's disagreeing with the left or right half of Bob's claim? And did Alice then post a claim about what she thinks the middle state is and so on? The referee at this point just makes sure that each player actually makes a move that looks legal ish. And by doing that, the parties do all the work and you get down to a disagreement about one block. All right, so now here's the full challenge protocol.
00:23:35.894 - 00:24:15.506, Speaker B: So we started with step one up. At the beginning, alice made a claim about the result of N blocks of computation and Bob disagrees. We bisect the dispute down to a disagreement about one block. Now, what happens inside that block? They're disagreeing about that block. Well, Alice now claims how many steps of computation, how many individual instructions of WASM got executed by the state transition function to produce that block. Alice makes that claim and now you can again do bisection, but now you're doing it over steps of computation. And the states are states of the WASM execution.
00:24:15.506 - 00:24:55.650, Speaker B: So you again bisect down to one step of computation. So like one add instruction or one memory read instruction or something like that in WASM. And once you've done that, alice then submits a proof of just that one step of computation. And at that point, we'll know who is lying or telling the truth. Now, this protocol guarantees that a party who's telling the truth can always win the game and force the liar to lose. And so the result of this is that we're going to identify a liar. That liar will lose their stake, half the stake goes to the other party, and then we're able to prune off the claim that liar made.
00:24:55.650 - 00:25:45.406, Speaker B: And so if you make a correct claim, you will eventually be able to prune off all the counterclaims that might disagree with it, and then your claim will be accepted. So that's how the protocol works. One nuance here is that we don't actually bisect into two pieces. We instead, for efficiency, break into about 400 pieces, with Alice or Bob putting about 399 intermediate points and the other party choosing one very small subsegment that just reduces the number of rounds. But that's basically the challenge protocol. And you can show that by using this protocol that a party who is correct and telling the truth can always force the correct outcome to be accepted. Okay, so that's arbitram nitro in a nutshell.
00:25:45.406 - 00:26:34.334, Speaker B: You can try it out. It's running on a public testnet we call it a DevNet that runs on top of the Gorely Ethereum testnet. There's a URL here on how to get to it and how to use it. We're really excited about nitro it's on testnet. It's going to be a huge step forward in scalability order of magnitude, improvement in throughput and gas cost reduction. We're not making promises, but if I were a betting man, I'd say maybe a factor of two reduction in gas cost over what is currently on arbitram. We are also working on follow on technologies, including something called Arbitrum, any trust which is able to drive down the cost further.
00:26:34.334 - 00:26:55.706, Speaker B: But I don't have time to talk about that today. So that is it. One more thing. The mandatory please come and work for us jobs@offchainlabs.com or reach out to me. I am Ed Felton on Twitter or Telegram with this name here. So that's it.
00:26:55.706 - 00:27:02.030, Speaker B: Let me go back to the DevNet URL and then any additional questions by chat?
00:27:04.930 - 00:27:10.640, Speaker D: Yeah, we do have a few questions in the chat I see there. I don't know if you see it on your end.
00:27:11.570 - 00:27:14.030, Speaker B: Okay, I've answered let's see a couple.
00:27:14.100 - 00:27:15.642, Speaker D: I think you answered both, actually.
00:27:15.716 - 00:27:17.460, Speaker B: Yes, I believe answered both.
00:27:18.390 - 00:27:37.410, Speaker E: I have a question Ed, if you don't mind. Go ahead, sure. So I have a question around fraud. I was speaking to a lending team and they said if their users are transacting with lending and borrowing on Arbitrum and fraud occurs, what happens to their users who are lending and borrowing when fraud is confirmed?
00:27:37.570 - 00:28:41.250, Speaker B: If fraud is confirmed? Well, nothing happens. Essentially nothing happens. So the way we think about so if you're a normal user of the system, you won't even know that someone tried fraud. What I mean by that is that honest Arbitrum nodes just look at the transaction sequence and they compute the state transition function for themselves and so they know what the correct outcome of the chain is. So the fact that a bunch of people are over somewhere else quarreling about what the outcome is in that sense doesn't matter. So from the user experience standpoint, the fact that someone attempts to commit fraud is not something that you'll ever see. What you see as a user, if you're connected to an honest arbitram node, just like if you're connected to an honest ethereum node, you see a chain that just marches forward and that executes correctly.
00:28:41.250 - 00:28:59.266, Speaker B: And because of that very strong guarantee, because of that very strong guarantee that any one honest party in the dispute protocol can force a correct outcome, as an ordinary user, you don't have to worry about it. And the user experience is that you.
00:28:59.288 - 00:29:00.420, Speaker C: Don'T even see it.
00:29:01.990 - 00:29:12.200, Speaker B: You see correct execution and you see finality in either the 1 second time frame or the ten minute time frame, depending on what kind of node you're connected to.
00:29:13.690 - 00:29:15.320, Speaker E: That's awesome. Thank you.
00:29:15.690 - 00:29:18.214, Speaker C: Thanks. Great.
00:29:18.252 - 00:29:22.140, Speaker D: Do we have any more questions? I think we're slowly running out of time here.
00:29:23.870 - 00:29:25.260, Speaker C: I think that's it.
00:29:26.190 - 00:29:31.194, Speaker D: Well, thank you very much. That was very informative. I'm sure everyone that was part of this really enjoyed it.
00:29:31.392 - 00:29:39.738, Speaker B: Thanks, everyone, and feel free to reach out. My Twitter and Telegram contact address are on the bottom of this slide now.
00:29:39.904 - 00:29:40.330, Speaker C: Perfect.
00:29:40.400 - 00:29:51.426, Speaker D: There's also a Discord Channel as well under ETH Global sponsor Discord Arbitram so you could find the team there. Thank you very much and thank you all for joining us today. We'll talk soon.
00:29:51.528 - 00:29:53.360, Speaker B: Thanks, everybody. Thanks.
