00:00:00.410 - 00:00:39.462, Speaker A: Thank you. So I am only the introduction, so don't worry. It's basically a hands on workshop. But I thought maybe I can give you a little bit sort of high level interview about sort of overview of how this tool works. I really encourage you to ask question during the during the presentation issue. So the pain point that we are addressing, I'm sure you know, but it's not specifically to web3 that you have buggy code. I think there are a lot of code analysis tools in web two and in web3.
00:00:39.462 - 00:01:19.730, Speaker A: And what my feeling is somebody who's working it mainly from the academic side that they don't work. And there are two reasons why they don't work. And you can see it from most existing tool is that they have false positive and they have false negative. They miss errors and actually most of the errors that they report are not real. And this is actually where you will see if you can come and stay in the workshop. And Sasha and Armand, they will actually show you how to make this tool which actually works at the moment is only in webtree and Solidity and Viper. But we think that this tool can be used also outside the area of webtree.
00:01:19.730 - 00:01:54.346, Speaker A: What Satora is doing. And we are building different tools. I'm only going to show you and this on the workshop. It'll be only the Satora approver, but Satora is building different tools for code security. And the other side of the coin, which is something Satora doesn't do, but it's equally interesting for us and that's why we are here is the connection with security team. So basically there are security teams like Code Arena actually interested in spare Bit and others twelve bit that interested to use this technology. And there is synergy between the people, between the community and between the tools.
00:01:54.346 - 00:02:48.398, Speaker A: And that's actually something we love about it. And of course, if you want to engage with us, you will get actually a trial key and you can try the tool. And if you want to work with us and also with Colorina that's actually doing this, that's great. So basically the glue, the interface between the community and the people at the moment is this CVL language that you will learn and you will learn from the team here. Basically it's a language for expressing properties of your code. So you write some kind of properties of your code in our language and then you can use our tool to do many things and in particular we can find bugs for you. So maybe just sort of just to give you intuition why I said that actually existing tools do not work, I'm actually using one of the best or tools.
00:02:48.398 - 00:03:09.446, Speaker A: So this is slitter. How many of you know Slitter? Fantastic. How many of you use Slitter? So Slitter is fantastic tool because it's actually very easy to use. But the problem with Slitter and you can see that here. I ran it on a very, very small contract. It's a tiny, it's basically a low word. And you see many, many red arrows.
00:03:09.446 - 00:03:45.234, Speaker A: Do you want to guess how many of them are real? None. Exactly. So the problem we want tools. And what you will see today is tools that you have arrows that when they are produced, they are produced with actually sort of a test case showing the violation. So how does the Satora tool work? You will see actually today you will learn. But the idea is that you kind of write your code twice. You write once you write your code in solidity or Viper or Rust or any other language, and then you write what you think about your code.
00:03:45.234 - 00:04:09.050, Speaker A: These are specification, these are some properties of your code. And the tool can do two things. The tool can give you a proof that's very interesting, but it's a bit boring. It says okay. Verify. But the most interesting use case of this is finding bugs which are hard to find. And we have actually used this tool before auditing and after the best auditing and found very interesting edge cases in your code.
00:04:09.050 - 00:04:49.042, Speaker A: Some of them you can actually use to actually deplete completely the money. So this is the tool that we are using. It's basically a tool that actually automatically either prove property or actually find test cases indicating violations of these properties. I have to warn you, we are addressing a very, very hard computational problem. It's considered the hardest problem in computer science. And this means that the tool is doomed to fail in certain cases if your code is too complex, if you have inline assembly, we can handle it. And we need sometimes help from the user.
00:04:49.042 - 00:05:33.986, Speaker A: So there are failures of the tool and there are mechanism where you can handle failures. So if your code is too complex and this is unavoidable, because we are addressing a problem in computer science, which is called undecidable, which means that the computer will always and since our tool is automatic, unlike existing framework, if you had this tool is automatic, you just write what you think about your code and it's almost like unit testing. You get approved or you get a violation inside Certora approver. I'm not going to be able to show you. But there's a lot of technology involved. There's a lot of technology. And interestingly, the tool actually doesn't analyze your solidity code, it analyzes your bytecode.
00:05:33.986 - 00:06:09.698, Speaker A: So it invokes the compiler. And then after that it analyzes your bytecode. And it's implemented a lot of sophisticated method that we actually have developed, and it were developed in academia in the last 30 years in order to work them. Most of them are relevant not just for blockchain, they are relevant for low level code. In particular, I want to point out that we have sort of a very, very we pointed out about Slitter. So inside Certora, there is actually a very, very complex slit. There is a very, very complex code that checks your code.
00:06:09.698 - 00:06:53.246, Speaker A: And actually this complex code, by the way, it found many bugs in the Solidity compiler itself, which are acknowledged by the Solidity. And the other thing that we are doing at the moment, you can think of Satora like a kind of smart compiler that compiles your code into mathematical firmware. But this is a naive solution and usually it works in certain small code. So what we do, we do a lot of things to make your tool work on realistic code. And this is a lot of complex things. There's some information on our website we actually just published yesterday evening, a white paper we encourage you to read. And I don't know if you got it, so we just published it for this workshop, so please read it.
00:06:53.246 - 00:07:24.614, Speaker A: And also I'm here this week and there's a lot of people on the team, the R D team is coming, so please ask us questions. This is just one acknowledgement from the Solidity team about Bug security. Bug actually was fined by the Satura approver. So how does it work? You will see later from Eura. But the idea is you write your code and you write some invariant. You see, for example, this is a very, very simple kind of transfer. And the invariant says that the total is equal to the sum of balance.
00:07:24.614 - 00:08:10.310, Speaker A: Or maybe you say that the sum of the balance doesn't change and the tool can actually give you a proof that this is preserved. And maybe it's boring because it's very simple code, but this is the kind of piece that you can prove. And of course, if you have overflow in your code, then the tool will identify that and give you an edge case for the overflow. But if you do not have a low overflow, for example, you're using Safe Mass or you're using Solidity zero eight, then in fact it can guarantee generate a proof and it generates the proof on the EVM level. So that's nice, but that's kind of boring. I said this is a bit more interesting. Here is I guess it's kind of a trivial bug, but this is a case that you have a bug, a code with a bug.
00:08:10.310 - 00:08:58.508, Speaker A: I'm sure most of you have seen this bug, it's so silly. But still, do you know what's the bug here? The problem is that this code does not maintain the invariability. Do you want to guess? There is a violation, the tool will find it, but I'm sure you will find it too. So what can get wrong here? It's almost like the same code. It's done in two steps. Basically it's assigned to a local variable and later on and then this local variable is stored into storage. Nobody can help? No.
00:08:58.508 - 00:09:28.050, Speaker A: So let's assume it's a uint, so balance cannot be negative. Overflow is an interesting thing. But let's assume we are working with safe mass because otherwise the previous code also. So let's assume overflow is a bug. But I'm looking into a more interesting bug that this bug by the way, allow you to a lot of money was stolen using this bug. So it's more interesting than overflow. It's almost trivial, but still BZ.
00:09:28.050 - 00:09:49.642, Speaker A: Yes, rentancy is not a problem here because it doesn't call other code. We can check rentancy, but here it doesn't call other code. Yes, exactly. Fantastic. Thank you very much. So it's a self transfer and you see the tool actually can find it. So this is the kind of thing that we want to find.
00:09:49.642 - 00:10:24.406, Speaker A: And I can show you that we found many more interesting errors because this is a very very simple error. But still, you know, bizarre text, lost few minutes. But this is a kind of bugs that we want to prevent before the code is shipped. So the biggest value of this technology is inside your development. It's basically integrating to your CI. So every time you change your code, you run this thing, you write this specification. And if you write this specification right, you can reuse them every time you change your code.
00:10:24.406 - 00:11:03.570, Speaker A: We are finding that sometimes different customer can reuse the same specification, which is fantastic. So what you will learn is writing specification and specification. One way to think about them, and this is of course go back to Aristo, is invariant. You write some things that you think if this is the property that all your states in your program has to satisfy. And in DeFi the interesting thing, when you have assets, you want to basically make sure that you have enough assets to cover your bill. And this is what you have to write. And you will see later in the workshop that you write these invariant.
00:11:03.570 - 00:11:53.278, Speaker A: And what Satora does, it does two things. It's basically bill you these tools and these tools, you can actually write invariant and you can check them. And it's basically a tool for the community, for auditor, for security researcher, for developers to write this environment and to check whether they hold or don't hold. How is Satora doing today? So you see that actually Satora is actually protecting some of the most important protocols in this space. We are actually analyzing many, many lines of code. Actually if you count in EVM, it's even more the things that we are and people run it like there's companies who run it actually more than us. It's a cloud based you will see the thing that we are very very proud of the bugs that we have prevented.
00:11:53.278 - 00:12:34.318, Speaker A: So with this technology, we have prevented a lot of security bugs. And I will give you just example, but you'll see a lot of our website and some actually acknowledged by our customers. So maybe I just give you a few kind of examples that we found. So sort of the biggest property that you can think for DeFi is solvency, which means that even if everybody goes to the bank, you can still get your money. So maybe insolvency means that you are banker. And these are insolvency issue which are found by the Satora approver after manual audit. So these are teams which are very, very careful about security.
00:12:34.318 - 00:13:16.718, Speaker A: They use the top and you see that they use the top auditors. And we run the tool after the top auditor said that the code is correct. Okay? And these are the bugs that are found by this technology. And I think this is actually how you can measure this technology. How many bugs are found, how is this technology compared to other tools? So of course, there's no silver bullet, and even if they run formal verification is not actually silver bullet. So the idea is manual auditors course can find bugs that formal verification will not find, especially if you don't have the right specification. And writing specification, as you can see, is actually hard.
00:13:16.718 - 00:13:46.258, Speaker A: So the idea is that manual audit actually supplement formal verification. And you should do them both testing and fuzzing. It's very interesting and usually cheap. And actually Satora is building its fuzzer, but that's usually peaks and inputs, so the coverage is much less. None of the bugs that I showed you in the previous slide were actually found by fuzzings. But it's of course thing you want to do. And I mentioned already static analysis like SLITA, which is incomparable, it misses some bugs.
00:13:46.258 - 00:14:09.866, Speaker A: And actually most of the bugs that are reported are not real. So that's very, very different. But of course useful. I want to give you just one example and I think it doesn't have significance, but this is a true fi. This is a team that's using the Sator approver. They have done kind of study. They basically use the Satora approver with auditors and they inserted bug manually.
00:14:09.866 - 00:14:50.410, Speaker A: And they want to know who found the bugs. So what you can see, it's kind of interesting. Many auditors, even good one, they missed bug. Sator also missed one bug. But Satora, and of course Satora, I mean, with the rules that they wrote, but with the rules that they wrote, you see that actually Satora found more significant bug, the tool, than all the humans themselves, all the human together. So the idea is this tool is really, really useful if you compare that to human, because humans are very good in intuition. But identifying edge cases, this is a case that a machine can sometimes be better than human, especially if you write the right requirements.
00:14:50.410 - 00:15:26.870, Speaker A: I want to sort of give you a little bit of sort of technical contents. You will see actually much more with you and Sasha. So the idea is just give you an intuition of what is going on. So I took a very simple case of the sushi. So basically sushi, but that's actually AMM you have basically constant product pool. So you have two tokens and the multiplication is constant. So for example, you have 50 tokens A and 200 B tokens.
00:15:26.870 - 00:16:04.274, Speaker A: And for example, you want to buy 50 B tokens. Okay, so this is what happened. You buy 50, then you have 66 and you see that why do you have now 66? Do you want to tell me why is it that you have 66? What's the wool that is maintained here exactly? The multiplication is constant. So this is the environment that we maintain. So we maintain the environment that the multiplication is constant. So that's the idea. And if you want to think about it even more simply, it's basically you maintain the fact that if one of the tokens is zero, the other is also zero.
00:16:04.274 - 00:16:44.750, Speaker A: And this is a very simple variant of the code. Okay? But guess what? The trident broke this invariant and when this environment is broken, all the money is lost. Okay? So our tool basically found, and this is the code, actually the code is not very complex, but still, you see, it has some nonlinear math. So it's burnt single. This is an operation. And the tool finds an edge case. It's actually a very rare edge case, but under this rare edge case, you can break the environment and as a result, you can actually get all the tokens in the pools.
00:16:44.750 - 00:17:29.070, Speaker A: So how does it work? You see this Trucy target by the way, you see, I told you it's a simple code, but it's already actually 2000 line of solidity code and it's actually 24,000 line of EVM. So actually, the tool handles actually quite significant part of the code. And basically the environment that we maintain is that both of them need to be zero or none of them is zero. And this is a very simple invariant. But look what happened. It found a case that Ellis bends her holding and gets 200 tokens. And as a result, you see now basically the B tokens is zero and the A tokens is not zero and the environment is broken.
00:17:29.070 - 00:18:06.310, Speaker A: And what is the significance of it? The significance of it is that somebody, and this is something of course, that the Satora tool doesn't do. The Satora tool doesn't find the exploit. The Satora tool only finds the violation of the environment. But then we manually look at that and show the team that actually you can now once this environment is broken, you can actually exploit the contract. And how will this work? So basically, this is the case. You have this trident, you have Alice and Bob. So Bob basically deposits 108 tokens at 100 B tokens.
00:18:06.310 - 00:18:40.130, Speaker A: Ellis now deposits also 100 B tokens. So altogether we have 200 A tokens and 200 B tokens. Everything looks fine. There is also something about LP shares, but I'm not showing to you because it's not relevant to us. But of course there are LP shares I'm not showing to you, it's not relevant. And then Ellis transfers eight tokens to Trident. So you see now there's a lot of money in the case, but now Ellis can burn her holding and she can basically get this 200 token.
00:18:40.130 - 00:19:17.360, Speaker A: And now you see the environment is broken, as we say. So what happened now? When the environment is broken, what can you do? How can you take the money? So I'm not asking you because you're probably not familiar with the Sushi code, but the idea is in the Sushi code. So the environment is broken. So basically, Alice, she pays one token and she gets all the sushi, okay, so she gets all the money. Basically, you see that now Bob is left with nothing and Ellis got all the money because the environment is broke. So this is exactly what we want to prevent. And actually formal verification is one of the tools to get this.
00:19:17.360 - 00:20:01.934, Speaker A: I want to give you just another example. It's even more interesting, I think, because it's example that found by a team. It's found by the maker team. And basically this is a code that was actually live for four years. And actually this code I think holds about $6 billion. And you see there's actually Kudberry, fantastic developer at the Sushi team, sorry, the maker team, he basically wrote the environment with the Satorapuver and then Satura approver, said it's not invariant. And usually, you know, when we work with static analysis tool, when it is a violation, we suspect the problem, there is a problem in the tool.
00:20:01.934 - 00:20:31.058, Speaker A: But no, in this case it's a problem in the code. The invariant is broken because there is a problem in the init case. So basically there is a complicated invariant. It's a bit complex. It has some sum about and actually what it says is that it's a stable coin. So the die actually represent a stable coin. And guess not, guess what, the tool actually can show you that under certain cases it's no longer a stable coin.
00:20:31.058 - 00:20:57.898, Speaker A: And it actually show you, you see that the init has an edge case. In the edge case of the init, it's not a stable coin. I want to actually just give you a little bit of why we are doing all these complex things. So there's a lot of other projects, they are open source. At the moment, we are not open source. Including these are a lot of some fantastic academic colleagues. I guess there is a Misten lab, they have the move language.
00:20:57.898 - 00:21:29.014, Speaker A: So a lot of people have actually formal verification and it's called vanilla. And what they do, they reduce to smt, which is what we do too. But it's only the beginning. So basically the idea is that you can actually build a tool for formal verification, at least an initial tool, very easily. You basically reduce it's. Like you take your code and you convert it to mass and then you use a solver either to find bugs or prove their absence. So that's basically the idea of the vanilla solver.
00:21:29.014 - 00:22:00.706, Speaker A: You see, I take this code with a bug and you see that actually each line of the code is converted into a mathematical equation. And it looks almost the same, but it's not exactly the same. In the left hand side, you have a chord, in the right hand side, you have mathematics. In particular. For example, in the left hand side you have 256 integers. In the right hand side, you have mathematical integers, and in the right hand side we can actually reason about the behavior precisely. And then basically the tool automatically finds the bug.
00:22:00.706 - 00:22:43.490, Speaker A: This is the vanilla verification and this is something that I'm not going to explain to you, but if you do this vanilla verification on interesting code, it will not work. And what we have in Satora, we have mechanism to avoid that. And we are not actually doing this vanilla. We are starting with this vanilla verification, but we are doing more things to make formal verification work. And the key idea is actually specialization. We basically sort of do things which are specific to DeFi. We understand something and we understand some invariant, some properties of your code that makes this formal verification feasible.
00:22:43.490 - 00:23:28.446, Speaker A: And this is actually why we can catch all these bugs. So when I told you that we handle EVM, I cheated a bit in a sense that we actually handle EVM that we like, but we can check if the EVM is the EVM we like. And of course this is checked by computer. So the tool is fully automatic. The tool handles your code and checks the properties and verifies. And basically, I'm just repeating, we need this simplification for financial systems because there's a lot of things that make formal verification hard in financial system, nonlinear mathematics and other things. I just want to point out that we found, as I said, many bugs in the compiler basically using our analysis.
00:23:28.446 - 00:24:10.666, Speaker A: So these are bugs that we found. All of them are disclosed and actually fixed, I guess designed usually a week by the Solidity team. Let me just give you one to give you intuition. So basically there is persistence torrent in the EVM and it's separated from the memory. And you see that actually this is the code that the Solidity compiler had to check that. So you see that anybody spots the bug here. So basically, do you see anybody with a good eye on code? Do you see the bug here? It's actually very silly, but it was found by a tool, but a human also, if you look at it, do you see the bug? So this code is buggy.
00:24:10.666 - 00:24:55.090, Speaker A: It's meant to check your memory that you don't do buffer over, but in fact it allow you to do buffer over. Do you see the bug? Okay, so basically you see that this here it says if a length is greater than 31, then it says if a length is equal zero, this is not reachable. And even worse, it is not checked where it's supposed to be checked. So this is redundant. The problem is that the solidity compiler guy, I guess he worked too late. So instead of writing this if here, he wrote the if here. So this is a bug in the compiler itself, which was actually caught by the Satora tool.
00:24:55.090 - 00:25:30.556, Speaker A: And that's the idea. So basically it allow you to actually read memory, so you can read memory out of bound, which we don't want. And of course this is actually prevented by us using formal verification. I think we are preventing more interesting bugs, but then we need specification. But this is a case that we even don't need the specification to find bugs. I want to conclude basically this tool for formal verification that you see, it basically gives you the ability to check the properties of the code. And we reason about very, very complex things on your code.
00:25:30.556 - 00:26:04.616, Speaker A: I think we have this analysis, which we call pointer analysis. We analyze the memory in a precise way, I didn't explain, but if you want, there a are lot of information in the website and in the white paper. And basically the importance of this technology is the bugs that we are preventing. Maybe just to give you a quick overview, because you probably hear a lot of tools. There is a K framework, there is Cock framework, there Isabelle, a lot of tools. So these are academic tools, they're very interesting, a lot of people have been working on it. And on the right hand side you see industrial tool.
00:26:04.616 - 00:26:32.384, Speaker A: They're equally interesting. These are things like MIT wheel by consensus and Kidnain mantico and Sliter by twelve of beat. So these tools are very scalable. These tools are very hard to use and you can check because it actually require different things. And where is Satora? Hopefully Satora wants to be somewhere in the middle. Satora wants to be almost as expensive, sorry, as expensive, as powerful as this. But you want to be something that you can use.
00:26:32.384 - 00:27:00.808, Speaker A: And you can judge yourself if you stay for the workshop, if this is where we are. But if you want to compare, we have teams which used to work in Maker and you can ask them to use in K. For example, the Maker team, they work long time with K framework and you can see. So basically using our tool is much easier. It's almost like a unit test. And you will be the one to judge. I think I'm done.
00:27:00.808 - 00:27:41.348, Speaker A: There are a lot of people in the team. We have a lot of people, some of them are here. We have expert in formal verification in tools. We have wait, doesn't move. Yeah, we have a lot of experts which are here on the DeFi. So I'm missing the slide. I want to basically finish this talk by the sort of tell you few lessons and of course I've been in this space for a long time.
00:27:41.348 - 00:28:45.230, Speaker A: Formal verification is a very beautiful area of computer science and a lot of very good result. I don't know if you know in computer science there's thing which is called touring award like a Nobel prize, the most number of touring award are informal method but there are a lot of myths, people miss a lot of things and there are a lot of myths about formal verification which are not real. And I want to basically point out to you because a lot of hype here, especially in the area of smart contact, but not only so the biggest myth on formal verification is only for proof, but actually I think it's wrong. The biggest value of formal verification is actually finding bugs, not actually the proof. And actually I'm not the first one to say it's, actually people have applied formal verification hardware and by far they reach that. The other thing which is actually not well understood is that people think that formal verification is hard because it's hard computationally it's of course true, but the hardest part in formal verification is actually writing the specification. And I think this is where in blockchain it's very interesting.
00:28:45.230 - 00:29:35.524, Speaker A: There are a lot of other things and I already mentioned that formal verification does not replace auditing. But maybe the last thing, this is what I want you to come from this talk is that formal verification is not a one time deal and you don't want to start it late. Formal verification is something that you want to integrate into your development and you want to start early. And if you are an early project and if you are working on early project, whether you're using our tool or not, it doesn't matter. But start thinking about at least formal specification and even later formal verification or even tools like Nkitnow Slit or any other tool when you start development that's much easier and it's much more useful. I'm done. I want to say basically we are working on this area of DeFi or smart contract.
00:29:35.524 - 00:30:01.090, Speaker A: You will see a lot of things but we have a lot of things about the specification and we have a lot of other tools for checking the specification. So I'm ready to take questions. I'm hoping you'll get some questions but you also get the other people who will give you more technical and hands on experience. But I'm happy to take questions, no questions. Thank you very much. Thank you for your time.
