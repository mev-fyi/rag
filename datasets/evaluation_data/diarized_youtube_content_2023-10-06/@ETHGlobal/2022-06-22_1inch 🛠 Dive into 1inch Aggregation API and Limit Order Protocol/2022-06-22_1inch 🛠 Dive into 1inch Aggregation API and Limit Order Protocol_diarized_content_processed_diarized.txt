00:00:06.730 - 00:01:05.730, Speaker A: Hello everyone. My name is Kirill. I am the lead backend engineer in One Inch and today we're going to talk about the one inch Aggregation API and one inch limit order protocol. Let's start from aggregation. One inch Aggregation protocol incorporates Pathfinder algorithm that search deals across multiple DEXes among eight networks. For example, if you swap one adder to USDT, you will get the simple path through DeFi swap. And if you want to swap large amount of adder, then Pathfinder algorithm will find the complex path among different automatic market makers, limit orders and also market makers called PMMS.
00:01:05.730 - 00:02:28.300, Speaker A: And let's look at the API how to swap one token to another and get the best rate using One inch. So you can go to the docs One inch IO and see the Swagger documentation. Quick start examples how to use the API on different networks with the wall flow of Request quote Request call Data, sign call data and Broadcast sign transaction to the chain. And also here you will be able to see Swagger documentation and parameters of each API endpoint. So let's start from the quoting point. This endpoint is just like a view function that allows you to see the exchange rate, the destination token amount. Here there are three required parameters the token that you would like to exchange destination token and the amount that you would like to sell.
00:02:28.300 - 00:04:37.430, Speaker A: For example in this default parameters we see the alias to ethereum address and the one inch token address and the amount of Ether invite that we want to sell. Let's try to execute this method and see that in response we'll have the all tokens details, our destination token amount and the execution path that was built by Pathfinder algorithm. For example, if we increase the value of adder, we will see the more complex path that has different splits, different roads, and in this case we'll get better rate than swap on any single decks. Let's look at other parameters. Protocols parameter allows you to set the enabled protocols. By default we enable all protocols supported by One inch pathfinder and if you would like to set for example only uniswap or SushiSwap, you can enter these protocols by comma in this field in this query parameter and Pathfinder will only look at the pools of these protocols. If you are an integrator and would like to charge fees from your customers, you can set the fee parameter up to 3% and receive the quote by giving fee parameter and taking into account this fee when calculating rates and our parameter is gas limit.
00:04:37.430 - 00:05:51.418, Speaker A: For example if you know that you don't want to spend more than for example 500,000 of gas, you can specify this limitation in this query param and Pathfinder will be taking into account the gas limits. Also, our API can work with the connector tokens. By default we have about twelve to 20 connector tokens through which the Pathfinder algorithm searches the path. But if you would like to set custom connector tokens that you can enter by comma in this query parameter. Next parameters allows you to configure Pathfinder algorithm. You can set the complexity level. This is the number of connector tokens that can be in the path.
00:05:51.418 - 00:07:26.010, Speaker A: For example, if we'll see at this path, you'll be able to see that in this path we have USDC as a connector token and also Dai as a connector token. And you can set any connector token if you know that this token will give you better price for some custom tokens than our default list. Next parameter it's main road parts. This is also finder settings so the source token amount splits by the parts and searches different subroads in the wall exchange path. For example, here we can see that 60% of Azer goes through this path and other 40% goes through this path. And if you set more main roads then you will be able to see the more precise values. And by the way, the response time will be slower because algorithm should perform more actions.
00:07:26.010 - 00:08:33.218, Speaker A: Another parameter it's parts. This spread is the same than main road parts but it works with single hope. For example, here we have the swap USDC to USDT on different markets and each market has their own percent of distribution. And you can set parts up to 100 and search for the most precible values of distribution among different DEXes between two tokens. By default it's 50 parts. But you don't need to worry about these parts. We always set the most useful parts to find the best price with the best response time.
00:08:33.218 - 00:09:34.990, Speaker A: And the last parameter it's gas price. By default we use fast gas price from the network, but you can specify your value in this field and pathfinder will search for the best rate taking into account gas costs with your custom gas price setting. Okay, let's go to the swap endpoint. This endpoint allows you to build the call data that you can execute directly from your wallet or proxy through your smart contract. And this endpoint has two more required methods it's from address and slippage from Address. This is the address that will call the one inch contract. It can be your wallet address or maybe smart contract address.
00:09:34.990 - 00:11:37.370, Speaker A: If you would like to proxy one inch call data through your contract to perform more actions and slippage parameter this is the maximal percent which you are okay to lose. For example, right now we see this amount of USDT. But when you send the transaction to the network, your transaction should be mined and it takes time. During this time the rates on different exchanges can be changed by our participants of the market and you can set the safety slippage percent. If the rate drops more than zero 1%, for example, then the exchange will not be performed and your transaction will be reverted and you will just pay for the gas fees for reverted transaction but it's better to pay gas fees in some cases than lose big amount of destination token. Okay, let's try this method for estimation we need to use some address with the big amount of adder and let's try to execute and here we are here we can add additional ticks property in the response object. Here you can see the from address from which we call like from what we send the transaction the wallet address.
00:11:37.370 - 00:13:07.502, Speaker A: If you use the smart contract that you need to replace this address to your wallet address that will broadcast the message to the blockchain two properties. It's a one inch contract address. The data is the call data that executes all swaps all the path in one atomic transaction the value this is the amount of ether that we need to send to the contract in this transaction to perform swaps from either and this is the estimated gas limit with some additional gas multiplier to be sure that your transaction will be completed successfully. And you can use this value, for example, to show the gas costs, to look at the gas costs of this transaction and gas price. And you can take this object and just sign it and broadcast to the node and perform one inch swap. Let's look at our parameters one more new parameter it's a desk receiver. This is the address that will receive the funds after the exchange.
00:13:07.502 - 00:14:53.786, Speaker A: By default we use from address that you specified but if you would like to send tokens after the exchange to another destination address, you can specify it in this parameter. As I said before, you can specify fee parameter and set the address that will receive this fee. This is the referral address query parameter. Another interesting option is disable estimate if you don't want to perform balance allowance call data checks and you need to set this value to true. For example, if you would like to proxy through your smart contract that doesn't have enough allowance or balance before the swap, then you need to set this flag to true and perform the transaction estimation on your own site. Also you can provide the permit to the parameters to allow some tokens support the way to approve amount of tokens on behalf of the smart contract and during the swap this permit will execute it and you don't need to do extra transaction to set allowance for specific token to one inch contract. One more flag it's allow partial fill.
00:14:53.786 - 00:15:58.670, Speaker A: This is the interesting feature. There are some cases when you need to swap tokens anyway. For example, sell one token or buy one token anyway. And when market moves fast, your transaction may be reverted. But if you set a low partial field flag to true then in case of price drops on some main roads, this main road will revert it for example, the first one. But if other roads will execute successfully and these roads will be okay with the price slippage that you said in your response. Then you'll get back for example 50% of other and receive now 50% of USDT to your wallet.
00:15:58.670 - 00:17:04.258, Speaker A: Yeah, this all about the swap API. You can also look at the supported liquidity sources, look the whitelisted token list and some helpers for approve and also health check. You can always go to the one inch documentation portal and see all descriptions and examples how to communicate with the one inch API. Okay, let's go to the limit order protocol and see how to set the gasless limit order. For example, what is limit order? This is the structure that you will sign by your private key. And this is not the transaction. This is just the signature on ellipsic curve of the hash of your data.
00:17:04.258 - 00:18:17.450, Speaker A: And this data includes token addresses, amounts and other parameters. And you can create the limit order, sign it and broadcast to some relayer and let's look how it works. What interesting feature limit order protocol has? Okay, one inch limit order protocol has three interesting features. This is the conditional execution you can check is your order valid or not during the execution when the taker will execute your order. And also limit order protocol supports arbitrary price discovery. With this feature you can use your custom formula for exchange rate. By default we use simple proportion, but you can fetch prices for example from chainlink oracle or maybe build some custom auctions.
00:18:17.450 - 00:18:58.520, Speaker A: But it's up to you. And also you can specify the custom callback during the execution that will be performed before the transfer from your maker address. Let's look at the order structure. The first field is itself. This just to protect orders against double spending maker asset this is the address that you want to sell. Taker asset is the token that you want to buy. This is your maker address.
00:18:58.520 - 00:21:28.450, Speaker A: This is the receiver address that will receive takers funds allowed sender allows you to do private orders to be specified for specific executor taker making amount this is the amount you would like to sell and taking amount the amount you would like to buy. Makers data and takers data allows you to perform transfers with more parameters by finding the selector of transfer from function getmaker amount and get taker amount allows you to provide the custom formula for execution abi encoded call data that will be executed on chain during the order filling predicate. This is the abi encoded function that returns boolean that checks. Is your order valid or not when taker tried to fill this order? Also you can specify permit to not set allowance before the order making and interaction. This is the encoded bytes of your custom callback that will be performed before the transfer funds from your address. To execute the order, you need to call fill order function that accepts order, the order structure, the signature of your wallet or any bytes in terms of you operate with the smart Contract as the maker and you would like to check not the signature itself, but some other details. You can provide here any data if you operate through Smart Contract and you can specify one of the amounts.
00:21:28.450 - 00:22:54.530, Speaker A: If you would like to set the amount that you would like to buy, you can set making amount and if you would like to set the amount that you want to sell, then taking amount and the threshold amount to protect you against front running if you use not fixed rate but the order contains custom formulas. Okay, let's look at the predicate. There are two built in predicates. This is the non SQLs and timestamp below you can combine different predicates by the end function that accepts the array of target addresses where you will call the data like the bytes array of data on each target. For example, we have two default checks. First check performs nons validation, like if you cancel all orders on chain that we increase your nons. And if the order contains of the previous nons that doesn't equal to actual nons on Smart Contract, then this order can be executed.
00:22:54.530 - 00:24:41.090, Speaker A: And if you would like to set the expiration time to your order, you can use the timestamp below predicate that check the expiration time of the order. Here is the default proportional formulas for calculating maker amount or taker amount. These actions executes on the limit order address by calling function static call. And if you would like to define some custom formulas with the custom smart contracts, you need to wrap your functions by the arbitrary static call function. Here you specify the target as your Smart Contract address and the data is the bytes of abi encoded call data that should be called to execute your formula on your contract. If you would like to operate with Smart Contract as the maker of limit order, for example you have the funds on Smart Contract that you would like to trade, then you need to implement is valid signature function on your Smart Contract that should return the selector of itself. As I said before, you can specify any bytes to the signature param and validate.
00:24:41.090 - 00:26:12.846, Speaker A: For example, order parse the order from this param and validate that this order is okay for your logic, but you can also provide a signature. You can set to your contract some EOA address like the basic wallet address and sign for the private key that belongs to this wallet. Address the order structure and provide the signature and validate the signature by the wallet in the storage on your smart contract. And the last thing is the interaction. If you would like to perform for example some collateral borrowing or repay deposits, whatever you can call the notify fill order function on some target. The interaction field contains of address the first 20 bytes and some additional data that can be empty or not empty. And when the order will be executed, your contract will be notified by the limit order contract address and you'll be able to see who executes this order the maker, asset taker asset and what the field amount this is all about limit orders.
00:26:12.846 - 00:27:00.570, Speaker A: You can always check the limit order documentation and some TypeScript otils by these core codes or just simply go to our docs portal and see the limit order section and here you will be able to see the guide how to start, how to create limit order, how to fill limit order. You can also cancel limit order, build your custom predicates operate with nonsense validate limit orders and set the cheapest orders called RFQ order. Thank you. Wish you good luck on the hackathon.
