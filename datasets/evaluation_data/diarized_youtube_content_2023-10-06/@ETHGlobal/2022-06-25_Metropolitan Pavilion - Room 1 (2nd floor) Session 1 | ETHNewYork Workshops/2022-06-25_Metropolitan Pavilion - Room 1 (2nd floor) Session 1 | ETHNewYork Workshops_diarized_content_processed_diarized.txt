00:09:10.120 - 00:09:42.660, Speaker A: Centralization and storage. So for centralization and storage, we're looking mostly at application data. This might be about the user, this might be about a collection of users. And with this centralized storage, we can oftentimes think about this as like application front ends, too. We don't want to necessarily host our whole website on AWS or Versaille or whatever else. And this is a little bit what Skynet is known for is our decentralized storage. But we can also look at centralization and compute resources, which is where this talk is going to go eventually.
00:09:42.660 - 00:10:12.670, Speaker A: And we can think about things like APIs that work over that application data. And for our kind of model here, we can think about this as our application backends. Of course, this is the off chain backend. Typically our compute a lot of times with smart contracts is going to be on chain. But there's also other APIs that get utilized all the time that we can focus on decentralizing. And Skynet is our magic bullet for solving these things. So I want to talk to you a little bit about what Skynet does and what we're building towards.
00:10:12.670 - 00:10:45.480, Speaker A: And so I'm going to talk to you hopefully only about ten minutes about Skynet and then show you what it looks like to use Skynet. But first, as a primer for what it looks like to eat, how Skynet is built, I want to have a little diagram here. Skynet is built on the SIA blockchain. It is an application specific blockchain focusing on decentralized storage. And it has hosts on its network, and it also has renters. And on Skynet, we have individual users in their web browser. And on Skynet, what we can do is have a user take a piece of data.
00:10:45.480 - 00:11:13.992, Speaker A: This can be an image, it can be a video, it can be their user profile data, and they want to send it to a Skynet portal like Skynetfree. Net. That data will then get broken into lots of little chunks and stored across a lot of hosts on the saya, network. Once that's done, once that data is persisted, that user will get back a Skylink. If you're familiar with IPFS, this is similar to a CID. It is immutable. It's like a fingerprint for that file.
00:11:13.992 - 00:11:32.792, Speaker A: It is a way that the user can later verify that the data that they're getting matches the data that they're requesting. And with the Skylink, they can pass that to a friend. It doesn't have to be isolated to that user. So now we have user B. They have the skylink. They say, hey, Fileportal.org totally different.
00:11:32.792 - 00:11:59.040, Speaker A: Skynet portal not run by skynet labs. I want this file. What happens is Fileportal.org has a connection with a bunch of hosts. It will select some that are the fastest. It'll grab enough pieces to reconstitute the original data and pass it back to the requester. Okay, so this is kind of what immutable data on Skynet looks like.
00:11:59.040 - 00:12:28.410, Speaker A: We have immutable data layer two. But talking about decentralization and decentralized APIs, there's something interesting here. Right on the right hand side, when we're still in the blockchain world, all this end to end is verified through typical blockchain stuff. But when we start using browsers, it gets a little bit weird. And if you noticed, I was being a little cagey with my language. The skylink is an identifier. That means that the data is Verifiable, but that doesn't necessarily mean the client is verifying it.
00:12:28.410 - 00:12:55.296, Speaker A: Which brings about a question, right? Are we just putting our faith in the portal at that point? It might be open source or whatever else, but do we have a centralization point happening there? Let's kind of look at an example. We've got a user. They've got this file, and they use Chrome because they love Chrome. And using chrome. They request this skylink from Badportal.org. Badportal.org, not surprisingly, returns out Bad data.
00:12:55.296 - 00:13:36.096, Speaker A: But because Chrome is dumb, it doesn't know anything about Web Three and the protocols and the protections we've built. It's going to just pass back this Bad file to the user, and the user goes on their way. But we could do a thought experiment, right? Like, what if Chrome browser did understand Web Three primitives and the protections that those can grant a user and incorporated them in the browser? And what that might look like is that our request goes out to badportal.org. We get back a bunk response, and the browser is like, hold on, I know that this is not the right data because I can verify this with the Skylink. So let me go reach out to another portal. Hopefully they won't lie to me or censor the data or whatever else. The file comes back.
00:13:36.096 - 00:14:05.236, Speaker A: It gets verified now, not just Verifiable. And the user, without thinking about portals or anything else, gets the data that they need in a fully decentralized fashion. Okay, so Skynet's not building a browser. Don't worry. I know that's always quite a task for some engineers. But we've built something called the kernel. And so what the kernel is, is it's either run as a browser extension or in an iframe, and it is able to load code hosted on Skynet.
00:14:05.236 - 00:14:37.648, Speaker A: And it will pull that code, verify the code, and then run that code as a decentralized client side API. And lots of websites can share that code. So what does this look like in practice? Well, we have a website, our kernel and our portal. And let's say we have great SCAP HNS it's. One of the naming services we support is Handshake. And so the application in its code will say, hey, kernel, use the module for doing uploads to do method upload. Okay? And it'll send that request to the kernel.
00:14:37.648 - 00:15:31.380, Speaker A: The kernel knows how to handle this. And so it's going to load that blob of data, run it as a web worker, pass on that request to the web worker, and say, hey, I need you to do upload. And this was requested from Greatscap HNS. And then this blob of code will know how to handle that. It'll talk to the portal, it does all the verified fun and eventually gets back to the browser in a protected, safe way, fully verified, end to end, fully open source, and fully permissionless. Okay, what if we wanted to get a little bit fancier? Well, the kernel also has an identity layer where you have a seed and public private keys for doing updates and signing messages, things like that. And so we might say to the kernel, hey, I will need you to use this module located at this Skylink to do the action registry update.
00:15:31.380 - 00:16:13.628, Speaker A: But the module needs the user's key. But we don't trust the module with the user's key. The kernel is the only one that gets to have the user's key. And we definitely can't trust the client side application because anyone can deploy that very trivially onto Skynet. So what happens is the module says, all right, I need a key kernel. Can I have one? The kernel will create a derivative key, a brand new key just for that module, and then we can do our signing and our interacting with the portal. And so I hope this gives you a little bit of a sense of what it looks like for our vision of creating a decentralized API where we can still do authentication, we can still do access control from modules calling other modules.
00:16:13.628 - 00:16:43.484, Speaker A: They know the identity of the caller or what the host website is. And let's see a little bit of what this looks like in code. Because you're hackers, you're here to code. So what you basically have to do, this is the module code for a very trivial module. But you'll clone a repo and you have a file where you start writing out your code. And aside from this boilerplate, basically we have to add handlers. So the requests have a method, and this method is called Say Hello.
00:16:43.484 - 00:17:08.816, Speaker A: And then we define a function that handles the requested method. So this function is called handle. Say hello. We'll log some data, and then we respond to the query with arbitrary data. And here it's an object with messages, the key and Why hello as the value from the client side in a react app or wherever else. This code is real clean and simple. And so you import this call module.
00:17:08.816 - 00:17:51.340, Speaker A: You want to have the Skylink of the module, which we here just have as a constant, and we say, await call module. So call out to the to do module. We want to do Say Hello and pass along some arbitrary data or action or whatever else. We'll await the response, grab the message, and be able to use it. And so, getting started building these APIs is actually not that complex. We have a pretty tight built pipeline where you're able to quickly deploy these things to Skynet just using your CLI and iterate against it. But APIs are made to be consumed, right? For the most part, we want more people consuming the APIs than producing the APIs.
00:17:51.340 - 00:18:27.870, Speaker A: And so how can we do that? I've already talked about, saya, Skynet, Skynet kernel. I know it's a lot going on. So let's look at what these layers of abstraction are on. Saya we have this fast and secure data storage and a decentralized blockchain that is still private though. So we need to make this accessible to the web, which is what Skynet does. And then to make these rich applications for web two, developer experience on web three, we need to enable identity and shared code execution, which is what these Skynet modules can do. These kernel modules can do.
00:18:27.870 - 00:19:07.640, Speaker A: And then lastly, what we're seeing is that people building these kernel modules then just write normal JSON libraries that wrap the annoying call module or whatever else. Right? So we're going to see a few of these in the demo. But the idea here is that we can do another layer of abstraction. So it just feels like interacting with JavaScript code for the end developer. The user doesn't really have to know too much that even a decentralized backend is supporting it. And we can empower really powerful, decentralized experiences where users can share their data across different apps in a safe, private way. Okay, so let's build a social DAP on Skynet.
00:19:07.640 - 00:19:50.680, Speaker A: So modules tend to isolate and separate out specific types of behavior. And so we, for building a social application, are going to need something for identity. We're going to need a social graph. We're going to need a feed of posts from those users. And then we're probably going to want everyone's user profiles so that we can have pretty things like avatars and BIOS usernames. So there is a set of developers in our community that have published Skynet DAX Library, that is one of those wrapper libraries so you don't have to deal with call module or anything else. These expose methods for interacting with these abstractions on Skynet.
00:19:50.680 - 00:20:13.810, Speaker A: And if you want to follow along or follow along later, or want to take a picture, this is the GitHub repo of the code that I'll be working with in the demo. And let's build. Okay, so let's take a look at that repo. Sorry about the plosives. Are folks able to see?
00:20:14.660 - 00:20:15.072, Speaker B: Great.
00:20:15.126 - 00:20:46.084, Speaker A: I think that seems pretty good. Okay, so I'm in this hackathon ideas workshop, and this is the code I'm working against here. And I want to show you that as a react app, I've already built out all the UI elements. So this is just mock dummy data that this is not coming from Skynet at the moment. But this is what I want to build. And so I want to start off here. I want to build an idea hackathon idea, decentralized web app where we can have people join a social graph of hackathon participants and mentors.
00:20:46.084 - 00:21:32.570, Speaker A: They can create new ideas and then see a feed of existing ideas from other folks in the hackathon. So that new idea page will be over here and I can put in some details. And if you take a look at the repo later, you'll notice kind of everywhere, these wires everywhere that I have these kind of mock statements. But all of the logic for dealing with the kernel and these decentralized APIs is going to be in this hooks folder. So basically all of this is UI stuff. But we're going to really focus on authentication and then using these social modules. So let's take a look at this right now.
00:21:32.570 - 00:22:14.476, Speaker A: Basically to do authentication, I have to use the functions in the Lib kernel library, which is produced by Skynet Labs. And first off, we need to load the kernel. So this is our bootloader. And once we do that, we'll set state in our UI to say the bootloader is loaded. So let's kind of just start stepping through this actually. What does it look like when we don't have a bootloader loaded? Let's start from the very beginning here. All right, so the bootloader is not loaded.
00:22:14.476 - 00:22:53.036, Speaker A: Bootloader loads pretty fast. So we'll get rid of these skeleton elements and our bootloader is loaded. Once our bootloader is loaded, our user is not logged in. So we have to provide a button here to log into the kernel. Again, I'm just kind of showing the UI and login flow here. But then once they authorize with the kernel, produce their seed, then the kernel will load and we'll start kind of preparing to load in other data. And once the kernel is loaded off of Skynet, the code that does all this protection, then we'll be fully ready to use this data.
00:22:53.036 - 00:23:31.210, Speaker A: And again, this is just mock dummy data for now, but what does it look like if we drop that off and actually call the necessary functions for interacting with Skynet kernel. So we await an init that's our bootloader. And then we basically await a promise from login complete. So whenever the user is finally logged in, then we can start doing some stuff in our application. So these are just kind of fairly boilerplate, honestly, if you want to build a react app following my example here. So let's go ahead and save. I'll do a hard refresh over here.
00:23:31.210 - 00:23:42.670, Speaker A: And now in actuality, I will be calling out to Skynet to load that bootloader, load in a kernel and get going with.
00:23:49.510 - 00:23:50.260, Speaker B: It.
00:23:55.750 - 00:24:37.790, Speaker A: Okay, so now if I've done my authentication correct now the user is authenticated and I can start interacting with this library that exposes all this social behavior. So, as I mentioned before, we have identity, which gets us the user's ID in this public decentralized social network. It's a ed two five 5119 pub key. And we can use that to then look up their profile, look up their social deck, and look up their feed deck. So this is their friends list and this is their lists of posts. And I'm not going to use any post here. We're going to have some selective elements where we modify which posts we actually want to show or display.
00:24:37.790 - 00:25:26.554, Speaker A: And so instead of returning, the photographers are distracting. Instead of returning this kind of mock data for our profile, let's start using the Use DAX hook to actually expose real behavior that will then export to our UI. Okay, so right now I'm returning early with mock data. Let's comment that out. And now if I reload my app, what should happen is I should load my bootloader. We'll temporarily see the kernel loading. And once that's loaded, now that decentralized API is going out, grabbing my profile data that I was on my own, assigned on Skynet, all the data is persisted to Skynet.
00:25:26.554 - 00:26:12.910, Speaker A: The user profile images persisted to Skynet and it's loading that identity into our application. And what this looks like from the code side is that we have the identity DAC. We say, hey, grab the user ID and let me know when you get it back, and then let's pass that to our profile abstraction and we want to get the profile for that user ID. Then once we have the result, let's update the state of our application and keep going. So there's a lot of Reacty stuff going on here. If you're unfamiliar with react, the actual kind of kernel stuff is not too deep or dense here. Okay, so also we waited until we were authorized authenticated on the user side, and we waited for a kernel to load.
00:26:12.910 - 00:26:52.182, Speaker A: Well, great. How about these avatars right here? If we go and look at our element for that on our hackers component, we kind of have a function where we say we want to get the user avatar for some predefined folks that we know. Like, these are our participants and mentors. So we have a list somewhere. I've defined a list, it's going to be in the bottom of use decks. I've defined a list of the user IDs that I want to define as like participants and mentors. And so now I want to grab their avatars.
00:26:52.182 - 00:27:47.850, Speaker A: Instead of grabbing this mock data and under Get User avatar, I can stop returning my mock data and instead say, let's create an instance of our profile deck. Remember this library that wraps a module interaction and called Get Profile with the user ID. And then that's a Skylink, which is we need to then define the portal that we're accessing them from. And that's what this method does. But at the end of the day when we save that, what will happen is we can refresh our page. And as these things load again, our application reaches out to the kernel saying, hey, I need this profile for this user ID. But I want you to use this module and the code in this module and then it will reach out to the next place, which will reach out to the skynet.
00:27:47.850 - 00:28:31.340, Speaker A: And so now we see these being pulled in in real time off of decentralized storage. This is fully decentralized end to end, which is pretty impressive, especially if you have experience building on some other decentralized storage projects. All right, how am I doing on time? Decent. So this is kind of cool. Like, I'm a brand new user. I don't follow any of these people. But I have a list of basically I can bootstrap my social graph that will follow me from application to application on Skynet by basically writing my own method that says, here's a list of people, go follow all of them and tag them as being associated with a specific event.
00:28:31.340 - 00:29:25.450, Speaker A: And so that's what this follow user list method does. I say let's use the social deck for all of the users in our user ID list that was hard coded into the program. Let's go ahead and follow that user ID. And if I pass in some details, I can then add some metadata too so that later on I can know why I followed them or whatever else. And there's nothing built into any of the protocol pieces that require me to use this tagging or use whatever else. This is all community developed and open source and everything else. So I think that's an interesting aspect here that we can design how we want social graphs to work and even extend how they work and use that extension in our application, but still have that data be interoperable with other folks building in the same paradigm.
00:29:25.450 - 00:30:38.660, Speaker A: Okay, so if I save that's now as those load, I already know these user IDs, but I can click follow all and I'll just in the back end that module will start following these users. I want to mention maybe right here before I forget, this is kind of the cutting edge of what Skynet is working on. We've focused a long time on decentralized storage and we've started seeing all the potentials for decentralized APIs being fully hosted on decentralized storage. So there are spots where we are still doing optimizations, things that are called sequentially that with a couple of hours work will be called in parallel. And so you'll notice things that like following these folks is going to take a little while. But we're excited to have developers start building on things now so that they can have a voice in the direction that things move and what we focus our efforts on. All right, I'm going to just try to fly through a few more before doing my closing appeal to everyone.
00:30:38.660 - 00:31:17.360, Speaker A: Let's look at our ideas feed and instead of returning our mock data, let's return actual data. So here what I have is a set of users and for each one of these things I'm going to eventually grab their user profile. But we've kind of looked at the profile deck. So I'm just going to skip over it. But what we have is a I broke something fun. Okay, what we have is a reducer here. Basically what that means is it's a piece of state that we can kind of keep updating with the previous piece of state's state.
00:31:17.360 - 00:32:08.000, Speaker A: And so what we're going to do here is call this updater every time we see a new user and grab their current social feed. And we are going to grab their whole social feed actually, but we can just really quickly filter it. So what we're going to do actually specifically is call, sorry, it is down here on our feed deck. We're going to call load posts for user. We're going to pass it our user ID and we'll get back a big list of posts and we can quickly call a filter on it to say we only want posts that have a content field that we've extended that is called event. We could say activity hackathon, whatever else. But here we can just say if it has an event field, let's use it.
00:32:08.000 - 00:33:18.242, Speaker A: And then we'll pass that onto dispatch ideas list, which is a complicated way of updating the state. But you can see that grabbing the data off of Skynet is actually pretty easy for the end user now. But the module developer has abstracted this decentralized social network behavior and it would be cool if things loaded. All right, so the last behavior that we haven't seen, maybe we can watch a few of these ideas load and pop over into creating a new idea. But while it's grabbing some of those, we've created a create post method here that we can call from our user side as well and we can just pass it a title for our project idea, some text, identify the event price, track, whatever else. And now we're making a post on that user's social feed that has this extended metadata that any application can utilize for whatever they want. But this is really cool because you'll in the ecosystem have other folks that are building aggregator type infrastructure.
00:33:18.242 - 00:34:02.500, Speaker A: And so now your application specific data that is tagged with certain stuff can still be included by maybe scrapers or aggregators or other user interfaces. And that's the beauty of this fully decentralized structure is that this application data is totally interoperable everywhere else. And again, you'll see that we're using the feed deck to create a post pass. It this information that we've formatted in the correct way and then it will be added to the feed. So let's take a look for a brief second to kind of see. We're loading in some of the feed items from members of our list up here above. But let's go ahead and add a new idea.
00:34:02.500 - 00:34:37.190, Speaker A: We want to have a super big prize winner and we'll be at ETH New York trying to do the public goods track, and we'll be building know, solidity flutter and hard hat. I don't know if those make sense together. And we're looking for a team. Now. When I press that button, I can call again. This create post. And what happens is that data is persisted to Skynet.
00:34:37.190 - 00:35:41.820, Speaker A: And then I'm immediately pulling that data off of Skynet into the social feed, using fully decentralized storage, using decentralized code stored on decentralized storage, and using a decentralized stored on Skynet piece of code to do all that verification, all that message routing and everything else. So from end to end, it's always forkable, it's always verifiable. And for the user, they don't have to have crypto or a wallet or anything else to interact with it. So I hope you see some of the potential and are a little bit excited about some of the direction that we're going. Again, if you want to look at this later on, you can see where I just comment out mock data on the Hackathon Ideas workshop. And we also have beta documentation because this is still new and is at kernel beta Skynetlabs IO. And I'm going to annoy someone by going about 30 seconds over here.
00:35:41.820 - 00:36:16.290, Speaker A: We are doing a call for builders. So we've just released this beta. We really want feedback from folks building decentralized applications, especially those that have maybe experience in Web Two or elsewhere. We're putting up $8,000 in prizes for anyone that it creates or consumes kernel modules in your application. So there's gold and two silver prizes. But you don't have to create a kernel module or a decentralized API to be eligible. You could just bring in some of these social components, identity, user profile, whatever, and still be applicable for the prize.
00:36:16.290 - 00:36:43.982, Speaker A: I just said all that. To learn more, check out kernel beta Skynetlabs IO. If you want a free account for 100GB of upload for decentralized storage, check out Skynetfree. Net. Come say hello to me. I'm going to be downstairs chilling at my booth for a long time, and I super appreciate everyone's time and attention and check out our discord. I don't think I have time for questions.
00:36:43.982 - 00:37:54.468, Speaker A: Is that correct? Have you considered not necessarily, no. If you want to have kind of like that sort of privacy on Skynet, what you'll want to do is use encryption to do that layer of interaction. I mean, I guess in theory, you could spin up like a private Saya and a fully private Skynet because it's all open source and you can do that. But by the default architecture, the idea is that these portals share this kind of big data lake, more or less, no matter what portal you're running or accessing it through. Yeah. So the economic relationship for getting data onto SIA is between the user and the portal. So Skynet Labs is using a freemium model where we let users have 100GB of storage for free and pretty generous access speeds but if you want to ramp those up for $5 a month or whatever else, because we're focused on making this really accessible for Web Two users that aren't in the crypto space yet.
00:37:54.468 - 00:43:34.018, Speaker A: But it's a fully open source stack and we're really excited for folks to open up portals where you can pay in crypto or anything else. And then the portal itself is paying in saya, coin on the SIA network because that's what that protocol does. All right, thank you so much for your time and attention. Come see me if you're interested in the prize and I'd love to help you out. Hi.
00:43:34.204 - 00:44:24.006, Speaker B: Today we're going to be doing a 40 minutes workshop on building full stack DApps. And really my goal here is for people who maybe there's a lot of protocols in the space, there's a lot of cool projects coming out. But for me, when I first got started in Web Three, I kind of found it hard to find what a Web Three tech stack looks like right now, like what actually works, what works well together and then piecing together how do I actually make all of these different pieces of the stack talk to each other. So that's what I'm hoping to accomplish today, so that you can leave ready for the hackathon. And I'm going to leave you with some resources that you can fork and clone and it'll help you get started a little bit easier, hopefully. So part of this is going to be a little presentation, kind of just going over some of the basics that I want to communicate and then we're actually going to walk through a project. I wanted to live code it, but there's just not enough time with what I want to do.
00:44:24.006 - 00:45:07.014, Speaker B: So we're actually going to walk through an existing project and then at the end, like I said, there'll be some resources for you to just get started with so really quickly. About Me I do developer relations at Edge and Node, which is a core developer of the Graph Protocol. I've been there for a few months and then I come from a more traditional software background. I was engineering at PayPal on the Checkout Experience for about a year and a half, and then I worked at a startup for some time in between PayPal and where I am now, I also took a more traditional path to kind of my career. I studied computer science in college and I've been an educator for six or seven years. Before doing developer relations, I taught kids how to code back where I live, so I've always loved to teach. This is what I love doing.
00:45:07.014 - 00:45:48.530, Speaker B: And now with my job and devrel, I get to teach adults, so that's just about me. So let's talk about the Web Three stack. So this definition is actually taken from a blog that Edge andOde wrote a few months ago, but it's really clear and really concise and one. That I wanted to use here. So when people ask like, what is the Web Three stack? I think the best answer that I found is the set of protocols that enable you building fully decentralized applications. So that means from beginning to end, there's a set of protocols that allows you to build DApps in a way that there's not any layer where it's like, oh, this is AWS, or you're putting this in some standard database. So it's the set of protocols that allows you to build end to end fully decentralized.
00:45:48.530 - 00:46:41.266, Speaker B: So before we get into kind of what my stack looks like, and maybe what I would recommend for now, or at least what I'm building with, I wanted to talk about some of the characteristics and some of the important pieces of the Web Three stack. So as we move on, this will make a little bit more sense. I know we are all really familiar with all of these, so I won't talk through them specifically one by one, but one that I do want to focus on is native digital payments. That's like the one thing that I feel like was really key when I first got into Web Three is when you think about Web Two. Someone put it this way and it made a lot of sense to me. In Web Two we put things like music and movies on the Internet and this whole concept of putting things that were in the real world on the Internet, like in Web Two. And now we're doing the same thing with Web Three by putting money on the Internet and making money native to the Internet rather than some external thing.
00:46:41.266 - 00:47:09.610, Speaker B: And obviously, native payments is a huge part of Web Three and why we're all here. There's incentive mechanisms behind a lot of these protocols. So I just kind of wanted to highlight that. And then the other one that I wanted to highlight was self sovereign identities. So like just today, actually, this morning, the Supreme Court overturned Roe v. Wade and now it's up to states to decide if abortion is legal or illegal in their states. And someone brought up a good point that there is a period tracking app called Flow.
00:47:09.610 - 00:48:04.478, Speaker B: It's an app where women and people with periods can go on there and track their cycles as a way of kind of like no hormone birth control. And the way that it is now, in theory, if you are using this app, your data is owned by Flow and Flow has been caught selling your data. So in theory, right, if you are using this app and the government, like your state government wants to prosecute you for having an illegal abortion, they could take the data from this app and say, look, you usually get your period, I don't know, the 20th of each month. And for the last three months you didn't get a period and now you have a period. So obviously, this is a very niche and specific example that I'm giving. But it's a very real world relevant example today where other people owning our data and having access to our personal data that can then be used against us in the world that we're in now isn't really a world that I think I want to live in specifically as a woman. Like going through all this.
00:48:04.478 - 00:48:28.838, Speaker B: So that's another thing that's really important here. Okay. And now getting to kind of the building blocks that we're going to talk about here as we build out our stack. So kind of the primitives or the building blocks is obviously a blockchain and l one blockchain development environment. So as I'm listing these out and you're hacking this weekend, start thinking about what you're using for each one. And obviously you don't need every single one of these. It just depends on what you're building.
00:48:28.838 - 00:48:55.486, Speaker B: All of these are specific to a project. But as I'm going through these and you have your idea, think about which ones you're going to need and then think about which ones you might want to use. So as we go through this talk, you can say, okay, I wanted to use this one, but she talked about this. And then you can go back and look at the do research between them, figure out the trade offs and then pick the best tool. So as I'm going through these, that's what you should be doing. So an L one blockchain development environment. And I'll go over examples of what these are right after this.
00:48:55.486 - 00:49:36.314, Speaker B: File storage, off chain data protocols, API for indexing and querying identity, a client oracles. And then I just grouped all these other protocols. And this is actually also from the edge and code blog post that I'll link at the end if you guys want to read more thoroughly. So I have this little visual here. This is what you should take a picture of if you are going to hack. So this kind of lists out all of the different options in each part of the stack that I just described. So as you're thinking through your project and you're like, for example, I need something for, I need an L two or a side chain, what's going to be the best one for my specific project? You can look through this list and a lot of these people are here actually sponsoring, so you can go learn about them.
00:49:36.314 - 00:50:09.480, Speaker B: But as you guys are all taking pictures, you'll see there's lots of options for all the different parts of the stack. And the thing that's important to remember is that there's no one tool. That's the end all be all and it's not the answer to every single thing. You should always take a look at all of the options and decide what's the best one for this specific use case and this specific project. So what I want you to do is don't walk away from this talk being like, oh, what she said is what I should be using in all my projects. This is what I'm using for some specific projects. And you should take this stack and adapt it to your specific project needs.
00:50:09.480 - 00:50:42.574, Speaker B: Okay? And then some that weren't included in that picture that I do want to include specifically for this hackathon because they're both sponsors, is Live Peer and Lens. So live, peer, decentralized, video infrastructure. It allows you basically to build in live streaming to any DAP really easily. So if you're familiar with Next JS, you can literally just enable Live Streaming and then like Minting Video NFTs just from an API route. And then lens decentralized on custodial social graph for building composable social applications. There's QR codes there. There's like guides to start each if anyone wants to take a picture.
00:50:42.574 - 00:51:14.336, Speaker B: These aren't going to be on another slide, so I'll give you guys a second in case anyone wants to. Okay, cool. Okay, great. So here's what I'm using for this project that we're going to walk through together. It's called Web Three RSVP and we'll go through it together. But basically the project is a way for, you guys know, Eventbrite. It's an events platform where people can create events and then users can go on there and RSVP to different events.
00:51:14.336 - 00:51:38.380, Speaker B: The only thing that's different is that you as as a user, you have to deposit some Ether and then you'll get that back when you show up. Kind of like what you had to do here, I think, right? Like hackers had to deposit some and you get it back when you actually show up. And it's basically just to combat the problem of all the lists filling up really fast and then people don't actually show up and these places are half empty. So that's what we're going to go through. So for my l one, I'm using ethereum. For my side chain. I'm using polygon.
00:51:38.380 - 00:51:59.876, Speaker B: For the RPC provider, I'm using Inferior in this specific project, but I've recently started using Anchor and I really like Anchor a lot. For my dev environment, I'm using Hard Hat. But I've also started using truffle recently. Really recently. It's newer and it has some advantages over Hard Hat for specific projects. So I'm going to start trying to use Truffle more. For off chain storage.
00:51:59.876 - 00:52:15.148, Speaker B: I'm using IPFS and web three storage. For indexing. I'm using the graph. For identity. I'm using Rainbow Kit and Coinbase wallet. And we're going to talk through what this means in a second. But Rainbow Kit is a way for you to easily offer your users basically that Connect Wallet button at the top.
00:52:15.148 - 00:53:20.648, Speaker B: And then for the actual wallet, I'm using Coinbase Wallet which is also newer. So I was kind of testing that out and have been experimenting with that. And then finally, for my client, I'm using ethers. JS So now I'm going to walk through the setup. Let me double check my time, how much time I have. Okay, cool. So I'm going to walk through is the text big enough? Okay, I'm going to walk through the setup for so really what I want is if you're here and you're like, I have a really good idea, but I'm not sure of the nitty gritty.
00:53:20.648 - 00:54:22.156, Speaker B: Like, how do you set up an RPC? How do you make your smart contract talk to your front end? How do you do all the little pieces that make everything come together? That's what I'm going to walk through here. So real quick, I'm going to just show you an overview of the contract contracts. It's so small. Okay, there sorry. So like I said, in this contract, we are setting up a struct because in this contract fact, multiple people should be able to create multiple events, right? So this is the way that we're storing the events in the struct is where we're storing all the things that are related about the event. So for this specific example, we're saving an event ID, the address of the person who created the event, the timestamp of the event, the max capacity of the event, the deposit that needs to be sent in order to RSVP to this event, and this event data CID. So this event data CID is related to off chain storage.
00:54:22.156 - 00:55:03.308, Speaker B: So, you know, to save things on the blockchain, it costs gas, right? So for this project, I wanted to minimize the number of items that I'm actually saving to the blockchain because, for example, the event description, I don't need to save that on the blockchain. I can save that off chain, save money. It doesn't have any effect on the security or the functionality of the app. So that CID is just for you guys to know that's related to off chain storage. And we'll talk about that in a second. But it's basically the IPFS hash the reference to our data that's going to come from the front end. So then we create this mapping where'd you go, okay, so this mapping so this mapping maps the ID and ID to a struct.
00:55:03.308 - 00:55:30.404, Speaker B: So here what we're doing is we're creating this collection. It's basically like a dictionary where for every ID, you can find all the information about the event that we just listed, the timestamp, the deposit, the max capacity. And then here we have our functions that do the different things. The first one, the most important one, is creating an event. We pass in all of these information, including the CID. So that's something to note. So remember, we're going to have to compute and get the CID before actually calling the smart contract function, which we're going to do in the front end.
00:55:30.404 - 00:56:06.660, Speaker B: So just hold off on that. But then when we do have that, we're going to pass it into this function. This right here creates a unique ID by hashing together a few of the different arguments because what you want to do is in a hash table, obviously you want to minimize what are called collisions, where basically you want to have a unique key to every definition. So if you have two that have the same key, you're going to be referencing perhaps the wrong one. So one thing to combat that is to get a really unique ID by hashing together some of the parameters that get passed in. So that's what I do there. And then here is where you actually create that entry in the dictionary by calling this.
00:56:06.660 - 00:56:55.792, Speaker B: And then one thing that you'll notice in my contract is I have a bunch of custom events. So here I'm writing custom events. And the reason why I'm doing that is because in order for my indexing and query layer, which in this case I'm using the graph in order for it to understand what's going on in my smart contract, the data that I want to expose needs to be exposed via events. So the data that you want to index and query can only be accessed via events. So that's why you'll see you might be like, why are you creating an event? And then also, I mean, like creating the actual event with the function. Why are you calling the function Create Event but then also emitting an event called where is it? Event called New event created that are basically exposing the same data. Right? But it's because my subgraph, it doesn't have access to my functions, it only has access to my events.
00:56:55.792 - 00:57:29.920, Speaker B: So that's another thing to know if you want an indexing and query layer. And what that does is it allows you on your front end and in this app that I'm going to show you, it allows you to build a dashboard of past events, events that I've RSVP to, events that I've created. It's a way for you to ask questions about your data from this contract. So for example, how many events have iRSVP to how many events have I created? And with that data, you could build a dashboard for each user to let them know what events they have coming up, what events have already passed. So in order to do that with the graph, you need to do it via events. So that's what these events do. And you'll notice at the end of each function, I'm actually emitting those events.
00:57:29.920 - 00:58:07.944, Speaker B: Then I have a function called Create New RSVP, where I pick the event based on the ID. So someone, the user passes in the ID, I go locate that one and I say, all right, from now on we're calling this my event. Then they have to pass in the minimum deposit. The timestamp has to be such that the event hasn't already passed. They get added to this array of RSV peers. And now we have this array of RSV peers, right? But now in order for them to get their ether back, we need to have a mechanism for them to be confirmed or for them to be checked in. So that's what this next function does.
00:58:07.944 - 00:58:44.324, Speaker B: So, again, we pass in an event ID. So we know which event we're talking about. We have to make sure that the person calling this function is the owner of the event, which is why in our struct, when we defined this, we added that in. So all of these little pieces that are there, they're there for, like, a very specific reason, right? And then we loop through the RSVPs. We loop through the RSVPs. So this is Confirm All Attendees, and it just confirms every single one, one by one. So we made this function because, for example, if you guys are all here, and let's just say 50 of you guys are SVP, and I counted, and there's exactly 50, I don't want to have to manually confirm everyone one by one.
00:58:44.324 - 00:59:29.924, Speaker B: So I might just want a button. Your users might just want a button to do Confirm All. So that's what this one does. And then down here, we have Confirm Specific Attendees, where you pass in the event ID and then the address of the specific attendee. So let me just show you guys what this looks like on the front end for you to have kind of like a better idea of how this looks. Okay, so this is what it looks like. Um, here is where the events that get created end up.
00:59:29.924 - 01:00:13.542, Speaker B: And if I connect my wallet and we'll talk about how to do this too, I just kind of want to show you so you know what I'm talking about when I say certain things. If I go here to my RSVPs, I haven't RSVP to anything actually, with this wallet. So let me do that real quick. But this is where it'll show up. And you do this using the graph, using your indexing and query. So if I go to RSVP, actually, I don't know if I even have matic, but I'll just try this real quick. Okay? I don't have enough Matic.
01:00:13.542 - 01:00:30.126, Speaker B: Okay, but let's just say I RSVP. Then it would show up in my dashboard, and then I would be able to create an event. This is the app that we're talking about. So now let me switch back to the code, okay? And then finally withdraw and claim deposits. I'm not going to walk through this. This is basically for the event owner, for people who didn't show up, for me to take your money because you didn't show up. So I get to keep your deposit.
01:00:30.126 - 01:01:17.626, Speaker B: That's what this function does. So now this is our back end, right? This is our smart contract. But now we need a way to do everything else in our client application. So I'm going to open that code up right now, too. File in our next JS project. That's that page where someone creates an event. God damn it.
01:01:17.626 - 01:01:37.518, Speaker B: Here, let me show you. I forgot to show you that. Oh man, I stopped the server. Okay, well, it's like a form where you just put in the event name, the event description, all that stuff that we talked about, but some things that aren't in our smart contract structure. So remember, we didn't have like event name, we didn't store that in the smart contract. We didn't have event description, we didn't store that in the smart contract. But still, it's stuff that we want to show in our app.
01:01:37.518 - 01:02:03.262, Speaker B: But the only difference is that we're not actually storing it on the blockchain. We're storing it off chain with web three storage. And that's what I'm going to walk through real, real quick. So let's go down here real quick. So here is this form, blah, blah. So here event date and time is where the person fills in the date fills in, the time fills in, the max capacity, all that stuff that I talked about. And we save this all in state, react state.
01:02:03.262 - 01:02:24.174, Speaker B: And then what we do is we pass the stuff that is not on chain. So to web three storage with this call right here. So it's just the next JS route. It's called create event. So let me just pull that up so you can see what that looks like. So an API create event. So it's just a function that initially checks the request.
01:02:24.174 - 01:02:55.390, Speaker B: If it's a post, then it passes it down here. I won't go through this line by line, but basically all it's doing is it's taking the body of the request and it's pushing it to web three storage and it returns you a CID. Remember, that's the CID. That's like an IPFS hash reference. And this one is a little longer and a little bit more complicated, I would say, because we're passing in an image too. So it's not just text, but if this was just text, it would be much simpler. But here I'm passing in like an image and that's how you get that really cute image.
01:02:55.390 - 01:03:26.476, Speaker B: So let me just show you here. So in create event. Okay, here. So in Create Event, this is where we make that API call. So we say, hey, we've saved everything in state. Here's the body, here's everything that we want to store off chain, the event name, event description, link, and the image. So now that we've stored the stuff off chain, once that response comes back as successful.
01:03:26.476 - 01:03:49.012, Speaker B: Like, yes, this has been posted to web three storage. It's up on IPFS. Now we actually need to make the call to execute the function on the smart contract and pass in the CID. Because remember, in our smart contract, it wants that CID. In order to do that, let me show you real quick. Create Event, it needs a CID. So that's why we did this in this order.
01:03:49.012 - 01:04:36.804, Speaker B: Because in order to call this contract, it would be missing an argument if we tried to do it the other way. So first we make the API call to web three storage, then it returns a CID and then down here, once it's successful, boom. So once it was successful, then we call Create event and we pass in the CID and everything else has already been passed in. And yeah, there we have that. And then when we're talking about identity, I said I'm using rainbow kit and coinbase wallet. So it's really easy to set up and I'm actually not going to walk through it because what I have is something better. I created a starter repo where you can just clone it and it has rainbow kit, wagme tailwind next, and a wallet connect function already set up.
01:04:36.804 - 01:05:27.556, Speaker B: So the only thing you have to do and I'll walk through it, is basically import your Abi. Oh yeah. So for people who don't know how to do that, I did it inside of a Utils folder. So you just create a folder at the root of your project, call it whatever, I call it Utils and then you make whatever name of your contract JSON and you just paste in the abi from your smart contract. But that's important. So now if we let me show you guys this real quick. Front end starter that you can clone and use for your project.
01:05:27.556 - 01:05:55.500, Speaker B: There's this function here called Connect contract. Can you guys see that? Yeah. Connect contract. And the only thing you have to update is you have to pass in your contract address. And then once that's in, you'll be able to so for every page that you're on in NextJS, if you want to call a function on your smart contract, you need a way to make that communication between your front end and your smart contract. This utility function does that. So instead of manually writing this in every file, we abstract this out to a Util and then you can just import that.
01:05:55.500 - 01:06:37.272, Speaker B: So here if I go to index, I've already done it for you. So it's already imported. And the only thing you have to do when you're actually ready to call your function and I also added it down here is you just do const. This is called your contract or whatever, and then you call that function that we created and then that way you can start calling your function. So this is called RSVP contract, but it'll be your contract here and that way you can use it on every page in your next JS project and you don't have to write the logic to actually connect to your contract that way. Okay, I know that was a lot of talking. Does anyone have any questions up until this point? Okay, so yeah, what you're seeing now is a template.
01:06:37.272 - 01:07:27.900, Speaker B: So let me actually, maybe I'll just run it so you can see, but it basically just has everything installed so it's still like a blank canvas. This is what it looks like. So it has rainbow kit wagme NextJS tailwind. CSS So I'm on the wrong network. But this is a button that'll allow you I don't know, maybe this is the right network, but it'll allow you to have the Connect to Wallet button right away so you don't have to write any of this logic yourself. And yeah, basically you can just start developing the logic to connect to your contract. Is there the logic to connect to your wallet? Is there the logic that's built into Next JS? That's really great, like routing and all that good stuff is already there.
01:07:27.900 - 01:08:01.832, Speaker B: And then you basically just have to import your own, you know, is just copying and pasting that into the utils file and then you can start developing. So let me go back here now. So is there anything I didn't talk about? So let me get into the graph a little bit more. How many of you guys already know how the graph works or you're familiar with it? So so actually not that many people. Okay, cool. So the graph, like I said, I'm going to talk about it six minutes. So the graph is an indexing and query layer and it basically allows you to efficiently read data from the blockchain.
01:08:01.832 - 01:08:36.376, Speaker B: So, you know, right now you can go to Etherscan and you can I don't know, what's a popular project, crypto punks. Sure, you can go to any contract, right? And you can read information about that contract. You can read data from the blockchain, but it's very one at a time. Let me give you an example. Image hash, I don't know. So, yeah, you can read data from the blockchain as it is now, but you kind of got to read it like one piece at a time. But if you want to make more sophisticated queries or to ask complex questions about your data, like you want to understand a relationship.
01:08:36.376 - 01:09:08.690, Speaker B: So for our thing, maybe I would ask how many users RSVP to this event and showed up, or how many people created an event have created more than ten events in the last year. Those types of queries you can't really make manually as it stands right now, just directly from the blockchain. So the graph allows you to do that so it reads all of this data that you're interested in. It indexes all of this data for you so that it's efficient query times when you do ask questions. And then it allows you to make queries with GraphQL. So if you're already familiar with GraphQL, it's the same exact query API. You can ask questions the same exact way.
01:09:08.690 - 01:09:52.196, Speaker B: And yeah, as a developer, basically what it allows you to do is hydrate your UI with data from the blockchain. And when you're developing smart contracts, a lot of your data is coming from the blockchain that your front end user is going to want to know. Like, for example, what is the deposit amount for this event that's on the blockchain. And we need a way to actually read that. And the way that we're reading that in this specific case is through a subgraph. So I can show you guys that real quick too, just so you guys get an idea. So if you write in JavaScript or in TypeScript, it's going to feel really familiar because the mappings are written in assembly script and it's basically just like writing JavaScript and telling and writing the logic for like, I'm interested in this data.
01:09:52.196 - 01:10:23.818, Speaker B: This is how you get it and this is how you construct an object to then send it to your UI. So let me go here subgraph. Okay, so you should be able to understand this because you just saw the whole smart contract. So let me show you in source mappings. Okay? Is this really small? No, it's not. Okay, so when a new event gets created on the blockchain, right, we need a way to display this on the front end. So the way we do this is we create an object.
01:10:23.818 - 01:11:01.906, Speaker B: Maybe I should show you that first. We create an object in our schema. So those who have maybe experienced with databases or with GraphQL, you know what a schema is, but for those who aren't familiar with the schema, it's basically you just defining the objects in your model, if that makes sense. So for us, the objects in our model are an event and an account, an RSVP and a confirmation. These are entities that are unique to our project. And if you make a project with a graph, obviously these will be unique to whatever are building. So for example, here, this means that I want to be able to query for an event and I want to be able to query for all of these different properties in an event, right? So this is what we're defining.
01:11:01.906 - 01:11:26.462, Speaker B: This is like the dictionary. We're saying I want to be able to do this. But now in the mappings, you actually tell the program how to get this data. How do you actually form this and construct this object to then return it to your front end? So this is what's going on here. So we say, okay, when an event is created, this is what should execute in order to build that object. For me, I can't really see from here. Yeah.
01:11:26.462 - 01:11:51.206, Speaker B: So like the event ID, you can get it from the parameters, the event owner, you can get it again from the blockchain who's the person sending this message. And all of these things you can get from the transactions that were made on the blockchain that you just wrote in your smart contract. But here you're just saying this is the logic for how to find it. You're just giving them a map. This is how you get it. That's all you're doing. And then for example, the stuff that is off chain, so stuff that's on.
01:11:51.206 - 01:12:32.686, Speaker B: IPFS, it's not on the blockchain. There's still a way to get it because there's an IPFS API that'll allow you to do the same thing for IPFS. And the only difference is that because this is metadata we're passing in the event CID so that the program knows where to actually go and fetch this stuff from. And what we're doing there is we're literally just going through this object. So JSON is a big object and then it has different properties where it's like name, description. I think those are the two things that we stored off chain image and link. So all we're doing is we're saying, hey, if this IPFS hash is true, if it's valid, if it doesn't come back as a falsey value, then go ahead and because it's an object, it's like one level object, there's no nested objects.
01:12:32.686 - 01:13:07.242, Speaker B: I'm just going to ask questions and I'm going to say, hey, look for a value called name, look for a value called description, look for a value called Link and photo. And when you find it, save it here. And then if these come back to be truthy values again, so if these don't come back as false, like if they're not null or for some reason we spelled it wrong, then this is how we actually construct the object. We're saying my event, the big entity, the specific property equals that. That's the construction, that's how you actually make that object. And this just repeats for all the rest of the stuff that we're doing. But that's the big picture.
01:13:07.242 - 01:13:41.446, Speaker B: Okay, almost done. Last thing I want to talk about present. Okay, cool. So we kind of talked about what the stack that I use is. Again, you should take this and apply it to your own project based on what you're building. But I did want to highlight the bounty. So if we talk about building something with the stack that I just referred to, there's what, 204-065-6868 thousand dollars in Bounties? Just with the specific stack that I talked about here and actually forgot to mention radical.
01:13:41.446 - 01:14:15.830, Speaker B: But radical is a decentralized GitHub. So they have this product where you can host your code and there's literally a prize for $1,500 just to a project that hosts their code there. You can still host it on GitHub if you want, obviously to keep it forever and for collaborators to use. But you can literally just host your code on GitHub and be eligible for this bounty. It's like the easiest bounty ever. And then here is that quickstart front end repo where you can just clone it and that way you'll have Rainbow Kit, Wallet, Connect, Wagme, Ethers, Tailwind, next, JS. You can clone it.
01:14:15.830 - 01:14:29.500, Speaker B: No, sorry. You should fork it first, then clone it and then do your thing on there. I'll pause because people are taking pictures real quick. Yeah.
01:14:33.870 - 01:14:36.890, Speaker A: Does the graph index it like, does.
01:14:36.960 - 01:14:39.690, Speaker C: The graph like listen 24/7 for events?
01:14:40.190 - 01:15:08.722, Speaker B: Yes, exactly. So the graph. Maybe I should have shown that. But the graph, in addition to the schema that you define in the mappings, you also define events to listen to and basically in order to guarantee that you always have the freshest data and you don't have stale data. Like if today we make a query and there's ten events on the platform, but I create three in the next hour, we need a mechanism to refresh basically and reindex. So the way that you do that is you define some events. So for example, for my contract, right, the event was new event created.
01:15:08.722 - 01:15:38.830, Speaker B: So then we say, okay, when new event created gets emitted, I want you to re execute the mapping which rechecks and loops through all of the metadata and does it over and over and over again until we have the freshest data. So yes, so that's that front end repo. I see one more person taking a picture, so I'll let them do it. Got it. Okay, cool. And then the other really cool thing that I want to talk about here is 30 days of Web Three is something that's being hosted by Women build Web Three. We're a dow that's pushing forward female engineering talent in Web Three.
01:15:38.830 - 01:16:06.806, Speaker B: But this is open to everyone. It's education that's going to be open source when it's ready. It's launching in two weeks and it's a 30 day curriculum to basically hold everyone's hand through developing a full stack DAP and kind of help them build that reference and that mental model for what it means to build a DAP. So that hopefully by the end of this you'll be able to say, okay, I have my own idea and I've done this once. I just kind of got to remix the contract because now I learned how to do everything else. I just got to remix and tweak small parts. But I know how to build a full stack DAP.
01:16:06.806 - 01:16:53.158, Speaker B: And actually I want to pull this up real quick so you can see it kicks off in two it kicks off in two weeks and you can register at 30 days of Web Three XYZ. It's open to everyone. It's free. And the cool thing is that you're going to build the project that we talked about in this mini workshop here of building a Web Three RSVP app. And the even cooler part is that there's going to be live workshops by all of these different amazing developers and developer advocates that are like experts in their specific part of the stack and they're going to come do live workshops like this, but more specific to whatever part we're talking about that day or that week. And this was also built with really amazing support from these orgs and these protocols. So, yeah, there's some FAQs at the bottom.
01:16:53.158 - 01:17:12.750, Speaker B: TLDR, yes, you can join if you're a man or anyone can join. It's going to be open source. The time commitment is 30 minutes a day. This is all online and Asynchronous. So in theory, you can do this in a weekend if you want. You can do this in a week. We just are dubbing it 30 days of web three, because that's the pace that we're going to go at and the pace people can follow if they want to follow along.
01:17:12.750 - 01:17:34.780, Speaker B: But you'll be able to do this at any time by yourself. It okay. Cool. And then finally thank you. That was it. If you guys could see my feet right now. Look at my feet.
01:17:34.780 - 01:17:55.344, Speaker B: I've literally been tippy toeing the whole time, and my cows are so sore right now. Okay, does anyone have any questions? You? Good. One question back there. They're not actually cammy in this thing. They took it down. But yeah, right there. I'll post them there and then it's the same as my GitHub handle.
01:17:55.344 - 01:17:59.450, Speaker B: So, yeah, I'll post them there. Cool. All right, thanks, everyone.
01:21:11.380 - 01:21:36.404, Speaker C: Scaffold ETH. If you guys aren't familiar with Scaffold ETH, it's just amazing. Awesome. Open source program or collection of tools. It's kind of like a toolkit that you can use to rapidly deploy ethereum based DApps real quickly, so it's available on GitHub. So really, you can kind of get started real quickly by just forking the code. We're going to go through a demo today and kind of walk through it and show you how you can tinker.
01:21:36.404 - 01:22:17.604, Speaker C: But all the instructions are here so you can get started real quickly. Once you get through kind of tinkering around with Scaffold ETH, you can kind of go on there and put in examples from, like, solidity by example and kind of mess around with it. And after you've been kind of playing around with it a bit, you can go to Speedrun Ethereum. So the Speedrun Ethereum is kind of these quests that you go on where you learn how to do different things, like build an NFT, build a decentralized Staking app, token vendor, dice game. There's all these cool things you can do, and eventually you can become part of the build guild, which is this kind of, like, collection of coders that want to build on the Ethereum Ecosystem. So check that out. Everything you need is right here.
01:22:17.604 - 01:22:53.472, Speaker C: So if you guys take a picture of this, this will give you the website for GitHub. This will give you speed around Ethereum and you guys can get started. Yeah, so we don't have the app up right now, but I use what's called tmux, which is this just a terminal multiplexer it allows me to have multiple screens up. I've already gone ahead and checked out the code for you guys, so we're just going to kind of get started and get going. Here everything's here. When you first download the repository, you're going to do a yarn install, which is going to basically go through, and it's going to install any dependencies that are required to get you up and running. So do the yarn install.
01:22:53.472 - 01:23:18.980, Speaker C: Takes about a minute or so to run and you'll be good to go. Then what we can do is we can do what's called a yarn chain. Yarn chain is going to spin up an instance of Hard Hat. Scaffold ETH uses hard hat. It's going to spin up that you're going to be ready to go. That's all you need. Then in a new window, you're going to come over here and you're going to do a yarn start, which is basically yarn start is going to spin up react.
01:23:18.980 - 01:23:51.388, Speaker C: So the front end that you utilize with Scaffold is react. That might take a little bit to load. So while that's kind of doing, that what I'm also going to do, and that's going to be the second window that you're always going to keep up. The next one I'm going to show kind of what the data structure of the code looks like. Okay? So you'll see when you first get in here inside the directory, let me close this out for right now. There's this packages directory. So inside there we have Hard Hat and we also have React, and then we also have subgraph.
01:23:51.388 - 01:24:32.296, Speaker C: So if you want to do a subgraph using the graph, a GraphQL subgraph, you can do that as well. But most of the stuff that you're going to really be messing around with is going to be here in the Hard Hat directory, right? So inside the contracts, there's this kind of like bare bones contract that gets deployed and it's kind of like a Hello World contract. We can kind of check it out and see if it's spun up, which here it is. So we're up and running. This is going to be out of the box. It's going to have a lot of cool stuff that you don't really have to think about to get started building on ethereum. One of the cool things is it has what's called a burner wallets, right? So you load up your Scaffold ETH app, everything's in burner wallets and you can just grab some funds from the faucet.
01:24:32.296 - 01:24:51.108, Speaker C: So it'll pull funds from Hard Hat, pull them into your Burner Wallet, which is like an in browser wallet. You don't need to mess with MetaMask. You don't have to worry about nonsense or any of that stuff. You can connect. I don't even have MetaMask installed on this profile. But if you wanted to, you could, you could connect to like wallet connect app. Or if you had made a mask, it would show up here as well.
01:24:51.108 - 01:25:24.640, Speaker C: So you can see I've got some funds down the wallet. This app Home, which is basically everything you see here, is like where you would build your app to prototype. So you kind of build the UI into this section. But what's really useful is this debugs contract directory. And this is where it's going to keep track of kind of all the functions that you have available to write in Scaffoldeth and how you can interact with them and test with them. It also gives you the address, contract address, and it tells you how much value is in there as well. I might need to reset.
01:25:24.640 - 01:26:09.404, Speaker C: Oh, I haven't run yarn deploy yet. So the last step is once you get hard hat up, you get react up, then you do a yarn deploy. Now what yarn deploy is going to do is it's going to grab the contract that's in the contracts directory and it's going to deploy that onto the blockchain. What it also is going to do is it's going to kind of like grab the Abi automatically, insert the abi into the front end, and it's also going to deploy an instance of the contract so that you can mess with it. And it also reports like, how much gas you use. It's really useful and it also publishes a subgraph as well. So let's take a look at kind of some things you could do.
01:26:09.404 - 01:27:08.876, Speaker C: So an example would be like, let's say we've deployed that contract now. Now that we've deployed it, we have this kind of like hello world, where there's a contract, there's what's called a purpose, which is just a variable that's being set. And then we have a function that allows us to update that, right? So we could say Ethnyc or something like that, right? And then hit send. And then we just interacted from our burner wallet directly into Scaffold ETH and we're able to see that we updated that variable, right? So it's real basic concept, right? So let's do something a little bit more interesting. So let's define a address variable and we might do something like public, make it a public variable and we'll call it Owner and we'll set an owner variable. We could grab this, sorry, you can copy the address of the contract or you can copy the address of the MetaMask or sorry, the burner wallet. So we're going to grab that and punch that in here and then save that and then come back and redeploy.
01:27:08.876 - 01:27:53.440, Speaker C: So you're kind of doing this thing where you're messing with the contract, deploying your changes, and then once you know that they're successfully deployed, everything gets updated and then you can look back at the UI and see, okay, cool. Now we have a new variable that's called owner and we have that and it matches this. So let's say we want to do something like maybe we have this existing function that gets set up here. It's called set purpose. And you can see here we have like a require that I've already done earlier. I was doing Gandalf, but we'll just say that you're not the owner if you don't have this particular message. So one of the first things you learn with Solidity is the require statement, right? It's this concept of you basically are checking a function to see that something is set.
01:27:53.440 - 01:28:23.992, Speaker C: In this case, we have one called message sender where we're checking to see that who was the message sender for this contract call? Does it match the variable owner? And if not, it's going to say not the owner. So we can set that do a deploy oh, did I do something wrong? Thank you. Let's try it again. Yarn deploy. Cool. But you get the idea. We're going through.
01:28:23.992 - 01:29:17.138, Speaker C: We're kind of doing some changes here, making some updates to the code. And so now what I can do is I can kind of mess around here and let's open up a new incognito window. Let's go to that local host. And so now we have a new instance of the contract up, or I should say of the DAP up, right? So at this point we can grab some funds into this burner wallet, we can go to the debug contracts again and we can try to update it to something like Foo, right? Hit send and we're going to get an error. Not the owner, right? Pretty straightforward. So you get in this kind of like loop where you're just kind of testing the updates that you make to the contract and then you're just kind of validating that, hey, these are the changes that I made and they're working. But that's not really the proper way to do something like access control for a function.
01:29:17.138 - 01:29:59.498, Speaker C: You could also do something like inheritance, so you can actually import another existing set of contracts. So in this case, we can import open Zeppelin contracts, specifically the ownable Sol. And then what we can do is we can make this an ownable contract, so inherited from ownable. And then we can do something like, well, we get rid of this variable here because we don't need that. And instead on the end of this function, we can say only owner, we can deploy that and then make that change. So inheritance is that concept of inheriting everything that's in another contract and making it available in this contract. Let's see if that deployed.
01:29:59.498 - 01:30:42.102, Speaker C: Looks like it did. But what you'll notice is now we have that owner variable, but it doesn't match what's in our burner wallet. So this is kind of one of the first things I had a problem with, with Scaffolds I didn't understand, like, well, who was deploying it? Well, Hard Hat is deploying the contract, right? So what we actually need to do is update the deploy script to transfer the ownership. So you'll notice that in the DAP here, now we have this transfer ownership function, which is a function that's built into ownable. So what we want to do is then take that variable, or I should say that function, and call it in the deploy. So when you set up Scaffold ETH, there's a couple of different areas. There's this old folder called scripts.
01:30:42.102 - 01:31:26.060, Speaker C: Don't go in there because that's the old deploy JS script. Go into this one here that's under deploy. And you'll see that what we're doing here is we're deploying the contract here and we're creating an instance of the contract and then there's an example of how you would deploy your contract here. So I've actually gone in here and already kind of set it up. But what we're going to do is since we already have the contract deployed in this particular instance here, we're going to call that instance of the contract call transfer ownership. But then we need to put the proper address that we want to transfer to. So we'll come back to our DAP, we'll come over here, we'll grab the burner wallet address that we have and oh, sorry.
01:31:26.060 - 01:31:30.890, Speaker C: So let's update that, save it and let's redeploy.
01:31:35.950 - 01:31:36.700, Speaker A: Cool.
01:31:37.070 - 01:31:54.270, Speaker C: And we might need to refresh it. Let's see if it worked. Looks like it worked. Okay, cool. So now we were able to deploy the contract using hard hat and then we were able to transfer the contract using transfer ownership. So now we're the owner again. But this isn't a very, I guess, interesting contract.
01:31:54.270 - 01:32:54.134, Speaker C: It allows us to set the purpose, but we don't want to really just let just the owner of the contract set the purpose. So what we could do instead is we could make this function actually have require a value to make transact with this contract. So to do that, we can go back to our smart contract and instead we can do require statement require that the message value. So this message value and messages send are these global variables that are available, right? And so what we can do is say message value is equal to, I don't know, a variable that we're going to call price. And then we're going to say add more money or something like that. And then what we can do is come up here, create a price variable. So we'll do UN public price equals, I don't know, one Ether, something like that.
01:32:54.134 - 01:33:02.920, Speaker C: And then we'll save that. So now when we deploy that, what it's going to do? Is it's going to recognize I probably did something wrong again.
01:33:11.000 - 01:33:12.150, Speaker D: What did I do?
01:33:13.880 - 01:33:27.154, Speaker C: Oh, thank you. Payable. Yeah. So it does need to be a payable contract. Newbie mistake. All right, let's deploy that again. Boom.
01:33:27.154 - 01:33:44.122, Speaker C: Okay, cool. So it's deployed. I always forget to make it payable, by the way. And we can also get rid of only owner actually too, because we don't want only owner, right? So let's go back because that would be useless. So redeploy again. Okay, so now we have the contract deployed. We've been able to transfer the ownership.
01:33:44.122 - 01:34:20.538, Speaker C: But you'll see, now the set purpose has this value. It needs value, right? So I can set it to whatever I want. So I'll say New York City or something like that. You'll see that? Now we have this price variable and you'll notice that I put Ether, but it's actually showing us in way what we need to actually send in the transaction. So if you didn't have that, there's this cool feature of Scaffold ETH where you can just kind of hit this little green button so you can type in what it would be in ETH, hit the green button and it would translate it to you in way. But since we have it right here, you could just copy and paste it and put it in there. So now we hit send and boom, it works.
01:34:20.538 - 01:34:47.650, Speaker C: So now you'll notice that the contract actually has a little bit of value. So we've deployed the contract and it also has some money in there. But there's a problem. We don't have any way to withdraw the funds. We created this kind of like black hole where we're dumping funds in there. So the next thing you would do is you probably would set up a way to either withdraw the funds or some kind of like if you're really fancy you do like a multi signature. But we're not going to do that right now.
01:34:47.650 - 01:35:45.894, Speaker C: So instead we can create another function that allows us to withdraw that. So I've already actually already wrote it here so we can just kind of grab it out of here. So what we're doing here is we're creating a new function and it's called withdraw and it's a public function but this time we're making it access controlled so only the owner can call it and we're setting a variable or a boolean named Success. And then we're doing a transfer to the message sender. We're doing a call actually with a value of the address of this contract's balance, right? So basically we're just like a rug pool. We're going to grab all the funds out of there so we can save that deploy. So you can see this kind of cool like we're building an app, right, real easily just by making our changes, deploying those and then kind of testing those.
01:35:45.894 - 01:36:02.342, Speaker C: Really cool. So now we can come in here, set the purpose to foo send, we've done it. And then now we have this cool withdraw function. So let's go back to our kind of like incognito one here and let's see if we can withdraw.
01:36:02.406 - 01:36:02.966, Speaker D: Boom.
01:36:03.078 - 01:36:47.942, Speaker C: So ownable caller is not the owner. So we've successfully set up this kind of bank where the contract is storing value. We've set up access control so that we can withdraw the funds. We might want to do something else kind of cool, like maybe just with a simple line we could actually adjust the price. So you can see here we could take that price variable that we're setting, multiply it by 101 and divide it by 100. So basically just increasing the price by 1%, save that, boom, deploy again. And then now what we'll notice is if it deployed successfully, which it did, if we change this thing to like NYC and then hit send, we get value added to the contract.
01:36:47.942 - 01:37:21.894, Speaker C: And what happens to this price variable? Well, it added 1%. So every time that someone's going to come in here and set the function, if we just try to send 10,000, it's going to say add more money because we didn't actually put in the new amount that it cost need to do that. So we can add that send boom. So now it let us do it. So now the price function is in there. We have the contracts getting value, we're able to withdraw the contract. We're able to do a lot of cool things.
01:37:21.894 - 01:38:39.946, Speaker C: We're kind of like building on our DAP. So what could we do next? So I guess what I want to show is maybe the idea of building a token, right? So the first thing usually you would do is if you're going to keep track of a token inside of a contract, you're going to basically create like a mapping, right? So you're going to create a mapping that keeps track of addresses and then unsigned integer that has kind of like a balance for that contract. So first we'll create a mapping, map those addresses to the UN and then we'll create a total supply. And there's a couple of ways you can do this, but total supply is this concept of like, how many tokens are we going to issue in our contract? What I like to do is actually deploy the supply inside of the constructor and I pass it through in the deploy arguments. So what I always like to do is come in here, accept an unsigned integer. In this case, we can do 256 and we can do the total, something like that. And then what we can do is total supply is equal to the total that's passed in the deployer of the contract.
01:38:39.946 - 01:39:23.126, Speaker C: And then what we can do is we can also decide who's going to get all of the balance for the initial balance, right? So we can call balances and then we can call the address. Oh, sorry, it's actually this. And we're going to grab that address that we have in the burner. We're going to put that there and we're going to set that to the total supply. So this is kind of like the owner or the deployer of the contract. And then if we want to actually deploy this, it's going to fail right now because it needs this variable passed over in the deployment script. So how do you do that? Well, there's this option here called ARGs where you can pass like an argument.
01:39:23.126 - 01:39:49.298, Speaker C: So in this case we could say like, all right, let's do, I don't know, 21,000 or something like that, save it, and then let's try to deploy it. So this deploy script is going to pass that value over and then it should update the balances for the burner account with the proper balance. So let's see if that worked. We can grab our address, actually I think it's already on my clipboard. Paste it in here.
01:39:49.464 - 01:39:49.934, Speaker D: Boom.
01:39:49.982 - 01:40:47.834, Speaker C: So this address has 21,000 tokens. So what would be the next thing you'd want to do with that? You'd want to have some way to transact the tokens, send them around. So we're going to actually build in that functionality so we can come down here, we can do like a transfer function. I've actually already written it as well, so let's just kind of block it out and I can kind of walk you guys through it. So this transfer function, all we're going to do is take in an address of where we want to send our new token that we've created and then we're going to take in an amount that we want to transfer to that person. So in this case, it's a public contract and we're just going to return like a boolean to see whether it was successful or not. The first thing you have to do is check with a require statement to say, hey, does this person even have enough to send, right? Do they have enough balance in their actual account to actually send those tokens over? Then it's two simple lines.
01:40:47.834 - 01:41:26.918, Speaker C: It's one to update the message that sender to extract their balance and then it's another one just to update of who you're sending that balance to. So if we deploy this, save it and deploy and now we'll have a new function in here to be able to transfer those around. So let's see if it works deployed successfully. And now we got this transfer function. So now I know that this contract here or this burner wallet here has 21,000. Maybe I want to send some to my other little blocky dude here. So let's come in here, let's do a transfer and let's just send him, I don't know, 777 and then send boom.
01:41:26.918 - 01:42:10.054, Speaker C: So now we can check our balance again and boom. You can see that we've been able to extract. So basically we've created an ERC 20 token so you see how easy it is to tinker around Scaffold ETH. It's really cool, really fun. Yeah. So after you get kind of going and you're messing around with Scaffold ETH again, the next thing I would probably say is check out the code, mess around with it, learn about Solidity. If you don't know Solidity well or you're just kind of getting started, go to Solidity by example and just kind of like start tinking around and grab stuff from Solidity by example, put it into Scaffold ETH, see how it works, right? And start building around and toying around with that.
01:42:10.054 - 01:42:29.998, Speaker C: Once you're done with that, then go to Speedrun Ethereum and come on here, sign up for basically you can connect your wallet here, you can start doing these quests and then eventually you'll be invited to join the Build Guild, right, and go from there and yeah, that's pretty much it. That's kind of my demo.
01:42:30.084 - 01:42:30.238, Speaker E: I.
01:42:30.244 - 01:43:22.718, Speaker C: Do want to see if you guys have any questions, anything you guys want to kind of know about Scaffold? No. Yes there is a TypeScript vision. Actually that is a really good point. So if you do go on Scaffold's GitHub, there's a bunch of different versions that you can get here. So if you want to search for like NFT or if you do TypeScript right here there's an you can oh, they've actually moved. So yeah, we do have a TypeScript version. If you do get any issues with Scaffold, another thing you can do, you can always reset the contract as well.
01:43:22.718 - 01:43:52.292, Speaker C: So that will kind of set the contract back to kind of a reset state. There's also another cool command that sometimes I use. Like if you don't want to constantly be bouncing around, you can do yarn watch where you can actually have it. Just kind of constantly updating for and checking for changes. I'm not sure why it's not working right now. It might not like some kind of change I've made to the deploy contract or something like that. So I'm not sure why it's not working.
01:43:52.292 - 01:44:43.108, Speaker C: But yeah. So really easy to get going. Just to give you an example of if you went to branch like NFT, you could do like I don't know, let's see NFT. So there's like an NFT auction option right, where you can just check out this repository and then it's got this kind of like ERC 721 build and it will help you build like an ERC 721 marketplace. At least I think it's ERC 721 and it gives you kind of like a starting point for your contract and you can kind of mint these little artwork that is in here and create NFTs. Yeah, to ERC 721. So there's a lot of cool stuff you can do.
01:44:43.108 - 01:44:50.088, Speaker C: Highly recommend you guys check it out again. If you guys want any of the links, they're going to be available here. I'm going to hang out a little.
01:44:50.094 - 01:44:51.336, Speaker A: Bit later here too.
01:44:51.358 - 01:44:59.470, Speaker C: So if you guys have any questions about Scaffold ETH or anything, just let me know. Cool. Thanks guys.
02:06:08.460 - 02:06:34.000, Speaker D: Good evening. Welcome to room one. You're in the right room. Thank you. Thank you. You're in the right room. If you're expecting to hear a talk about how to deploy on scale and some wicked cool features that we'll explain that's available on scale chains at this hackathon.
02:06:34.000 - 02:06:57.604, Speaker D: So let's get to it. Welcome to New York. If you're a native here, it's awesome. If you're a visitor, I love this city. I really love the ETH Global events. One of my last favorite hackathons was East Amsterdam and a couple years ago ETH New York in Brooklyn. So I'm so excited that we have such great weather and such a great venue.
02:06:57.604 - 02:07:20.480, Speaker D: So thank you ETH Global organizers for setting this up. Really pumped about this weekend. I love hackathons. They're dear to my heart. So really excited to kick off this weekend for a lot of fun and building some cool stuff by way of introductions. My name is Chadwick Strange. I'm head of product at scale.
02:07:20.480 - 02:07:59.804, Speaker D: I've been with Scale since 2018. This is my third venture in the Web Three space. Before this, I was working in a completely different industry, pharma and Biotech, and I got a reality check that I was in the wrong industry and found my passion in Web Three. And it was at a hackathon in Berkeley, California, where I basically subjected myself to, much like yourselves, trying to learn new things, trying to build cool stuff. Was up late at night till, like, 02:00 A.m.. I'll never forget one of the sponsors who was there at, like, 02:00 A.m. To 04:00 A.m.,
02:07:59.804 - 02:08:24.790, Speaker D: helping our team, trying to deploy a contract. We worked really hard. We had no sleep. The next day, we submitted the project did not work. It partially worked, but people got it. People got the vision, people got the effort, and our team won second place. And that started my foray into this space that I'm super passionate about.
02:08:24.790 - 02:09:03.516, Speaker D: My last name is Strange, and I want to give a shout out to Rob, our social media manager who created this meme from Dr Strange. So the Marvel Studios Dr Strange multi Chain of Madness. And I'll go into Multi Chain in a bit. All right, to set this up for the agenda for this session, I'm going to first talk about Scale network. I'm going to give a high level overview, kind of going deep in certain areas. I'm sure some of you might have heard Skill Network. Maybe you don't know anything about Skill Network.
02:09:03.516 - 02:09:39.660, Speaker D: So we'll start with a high level explaining what it is, and then I'll go into detail about how to deploy on scale. Then I'll walk through some really cool features that are not only great for DAP developers, but they're great to help out, build out incredible DApps. I'll walk through that. I've got some video demos just to truncate the time. So we'll scroll through that, and I have a really awesome live demo at the end. So praying to the WiFi Gods that I'll still have access and bandwidth to do this live, but we'll see. Live demos are always tough.
02:09:39.660 - 02:10:22.300, Speaker D: And then I know you all are here to build, and there's not a lot of time to build. You're thinking about ideas. So I'm going to actually walk through a cheat sheet about how best to position your team for success in building on scale and showing off scale in your project. So I'll walk through how to really win. What are the tips that I can give you to work really fast and to integrate in your DAP, and how can you position yourself best to win? Scale bounties. All right, let's get into it. So what is the scale network? The scale network is the first multi chain ethereum native scaling network.
02:10:22.300 - 02:10:54.980, Speaker D: There's a lot to unpack here. Let's start with ethereum. Native the entirety of scale network is architected and built on top of the Ethereum mainnet. And what does that mean? The entire network nodes represented by these lovely dots on the left side of the screen run by validators. These are skill network validators. When they register with a network, they're registering with Skill Manager on Ethereum. Those are transactions that exist on the Ethereum mainnet.
02:10:54.980 - 02:11:53.984, Speaker D: When you request a scale chain or do any network operations those are also transactions on Ethereum mainnet. And that's really important because the scale network uses the pooled security of Ethereum validators to help support the network. So as validators are joining, as validators are providing or getting stake and delegation. That's all secured by the Ethereum validation layer and then extended through the unique security features of scale network. And so scale network has over 160 nodes currently connected to the production main net. And as a DAP developer when you request a scale chain and again that's a transaction that exists on Ethereum. Scale Manager handles that transaction and says all right, how do we provide a scalable blockchain for this DAP developer? It will go into the scale network.
02:11:53.984 - 02:12:48.170, Speaker D: We'll go into the nodes. It will select 16 nodes at random and it will send an event to those nodes and tell those nodes hey, build or provision a scale chain and these nodes will spin up a dockerized container. These containers are networked together and that basically encompasses the DAP specific blockchain that you use to deploy your DApps and have all your users or community transact with one of these nodes. Let's take a look at this. I'll do this very briefly, but a node, again, run by a skill network validator is a bare metal that runs skill node software. At the core of this software is a Python script that is listening and transacting with the Ethereum mainnet. It's listening for inbound messages about whether a skill chain has been requested.
02:12:48.170 - 02:13:33.850, Speaker D: The other part, again, that's the core, the inner diamond. The outer part of this hexagon kind of it's an abstraction representing the other available compute resources on this node. And that's available to basically containerize or provide scale chains of various sizes and various numbers. So a single node can support up to 16 individual scale chains. It's a very powerful system. And then as a shout out to some of our validators we're working with a lot of validators that also validate for a lot of other networks, especially Ethereum. So these validators have been really great in helping support, build out the scale network and help onboard scale network partners.
02:13:33.850 - 02:14:22.322, Speaker D: So you can think of scale network as a network of DAP specific blockchains represented by these circles surrounding these nodes. So any node can support multiple DAP specific chains. And these chains are very special because they have very fast finality. And that's due to the consensus and cryptography technology that scale network has combined, they run very fast, about up to 2000 transactions per second. You can really throw very interesting contracts at this. So it runs full state smart contracts. It comes with a native file storage layer, comes with a native random number generator endpoint that allows you to help develop contracts and have a really solid source of entropy.
02:14:22.322 - 02:15:24.010, Speaker D: And it comes with a native expandable bridge, which is in a really incredible bridge that allows tokens and messages to be exchanged or transacted with any scale chain and with any Ethereum network chain. And they're DAP specific because as a DAP, if you're building a game or if you're building a marketplace, you have the full resource capacity of this chain, you're not sharing resource capacity with other chains. We all know what happens on a single chain like ethereum. If there's a huge game or AirDrop gas fees go through the roof, the chain slows down, your DAP slows down along with everyone else. On scale, this does not happen. It's a containerized individualized DAP specific resource that's dedicated to your DAP, your contracts, and your community. And this can be shared at least to you or maybe your project, or even open to like a dao community to allow a dao members to be able to transact, deploy contracts and build really interesting stuff on these chains.
02:15:24.010 - 02:16:22.346, Speaker D: With a multi chain architecture, with the many DAP specific chains that can be deployed on scale network, we can kind of think or the network has evolved to create these new abstraction layers and they can be called scale hubs and DAP specific chains. At the bottom, you can think of these DAP specific chains as individual projects, either running a game, running a metaverse, a music streaming app, whatever it is. And each of these apps might need services. For example, for a game, you might need a liquidity layer or some liquidity on ramp. If you're a metaverse, you might need the resources of a marketplace. Well, a marketplace can exist on its own separate chain, and on your DAP specific chain, you can connect to these hubs as service layers. So if you're building a play to earn game, you don't need to build a marketplace on your chain.
02:16:22.346 - 02:17:21.934, Speaker D: You can use a marketplace on another chain and be able to connect chains together using the native token bridge, which allows very fast exchange of messages or tokens between any of these hubs. So again, as a play to earn game, you can get liquidity from one of these hubs. You can send your NFTs to an NFT marketplace and then sell them on the market. So in this way, these hubs provide services to multiple chains on the network. This is an extremely powerful abstraction that is really interesting because the scale network partners have really galvanized around this and decided to build communities of liquidity hubs and NFT marketplaces where it's sharing amongst multiple marketplaces and liquidity on ramps. All right, so that was the introduction for scale network scale hubs. The technology, the nodes, the DAP specific chains.
02:17:21.934 - 02:18:30.594, Speaker D: What can you do on scale? One of the key features is every single DAP specific chain provides gas free transactions with a free gas token called Sfuel. That's right. When you deploy a contract, when your users transact, they don't need to worry about gas fees, they don't need to worry about exchanging ETH to get something done with Sfuel. Again, when you create a skill chain, you're provisioned a huge amount of Sfuel as a skill chain owner that you can allocate or provide out to your users. So long as your users have Sfuel, they can conduct transactions. So this is also a unique way where you can control or basically provide a system where you can onboard your users and sort of modify or customize their onboarding behavior. So as users come on, for example, maybe they create an account on the DAP, they can be provisioned Sfuel and then they conduct transactions after they conduct a transaction, spend their s fuel, they can be topped up through contracts or through faucets or through other mechanisms.
02:18:30.594 - 02:19:19.800, Speaker D: And the reason why there is a gas token is to prevent DDoS attacks. So no single user could just slam the chain with transactions. And this way every single scale chain owner can customize the onboarding process and user behavior through their user journey. Scale chains come with a massive block gas limit 160,000,000. This allows some really interesting design patterns that you can do with solidity contracts. Typically on other chains, you would have to gas optimize your contract, make sure it's not too expensive on scale, since there is no value of gas. You can really pack a lot into the logic of smart contracts and do some amazing things like combining machine learning models with smart contracts that would be completely cost prohibitive on any chain where gas is an actual economic value.
02:19:19.800 - 02:20:21.514, Speaker D: File Storage every single chain comes with a native file storage layer. So you could use other file storage systems, but how nice it is if you're deploying an NFT game or a marketplace and those visual assets or image assets or video assets exist on the same chain as those NFTs, and those files are redundantly stored across the multiple nodes that support your chain. And I'll show a demo of this. So again, if you upload NFT assets, those images, those JSONs, can be stored natively on the same chain that those contracts are deployed onto. You can even use it to host statically generated websites and serve that over the web. Every single skill chain comes up with a random number generator endpoint leveraging key architectural technology of BLS threshold signatures to drive the entropy for random number generation. And I'll give a quick example of how this works.
02:20:21.514 - 02:20:57.830, Speaker D: And this is great, because now you can use this to gamify things. You can use this to maybe randomly select a tie vote for some Dow proposal. Or you can use this to drive some unique aspects of maybe on chain SVGs and creating some unique minting properties of NFTs. And as well we have an IMA bridge. I'm not sure if enough time to go into this, but let's see how we go. So let me get to the first demo. This is just a quick pre recorded video of how to deploy a website on a scale chain.
02:20:57.830 - 02:21:25.890, Speaker D: Oops one secondary it.
02:21:27.060 - 02:21:28.450, Speaker C: Let's try that again.
02:21:35.680 - 02:22:29.900, Speaker D: So I'm going to create a very simple project here. Let me skip ahead a bit. I'm going to port in environment variables which includes my skill chain owner address, my private key as well as the skill chain endpoint. And I'm going to pull in the file storage JS package which allows me to interact and do upload delete create directories with the file storage layer on the scale chain itself. And then I'm going to create a folder that will host a really basic HTML website. Very simple HTML boilerplate. I'll skip ahead, I'll create some CSS.
02:22:29.900 - 02:23:24.684, Speaker D: And then I'll do is I'll create a file storage script for uploading. So this is pulling in the file storage JS library. It's going to hit the directory that I put those HTML and CSS files, it's going to iterate over those files and file storage JS will take those files, cut them up into chunks. It will actually push that as transactions directly to the scale chain itself. And the scale chain will see those transactions, realize that they're for file storage construction, and then it'll recreate that file on a native file storage partition on each of the 16 nodes. So that's what's happening right now, at least in the video. I'll skip ahead and I'll go to my browser.
02:23:24.684 - 02:24:00.990, Speaker D: The other key thing is great, you have a file that's stored on these nodes. There's also an NGINX server on each of these nodes. So now you can serve those assets over the web. So in Brave, there we go. I've just served a static website by uploading files directly onto the scale chain itself. So not only can you create assets that drive your NFTs and have NFTs reference assets on the scale chain, you can create a whole website that's decentralized across your scale chain. Let me go back.
02:24:00.990 - 02:24:39.050, Speaker D: Okay, next we'll look at the RNG endpoint. I'll kind of hurry this up. I actually won't go into the demo because this is pretty simple. I'll go into how you get the information for the hackathon. But this is our documentation portal under Develop. We have a bunch of tools here and right here using the RNG endpoint. Not going to go into details, but you can look this up later.
02:24:39.050 - 02:25:19.910, Speaker D: But this function here, this get random function basically calls a very special precompile contract that's deployed specifically on scale chains only. And this grabs the glued threshold signatures that are used to sign every block onto the chain and it generates a hash of that, and that's returned as a bytes 32 hash that you can then use to generate your Renault number generator. So it's very easy to implement. You copy this, paste it in. As soon as you hit the scale chain, you'll be able to create these random number generators or random numbers.
02:25:22.360 - 02:25:24.070, Speaker C: And we go back.
02:25:33.730 - 02:26:13.686, Speaker D: I won't have time to show the entire video, but again, for Docs, right here on the main page. Ethereum to scale bridge. This contains all the information to get started with transferring tokens between chains. At this hackathon, you'll be able to transfer tokens between Rinkabee and scale, as well as the two scale chains that are available for the hackathon. So you can do scale to scale transfers of ERC 27, 21, Lem 55, and you can expand this to any arbitrary contract. The other key thing about this bridge is it's very fast on production networks. The finality between one chain to another chain is 18 seconds.
02:26:13.686 - 02:26:36.660, Speaker D: That's absolute finality. There's no challenge, period. It is final. When that transaction happens, it's very fast. And let's get to the on chain SVG demo. I did this quite last minute this week, so we'll see how we can get through this. Let's see.
02:26:36.660 - 02:27:11.484, Speaker D: I'll show you briefly the contract I created. The reason I wanted to play with this is I love what people are doing with Onchain SVG. I think it's super cool. And I think we just hit the tip of the iceberg of what can be done with Onchain SVG. So I've created a strange token and I've created this simple mint function. So it's minting incrementally. This is an ERC 721.
02:27:11.484 - 02:27:52.570, Speaker D: I want to kind of show not 1155, but actually minting multiple of these on a scale chain itself. I'm creating an SVG for the token Uri, I'm using the Get random function. So I'm using the randomness for every block to help modify the SVG in place. And here we go. Here is my SVG. So I have this massive SVG with three circles, and the components of this circle are being randomized using the random number generator. So, in effort of time, this is already deployed on a chain that's live right now.
02:27:52.570 - 02:28:30.440, Speaker D: So without further ado, I am going to go ahead and mint this live. I'm not going to do 1000. I've actually trimmed it back. I'm just worried about the WiFi. Well, here we go. So the token is already deployed onto the chain, the ERC 721 contract. And now it's going to go through and just mint 100 of these and it's going to hit the scale chain.
02:28:30.440 - 02:29:03.664, Speaker D: And I have a Block Explorer here, and it might not refresh as fast as the WiFi. You can see a bunch of transactions are hidden into the chain, are being minted. We have contract call. If we go back here, the mint is still happening. Boom. Just let this finish. It's finished.
02:29:03.664 - 02:29:52.064, Speaker D: Minting 100 on chain SVGs using the random number generator. Let's take a look at one of these. Let's see here. Ah, so as you can see, I'm using Remix, so I can easily use Remix or any other web three tooling for a scale chain. And I'll pull up, I think Token 105 was the most recently created. Maybe 401. Yeah, let me check it with three.
02:29:52.064 - 02:31:13.900, Speaker D: Let me refresh I'm trying to read this from this monitor here. It's not the easiest. Let's see ten, it it there we go. I'll do let's see here.
02:31:20.600 - 02:31:21.670, Speaker C: There we go.
02:31:29.430 - 02:31:54.070, Speaker D: Not sure why this is not pulling up. I don't see that file on this screen. Anyhow, if you come by later, I'll show you this live, but it will display in browser the on chain SVG of three circles. Every single mint is slightly different. And that's all done live on a scale chain itself. I'm surprised I got that far in the demo without it breaking.
02:31:54.150 - 02:31:54.780, Speaker E: So.
02:31:56.610 - 02:32:30.150, Speaker D: Without further ado, let's continue on the journey. There are many partners building on scale what things are currently building on scale. Lots of games. Brock Ballers, a lot of people love their stuff. It's like an on chain RPG. Live on scale. We have a lot of other games that are going live or building currently on scale, along with some AMMS, decentralized exchanges, as well as some interesting apps like a name service where you can buy a name service across.
02:32:30.150 - 02:33:21.598, Speaker D: Multiple blockchains that's making use of file storage to actually store a mapping database of those names cross chain as well as decentralized e commerce and NFT marketplaces. So all across the board, many applications to use and deploy on scale the cheat sheet. The requirements to earn scale bounties at this hackathon is simple deploy on a scale chain. My recommendation, just to help everyone else out, is to document scale use in your GitHub dev post and in your presentation. We love to just see how you're using scale and explain that in the presentation itself. And in order just a suggestion in order of the ease of how easy it is to earn these bounties. First thing, deploy it on scale.
02:33:21.598 - 02:33:34.546, Speaker D: Super easy. Any project can do this. Just get an RPC endpoint. I'll show you where they are. It's the easiest thing to do. The next thing of greater difficulty, probably only take five minutes. Integrate an RNG endpoint.
02:33:34.546 - 02:34:01.242, Speaker D: You copy that function, put it into your contracts. When you're deploying that on scale, you'll be able to make use of that RNG function in whatever you're building for various features. The next tier of difficulty is file storage. It's very easy. There's an NPM library that allows you to do these upload operations. Maybe you can host your entire presentation on the scale chain itself, host all your NFT assets, who knows? Go crazy. And then the next thing is the IMA bridge.
02:34:01.242 - 02:34:46.670, Speaker D: We have a lot of sandboxes code samples, JS libraries. It's a little bit more nuanced. But we've had lots of people have a lot of fun building on the bridge and making some really cool stuff at Hackathon. So I encourage you to go all the way down this list. But if you're prioritizing time, this is what I'd say to go through. We have $20,000 in prizes to give out, 5000 to a grand prize, 8000 to a Metaverse Gaming NFT 2000 to a partner integration such as Live Peer at the Graph, and a pool prize of $5,000 shared amongst everyone who at least deploys onto a scale chain themselves. So thank you.
02:34:46.670 - 02:35:10.018, Speaker D: You can scan this QR code. This will get you all the information that you need for getting a scale chain itself. And I'll show you what this page looks like. This is the Faucet hackathon page. So you'll get all our docs here. If you click this hackathon link right here, this will give you a page that looks like this. These are the two scale chain endpoints that are available at this hackathon.
02:35:10.018 - 02:35:37.486, Speaker D: If you click this, it will drop down. You have your Https WebSocket endpoints, a file storage endpoint. So you can hit this, put this in the browser see, and serve those files over the Internet. You have your chain ID. You can click this to add this network to your MetaMask. There's a block explorer. These two chains have IMA natively deployed they're connected to also, these two chains are connected together.
02:35:37.486 - 02:36:30.686, Speaker D: So you can transact tokens between these two chains and then back to that prior page. There's a little bit of nuance about these chains at a hackathon on production, there's a configuration that only certain deployers can deploy contracts to the scale chain here. Anyone can deploy just to make it easier for the hackathon. But every single user who deploys needs S Fuel. So this is a quick faucet how this works out of the two endpoints, just copy paste the endpoint in here, paste in your public key address, hit the S fuel and your account will be allocated Sfuel as well. File Storage you need to reserve space to upload certain files, otherwise people would dos the file storage layer. So we have very similar to Sfuel, a faucet to reserve space.
02:36:30.686 - 02:36:47.106, Speaker D: And there's some quick FAQs and tips just below here. If you have any questions, find us at the booth. We're here all night, all hours. We're often here very, very late hours to help hackers. So stop by engage with our team. Our booth is downstairs. Thank you very much for listening.
02:36:47.106 - 02:36:48.040, Speaker D: Thank you.
02:40:14.200 - 02:40:45.984, Speaker E: A very simple way of explaining what Wallet Connect is. It's just a secure remote signing protocol. What this means is that your wallets can interact with DApps without your private keys leaving your wallet. Basically a lot of wallets support Wallet Connect, and basically any wallet that you can use is enabled. With wallet connect. We also have a lot of DApps. A lot of DApps usually have wallet Connect integrated with us.
02:40:45.984 - 02:41:42.064, Speaker E: And so then for this hackathon, usually just if you want to use any wallet and interact with another DAP, usually Wallet Connect is enabled. Here's a full list and hopefully that by the end of this hackathon your DAP will also be included in this list. We have had lots of downloads throughout the years so we're reaching more places as we keep growing. So how do you integrate it? There's a very simple UI that you see probably in a lot of DApps, which is this Web Three modal and it basically gives you the ability to use any Web Three provider. And this Web Three modal is a way for DApps to connect to either MetaMask or Wallet Connect. Those are the two most popular ones. So I'm going to focus just on those two.
02:41:42.064 - 02:42:31.164, Speaker E: And there's other providers but I'm not going to mention them for now. This is the package you're interested, this is the Wallet Connectweb three provider. This gives you the easiest way to start using Wallet Connect and also use MetaMask at the same time. So this library is this UI that you see when you click Connect. So then how do you configure it? The Web Three model is very easy to configure. What's the most important aspect about the Web Three model is that you can pick multiple different EVM chains. So like for example where it says the network parameter, you can put the Ethereum main net, that's the default.
02:42:31.164 - 02:43:29.540, Speaker E: You can put optimism, you can put Polygon Mumbai. What you have to remember is that you have to pick an EVM compatible chain. Also something important that you need to do is that you have to have your inferior ID. The reason for this is because the connection with the wallets, the wallets don't provide the blockchain information. Your DAP still has to query that information with Infuria, for example like nonsense or token balances that is obtained through Infuria, not through Wallet Connect. So once you have it set up, you can do await this promise web Threemodel Connect and at this point the user is presented with this interface. So only until the user presses one of the options either MetaMask, wall connector or coinbase, that promise will resolve and then you can easily integrate it with a Web Three object.
02:43:29.540 - 02:44:23.280, Speaker E: In this case it can be Ethers or Web Three JS and the provider would be the wallets that the Wallet Connect has given through the connection once the user connects with it very similar to MetaMask. Once you press Connect, it gives it to the user to this object. This provider object follows this EIP 1119 standard. And there's two things you should pay attention during this hackathon with regards to this standard is that it has two functions which is two events accounts changed and chain changed. So what usually happens is that on your wallet the user can like okay, I'm on Ethereum main net, I should. Probably want to switch to the testnet. So I want to switch to Rinkabee.
02:44:23.280 - 02:45:27.656, Speaker E: So you want to pay attention to when the wallet changes from one network to the other because that can change the contracts that you interact with or where your DAP is deployed. Another thing that you have to listen to is the events for account change because the user you can have multiple accounts on your wallets, and you might switch them to test your DAP. And just keep in mind that this is how you listen to them and depending on your use case, finally, so you're going to be iterating a lot in your DAP, probably in this hackathon, and you might want to disconnect to try to reconnect with another wallet. Just like, okay, you're sharing with your teammate in the hackathon. It's like, okay, here, scan this. Why is it not working for me? So you have to remember that when you disconnect that, disconnects the session, but the cache on the browser still contains the information of the address that was previously used. Now, this is useful for user experience because then it's like you don't have to reconnect every single time.
02:45:27.656 - 02:46:16.650, Speaker E: You don't have to scan the QR code every single time. But it can be quite troublesome for you during this hackathon when you forgot to clear your cache. So it's recommended at least that after you disconnect, you also clear the cache just to make sure that you don't have any leftover addresses that you don't want to use. So here the docs. There's a lot of other providers that are not just only infuria or I mean just other Web Three providers that the Web Three model supports. We recommend that you use four to six providers because sometimes having more options is too overwhelming for the user. So the top four most popular is usually pretty good starting point.
02:46:16.650 - 02:46:58.940, Speaker E: And we also have the Wallet Connect docs for when you depending on the different types of transactions you want to do with your DAP. And finally, here's an example repository that has Ethers JS. Ethers. JS is just a web three library. This is a react app, and it already has the Web Three modal installed. So this is a good starting point for your DAP if you just want to use Wallet Connect with Ethers JS. Yeah, it's a very quick demo.
02:46:58.940 - 02:47:48.640, Speaker E: I'll just go back because this is probably this the event accounts changed and chain changed is quite important. And the disconnect, you don't want to make sure that you leave cache there that affects your adapter and your hackathon. I'll just leave it at the docs and that's it. Any questions? Go ahead, Alchemy. Yes, you can use it. Yeah, definitely, you can use it. So other EVM chains I know, for example, that some Cosmos chains have forked Wildconnect to support Cosmos transactions.
02:47:48.640 - 02:48:39.040, Speaker E: I don't remember exactly the name, but I'll have to get back to you in that version. Two of Wildconnect, which is we're hopefully wrapping up soon, would be multi chain. So, sadly, it's not ready for this hackathon, but hopefully future hackathons, we will have multi chain support. Okay, if you have any questions, we're going to be here at the booth. Usually most of the problems occur with network changes. Like when you change your network from either Mumbai or to optimism on your wallet, that usually causes a lot of confusion or the event does not get updated properly. So you should pay attention to that during the hackathon.
02:48:39.040 - 02:48:54.550, Speaker E: My personal experience, Rainbow Wallet works really well. It's really well supported with Wallet Connect, and it yeah, that's what I have for now. Any more questions? All right, thank you very much.
