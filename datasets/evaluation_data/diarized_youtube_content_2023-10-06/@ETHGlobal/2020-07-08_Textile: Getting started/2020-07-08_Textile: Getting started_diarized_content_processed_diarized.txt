00:00:01.290 - 00:00:03.200, Speaker A: Started it. Give me a second.
00:00:19.330 - 00:00:37.238, Speaker B: Looks like Twitter is good. We're streaming on Twitter. We are streaming on you. We are go. Cool. All right. Welcome, everybody, to what feels like the third or fourth event this week.
00:00:37.238 - 00:01:21.254, Speaker B: Even though it's Tuesday, we're happy to have you all. This is part of the workshop series for Hack FS, which is the filecoin and ETH global or sorry, protocol labs and ETH global hackathon. We're glad to have you here. Let's see if there's any housekeeping I got to get out of the way before we start. This Thursday at midnight, Est or Eastern is the staking deadline, so if you haven't staked already, please make sure to do that. That's how we make sure people are going to be engaged throughout the entire event and are going to submit something at the end. So it's a small thing, but just make sure you get on that ahead of time.
00:01:21.254 - 00:01:56.446, Speaker B: So you just get it out of the way and you can start hacking. We've got a bunch more events starting Wednesday and then more into Thursday and Friday, so keep track of the schedule in the Hackafest Schedule Channel. Hopefully you've seen it, used it. It's a useful channel. And today we have the second Textile workshop with Carson Farmer leading this time and Andrew Hill. They're both from Textile. They're going to be diving a little bit deeper into what Textile is and how you can use it in your hack.
00:01:56.446 - 00:02:26.060, Speaker B: So we're super excited that they're back again. I think the first session was really helpful for a lot of people. And just a note, if anybody is in the chat or they've missed previous sessions, they're all recorded and we put them right on the ETH Global YouTube directly after. So have no fear. If you've missed other ones, just check there and they should be ready to go just after each event. Let's see. Before we start, we're going to loosen it up a little bit and play a quick game.
00:02:26.060 - 00:02:40.382, Speaker B: It's not a very hard game. It requires some participation and your camera. So let's see. Reach around your desk. You don't have to get up for this game. And pick up a writing utensil. Let's see.
00:02:40.382 - 00:02:49.950, Speaker B: I'm team highlighter. Oh, wait, there we go. It wasn't going to show up on the green screen. Team Highlighter, where are you at? We've got some pens.
00:02:50.110 - 00:02:52.606, Speaker C: Can I actually have a construction pencil?
00:02:52.798 - 00:02:56.520, Speaker B: I think that counts as a highlighter, though. It's pretty yellow. You're on my team.
00:02:57.370 - 00:02:58.470, Speaker C: Both all right.
00:02:58.620 - 00:03:05.720, Speaker B: Unfortunately, it looks like the Pens are going to take this one. Josh, is that a mechanical pencil or a pen?
00:03:08.650 - 00:03:09.766, Speaker A: It's a pen.
00:03:09.948 - 00:03:16.860, Speaker B: Good question. All right. Looks like the pens win. I can't win them all.
00:03:20.990 - 00:03:25.818, Speaker C: I didn't really have you writing utensil on my desk. This was actually in a tool belt.
00:03:25.914 - 00:03:27.200, Speaker B: Are you building something?
00:03:28.530 - 00:03:30.686, Speaker C: Always building something. Aren't we all building something?
00:03:30.788 - 00:03:38.660, Speaker B: That's true. We're in a hackathon. All right, enough with the games. I'll let you guys start talking and educating us. Take it away.
00:03:39.750 - 00:04:20.094, Speaker C: Okay, cool. I'm just going to share my screen over here and cool. All right, thanks everybody, for joining. I've got a little bit of time here, about an hour, I think, today to talk a little bit about getting started with Textile. We're going to cover a little bit about what is Textile, but mostly I'm going to be talking about a couple of different textile technologies that you can use in your hacks to blow everybody's mind and win this thing. So I'm Carson. I'm from the Textile team.
00:04:20.094 - 00:05:46.682, Speaker C: And for those of you who don't know much about textile yet, we are a company focused on building developer tools on top of decentralized web technologies, specifically IPFS Filecoin and Lib, P to P, and a lot of those other fancy schmancy terms for the DWeb technologies. And so our team focuses a lot on trying to build tools that feel like existing web development workflows for developers coming from the web two or more traditional web development background into a web3 space. So hopefully today you'll see some of that technology in action. So today we're going to learn a little bit about building some JavaScript apps that use Textile's, kind of three of the four flagship tools that Textile supports the Hub, threads and Buckets, which I'll talk a little bit about over the next couple of slides. And we'll use those to push data to IPFS and beyond. We're also going to walk through a series of setup options to actually get you going and using some of the Textile infrastructure. And then we're going to use some examples in a repo that we already have online so that you can kind of copy past bits and pieces and components into your hacks to kind of bootstrap what you're working on.
00:05:46.682 - 00:06:27.398, Speaker C: So we'll show you how to get started a little bit with some basic identities, and you can mix and match your own user identities in there if you'd like, and we'll just start building potentially real apps for the decentralized web. And so let's jump into that. There we go. That's me, and that's what we're doing. So when I say real apps, I'm talking about hopefully engaging apps with real users that are dealing with real user data. And by the way, while I'm going along here, if you do have any questions, feel free to ask along the way. I'm going to ignore you.
00:06:27.398 - 00:07:35.134, Speaker C: But we have Andrew and Aaron on the call here who should be able to answer your questions as we go in the chat and on Slack as well. So please feel free to interrupt me as we go along. And Andrew, if there's any big question you want me to answer in person, ping me in the community channel and I can address it live. Okay, so let's start with a pretty common set of requirements for some kind of web or even a mobile app. So say you're creating a document signing service like something like DocuSign where your users might be uploading documents, they want to share links to those documents, they want to have folks interact with those documents. Or even just a simple photo sharing app which we're going to touch on a little bit later today or at least a photo viewing app or any number of sort of like standard web two experiences where you've got a user that wants to do things and potentially interact with other users. So one thing is you're going to need users, I can't help you with that, although we might be able to help you make it easier to onboard those.
00:07:35.134 - 00:08:38.402, Speaker C: You're going to need some storage and some level of persistence for your user's data and you're probably going to want some form of authentication so you can actually ensure a nice smooth user experience. You don't just get spammy things and all that. You'll also want some things that we've kind of come to expect out of Web Two and Web Three technologies, which are things like standard encryption tooling and best practices there you'll want a way to scale without having to have your users install something and download it on their desktop. You probably don't want your dev team to have to learn a whole new language just to kind of get started. And you probably don't want your users to have to learn a whole new language just to get started. As you know, there's a lot of things we'd want as developers and a lot of this stuff exists already to some degree. But now we want all this stuff to run on the decentralized web or the IPFS network, we want all the nice content addressable features, we want P Two, P networking, we want all those goodies and we want it to be easy to use.
00:08:38.402 - 00:09:44.770, Speaker C: So things are starting to get a little bit more technical complicated from a technology point of view, but we'll add another constraint which is that we want the users to have control of their own data as well. And our team has talked about this a bit in the past, but the sort of long and the short is if we're going to be changing the way people interact with data on the web, we might as well. Do it the right way and make sure that users have sort of interoperable data that they can actually own and bring to the apps that they engage. Know, we want all these nice things, we want encryption, we want it to be familiar, we want users to have control. And I've talked about this in a previous ETH event, ETH Denver, where these jazzy hands are sort of suggesting we should put the control back into the hands of the user. So I'm not going to show this or anything, but there's a link in the slides to some of our thinking around how that might look, but okay, back to the task at hand. We've got this impossible set of constraints that we want to build apps on the DWeb.
00:09:44.770 - 00:10:17.982, Speaker C: That's where textile comes in. You can kind of think of textile in the set of technologies that I'm going to talk about here today as something like a firebase for the DWeb or an Icloud sort of framework for the DWeb. Now, I'm not going to talk much about powergate here today because Andrew's already covered that really well in some previous sessions. So definitely check out those videos if you want. I'll allude to what you can do there in a little bit. And Andrew's going to give us a little demo at the end. Hopefully that is going to touch on some of those concepts.
00:10:17.982 - 00:11:15.938, Speaker C: But what we are going to talk about here today is threaddb buckets and the hub. Okay. And these are some of the core textile technologies that I'm going to dig into here. So let's start there. So thread DB, that's what we have is it's a P, two P database, peer to peer database. We call it thread DB, and it's been designed and built pretty much from the ground up to leverage some of the best features of lib P to P and IPFS for creating and storing and syncing dynamic data, focus on dynamic data across a network of potentially trustless peers. And so I'm not going to spend a ton of time talking about the nitty gritty details of threaddb because we're going to actually leverage it a little bit, sort of under the hood, and some of the examples and things we'll talk about later.
00:11:15.938 - 00:12:00.420, Speaker C: But if you really want, you can read our white paper. We wrote a white paper, so, you know, it's good science because everybody likes reading academic research papers. But you can also check out our docs online to find a little bit more about what's going on under the hood there. Essentially what we're talking about is a peer to peer decentralized document store with a familiar MongoDB like API. It's got offline first storage and remote peer syncing, so you can sync your peers across the network. It has user and developer authentication and cloud support. So you can actually run threaddb daemon or peer in the cloud, which we'll talk about a little bit later.
00:12:00.420 - 00:12:36.650, Speaker C: It supports encryption and custom conflict resolution out of the box. So data and files are encrypted by default. And one of the things we'll mention later today is it has a flexible idea of a user identity. So that if you are coming in, building a DAP, and you've already got your users using three box profiles or you're using MetaMask or whatever, that's cool. Threads can support that. And yeah, check out the white paper if you like that kind of thing, and skip past it if you don't. But the long and the short of it is it's a protocol.
00:12:36.650 - 00:13:34.382, Speaker C: So threads is a protocol for synchronizing database updates among a network of these peers, potentially trustless peers. And threaddb is a document style database built on top of the threads protocol. So we've got threads the protocol, and threads the database. And the cool thing about this is it gives us some pretty slick database superpowers in terms of things like being able to defer conflict resolution until such a time as the data is actually accessed by a user, plus a whole slew of other pretty pluggable and powerful features. So if that sounds interesting to you, read the white paper, check out the docs, and we'll mention a little bit more about it later. All right, so threaddb is really great for managing things like documents and even structuring potentially. So someone mentioned in the slack channel today how you might index and query files and data on IPFS.
00:13:34.382 - 00:14:23.150, Speaker C: Well, threaddb is one way that you might do that, where you can sync actual mutable. It's essentially immutable database that takes advantage of the immutability of the underlying IPFS, and then uses lib PDP to actually communicate those updates among peers. So for things like JSON, documents, structured data, all that sort of thing, user data, it's perfect for that. But one thing we learned along the way is a lot of time when you're dealing with very large data sets, or you're dealing with whole folders of files and things like that, you don't necessarily want to stick those things into a database. Things start to blow up pretty quick. Often what you want to do is you want to reference files within your database. You want to reference that binary data within your database, but store those files elsewhere.
00:14:23.150 - 00:15:27.026, Speaker C: And in the case of a decentralized web system, you want to store those files on IPFS. So while threaddb is great for JSON like documents and that sort of thing, for large data images, et cetera, you kind of want to take advantage of some of the core features of IPFS, things like data duplication, chunking IPLD dag so like highly nested folder structures. But you might also want things like persistent identifiers so that if you modify that folder in any way, it's still the same reference in your database. You might want dynamic data management, you might want to build collaboration tools, and that's where buckets comes into play. So basically with Buckets, we're talking about dynamic folders built on top of threaddb and IPFS. So this is really useful for things like collaborative multi user folder syncing. So you could have like, team projects that you sync in a folder, you could build a dropbox like app, s, three style APIs, all sorts of really cool things.
00:15:27.026 - 00:16:17.000, Speaker C: And in fact, buckets has kind of moved beyond just a protocol that we use for these types of things to a whole sort of application that you can run locally, and we'll talk a little bit about that as well. But essentially, buckets are a cross protocol format built on IPLD and threaddb with some pretty nice design constraints or features that we kind of focused on. Buckets are already being used by teams like Fleek, which who, by the way, you should totally check out for your hacks, by the way. In fact, they have a bounty for the best app that uses their space daemon, and that could actually be used as a buckets gateway for actually rendering and interacting with buckets data. So that's really cool. I encourage you to check that out. I encourage you to check out all the projects, but Fleek in particular is doing some really cool stuff.
00:16:17.000 - 00:17:14.914, Speaker C: But if you've used a cloud storage kind of provider before, you'll find buckets. Pretty easy to understand. Except, unlike a cloud storage service, buckets are built on IPFS, lib, PDP, and textile. So you can serve websites, data, and apps right from buckets. But here's something I think is super cool, and for anybody who's even remotely familiar with IPFS, this is pretty magic, I think. So buckets are actually a folder on IPFS, similar to how you might add an Immutable folder on IPFS, except so buckets are simultaneously an actual threaddb document instance, so you can actually query the folder as if it was like an entry in a database, an Http available domain. So you can actually host and render websites on a bucket, and an actual working IPNs address on the IPFS network.
00:17:14.914 - 00:18:19.734, Speaker C: So the bucket ID is itself an actual IPNs address. So this is pretty cool because it means that every time you update a bucket in the background, textile, buckets is actually automatically updating the IPNs address so that you get this dynamic data on IPFS dynamic folders. And so you can imagine things like, you can start to render folders of images that are updated or blog posts or however you want to start to think about data. So this is a pretty powerful thing, but sometimes things don't work, sometimes things break. So another really cool feature of buckets is, and a huge part of part of the textile philosophy around peer to peer systems, is there needs to be multiple paths to access any particular resource, because your phone's going to go in your pocket, your laptop is going to be closed, things happen. So with threads, we have multiple ways to access thread data or thread DB data. We have pub sub, we have direct peer to peer sharing, we have gRPC web enabled push and pull APIs, we have raw IPFS.
00:18:19.734 - 00:18:54.114, Speaker C: All that stuff is available on IPFS. So if you've got an IPFS Damon, you can access that stuff. With buckets, you have all that stuff. Plus you have IPNs, you have custom and vanilla IPFS gateways, and you have all these slew of different ways that you can access you and your users can access their data. So the whole idea here is basically users should be able to find you and their data, no matter what. And at the end of the day, like I said, if they've got IPFS, then they can get it at the sort of fairly low level as well. So what we have is dynamic data and storage on IPFS at our fingertips.
00:18:54.114 - 00:20:04.254, Speaker C: We got a database, we got large data store, and then we have the Hub to wrap this all up with a nice pretty bow. So the textile team, we're pretty much all developers, some of our best friends are developers. And our philosophy is that if we want to see this shift over to the D web happen, it's not going to happen until developers start building better experiences, more interesting experiences and new experiences on web3 tech. And the way we get there is we build tools and then people build tools on top of those tools and other people build tools on top of that and so on and so forth until we all win. And so that's pretty much what the Hub is about. It's trying to make it as easy as possible for developers to start exploring web3 tech without having to fully commit to running filecoin nodes and IPFS peers and all these different things. You can defer some of that technical stuff to the Hub, you can start exploring that stuff and then as your project matures, you can shift onto the Hub, you can shift off to the Hub, you can move to a more production ready or developer framework, whatever you want.
00:20:04.254 - 00:20:58.734, Speaker C: And the Hub is designed to be there for you at all those different stages. So it's essentially cloud tooling for developers that are designed around user controlled data. So that's part of our sort of underlying philosophy with trustless data management, a bunch of new models for decentralized data access. And at the most basic level, we're talking about remote IPFS and threaddb peers that developers can use to test out, build stuff, manage teams, deploy their apps, and then potentially even connect up with the filecoin network. So it's a nice way for developers to dip their toes in without having to commit fully. And then right now, all these things are free for developers with some reasonable limits. And hopefully you saw the announcements that Andrew mentioned about hosted powergate instances for teams that are hacking as well.
00:20:58.734 - 00:21:51.534, Speaker C: So if any of that stuff sounds like oh, I'll just use the Hub, great, we'll talk about that today. And if any of that sounds like oh, I'd really like a custom version of something around that, then get in touch as well. We may say no way, that sounds like a lot of work, but we might also say hey awesome, let's do that, so get in touch. Anyway, the long and the short is we want you to build stuff and the Hub is going to make that a little bit easier. So let's just do some of that. I'd like to today basically start to onboard some folks to the Hub and threads and a few other things. So that after today, if you have any questions or you want to figure out how do I do this with threaddb, or how do I push this kind of data to a bucket, or what can I use a bucket for? At least we'll have all the groundwork to say.
00:21:51.534 - 00:22:18.134, Speaker C: Okay, do you have an app that's got the bucket client working? Great. Cool. Let's dig in and figure out API keys and that sort of thing. So my goal here today is kind of open your eyes to some of the tools that Textile provides, point you to as much documentation as I possibly can. And I got to say, Andrew, who's on the call here, has done an amazing job with our doc updates lately. So dig in. It's pretty nice.
00:22:18.134 - 00:23:22.810, Speaker C: And in fact, we're pretty much going to just go through some of the documentation that we've put up there. But that's my goal here today, is basically get you onboarded at the minimum and then point you in all the right directions. And I think that if we do that, that'll be a success. So on that front, I'm going to kind of treat the rest of the session as a tutorial walkthrough kind of thing just to keep us on time and avoid getting bogged down with NPM issues or do you have the right node version and all that stuff. But I do encourage you to follow along, at least with the first part because I want to make sure everybody's got their accounts and command line tools. And then as with all these sessions, all of these materials are already and they will be available after the session so you can tinker around at your own pace. But today, if you stick it out with me, you're going to learn how to generate some API credentials that you can share with your web apps so that your app can actually leverage the Hub directly.
00:23:22.810 - 00:24:04.422, Speaker C: And the reason we want to do that is this is kind of a neat feature of the Hub. It's solving a problem that we potentially didn't really need. It wasn't a problem until we started to focus on peer to peer and decentralized compute and tooling. But basically what we're going to do is we're going to generate some Hub credentials. And with those Hub credentials, your users will actually be able to access things like Threaddb and some of the thread services like Buckets. They'll be able to create buckets, push to buckets, pull from buckets, et cetera, and use IPFS persistence and all those nice things right from the browser, which is great. Okay, that's pretty neat.
00:24:04.422 - 00:25:15.554, Speaker C: But the really cool thing is you will be able to build your app so that your users will take advantage of you, the developer's resources, so your API access while still maintaining their ownership over the data that they create. So it's basically like you the developer are going to carve out some space for your users on the hub without you or anyone that they don't want being able to look over their shoulder. And this is pretty powerful kind of concept because what we get out of that is we get the ability for different developers to create data on behalf of users and users potentially have that data transferable or interoperable among different apps, or at least that's the idea. And what would be really cool is if we get multiple teams doing this and then potentially explore the idea of actually cross data collaboration. But we'll see. Anyway, this can kind of help to answer the question of who's responsible for your app data. It's you the developer, but only insofar as your users actually want to trust you.
00:25:15.554 - 00:25:58.910, Speaker C: And I think that's a pretty neat idea. Okay, so that's what we're going to cover today. What we are actually doing today is we're going to be following some of the docs that we already have online on our docs site. That way you can follow along afterwards. So if the top link here, the tiny URL, that is a gist, a GitHub gist with a bunch of the actual command line things that we're going to cover today. So I highly recommend you grab that URL and go there and get ready to copy past us some stuff. But what that really is going through is that tutorial there.
00:25:58.910 - 00:26:48.574, Speaker C: So Docs textile IO tutorialhub. So that's kind of what we're going to go through today, or at least we're going to get to the point where we're going to do that. And we're also going to play around. And this is in the gist as well with this examples repo. And I'm mentioning this Bucket photo gallery example specifically, but there are multiple examples in that JS examples repo that you can pick apart and play with as you're exploring Textile as part of your hack. So that's what we're going to do here today and then tomorrow during our office hours, which I will have to confirm the time towards the end of our session today. But during the office hours, I'm going to actually also, depending on how many questions there are, we'll address the questions first.
00:26:48.574 - 00:27:21.274, Speaker C: But if there's a lull, I'll actually go from building from an empty folder to a working thread space DAP or app. If anybody's interested in, I'll do that live so that you'll actually see kind of the nitty gritty of how that might work. And we'll just do that as a create react app, quick one. And I think that'll be kind of fun as well. So stay tuned for that if you're interested. Okay, so with that, let's follow along with the gist. And I want to get everybody onboarded a little bit here.
00:27:21.274 - 00:28:15.450, Speaker C: So I've got the gist open here and hopefully everybody can still see that. I think I'm sharing this whole screen. So I'm going to move that over to the side. So that's the URL that I had in the slides there and hopefully everybody is able to find that and probably someone can share it in the chat if not. Okay, so here's some description of what was going on here, but I want to jump us down to getting started with the Hub. So like I mentioned before, the Hub is basically cloud infrastructure for getting started with threads and buckets and various textile infrastructure. We have a command line tool that allows you to kind of explore just about all of the APIs that are available in our JavaScript clients from the command line.
00:28:15.450 - 00:29:05.066, Speaker C: And I encourage you once we get this downloaded and going to explore some of that. Because what I find is super handy is if you want to test out something that you're going to do in your app, you want users to push a photo to a bucket or something like that. You can test that on the command line using your own account first as a really nice kind of way to say, oh, okay, here's the call. These are the different flags that I might want to use in order to turn on encryption or turn it off, what translates over to the API clients. And I'll point you to all the documentation for the clients as well. But the other reason we need the Hub command line tool is because we need to create a developer account for everybody on the Hub. We can't really use Hub infrastructure if we don't know who you are.
00:29:05.066 - 00:29:41.510, Speaker C: You can't allocate that space for your users if we don't know who to allocate that space with. So let's get the CLI tool. We're right here so you can grab the latest releases from our release page. So if you go to releases, you'll probably see something kind of like this. So here's the main textile GitHub and their new links for the releases are on the right there. So you can go and grab the latest release for your platform. And we just released a version about five days ago, so it's pretty hot off the presses.
00:29:41.510 - 00:30:23.602, Speaker C: And just grab the Hub not Buck, that was for a different session. The Hub tool for your platform. So I'm on macOS, so that would be the StarWind one, but you might be on Linux, Windows, wherever. We just added the Windows builds back. So that's pretty exciting. Okay, so you're going to want to grab that and download the tar gzip or whatever zip file if you're on Windows unarchive it and then go change into that directory. So if you're on Mac, here's a couple of steps you might want to follow.
00:30:23.602 - 00:31:02.834, Speaker C: If you're on Windows, open up the zip file and put that executable somewhere that is handy for calling tools from your terminal. We do actually have an install script in there, so if you're on a Nix like system, you should be able to use that. Don't worry about it. If that doesn't work, if you don't have permissions or something like that, it's a self contained executable. So you could stick that Hub Binary pretty much anywhere. And as long as you can call that Hub Binary, then you have all the tooling that you need. So, yeah, hopefully that's good.
00:31:02.834 - 00:31:49.914, Speaker C: And someone can ping me if that's not working, but I'll give everybody a couple of seconds to download that and get it installed. Put it somewhere that's handy. Now, if you're on Mac, your operating system is trying to protect you from textile. We just haven't signed our binary releases yet, so you may end up getting a warning that looks something like this hub cannot be opened because the developer cannot be verified. So the way to check that is download the Hub Command Line Tool and install it. Put it wherever you want, and then if you just run Hub Help, chances are you'll get this pop up on macOS the first time you do it. So go ahead and click Cancel.
00:31:49.914 - 00:32:22.410, Speaker C: Don't move it to the trash. Obviously that wouldn't be great, although you can always just extract it and install it again. But click Cancel and then just go up to your little Apple Guy system Preferences, Security, and Privacy, and you should see a little thing towards the bottom of that dialog that allows you to click Allow. Anyway, trust me, it's fine. Don't worry about it. We wouldn't do anything untoward. We just haven't signed our releases, which we'll do in the near future.
00:32:22.410 - 00:33:10.102, Speaker C: But you can click Allow anyway. And then if you run Hub Help again, you might see another warning, but this time you should be able to click Open, and then it should run. So hopefully that's the case for everybody. And then you can start to play around with the Hub Command Line tools. So if you open up a terminal here and you type Hub Help, you should get some output that looks something like this. And yeah, there's a bunch of tools in here that we can use, and we're going to go through a couple of them now. And then I encourage you to kind of play around and explore some other ones as you go.
00:33:10.102 - 00:33:50.006, Speaker C: I always like to try all of the different commands on a new tool I find, just in case I can break something or do something fun. So I encourage that, but I will wait a second. And I've been blabbering on for a while, so hopefully everybody has got that downloaded. So now to actually use the Hub, we're going to actually initialize an account and create an account. So the Hub is where there's a whole blurb here. You can read it about what the Hub is for. But basically what you're going to need to do is you're going to need to create an account on the Hub, and you can actually create teams and collaborate with team members via the hub as well.
00:33:50.006 - 00:34:40.534, Speaker C: So you can have team based buckets and you can manage threads and things as a team. And we recommend that if you're just starting off as a developer, you might as well use your own account and create keys and blah, blah, blah. But once you maybe actually formalize your hacking team and you want to think about deploying assets to buckets, or you want to use buckets in your own app, or you want to generate keys for a production app, that you might do that as a team. And so there are various tools to help you manage keys and orgs. I've been saying teams but orgs and organizations similar to the concept of like orgs on GitHub versus users on GitHub. So there you go. Anyway, we're going to create an account and you can do that using the Hub init command, which I've got over here.
00:34:40.534 - 00:35:36.374, Speaker C: You're going to choose a very clever username and you're going to enter your email and then what you're going to get is the tool is going to sit there and wait for a little bit and you're going to get an email and there'll be a link in it that you can click to authorize. Now I've already initialized an account but I can log back in, so I'll do that. And you should see something similar to this if you're calling hub in it right now. And then you'll get an email. And I've got an email right in front of me, but I'm not going to show you my inbox. And I will click a link in that email and you should get this beautiful, starry eyed smiley face. And then you should see that your email has been confirmed and you're now logged in.
00:35:36.374 - 00:36:15.720, Speaker C: And so hopefully something like that happens for you as well. I can't believe that just worked live. It was almost guaranteed not to work. Email came through so that's great. So you can go ahead and do as the little smiley face says and close that and you're logged in. And like I said, you can log in again anytime you need to and you can always check to see who you are to see if you've got a valid hub session going by typing hub, who am I? And so if you forget what's going on or you aren't sure if you're still logged in or something like that, you can always check that. So there you go.
00:36:15.720 - 00:37:08.622, Speaker C: All right, so that's pretty cool. You basically now have a developer account on textile's Hub and now you can start to do a bunch of cool things like create developer tokens and developer keys that you can use in your apps to actually interact with the hub, so to allow your users to interact with the hub. And so we're going to jump into that today. But there's a bunch of other tools that Andrew's going to mention, a few of them in his demo later that uses some Hub tooling as well. But anyway, we're going to jump straight down to creating some keys. Now for development, you effectively have four different ways that you can interact with the Hub using developer keys. We have two different main types of keys which are account keys and user group keys.
00:37:08.622 - 00:38:02.840, Speaker C: You can see over here in the gist that I mentioned them and there's a little blurb about that. You can also check out our docs online where it's pretty extensively covered what these keys are used for. So take a look at that documentation. The keys are pretty similar to standard web, two developer key tokens where you've got like a public component and a private component and you don't want to share the private component with your app. Pretty standard stuff there. But there are a few interesting quirks that you need to consider when you're building quasi trustless apps for decentralized web because effectively what you're doing is you're using the Hub resources or your users are using your Hub resources on your behalf. So you need some way to say like, yeah, it's okay that this particular user is going to use my Hub credentials and that's what the user group keys are for.
00:38:02.840 - 00:38:29.760, Speaker C: So like many keys, there's a public secret component. You never want to share the secret component. And what you can do to simplify things when you're developing is you can create an insecure key. And basically this insecure key only has a public component. There's no secret component. And so you can create one of these keys. As a developer, you can actually embed that key in your app as you're developing it, you can share it with your team.
00:38:29.760 - 00:39:24.254, Speaker C: Makes it a lot easier to essentially take advantage of Hub infrastructure without having to have an authentication flow all hooked up and ready to go. And then when you're ready, you can switch over to a production flow where you actually have a full authentication flow. And the docs online actually there's a whole entry on, okay, now you're ready to upgrade to production. How do you do that? So I highly recommend, especially for the hackers in the crowd, that you start by creating some insecure keys and then obviously don't just post that stuff on the Internet because it means that people can use your Hub credentials without authenticating. But it'll be great for collaborating as teams. So that's what we've enabled this just recently and I think it's going to be a really great way to bootstrap your apps. So with that in mind, let's generate some.
00:39:24.254 - 00:40:13.006, Speaker C: Let's see how easy it is to generate some keys. So I'm just going to call Hub keys and if you do that and you say Hub keys help or just Hub Keys Oops, it tells you what you can do here. You can list some and I've already created some, or you can create new ones. Hub keys create and then it will ask you a couple of questions. First question it's going to ask you is, do you want to create an account key or a user group key? An account key provides access to your developer account. So you do not want to use that in an app, right? You don't want your users to have access to your developer account. So you're going to want to use a user group key.
00:40:13.006 - 00:41:05.726, Speaker C: And we call them user group keys because they're effectively like keys for a group of users using your app. And then you get this question, do you want to require signature authorization in a production app? You would say yes. And then you'd have to use the Auth flow to essentially authenticate a user before allowing them to use your hub credentials. But for development and that sort of thing, if you hit no, which is not the default, and hit Enter, then we sort of say, no, you don't need to reject that, we don't need to require that. And you get this little printout. So now we have it's going to generate a secret anyway, but it's just not going to worry about it when you actually access the APIs. So we've got this new I got this super cool key that starts with Bcjam.
00:41:05.726 - 00:41:33.580, Speaker C: That worked out great. And we can use that in our apps. Okay, so we got that. That's great. So the next thing we want to do is we've got an account on the hub, we've got our Token that we need to access. Might as well start building an app. So what we're going to do is normally you would want to create a new react app or view JS or whatever your favorite framework is.
00:41:33.580 - 00:42:16.630, Speaker C: And we recommend using TypeScript because who doesn't want type safety? But also with Textile, we release everything with full TypeScript types. So if any APIs change or anything like that, you're going to catch that before anything happens. And it's like a lot of Web Three projects. It's fast moving, so it's not a bad idea to keep an eye out for API changes. We try very hard to be Semver compliant, but things sneak in. We're all cowboys around here, so sometimes it's good to have those types anyway. So you can bootstrap an app from nothing.
00:42:16.630 - 00:43:04.866, Speaker C: And that's what I'll touch on a little bit tomorrow during our office hours. But for today, we're just going to git clone an existing app. Okay, so I am perfect. I'm just going to CD. I think I have a demos folder. And so I am going to I want to do this with you live, so I'm going to just get rid of my existing JS demos folder. So let's go ahead and clone that CD into JS examples.
00:43:04.866 - 00:43:26.480, Speaker C: And I want us to play around with this Bucket photo gallery app. So go ahead and CD into there as well. And this is a node. JS app. It was bootstrapped using create react app Andrew did it. So all of the mistakes in there are his fault. And you can just NPM install that right now.
00:43:26.480 - 00:43:58.614, Speaker C: And as we download all the money off of your computer, just sit back and watch. Just kidding. It's just installing the Web app so you can deploy that and we'll be good to go. No more jokes. It's too many jokes. Okay, so while that's downloading and installing all of those NPM modules that we need, we can kind of focus on the anatomy of the app that we're going to play around with. So there's a few key points that I want to cover, and I'm going to do it live during the session, and I'll just open up a text editor and we can play around with it.
00:43:58.614 - 00:44:53.498, Speaker C: But the two main things you need for any textile app are your Hub credentials, which we've kind of already covered, and an identity for your users so that they can take advantage of those Hub credentials. So we already talked about the Hub credentials a little bit, but I'm going to briefly outline how they're used in the app in a second here. And apologies if you can hear a tiny dog barking in the background. His name is Lucas, and that's all you need to know. Okay, so I'm going to open up Codium, which, by the way, is a fun open source version of Vs code, which I can highly recommend. Anyway, here it is. So it'll look very familiar to you, but it's actually the open source release of Vs code.
00:44:53.498 - 00:45:31.286, Speaker C: So if you can see this, hopefully that's big enough for everybody. We've just got a pretty bog standard React app here. So everything was bootstrapped using Create React app with the TypeScript flag on it. And the main thing in here you want to look at is the App TSX file here. And Andrew has set it up so that essentially everything is kind of in here and linear. It may not be the way that you would design an app, but it's a great pedagogical tool. So that's how we're going to kind of look through it here.
00:45:31.286 - 00:46:12.834, Speaker C: Almost everything, all the logic is actually in the App TSX file. And so you can play around with that and take a look. And we've got a couple of nice UI things in here. But the main libraries that you're going to use for any textile app and the way that you're going to want to access things is using the At Textile Hub library. And tomorrow I'll have a little script. It's like a bootstrapping script, essentially, for starting from scratch with the Create React app. But these are the two textile libraries that you're probably going to end up importing in any textile threads buckets based project.
00:46:12.834 - 00:46:43.630, Speaker C: So Textile Hub and Textile threads Core, and then the rest are just fun things to make it a little bit more easy to interact with the UI and render things. But the two things I wanted to point to you out. First things first. When we're developing and we've used the Insecure app keys, you can actually just embed that directly in your app. So let's just do that. It'll save us a bunch of hassle later, especially when we're interacting with team members and you're git checking things in and out. It's totally safe to share this.
00:46:43.630 - 00:47:14.440, Speaker C: You can revoke this key later. And it makes it easier for your teams to just kind of NPM run start an app. So there's one in here already, but what I'm going to do is I'm going to go back to my command line. And you know what? I totally flooded my screen, so I'll just list it again. Hub keys list. And I'm going to use my BC jam key here. So I'm just going to copy that and paste it in here.
00:47:14.440 - 00:47:47.090, Speaker C: All right, now I'm good to go. That's pretty much all I needed to do to get my Hub credentials working in my Web app. In fact, you can already fire this app up. I'm just going to use the terminal that's embedded in my text editor here. NPM run start. Load this up. It's going live.
00:47:47.090 - 00:48:09.180, Speaker C: Let's see if it works. It oh, it's still starting to development. Server building things. It's the first time running. There we go. Boom. Okay, so that already works and it's using your developer credentials on the Hub already.
00:48:09.180 - 00:48:37.650, Speaker C: Andrew has already got this beautiful app, arguably all bootstrapped up and ready to go. And there's a couple of fun things here, but I want to point out some kind of critical underlying pieces. So that's the first thing you got to specify your key. All right? And that's specified in what we call a key info object. Here's the type information for it. It's the key and the secret. The secret is optional because we're using Insecure keys.
00:48:37.650 - 00:49:17.710, Speaker C: Okay? And this key info, if I copy, gets used in a bunch of places, including when we initialize our buckets clients. And actually that's pretty much it. Okay, now I'll touch on that in a second. The next thing that I mentioned we need if we go back to here, we need our Hub credentials. Okay, check. And then the next thing we need is our user's identity. We need some way to represent our users in our app so that we can effectively allocate resources to those users on the Hub.
00:49:17.710 - 00:50:02.970, Speaker C: So, oh, this should be like a little heading, but anyway so you need some concept of what a user is. If you remember from before, depending on how we set up our Hub credentials, you can essentially allocate resources on behalf of your users and the users. The concept of users is pretty generic. It's just something that can sign things, basically. So this is the flow that needs to happen in order to actually authenticate a user. Your user is going to attempt to sign in using their public key. Your app is going to create a challenge for them to authenticate with.
00:50:02.970 - 00:50:40.406, Speaker C: The user will then sign that challenge with the private key to generate the credentials and then the app uses those credentials to move on. So it's a sort of standard call and response, challenge based authentication scheme. Of course, all of this gets abstracted away from you as the developer so that you don't have to deal with all that stuff. But it's useful to know what's happening. So in our app here, we're just going to generate a random user identity. Nothing fancy. But in our documentation, which I encourage you to go read, there's a mention of you could do this with MetaMask, you could do this with a three box identity.
00:50:40.406 - 00:51:32.940, Speaker C: You can do other things. And we're going to be rolling out of examples with other identity providers as they come along or as fast as we can develop them. So if you don't want to create random ones, your users already have identities, you can take advantage of those and you can use those. All right, but let's just for the purposes of this demo, we're going to jump in and we're going to look for this function called Get Identity. So we're going to create a new identity when the app loads and we're going to call this function called Get Identity. And it's pretty straightforward, it's pretty simple. And Andrew in this example has also baked in some local storage caching so that your users don't have know create a new random identity every time.
00:51:32.940 - 00:52:07.006, Speaker C: But here, I'll just pull this down. So this is what we're going to do. We're going to create a random identity based on the Lib P two P JS crypto library. It's just a sort of fairly generic implementation of a public private key infrastructure PKI setup. All right? So first we're going to try to pull the identity from local storage. And if we find it, we'll just generate one from the string and we're good to go. Whether or not this is how you want us cache user identities or not is totally up to you.
00:52:07.006 - 00:53:00.326, Speaker C: But this is one way you could do it. If they don't have one already, we'll just create a random one, we'll convert it to a string, we'll add it to local storage, and then we'll just return that identity. So this is just a random private key, basically. Now you can imagine the same thing if they've already got MetaMask installed and you use the Web Three extension, then you can use the sign function there to do any signing that you have to do. It's sometimes a pain in the butt if your app is going to be generating tons of data to have to sign every piece. But if it's something really secure and important that you want the user to be aware of every time, then great. Otherwise you may want to use an identity provider which essentially you could use to sign one key at the start of the session and then use that key multiple times.
00:53:00.326 - 00:53:47.206, Speaker C: And then that identity provider could revoke permission to use that key later if they wanted to. There's lots of different ways. Anyway, that's basically what we needed. We needed our Hub authentication and we needed an identity for our user. And now we're pretty much good to go in terms of interacting with Hub infrastructure and APIs. And I'm almost out of time and I do want to leave some time for Andrew to give a mind bending demo. So just one last thing that I wanted to highlight is once we've got the identity and we've got those Hub authentication keys, then in order to create a Bucket client, so a client that allows us to interact with the Buckets API, for example, here is what we have to do.
00:53:47.206 - 00:54:51.910, Speaker C: So this key info, that's our key info that we specified with our developer key, and you just call this static method Buckets with key info and Blammo, you have a Bucket client that is ready to interact with the APIs. Then what you want to do is you want to associate this bucket client session with a particular user. So you call Buckets, Get Token, and you pass in that user identity blammo, now you're good to go. All of your Bucket interactions with the Hub are now scoped to that user. And this get token actually does that. It abstracts away that signing challenge handshake. But for the paranoid in the crowd, you could alternatively use our I don't want to type it out because I'll probably get the API call wrong, but check out the docs.
00:54:51.910 - 00:55:51.130, Speaker C: You can also call Get Token challenge and it will use a callback based framework so that you don't have to feel like you're passing your user's keys off to some API, which you're not. But at least with the callback you can physically see that you're not as well. And a good example of why you might want to do that is the MetaMask based key signing where you would just call out to the Web Three provider in your callback to do the signing step. So multiple ways to do that, mostly abstracted away to make it easy just to use your key info, get a token for your users, and then blast away on the APIs. And in this case, we're just initializing a new bucket and then we're off to the races. So I encourage you to download that, get it started. I want to just show you really quickly that we have this react app going.
00:55:51.130 - 00:56:30.394, Speaker C: It's created a random identity for me and it even created a cool pretend little icon for me here. And now, let's see, I'm going to see if I can find a nice file that I can share with everybody. Okay, here is my background. This background image that I have, which is a background image of an office space. Drag and drop that onto the app here. And let go. And it was a fairly large image, but there you go.
00:56:30.394 - 00:57:02.382, Speaker C: So what happened in the background is the Hub was used to upload this photo to a bucket. It was added to this gallery here. That's scoped fully to me, the user, and it's created this brand new bucket. In the background, there's a couple of really cool things I want to highlight. Here one, this is also an IPNs address. If I click on IPNs and I look at this URL, there's the bucket ID right there. IPNs Hub.
00:57:02.382 - 00:57:41.600, Speaker C: Textile. We have a textile. The Textile Hub is running a gateway there that renders IPNs links. But you could similarly access this, though, over any of the IPFS gateways. And what you see is you've got this folder, and the app has automatically added a bunch of things to it, including some different sized images so that your app can take advantage of, like thumbnails and full size ones and blah, blah, blah. It also has the index HTML, which, if I click on it, will render this as a website that's all over IPNs. That's pretty cool.
00:57:41.600 - 00:58:11.194, Speaker C: If I go back to the app, click on this, that something didn't work there. So let's just move on. And I can also click on this bucket link, and it actually takes me to the raw bucket folder that also has a default rendering mode. Oh, there it goes. Works now. And then I can add more folders and blah, blah. It's all very fun.
00:58:11.194 - 00:58:42.606, Speaker C: And it's a folder on IPFS. I don't know how to stress the coolness of the dynamic IPNs folders, except it's very cool and you should check it out. All right, so without further ado, please do jump in and play around with this app. Break it, fix it, ask us questions on our Slack. And I really hope that you all do great. You can't all win, but we can win some stuff. And don't forget that Textile has some bounties.
00:58:42.606 - 00:59:12.720, Speaker C: Everybody has. There's lots of bounties. And even adding something like this to your hack flow would put you in the running for some of those. You know, check them out, and don't forget to try some of those. So let's get back to our presentation, which is oh, yes. Demo by Andrew. So, Andrew, are you ready to blow everybody's mind?
00:59:14.770 - 00:59:18.110, Speaker A: We'll start a notch down from that and see what happens.
00:59:18.260 - 00:59:24.980, Speaker C: Okay. All right. Yeah. I will relinquish my screen sharing to you.
00:59:25.510 - 00:59:25.970, Speaker A: Cool.
00:59:26.040 - 00:59:27.140, Speaker C: Let's take it away.
00:59:27.910 - 01:00:18.206, Speaker A: Okay, cool. So I'm going to move pretty quick. I think this should take less than ten minutes. Thanks for sticking around. I'm going to show you something really cool that we are preparing just for Hackers this month, which is linking you might have seen my workshop last week and some of the things we've been talking about with the Powergate and making it easy for you to build things on top of Filecoin. The Textile Hub is one of the first users of Powergate, and so we're integrating it behind the scenes on the Textile Hub so that it manages this pinning for you. So when you push buckets to the Textile Hub to persist them on IPFS, when people close their browser or put their phone away, we can keep them persisted there for you.
01:00:18.206 - 01:01:03.870, Speaker A: So by putting the Power gate there, that means that we can also let you push things to Filecoin. And so that's what we want to give you this month is kind of a few different ways that you can get to Filecoin depending on what you're building and what is easiest. We have Powergate, the full open source stack. We definitely recommend you go try that and run it and see if you just want to run that thing and use that as a resource for your app. We have offered for teams, we have hosted Powergate instances. So if you need the full Powergate API, but don't necessarily have the machinery to keep a node connected to testnet, this could be a really good resource for you. I should mention in that first one, we have the local net so you can do things really fast without having to sync the whole network.
01:01:03.870 - 01:01:55.102, Speaker A: But we also have these managed instances which we're working to get teams onboarded to now. So if you end up building with the Powergate and really need that get in touch, it's got some restrictions to it, but should be really useful. And then now I want to show you the third option, which is to use basically an experimental version of the Textile Hub that already has the Powergate enabled behind the scenes and will let you fire off these archive commands on your buckets. And every time you fire off an archive command, it will create a new deal behind the scenes to move that bucket and the contents of that bucket to Filecoin. So let me just show you a little bit about that really quick. I'm just going to blast through this so you get a sense. We'll do our best to get details about this out this week to you.
01:01:55.102 - 01:02:41.470, Speaker A: We're shooting for tomorrow, but we may actually also just wait until the staking is complete and we know everybody that's taking part in the hackathon and then get the details to you on how to use this. But the idea is simple. Basically, you're going to use everything that Carson already showed you today. So you could use the Hub's command line tool, but instead of just creating the buckets and ending there, you can also run these Archive commands on buckets. Additionally the same, if you use this experimental version of the Hub, you can also connect all these JavaScript libraries to it and use it the exact same way. But now you'll get an additional set of commands on buckets that let you create archives so that. Means start pushing them to filecoin.
01:02:41.470 - 01:03:30.650, Speaker A: That can take time or that will take time to create deals on the testnet and confirm those deals and get all the information back. So there's these other commands to monitor the status of that deal, give feedback to your users and all that good stuff. And this came up in the Zoom chat a little bit about the Hub being some centralized services around the decentralized network. And at Textile, we're pretty strong believers that services are going to exist for a long time. But what we need to do is move services to sort of a better idea of what the Internet is. And one key component of that is to make services that don't have lock in for you and your data and your users. Data and buckets connected with Filecoin is one of the ideas that we have to help you keep from getting locked into our APIs.
01:03:30.650 - 01:04:24.542, Speaker A: So you can push buckets, for example, to Filecoin, leave Textile, never come back again, and go get that data directly from the Filecoin network. And Ignacio on our team put together a really cool little video demo for a technical post he wrote the other week. And so definitely go review the technical post. It gives some great details on buckets in general, but then the video will show you what I mean by pushing a bucket to a service like the Hub, but then also creating a deal on Filecoin so you can leave the Hub if you never want to come back. Okay, so these are just some warnings about using this experimental service. So when we share this with you, when we make it available to everybody, these warnings will stand true. It's basically we're building this stuff on testnet, and testnet may reset, or we may have issues with what we've built over the next month.
01:04:24.542 - 01:05:12.880, Speaker A: So this service isn't meant to be a stable service at all. It's really meant for you hackers to go and try to build and try the newest stuff with us. Everything Carson already showed you with the account setup will be the exact same, but we're going to give you a URL that you'll connect your instance to instead. And that's what we're calling the Next Hub. And so before you did Hub in it to create an account and you verified your email, you're going to do Hub in it against this new endpoint, and then everything else will work exactly the same as it did in the tutorial today. So let me just show you what this looks like. Let me blast this.
01:05:12.880 - 01:05:40.770, Speaker A: So let me create this bucket. Actually, I'll just show you. It just has an image in here and a file. I think this was from the previous workshop that I gave, actually. So if I do Hubbuck in it, I can do all the same things as before. So a lot of people have asked this. Like what? It would be a good flow for encrypting data before it goes to filecoin.
01:05:40.770 - 01:06:21.670, Speaker A: That's one thing that buckets has in it already is so I can just go ahead and say I want this to be an encrypted bucket and then all the same things again. So let me go ahead and toss this into a thread and I'll get all the links I did before. If you haven't seen this before, this is also pretty interesting to check out is the links when you have an archived bucket so that you can see that this data is encrypted. So it's still on the IPFS network, but you won't be able to see the contents unless you have the key. All right, so I've created my bucket. I'm going to hit this problem right now. Well, first, actually, let me push these files.
01:06:21.670 - 01:07:12.838, Speaker A: So now I basically added these files to the bucket and pushed them to a remote node for persistence on the IPFS network. So if you've paid attention to the Powergate architecture, they're now in the hot layer, essentially, so they exist on IPFS. Now I want to issue a command that tells the Powergate to move them or keep them on the hot layer, actually, but create a deal, archive them on filecoin. And so the really cool thing about this experimental endpoint is since it's running on testnet, you're going to get a bunch of free fake filecoin. And so every time you create a bucket, that bucket actually has its own wallet address on the network with its own balance and everything. But during testnet, you're not going to have to worry about that too much. The Powergate is going to auto fund that for you so that you can start creating deals and testing this out.
01:07:12.838 - 01:07:48.722, Speaker A: There's a little caveat here, and that's why I'm talking so much, is that funding takes a moment. So I just created this bucket for the first time, and it's going through transferring funding to the wallet address for this bucket. So that can take about 30 seconds. But as long as that's done now, I should be able to go and issue an archive command. So it's going to give me another warning just to make sure I'm aware that this data, even though I'm archiving it and I'm doing it on filecoin, we're still only on testnet. And so this data will actually disappear. Whether it disappears in the next couple of weeks, it doesn't matter.
01:07:48.722 - 01:08:31.278, Speaker A: At the end of testnet, whenever they reset testnet before mainnet, it's going to go away. So don't build anything production here. But if I go ahead and archive that, it's going to add it to the deal queue on the Powergate and start trying to create some deals for this. So this takes a while, but you can check in on it and see the status of it. And so if you made it to the Powergate presentation last week, you would have seen a lot of this stuff already. But here I'm just checking on the status of archiving my bucket, and you can see that again if you followed that presentation at all. I'm pushing a new configuration to the power gate that defines how many deals I want to create for it.
01:08:31.278 - 01:09:06.854, Speaker A: And now it's going and trying to create different deals with different miners. Here's a miner that's asking for way too much money so we can't afford it. And I think that's what's happening there. But a bunch of other miners that it's starting to negotiate the deal with, and it's going to figure out where it can store it. If I come back and check on this later, I should see a bunch of these deals closing and I can get the deal information about this archive, which is really sweet. And so once you have that, you can go and do anything with that deal. Since this is running on the real testnet, you can go check other services, look at the information about this deal, see what's happening on the network.
01:09:06.854 - 01:09:34.900, Speaker A: So that's pretty cool and a good resource. Another cool thing is you can also recover this data later so I could do Hubbuck in it, and if I pass the e flag, I can pull it back out of the network. And so I forget what I called that one. I guess I called all my experiments the same, but doesn't matter. It will just go and pull the data back down. I think actually I pulled the wrong one. Let me try that again.
01:09:34.900 - 01:10:10.110, Speaker A: It let's try this one. Yeah, there we go. Okay, so I can just go and pull that data back out of the network. And so this should help you get kind of that full flow of data moving through IPFS, moving through Filecoin in like, a matter of seconds. And so if you're interested in using this, just let us know. We're going to get details out about it as soon as possible here. And hopefully all this stuff is exciting and got you inspired to build some stuff on buckets or threads, but definitely on IPFS and filecoin.
01:10:10.110 - 01:10:21.860, Speaker A: Cool. Carson, do we have any questions before we wrap it up?
01:10:25.370 - 01:10:31.320, Speaker C: Yeah, we do have some questions, but I think Aaron managed to answer them already.
01:10:32.170 - 01:10:32.920, Speaker A: Cool.
01:10:34.010 - 01:10:50.960, Speaker B: We had some people in the YouTube chat asking about what was it comparison between threadsdb and Orbitdb, and I thought I had linked them to something, but maybe I grabbed the wrong link. Do you guys want to just go over that verbally or drop a link and I can pass that along?
01:10:52.450 - 01:11:49.840, Speaker C: Yeah, we get that question pretty frequently. I think it's just better. But no, there's a lot of differences, right? And a lot of similarities. And in fact, we are pretty confident that they could be interoperable over the longer term, depending on if someone wants to write a custom codec for textile or threads, DB that speaks the update types that Orbitdb generates. So you might think of Threadsdb as more as like a more generic implementation of a append only log based database. But there are a couple of pretty key differences. Some of them, like at the technical level, that allow threadsdb to handle different types of data.
01:11:49.840 - 01:12:42.754, Speaker C: So, for instance, Threaddb is based on every writer to the database has their own log. So we have this concept of single writer logs. What this buys us, among other things, is a bit more fault tolerant in terms of if you don't receive certain updates for the database over the peer to peer network, that's okay. It also buys us the ability to defer conflict resolution until such a point that the data is actually rendered on the client. That means that you can do things like custom codecs for managing different data and things like that. And some of these concepts are covered in our white paper for those who really care about those nitty gritty details. A couple other features of Threaddb include just some of the APIs that are available.
01:12:42.754 - 01:13:56.962, Speaker C: So like the push and pull based syncing across peers. So instead of using Pub sub, while PubSub is available as one medium for sharing and syncing data, peers can also call gRPC calls directly on one another to pull and push data. And so in a collaborative environment, that means that my peers, if they're online, are always getting direct pushes, and if they're offline and come back online, they can do direct polls and a few sort of features like that. It's designed to be offline first, so syncing can happen in the background. That's a feature that Orbitdb also supports. So there are a lot of similarities, a lot of differences, and a lot of the differences are sort of low level optimizations things that we learned having come from a mobile first and browser driven environment. When building threads, we should probably put together a sort of document that outlines that more clearly over the longer term in our documentation.
01:13:56.962 - 01:14:05.610, Speaker C: But yeah, in the interest of keeping it brief, I think that's a pretty good little snippet. I don't know if you had anything to add, Andrew.
01:14:06.110 - 01:14:17.120, Speaker A: That's really good. I shared the go threads. Repo has a table of some of the things that are unique, and I think you covered a lot of them and more. So that's great.
01:14:20.150 - 01:14:28.040, Speaker B: Awesome. Well, does anybody else in the chat have any lingering questions that they want to get answered while we've got everybody here?
01:14:31.450 - 01:15:25.206, Speaker A: I'd say one thing because in Zoom some people are asking about how Buckets encryption works. Buckets, the original implementation of Buckets is written in Go and has a lot of work behind what's happening with encryption and the use of the Dag to do syncing and state management. And it's definitely worth checking out, but we have a really good thread about that. And so this is for people watching on YouTube that don't see that conversation happening, but over on our sponsor channel in the filecoin Slack. There's a really good thread started earlier today asking some of the similar questions. And I think it would be really great place for people that are just interested in what are the mechanics behind there and how is key sharing and things. How are those working to go check that out and join that and ask any more questions you have? The price of the deal is determined right now.
01:15:25.206 - 01:16:19.062, Speaker A: It's determined by the powergate settings. I think that we'll do more work to let you configure that per bucket, but right now it's just early stage for that API. But if you go check out my workshop on the way the powergate works, every deal is attached to a config, and that config can make some decisions about what your max price is, what kind of miners you want to do a deal with. Right now, the buckets API that I showed that we'll give you is just going to use the default CID config, which you can go check in the documentations what that is. It'll just try to find you the best price with the fastest responding deals, deal makers and things like that. And it's actually doing I don't actually know the number of Replicas it's doing, but in that config, you can set how many times you want the file to be stored. And so it's doing replicated storage of that bucket just because we're on testnet and some miners are going to actually turn down deals midway through.
01:16:19.062 - 01:17:18.278, Speaker A: Things aren't complete there. So we kind of like cast it out to the network to a few different places to see who comes back the fastest and how many replicas we can get out there for you. Yeah, so we're kind of glossing over a lot of that stuff today just because sorry, the question is also, from what I understand, there are two markets, filecoin archiving plus retrieving. So, yeah, writing deals versus retrieving deals. How does the deal handle both at the same time? Well, they're just kind of fundamentally different things. So definitely go check out that workshop that I gave last week. It goes through the full flow of how the configuration file is used to structure that deal and then how that config is used to determine how your data is pulled back out of the cold layer.
01:17:18.278 - 01:17:36.340, Speaker A: So definitely check that out and then see what questions you still have left. So then there's a question. Are there any examples using React Native in that same repo that Carson showed? There's another folder in there that's for a React Native app. So the answer is yes, absolutely.
01:17:43.190 - 01:17:48.230, Speaker C: Yeah, I think that's good. Thanks for sticking through a little long with us, folks.
01:17:50.090 - 01:18:21.022, Speaker B: Yeah, let's see as we wrap up. Yeah, we got a clap from Jeremy as we wrap. Just a reminder, if you missed any of the other sessions, just check the ETH Global YouTube channel. We have all these recordings. And tomorrow we have four events, I believe. Let me see if I can go through them in the morning. Sorry.
01:18:21.022 - 01:18:48.440, Speaker B: The afternoon we have at 12:00 P.m., unstoppable Domains is giving their intro workshop. So if you're unfamiliar with that project or you want to learn more about it, go check out Unstoppable Domains. It's going to be a similar format to this, where they'll be just going over what the project is and some of the details to it. At 130 to three, we have a team formation workshop. How many people on the call? We had some people drop, but is anybody still looking for a team? Yes. No.
01:18:48.440 - 01:19:13.358, Speaker B: Maybe Karate is going to be solo, I feel going to be on his own. Yeah. All right. So if you do need a team or if you watch this video before tomorrow, make sure to jump into that. And there'll be just an open session where people can try and find other hackafest, people who are interested in working together. Definitely going to be a good session. And then in the afternoon Eastern, we have two more workshops.
01:19:13.358 - 01:20:09.422, Speaker B: The first is the Graph protocol going over there some of their details about their protocol and how you can actually integrate it into your hacks, as well as the final one for tomorrow is Juan Benet is going to be giving another in depth system overview for Filecoin. Definitely if you're not super familiar with the Filecoin ecosystem or some of the specifics on how the system works, I would highly recommend you check this out. He's going to be going over the concepts behind how Filecoin works, a ton of different topics, and then Q A, specifically if you want to build on Filecoin. So I'd highly recommend you check that out if you're new to this area. I think that's it. Definitely check out the schedule channel. We're going to be updating stuff as we get them scheduled and then sending out email links.
01:20:09.422 - 01:20:25.266, Speaker B: There's a fleek workshop on Thursday and then more after that. So it's packed. There's tons of content. I hope nobody is bored. I'm definitely not. I've got to go think of some more games for the beginning of these events. Thank you, everybody.
01:20:25.266 - 01:20:37.640, Speaker B: Carson and Andrew, really appreciate your time and sharing some of that knowledge. We'll see everybody in the slack if you have any questions and tomorrow for any of these sessions. See ya.
