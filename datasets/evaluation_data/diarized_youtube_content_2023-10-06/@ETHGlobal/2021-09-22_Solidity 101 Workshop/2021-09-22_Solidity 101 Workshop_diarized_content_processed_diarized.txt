00:00:00.090 - 00:00:19.338, Speaker A: Active workshop. I'll let Jeff take it away shortly. We encourage everyone to ask questions, check in. This is going to be a hands on kind of thing, so at that, I'll hand it off to Jeff. Wonderful. Thank you. Thank you very much, Andrew.
00:00:19.338 - 00:00:30.946, Speaker A: Hi, everybody. Good morning. Good afternoon. Good evening. I'm Jeff Wentworth, the co founder of a blockchain middleware company called Curvegrid. Here to do solidity 101. I do have some slides.
00:00:30.946 - 00:01:28.410, Speaker A: I was not going to go through them today at all and I wanted to make this highly interactive. So what I have up in front of me here is Remix. I'm going to spend about three minutes sort of giving a quick tour of this web application. And then I would love to encourage you to if you have a question or you've had run into issues during the hackathon thus far, when you're coding Solidity or something, you've always wondered about blockchain programming. Go ahead and you can either throw it into the chat while I'm doing my little intro, or you can unmute and ask it then. And we're going to use that as a starting point for a more in depth, basically dive into smart contracts. We're actually going to build one up and I'll show you how we can sort of do that from scratch.
00:01:28.410 - 00:02:23.766, Speaker A: This is remix. It's always going to end up tacking on these parameters at the end, but you can just go to remix Ethereum.org. And this has been around for quite some time and was sort of left to the side for a while in favor of some other tools. But then the Ethereum Foundation has come back to it and it really is quite a useful tool, whether you're a beginner, smart contract programmer, or very experienced. On the left side here, you've got a number of different left side tabs. When you first get in here, you may see nothing on the left side. And in that case, what you need to do is click one of the featured plugins, let's say Solidity.
00:02:23.766 - 00:03:05.154, Speaker A: This is solidity 101. The first tab is a file explorer and you'll notice a number of different files that are already here and you can always add more. The second one is the Solidity compiler tab, and it should default to the latest Solidity, which is 87. But you can choose any of the other versions in here and they're loaded dynamically. You can turn on autocompile if you have a fast enough computer, this can be very handy. I don't have it turned on at the moment, but we may do that later. And then the other tab here that's very helpful is actually deploy and run transactions.
00:03:05.154 - 00:03:48.246, Speaker A: And this is a complete blockchain right in your web browser. So this has the nice feature of doing everything in a JavaScript EVM VM, if you will. Ethereum virtual machine. You can also either use injected web3 this means basically MetaMask or similar web3 wallet or you can connect to a Web Three provider, right. If you're running Geth and you have actually like another endpoint here, you can specify it directly. We're going to stick to JavaScript VM. With the JavaScript VM, you get a bunch of fake wallets with fake Ether and you can set parameters here.
00:03:48.246 - 00:04:45.640, Speaker A: Once a contract is being compiled in the Solidity tab, then you can deploy it or you can link to it at an address here. So we don't have any contracts deployed at this point, so there's nothing we can do. What are these other tabs here? We have yeah, if you wanted to do there's some static analysis on your Solidity. There's some unit testing pieces which you can run here and plugin manager and here's all the different plugins you can add if you want, which can be super helpful. So that is a three minute tour of Remix, which we're going to spend some time in today. Have there been any questions in the chat? No, not so far. Does anybody want to unmute again, if you have a question or you're stuck in a particular spot with Solidity and want to know where to start? Anyone? This will be our starting point for where we kind of kick things off.
00:04:45.640 - 00:05:07.450, Speaker A: I will give it a minute. Less than a minute. None yet. But thanks for starting with Remix. Wonderful. Thank you, Derek. Okay, well, if you do think of something, please do unmute.
00:05:07.450 - 00:06:17.054, Speaker A: Otherwise what I'm going to do is actually flip back to the slides and I'm going to assume that I'm going to start fairly basic, but please do raise your hand if you do have any questions or speak up or unmute if you do have any questions. Or if you'd like me, go a little bit faster, slower. I'm going to skip through a bunch of these earlier slides and I want to talk a little bit about what smart contracts are first and then we're going to flip back to Remix and actually do some coding in there, right? Like basic, basic, solidity 101. So if you consider the blockchain right. We're going through this because I think this is an important mental model to have when you're programming, right? So the blockchain, I like to think of it as a decentralized ledger or a table or a spreadsheet. And if you consider, if you've ever taken, let's say counting 101, not Solidity 101, what might be a double entry bookkeeping ledger. So this is basically what the blockchain is.
00:06:17.054 - 00:07:09.598, Speaker A: What the Ethereum blockchain is where you have accounts, let's say Alice and Bob, and then you have two columns, one for Debit and one for credit. Right. So let's say -2000, Ether, from Alice and plus 2000 Ether to Bob. The point is that key point here is that these transactions are atomic on the ledger, which means either the entire thing happens or none of it happens. So if you've ever dealt with bank wire transfers, and you've sent money and the recipient didn't get it, or you've found money in your account that you didn't expect, which happens. That's not possible in blockchain, in the Ethereum blockchain, either the entire transaction happens or it doesn't. And that's what we mean by it being atomic transactions are grouped together in blocks and blocks are appended to the ledger.
00:07:09.598 - 00:08:14.200, Speaker A: So you can think of it as each transaction is happening in turn and essentially it's a giant table or a giant spreadsheet that's always growing downwards with time. What we mean by immutable is that you can never go back and erase something in the middle, right? So as the ledger is being appended to, you can always do potentially, let's say undo, but you'll always have a record of that, right? Nobody will ever be able to sort of cook the books, as it were, on you. Account names are actually very large numbers, right. So represented here in base 16. And if we come back to remix, you can see in the simulator, we have our accounts here. And if I was to open up MetaMask, you would see the accounts there as well. So these are 40 bit numbers, two to the power 40, so 20 hexadecimal characters and they represent the address, right, the public address of an account.
00:08:14.200 - 00:09:19.190, Speaker A: So the public key side of it, it's not the public key, it's a representation of the public key. Transactions can include computer code that will run on the blockchain. So in this case, we're invoking a function called remit with some parameters. So far in this series of examples, we've just been dealing with sending Ether back and forth, but now we're actually talking about including computer code that's going to run on the blockchain. So if we have Bob here, who's both receiving Ether but also is receiving a transaction or receiving this computer code to run on the blockchain, who or what is Bob this account number? Well, it turns out that accounts can also be smart contracts, can be computer code that runs on the blockchain. So, again, a smart contract is nothing more than computer code that runs on the blockchain. And so this is the function remit.
00:09:19.190 - 00:10:21.674, Speaker A: It's similar to functions in C, like programming languages. There's a name and there are parameters that get passed in optionally, there's return values and then there are, let's say, qualifiers here which tell you things or set different characteristics of the function. For example, is it public or is it private and internal? Which just means, can it be called externally? Can you send Ether to it or not? We're going to get back a little bit more into this. So, again, level set computer programs on the blockchain, also called smart contracts. They can hold and dispense value or Ether. They're governed by the rules of their computer code. And like any other transaction or any other credit or debit entry on the Ethereum ledger, they're immutable, they can be inspected or invoked by anyone who has access to the blockchain.
00:10:21.674 - 00:11:04.054, Speaker A: And this is a really key piece from a security perspective. So a minute ago I mentioned the fact that there's this thing called private functions. That doesn't mean that nobody can see them or access them. It simply means that from within the programming paradigm that they're not accessible outside of that smart contract. But you can still see the code and anybody with sufficient technical knowledge can access any of the data on the blockchain. And so we have to protect access to contracts through some other mechanism. They also cost gas to invoke, which is currently so sorry, I'm based in Tokyo, Japan.
00:11:04.054 - 00:11:56.910, Speaker A: Depending on your blockchain or layer two, it could be anywhere from, let's say ¥5 to ¥100,000, which is roughly five cents Canadian or American, and to $1,000 Canadian American. And then this limit on gas prevents runaway contracts. We're going to go into some of the details on each of these in a little bit, but these are sort of some of the key pieces. I want to talk for 1 second about DApps or decentralized applications. And probably most of you are building a DAP. You're not just building a smart contract in this Ethn online hackathon. You're building a complete decentralized application, which is a combination of traditional software that means web, front end, potentially a back end, maybe a database as well with one or more smart contracts running on the blockchain.
00:11:56.910 - 00:13:11.158, Speaker A: Now, I said maybe a database as well. When we're thinking about mental models around what a smart contract is and what the Ethereum blockchain is, many people say it's like a distributed database. That's true. But it's also like a distributed cloud compute system, right? Because we have these computer programs that are running on the blockchain. And one of the characteristics of distributed databases like a MongoDB or like the Ethereum blockchain or distributed compute clouds like, let's say AWS or like the Ethereum blockchain, is that they have to make a trade off between I'm going to get this wrong. What's the triangle cap? Consistency, availability, and is it performance? But the key piece there is with consistency, the trade off that Ethereum makes is that it will be eventually consistent, right? That it's not guaranteeing that when you send your transaction and it gets included into the blockchain that the first time it gets included into the blockchain. The first time your computer code runs is the only time it's going to run.
00:13:11.158 - 00:13:40.030, Speaker A: The effects of it may get undone in what's called a chain reorganization and then redone later or may never happen. And that's one of the issues around the practical aspects of blockchain programming. So that's it for the slides. I see a note in the chat, partition tolerance. Thank you. Thank you. Partition tolerance, consistency, availability, and partition tolerance, aka forking.
00:13:40.030 - 00:14:47.282, Speaker A: Any questions at this time before I flip back to remix? You can put it in the chat or you can just unmute yourself if you feel comfortable doing that. Okay, great. Okay, absent any questions or direction on what to do, we are going to start from first principles and create a brand new smart contract and we're going to see if we can get it to compile and then we're going to interact with it because why not? So what you do in Remix is you come in here and it should have a default workspace already created. You can also create new workspaces if you want by clicking this plus icon here or rename it or delete it. You can upload files sorry, create new folders, publish it to GitHub, load a local file or create a new file. And that's what we're going to do inside the Contracts folder. So I think you need to click the Contracts folder first.
00:14:47.282 - 00:16:09.834, Speaker A: We're going to get a new file and we're going to call it Solidity 101 Sol and it's going to open up here. Generally the first line in any Solidity smart contract is the Pragma line, pragma Solidity, and then you have to give it a okay, so what does Pragma mean I should back up? Pragma is an instruction to the compiler about something. Pragma solidity means hey, Mr. Solsi solidity compiler or hey solsi solidity compiler. I'm going to tell you what versions I support. Now you can do something like zero, zero, I can't remember what this is like that I think would say like any possible Solidity version, but that's not very good because Solidity has gone through a number of where are we here? Solidity has gone through a number of transformational changes since the first version that's in here, zero one, one, even within, I would call the first one major, minor and then point release. Right, sorry, again, I can't remember what you would typically call this third one, but essentially Solidity at this point.
00:16:09.834 - 00:17:06.480, Speaker A: Anyway, we're not yet at the version 10 because it's been undergoing so many changes. So really this is like major and minor, but even within the major, even within the zero one or zero five, we see breaking changes to the language. And one of the challenges when you're reading stack overflow or looking at other code is that if you're not using the exact Solidity compiler version, things may not work. That's challenge number one. Challenge number two is when you're trying to combine different contracts, like you're trying to import another contract into yours and it's using a different Solidity compiler version. If you're just using the straight Solidity compiler at the command line or even Remix or Truffle as far as I'm aware at this point, sometimes it won't compile and you will need to update one or more contracts to the desired version. Hard hat, which is another.
00:17:06.480 - 00:17:45.114, Speaker A: So Truffle is sort of like your NPM, it actually is built on NPM, but it's kind of like your version manager, compiler build manager for one of them for Solidity. Hard Hat is another one which is created by a different organization, consensus versus Nomic Labs. Hard Hat does support compiling multiple versions or different versions of Solidity patch. Perfect. Thank you, Andrew and Tom. I'm just checking if people are paying attention. Major minor Patch is the third one, but really, I would say Solidity shifts everything to the right.
00:17:45.114 - 00:18:36.060, Speaker A: We're going to use the latest one because why not? It's more efficient. There's some more fun features in it, but I would say that 0706 are popular as well. So Pragma Solidity not tilled Carrot little Hat symbol, and then zero 80. What this is saying is anything within the zero eight family is acceptable. I can also lock it to a particular version by doing, let's say, pragmas zero eight seven, but let's leave it at zero 80, which just gives us more flexibility. Okay, so Pragma solidity contract. Solidity 101.
00:18:36.060 - 00:18:51.490, Speaker A: Open squiggly bracket. Close squiggly bracket. All right, let's see if this compiles minimal solidity 101. Compile solidity 101. There we go. It's compiled. Warning SPDX license Identifier not provided in source file.
00:18:51.490 - 00:19:35.070, Speaker A: We will see this SPDX license Identifier just means, like, what is the open source or closed source status of this? So let's see if we can make quiet this SPDX license license license Identifier. Sorry, I couldn't copy and paste that MIT. Compile. There we go. We have soothed the linter and made it quiet. Absolutely 100% minimal smart contract here. Let's try to deploy it in remix sorry.
00:19:35.070 - 00:20:26.302, Speaker A: Within this JavaScript VM. So we're going to use our base account here, and we're going to pick our contract, Solidity 101. We're going to then click deploy and boom, it's been deployed. So you'll see in the lower right here, this is sort of our transaction log. And if I expand that scroll down, you can see that we have indeed with this transaction hash from this address, which is my address up here, my B three, with a gas limit of 80 million gas, which actually contradicts our gas limit here, but that's actually good. 3 million is very low. Within, I think, main net Ethereum, the base gas limit is something like 15 million.
00:20:26.302 - 00:21:11.386, Speaker A: Now, for some reason, remix the limit is still 3 million. If you get an out of gas error, either on contract deployment or on your contract interactions, consider increasing this gas limit to something more reasonable, like 15 million. That's just a tip. It's taken 67,000 gas to deploy. Now, gas, again, is not Ether. It is unitless measure of how much essentially like a cost with how much a smart contract interaction took. There is a limit on gas on both write transactions and read transactions.
00:21:11.386 - 00:22:13.410, Speaker A: But you don't actually pay any money when you're reading from the blockchain, only when you're writing to the blockchain. What happens when we compile solidity is our code here gets compiled down into bytecode zeros and ones and then sent to the blockchain. Right? That's what we've done when we deployed it. And then when it's executed, either in a deployment because there is an execution that goes along with deployment, or subsequently, every opcode that gets executed has its own gas cost. Storing data on the blockchain with an Opcode like S load costs a lot more money than just doing an addition. The EVM, the Ethereum virtual machine, when it's executing your smart contract, keeps track of the cost of each Opcode. And when you exceed your gas limit that either you have provided as part of the transaction or that is the gas limit of that block, which again on Ethereum main net now is something like 15 million.
00:22:13.410 - 00:22:55.966, Speaker A: I believe your contract will return with an error out of gas, transaction aborted and everything gets undone. So this is another key constraint of solidity programming. We need to fit everything within at least the block gas limit. And if you are hitting the block gas limit on Ethereum main net you're going to be paying something like two Ether in costs, which is what, like $8,000 now. So this is also where we start to talk about being very efficient with solidity programming. For read functions, it doesn't matter. We can spend as much gas as we want up to that 15 million.
00:22:55.966 - 00:23:31.110, Speaker A: But for write functions we have to think about being efficient with them or use a different blockchain and or use a different blockchain that is cheaper. So remember how I said that gas is unitless? That's true. There's also a gas to Ether exchange rate which fluctuates. So here's gasnow.org. This is for Ethereum Mainnet. This tells you the current basically exchange rate and the gas price. You have to set a gas price when you send a transaction.
00:23:31.110 - 00:24:01.006, Speaker A: It's not here at all because this is just fake money. But basically the miners will bid on will not bid. You are essentially bidding for inclusion in a block. Right. So the way to think about it again, like mental programming model, when you use a cloud computing service like Amazon AWS, you are charged at the end of every month. Well, first of all, if you're on the free plan, you don't get charged anything. But there is no free plan with Ethereum except on the test networks.
00:24:01.006 - 00:24:50.222, Speaker A: That is the free plan, I suppose. But let's say on AWS, Amazon Web Services or Google Compute Cloud or Microsoft Azure, you're charged on your credit card at the end of each month for what you have used in Ethereum. You are charged immediately when you submit the transaction. And it's not a fixed charge, it's a variable charge. You're essentially bidding for compute and storage time on the Ethereum blockchain. This is completely different than what most of us have done in the past. But this is essentially decentralization, right? And you think, oh my gosh, how do I manage this as a programmer? Well, most of the time you don't need to worry about it because your users are the ones that are going to be paying when they mint an NFT, they call your function to Mint or claim an NFT or to interact with your contract.
00:24:50.222 - 00:25:52.646, Speaker A: They're the ones that are going to be paying for it with cash on the table, not credit card at the end of the month. Hello? Question from Gabriel. Is there a way to know before a transaction is done the gas price it would cost? So when you submit a transaction, whether it's through the MetaMask or another web, three wallet in the browser, or if you're submitting it manually through a blockchain node, it will estimate it uses what's called a gas price oracle to give you what it thinks is a reasonable price to get it done in a certain amount of time. So let me go into here, StarMO BSD Mainnet. But let's go to Ethereum Mainnet. Let's go to this account here, and you can see that. Can we do an easy contract interaction? No, actually not at the moment.
00:25:52.646 - 00:26:28.980, Speaker A: But what happens when let's go to like, uniswap. So this is a DAP, right? Uniswap is adapt. And let's say, okay, so I have my Ethereum account connected here. Let's do like one I want to swap one Ether for one die. It's probably going to be smart enough and say, like, insufficient ETH balance. But if I had sufficient ETH balance when I clicked swap here, it would pop up and it would give me essentially a gas price. It would quote it to me and I can adjust that up or down.
00:26:28.980 - 00:26:58.010, Speaker A: There's a great website. What is it? F Bus. Ethereum Bus transactions. Here we go. Ethereum transaction visualizer. So this is a lot of animation, so I'm not actually going to load it, but essentially this shows you what happens for all the transactions that are waiting as they get on the buses. The people are transactions, the buses are blocks.
00:26:58.010 - 00:27:34.854, Speaker A: So I'm going to drop that link in the chat and that's a good visualization of how transactions work with gas prices, if you will. Okay, where are we here? Okay, so how are we doing in time? We're good. Again, shout your questions out unmute or put them in the chat if you want. So we have deployed our contract with 67,000 gas on our test blockchain. And woohoo. There we go. So if we go back to the left hand side, we click the deploy button.
00:27:34.854 - 00:28:24.006, Speaker A: We had our contract selected and we can see our deployed contract here and wonderful. What can we do with it? Well, actually not a whole lot because there's no functions in it yet. So the most that we can do is pass in some what's called manual call data, some bytes and click transact. Basically, nothing's going to happen if we try to do that. So I'm going to do, let's say zero one, and if I click transact, it's going to fail because I don't even have what's called a fallback function defined. So people can send data to your smart contract even if you don't have any functions defined. If you have a function called the fallback function, like the default function defined, then it will run when they do that.
00:28:24.006 - 00:29:01.634, Speaker A: But basically we can't do a whole lot here. So let's create a smart contract. Why don't we create an NFT? Because it's pretty topical and fun. So an NFT, non fungible token. These are unique serial numbered items. So it could be like smartphones, it could be cars, it could be artwork or collectibles. This one collectible is different from that.
00:29:01.634 - 00:29:30.190, Speaker A: This other collectible over here, as opposed to fungible items, which would be like money or bolts in a box in a warehouse. One bolt is the same as another bolt. There's no serial numbers on it. Non fungible tokens. NFTs obviously very topical right now. So the first thing that we need is we need some way to keep track of the NFTs. So what we're going to do is we're going to use an array.
00:29:30.190 - 00:29:49.726, Speaker A: Let's see, let's call it like inventory. Okay. Another question. Thank you. So there's no way to know what a transaction will cost from my IDE. No, there is. There's a function within most of the JavaScript SDKs.
00:29:49.726 - 00:30:30.270, Speaker A: For example, ethers JS or Web. Three JS called estimate gas. That will tell you how much gas a function call is likely to take, as well as there should be a gas price function or recommended gas price, I don't remember what it's called. If you call either of those functions, it won't execute your transaction, but it will basically tell you what it would cost to execute your transaction. You can display that to your users, but that would be one layer up from Solidity. That would be up in the JavaScript library that you're using. So where are we here? So inventory.
00:30:30.270 - 00:30:59.814, Speaker A: And we're going to say in Solidity we have to give it the variable type first. UN 256 is very common. This is a massive number two to the 256 bits. But this is like the base. You think about 32 bit computers or 64 bit computers. The Ethereum virtual machine is a 256 bit computer. And for efficiency's sake, we usually work in 256 bits.
00:30:59.814 - 00:31:46.646, Speaker A: Even though you would think, well, if I don't need such a big number, I can use a smaller one. But that's the kind of the state of the compiler at this point, the UN 256 inventory. And so this is an array of UN two hundred and fifty six S. And I'm going to say, let's say we're going to have a function called Mint and I'm going to mint an NFT. Let's say we'll just call it Mint function, mint public. And there we go. And then when we call Mint, what we're going to do is we're going to say array of well, this doesn't make much sense, right? I'm just storing numbers here.
00:31:46.646 - 00:32:18.834, Speaker A: So wait a minute. What we actually want to store is we want to be able to store things like Struct NFT. We want to be able to store things like a name for NFT. We want to be able to store an ID, token ID. Let's say UN. 256 token ID. Or we'll just say ID of my NFT and maybe we want to store well, let's keep it really simple for now.
00:32:18.834 - 00:33:05.854, Speaker A: Let's just do name and ID. Can you store images from Beowulf? Yes, you can, but it's going to be very expensive. So you typically don't, right? At least on the Ethereum blockchain. If you want to store images or you want to reference images, generally what people do is store the URL, which is a string and cheaper. If you want to store a URL, let's say, I don't know, 40 characters and all the associated logic, you do that as part of an NFT. On the Ethereum main net blockchain, it's going to cost you about $40, which is the going rate in Gas at the moment. Obviously on something like Polygon, it'll be fractions of a penny, or Finance smart chain, it'll be a few cents, but that is one strategy.
00:33:05.854 - 00:34:03.330, Speaker A: And then reference your image either in a centralized website or a decentralized service like IPFS Interplanetary File System, which is also Immutable. It's sort of like a combination of IPFS is like a combination of BitTorrent and blockchain, if you will. The other option is to generate the image, and this is a relatively new technique, but the way to do it is essentially to generate vector graphic data in the form of SVG data directly on the blockchain and then return that at a function. And you'll see that in some cases. Actually, I think Uniswap B three is doing that. There's a number of different what was it? Loot. The Loot project is doing that in their NFT.
00:34:03.330 - 00:34:52.610, Speaker A: So if we come in here and so this is, by the way, if I'm going too quickly, this is Etherscan, it's a block explorer. You can look at what's on the blockchain, including for smart contracts that are verified on Etherscan, you could look at their source code. So I'm just going to control F and search for SVG here. You can see that it's actually creating an SVG inside of the smart contract and then returning it. And they're using some techniques here with these built in functions for packing. And so the images that get returned, these images are actually SVG images. And where are we here? So what's a token Uri? So this is a reasonable strategy, but you are still limited by size.
00:34:52.610 - 00:35:26.670, Speaker A: But you can actually do something decent here or reasonable here. So token Uri, I don't know. Token number one, it's going to return this. So it has actually base 64, encoded it, and it's returning it as a data Uri. So I think, I don't know if this is going. To work or not, but if I just paste it into a new browser window here, the site can't be reached. I think I might be missing either a comma.
00:35:26.670 - 00:35:50.520, Speaker A: There we go. So actually, sorry, this is not the image here, this is the JSON. So actually it's returned the JSON and then it's also put the image into the JSON. Very slick. Actually, if I paste this in, you'll see now this was generated directly on the blockchain, this SVG data. Pretty cool. Yeah.
00:35:50.520 - 00:36:37.874, Speaker A: So question from Max andrew. Did Vitoxy making two to six was bad? Yes, he did. Perhaps it should have been 64 bit with an arbitrary size big int feature, because 64 bit is more space efficient, more a standard dev experience or both. Other times that 256 makes more sense. Ethereum was an experiment. I mean, it kind of still is an experiment, although now it's really in production and there's a lot of things when you're dealing with cryptography and public and private keys where 256 bits, especially with elliptic curve cryptography, is a good place to start and to make things easy. I think that's why they chose 256 bits.
00:36:37.874 - 00:37:11.326, Speaker A: But it is a massive, massive number. Normal computers now don't support it, although they probably natively, although they probably will someday. So, yeah, I mean, I think it made a lot of sense at the time, but yes, I think Vitalik did write either on Twitter or in an article some point, that maybe they should have used a smaller bit size. Okay, we're not quite building Loot yet. We're building our simple NFT, which isn't even going to be yet compatible with the standard. So here we go. So NFT.
00:37:11.326 - 00:37:44.566, Speaker A: Name and ID. And in fact okay, so inventory. So not uint 56. We're going to make this an array of NFTs. And when we mint, what we're going to do is we are going to simply say, where are we here? So of type NFT and it's going to be in memory. That's where it's location. It can be a few different places, but memory or storage.
00:37:44.566 - 00:38:15.110, Speaker A: But we're going to start it off in memory and then store it. Who. Also qualifier, we almost always want to make our state variables public because again, all of our data on the blockchain is public anyway. We may as well make our debugging experience easier. There can be reasons to make things private also from a Usability perspective, but from an efficiency perspective. But for now we're going to make this variable public. So again, we defined a type here for NFT, we've defined our inventory and now we're defining a mint function.
00:38:15.110 - 00:39:01.860, Speaker A: So NFT memory, NFT equals NFT type open squiggly brackets. And then we're going to say string is our name and ID, sorry, not string name is our name and ID is our ID. And there we go. So one thing that I like to do is probably a lot of programmers do is let's see if we can compile this, and what errors do we get? Undefined Identifier name. Undeclared Identifier name, the underscore name. And if I make this a little bit bigger, you see that it's going to kindly highlight. Maybe I can't make it big enough.
00:39:01.860 - 00:39:16.140, Speaker A: Okay, it's not going to do that. Whoops. Lost our side window. There we go. But it's underlining this. Of course, I have to pass it in. So string call data name.
00:39:16.140 - 00:39:53.570, Speaker A: And do we want to pass in an ID? Well, why don't we just auto generate it? Why don't we just take the length ID? Whoops ID. I'll tell you what I'm doing in a second here. So UN 256 ID equals inventory length plus one. Yes, plus one. Why not? And there we go. So actually, we're just going to make it inventory length. There we go.
00:39:53.570 - 00:40:09.482, Speaker A: Equals ID. And then let's try to compile again. Unused local variable NFT. Well, of course, we haven't done anything with it, so that's a warning. These are actually all warnings. Function state immutability converted to view. So I'm not actually storing anything here.
00:40:09.482 - 00:40:38.370, Speaker A: I'm just doing operations in memory. So it says, well, don't just call it public so that somebody will pay gas for it, make it a view function. Right? And if I'm not even interacting with if I'm not retrieving any data off the blockchain, I could even make it pure. So these are all function qualifiers that go there. But I do actually want to interact. So what I'm going to do is I'm going to say inventory push NFT. So I'm going to append to my inventory and then compile.
00:40:38.370 - 00:40:51.954, Speaker A: Hey, there we go. All right, let's go. Deploy. Deploy. I'm going to delete my previous one here so I'm not confused. Deploy a contract. It succeed.
00:40:51.954 - 00:41:05.946, Speaker A: I get the green checkbox in the lower right. Mint. Let's mint. An NFT. What are we going to call it? Of course, it's going to be hello world. I can expand this as well. And I can see the variables broken out here.
00:41:05.946 - 00:41:51.226, Speaker A: Why did I use underscores? Nobody asked this question yet, but I will answer it. Why did I use underscores? It's just by convention. And the convention is highly inconsistent. But often when I'm creating setter or getter methods, for example, if I had like, contract name or I don't know what's a good one here, like owner method here, address public owner. And if I want to update this, like, set owner getowner, I will pass in the value. I can't call my parameter owner because it's going to be overwritten or it's going to override in terms of the visibility, my public state variable that I'm trying to set. So by convention, we do this here.
00:41:51.226 - 00:41:59.040, Speaker A: Okay. Anyway, sorry. Back over here. Mint. Hello, world. Did the transaction succeed? Yes, it did. Awesome.
00:41:59.040 - 00:42:50.110, Speaker A: Okay, so I have orange and blue buttons here. Orange means that I am sending transactions into the blockchain. And actually, as you can see here, my account is losing a little bit of ether every time and fake ether because I'm sending transactions to the blockchain. Blue buttons mean that I can call a function, right? You say, why am I calling a function called inventory? Well, what the Solidity compiler does is it automatically creates getter functions for any of your public state variables of which inventory is, and it knows it's an array of NFTs. And arrays are indexed by numbers UN 256. So if I put in zero here and push the blue button, I'm going to get back my struct name. Hello world.
00:42:50.110 - 00:43:31.946, Speaker A: ID zero. Hey, we've minted an NFT. This is extremely exciting. Yeah. Okay. Just answered Gabriel's question about whether you use underscore before variable before variable or not before. A variable I should also add is typical for parameters getting passed in underscore after a variable, you may see four parameters that are return values and yeah, you're right, not super consistent, but who owns this NFT? Well, we all own it because there's no owner associated with it, but maybe we do want to have an owner associated with it.
00:43:31.946 - 00:44:32.510, Speaker A: So let's add address here, owner of the NFT and this will be the current owner of it. So where are we here? Okay, so who's going to be the owner? Well, rather than pass in an owner, why don't we just say that whoever created it is the owner. And we do that by using message sender and message refers to you'll see this turned into blue here. Message refers to the current transaction. There's other ones, like I could say created at, created at type goes before UN 256. I can do created at, created at and block timestamp. Block timestamp actually refers to the previous timestamp.
00:44:32.510 - 00:44:56.962, Speaker A: But yeah, there we go. So let's try this again. We're going to go a little bit faster this time and in fact, I'm going to turn on autocompile green checkbox, good to go. Delete our old contract, which we did deploy. And then we're going to Mint to say hi. And let's take a look at token ID zero. And you can see string.
00:44:56.962 - 00:45:50.006, Speaker A: So there's high right, ID zero. The owner is me again, message sender. And the block timestamp was the timestamp of the previous block so close enough at least on main net ethereum where blocks are constantly getting generated, but close enough to the current time. What if we want to explicitly return some data from a function? So maybe I want to say, maybe I want to say how many NFTs does a given owner have? Well, I'm actually going to need to store a little bit more data. So where are we here? We are going to do UN 256 mapping. So mapping is a hash map, extremely useful. It looks like this, you can even nest them.
00:45:50.006 - 00:46:34.130, Speaker A: I could do mapping, mapping UN 256 to like UN 256 if I wanted, but we're just going to do mapping address to UN 256 and balances. We're going to call it public and this is going to be, I like to comment it here. So owner to quantity or balance, right? And in fact, we're going to turn off autocompile because it's just like popping up the messages there at the bottom, which we don't need. Another question in the chat. Can an NFT create another NFT programmatically? Yes, absolutely. Contracts can deploy other contracts. Absolutely.
00:46:34.130 - 00:47:24.082, Speaker A: And that pattern, like the factory pattern, is fairly common. But what you have to remember is every transaction has to be initiated from outside. So if you want to do something on a regular schedule in the blockchain or any kind of automation, the initiator of that transaction always has to be from outside of the blockchain. So it's not like it could never be, let's say, sentient at this point, at least if you want to think of it like that. But yes, contracts can deploy other contracts, so balances. So what we're going to do here is we're going to say when we mint an NFT, we're going to do balances message sender plus plus and there we go. I also wanted to introduce another concept here called events, which are critical.
00:47:24.082 - 00:48:54.850, Speaker A: So event transfer, let's say address from address to and ID token ID token ID UN 256 UN 256 remember when we talked about the blockchain and ethereum blockchain being eventually consistent? What that means is that you don't know when your little unit of computation, right, your transaction is going to run. You submit it to the blockchain and it could run now, it could run in ten minutes or 10 hours or never, right? Likely you've submitted it. If the blockchain is not so busy and you've given it a high enough gas price and the function succeeds, it should complete within seconds to minutes. But you don't have any way of understanding when that has actually happened, other than polling is one option. Or essentially this is almost like a callback or a webhook. It's not a webhook, but it's like a callback is what events are, right? So when something happens on the blockchain, the event gets issued and my external code can be listening to it. This is the recommended programming paradigm for the blockchain.
00:48:54.850 - 00:49:49.506, Speaker A: Do something on the blockchain, emit an event and then listen for that and then take further action. It is just not efficient to do anything else. Maybe in really small trivial cases, but for example, if I have not just one, but if I have 10,000 NFTs with 10,000 different owners and I want to have a table on my web page that is displaying all of them, it's completely inefficient for me to every block go and pull 10,000 balances. I'm much better to essentially receive callbacks or webhooks or these events from the blockchain. And all the libraries that you're used to programming with, whether it's web3 JS or Ethers JS or our own multibas give the ability to essentially listen for these events. So we're going to do that here. We're going to say Emit transfer and we're going to do address zero because we're minting it.
00:49:49.506 - 00:50:26.266, Speaker A: It came from nowhere. Message sender and the token ID. All right, let's try compiling this again. Did it work? Did I think right? Yeah, there we go. Delete the current one, deploy contracts so we can mint now hi and we can do inventory. And in fact, if we expand this, we'll see our event. This is in a place called Logs.
00:50:26.266 - 00:51:06.966, Speaker A: So from address zero to our address token ID zero, inventory zero. There we go. There's our inventory. If we take our owner, we can also copy it from the top here, which is handy paste in the balances and balance of one. Just looking through the questions, can you recommend a good resource for going deeper on best practice for variable and function visibility? I would say that the Solidity Docs are helpful soliditylang.org and then go to Docs. Pick your version because they've changed.
00:51:06.966 - 00:51:52.250, Speaker A: Like those keywords public, private, pure, et cetera have changed. But let's say version latest or pick a version here. Tom, I would say that's the best. Keep in mind everything on the blockchain is public, especially in a hackathon. It doesn't matter really, but just because something's set to private, it's more about to use some of what you've written, the paradigm or the structure that you're trying to create rather than whether somebody can read it or not. Is there a way to have breakpoint and live debugger? Yes, there is, absolutely. So what I can do actually is I can come in here and click debug and I can be debugging.
00:51:52.250 - 00:52:11.898, Speaker A: And this is the integrated debugger. It's a little flaky. It's kind of the best that we have. You'll see that I'm scrolling through the opcodes here. So slow dupe one, swap one, et cetera, et cetera. I can set breakpoints as well. I've just set a breakpoint there and theoretically go to the next one.
00:52:11.898 - 00:52:52.922, Speaker A: The last time I did this, it hung my browser. So I'm not going to try. The other option is if you use something like Hard Hat, they have console log. So I can't show it to you at the moment because we're just working in the browser. But you can essentially if I do, like if you Google hardhat console log, there's basically a way to printf inside of your smart contract functions during debugging only super handy if you want to store sensitive information. Would it be okay to store private mapping, for example, with my passport ID? No. Do not put any private information on the blockchain.
00:52:52.922 - 00:53:29.078, Speaker A: Let me repeat that. Do not put any information on the blockchain that you do not expect to be completely public. It is there forever. What you do instead is you store a non identifiable reference like an ID number or a Guid on the blockchain and then you store any private information off chain? Yes. Can you encrypt it and put it on the blockchain? Yes, you can. You've got to be super careful about that as well. It is possible, but as we know, we all have to be cautious about encryption.
00:53:29.078 - 00:53:54.450, Speaker A: Can I talk a little bit more about the mapping? Yeah. Thanks, Gabriel. Sorry, I'm scrolling down. I could use memory. Why did I use call date instead of memory? There is a technical reason I don't remember what it is. I could just as easily put memory in here and that would be fine as well. So that's something I'll probably take offline theme in discord.
00:53:54.450 - 00:54:31.950, Speaker A: Yeah, you could encrypt data map, hash table. Thanks for helping out Chat, really appreciate it. Wonderful. But yeah, the thing to remember about arrays and mappings in solidity is they don't have a maximum size. As long as you're willing to pay the gas fee, they can grow forever. And for example, theoretically, right, the index size on an array is UN 256. So two to the 256, just more than the number of atoms in the planet Earth.
00:54:31.950 - 00:55:00.422, Speaker A: Number of elements in an array. So you're never going to run out of space. Yeah. There we go. We are coming up on time. We started a couple of minutes late, so I'll run just a couple of minutes over, maybe to show you a few other things. So, Mint, let's say, for example, I have balances here, but we haven't shown how to return a value.
00:55:00.422 - 00:55:40.402, Speaker A: So function get balances, get balance of or we'll just call it balance. Balance of which is actually ERC, 20 standard. So we're going to do address owner underscore by convention, public view. So this will show up as a blue function here on the left. It won't cost us anything to run and we're just going to do return balances of owner. Not particularly useful function because we already have a public state variable. But let's say we made this private here.
00:55:40.402 - 00:55:55.918, Speaker A: Where's my balances? Private. All right, so let's try to compile again. Compile solidity 101. Different number of arguments in return statement. There we go. Public view. Returns open and close bracket.
00:55:55.918 - 00:56:22.740, Speaker A: I can return multiple values here as well. UN 256. Compile. There we go, to the blockchain. Deploy, deploy contracts. Mint high balance of. Right, we had balances before, now we have balance of and copy my contract here.
00:56:22.740 - 00:56:48.620, Speaker A: And there we go. Balance of one. Yeah. If you run a space of a mapping, you're just abusing the storage capability of the blockchain. Yes, absolutely. Definitely be efficient as possible with storage. So what are the options for updated contracts on the blockchain? There's a few different options.
00:56:48.620 - 00:57:42.304, Speaker A: You can never go back. Well, actually, you can. There's a function called self destruct, where if you call self destruct, I don't know if this will work. Function destruct public. If you call self destruct, it will actually delete the contract off the blockchain. Given one, it wants somewhere to send the ether in the contract invalid type for argument in function call from address to address payable. I might not get this, I might not get this without Google and we're running out of time now.
00:57:42.304 - 00:58:31.120, Speaker A: There we go, it worked. So you can always delete a contract and then it's gone from the blockchain from that point in the future. That doesn't really help you though. But it can be potentially part of another pattern, which is basically just deploying a new contract and pointing people at that. Typically you actually don't self destruct your previous contracts, you simply deploy new ones and point people to that. In the past, people just published new addresses of contracts. Now there's another way using what's called the proxy pattern and some low level assembly to essentially have kind of like a doorway or a proxy contract which is able to dynamically reroute any kind of smart contract function call to another contract.
00:58:31.120 - 00:59:35.652, Speaker A: The good thing about this is it makes your smart contracts upgradable. The challenging thing is you have to code your smart contracts in a very particular way to make it work. If you want to try this, and I don't recommend this as a hackathon thing unless you're trying to learn or it's critical to kind of what you're doing. But you should look at the open Zeppelin docs around their proxy upgrade plugin, which takes care of a lot of the challenging pieces for you. Right? So here's kind of that model of what I was just speaking about. The other reason to not do this is that it doesn't violate the kind of promise that you made to your users that things are going to be immutable. But you have to be very clear about that, right? Because if you're able to change the logic of your contract while the storage stays the same, I could do, hey, okay, upgrade my function and now my returning balance of times four.
00:59:35.652 - 00:59:51.770, Speaker A: I've got four times as many NFTs as I did in the past. Right. So that's something else to consider when thinking about smart contract upgrades. Yeah. Thank you. Thank you, Carlos. Appreciate you jumping in there as well.
00:59:51.770 - 01:00:07.712, Speaker A: So, let's see. Actually, let me try this. I'm curious if this is going to work. I don't think I've ever see compile to work. Yes. Delete deploy. Here we go.
01:00:07.712 - 01:00:37.608, Speaker A: Here mint high. We've minted it. Inventory zero. There's our high contract destruct. That seemed to work. So now let's try calling inventory zero and we get basically no data back, right? Because the contract has been self destructed. So, yeah, maybe one last function and then we'll wrap things up.
01:00:37.608 - 01:01:23.210, Speaker A: Let's implement a transfer function. So we're going to say two, address two, and then token ID. So the one last thing we talked about, security, right? The require keyword is basically like an assertion, which means that it's a boolean statement followed by a reason, which will get returned. So message sender is not owner. And the logic is require that what did I call it? Inventory. Right. Inventory ID.
01:01:23.210 - 01:02:13.896, Speaker A: Inventory token ID. Inventory TokenID owner equals message sender. So again, anybody can read anything that's on the blockchain. Anybody can call your smart contract, but the logic can implement access control. And that's how you have to do it. Then what I can do is I can say inventory TokenID owner equals two. I also have to do balances message sender minus minus balances, two plus plus.
01:02:13.896 - 01:02:45.330, Speaker A: And I'm going to emit my event, my transfer event. Where are we here? Transfer from message sender. And then two token ID autocomplete. All right, let's try compiling file solidity, no visibility. Of course. It's got to be public. Public.
01:02:45.330 - 01:03:11.736, Speaker A: There we go. And delete the old version. Deploy the new one. Mint. Hello, world. Okay, so now my address here, my balance is one. My inventory, the inventory for token ID zero.
01:03:11.736 - 01:03:39.516, Speaker A: I'm the owner here. Let me pick another account to work from. And let me try transferring token ID zero to myself, right? So one parameter comma the other parameter and I expand that I can see. I can fill them in here. Transact transfer. And here we go. The transaction has been reverted.
01:03:39.516 - 01:03:57.692, Speaker A: It was not successful. Message sender is not owner. Message sender is not owner. That's how you do access control on the blockchain. Let's try this, in fact, where I am going to transfer to the second one. So I am going to be the owner. I'm going to call transfer again and it succeed.
01:03:57.692 - 01:04:26.464, Speaker A: And now if I look at inventory, you can see the owner has changed. My balance of has gone from one to zero. And the balance of the new one, the new one has gone from zero to one. There we go. Okay, well, listen, thank you, everyone. If there's no final questions, I think we're going to wrap things up. Appreciate you all joining today.
01:04:26.464 - 01:04:49.780, Speaker A: This has been wonderful. I think it's being broadcast to YouTube and we'll be there if you want to check it out afterwards or direct your friends to it. I'm available on Discord in the tech mentors and debugging channel. You can find me there. So thank you again and have a wonderful day. All right, bye, everyone. Thanks, Jeff.
