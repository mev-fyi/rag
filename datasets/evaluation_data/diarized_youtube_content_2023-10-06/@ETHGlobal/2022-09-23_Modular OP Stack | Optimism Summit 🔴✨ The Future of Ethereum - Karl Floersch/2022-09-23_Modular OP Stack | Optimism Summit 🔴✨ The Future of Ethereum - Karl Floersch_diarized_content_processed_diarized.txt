00:00:06.330 - 00:00:24.606, Speaker A: So, without further ado, would love to welcome Carl onto the stage. So, Carl, whenever you're ready, feel free to unmute and share your screen. Carl is listed on this chat as Carl with many Op with many exclamation points. So, you know, he's excited. There you go.
00:00:24.628 - 00:00:32.870, Speaker B: Welcome to you already know. How could I not be? Oh, my goodness. Let me make sure that okay, I got all the things.
00:00:33.020 - 00:00:34.214, Speaker A: You're all set?
00:00:34.412 - 00:00:36.870, Speaker B: I'm all set. We did it. Reddit.
00:00:37.850 - 00:00:38.502, Speaker A: There you go.
00:00:38.556 - 00:00:39.506, Speaker B: Everything looks all right.
00:00:39.548 - 00:00:42.810, Speaker A: Well, I'll get out of the way and excited to hear more about the Op stack.
00:00:43.550 - 00:01:15.762, Speaker B: Okie dokie. So welcome, everybody. Going to talk about the Op stack bedrock and the rise of the super chain. And we actually got a solid amount of time. I didn't realize we had so much time, but I got to fill up all the time. So without further ado, I'm Carl, of course. I work at Op Labs doing this optimism or whenever I talk about these things, right, these words pop up on the screen.
00:01:15.762 - 00:01:46.478, Speaker B: There is one word that everyone sees. They don't see the rest of the words, they see super chain. That is what they see realistically. So I'm not going to start off by talking about the super chain. I'm not going to talk about how it is all these chains kind of combined into one super duper fantastic thing. I'm not going to talk about that to begin with. Instead, what I'm going to talk about is the problem ethereum congestion back in 2016, 2015.
00:01:46.478 - 00:02:13.270, Speaker B: This has been a problem for way too long. Oh, my God. It's been a long, many years. But we've had too much demand for Ethereum. Ethereum is too good. And so what happened? How did we solve Ethereum congestion, realistically speaking? Well, we copy and pasted it into more chains, all these various chains generated by dolly two. That is what we did.
00:02:13.270 - 00:02:58.498, Speaker B: That is what we did. And then what did we do? Well, we connected these chains with largely insecure bridges, these largely insecure chains, realistically speaking. And we kind of hacked some together to address this horrible problem of congestion. And in some sense, optimism is kind of one of these things, right? It is a layer two, but from a user experience perspective, it still has a bridge. It still feels a little bit distinct, but it does have the nice quality of being rooted in Ethereum and sharing some of that security. And so this is kind of the state of affairs in some sense. And if I'm a user, this cute little gerbil also generated.
00:02:58.498 - 00:03:35.522, Speaker B: Most of these photos are generated, actually. Then you're going from one chain to another, trying to deposit, withdraw. It's just kind of chaos, to be honest with you. And you can kind of visualize this as a crazy market, right? It's like a marketplace. And you're going from these different sellers, and maybe you go to this person, you're transacting on this chain using this vendor. And behind you there's a bridge that just exploded and another one that just exploded. And then you went to this other chain and now it's actually a rug pull.
00:03:35.522 - 00:04:09.900, Speaker B: It is true and utter chaos right now. This is not good. This is not a user experience worth bragging about, right? This is just honestly very sad. But it's better than no one being able to transact, which is the alternative because Ethereum was just way too congested. But we can do better. We can do better. And what if I told you what if I told you that there was a solution to this problem? There was a solution where instead of going from one place to another, everything is all in one place.
00:04:09.900 - 00:04:42.534, Speaker B: And you don't have to transact with all these different vendors. You can instead transact with one trusted seller. One trusted seller and you've got seamless atomic checkout in this market. Well, it's the supermarket. Whoa. Oh my gosh. Okay, this is a joke, right? We're not here for supermarket technology, but it's just supermarket super chain anyway.
00:04:42.534 - 00:05:10.910, Speaker B: Really, though? Really, though, I can't help myself. Our chain should have these properties, right? We demand these properties that everything in one place is single trusted seller. So you're not getting hacked all the time, right? We shouldn't have to bridge from one chain to another. We shouldn't have to get hacked. I mean, my goodness, that's a low bar. And also transaction fees should be cheap and sometimes pretty much free. Like, that is legitimately.
00:05:10.910 - 00:05:29.906, Speaker B: There is no technical blocker and so there is no reason why we should not achieve this. Don't fear, though. Don't fear. The op stack is here. All right? We finally got to the actual meat of the talk to an extent. Well, state of affairs. Kind of crazy, absolute madness.
00:05:29.906 - 00:06:02.446, Speaker B: But we can fix this. How do we fix this? Well, we can build standardized open source libraries that provide shared security so things are actually secured rooted in Ethereum. There are fallback mechanisms. There are things that prevent terrible hacks. Also, just the fact that it's standardized makes it way more secure because now there are way more eyes on it. It's not just a one off solution because that's how you get hacks. Additionally, composable, right? We need these systems to all work together.
00:06:02.446 - 00:07:07.562, Speaker B: You can swap out one module, they're compatible with one another. And additionally, finally, coordinated sequencing. I won't talk about how incredibly that important that is, but it is actually incredibly important for creating an experience. Now, what is this experience? That the user, at the end of the day, all of this technology is in service of building something that we can all use, right? I want to use a better product than we have today. And so what is the user experience of this system? Well, with the compatibility that the shared technology enables, we can actually create a virtualized single super chain. Right? We can actually interact with the system in a way where you're not having a bunch of user facing bridging. All that kind of stuff can be handled in the background, right? We can have robust modules that ensure security and additionally, it should be hella scalable, horizontally scalable.
00:07:07.562 - 00:07:55.938, Speaker B: Some call it, quote, infinitely scalable, but I feel like that's just like a savage marketing term, horizontally scalable. So we can have near free transactions, transactions that essentially cost the amount of money that it costs to run that transaction on a computer. So it's like renting from AWS as opposed to paying surge pricing on Uber. So we can realize this super chain. We can realize it with open source technology, shared standards and working together. And we can make that happy experience for our happy gerbil. Now, if we want to talk about how exactly the kind of like combination the virtualization of the superchain works, you can kind of take a look at endgame that has a bit of a hint at it and then there's even more talks that we can go into.
00:07:55.938 - 00:08:25.002, Speaker B: But I won't do it right now because we don't have enough time, or at least so I thought. But you can ask questions at the end of the presentation. So now we are past the intro. Maybe I needed all the time that we have. Let's talk about the core of the Op stack. So this is not necessarily everything, but this is the kind of bread and butter. Okay, what is the Op stack again? Standardized open source modules for layer two chains.
00:08:25.002 - 00:08:54.322, Speaker B: We are using it for, of course, optimism mainnet. But it is open source, therefore anyone can mess around. Now, there are three key layers to this, right? Any stack has some layers the consensus layer, the execution layer, and the settlement layer. Consensus. That's how the chain gets constructed. The execution, that's the virtual machine that is actually being executed over this chain of inputs. And finally the settlement layer.
00:08:54.322 - 00:09:43.350, Speaker B: That's how withdrawals occur. So if you look into layer one, if you look closely with a magnifying glass, you will see that layer one is actually made up of its own consensus layer and execution layer. So this is a recent change that we've modularized layer one in the very same way that we're trying to modularize the layer two technology. And the way that that works is that we have Prism. These consensus layer clients, not just Prism, don't just use Prism y'all, we need diversity. Additionally, we have execution layer clients like Geth and we have that same structure playing out in layer two as well. Now, let's get into the nitty gritty of the consensus layer, execution layer and settlement layer.
00:09:43.350 - 00:10:20.622, Speaker B: What are these different things? So first, for the consensus layer, we have two key modules, two options that we can choose from. We can either choose roll up, which basically means that all the transaction data is fully available on chain or plasma. Now, plasma got a bad rap back in the day. It's just too early. And now there's a million different terms for plasma, like Valadium validium all of these things, the various things. Basically, at the end of the day, we should just call them data availability challenges. We have a consensus layer client that has off chain data with data availability challenges on chain.
00:10:20.622 - 00:10:58.910, Speaker B: So those are our two kind of like broad categories of consensus layer type deals. Additionally, we've got execution layers. So that is the EVM, the classic one, right? We've also got extra fancy ones like this weird one in the middle that I'm kind of just like hinting at but not saying because I don't know if I should talk about it yet. But anyway, we've got other execution clients that are special purpose, maybe for some games, maybe not, whatever. And then finally we have the settlement layer. This is how things actually get withdrawn from the system. This is how you kind of prove the withdrawal.
00:10:58.910 - 00:11:58.498, Speaker B: Now, notably, I have here multisig fault and ZK proof. I am writing this as though the settlement layer, if you have a fault proof or a ZK proof that is kind of working, but you still have a fallback to a multisig, then because of the weakest link security, at the end of the day, you're still multisig. And so that's why multisig is here. Obviously, no one wants multisig to persist into the future. But the reality of layer two right now is that things are being secured, withdrawals are being secured by the multisigs, which is better than it being secured by an insecure proof system. So let's be thankful. Anyway, consensus layer, execution layer, and settlement layer, right? You can choose each one of these and if you choose this configuration, then you'll end up with an EVM equivalent optimistic roll up, right? This is the perfect flagship for an L two, but it's not necessarily the only configuration you might ever want.
00:11:58.498 - 00:12:56.542, Speaker B: And it does have different security trade offs or withdrawal trade offs, right? All of these things are trade offs. Now, additionally, eventually you'd want to plug in potentially a ZK roll up, a ZK proof system, a ZK settlement layer. And so what that means is that we can have an EVM equivalent ZK roll up. And additionally, because it is modular, we can swap it in and swap it out. So the same chain that was running a fault proof can, without changing anything about developer experience, without changing anything about the nodes that people are running, you can actually swap in a different proof system for withdrawals. And so that means that we can get these seamless upgrades and write compatible software. Actually, in fact, the key to scaling up the production of software is defining really good abstraction layers.
00:12:56.542 - 00:14:03.830, Speaker B: And so this is actually more important than you might imagine because it allows people to work on different things in silos and still be compatible once they have done the incredible amount of work. And ZKPs are a great example of something that's going to take a lot of work to make extremely inexpensive. And let's continue. So we've got the consensus layer, right? We can do things like layer three by layering in plasma with the EVM and fall proofs, right? All of these things are options and even swap out the execution layer. All of these configurations are valid. But the key is that we should make sure that the way that they communicate, the way that these layers communicate with one another is standardized so that we can all benefit from each other's innovations and build out the blockchain stack candidly in an open source and permissionless way. So that is the core of the opizzle stack ISL so the bedrock release.
00:14:03.830 - 00:14:34.706, Speaker B: We are finally at that section. Okay, what is bedrock? Right, bedrock is a major step forward across two primary dimensions. So first off, obviously it is the next upgrade to optimism mainnet. That is, we are upgrading our main net. If you deposit into optimism, then that thing is going to be using bedrock very soon. And that's going to make it literally like the most secure, the most scalable roll up that is out there. Let's go.
00:14:34.706 - 00:15:25.978, Speaker B: So, bedrock is actually legitimately, extremely, extremely dope. The second thing is that it supplies the foundational op stack modules, right? We built it out in this modular way already. And in fact, in the later talks with Josh, et cetera, we'll go into the details of how these things actually fit together and what components we built. So, we have a configuration of the op stack and we have all of these different packages which it is using, right? We have this op node, which is the consensus layer kind of equivalent. We have op geth. We even have op aragon, right? This is literally two ethereum clients that are compatible. Additionally, we've got all of these other batcher proposer contracts.
00:15:25.978 - 00:16:06.834, Speaker B: We have Canon for fault proofs. All of these things are built in this modular way. And so here I'll go over into more specific details of where the major steps forward in modularity are. So, first off, modular execution with the engine API. So, first, I started this talk by saying how the consensus layer and the execution layer are actually being built out and were created for layer one development. Well, what did we do? Well, we swapped out the consensus layer and replaced it with the op node. So now we're coming to consensus by using l one consensus that's literally like the definition of layer two.
00:16:06.834 - 00:17:03.790, Speaker B: Additionally, we have the execution layer, so we have guess. But we can also swap in things like aragon. And it takes very little code to modify these execution layer clients to support layer twos. And that is critical, right? Code reuse is a key factor of security and these systems need to be more secure than any other system you've used, let me tell you, these security requirements are insane. And so this also enables us to have a multi client ecosystem. We would never have made the Merge upgrade we would never have done the Merge upgrade without multiple clients because multiple clients catch divergences between them, making the entire system more secure. That's why the merge went through without any critical bug reports, right? That is literally the technology that the security technology they used was a MultiClient ecosystem.
00:17:03.790 - 00:17:32.154, Speaker B: And so we need that very same thing for layer two. And that is absolutely critical if we want to enable fault proofs, for instance. And I'll talk about that a little bit more later. So, yes, additionally, we can even have more fun. And maybe it's not going to have a multi client ecosystem, but we can input this weird mystery VM and boom. Now we've got even more execution engines that we can use. So that is the first step, right? It's the engine API.
00:17:32.154 - 00:18:02.882, Speaker B: The second thing is modular derivation. So first execution. The second one is derivation or the consensus layer. So back in the good old days, a year and something ago when we were writing our roll ups, we thought that we needed a bunch of smart contracts on layer one to actually derive the roll up. So essentially, you take in L one. This function is like the roll up function. It produces the layer two blocks.
00:18:02.882 - 00:18:55.254, Speaker B: And what we were doing is we were saying, okay, you need layer one and you need some smart contracts on layer one to do some management for you and whatever. But this meant that the system was actually really brittle. It was really hard to upgrade because you always needed to maintain these layer one contracts. But now what we're doing is we're consuming raw layer one blocks raw layer one block data to produce the layer two chain. So what does that actually mean? It means that we can swap in because it's just like a raw stream of data. We can swap in new data sources like EIP 4844 or even plasma, right? Things like off chain sources of data. So this allows us to both a scale up, be ready for when we're improving layer one, because we're pushing forward EIP 4844, which is a major improvement to layer one.
00:18:55.254 - 00:19:59.738, Speaker B: But we're also able to support things like layer three. And finally, modular proofs with Canon. Canon, it generates the execution trace over the client and it allows us to prove that execution trace, but we can prove an execution trace with either fault proofs or ZK proofs, right? These two things totally work. The ZK proofs might be too expensive right now, but that's something that we can work on over time. And importantly, right, importantly, bedrock again supports multiple clients. And multiple clients is incredibly important to support production, high security chains, and specifically to support fault proofs and ZK proofs without big bad upgrade keys, right? We need our upgrade keys to be upgrade and then you wait like two months because you can actually withdraw. And we need them to make sure that the mechanism that allows people to withdraw from layer two in case there's a malicious upgrade, we need to make sure that that mechanism will never break.
00:19:59.738 - 00:20:34.034, Speaker B: And the only way to make sure that mechanism will never break is with multi client support. So there we go. More information on that in our Pragmatic path to decentralization because we need to get rid of those upgrade keys. We need to not be multi SIG roll ups anyway. Great. This evolution, right? The state of affairs, this madness with these bridges going crazy and these different chains and this terrible user experience. We're already making progress there, right? Bedrock release is fast approaching.
00:20:34.034 - 00:21:02.606, Speaker B: We're about to take a massive step forward in the op stack. Additionally, we already have multiple op based chains, so this is not even like an X. We need more op chains. Literally. We accidentally had people deploying op chains just because we were writing our software out in the open. And additionally, we've got teams experimenting with bedrock, pushing the boundaries of what was possible on chain. Right.
00:21:02.606 - 00:21:51.230, Speaker B: We're going to break through. Even the scalability that we have today is not even close to what we're going to have tomorrow. It's like you don't think about the resource constraints on AWS unless you're a massive crazy team, but you don't really think about the scalability constraints on AWS. As an average individual, you should not be thinking about the scalability constraints as you're transacting or deploying DApps to a blockchain. This is just the beginning, right? We are about to take over with the zombie horde of gerbils generated by artificial intelligence. We will take over the game and soon we will realize the final evolution of blockchain walmart. No, I'm just kidding.
00:21:51.230 - 00:22:30.060, Speaker B: We will finally realize the super chain thanks to the op stack because we're working together to solve the problems in a secure and scalable way. Hallelujah. We're going to provide that good user experience to us because we're the users too, you know? And the rise of the superchain. That's it. And by the way, this is also a super chain image, but including a gerbil. I just love the way that these AIS, or like Dolly specifically cannot spell it's so good. Anyway, thanks everybody.
00:22:30.060 - 00:22:55.970, Speaker B: I guess we don't have that much time for questions, but happy to answer them. Let's go. All right, that's it. I mean, I don't know. I'm now in my room. I still feel like I'm in my room. Is there a place I should be looking for for questions? Do we have a couple? I don't know.
00:22:55.970 - 00:23:11.910, Speaker B: I don't even know. I don't know where I am. Well, I feel so alone. Wait, am I oh, it's because I turned off my mic. Because I can't hear. Maybe. Hello? Okay, fine.
00:23:11.910 - 00:23:13.030, Speaker B: I'll just talk then.
00:23:13.100 - 00:23:14.118, Speaker C: Hey, Carl. Sorry.
00:23:14.204 - 00:23:14.662, Speaker B: Oh, great.
00:23:14.716 - 00:23:23.598, Speaker C: No, I think hi, it's me. No, I think I don't see any questions. I think we're good.
00:23:23.764 - 00:23:35.630, Speaker B: How did you find such a cute dog photo? Well, that would be my question. Dog on Google. All right, let's move to Josh.
00:23:36.370 - 00:23:42.106, Speaker C: Okay. Awesome. Carl, thank you so much. I love your presentations. You're so enthusiastic.
00:23:42.298 - 00:23:43.420, Speaker B: Thank you. You're awesome.
