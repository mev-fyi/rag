00:00:00.170 - 00:00:18.030, Speaker A: Tech, and he'll be talking about the new layer two aspect is built as their ZK evolve service with privacy at its core. And I know Joe is already here with us on this call, so I'll just let Joe kick off with a screen share and his presentation. Welcome, Joe.
00:00:19.650 - 00:00:45.834, Speaker B: Thanks, Karzek. 1 second. Great. I'm going to run through this fairly quickly because I'm on patchy Wi Fi. Hopefully this will hold up this time and we'll move on to the demo and the code, because I'm sure that's what everyone's here to see.
00:00:45.952 - 00:00:46.940, Speaker A: Sounds great.
00:00:47.790 - 00:01:32.426, Speaker B: Great. My name is Joe. I'm one of the co founders of Aztec, and we're very excited today to announce the launch of Aztec Two, a ZK roll up with privacy. So in the half an hour we've got today, we're going to run through what Aztec Two is and how we use ZK Snarks for scaling and privacy in the layer two. We're also going to do a quick demo of how private transactions appear on Robstone, and we'll do a run through of Noir, our Snark programming language. I also think it's important to take a step back when people are developing an ethereum, things move very quickly. It was only eight months ago we launched the 1.0
00:01:32.426 - 00:02:14.470, Speaker B: version of our protocol, bringing confidential transactions to Mainet shortly afterwards. Tornado Cash also brought anonymous transactions in February. And in the same month, our research team upgraded our universal Snark Plonk in February. So what is Aztec Two? Aztec Two is a ZK roll up based layer two. It allows users to have private sends by default, averaging around 5000 gas per transaction. It has social key recovery built in and allows scalable private access to DFI. Alongside it, we're also shipping a programming language, Noir, giving developers the keys to programming privacy.
00:02:14.470 - 00:02:56.390, Speaker B: Aztec Two is powered by Plonk, the cutting edge Snark built by Aztec over the last year. Plonk has the performance of a traditional Snark, but only needs one trusted setup. In certain areas. It's also ten times more efficient, allowing us to do recursion. This efficiency makes Zok Snarks usable on ethereum. Today signatures can be validated over the ethereum curve, as well as curve 25519, which is the curve inside most iPhone and Android security modules. Proofs can be constructed in seconds, and clients can benefit from full user privacy.
00:02:56.390 - 00:03:40.180, Speaker B: This efficiency is core to the design of the Aztec layer two. It allows us to roll up Snarks inside Snarks. The inner Snark can be anything a private transaction, a uniswap trade, or even another roll up. This design allows our layer two to have scaling and privacy. As private transactions are at the core of the network, users can get opt in privacy for ERC 20 token transfers. Balances are confidential and senders, and recipients are anonymous. This is the most efficient version of Aztec, yet it's over 200 times more efficient than Aztec One.
00:03:40.180 - 00:04:24.302, Speaker B: Private sends are around 5000 gas per transaction, and DFI interactions, which will be launched in November, are around 10,000 gas. In fact, the network can scale elastically up to 1024 transactions in a single block. Alongside this, we're proud to announce a new account model. Each user can now have an alias. You can be Montsuma II and not an ethereum address. We also mirror common social recovery patterns seen on Ethereum mainnet today. Alongside the network as the core is a snark.
00:04:24.302 - 00:05:33.190, Speaker B: We're releasing Noir, a programming language that allows developers to write their own circuits and have those bundled in the Aztec roll up. The language will be released in Developer Preview in November and is open source and written in Rust. Let's move on to a quick demo. And we'll first of all demo the Block Explorer, then a quick Terminal view, and then the code. So we have a block explorer live on Explorer Aztec Network. This Explorer updates in real time and allows users to go and see the blocks that are being processed by the network, the transactions on Etherscan and any transactions that are inside the block. We also have a demo UI which is at Terminal Aztec Network, which is a fun command line interface we call the Aztec Zero Knowledge Terminal.
00:05:33.190 - 00:06:20.370, Speaker B: You can use it just by typing help to get a list of commands that are available. And then init in the background here, we have to construct some proving keys which allow the client to construct the inner proofs in our roll up. Once the network synced, we can see my public balance is 655 test I and I have a private balance of 30. If I look at my list of commands now, I can do a lot more actions. I can mint, I can approve, deposit, withdraw, transfer, or register an alias. Let's start with a private transfer. Then I can transfer to one of my colleagues, Charlie.
00:06:20.370 - 00:07:22.300, Speaker B: Just by typing transfer charlie. The proof's generated in seconds, and as soon as it's sent to the roll up provider, we can head over to the Block Explorer to see it being mined. It in the background. Our roll up provider scales elastically based on the demand of transactions. It will pick a roll up size that's suitable based on the number of transactions in the queue. On testnets, we prefer to relay blocks more efficiently and quickly just to aid the developer experience. On main net, this will likely be every hour.
00:07:22.300 - 00:08:17.930, Speaker B: So you can see here that a block has been processed. It's currently waiting to be mined on Robston, and we can go over and see the transaction. As soon as this is mined, the Aztec SDK, which powers the terminal view, will update, and I'll have a live update of my balance decrementing. This transfer is completely private. No one can see who I'm sending to or the amount that's being sent. In fact, if we look at the transaction itself, the only state changes we can see are gibberish. There's also a command to view status of transactions.
00:08:17.930 - 00:09:25.730, Speaker B: We can see it's still pending here on the theoretical while we're waiting for that to be mined. Oh, there we go, it's been mined. We can also look at some of the use cases that are useful for DFI, such as withdrawals. If I want to withdraw back to layer one, save 20 die, I can specify any withdrawal address here and that withdrawal will be anonymous. I think the transactions are a little bit slower to generate when zoom is running, but usually this takes around ten to 15 seconds. We head back to the block Explorer. We can see that last block was settled, and as soon as the proof sent, we'll have a new transaction in the queue.
00:09:25.730 - 00:10:33.522, Speaker B: When we look at the next block on Etherscan, we won't be able to see who the sender of the Dai was. We'll just see an anonymous withdrawal from the roll up contract on layer one. While we're waiting for that to be mined, as a lot of you are developers on the call, I'm going to head over to the documentation. So all of this functionality is available today through our JavaScript SDK. The SDK is written in TypeScript and it allows users to interact with the layer two. See if this is in mind yet. The docs are available at developers.
00:10:33.522 - 00:11:32.614, Speaker B: Aztec Network and the docs have this unique feature of being live, so you can run all code examples in browser without having to set up any testing environments. Let's run through some quick examples around social recovery. The way that social recovery works in the Aztec Network is we have a multiple key model for a user. So a user is identified by an alias and then it has multiple signing keys. When we create an account, we create a throwaway key pair that's attached to the user's account but is single use, so no one knows the private key. Before the key pair is thrown away, it signs a recovery signature for a trusted party. That signature authorizes the trusted party to take over the account and only that trusted party.
00:11:32.614 - 00:13:03.030, Speaker B: That signature can then be shared amongst multiple services or key sharding services, and it allows at a later date, the account to be recovered to that trusted party without having to share private keys. So if we look at the code here, we can see we're just going to use random addresses here. But this code could be if you were a wallet provider or adapt, you could use a trusted address that you use to recover your users accounts. Or users could select their own address here to allow them to let their friends recover accounts. Just initialize the SDK on the docs so we can interact and run this code. The docs are also linked to the terminal view, so you can see that my balance is synced in the SDK across both websites. Just open this in a new tab.
00:13:03.030 - 00:13:57.990, Speaker B: We can see the transaction here waiting to be mined. This is an account transaction which is different to the join split. The more useful thing to probably run here is actually talking about the recovery data and what users get. If we run this particular example, if I zoom in, we can see there's a recovery payload here which gives us the key that we added as our trusted third party public key. The key we've added to the account, that's the throwaway key. And then recovery data. The recovery data here is a signature which can be used at a later date with the add signing key method to add the trusted user into the account and give the user control of their account again should they lose one of their devices.
00:13:57.990 - 00:15:09.226, Speaker B: We also have the standard methods for deposit withdrawal, transfer for ERC, 20 tokens and the network has a full emergency withdrawal feature should we disappear as a roll up provider. All of these functions can be run on layer one without the need for us using the emergency withdrawal method. Later this month we'll be expanding the network to work with DeFi. Users will be able to swap token pairs on uniswap or invest in compound. And as I said on the earlier presentation, there'll be developer preview of Noir which allows users to write their own circuits to be bundled in the roll up. I think if the last transaction has been mined, we can go and have a look at the anonymous nature of these transactions. So here we can see as a user, the only transfer that I can see is a transfer from our contract to a user and that user has no link to the original sender of the transaction.
00:15:09.226 - 00:15:29.830, Speaker B: So this is true cryptographic anonymity. I think that's probably sufficient for the demo. I'm happy to go over more things in the questions, but maybe it's good to take a couple of minutes just to take some questions and run over any details that I may have missed.
00:15:32.860 - 00:16:26.970, Speaker A: That sounds perfect, Joe. Thank you so much for that amazing talk and I'm super excited to kind of see that we just found out about the Block Explorer, the fact that you guys are ready to do 1024 transactions that are private by default and also about Noir. A lot of amazing updates bundled in. So we have a few questions coming in from the chat here and I'll just kind of start asking them in order and for the people listening in on the video because of the delay, if you have any questions, just type them up in the chat and we'll propagate them up to Joe. But a sample of clarifications that I think will be super helpful here. I think the first one that we would like to kind of get a better understanding of is how do addresses work in Aztec too? Are they just the same as an ethereum one address for a user? What's different about address spaces as you think about the role of service.
00:16:27.900 - 00:17:01.408, Speaker B: Sure. So an identity in Aztec, it can be anything. So it could be linked to your Ethereum address and it could be derived from your Ethereum signing key. But it doesn't have to be. So we have the concept of multiple keys per account. In the current testnet, the keys that are available to users are on a Grumpkin elliptic curve. But later in the year we'll be expanding that with our ultraplunk research to allow Ethereum signatures or hardware security module signatures.
00:17:01.408 - 00:17:44.368, Speaker B: So I think to go back to the question, the account model, an account is identified by a unique ID. That unique ID can have an associated alias. So a short name such as Joe, and it can have any number of signing keys. You also don't need to have an initial transaction to generate an account. You can kind of have programmatically generated accounts that can receive funds without the user having to call the create account proof. You can just send to a unique user ID. And then at a later date the user could claim those funds and kind of make a fully formed account by adding further keys and an alias to that account.
00:17:44.368 - 00:17:53.620, Speaker B: And then if at any point they want to recover their account, they can use the social recovery features to remove keys that have been lost and add in new keys.
00:17:54.600 - 00:18:07.850, Speaker A: Awesome. Another clarification that we have from the chat is can you talk a bit about what the onboarding and exiting costs are for a user and kind of how do you think about people onboarding and using the service?
00:18:08.700 - 00:18:38.180, Speaker B: Sure. So the deposit flow for standard EFE 20 tokens will incur gas on the user's kind of deposit deposits fairly fast. It just basically is a single block time for our main net launch. For tokens that support permit, we'll probably do an initial scheme where we pay the gas for deposits to help kind of bootstrap network liquidity, but that's still to be finalized.
00:18:39.400 - 00:18:41.990, Speaker A: Great. The next question we have is.
00:18:43.720 - 00:18:44.084, Speaker B: We.
00:18:44.122 - 00:18:54.840, Speaker A: Would like to learn a bit more about Noir in general and what's possible, what are the capabilities, the way you plan in features, and sort of how does it differ right now from something like sync?
00:18:56.380 - 00:19:42.760, Speaker B: Sure. Inside Noir, this is a private by default language. So the programs are private. So unless a developer wishes to expose variables as kind of public inputs to the circuit, everything is private. So I think the main difference here is that Noir is built with privacy at its core. In terms of functionality, we have Shah hashes Pedison, hashes Blake, two hashes Merkel, proofs of inclusion and non inclusion, as well as some other features which are coming later in the year, such as Ethereum transactions. But at a high level, it's kind of a language that's very similar to Rust.
00:19:42.760 - 00:20:02.560, Speaker B: It's been written to be as usable as possible. It shouldn't have any kind of strange symbols in it. And the idea here is that most Ethereum developers can write these mini programs that can be bundled into the roll up without kind of zero knowledge expertise.
00:20:03.380 - 00:20:12.080, Speaker A: That's awesome. Yeah. I feel like I'm personally excited to play with smart contract languages that are private by default.
00:20:12.660 - 00:20:27.632, Speaker B: Just to add to that, I think one of the other main differences is we have a standard library which is kind of bundled alongside Noir. So if we look at if my screens are still being shared here, this is an example of one of our highly optimized implementations that comes with Noir.
00:20:27.776 - 00:20:33.050, Speaker A: The screen is no longer being shared, but if you mind doing that, we can have that up for everybody else to see.
00:20:36.300 - 00:21:26.200, Speaker B: Give me 1 second. So this example here is just importing something from the Aztec Standard Library, which will be kind of audited versions of common cryptographic primitives. So we're doing a Shardy five, six hash here. So instead of developers having to go and write their own optimized versions of that, we're just bundling with the language highly optimized, efficient versions of common cryptographic primitives. So I think that's also useful for kind of keeping the complexity down and developers not having to worry about the efficiency of their Snark code, because in Snark programming, efficiency is measured in gate count, which translates to client proof of time. So you don't want users waiting for ten or 20 seconds for long proofs when it can be a five second circuit.
00:21:27.100 - 00:22:10.170, Speaker A: Amazing. The last question that we have here is a question kind of for me here, just to kind of better understand, maybe you can spend a couple of minutes on this thing. This is clearly a unique approach that you presented here for how a private roll up works. So if you have time, would love to understand how does this actually interface with existing DeFi protocols that are already on main net? And how do you think about how is it possible to bridge them? Whereas we look at other scaling solutions that require a different VM to exist and have a different version of those contracts over there. How does actually Aztec or ZkZk roll ups enable that to be a lot more seamless and kind of how are you getting the uniswap and the compound integration baked into the roll up service?
00:22:10.540 - 00:23:07.368, Speaker B: Sure. So with the November upgrade, we're taking kind of a layer one approach, I would say. We're going to batch transactions in the roll up and we'll kind of, as a group, relay those trades back to uniswap. And there's some discussion here around kind of minor extractable value. But the initial approach we're taking is instead of having to port an entire D Five protocol to layer two, which comes with its own audit risks and kind of just security risks, we're going to for very liquid markets. I think you can quite easily allow users to bundle trades together inside a roll up and have them all executed at once. And yes, there'll be some slippage in that but for smaller notionals the trade off between gas price and slippage for kind of end users is pretty worth it in our case.
00:23:07.368 - 00:23:27.280, Speaker B: If you're a larger kind of DeFi trader you can always decide to pay the layer one fees and go back to mainnet. But for smaller kind of consumer users and kind of bringing this to mainstream for notion was kind of around ten k. The slippage versus gas price that we think we can get should be sufficient.
00:23:28.180 - 00:23:42.750, Speaker A: Amazing. I am personally excited about 5000 gas cost transactions. I'm sure others are too here. So Joe want to thank you for doing this presentation and showing us a really cool demo of a private roll up service that's already available for people to test.
