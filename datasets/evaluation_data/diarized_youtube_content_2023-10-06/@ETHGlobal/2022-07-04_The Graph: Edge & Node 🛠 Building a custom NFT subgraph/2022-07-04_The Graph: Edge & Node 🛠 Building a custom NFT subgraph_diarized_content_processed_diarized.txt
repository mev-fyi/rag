00:00:06.650 - 00:01:03.810, Speaker A: Yeah, I think we start the thing is recorded, but I'm also around at the booth for questions later, so hi, my name is Simone. I'm a solutions engineer at the company Edge and Node. That's a core dev working on the Graph Protocol. The Graph Protocol is also a sponsor of this hackathon. We will look at the prices later, but in this workshop I quickly show you how to build and publish a customized and decentralized NFT subgraph. So yeah, Eva Bailin, the director of the Graph Foundation, once tweeted and said like, yeah, if you build an app for the community but you using centralized components just for your VCs or whatever, then you're not really building a DAP, you're just building an app using web3 stuff. Right, but the problem is really having a decentralized stack is quite challenging.
00:01:03.810 - 00:02:01.986, Speaker A: But I walk you through these steps. So the data storage of an NFT contract can be roughly be seen as just Google spreadsheet where you have like owners and then IDs and metadata and that's kind of the state of the blockchain. So you can always just query the blockchain, say who owns, let's say the first punk, but it's very hard to see who owned that punk before. You can do that by digging through the blockchain, but it's not easy. So that's what the NFT people call the provenance. So like, who owned it before? Yeah, and the blockchain basically works like this. So you send a transaction to the blockchain and then with that transaction you change the state of the blockchain and then eventually and then immediately you can read the current state, but you cannot really read what was going on.
00:02:01.986 - 00:02:57.278, Speaker A: So what you would like to have is kind of this time travel feature that we know from macOS, so that you actually have the same data, but you can actually go back in time and see how was it before? And yeah, this is actually what the Graph enables. I said that this is the problem with the DApps in general. So initially the DApps were kind of thinking about, yeah, we can have a user interface that is just HTML, CSS and JavaScript. It's deployed to IPFS, so it's already a permissionless storage and then it directly interacts with the blockchain. So everybody runs their own blockchain node on their computer in a fully decentralized manner. Time was telling this is not the case. And the biggest problem is actually the blockchain is right optimized and incentivized.
00:02:57.278 - 00:03:37.090, Speaker A: So by sending transactions to the blockchain you pay gas, and that gas the miners take. And so they kind of are incentivized to run that stuff. But if you want to just read data from the blockchain, then you start to kind of talk to the miners and say or to the nodes and say like, hey, can I know this data? And there is no incentivization mechanism to do so. There were like more than 1 billion queries per day on that hosted service. So that's quite a lot. And we are currently in the process of migrating all these queries to the decentralized network. So whoever has a subgraph on the hosted service and uses it currently, feel free to come to me.
00:03:37.090 - 00:04:14.346, Speaker A: I'm helping you to migrate those subgraphs over to the decentralized network. I also have t shirts and Poops for those who do so yeah, grab me. As I said, it's a decentralized indexing protocol. Yeah, animated there are like more than 160 actually indexes world it's permissionless. So these indexes, they are kind of independent, everybody can join. And through that you have this redundancy across the globe that your data is always accessible. If one indexer goes down, another one is there to serve your queries.
00:04:14.346 - 00:04:50.038, Speaker A: Also because they are across the globe, wherever your users are when they query the graph, then they will receive a response from an indexer next to them or like from index that can give a quick result. The queries are kind of they are fast, cheap and reliable. What changes, and it might be a little bit new is like now you pay for the queries. So that's why now the queries are incentived. So you pay a small amount for the queries. It's not that much, but it kind of shifts this power structure towards the users who you are only in control of stuff when you somehow pay for it. Right.
00:04:50.038 - 00:05:21.730, Speaker A: Otherwise we have kind of data miners and ads and stuff that try to make money out of it. Yeah. And so that's kind of the vision. We're going through this global, open, decentralized API and I would invite you to join and build on it. So this enables us to build truly decentralized apps. Yeah. So this is the rough overview kind of are there any questions about the graph on this level before we dive into the tech? No.
00:05:21.730 - 00:05:55.006, Speaker A: Otherwise we are around. We have a booth come and find us. So, what is a subgraph? So subgraph is kind of this piece that is at the core of the graph. You can think of it like as we saw before, the blockchain is kind of actually a mess. You have all these transactions for all these different protocols more or less on top of each other. Now, if you want to make sense out of it and see what actually happened with let's say sora, then you need to go through all these transactions and take the ones from Sora out and pull them together to make sense out of it. Right.
00:05:55.006 - 00:06:36.090, Speaker A: So that's what happens and that's why it's so slow. But what would be nice is actually if we have separated databases per protocol which store that data for that protocols in a way that you can easily query it. And that's what actually a subgraph is. So a subgraph is the definition of how do I want to have my database schema and how do I want to put data that we see from the blockchain into that schema and then it generates you automatically interface to query it. So in the end the lifecycle of a query or the whole thing works a little bit like this. On the top we have the DAP. We know that kind of just the front end HTML CSS.
00:06:36.090 - 00:07:45.890, Speaker A: It sends transactions to the Smart Contract or to the blockchain node, which Smart Contracts usually they emit events. So the graph node in the middle, it listens to those events on the blockchain. And when these events happen, they go through this mapping which is a WebAssembly module and the mapping makes sense out of these events and stores it into the database that we see on the bottom right. And then on the other hand side, like if the DAP wants to send a query on the left, then it goes to this GraphQL API that we saw before, a very nice Expressive Query Language to get that data out of the graph node. So this is roughly the system architecture. So because there was this NFT NYC and because it's a cool example anyways, let's see how an NFT subgraph would look like and we can also kind of build one together quickly. So like at the nutshell, the ERC 721 standard is just you have the transfer events that you see like which token moved from who to whom.
00:07:45.890 - 00:08:28.558, Speaker A: You have like this balance off function where you can check the balance of a certain address, you can check the owner and you have this transfer function that you can actually trigger transfers. So it's basically super simple. So we can look at this when you get into subgraph development, then here are some tips and tricks. When you write the Smart Contracts, you should be a little bit verbal with the events. Don't try to save gas there because you should later in the food in kind of making sense again out of your contract. Then with the subgraph development there are these Eve calls. So let's try to not call back.
00:08:28.558 - 00:09:31.650, Speaker A: Let's try to have all the data that you need in the subgraph in the events, so that can make the subgraph indexing much, much faster. You can create entities for important objects and concepts we'll look at later more in practice. You can store aggregation data on those entities like counts and stuff and link those entities together. So you can have more meaningful queries and also more explorational queries. And then there is kind of the Standards NFT standards WTF. It's a good resource but yeah, you can also ask me so then you can start to think about like okay, what kind of questions do I want to ask? What questions do I want to have an answer through with my subgroups? So for the NFTs kind of how many NFTs are there in total? How many NFTs have this trade X? Who owns which NFT? What's the provenance? Who owned it before. Is it available when we have on chain markets, what is the historic price, what's the current asking price and so on and so forth.
00:09:31.650 - 00:09:54.970, Speaker A: So you start to think about that and then you can come up with a schema. So this is a rough schema. How I would like model an NFT. So you have a contract that's the collection. It has accounts about everything and it links to the owners. Then you have the accounts which are the owners. You see the holdings which will also link to the NFTs where you have the token ID, the metadata Uri.
00:09:54.970 - 00:10:20.178, Speaker A: Then you have like the events. You would just store the events. Also like the transfer the Mints bid asks and sales if you have them, block number, block hash. You want to have per event metadata and trades if available. So let's do this. So first you install the dependencies. I created actually a small GitHub repo that's here.
00:10:20.178 - 00:10:50.282, Speaker A: I will also tweet that later. So that's here on my GitHub that you actually can follow the steps. It's also linked to this slide. So basically you install this graph CLI globally to get started and then you can be going to look at the hash Masks contract. So you can go to this to either scan you see that contract. So that's the hashmael. So we know the contract address.
00:10:50.282 - 00:11:44.538, Speaker A: But also what's interesting is kind of this start block, right? Because we do not want to start to index the blockchain from Genesis if we are just interested in a contract that was deployed at a certain amount of time, certain point in time and now this one, this is actually the biggest time saver, especially for the hackathon projects. If you want to quickly start a subgraph from an existing smart contract on Etherscan or on Ethereum or any other chain that is supported, not all of them are supported with this quick start. You can also do this if you can provide the Abi. It's a little bit more complex but we want to move fast here. So what I do is just run this. So what it does, it says okay, graph initialize me a new subgraph. I want to deploy it to the subgraph studio which helps me to deploy it to the decentralized graph network.
00:11:44.538 - 00:13:01.974, Speaker A: Then I kind of say like this is the contract address and this is the important one index events. So I want to have like a scaffold which automatically indexes the events and then I want to have like that's the contract name I stay with hashmask which network I'm indexing and then also the directory. So let's fire this. I did it before, now you need just me to trust me that this works because before it took very long to yarn install everything. So I was like maybe we can skip that. So that will be the outcome. So you have this thing here, let's make it a bit bigger is it big enough? So by looking at basically it's a JavaScript ish environment.
00:13:01.974 - 00:13:24.514, Speaker A: So usually you can start to look at with package JSON. So we see here we have some dependencies and some scripts predefined. So that's already good. Then the next thing that I look at is kind of the subgraph YAML here is defined like how the subgraph, it keeps it all together. It says like, okay, here are the data sources. You can have one or many. We see again.
00:13:24.514 - 00:13:42.870, Speaker A: Like it's? Ethereum mainnet. This is the address, this is the Abi. These are the entities. We go later to the entities. And then we also have the event handler. So this year 721, they emit these events like approval, approval for all name change. This is special for the hash mods because you can name them ownership, transfer.
00:13:42.870 - 00:14:05.114, Speaker A: This also because ownable contract and also the transfer event. So this is here. And then you say like, okay, and I want to run this in this mapping TS. But first we look quickly at the schema. This is auto generated. So like for every event, it automatically creates an entity. So despite that, this is kind of named schema GraphQL.
00:14:05.114 - 00:14:38.822, Speaker A: What this actually is, is kind of a database schema. It's not the exact GraphQL schema that will come out of it, but we will see that later. So everything has kind of an ID and more or less just whatever is in this event kind of stored. And then also we have in source mappings, we also have the boilerplate stuff. We have all these handlers. Actually the most interesting one is the handle transfer. So every time a transfer happens on the Ethereum blockchain of a hash mask, this handler is triggered.
00:14:38.822 - 00:15:23.578, Speaker A: And what it does is kind of it creates a new transfer entity. It creates this ID for it, which is just the transaction hash and the log index. So you have kind of canonical identification of that event and then you add those things to the entity and then you just save it. I mean, it's super simple, right? So you can check if everything works fine. You do Yarn code gen, which generates the boilerplate code here. So it creates these helper functions that help you to interact with the entities and also the Abi helper functions. All right, so this works.
00:15:23.578 - 00:16:04.802, Speaker A: I can check with Yarn build if I actually can build it on my local machine. Yeah, okay, cool. That works, right? So here it has created the WebAssembly files that I can now upload. I can go here to the Graph.com studio and yeah, I'm already connected. So you connect with the MetaMask. I can go here and say like and indexing Ethereum Mainnet and yeah, you're already here.
00:16:04.802 - 00:16:53.684, Speaker A: And then I can only do this I only need to do this graph auth and then Graph deploy. We need to give a version. And then it creates again these WebAssembly files uploads it to IPFS and deploys this to the studio. The Graph Studio is kind of a centralized service provided by Edge Node for you for easily develop subgraphs. So you see it's kind of deployed already. So I can quickly refresh here and it should index. So it already starts to scan.
00:16:53.684 - 00:17:55.710, Speaker A: See, we can see here the locks and we can also see here that it didn't sync yet. All right, it will take a while, but that's okay because oh, I forgot to add the start block. So if the start block, it actually it indexes quicker. Cool, I change this and then I can just redeploy and I probably need to give a new version and that should be quicker going back to the presentation. So this was just like the super quick start of getting started with the Graph. Now we have kind of just all the events stored in entities, but you probably want to do more complex stuff. So I'll show you some patterns.
00:17:55.710 - 00:18:24.150, Speaker A: So you want to store these Immutable events. That's actually what we did. Like events are typically Immutable events, immutable entities, because they are just happening once and you do not want to change an event after that. You just store it. And I also think about a little bit about events as the low level entities. On top of that, you start to build more interesting stuff like the actual accounts, the actual NFTs which you can derive from that event. So you have an account, so you see an event.
00:18:24.150 - 00:18:43.366, Speaker A: So you basically see an event. It's a transfer. And by seeing the transfer, you can see okay, from who to who was the transfer. So you have already two new entities, namely two new owners. And then you can just start to count up and down. So these are kind of the little bit the highers. But for the events, I would go with Immutable.
00:18:43.366 - 00:19:10.626, Speaker A: So this is the pattern for it. You can have those get or create owner helpers because you often want to get the owner or want to get the token or whatever. And it's always a little bit the same. If you see it for the first time, you want to create it. And if you have it already, you just want to load it and maybe add something to it. And in the schema you want to link the entities. So here the contract and transfers are linked.
00:19:10.626 - 00:19:53.186, Speaker A: And also you have the aggregation entities where you store counts. So for example, Uniswap has aggregation entities, so they store one line for every day and then just start to do these counts so that in the end they can display their charts. Yeah, before we go back to the code, there are two categories of prices from the graph. The first is like best use of existing subgraphs. This is in my opinion, a little bit easier because you can just go for example, to the Graph Explorer and then you look at an existing Subgraph. You have very cool subgraphs here. So maybe this one is cool.
00:19:53.186 - 00:20:30.746, Speaker A: The 721 Marketplace is one that indexes all the NFT sales actually. So you can go here and start to send your queries. You can start to explore how it is set up, which entities you have, which things. You can just start to query it and can use the endpoint to start to query. So this is a little bit easier. You don't need to learn Subgraph development and you already kind of have the same price as for the new subgraphs. So, kind of a trick.
00:20:30.746 - 00:21:01.798, Speaker A: If you're a good front end developer, this is a cool track to get some prize money. The other track is the best new Subgraph. So here we expect you to write a new Subgraph and we look at complexity, innovation and that kind of stuff. So, again, we have a first, 2nd, 3rd price. If you want to get some bonus points, there are two stuff that you can do. So use the decentralized graph network. That's what I showed you here.
00:21:01.798 - 00:21:31.726, Speaker A: If you go to this Explorergraph.com, there is also the hosted service, which you can still use. But if you use the decentralized network, you will get bonus points and also by using substreams. So, substreams is a very new technology that we recently announced at the Graph Day in San Francisco. And it's actually kind of a new paradigm to write subgraphs. There will be written in Rust. The technology is very young, but it's very powerful.
00:21:31.726 - 00:22:00.534, Speaker A: So if you're into Rust and into indexing blockchain data, or kind of trying to stream blockchain data, think about to make your hands dirty with substreams. And that would be also kind of a big bonus point. So, like, if you're writing a Substream, you will be very high up for this. Best new subgraph. Yeah, so this is my Twitter. My DMs are open. You can write me on Twitter or you come to the graph booth.
00:22:00.534 - 00:23:07.694, Speaker A: Or there's also the discord channel that you can go in. And now we can try to see if yes, if that had started to index. Yeah, already that's cool. So see, we see, for example, like, we can check the approvals and we already have approvals here, or we can check for the name changes. We can see which are the recent name changes that we saw from the hashmasks. So this is just given by just indexing those events in my GitHub repo that I linked here, I was actually going further of then removing unused entities, extend the entities and write more stuff. Create these logical entities on top of it.
00:23:07.694 - 00:23:54.014, Speaker A: And you can all kind of start to look into this. So there's the schema, how it looks like later on. And there is kind of a mapping how it would look like if you really go through those steps. But you saw my goal for this presentation is just to say to you look with the graph init command, you can very quickly spin up the subgraph. It already kind of gives you very good insights and from that you can start to explore the stuff. And if you have a very cool subgraph on the Decentralized Network on Ethereum Mainnet and you want to publish it to the Decentralized Network, then you can click here on Publish. You say where you want to publish and then you can do it in Rinkabee if you want to just test it out, or Mainet if you wanted to do it.
00:23:54.014 - 00:24:37.028, Speaker A: And then you can do this and really be part of the decentralization movement. Yeah, that's the finish. The end of my talk. Are there any questions? Yes? No. Publishing. So by publishing you should signal ten K GRT on it and then just the on chain action is probably around 0.5 e or something like that.
00:24:37.028 - 00:25:11.370, Speaker A: It's not super crazy. And for the GRTS, for the initial signal you can actually reach out to me or to the graph foundation. So we help you bootstrap this other questions? Cool. Thank you so much for your attention. I bring my thing here again and happy hacking. Thank.
