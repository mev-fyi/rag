00:00:07.850 - 00:00:34.310, Speaker A: Is everything cool with Av? And pick me up on the microphone. Okay, cool. So I just want to say it's great to be back in Prague. Five years ago, I started my journey in crypto. I'd started at consensus a couple of weeks before. They had a Pegasus offsite the week after Devcon. So it's kind of coming full circle for me to kind of talk about some of the things that are on my mind about censorship, resistance.
00:00:34.310 - 00:01:26.694, Speaker A: So I'm going to talk about mind your own business, state prison, transaction verification, and then what on earth does this have to do with parallelism? And we'll get to that, but first, a little bit of context about what mind your business is and what I'm going after with that. So this is a picture of something called the fujiocent. The fujiocent was the first currency circulated by the US, not the first currency minted by the US mint, but the first actually circulated currency. And there's a lot of trivia and a lot of coin information that goes with that. But what's interesting to me is this little logo, this little model put on the bottom of mind your business. It's something that Benjamin Franklin was really excited about, and he was sharing with people that you should always mind your business. And it's kind of a strange phrase that had a lot of different implication 200, 300 years ago than it does today.
00:01:26.694 - 00:02:05.410, Speaker A: Because when you hear the phrase mind your business, usually what you think of is mind your own business. And that's what people tend to worry about when they talk about censorship, is they're worried about cameras and the government and everyone looking into things that, quite frankly, don't matter to them and minding things that just really, they shouldn't be caring about, and then being invasive and looking into all those things. And people want privacy in this regard, so that what they do in private stays private. So when you hear the phrase of mind your business, you sometimes put in mind your own business, saying, stay out, stay out. This isn't you. This is kind of an outside in looking view of it. And honestly, the government is not the worst version of this mind your business situation.
00:02:05.410 - 00:03:08.182, Speaker A: I think surveillance capitalism is probably a bigger impact of this whole mind your own business situation, where you got people who are companies who are building these giant data centers to collect all of this data and to combine it together and to figure out whether it's better to sell you an ad on a cookie or an ad on a car, and they're using all this massive amount of information to do it. But when I think of mind your business. I actually think of a Netflix series called inventing Anna. And there's a very pivotal scene in that where Anna, this woman who's trying to do a confidence game on high society in New York to build her dreams for an art studio, keeps getting kicked out of hotels and keeps know she doesn't have the money, but she's living like she has all sorts of money. Another character named Neff is one of the concierge of one of the hotels that she's worked living in. And Neff is one of her closest friends. If she has friends that really understands, because these two, they recognize people that have hustle in their life, recognize people who are making things happen.
00:03:08.182 - 00:03:45.406, Speaker A: So when things are starting to collapse at the hotel that Neff works at, she gets Anna to the side for a moment and she tells her mind your business. And what she's saying. There is something not about don't stay out of my business. What she's saying is take care of your business. You have bills to pay here. You need to pay them because things are ending. And I think that's really when we talk about mind your business, we're talking about taking care of your business, taking care of the things that you need to worry about, being able to pay your bills, make sure that your checkbook balance is properly, make sure that your bed is made, make sure that your car is running properly.
00:03:45.406 - 00:04:15.180, Speaker A: And these are the things that we really need to worry about. In a censorship resistance world, it's less like, can I still do the things that I need to do? And that's kind of the counterpoint to privacy. I need to worry about it. Do other people need to worry about it? Well, I don't know if other people are going to worry about it, but I need to take care of my stuff. So this brings us to the dark side of scalability, which is kind of the direction that things are starting to go. And this is a problem related to success. It's probably one of the better things to happen to Ethereum, but it's still a problem.
00:04:15.180 - 00:05:14.562, Speaker A: Let's take an example of getting paid on chain. Let's say you're a box packer or a barista or a high school teacher, and in the future you've been moved to having your payments happen online. If you want to prove that you've been paid, if you want to prove that the contracts have executed properly and that everything is there, you either need to don't run the execution and just hope everyone's analysis of it runs or you need to execute it yourself, and execute it yourself. You need to run every previous transaction that leads up to that, to prove that people had the balance, and then when they had the balance, that they took the balance, and then they paid you and all of the other various side effects of that. So to calculate all this information and get all this information, it takes a rather beefy computer in the cloud to calculate all of this. And typically to run a node, you need something like four cores, two terabytes of hard disk, 200 gigabits of bandwidth, and 300 I ops. And that's not something that a high school teacher is going to use their salary to spend on, just to verify that they can get paid.
00:05:14.562 - 00:06:03.070, Speaker A: This is a problem for broader and wider adoption of crypto. We want people to fully participate in the censorship resistance, and it's no more truer than Polynia, who yesterday posted a post just yesterday, and I'm just going to read what he said because, or she, I don't know if it's a here or she, but what they said was very insightful into the problems that we're having with these growing nodes. They said, the more transactions the network processes, the higher everyone's hardware requirements. The more nodes in the network, the more inefficient and slower it becomes. Or alternately, you limit accessibility. So very few people in very few places can run unsubsidized, independent nodes, effectively leaving to a dystopia that is infinitely more centralized than traditional finance. And I like to call this censorship by wealth.
00:06:03.070 - 00:07:00.126, Speaker A: If you are not rich enough, you cannot participate in a system. And this is kind of the opposite of a lot of the enablement that we've been going for in ethereum, to make sure that everyone at all different levels can participate in their financial freedom. If this goes unbounded, it's going to be more effective than banks ever could have done. So how can we address this problem? How can we solve this? How can we make sure that you can mind your business in the entire world economic system without having to process the world's economic systems? That's where state proofs and transaction verifications come in. State proofs are a witness of the block to say, here's what was happening before, and here's the data that you would need to prove it. And transaction verification is actually running these blocks and proving the verification we have there. So instead of drinking from the fire hose while the world burns down, it's a small drinking fountain in the park, providing the refreshing water that you need to run just your transactions in your blocks.
00:07:00.126 - 00:07:35.914, Speaker A: Typically these things include the minimum things like a header, the block header that you're verifying for the block. The accounts that were read to or written from, read from or written to. The contract storage that was read from or written to. Any intermediate tree nodes that are needed to calculate the state route to prove that you have a consistent state, the code that you need to execute. And maybe in some situations we might need to include some prior block hashes, depending upon which operations you execute it in. And if all those things are in a state proof, then you don't need those giant machines in the cloud. You could verify this block with a phone that you keep in your pocket.
00:07:35.914 - 00:08:04.898, Speaker A: And I'm not even talking a high end phone. This could be like the $99 special that you get out of Google Fi. With this sort of information, you can verify your transactions occurred in a much more reasonable system. There's a problem though, is that we don't have it today. And why don't we have it today? The problem relates to our current Merkel Patricia tree. Our Merkel Patricia tree. If you've seen the typical images of it, you'll see a nice cute binary tree with maybe five levels and really small consistent proofs.
00:08:04.898 - 00:08:30.480, Speaker A: But the reality is these trees are 16 nodes wide. They're often 30 layers deep. And for a block proof, typically it takes up to a megabyte. Bad block proofs will take up to two megabytes. So we can do this today, but we can't do it in a way that can be efficiently be spread worldwide for transactions at scale. And this is, by the way, at about 12 million blocks. 12 million gas blocks, 15 million gas blocks take more.
00:08:30.480 - 00:08:53.366, Speaker A: 30 million gas blocks are going to take even more than that. So this gets worse and worse. The good news is there is a solution that we're working on to address this size problem. And it goes by the name vertical trees. There's even an eip for it. So we take these big 16 area blocks and we compress them into witnesses. So instead of needing 16 values to prove that your next step of the block is true, you only need three.
00:08:53.366 - 00:09:31.474, Speaker A: You need to know where you are in the parent commitment, you need to know what your value is, and you need to calculate a special little thing called a proof. I don't fully understand the math into it, but I know that the side effect is it takes what used to take kilobytes into a matter of tens of bytes. So vertical trees are basically a tree of these vector commitments. What's even better about this is if you look at some of the details, it fixes the side problem because rather than being 16 wide, these things are 256 wide. So we even make the tree shallower. In addition to having smaller leaves, you have less leaves and smaller leaves. And we're packing everything into this tree that we need.
00:09:31.474 - 00:10:12.750, Speaker A: We're packing all of the account state, we're packing the code, we're packing contract state and known state. These things are going to be in the vertical tree and they're going to be available and accessible in a much smaller system. And from this we can reasonably, as part of the protocol with every block, send out a proof in something that takes kilobytes instead of megabytes. And this will allow us to scale. We've almost made it. We can almost do it today. But what happens when we grow? What happens when we have billion gas blocks? What happens when we have transactions on the scale of visa on one chain and one network? So this is where parallelism comes in.
00:10:12.750 - 00:10:44.506, Speaker A: And when people talk about parallelism, this is kind of a topic on twitter that people talk about. But I think there's a stealth way that we can use parallelism to help solve these issues. And when we talk about parallelism, there's like three layers of places we could put the parallelism. And I think we've only really touched on one or two of them. The first I term prefix parallelism. This is where before you submit your transaction, you put information into the transaction that you think might be useful for parallelism. You might use access lists to say, hey, I'm going to be accessing these storage slots and nothing else.
00:10:44.506 - 00:11:17.234, Speaker A: And systems can use that in their transaction to schedule so that you won't have conflicts. And another version of parallelism that's been out for years is called sharding. Instead of doing everything in one block where we have a billion gas, let's have 1000 1 million blocks and split it up into smaller shards. Sharding is actually a parallelism solution when you look at it. What people are working on today is what I term infixed parallelism. This is where you take parallelism into the execution of the block stuff that Monad is working on. There's so many m words.
00:11:17.234 - 00:11:55.710, Speaker A: I want to call them modular. But Monad's working on a solution that they borrowed from diem, which then became apptots and something called block STM, where they're taking the execution of the block and they're using optimistic concurrency control to just execute it in parallel. And when things go wrong, they re execute it with a new information. And they've also introduced another interesting idea that I'll come to later in the talk called delta writes. Instead of writing value goes from one to two, just say value increases by one. And that's a parallel optimization. That's something that's used in a lot of parallel systems to make sure that the impacts don't collide.
00:11:55.710 - 00:12:43.386, Speaker A: But I think the most interesting area of parallelism can be applied in what I call post fixed parallelism. This is where you've executed the transaction, and you know the details about the transaction, and you apply information to your output to say, here's how you can execute it in parallel. So you might notice which transactions conflict. And you could put metadata into the transaction receipts to say these transactions conflict and must be done in a certain order. And from this we can identify something that I'm calling a compatible transaction group, where you have groups of transactions that can be included or removed, and all the side effects will be the same regardless of how many of those that you evaluate. Now, I've been thinking about parallelism for a time, and here's a tweet just from just July, but I've had graphs for this parallelism stuff for years. As Tim could attest to, we had a little thing in consensus.
00:12:43.386 - 00:13:21.370, Speaker A: We were thinking, how could we parallelize this? And the problem is actually with the database back four years ago, why I didn't go into parallelism. But it's interesting we should talk about databases, because when you talk about database transactions, there is a famous acronym called Acid, which talks about four characteristics that any database transaction needs. And these database transactions are always done in parallel. They're always distributed, they're always done with bunch of people at the same time. The first concern is atomicity, that what you do only succeeds or passes in one group. The second is consistency. The work that you're doing won't cause problems in the work someone else is doing.
00:13:21.370 - 00:14:02.220, Speaker A: This is important in issues like in larger data collections to make sure that when you add to a map, that you're not going to make the map have a self referential loop. The third is isolation, and that your transaction only interacts with its own world and doesn't need to worry about anyone else. And the final one is durability. Is this actually stored in the database? But of these four principles, I think the most important one to parallel transactions is that of isolation. We can take our transactions, we can isolate them from the other transactions in the block. And if we isolate them, we only need to care about the transactions that you put in there. And you don't care about the other 999,999 transactions in this million transaction block because you can identify the consequences that come from this.
00:14:02.220 - 00:14:48.882, Speaker A: And as ETH, as one of the replyers said, you know what sounds like a topological sort problem kind of is. So here's a simple seven transaction block. You can see that some of them have dependencies and some of them cause dependencies. If we wanted to just worry about our transaction, if we don't conflict with other transactions, it's easy. We can just allied the other six transactions from our block witness just evaluate ours and be confident that our side effects will be seen. Gets more tricky, though, if we're downstream from other people's transactions, if we want to make sure that our side effects are consistent, we need to see other people's side effects. So this is what building parallelism into a protocol would do, is it might identify these conflicts.
00:14:48.882 - 00:15:44.854, Speaker A: You can efficiently get your transaction groups that you would need to evaluate to make sure that yours is true. And another one, we don't even need to worry about other people as we go downstream. If there's a transaction that impacts multiple people, you just care about what your ancestors are. And again, if you're just the upstream transaction, you don't care what the side effects of the downstream are because you're only concerned about your own side effects. But I think the holy grail is the situation where, yes, you do have transactions that have changes before you, but that you can not care about them, that you can get the necessary information in the block to make sure that if you evaluate just your transaction, that the side effects are going to be true and correct in everything that you evaluate to make sure that you can verify this transaction. One of the steps towards this is an EFP proposed a couple of months ago that brings in the s credit and s debit operations. And this is basically bringing delta rights into Ethereum.
00:15:44.854 - 00:16:37.100, Speaker A: Instead of writing that we're going to set block one from 100 to 200, we're going to say we're going to add 100 to block one, and we're going to take 100 out of block two. So this allows us for a situation where to allow us to prove more interesting things like say, let's say Alice has 200 coins and there's three transactions that affect Alice. 100 is sent to Bob, 100 is sent to Christy, and Dave sends her 300. So from that precondition that if Alice has at least 100 coins, you can do any of the next three transactions in any order, you can do any of the three transactions, you feel like you can do all of them, you can do one of them, you can do two of them, and all the side effects in those three transactions are all going to be the same. This is the power that parallelism, postfix parallelism can provide for us in transaction verification. If you can prove these ranges and also saves a tiny bit of gas, the gas golfers are going to love this. So it might be easier to get this in than we think.
00:16:37.100 - 00:17:11.490, Speaker A: So from this we can produce groups. In the protocol of compatible transactions, we can identify sets of transactions. And here's my definition. It's a set of transactions where you can have the transactions in a set done in any order, and also you can evaluate any subset of the transaction within it, and the side effects of those transactions are all going to be the same. So you can have some one or all, and you can do them in any order. And if it's in a compatible set, then it doesn't matter what you do there. Now combine this with a ZK validity of the block proof.
00:17:11.490 - 00:17:42.490, Speaker A: We can align almost all the other data out of the block proof and provide this to someone and say, hey, I paid you. And here you can evaluate the transaction, and here you can observe the side effects. And with a feature like this, this is going to allow us to mind your business, mind all of your business, as you only have to mind your business if that's the only thing you care about. So again, this is my vision for how transaction verification can really help resistance to censorship by wealth so that everyone on any device can verify that their transactions were part of the Ethereum chain.
