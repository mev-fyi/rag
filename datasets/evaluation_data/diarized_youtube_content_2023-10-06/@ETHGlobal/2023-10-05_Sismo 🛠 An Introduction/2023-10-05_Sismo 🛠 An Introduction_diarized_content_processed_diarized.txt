00:00:07.610 - 00:00:55.558, Speaker A: So I'm Leo. I'm from Cismo. And so today we are going to do a workshop. So there will be very few presentations, but more like trying out a bit, our tutorial, our Gorilla Plate and stuff like that. So I hope you enjoyed. So at Cismo, what we do is that we leverage zero knowledge proof to enable users to aggregate their identities and selectively declose some piece of personal data directly to applications. So here we can see we have zero x one and zero x two, and we are able to aggregate this data, generate a zero knowledge proof of some small piece of personal data inside it, and bring it to an application with a single sign on.
00:00:55.558 - 00:01:47.150, Speaker A: So SSO Flow, I'm going to do a demo right now so you will more understand how it works. So for a bit of context around this demo last year, what we have done is we have printed a code of Tornado cash with a two meter high artwork. So it was a physical painting. Two months ago, it arrived on Twitter and people asked us to have it and to have a version of it. So what we did is we did a lottery to be able to gain this artwork. The problem was, okay, we wanted to gate this lottery only to users of Tornado cash. But when you use Tornado cash, you can deposit and withdraw a lot of times, so it's highly uncb resistant.
00:01:47.150 - 00:02:35.866, Speaker A: So we decided to also add a way to have CB resistance to enter this lottery. We use Gitcon passport for that? So Gitcon passport is a way to connect your Twitter, your GitHub. So it's a bit like Doxing, because all happened in your public identities and it analyze your activity. Basically the commits you have made, the tweets you have made, and based on that, it will give you a score of CB resistance. And for instance, a score of 15 is a good score of CB resistance. Let's say I am human. So here, this Mo is a very interesting use case because you want to prove that you have used on ado cash with a very private wallet.
00:02:35.866 - 00:03:02.174, Speaker A: You don't want to reveal at all, and you want also to prove that you have a Gitcoin password. So basically that you are CBL with your very public wallet ENS. And so using Sysmo and Sysmo Connect, you will bring these two data without revealing the address that was used behind. So let's go to the demo. So we have what we call the App Store. So. It's apps.
00:03:02.174 - 00:03:40.310, Speaker A: Tismo IO. You can go there and try it out. You click on Demo here, and here you can see the lottery registration. So basically, this is the application, lottery registration. To be able to enter, you are going to do SSO flow sign in with ISMO and requesting data from the user to be able to enter the two data we request. Here is okay, I am well, a tornado cash ethereum depositor on Mainet and I have a Gitcoin passport with a score more than 15. So I do sign in with Cismo.
00:03:40.310 - 00:04:15.706, Speaker A: I'm redirected to my Cismo data vault. So the Sysmo Data vault, it's like a password manager when you import all your different accounts. So this one is a demo one. So we can see here there is a lot of accounts that already have been imported. I can show you mine, my real one you will see. So I won't do all the one because otherwise I will DOX myself. But you can see I have a lot of accounts and I import them just once, like in password manager, in one password, for instance, you import your different accounts when it's imported, it's linked to your vault.
00:04:15.706 - 00:04:57.786, Speaker A: And in Sysmo data vault you have what we call the vault secrets that you will be able to use in zero knowledge proof to prove that you own these different accounts. So thanks to that, you will be able to prove to application that you own your different accounts if you want. And we will see this later how to use a devex to request some proof of ownership of different accounts. But you can also do some membership. Basically, what is this membership? You have groups of all the accounts that have exactly the same characteristics. For instance, here you have the tonadogash ethereum depositor groups. If we see the content of the group, it's all the depositor on mainnet.
00:04:57.786 - 00:05:49.518, Speaker A: So it's basically all the accounts that have made this action. So what we are going to do is that we are going to prove in zero knowledge proof here. So all happened in the browser that we own an account that is inside this group and we are going to send back this proof to the application that will verify it, verify it off chain or on chain. If we take the Gitcoin passport, it's exactly the same. So you have the group of all the Gitcoin passports and we can see here the content and there is a particularity is that it's a key value data group. So the key is the account and the value is the score of your Gitcon passport. And what is interesting here is that you can do predicate or statement around this value the application can request and this is what's happening here.
00:05:49.518 - 00:06:28.836, Speaker A: That okay, you are part of this group, but also you have a score that is more than 15 and the application won't know exactly which score I have inside. But the application, we know that they have more than 15. This is just what is interesting for the application. So I do generate ZK proof. The ZK proof is generated, it's sent back to the application and I can verify my ZK proof and I will be able to enter the lottery. So here the flow. The verification happened off chain, but it can also happen on chain.
00:06:28.836 - 00:07:10.630, Speaker A: We have a solidity library that we can call to verify the proof. So we have what we call the factory. The factory is a UI dev tool that enable to browse the different data groups and create data groups. So data groups here are very important because it's a source of data you will be able to use inside your application. So we can see here for instance, that there is around 1000 groups that have been created. So you can go there, it's all open and you can search. For instance, the gitcoin passport one is here.
00:07:10.630 - 00:07:41.804, Speaker A: We can see the last generation, the next generation. The groups are snapshot groups, they are run at daily frequency. And you can choose basically the frequency you want for your group to refresh this data. I will show you how we can create new data groups. So you can do all in the UI tool. Also you can do a manual group. Like basically you just put your addresses, your list of addresses, or you can use what we call data providers.
00:07:41.804 - 00:08:19.108, Speaker A: Data providers are just a way to fetch data from the outside world. So for instance, here we have a lot of data providers that have been made by the community. Also you can also code your own data providers that will appear here for all the other developers. So we can create a group together. I propose that we use like the GitHub one. Here you can see the different accounts we have. We have like web3 accounts, but we also can have like GitHub, Twitter or Telegram accounts.
00:08:19.108 - 00:09:10.490, Speaker A: So basically, if we do a group of all the GitHub contributors of the repository, you will then later be able to prove that you are part of this group without revealing exactly who you are. So basically, you can import your reputation from your web two activity in this example, or bring some web two activity and web3 activity together in one proof. So here we can take for instance, let's take the foundry one. So it's an interesting one, I think. There is no group for this one. So you just need to put here the repository. So here we know that there is 274 accounts that contributed to foundry.
00:09:10.490 - 00:10:13.434, Speaker A: You just continue. So here you need just to put a description and specification around your data group so other people can search for groups and reuse them for their own application. So when you create groups, you just bring data for all the other people to be able to generate zero knowledge proof out of it. So let's say data group of all the contributors to foundry. So data groups of all committers to the so in the specifications. What is good is to put the very more precise one like to put all committers to the repository. Okay, so let's say foundry, GitHub contributors, data groups.
00:10:13.434 - 00:11:13.198, Speaker A: Here you specify the frequency you want. So either once it will be computed just once or weekly let's put daily because then we will have updated data each days here public information is to be able then to contact you if we want to change the group or whatever. So I will put mine because I'm the one that did the group and let's go. Okay so you see your group is being created. What happened here it creates so the factory is a UI tool on top of the Sysmo hub which is a repositories that contain all the infra that computes all these groups and put them in merkel trees in what we call posaden merkel tree to be able to use them inside zero knowledge proof. So it computes all these merkle trees, send the root and chain and then it's available for everyone to be used. Here what happens.
00:11:13.198 - 00:12:26.920, Speaker A: So you can see the code you can directly code your own groups by hand as a developers and do really more complex stuff like using multiple data provider together, computing some score around it and trying to normalize stuff whatever you want once we have this group so we can do zero knowledge proof out of this group so what will happen here? It will be automatically checked. If all is good then it will be merged automatically and when it's merged it's deployed. For instance we can see an old one. So you will understand for instance if you see today there was this group that was created and so here we can see that the group is generated, the merkel trees are created and then the root of all these merkel trees are sent on all chains and then they are available to be used in Cismo Connect. While it's generating and deploying. We are going to effectively use Cismo Connect through an app. So we have provided some boilerplates for that.
00:12:26.920 - 00:13:04.530, Speaker A: You can go to stocks, Cismo, IO and we have here all the sections built with Cismo Connect. In the overview you will see so exactly what I demoed you. So you have a button you need to forge the request you want to do for the user. So basically you will say okay, I want this. He is part of this group, this group and this group. The user generates his secret proof in his browser. Send back the ZK proof to the application, your application and you can verify it off chain or on chain.
00:13:04.530 - 00:14:03.166, Speaker A: Okay, sorry. So if you go to the installation here we have a create systemnect script that will basically set up all the different bowl plate we have. So let's start running it. What is the name of your project? So let's say workshop. So when you start the script asks you for an app ID. What is an app ID? It's basically when you create an app on top of this mode it's like when you do connect with Google you need to register your app so the prover part will allow only your front end to be able to request data from the user. So it's for security reason, basically.
00:14:03.166 - 00:14:37.880, Speaker A: So you create your Cismo connect app. So it's very easy. It's permissionless, you just need to go to the factory again and to create your Cismo Connect app. So let's say is global workshop. So it's fun when you add a picture and authorized domain. So here you can put like localhost to test in localhost. And then once you deploy, you can update it to add the authorized domain for your app.
00:14:37.880 - 00:15:05.854, Speaker A: And by creating this app, you will have an app ID. So this app ID is the one you will put into your piece of code. Like when you install the front end and Sysmo Connect button and the Sysmo Connect Verifier. Okay, so you put your app ID here. It reconnects it. And let's start by the off chain. So we have an off chain and an unchained border place.
00:15:05.854 - 00:15:37.820, Speaker A: So you can do what depending on your sorry. I am so sorry. Is it better like that? Thanks. So let's go to the off chain one to start. So it will set up a next JS application with Cismo Connect installed in it. Okay, let's go to workshop. Yarn dev.
00:15:37.820 - 00:16:24.810, Speaker A: So here you will see, okay, you have the front end, you have your button, and this is what is used to request your ZK proof. You have the Cismo Connect config where you have your app ID and the different data you want to request. And then you have your API, your backend to verify the proof. Okay? So when you launch it, you will arrive on a very simple front end that you can modify to just do your needs. But here you can see what we are going to request. So we are going to request authentication. So it's basically proof of ownership of an account and claim requests that are basically proof of membership into a group ID.
00:16:24.810 - 00:16:58.070, Speaker A: You can see the different group IDs here. So you can see when we click, it goes directly to the different Group ID. Sysmo app contributor. For instance? Okay, we do pro resismo generate ZK proof. So here you have like six different ZK proofs. So it takes a bit more time in the browser to run it's around 2 seconds by ZK proof. So if it takes a bit of time, it was pretty fast verify.
00:16:58.070 - 00:17:30.822, Speaker A: Okay, then it's verified. So it calls the back end and verified the result and prints the result here. So then you can use them to do whatever you want, store it into a database or whatever if you want to update. So let's try to update it. So here you can see the button. It's very easy. You just need to put your config sorry, just need to put your config with your app ID.
00:17:30.822 - 00:17:55.850, Speaker A: And here you can impersonate accounts. You have your app ID that was automatically filled. And you have here the accounts that you can impersonate. So you can change this to say. Okay, so we use foundry. Let's impersonate const. Which is Georgia's.
00:17:55.850 - 00:18:49.916, Speaker A: Okay, I think I think I did a mistake here. Okay, so we do again your proof of resismo and we can see here. So we have our ISGlobal pari workshops. I discovered the app ID and changed here the impersonated account. So now I use const. Let's go see our group how it goes. So it's been sent on chain, so yeah, it will be ready in around two minutes I think.
00:18:49.916 - 00:19:18.504, Speaker A: So during that time it sound. Let's try to set up the maybe unchained border plate. So we will have the unchained one. So we are using Foundry for this one. So I don't know if you are very familiar with Foundry, but we also have a package for RDATs. But we advise you to use Foundry and we have these boilerplates that are all well set up. So I think it's a good reason to start on Foundry directly if you want.
00:19:18.504 - 00:20:27.816, Speaker A: And it's really like a ten x tool when we compare to the old adat. So I really advise you to do it. Okay, so we start again the Create systemo Connect app. Let's take again the sysmo app ID. So we have this one and we take the unchained one. So in this border plate you have a font folder where you will have a next JS application with all Wagme and VMs that will be able to allow you to call directly your contract. And you have a SLC folder here with AirDrop Sol that is using Sysmo Connect to verify the proof.
00:20:27.816 - 00:21:15.550, Speaker A: So it's very easy, you just have to put it here and to import it from this library. So all this is in the documentation also. So in the installations part, then you have a claim with Cismo function where you will have the Sysmo Connect response that you will be able to verify regarding the data you wanted. So you need between the front end and the back end or here the smart contracts you need to have exactly the same request, otherwise it will fail because you request something and you verify it, but if it's different, it does not correspond. Basically it's like a signature. When you do a signature, you verify your signature against a specific message and you verify that your public key corresponds to this verification here. It's exactly the same.
00:21:15.550 - 00:22:06.996, Speaker A: So let's go to we don't have a lot of time, so I'm going to modify it to just put our new group ID and to use an authentication of type vault. So I will explain you just later what happened. So we are going to say, okay, I want to verify a claim request from being part of this group. So let's go on our so it's almost finished. Okay, let's go to browse our groups. Okay, so our group is here, we can see the content of the group. So we have all the contributors.
00:22:06.996 - 00:23:20.630, Speaker A: Our gear consists here so it will work in the value the data providers was developed to put the number of commits you have made. So then here it's interesting because we can do request of having done like more than 50 contribution into this repository. We take the group ID here and I can put it directly there. Um, now if I go to the button part so we are looking for the Sysmo connect button here we see our config where we have same so our different impersonator address. So let's change this one to have the GitHub and let's change our request. So here we have our authentication request and our claim request so we say we need to have exactly the same between the font and the smart contract. So we put a vault.
00:23:20.630 - 00:23:49.734, Speaker A: So here let me explain you the vault. We have created an app and we are doing zero knowledge proof from a user to an application. This app has an app ID. This app ID is a random number. Basically, inside your Sysmodata Vault, you have a secret that is stored in the browser in the Sysmoda Vault. Let's use the password manager. And if you hash in zero knowledge proof this secret with the App ID, you will have a unique number the Vault ID that will identify you to the application.
00:23:49.734 - 00:24:55.560, Speaker A: This vault ID is very important because it can be used as a nullifier for your app. Let's say you do an AirDrop, you can just store this vault ID as being used and the user won't be able to claim again his AirDrop or on off chain. You can use it like you bit more as a user ID into your app and it's like an anonymous user ID but you will be able to authenticate each time and you don't need an email or I don't know or whatever. So let's go do here just verifying this is okay, I think this is almost done. Sorry the group ID is here and here we go. Okay so when the create Sysmo connect app has launched it say you need to launch local chain. This is just so you can deploy your contract easily and don't pay each time on your local chain.
00:24:55.560 - 00:26:01.580, Speaker A: Sorry I need to go to the unchained foundry and launch my chain and same here I will go to the front end and do yarn dev. So all should be explained here, I don't know why. Okay, so all here should be explained. When you run it you have all the explanation on what to do exactly here. So let's go to our new system connect it's because I have the off chain one sorry so I will launch it again. Okay, so what happened? When you launch the front it will also deploy your contract into your local chain and each time you modify your contract it will redeploy into your local change of contract. Okay so here it asks me to connect my wallet.
00:26:01.580 - 00:26:26.344, Speaker A: Ask me to just I need to switch. Sorry. Okay, so we say I am in this local chain. I'm connected with my account. I do claim with Cismo. I see that. I request only ownership of my vault ID here.
00:26:26.344 - 00:27:18.920, Speaker A: It's my random number that will be computed in the Runage proof. And here we're checking that gekkonst, which we are impersonating here, is part of the Foundry GitHub repository group. So what happened here is that we download the world group in the browser and we generate the zkpuf out of this group. So all happened in local in your browser. I think this is because the WiFi is a bit slow, but let's try again. Maybe let's take another group. I think we were going to take the rest one that we already have.
00:27:18.920 - 00:27:56.000, Speaker A: So if we change the group, we need to change it also in the contract. Let's go again. I'm a bit out of time, sorry. Okay, let's do claim with system again. So now we have the rest GitHub contributor group. We do generate zika proof, we are redirected back to the application and we can do our claim with Cismo. Okay, so sorry for that.
00:27:56.000 - 00:28:23.220, Speaker A: Yeah, I think we are running out of time, so I won't show more. If we want to build on Cismo, go to builders Sysmo IO. Here you will enter a telegram channel where you can ask for help for whatever happens. And we will be here doing this report all the weekend. Thank you for your time. Just add it.
