00:00:04.010 - 00:00:16.702, Speaker A: So we have Alana coming up. She's going to talk about why everyone should know ZKPs. And yeah, Alana from Ironfish, thanks so much for joining us. Come off mute and do your thing.
00:00:16.836 - 00:01:00.430, Speaker B: Cool. Yeah. Thank you so much for having me here. So, yeah, this is a talk that's going to be about why everyone should know Zero Knowledge Proofs, or ZKPs for short. And before I get started, I kind of wanted to share my own background and how I got onto crypto because it was actually through going to hackathons like this one that have led me to this space. So in a previous life, I was a software engineer, and in about 2017 2018 era, I started going to hackathons. So the first one that I went to was Youth Waterloo, which was in 2017, and that was the first Youth Global Conference or hackathon.
00:01:00.430 - 00:01:31.710, Speaker B: And it was such an amazing environment. Everybody was there. Vitalik was there, his dad was there, the maker people were there. Dan Finlay from MetaMask helped me debug my project. It was a really special place and I started going to more and more hackathons and doing talks and conferences. And that was like the 2017 2019 era. And at the first hackathon, I actually set myself on a path that led me to discover zero knowledge proof.
00:01:31.710 - 00:02:25.786, Speaker B: Zero knowledge proofs, which is kind of what I wanted to share with you today. So the hackathon that I was working on relied on something called video transcoding. You don't need to know what video transcoding is, just that it is a heavy computation. So it's really expensive for your computer to actually do video transcoding. And so I was kind of obsessed with this question of how do we do honest computation? How do you prove honest computation in a trustless, adversarial decentralized environment? Meaning, can I make a system such that I give to a different computer a really complicated task to do like video transcoding? They come back with a result and I can very cheaply verify that the result was computed correctly. And so I started asking around and finally I discovered zero knowledge proofs. And zero knowledge proofs were built for exactly this problem.
00:02:25.786 - 00:03:03.510, Speaker B: They were built for honest computation. Now, unfortunately, zero knowledge proofs are way too early to do anything as complex as video transcoding, but they were kind of built in Ethos for this exact problem. So brief kind of history about zero knowledge proofs, what are they? They can be used to prove something about hidden data. Now. They were invented in the 80s by Shafi Goldwater, Sylvia McAuley and Charles Rockoff. And some of these names might actually be familiar to you. Sylvia McCauley is working on a crypto project currently.
00:03:03.510 - 00:03:51.082, Speaker B: Shafi is actually a professor at Berkeley. And initially Xeonch proofs were an interactive protocol, meaning that the verifier and the prover had to have interaction in order for the proof to take place. So what are zero launch proofs. There are a ton of zero knowledge proofs and I'll get to that in a few slides. But what they are essentially is they are a proof that satisfies these three properties completeness. So if the statement is true, an honest verifier will be convinced by an honest prover. Meaning that you just need the proof to verify the statement that you're proving soundness.
00:03:51.082 - 00:05:12.446, Speaker B: If the statement is false, no tree improver can convince an honest verifier. Meaning that you have to set up a system such that only the honest proof will be valid in the system and it has to be zero knowledge. Meaning that if the statement is true and if the proof is true, the verifier learns nothing extra about the statement. So again, zero launch proofs can be used to prove something about hidden data and so why is that useful and why is that useful today? So it's useful for three things. So one thing that is useful for is computation, meaning that I can potentially do fairly expensive computation off chain and then just prove it or give a proof for the final state on chain. And so currently I'm kind of really thinking about cross chain transactions, I think as a lot of people are and so in theory you could potentially prove that a certain action has happened on one chain in order for a different action to happen on a different chain scalability. So because unlaunch proofs are used to prove honest computation, you could actually prove that state transitions happened correctly and all you need to do at the end is provide a single proof in the final state.
00:05:12.446 - 00:06:08.478, Speaker B: So if you've heard of zero knowledge proof roll ups, for instance, this is where the scalability aspect comes from and the other one is privacy. So you could prove ownership of something the user wants to keep hidden. So I could say, for instance, if you're familiar with Aztec or to no cash, which I will get to in a minute. You could use your knowledge proofs to say something like, look, I have a note, or I have some hidden ETH or some hidden asset, and I would like to spend it or move it somewhere, but you don't need to know what I've done with it. So in 2018 I quit my job as a software engineer at Airbnb to focus on crypto full time. And I kind of made this bet that even if this blockchain thing is going to go away, zero knowledge proofs are here to stay. And in 20180 knowledge proofs were arcane tribal knowledge.
00:06:08.478 - 00:07:08.966, Speaker B: It was really hard to understand how they work, it was really hard to figure out who to even ask for help. There were very few projects working with zero knowledge proofs and the ones that were had people who were academics and PhD cryptographers, like world class cryptographers. So it was kind of hard to break in and materials on Xeon proofs, especially back in the day went from super high level. So if you ever looked into what Xeonological proofs are, I think you've all kind of seen this example of this cave. And then there's like Peggy and Victor or Alice and Bob, and they're running through this cave to prove that they know something. So most materials kind of went from this super high level to extremely low level. So when Dusty and I were working on trying to figure out what zero knowledge proofs are and digging through academic papers, we would find statements in the abstract, like in the summary of the paper, that were as complex as this one.
00:07:08.966 - 00:08:09.642, Speaker B: For instance, one knows through the construction that the sextic twist will be the Dtype, which means one doesn't have to count points and lift a curve to check their order. It was really hard to get into the launch proofs. However, fortunately, today we have plenty of access to really, really good material and extremely great tooling to make zero knowledge proof development fun and accessible and easy and fast, which I guess is kind of the more important part when you're working on a hackathon project. So I kind of want to go over slightly more history about zero knowledge proofs. I want to highlight some of the evolutions that kind of have happened that led to the genealogy proofs that we have today. So in 2011 there was a first paper that coined the term ZK snarks and ZK snarks just stand for Succinct nonractive arguments of knowledge. That paper was authored by Alessandro Chiesa and Aaron Tromer, both of whom you might have heard of.
00:08:09.642 - 00:09:48.060, Speaker B: They were both Zcash bounty scientists. And then in 2013 we had a paper that made ZK snarks more kind of applicable to general computing, meaning that before Xenon proofs were again fairly difficult to use. And then in 2016, Jan's Groff, who's a professor at University College of London, made a paper in 2016 that actually made ZK snarks pretty darn efficient to use. And if you guys have heard of Zcash, for instance, the Sapling protocol of Zcash, their main privacy mechanism is based off of cross 16 as well as quite a bit of ethereum based or proof ethereum smart contracts are based on cross 16 as well. So I'm not going to go into exactly how ZK snarks work, but I do want to give you guys the intuition behind how they work so that you know their limitations and what they can do, but also so you have the necessary knowledge to go and read up on these concepts on your own. So a Stark construction has these five steps and for the first four steps, meaning how you go from a computation. So like a statement to a quadratic arithmetic program or Cap, there is actually a great tutorial by Stefan Demeale from Decentric that kind of goes over exactly how computation goes from a statement, like an if statement, even to a rank one constraint system.
00:09:48.060 - 00:10:49.110, Speaker B: And for the last step of how you actually make a Snark, there is quite an amazing tutorial by Maxim that actually goes over the intuition of how polynomials can be used to prove certain information. Now, the most efficient curve for cross 160 launch proofs is BLS twelve three eight one. Unfortunately, Ethereum does not support it, despite a lot of EIP and a lot of efforts. But there is a great article that explains the curve and why it's so efficient. So kind of a huge overview of how ZK snarks work. For Snarks we have kind of a predictable way to transform a statement into what's called a language of polynomials. And like with any proof system, there is a prover that is trying to prove something and a verifier so approver here can be the end user and a Verifier can be smart contract on Ethereum.
00:10:49.110 - 00:11:50.030, Speaker B: And there is a challenge, meaning what is this prover trying to prove? Maybe this prover is trying to prove that I have some hidden state in a game or I have a note that has some balance that I'm trying to spend and the verifier could be a smart contract that actually validates those statements. Now, we do need to make this challenge non interactive and so we need to kind of hard code this common reference string, which is part of the trusted setup. When you actually set up this like a smart contract, for instance, you do need to go through the step of setting this up. And this is such so that the challenge or the proof that the user gives you can actually be validated. Now, for cross 16 in particular, this is kind of done by using elliptic curve pairings, which I won't go into today. But not all zero knowledge proofs kind of have this property. So I am going to focus a bit on cross 16.
00:11:50.030 - 00:13:00.242, Speaker B: And so why is cross 16 so great? Now, zero knowledge proofs are typically graded on three things, which is prover time, proof size and verification time. Prover time means how long does it take for me to actually make the proof. Proof size means how big is the proof, which if you are dealing with an Ethereum smart contract, this is an important part for you to consider. And then verification time. So, given the proof, how fast can the validator actually validate the proof? And graph 16 has actually pretty good metrics for all of those three things, even on curve what was it, BN 124 that Ethereum uses. So it has pretty good prover time, it has great proof size, 192 bytes is really good and it has constant and fast verification time, which again is exactly what we need for a blockchain based crypto system. So the other things that Zeolash proofs are sometimes graded on is again the size of this common reference string cryptographic assumptions.
00:13:00.242 - 00:14:04.730, Speaker B: So for instance, graph 16 uses elliptic curve pairings and that is for instance, not quantum secure. And for instance, Cross 16 does have a trusted setup, which can lead to some disadvantages. So the trusted setup, I have a great tutorial here that kind of explains how it works. But I do want to put kind of a caveat that we do have kind of tools in place to make this less scary and less, quote unquote, trusted for you to set up a system. And I'll get into that in a minute. So in 2017 onwards, there was this huge, huge push in academia as well as in companies, in commercial kind of activity as well, to figure out how do we do zero knowledge proofs that don't have this trust head set up. And there were a couple techniques that were being kind of experimented with at the time, most notably this paper that came out in 2010, sometimes referred to as KCG.
00:14:04.730 - 00:15:24.530, Speaker B: And I have a great explainer for what that means. This paper kind of led a pretty big explosion in activity for discovering new zero knowledge proofs that don't have a trusted setup. And to kind of give you guys an idea of how many zero knowledge proofs kind of erupted that did not have a trusted setup from 2017, we had several that were published in 2017, we had some in 2018, we had a ton in 2019, and we had some in 2020 as well. So for those of you who might be overwhelmed by the slide, kind of want to highlight these three that I would kind of pay attention to. Halo Two is being backed and developed by CCASH, and I believe their next upgrade is going to be using their new privacy mechanism is going to be using Halo Two. Plonk was originally developed by the Aztec team and now there's more of a community building up to support tooling for Plonk, which is really cool to see. And then Starks are kind of guided by Starkware and things like, was it Starkx or StarkNet? Which is their layer two solution using Starks.
00:15:24.530 - 00:16:38.410, Speaker B: So that was quite a bit. Which ones should you pay attention to today? So, again, I think Raw 16 actually is still one of the best kind of solutions or best approaches for you to use, primarily because we have such great, great tooling around it. It does require trusted setup. However, I believe this was started by the Ethereum Foundation, which is this project called the Perpetual Powers of Tau. And whenever you do a trusted setup, there's actually two steps to get to that final common reference string, and the first step can be done through multiparty computation. And this project, Perpetual Powers of Tau basically has a system such that anyone at any given point can contribute randomness to the trusted setup, such that future projects that use it basically have this trusted setup that's been organized by, I think, hundreds of people around the world at this point. If only one of those people is honest, meaning that they throw away the randomness that was used to create this common reference string, then the entire system is honest.
00:16:38.410 - 00:17:11.522, Speaker B: Which I think is a really cool project because it kind of shows that graph 16 and the stress of setup is not that scary because we do have mitigating ways to reduce risk. And the most recommended tool set for geolaunch proof smart contract development, in my opinion, by far, is Circum. They have really great documentation. The project has been developed on for, I think, three years at this point. It started off as a JavaScript project. Now they've moved entirely to Rust. It's really efficient.
00:17:11.522 - 00:17:52.194, Speaker B: There are implementations that let you generate the proof in the browser, which is pretty great for app development. And they also have a smart contract Verifier. So you can run a command and it kind of auto generates a smart contract with the Verifier in place. So you can deploy smart contracts pretty easily with it. So I want to kind of point out some notable examples of projects in the Ethereum ecosystem that not only use Circum but are also based in Gras 16. One such category is gaming. So as we all know, Ethereum is a public state.
00:17:52.194 - 00:18:41.170, Speaker B: So if you want to create a game that has hidden state, it's kind of hard. Like, for instance, how would you make Battleship on Ethereum when the state is totally transparent? It's pretty hard. So one notable example is Dark Forest. I don't know if you guys are familiar with it, but if you're not highly, highly recommend it, it's probably one of the first genuinely fun games that are based entirely in Ethereum, at least in my perspective. I know there's like a ton that have come up recently, but I personally have spent an embarrassing amount of time playing Dark Forest. And the idea behind it is you can claim planets on Ethereum with the help of zero knowledge proofs, such that your opponents don't know which planet you claimed. So it's a pretty cool game mechanic.
00:18:41.170 - 00:19:22.686, Speaker B: The other notable example of things you can do with geological proofs today on Ethereum is private transactions. So. For instance, I mentioned tornado cash earlier. Tornado Cash is, I think, one of the biggest zero like a privacy kind of mechanisms for Ethereum today and is based on Circom, which is pretty cool. You can check out their GitHub, you can check out their circuits, you can kind of use that code base as an example of a production ready project that runs in the browser and uses Circum as their main circuit generator. So the other one that I want to point out is Plonk. So Plank is another xerologic proof system.
00:19:22.686 - 00:20:08.318, Speaker B: And remember how I said that Xerologic proof systems are graded on these three metrics, which is prover time, proof, size, verification time. And so, overall, Plonk still lags behind Gras 16, but not by much. And it actually does outperform Gras 16 for ethereum based curves for operations like MIMC and Peterson commitments. Now, Plonk does require a universal setup. So instead of doing a trusted setup for every time you update your circuit, meaning every time you update your genealogy proof kind of logic here, you don't have to do that. So you can use a universal setup, so you can actually use the phase one of the perpetual powers of tau that I mentioned earlier. You can kind of skip this entire step.
00:20:08.318 - 00:21:05.250, Speaker B: And the most recommended tool set for this, again, is Circum. Circum is probably one of my favorite kind of open source projects for zoological proof tooling today. And you can actually write well, like your logic in their DSL, which is domain specific language. And then you can choose whether or not you want to use Plonk or Cross 16 as the underlying proving system, which is super cool because that means you can start with Cross 16 today to kind of get the benefits of things like prover time, improve size. But then as Plonk catches up in popularity or in efficiency, you don't have to rewrite your entire circuit. You can just still continue using Circum and choose Plonk as the underlying circuit compiler. Plonk is pretty cool, and I kind of highly recommend you guys to dig in further.
00:21:05.250 - 00:22:04.900, Speaker B: And the best kind of low touch but still know still thorough tutorial that I found is actually this one by Vitalik. The other tools is to consider is Cairo. So Cairo is based on Starks, and again, it's a domain specific language or DSL, and it's being developed by Starkware. However, in my personal opinion, if you are thinking of building Ethereum Xenol proof based kind of applications today, the most obvious choice is Circum. If you want to actually learn a lot more about zero launch proofs, I found this great compilation of tutorials on zero launch proofs, and all these slides will be posted later for you to click on these links. So that pretty much concludes my overview of zero knowledge proofs. I hope you have found this helpful in your kind of brainstorming of projects to build.
00:22:04.900 - 00:22:53.506, Speaker B: And before I go, I do want to have this shameless plug. So if you want to work on a privacy preserving protocol full time, I'm working on something called Ironfish. Ironfish is a layer one with only private smart contracts, and our goal is to bridge to Ethereum so that we can give every ethereum asset the best available privacy. So if you have any more questions, let me know. All these slides will be posted on my Twitter, and I highly encourage you, if you're curious, to learn more about Zero bruce is to click through some of the links that I provided so you can kind of learn more deeply about how they work and how you can use them today. And with that, I think that concludes my talk. Awesome.
00:22:53.608 - 00:23:10.840, Speaker A: Thanks so much, Elena. Yeah, I'm definitely going to go check out Dark Forest now, because that looks super cool. I was googling it as you were talking, so yeah. Awesome. Well, thanks for joining us again. And, yeah, everyone, go check out her slides where she linked them.
00:23:11.370 - 00:23:16.486, Speaker B: Cool. All right, thanks. Awesome.
00:23:16.588 - 00:23:34.970, Speaker A: And, yeah, thank you, everyone, for joining us for the Hack Money Summit. I hope it was very informative and you learned a lot. I certainly did. And, yeah, super excited to now kick off Hack Money. So happy hacking, everyone, and I'll see you in discord. Bye.
