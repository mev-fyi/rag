00:00:02.730 - 00:00:44.422, Speaker A: Hello guys, welcome to the video on Router crosstalk Library by Router protocol. I am Shivam, a member of developer team at Router. Let me tell you what Router protocol is before we start any further discussion. So, Router protocol is an extension multidirectional bridging protocol that connects current and emerging layer one and layer two blockchains to allow contract level data flow across them. At Router we have multiple product suites. The first one is the Pathfinder API, which you can use to swap your tokens directly on the Router bridge. The second one is the Router Widget, where you can integrate the Voyager cross chain swap UI into your own UI.
00:00:44.422 - 00:01:43.930, Speaker A: The third one is the Router Crosstalk Library, about which we'll be talking today. At Router we have around ten blockchains already implemented and we are focusing on implementing other blockchains also in the future. So let's talk about the Crosstalk library. So, Crosstalk Library is a library that can create cross chain contracts with the ability to sequence token transfers as well as arbitrary messaging. You can create a contract, you can integrate this crosstalk library into your contract and you can make it cross chain. You can swap tokens through your contract itself, you can pass arbitrary messages to other chains with your contract itself and you can do both in a sequence also through your contract itself if you integrate the cross off library. So, if we talk about the requirements of cross chain systems, you'll find mainly there are three requirements.
00:01:43.930 - 00:02:29.850, Speaker A: The first one is the cross chain token transfer if you want to transfer your USDC from Polygon to BSc. So this is one thing that cross chain systems require. The second is cross chain instructions. So if you want to instruct your contract on the other chain to do something, so that is one of the requirements also. And if you want to do both of these in a sequence, so if you want to swap your tokens and then do something, that is the third requirement we have discovered. So with the Crosstalk Library we provide a robot solution for all of these. So you can transfer your tokens, you can transfer arbitrary messages as well as do both of these in a sequence using the Crosstalk library.
00:02:29.850 - 00:03:54.726, Speaker A: So most of the crosschain solutions available today provide either token transfers or generic messaging or both, but in silos. So while we were creating a cross chain staking DAP where we wanted to swap our tokens cross chain and then stake the tokens on the other chain, so we discovered a problem that we do not have a good solution for sequencing the transfers as well as the instructions, right? So we created the Crosstalk Library for this, where you can swap the tokens as well as pass some instructions with a sequence that it should happen first and this should happen. So how does it work and how you can integrate it into your contracts? So, there are very simple steps. First is you need to inherit the Crosstalk library into your smart contract. Then the second is that you need to deploy these contracts on all the chains you want to have your contracts on. And while transacting you need to provide the data for ERC 20 transfers or generic messaging or both, whatever you want to do. Then you need to provide some free tokens to your contract so that it can pay a bridge for the Crosschain services.
00:03:54.726 - 00:04:41.190, Speaker A: So you do not pay directly to the bridge, but your contract itself pays it. So you need to provide some fee tokens to your contract to pay the bridge. Okay, so what use cases you can enable using Crossrock? So there are multiple use cases but we have listed only four or five of those here. But you can have infinite number of cases. The first one is the DEXes that can allow cross chain swaps and Staking together in one transaction for users. So you can transact on a chain a that you want to swap these tokens to the other chain and then stake it so you can do that. Then you can create cross chain tokens where you can burn the tokens on the source chain and mint them on the destination chain.
00:04:41.190 - 00:05:39.380, Speaker A: Then there are lending protocols that can allow for cross chain payments and settlement of borrowed capital. Then you can have cross chain NFT minting where the fee for minting can be taken on one chain and the NFT can actually be minted on the other chain. Then there are some other things like cross chain prediction markets and so on. So let's now move on to the demo for the router crosstalk. So you just need to go to GitHub.com and search for router protocol and you can find the router crosstalk sample. Then you just need to go to this branch and you can check the code here.
00:05:39.380 - 00:06:08.860, Speaker A: But we'll show you a demo. So we'll fork this branch. Not actually fork, we'll clone this branch. Okay, so I've actually cloned it already. So I'll move to my editor. You can see this is the sequence of Staking branch and it has all the contracts and stuff here. So here what we are creating is we are creating a contract where we can swap the tokens from one chain to another and then stake it on the other chain.
00:06:08.860 - 00:07:10.210, Speaker A: So here you can see we have two contracts, the vault contract and the state contract. So what vault does is vault actually implements the router cross top contract. Okay, you can see here it integrates the router cross top contract. It inherits it here and we initialize it here also and it is used to create a cross chain request as well as handle crosschain request from another chain. What stake does is we can call the stake function here in this Staking contract and it will take the tokens from the vault contract and stake it for the user so what if we want to swap a token and then stake it on the other chain? So we'll just call this stake cross chain function. We will be providing the chain ID, the gas limit and the gas price, the ERC 20 data and the swap data that we want to pass. I'll walk you through what each of these things mean.
00:07:10.210 - 00:08:06.804, Speaker A: So here we just pass the selector to the function and we just pass on the params and then it sends the tokens also and then stakes it also on the reduction. Okay, so let me walk you through the vault contract as well as the stake contract first. Okay, so to integrate the router crosstalk library, you just need to first inherit it and then you need to initialize it. So you need to initialize it with the sequencer handler, ERC 20 handler and the reserve handler contracts. All of these can be found at dev routerproteocol.com. So these can be found at dev routerprote.com where you'll find documentation to the sequence this crosstalk also as well as all the addresses that you need to pass here.
00:08:06.804 - 00:08:54.080, Speaker A: Okay, and then what is this token? So this is the token for which we are providing staking. So maybe it's USDC, maybe it's polygonmatic anything. Now there are some functions that you need to have in your contract to integrate the crosstalk library. So you can see these are the three functions which needs to be integrated to have crossing capabilities. The first is the set linker function, second is the set fees token function, third is the proof fees. So what these things are the set linker function. So linker is the address of the admin who can link the contracts on different chains.
00:08:54.080 - 00:09:42.320, Speaker A: So you need to deploy this contract on multiple chains and then you must have some way to know what is my counterpart on other chain, right? So we need to contracts on different chains. So linker is the address of that admin who has the capability to link these contracts on different chains. Then there is a set fee token. So as I told you, the contract pays the fees for the bridging services provided by router bridge. So there are multiple fee tokens that we accept and the list of those can be found at the same website, the dev routerpotocol.com. And you can pass any one of those fee tokens here as your desired fee token. Then third one is approved fees.
00:09:42.320 - 00:10:56.312, Speaker A: What is this for? Since your contract pays the fees to the bridge, you need to approve the bridge from your contract that it can deduct the tokens on this contract, right? So this is what approved fees does. Okay, then here we have the approved tokens function just because we want to approve the staking contract, once the tokens have reached here, we want to approve the staking contract that it can cut the tokens from our wallet from not our wallet, but this vault contract. So once I call the stake cross chain my tokens from my wallet will be sent to the vault contract on the other chain, right? And then if we have approved the Staking contract then the Staking contract will be able to deduct those tokens from the vault contract. So that is why we have the approved tokens function. Then there is a set Staking contract. This is a regular function, this has nothing to do with router crosspr. Then there is a stake function which you can come to the contract and stake actually this is not a cross chain function, this is the same chain stake function.
00:10:56.312 - 00:11:39.610, Speaker A: Actually then there is a same chain unstake also now we have a stake crossing. So what we pass here is the destination chain ID and this is not the actual chain ID of that chain but the router defined chain ID. Like for Polygon we have the chain ID one, for BSc we have two, for Avalanche we have three. So the list of these chain IDs also can be found at Dev routerproteocol.com. Now this is the chain ID of the destination chain. So if you are going from Polygon to BSc and for BSc we have the chain ID two at router protocol. So you will need to pass to here.
00:11:39.610 - 00:12:33.336, Speaker A: Then there is a cross chain gas limit. So what is cross chain gas limit and what is crossing gas price. So you have to pass the gas limit as well as the gas price you are willing to pay for the execution of your function on the destination. So if you have created a contract and you think that okay, this should take this much amount of gas limit and this much amount of gas price to execute on the destination, then you have to provide that amount of gas limit and gas price. And this is how we'll determine the fees that we need to take from you for the cross chain swap. But mind here, if you pass a lower cross chain gas limit or gas price than required on the destination chain, your transaction may get stuck on the bridge and you will need to replay it. We also have a replay mechanism but I'll talk about it later.
00:12:33.336 - 00:13:20.810, Speaker A: So yeah, you have to pass a good amount of gas and gas price so that you will be able to seamlessly use the Bridging services. Then there is an ERC data and there is a swap data. So actually these two are for the cross chain ERC, 20 transfers, right? And these two you will be able to get through our API which I'll be showing you later. Okay? So you just need to pass the token addresses of the token on chain A to the token on chain B. You need to pass the chain IDs that I want to swap this token from chain ID this to chain ID this. And you need to have some data. And then you'll be able to get these two things, the ERC data and swap data.
00:13:20.810 - 00:14:24.604, Speaker A: Now what we are doing here is we are just creating a selector to the function we want to call on the destination chain. So we will have this function on this contract itself on the destination chain and this function will be called when the request is received on the destination chain. So we'll encode the data we want to provide, so not actually encode, we are decoding the swap data to get the amount we want to swap. Then we are passing this data into an Avi encode. So what we are doing is we require an address as well as a UN here and this address is the address of recipient. So staking will be done in the address of this message sender, right? And then this is the amount of tokens that needs to be staked, right? So we are encoding the data that needs to be passed to this function receive cross chain on the destination. Then we have a generic data.
00:14:24.604 - 00:15:13.896, Speaker A: What is generic data? So we just encode the selector and this data that we have created to pass through the other chain and this creates the generic data. Now we have a param struct where we accept the chain ID ERC data, swap data, generic data, cross in, gas limit, gas price, fee, token address and these two parameters. So first one is the sequencing function. So if this is true, this means that you want to swap ERC 21st and then you will call the generic function. What is the generic function? This receive crossing function. The second is if you pass False then this function will be called first and then ERC 20 transfer will be executed. So you want to transfer your tokens first before you start staking.
00:15:13.896 - 00:16:11.010, Speaker A: That is why we have a True. So that ERC 20 transfer takes place first and then we will call this function on the other chain. Then this is okay. So this is only generic actually. So what this means is if this function you are calling does not have to transfer any ERC data, right? So if you want this function to just call some function on the other chain and do not transfer any data, any ERC 20 tokens, right? So you use True for if you want to do only generic message passing, you will pass True. And for swap data and ERC data, you can pass any dummy data so that will not affect. Okay then you just call this router send function with this params and it's done.
00:16:11.010 - 00:17:21.396, Speaker A: So you have created a crosschain request for staking that will transfer your tokens crosschain first and then it will stake it for you. Now as I told you, we have a receive state cross chain for which the selector we have here. So this is the function that will be called on the destination chain and what it will do is it will just call the staking contract stake function with the user as well as the amount we pass here the user is message center and the amount is this. So this function is called on the source chain and this is called on the destination chain. And you can see it has a self modifier, what is itself modifier for security purposes, we want that no address can call this function directly. Only our bridge can call this function, right? And not also our bridge, but this contract itself will be only able to call it. And how we will achieve that? How will this contract itself call it? So when a cross chain request is received on the destination chain, this function is called, that is a router sync handler with the selector and the data you passed in the generic function.
00:17:21.396 - 00:17:58.290, Speaker A: So here is the generic data. You pass some selector and you pass some data. What this data is, it has the user address as well as the amount of tokens need to be stable. So this selector and data is received on the destination chain into this router sync handler function. And what this does is it checks if this is the selector to this function and we decode that data accordingly. So we know if it is a stake cross chain function then we must be receiving the user and an amount. So we decode it accordingly and we just call that function from here.
00:17:58.290 - 00:18:50.960, Speaker A: So only this contract itself calls this function. No other address or any contract can call this function. So this is how a cross chain request that is received is handled on the destination chain. Now we have a replay transaction function. So maybe if you pass a lesser amount of gas limit or gas price than required on the destination chain for transaction to be executed, then your transaction may get stuck on the bridge and you will need to replay your transaction. And for this, you have to call this replay transaction function. And what happens here is you pass the nons for that transaction, you pass the cross chain gas limit, you pass the cross chain gas price and this is the updated gas limit and gas price you are willing to pay for replaying your transaction.
00:18:50.960 - 00:19:35.500, Speaker A: Then it will call the router replay function which will replay a transaction on the bridge. Now we have a recover fee token function. But actually this has nothing to do with crosstalk integration. This is just because this is a testing contract and if I pass some fee tokens and something goes wrong, I want to recover my fee tokens so that I can use it with my updated fund. So that is why I have this function. But it has nothing to do with the cross chain contract. Okay? Now, so we learned that we need to initialize the sequencer cross top with the address of sequencer, the ERC 20 handler and the reserve handler.
00:19:35.500 - 00:20:39.296, Speaker A: We need to create these three functions that are necessary for crosschain swaps and generic message passing that are the linker address set, fee token and approved fees. Then we need to have three main functions which are a crosschain sending function which will use to create a cross chain request. Then we'll have a router sync handler function which will handle the cross chain request received. Then we'll have the replay transaction function which will be used to replay the transaction. So only using these simple steps, you can integrate the router cross top into your contract. Now we have the Staking contract and actually this does not do anything, it just have the vault address and the token address that need to be staked. It just maintains a balance of the staked balances, a mapping of the staked balances according to the address and it just transfers the tokens to itself and updates the mapping.
00:20:39.296 - 00:21:25.700, Speaker A: So that's the only thing it does. Okay, so let's now talk about the deployment and the config of these things, right? So we have created a very simple system of deployment. So we have a one click deployment process here in this contract module. So we have a deployment folder where we have the sequencer deployments JSON. What happens here is you just need to pass the things you want to provide to your contract. So we need to have the sequencer ERC 20 and reserve handler addresses in the contract to initialize the vault. You can see here we also need to have the token address, right? So we have the sequencer ERC 20 and reserve handler as well as the token address here.
00:21:25.700 - 00:22:18.148, Speaker A: So this token address is actually the USDC on polygon, all right? And fee token is also USDC on polygon. And the token we want to stake is also USDC on polygon. Okay? Now the linker is my address actually. So this is the address of admin that has the capability to map the contracts on different sheets similarly for Awaps, also we have the addresses and these addresses, the sequencer ERC 20 and reserve handler addresses you can find on the official documentation the dev Torto protocol.com. Okay, then this is the USDC on avalanche. So we are using the fee token as USDC and the token to be staked also as USDC on the other chain. Then we have the linker address.
00:22:18.148 - 00:22:46.600, Speaker A: So this is the linker. This is the same address. You can see this is my address actually. Okay, so once you have done this, you'll just need to go to the tasks. And we have all the tasks here. The one is the deploy vault. What this does is it takes the data from your deployments file, the one we just created, and it just initializes the vault contract here and it stores the address of the vault into that file directly.
00:22:46.600 - 00:23:33.992, Speaker A: Then it sets the link up on this contract. It sets the fee token on this contract and it approves the fee token on this contract. So this pretty much does all the config for us. Then we have a deploy stake function which will just deploy the staking contract. Then we have set fee token, set linker, so all these are called inside some master task like deploy vault calls this set linker, set fee token and approved and so on. Then we have a deploy all task which will actually do all the things for us. It will deploy the vault, it will deploy the stake contract, it will set stake contract on the vault and it will approve the tokens.
00:23:33.992 - 00:24:15.748, Speaker A: So what is approving the tokens. So once we receive the tokens on the vault contract, we want the staking contract to be able to deduct those tokens from the vault contract. So this just approves the vault contract from the staking contract to deduct the tokens and stake it, okay? So once all these things are done, these four things, we need to map those contracts and for that we have a map contract. Here is the map contracts task. What you need to pass here, we need to pass the chain ID and N chain ID. What is the chain ID. So chain ID is the destination chain ID defined by router.
00:24:15.748 - 00:25:13.864, Speaker A: So example, you have deployed your contracts on Polygon, BSc and avalanche. So from polygon you need to map your contracts to BSc and avalanche. So for BSc we use the chain ID two for BSc and we use the chain ID three for avalanche at router protocol and all these things again you can find on the official documentation. So chain ID two and chain ID three. So this chain ID is the destination chain ID defined by router. So when you are mapping from Polygon to BSc, then you will need to pass the chain ID as two and then the NCHN ID is the actual chain ID of the destination chain. So for BSE that will be Ncnid is equal to 56 for Erax, n chain ID is four, three 1114.
00:25:13.864 - 00:25:52.566, Speaker A: Okay? So when you are mapping from Polygon to BSc, you need to pass two for chain ID and 56 for N chain ID. And for polygon to AVAX you need to pass three for chain ID and 43114 for NCHN ID. Once you have done those things, then I think you are ready to go and test your contract on the explorer of your UI. So let's deploy these contracts and test it out once. Okay, now, so let's deploy these contracts on polygon and avalanche. So let's start with polygon. First is polygon.
00:25:52.566 - 00:27:50.490, Speaker A: So we'll write the task NPX hard at deploy network polygon we have a deploy task that will deploy the stake that will deploy the vault contract as well as set all the config on vault and stake, plus approve the stake contract to deduct tokens from the vault contract. Also all the addresses it will take from the sequencer deployments JSON in the deployments folder, so you can see it has already deployed the vault and set the linker address, the fee token address as well as approved the fees. Also this address is stored in the sequencer deployments file that I'll show you later. So all the config and everything is done on Polygon. Let's do it on avalanche. Okay, so the deployment has started. Deployments are complete here.
00:27:50.490 - 00:28:42.690, Speaker A: Now we would also like to verify these contracts so that we can access them on the explorers. So you can see all the deployments have been completed and the addresses have been stored in the deployments file. Now for verifying it, also we have created some tasks. So if we call this verify all tasks it will verify the vault as well as the state. So let's do that. So we'll first verify on the polygon network. So the verification has started on Polygon.
00:28:42.690 - 00:30:07.930, Speaker A: Okay, so the Polygon and Polygon verification is done. Let's do the same for Avalanche. Now the contracts are verified on both Avalanche and Polygon. Let's open it up. First we'll open the contracts on Polygon. We have opened the vault, now we'll open the stake also. Similarly we'll open the vault and stake on Avalanche also avalanche is not race.
00:30:07.930 - 00:30:48.390, Speaker A: This is the vault. Okay, we have the vault, we have the stake. Now we would like to transact from Avalanche to Polygon. So we'll send some fee tokens first to the avalanche network so that it can pay our bridge. So we have kept Polygon as the fee token. Let me send some fee tokens to my contract, the vault contract. Let's say we'll send one USDC.
00:30:48.390 - 00:31:48.174, Speaker A: Okay, so I've sent some fee tokens to my vault contract so that it can pay the bridge. Now we want to transfer some USDC from Avalanche chain to Polygon chain and then stake it on the polygon chain. Okay? So we also need to approve this vault contract from our main wallet so that it can deduct those USDC that we want to transfer to the other chain. So we'll open the USDC, we'll open up its contract and we'll approve a vault contract for it. We'll copy the vault contract address and we'll approve it. This is the approve function. We'll have the spender address and we'll only give approval for some point.
00:31:48.174 - 00:32:36.098, Speaker A: One USDC for zero one we have to write 50 because USDC is 60 six decimals actually. Okay, so now that we have given the approval also we can go and try any cross chain functions. Here you can see we have one USDC here in the contract itself to pay the fees. We have also approved it from here from our main wallet. So let's try to call Sake crosschain function here we'll connect the wallet and we'll go to the safe cross chain function. Okay, now we need the chain ID. So for chain ID for Polygon chain, the chain ID is one where you can find it.
00:32:36.098 - 00:33:00.714, Speaker A: You can go to dev routerproteocol.com. Here we have a list of chain IDs. So let me have a look. So supported chains. You can go here and check that polygon is chain ID one for router. This is the internal chain ID. Polygon has one, we'll pass one as the chain ID here cross chain gas limit in gas price.
00:33:00.714 - 00:33:22.210, Speaker A: So I know that my function is not that big. So I'll pass a medium kind of gas limit. Maybe I'll pass for the safer side, I'll pass 100,000. You can pass lower if you want. I think this is not a complex function, so it should work with lower amounts also. But I would just want to be on the safe side. For cross chain gas price we can go and check the Polygon gas price.
00:33:22.210 - 00:34:22.038, Speaker A: Currently it's 40 GUI so we'll pass 50 go 590. Okay, now to get this ERC and swap data, that is for ERC 20 transfers, we'll use an API and I have written a script to get this data. So you can go to the scripts folder and get sequencer data. So here you have this basic URL and then you need to pass some parameters. So in front token address, we are passing the USDC on avalanche, the two token address, we are passing USDC on polygon because we want to transfer USDC on our avalanche chain to USDC on polygon chain and we want to transfer an amount of zero one USDC 40 hints with six decimals. Now source chain ID is avalanche. Destination chain ID is polygon 137 free token address is USDC on avalanche as we discussed earlier, recipient address.
00:34:22.038 - 00:35:24.940, Speaker A: So here what recipient address should be. So we want to send our token from Polygon from avalanche to Polygon, but we want to send it to the vault contract on polygon so that the stake contract can take it from the vault contract, right? So here we'll pass the vault contracts address on polygon. So this is the vault contract address on polygon. So we'll pass this address as the recipient address because the stake will deduct these tokens from the vault contract. So we need to specify vault as the recipient address now is destinative what is this? So if the destination token is a native token of destination chain, if we wanted to convert this USDC to matic token on polygon, then this should have been true, otherwise this should be false. Okay, now we construct the query URL here and we query it here using axios. So let's run this script once.
00:35:24.940 - 00:36:11.180, Speaker A: This is a sample script, you can use it in your project to do it dynamically. So it's in the scripts, folder and name get sequence. So when it runs it will give me the ERC data and swap data. I just need to pass those parameters to the function and we can do the transaction then. So we have the ERC 20 data here. So I will go and paste it on the vault contract. We have the swap data also.
00:36:11.180 - 00:36:48.270, Speaker A: So. This is the data that we pass to the bridge for ERC 20 transfers. Okay, so we are getting some issues here. Let me check. So I figured out what the issue was. The issue was that so do you remember earlier I told you about the linker address? That the linker address has the capability to map the contracts on different chains. Right? But we did not map it.
00:36:48.270 - 00:37:19.450, Speaker A: So let's go and map it. So from Polygon we want to map our contracts to the avalanche chain. And from Avalanche we want to map our contracts from the Polygon chain. So let's run the task map contracts. What we need to pass one is the chain ID which is for Avalanche to Polygon we'll use the chain ID of Polygon. So router spec chain ID is one and the N chain ID is 137 for Polygon. And this is on the network Avalanche.
00:37:19.450 - 00:38:03.970, Speaker A: So from Avalanche we are mapping polygon. Okay, mapping is done. Now from Polygon we'll map avalanche. So for Polygon we'll have 43114 here and we'll have chain ID three because Avalanche has chain ID three. Here you can see. So this is Avalanche has chain ID three and this ID is 143114. Okay, now we'll do the crossing swap and you can see it's.
00:38:03.970 - 00:39:30.608, Speaker A: Okay, now we have done our transaction here. It takes some time to go to the destination chain but here we can check. We do not have any staked balance right now we can go and check the state balance in the contract and we can pass our address here. So you can see when we query it we find zero. Okay, now let's wait for some time and we can check what happens. So it has not come yet, but let's wait. So now you can see here that the balance has been updated to 10,000.
00:39:30.608 - 00:39:49.830, Speaker A: What this means is that the USDC you paid on the vault contract in AVAX has now reached the Polygon network and is staked here. So I think that completes our tutorial. Thank you guys for being with me and I wish you all the best. Thank you.
