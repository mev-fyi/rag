00:00:13.960 - 00:01:13.664, Speaker A: Mostly talked to each and every person here in the room. So mostly you guys are already with what disconnects and simply explaining. We have been here in this space for three years. We have been focused on interoperability and we have built like multiple projects starting with Spanchette, Vector, Indra and before this the project we did was Vector and we hit 500 million volume in it but we were using State Channel. So we hit a limitation of the scalability in it because we have to basically maintain a same DB at all the nodes which are getting created. So that means each and every user we realized this problem and we started doing interchange. That is Nxtpv zero where we started and we realized that also that right now with the current surf which is running which is supported for 15 chains earned more.
00:01:13.664 - 00:02:08.210, Speaker A: The only problem which is coming in right now is the segmentation of the liquidity because the way it works is that when you put your funds on the sending chain people receive funds on the receiving side. So assuming that there is a lot of users coming onto this specific sending chain then the liquidity gets collected over there. So now what it is is that we have been working for like six months to produce this new solution which is called Amaroc. You have seen our swags which have a wolf kind of figure and that animal is known as Amarok. So we are calling this hard fork and Amaroc and now we are collaborating with Nomad which is a messaging layer cross chain which is a slow one. It is based and inspired from roll up. So it takes around half to 1 hour to provide and prove that this message which is coming from the sending train is true.
00:02:08.210 - 00:03:15.844, Speaker A: Would love to deep dive into how this works. Technically Nomad itself and how Connects is working. But we'll start with the basics. What has been with the Connects, what we have been building until now. Starting with my introduction, I'm a project manager and engineer at Connects, more or less like Engineer which got a lot and we have been a trendsetter, we have been a thought leader into this ecosystem. So we're going to make sure that everything is crystal clear to the people who are coming to this ecosystem and naming it because there are multiple chains which have maybe chain ID or not or which have their own ecosystem which have their own VMs or maybe no VMs like Mina. So we want to make sure that we can be with any chains which are coming in live and that's why we are naming any sort of domain from which one chain to another or a domain to domain you can connect and it could be L one L two side chain or non EVM.
00:03:15.844 - 00:04:13.272, Speaker A: So it could be near optimism, polygon ethereum itself. So we are calling these domain. These are the execution environment where you can run a cross chain application and connect it with the other one on the other chain that is going to be our domain and we are calling these applications not app, not DAP. We are calling it them Zap because they are cross domain communication so we can do a native application integration with cross domain. So any chain we are calling cross domain we are calling is cross domain native DAP. So that is Zap. Not going to take much time off now but going to quickly skim through all the slides wise apps because we have seen interoperability problems coming in in last five years.
00:04:13.272 - 00:05:12.620, Speaker A: We have seen why we needed E two and then there are multiple chain came in. But now how the liquidity segmentation bridge hacking and all these things are coming in. So we want to make sure that when you are using or building a domain zap that time you make sure that there is a significant security available onto your bridge. You are not making a trust assumption and you are making a winning L one, L two DAP which can be used by a user. So user want to use any chains right now. So you want to make sure that your application is available with them and there are maxis which maybe are more favorable to it or Polygon near Ad and Scalar mina and there are many apps but we want to make sure that you are with the user. So you want to build an app which is available to all the users, all the chains so you can have more users into your ecosystem.
00:05:12.620 - 00:06:13.180, Speaker A: Onboarding user is very easy. If you are it's going to be very hard because they have to pay a high fee so it's better to avail it on multiple chains so they can come from anywhere. Again, security is very important. We have seen a lot of bridge hacking in last year and why it is important everyone knows now and that is what connects validates now that security is very important, you want to make sure that whatever you are building is very secure. So we don't do any trust assumption. It's a trust minimization solution but you want to make sure that on whichever chain you are deploying it is secure. So the only trust only thing which is available which is threatening your app with the security is the chain itself which is on deploy on here it is going to be a domain cross chain.
00:06:13.180 - 00:06:59.420, Speaker A: Chain deployments is already here. There are multiple apps which are live with ours lefi the layer two sorry layerswap. So there are multiple application which are already building in aave is doing their V three version which is going to be using natively Nxcb. So it is going to be amazing how you can improve the Zaps. So you want to make sure that the interface which you are using is same to all. So it is easy to actually scale and build and make sure that it is easy for the user to actually start with something. So you don't want to change things for the user when you are switching with the applications or with the chains or the domains.
00:06:59.420 - 00:07:35.580, Speaker A: So you want to make sure that the interface stays the same. The bridge is abstract, it doesn't have many layer of securities involved. So that is why connects is ideal for you guys. And you can pass call data so you can call contracts on the receiving side you can perform multiple things like dow to do interaction, metaverse to metaverse you can build wall zaps. You can have so many possibilities and so many use cases. I don't really imagine right now we are waiting for the developers to come in and actually build some cool shit on us. Thank you very much sir.
00:07:35.580 - 00:08:25.676, Speaker A: And we are trying to support as many as developer as possible. There were a couple of right directions which were taken in controlling the protocol bridge which were availing a user, a single user who comes in he doesn't have to know that which chain he is on, whatever the application is built for they should actually perform that. So if you are talking Zap, they want to get most APY. They don't really have to know which chain they are on, they simply want to get a benefit out of it. So this is the ideal world where the protocol bridging is coming in. It is more or less they don't really care right now also in web two they don't really care where the data is saved. It should be same but now they should realize slowly they are realizing the security aspect of it but they don't want to move it move ahead with that.
00:08:25.676 - 00:09:22.584, Speaker A: But now if you can have some sort of interface which can allow them to move in a very secure or in a very UX friendly way that will allow the users to come into and get into the blockchain system and that is what we are looking for. Challenges. So these were the challenges which we have seen throughout the time which we were facing for the last years, that deploying the contracts gets very hard because there are multiple chains. So you have to keep a track of it and managing these deployed address. So whenever you are sharing with the application, it gets complicated with them. Because on some chains the address are different, on some chain it's not. And reading from the chains the data which is available from the chains when you are reading from the subgraph itself there are a lot of blocks sync, they are not synced to the latest, there could be a 200 blocks delay.
00:09:22.584 - 00:09:56.456, Speaker A: So you want to make sure that whenever you are reading the data you are on the latest. So this is something which we have been solving a problem with the graph itself and many multiple companies we have been talking to, we have beware where we deployed multiple graphs. So we want to make sure that the data is available all the time. So the piece of infrastructure shouldn't be the failure of your application. So we want to make sure that doesn't happen. So we have like two to three backups. When you are deploying, you are using an RPC, you don't use a single RPC, you have multiple RPCs which are there.
00:09:56.456 - 00:10:46.984, Speaker A: So these are the things, these are the steps we have taken to make sure that the UX doesn't suffer for the user and your DAP billing with connects. So it is quite simple. The one way is that you can do a simple transfer, very simple. You use SDK, you make an X call and that is all required and the user will receive their funds like in ten to two minutes depending on whatever the chains they are interacting with. So if you are in polygon so any chain we're simply waiting for the safe confirmation to be happening. We want to make sure that no reorg happens so router won't lose the money, otherwise router can actually take the risk. But more or less if it is polygon, I would say 20 seconds is more than enough where we are making sure that 150 safe confirmation happens and then a receiving side transaction happens.
00:10:46.984 - 00:11:33.496, Speaker A: So in 22nd people are actually moving their money in the most cheapest way possible and the most secure way. So this is the incredible solution we are offering for the DAP developers to actually scale their users. Other than this we have instant liquidity bridging now because the liquidity will be available. If it is not, then we have a slow liquidity which will be done in like 30 minutes or so. So if a user is creating a transaction, you are sure that it will be done within a 1 hour and it could be done instantly. If it doesn't happen, then we will show you that that is the flow liquidity. There are parameters, that's how you can check it.
00:11:33.496 - 00:12:43.772, Speaker A: Other than this there are so many possibilities using the call data itself, you can call a Dex where you can make swap, you can call a Dao where you can vote in cross chain mechanism where you can move the liquidity from dow to dow in the most trustless manner. So these things are possible with Amaroc when you build with connect anatomy of Zap this is something we have been talking about when we are saying that how you can do a contract to contract interaction. You can have your origin contract which can be built upon the connects where you will have an X call into it. So you do a contract to contract, it doesn't have to be off chain, you don't really have to use SDK even if you make a direct call to Xcall then also it will be picked. So it doesn't require any sort of off chain piece of infrastructure to be communicated from the user or required at the part where the DAP is interacting. So you can do a contract to contract interaction you can do a simple SDK call or you can simply call the contract itself. So any of these are possibilities which can happen.
00:12:43.772 - 00:14:12.996, Speaker A: So once when we are talking about how does this basically work we have a connects contract on both the chains on sending side you will call XCON which will provide you you will provide the basic data where you are providing the amount or the piece of information you want to deliver and mention the call data. If there is a receiving site call you want to make this is the only information which is required on the sending chain. This happens. There are routers one of the key infrastructure and connects which are the liquidity provider or the message relayer. I would say so once router sees that there is a transaction happening on the sending side so what they do is that they basically compete with each other and one other router or a couple of the router who can collectively provide the liquidity or the message they will send their request and the relayer will send their transaction on the receiving side. This happens user receives their information and proceeds with whatever they were doing in case of permissions contract which will be a part of the starter kit we will tell you about it which is required in some cases where you want to make sure the origin sender the sender on the sending side is the one you want to trust. So in case a dow to dow interaction you don't want to trust the user who is creating the X call you want to make sure the user who is calling the X call is your dow contract.
00:14:12.996 - 00:15:10.270, Speaker A: So you want to make sure that origin sender which is coming from the sending side on the receiving chain that this is the person, this is the contract which called it. So you can have some modifier on the receiving side and have this permissioned way. So this is all you can actually get at the Zap starter link. If you go there, we have three ways to actually start interacting. And we did mention if you go to Docs Connect network you will have a Getting Started very simple where you can do an instant transfer, maybe start you just have to download the SDK itself and then just get started with it. I can show it to you guys right now if you can start and do some coding if that is cool with you guys. Any question till then I will take it.
00:15:10.270 - 00:15:12.430, Speaker A: Please go ahead sir.
00:15:13.840 - 00:15:21.132, Speaker B: I'm kind of used to bridging you mentioned that Connect is much more trustless.
00:15:21.196 - 00:16:00.764, Speaker A: Than normal bridges, right? How do you guys make this happen? Okay, so that would require a couple of comparisons. But I would simply say why we are trustless. Because we don't assume any sort of validation or there is no set of validators who are actually where you are depending your money onto them. The router who are providing their liquidity, they are making sure that, okay, I'm fine with completing this transaction. So they are not actually giving out the money to any third party. Okay, please validate for me. That is not the case.
00:16:00.764 - 00:16:26.710, Speaker A: Router is actually checking that there is a transaction happening on the sending side. They make sure because they are reading their own data. We are not the one who are providing them that okay, this happened. Please make a transaction. That's not the case. Router have their own key infrastructure where they are making sure that they are reading the correct data and then they are creating a transaction and we don't want to race it. So we create a competition and a way where they can actually send the transaction on the receiving side.
00:16:26.710 - 00:16:28.550, Speaker A: So.
00:16:36.970 - 00:16:53.870, Speaker B: So using this logic, right, the ten aspects of how deferred bridge hacks, the exploits actually function. So these wouldn't be possible with your.
00:16:56.560 - 00:18:14.808, Speaker A: System, right? So the only trust minimization so we were trustless until now we didn't had any sort of trust assumptions now we are depending on trust nomad in this case for the reilling of message that's where we are saying trust minimization. But that is the risk which will be taken by it will be routed. So how this is working with us right now with MROC. Upgrade is that once the user is creating their transaction router creates a transaction on the receiving side they complete their transaction that is going perfectly fine now how does the router actually receives their money? So basically they wait for the Nomad, which takes around 30 to 1 hour to complete the message sending on the receiving side and receive their money through the slow liquidity path. So we provide the fast interaction for the user and router will receive the slow one through Nomad and for that they will charge 0.5%. And if that is something subject to change that will be present on the docs. Any other question I can entertain with? Okay awesome.
00:18:14.808 - 00:19:06.404, Speaker A: We can get started with couple of I'll just go do an overview how you can actually get started and build some cool shit. So we have a Zap starter we have kept it very low level and we didn't provide any sort of UI which we are not very much interested in. So even if you don't really have a UI, even if you are doing a contract to contract interaction, that is completely fine with us. We want to see the Use case that can be possibly happen with you guys and have the potential to build it. So that is the only requirement. We are not looking for any sort of UI so when I said that you can build some X domain when I said that what are the possibilities of the use case you can build with. So the very simple one would be like a ten minute integration.
00:19:06.404 - 00:20:07.484, Speaker A: Or five minute integration would be simply download this SDK and then just create, which will be an initiation. And the SDK config consists of chains where you are mentioning the provider as well as the addresses of the tokens which are there. And that is all the config which is there, which will be available. We will update the docs better or you can search the SDK requirements still other than this we have Xcall which is the main function where you will provide whatever you want to transfer from one chain to another. So we'll mention the two address where you want to the target address where you want to have the interaction to be happening or the receiver of the funds call data will be something, it could be zero X if you are not interacting on any contract on the receiving side. If you are then the call data will be a functional encoded function which is an interaction which is happening on the receiving side. We can help you with that.
00:20:07.484 - 00:20:42.392, Speaker A: We have examples so nothing to worry about. Origin domain and destination domain. So instead of chain ID again we are using domain to make sure that all the chains possibly can be supported. All the chains L, two s roll ups and non EVM chains. So we want to make sure that we don't stick to the chain ID standard. So the domains documentation is available right now and if you have any questions we are happy to support with it. You mentioned these couple of params and other than that you mentioned what is the transacting asset ID.
00:20:42.392 - 00:21:50.520, Speaker A: You will mention the asset ID you are transferring from one chain to another so you will mention that and amount this is all required and simply you call X, that is the only thing you require and you will instantly receive the money on the other side. Right now the testnet is available on Rinkiba and Covan so you can test over there. Sorry, other than this when you are trying to build some cool things you can do sorry, could you repeat the test? Kovan and Rinkibar. Thank you. When we are doing the interaction from contract so what can you build? You can actually hold a governance vote on one chain and have the interaction happening from multiple chains. So you don't have to actually create the proposal on all the chains and then you will be combining it but it's not traditionally decentralized so you want to make sure that it is decentralized. So you can have the voting done on a very cheap chain and if a person is there who is not actually working with that specific chain he can call it from another chain.
00:21:50.520 - 00:23:00.370, Speaker A: So this can happen, you can hold the proposal voting on one chain and have the votes coming from all the chains and the address will stay same. You can have the validation done and you will be creating some middleware contracts above the next to make sure this happens. We can go through the details but it is going to be the permission one which is mentioned under the starter kit. So once you go through in the overview we have mentioned a couple of things where we have permissionless and permission here you can have the use cases as well as we have explained what is the requirement for those contract to be built coming back to all the possible use cases token Bridges this is NFT bridging which can be happening you can create one contract on the sending side where the burn can happen or lock can happen and on the side you can mint. So this is NFT bridge, which can be done and built using Connect. And other than this, I think we have a hacker who is building the NFT bridge and it is going to be super cool if we can build during time. We are really looking forward to it.
00:23:00.370 - 00:24:14.244, Speaker A: A swap ender transfer on the receiving chain. So assuming that you want to do a swap on Uniswap or one inch or any sort of dex, you can actually provide the call data when you are calling during the X call and then you can make a transaction on the receiving side. Other than this we have dex liquidity zaps critical protocol operation which can happen to make sure the global constants which are there will stay the same. You can build univ three trap which is very exciting. You can have chain Agnostic V token accordance which will be soon done by Aave but we would love to see one of you building that and metaverse to metaverse interoperability. This is very strong so these can happen all if you go through we have put in some examples possibly in the starter kits where you can see that what are the requirements if you have to go through the permission layer or if you have to go the permissionless if you are going with permission layer then you will have to use the slot. There is no possibility to use the fast one because you want to make sure the origin sender which is coming from the sending side is the one which is your contract.
00:24:14.244 - 00:24:48.510, Speaker A: In fast recurring DT permissionless the fast interaction is possible so these are some of the examples which you can go through the documents and if you have any question we'll be here all day tomorrow too. Thank you. I think I will conclude here. Thank you any question if you have good thank you very much.
