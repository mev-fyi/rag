00:00:06.090 - 00:01:11.294, Speaker A: I'm a blockchain engineer at Biconomy and we work on the usability side of blockchain applications. And I'm going to talk about how you can build very simplified DApps and that improves the user experience for your end users through different products. Or we'll get into it like the fee abstraction mechanisms, or it can be like, easy onboarding and even on the security side of things. So for that, we have an ultimate toolkit called Biconomy SDK. So I'll talk a bit about it in the beginning and then what I'm going to do is I'll be doing a workshop which is going from a regular DAP to adapt that is using Biconomy SDK using some of the features like gasless or forward. So we have been into the space for like three years and we initially started with realizing the usability problems in the space. So for example, first thing was like gasless transactions.
00:01:11.294 - 00:03:04.840, Speaker A: So that was the first product and we have been continuously building for builders so that you can build better applications or your users can have better experiences when they come. To your platform and there are lot of DApps and they have come to us and told us that it improved x amount of interaction or in terms of user onboarding when they integrate the solutions of Biconomy. So I'll get into the products or even maybe we can chat later in blockchain if it has to go on next rapid growth cycle there are three things, right? Like one is scalability, one is usability and another is interoperability. In terms of scalability we have made a very good progress but there are not many DApps which are actually usable so there is still a lot of friction in terms of number of user interactions, right? And on the interoperability side as well there are multiple chains which are siloed and then you need to bridge your funds from one chain to another to do something on another chain. So this is a typical use case where user wants to for example I have some funds or some shitcoin on let's say avalanche and I want to go and buy an NFT on polygon so I need to go through this entire process like connecting the wallet and changing the RPC. If it's completely new chain to my MetaMask or whichever wallet then I need to find out the details and first transaction I'm going to do is to get some native tokens because every interaction is like this checkpoint or where you're basically like it's a highway and you're paying taxes right when we talk about gas. And you need to manage the lot of other complexities as well, in terms of failing transactions or bumping up the gas price.
00:03:04.840 - 00:03:41.554, Speaker A: Whichever wallet you are on. And that's just one of the actions which could be like ten action thing, right, that you want to do as a user. So you go and sign approve a transaction and then once you have the token that you want, but that's still on the chain, which is let's say we started with Avalanche or Polygon and then you need to bridge it to BNB and then change the RPC again. Then you need to have the native token for that chain. And then let's say you are buying an NFT. So you do that transaction and then you stake it to get some position. So it's a very messed up UI and it takes like about ten to 15 minutes.
00:03:41.554 - 00:05:07.606, Speaker A: With Bironi SDK you can build like one click experiences, that is cross chain and even on a particular chain within like seconds. So I just want to play a video. I think that speaks better. Let me know if you guys can hear the sound. All right, thanks. It all right. So, so far we have gotten into why of it, right? All right, so now I'll come to what is Biconomy SDK.
00:05:07.606 - 00:05:53.382, Speaker A: So it's basically smart contact wallets plus the infrastructure to enable all of these one click experiences which I just talked about. And it heavily utilizes account abstraction, that is EIP 4337. And then there are other mechanisms because it's a smart contract wallet, right? So you can go wild with it, like with signature verifications, different kinds of fee abstraction. So that is the idea. So first of all, account abstraction means that your account and signer is different. So you park your address somewhere else and in order to initiate transactions, there is a key signing key which you can rotate and you can have multiple party computation, a lot of things. And what I mean by gas abstraction is that just the thing which I talked about.
00:05:53.382 - 00:06:34.626, Speaker A: You do not need to hold native assets. Someone can sponsor gas fees on behalf of you in native tokens or even in ESC 20 tokens. Or if Adapt does not wish to sponsor, then they can make the user pay using the assets that they are holding in their smart account. And in terms of chain abstraction, once you integrate as a DAP, let's say I'm on five different chains, you do not need to make users change RPC and everything. So that's the idea. And I'll get into more details in terms of architecture. So it's basically, like I said, there is a relayer, there's a bundler service for account abstraction, there is indexer service, there is a backend node and there are several packages within the SDK.
00:06:34.626 - 00:07:57.470, Speaker A: So you can use all of them at once or just some of them. And some of the features that are exported out is one of that is social login. So you can have like MPC support and social logins for completely new or not crypto Savvy users and just give them the EOA address or a signer because basically smart contract wallet or this whole layer zero which we have built on, it just needs a signer, right? So as long as you have a signer on top of that, there is a smart contract wallet which gets pinned up and this signer will be the controller of the smart account or smart contract wallet. And whenever you want to initiate the transaction, it's always just a signature verification. So your end user just signs the message but the fee abstraction happens within the smart contract wallet and then there is a relayer or a bundler to poke your wallet because contract accounts cannot initiate transaction on themselves. So multiple things like you may be already aware about like custom signatures schemes and there is also something called concept of modules where basically you can enable a certain module in your smart contract wallet and say that for example in Nosisafe. So the idea comes from Safe itself where you can have like daily spend limit module or you can have social recovery module, session keys, et cetera.
00:07:57.470 - 00:08:41.360, Speaker A: So using this the transaction can go through certain level of different access control and that skips your original sign in. So that's the idea. I'll just quickly script through it because I want to get into the workshop mainly. So this just talks about fee abstraction like gases transactions and the amount of fees that you are going to pay by estimating yourself on MetaMask and then bumping up going through that whole process. The relay is to this job like bumping up and choosing the optimum gas price even in case of gasless or any other case as well where user is paying. So let's get into the workshop. So what I've basically done is let me just open this app.
00:08:41.360 - 00:09:33.314, Speaker A: So there is a version which is very simple boilerplate. There are other demos which I'll link in the references at the end of the session. But basically what this does is 1 second. Yeah, so I have so here it's first demonstrating the connection from externally owned account. It could be like MetaMask or any other wallet and there is a smart contract which basically lets you set a purpose. So it's just a string which you set. It can be like capture a flag kind of a thing.
00:09:33.314 - 00:10:15.810, Speaker A: But in order to do that because I wanted to showcase some batching actions as well because there are like multiple clicks, right? So in the current world I deployed a test token as well. So we are going to be playing with these two contracts. So basically when you want to set a purpose or this string on a state of the contract, you need to pay at least like one token or you can pay more as well. So that's the idea. But because you are paying this, it's just a polling mechanism, right? Like so contract will pull. So you need to give approval first and then this code is set. So I'll open the app here, I'm logging in with my MetaMask.
00:10:15.810 - 00:11:11.894, Speaker A: So this is the address. I have some matic and I have some test tokens as well. So first I'll approve the tokens so this is my first transaction. You'll set the gas price, then we will wait for it to get confirmed. So once this is done, let's say so one purpose is like checking out the documentation. So this is just pretty basic stuff, right? So I did two transactions. I needed to have native tokens in Matic.
00:11:11.894 - 00:11:59.470, Speaker A: So I'm doing everything on Mumbai right now. Now we will start modifying this DAP by going through Biconomy documentation. So let me get into it. Our two of the transactions got confirmed, so we can check like a different code. Okay, this one failed. So this is the main entry for the Docs. And what I'm going to use is there are several packages.
00:11:59.470 - 00:12:38.220, Speaker A: I'm going to use social login and also showcase some sort of fee abstraction where we'll be using the gasless flow by account abstraction, paymaster. So the Paymaster I'm going to be using is a verifying Paymaster. So basically as a DAP, you register on a dashboard called Paymaster as a service where you basically can whitelist your contracts. That okay, these are the methods which I want to sponsor or these contracts, right? And then there can be like other levels of checks as well as conditional gasless. So as a DAP, you'll need API key. So we'll get into that. First I'll just start and start doing the changes here.
00:12:38.220 - 00:13:46.120, Speaker A: I have already added some states login section which I have left out. And there is an initialized wallet. So currently I'm initializing or in the demo. Before that I just initialized with my EO account and we'll be making changes here. So instead of this, we'll be using like a smart contract wallet and have that context in our application to keep using smart contract wallet for the transactions and to give you the overview of this. So basically I had these two methods, right, which we just invoked. One is approve and one is like submit this purpose.
00:13:46.120 - 00:14:27.640, Speaker A: But we'll be batching it into just one transaction and instead of paying for gas fees, someone else will sponsor it. And there can be other ways as well where you can get a fee code from the relayer which is plugged in with the SDK, right? So in that case, user base. And you can also show in the UI that okay, these are the options like x amount of USDC, y amount of USDT, whichever tokens relayer supports. So that is part of other demos as well. So I'll shortly link the video over there. So coming back here, basically we'll be changing the way login happens. I'm going to start with the social login package from the SDK.
00:14:27.640 - 00:15:25.940, Speaker A: Let me just comment out a few more things. All right, so, yeah, first we need to import some packages from Bikronomy SDK. But first I'll start with social login. So for that you import web3 auth. So I'll just do yarn. And for like rest of the things I'm just going to keep following the documentation. So you get an idea like which thing goes where.
00:15:25.940 - 00:17:18.330, Speaker A: So we'll write this here's. So this package gives you like all the types used within the SDK and main entry point or the package which is going to be used most is the smart account. So we'll go with the social login by the time I'll also install other things. Okay, so it says that you need to initialize the wallet. So I'll come here, I'll remove this stuff not getting the UA provider and since we are on Mumbai, I'll just change the chain ID. So after this we'll set the context. All right.
00:17:18.330 - 00:18:22.480, Speaker A: And here in login you need to show wallet. So if there is no login context then if there is no provider then basically I want to pop up the model for showing the wallet. So this basically tells you that what is the EO that you want to select? Whether it is going to be like social login or is it going to be MetaMask also because you can set up on top of MetaMask as well. So this is my login context show wallet. So I've done this part. Now the next thing is let me make sure I installed all the packages should be in my node modules already. Yeah, so now I'll go to this references section and we will install smart account package and then write the wallet connection.
00:18:22.480 - 00:19:50.144, Speaker A: So coming back here after here we can log the EO address like what is it is going to be generated using social login or it can be like your EO address as well. Now I will just set the so we'll follow this connect wallet for creating an instance of a smart account and then initializing it. And if you notice this wallet provider now becomes the provider which is coming from web3 auth. So for the options I think it's easier to copy from here. So what we are doing here is we are creating an instance of a smart account and I'm passing the wallet provider which we got from our current logging context. And then these are the options. Like by default SDK backend node will use the default values like in terms of supported network IDs.
00:19:50.144 - 00:20:49.620, Speaker A: But you can change these values. And for the network config if you want to use gasless transaction through the Paymaster dashboard then you need to provide a DAP API key. So the dashboard looks somewhat like this. You go to adapt and you copy the API key. Currently we are only supporting testnet for guestless transactions and for when user pays any RC 20 tokens you can also do on multiple main nets. So now we have an instance of smart account and you can log the address of the smart contract wallet like going to be my address and let me just set it to something. All right, so we have set a wallet provider and smart account address.
00:20:49.620 - 00:23:07.068, Speaker A: Now you can also go and since there is like if you want to also check what are the transactions so far on the smart contract wallet or if you need to get the balances you can use the balances endpoint which will fetch the balance from the SDK. So this gives you you can also get like USD value across all the supported chains which you have passed or you can also get like token amounts right? So if you need to show to the user in some form of widget right? Because once you go from EOA to using a smart contract wallet that becomes your primary identity right? So all the funds like you can query like which NFTs are there, which tokens are there and once this is done so we are ready to do the transactions basically. So what I'm going to do here is let me comment out some stuff here as well. So I'll shortly get into the demo of this working and when you initialize smart account if you're using webpack greater than five then you might run into some issues so we have added proper documentation to make your way through it. So I have done with the logout now we are not going to need these things anymore so I'll just start implementing in this here where we'll do like batching of both of these transactions. So let me copy what we are doing before for approve and now we don't need the EO address anymore and we'll create transaction array. So basically we are following batching transaction docs.
00:23:07.068 - 00:24:11.780, Speaker A: From here I use the API key which is shared across DApps on testnet but you can spin one using the dashboard backend as well. Once I've done this I also need to set up some watchers so basically once you get the transaction hash you do not need to go to any external service like block native to see what happened with the transaction on my smart contract wallet. So you can attach the listener basically using the Emitter, which is the smart account class itself in the SDK. So that goes in the login section once this stuff has been done. So you get the events like transaction hash has been generated and you also get the event when it gets mined or even when relayer resubmits a transaction and the hash gets changed. Right. So you get all the updates and then you can even get the receipt and show to the user directly what happened and this has to be created before you send any transaction so that it starts listening like what's happening on this now coming back to my implementation.
00:24:11.780 - 00:25:12.458, Speaker A: So I just want to create like an array so basically whatever you want to batch you can just keep adding the transactions right? Like I'm just doing very simple stuff but it could be like let's say you're doing a swap and then for that swap you will require approval once you get two tokens from the swap then you want to, let's say provide liquidity on some liquidity pool and then you get an NFT. Then you want to stake that NFT or move that liquidity to some other chains. So all of this can be combined as a batch transaction. Now I'll copy my second interaction which is setting this purpose. So I'll just take till this point. Let's push this. Okay, so now we are ready to dispatch this transaction through the relayer.
00:25:12.458 - 00:26:11.490, Speaker A: So let's say response and all of these APIs are available on smart account instance. So what I'm going to do is I want to send a batch of transaction and that has to be gasless. Like there are other methods. So if you notice here and even if you go to the documentation you get let's say send transaction is there, but you can prepare refund transaction batch which basically creates transaction payload in which the user itself will refund and no one is sponsoring for the gas fees. So for this we are going to go with this here and the array which I just created is going to be part of it. And let me comment out some other stuff which is just like it will show my EOA account and my smart contract wallet account as well here. All right.
00:26:11.490 - 00:27:06.780, Speaker A: And let me just replace so that everything is consistent. So now this demo gets updated and we can do several transactions, maybe using social login or even like using my MetaMask. Cool. So here I'm getting two options. Let's choose social login. So I need to open my Gmail. So it is constructing the private key using the Web Three network.
00:27:06.780 - 00:27:44.600, Speaker A: And now this is my EO address which has been just spin up like it says, a public private key pair which I'm going to use for signing. And this is my smart contract wallet address which is created by Biconomy SDK. And these wallets are counterfactual wallet address so it does not need to be deployed. So if you check on Mumbai Explorer, it's just an account, right? So you can send funds to it. It's a contract for me because I already done some transactions. But if it's a new user, it's just an account. You can send assets if it is supposed to pay to the relayer within the same transaction.
00:27:44.600 - 00:28:18.628, Speaker A: Otherwise it just gets created as a first section of the batch which will go through here. It's just one click. So where basically this guy needs to have some tokens which we use for previous interaction. And then you just do like one click. So maybe I can do from other ways as well. Like let me connect my MetaMask. So here my EOA becomes this guy.
00:28:18.628 - 00:28:45.324, Speaker A: It already has some tokens and my smart contract wallet address also changes which has been spinned up on top of this. You can do this in browser extensions as well. A lot of tooling like MetaMask snaps provided. So you can show in a widget kind of a view. Now let me check if or we can just send some tokens. Let me just check quickly. Cool.
00:28:45.324 - 00:29:50.440, Speaker A: So I already have some ethan tokens and minimum amount is one. So this is my fee token and this is the contract we are going to interact with directly right now. Let's come here and maybe let's say something like start integration. So in this case, this guy just needs to sign a message and then the transaction will go through on this smart account. It will go through the account abstraction entry point and it will utilize the paymaster which is associated with this DAP API key which we just added in the smart account config. And as you can see why I've wrote those listeners is that it is subscribing on the transaction ID we received from the relayer and you get all the updates. So we get that this transaction hash got mined.
00:29:50.440 - 00:30:44.904, Speaker A: So let's check this on Mumbai. Cool. So I paid two ETH India tokens before that I did approval of two tokens and I also managed to change the state on the contract. So the set purpose is there and now you go back to the contract, the state changes and everything is just one click and someone is sponsored for your gas fees. So you can do this for your end users or they can also pay in, ERC, 20 tokens using the account abstraction flow as well and using like there are some methods in the wallet itself which allows you to do that and anyone can. If you go through the docs, you can also plug in like your custom paymaster in the gasless section. So that's possible as well if you guys are building these kind of custom contracts.
00:30:44.904 - 00:31:19.852, Speaker A: So that was it for the demo for my site and yeah, I have just added some resources or links so there are other examples. What we did is that one of the products is Hyphen which is a cross chain bridge. So we folk that and added the Biconomy SDK support to it. So you can go here, play with it toggle and do Gases transactions or the transaction where user pays in whichever tokens they are. Let's say providing liquidity in. Right, so that's the thing. All right, cool.
00:31:19.852 - 00:31:42.370, Speaker A: Yeah, I'm almost done. Cool. I think I'll open to questions for 2 minutes and if you guys are hacking, just have fun and check out the price this using SDK you can apply for Biconomic Track or Ethereum Foundation track and build and have fun.
