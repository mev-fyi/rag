00:00:01.050 - 00:00:24.800, Speaker A: Hope everyone's hacking projects are going well so far. I know it's a really tight timeline to set up everything. I want to thank everybody for joining us again. We have an amazing session lined up for you today. We're joined by Sam from the Superfluid team. We're going to be taking questions at the end, so be sure to put your questions in the zoom chat below, and we'll get to them right after the session. But Sam, I know this isn't your first rodeo, and you need no introduction, so take it away.
00:00:26.650 - 00:00:27.426, Speaker B: Thank you, Luke.
00:00:27.458 - 00:00:39.820, Speaker C: I appreciate it. It's always fun to do these workshops. I just want to echo that. I hope all of your projects are off to a good start, and I'm excited to talk to you about Superfluid today. So I'm going to share my screen, and we will run through.
00:00:41.550 - 00:00:42.074, Speaker B: A little.
00:00:42.112 - 00:00:44.860, Speaker C: Presentation for you here. Give me 1 second.
00:00:46.430 - 00:00:47.420, Speaker B: All right.
00:00:49.310 - 00:01:01.550, Speaker C: We'Re sharing now. Let me move this over. I'm assuming that everybody can see my screen. Okay, somebody just speak up if you can't. Luke, speak up if you can. All right, I got the thumbs up. That's good.
00:01:01.550 - 00:01:42.646, Speaker C: Okay, so what we're going to talk about today is how you can integrate money streaming into your Dow operations. That'll be the overall theme. We're going to try to pack a fair bit in so we'll go through what Superfluid is, some resources I'm going to point you to to start building on Superfluid for your project this weekend. And then we'll go through a very simple Superfluid smart contract that will allow you to integrate money streaming into some Dow operations. So we get into this here. What is superfluid? Right, so, Superfluid is a protocol which supports what we call real time finance. And one of the things that you can do with Superfluid is create digital native programmable cash flows.
00:01:42.646 - 00:02:47.506, Speaker C: So we use stream money with no capital lockups so you don't have to lock up funds in order to stream money. And you can do it in a way that's completely programmable and on chain, which is great for you all as developers. So, thinking more about this idea, part of what really excites us about Superfluid is that we believe that the Internet is to information, what blockchain is to value. We're going to see a bunch of new use cases that are what Chris Dixon would call non skumorphic, so brand new use cases that are specific to how money can move in a world where we have this Internet of value. And when it comes to cash flows, one interesting thing to consider is that services flow in real time from a provider to a client, and that payments should work in the same way. If you're providing a subscription based service or if you are providing your service as an employee, you should get paid every second that you're providing that service. And that's possible now with things like Superfluid and with the money stream itself getting a bit more detailed on what it is and what it can do.
00:02:47.506 - 00:03:06.050, Speaker C: Within Superfluid, a money stream is basically just a continuous payment that's an open ended connection between two accounts. Again, this provides a really cool direct link between value transfer and service provision. And it also allows you to embed these kind of payment terms on chain.
00:03:06.130 - 00:03:06.374, Speaker B: Right?
00:03:06.412 - 00:03:42.366, Speaker C: So if I agree to send you $10 per day indefinitely, those are payment terms that is on chain. I can use the graph and query that and provably have some kind of proof that I'm paying you or you're paying me in an on chain way that's verifiable by a third party. And this helps because it prevents any kind of delays around payment risk during the payments process. We all might have an experience of getting paid a bit later than we should have or something like that. Superfluid can help prevent that. So what is the protocol? How is this working under the hood?
00:03:42.478 - 00:03:42.802, Speaker B: Right?
00:03:42.856 - 00:04:22.414, Speaker C: So we have three high level aspects to the protocol. One of them is the overall protocol. Like superfluid host of the protocol. This is kind of like the brain of everything. We also have an agreement library which effectively encodes how the stream should work, right? So right now we have just a constant flow agreement which allows you to send a constant amount of tokens. Every second we have a new decaying flow agreement coming out which sends them kind of on a curve or exponentially decays. That's the agreement library, right? Basically, like I said, library of different things that can mitigate value transfer.
00:04:22.414 - 00:05:02.522, Speaker C: And then the third aspect to the protocol that's important are super tokens. So super tokens allow you to be able to calculate a real time balance at any given point in time. And what's happening is that the super token has a function on it called real time balance of which allows us to calculate all of the incoming and outgoing flows you're receiving and combine that with whatever your static token balance is. Maybe you have 100 super tokens in your wallet. We'll take that plus all of your flows into consideration and be able to get your balance at any given point in time. So again, we can unpack this all day. There's a lot of depth here, but I will leave it somewhat high level at that.
00:05:02.522 - 00:05:30.082, Speaker C: But what I do want to get across here is that this is all very programmable, right? You can create cash flow where smart contracts, right? I can send a stream into a superfluid contract, right? A superfluid super app as they're called. And inside those contracts I can have Callbacks execute to perform cool operations whenever a stream is created, updated or deleted with that contract as one of the receivers.
00:05:30.146 - 00:05:30.422, Speaker B: Right?
00:05:30.476 - 00:05:47.974, Speaker C: So as one example, what you could do is you could create something like a Tradable cash flow where you send funds into an NFT contract and then have that NFT contract send 100% of the funds coming in to whoever the owner is so that anytime I transfer, the NFT funds are then sent to the new owner.
00:05:48.022 - 00:05:48.234, Speaker B: Right?
00:05:48.272 - 00:06:40.154, Speaker C: So that's just one of many things you can do with programmable cash flows, right? And again, these programmable cash flows are called super apps. These are reactive smart contracts where you can put any arbitrary logic inside of these callbacks that can run whenever a stream is created, updated, or deleted with that account as a receiver. Okay, that's a high level overview of Superfluid. Getting a bit more tangible and specific for you now. We're really excited to be sponsoring Dow hacks. The ETH Global team always does a good job with these events, and we think Superfluid has a lot of interesting overlap with Dows. So in terms of our prizes, we have $3,000 for the best overall project built on Superfluid, 2000 for the best superfluid application for Dow Finance, 2000 for the best use of Superfluid and NFTs for Dows, and $1,000 for the best use of Superfluid and another sponsor's, tech.
00:06:40.154 - 00:07:24.026, Speaker C: So lots of good prizes out there for you and lots of other good sponsors if you want to integrate Superfluid with the different sponsors tech. So building on superfluid, right? Hopefully you're here because you're interested in building on Superfluid in some capacity. Let's get into how you can do this, both with some general places you can go that might be helpful and a bit more context on how things are working under the hood in the protocol. And then at the end, if we have time, we'll get through a bit of an example app that I've created. Okay, so one resource that you definitely should check out if you're considering building on Superfluid this weekend is the Developer console. You can find this at Console superfluid Finance. It will help you to manage the entire development process.
00:07:24.128 - 00:07:24.394, Speaker B: Right?
00:07:24.432 - 00:08:02.200, Speaker C: Very useful. Another place you should go is the Superfluid Dashboard, which is a more like visual way to create, update, and delete your streams so you can actually perform state changing operations at the dashboard. You can find that at app Superfluid Finance. And then on the development side, one thing you'll probably want to use is the Superfluid SDK core. So this is a really easy way for you to get started with Superfluid in JavaScript or TypeScript. And you can very easily create streams with a single line of code, right? So highly recommend checking that out. And we'll use that a bit when going through our example app.
00:08:02.200 - 00:08:39.966, Speaker C: Okay, so let's look at the basics of building on Superfluid. Right, so what's actually happening under the hood when you are working with these money streams and programmable cash flows? Well, like I mentioned earlier, there are roughly three things to keep in mind when looking at the protocol's architecture. One of them is the host contract, which is the brain of the protocol. You won't really interact with this directly, but it's good to know that it's there and basically controlling all the high level actions taking place. The second thing to keep in mind are agreements. So for working with money streams, we will be working with the Constant flow agreement. But we do have other agreements.
00:08:39.966 - 00:09:37.918, Speaker C: I mentioned the agreement where there's a decaying flow that will be available soon, but there's also something called the Instant Distribution Agreement, which allows you to send lots of separate transactions, not lots of separate transactions, but allows you to transfer tokens to large numbers of recipients in a single transaction. So we won't get into that today, but I do recommend checking it out. We have lots of good examples on it in our docs. And then finally, you'll want to keep in mind that you'll have to use super tokens here, right? So in our examples later, we'll use something called Daix, which is just a super token wrapped version of Dai. But again, you can learn more about super tokens and some of the exotic forms of them inside of our docs as well. But like I mentioned, we're going to be using Dai. So if we want to get super tokens, we know that interoperability is so important in our space, right? We are building money Legos, not money silos.
00:09:37.918 - 00:10:48.810, Speaker C: And in order to get Dai, you can just simply wrap your existing Dai to get the super token version. So you just call a single function on the DIAX contract. That function is called Upgrade, and will allow you to upgrade your ERC 20 die to super token die. If you ever want to redeem those tokens for the underlying, it's very easy to do that. You just call downgrade and all of the super token die that was minted to you is just burned, and you get back your underlying ERC 20 asset. So once you have super tokens, you'll want to then interact with an agreement of some kind to create a flow. And this is what's happening under the hood when you're making a call to the protocol, right? So we abstract this away from you using the SDK and some of our libraries in Solidity, but what's happening is you, as the sender of a flow, are technically making a call to the host contract, right? You're basically sending a transaction to the brain of the protocol, and inside of that transaction, you're telling the host which agreement I want to use, and within that agreement what function I want to call, right? So for example, if I want to create a flow, I'll call the superfluid host contract.
00:10:48.810 - 00:11:12.670, Speaker C: The host contract will call the Constant flow agreement, and it'll say inside of the initial call I made of the host contract, you'll be able to specify, I want to open a stream of ten dix per day to my friend, right? And boom, this process all flows through and a stream is open from you to your recipient.
00:11:12.750 - 00:11:13.330, Speaker B: Right?
00:11:13.480 - 00:11:19.510, Speaker C: Again, we abstract this away from you, but I do just like giving people an insight about what's going on under the hood.
00:11:20.490 - 00:11:21.046, Speaker B: Okay?
00:11:21.148 - 00:12:24.102, Speaker C: Those are some basics it's time to build. Okay? So to give you a bit of background for what we're going to build, we need to talk about this idea of network cash flows and how they relate to Dows. So again, as a reminder, we enable these programmable cash flows. And one interesting thing to think about with these programmable cash flows is what happens when assets can continuously flow through an organization in a very automated way. So if I want to make sure that my Dao is budgeting correctly and I want to make sure that cash coming into the Dao is being sent properly to subgroups and that those subgroups are able to send cash flows to their individual contributors, how might Superflu be able to help with that? Well, we think that Dow Treasury management could probably be done in a more effective and automated way. And one way to look at this might be to use NFTs and Superfood streams as a way to manage this internal budgeting.
00:12:24.166 - 00:12:24.394, Speaker B: Right.
00:12:24.432 - 00:12:42.970, Speaker C: So you can imagine I have this good champagne visual for you here I think has least helped me when thinking through this example. At the top, someone's pouring the champagne into that top glass, right? You can think of that top glass as like the Dow itself. So the Dow, not every Dow has cash flow.
00:12:43.050 - 00:12:43.390, Speaker B: Right.
00:12:43.460 - 00:13:22.086, Speaker C: But we expect as more and more Dows are created, there will be some form of cash coming into the Dow. What that Dow then needs to do is easily funnel it to the subglasses, right? So you can think of those glasses as individual working groups and then maybe at the very bottom, maybe those are individual contributors to each of the working groups. Right. In our example, what we're going to do is we're going to create a system to allow you to issue NFTs to working groups within a Dao. And then every time you issue an NFT, that NFT comes attached with a superfluid stream.
00:13:22.278 - 00:13:22.682, Speaker B: Right?
00:13:22.736 - 00:13:37.150, Speaker C: And if I ever want to edit the NFT as the leader of the Dao, so I'm sending less or more to each individual working group. We'll make it easy to do that and we can also make it easy to merge and split those NFTs into more NFTs in separate cash flows.
00:13:37.230 - 00:13:37.522, Speaker B: Right?
00:13:37.576 - 00:14:19.694, Speaker C: So we'll go through that example in a second. But as a recap, what we're going to build is a contract that stores and manages NFTs that then manage the Dow's overall budget. Okay? We don't have a ton of time. We'll do this in five or ten minutes. But what's going to happen is the Dow is going to make sure that funds are sent into this contract and the contract's owner is going to be able to mint new NFTs to the addresses that manage the sub portions of the Dao. Why is this interesting? Well, again, to recap, DAOs need an easy way to manage the flow of funds within an organization. And it'd be nice if there was some kind of good accounting mechanism like an NFT to do this.
00:14:19.732 - 00:14:19.982, Speaker B: Right.
00:14:20.036 - 00:14:29.666, Speaker C: Maybe they can be tradable. When you trade the NFT, it comes with the cash flow. Maybe if you want to sell a portion of the Dow, you just trade the NFT and the cash flow comes along with it.
00:14:29.688 - 00:14:29.826, Speaker B: Right.
00:14:29.848 - 00:14:35.698, Speaker C: You can get very creative with this. So from an architecture point of view, how is this going to look?
00:14:35.784 - 00:14:36.514, Speaker B: Right?
00:14:36.712 - 00:15:20.846, Speaker C: So the Dow Treasury there is separate from our system, but we can imagine the Dow Treasury as the owner of this budget contract here in the middle. The Dow Treasury is going to send funds to the budget contract and then the owner of the budget contract, which presumably will be the Dow Treasury, will mint NFTs to sub working groups. Okay, so this is more of a textual recap here. I'm not really going to go through this because we kind of just talk through it. But what I'm going to do now is actually go through writing some code to do this. And I do want to let you know that as I go through it, we do have the example sitting in our examples repo. So if you go to our protocol monorepo, right? Just look up Superfluid and GitHub protocol monorepo and examples.
00:15:20.846 - 00:15:50.540, Speaker C: You will see the budget NFT example in there. Okay. So we will pull up my code editor here and I'll more so just talk through the example just due to in the interest of time. But let me pull this up and let me make my font much, much bigger for you. Give me 1 second here. Let's zoom way in. That might be too much.
00:15:50.540 - 00:16:16.038, Speaker C: All right. I hope the font is okay. Let me check the chat to make sure that no one has any complaints about the font. Just drop a complaint into the chat if the font is too small, no worries. But you'll see here that this project is pretty simply set up right there's. Basically just a single NFT here or NFT. This budgetnft sol is a single contract here and we have some scripts that we can use to interact with this.
00:16:16.038 - 00:17:04.180, Speaker C: Okay, so this contract is an ERC 721 contract. It's also ownable and what we're doing is allowing outsiders to come in and issue NFTs or not outsiders, but the Dow Treasury is going to be able to issue NFTs. They'll be able to edit the NFTs. And then if we want, we can also burn NFTs, split the streams into additional NFTs and then also merge NFTs into one. Okay, so this is just good for overall cash flow management. And what happens when I issue an NFT? So this upper level function is called minimize. This a bit, which calls this internal function.
00:17:04.180 - 00:18:09.690, Speaker C: What it does is we're basically storing what the flow rates of each NFT are. So we have token IDs generated for each individual NFT that's issued. And what we do is we just have this mapping here that's going to map the token ID to whatever flow rate was just passed in here. We'll make an event when that happens. And then right after we make this change inside of our contract storage, we will mint the NFT itself. Okay, so we have the mint and then we also can see that we have this before token transfer hook implemented, right? So this is an extra utility on ERC 721 contract you can use if you want. And what happens here is we get the old receiver, new receiver and token ID so that anytime I transfer the NFT, what we do is we can either increase the flow or reduce the flow to make sure that the attached flow to the NFT is being sent to the right person in the right amount.
00:18:09.690 - 00:19:03.670, Speaker C: Okay, so for example, inside of increased flow, let's go down a bit. All right, so if the current outflow rate is zero, right, meaning there is no stream to this new owner of the NFT, what we're going to do is we're going to create a flow to the new receiver of that NFT and make sure it's at the correct flow rate. So you can see what this create flow is. It's just a call to the superfluid host contract, right? And what we're doing is we're passing in the logic you want to call on the constant flow agreement contract. So we're passing in the token we want to use the address we're sending it to and the flow rate. And just for context, the flow rate is the number of tokens you want to send per second. So you can learn more about how this call is actually working inside of the solidity examples of the superfluid docs.
00:19:03.670 - 00:20:04.014, Speaker C: It's actually even easier now to create a flow like this because of the fact that we have a new library lets you do this in a single line of code. But that's a bit of an insight into what's happening under the hood there. So, okay, we have the issue NFT function. What about with an edit of an NFT, right? So what happens when we edit is we just pass in the token ID of the NFT we want to edit and the flow rate. So when this happens, what we do is we at the end of the function just change the flow rate here in our mapping so that the Token ID is now mapped to a different flow rate. And then we actually go in and either reduce the flow if the flow rate is decreasing or we increase the flow if the flow rate is increasing. And finally, if we look at the split stream and merge stream, what we're doing here is we're allowing the owner of an NFT to split their stream into like a set of so this is the use case here.
00:20:04.014 - 00:20:56.046, Speaker C: Is I am a subgroup within a dow and I have individual contributors that I kind of want to effectively hire to manage my different aspects of my subgroup. Right? So I am splitting my department into individual contributors that I want to send the cash flow to. We can do that using the split stream. So what we're going to do here is take the token ID that I want to split. We're going to set the new token flow rate, which is basically just going to be how much I want both my original NFT that I'm splitting and the new NFT that I'm splitting it into. How much do I want them to receive? Right, so if I set this new token flow rate to be half of the flow rate coming into my NFT, now we're just going to get 50% each of that flow that was originally coming into the parent NFT. And then same thing here.
00:20:56.046 - 00:21:40.490, Speaker C: We're handling things in our mapping and then we're calling reduced flow, which needs to happen if we are splitting it, and we're issuing a new NFT to that new owner. Okay, so like I said, you can go read through all of this logic in detail inside of our repo. I don't have time to go through every single line just due to the fact that this is a 30 minutes workshop. But if you want, I'm happy to spend time with you one on one and walk through how all of this is working in Solidity, if you'd like. So that's the contract. I've also written a couple of scripts in my local environments to help us interact with this. So one of those scripts is this script to deploy.
00:21:40.490 - 00:22:20.410, Speaker C: So this is just done using standard Ethers methods. So I am just creating a signer here. I'm actually using the superfluid SDK to create a signer, but you could do this in Ethers as well. I'm using the Ethers Git contract factory here and making sure that it's being deployed from an account that I have the private key of. We're deploying it here and then we'll just log it. Okay, so let me run this script. Hard hat run scripts, deploy budget NFT JS.
00:22:20.410 - 00:22:59.320, Speaker C: Okay, that's deploying. Can we deploy our own super tokens? This is a question coming in. You can deploy your own super tokens. You can actually either deploy a super token that we call a native super token, which has no underlying ERC 20 asset, or you can just deploy a wrapper on any ERC 20 token you want to use. So if you have a governance token in your Dow that you want to wrap, it's very easy to do that. At the end of the call, I can probably quickly grab the link for you with instructions on how to do that. Okay, so back to our application here.
00:22:59.320 - 00:23:17.530, Speaker C: This budget NFT was just deployed correctly. Fantastic. So now I'm going to copy the address here so we can use it in some of our other scripts. So I'm going to paste it into this script. And what's happening in this Create Flow script is I am sending a stream into the budget.
00:23:18.030 - 00:23:18.682, Speaker B: Okay?
00:23:18.816 - 00:23:45.362, Speaker C: So this is important because the budget NFT contract needs to have some funds to distribute to the sub NFTs. So we're imagining that we're calling this as the Dow Treasury owner. We're making sure that funds are sent into the contract so they can be sent to the subgroups within the Dao. So this is all set up here. What I'm using is the superfluid SDK core to create a stream. It's very simple to do so.
00:23:45.416 - 00:23:45.634, Speaker B: Right?
00:23:45.672 - 00:24:22.446, Speaker C: All you have to do is call SF CFAV One, create Flow, pass in your receiver, pass in your super token, and pass in the flow rate you want to use. And again, the flow rate is the number of tokens to send per second in way. Okay, so I think this is roughly $100 per month, maybe more. It actually might be more it might be more like 1000. Okay, so I'm going to run this script now. We'll create a flow. All right.
00:24:22.446 - 00:24:49.318, Speaker C: And before I do that, while this actually works, I'm going to go to our superfluid developer console and show you how you can manage some of this. Let me slide my browser over onto the page. All right, zoom in on it a bit. Inside of the superfluid console, you can search any address if you want. So here I'm at Console Superfluid Finance. Let me just go home so you can see it. I can type in any address in any network.
00:24:49.318 - 00:25:00.620, Speaker C: So this is the address of the newly deployed token here or contract here, rather. Let me search one more time.
00:25:01.150 - 00:25:01.562, Speaker B: Okay.
00:25:01.616 - 00:25:25.060, Speaker C: We have an address on Coban, which is a test that I'm using. I am sending funds into the contract, which is great. We see that this transaction just went through correctly. And now we have a flow rate of $333 per day. So this is actually much more than $1,000 per month. This is quite a few this is more like, I think, $10,000 per month. All right, so a stream is being sent in.
00:25:25.060 - 00:26:00.400, Speaker C: Now let's make sure that a stream can come out of this contract. Let's make sure that calling that issue NFT function indeed does issue the NFT and then also issue a stream to the address we're going to send that NFT to. All right, so another script here. Inside of issue NFT, we're just getting the contract instance of the deployed budget NFT. Let me make sure that I have the correct address here. You just copy this address issue NFT. I'll save that.
00:26:00.400 - 00:26:52.030, Speaker C: Again, all we're doing is we're just getting the deployed instance of that NFT, connecting it to our assigner passing in the address we want to send the NFT to and then the flow rate. All right, so let me run this issue NFT JS. All right, so while this loads, let me look back at our question chat. No questions issuing NFT from a contract and all right, this transaction was also successful. So if we want we can see the hash on COVID ether scan if we want. You head back up here, see if it propagated. All right, looks like it's still loading.
00:26:52.030 - 00:27:40.398, Speaker C: What we'll see here in a second is that the contract will have not just an incoming stream, but it will also have an outgoing stream. There we go. We are indeed sending the stream to this address, ending in six B three, which is correct here. All right, so an NFT was just issued and a stream was created that went along with that NFT. I have another script written for editing the NFT. I don't think we have time to go into it because I do want to open up the floor for a couple of questions. But as a recap, what we just did is we deployed a smart contract that is able to receive a stream and it has functions on it that we can call to both issue NFTs that are attached with superfluid streams to them.
00:27:40.398 - 00:28:17.514, Speaker C: And there are ways to manage this within a dow. If you'd like, you can edit the NFTs over time. If you'd like to, you can merge them, split them and yeah, this is a good potential starter project for those of you looking to integrate superfluid functionality and things that can really help dows on a day to day basis. So I hope that was helpful. I am here if you have any questions on this particular project and I'd love to open up the floor for a couple of questions while we still have a bit of time. So let me stop the share and we'll look at the chat. All right, so we have a question.
00:28:17.514 - 00:28:24.126, Speaker C: Is there a way to get streamed amount per some amount of time?
00:28:24.228 - 00:28:24.846, Speaker B: E g?
00:28:24.948 - 00:28:41.890, Speaker C: Can I know how much I streamed to address X in the last week? Yes, you can. So we have our own subgraph deployed and if you want, you can not only just query the subgraph, which we have examples for in our docs, but you can also use our SDK to ask the same kinds of questions.
00:28:41.960 - 00:28:42.146, Speaker B: Right?
00:28:42.168 - 00:29:29.070, Speaker C: So you can add your own queries inside of our SDK. Let me send you a link to our subgraph docs though. There's a good example in here. Current streaming time bias in your example is per second. Is it possible to do so in hours, weeks or months? So when you call the function that will create the stream, you do always have to pass in the number of tokens you want to send per second, right? If you want though, we have some example. Formulas that will allow you to calculate what an amount will be per second based on how many you want to send, how many tokens you want to send per month. And a good example place to do that is inside of our docs at the bottom of our Money streaming docs.
00:29:29.070 - 00:30:18.050, Speaker C: Let me send you a link here. You can type in an amount per month in way and just hit Calculate and you'll be able to get whatever that is per second. So use that example there that I just sent without creating contracts, can we use with API directly sending tokens in a streaming cancel? Yes, absolutely. So again, let me send a link to this Money streaming guide here which allows you to just create, update and delete streams using just JavaScript in the front end. There are three code examples you can take directly from this link and pull into your own projects. Can we set a limit to a flow? Good question. So when you create a flow now, it is constant and it is open ended.
00:30:18.050 - 00:30:58.234, Speaker C: So in order to stop the flow, there has to be another transaction sent to do so. There is a functionality being built into the protocol now by our protocol team that will allow you to set an end amount which will automatically close. But for now, for the sake of this hackathon, keep in mind that if you want a flow to end it at some date in the future, something is going to have to call Delete Flow or Update Flow at the end to make sure that stream is closed. If you run out of tokens, what happens is there's a network of what we call sentinels that are compensated to close streams that have run out of tokens.
00:30:58.282 - 00:30:58.494, Speaker B: Right?
00:30:58.532 - 00:31:51.360, Speaker C: And what they're compensated with is an initial escrow or buffer that you put up when you create the stream. So when you create a stream, there's 4 hours worth of your stream that's taken up as a kind of buffer. If you close the stream before your balance hit zero, you get that buffer amount back and in most cases it's a relatively small amount, right? If I'm sending 100 tokens per month, 4 hours worth of that is very little money. However, it's good to know that if you don't close your stream before your token balance runs out during that month or during any point in time that four hour deposit is taken. So just keep that in mind. All right, where can I find the link to the GitHub repo for the code you showed in a workshop? Good question. So let me send it here.
00:31:51.360 - 00:32:35.024, Speaker C: Budget NFT Hard Hat there's also a Truffle version of the project if you'd like to see that. But this is the hard hat version. It's just in our main GitHub repo in the examples folder. All right, any other questions that I may have missed? I've never used hard hat. Is it possible to deploy the contract using Remix and then interact using a front end. Totally. So what I'd suggest in that case is just to go into the Contracts folder, just grab the budgetnft Sol, and literally copy and paste that into Remix.
00:32:35.024 - 00:33:04.220, Speaker C: That'd be one way to get started. All right, that may be it for questions. One more one more question. Okay. Type fast. Are the streams public?
00:33:05.150 - 00:33:05.562, Speaker B: Yes.
00:33:05.616 - 00:33:20.800, Speaker C: So everything is on chain in that you can look it up on a Block Explorer, or you can use the Superfluid console to view each individual stream. Meaning, like, does everyone see the address sending and receiving? Yes.
00:33:22.290 - 00:33:22.702, Speaker B: Right?
00:33:22.756 - 00:33:24.666, Speaker C: Just like any other on chain transaction.
00:33:24.698 - 00:33:24.894, Speaker B: Right.
00:33:24.932 - 00:33:58.780, Speaker C: Now, obviously, granted, there are some zero knowledge protocols, and layer two starting most transactions work in the same way, in that if I send you funds, there's a transaction hash out there which shows that I sent you a certain amount of funds. Super Clear works the same way, unless in the near future, we're all able to deploy on ZKsync or StarkNet and make it all private. All right, thank you guys for some good questions. This was a good time.
00:33:59.230 - 00:34:13.360, Speaker A: And thank you, Sam. This is an amazing presentation. I'm sure everyone learned a lot heading into this weekend where that knowledge is going to be really super valuable for them. I want to thank everybody for joining us today and get excited for the kickoff in 30 minutes.
00:34:13.970 - 00:34:14.974, Speaker B: Looking forward to it.
00:34:15.012 - 00:34:31.262, Speaker C: One other thing I just want to stress is that if you're here and you made it this far and you watch the presentation, we really appreciate it, and I consider me as a resource all weekend for your projects. Hit me up anytime, even if it's non Superfluid related. You can find me in Discord under this handle.
00:34:31.326 - 00:34:31.666, Speaker B: Hang on.
00:34:31.688 - 00:34:33.570, Speaker C: Let me put this in quick and we can jump.
00:34:35.830 - 00:34:52.220, Speaker A: He's absolutely right. Make sure to continue the conversations in the Discord. It is an incredible resource as you're building your projects. There's a lot of knowledge in there. A lot of knowledgeable people like Sam and the rest of the Superfluid team. All right, we're going to be ending the session here.
00:34:52.910 - 00:34:53.610, Speaker B: Take care.
00:34:53.680 - 00:34:55.000, Speaker A: Good luck this weekend. Look.
