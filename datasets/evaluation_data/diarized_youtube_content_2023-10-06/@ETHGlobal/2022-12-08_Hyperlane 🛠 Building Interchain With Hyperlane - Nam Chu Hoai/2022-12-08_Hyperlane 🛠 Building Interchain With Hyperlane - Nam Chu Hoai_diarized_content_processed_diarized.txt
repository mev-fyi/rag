00:00:06.170 - 00:00:48.490, Speaker A: How's everybody doing? Like, it's been a long day. It's going to be a long weekend. Well, I appreciate you taking the time to learn more about Hyperlane. My name is Nam. I'm one of the co founders here at Hyperlane. And we are doing what we're calling building the interchange highway. So first you might ask yourself, like, what the fuck is the interchange highway? And what we think of the interchange highway is basically kind of the situation that we find ourselves today, where we have all of these really amazing blockchains, right? Blockchains are really all about kind of valuable state that can be accessed by anybody and modified by anybody, right? Like the analogy, usually it's like in our computers, but now we have so many of them that there's a lot of valuable state, but they're all isolated.
00:00:48.490 - 00:01:30.630, Speaker A: And so those kind of computers might as well be different galaxies. And the problem that arises is that the state is fragmented. And so when you build an application today, you have to pick one chain, which also means that you won't be able to access all the state on all the other chains. And so developers can only really serve users on that chain. They can't compose with protocols who are not on that chain. And oftentimes people, what they do is they end up just like unisop or sushi, right? They just end up deploying contracts on multiple chains. But for all intents and purposes, those deployments of the contracts are completely independent, basically, effectively different applications.
00:01:30.630 - 00:02:18.390, Speaker A: And so we know that that's just not going to be tenable, right? There's no world in where, let's say, the Internet is not composable across many different websites. And so the question is, what is the end state? And so people have thought about this problem for a while, right? We're not the first ones. There are what we call different eras of interoperability. So in 2016, we started with the Cosmos and polka dots of the world, right? That's where they got started. And so basically, they were able to derive interoperability protocols that are able to natively verify other chains that are built within the same context. So that's where kind of the Cosmos app chains kind of arise. Like IBC is able to natively verify the consensus of other chains via IBC.
00:02:18.390 - 00:03:11.260, Speaker A: However, 2020 comes around, and there's all of these alternate L1s popping up. And there was no interoperability protocol that existed between all of these other L1s. But at the same time, there were all these users who had this kind of goal of like, hey, there's salana popping up, avalanche popping up. So how do I get to use these applications, right? And so there's what we call these kind of like makeshift user facing bridges that came up and are now what we consider bridges for the most part, right? It's like end users going to a bridge, depositing the tokens into the bridge, and then getting either a wrap representation on the other side for them then to use. And so, yeah, most kind of bridge volume is basically through those bridges. But we also have seen, I think the kind of downside of those bridges because they're oftentimes built in an ad hoc way. There's been a lot of bridge hacks because there's no kind of native verification that can really happen.
00:03:11.260 - 00:04:06.678, Speaker A: And oftentimes new chains just come up with like an ad hoc bridge to build because they needed some value to come from Ethereum to their chain. And so we believe that 2022 is the start of what we call app centric interoperability. And so instead of an application making the user figure out a way to come to the application's chain, we think that applications will incorporate that problem of interoperability into the application itself and so that users are able to use the application from whatever chain they happen to be in. So we call those interchange applications. And so to be able to build these interchain applications, what you need is what we call interchange highway, right? Like this kind of division of the interchange singularity is like applications that just live on every chain. Users can use them wherever they happen to be. And so important piece for you to realize here is that hyperlain is not in of itself another blockchain.
00:04:06.678 - 00:04:53.798, Speaker A: And it doesn't rely on another blockchain to kind of like be solving all of our blockchain problems. And instead, hyperlain is a network in between blockchains that facilitates state transfers between the blockchains that we have today, but especially the blockchains that will come up in the future. And so our effort basically relies on us creating this safe, fast and accessible kind of highway between blockchains. And so how does it work at the kind of service? It's pretty simple. So we basically have what we call mailbox contracts on every chain. And so you as a sender, whether you're a smart contract or like an EOA, you basically call the dispatch function on the mailbox. When you call the dispatch function on the mailbox, what ends up happening is that message gets enqued in the on chain merkel tree in the mailbox.
00:04:53.798 - 00:05:45.500, Speaker A: And so then validators can observe that merkel tree on that origin chain mailbox create a signature and then on the destination chain the mailbox contract can verify those signatures alongside with a merkle proof for that message. Can then process the message by calling handle on the recipient of that message. And so the API is pretty simple, we think it's like this. So on the mailbox on the origin chain side you call dispatch with the destination chain which is like just an ID for the chain, the recipient. So the address on the destination chain and then the message which is just like arbitrary bytes that you can specify. And on a destination chain the recipient will be called with three parameters the origin chain. So where did the message come from the sender who sent the message, and then again, the message bytes that were sent.
00:05:45.500 - 00:06:15.654, Speaker A: And we have a Message Explorer that can kind of show you the progress of the message as it crosses the chain. And if I'm bold enough, I'll try the live demo right now. I think the Internet has been pretty rough, but let's see if that works. So, basically, what I will be doing is I'll just go through the quickstart tutorial and basically using MetaMask. And so first what we do is we have to find the mailbox contract on our origin chain. So there's a list of them right here. Can open them up.
00:06:15.654 - 00:06:45.430, Speaker A: Oops. Of course. I don't think that will work. I guess see, that's what happens when you try to do a live demo. We might have to come back to this. Let me try my phone. Nope.
00:06:45.430 - 00:07:09.190, Speaker A: All right. Give it 30 more seconds, and if not, I'll just have to skip the demo today. Up. Cool. All right. Yeah. So basically, on our docs here, you could find kind of like, all the mailbox contracts on all the different chains.
00:07:09.190 - 00:07:58.402, Speaker A: So let's say right now, let's try to send from Fuji to Mumbai. And so basically, what you can see here is we call the dispatch function, right? The first argument is, as I said, the domain IDs, and so you can find them on the docs as well. So the Domain ID of Mumbai in this case is 80,001 the recipient address. So in this case, it is bytes 32 instead of address, because not every chain has just 20 bytes for addresses, right? Like, eventually, like, Cosmos and Salana and others actually have 32 bytes for an address. And so if you send it to an EVM chain, you'll have to zero padded to 32 bytes. We have kind of pre deployed test recipient contracts on every chain, but you could also obviously just enter your own recipient in here right now. And then as a message body, you can again send arbitrary bytes.
00:07:58.402 - 00:08:38.580, Speaker A: And so we can just say, do hello from Eve, India, right? And then that's just ETF encoding into a particular string. So we'll do this, and then we can send the transaction. And hopefully, if everything goes well, we just call MetaMask right here. We get the transaction. There you go. So, in a moment, it will be mined right here. And as I mentioned, you can use the Hyperlain Explorer to kind of track the status of your message.
00:08:38.580 - 00:09:25.140, Speaker A: And so, hopefully, if you can see here that we are sending from Fuji to Mumbai, right? So you can kind of open it here so you can see the phases here that we send. A message. Transaction has to be finalized before validators can attest to the validity of the message in the Merkle tree. And then once the validators basically sign the merkel route, the relayer, which is permissionless, can process the transaction on the destination chain. And so I think we'll have to wait a couple of seconds. And in the meantime, I'll show you the test recipient contract. So this is the contract that we specified here on the sending side, right? And so all the contract does, let me show you what it does.
00:09:25.140 - 00:10:16.638, Speaker A: Recipient here is like on the handle function, right? Like it receives the origin, the sender and the call data. And so it will emit a message event here and then it will set these two state variables. Okay, cool. So it processed, we can look at the destination processing here on a destination chain. And then if we look at the logs, we can see the received message that was emitted by the test recipient, right? And so, as you saw, very simple, like sending a message across the chains. And it's as simple as calling a function call on a smart contract. So one thing we have noticed is that to be able to do this, you need to have a smart contract on the origin chain and the smart contract on the destination chain.
00:10:16.638 - 00:10:58.538, Speaker A: And we were constantly thinking, how can we make the developer experience better? Because basically the message API has no concept of what the data is that you're sending and how it's structured. However oftentimes what you want to do is you want to be able to make a function call on the destination chain, right? So let's say you have a Dao. Let's say you have a Dao on Ethereum where it lives. It wants to own assets on other chains. You could totally use the message API to basically deploy a smart contract on both sides and basically relay authenticated calls across. But we can just do this for you. And so interchange accounts are basically a middleware abstraction that allows senders on an origin chain to have a proxy account on a destination chain.
00:10:58.538 - 00:11:39.498, Speaker A: And that proxy account will only ever accept basically function calls that were sent from the origin sender. And so that basically allows for what we call a much kind of nicer experience because you basically abi and call the function call. You give that to hyperlane? Hyperlane will basically forward the call to that proxy account, what we call the ICA. And then that proxy account will make the call to the recipient. And so kind of the outcome of this is that on the origin chain, you make this function call, which is very similar. You just API encode the call as you normally would if it's a single chain context. And on the destination chain, you actually have to have no contract at all, like you're just making a direct function call from the ICA.
00:11:39.498 - 00:12:33.214, Speaker A: And so we can highlight that as well. So, again, on the page here on the accounts, we have the quickstart tutorial. So all we have to do is we have to go to the ICA router, which is this address. And we basically here have this dish function, right? Again, we have to specify the destination domain. So actually, let's do it again to Mumbai, the target, which is again our test recipient. And then this is the abi encoded function call, right? So in our quick start, you will see here that we're just going to call FUBAR with these two arguments. And I just kind of encoded these two arguments in here and that will ultimately generate this API encoded function call.
00:12:33.214 - 00:13:40.338, Speaker A: And so if we once again write this and do this on MetaMask, we'll have a transaction. And just to show you what the test recipient, this is the Fuba function call that will get called. And so let's once again look at our messages refresh. We got once again sending from Fuji to Mumbai. And then once this is processed in a hot second, actually, I'll just show this later because you can imagine what's going to happen. Like the call will be made and then on here, as you saw, we just emit this emit receive call event and we write those two variables that I can show you whenever that's done. All right, next one.
00:13:40.338 - 00:14:37.298, Speaker A: So that's if you want to basically write from an origin chain to a destination chain. But let's say, what if you want to actually do the reverse, right? So let's say you have a contract on polygon and you really want to access some state on ethereum, right? For example, like the V three TWAP on E to USDC, which is probably the most secure TWAP. But you're on polygon, so what do you do? Once again, we've kind of thought about what it would be a better developer experience. And the best thing would be if you on polygon can just abi encode the view call, send it to hyperlane and hyperlane will basically do the view call on ethereum for you and then call your contract on polygon with the results of that query. And so that's what interchange queries is. So the way it works, once again is that you basically pass to the query function your abi encoder function call. And then the callback, which is the function on your own contract that should be called hyperlane, will relay that message over to the hyper encoder on the destination chain.
00:14:37.298 - 00:15:21.410, Speaker A: It will make that call as you specified onto the sender. And then the result will be put again into a message back to the origin chain and that result will be put into the callback function as you specified. And so, again, the nice thing is that on the destination chain, there's no contract that you have to write just on the origin chain. You specify destination chain, the target you want to make the view call against the query, like the view call itself, API encoded and obviously the callback on the sender as well. And so, once again, let's do a demo, which is right here. Actually, wait, it's not right here. It is right here.
00:15:21.410 - 00:17:07.590, Speaker A: So basically this time it's a little different because we have this test query sender contract on the origin chain which will do the query right because in this particular case the way you receive the result is a function call on yourself on the sender and so we've pre deployed those contracts right here. You can see the interface of it here if you want to look at the contract real quick test query sender, right? So basically when you call query address all it will do is we'll call the query router on the hyperlan contract with the destination main the Abi encoded call and then the callback which is handle query address result which is this function. So basically if you as the developer just have to kind of like make this call and then you can expect that the hyperlain contract will call handle a query address result with the actual result that happened on the destination chain and so let's actually do that, right? So in this case let's say we are sending the Girly which is the domain five right here in this quick start example what we're doing is we are just reading the owner state variable of a particular contract. So in this case this is just a contract that we have and the owner of that is like one of our keys. But then basically the view call that we're making right, is like this owner and so that's Abi encoded. It's just this particular byte string. And so basically, if we do those three things, pass that to query address can once again make the query.
00:17:07.590 - 00:18:19.950, Speaker A: And this is maybe interesting because once the transaction is finalized, we can also see that our previous ICA account call was delivered. Let's see. Okay so we're sending from Fuji to Girly, right? And this is the query the first leg, right where we're basically saying like hey, what is the owner address of this particular account? And so let's wait until the transaction gets processed on the destination chain. And so to be clear what we're doing is right now is this part right? Like we're sending this message right now. Let's just see once that goes through. I think Gurley and Mumbai have been pretty congested or not congested but it's just like not as easy to include transactions lately anymore. But so once that goes through there you go right I guess it took only like what 20, 30 seconds.
00:18:19.950 - 00:19:23.010, Speaker A: So basically we're going to see is just open it in the block Explorer. Ah right. Like basically we returned this query so this is the address that we were reading. This is the result of the address and so this transaction hash actually ends up sending a message back to Fuji and so if we add this transaction hash to our search you can see it's actually two messages, right? Like one is the one from Fuji to Girly and then here is the one from Girly back to Fuji. And so that already processed. And so here on the Block Explorer, we are able to see that the query was resolved with this data. And that is the last address result here, right? Like you can see that this is the address that we got returned.
00:19:23.010 - 00:20:05.278, Speaker A: Cool. All right. So last but not least, sometimes what you want to do is you don't want to just send messages, but you actually want to send value, right? So the message API, all it does, it sends arbitrary bytes. But how do we decide what value is? Obviously, like a much bigger topic. If you're interested, come back to our booth to talk and talk more about it. But one thing that's a key part here is that whether you're actually sending canonical tokens versus wrapped tokens, right? So right now when you say, let's use wormhole to send USDC from ETH to Solana, actually what you end up doing is you're depositing USDC on ethereum and then portal mints like a wrapped USDC version on solana. And there's obviously all kinds of good and bad things about that.
00:20:05.278 - 00:20:46.270, Speaker A: We believe that there's going to be many different ways of transferring value. And so we have what we call the liquid layer API, which allows you to use, through a single interface, different value bridges, right? And so, for example, you will be able to use portal but also like circle's native USDC bridge, which burns USDC on, let's say, ethereum and then mints it on avalanche. And so you never have this kind of like wrapped token issue. And so the API looks very simpler. It's similar to the message API, where you send your specified destination chain, a recipient a message. And then the three additional arguments are the token that you're trying to bridge an amount, and then the string of the bridge itself. So in this case would be either circle or portal.
00:20:46.270 - 00:21:58.958, Speaker A: I'm going to skip the API demo here, but if you're curious, it is obviously on our docs page right here. And last but not least, the thing that I want to kind of highlight as well is that when I had this diagram here, it was very simplified, right, because basically it said like, oh, the mailbox of Val will verify signatures. But one of the key points that I think everyone should take away from this talk is that bridge security is very hard, right? Like, every second bridge basically has been hacked. And part of the reason why is that there's no such thing as one security model fits all a hacker here. If India has very different security requirements than, let's say, Uniswap. When it wants to do governance decisions to cross chains. And so we have what we call sovereign consensus, which allows the recipient to specify the security model under which the recipient accepts messages, right? And so, for example, in the simple case here, if India, you could say, oh, any validator signing a message is okay for me to accept a message, but if I'm uniswap, I might actually want higher security to accept messages.
00:21:58.958 - 00:22:44.500, Speaker A: And so basically you can create these things. What we call isms interchange security modules which the recipient points to. And then basically the hyperlane API will first call the Ism with like an Is valid function call. And only if that is true, it will actually call handle on the recipient. And so that allows applications to kind of specify their own security. And so in default case right now of Hyperlane, you have this validator set that you use, but you could imagine Isms that have optimistic modules, or you could imagine isms that for specific chain pairs actually use ZK bridge or something. And so we think that as a developer you are able to kind of opt in into the same API but will have different security going forward.
00:22:44.500 - 00:23:07.798, Speaker A: All right, I think that's it. I know we are all running behind, so if you have any questions, we have a booth over there. We'll be here all weekend. We also have Bounties ten K. And we're generally just looking for very creative users of Hyperlane. As we mentioned in the beginning of the talk, we believe that the future are interchange applications. Applications that live on every chain.
00:23:07.798 - 00:23:34.110, Speaker A: It just doesn't make sense to me to have an application that only lives on one chain and then all the other users, you're just like shit out of luck. You have to figure out a way to come to us, right? In no world our application successful if they just force users to jump through hoops to use your application. So, yeah, if you have any more questions, please come by our booth. And yeah, hope you have a good weekend. Bye.
