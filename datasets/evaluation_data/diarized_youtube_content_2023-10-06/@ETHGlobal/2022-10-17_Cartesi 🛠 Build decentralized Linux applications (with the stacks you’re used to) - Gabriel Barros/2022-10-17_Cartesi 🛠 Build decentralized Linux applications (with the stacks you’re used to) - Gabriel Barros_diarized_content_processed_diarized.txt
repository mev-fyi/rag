00:00:06.090 - 00:00:33.574, Speaker A: Hi there, guys. So I saw some of you at the booth already today. I'm going to talk about how Cartesi is bringing Linux to the blockchain. And I'm going to explain how that's possible. And I'm going to show you a Python example of how that works. So this is a quick overview of what we are going to do over here. So I'm going to talk a little bit about Cortesi, what it is, how long we've been around.
00:00:33.574 - 00:01:07.534, Speaker A: And I'm going to do a light comparison between web three, web two and Cartesi development. And then I'm going to actually talk about Cartesi roll ups. I'm going to introduce you to roll ups for those who are not familiar with it. And then I'm going to go dive into the code. However, I want to keep you hooked. This is the code we are going to investigate together. So this 25 207 line Python code that's actually importing libraries from normal python.
00:01:07.534 - 00:01:57.060, Speaker A: It's actually running on a virtual machine that can act as a roll up for Ethereum, for instance, this is actual smart contract. This one here is doing an echo python. So whatever you send it, you send it back on the blockchain for you. So Cortesi, cortesi is a company that was founded in 2018. These guys have been working a long time trying to bring a risk five. I'm going to talk about risk five, but a processor, a true processor to the blockchain, how to make it deterministic so you can do like normal computations. And that's why they're calling it the blockchain OS, because we actually brought the Linux for it.
00:01:57.060 - 00:02:38.080, Speaker A: So the overall idea, I guess you're all familiar with it, so I'm just going to run through it, is that Ethereum is awesome. It's secure, it's somewhat censorship resistant, decentralized. There's all these good features about Ethereum. However, it becomes slow, it is expensive. So DApps are actually fighting for space resource inside of the blocks to actually be processed. And it comes with a lot of friction for developers that are just coming to blockchain. So you have 30 years of experience, doesn't matter, you're going to start over all over again.
00:02:38.080 - 00:03:35.042, Speaker A: So the idea is, what if we can do complex computations and maintain the main layer's security guarantees? So here's the Kurtesi response to that. First, we use a transparent VM, so you are able to actually see the whole code. It's not somewhat complicated, but it's open source. Like the last guy was saying, compiler stuff is hard, but in any case, it's open to everybody to investigate it. And it is using the RISC Five, like I said. So RISC Five is an open hardware platform, just like open source, but for hardware. And it comes with a lot of security guarantees already because it's being audited by several companies and people, it keeps getting updated throughout the time.
00:03:35.042 - 00:04:34.340, Speaker A: So that's nice. Any person is allowed to build on top of it and it is a platform processor, which means you can actually have any kind of OS on it. It's a very robust machine and the only thing that we needed to actually adapt is to build a deterministic emulator. So we made RISC Five deterministic and because of that we could actually make the emulator for EVM as well. So whenever you run the computation off chain, it is possible to actually run the same computation on Ethereum. Right? Now, in fact, one of our acceptance tasks is to actually do the whole RISC Five acceptance test on chain. So of course it's a testnet or a local testnet, but we do it on the EVM just to prove that the version that we have on chain is the same exact version that we've developed in C plus plus.
00:04:34.340 - 00:05:42.954, Speaker A: So that allows you to have massive computation as a layer two. And with that, the whole way this works, the idea of to actually have the massive computation not become yet another limiter again, is to have local consensus. I guess people here are more familiar with app centric roll ups. So because of that, instead of having a lot of computation, doing the same work over and over again, effectively only having a single machine, which is the way the Ethereum works, you can actually have computational resources dedicated to each application. So every application, it is its own roll up. If you use the Cartesi framework, finally, the most important thing, it's to actually make you work with the blockchain, right? So that's where the dispute protocol comes in. It's not any novelty, it's actually been discussed for a long time.
00:05:42.954 - 00:06:42.590, Speaker A: So here we are using the verification game. The overall idea is you get the whole computation you did off chain. Let's say it took like 3000 cycles, CPU cycles, you find exactly where the validators diverge and you only have to execute a single CPU instruction cycle on Ethereum, which makes validating the whole process really cheap. So how to say the end result is Ethereum becomes a judge. So it means that if you have, I don't know, like four people playing a poker game and one of them win and the other three start to collude against the one that won, that single honest validator. That's all that you need a single honest validator to come to Ethereum and complain about the end result. And then Ethereum is going to judge who's telling the truth.
00:06:42.590 - 00:07:42.160, Speaker A: So you guarantee the correct settlement of computation. So for those who are not familiar with roll ups, the overall idea is you have the main chain, it has its own blocks. At some point you initiate the process, you tell Ethereum, here's the initial state of my roll up, and you go on with your life for a little while off chain doing computations. And once you're done, or once you want to do a checkpoint, because that's the idea of roll up, you're always checkpointing your process. You go back to the blockchain and with optimistic roll ups, you actually have like a seven day window for now. That's the agreed good time span for disputes. So you have a seven day window to actually complain about anything that went wrong on that block of computation, so to speak.
00:07:42.160 - 00:08:43.442, Speaker A: So how everything gets together, right? So before in web two, you used to have like some kind of a front end, a few APIs defined by you to be run in a centralized server or a set of centralized servers talking to a set of centralized databases, right? That's the main web two idea. So Ethereum comes up and say, you know, what the business logic, whatever is most important, you can actually decentralize that. So you figure out a way to deploy your front end. You could use IPFS, which is really nice, and you communicate with the blockchain. Cartesi doesn't change that too much. The overall idea is still you have the same feel as the Ethereum. You are supposed to have a set of nodes that you communicate with.
00:08:43.442 - 00:09:38.310, Speaker A: Just like what happens with Ethereum to have your back end be the base of your app. The main difference is instead of burden the developer with all the little things needed to actually communicate back to Ethereum, we are calling here http dispatcher. It's just an API that encapsulates all the complexities of communicating with the blockchain back. So basically what you need is just to communicate with a rest API. So there is a definition of that. There's three endpoints, you get to learn how the endpoints work and now you can develop your solidity, I'm sorry, your smart contract in any language. That's the overall idea and I'm going to show that in Python.
00:09:38.310 - 00:10:51.918, Speaker A: So how it actually looks like we have the three main pieces of APIs. The first one is the JSON RPC, it's just there. So that one is still like Ethereum. So you have a data availability issue, right? You're settling on process like on computational disputes, but it's still agony and chicken situation if you don't have an agreement, what was the input that you had for that process? So the idea, yes, let's keep using Ethereum or any other layer one networks to just communicate what were, I don't know, our chess moves for instance. So you have the JSON RPC, there still to do inputs to the roll ups. However, you have the GraphQL API that we developed and the GraphQL API is mostly so you can check on three things that we have on the Cartesian machine. So over here we have report and notice they are similar but different enough.
00:10:51.918 - 00:11:32.682, Speaker A: So report is any kind of log that you log within the Cortez machine. Think of it as a developer debug log. So it's not provable, it's ephemeral. You cannot do much with that. It's just to help you out while you're checking the health of a process or you're developing your DAP. However, the notice is our version of Ethereum events with a twist. So right now, if ERC, 20 token says there was a transfer between an A and B party of a sum amount, it's trustworthy enough.
00:11:32.682 - 00:12:06.742, Speaker A: If you're running the Ethereum node, however, you have no proof that the event actually exists. You have to be running the node to trust the event. The notice, however, comes with its own proof. So the notice is part of the machine state. So if you go back to Ethereum and you have to create other DApps and interact with other DApps inside Ethereum, or even on other optimistic roll ups, you can build upon the idea of having notices. So let's say you have a transfer happening inside an Ethereum machine. It doesn't need to be a direct call.
00:12:06.742 - 00:13:00.306, Speaker A: You just need to say, hey, I actually won the game, let's say an NFT generating situation. So in order to win this badge, like the winner, you have to prove that you won ten times the game. You just collect the ten notice and you can put it to be proven on Ethereum for instance. So that's how it is different from an event and Voucher, the final one is basically Ethereum transaction that is yet to be. So whenever your roll up DAP wants to communicate back to a smart contract in Solidity, for instance, it creates a Voucher. And if the optimistic relapse settles and there is no disputes on that, after the seven day window, the Voucher becomes executable. So it becomes actually an Ethereum transaction.
00:13:00.306 - 00:13:44.450, Speaker A: So you as a user could just call it and claim the Voucher, or you could let the validators on the network do it for you. There is like fees and other stuff going on on that. So that's why you have the GraphQL API. Because if you want to populate your front end with that kind of information, you can access it directly calling the node. Finally, we have an ATP Rest API that works like ETH call for those who are familiar with Ethereum. Basically it's any call that you do to the machine that is not state transitioning. So we ensure that this call, we always roll back to the initial state of the machine.
00:13:44.450 - 00:14:25.166, Speaker A: That's the main difference. And that call only can generate reports because that's what I said before, right? It's something that it's not provable. So the idea is to have quick depth communication. You can use it to grab data for your UI and you can use it as a debugging solution as well. It's easier to check up on the state of your machine, of your program. So now I go back to the Python example. So to this yellow side over here, we have a tool on our roll up examples repository.
00:14:25.166 - 00:15:10.942, Speaker A: But basically they're encapsulating JavaScript code, like how to actually call stuff through the jarpc, right? It's a helper tool. And over the blue side I have the actual Python DAP. So we're going to start sending like a payload with just, hello there it is just a transaction call data. Nothing special about it. And we are going to start checking what happens on the code. So from the beginning, you can see that I can use all the support that Python offers me. And I'm going to start using requests because I want to talk to the API that I just talked about.
00:15:10.942 - 00:15:45.478, Speaker A: Right. I want to be able to do Http requests I grab from the environment. Where is the actual URL for the Http API within the machine. So we provide you with that environment variable for you. So you can actually just grab it without hard coding it on your code. And here we have the two types of handlers I was just talking about. But from the API's perspective within the machine, here are the two types.
00:15:45.478 - 00:16:15.010, Speaker A: If you receive an inspect state kind of a request, it means that the whole machine, the whole Emulator will revert back. Oh, something happened. Okay, now we're back. So it will revert back to the previous state before the request. However, if it is advanced state, it's basically telling you this is going to change the state. So you should do it properly. Basically with that, it's just the high level.
00:16:15.010 - 00:16:44.266, Speaker A: You can subscribe and create as many endpoints as you wish. It's just like solidity in a sense. At the solidity code, you basically have the entry point and you do all the switch for the functions. Right here, you have the main loop. So the idea is that this machine outs. It doesn't stop, it just out. So every time you finish a request, processing the request, it just halts at the end and wakes up at the next input.
00:16:44.266 - 00:17:09.122, Speaker A: So this finish over here is actually kind of like a Next. So it's actually saying, hey, I'm ready. Wake me up whenever you have something. So you stop over here. So as we begin for the first time at a code, you're going to see that I have like finished status accept. And that's what I'm sending to the Emulator beneath it. And it's going to halt.
00:17:09.122 - 00:17:46.994, Speaker A: And then when I say hello there, it's going to wake up the code exactly at this line. And from here on out, we are just going to process this request. So I send an input. So it should be an advanced state kind of request. So we're going to just pick up the JSON data from there, actually go to the handler that is responsible for that, so that's the advanced state and add a function. At this time, I'm just going to create a notice, just the notice with the same data I just received. So I grab the data payload and put it in the notice payload back.
00:17:46.994 - 00:18:07.394, Speaker A: It's just a simple program in this case. And I'm going to call the API. Creating a notice, that's what that's doing. It's not going to how the machine. It's just saying, hey, here's something that it is an output from this process and I can call it as many times as I wish. Okay. And the result is accept.
00:18:07.394 - 00:18:47.586, Speaker A: Again, it's all fine. So I'm just going to jump over the Inspect for a second. So I would just add to the status accept and because I am in a loop, I'm going to end up here to finish again, sending the accept status halting the whole machine. However, if I had the handler of the type Inspect, meaning instead of sending an input over there, I would actually try to inspect the machine saying, hello there. You would go to this different handler. You would create just a report. Just like the notice is not that different when you see the code and it's the same.
00:18:47.586 - 00:19:22.372, Speaker A: I just finish and whenever I ask for the helper to list all the new notices that there is there, you're going to see that the machine would return you with the hello there as a payload. And that's the overall idea. Do you guys have questions? I guess it's too much. Yes. Can you make arbitrary? Oh yes. It's still a blockchain environment. So in a sense you're not connected to the Internet.
00:19:22.372 - 00:19:47.810, Speaker A: You can have internet at the Cartesian machine when you're first building it. So remember the roll ups example thing I was doing like initial state. So let's say you're building your machine, building all the DAP, and you need data. So I don't know, docker images and NPM installs and things. You can have that for sure. But once you're in the roll up environment, you don't have that access anymore. Makes sense.
00:19:47.810 - 00:20:21.456, Speaker A: Go ahead. What's the cost of deployment? So there is the cost of deployment of the roll ups itself, like the set of smart contracts and stuff. It's not that high. I don't actually have a right figure for you right now, but it should be something around like $50 or something for Ethereum right now. But just so we have all the insertion points, so to speak, on Ethereum. Because this DAP actually has a mirror address on Ethereum. So other DApps can communicate through it back to the Cartesi roll ups.
00:20:21.456 - 00:21:01.640, Speaker A: But in terms of actual cost of running this thing is up to the depth developer. You say, do you want to charge people for using it? Do you want to just you and other developers run the nodes? Do you want to incentivize your users to run the nodes? It's up to you. In the sense cortez is more like a framework, really, because it's really app specific. You tell the parameters. You don't like the seven days because you're doing a simple game like if really simple, low stakes, maybe it's just 5 hours for your roll up settlement window. Makes sense. You had a question.
00:21:01.640 - 00:21:29.264, Speaker A: Yeah. Are the expectations that everyone is going to be running their own infrastructure like they are setting up the machine that is going to be running. I mean, it's up to the DAP developer if it is something that makes sense, I guess. Sure. But right now we're in the middle. Right. We understand that mostly we're still going to have these service providers running the nodes and people kind of like trusting them.
00:21:29.264 - 00:21:37.570, Speaker A: Yeah. Any more questions? Okay. Thank you.
