00:00:32.060 - 00:02:58.640, Speaker A: Quite the school. Yeah, right now make white everything. Maybe I make.
00:03:12.860 - 00:03:13.610, Speaker B: It.
00:03:17.180 - 00:03:18.040, Speaker A: Figured.
00:04:31.530 - 00:04:34.960, Speaker B: Ten from you.
00:06:01.670 - 00:06:35.346, Speaker A: But I wonder like me like but.
00:06:35.368 - 00:07:42.490, Speaker B: I can't wait for her there's.
00:09:06.090 - 00:09:07.400, Speaker A: I think like I.
00:10:21.950 - 00:11:10.150, Speaker C: I think we are shortly ready to start. So I would just love to welcome everyone who is here today, who is joining us from the stream as well. And today we'll be talking about introduction to IPFS and Filecoin and how they shape the future of Web Free. There'll be multiple topics we are covering during the session so at the end of it I will also give some time to answer all your questions so feel free to stay tuned and we'll be here also during the hackathon. So let us know about all your questions and ideas about building projects during the hack. To start with, there are multiple projects which we have inside the Protocol Labs. Myself, I'm a startup operator at Protocol Labs but we work as a community of people and organizations that are building better future through the technology.
00:11:10.150 - 00:12:08.598, Speaker C: There is protocol labs, which is open source r d organization. There is a Filecoin Foundation which is a steward of Filecoin community which is aspiring to put the power of humanity most important information back into the hands of everyone. And there are also multiple core solutions such as IPFS which is a peer to peer protocol that making web upgradable, resilient and more open. You can think of it as a peer to peer version of an Http and there is a File coil which is a decentralized storage network to store humanity's most important information. You can also think about it as an airbnb for storage and those are multiple components which come together in one place to be the Web Free layer foundation for the data storage and much much more. So we'll go through agenda today which first will be the core concepts of IPFS and Filecoin. Then I will tell you more about the tools of Web Free which will be particularly handy for you during the hackathon to build straight away on top of IPFS and Filecoin.
00:12:08.598 - 00:13:10.574, Speaker C: I'll also highlight you the possibilities of webfree right now to give you a bit more ideas of what is possible, what could be done and maybe that will be helpful for some of you to brainstorm your ideas further and there will be also some learning resources and discussion Q A in the end. So starting with the concepts of IPFS and File coin, I will not go into too much details what exactly Web Free is but trust me that we are on somewhere transitioning from web two to Web Free where web two was read and write. So you could write an information on the internet and you can read it from and now we're transferring to Web Free which is Read, Write and Trust. And trust here is being an operative thing where you can verify some information on the internet directly without having a prior knowledge to it. It also being supported by a bunch of underlying primitives and technology that builds up verifiability directly in webfree. Moreover, webfree stack is for web free. Stack verifiable data is essential for a truly distributed system.
00:13:10.574 - 00:14:33.146, Speaker C: This image is already quite outdated because the web free is exploding like hell and there are more and more projects appearing each and every second. But at the same time the file storage is still a core fundamental piece of it. Moreover, you can place now us not only in file storage as it is with IPFS and Filecoin, but you can also definitely move us to the cold storage solutions and with soon updates of the filecoin where we're developing smart contracts and Filecoin virtual machine, you could also easily place us to the layer one blockchains with smart logic and smart contracts. So once again we are somewhere in transition between web Two and web Three, where web two is being centralized solution, where the data, knowledge and information is being kept at a centralized point and we barely have the ownership of that data which is being centralized. It's a critical point to the human development and that's why we at Protocol Labs believe that this distribution of the knowledge and distribution of the power should be safeguarded and that knowledge should be open and in the hands of people. But at the moment data, information, knowledge is not publicly open and publicly owned. And there are few companies which you're familiar, which is Google, Amazon, Apple, which are being the silos of the data and limiting the ownership of that.
00:14:33.146 - 00:15:39.966, Speaker C: And if some of this solution fails due to the system being centralized, it fails altogether and you basically lose access to your knowledge. What you can do. Instead of having a centralized solution where you have single points of failure, where your data is monetized by the data monoliths, you can have a decentralized or even better distributed system where the users have the power to manage their data, where the users power the service themselves and at the same time the infrastructure which is being developed in a peer to peer manner. It's also being censorship resistant. It ensures the privacy of your data. You can self verify all the content which you're having in the web and the data is being non siloed, meaning that at any point of time you can discover the information that you are really interested in without any limitations. And I will tell you in the next 15 minutes or in the next half an hour what is IPFS and Filecoin and how they contribute to this vision of distributed decentralized web free internet and how to build on top of those protocols to make sure that you're really going to the future in the web free.
00:15:39.966 - 00:16:37.998, Speaker C: And moreover, I will tell you that files and folders is not a boring thing. So first of all, IPFS is an interplanetary file system which where files and systems is file system is obviously files and folders. You are familiar with them already. You work with computers all the time so there's just the same thing while interplanetary thing is way way more interesting. Imagine that you have to send imagine at some point we reach Mars and we'll have to send information from Mars to Earth. If we maintain these centralized solutions for any call or any update or to watch a video, you'll have to make a call from Mars to Earth and from Earth to Mars backwards and this will at least for one call take you an hour. So that's not very scalable solution when you think about expanding to other planets or generally just expanding your network.
00:16:37.998 - 00:18:03.294, Speaker C: And that's where IPFS is coming handy into the place because of distributed solution in the first place it allows you to download the files not from the central place somewhere on Earth, but rather have if someone has it already cached on the Mars, you can directly retrieve it from them. Therefore connecting and creating a network of peer to peer data exchange where everyone can cache and store the data and it's available not from only one source, but from multiple sources creating this resilient and distributed solution that can scale across the planet. And that's where resilient and offline first solutions such as APFS is coming very, very handy to develop a network which is independent of centralized solutions. Moreover, in order to achieve so, it's very very complex if you try to address the data as you commonly do. It in web two. For example, if you're looking for a book and your friend tells you oh, you can find this book in the library on the second floor, on the third bookshelf and on the third row from the top and it will be the second book from the right. When you come to this place and get the book, suddenly you realize that it's the same book which was in your backpack, but you just didn't know that it was there and you didn't know that you were referring to this book.
00:18:03.294 - 00:19:04.302, Speaker C: Exactly the same thing is happening right now with computers or web. Two way of addressing information, where in order to find a file, you actually go to the location of it instead of that, or it's actually happening the same in the browser. Where to find an object in the internet, you go to an Http domain, you go to the path to the index of it, and then you find a file there. It's a very weird way to structure finding information and why not instead to actually look for information itself. So instead of going to the library, to a certain place, you just tell a person which book to find and essentially you are looking for a content and not for the address where it's located. And that's where IPFS brings the most value because it allows you to address the content by what it is instead of where it is. You essentially replace a folder or a file location with a Content ID, which is a unique fingerprint which allows you to discover the object's internet regardless of their location.
00:19:04.302 - 00:19:38.826, Speaker C: And I will tell you more how the IPFS works specifically. For example, you have a Content which is Hello World Text document sorry. And you create a cryptographic hash function out of it, which is a Sha 256 standard algorithm. And you create a Content Identifier for that. So once you created a Content Identifier, this is a unique fingerprint which points to exact content of the file which you created. So the same content will always resolve in the same CID. And content CID can be reproduced anytime from the original content.
00:19:38.826 - 00:20:25.658, Speaker C: So imagine that it's independent of who creates the CID. Rather it's always a computer which is dependent on the file you upload. So if you have the same content, any computer in the world or any solution will create you the same CID. Therefore you can easily discover the object by what it is rather than by where it is. And it also adds us this trust function of the web Free, where once you received an object from the IPFS or from any other solution, you can validate through the CAD if the content you received matching the original CAD you requested. If something is flawed, then you have a different CAD and then you know that it's not the content you are looking for. The best part of it is that content is not only files itself, folders could be the same content.
00:20:25.658 - 00:21:10.214, Speaker C: And essentially a folder is a special kind of a file which lists other files inside of it. So all the core principles which apply to the files in IPFS work the same way in the folder structure. So you can also use files and folders in IPFS without any limitations. And to give you a brief idea of how exactly it works, here is a small diagram where we have four objects in the bottom and each of it has produced its unique CID. So you can always trace an object by a CID. And these images are grouped into two folders, first one containing the first free and you see by different colors there is a fingerprint. So these are different CIDs on the first place.
00:21:10.214 - 00:22:18.026, Speaker C: Then all these two folders are then connected in one folder and you get the root CID of the first initial folder. So when you have the root CID, you can discover which objects and files are inside of it and which CADS continuously are inside of it. And that's what exactly Merkel Dag is or Merkel Direct Acrylic Graph, which is a graphs data structure and where each node is content addressed by itself. So CADS and IPFS allows you to not only address the files, but also the structures in the Direct Acrylic graphs. And the beauty of it, it allows you to really deduplicate the internet in a sense that imagine there is a case where new folder is created, but the content of this folder is based on already existing solutions in IPFS and on already uploaded content. So here for example, I create a new folder which contains two write images and even though I create a new folder with a new list, apparently it gives me the CADS of the previously added objects. Because again, CADS are referring to the object content and not to where they are located.
00:22:18.026 - 00:23:26.574, Speaker C: Therefore we get the ability to duplicate the amount of files we store and essentially, instead of storing hundreds and thousands of memes on the internet, you can just store five redundantly and always point to the same objects instead of just storing them again and again and again. This also gives us the verifiability. If some of the contents inside the folders change, then a new CID will be as a result. And therefore you can always trace whether the data which is served to you is reliably what you have requested in order for this to work in the network, in a peer to peer network, there is also some functionalities which needed for you to have as a network. So, first of all, the network of IPFS is a swarm of peers where peer is a node in a peer to peer system. In order for the system to work, there are many, many peers across the world which are serving parts of the content. Therefore, if something changes or something happens to any of the peers, this whole system still became resilient and you can just retrace the content or find the content on any other peer that is available and still online.
00:23:26.574 - 00:24:13.806, Speaker C: So, in order for the system to work, you need to impose several requirements on the peer to peer system. Therefore, each and every node in the network must be discoverable. So you have to be able to discover where the node is located and which content contains and it must be Routable. So you need to be able to any node to have a trace through other peer to peer nodes so that at any point of time you can discover both the content and where it is located. And that's where a distributed hash table functionality which is available in IBFS is coming very handy. Imagine distributed hash table as something like a phone book where you have a name of a person and a phone number of a person. But instead of having just a phone book by yourself, you are sharing it with your friends or your peers.
00:24:13.806 - 00:25:21.114, Speaker C: So you maintain it jointly and you're all adding new names and new numbers to it. And that's exactly how the distributed hash table works in IPFS. So there is a group of peers or a group of nodes which are maintaining the same distributed hash table and adding the content to it upon uploading to a specific peer or node and it's maintained by multiple peers, but only a small number of peers. So you never have a distributed hash table of the whole IPFS because it will be a tremendous size and very hard to maintain. Rather, if the content is not served in this particular DHT or distributed hash table, the peer itself can refer and ask neighborhood peers if they have content in their DHT tables. And it's very fast and very simple to trace whether there is a content available on IPFS node network in general and in which particular DHT table it is located. Because all the DHTs contain the CADS of the content in a manner that they are discoverable and in manner that they are grouped together by similarity of the CAD compared to the content.
00:25:21.114 - 00:26:37.502, Speaker C: And that's where it's becoming really easy to manage and operate the whole network because every peer can add roles to the DHT table, declare their peer ID and provide specific CADS based on how they connect to the peer ID and how they're available through the network. Moreover, peers can query the DHT to find peer ID which is providing which content ID, so making every node available to trace and reach any content in the internet and that being self served system where it's also independent of protocol apps or development solutions where it's an open protocol on the first place. So whenever you have this solution, it's available for you at any point of time, regardless of limitations or centralization, which I talked to you beforehand. The very nice piece about it is that once you have all these concepts ready and technically working, which they are already for quite some years, you need to start thinking how to build a network out of that and how to serve the content which you particularly have or you own through the network. So it's available to you over time and it's available to you whenever you need it. So there are multiple ways of using IPFS. In general though, you need to understand that if there is no nodes, there is no retrievability.
00:26:37.502 - 00:27:51.194, Speaker C: So you need to think about who actually runs the nodes in peer to peer network. So obviously, first of all you can run your own node and store all your content just on it, but then it's becoming the same single point of failure and if something happens with your content, then it's basically lost. Then you can also run your own network of nodes, but at the same time it comes at the cost of infrastructure running and the team to manage it. You can also pay Pinin services that's available already right now on the network such as Pinata, Temporal, infura and many more. But this is a payment solution so you have to pay someone in order for them to provide you the content from peer to peer network. And at the same time you may just hope that content becomes popular enough and that other nodes will pin it instead of on your behalf, just for free? And does that system where you have to rely on a solution or on someone's goodwill to pin your data in order to be able to retrieve it, sounds reliable and decentralized for you? For me personally not. And that's exactly where we can talk about Filecoin and how Filecoin incentivizes persistence and verifiability of storage on web free.
00:27:51.194 - 00:29:07.282, Speaker C: Filecoin is a solution which allows you to make a deal with a storage provider, which we have more than 4000 at the moment, with more than 18 exabytes of storage capacity already available on the network. And it allows you to create a deal where storage provider confirms that he has your data for the duration of the deal and at the same time it's available. And we can prove, verifiably prove that he stores your data continuously through the whole duration of the deal, the duration of the deal and the provider has to run cryptographic proofs on the data which he stores for you every 24 hours. So we are making 100% sure that the data is available. And the beauty of it is that it's also being replicated multiple times or sort redundantly on the network. So that even if something happens with one single storage provider, it's always available to you, regardless of what an additional benefit or the way we designed it to actually serve the multipurpose is that it also utilizes the same CAD solutions as I just described you inside of the IPFS. So essentially you can have your IPFS CAD being stored and verified over a Filecoin deal and it's stored redundantly multiple times.
00:29:07.282 - 00:30:19.570, Speaker C: So that's how you achieve this decentralized verifiability storage on web free for your lifetime of your project, your lifetime of solution and just long term having preserving your knowledge, which is essential for human development. And that's where you can also run multiple times the dealing on the filecoin. That's where you first receive the fundamental reliability or resilience of the structure, the beauty of it that you can also run it in parallel with cloud or with any other solution because we are essentially agnostic to what are the other solutions you are using to store the data. You can also backup it with the cloud, you can use different solutions from different storage providers, but it doesn't stop you or we do not lock you specifically on Filecoin for you to retrieve your data. And that's where I would say that IPFS is really loving Filecoin and they're really designed to work well together, where IPFS is designed for the fast and flexible retrieval, where the gateways, local nodes and browsers are available. The beauty is that right now we are also natively supported by multiple browsers. The Brave is already fully supporting it and running an own IPFS node on the background for you.
00:30:19.570 - 00:31:29.290, Speaker C: So you can directly watch in the browser all the content from IPFS and there are multiple more browsers that are coming soon with the implementation of IPFS reading. Whether they're using just a gateway through IPFS or directly installing the nodes, the more are coming from firefox and then we're also working on implementing it into the Chromium. So all chromium based devices will be also natively able to read IPFS, CADS and content inside of it. Also on top of the IPFS there is a filecoin which provides you this needed persistence and verifiability of the data on chain and reliably storage of the data for the duration of your content or duration of a lifetime of the deal which you have made on top of IPFS and Filecoin. And that's where we can slowly transition to the tools of web free, where I will give you, in the next ten minutes, the details. How you can build on top of IPFS and filecoin and how to easily kick. Start your project during this hackathon so that there is no problems in building your own nodes and finding the solution that you need to develop on top of IPFS and filecoin.
00:31:29.290 - 00:32:45.800, Speaker C: So the very first and very, very easy to use solution is NFT Storage, where it's completely a free solution to store your NFTs with simply two lines of code. You can register on NFT Storage website, you can get your API keys, and whenever you make a call with an API, your data will be stored on IPFS and filecoin, and it will be pinned redundantly five times across the network. The beauty of it that CADS are again computed locally, so there is no dependency on any of the storage solutions which you are using and at the same time you can still discover it over the traditional IPFS network, so all the content could be stored and served on the web directly through NFT Storage. Also, the beauty of it is that from protocol apps perspective we are treating NFT Storage as a public good. Therefore it's designed to be completely free for use for any NFTs. We preserve the NFTs as a common knowledge and we believe that that's the way how to build the web free so that people really have the access to the data they create at any point of time. Also if you even think about but what's the incurring cost, maybe we'll run it for price later on and then charge everyone because they are locked to the system.
00:32:45.800 - 00:33:39.878, Speaker C: Apparently we are also at least 100 times cheaper than Avs and Cloud solutions, so it's run on behalf of protocol apps. And whatever happens to the solution, it still could be pinned on your local nodes and be available and retrievable at any point of time when you want to scale your solution. Not just for NFTs, but for any kind of storage. That's where the web3 storage is coming the most handy. It's a solution for general IPFS and filecoin storage, and it provides you a simple and familiar interface also with only two lines of code to implement to store. It reliably on IPFS and filecoin, and it provides you 1 data for free, so you can use very simple JavaScript or Go client implementations. And it has an Http API for remote pinning service and a web interface to upload your data or to retrieve your data on your browsing solutions.
00:33:39.878 - 00:34:52.746, Speaker C: When you're also thinking about developing your websites, that's where Flick hosting is coming into place. It's Flick co and it allows you to build your websites on top of IPFS and Filecoin and store them directly into IPFS network, which makes you independent of any cloud storage provider. And it's reliably accessible through the peer to peer network as well. It is very easily built on top of GitHub repository so you can just connect it, set up your build settings and it will be deployed directly onto a PFS and backed with the Filecoin solution. So just simple and amazing tool to run your solutions on top of really decentralized network and be ready for web free whenever you are building your project. There's also an advanced solutions or additional solutions where developers who have powergate if they want to have a powerful ways to connect and extend protocols such as IPFS, Filecoin and Lipitop. It provides you the opportunity to have a docker container wrapped around IPFS node and Filecoin node and it gives you the flexibility of staging, storing and retrieving data and have the default configuration for the minor selection.
00:34:52.746 - 00:36:00.594, Speaker C: And one more topic which I want to cover in this presentation and which is the more and more upcoming and important effort of Filecoin in particular is Filecoin green. It provides you now the opportunity to measure the energy which is used by storing your data. And our whole effort of protocol apps and IPFS, and Filecoin in particular is to build the reliability on the web where you can specifically verify that the data is being stored in sustainable way. And it's provable that the sustainability aspect is not faked or is not just a number on the dashboard, but rather it's something which is cryptographically or verifiably proved that the solution is totally green. It also provides you the consensus mechanism that is used by Filecoin which requires each node to prove that resources contributes to the network. Therefore you can easily calculate the amount of the energy which is being used to store your data and then later on scale it to more projects. On the green aspect of the sustainability of the blockchain.
00:36:00.594 - 00:36:50.690, Speaker C: I think that is one of the interesting topics to work also in the scope of the hackathons because the green aspect was not that in the radars of developers. For quite some time right now. But we have seen more and more the problems or the general sustainability issues on the world around. And I think, as Vitalik was mentioning, it's really a matter and great effort to build. The sustainability of the blockchains on the first place making sure that the tools which we are building are scalable to the future. Also from the sustainable perspective. And that's where I'm coming to the amazing possibilities of web free or what to build right now, how to build it and generally it's an amazing network which we are running and the ecosystem which accounts for many many people building on top of IPFS and Filecoin.
00:36:50.690 - 00:37:48.138, Speaker C: It's quite an outdated view already, but there are all types of solutions from Flick, from Orbit, from technical solutions. There are also many many teams that are building on top of IPFS and Filecoin from other chains. There are practical technical implementations and I encourage you to look through the hackathons Filecoin IO website where most of the hackathon participants from the past year were listing their price projects. So you have all the access and all the knowledge which we maintain across our ecosystem. So you can have your kickoff of the project for the hackathon for ETH Amsterdam as soon as possible and build on top of reliable solutions, rather than developing something new from scratch. Also there is a list of projects I really like in particular which were using IPFS and Filecoin. First of all, we are also backing up the Internet Archive which contains the most important human data right now.
00:37:48.138 - 00:39:06.894, Speaker C: We are also collaborating with Starlink Lab which creates a framework for data integrity and preserves testimonials of the Holocaust survivors. That's where we're also looking to contribute to the public goods and Creative Commons. They're an effort joined together with Ethereum Foundation and Ethereum Networks where we're collaborating on retroactive public goods funding and generally finding solution for the public goods to be reliable and accessible topic over the web free as well. There are also nice practical applications such as Audios, which is new version of music tool where you can listen music, podcasts and everything. There is live peer solution which gives you the opportunity to do video streaming and NFT minting of the videos straight away with their development. We also have an amazing projects with teams or organizations outside of the web free. For example, we're developing the New York City Open data with Filecoin and IPFS and if you're familiar with OpenSea Wearable or you're generally interested with NFT topic then I can also highlight that in the back end of OpenSea they're also storing all the NFT content through IPFS and Filecoin.
00:39:06.894 - 00:39:56.750, Speaker C: So in order to summarize that, Web Free is essentially a decentralized web where the blockchain is a fundamental layer which allows you to make verifiability on chain and provides you the independency of a centralized state rather than ensuring that the content is being available, is being linked and being resilient to the future proof, solutions and applications. And just to sum it up, apparently the best way to predict the future is to create it. So I really encourage you to do all the best on this hackathon having an amazing 36 hours of. Hack build your projects, build it on top of IPFS and Filecoin. Let us know if you have any questions about how to build us. We'll be available on the booth. We'll be also giving a talk tomorrow.
00:39:56.750 - 00:40:49.806, Speaker C: Our CEO Juan Benneth will be providing a talk on public goods and crypto economics. So there is a lot, a lot of opportunities. And once you join the ecosystem, they are more than just building on top of IPFS and Filecoin, we are also running a huge grant program. So for us and for you, hackathon is just the first step. You can scale further with our grant application, with our Micro grants, development grants, and then launching further your projects with precede seed rounding and startup as a part of an awesome community. And last but not least, I will also highlight for you some learning resources. There are Discord and Slack available and specifically for this hackathon, I believe we are running through the Eve Global Discord, but feel free also to join our Discord and Slack from IPFS and Filecoin.
00:40:49.806 - 00:41:48.898, Speaker C: You can find it at filecoin. IO Slack and you'll have all the answers there. We are working as a public company, so everything is available from our development directly on Slack. You can reach any of our team members on Slack and that's where we believe that working open source is not only building open source solutions, but actually living open source, making sure that we are collaborating instead of hiding information and where everyone can contribute to the scale of the greater good and a greater ecosystem. With that being said, I would just encourage and say good luck to you all on developing your hackathon projects. It's definitely an amazing time and I was a hacker myself a few years ago. I love this time and I will be here together with my team to support all your questions and making sure that an experience for you to build on top of IPFS, Filecoin and any other solution from protocol apps is an amazing experience and you want to stay with our ecosystem further.
00:41:48.898 - 00:42:12.046, Speaker C: Thank you a lot and that would be it from my side. And I guess we are running greatly in time, so we have at least ten minutes for the questions. But I'll also be happy to stay further and answer all your questions afterwards. So who want to be the first? Yes please.
00:42:12.228 - 00:42:17.760, Speaker A: Is there any solution for storing data with access control?
00:42:25.110 - 00:43:17.890, Speaker C: Yeah, that's a very good question. Oh yeah. So the question was if the content on the IPFS and Filecoin is public, or you can somehow encrypt the information first, or what are the solutions to work with the private data. Essentially, so IPFS and Filecoin is deliberately an open network, so all your content which is stored through IPFS and Filecoin is public. You are completely right that you can first encrypt the information and then decrypt it when you download it, but it will still be available on the public network as a peer to peer storage solution. I would say that there are some teams who are working on encrypting the solution on encrypting protocols on top of IPFS and filecoin but you are more than welcome to develop your own. I think that's a hot topic right now.
00:43:17.890 - 00:43:38.120, Speaker C: And if you're working with some private data, it's very interesting to also think which parts of data is actually sensitive and should be private. Because quite often it's only a small fraction of the actual content you want to store, which is private and you can split it and still store most of the content in completely open system.
00:43:38.590 - 00:43:47.530, Speaker A: One thing to check out is maybe lit protocol, lit protocols and they have some encryptions.
00:43:49.070 - 00:43:51.100, Speaker C: There was one more question. Yes, please.
00:43:58.270 - 00:43:59.020, Speaker A: Like.
00:44:01.730 - 00:45:16.774, Speaker C: Well, whenever I speak about public goods, first of all, like foundational human knowledge is very important topic. I believe that the content about learning about just general education is something which should be preserved and should be available regardless of the paint walls, regardless of proprietary information. That's something which all of the society should build on top of. There is also public goods which could be the data sets which provides you the knowledge on for example medical data sets or something which you can build on top of in order to create a more resilient and more efficiently working system. At the same time public goods could be some I mean there is common projects which we are building from retroactive public goods funding with Ethereum Foundation where it's also being a focus of ensuring that the developments which are happening in the public goods field is being well funded and receiving sufficient support from the teams and at the same time, apparently just storing the data for someone could be already a public good whenever the information which is being stored is socially valuable or just generally valuable as a human knowledge. Does that answer your question?
00:45:16.892 - 00:45:17.654, Speaker D: Yeah.
00:45:17.852 - 00:45:21.900, Speaker C: Thank you. Are there any other questions?
00:45:23.870 - 00:45:29.894, Speaker A: Is there anything to keep in mind when deploying an app on IPF as compared to the cloud? I guess there will be some latency.
00:45:29.942 - 00:46:26.094, Speaker C: Issues potentially yes, production ready. So if we are speaking about web applications like hosting the website through Flick co I believe they're also hosting it on their own node. So you get quite good retrieval speeds though. Yes, you have definitely. Keep in mind on the real retrieval speeds of the Data IPFS filecoin is now not always as fast as the traditional solutions, though we are right now building the super hot CDN solutions where in one, two months it will be production scale ready and the same speed as the CDN of a traditional cloud. So that's the feature we are also aware of and we are developing it towards making it large scale and available as a retrieval storage market. But that's a topic which we are also discovering right now.
00:46:26.094 - 00:46:36.660, Speaker C: But there is already like you can already build on top of IPFS and filecoin and get proper user experience though it takes us an additional time to make sure it's all fluent and available.
00:46:44.640 - 00:46:46.940, Speaker A: Which is specifically for NFC.
00:46:51.200 - 00:46:51.788, Speaker E: Nodes that.
00:46:51.794 - 00:47:28.170, Speaker A: Are actually extremely fast. Yeah, I am thinking about specifically where your node is might get good loaded fit around it but maybe some users comes from the state then you need an additional node there. I mean filecoin eventually will incentivize that with the actual crypto economics where you have a market for retrieval and then basically anybody could be a retrieval at which point you have an extremely CDN that's more distributed than any other CDN could ever be because anybody is retrieval perfect.
00:47:29.440 - 00:47:30.670, Speaker C: Any other questions?
00:47:31.040 - 00:47:32.956, Speaker A: Then what does it mean for me.
00:47:32.978 - 00:47:34.696, Speaker D: To run an IPS node?
00:47:34.808 - 00:47:36.904, Speaker A: Let's say if I want fast retrieval.
00:47:36.952 - 00:47:39.656, Speaker D: Speed, can I pin a content to my node?
00:47:39.768 - 00:48:22.510, Speaker C: Yeah, that's exactly how it works. So for example, if you're sitting in the same room and someone from the room already have your content he can directly serve it to you instead of going to a centralized node and download and uploading it directly. So that's the beauty of it where the more peers are serving the same content the faster the retrieval you will get. And if you are working from the same network that's the ideal case where the peer can just directly streamline you the content which he has and that's where the more nodes the better is the approach. But at the same time having this ability speed is also dependent on the size of content and some of the delays which may occur on peer to peer networks which are traditional to it.
00:48:22.960 - 00:48:24.152, Speaker D: What is it internally?
00:48:24.216 - 00:48:29.020, Speaker A: Is it object storage or it's traditional Unix file storage.
00:48:30.000 - 00:48:31.596, Speaker C: Can you elaborate a little bit more.
00:48:31.618 - 00:48:44.656, Speaker A: On the question how exactly the file is stored inside the node? Is it like object storage or do you use some technologies like I don't know how HDFS stores the files?
00:48:44.848 - 00:49:17.196, Speaker C: Yeah, so it's a file distribution. So any object could be uploaded independent of file format and will be served from the node to the node. Not all the nodes will contain the file fully so some of the nodes will be only serving it as like transmission nodes. So they do not need to store your file directly but they'll be only transmitting through them because essentially there is connectivity could happen through each and every node on the network. Any other questions? Yes, please.
00:49:17.298 - 00:49:37.316, Speaker A: I have a slightly more technical question. So as far as I understand the way the CID hashing function works on images divides the image up into separate chunks, a hash for each image chunk and then the aggregate hash or the hash of the chunk of the image. What happens if I start downscaping my image? I start like pixelating it more and.
00:49:37.338 - 00:49:46.720, Speaker C: More yeah, then the CID will change essentially if you change any pixel of the content you will always receive a different CID.
00:49:46.800 - 00:49:52.920, Speaker A: But if the pixelation is so slight, there's a sort of decrease in pixel size. Maybe it's ever so slight.
00:49:55.340 - 00:50:37.370, Speaker C: I think that's a very interesting corner case and I would love to know if you explore that further during your hackathon. But I would assume that if the file size also changes, then it will also affect the final CAD because essentially you store it in a different format than it was originally. So the idea of the CAD encryption is that every unique content creates its own unique CAD. And in downscaling I believe you still change in the background of the file how it's been recorded. So it doesn't take your image directly. In a sense it takes the way machine explains it and then transcodes it into sha function. Yeah.
00:50:37.370 - 00:51:15.108, Speaker C: Any other questions? If not, I would love to thank you all for your attention. It was an amazing time and pinning service. I would use directly web3 storage or NFT storage. They also pin the content on your behalf. So it will be pinned five times redundantly and available for the filecoin deal, for the filecoin network and it's also free to use then. Thank you all and have an amazing hack.
00:51:15.164 - 00:51:15.770, Speaker B: It.
00:52:07.550 - 00:52:08.700, Speaker C: Will be right here.
00:58:08.590 - 00:59:21.610, Speaker A: Allow nice. Yeah, I think you should know like I think standing would be nice at the background that's but it's just.
00:59:26.660 - 00:59:27.810, Speaker B: Prompting questions.
00:59:34.240 - 00:59:36.190, Speaker A: You can look at you.
00:59:38.100 - 00:59:39.650, Speaker B: Stepping into the other.
00:59:45.190 - 00:59:50.402, Speaker A: Now you're watching. You're looking at to the left for you.
00:59:50.456 - 00:59:51.060, Speaker D: Yeah.
01:01:20.290 - 01:01:21.390, Speaker A: Many conference.
01:01:23.730 - 01:01:24.480, Speaker D: Actually.
01:01:28.010 - 01:01:45.390, Speaker A: Internet great. Yeah, I think it's enough for what we need. Do you have anything else should I mention?
01:01:46.960 - 01:01:50.430, Speaker B: Why don't we mention it and then I'm not sure if we'll include that.
01:01:57.090 - 01:02:18.708, Speaker A: Thinking about Web three storage layer. Great, thanks so much.
01:02:18.794 - 01:02:19.332, Speaker D: Very nice.
01:02:19.386 - 01:02:22.470, Speaker A: Thank you. Let me help you with micro. Oh, yeah.
01:05:03.300 - 01:05:04.050, Speaker B: It.
01:05:07.940 - 01:05:09.490, Speaker D: Yeah, just let me know.
01:05:52.280 - 01:05:53.030, Speaker B: It.
01:06:11.340 - 01:06:13.000, Speaker D: A way to mirror my screen.
01:06:13.150 - 01:06:13.850, Speaker A: Yeah.
01:06:22.040 - 01:06:32.630, Speaker D: Can I use that? Yeah, I prefer that. Okay. Right. Test.
01:07:06.380 - 01:07:07.130, Speaker B: It.
01:07:41.290 - 01:08:16.596, Speaker D: Because I like moving around a lot. Okay, got you. Yeah, I'll be it's just how I when you have questions yeah. Will there be last question? Yeah. When you say to the people, I'm.
01:08:16.628 - 01:08:17.690, Speaker F: Going to the people.
01:08:18.940 - 01:08:19.400, Speaker D: Perfect.
01:08:19.470 - 01:08:20.136, Speaker A: Awesome.
01:08:20.318 - 01:08:21.770, Speaker D: Yes. Perfect.
01:09:29.280 - 01:10:09.470, Speaker B: It's.
01:10:11.930 - 01:10:24.902, Speaker D: Everyone. How you doing? My name is Rahat. I'm a developer advocate over at Polygon. So I decided to do this workshop a little bit differently. This is the only slide you will see. That's it. Everything else is code.
01:10:24.902 - 01:10:43.454, Speaker D: Is that cool? I said screw it. We don't need slides, we just need code. You guys are hackers, you guys are developers. This is what we're going to do. So thank you for coming to my talk. This is all about taking a Web Two browser game and turning it into a play to earn game. We're going to do something real simple.
01:10:43.454 - 01:11:02.502, Speaker D: How many people have played Rock, Paper Scissors ever in your entire life. So you're aware of the mechanics of rock, paper, scissors? Cool. Awesome. So let me just make sure my code is what I want it to be. Okay, so we got this rock, paper, scissors game here. Just a simple react application. Nothing big, nothing's going on.
01:11:02.502 - 01:11:18.650, Speaker D: All right, if you want me to hit Rock, please put up a Rock scissors. Put up a peace sign. Paper. Put up a hand. All right, see to paper, scissor. Rock. All right, it looks like Rock wins.
01:11:18.650 - 01:11:28.266, Speaker D: All right, hit Rock, nobody wins. Come on, guys. All right, one more time. Rock, paper or scissors? Paper. Scissors. Okay. All right.
01:11:28.266 - 01:11:42.946, Speaker D: Paper again. Paper. We lost. Okay, whatever. So nothing huge going on there, right? It's a simple rock paper, scissors game. This is what the code looks like. Real quick, I'll show you right now.
01:11:42.946 - 01:12:07.270, Speaker D: Components. I call this component web two game. So it's just this gigantic switch case with a bunch of if statements. If, paper, Rock, whatever, somebody wins. And I'm just like putting a bunch of things in state. This is probably not an optimized version of this code, very crappy version of it, but it gets the point across, right? We have a rock paper scissors game. It exists in the browser.
01:12:07.270 - 01:12:31.102, Speaker D: Now, what if we wanted to add some elements of Web Three into this? So I'm opening this up. I call this the Web 2.5 game. Call it Web 2.5 because all we're doing here, we're slapping a Web Connect wallet Connect function onto this. Nothing huge going on. I have this handle Wallet Connect function pulling the Ethereum object out of the window.
01:12:31.102 - 01:13:04.860, Speaker D: What does that mean? As long as I've got a browser injected chrome extension like MetaMask or something like that, I'll have the Ethereum object, and I can pull that out the window. As long as that all is good. I am just doing a couple boilerplate stuff of taking the Web Three provider from Ethers, requesting access to the user's account and getting their address. So let's update that. Let's remove the Web Two game from in here and add the Web 2.5 game.
01:13:07.700 - 01:13:08.770, Speaker E: Wrong thing.
01:13:10.260 - 01:13:16.450, Speaker D: Okay, come on. Doing this with one hand is, like.
01:13:18.260 - 01:13:19.104, Speaker F: Wrong thing to do.
01:13:19.142 - 01:13:33.240, Speaker D: Okay, cool. So now we got this Wallet Connect, right? Hit connect, wallet great. MetaMask pops up next. Connect. Wonderful. All took was two lines of code. Right? Now we slapped a Wallet sign in with Wallet.
01:13:33.240 - 01:13:59.830, Speaker D: Can anyone tell me what's wrong with this? Just shout it out. Exactly. It's not inclusive because not everyone uses MetaMask. People have mobile wallets. People have hardware wallets. If I wanted to go beyond this and make sure that I'm actually being inclusive and bringing people in, I think there was a workshop earlier on Wallet Connect. Definitely recommend using that instead.
01:13:59.830 - 01:14:45.136, Speaker D: But for the purposes of this, I'm just kind of looking at one use case, particularly for an injected wallet. But we always want to make sure we're being as inclusive as possible to many different types of people. So for now all I'm doing is just I'm saving this address into state. Nothing big again, just works the same. Still a web two game, right? How would I turn this into a web3 game? Let's take a look at some smart contract code. So this is very simple smart contract. There's not a lot going on here but just to kind of visualize what's going on, what I want to accomplish here is that I want to take this Rock Paper Scissors game.
01:14:45.136 - 01:14:58.740, Speaker D: I want people to wager some amount of matic on the polygon network and if they lose, if they draw, they lose that matic and if they win they take the entire amount of matic that's in the pot for themselves.
01:14:58.810 - 01:14:59.524, Speaker B: Right?
01:14:59.722 - 01:15:52.324, Speaker D: So a little bit of a gambling rock paper Scissors implementation of a game. Right? So how does this work? So I've got the contract, the game, I've got a private string that is going to take care of who the winner is. Actually I don't think I'm using this but whatever this unsigned integer which is the balance which is going to keep track of how much money is actually in here, I've got a few functions. First is this Receive money function is just to send some money over to the contract. Now I made this public for one reason. I just want to make sure that if at any point in time I decide to put this smart contract onto the blockchain or whatever, I can load it up with money in case if I need somebody to load it up with money so people can actually earn some stuff instead of winning nothing. So just making that a little bit easier.
01:15:52.324 - 01:16:36.644, Speaker D: Using this payable function, Solidity has payments baked in natively. You don't need to import any other smart contracts, anything. Everything is like accessible with this payable modifier. So all I'm doing is taking this balance up here, this public balance and updating it with this message value. Where do I get message value from? Whenever somebody uses their wallet, their MetaMask or anything like that I can extract the value of whatever amount of money they've wagered or put in there and keep track of that value with this this message value. Super useful to know in Solidity. Now I'm doing this.
01:16:36.644 - 01:17:26.388, Speaker D: Get balance function. This might be redundant but just to kind of give you an idea of how something like this would work it's just a very plain kind of function. Tells you the current balance of the amount of money that's on this contract, right? Nothing useful. Now we get to the fun part, this play function. So literally all I'm doing, I'm still allowing my front end to decide who the winner is and if they won, if that's true, then I'm going to take the address of the person who is interacting with the contract. So that is available through me again through this message object. But now it's not a message value through message sender, which is going to give me the address of whoever is interacting with this contract right now.
01:17:26.388 - 01:18:10.964, Speaker D: I'm going to take that and just going to transfer some money to them. Whatever the current balance is, I'm going to give them that money. If they won, they didn't win. I'm just going to call the receive money function up here and they lose the matic that they wagered, right? So nothing too over detailed. A couple of things wrong with this. One thing I learned from a talk I once listened to is when you're building anything, you're building a SaaS product, you're building a smart contract, whatever your first version of it is, probably not going to be the best version of it. You still want to get something working, right? This works.
01:18:10.964 - 01:18:49.996, Speaker D: It does in theory, what you need it to do. You can extract money from someone. If they win, you can give them some money. Originally I was thinking about doing the whole game engine on Chain, which would have taken me more than 20 minutes, so I didn't do it. What I would do if I wanted to make this completely on Chain. Now in JavaScript, I'm able to go into an array and just sort of randomly pick out some value, like rock, paper, scissors for the opponent value. In Solidity, you cannot do anything randomly.
01:18:49.996 - 01:19:31.224, Speaker D: You can do pseudo random numbers. There's different methods, but there's no actual way to do truly randomization or random number generation inside of Solidity. If you wanted to do that, there are some tools out there like Chainlink will give you a verifiably random kind of like generated number, things like that. But that has to happen off chain somewhere. So just to kind of emulate that, you know what, let's let JavaScript kind of handle that part. But if you were to actually go into production with something like this and you want like real random number generation, definitely recommend looking at Chainlink. I do not work for Chainlink.
01:19:31.224 - 01:19:46.512, Speaker D: They did not endorse this at all. I just like their product. So I want to make that clear. So we've got this. Let's deploy this. I've got this here. If I'm deploying from Remix, I go here.
01:19:46.512 - 01:20:01.290, Speaker D: Compile. Looks like there's no problems. I'm going to copy this abi code real quick. Just drop that in here. Abi JSON. Why that's important, I will talk about in just a second. But that's there.
01:20:01.290 - 01:20:05.930, Speaker D: And let's go ahead and deploy this injected web3.
01:20:07.580 - 01:20:08.330, Speaker G: Cool.
01:20:08.780 - 01:20:34.224, Speaker D: This is my test matic. I don't have this much matic. I wish I did, but let's deploy this. Hit deploy, my MetaMask pops up and we'll confirm this. And this is being deployed onto the Polygon Mumbai network. It's one of our test networks for anytime you want to test out your smart contracts. Putting things out there.
01:20:34.224 - 01:21:03.860, Speaker D: How many people have just worked with Solidity in general, worked on the Ethereum blockchain. Cool. A bunch of you. Okay. Doing things on the Ethereum blockchain and on the polybomb blockchain exactly the same. Every tool that you learn, every if you use Hard Hat Foundry, if you use Truffle, if you use Remix, all of that maps one to one. It just takes usually one line of configuration.
01:21:03.860 - 01:21:33.910, Speaker D: If you're using Hard Hat or Truffle or something like that, all you do is just change the RPC endpoint from the Ethereum endpoint over to a Polygon Mumbai network or Polygon Main net if that's what you want. But at the end of the day, everything is EVM compatible. Everything you learned stays the same. And again, just maps one to one. That's why it's like we've been really focusing on a good developer experience. We don't want you to learn anything new just to use another blockchain. Everything maps one to one.
01:21:33.910 - 01:22:01.820, Speaker D: You'll also. So this is specifically using our proof of stake blockchain, which many people know as a sidechain. That is not the only product that we have out today. And a few other days, we actually launched a few other things, like Polygon Edge. There's a lot of work that the Hermes team is doing as well. And there's a whole suite of products that you can use to build on top of Ethereum. But, yeah, today we're just focusing on our proof of stake blockchain.
01:22:01.820 - 01:22:20.532, Speaker D: So that is out. Let me see where that is. Okay. Is that in here? Contract deployment. Let's view on block Explorer. So this is a testnet transaction. Great.
01:22:20.532 - 01:22:40.296, Speaker D: It was a success. Everything looks good. Let's actually take a look at this deployed contract. So these are some of the functionalities that I could just test before I actually put it into my front end. But hit balance right now says zero. Right? I made that. Remember? I made that.
01:22:40.296 - 01:23:22.150, Speaker D: Receive money public just so I can put some money in here. Let's go ahead and put three matic in here. So if you've done any sort of deployment or work on Solidity before, you'll know that the smallest unit inside of Solidity in reference to Ether is Way. Works the same way on Polygon blockchain. Smallest unit of matic is also Way, which is like one to the 18th zero power or something like that. So three matic that converts over to this much weigh. Let's copy that value and drop it in here.
01:23:22.150 - 01:23:47.360, Speaker D: Okay, so let me just do three. I'll do 345678, 910, 11, 12, 13, 14, 15, 16, 17, 18. Okay, that's good enough. Okay, so let's hit receive money. Awesome. I'm putting three matic onto this contract. Confirm and you'll see, like, gas fees are very negligible.
01:23:47.360 - 01:24:08.390, Speaker D: Confirm that's pending. Let's actually go ahead and look at this contract itself. How do I get to the contract? There it is. Contract. So this is the deployed contract on Polygon scan. Right now, deployed about three minutes ago. Let's just make sure this went through.
01:24:08.390 - 01:24:25.032, Speaker D: Looks like it was successful. I'm going to hit balance. Yes. Three to the 18th. Power away. A little bit small, hard to see, but hopefully it gets the point across. Right there's three matic inside of this contract.
01:24:25.032 - 01:24:54.512, Speaker D: Yeah, there it is. Three matic. Cool. So now we've confirmed that on this contract, there's three matic that somebody could potentially win if they win this rock Paper, scissors game. Let's see how we put that into our front end. So this is going to be a full stack application built with the polygon blockchain in like five minutes, guys. So I'm going to go over to this web3 game JS that I have here that uses this other component called Soliditygameengine.
01:24:54.512 - 01:25:26.300, Speaker D: JS very bad at naming things, which I'm sure the rest of you are too. We're all developers, right? So how do I actually go and interact with this contract? Right? So I have this old contract here. Let me just delete that. Delete that. I'm going to copy this contract address just so making sure we're going to that same contract. Remember, I saved some Abi code from before. I'm importing that from Abi.
01:25:26.300 - 01:26:22.370, Speaker D: What is the abi? What does this do? Traditionally, in web two development, I guess, for lack of better terms, the way you would interact with an API, be through like an Http request, fetch axios, something like that, right. When you're interacting with the blockchain from a front end, like react rather than doing something like using a fetch request, this Abi code, this gigantic JSON file, essentially acts like a map for JavaScript to parse through and understand how to interact with the blockchain. So this Abi code corresponds to the compiled bytecode from Solidity. So in order for the Ethereum virtual machine to actually read your smart contract data, that is all compiled to bytecode, which is like a machine code. And that is the actual code that is deployed onto the blockchain, not your Solidity code. Your Solidity code is at a very high level. It needs to be compiled down.
01:26:22.370 - 01:26:49.610, Speaker D: So this JSON file is just a map. It just tells JavaScript, okay, this is a function I can use. This is some sort of state. This is some sort of input that a function needs, et cetera. Right? And you'll notice in here there's like inputs to find balance, to get the balance, et cetera, all the stuff that we wrote in this nice mapped out format. So that's cool. That's great.
01:26:49.610 - 01:27:28.228, Speaker D: So now we come back to our Solidity game engine again. I'm bringing in the Ethers library. Once I have the Ethers library in here, again, just some boilerplate code of just like, making sure I'm connected to the contract. The contract connection requires the contract address, which is what I had before. It requires the Abi and it requires the signer. The signer is simply just again, that address that we had before. Now I need to make an actual transaction, right? The transaction with the blockchain to either check if this person is the winner or not.
01:27:28.228 - 01:28:03.776, Speaker D: So I've hard coded this to just always be one matic. We're just always going to bet one matic. Just keep it simple. For the purposes of this demonstration and I have this piece of state up here, player is winner by default. It is set to false. And down here again with my very, very poorly written rock, Paper, scissors game, what I'm doing here is if I set the winner to be the opponent, I'm setting player to false, transacting the game, et cetera. And if you win, if winning is true, then transacting game will update to be true.
01:28:03.776 - 01:28:35.512, Speaker D: So you either win thematic or you lose thematic. So now let's go ahead and update the game. We're moving on from Web 2.5 and let's do web3. Okay, so I've got my React app. Let's hit connect wallet. All right, now I want to win some matic, so you all going to need to help me rock, Paper, scissors.
01:28:35.512 - 01:28:58.080, Speaker D: Let's go. Always rock. All right, he said it first, though, so I'm going to go with rock. All right, so this is on you if I lose money, though. All right? So let's hit rock. No, you lost me some money. All right, so hit confirm.
01:28:58.080 - 01:29:34.316, Speaker D: We just lost one matic. This is fine. Technically, yes, you could do that if we were making sure that this actually worked properly. We do that on chain, which in this case you would reach for a tool like Chainlink or something like that to do like the random number generation here. We're just trusting our players to do the right thing. Let's play again. Let's try to try to win this time.
01:29:34.316 - 01:29:55.568, Speaker D: Oh, crap. Okay. Rock, paper, scissors? Anyone? Okay, he did say it first. All right, we're doing a rock again. Yes. All right, so we're going to hit confirm. I had 494 Meta it's pending.
01:29:55.568 - 01:30:06.500, Speaker D: See if this works. Do I speed it up. No. Yeah, that's testnet medic. Yeah. Okay, cool. It updated.
01:30:06.500 - 01:30:46.180, Speaker D: I won some money, so cool. That's a very basic implementation of play to earn mechanics set to a browser game. Right? We started off with a simple rock, Paper, scissors game. We connected everything to a smart contract. It's not the most complex application, but it's really just to give you an idea of how you can start incorporating these play to earn mechanics. This is just like a simple kind of like gambling rock, Paper, scissors game. But this is kind of the basis of what games like Axio Infinity, DeFi Kingdoms are kind of like built on.
01:30:46.180 - 01:31:19.410, Speaker D: You take the little fundamentals and building blocks, put these together, make it a little bit more complex, test your code unlike me, and always test your code and put that onto the blockchain and you've got a play to earn game. Play to earn is something that is. Getting pretty big right now. All the rage, all the VC funding is trying to find its way into play to earn and all that. So if that's something, I'm pretty sure it's one of the tracks as well for Polygon. So if you want to win some money from us, something you could build.
01:31:20.340 - 01:31:20.704, Speaker C: Cool.
01:31:20.742 - 01:31:44.490, Speaker D: I'd like to open this up to questions. Any questions about the code? Any questions about any anti implementation polygon in general? Love to open it up to you guys. Anything? You have a question? Can we get Mike? Yeah, I think he's going to give you the mic.
01:31:51.980 - 01:31:53.290, Speaker E: Great, thank you.
01:31:53.660 - 01:32:15.632, Speaker D: Question was, is this code open source anywhere? Can I look at this? Maybe I want to build something similar. Yep. So this will be open source by later tonight. So I will just post this up again. You can follow me on Twitter at rahat codes. I will tweet this out. But I will also put this in the discord in the Polygon sponsor channel as well.
01:32:15.632 - 01:32:19.830, Speaker D: So both places by later tonight, we'll have that up there.
01:32:27.480 - 01:32:46.236, Speaker E: I'm somewhat new to Polygon. I think basically how it works, right? It's like layer two and then all the transactions get put into Ethereum blockchain in a bunch. That's how they can have fast transactions and stuff, right?
01:32:46.418 - 01:33:12.420, Speaker D: Yes. This specific implementation is using our Polygon proof of stake slide chain. So rather than doing like proof of work computations, which is going to take more computing power, going to take a little bit more time to do, proof of stake algorithms allow for much quicker transactions. So a lot of that is built on that side of things to get you that better. UX.
01:33:15.160 - 01:33:24.760, Speaker E: Polygon offers pretty cheap fees and fast transactions. So does Solana. What's, like the trade offs?
01:33:26.140 - 01:34:00.260, Speaker D: I couldn't intelligently speak about Solana. So I will say if you're already used to building on top of Ethereum, building on top of anything EVM, the advantage here might be like, you don't have to learn anything new. Like with Solana, you have to pick up rust, build smart contracts. So if you already know solidity, if you've already been developing on an EVM blockchain just for developer experience, I go with Polygon.
01:34:02.680 - 01:34:09.190, Speaker E: Do you know if Polygon are going to be affected by the merge? Anything?
01:34:09.800 - 01:35:03.050, Speaker D: Yeah, I think we're actually very happy about the merge. While the proof of stake blockchain will still be a thing will still be available, there's a whole suite of kind of products that we're building and putting out a combination of ZK roll ups, optimistic roll ups, as well as just like, different tools for just like, building on top of Ethereum. Our whole thing is just like making Ethereum scalable. So whatever Ethereum does to make that easier for us is just even better. This implementation of putting this on the Polygon proof of stake blockchain is just like, one way you can interact with the Polygon ecosystem at large. This is only one of our products. So maybe there's a future where our other tools would be more popular because post merge, it's probably stuff that you'd want to use.
01:35:03.050 - 01:35:17.000, Speaker D: Cool. Anyone else? Do you have a question? No.
01:35:18.910 - 01:35:21.020, Speaker E: Trying to think of something.
01:35:23.470 - 01:35:24.220, Speaker D: Yeah.
01:35:32.590 - 01:35:55.922, Speaker E: But Solana, there is a tool, there is a game that exists that's called degen coin flip. And what it is, it's like you bet an amount what you want, and if you lose, you lose this amount. And if you win, you double your amount. You're winning with a small fee that this contract in Solana is keeping for themselves.
01:35:56.056 - 01:35:56.786, Speaker D: Right.
01:35:56.968 - 01:35:59.282, Speaker E: So it exists for Solana, something like this?
01:35:59.416 - 01:36:00.100, Speaker D: Yeah.
01:36:00.470 - 01:36:03.878, Speaker E: Implemented it. I don't know if this contract is open on it.
01:36:03.964 - 01:36:24.242, Speaker D: Yeah. I mean, this is sort of like a very similar implementation. You're wagering some money. I could add some more to add some fees if I wanted. On top of that as well. I can code that into the balance and things like that. But this is going to be more like a basic sort of implementation.
01:36:24.242 - 01:36:42.530, Speaker D: But I don't think you need much to add very much more code on top of this to actually get to the end to what you were describing there. The basic functionality is there, wagering, sending money, things like that. Probably just be like doing a few things, know, keeping track of fees and things like that.
01:36:42.600 - 01:36:59.266, Speaker E: But what they have on top is like an NFT collection. The revenue from the percentage they are keeping, it goes to the NFTs, the wallets of the NFTs.
01:36:59.378 - 01:37:09.020, Speaker D: Nice. Yeah. I mean, those are definitely different functionalities. You can add on top of stuff like that. That's awesome. What about.
01:37:12.290 - 01:37:14.990, Speaker A: The main selling points for polygon?
01:37:18.450 - 01:37:58.486, Speaker D: I mean, you know, for this, that's really for the proof of stake blockchain. Cheap and fast. But our other solutions would also leverage the Ethereum security level of security that we have there. Are we out of time? Yeah, the selling points for the proof of stake blockchain is there, but if you want to leverage the full security of Ethereum and everything like that, you would reach for something like our ZK roll ups, optimistic roll ups, some of those other products. So it depends on your use case for what you need. Cool. Thank you for coming by to this workshop.
01:37:58.486 - 01:38:04.620, Speaker D: Really appreciate you all. Thank you for the questions and yeah, I will post the code later on tonight. Thank you.
01:38:38.350 - 01:51:48.890, Speaker B: Sam to be sam. Sam. It's. It's Sam. I'm Sam. Sam SA jam sam. Sam.
01:51:48.890 - 01:57:21.640, Speaker B: Sam. It Sam. SA sam. Sam.
02:02:04.240 - 02:02:05.340, Speaker G: On the ram.
02:02:17.900 - 02:02:19.850, Speaker E: Test and toy three.
02:02:21.020 - 02:02:21.770, Speaker F: Yeah.
02:02:23.420 - 02:02:25.800, Speaker E: Test and Toy dream.
02:02:29.340 - 02:02:32.090, Speaker G: Working test.
02:02:36.060 - 02:02:37.100, Speaker A: What do you want?
02:02:37.250 - 02:02:38.190, Speaker D: This one?
02:02:39.780 - 02:02:41.056, Speaker G: I will have this one.
02:02:41.078 - 02:02:42.210, Speaker D: Yeah, of course.
02:02:42.660 - 02:02:44.370, Speaker G: And I should.
02:02:47.630 - 02:02:48.380, Speaker B: Okay.
02:02:53.230 - 02:02:58.720, Speaker F: But I will we are going to start.
02:03:13.500 - 02:03:15.480, Speaker G: Hey, we'll be at the end of the song.
02:03:18.550 - 02:03:19.300, Speaker D: Nice.
02:03:19.990 - 02:03:21.314, Speaker G: Of course you can hear it.
02:03:21.352 - 02:03:21.940, Speaker A: Good.
02:03:25.110 - 02:03:28.500, Speaker F: Okay. Do you want to keep this mic here just in case.
02:03:33.750 - 02:03:34.322, Speaker B: For now.
02:03:34.376 - 02:03:34.930, Speaker F: Okay.
02:03:35.080 - 02:03:43.266, Speaker B: Nokia.
02:03:43.298 - 02:03:44.630, Speaker E: Kabasi Catalyst.
02:03:47.290 - 02:03:48.310, Speaker F: Incoming.
02:03:48.650 - 02:03:52.990, Speaker G: No in you tell me like it was a Shamaris.
02:03:55.250 - 02:03:57.230, Speaker F: No, but on the Javara.
02:04:25.670 - 02:05:06.800, Speaker B: It'S gonna work. Not working. Totally.
02:05:08.020 - 02:05:08.770, Speaker D: Okay.
02:05:10.500 - 02:05:11.920, Speaker G: Today to put the tag.
02:05:20.530 - 02:05:20.894, Speaker B: We.
02:05:20.932 - 02:05:30.570, Speaker G: Share the full screen. Now you won't check it.
02:05:38.970 - 02:06:24.370, Speaker B: Today'S. It.
02:07:22.140 - 02:08:18.992, Speaker G: So welcome abira everybody for coming to this talk. We are talking about ABEV three. My name is Tabith, this is my peer Michael. Yeah, we are going to learn more about the Ave Protocol new features of AV Three. First of all, what is Ave? Basically, Ave is a decentralized protocol liquidity market that allows users to supply cryptocurrency, provide liquidity to the protocol and head some yield of it. There's also other factors, that is the borrowers that can draw liquidity from the protocol but putting collateral first. They can use collateral and support the market like Ether Dai.
02:08:18.992 - 02:09:30.290, Speaker G: And also there is another actor is the regulators that take care of the healthy, making the borrower healthy. They basically liquidate procedures, basically paying back the death of borrowers to have risky positions or they are near quality. Well, we launched Abe B three, like, one month ago. It has received a lot of well, it was well received by the Ave community. And basically we caught the avalanche market that is now with around four billions of liquidity located at the protocol and by using liquidity incentives by the avalanche project and also we have the auto markets that are with a liquidity around between 5 million and 40 million with organic growth. We do projects in six networks, six different networks. And yeah, we also have more markets like the AMA market.
02:09:30.290 - 02:09:41.030, Speaker G: And now Miguel will talk about the new features of Abbey Three.
02:09:41.720 - 02:09:42.470, Speaker C: Yeah.
02:09:43.580 - 02:10:59.468, Speaker F: Thanks, David. So yeah, the third iteration of the Abe Protocol builds upon the foundational elements of the Abe protocol which are instant liquidity, the A tokens, different interest rate strategies and so on and so forth. Win with new groundbreaking features that spans from the increased capital efficiency to enhance decentralization. So yeah, let's dig into some of the new features of this self iteration of the protocol. First, in terms of capital efficiency, we have Portals. So yeah, given the fact that we live in a MultiChain and multirolap world, having a way to migrate tokens from one chain to another in a seamless way is more and more important these days. While the previous iteration of the protocol, the version two goes into play on multiple networks with meaningful TBL, it's true that there was no way to have all the supply assets flowing seamlessly from between chains.
02:10:59.468 - 02:11:51.756, Speaker F: So this is the point of Portals. Portals is a new feature of the core contracts of the version three of the protocol that allows the supply assets to flow seamlessly between chains. So in high level it leverages the unique design of the A tokens. So whitelisted bridges are able to take a tokens from the users in one chain and mint those eight tokens into another chain. So first we will need breaches that plug into the portals. These kind of bridges will be named as ports. Once they are kind of registered in the system they will need to call a couple of functions new functions that are in the pool contract.
02:11:51.756 - 02:13:15.160, Speaker F: These functions are mint and backed and backed and backed. The first one allows the bridge to mint and backed a tokens which means that these a tokens don't have the underlying assets with them and then they will need to use the other function which is called back and backed which allows to back those a tokens that were already minted. So portals essentially allows these bridges to supply assets in a deferred manner. So when a user wants to move their a tokens from the source network to the destination network, first the bridges will take the a tokens from the user in the source network then instantly mint brand new a tokens in the destination network and redirect it to the user. And once the underlying assets, the real liquidity has been moved through the bridge could be the canonical bridge of the chain or whatever bridge in the ecosystem. Then they will be able to back those already fresh new minted a tokens with the underlying. So at the end the destination network will have all the a tokens with the corresponding underlying assets.
02:13:15.160 - 02:14:41.044, Speaker F: So as you can imagine this feature is really interesting because it allows the users to move the a tokens from one chain to another without losing a penny of a dollar and without the need of unwinding the position which is really cool. Also the efficiency mode this tries to increase the utilization of the capital that is sitting in the protocol because as you already know, there is a lot of assets and capitals that are currently sitting idle in the protocol. So this is mainly caused because the risk parameters, the risk parameters in the system. There is one of the risk parameters in the system which is called the collateral factor. The collateral factor determines how much of an asset a user can borrow using an asset as collateral. So having a 75% collateral factor on die means that a user can borrow up to 75 die with 100 die as collateral. So if the protocol is able to increase this collateral factor they will be able to increase the borrowing power of the users and thus increase the capital efficiency of the protocol which is really good.
02:14:41.044 - 02:16:05.660, Speaker F: So as you can imagine, the collateral factor of the assets in the previous iterations of the protocol were a bit conservative because all the assets has its own characteristics, its nature and even different price volatility. So as you can imagine, it's not the same having a user borrowing USDC against ETH than having the user borrowing USDC against Dai. The later position is less risky for the user and also for the protocol. So this is mainly because both assets are stable coins and also because those assets are correlated in price. So that's the main point of the efficiency mode. What if we are able to group the assets in categories with the same characteristics, same nature or the same price volatility so we can increase the borrowing power of the users in that cases. So in the protocol v three there are high efficiency modes categories, we have the stable coins category with USDC, die USDT or even the Euro pairs.
02:16:05.660 - 02:16:47.980, Speaker F: Also we could have BTC variants or ETH variants and let's see what's coming from the community in the future. It's going to be interesting. So when a user enters emote in one of these categories, let's say for example, Stablecoins, the user will be able to enjoy high borrowing power using Stablecoins as collateral. But they will only be able to borrow stable coins. So they still can supply other assets and even use them as collateral. But only with stable coins. They will only be able to maximize their borrowing power.
02:16:47.980 - 02:18:06.810, Speaker F: So right now users in stablecoins emote they enjoy 97% of collateral factor which is really good because they can borrow up to 97 die with 100 die as collateral. So these features will bring wave of new use cases, new tools in the ecosystem like for example high yield farming strategies, high leverage tokenized positions, also diversify market risk because you now can split your assets in categories. So yeah, it's going to be nice. Now more on the risk and security side. First we have the supply and borrow caps. This security measure is pretty intuitive because this security measure allows the community to set hard caps on the amount of the supply assets and the borrowing assets. So in this way the protocol can control and modulate the exposure to certain assets in some way.
02:18:06.810 - 02:19:47.732, Speaker F: Supply and borrow caps together with isolation mode is a good combination, an interesting combination to modulate the exposure as I said, but also to list assets in a more secure way. So until now, usage assets when are listed in the protocol allows the users to use that assets as collateral and borrow any kind of assets in the protocol. So theoretically we could have a user borrowing the whole capital of the market using one single asset as collateral which is far from ideal because that will mean that the protocol is completely exposed to that certain asset. So isolation mode which is inspired by the MakerDAO, I don't know if you know it, but in MakerDAO you have different vaults. This vault has a particular asset for each and they also have adept ceiling so you cannot mint more than the ceiling using that specific vault and that specific collateral. So isolation mode works in a pretty similar way. Users, the community can list assets in isolation mode and users using this asset as collateral which is isolated, they only will be able to borrow up to a certain limit of assets.
02:19:47.732 - 02:21:01.040, Speaker F: So for example, in this case we have the token two which is listed in isolation mode with a debt shielding of 10 million. And that will mean that users can use that token two as collateral, but only they will only be able to borrow up to $10 million worth of assets in stablecoins. So as I said, this is an interesting way to modulate exposure and also list assets in a more secure way. And yeah, all of you can imagine having a new asset into the Protocol first listed as in isolation mode, then keep on going with supply and borrow caps, finally maybe without any other security measures at all, which is good. Also the price. Oracle sentinel. This Oracle is really specific for layer twos and increases the experience of the users in those networks.
02:21:01.040 - 02:22:12.300, Speaker F: This price Oracle Sentinel allows to handle eventual downtime of the sequencer. As you may already know, the sequencer are the entities that are in charge of submitting and settling transactions in the network. So if the sequencer goes down, then the network essentially stops working. So during this downtime we could have price variations and these price variations could affect the users positions in some way. So when the sequencer goes up and the network starts working again, these users could have these positions affected since all the price variations come into play at once. So in order to mitigate this scenario, the protocol introduces a grease period which is a duration of time that the users are able to fix their positions in order to don't get liquidated in some way. Yeah, decentralization.
02:22:12.300 - 02:23:23.264, Speaker F: In the third version of the protocol there were also some improvements in terms of decentralization. In the previous iteration we already have some permissioning system where all the rules were specified with their responsibilities. But in this version this permissioning system is more fine grained and more sophisticated. And also there are some new roles in the system that brings new ways of doing things, let's say. So we have the risk admins and also the listing asset admins. The risk admins is a specific role of the system that has the ability to change the risk parameters of the reserves without the need of a governance vault. These risk admins could be Dows or any other entity or even automated agents that react to specific events or metrics and change the risk parameters accordingly.
02:23:23.264 - 02:24:37.592, Speaker F: They can change the risk parameters or also the interest rate strategies of theirselves as well. And also we have the listing admins, which has the ability to list assets without the need of going to a governance proposal, which is also interesting because we could have some new strategies of listing assets. And this is a kind of a way of delegating the governance of the community of the protocol to some other entity out there. So one of the discussions that has been in the community forum is the permissionless listing. So what if a community of users are able to decide which asset they want to list so they can stake a part of these assets in the protocol and use these assets as a backstop in case that something happens. So yeah, really cool. Also, as you can imagine, there is a bunch of new features in this third iteration of the protocol.
02:24:37.592 - 02:25:45.792, Speaker F: Some of them are more user facing futures, some of them are more in the technical side. But yeah, for example it's good to mention the repayment with eight tokens. So now this increases also the experience of the users. As you can imagine, users now are able to repay their debt with eight tokens. So if a user has a depth of 100 USDC, they can provide 100 a USDC to repay the debt. This as I said increases the user experience but also helps the protocol just in case the underlying assets gets locked in the Ave pool contracts for some reason. Also there is the introduction of the permit function and the EIP seven one two to the credit allegation function and also the introduction of a simplified version of the flashlong function with a reduction of 20% of gas cost.
02:25:45.792 - 02:26:18.910, Speaker F: This is only in the case that the user wants to flash loan one asset instead of assets. And yeah, there is many many more but in general the code was reorganized and also optimized so there has been a reduction of ten or 15% of gas consumption across the board. Across the board which is really nice. Yeah, that's pretty much all.
02:26:21.920 - 02:27:31.476, Speaker G: Yeah. We created some tools to help you to build on top of Ave. The first one is the Ave sandbox that these tools allows you to integrate or to fork a network that has been deployed with a simple command and it spins a hard node to say Abe market. It also allows you to faucet the assets that are listed in that market in an easy way and also it allows you to connect the abe open source front end to this local sandbox or to this local. Yeah, in this way integrators can will safely the top of markets in production but also in the same time a local host that is much faster to develop. The only dependency that you need is node JS. You can find the repo, the QR code and also GitHub.com
02:27:31.476 - 02:28:23.780, Speaker G: Ave. We also have some NPM packages with smart contracts and also some utilities, some helper factors that help you to develop new front end for abe or different dashboard that you need. The utilities contained all the helpers to interact with the protocol and also contains all the math related with the protocol. So it's quite nice. You need to rebuild the wheel well. As always you can check the code at the different repositories. Right now here at the hackathon we have the prices we are rewarding for the most innovative AB integration.
02:28:23.780 - 02:28:27.156, Speaker G: You can see the list of the.
02:28:27.178 - 02:28:27.940, Speaker D: Prices.
02:28:31.080 - 02:29:09.776, Speaker G: Some resources like the developer docs that are quite complete and it contains all the definitions, all the contact that runs, also the abeganas Dao. Here in that link you can request for proposals. Maybe you have an interesting idea to build on top of Ave as a community member. And here you can request a grant to develop that idea and execute that idea. Here. Next Sunday we have rabbit. So here is a monoscode that you can use.
02:29:09.776 - 02:29:17.236, Speaker G: It's hosted by the and that's it. If you have more questions, feel free.
02:29:17.258 - 02:29:18.390, Speaker D: To ask to us.
02:29:24.860 - 02:29:29.880, Speaker G: Okay, so that's it. Thanks everyone for coming. As you have one question.
02:29:29.950 - 02:29:31.770, Speaker A: Okay, I missed the code.
02:29:32.140 - 02:29:36.250, Speaker G: Yeah, of course. Hey, the code.
02:29:40.300 - 02:30:02.640, Speaker A: Something. So I would be brief. Did any of the exchange that handle funds in the sense that when you deploy version of a central lens of DAP might be introduced like security? Is that the case with this deployment or was more like an overall.
02:30:05.940 - 02:30:08.096, Speaker F: Gladiator Minnesota, could you repeat?
02:30:08.208 - 02:30:08.532, Speaker D: Yeah.
02:30:08.586 - 02:30:16.390, Speaker A: So I'm wondering if deploying a new version of the protocol introduces security risks that might.
02:30:18.760 - 02:30:46.510, Speaker F: Yeah, I mean, like any other protocol, if you deploy any version, you need to take into account how the upgrade is going to be. Of course, if you are using some kind of proxy pattern like Avidas, you need to take into account the storage layout and keeping things retro compatible, maybe wherever. So you need to take also things into account in that way. Sure.
02:30:47.040 - 02:30:49.970, Speaker A: Version two with version three are running at the same time.
02:30:51.060 - 02:31:14.744, Speaker F: Now. They are running at the same time. There is also some discussions in the forum to upgrade the contracts of the B Two market to B Three. And that's going to be a challenge. That's going to be a real challenge because yeah, exactly. So it needs to be bargains compatible. Also take into account all the functions, all the storage layout, these kind of things.
02:31:14.744 - 02:31:16.010, Speaker F: So yeah.
02:31:21.340 - 02:31:26.612, Speaker G: Any more questions? Great.
02:31:26.766 - 02:31:39.790, Speaker F: Nice guys. Thank you so much for coming. Reach us out if you want to talk about Ave or any hackathon idea or just about Avi B three or what's going on on Ave companies. Thanks for coming.
02:31:40.240 - 02:31:41.310, Speaker G: Thank you everyone.
02:31:43.280 - 02:33:30.100, Speaker B: Thank. It's. Great people.
02:36:59.600 - 02:37:00.350, Speaker A: And.
02:51:39.430 - 02:52:54.000, Speaker B: There'S Sam.
03:01:51.920 - 03:01:54.630, Speaker C: Chef, can you eat? You ha.
03:01:57.320 - 03:01:57.732, Speaker D: Test.
03:01:57.786 - 03:02:13.380, Speaker E: Entry, entry, entry. Antwaidry each hoka. Perfect. Antidast.
03:03:11.220 - 03:03:52.050, Speaker B: Sam? Yeah, sorry, but.
03:03:55.620 - 03:03:56.370, Speaker D: Yeah.
03:04:10.820 - 03:04:37.170, Speaker B: You sam me.
03:06:02.100 - 03:06:26.948, Speaker H: Hello. Hello everyone. My name is Nick. I'm from One Inch Network and today I want to talk a bit about our API and our limit orders API as well. So let's start from one inch. I just want to repeat a bit what we are doing and what is our value proposition. So, basically, One inch is Dex aggregator.
03:06:26.948 - 03:07:03.524, Speaker H: So we aggregate multiple DEXes when we want to swap a coin to other coin. So we have much more liquidity than any other Dex. And also we have algorithm called Pathfinder. So actually we build specific D app that allows you to swap coins or any other coin based on the path that we calculated. And it's pretty good path. So you get much more coins return amount than using any other decks or any other decks or dex aggregator as well. It's like a small example.
03:07:03.524 - 03:07:40.970, Speaker H: For example, for example, I want to swap 500K Ethereum to die. We see a lot of money just demo. So basically you can see the path here, so we just allow you to it's just one transaction. So you can swap through multiple pools in multiple DEXes and all of that will be atomic and the return amount will be the largest one compared to uniswap, for example. And basically the awesome thing is that you can access our API that allows you to integrate the.
