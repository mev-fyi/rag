00:15:47.880 - 00:16:00.348, Speaker A: Hello. Hi. ETH, New York. How are you going? Good to see everyone here. Hopefully you're all in an empire state of mind, ready for this hackathon. It's like packed out here. So I'm super psyched to be here.
00:16:00.348 - 00:16:39.368, Speaker A: I'm Ali, I'm a filecoin developer. I've Kit Or, I work at the Filecoin Foundation. And yes, the accent is Australian, for those of you wondering. But tonight I want to give you a brief intro into IPFS and Filecoin. And then I'm going to dive into the mechanics of making an NFT contract and why IPFS and Filecoin are so necessary, particularly if you're not storing that metadata on chain and why that sometimes gets really prohibitive as well. So this is a little project I've made. It's a MultiChain, multi contract personalized NFT collection.
00:16:39.368 - 00:17:23.580, Speaker A: So just built on solidity contracts. I've used both an ERC 721 and an ERC 1155 contract. And I'll dive into why they're different a bit later and with a react front end and some dev tools around this. So hard hat Morales for node provision and specifically NFT storage to store our NFT metadata. So, firstly, I just wanted to clear up some confusion that's maybe out there around a few names you've probably heard floating around the web3 ecosystem and share how these fit together. So, Protocol Labs, firstly is an open source research and development lab. It's building protocols, tools and services to improve the internet.
00:17:23.580 - 00:18:06.648, Speaker A: And we really believe in this concept at the moment. Actually, we're running funding the commons here in New York as well, in parallel with this. So we're really aiming to build tools and services that help radically improve and drive breakthroughs in computing and move humanity forward and for the common good as well. So some really big goals there. IPFS and Filecoin are two of the projects that were originally incubated by Protocol Labs and they now operate as their own separate but complementary projects within the ecosystem. Still sharing the same vision. But let's jump into firstly, cue the Star Wars music here.
00:18:06.648 - 00:19:02.270, Speaker A: Interplanetary file system. So this isn't just a meme name though, because as a distributed peer to peer network for files and folders, IPFS was designed to be able to work even when you're between planets. So let's say you signed up for the Mars colony program and you're now living happily on Mars. Maybe it takes you an hour or so to request a file from Earth that you need, but if someone else on Mars already has that file, then they can just serve that content to you instantly with IPFS. So maybe you're thinking this is just a fancy name for a peer to peer protocol or network now, but there's real gravity. Get it in what it does. Because IPFS is distributed by design, it has no central authority servers, it's designed to be offline first for resilience and it uses specifically a really unique and upgradable standard for addressing content.
00:19:02.270 - 00:20:02.192, Speaker A: And this is the unique part of IPFS, because rather than using methods that we might be familiar with for storing and accessing content, so location paths, we go to the web, we type in a Http URL, and that location serves us up a piece of content from some specific centralized server. So this is called location addressing, and we're never really sure what content we're going to get for that location that we go to. So with IPFS, instead we generate a content ID. And I'll just jump to this one for a second. So each piece of content actually has its own cryptographic hash function, so it's like a unique fingerprint for each piece of content. And this is kind of wild, or at least it was to me when I first started looking into IPFS. And it's because it's such a mind shift from the web two way of doing things that we're really accustomed to at the moment.
00:20:02.192 - 00:20:48.092, Speaker A: And it's super elegant for its simplicity, because this really opens up the web to fully massively distributed storage systems. And that's important, right? If you can always verify what content you're getting back, you really don't have to care where that content comes from. So that's really like the key part of learning IPFS, the fact that it's not just a peer to peer protocol, but it also has this content addressing system, so it makes the web work peer to peer. And by the way, that's a bit weird. My speaker notes have stopped. Anyway, that's all right. So IPFS is not just for Web Three either, so it also works with web Two.
00:20:48.092 - 00:21:39.996, Speaker A: It's a protocol, not a blockchain. So it's used in things like Flickr has been using it. Some of our amazing colleagues here in the Web Three are also using it. So I know Vallast has built on top of it, Livepeer is built on top of IPFS audience as well, to name a few. So the problem with IPFS in the wild though, is like, you can run your own nodes, but as soon as you shut your laptop, that content that you've stored on your own node is no longer really retrievable by anyone else. And let's be honest, not everyone wants to run their own content nodes the other way. You can maybe ask someone else to store your content for you, but unless they really like that data, or they really like you for some reason or whatever it is, that content may become unretrievable after a while.
00:21:39.996 - 00:22:35.116, Speaker A: And we've all seen this with kind of torrenting systems where less popular piece of data just stop being retrievable or available, basically. So a third way to do it is you could pay a pinning service to pin that content on the net for you. But if we start doing this, we're kind of opening up to these centralization issues that we already have in the web today, and we really kind of want to avoid centralizing our data pinning services by using pinning. So despite maybe what the really annoying anyway, despite what the community's general altruism or wanting to do this, eventually content can become like unretrievable. So this is where Filecoin comes into the system really. So Filecoin is storage designed for web3 from the ground up. It's a distributed storage network.
00:22:35.116 - 00:23:10.008, Speaker A: It uses crypto economic market levers to incentivize the storage of data. So it uses two main consensus mechanisms to do this. The first is proof of replication. This ensures that providers are actually storing your data and keeping it safe when you first upload it. And the second one is proof of spacetime. So all of our storage providers, and there's like over 4000 storage providers globally at the moment, all of them put Filecoin up as collateral. And they have to prove daily that they're holding a subset of the data that you've asked for them to store.
00:23:10.008 - 00:23:54.776, Speaker A: And if they don't do that, their File coin is slashed. And because running a data center is quite expensive, plus the amount of Filecoin to do it is also expensive, we're really decentivizing having bad actors in the system as well. So the second thing is that Filecoin runs on market deals. So if you want to store data on the network, you can firstly decide how many storage providers you want to store that with for resilience and redundancy. And then secondly, you can decide how long you want that content to be stored. So it's really your data and it's your choice. You can decide if you want to store that for six months or you want to perpetually store it using something like smart contract for 500 years and just keep doing that.
00:23:54.776 - 00:24:44.308, Speaker A: So the too long didn't read basically is that IPFS and Filecoin are great complements. So IPFS is great for that content, addressing verifiability of content coming from anywhere and for fast and flexible retrieval. And Farcoin is really that persistence and verifiability of that data storage layer. But what's this got to do with NFTs? You might be wondering, well, if we dig into the anatomy of an NFT contract and this is the ERC 721 standard, the original NFT contract, and this is the Open Zeppelin one. So you could build an ERC 721 from scratch if you wanted to. But most people I think, would use this template. It's been audited, it's community tested.
00:24:44.308 - 00:25:18.936, Speaker A: This is probably where you'd start in developing an NFT. So this is a contract from Open Zephyrn. Like I said, it's been audited and community tested. And here's the API for it. Here's the basic functions that come with this ERC 721. And here's an example straight off the Open Zeppelin website that shows this implementation of ERC 721 in solidity the ethereum language. So this contract basically creates a gram item here as an NFT, an ERC 721.
00:25:18.936 - 00:25:56.748, Speaker A: And the function that mints that NFT or stores it on the blockchain is called award item. In this scenario, in this code here anyway, and it takes two parameters. The first is the address of the player. So I assume that's who they're awarding this NFT to, the player. And the second one is a string and a token Yuri. What is this token? Yuri well, it turns out that this token Uri is basically just a JSON file. It's an object that has a few descriptors of what this NFT is and it's really what you'll view on the web as an NFT.
00:25:56.748 - 00:26:52.444, Speaker A: So you can see here it's got a name, a description, an image, and say, some other attributes like strength or whatever you want to add to this game item. For example. Now the problem with this contract is that this image has a location address, it's got a Https address and even OpenZeppelin itself says you'll notice that this item's information is included in the metadata, but that information isn't on chain. So a game developer could change the underlying metadata, changing the rules of the game. And there's been some famous examples of this happening because they're using location addressing rather than ensuring immutability and non fungibility of the NFT with content addressing. So one of them is this like rugs contract here. Someone created a full NFT line, it sold out, it was really famous.
00:26:52.444 - 00:27:35.084, Speaker A: And then they swapped out all the tokenuries, all the metadata for actual rugs. It was a rug pull basically. So pretty funny that one in retrospect. The other one was this F bubbles one, I won't swear, but they basically use their NFT collection to then advertise their next NFT collection. So they change whatever this bubble said to advertise their next collection. Which really, if you're buying an NFT, you want it to be non fungible or at least operate how you understood it to operate in the first place. And this is where you can really come into trouble with Http addressing in NFTs.
00:27:35.084 - 00:28:30.620, Speaker A: So you need firstly, if you're not storing your metadata on chain, which let's be honest, it can get very expensive, especially if you're storing this on the Ethereum main net, and particularly for large files as well. If you want audio, if you want video, if you want 3D objects as part of your NFTs, which you may well want to do with for example, metaverses or gaming examples, then this gets really prohibitively expensive to store on chain. So secondly you want to keep a fixed address for that content that ensures immutability. Now you can code in like Mutability to your contracts and actually we've got a whole tutorial on how you would go about that in the right way as well. But that's beside the point for now. But we want to ensure that this non fungible token stays non fungible. So that's where the IPFS content addressing protocol comes into its own with NFTs.
00:28:30.620 - 00:29:25.040, Speaker A: So these CIDs on IPFS guarantees immutable content referencing. And the third thing is you really need storage that's persistent and reliable. You want these NFTs to last forever, right? Not just like the next five minutes and then never be retrievable again. So this is where filecoin comes into play as the Decentralized Storage guarantees for that NFT metadata. Luckily though, you don't have to go around and create the whole IPFS thing and then store it on eight different storage providers and make storage deals with those storage providers instead. We've created a public good called NFT Storage, and this is designed for devs who want free, multi generational decentralized storage. Firstly, you create this NFT Storage metadata, it will create a CID IPFS CID for you.
00:29:25.040 - 00:29:56.030, Speaker A: It will then make deals with at least eight storage providers to store that filecoin content and it will auto renew those deals in perpetuity. And the best thing about it is it's completely free. It's a public good, so there's no cost to using NFT storage. It's actually used by Openc and Magic Eden as well. We're storing about 45 million, I think it is, at current rates, NFTs on NFT Storage. So it's really like a standard. It's not just great swag, but it is that too.
00:29:56.030 - 00:30:44.830, Speaker A: So project demo, I'll see if I can hopefully change my screen, which looks like that's not what I meant to do. Awesome. So this is the project that I've kind of made. You can see I can just type in my name and it's kind of a customized personalized NFT. Now I'm doing this on the rinkby chain at the moment, but it also deploys to polygon or binance chain and that's via Morales. So I'm using Morales nodes to enable me to deploy to multiple ETH compatible chains with this. Now at the moment it says it's saving NFT metadata to NFT Storage and I just want to show you the mechanism behind that as well, if I can find it, which hopefully I can.
00:30:44.830 - 00:31:14.420, Speaker A: All right, yeah, not that one, not that one. Let's try this one. So this is creating the NFT metadata. This is my function that creates the NFT metadata. With NFT Storage, it's as really as easy as like importing that NPM library, that node library into my react front end, basically into my react front end. And I create the client the same way you do with anything with an API key. And then I use await client store.
00:31:14.420 - 00:31:57.350, Speaker A: You can see here the JSON that is going to be my metadata. So I've got a name, I've got a description, I've got an image and I'm just like encrypting that on my front end so I don't get any injections. But it's just an IPFS image basically and then know, storing whatever other attributes I want to with it. So it's really as simple as calling a function like this to create your NFT metadata. Let me just go back to it looks like it's actually minting. It's asking my wallet to mint. I just want to go back here quickly because if I have a look here, I've actually created an IPFS image link and I think my internet is a bit slow, so my image isn't showing up.
00:31:57.350 - 00:32:51.270, Speaker A: But you can see here like it creates I don't know if you can actually see the URL, but it's got a Https and then it's got a CID, which is like this big long letters and numbers here. And then it goes IPFS NFT storage link and the name of this image, which hopefully will come up soon. So this is our gateway. So IPFS by default doesn't actually work straight with Http, which makes sense, right? They're two different protocols. So IPFS needs to go through a Http gateway to be seen on regular web browsers. Now, luckily for us, browsers like Brave and Opera do this by default. So I can just type in IPFS and then the CID and Brave will automatically route that through a Http gateway for me.
00:32:51.270 - 00:33:17.500, Speaker A: But other browsers don't do this by default and that's where you'd need to add on this gateway for it. So things like Chrome wouldn't do that by default. Don't know why that's not coming up. Let's not worry about it. So basically, after I've created my NFT metadata, it will return an IPFS CID for me, which I'm pretty sure it does. Let me just type in metadata instead. There we go.
00:33:17.500 - 00:33:58.120, Speaker A: Got too many console logs anyway, so this is what gets returned from NFT storage. Hopefully you can kind of see that. So basically Ipnft URL, and then that data that I stored with it. So attributes, description, image, and the name of my NFT. So I'm taking that IPFS URL basically, and then I'm sending that because this is actually a JSON object, which I can verify by putting this into Brave browser as well, which also may not come up. There's an example from earlier. So there's one I did earlier, like the cakes.
00:33:58.120 - 00:34:24.820, Speaker A: Anyway, so this should come up. There we go. So this comes up as the JSON object here, and I just typed that straight in IPFS and then the CID into the Brave browser and it automatically shows you the JSON object that I put into that. That's kind of just an aside. Now if I do click Mint, that's what I will send as my IPFS Uri to my contract.
00:34:27.560 - 00:34:28.310, Speaker B: Sure.
00:34:32.250 - 00:34:55.760, Speaker A: So now I can call lick mint. Oh look, there we go, my images finally showed up. Thank you. It does work. It's true. So now my NFT is Minting and it's basically just calling that Mint my NFT function in the ERC 721 contract or 1155 contract. Taking that IPFS Uri and sending it through.
00:34:55.760 - 00:35:50.884, Speaker A: Think maybe I'm just about at time here, so I won't linger too long on this. You can actually go. And are we still note what are we seeing up there? It looks like sorry guys, looks like my screens are showing the wrong thing. So I'll just try and fix that. That's better. All right, so you can actually go and mint your own NFT. I've only got it on testnet, but you can go and mint your own on whatever chain you like.
00:35:50.884 - 00:36:50.180, Speaker A: Just go to New York, filecoin NFT on the bitly link there, and you can go and mint your own if you've got some testnet. What else have I got? All right, there are more DevTools than just storing NFT metadata, obviously, to IPFS and Filecoin. Some of the easy ones. If you want to get to know IPFS, you can install our IPFS desktop or IPFS companion for browsers and play around with IPFS and how it works that way. We also have IPFS HTP and Go client libraries, so you can go and have a look at those and use them in your projects as well. Fleek hosting is another cool one. So Fleek actually deploys your static websites on IPFS and then stores that to filecoin, and it's as easy as using, say, Netlify or Versaille, which you might be used to in the web two world and taking your site from GitHub and then deploying it through Fleek instead, which actually is on IPFS and filecoin.
00:36:50.180 - 00:37:19.730, Speaker A: So actually making your DApps your decentralized apps more decentralized instead of using a centralized website. Sorry, Cicde. You could use fleek. So another cool project is Web Three storage. So this is for any content that isn't just NFT metadata. So files, folders, text, whatever else you might want to archive and store. Web Three storage is the right place to go for that.
00:37:19.730 - 00:37:59.196, Speaker A: Another one I'll mention is textile powergate. So this is a bit more advanced. It's a docker container wrapped around an IPFS and Filecoin nodes, and it gives you more granularity around how you want to access storage deals or access lib peer to peer, which is another thing in our ecosystem, or access IPFS. They also have some experimental bridges to other chains as well. And the other thing they do have is something called Threaddb. So a lot of people come to Web Three and they're looking for a relational database. Now, that's not an easy thing to achieve in Web Three and distributed storage, but there are people working on it.
00:37:59.196 - 00:38:36.596, Speaker A: And one of those projects is Threaddb. Another one of those projects that's working on a relational database is Orbit DB. So you can try that out. If you want to get in the weeds and work on something relational database, have a go at Orbitdb or Threaddb. There's also heaps more tools out there using IPFS or Filecoin or making them easy for you to use, I should say. So Ceramic is also using IPFS and Filecoin, and that's a decentralized identity based solution for social ID portability Lighthouse storage as well. Also makes it super easy to use IPFS and Filecoin.
00:38:36.596 - 00:39:01.708, Speaker A: And another project in our ecosystem if you're looking for random numbers is Dran. Love. So check that out if you're looking for random numbers. So some further resources as well. Here's that guide to Mutable NFTs that I was talking about earlier. So that's on Nftschool Dev, there's also more like really short tutorials that you can go through on proto school and get an idea of how that works. There's.
00:39:01.708 - 00:39:34.134, Speaker A: Obviously the docs always look at the docs, right? And then our YouTube channel as well. And after this hackathon, if you do submit a project, you can go and apply for one of our grants. If you want to keep building on your project, that's probably some of our further resources. Get in touch. Of course, all our get in touch things be involved. You're already involved because you're all here, right? So congratulations on that. And I've also got finally, I just want to show you some project ideas.
00:39:34.134 - 00:40:17.414, Speaker A: So these are some of the cool projects that are actually building on IPFS and Filecoin. So I did mention live here and audience earlier, Huddle One, if anyone's seen the Zoom like Web Three version though, huddle One is also building on IPFS. And like I said, OpenSea is using NFT Storage. There's a couple of cool projects at the top there that are from ETH Amsterdam that, well, I really liked. So Tetris, they were creating a whole Tetris game basically, and saving each piece as an IPFS CID and then reconstructing that and making an NFT out of that game. So I felt like that was like a really clever use as well of things to do. But there's so many more things you could do with this.
00:40:17.414 - 00:40:44.590, Speaker A: So you could create a video streamer, you could create a YouTube wrapper with IPFS which might be kind of current at the moment, distributed metaverse. There's heaps of project ideas and past winners on our hackathons filecoin IO site. So if you want to get some inspiration, go and check out that site and otherwise thank you everyone. Appreciate your attention. And I'll be around all weekend, so if you want to ask us questions, come by the booth.
00:46:08.100 - 00:46:49.964, Speaker B: Hi guys, my name is Jack and I do developer relations at O One Labs, which is the company that incubated the Mina Protocol. And today I'm here to talk to you guys about the Mina Protocol and ZK apps. For people who don't know, the Mina Protocol is a layer one blockchain that is kind of built with zero knowledge proofs at the center. And so this impacts both the way that the blockchain itself works in terms of consensus and stuff, and also the way that developers build applications for the blockchain. And so we'll kind of get into that in a minute. Yeah, so hopefully by the end of this presentation, you have kind of a sense for what Mina is and also a sense for how you might go about building an application on Mina and why you might want to do so. Here's kind of our run of the day.
00:46:49.964 - 00:47:45.148, Speaker B: We'll talk about Mina and Zkap's architecture, then Snarky JS, which is the TypeScript library that we use to write zero knowledge proofs for Mina. We'll go through a Hello World example and then I'll direct you to places where you can learn more and we'll do a quick questions and answers. So first we'll start with Mina. Mina, probably you've seen the marketing. Our marketing is full of this idea that we're 22 KB other blockchains grow because you have to remember the entire history of transactions in order to be able to kind of verify a recent final state. Mina works differently because it uses recursive zero knowledge proofs to basically prove that all of the previous transactions are valid and then prove that all of the new transactions are valid inside of a zero knowledge proof that can then be put inside of another zero knowledge proof and so on and so on. And so this is useful because the zero knowledge proofs are fixed size.
00:47:45.148 - 00:48:28.536, Speaker B: They always stay at, well, the zero knowledge proof and a couple of other things total to 22. This is useful for some things like bridging. We'll touch on this in a minute. But it's also kind of just a good thing to keep in mind as we go towards how you build applications using Mina and why you might want to. Because the benefit of Mina is not just that it's very small, but also that it enables a huge amount of things that you couldn't do on a more traditional blockchain. Mina is Succinct, it's small, uses recursive ZK snarks to compress the blockchain into a single ZK snark. And this proof system that we use is called Kimchi.
00:48:28.536 - 00:49:18.750, Speaker B: It has some kind of qualities from plank and halo two and then some things that are kind of all its own. It's trustless, it's recursive and it's pretty efficient. It has some cool custom gates that let you do some useful things really efficiently. And so how does an Ethereum DApp work? Well, you tell Ethereum what you would like it to do and it does this on your behalf. And the result of that is that anything that you want to do on Ethereum is going to be public. And if you want to kind of make it private, you have to really think a lot about how you're going to do that. There are ways to obfuscate the public data, but it's usually not simple.
00:49:18.750 - 00:50:10.910, Speaker B: And it's pretty constricting in terms of what kind of applications people have developed over the last five years. Mina ZK apps work significantly different. The computation actually happens off chain. And so you write your smart contract in Snarky JS, our TypeScript library that I'll get to in a second and the user just runs it like they would run code that's a part of a web app like Google Drive. How do you keep this secure? How do you guarantee that users aren't doing things that they're not allowed to do? And that's what we use our zero knowledge proofs for. So when you interact with Mina, what you're doing is running the code yourself, you're running your transaction on your own computer, and then you're generating a proof and the relevant state updates, which can be nothing. You cannot update the state at all, or you can update the state depending on kind of if that's something that's useful to you or not.
00:50:10.910 - 00:50:42.948, Speaker B: The advantage of this is that it's scalable in the sense that there's no gas model. The only thing that the Mina blockchain is doing is verifying your proof. And that's the same amount of work every time, and it's the same size. Oh, cool. Okay. Yes, that's the same amount of work and it's the same size. And so this means that every transaction, well, every ZK app transaction costs basically the same amount.
00:50:42.948 - 00:51:33.376, Speaker B: It varies based on market demand and congestion, but there's no gas model. And so you can do a little bit of computation and that will cost the same amount as doing a huge amount of computation. The only limiting factor is how long you want to sort of wait for your computer to do things on its end. It also is private because you don't have to send any of your information to Ethereum. This makes it really kind of easy to see that if you do all the computation on your computer and you send a very small zero knowledge proof and you've done a lot of computation, well, there's no way to commit to all this computation. Inside of this tiny zero knowledge proof, you have privacy by default, and then you can kind of open things up as much as you want to. So you can start with a level of privacy that is sort of so extreme that it basically makes the applications useless.
00:51:33.376 - 00:52:20.660, Speaker B: And then you can go all the way to this place where you just make everything public. And so you can pick anywhere in the middle on that kind of slider, whatever fits your use case. Well, I think I kind of touched on this, but the off chain execution is basically unlimited. It's only limited by the kind of computer hardware that you have that's generating the proof and the amount of time you're willing to wait. So what is this useful for? So here's kind of an example of something that Mina can do that is kind of unique. And so this would be to prove that I have more than $5,000 in my bank account without revealing the exact amount or any identifiable information about me. And so this is useful because you might want to kind of just use one quality of a piece of data without having to give that data to everybody.
00:52:20.660 - 00:53:29.416, Speaker B: And in the case of a blockchain, you know the entire world. And so you can define a smart contract that will go through your financial data and prove that you have more than $5,000 and not disclose the exact amount of money. That you have, you can write a program that will basically only throw true if you have more than $5,000 and you don't have to run that computer I'm sorry, you don't have to run that program on somebody else's computer in order to prove that it's ran correctly. So something else that's interesting about kind of Mina and its succinct quality is that you can actually bridge Mina state to other chains much easier than you can in other blockchains, where the total size of the chain grows significantly over. And if you're interested in that, come talk to me at our booth. We'll be here the next two or three days. So a ZK app is what we call these decentralized applications that use zero knowledge proofs.
00:53:29.416 - 00:54:24.552, Speaker B: And this word kind of includes the smart contract and the UI. And this is cool because, as I said, the smart contract is written in TypeScript now, which means that you can actually just write it in TypeScript, publish it as an NPM package, and then import it into your front end and just deploy basically your front end. So a Snarky JS contract is compiled into basically two artifacts. The code itself remains. And this is like you actually run the code that the contract developer writes directly when you use Snarky JS. But in order to constrain this code and make sure it's executing correctly, we use Approver function, which is something that runs locally, does the computation, and then generates a zero knowledge proof that it ran in the correct way. And a verification key, which is sort of like a commitment to the state of the code at the time that you publish it to the blockchain.
00:54:24.552 - 00:55:20.304, Speaker B: So this is how you ensure that nobody's changing what the code does. It's kind of how you identify it. And when you deploy the verification key to the Mina blockchain, it creates something called a Zkapps account, which is just like a normal Mina account, except for that the way that you can interact with it is now determined by whether you can create a valid proof. And then you would include that with your transaction in order to kind of just like in order to be able to interact with the account at all, you have to have a valid proof. And so you can set the account up in such a way that you'll only be able to generate a valid proof in the event that you meet some specific qualification. That would be basically what you have programmed the code to do. So, yeah, you can see here's, I guess, a demonstration of that.
00:55:20.304 - 00:56:19.104, Speaker B: You send a transaction and it updates the verification key for one of these accounts, and then you have a smart contract on Mina and you can't send the transaction without a valid proof, and you can send the transaction with a valid proof. And so every ZK app is compiled into a program which has the input arguments and the on chain values. So these would be the values that you're taking either from users or from the current chain state. And then outputs, which will be a list of updates to perform and a list of preconditions related to the on chain state. And so when you run the Smart contract, if you run it correctly, you can get a valid verification key and I'm sorry, proving key, and you can send that to the Mina blockchain along with the state transitions that you want to take place. And as long as the zero knowledge proof is valid, mina will update these states. Okay, so kind of getting into Snarky JS a bit more.
00:56:19.104 - 00:56:49.704, Speaker B: Snarky JS is written using TypeScript. It's a TypeScript library and you import it just like you would any other TypeScript library in practice. It feels a bit like React to use. It feels kind of like a framework for defining zero knowledge proofs. It's very easy to use and it fits in nicely with existing tooling, which is really nice because kind of like a part of our vision for Snarky JS is we're really ecosystem focused. We want to make it so that people can write code that other people will use. That way, if you have somebody who's really good at cryptography, they can write a library.
00:56:49.704 - 00:57:38.680, Speaker B: And if you have somebody who's sort of more entrepreneurial, they can use this library to make an application, I think. Yeah, JavaScript and kind of the ecosystem around it has really kind of led the way there in terms of how do you get a bunch of people sharing as much code as possible. So our developer tooling is called the ZK app CLI. And you can just NPM install g, the Zkap CLI and ZK project name and you'll have a project ready to go. It'll scaffold everything and set up testing linting all the stuff you need to deploy to the chain. It's very straightforward to use and yeah, you can clone it. Now, Zkapps are written in TypeScript using Snarky JS.
00:57:38.680 - 00:58:12.888, Speaker B: We use existing open technologies. It runs in the browser and node JS. You can use existing JavaScript and TypeScript libraries and tools. We kind of touched on this. You won't be able to import a JavaScript cryptography library or something because it's a bit like how you can't import Jquery stuff into a React project. It kind of has to speak the same language, but you can still use a lot of the stuff that you'd want to. You have really good Vs code support, IntelliSense and copilot work.
00:58:12.888 - 00:58:37.330, Speaker B: That's cool. And so okay, what kind of data type do we use when we program these zero knowledge Smart contracts? We use something called a field, and this is an element of a finite field, which is kind of like a math idea that's not super important to get way into for most practical purposes. It'll end up feeling a lot like a UN two, five, six, but.
00:58:39.620 - 00:58:39.948, Speaker A: It'S.
00:58:39.964 - 00:59:26.308, Speaker B: A little bit smaller. So it's basically an unsigned integer with some added caveats, which are that you can overflow and division works a little bit differently. But we have to use this data type because it's what makes the zero knowledge proof possible. Yeah, so we have went through this, it's the field type in Snarky JS, and then in addition to this, on top of this field type, we've implemented some of the other types that you might like, like booleans, unsigned integers. Actually we have signed integers and we have something called circuit value, which you can use to kind of describe even more specific data types that you might want. Functions are just normal TypeScript functions. We use a decorator in order to kind of tell Snarky JS that hey, this is something that's going to be called by a user.
00:59:26.308 - 01:00:10.110, Speaker B: And data are also normal TypeScript classes. So you can see sorry, yeah, we just have a function here. Pretty simple. The only thing that's interesting is that instead of using the JavaScript infix operator, that would be like the plus sign x space plus space one, we have to call this add method. And this is because Snarky JS needs to keep track of what we're doing and we need to be working with this field type. So JavaScript doesn't have a field type and so we have to call this method in order to be able to do addition or multiplication on this field type. Other than that, it's pretty much what you would expect though.
01:00:10.110 - 01:00:51.624, Speaker B: So, yeah, we'll walk through a Hello World example really quickly and then probably have some time for questions. So we'll write a smart contract with a single state variable named x and it will have a method update that will let us replace X only with its square. And we can only update it if we control a secret admin private key. So this is how you gate who's allowed to call specific things. It's sort of a more general model than probably people are used to with Ethereum. So if x is equal to three and we call update nine with our secret key, then this should work. And then if we call update 81, this should work.
01:00:51.624 - 01:01:53.710, Speaker B: And if we call three to nine, that works, but nine to 75, this won't work. So to write a smart contract, we just extend this smart contract class in Snarky JS. So we're making a smart contract called Hello World and ZK Apps. By default they're associated with eight field elements that are stored on chain. And so we don't have a lot of on chain storage by default because we expect that people will use these field elements to store commitments to off chain storage or storage on IPFS. You can put the data kind of anywhere you want, you just need to store a commitment to the data on chain. And so we use this state field decorator to basically say we're making this variable X and we want this to exist on chain as a field type so we could replace like field with bool or something else and that would work as well.
01:01:53.710 - 01:02:49.612, Speaker B: And yeah, override deploy to configure the smart contract that's not super important in this case initializing this date. Oh, I see. Yeah, in this case this deploy method is the method that's used to put the smart contract on chain and we're calling this X set to three. So we're going to take this state here X and we're going to set it to three as the contract is deployed. And then we also have this party set value this self update delegate admin private key. So this is a method basically we're ensuring that the person who calls this contract will have the private key. A smart contract can contain multiple methods, each will have its own logic.
01:02:49.612 - 01:04:09.450, Speaker B: So here we've got this method decorator in front of update means that update will be callable by users and it takes in a field element called squared and then also a private key called admin. And so these describe how people can interact with it once it's deployed. And so in this case we'll take X, we'll get it from the onchain storage, we'll store it in the variable X, we'll square it using the square method and then we'll assert that it's equal to its square and then we'll set X on chain to squared. So if you were to pass in an X that wasn't the square of the prior X, this assertion would just fail and it would be impossible to generate a valid zero knowledge proof. So finally we'll take this admin private key and we'll actually convert it to a public key. So this is a totally constrained method so we can pass in a public key directly into a method that we're calling because it all happens on our local machine and then we can compute the public key from that. And then in order to make sure that only the person who owns the associated private key can call it, we just use this account delegate assert equals admin private key.
01:04:09.450 - 01:05:14.632, Speaker B: And so this basically means make sure that the person who's calling this is using the public key associated with the private key that we pass in. And so what happens under the hood when we run update nine with our secret key? We run some code in the method with some arguments and the result is that x goes from three to nine. And so that's kind of like what changes on chain. And then for our preconditions we're making sure that the admin secret key is associated with the admin public key and then that the person calling it has the admin public key. So yeah, this is kind of what these contracts end up looking like. We define a bunch of state up at the top, then we define a deploy method. So this is what you use to deploy the contract.
01:05:14.632 - 01:05:51.810, Speaker B: And then we have methods that are callable by users which are preceded by this method decorator. If you're interested in learning more, you should scan the QR code because it's cool and it's full of good information and yeah, I'll give everybody a second and then we can open it up to questions. Oh, it's not working. That's not awesome. Okay, yeah. Go by the booth and scan the QR code on the banner. Sorry about that.
01:05:51.810 - 01:06:28.170, Speaker B: I must have broke that at the last second. So here's the information that wasn't from the QR code. So we have a discord with a channel called Zkapp Developers. This is a great place to get information if you're interested in learning about zero knowledge applications and starting to develop them yourself. And then we're also on Twitter, and we have our GitHub repositories. And of course, the main thing is the docs. If you just search Mina docs in Google, you'll get our docs and we have tutorials and some explanations of kind of what's going on and how to get your head around it.
01:06:28.170 - 01:06:37.650, Speaker B: So that's it, I think. Does anybody have any questions? Data yeah.
01:06:43.400 - 01:06:44.310, Speaker A: Where does.
01:06:51.500 - 01:07:22.340, Speaker B: Yeah. Okay, so the question is, you know, we're talking about computation on chain and off chain, and where does your knowledge come into this? What can the prover hide from the verifier? I got that. Okay, cool. Yeah. How this ends up working is basically when you create the zero knowledge proof and you send it to the chain, that proof really just says, I did some computation correctly. It doesn't really disclose anything about the computation. And then you can kind of choose what you would like to disclose about the computation.
01:07:22.340 - 01:08:05.424, Speaker B: And so if you have something like, I don't know, let's say that you want to prove that you have the private key associated with, like, an ethereum account, you couldn't do this on another blockchain very easily. You could sign something. Actually, sorry, that's a bad example. Okay. A better example is a sudoku. So let's say that you have a sudoku and we've committed to the puzzle on chain and we want to prove that we've solved the sudoku. But we can't send the solution of the sudoku to the chain because then it would disclose what the solution of the sudoku was.
01:08:05.424 - 01:09:23.950, Speaker B: And then people wouldn't be able to use our cool sudoku app to get an NFT by proving that they have the right solution. So in this case, what you would do is you would prove that you did the correct computation to figure out that the sudoku is valid, but you wouldn't actually disclose what sudoku you input. And so this way you can prove I've solved the sudoku, but you don't have to tell the chain how you solve the sudoku. And that way this game can stay fun long term because after one person solves it, it's not solved for everybody. Yeah. So the question is, is the verification sort of a claim that something is true as opposed to, I did all this computation and I'm showing it? The proof is basically a claim that you did the computation correctly without having to show it. So you can kind of think of it almost like imagine that doing the computation correctly gets you the digest to some chunk of data.
01:09:23.950 - 01:10:16.146, Speaker B: When you do the computation correctly, you can kind of figure out what one of these good pre images is. That is basically the zero knowledge proof. And then if you do the computation incorrectly, then you would just have to guess over and over and over again in order to find a fake zero knowledge proof. Basically, yeah. So there's kind of, like, three parts. So we have, like, a Plonker Arithmetization scheme with some cool custom gates, and then we use the inner product argument that halo two and bulletproofs use. And then we have something called pickles.
01:10:16.146 - 01:11:18.220, Speaker B: And Pickles is kind of the thing that wraps this whole proof system that allows us to do recursion well, and it informs the design of some of the other parts of the proof system, too. But really what it's doing is basically you kind of have, like, two proof systems, and one proof system is able to generate proofs that are easily verifiable in the other proof system, and the other proof system is able to generate proofs that are easily verifiable in the first proof system. And so what happens is you generate a proof and it's verified in this other proof system, and then this proof generates a proof which is then verified in the first system. Again? Yeah. I'm sorry. Say again? Yeah. No, so Kimchi does not kimchi is our proof system.
01:11:18.220 - 01:12:10.130, Speaker B: I don't know. There might be some way to make something like that possible, but it's not it's it's not like it's not something that, like, intuitively makes sense or is, like would be an improvement, given our situation. Yeah, so Snarky JS is calling something called Snarky, which is an OCaml library that's basically working with stuff at a pretty low level underneath that. Yeah. And so come to the booth and we can talk a bit more about that. And yeah, I might even have to. Probably somebody on the crypto team at Minan I'm sorry, at Owen Labs knows better than I do.
01:12:10.130 - 01:12:28.712, Speaker B: Oh, yeah. We'll be here all night. All day, all night, all the days, all the nights. Yeah. Cool. I don't think there's I don't know. There might be more questions, but I think I'm out of time, so yeah.
01:12:28.712 - 01:12:29.690, Speaker B: Thanks, guys.
