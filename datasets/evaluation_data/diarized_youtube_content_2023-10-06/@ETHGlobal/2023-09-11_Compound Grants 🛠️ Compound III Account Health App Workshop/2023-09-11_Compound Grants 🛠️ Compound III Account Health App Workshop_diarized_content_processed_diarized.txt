00:00:07.290 - 00:00:30.642, Speaker A: All right. Welcome to the compound workshop for Heath Global, New York, 2023. Going to tell you a little bit about Compound and the bounty prize you can win in this year's ETH Global New York hackathon. I'm Adam. I'm the developer relations lead at Compound Labs. I'm here to help out with Ethereum related development projects that use the Compound Protocol. You can find me on Twitter and Discord.
00:00:30.642 - 00:01:06.846, Speaker A: I'm mostly in the development channel of the Compound Discord. I can answer your technical questions there. Compound Grants is sponsoring the hackathon this year, and we're really excited to be at this event where we're ready to see all the cool things that you're all building and ready to help out with Compound related projects. And if you want, you can apply to Compound Grants. We can tell you a bit more about that if you're interested and help you get your application accepted. So in this presentation, I'm going to tell you about the hackathon Bounties for this year. And if you're not familiar with Compound, I'll tell you about the Compound Protocol.
00:01:06.846 - 00:01:51.834, Speaker A: I'll tell you about the key differences between the protocols V Two and V Three. V Three is the latest version that has new deployments that came out this year and a little bit last year as well. I'll tell you about protocol governance, and I'll also show you some developer resources so you can get started building right away. All right, Compound Grants has a Pounty prize this year of $5,000 USD to the best integration of Compound Three. The rules are that your product must interact with a smart contract or with JSON RPC, with any instance of the Compound V Three protocol, or be a supportive project that is specifically created for the compound community's use. All right, a little bit about Compound. I work at Compound Labs, and we're the authors of the Compound Protocol.
00:01:51.834 - 00:02:33.326, Speaker A: It's a protocol made up of several smart contracts running on Ethereum, Mainet since 2018. And our mission is to create efficient algorithmic money markets. What gets me excited to work in the DFI space is that we author and continue to steward decentralized, free, and open crypto tools for everyone with an Internet connection, including the banked, the underbanked, and the unbanked. And if you think about it, that's a huge amount of market to serve globally. Anyone on Earth with a smartphone and an Internet connection can use DFI and can use Compound. So historically, we've seen interest rates for suppliers to the protocol as high as 15% APY on USDC, as well as other supported assets. And I love that.
00:02:33.326 - 00:03:27.518, Speaker A: What we're doing is different from TradFi because DeFi systems like the Compound Protocol are transparent and they're voluntary with public ledgers where code is law, and with DeFi, you instead get decentralization and transparency, unlike centralized banking and financial systems. That's what gets me excited to work in DFI and also in the Ethereum space. What is the compound protocol? Simply put, it is crypto asset money markets and we refer to it as the Compound Protocol. It runs on Ethereum, as well as several L2 S that you can see here. It's decentralized, which I will explain a bit more shortly. The main use case is that it allows users to earn interest on their cryptocurrencies or permissionlessly borrow other cryptocurrencies. So instead of an asset like Ethereum or USDC sitting idle in your wallet, you can supply it to the Compound Protocol and earn a varying interest rate.
00:03:27.518 - 00:04:07.622, Speaker A: Users that supply crypto collateral and borrow a different crypto asset against their collateral. And the interest that suppliers earn is driven by the interest that borrowers pay. Those are the two basic uses of the Protocol for everyone earn interest on your crypto or borrow other crypto assets. The Protocol can only support crypto assets that are tokenized on Ethereum or other EVM chains as ERC Twenty S. It allows suppliers to earn a variable interest rate on their assets. An individual that uses an app like the ones listed on the compound homepage or their own code, can use every feature of the Protocol. Developers can build their own apps.
00:04:07.622 - 00:04:43.890, Speaker A: They use the Protocol as interest earning infrastructure. Users or organizations can use interfaces to earn interest to borrow assets or participate in Protocol governance. So use cases that we've seen are crypto wallet applications. They use the Protocol to offer interest earning for their users and also any business that holds funds for a period of time. They use the Protocol to earn interest for that period to create some income instead of letting those assets sit idle. So I'm going to give you a little bit of an example here. Let's say you use one of the many interface applications for the Protocol.
00:04:43.890 - 00:05:23.860, Speaker A: You can supply assets to compound. When a supplier supplies, they get a fixed amount of C tokens, which you can think about as a one to one asset that is representing the underlying that you have in the Protocol. In V Three, C tokens are only minted for the supplying the base asset. They're not minted when you supply collateral. They're one one and they rebase. So when you supply, you have this balance of C tokens in your wallet and that balance will go up over time automatically. And you can redeem those C tokens for your underlying asset at any time.
00:05:23.860 - 00:05:58.586, Speaker A: I'll give more differences between compound V Two and V Three in a later slide. Those assets are stored in smart contracts that no individual controls. There's an onchain government system that will be covered later. C tokens are redeemable at any time. Users can supply for as little as one EVM block and interest accrues every EVM block, which is about 12 seconds nowadays on Ethereum. This enables on demand supplying and redeeming from the Protocol. No need to wait for a lockup period.
00:05:58.586 - 00:06:42.344, Speaker A: You can earn interest for supplying to the Protocol for even just 1 minute. The other big use case is over collateralized borrowing of assets. So user can supply a collateral asset before they borrow. They can only borrow up to a certain amount of USD value of their collateral. So the token value of their collateral is always worth more than their total borrow value relative to USD. So an example would be to supply a collateral like wrapped bitcoin or wrapped ether or one of the many others, and borrow a smaller value of Dai or USDC such that your account is over collateralized. The limit of the borrow depends on the collateral asset.
00:06:42.344 - 00:07:26.932, Speaker A: There is a percentage called the collateral factor, which is set for each individual collateral token type. Wrapped ether and wrapped bitcoin have different collateral factors. Those factors are chosen by the community members and are selected based on perceived risk of the value fluctuation. In order to borrow, a user must supply a supported collateral asset, and they can then borrow. In V Three, there is only one asset that can be borrowed from each instance of Comet. So currently there are deployments of USDC and wrapped ether as the base asset. So you can supply a collateral and borrow those two assets, or you can earn interest on those two assets, only those two assets.
00:07:26.932 - 00:08:14.840, Speaker A: So you can't earn interest on collateral in V Three, but you can earn interest on the base asset. If an account becomes under collateralized, like when the USD value of the collateral goes down or too much borrower interest accrues for that borrowing account, the user's collateral can be liquidated and a liquidator will perform a liquidation. By calling these two methods on the protocol, they can call Absorb and then buy collateral. So what happens is the user's collateral is taken over by the protocol. Their borrow is repaid by the protocol reserves, and their collateral is sold off at a discount to a liquidator that can then swap it on a Dex for a profit. So supplying only is safer than borrowing. You can't get liquidated if you only supply.
00:08:14.840 - 00:08:51.780, Speaker A: There's much less risk involved. When a user only supplies and does not borrow, liquidators keep the protocol safe and collateralized they are incentivized to do so. So borrowers that become under collateralized are subject to liquidation of their account at any time. They will lose all of their collateral, but they will get some of the base asset back after the liquidation process ends. Due to the autonomous nature of the protocol, the liquidation system is much harsher than traditional finance. There's no negotiating, there's no delinquent repayments allowed with the Onchain code. The latest version of compound is Compound Three.
00:08:51.780 - 00:09:27.024, Speaker A: It is more gas efficient and capital efficient than compound V Two. It streamlines the most popular use case of compound V Two, which was to supply a volatile priced asset like wrap bitcoin or Ether, and then to borrow a stable price asset like USDC or Dai. This version has additional safety for liquidations. It has a higher threshold for the same collateral factor. So you can borrow more with the same collateral. One asset can earn interest or be borrowed per deployment. That's called the base asset and it makes opening positions in V Three have less stacked risk than V Two.
00:09:27.024 - 00:10:09.224, Speaker A: Currently, there are seven deployments of Compound Three. There are deployments with USDC and WETH as the base asset and that is on Ethereum Mainnet and also on base. There are deployments on other chains like Polygon and Arbitrum, and there are many more to come soon this version of the protocol is able to be deployed on any EVM chain. The key differences between V Two and V Three are that V Three has less risk, less gassiness and can be deployed anywhere that solidity is supported. V Two you can borrow any supported asset, but V Three you can only borrow the one single base asset per deployment of Comet. Compound v two and V three coexist. V two is not going anywhere.
00:10:09.224 - 00:11:08.316, Speaker A: However, there is a deprecation going on by the community at the moment. You can follow along with that at the forums at www dot comp XYZ basically, what the community is doing is they're lowering the protocol rewards for V Two and also incentivizing users to move from V Two to V Three. So here are some key differences between Compound V two and Compound V three. In Compound V Two, C tokens are minted to the suppliers of any asset and C tokens are about a 50 to one ratio and the C tokens can be redeemed for more underlying as the block height increases. In Compound V Three, C tokens are only minted for supplying the base asset and those tokens are one to one and they're rebasing so that balance automatically goes up in your wallet. In Compound V Two, you can borrow any asset supported by the protocol, but in Compound V Three you can only borrow the base asset per deployment of Comet. And currently there are only two base asset deployments.
00:11:08.316 - 00:11:44.028, Speaker A: USDC and wrapped ether. Compound V Two was a single system with many assets. It's only running on Ethereum main net, and Compound Three is a single asset focus per deployment and it's running on several L two s as well as Ethereum Main net. Compound V Two is a single protocol deployment on Ethereum, and Compound Three can be deployed on any EVM chain. In Compound V Two, max borrowing and liquidation are at the same point. So if you borrow the maximum amount allowed by your collateral, you'll get liquidated in the next block. In Compound Three there's a separate max borrow and liquidation point.
00:11:44.028 - 00:12:19.030, Speaker A: So there's a no new borrows period, which makes it safer for borrowers to borrow the maximum amount and they won't always be liquidated immediately. In Compound V Two, you can earn interest on any supported asset, but in Compound V Three, you can only earn interest on one asset per deployment. And that's the base asset. In Compound V Two there are some assets that are not valid collateral. They can't be used as collateral to borrow other assets. And in Compound Three there is no interest for suppliers of collateral. Collateral is only used as collateral in Compound Three.
00:12:19.030 - 00:12:57.190, Speaker A: So in Compound V Two there's an integrated comp distribution into the comptroller contract. In Compound Three there's an encapsulated rewards contract that can be used with any ERC 20 token. It's outside of the protocol and is a little bit meter from a developer's point of view. Compound V Two has one account controller and that's the one controller of that account. In Compound V three. There's Account Manager. So you can approve a different manager for your address or you can revoke those permissions later, and those permissions allow an account to transfer or borrow or withdraw on behalf of that account.
00:12:57.190 - 00:13:51.936, Speaker A: Compound protocol is decentralized and it's governed by the comp token holders. The comp token is an ERC 20 token that can be used to propose on chain protocol upgrades or to vote yes or no on those proposals and the community can make those proposals. The contracts for governance are in the Compound Finance GitHub organization under the Compound Protocol repository. You can check them out there. There's a governor contract as well as a comp token contract. The comp token is the voting and proposing token that allows Onchain governance to function for the compound protocol. The protocol has been decentralized since June of 2020 and the comp tokens have been distributed to users of the protocol at a slow drip.
00:13:51.936 - 00:14:46.164, Speaker A: And those users can take those tokens and vote on proposals, or they can create their own on chain code proposals to upgrade protocol code or protocol asset configuration settings. And with this token, you can delegate your voting weight to your own address, or you can delegate that voting weight to another address. So say there's a delegate that has more knowledge than you of the protocol. Many addresses can delegate to that one if they trust them to vote on their behalf. Or you can always vote on your own behalf if you delegate to your own address. The governance process is a seven day process for ethereum, and it's an eight day process for all L two S. So what happens is a community member will make a proposal, and there's a two day review period where all of the other community members can check out that proposal, make sure it does exactly what it says it does.
00:14:46.164 - 00:15:51.880, Speaker A: There are no bugs, there are no issues, and also the consequences of that proposal succeeding. For apps that depend on the protocol or other protocols that use the compound protocol as infrastructure, after two days of review, there is a voting period where anybody with comp tokens delegated to their address can cast their vote on the proposal, whether they can vote in favor or against the proposal. After the three day voting period, the proposal either succeeds or is defeated, needs to reach quorum of 400,000 votes in order to proceed. After a proposal succeeds, it is in the time lock for two days where it is queued and then executed. And after it's executed, there's an additional day and execution for all L2 s. So what happens is the time lock will pass the message to the bridge for the L two, and then there'll be an additional one day time lock on the L2 before it's executed on the L two. So those are only for proposals that affect the Comet deployments on other chains than Ethereum.
00:15:51.880 - 00:16:43.800, Speaker A: The timelock phase is only two days on Ethereum. So if you're a developer, you can head over to Docs Compound Finance to find smart contract method documentation. You can find contract addresses as well as SDK documentation, explanations for how each of the contracts work, and links to guides and security audits. If you have a technical question or just want to join the community conversation, you can go to Compound Finance Slash Discord and join the discord. If you want to apply for a grant to work on something in the compound ecosystem, you can go to Questbook App. If you want to see code examples for building on top of compound, you can go to the Compound Developers GitHub Organization. Or if you want to see the Compound Protocol smart contract code, you can head over to the Compound Finance Organization on GitHub.
00:16:43.800 - 00:17:10.784, Speaker A: Here's the workshop we're going to be working on today. You can head over to GitHub and check out this repository. You can always clone it. It's open source, and you can use this QR code with your phone if you want to check it out on your phone. Compound Grants is an independently led organization that funds projects that are working on the protocol. You can head over to Questbook App if you want to apply for that program. They have rolling applications.
00:17:10.784 - 00:17:46.616, Speaker A: They have funded many builders in the ecosystem and got them going. Building on compound. If you have more questions about that, you can come over to us during the hackathon and ask us, and we're happy to help and connect you with the right people to get your project approved for a grant. If you're not sure what you want to build in this hackathon, we have an Ideas blog post. You can head over to this link. If you want to check out that Ideas post, we have several ideas that can help you win this year's Hackathon Bounty for Ethg Global New York. And you can also see links to previous year's winners of Hackathon Prizes in the ETH Global Hackathons.
00:17:46.616 - 00:18:25.550, Speaker A: So please check out this blog post. All right, that concludes my slide deck. For this presentation, I'm going to go through a developer workshop now where I show how to build an app that has account health for each instance of Comet and shown in a dashboard. It's going to go over some solidity code as well as front end web code for getting that data from the blockchain. All right, here's the repository for this workshop. If you want to clone this code or check it out, you can always come over to this repository. I have the link in the description as well as the QR code during the presentation, so you can rewind to find that as well.
00:18:25.550 - 00:19:04.328, Speaker A: So basically what we have here is a full stack web application that queries each blockchain that compound exists on and gets all of the account data on those blockchains. And it decides whether or not those accounts are healthy. These are just accounts that borrow assets. So if you borrow again, you can get liquidated if your collateral doesn't support your open borrow. And accounts that get to that liquidation threshold are considered unhealthy. And this dashboard will show the most unhealthy accounts and also will show the ones that could be liquidated. So this is a node JS application.
00:19:04.328 - 00:19:34.800, Speaker A: It uses express. JS for a server. We're going to query blockchains from that server script, and we're also going to host an API from there. And our front end web application will be hosted from the exprs app as well. And it'll use it as an API to fetch that data and show it in a browser page. So in order to run this application, you need to install node JS, and you need to install each of the dependencies. You do that with the NPM install command.
00:19:34.800 - 00:20:12.972, Speaker A: In addition to that, you need JSON RPC provider URLs. You can find each of those four on Alchemy.com. If you don't have them already, you can get them for free. And basically what that does is it allows our app to use the Alchemy API like it was a Rest API, and it fetches data from the blockchain that is up to date. So this is what the finished product of our app looks like. It's a simple web dashboard. It has this selector so we can choose each instance of compound three that we want to look at the borrowers for.
00:20:12.972 - 00:20:53.768, Speaker A: And it has this table here that shows each account in order of its unhealthiness. Accounts that are in red are actually liquidatable right now. If you wanted to, you could liquidate these accounts on compound, and the ones that are not in red are close underwater, but they are still considered healthy from the protocol's point of view. So if you want to see the latest data, you can always refresh this page and we'll get data that is more recent from the blockchain. And if you want to see a different instance of compound three, you could see that on cusdcv three. On Polygon, there are three accounts that can be liquidated right now. So before we begin, I encourage you to go over to Docs Compound Finance.
00:20:53.768 - 00:21:30.824, Speaker A: This is where all of the documentation for the protocol exists. You can find each of the deployments of Compound Three here and their contract addresses. You can also find developer resources. There are guides for building on top of the protocol, as well as a list of security audits and smart contract method documentation. You could use the search bar at the top to search for any subject that you need in the docs. All right, I'm going to run through building this application now. If you want to build something on top of this, you can clone this code here.
00:21:30.824 - 00:22:01.360, Speaker A: You can go to GitHub and then clone the repository to your machine. There's instructions for doing that here. I've already done it. So I have the app on my local machine here and I'm going to open up the source code in Sublime. So the first thing we're going to go through is the server script. It's called index JS. And in order to run this app, we have to run this server script.
00:22:01.360 - 00:22:37.100, Speaker A: Uses Ethers to get data from the blockchains. Uses Exprs to serve the HTML, CSS and JavaScript, as well as our API, which serves some JSON. Data. Helmet is just like a safety package in Express. Sleuth is a new way of querying data on blockchains in a more efficient and fast manner. I'll explain what Sleuth queries I'm using later and how it works. We're doing a query for account data.
00:22:37.100 - 00:23:15.636, Speaker A: So these are for getting each of our borrowers on the instances of Compound Three. I'll show that query later. It's written in solidity. And we have our port we're running on our machine. It's going to be a localhost port, 3000. And this JavaScript object called DB is sort of like our local in memory database where we're storing all of our borrower data after we get it from the blockchain. So this app is going to automatically get the latest borrower data from the blockchain every hour, unless somebody is using our application and hitting the rest endpoints.
00:23:15.636 - 00:23:50.644, Speaker A: If they hit the rest endpoints, then it'll update itself automatically. I have a setting for each of the instances of Compound Three in this object. So every 90 seconds at maximum, the data will be updated for each instance. The proxy address is actually the Comet address. So this is where the protocol is located. On each blockchain we have a provider URL, which is a JSONRPC URL provided by Alchemy.com. You can head over to Alchemy.com
00:23:50.644 - 00:24:25.170, Speaker A: and get yours for free today for each of the blockchains used in this workshop. So for this workshop, there's ethereum, polygon, Arbitrum and base. So we have some data pertaining to each deployment of Compound Three. I got this data from the documentation page that we saw earlier. I have it here inside my app so I can quickly get data from the blockchain. So each of these keys here represents a Compound Three instance. There are currently seven.
00:24:25.170 - 00:25:09.814, Speaker A: So the base asset is the asset here. And I have underscore the blockchain that it's using. So ETH is ethereum, pol is polygon, ARB is arbitram, and base is base. So here's our abi for using Compound Three, also called Comet, as well as ERC 20 Ebi for getting some basic ERC 20 token data. I have a helper function here for updating the console. So as the developer you can watch your console running and see exactly what our script is doing. It has some line at the bottom that updates and gives a little message that says what we're doing at the moment.
00:25:09.814 - 00:26:17.260, Speaker A: So this is a little helper function. To facilitate that display, we have the Sync instance function. What this function does is it fetches data from the blockchain so we pass an instance ID, which is the ID you saw in these objects earlier at the top. So there's one for each instance of comment. When we pass that to Sync instance, we update all of the data in our local database that we have in memory and we make sure that we don't query the blockchain more than once every 90 seconds. So if people were to be making lots of requests to our app, we wouldn't be running out our JSON RPC API key. We would make sure that we stay safe and only make a certain amount of requests each month to keep our usage low, to keep our bills low.
00:26:17.260 - 00:27:03.350, Speaker A: So we're doing something called debouncing, which is essentially keeping the amount of requests that we make to our JSON RPC API low. And we're going to save the timestamp every time we do make a request. So basically, we pull a bunch of asset data from the blockchain so each of the collateral assets as well as the base instance. So our database has that data ready to go when we need to serve it to our users later. And the two most important parts here are getting price data as well as borrower data. So when we get price data from the chain, we're talking about the prices of the collateral assets. We can use that price data to make sure that borrowers are not underwater.
00:27:03.350 - 00:27:55.380, Speaker A: So to do that, we're going to go through each instance of Compound Three. We have an update here that shows the developer on the console log line what the script is doing. So basically, we're going to query the comment contract. We're going to get all of the available collateral assets and we're going to find out their price using the Get price method and we're going to update that in our database. So it's going to do this for each collateral asset in that instance of Comet. Then we're going to pull the borrower data from the blockchain so this will get all of the current borrowers from the Comet instance. This is where the majority of the code in this file is from.
00:27:55.380 - 00:28:54.380, Speaker A: So we're going to get that for each instance of Compound Three and we're going to do that for the latest blocks in which we have not already got data from. So we got our update console log line here to say what's going on. We're going to get our instance data we have from our JavaScript object at the top of the file nicely is this. With Sleuth, we have a way to look up each instance of compound using the asset address, which we'll use later. We're going to get a JSON RPC provider using the ethers SDK. We're going to find out what the latest block height is on the blockchain that we're querying, and we're going to get every withdrawal event from Compound Three. So in order to borrow on Compound Three, you need to withdraw from the protocol.
00:28:54.380 - 00:29:56.698, Speaker A: And whenever you withdraw, there's an event emitted called withdraw. If we get all the historical events of borrowing on the blockchain, then we can find out who specifically is borrowing at this time. So this gets all of the borrow events from the beginning of the blockchain's history. So it gets it from block height zero all the way to the present block height. And subsequently we're not going to re query specific blocks, we're just going to query the most recent blocks for which we don't have data. So if we're going to query this at the beginning, we're going to get from zero and then every few minutes or so how often our app updates based on the requests made to it, we'll get the latest block data and we'll get any withdrawal events that have occurred since the last update. Okay, once we have all the withdrawal events, we can find out who's a borrower.
00:29:56.698 - 00:31:00.888, Speaker A: So when we get the withdrawal events, we get all of the accounts that are maybe borrowing, and then we can check later to see if they're actually borrowing. So we have all the previous borrowers in our database from when we saved them last. And then we're going to get all the new accounts that we got from the blockchain just recently. This is where we make our Sleuth query to get data from the blockchain in a much faster and more efficient way than if we were to query them using JSON RPC from this script. So to get data from all accounts, we're going to use Sleuth. Sleuth is a JavaScript package that you can find here. So if you want to check out Sleuth, you can check out how it works here in some examples.
00:31:00.888 - 00:31:37.030, Speaker A: In the README of the repository for Sleuth, I'm going to run through my Sleuth query here. So here's how we declare it. We need to reference the bytecode from a smart contract that we compile. So here we reference our Sleuth query. And what we're going to do is we're going to pass 1000, maybe borrower addresses at a time to the Sleuth query and make a single JSON RPC call instead of making several for each individual address. So this will greatly minimize the amount of JSON RPC. Calls that we need to make.
00:31:37.030 - 00:32:04.780, Speaker A: And I'm going to take a look at that Sleuth query by going over to my Contracts folder in the Sleuth queries folder. Here's my account data query. So it just looks like a regular smart contract. I have references to a library that I call Comet structs. These are structs that are on the Comet contract. Here's an interface for Comet. These are all of the methods that I'm going to want to call on the Comet contract.
00:32:04.780 - 00:32:38.920, Speaker A: And then here's a struct that I made up specifically for this query. This has account data for each account on Comet. And I'll return an instance of the struct for every single address that I'm querying using Sleuth. Here's my actual sleuth query. It looks like a smart contract with a function called Query. I'm going to pass the Comet address and all of the accounts 1000 at a time in which I'm going to get data from the Comet smart contract. And I'm going to return an array of account data structs.
00:32:38.920 - 00:33:12.020, Speaker A: So the first thing I'm going to do is find out how many collateral assets there are in Comet so I can use a loop. I'm going to make an array of account data structs. So there's going to be one struct for each account that we pass to the query. I'm going to loop through every single account that I pass. I'm going to find out if that account is currently liquidatable. I'm going to find the borrow balance of this account. If it's greater than zero, then that account is currently borrowing.
00:33:12.020 - 00:34:24.660, Speaker A: I'm going to make an array for every collateral asset as well as the balance of those collaterals and we're going to return that to the API. So then we can show the health level of each account. So if the collateral value is not high enough to support the open borrow, they'll have an account health of over 100% and they'll progressively get closer to that as their collateral is not high enough to support their open borrow. So I'm going to loop through each collateral asset. I'm going to get the info for that asset and I'm going to get the collateral balance for each specific account for each specific collateral that's supported by that instance of Comet. I'm going to make an account data struct and I'm going to add that to my array and eventually I'm going to return my account data array. So this function uses Sleuth to get lots of data for many accounts by doing very few JSON RPC calls and taking advantage of the Sleuth query interface.
00:34:24.660 - 00:35:38.060, Speaker A: So now that we have the data for each and every account, we can find out which one is borrowing. So we're going to loop through each of those accounts that we query data for and we're going to find out if they are borrowing, which collaterals they're using, and we're going to turn those integers into doubles so we can read them in our app a little bit easier. And we're going to show if they're liquidatable, which will be able to make them red in our app, or black if they're not liquidatable. So after we've gotten the data for each borrower, we save the block in which we've queried data up until so later we can make sure that we don't re query the same blocks. And then we set our database to our latest borrowers that we found from the blockchain. After we've pulled all the borrower data from the blockchain, we're going to calculate their account health. So we're going to find out that percentage that we saw in the app earlier.
00:35:38.060 - 00:36:33.084, Speaker A: So to calculate their account health, we get each and every borrower we get each and every borrower from our database and we find out their collaterals. We go through each collateral and use the collateral factor as well as the liquidation factor to find out how close they are to liquidation. We set a number for their borrow limit, their liquidation limit, as well as a percentage to liquidation, which we show in the app. We're not using this in this app. This code was reused from an older workshop where I showed the liquidation price if the account has one specific collateral. So we can know what the price of that collateral would be when this account would likely get liquidated. It doesn't really work when you have multiple collaterals because which price would have to go down, we're not sure.
00:36:33.084 - 00:37:10.350, Speaker A: So it only works with one. And when we stick with the data from the blockchain, we're going to do this in an interval. We're going to do it every hour, so if nobody is querying our app, it'll still update the data once every hour as long as the app is running. So we have our main function here at the bottom. This will run as soon as the app boots up. We'll sync the data with the blockchain, basically get all the data that we just showed and put it in our in memory database that we have in our app. We're going to create an Exprs application.
00:37:10.350 - 00:38:04.170, Speaker A: Here's some housekeeping stuff with Exprs. This makes post bodies for requests only acceptable if they're a certain size up to 100 bytes. Helmet has some security features for Exprs apps in this instance where it's just, for example, this isn't really important, but this is something you'd want to put in a production app, as well as this header information here. We're going to allow the app to get files from a specific directory so we have a public directory with our HTML, CSS and JavaScript. This will allow the Exprs app to serve those assets. Here's our single API request route. You can use this API to get the borrowers from the blockchain.
00:38:04.170 - 00:38:41.960, Speaker A: You can use this route to get the borrowers from our app, which got them from the blockchain. Each of these instance IDs corresponds to the instances of Comet here. Whenever a user makes a request to our app, we're going to try and get that data from the database. We'll return a bad request. If we don't recognize the ID that they pass, we're going to sync with the blockchains. This, of course, only works if the last request was made more than 90 seconds ago. Otherwise it will not make any requests to our JSON RPC API key.
00:38:41.960 - 00:39:28.450, Speaker A: And here we're going to sort the data by percent to liquidation in descending order so we can see the most unhealthy counts, so we can see the most unhealthy accounts at the top. And then we're going to return that JSON data. If anyone puts in a bad API route, we'll give them a bad request. And this runs the server on our port, which will be port 3000, and gives the developer a message in the console so they can see that the app is running and localhost port 3000. That's this whole app. I'm going to run over to my console and I'm going to do NPX hard hat compile. This will compile the Sleuth query.
00:39:28.450 - 00:40:00.480, Speaker A: It's already compiled, so there's nothing to compile. And then I can do node index JS to run the server script. But I'm actually going to do NPM Start, which does both of these commands for me. So our app boots up and it gets the data from each blockchain and each instance of Comet. It gets it from block height zero to present. So this takes a little while for each app to run for each instance to get its data. After we've got all the data, we can then display it in our app.
00:40:00.480 - 00:40:33.290, Speaker A: It already got data for the ethereum instances, so we should be able to see those in our app. There's the latest data. We have the date and time of the latest accounts. Here's each of our accounts. There's still several that can be liquidated right now. So next I'm going to walk through this front end code here. So you can build your own app like this, or you can even add to this app.
00:40:33.290 - 00:41:38.690, Speaker A: I challenge you to make a button so you can liquidate any of these accounts with a single click and run that transaction from your MetaMask. You can do that if you piece together multiple workshops. There's a workshop on the Comp XYZ forums for liquidating accounts. So what you can do is you can use the on chain liquidator smart contract and you can call that contract using an EOA and it'll liquidate an account. So if you head over to www dot comp XYZ, you click on Guides, you can find the Compound Three liquidation guide and learn how to run your own liquidator on compound. You can use the Onchain liquidator contract and call it from an EOA to liquidate any address on Compound Three. So I challenge you to make it so you can click on any of these and a transaction will pop up with your MetaMask and you can liquidate any of these accounts.
00:41:38.690 - 00:42:19.058, Speaker A: That project would be eligible for the bounty prize in this hackathon. Okay, onto the front end code. So our front end code is in our public folder and start off with index HTML. So what we see in that web page is some basic HTML. We have a reference to a CSS file which I'm not going to go through. We have our account health dashboard header. We have a select box with each instance of compound three.
00:42:19.058 - 00:42:58.470, Speaker A: Each of the values corresponds to the keys in our server script file that we saw earlier. One for each instance of compound three. We show the date that the data was last fetched from the blockchain, so we know if it's stale or not as a user. Then we have a table here where we display each of those rows of data. One for each account. And we have a JavaScript file that powers that page and interacts with our API. So I'm going to head over to the JavaScript file.
00:42:58.470 - 00:44:00.574, Speaker A: We have a function that runs when the web browser page finishes loading. We refer to the three HTML elements we saw earlier. Whenever we use that select box, we're going to render the page with all of the data in the table based on the instance we selected in the select box. This render function makes a query to the API using the selected instance. Before it does that, it shows like a loading shimmer, which we don't really see because the data is returned so fast. But if we were to set up this API on a server, there might be a delay where a user would like to see a loading screen so that we have a loading shimmer effect. After we get the data from the API, we show when that data comes from.
00:44:00.574 - 00:44:58.354, Speaker A: So we have a parameter in that JavaScript object that shows the timestamp of the data. So that's this timestamp here we can show that as a JavaScript date time using the date object. We only show the top 100 borrowers in our interface because if we were to show all the borrowers, it might be a bad user experience on the web page. So we're just showing the top 100 and we create a nice big HTML string for each of those rows. So each of those rows has its own HTML element. And we put the data for each borrower in an HTML div. So we have one for the address.
00:44:58.354 - 00:45:33.710, Speaker A: We have the borrow size. We have a list of symbols of the collateral assets that the account is currently using separated by a comma. And then we have the percentage of percent to underwater. So basically if they hit 100%, that means that they are liquidatable. The account is underwater and is violating the collateral requirements of the compound protocol. Any searcher can liquidate their position on chain at any moment. Sometimes we'll see positions like these that are not profitable for a liquidator.
00:45:33.710 - 00:46:14.770, Speaker A: They would probably waste more money in gas than they would get from a liquidation. So that's why this one remains open for USDC. Some of these are a bit bigger though. Might be worth the gas. Might not be. After we've filled up our table HTML string with all of the rows of accounts, we put it into that table content element that's here. So we update that with a new HTML string and the browser will show all of that nice rendered data.
00:46:14.770 - 00:47:05.946, Speaker A: When this web page first loads, it's going to load the data for the very first element in the select box. So for us, that's cUSDC v three on Ethereum main net. So when we load the page, it automatically renders for that instance of Comet. Down here we have some HTML strings, we have the shimmer for the loading screen that I mentioned earlier. And we also have the header row HTML, which we see here, which explains what each row is in the table. So we paste that over and over again each time the user interface reloads. That's it.
00:47:05.946 - 00:47:53.370, Speaker A: That's all of the JavaScript code for the front end. This is a very simple app. You can get this app running on your own if you clone the repository and walk through each of the steps I had in this workshop. Remember, you can always check out the README here we have instructions for running as well as setting up and a link to each of the dependencies. If you want to learn more about each of the dependencies this project uses, remember, you can always find me at the hackathon. I'll be walking around the floor and you can message me in discord. I'm happy to come over and help you out with your code, or to explain to you how the Compound Grants application process works, or to validate your project idea for the Compound Grants bounty in the ETH Global New York 2023 hackathon.
00:47:53.370 - 00:48:22.080, Speaker A: On behalf of Compound Grants, thank you for watching and best of luck to you in the hackathon. We're excited to see what you build and happy to help you out in getting a grant in Compound Grants. Remember, you can always apply at Questbook. There's a rolling application for Grants going on. Come find us at the event if you want a compound t shirt or a compound sticker. Best of luck to the hackathon participants. Happy hacking and see you soon.
