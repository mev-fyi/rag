00:00:01.210 - 00:01:11.822, Speaker A: Ava Labs is the part of the company that actually contributed to the development of the AVE protocol, and more recently on the design and development of Go, which is the Ave native stablecoin. So this particular workshop is going to focused on the Go smart contracts. To be fair, Go smart contracts are relatively simple. There's nothing particularly complicated there, so it should not take a particularly long amount of time. What I wanted to focus also a little bit, is the idea behind Go, because it can also be useful for people participating in the hackathon. Like to, I don't know, get some interesting advices or suggestions on what to develop for the hackathon. And once that topic is clear, I will start diving a little bit in the go smart contracts and how we integrated go within the average protocol.
00:01:11.822 - 00:01:58.522, Speaker A: So let's start from the beginning. So as I mentioned before, Go is the native stablecoin of the Ave protocol and of the Ave governance. It's pronounced Go. So the h is muted. We wanted to propose to the Ave governor to introduce another native stablecoin. For a variety of reasons, native stablecoins have much higher capital efficiency. So with the Ave protocol, there is the inherent complexity of having the need for suppliers to step in to provide liquidity, and therefore to satisfy the borrower's demand.
00:01:58.522 - 00:03:50.920, Speaker A: And this is something that is immediately circumvented, immediately be satisfied with the possibility of using a native stablecoin. The complexity there, which is a completely different topic, is actually being able to scale such stablecoin, especially when a new stablecoin is launched. Like behind the possibility and the capability of scaling a stable coin, there is always the need for creating use cases for the stablecoin, which actually incentivize people to use it and to hold it. So I always say that the first true use case for a stable coin immediately after it's launched, is the capability to swap such stablecoin for other stablecoins. So at the beginning, when the stablecoin will not be widely available on different venues, like decentralized exchanges, centralized exchanges, off ramps, and when you generate a new stable coin right off the bat, created stablecoin, those capabilities, like that other more mature stablecoins enjoy, like again, of ramps and trading pairs are not available, right? So what users typically do is they mint the stablecoin through the meanings of borrowing on the other protocol. For example, to actually be able to use the stablecoin to achieve their own goals. So, I don't know, trade on other venues, rather than leveraging a certain position.
00:03:50.920 - 00:05:25.054, Speaker A: And usually what happens is that to be able to trade with convenient fees and convenient slippage, they usually swap to other stable coins in order to be able to access the wider market that these stable coins usually have. So for example, USDC, what happens is that many people actually swapped their debt from USDC to go, because go was cheaper to generate and other people actually borrowed and immediately swapped go to other stablecoin to trade on other avenues, for example. So that's usually the first use case that you can create for a stable coin. And to do so sustainably, it require quite a lot of work on secondary market to structure the liquidity in a way that is able to absorb the sell pressure of users generating such stablecoin. So when we thought of creating go, we also started thinking about possible use cases, possible different ways of scaling such stable coins. And actually, those thoughts actually kind of shaped the architecture of go itself, which is what we are going to explore right now. So, I don't know if you guys can see here, let me.
00:05:25.054 - 00:06:21.122, Speaker A: Oh no, I don't want to do this. Why did they do this? Let me see if I can rotate. Yeah. Okay, so if you can see this diagram. This diagram highlights the architecture of Go. So the architecture is quite different from other stablecoins that are decentralized stablecoins that are available in the market. The idea behind go is actually not to strictly correlate the stablecoin, one way of generating it, which could be, for example, over collateralized borrowing, but actually make that as much flexible as it can be by giving the token itself and the governance the capability to allocate the creation of such stable coin to different entities.
00:06:21.122 - 00:07:24.058, Speaker A: Okay, so what happens in Go is that we introduced this concept that is called facilitators. So different entities, different protocols can have allowance to actually mint go to a certain amount that we call bucket capacity. And when such capacity is reached, those entities will not have the possibility to mint further until the governance, the other governance, decides otherwise. So the goal here is to have the other governance in control on which entities are allowed to generate Go and in what size. That is the idea. When Go was launched, when Go was released and activated by the Ave governance, the first of this kind, the first facilitator, was actually the AvA protocol. So the AVA protocol is at the moment the first and only place where it's possible to generate go.
00:07:24.058 - 00:08:44.930, Speaker A: But there will be other ways in the future which might be future versions of AVe, might be other protocols completely different from the AvE protocol, and might be, as you can see here in the diagram, RWA based system. So where you have tokenized RWA backing the stablecoin as collateral. You can have protocols that actually generate a stablecoin using as collateral delta neutral positions. You can have part of the stable coins backed by different centralized entities. So other centralized entities could generate parts of the go to maybe for example, help sustaining the peg against the real world assets and so on and so forth. So the architecture of Go itself is very simple, but I believe very powerful because it gives the Ave governance all the flexibility in the world to actually be able to manage and to scale the stablecoin as more and more use case appear in the future. So as I mentioned here, as it's mentioned here in the tech paper, the first facilitator is the average protocol.
00:08:44.930 - 00:09:53.862, Speaker A: What's interesting is that the average protocol was not originally designed to be able to generate a stable coin which can be basically assimilated to a synthetic asset. So the average protocol doesn't natively have the ability to generate anything that is not actually previously supplied by liquidity providers. So we had to kind of work around certain limitations to be able to support Go within the Abbe protocol. I will show these kind of limitations later when we look at the code. So because the go stablecoin is generated on the fly, there is no supply side on the other protocol. So it's not possible to supply go to the other protocol. It might be possible to supply go to other markets where go is not generated natively.
00:09:53.862 - 00:11:36.058, Speaker A: So example, we at avalabs are currently working on possible implementation of cross chain go, which will use CCIP from Chainlink, and this will allow the Ave governance to bring Go across a variety of networks, all the networks where Ave is deployed and CCIP is supported. And by doing this, it will be entirely possible to actually list go as a normal asset on other markets, for example on polygon or avalanche or arbitrum, with an expected supply side for liquidity providers. So liquidity providers could, for example, borrow from the native market where Go can be minted on Ethereum, move the go so minted to polygon, and supply polygon to arbitrage interest rates, for example. That's going to be entirely possible. And it's also going to be entirely possible to have other facilitators that actually mint natively on other networks. So this kind of architecture already gives this flexibility where the Ave governance can really decide whether or not the go can natively be generated on what ave market, or actually just listed as a normal asset, where it can be supplied by liquidity providers, the borrowing. What's important is that the contracts that we are going to explore shortly are the contracts that allow native minting of Go.
00:11:36.058 - 00:12:49.330, Speaker A: So those are the contracts that are actually being used on the v three Ethereum market to generate go natively. And the borrow. Again, in markets where go is listed natively, where it can be minted natively is the borrow action that actually generates the go and transfers the go directly to the borrowers against a certain collateral, while in markets where it will be listed as a normal asset, for example, another market on polygon, those will follow exactly the same dynamics as any other asset or any other stable coin where users borrow from liquidity providers and pay interest to liquidity providers. That's pretty much it. This diagram kind of explains very simply how the borrow process happens. So every time someone borrows on the other protocol, v three on ethereum, there is a check that validates if the bucket size is reached. If the bucket size is reached, it will not be possible to mint any other goal.
00:12:49.330 - 00:14:29.570, Speaker A: If it's not reached, it will mint the asset and update the facilitator bucket level to keep track of the additional amount that has been generated through this particular facilitator. One interesting aspect of the native integration of Go on the Avitri market is that which is also one of the mechanisms that guarantee that go can always be generated and redeemed at one dollars is that the price on markets where go is natively generated is always one dollars. So the oracle that actually provides the price for Go always has a price for Go of one dollars, no matter what the price of the stablecoin is on the market. This basically allows on the long term to maintain the peg of the stable coin, even though there can be oscillation over the short term. Because whenever the asset is below peg, there is an incentive for people to actually buy back the token and repay their debit at a profit or for position to be liquidated for a further profit. And when the asset is above peg, there is incentive for borrowers to mint more go and to arbitrage the opportunity that is available in the market. So this is also another interesting aspect of the integration, the native integration with the other protocol of the Go token.
00:14:29.570 - 00:16:19.142, Speaker A: The interest rates of Go are also decided by the governance, even though we are currently developing a kind of novel mechanism for dynamic borrow rates for Go, which hopefully should also help maintaining the stability I just had. On Friday, I did a talk on the topics which explains basically the strategy that we are using that we will be using for managing the go interest rates rather than being governance controlled. Another interesting aspect of the AVE Go integration is that for those of you who don't know, the AVE protocol has one component of the AVE protocol is called the safety module. The safety module is supposed to be kind of an insurance fund for the ABBA protocol. So if there are large insolvencies because of market oscillation, which could leave bad debt, or because of, I don't know, technical issue that might bring bad debt to the protocol, then the safety module can basically be used with the assets that are provided being sold on the market and used to repay the bad debt. Until now, the safety module has not been used because the AVE protocol thankfully has not incurred in any meaningful debt, meaningful insolvency since the inception. But the mechanism is there.
00:16:19.142 - 00:17:28.714, Speaker A: So part of the integration of Go with the AVE protocol is that it allows participants of the safety module to actually borrow go at a discounted rate compared to the nominal rate where other users borrow. So the way it works is actually there is a threshold for each ave of Go that you can mint a discount. So I don't remember the current configuration. Honestly, I think it's 100 go per every AvE supplied to the safety module, something like that. So to calculate the discount, there is a threshold that depends on how many ave that were supplied to the safety module, and also a discount rate that actually provides the amount discounted compared to the nominal rate the normal users that are not providing to the safety module are paying. So here are the formulas to follow the calculation. Those are very simple.
00:17:28.714 - 00:18:22.718, Speaker A: This is actually just a weighted average. I will link later the URL of the tech paper and here is the definition like there are a few examples of how the interest rate considered a discount is calculated here. There are bit of formal definition of the discount. I will not go through this because take a bit of time, but they are very simple, so it's pretty easy to understand price. Oracle kind of describes what I already said before, which means that the one go is always fixed at one dollars within the other protocol. So I think we are already quite far away in the workshop, so I will go quickly through the code. I would go first, explain a little bit.
00:18:22.718 - 00:19:30.846, Speaker A: You guys can see the code right on the screen? Yes, perfect. So I will describe the code quickly starting from the go token contract, which is honestly very simple. It's just an ERC 20 token with a few interesting things. As I mentioned before, there are the facilitators. So here, this mapping here tracks the facilitators that they have a governance list within the go facilitators. Those are also kept as a list to give the possibility to query on chain. We can see here there are the mint and barn function, which are only accessible if a certain asset is a facilitator.
00:19:30.846 - 00:20:22.260, Speaker A: So like any facilitator that is not listed by the other governance, that is not activated as a bucket size of zero. So if someone tries to mint the go token and its bucket size is zero, the minting will not be allowed. So it will revert here with this particular error. Otherwise the minting will be allowed. Otherwise, if the address has an allowance, has a bucket site, and the bucket level is not crossing the bucket sites, then the minting is allowed. And there is a very normal minting process with an additional event that basically tracks the updated level of the bucket sites of the facilitator. Barning is exactly the same thing.
00:20:22.260 - 00:21:36.886, Speaker A: It checks like what's the bucket level? It subtracts the amount that is being burned to the bucket level and then emits exactly the same event as before the add facilitator. This is a permissioned function in the sense that there is a specific role that needs to be satisfied to be called this function, which is the facilitator manager in this case. In our case, the facilitator manager is the avocovance. So only the average governance can call this function here. And what this function does is very simply just get the structure of the storage related to the particular address, update the capacity and setting the label for the facilitator, add it to the list to be able to track and emit an event. Very simple remove does just the opposite action of removing and setting the values to zero, removing from the list and then set the bucket capacity it will set here. It checks if the facilitator exists by validating the label.
00:21:36.886 - 00:22:47.694, Speaker A: So if the facilitator has a label, then the facilitator exists and it just sets the bucket capacity to the amount that is passed through as a parameter, and then a few getters to just get access the data that I just mentioned above. So that's pretty much it. The rest is completely standard ERC 20 implementation. It has like a permit, it supports permit for gasless approvals and I would say that that covers pretty much everything there is to cover about the go token. I will go quickly through the implementation within the AvE protocol then in my opinion it's more interesting. So for those who don't know, the AvE protocol v three tokenizes the positions of the liquidity providers. So whenever you supply an asset to the average protocol, you get a token in exchange.
00:22:47.694 - 00:23:44.866, Speaker A: That is basically a representation of your deposit. We call these tokens a tokens, and the same happens with the debt. So if you take out certain token as a debt using your collateral, you will receive that debt and you will also receive another token that basically tracks your debt balance. The debt token specifically is not transferable because otherwise you would be able to transfer your debt to someone else. And in the particular case of debt, tokens is mainly used only for accounting. So it doesn't have any other function, it's just the protocol, using it internally to account for the debt. The interesting thing about eight tokens is that they increase in balance over time.
00:23:44.866 - 00:24:42.450, Speaker A: So depending on the interest that is being paid. So if you supply today, 1000, I don't know, USDC, and throughout the year you have an interest rate on 10%. After a year you will have 1100 USDC. Actually a little bit more because it's compounded, but that's pretty much how it works. Now for the Go implementation specifically, the interesting thing is that because there is no supply side, so we don't want people to be able to supply go to the AvA protocol. What happens is that, and we don't have an actual support for this particular capability within the ABBA protocol. What happens here is that we basically forbid people to supply by reverting the operation of minting.
00:24:42.450 - 00:25:52.586, Speaker A: So all the operations that are usually for other assets used to supply and withdraw and liquidate and et cetera, they revert because they will not allow supplying the asset in the traditional way, because the asset is generating on the borrowing side, which we are now going to see. All the rest is basically returning zero. There is one interesting thing that is the handle repayment. Because like this particular function, handle repayment is called within the Ave protocol every time someone repays debt, which is still the case within go. So if someone repays God debt, this function is still called and handle repayment. The interesting thing that this does is that it basically accounts for the balance, and it also burns the corresponding amount of Go tokens minus the interest. Because the interest is never burned.
00:25:52.586 - 00:26:47.354, Speaker A: The interest is earned by the treasury. And what happens is that the interest is accumulated within this particular token, a token contract. And then there is this function, distribute fees to treasury, which actually gets the go balance of this particular contract, which is the total interest that has been paid by Go borrowers, and transfers it to the address of the other treasury, which is tracked through this particular internal variable. The permit also reverts and all other transfer reverts, of course. And then there are a few other accessory function to update the go treasury to get the variable depth token and so on and so forth. Let's go to the variable depth token also. Another thing is that the average protocol has two depth modes.
00:26:47.354 - 00:27:25.766, Speaker A: One is stable and one in variable stable is being deprecated. So it's not possible to borrow go at a stable rate. You can only borrow at variable. The variable again is the variable rate is decided by the governance though. So it does not have the same variability that other assets have, like USDC. Those are pure variable in the sense that you can get borrow at 3% and paying, I don't know, 60% the day after because it depends on, it's strictly correlated on the supply and demand. Within the average protocol itself, this is different, this is decided by the governor.
00:27:25.766 - 00:28:36.900, Speaker A: So the interest is still variable, the interest rate, but it's way less variable because there is a governance process behind that is used to actually change the interest rates. So again, this is a variable debt token, which is what I mentioned before. This particular token, in any implementation, for any asset is not transferable because the transfer of the debt is not allowed, because otherwise you would be able to transfer your debt to someone else and keep your collateral, which is something that we don't want. There is an initialized function, this is for the proxy. There is a mapping that tracks all the state for every borrower, where the state is the amount of interest that they accumulated and the discount percentage that they get, as I mentioned before, from the SDK, from participation within the safety module. So again, these contracts is relatively simple. Minting is very simple.
00:28:36.900 - 00:29:49.062, Speaker A: It's called during the borrow function, and it means an equivalent amount of variable debt token to the user that is borrowing the barn is the same. It just burns the amount total supply. I'm not going to in these details because this would require much more time. This is the way that the average protocol calculates the debt and the supply side internally to keep track of how much every user has supplied and how much interest the user has accumulated. If you want more details about how all of these dynamics within the average protocol work, I can link later the white papers of all the three versions of the Ave protocol, where these particular calculations are explained in detail. Here we have a function that essentially sets what's the Atoken forego, which is the contract that we saw before this. We need it because we have a certain information on the a token that is also needed within the debt token.
00:29:49.062 - 00:31:04.158, Speaker A: And then there are the functions to update the discount rate strategy, which is basically the strategy that calculate that returns the interest rate set by the governance and the discount rate that is also set by the governance. And also it keeps track of which is the token that actually makes you eligible for a discount. In this case, it's the SDK Ave, which is the token that is minted when someone supplies to the safety module. So this address in production is basically the address of SDK Abe. And here there are all a few functions that allow for the update of the discount whenever the discount is changed on the governance side, because like everyone has a different discount. So what happens is that when the governance changed the discount, it doesn't change the discount for everyone, because everyone keeps the discount at which they borrow it. So through this particular set of functions, we are able to update the discount of individual users one by one, if that necessity arises.
00:31:04.158 - 00:32:12.262, Speaker A: It's not always the case and I don't know, unfortunately I'm already out of time, but I will try to. Let's see if there is something else interesting here. Yeah, the mint function is particularly interesting because it also has all the calculations regarding the discount and the accrual of the debt whenever someone mints. Because of course, minting debt can happen for every user multiple times. So with the same collateral, I can borrow, decide to borrow three different times, and I need to recalculate every time this particular action happens, how much interest I had accumulated until the last minting, and how much discounted balance I will have on the interest and so on. And so, I mean, this might seem complicated, it's relatively easy, but requires a bit of understanding. Honestly, there is a question, I think, John, I don't know if.
00:32:12.262 - 00:32:13.960, Speaker A: Should I allow.
00:32:14.570 - 00:32:46.206, Speaker B: Yeah, hello John, thanks for the roundup. It has been quite useful. I wanted to ask something regarding how to calculate gho interest rate before borrowing. I think you showed us in this contract the go variable dev token how to get the interest rate, but that's after I have borrowed. So I have been issued the variable dev tokens.
00:32:46.238 - 00:32:46.674, Speaker A: Right.
00:32:46.792 - 00:32:48.900, Speaker B: So my question is, how can I.
00:32:51.910 - 00:34:07.562, Speaker A: No, I mean you can do also before, again, only because the go interest is calculated set by the governance. So, you know, like compared in the other protocol and you borrow USDC, for example, you might borrow a three, but your borrow action already changed the interest rate if the supply side remains the same. Because if supply is 1000 and you borrow five, the base borrow at the moment that you are borrowing is going to be different than the borrow rate after your borrow, because you took some liquidity out. So that's a bit harder to predict what it will be, because for example, in the same block there might be other borrowings or other supplies actions which might alter your calculations. Okay, so if in the same block before you there is a supply, for example, you are going to pay less than what you calculated. This is talking about a normal asset in the other protocol, not gold specifically. This is because the interest rates on USDC, for example, it depends strictly on how much liquidity is supplied there and how much borrow demand and what the users are doing.
00:34:07.562 - 00:34:58.902, Speaker A: If there are users that are withdrawing, if there are users that are getting liquidated, so they are refilling the available liquidity. If there are users that are supplying more, so that's way harder to predict. In this case, you can still do it. You can fetch the discount rate strategies, which is this particular strategy here, that is set within the go, get the interest rate that is returned by the strategy, and also get the discount rate that is also returned by the strategy. And depending on how many SDK avid the guide are supplied, you can exactly calculate how much you are going to pay for your amount, the details of the formula and detect paper. So it's not super straightforward. There are a few edge cases that you need to keep into account, but you can do it precisely.
00:34:58.902 - 00:35:31.590, Speaker A: The only variability here is if the governance, after you borrow it changes the interest rate. In that case, of course you are not going to be able to, I mean, you're willing to do their calculations of how much you are going to pay if the interest rate change. But if we suppose that through the interval of time interval you're borrowing, the governance does not change the interest rate. You can calculate already in advance. You don't need to wait until the borrowing action is completed.
00:35:33.450 - 00:36:07.486, Speaker B: Sorry, just to make sure I'm on the same page, you're referring to interest rates of borrowing go tokens, right? Not about. All right, the functions to read the current, let's assume that there is no other supply or borrowing happening in the same block. Let's take a very naive example here. So, the functions I would need to call, let's say, on my front end to do some calculations would be in this contract, in the variable debt token contract, or in some other contract.
00:36:07.518 - 00:36:36.534, Speaker A: Wait, we are talking again. Go or any other asset go, because it's different. Okay? Yes. All that you need are in the discount rate strategy. So that you can fetch from this token get. There must be a getter somewhere. They discount rate strategy.
00:36:36.534 - 00:37:22.658, Speaker A: There must be a getter for this discount rate strategy, but you can also fetch it from the Ave protocol. As a get interest rate strategy for an asset. So basically what happens, every asset has independent contract which sets what's the interest rate strategy? Okay. Those contracts are, you can be in the particular go implementation you can fetch from the contract here. There needs to be a getter that I cannot find at the moment. But you can also find from the configurator, the Ave protocol, the configurator contract. There is a get reserve interest rate strategy function with.
00:37:22.658 - 00:37:43.340, Speaker A: You can pass the address of the asset. In this case, you can pass the address of go, it will return you the address of the interest rate strategy. And then at that point in the documentation, everything is explained how to fetch the interest rate, how to do the calculations and so on and so forth. You find everything there you can do. Like we use this on our front end, basically.
00:37:44.210 - 00:38:12.120, Speaker B: Awesome, thank you. So basically the easy way is to just call the pool configurator contract. Yes, sir. One more very short question. I noticed you deployed a fresh sepoli deployment for go, but the only asset available to deposit there is ETH, and the APY is set to 0%.
00:38:17.530 - 00:38:19.080, Speaker A: For ETH or for go?
00:38:20.090 - 00:38:23.400, Speaker B: For ETH to supply ETH. Yeah.
00:38:23.950 - 00:38:41.920, Speaker A: Okay. No, maybe it's zero because it's empty, I don't know, I haven't checked yet. But if it's empty and nobody's borrowing, it's going to be zero because it's a new fresh deployment. And I think that's probably the case. I haven't checked in the last couple of days. If someone has already supplied and borrowed, but.
00:38:43.730 - 00:39:01.220, Speaker B: I supplied already and I can't find from the UI at least a way to borrow, so I can artificially pump the API there to make my application make sense because basically we're trying to build on top of the yields that are generated from.
00:39:03.990 - 00:39:14.540, Speaker A: This. You can ask to the guys in discord or in the chat like they manage the deployment, like if you have a problem or this kind of problem, you can ask to the guys that will help you.
00:39:14.990 - 00:39:16.540, Speaker B: Okay, thank you very much.
00:39:17.310 - 00:40:00.086, Speaker A: Yeah, I haven't checked in the last couple of days. I was like discussing with the guys about the deployment, but I haven't checked in the last couple of days. So I don't know what's the state of supply and borrowing of the various assets. Okay, I think we are out of time. I, I want to thank you guys, everyone, for participating in this very short, smart contracts. Overview of the goal. I mean, some of the concepts that I try to explain, they are a bit more root in the mechanisms that the other protocol use that are a bit more complicated and they require a bit more time to actually fully explain and fully understand.
00:40:00.086 - 00:40:45.214, Speaker A: So half an hour is not really enough. I tried my best. I hope it was useful. We are available, of course, to explain. I just wanted to say that what I hope to see for this hackathon as well is also ideas for new facilitators that would be amazing. New facilitators that actually allow the other governance to generate more go that would be very interesting. Or come up with other different ways of, I don't know, integrating the other protocol within go, for example, different implementation that might be more efficient, or, I don't know, different strategies for managing interest rates.
00:40:45.214 - 00:41:05.030, Speaker A: All of these kind of would be super interesting to see your contribution on that particular topic. So thank you everyone for participating, and good luck for the rest of the week. Bye.
