00:00:07.050 - 00:00:58.590, Speaker A: I am a research engineer at Celestial Labs. I'm a contributor to Rollkit. My name is Nash and the motivation for this talk is basically before Ethereum did everything we could rely on censorship, resistance for transactioning, illusion, proof, verification, ordering. But now we realized and we have specialized protocols that can do those things, right. We will have DA layers that specialize in data availability. We have shared sequencers which do sequencing. We will have provermarkets, right? And using all those softwares we now have the realization that, oh, we now inherit their censorship resistance.
00:00:58.590 - 00:01:45.198, Speaker A: And how does this affect the roll up itself? And basically we'll go through some examples, some attacks, and I'll start off with how I define roll up. Roll ups are blockchains that post their transaction data to another blockchain and inherit its consents and data availability. And roll up blocks consists of roll up data and roll up headers. The roll up data is a batch of transactions or the state difference. I will only focus on the batch of transactions. And roll up headers is metadata about the block, which at minimum includes the commitment of the transaction. So this could be a basic roll up.
00:01:45.198 - 00:02:25.466, Speaker A: A user submits a transaction to a sequencer. The sequencer batches it. The roll up full node sees the batch and has finality. The roll up lite node doesn't get the batch by definition. So it will need someone to produce the header with some cryptographic commitment or some guarantee. And it will now trust that guarantee and it's final. And in that process we had a bunch of steps that we were able to delegate, right? We were able to delegate data availability like we already did that.
00:02:25.466 - 00:03:12.502, Speaker A: But also inclusion, which means what transactions are inside the block, ordering means which order the transactions are. The execution is what the state route will be after I execute the state transition function and basically produce the header. And proving is using some cryptographic primitive to confirm the validity of the metadata, like ZK proofs or validity proofs, fraud proofs. So back to that basic roll up. The sequencer can do inclusion or ordering. It will can be an ordered batch or an unordered batch. We could have the header producer do the execution and also probably the proving.
00:03:12.502 - 00:03:39.950, Speaker A: And we have a mix and match, right. We start off with the most basic roll up. The most basic roll up is a base roll up. I post my transactions directly to the DA layer. Then I, as a rollup full node can read from that DA layer. What that means is that the DA layer gets all the mev. I can extract it, I can reorder it, censor it, whatever I want, I'm leaking mev to the base layer.
00:03:39.950 - 00:04:26.260, Speaker A: That's the most easy attack. Now maybe I don't want to leak the mev to the base layer. Maybe I want to leak it to a shared sequencer. Right? But the shared sequencer can do the same thing. The shared sequencer can give you soft confirmations for faster block time, but the finality will in the end be through the DA layer and the audit batch that the roll of full node can actually read. So the shared sequencer is also incentivized to extract value and get bribes. Now another attack is when the shared sequencer does not provide those soft commitments, right.
00:04:26.260 - 00:05:24.210, Speaker A: Why we read from the DA layer is basically to force them to post it because it won't be final until we get it. And what the DA layer now can do is to collude and censor. The sequencer blocks batches on the DA layer so the roller full node will not be able to get the canonical chain. It's not that the DA layer can reorder the transactions. The transactions are already fixed, but they're not posted on the DA layer yet. It's now a symmetry of knowledge between those two full nodes and a delay of finality. Okay, now imagine we have two shared sequencer schemes, one through the shared sequencer, one through the base layer we have some kind of escape hatch.
00:05:24.210 - 00:06:12.930, Speaker A: We have a fog choice rule where we say if in a DA layer block there's a shed sequencer batch and base batch, we always prioritize the shed sequencer batch. Now we think we figured it out, we can use both. But the DA layer still has the control. Now because they can censor the shared sequencer batches. And now because they're only base batches, they can reorder those. And basically we are back to square one where we can trigger the fallback and extract the mev. Right, we covered sequencing, now let's go to execution.
00:06:12.930 - 00:07:04.606, Speaker A: So far we only had roll up full nodes, which means they were only in pessimistic mode. I need to execute all the transactions to confirm the validity. The roll up light nodes do not execute transactions. They don't get the batches, they need some commitment. The header producer will get the transaction batch from a DA layer and be able to commit over that header in the stage route with some economic guarantee. And if the roll up full node sees that there's fraud, it can send a fraud proof to the rollup light node. Now the difference between this diagram and the diagram before is that we ignore the ordering, right? It's the same transaction batch living on the DA layer.
00:07:04.606 - 00:07:59.186, Speaker A: But we say hey, I don't care, I'm going to reorder it again because why not? The centralized header producer can reorder it and then maximize it in some kind of function. But maybe we don't want that. This header producer maximizes it for themselves. So let's try to create a competition and have permissionless header production. Now we can reorder transactions to maximize some objective function. The forktress rule, it could be the most mev extracted, the most gas burned, the most user welfare, whatever that means, and the most funds transferred to the community pool. But here we have the next attack where if you have more than one header producer per roll up height, then you leak mev to the DA layer.
00:07:59.186 - 00:08:58.598, Speaker A: Again, profitable censorship, again, where the fortress rule will be again, highest bribe because the header producer can bribe the DA layer to say hey, I produced the biggest mev, I'll give you a cut, please censor the other ones. Okay, this was the optimistic case. Let's try to do it with the ZK case. We have a ZK roll up and we now have a decentralized provo market. This provo market is basically to incentivize that we can create proofs for the DA layer. The DA layer does ordering and inclusion again, and the header producer does execution. This attack is where we censor proof generation and propagation where because the light node finality depends on the correctness of the validity proof.
00:08:58.598 - 00:10:13.322, Speaker A: And we can imagine an end game where an end user will run their light node does that availability sampling, gets a validity proof and gets the whole correction. The end user will wait and basically have a delay. It's a censorship method to delay light nodes. But light nodes are off chain at the user, subjective. And I do think with good proven market incentives and because we propagated through PDP and we assume no eclipse attack, this can be solved. The problem comes here when it's not an off chain light node but an on chain light node, right? If I want to have bridging and we have to realize currently we talked about sovereign roll ups, we talked about roll up designs that didn't bridge yet, but we want to have a bridge. And a bridge equals a on chain lite client to execute, to basically create that transaction, initialize that bridge.
00:10:13.322 - 00:11:04.580, Speaker A: I have to create a transaction which includes the ZK proof. So me creating a transaction with the ZK proof will go through the whole pipeline of the second roll up or the second blockchain. And now maybe something controversial. If this roll up, imagine this is ethereum. Did we now create a sovereign roll up that bridges to ethereum? Is it now an l two, are those two the same thing? Maybe. Okay. And this attack basically now says that because we're dependent on the censorship resistance of the other blockchain and maybe the relayer, but he can probably get obstructed away.
00:11:04.580 - 00:12:14.950, Speaker A: We have the attacks that I previously mentioned again. But for that blockchain and controlling the funds and message unlock might give you access to MeV. You could imagine that a person is trying to bridge collateral to save themselves from a liquidity. And if you are now the other blockchain, you can censor the unlock of the ZK proof to make sure that he gets liquidated, and then he misses out and capture that attack. All right, optimistic bridging is very difficult in that sense because the censorship resistance is tightly dependent on how you generate, how you calculate the fraud proof window. If you go here and look at the bridge, depending on what kind of censorship properties there are, you need to increase or decrease the fraud proof window. And depending on which kind of stack you're using, you might have different kind of properties going through the whole pipeline.
00:12:14.950 - 00:13:14.410, Speaker A: So you need to now be careful. How do you even calculate that fraud proof window? And so far, those seven days, if I remember correctly, were just set arbitrarily. If we now have more protocols in between, it will be more difficult to set those fraud proof windows correctly. So there needs to be more research in that topic. Okay, so now let's see all of the things together in a big mesh. A user submitting to a shared sequencer, the shared sequencer publishing the ordered block to the DA layer, the header producer getting that ordered batch and basically executing it, creating a ZK proof, propagating that. And then we're also going to bridge with that ZK proof.
00:13:14.410 - 00:14:28.606, Speaker A: And in all of those little things we have possible attack vectors of censorship resistance. So what is the solution here? Basically have strong censorship resistance at each layer, especially the DA layer. It's very important to realize that because there are so many protocols now we really have to make sure that we try to maybe mitigate some things, right? If I enforce a shared sequencer batch and I ignore all base batches, I am mitigating the extraction of the base layer. And the only thing that the DA layer can do is delay finality. But maybe that's also bad. So we want to have very strong sensor resistance at the DA layer. And maybe you can achieve that through threshold encryption where the proposer doesn't even know what they are putting or what's.
00:14:28.606 - 00:15:24.810, Speaker A: Also very interesting, an idea, I think, from Elijah have multiple proposals per block. Where you could imagine that having multiple proposals for the DA layer can be very additive. And depending on who proposed what, you can basically split censorship resistance and have much higher guarantees to get included. And if you have those guarantees for the DA layer, you don't have to worry about a lot of the things building on top of that. If you want to research more about this, I recommend you two talks. One is about exploring mev capture and modular systems. Was at the modular summit, which is talking about multiple proposals per block.
00:15:24.810 - 00:15:45.380, Speaker A: And the other talk is profitable censorship MEV, which talks about different kind of sequencer schemes and how those sequencer schemes could extract or mitigate MEV leak. And I left some time, so I'm happy to answer some questions.
