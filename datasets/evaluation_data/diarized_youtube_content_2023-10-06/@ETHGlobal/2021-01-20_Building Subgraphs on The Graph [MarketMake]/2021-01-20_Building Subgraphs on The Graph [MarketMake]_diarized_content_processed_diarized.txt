00:00:00.090 - 00:00:17.440, Speaker A: Mute yourself just for that background noise. Great. So do you think we should get started now, Trent?
00:00:17.780 - 00:00:18.530, Speaker B: Awesome.
00:00:19.380 - 00:00:30.970, Speaker A: Thank you everyone for joining. We have Ariel from the Graph who's going to show us how to build subgraphs so you can integrate them into your hacks. Thanks, Ariel, I'll let you take it away.
00:00:31.340 - 00:01:34.860, Speaker B: Thank you. Well, first with introductions, my name is Ariel. I'm working as a smart contract lead in the Graph. I joined the team a year ago and previously I worked for a couple of years in Decentraland, another project in the ecosystem. And I want to give you some tools that I think will be very helpful with the project you are building. But also I would like to use this opportunity to explain the value behind the graph, what is useful. I want to show you the different approaches when building a front end application for something based in Ethereum on any blockchain, and the difficulties that you face when building that type of application and what happened in Decentraland, for instance, so you can understand how you can implement in your project basically using the graph.
00:01:34.860 - 00:02:29.500, Speaker B: The idea behind the Graph as a vision is to be an open API for all type of data. Basically, what the graph is doing is indexing blockchain data now mostly, and the most popularly Ethereum, and it's organizing this information so you can query it easily. Okay. And the challenges you see when you are building a front end application is that you have some contract, you created a protocol and then you want to create a front end that is querying this contract. And it's hard for different reasons. Let me share my screen now so I can show you an example application. This is the marketplace that we built in Decentraland, like a few years ago.
00:02:29.500 - 00:03:21.980, Speaker B: This is an improved version of the initial marketplace. But with the team, when we started creating a front end for our contracts, we faced many issues. The first issue is like Decentraland was, well, it's an open virtual world with parcels of land that people can buy and sell and put content on top of that. And we have all this information in contracts. The land is an NFT, you have Mana, there is a token. And we wanted to build a front end. And the naive solution was to query the contracts directly, basically creating a react application, sending requests to an Ethereum node and trying to print the information in the front end to help users.
00:03:21.980 - 00:04:37.140, Speaker B: But it was a naive and a very slow solution because when we wanted to show a map like this one, we needed to query thousands of land from a contract and Ethereum nodes are not prepared for that. It's super slow. We found out that the information in the blockchain, the information is stored as blocks, store as transactions with a payload, raw data emits events. But that's not a proper or very friendly structure to query the data you have in your application. So what we did was to index that information, doing our own manual TypeScript app that basically listen for events, ethereum events, insert that information in a postgres so we can query that information from our front end that was much faster. It was a really interesting solution. But the issue with that is that maintaining a TypeScript or Rast or Go application that you build yourself for indexing the blockchain is tough.
00:04:37.140 - 00:05:32.440, Speaker B: There are many things that can happen like ethereum nodes going down, maybe latency or some problem with the request you have reorgs. You have to keep up with a lot of things. So in the end we turn out like migrating to the graph. Basically the graph we are building a server called Graph Node that integrates, connects what happens in the blockchain. Your own indexer that is configured as mappings and it expose an API using GraphQL. So in summary, it's like a backend for your Ethereum application. Now I'm saying Ethereum because it's the most popular but there are many different blockchains integrated.
00:05:32.440 - 00:06:24.890, Speaker B: So the solution that now you see here in Decentraland is using the graph as a back end and it's super fast. You can see that you can basically switch from different land parcel of land fast and it's querying the back end using the graph. So that's an introduction. I think that you can use the same thing in your project and I want to show you what's behind the scenes to create something like this. An interesting place. I will say if you want to start your create a subgraph that you can use as a back end is to go to the documentation in the graph docs. You have the introduction explaining what you are building.
00:06:24.890 - 00:07:40.210, Speaker B: But you have a quick start where you can see all the steps you need to do to bootstrap your project first and then how to deploy the subgraph into our hosted service. Basically what we are doing is running different nodes that we call the hosted service that accept different subgraph and index them and publish an API that you can use in the front end. Okay, so the first steps that you need to do is to install this package. You can use NPM or Yarn, the one you prefer and it's going to install a tool that you can use from the command line called Graph. And by using this tool you can bootstrap the project first so it will create like a skeleton in a folder where you will work and then publish to the hosted service. I'm going to tell you more about something called the Decentralized network that we launched in December. But first let's focus on the hosted service.
00:07:40.210 - 00:08:26.370, Speaker B: So the first steps to create a subgraph is to do the init that I mentioned. I have already created a project here so I can show you with more information. But basically what you need to do is graph. In it, you're going to connect to our service with GitHub. So I'm using my GitHub username and a name, let's say fake token. It's going to guide through the creation of this skeleton of the project. It's going to ask a couple of questions.
00:08:26.370 - 00:08:31.600, Speaker B: You can select the blockchain you are going to index.
00:08:34.500 - 00:08:36.716, Speaker A: Can you zoom in your terminal a little bit?
00:08:36.838 - 00:08:43.476, Speaker B: Oh, yeah, it is better. Can you see that?
00:08:43.658 - 00:08:45.110, Speaker A: Yeah, I think that's better.
00:08:47.400 - 00:09:30.532, Speaker B: Okay, maybe this. It's going to ask a contract address and it's going to fill a lot of files by doing this. So I'm going to cancel and go to the project I already created. Here is the project. You can see like there are a number of files created by the Bootstraps script. And I'm going to explain each of the files so you understand what you need to do with each of them. So these indexing units is what we call subgraphs.
00:09:30.532 - 00:10:19.530, Speaker B: So probably your project will have one subgraph at least, but it can have multiple subgraphs. Okay, so a subgraph is something that is connecting a blockchain, like Ethereum. It's going to connect entities that we can think of. Entities like a table or an object in a database. And it's going to connect mappings or handlers that you will use to map information from what you see in transactions, in blocks, or in events. You're going to map them into entities. Okay, so basically you are transforming the data you see in the blockchain to something that is more of friendly for your application.
00:10:19.530 - 00:10:58.070, Speaker B: So let's skip this part of the documentation that is about the init that I already show. You have this file called subgraph YAML that is going to define something that we call the mappings. So this is the same file in my project. You will see that these files configures a number of things. The first thing is a data source. We are saying, I want to index the graph token. This is my example.
00:10:58.070 - 00:11:35.820, Speaker B: We are going to index the graph token. It's a typical ERC 20 token. We are going to use the main net, the main network. The address of this token is this one. We are going to start indexing everything that happens in the blockchain with the graph token. From this block, you can leave it zero if you don't know. You can set to a particular block number if you know when this token or contract was deployed.
00:11:35.820 - 00:12:23.156, Speaker B: It's more efficient if you set a block so the graph node don't need to index from scratch from the genesis. So this will help. And then you define a number of mappings, what we call mappings. This is connecting an event signature. I'm using an event handler here with a function, with a function called handle transfer. So when you run this subgraph, it's going to index every event with this signature by calling this function called handle transfer. So this is the mappings.
00:12:23.156 - 00:13:24.320, Speaker B: You could define, let's say if you wanted to manage more events like approvals, you will basically copy this information, paste it and set the right signatures, like whatever it is. It could be any type of event emitted in a contract in Ethereum. So let's see the other part of this. You have a mapping configure. You have, as I mentioned, an event handler. And there are some entities, as I mentioned before, for this project, I created one entity called Account. What I'm trying to do here, this is an easy example, is to have a list of accounts that use the protocol, basically the Graph token, and be able to query the balance of each account easily.
00:13:24.320 - 00:13:44.010, Speaker B: So, what I did is I created an entity and that is defining schema. GraphQL. This file, very simple entity. You define an entity like this. Type. Account is the name of the entity. This is the type.
00:13:44.010 - 00:14:25.190, Speaker B: And as you see, this entity has two fields. One is the ID. This is mandatory. Every entity needs to have an ID and one extra attribute that is the balance. Okay? And this is a big hint reference about how to define schema. You can find information in Google Everywhere about GraphQL. GraphQL is a protocol created, I think by Facebook where it can let you basically create an API on top of a model that you can query in different ways.
00:14:25.190 - 00:15:06.528, Speaker B: So this is a way to define a super simple entity in GraphQL. And we are using GraphQL as a way to express and to query the API that you index. So here I have my account, and the last thing I need to do is to set the logic for the indexing, right? So, again, going back, I have the mappings. I have an entity called Account. I have an event handler from Ethereum. Every time the indexer C transfer will call handle transfer. This function is on the mappings file.
00:15:06.528 - 00:15:32.140, Speaker B: So you have these mapping files with a bunch of functions. These can be commented out. I'm not using them. They are empty. But you can see here is a file that it looks similar to TypeScript. It's assembly script. It's very similar to TypeScript with some limitations.
00:15:32.140 - 00:16:00.390, Speaker B: And the good thing this is compiling to WebAssembly and it's super fast. So we have indexes reading in Rust that can run these mappings. In WebAssembly, we try to use the faster technology. And also Ras is very stable. So running basically one Graph node is super safe. Quick question.
00:16:01.080 - 00:16:05.910, Speaker A: One of the hackers is asking if there's a repo they can follow along with.
00:16:08.700 - 00:16:36.400, Speaker B: Good idea to have a repo. We have a repo, not for the project I'm doing right now. But there are multiple examples of subgraphs. If you go to GitHub Graph protocols, they are an example subgraph. And there are other subgraphs for, let's say, pull together uniswap aragon. And these projects also have subgraphs. So you can see the same structure.
00:16:37.860 - 00:16:41.760, Speaker A: Okay, yeah, that might be a good start. I'll grab those links.
00:16:42.340 - 00:17:45.616, Speaker B: Yeah, maybe you can look at example subgraph. What I'm going to do after the call is to maybe push my example so you can see it. Okay, so I was saying, okay, when the graph no is indexing the blockchain and is finding an event immediate for a transfer, it's going to call this function. And basically I'm in charge of defining what this function should do. Okay, so what I'm doing here is we receive the event and you can see that this is already prefilled with some TypeScript bindings. So you can see all the information. You can basically read from the bends, the address of the contract, the block, the transaction to get like a hash.
00:17:45.616 - 00:19:11.148, Speaker B: For instance, you can get the event parameters by doing this with from to and the value. And what I'm doing here is like fetching this information and basically then storing in the entity that I defined in the GraphQL schema. So this is basically some checks I added because when you are minting a token, basically it's a transfer from the zero address and I don't want to record an entity for the zero address. So I'm skipping that. But what I'm doing basically is storing one entity from account, storing one entity to the destination account and subtracting the value from the balance of the source account and adding the value to the destination account. So I'm keeping the balances of multiple different accounts using the transfers information. Okay, so after the graph node finish indexing this subgraph, I will have information about the accounts with the proper balances.
00:19:11.148 - 00:20:21.370, Speaker B: Okay, you can also apart from writing I heard some noise, sorry. Apart from defining a handler like I'm showing you here, you can define other functions, helper functions. For instance, I define this load or create account function that you can use from your own code that is basically testing if the entity exists or not and initializing a new one. Okay? Again, you can think of an entity as an object that you save in a database or a row in a table. Okay, so I want to show you a bit this function because it's interesting. This is the way I can work with entities you will import in this file from the Schema. I'm importing this entity I defined here.
00:20:21.370 - 00:21:21.736, Speaker B: Um, once I import it, I can use it the same thing with the, with this TypeScript binding. So I can call functions like load that is going to fetch an entity from the storage using the ID. In my case, the ID is the address, the address of the account and you can assign it to a variable and then interact with that variable. Okay, so you can see the attributes you define. In my case it's balance and you can operate on that attribute. Okay, this is one way to operate with the entities. The other way is to basically I'm loading here, I'm testing if the entity is already there.
00:21:21.736 - 00:22:23.660, Speaker B: The other thing you can do in this case is I'm testing if the account exists or not. If it doesn't, I basically create a new entity call account the address and setting the balance to zero. The last thing you do after you basically operate on an entity is saving it and it's going to basically save to the storage, update it or create a new record. I find it quite easy. Maybe it's a lot of information when you see for the first time, but it gives you a way to manage each of the events that gets emitted into a very contained function where you can do transformations on the entities. So this is on the side of coding it. Let me show you about the workflow.
00:22:23.660 - 00:23:33.044, Speaker B: So I'll move this down. You have the project here. When you need the project, it will create this package JSON with some information about to deploy the project in our hosted service. But also some helper functions to basically build the subgraph. You'll see that there are two things like you see code gen and build. And these two things are important if you run code gen. This is basically doing is reading the schema, it's reading the contract information and it's creating these bindings that I show you where you can basically import it in your code and use it like a TypeScript object.
00:23:33.044 - 00:24:23.030, Speaker B: Okay? So it will help with the development. You can see the generated files here like graph token TS. This is auto generated by coaching and it's also creating this schema TS. From the original definition I created here, you don't need to worry that much about these two generated files. You need to define the schema properly and then basically run code gen if you change the schema. Okay, the other thing is building the sacraft. Well, my cat is trying to code with me.
00:24:23.030 - 00:25:07.728, Speaker B: The other thing that you can run is build. It's the other important function in your workflow. Basically what this is doing is compiling your project into WebAssembly and it's preparing it to be deployed. Okay, so running build is a good opportunity to identify issues in the code. Let's say I know, let's do something. Let me see if this is breaking the code. Okay.
00:25:07.728 - 00:25:53.676, Speaker B: I've removed some attributes here and it's like giving me some information that the conversion is wrong and I require a typecast. And this is because I'm assigning something, I'm assigning a parameter instead of this attribute. So if you fix it and run again, you'll see a confirmation that the code is right so you are able to deploy it. Okay, so these are all the things that you need to do to prepare your code. Handle transfer is a function basically I use for keeping track of the balances. But in your case could be something completely different. Maybe you are tracking NFTs.
00:25:53.676 - 00:26:38.240, Speaker B: You want to track the rewards assigned on a farming DeFi project. There are many things that you can do. All these protocols, emits events, you multiple contracts. In the mappings I set this data source, the graph token, but you can set multiple different ones. You can track multiple events, you have block handlers, you have many different tools to play and to create subgraphs. So the final step is to deploy this into our hosted service. If you want to do that, you can visit the Graph plural.
00:26:38.240 - 00:27:53.350, Speaker B: This is the website of the hosted service. What we are seeing now here is my already deployed project. I already been playing with this example and deploying it. So you can see all the information about the project, but you will sign in with your GitHub account, click Add Subgraph and basically you can put an avatar, you can set a name, well, it's going to validate it's under my account. You can set a title, you can decide if you want to show it or not. In our Explorer we have a dashboard where you can see all the subgraphs from different projects. And then you click Create subgraph from here and it's not working.
00:27:53.350 - 00:29:06.270, Speaker B: I know why there. So I created my new subgraph and what you can do is follow these instructions. Basically it's guiding through what we already did, setting up Graph out like you are using your access token to log in and then Graph Deploy. So we are now going to do a Graph deploy on my Graph token project here. NPM run graph. Run deploy. It is now building WebAssembly and it's going to push this subgraph to IPFS and then notify the hosted service that it needs to index this subgraph.
00:29:06.270 - 00:30:01.002, Speaker B: You get a confirmation that everything is all right. One particular thing to notice is that we are using IPFS. The Graph node is using deterministic sources for all the information. Like if you run two subgraphs multiple times, it should get to the same result. Basically, using the Graph node is taking care of the block reorgs and it's indeterministic. So by using IPFS we guarantee that the hashes won't change and the information is the same if you are going to index this subgraph from different places. So now if we go back to the UI, we will see the current version of the subgraph and something called depending.
00:30:01.002 - 00:31:06.360, Speaker B: Okay, depending version is the new version I deployed and the current version is like the live version I had before. And this is interesting because if you do change in the subgraph, let's say you fix a bug or maybe you added a new feature to the subgraph, the current version will be working, will still be working. So your front end, if it's querying this subgraph, will keep solving the results and getting information from the API and it's changed and hot swapped when it's finished. So if you change to pending version, you will see the progress of the indexing. You can see the hash of the file. You can see the log of the progress of the indexing process. You can see things like this signature here.
00:31:06.360 - 00:31:55.350, Speaker B: It's calling handle transfer. You can change the debug level and it's good to see the progress. It's also showing the progress here. So this hosted service helps like a playground where you can submit your subgraph, test it. Share this link where people can start using this subgraph, integrating in a front end or on any other service. Let's see this playground first. As you know, we define this account entity.
00:31:55.350 - 00:33:19.322, Speaker B: These two attributes I can query it by using GraphQL. If you click Play here, you'll see account data like for instance, this account has zero balance. This one way of token this account has more balance. Remember that this number is in way so it's a super long number. You need to divide to take into account the decimals in the token. You can change this to query more results. This is a very simple example, right? But it gives you an idea of the workflow things that you might need when developing a subgraph is adding some debugging information like where is that? Here the let's say you want to log let's say you want to add some logs to your handler.
00:33:19.322 - 00:34:32.800, Speaker B: You can import this graph TS library and use the log function. So you could add things like log debug, a message, a placeholder, and then something to fill this placeholder, let's say. So when you build this project and deploy, you will see this message in the log. This is very useful if you want to see if a variable has what you expected it to have, for instance. So let's deploy the project again. It's going to generate the files. If the files change, the IPFS hash will be different because the content changed, so it will be a different subgraph.
00:34:32.800 - 00:35:57.660, Speaker B: Now it's deploying. So we get back here and we can see that this subgraph ID match with the hosted service one. So we know that we are indexing the right one. And if we go to logs and we set debug level, we can see the message I set in my code, like hello and the address. And this gives you the possibility to try different combinations and maybe finding a bug in your code easily by using the log. So it's super useful in mathematics. The other thing that is super powerful, let me show you in the documentation is that you can find in our example, we define an entity, a super simple entity, like it was the account with a couple of attributes, but you can define entities with relationships.
00:35:57.660 - 00:37:09.792, Speaker B: Let me look for an example of that, because it's interesting here. You can define relationships, right? Like let's say you have transactions on transaction receives you could define these two things as entities and you can link them by saying the transaction has a transaction received and you are linking the receipt from the transaction. Okay, so when you query that in the playground and by using GraphQL, you will see that these two things are linked. You can define one too many relationships too. You can do reverse lookups, this is something that you maybe if used orms database in the past. This is like a pattern very use in orms like Ikemi in Python or others. You can define a relationship and then from a different entity look back to the balances.
00:37:09.792 - 00:38:02.900, Speaker B: In this case you can define many relationships to make it performant. This approach is very similar to what you do in a database by having an intermediate relationship to link users and organizations. So as you can see, there are many patterns you can use. I don't think I will have the time to give everything because there's a lot of documentation. But I want to give you the tools so you can bootstrap your subgraph and then you can basically have the means to investigate and maybe adding and making them more complex. If I were to learn how to create a subgraph, I think that I will base with this documentation. And there are a bunch of examples online from big projects.
00:38:02.900 - 00:39:02.984, Speaker B: Let me see if I can find the for instance, Uniswap. Uniswap has the subgraph defining their I'm referring to Unisop because one of the biggest projects out there has their subgraph and it's quite complete. So you can look for ideas. You can see they define their own helpers. You can base on other project helpers too. They have this function where they are defining handlers for tracking new pairs and creating entities related to that. If you're looking at a new project, maybe it's a good idea to look at the mappings file that I showed you initially because this is the way you track everything.
00:39:02.984 - 00:40:11.710, Speaker B: You can see how they link contracts to particular events and particular functions they use to handle the event. Also the schema file. This is a much more complete example than I show. They have these factories token a pair with these entities that can be linked as I show you with derived from and one entity having other entity defined like liquidity position has a user and a pair for instance. So there are many options for you to play in your project and I would see other subgraphs from other projects to get good ideas. Another tool I would like to show you is in the Explorer. Any questions so far?
00:40:13.840 - 00:40:25.824, Speaker A: There are a few in the chat and then one I pulled over from YouTube if we want to go through them quick. Okay, I can read them to you. Or if you'd like to read them in.
00:40:26.022 - 00:40:29.200, Speaker B: Are them in zoom?
00:40:29.700 - 00:40:47.320, Speaker A: Yeah, in zoom. I'll just read them out. The first one is just a general question about what graph protocol does and I'll just read it. So this protocol would allow us to index and search for data across blockchains on top of other protocols. Is that right? What about Oracles?
00:40:49.020 - 00:41:44.856, Speaker B: Well, something that exists subgraph is now indexing things that exist in a blockchain. So if that information is put into a transaction that can be read, it can be indexed. So let's say Chainlink is the chainlink project. There are multiple nodes in the chainlink project that are submitting information on chain about different things. Right? Like they're a solution for Oracles bringing information from the real world to the blockchain. So you can set up a subgraph that is watching these contracts, and you could index the information that these contracts are bringing. So you could index chainlink.
00:41:44.856 - 00:41:49.980, Speaker B: You could index any information that is on the blockchain with the graph.
00:41:50.560 - 00:42:01.584, Speaker A: Yeah. One way to summarize it and tell me if this makes sense is the graph is good for indexing historic data and Oracles bring new data on chain. That's the difference.
00:42:01.622 - 00:42:04.160, Speaker B: Exactly. Yeah.
00:42:04.310 - 00:42:18.230, Speaker A: Cool. Let's see what the next one is. Rafael asks, is load an inherited method from the entity prototype? This is going back a few minutes, I think, when you were going through the demo.
00:42:20.860 - 00:42:22.504, Speaker B: What's the question?
00:42:22.702 - 00:42:29.800, Speaker A: Sorry, I mushed that together. The question is, is load an inherited method from the entity prototype?
00:42:30.220 - 00:42:48.640, Speaker B: Yeah. Every entity we define is schema GraphQL. It's extending the entity object. Yeah. So we don't need to define Load. Load it's in every entity.
00:42:50.900 - 00:43:07.620, Speaker A: Okay, cool. Rafael, if that answers your question or not, just drop it in the chat and then we can address it later. One of the questions from YouTube is not very familiar with GraphQL, but what are the advantages of using graph for doing the same thing in MongoDB?
00:43:08.600 - 00:43:55.664, Speaker B: Well, what gives you GraphQL? It's super extensible, it's easy to query different. It's a combination of two things. You define an entity format, but it's building an API for you almost automatically by reading the entities that you define. So we thought it was a perfect solution to create a generic API that can be used for multiple use cases. Mongo is a storage solution for querying. You need something else. You can use the language provided by Mongo basically when you connect on the client, but it's a different abstraction.
00:43:55.664 - 00:44:24.510, Speaker B: The GraphQL lets you create queries, and then the storage can be something else. In our case, graph nodes use postgres, so this information is converted into tables. The storage is completely different, and you could swap the storage to something else, to something different to postgres, and you keep GraphQL as an outer interface to the world. Cool.
00:44:26.980 - 00:44:37.520, Speaker A: Maybe this next question might be a little bit out of scope for this tutorial, but Rafael asks, will we ever get charged for deploying a subgraph?
00:44:38.580 - 00:45:29.904, Speaker B: The host service now is free. You can basically deploy subgraphs using your project for free. The new thing in the graph is that we launch a decentralized network in December. That means instead of us hosting all the subgraphs, we have a network of. Now more than 100 indexers that they index subgraphs from the network and DApps can use them. To use the network you need to use GRT. There is a token and we are planning some migration from the hosted service to the network.
00:45:29.904 - 00:46:13.490, Speaker B: But it's going to take some time and we will give more information about how that will happen. The idea is to maintain the playground in the host service, but we'll provide more information in the coming weeks. We'll say okay, I have a question. Yeah. Forgive me if this is like a dumb question, but I was just curious. I mean, it seems like a lot of these DApp protocols have their own tokens, but what prevents you guys from not using ether? And then why do you need a separate token? I was just curious on that. Yeah, there are a couple of things, or I would say crypto economics mechanisms that you wanted to use.
00:46:13.490 - 00:47:24.164, Speaker B: One is this token that we created have multiple functions in the network. There are like Delegators indexers, curators and consumers, basically people that query the subgraph and developers of subgraphs. So by having a token we could create more of we are more like free to create crypto economic designs. On top of this token, indexers can stake, delegators can share some capital to indexers. By using the token. We can have an inflationary rewards for indexers by minting an amount of tokens based on them providing service to the subgraphs that they curate. So if we're using it, we won't be able to add all these crypto economic mechanisms.
00:47:24.164 - 00:47:50.100, Speaker B: Or maybe we should have designed them in a different way. So that's the main advantage, I think, that we can do like a complete call about the decentralized network because there's a bunch of things in the design and it's super interesting. I would like to talk about that, maybe in a different workshop. All right, thanks. Thank you.
00:47:51.030 - 00:47:59.046, Speaker A: Yeah, that's it for questions now, unless somebody just thought of one, but you can move back into whatever part of the workshop you were in.
00:47:59.068 - 00:49:18.000, Speaker B: Ariel yeah, I wanted to show this explorer where you can as I mentioned before, looking at open source code is a good way to learn to get ideas for your project and to basically get to a higher level of I learned a lot of as a developer by looking at other projects. So you have this explorer where you can see subgraph created from the community. You see many of the biggest projects in the ecosystem using it. So you can click on this featured one and look at the subgraph. And a good thing to see, apart from the code in GitHub is how they design the entities. Basically designing the entities is like thinking about the tables and the relationship you should have in your back end. So is it a good idea to have a user? This all depends on how you are going to query the information.
00:49:18.000 - 00:50:20.370, Speaker B: Is it a good idea to have a user? Do you have a pair? In this case? They have pools and they have pairs. So probably they are consolidating a lot of information in this entity. But I will look at the design of other projects for their back end. So I think it will help you to design your own schema because maybe that's one of the first things you would like to do, like design the schema and then see how you map the events that you can read from a contract to this schema. Then you can play with a playground of basically any subgraph. You can query multiple entities at the same time, like you can see in this example. But you can play these unisoft factories.
00:50:20.370 - 00:51:20.920, Speaker B: Entity has these attributes, you can add them like I'm doing now. Most liquid tokens. This is another entity that probably has more attributes. So you can query them like this. Yeah. So I invite you to play with the Explorer, see what our projects are doing, work on your entities and start the skeleton as I show with the graph in it and then deploy some graphs in the Explorer and play with that. I think this gives you a good overview to start, but I would like to see if you have any questions or maybe I went too fast on a couple of things and you want me to repeat something or let me know.
00:51:23.530 - 00:51:43.900, Speaker A: That'S for you hackers. If you had any questions or missed something while the tutorial was being gone through, now's your time to ask away. Sounds like you covered everything.
00:51:45.170 - 00:52:15.400, Speaker B: Okay, good job. I had a feeling I went too fast in a couple of places, but there are a lot of things to show. The summary is like you have the tools and you can now deep dive into the documentation and look at the examples of graphs. I will push the one I've been using in this demo and I'm free if you want to ask questions after the workshop. Okay.
00:52:15.770 - 00:52:32.460, Speaker A: Yeah, it looks like one just came in from YouTube. Not really related to the hackathon, I don't think. But will creating useful subgraphs help me earn CRT? I am very interested in being involved. I think that is true. Right there's some curation benefits.
00:52:33.390 - 00:53:34.830, Speaker B: Yeah. If you create subgraphs, you can do curation on the subgraphs and by curating a subgraph, what you get is rewards from query fees that the indexers that are using that subgraph are earning. So let's say 10% of the query fees goes to curators and the curators are related to the process of creating a subgraph. So as a developer you will probably instead of pushing to the hosted service like I show here, you will be curating on a subgraph and pushing the code there. So you'll get rewards by doing that. There is a section in the documentation that this is split now that you go to host service. This is the thing I show you, but there's a section for the network.
00:53:34.830 - 00:53:59.510, Speaker B: We are completing this section, but you can see the roles I mentioned in all the crypto economics of the network and the things you can get by participating, by being each of these roles as a delegator, as an indexer, as a curator and some guides. We are going to complete this document with more information about the network.
00:54:01.610 - 00:54:06.700, Speaker A: Yeah. Another person asks, can you implement the graph in an existing project?
00:54:08.430 - 00:54:51.430, Speaker B: Yeah, as I mentioned before, when we started this central land, we started this project with the naive solution of querying the contracts. It was super slow. Then we switched to our own indexer and then we switched to the graph. So the approach to implement something like that is you keep your back end while you develop a subgraph. To replace that back end. You can test it using the Explorer and all the tools we have. And then you switch your front end to use the GraphQL interface from the subgraph.
00:54:51.430 - 00:55:00.460, Speaker B: Now you know that the front end is working properly. You can ditch your indexer if you had something for your back end.
00:55:02.750 - 00:55:08.510, Speaker A: One last thing, what would be the best tutorial to start with if you didn't know anything about graph?
00:55:09.490 - 00:55:58.350, Speaker B: The best tutorial is this documentation I showed. I think it's pretty well written there's. All the things I mentioned, like from installing the CLI to what is a subgraph, the manifest, the schema. I will start by reading this and then basically running graph in it and getting the skeleton and step by step, trying to implement something easy and getting it more complex with time. And then as you move forward, looking at other projects, like bigger projects and get ideas like the Uniswap that I show. But there are so many in GitHub.
00:55:59.490 - 00:56:05.694, Speaker A: Definitely. Yeah. So I just dropped the link in there for Docs. Seems like a good place to start.
00:56:05.892 - 00:56:06.800, Speaker B: Thank you.
00:56:08.150 - 00:56:40.874, Speaker A: I think we've covered all the questions. Unless there's oh, here we go. Let's see. Can you give a rundown on the other big projects in crypto doing data indexing querying and what the differences are, e G, Dune Analytics versus the graph, versus whatever you think is worth mentioning. Well, Dune is not a protocol I'll let you answer. Go ahead.
00:56:40.912 - 00:57:56.734, Speaker B: Yeah, the ones I follow I know from the community is Dune Analytics nansen. Maybe they have maybe different approaches. Dune analytics, they have a repo, I would say, like a lot of information that you can query from different places to create charts and to create some visualizations. And I think that they are very good at all this. I'll say data science and maybe the approach for the graph is like even if you can do that with subgraphs it's, more of people are using more as a live back end for the open data. Like you have some service running a critical part of your application is it's not that you are doing only analytics. We have sites like Uniswap Info, but you have a running site, it's the back end for your DAP in a way and that's the value and you can aggregate information from different places.
00:57:56.734 - 00:58:28.110, Speaker B: So I think that there are different approaches and people tend to use maybe dun analytics for other purposes like analytics that you do with some time. It's not at the back end for your service. Nonsense is the same thing. It's more of a user oriented that you want to track the token flow or other things. But these services are not back end for web three applications.
00:58:29.170 - 00:58:41.010, Speaker A: Yeah, that's a good way to summarize it. Another question is can you explain a little more about the cost in GRT we need to pay to deploy or query subgraphs?
00:58:43.110 - 00:59:44.870, Speaker B: Yeah, it's an interesting question. The indexers now they set the costs by using a tool that lets them set the cost per query. And there's another entity that is a gateway that has some indexing routing logic based on the query fees and the query price. But maybe it's a bit soon to answer that question because we are starting to see the market, the formation of a market around the query fees. So it's a bit early because we launched Decentralized Network maybe a month ago. Yeah, so it's early. I will have a better answer after some time and see how indexers set up their prices.
00:59:44.870 - 00:59:57.930, Speaker B: But I will spec competition. We have more than 100 indexes already, so we'll see how this plays good.
00:59:58.000 - 01:00:08.986, Speaker A: Yeah. Okay, the questions keep coming in. Somebody asked if you can share the example code and I believe you said you're going to push this to the repo.
01:00:09.178 - 01:00:24.180, Speaker B: I will push the example code. Basically the example is indexing the graph token ERC 20 and saving some information in an entity that you can query. You can use it for a different ERC 20 if you want.
01:00:28.150 - 01:00:34.520, Speaker A: Another question is could a subgraph be used to make a block Explorer? What are the limits on subgraph size?
01:00:38.330 - 01:01:23.190, Speaker B: You can basically you can track let me show you something. My example application was using event handlers. So you set up this signature and then you basically set up the function that you want to index. But there's other things called block handlers. So you can set up that you want to watch every block and you have a handle block function. So basically by using that you could listen every block, you could store blocks and transactions. Am I doing that? You have a block explorer.
01:01:23.190 - 01:02:07.540, Speaker B: I would say what you need to build a block Explorer, maybe it will take some time to index that subgraph, but you have the tools. So I will say the answer is yes. By using these tools, people typically use this subgraph to create a back end for a specific application. Maybe a block spler is something more general, but you could use these tools. There was another question about that.
01:02:08.970 - 01:02:15.014, Speaker A: Other questions, not necessarily about the Block Explorer. Oh. What are the limits on subgraph size?
01:02:15.132 - 01:02:45.146, Speaker B: I think you answered that. I didn't answer that, but we have very large subgraphs in the host service. I won't talk about a limit because I don't know if we set a limit. I can ask people in the team if we have a hard limit, but we have really large gigabytes like many gigs. Size subgraphs.
01:02:45.338 - 01:02:58.082, Speaker A: I think I saw somebody syncing there. It was either an ether or a wrapped ether sub graph, and it seemed like it took quite a long time. So it's possible to do large ones, whatever that's possible.
01:02:58.136 - 01:02:58.402, Speaker B: Yeah.
01:02:58.456 - 01:03:18.810, Speaker A: I'll try to find the Tweet. Dennison okay, let's see. Gawain asks, will the graph be compatible with Maddox before the end of the hackathon? The end of the hackathon is February 7, I believe. What do you think, Ariel?
01:03:19.470 - 01:03:34.000, Speaker B: I can ask the team. I know that we are doing some integration with Maddok, but it's more of I need to ask the engineering team because they know better. We can provide the answer after the.
01:03:36.290 - 01:03:56.070, Speaker A: I wouldn't I would assume it's not going to be because even if it's available in like a week or so, it may not be enough time. So don't plan your project around this specific integration, but hopefully they get it in time.
01:03:56.220 - 01:04:10.940, Speaker B: Yeah, I think it's a good advice if you are waiting till the last minute to get that and create that dependency. I'm not sure about times, but it's a good advice if you can maybe work around that.
01:04:14.990 - 01:04:22.030, Speaker A: Another question from Keisha is, could I obtain a list of accounts who hold a certain ERC 20 using the graph.
01:04:24.050 - 01:05:15.294, Speaker B: Accounts that hold a specific ERC 20? You would need to maybe track all the ERC twenty s and see when there's a transfer to that account. Maybe I can think of a better approach to that. But there's a way to create or maybe you can scan transactions and see if the from or to address is related to that account. I would need to think about that, but I think you would be able there's something that I didn't show that it's data sources templates. This is something useful if you want to track multiple ERC 20s instead of one, like I did in the demo. You can create a template. Okay.
01:05:15.294 - 01:05:51.340, Speaker B: And then by setting up a template, you can then apply this template to multiple ERC 20s. So you define how to track a transfer, let's say for a contract, and then you apply it to multiple addresses that are using the same interface, ERC 20s, for instance. So you can create a list of multiple ERC twenty s I want to follow. So that's interesting. You can dive in the documentation and look for data sources templates, too.
01:05:59.250 - 01:06:32.570, Speaker A: Kada, did that answer your question? Or maybe we can maybe talk more offline yeah. Okay, cool. I think we've covered everything after the last call. This is the last call for questions if anybody wants to. Okay, we got another one coming in. What is the vision for the graph? I hear it is the new Google, in a sense. Can you elaborate?
01:06:33.550 - 01:08:01.890, Speaker B: Yeah, the vision is to be a decentralized protocol for indexing a querying, open data basically. And we are focusing maybe the graph is popular for ethereum because the project started by indexing the ethereum blockchain but it is to index any kind of information out there that can be ingested like the ethereum blockchain. We are supporting other blockchains too and create this mapping of the world by having a lot of subgraphs for different things and that's maybe why people say it resembles Google indexing web pages and we are doing this for web three and I see the resemblance is by the indexing but that's the vision. So we are doing a great job by being the back end for multiple of the web three ecosystem and we want to keep on integrating more chains and we are doing that. When I show you graph in it, it's not only supporting Mainet, there are like other things Xdai and we are planning to have more integration. That's the vision.
01:08:03.110 - 01:08:36.914, Speaker A: I think that's probably a good place to wrap it. The graph has a huge vision and they'd love to help you build that vision at this hackathon. Thanks Ariel, for sharing this tutorial. If there's anything that needs to be followed up will be in the discord. I'm not sure if you're there, but it'd be great to have you join Ariel and then hackers can pass along anything or any roadblocks they hit. Yeah. Thank you everybody for for sticking around.
01:08:36.952 - 01:08:40.862, Speaker B: Thank you. I'll turn this girl and see you there. Bye.
01:08:41.006 - 01:08:42.430, Speaker A: See you. Bye.
