00:00:19.800 - 00:00:20.350, Speaker A: You.
00:00:22.320 - 00:00:33.710, Speaker B: Hello everyone, and welcome to the ETH Online 2023 Hyperlane Workshop. One click, cross chain actions. Joining us today is York Rose, who will be taking us through this session. And with that, I'll pass over to York to get the session started.
00:00:35.280 - 00:00:51.060, Speaker A: Great. Thanks, Rory. Welcome, everyone. Thanks for coming. For those of you who don't know me, my name is York. I work on a project called Hyperlane. Hyperlane is an interoperability protocol.
00:00:51.060 - 00:01:42.624, Speaker A: In the past, we've been operating on exclusively ethereum EVM chains, but recently have expanded to few other ecosystems. If you're not familiar with Interoperability protocols, I'll give some basic definitions. In our case, we like to describe our product and our protocol as a permissionless interoperability protocol. So permissionless just means anyone can use it. It's accessible to everyone. We want to create a protocol that can kind of outlive the lifetime of any business. And Interoperability is making applications that are on different architectures composable.
00:01:42.624 - 00:02:53.852, Speaker A: So why should you care about this? I'm going to set the scene with what's been going on in the Ethereum ecosystem and crypto in general for the past decade or so. The way I like to think about it is, as DApps decentralized apps have evolved, they're using increasingly divergent infrastructure. So we started with Bitcoin, which was this kind of quite simple and elegant payments protocol that allows users to send each other bitcoin in a way that's permissionless and trustless, at least up to some kind of hush power guarantees. But Ethereum generalized this, and there were a few protocols that followed suit soon after. So we went from just the simple payments to generalizing computation on a blockchain. Hopefully. I think most of you guys are probably familiar with that, so I don't need to get too in the weeds there.
00:02:53.852 - 00:04:15.424, Speaker A: But beyond Ethereum, there are more recently people experimenting even more at the infrastructure layer. So if you guys are familiar with the cosmos and polkadot ecosystems, their idea is kind of instead of having this kind of generalized execution environment like Ethereum, you can get some additional optimizations from having a chain that is designed specifically for an application. So if you're building a lending protocol, maybe you can have the entire infrastructure stack, make design decision or make trade offs based on that specific use case. And then within the Ethereum ecosystem, I think mostly people are excited about roll ups. A lot of this was motivated by basically Ethereum l one, not scaling to the kind of consumer grade demand that we maybe anticipate or expect. Fees are high. It's maybe hard to use, maybe slow.
00:04:15.424 - 00:05:15.764, Speaker A: We don't have single slot finality. So roll ups provide an alternative while maintaining some of the kind of Ethereum security guarantees we have plasma, sharding, whatever. So this is kind of like my timeline of how we're diverging in the infrastructure that actually DApps use. And this presents a problem. Well, first of all, it's exciting because I guess for a long time, these roll up frameworks were very theoretical, but I just wanted to include a slide that shows that actually this is actually taking place in the market. Applications are adopting these new architectures. Here's a screenshot from L2 Beat, which is a great website to kind of track this transition, just showing the kind of marginal activity across ethereum L One versus L two S.
00:05:15.764 - 00:06:04.250, Speaker A: And actually over a year ago now, the transactions per second on L2 S and aggregate crossed over. We have coinbase bought into this. Applications are building application specific roll ups. So we got this like, it's cool, it's exciting. We're solving the scaling problems, but we have new problems, and the new problems are fragmentation. Maybe this chart is also familiar to you, but there's all these different roll up architectures now we have optimism, we have Arbitrum, we have Polygon, ZK, Sync, Avalanche, take your pick. The list goes on.
00:06:04.250 - 00:07:00.856, Speaker A: And as an application developer, if you want to build your DAP on top of one of these infrastructure layers, you have to go and learn one of these frameworks. And that might be fine. Maybe they're sponsoring a hackathon, maybe you can go and play around with it. But the problem that presents itself is each one of these frameworks has kind of like an entirely unique integration surface area and kind of conceptual overhead that you need to understand to be able to build your app on, let's say, optimism or Arbitrum. And so each of these actions that I've listed here on the right side are all independent interfaces. So if you need to go from L One to L2, that's one surface area. If you want to go between L2 S, that's going to be like a different Bridging interface if you want to do general message passing.
00:07:00.856 - 00:07:50.980, Speaker A: So not just like depositing or withdrawing tokens, but actually passing some richer information, that's going to look like a different interface for most of these frameworks. Yeah, basically we don't have standards around any of this stuff. And that's a problem. People are thinking about it. But yeah, we're far from kind of solving this problem. And so at Hyperland we've been thinking about this specific problem of this fragmentation and this divergence of infrastructure, and we are presenting a solution which we feel can address some of this fragmentation. And we call that modular interoperability.
00:07:50.980 - 00:09:50.780, Speaker A: The theme of kind of the past decade or so is that in the evolution of these infrastructure layers, things are becoming more modular. We're optimizing narrower and narrower layers in the hopes of having the stack that an application developer can come to and kind of pick and choose the pieces that make the most sense for them. And so we're taking that same approach to this interoperability problem. So instead of being forced down a specific frameworks interface for interop to reach their chain, if you want to reach the users or kind of have distribution there we want to provide to application developers a single interface for doing this basically, like general message passing and deposit and withdrawal from and to any chains, whether it's an l one or an L two or a Cosmos app chain or a Celestia roll up or whatever it is. We want a consistent interface so application developers don't have to spend so much time thinking about the infrastructure because that's counterproductive, I think, for us innovating at the product layer. And so, yeah, we're trying to separate basically the API that you guys can use to send information between these chains and the actual underlying kind of security mechanism and transport mechanism for actually moving that information. Because as we can see, some of these roll ups are optimistic, some of them are ZK, and they might have different mechanisms by which they verify information coming from an L one or an L two or another chain.
00:09:50.780 - 00:11:52.596, Speaker A: And so we want to abstract that away from the application interface such that there's just a single integration that you do and then you can use this API across basically all of the chains and all the roll ups. More specifically, not only do we want to abstract that away, but we have noticed this problem in kind of the competitive landscape with other protocols that attempt to solve this kind of, like, generalized message passing, Bridging problem, which is that you have what we call like omnibus security choices, which basically means that applications don't have the modularity, they don't have the choice, the power of choice to be able to say, hey, I don't want to use your security. I want to tune it to kind of my own applications like risk tolerances. Maybe if I'm a Dow and I'm doing cross chain governance, I might want really high security on that or I might want some members of my Dow to even vote on the cross chain messages or something like that. So in addition to abstracting away this transport layer, we allow applications who are receiving messages actually to specify their preferences on the security used coming from another chain through like a smart contract interface. So instead of thinking about like, oh, how do I integrate this proving service or whatever, there's like a simpler application API if you choose to kind of customize your security preferences. But I'm just going to walk through kind of like the motivation here.
00:11:52.596 - 00:13:15.180, Speaker A: So a lot of these protocols look like this where basically as an application you want to send a message from origin chain to destination chain. And so you need to choose a recipient contract on that destination chain and you need to pass some string, some body, and there's going to be some off chain actor that basically takes that message that you dispatched and passes it to the destination chain. There's no way for these contracts to interact with each other across these chain boundaries. And that's why this is a difficult problem to solve. So we need this off chain actor to pass the message for you. And kind of the simplest security model is we just trust that off chain actor. So if you have some centralized service that you trust that does the relaying, you can specify your security preference to be just this trusted relayer as a message recipient and then everything's good, right? But let's say we want some different security model that maybe provides better guarantees than just like this kind of centralized service approach.
00:13:15.180 - 00:14:30.016, Speaker A: Well, the idea of hyperlane is, okay, we can abstract away all these other security mechanisms. So instead of if we're going between an optimism L2 and ethereum L One, we can actually leverage the optimism bridge contracts to actually be the one who does the transport layer of passing the message from chain A to chain B. And there's some optimism proposal basically in between here, but we don't really need to think about that. This is like an off the shelf configuration that we kind of allow applications to specify and then they get all the benefits of the kind of l One l Two security relationship. What we actually operate is a set of validators providing this security. It's quite involved, but the general idea is that they can provide economic security on messages. I don't want to get too deep into this, but that's the basic idea here, that we're abstracting away the security and the transport layer so we have a consistent interface across all these chains.
00:14:30.016 - 00:15:37.900, Speaker A: So as an application developer, you just integrate our API once and you can still get the same trust guarantees of roll ups and economic security. Maybe you want to use wormhole or something. This chart shows kind of like the different chains you would want to reach to have the widest distribution of your application. And so integrating hyperlane once you get all this distribution, rather than having to go and integrate all these yourself. So that's a basic idea. On top of this simple API of just, like, sending and receiving messages between chains, we've built a bunch of developer primitives for you guys to use during this hackathon and in general, in your applications to make the integration even more seamless. Because sending kind of, like bytes over the wire between contracts maybe at first might not seem super useful.
00:15:37.900 - 00:16:49.270, Speaker A: So, yeah, if we want this talk is called One Click Actions. How do we actually achieve that with this technology? So I'm going to explain that. So we have these two developer primitives that we call Interchange Accounts and Interchange Queries. And the idea of this is this API block you can basically think of as what we were just looking at with the dispatch and handle of sending a message and receiving a message on another chain. And this Interchange Accounts API basically allows you as a contract on the origin chain to send a call that you want to be made like an ETH call that you want to be made on the destination chain on your behalf. And the idea here is that normally your contract on the origin chain can't interact with contracts on the destination chain. Right? That's the whole problem here.
00:16:49.270 - 00:17:47.460, Speaker A: But this API basically allows you to pass a call. So let's say you're on Ethereum and you want to call Mint. Or let's say you want to call Mint on some NFT marketplace that's on polygon. So what you would do is you hit this interchange accounts API with that call that you want to be made on that other chain. And this will abstract that whole process away. And basically, it will perform that call from a proxy account that only can be kind of activated or make calls based on actions that you do from the origin chain. And so it would perform this Mint and then this proxy account, this interchain account, as we call it, would now own the NFT.
00:17:47.460 - 00:18:45.976, Speaker A: And so this enables this relationship where smart contracts can now hold assets on other chains. They can do actions, basically, against contracts on other chains. So this is like a nice simplification of basically crossing the chain boundary. Almost introduces an Async Await style syntax for doing contract calls on other chains and then just extending that idea a little bit further. We have this queries API which allows you to know if, let's say we were doing that Mint and we wanted to know the return value of doing that function call on the other chain, we can use the Queries API to do that. So this will actually, underneath the hood, it actually is sending two hyperlane messages. One from the origin chain to the destination chain, basically encoding this contract call.
00:18:45.976 - 00:20:18.976, Speaker A: And then after we've done the call, we did Mint and we're getting the return value, we actually send a message back with the return value. And so, again, this is kind of this Async Await style syntax. It really lowers the barrier to developers basically building applications that can leverage all these new infrastructure layers. So when I say one click action, there's been a lot of people talking about basically how the Zora chain, as an example, Zora launched an L2. What does it mean? They can basically get a better fee experience for users who want to just only interact with Zora. But the problem is, like, okay, well, if I'm a user and I only have funds on Ethereum, how do I actually interact with Zora? Historically, what you have to do is you have to go to some third party application that's not Zora, and you have to basically bridge ETH from Ethereum L One to the Zora network in that Bridging application through your wallet. And then you have to figure out how to go back to the Zora application and connect your wallet that you just bridged ETH to on the Zora network.
00:20:18.976 - 00:20:57.744, Speaker A: You have to add the RPC of the zora network. You have to do all this stuff to figure out how to actually connect to this network. And then only then can you call Mint. It's like you're signing multiple transactions. The user experience of this is really not great. And so with these style primitives, what you get is actually like you can have a single action that the user signs a transaction for on one chain and it can go and do the Mint and it can even get the return value all in one transaction. So you don't need to impose this kind of quite complicated user experience.
00:20:57.744 - 00:22:00.388, Speaker A: I think there's been countless stories of people basically losing funds while they're bridging or there's all these bridge hacks. So we want to avoid exposing users to that level of complexity. I mean, it's hard for us, even as application developers, to reason about this stuff. So we can't expect our users to understand how to move between chains. We want to really abstract all that away just as another call out. We have this concept of token warp routes, which is like a contract smart contracts template basically, that will allow you to create a token which users can kind of seamlessly move between chains without having to do sign transactions on multiple chains. And this is compatible with native assets.
00:22:00.388 - 00:22:47.184, Speaker A: It's compatible or matic on polygon or the equivalent of the native asset on any chain. You can wrap existing tokens and move them around to other chains. You can basically create synthetic tokens. So you can create a derivative of a token that's on another chain. And yeah, that's basically what I wanted to talk about. So these are the two APIs that are going to make it easier if you want to kind of go more bare metal in this hackathon. Something that we're also interested in is people actually going out and building their own security mechanisms.
00:22:47.184 - 00:24:02.264, Speaker A: So, as I said, we're pushing this modular interoperability concept. If you want to contribute to the protocol itself, you can actually go out and implement one of these interchange security modules as a smart contract and then other developers will be able to use your implementation. And so, like I said, we've done that for the optimism bridge, but you can imagine doing the same thing for the Arbitrum bridge or the wormhole. We actually have ongoing work on a few of these, but you basically reach out to us and figure out what would be the most useful kind of contribution. If you want to contribute to the protocol, that's, I guess the last bounty here, write a new interchange security module that could be a new ZK lite client or something of another chain. If you're really into ZK or some other light client mechanism, there's a lot of possibilities there that I could give more details on if people are curious. The other prizes are basically just best interchange applications.
00:24:02.264 - 00:25:00.540, Speaker A: So we're curious what you guys can come up with with this API and some of these developer primitives. Maybe it's a cross chain lending protocol. Maybe it's extending just some DAP architecture that exists on one chain, which maybe would benefit from the kind of distribution or composability of being on multiple chains. Maybe it's bringing a lending protocol for native assets. So maybe you can borrow and lend Matic and ETH against each other, something like that. Best use of warp routes and then infrastructure is kind of open ended. Basically, this would involve contributing to something that improves the developer experience of building on top of Hyperlane, so that can be anything from additional monitoring.
00:25:00.540 - 00:25:55.568, Speaker A: Maybe you can build some sort of front end component that allows you to, as a developer, maybe leverage interchange accounts. You could have, like, a wallet integration. We've talked about MetaMask snaps as a potential bounty here if you wanted to basically create some sort of wallet integration or plugin that leverages some of this interchange account stuff so that as a user, you maybe don't even know or you don't need to know, kind of what chain you're on or what chain you're interacting with. And Hyperlan underneath the hood handles all of the cross chain balance management, cross chain calls, et cetera. There's a lot of possibilities here. I think that's mostly my time. Happy to take more questions.
00:25:55.568 - 00:26:00.150, Speaker A: I saw a few comments in the chat. If I can just pull that up.
00:26:03.320 - 00:26:14.304, Speaker B: Yeah. If anybody has any questions, definitely feel free to type them in the chat or take yourself off mute. I think a lot of the stuff that you may have seen was people's autopilots transcribing.
00:26:14.432 - 00:26:32.430, Speaker A: Oh, I got you. Yeah, that's cool. So bad with Zoom trying to find the chat. Oh, there it is. Okay, cool. Yeah, it was mostly autopilots. Got you.
00:26:32.430 - 00:27:21.710, Speaker A: Great. Well, yeah, if there's no more questions, I know I was a couple of minutes late, so I don't want to run over, but yeah, definitely. If you guys are interested in any of these bounties, definitely hop in our Discord. Or we're also in the ETH Global discord. What's the supported chains we're on? Basically probably any EVM chain you can think of. And if we're not on it, I think we'd be happy to collaborate on getting some support there. We actually have a guide in the docs for how to basically deploy the protocol yourself to a chain, if we're not on some chain that you want to have access to.
00:27:21.710 - 00:28:03.680, Speaker A: Again, we're focused specifically on this kind of permissionless interoperability goal, so we don't think that we want to allow anyone to deploy this and expand it to any chains. We don't want to be the only person who can operate this thing. It's a good question, though. Yeah. And you can check out our docs, Hyperlane XYZ. I don't know why I can't type in this chat to meeting chat, send chat to so weird.
00:28:04.420 - 00:28:06.844, Speaker B: I can type it maybe if you want me to as well as hyper.
00:28:06.892 - 00:28:21.696, Speaker A: Yeah, just docs hyperlane XYZ. So weird. Thank you. Awesome.
00:28:21.798 - 00:28:39.950, Speaker B: Well, if there are no more questions, thank you, York, for the great workshop and presentation. And thank you everybody else, for attending. We still have one more session and then team formation session later today as well. So cheers. Thank you all. Have a great Friday and a great rest of the weekend. If we don't see you at the other.
