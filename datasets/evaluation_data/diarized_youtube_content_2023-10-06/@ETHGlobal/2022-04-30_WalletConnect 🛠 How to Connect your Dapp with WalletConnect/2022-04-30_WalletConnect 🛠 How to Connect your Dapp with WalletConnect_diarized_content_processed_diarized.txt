00:00:08.490 - 00:01:11.518, Speaker A: Thanks again for everyone who has come. If you don't know what Wallet Connect is, wallet Connect provides you with the ability of connecting to multiple wallets remotely and not just have the browser extension. So if you're familiar with Metam, Musk or even with a mobile app that has a little DAP browser, it allows you to inject a provider that will allow you to have the wallet expose some accounts, and then those accounts are used for you to know which addresses the user has. And with that you can actually sign transactions and messages. Right? So that's kind of the core concept from it. And what Wallaconnect has enabled was basically to make it more interoperable and expand beyond the world of just the desktop browser or even the mobile DAP browser and just have this remote connection be anywhere. The first experience that we created was with a mobile wallet connecting to a desktop computer and you would have complete separation between the wallet and the DAP.
00:01:11.518 - 00:02:06.738, Speaker A: So we basically created an end to end encrypted channel or end to end encrypted chat that allowed you to have to any wallet to connect to an application. And that would look like, for example, if you go into our registry, we have more than 100 wallets. Like, you can go through all the pages in here, but even if you choose a DAP like uniswap, you would have the ability of actually connecting your wallet. And when you go into the Wallet Connect, you actually pop up this QR code and you bring one of your wallets and you scan the QR code. You go into the QR code scanner and as you go to the QR code scanner, you get prompted to connect your wallet into the application. It knows which website is connected to and it's asking you to approve it. So when you actually do that from your phone, it sends a message back and that message sends the accounts.
00:02:06.738 - 00:02:57.362, Speaker A: So essentially Wallet Connect is a messaging network with a very specific purpose. So let's say we wanted to buy like 100 inch and then it's going to fetch the best price and then you confirm that you want to swap it. On my phone I received a message, this needs to be approved and it happens immediately. And in order for this to happen, you have basically a service in the background just relaying encrypted messages and these two parties are talking to each other. So in this case, I'm actually going to cancel and you see that the swap has failed because I canceled. There's more than hundreds of DApps and 110 wallets right now supporting Wallet Connect. But in order for us to actually reach this adoption, we had to make the experience of connecting your DAP to your wallet much easier.
00:02:57.362 - 00:03:45.854, Speaker A: And one of the things that we created is this open source project called Webtreemodel. You might have seen this screen before. It's I would say, a very popular screen nowadays. And this drove a lot of the adoption for Wallet Connect because it did one thing that nobody was doing, which was how do I allow the user to select which option they want? Everyone just made the assumption everyone's just going to use MetaMask or use like a DAP browser. But then I actually wanted to make it easier for them to actually select Wallet Connect. So I created a library called Webtree Modal, which in a sense says it's a web3 modal because it displays a user with a modal to select which web3 provider you want. So this will be compatible with either webtree JS or Ethersjs depending on your preference.
00:03:45.854 - 00:04:26.270, Speaker A: Personally, I would recommend ethersjs. Nothing wrong with web3 JS, but Etherjs is really good so it will save you a lot of time. And how does it work? You go into NPM and you install webtream modal. And when you install webtree modal, then you have to see the provider options section. The reason for this is because when you add to your project, you're going to have this library web3 model that you can even configure which network you want. There's some option out for the provider and everything. And then this part here, when you say Connect, it abstracts the user selection.
00:04:26.270 - 00:05:18.658, Speaker A: It will handle when the user is displayed with a modal, it will display that for you. It will handle when the user failed, for example, they went through the process of connect to MetaMask wall connect, but for some reason failed. It will throw an error, but at the end of the day it just says here's your provider and then you could take that provider and inject it into Web Three or Ethersjs. So I have actually example here of source code that uses webtream modal. It's literally the react app like Boilerplate with the button that says Connect. Can you imagine what it's going to do? It's going to display the webtoon model magic. So this is interesting, right, because then you have the option here of actually selecting MetaMask or I can cancel it and I can go into the Wallet Connect and you're abstracted from that whole experience.
00:05:18.658 - 00:06:10.206, Speaker A: And then when it actually is successful, it will just replicate and say, oh, look, you're connected and there's this address here and I have this button authenticate, which signs a message. And then you will see it pop up on my phone which actually shows like this one wants to sign a message and then I actually sign it. And this is such a simple example that the signature is here and the signature is here. So basically I've been able to connect my wallet to this and I can do the same experience on MetaMask as well. Actually. I have to clear storage. All right, so we repeat the same experience with MetaMask.
00:06:10.206 - 00:07:23.306, Speaker A: Sorry, because MetaMask is like unlocked. Don't look at my password. All right, MetaMask and it's authenticated and then you actually see the message and it signs and webtoon model works exactly the same. So how would you go into the process of doing this? The most important thing to consider is that webtream modal is an abstraction but then we don't want when you install webtoon modal that all of the 20 providers are in your app, then your app would be like 20 megabytes big. You need to actually have some consideration that they need to be installed separately. So you made this ability of actually configuring which providers you want and sometimes providers have options of their own that need to be injected. So the first step that you need to take is actually import webtream model that we saw that you need to install and in this case we're going to support MetaMask and wall connect.
00:07:23.306 - 00:08:39.170, Speaker A: The reason MetaMask doesn't need to be configured is because it's a browser extension so it's already present in the user and webtree model will detect whether MetaMask is there and if it's not there it doesn't even give it the option. So webtree model abstracts that logic for you and you don't need to configure anything for wall connect, you have to install wall connect ethereal provider and then from the wall connect ethereum provider you can create a webtream model object which you can see here and I pass the network to be mainnet cache provider. Cache provider is an interesting feature that has become more and more popular where you actually cache the user selection. So next time the user comes to your app they don't need to select that modal over and over again, it will just default to the provider that they used before. So for example, if you use MetaMask then when you come back it will use MetaMask because it knows your browser has been to MetaMask and in the provider options you basically put the provider that you want and you pass it the package so you have to inject the package. This is what makes it like a lighter library because you only install Webgmodel and Wall Connect provider side by side. And in the case of Wall Connect, you actually have to pass like a new Fiore ID.
00:08:39.170 - 00:09:45.394, Speaker A: And here I actually use Environment Variable, which is a good practice. Guys do it more often, but it's a hackathon, so you don't have to do it. One of the things that's really important to do when you actually integrate with this is that you have to listen to events like for example if you're familiar with the EIP 1193, if you're not then I'm going to actually teach you about it. The reason web3 model is actually possible is because there's a standard called 1193 or ethereum provided JavaScript API that defines that every wallet provider will follow this API. So web3 model was able to support more than 20 providers because we all agreed how the providers are going to look like and these providers have a lot of definitions and everything but you know what, in webtoon model we explain it more easily, we just say that you have to use these events. These events are very important. The first event shows when the accounts has changed.
00:09:45.394 - 00:10:31.490, Speaker A: Like it's a very common pattern for Ethereum Wallets that the user can select which accounts are available to the application. And if that were to change after the connection, then you can actually listen to this event and you can see that the data that it's passed is an array of accounts. And the second one is the chain change, which is very useful, especially in the pattern of MultiChain EVM and everything. Because if you want to use a L2, you tell the user, hey, can you switch to optimism or arbitram or something like that? And it will show you the chain ID and you can update your app and say, okay, now we're on this chain. And then you have also connect and disconnect. In the case of MetaMask, you don't actually have that. But like some wallet providers use remote connections.
00:10:31.490 - 00:11:22.578, Speaker A: Even coinbase wallet has this so in case there is a disconnection, you actually have this event happening and you can handle that state. You can even have a little red indicator oh, your wallet is offline and then your wallet is online. So it's a really good pattern to follow there. But the most important things that you have to consider is that when you get the provider you can just inject it into the web trade that you want. So sometimes when you're in a hackathon, it's good to just write vanilla JavaScript and not have a react app. We also have an example for that so you can actually follow the vanilla JS example and you can see how it actually handles this. In the case we have, like, wall connection for Matic.
00:11:22.578 - 00:12:10.710, Speaker A: You still pass the provider options here and everything. And you can see how it's used in web3, where you can get the chain ID. And then from the chain ID, we even have this library to get the name of the chain and everything. You get the accounts and then you have to listen to the actual changes for the accounts. Change, God, change. There we go. Wow so here, see like you have to provide their own accounts change, fetch new account data change, fetch new account data network change, network change was deprecated, this no longer exists but now you still have to listen to these so these are the most important things when you're connecting to a wallet.
00:12:10.710 - 00:13:15.174, Speaker A: Also another thing to consider that I think not a lot of people consider is like the disconnection. Because while you can't really disconnect in MetaMask, you can actually disconnect on wallet connect and other providers like coinbase wallet so from the DAP you can actually have the user block that connection and not have it connected anymore. And the way you can do that is by calling provider close. And if you're using the cache provider, you actually should clear the cache provider because if you're caching the provider and that was just a page that reloaded, then it's important. But if the user specifically disconnected the provider, then in that case I would recommend that you clear the cache provider at that point. And honestly, I think that pretty much covers all of the basics. I think it's also useful to review the documentation.
00:13:15.174 - 00:13:47.422, Speaker A: For example, on Wall Connect you can go to Docs wallconnect.com, go to Quickstart. If you're building a DAP, then you go here. You use the Webtree provider for your Webtoon JS or E JS and we tell you how to install it. And we have a setup that can use both infura or a custom RPC where you can use like for example, Alchemy Nodes or some XDI or some Arbitrum. You can use whatever you want with Wall Connect and you can customize it. Over here you enable the provider.
00:13:47.422 - 00:14:32.820, Speaker A: This is what Webtree model abstracts you from. So you don't need to do this part, but then obviously you have to do the events for eleven, nine, eight, three and then you have the methods to request. What I was going to say is that there's some particularities about the Ethers JS and Web Three JS. So Web Three JS existed before and worked in a very specific way. So they actually have a much cleaner integration here. But then when you use Etherjs, you have to make sure that any Web Three model provider needs to be wrapped as a Webtree provider before being passed into one of the contract classes or Wallet classes. Yeah, I would love to hear questions.
00:14:32.820 - 00:15:29.830, Speaker A: How do you show the model? How do you, how do you go to show the model before the modal? Yes, for the user. Right? So the modal is very abstracted. So when you actually go into let's go into the documentation of Web Three model. This model is displayed in this part, web Three model Connect. So you can have your app, you configure your provider options and you instantiate the Web Three model object. And then whenever you want to get, you could assign this to the Connect button. The Connect button that we saw in the React app would call this webtree modal Connect and that would open the modal for the user and the user would do the whole process.
00:15:29.830 - 00:16:12.580, Speaker A: So different providers will have different process of how they authenticate. But once it's finished and complete, then it would return you an object and it would just say here's your provider. Now you can actually go into Webtoongs or ETGs and just add it in. So this process will open and close the model for you and it will also handle the success and failure states of different providers. And you just need to build your DAP, which is your job. The experience of webtree model is really developer focused because we want to make sure that you have to think less about things that don't really matter. There's so many webtree providers out there.
00:16:12.580 - 00:17:21.722, Speaker A: Literally when you see C provider sections, you go into provider section here, there's all of these options and then inside, for example, wall connect or coinbase wall. Like you open it and then you have like for welcome you install the webtoon modal and then you have to configure it like this and have to pass the inferior ID and then it shows Cfool options for wall connect webtoon provider. In the case you actually want to go to wall connect documentation and configure even further. But this is like the basics for the wall connect provider and if you were going to go like with the coinbase wallet, then it has like a separate document that actually provides you here with how you would actually do it. But they all follow the same pattern of you have to install an extra package inject a package into the provider options of web3 modal and then pass some optional or required parameters. Yes. Sorry to ask about web3 modal again, but is MetaMask the only extension based wallet that's automatically populated? This is a good question because actually it has nothing to do with that.
00:17:21.722 - 00:18:13.302, Speaker A: It has to do with the fact that it's an injected provider and if you want to dive into source code, we're going to do it. So there is actually when I say MetaMask, I actually mean injected providers. We actually have here a massive list of injected providers. MetaMask just happens to be the first one that existed. Gnosis Safe back in the day actually had a provider that was a browser extension that would actually inject nifty wallet also exists, that is an injector provider. So that first option of the injector provider would actually be configurable automatically displayed sorry, amand based on the injection. So if you go to, I don't know, for example, status wallet and you open the DAP browser, the webtream model would detect it and just change the logo to be status.
00:18:13.302 - 00:18:51.634, Speaker A: But 90% of the times it's MetaMask. That's why I keep saying MetaMask because it's easier. But actually if you go through, there's actually a lot of injected provider wallets out there and it will change the logo based on the one that's available to the user. So that's why it's automatically there because you could think of it as like injected wallets are user installed and these are developed and the other ones are developer installed. So it's up to you to do the configuration rather than the user have to do it themselves. Yeah. For example, you see Brave, the browser has their own browser extension and they also have their dedicated logo.
00:18:51.634 - 00:19:04.220, Speaker A: So when you open this modal over here, instead of saying MetaMask, it will say connect to your Brave wallet and it will show the little Brave logo other questions.
00:19:08.350 - 00:19:19.470, Speaker B: There is an example app with the list of all providers available as a working app. Yes. Do you have something on GitHub or somewhere?
00:19:20.450 - 00:19:56.630, Speaker A: So to rephrase your question, is all the providers options in there configured into the Web Three model? Actually, I've never done that. It will look crazy. It will start scrolling through it. Yeah, it will scroll, it will start scrolling. So I would not recommend that. Honestly, I think at the end of the day, as a developer, you have to think what's your target user? And you have to kind of just pick. Like, for example, I personally picked this because I found this to be a good combo.
00:19:56.630 - 00:20:26.740, Speaker A: You have the desktop users and then you have the mobile users and then you have the users that don't know what the wallet is, so they can just use taurus, which now it's called Webtree Off. They're downstairs, they renamed, I have to rename this. And then you have coinbase wallet. So this is like very popular options. So that's the ones I usually configure, but I've seen some of them with like eight providers at once. And honestly, that's fine. It's up to you guys to develop it.
00:20:26.740 - 00:21:07.070, Speaker A: Hi, do you also have some option for analytics, like tracking which wallet gets connected the most or something? We don't, but we actually have thought about that. That would be actually a very cool feature to have. The reason we don't have that is because this isn't a very open source project. There's no backend. Even though it was developed by Wall Connect, this is a completely separate thing. That's why it's so popular, because it's kind of like free open source libre. Like, nobody owns this, nobody's tracking this, there's no analytics.
00:21:07.070 - 00:21:51.658, Speaker A: But honestly, you could, you could just like after the Web Three model connect, you could just look at which web provider you got and then you just track it yourself. In theory you could do that, but it's not built in. Yes. Does it work in Svelte? So this is a very, how do I say, isolated library. It's technically built in React, but it should work anywhere because it's rendered completely separate. You could have like a View JS app with this webtream model and it would work. So, yes, I would say it works in Svelte.
00:21:51.658 - 00:22:33.310, Speaker A: I've never tried personally, but I know there's an example in VIT, there's an example in Angular, there's an example in View and Svelte I never tried, but it should work. And PHP would work. Right? Yeah. Any other questions? What if you have an injected wallet that is not on your list? That's a good question. It will show you like a little logo that says Web Three and just says connect to Web Three wallet. So it kind of just like defaulted to Web Three wallet. It has a fallback injector provider, but there's a huge list.
00:22:33.310 - 00:22:44.580, Speaker A: It's very unlikely that happens unless you built your route yeah. Anything else? Can you pass the mic?
00:22:47.830 - 00:22:57.430, Speaker B: Yes. Hi. General question. Does it have to Wallet Connect, does it have to run in the browser or can it run outside the browser?
00:23:02.090 - 00:23:27.722, Speaker A: No. Yeah, because I was saying if you're chris because we had similar question in the booth before. Yes. Wallet Connect. Like Web Three. Modal is for browsers, but Wallet Connect can run anywhere. Web Three modal only runs in browsers, but Wallet Connect provider, you can run it as an electron app, as a react native app, as an iOS app, Android app, literally anywhere.
00:23:27.722 - 00:24:10.640, Speaker A: Honestly, we even had some people who developed, like, a Flutter plugin, but it wasn't actually developed by us, but we posted on the Discord chat if someone wants it. Yeah. So, for example, if you want to do, like, a Node JS, I remember there was someone who did a CLI Terminal that would connect the wallet with Wallet Connect, and it would just display the QR code in terminal, and it would work. So, yes, the JavaScript library is what's called Isomorphic. So it will work. Whatever. Any other questions? Sorry.
00:24:12.450 - 00:24:15.870, Speaker B: The language library is obligatory JavaScript.
00:24:20.290 - 00:24:44.114, Speaker A: So talking about Wall Connect, specifically, the library that I showed is a JavaScript library that will run in react native electron Node JS browser. But then you have the Kotlin Library, which runs on Android. And then you have the Swit Library, which runs on iOS. And there's even a C Sharp library that runs for Unity. And then there's the Flutter one. No. The dart.
00:24:44.114 - 00:25:00.220, Speaker A: One for flutter. So if you're thinking about another one no, there's no more. There was someone who did, like, a one weekend prog Gent and write it in Rust, but it was not maintained for, like, three years, so I wouldn't recommend it.
00:25:07.980 - 00:25:14.730, Speaker C: So how does the flow differ on a mobile app? And how can you optimize that part?
00:25:15.900 - 00:26:04.876, Speaker A: So you're saying what it would look like if Web Three model was on a mobile app? I mean, it would look like the same, and then you would have the user selected. And for example, for Wallet Connect actually, I can try to emulate it. Let's try to emulate that. Give me a second. Well, yeah, it's responsive. All right, so we have on the left uniswap on mobile. Let's refresh it.
00:26:04.876 - 00:26:34.260, Speaker A: Just make sure it detects on mobile. We're going to change. I might need to do a hard reload. You know what? Just go full incognito. There you go. All right, now it's why is it still there? We're going to go safari, guys. Desperate.
00:26:34.260 - 00:27:18.500, Speaker A: Okay, it's not there, like, wallach. And Ike is very persistent, actually. This is terrible. Here, I just need to go into here. Now wipe. That actually that's very annoying. How do you disconnect from here? Oh, it's this guy.
00:27:18.500 - 00:27:44.792, Speaker A: Because we used MetaMask before. So I kind of wish MetaMask had the disconnect button. You know what? I'm not going to use this one. I'm going to use this one. There you go. All right, this is how Wallet Connect would look on mobile. Wallet Connect doesn't use a QR code on mobile because it would be impossible.
00:27:44.792 - 00:29:22.048, Speaker A: So the way it works is that you have these deep links which will redirect you to the specific wallet on iOS and on android. This would actually look different with just, like, a one button, because Android actually has a user prompt to select the like, for example, if I were to emulate it here, the Uri actually just shows right on the right. And you approve it, and you would be able to do all the transactions because the QR code just has, like, this minimum information to actually establish the connection. And that can be represented either as a deep link or as a QR code. So yeah, that's how it would look like on that side, it any other questions? Wow. Then oh sorry. Is it easy to use wallet providers instead of the Alchemy one after you connected the wallet when you want to go some smart contract functions? So the question that you have is specifically compared to Alchemy or like Infuria, right? So remember there was this part here where I showed on the documentation for Wall Connect that you can customize your RPC endpoints.
00:29:22.048 - 00:30:10.710, Speaker A: That's when you actually have basically the web3 provider for Wall Connect proxying to your favorite RPC. Wall Connect doesn't actually read smart contracts directly. You choose who actually reads the smart contracts by default. We had Infura always, but then we added a custom RPC and you can put like your Alchemy endpoints so it will format the transaction reading from Alchemy or Infuria or Quicknode, and then take that transaction and send it to the wallet. So only when the transaction or the message is ready to send to the wallet, then it would actually go through Wallet Connect protocol. Right? So you would have the exact same performance as if you're connecting directly with Alchemy because we're just proxying to the wallet before going to sign.
00:30:17.400 - 00:30:30.330, Speaker C: So I have an app that logs in with Wallet Connect, but Apple rejected it because they don't like the flow of the user being taken out into MetaMask and then coming back in. Is there like a way to amend that problem?
00:30:32.140 - 00:31:16.024, Speaker A: That's actually the first time I heard that. Know, the thing with Apple is that they have guidelines, but then they kind of just pick and choose someone to bully. Because, honestly, I don't think that that should have been a problem because there's literally wallets like trust wallet, that they had to remove their DApp browser because Apple didn't like it, and then they just used Wallet Connect instead. And then they were cool with it. So I don't know what particularly they were not liking about that. But if you go to the OpenSea app on mobile, like the native mobile app, they use Wall Connect to connect it. Zarian also uses it, zapper uses it.
00:31:16.024 - 00:31:27.724, Speaker A: Even Twitter with their new Twitter Blue feature of the NFT. They use Wall Connect. So if they didn't reject Twitter, it's because they have favoritism. Honestly, they have an option where you.
00:31:27.762 - 00:31:36.704, Speaker C: Just input your wallet and they log in. My guess was that for that reason they allowed it because there's another way to log in.
00:31:36.822 - 00:32:06.424, Speaker A: Yeah, but then you have other apps that don't do that. Add another option for just adding the address. Maybe they will pass it. Sometimes you just kind of have to play ball with them to just get it approved. Pass the app store. Sometimes they live like a Scam app, but they don't live your app. It's not perfect system, right guys, I think we cover pretty much all of it.
00:32:06.424 - 00:32:33.070, Speaker A: And thanks a lot for all of your questions. I have some stress pulse because it's going to be some very stressed times ahead of you for all the hacking and late submissions that you guys are going to go through. So please take them. Yeah, and thanks a lot for coming and I hope you guys use Volkanik. If you have any questions, please join me at the booth on the other side of the venue and I'll be happy to help you guys. Thank you, everyone.
