00:00:00.330 - 00:00:15.900, Speaker A: We'll keep you tight. Got a lot of she knows how to apply.
00:00:25.120 - 00:00:38.836, Speaker B: All right, it's 330. Let's get started. It's probably people rolling in, but they'll be late. That's okay. Yeah, yeah. LFG that's right? Okay. Hey, everybody.
00:00:38.836 - 00:00:54.456, Speaker B: My name is Eric Tang, and I'm the co founder and CTO at Livepeer. Before I get started, I'm just curious, show of hands, how many people have heard about Livepeer or know kind of what it does? Okay. About half.
00:00:54.638 - 00:00:55.176, Speaker A: Great.
00:00:55.278 - 00:01:51.096, Speaker B: So let me do just, like, a really high level introduction to Life here and tell you a little bit about what we're talking about here today. Right. So Live Here is a decentralized video streaming infrastructure project, and we've been working on it for about five years. It allows any Web Three developer to build a video streaming application. So if you want to build a Web Three version of a YouTube or Twitch, something like that, you can use Live Here. Live Here itself is a decentralized network, and at the same time, it also integrates with other decentralized infrastructure that allows you to, for example, control the video streaming behavior using the blockchain in the Lifeyer network. But today, the talk is not only about Life peer.
00:01:51.096 - 00:02:40.680, Speaker B: The Talk is really about building the killer Web Three consumer app. Right. Personally, I've been thinking about this problem for a long time, and so a little bit of background. Personally, before I got into Web Three, I worked on a company called Wildcard. Wildcard was kind of a social app content application. It was one of the top apps in the App Store back in 2015, wildcard was built on top of the open APIs on Twitter, Facebook, and all these other platforms that were also emerging at the time, especially on mobile. But over time, these platforms started to close up their APIs.
00:02:40.680 - 00:03:54.560, Speaker B: So that really impacted Wildcard as a company and as a business. So ever since then, I've really been thinking about how exactly can we actually build open applications, an open infrastructure that helps us solve this platform risk as developers? And that was one of the reasons that really drew me into Web Three, is because you can now build on top of Ethereum. And the Ethereum API is not going to change, and no one is going to tell you not to build anything because anybody can build in this permissionless decentralized world. And that's what's most exciting for me. However, we all know that we're still pretty early in the Web Three journey in terms of building consumer facing applications that are actually really scale like the next TikTok. However, I have a pretty strong personal conviction that that's going to happen very soon. And when we have the Web Three TikTok, it's going to be ten times bigger than TikTok, and it's going to happen ten times faster than TikTok.
00:03:54.560 - 00:04:58.856, Speaker B: And one of the biggest reasons is that there is now no centralized party that can be kind of the gatekeeper for people to adopt these new applications so they'll just emerge very quickly and grow very quickly as well. So today I want to lay out some thesis and kind of tactics on how can we actually start to approach building these types of decentralized and consumer facing application that actually have consumer scale and have consumer appeal. To talk about that, let's first look at what's happening in the Web Two consumer world. And this is a graph that often use. It shows the growth of online advertising revenue in the last 20 years. And what we've seen is that in a very short span of time it's grown by 25 X. This is quite astounding back into 2000.
00:04:58.856 - 00:06:28.550, Speaker B: It was 8 billion. Today is 190,000,000,000 last year, right? And you might think that, oh, more revenues must be good, but this revenue actually comes at a cost, right? And the cost is that the online advertising model is working too well. And because of that, every consumer app that we use is looking at this same model. Every consumer app is trying to monetize using the same online advertising model. And when that happens, we start to get into this problem of the online advertising model actually driving these consumer applications as businesses. And we start to get into this world of surveillance capitalism where all of our data, every single click online, is being tracked and bundled up and sold to advertisers for our attention. And every single consumer platform that we use is optimizing for keeping our attention for as long as possible in order to show more ads and grow the business, right? And that's how this curve happens, right? The more attention we as consumer are kept on these platform, the more revenue is there.
00:06:28.550 - 00:07:41.420, Speaker B: That becomes the challenge and also the opportunity for Web Three, which is how do we break that model and find alternative models to start to approach this problem from a different way and still make things very interesting and engaging for consumers. And people have been trying this since the beginning of Web Three, right? So I'm listing out some of the old applications that have been around. How many people have heard of steemit or have used steemit? Okay. What about PPitH? Anybody knows PPitH what about Peppo? Okay, so Steemit is kind of one of the early social apps in Web Three that's very similar to Reddit. I would say PPIF was probably the very first web Three Twitter. You would pay like zero point 25 e to post a tweet on Ethereum. And then Peppo was the very first experiment around kind of like a Web Three TikTok built for communities.
00:07:41.420 - 00:08:55.510, Speaker B: And these applications all succeeded in different ways and failed in different ways. Steam was actually one of the more successful examples. There were some problems with the incentive mechanism in the Steemit platform where it started to become more of like an echo chamber that just pumped the steemit token. But nevertheless, it actually over time had a lot of adoption. In order for us to move past this phase of Web Three, this old phase of Web Three consumer apps and moving to the new phase, I think what we need to start really looking at is how to stop building the Web Three version of the Web Two app, right? We're not talking about building Web three YouTube or web3 Twitter or whatever. That's going to be problematic because these existing social applications already have this really strong network effect and this mode that they've built, right. And they've really optimized to make sure that their competitors are not going to be able to compete with them.
00:08:55.510 - 00:09:50.224, Speaker B: In order to start attacking that problem, we need to look at what are the unique values that Web Three actually presents. And for me, there's really four things that has been proven out in Web Three that is unique and has already adoption. The first one is Permissionless Crowdfunding. Second one is Decentralized Financial Instruments on Chain, being able to do exchanges. Third one is provable Digital ownership. And the fourth one is collective global coordination. So if we kind of put these four value propositions into their acronyms, the first one is really ICOs, right? Permissionless Crowdfunding.
00:09:50.224 - 00:10:40.608, Speaker B: We're able to kind of do capital formation on the blockchain. Decentralized financial instruments is DeFi. I think we're all pretty familiar with that. You can start to build lending protocols or exchanges and things like that. Provable Ownership gives us this unique building block of NFTs, right? So now they're still kind of JPEGs, but really if you look underneath, it's a reference point to any digital link. Right now we're starting to see all these different use cases that comes with NFT, but it is all rooted in the fact that you can provably show that you own this NFT. And the DAOs we're starting to see there are global communities that are forming.
00:10:40.608 - 00:11:17.200, Speaker B: They're starting to have their own missions, they start to organize themselves differently. There are many interesting experiments like the nounsdao, where the communities are coming together across to really go after a specific mission. If we look at all these different unique value propositions, the next question is, okay, how do we use those value propositions to actually compete with an existing Web Two platform?
00:11:17.350 - 00:11:18.048, Speaker A: Right?
00:11:18.214 - 00:12:09.120, Speaker B: Well, there's this old fable in Silicon Valley. I think it comes from Chris Dixon from a 16 Z. And it goes come for the tools and stay for the network. So what does that mean? It means we first need to build an application that provides some core value for a set of users and then those users come and then you start to be able to build a network effect. Some examples may include like Instagram, for example. At the very beginning, it was a tool for people to add filters on their photos that became a very unique value prop. And then as people came in instagram implemented the follow mechanisms so people can start following each other and they start to build this social graph.
00:12:09.120 - 00:14:01.860, Speaker B: So come for the tool and stay for the network is an important lesson for Web Three applications where we think about building something. And the other thing that's interesting to think about is using these existing web two platforms as distribution channels because there's already all these users on those platforms. So you can actually build your application in a way that bootstraps your own network effect on top of the existing social networks. So we're starting to see applications that really lean into Twitter, for example, allowing their users to post tweets inside Twitter that then drive with links that drive Twitter users over to their application, right? So if you look at it from in marketing terms, you can really treat these web two platforms as the top of the funnel and then start to drive your users down to the bottom of the funnel where you can continue to convert them. An example would be if you're minting NFTs, you can think of the NFTs as the canonical representation of a piece of content. In that case, people say like, oh, you can right click and copy and save the NFTs, right? But that's actually the best thing for the NFT because the more people save it, the more people copy it around the web, the more valuable that NFT becomes. And that's actually what you want, right? It's having as many people post these NFTs on other social platforms as possible so that the canonical representation of the image actually becomes more valuable.
00:14:01.860 - 00:14:05.636, Speaker B: That's a strategy and tactic to think.
00:14:05.658 - 00:14:06.230, Speaker C: About.
00:14:09.500 - 00:15:01.572, Speaker B: When we talk about come for the tools and stay for the network. These tools need to solve a problem. What are some of the problems that are in Web Three today that we can actually solve? Right, here are some examples. One is Dows need a place to organize their content. We have all these decentralized organizations that are popping up and I think it's only going to accelerate because it's just so much easier to create a dow and get a group of people to start working towards a mission than needing to form a company or form an organization. So Dows are kind of now the quintessential internet native way to get a group of people together and work on something. But all of these DAOs are now very fragmented.
00:15:01.572 - 00:16:15.768, Speaker B: They use Discord for their community management, they use YouTube for putting their content around. They really need one place to actually organize their content. And I think the first application that cracks that is going to get a lot of adoption in the Web Three ecosystem. The second problem I will point out is the fact that Web Three content today is still living at different places, right? We have these Web Three publications CoinDesk things like that. There's crypto Twitter, right? And if you think about crypto, Twitter is really kind of like a wild, wild west where people are selecting their own people to follow. Twitter was not created to be a Web Three tool. It just happened to kind of stumbled into it, right? So someone who solved the problem of curating Web Three content to make sure that when people can go to a single place to look at the best content for their specific interest, I think is going to have a lot of adoption in the Web Three space, right.
00:16:15.768 - 00:17:47.224, Speaker B: Because it's solving a real problem for the Web Three consumers today that are looking for high quality content but not knowing how to get there. The third thing I want to point out is incentivizing content creation. I think that's something that's really unique in the Web Three ecosystem, right? Because until now, if you want to create content, if you want to be a content creator, you need to do it for free, right? In fact, for example, today, if you want to start to become a YouTuber, usually you need to constantly, consistently create content, at least on a weekly basis for a year, a year and a half, until you build up a big enough audience to be able to start monetize that. That is a long time. That is a long time for someone to work for free to create quality content for YouTube in order to start monetizing any of that. Web Three actually solved that problem, right? Because there's this token mechanisms that you can start to build into an application that starts to draw creators from day one and start to compensate them for their work from day one. To make that more concrete, I think building a Web Three zoom is something that's unique.
00:17:47.224 - 00:18:05.140, Speaker B: All of the dows they're doing these zoom calls, zoom is not created for Web Three. It's actually a very clunky experience. Right now. There are some applications that are already working on this. I'm going to give some examples later. Building a web3 native video. CMS.
00:18:05.140 - 00:19:26.204, Speaker B: So again, to solve that video fragmentation problem, so people are posting their videos maybe on YouTube channels, maybe on Mirror. Having a decentralized organization to be able to kind of organize all of their content into a Web Three native CMS can be a really powerful tool. The other solution or the other opportunity is a curation dao. And the idea of a curation dow is to have a group of people who are incentivized not to create content, but to put together the best content. You can use different types of metrics to start to track who is performing well in a dow, but having a group of people paying attention and actually contributing to the curation of Web Three content can be a really powerful thing. And if you think about it, a lot of Web Two platforms actually behind the scenes use a lot of curators. So Spotify is a perfect example where all the playlists, the most popular playlists in Spotify are actually curated by people.
00:19:26.204 - 00:20:52.184, Speaker B: Spotify just creates a standardized interface for people to search between search amongst those curations. And finally, when creating tools that target creators, which a lot of times consumer application is really about content discovery and content consumption, right? So someone needs to be creating that content. There's a big number of creators that are now being underserved in today's prevailing applications like a YouTube or Twitter, right? So targeting those creators who are doing their one and a half year content creation without getting paid, but a lot of times having really good idea and really high quality content, that's a good way to kind of pull creators into the Web Three ecosystem. So I want to show a couple of examples of applications that are already doing this to kind of illustrate this point. Huddle one is kind of a web. Three zoom. They allow people to use their MetaMask wallet or any their crypto identity to link to the application, to have their identity as that.
00:20:52.184 - 00:21:39.844, Speaker B: You can link your NFTs, you can have your avatar as NFTs. They use Lifeyard to make those streams become broadcasts and so a big community can watch them. Lens Tube is an example that's built on the Lens Protocol. So they use the Lens Protocol for kind of social profiles. And right now it still kind of looks like a YouTube, right? So it's still kind of in the early phase. But we're starting to see Lens to do slightly different things in the Web Three sphere. For example, offering paid content or offering people to have the ability to mint NFTs using these posts.
00:21:39.844 - 00:22:54.476, Speaker B: In fact, every single post in Lens Tube or every single post on Lens is by default an NFT. So that already captures the ownership of the video and link that to the creator much more than what YouTube is able to do. The 402 is a pretty good example of a live streaming application, maybe similar to your Twitch of the World. They currently focus on musicians. So musicians can come to the 402 and do live performances and sell tickets as NFTs, right? They're already seeing really great success where the musicians are able to make hundreds or low thousands of dollars per show, where they would have to do that for a whole month on the Twitch in order to make that much. Beam is another example where as DAOs or decentralized applications, you can do real virtual events through Beam. Bonfire is one that allows the creator to connect directly with their fans.
00:22:54.476 - 00:23:59.430, Speaker B: So if you're a creator, you would use Bonfire to create your own almost like fan club homepage. And Bonfire allows you to do things like NFT drops or do live streams to your community that are token gated. Using new Web Three mechanisms for creators to really build their fan base and know that the creators can actually own their fan base. Because all of that is on the blockchain and they can take their fan base to another application if they wanted to. Last example streameth. This is a really cool collaboration that Life pair did with the Ethereum Foundation and it's Open Source Project and Public Good project, where Defcon, for example, was streamed using Streame and DevConnect earlier this year. ETH, Berlin a couple of kind of real world Web Three events are all streamed on this platform.
00:23:59.430 - 00:25:10.590, Speaker B: So you might notice all these examples are video based. Why do I talk about video based? Well, we're working on Live here and the reason we think video is important for the Web Three space is, well, 80% of the content on the Internet in general is video, right? So at any given time, people are consuming lots of video content. And the reason is that video is the most engaging and most powerful medium of storytelling and communication for any consumer application. The most viral, the most engaging content type by far is always video. So if you think about the Web Three tech stack, we can see we have the blockchain base layer and we have the scalability layer of L2. We have our storage layer like IPFS or Rweave. We have our index and query layer, we have our identity layer that are wallets themselves or things like Wallet Connect.
00:25:10.590 - 00:26:21.548, Speaker B: We can combine all those things together and build applications using video that take advantage of all of these different other components to build really powerful video, to build powerful Web Three video applications. So I want to give you a couple of examples of how this works inside Livepeer. The first thing I want to show you is the ability to upload videos, right? So all of this is available as APIs, but also I'm just going to show you the dashboard here real quickly. So here, for example, I can upload any asset. I'm not going to upload an asset right now because it takes time, but this is an asset that I've already uploaded before, so I can play it here. But more importantly, these video assets can be exported into IPFS. So if you're minting an NFT, you can use this video asset.
00:26:21.548 - 00:27:55.004, Speaker B: However, there's a problem, right? And the problem is if you're creating so I'm trying to load the video from IPFS, it might work okay because I'm on high bandwidth connection, but if I'm streaming this video file directly on my mobile phone or something, IPFS doesn't really have the ability to make the video streamable at scale. So instead I can do it through Lifepeer and still use the same IPFS hash and I can just load it from Livepeer. And when I do this, Livepeer under the hood, transcodes the video into HLS, and it's able to stream that video in many different bitrates and formats so that anybody from anywhere around the world is able to stream that video on any it's. It's an example of using this video layer that plugs into all the other blockchain components. So that allows you to mint a video based NFT, allows you to make that NFT actually streamable across the world. And that's for example, this is what Lenstube uses to make their user experience as good as a YouTube. Another example I want to show you quickly is the live streaming API.
00:27:55.004 - 00:29:03.044, Speaker B: So now I'm going to interact with the API. So what I'm doing here is I just created a live stream, right? And now what I can do is I can send a video live stream in there. We created this testing tool that will send a test stream right away because in this room there are tons of hackers sharing the same WiFi and you can't always get the video stream going. But I just sent a test stream so now I can see that it's live in here. In fact, the other thing that I can do is I can use the Live Peer video player to directly watch the video. Now this is a puppy video, so it's about ten minutes long. Now anyone can create a live stream, right? And this is all working.
00:29:03.044 - 00:30:04.200, Speaker B: But to kind of illustrate another point of building your application alongside of a Web Two app, now you can start to say, you know what, I want my live stream to also be restreamed into a YouTube or into a Twitter or into a twitch to get more audience to come. In fact, this is what the Defcon organizers did in streamed. We streamed the live stream on both the Defcon homepage and on YouTube. So at the end there was about 40% of the people who watched the video on Live Peer and about 60% of the people who watch the video on YouTube. So now we have a decentralized infrastructure that can stream in a decentralized way but also leverage the existing social platform to be able to drive the eyeballs.
00:30:07.110 - 00:30:07.570, Speaker A: Cool.
00:30:07.640 - 00:30:44.682, Speaker B: Let me go back to the last bit. So for this hackathon we have $10,000 of prize. First place is 5002nd, place is 3003rd, place is 2000. We really want to see some interesting applications that use video as a hook for consumers. So video based NFTs or live streaming based video NFTs. There are some prior arts. If you search the ETH Global hackathon you'll find them decentralized video messaging applications or video tools for Dows or Web Three communities.
00:30:44.682 - 00:31:21.720, Speaker B: These are some high level ideas and our team is here and so you can come find us in the booth. We have a hacker Quick Start guide to help you get started. You can join the community here. I want to specifically point out Livepeerjs.org, which is a new developer SDK that we created that's inspired by Wagme, if you're familiar with kind of the ethereum world. So it's very easy to get started building application using Livephere. JS, thank you very much.
00:31:24.690 - 00:31:25.440, Speaker A: It.
00:31:34.290 - 00:31:35.790, Speaker D: If you want to like display.
00:31:39.970 - 00:31:42.670, Speaker B: Maybe I'll do it at the booth.
00:31:43.490 - 00:31:45.630, Speaker D: Where is the people with the workshop?
00:31:46.050 - 00:31:49.086, Speaker A: Okay, sorry, we need to do a.
00:31:49.108 - 00:31:58.390, Speaker D: Better eric.
00:32:41.890 - 00:33:08.980, Speaker A: Idea was yeah, and see it. There we go. Yeah, and see around it.
00:33:36.480 - 00:34:24.936, Speaker C: Hi there, guys. Just give a minute for any late comers. Meanwhile, how many of you have heard about Cartesi before? Are you guys familiar with optimistic relapse? No. A little bit. Okay, sure. Let's get started. So for today, I'm going to be presenting to you a little bit about optimistic relapse and also how Kurtesi uses it for our technology and what it can offer to whoever builds on it.
00:34:24.936 - 00:35:21.052, Speaker C: And first we're going to start with a quick overview of Cortesi, just very briefly. And then I'm going to compare a little bit Nabar's eye view, the differences between web two, three and how it looks when you build on Cartesi. And then I'm going to explain a little bit about rollups. Finally, I'm going to present to you a very simple sample code of our Cartesi DAP written in Python. So here is a DAP written in Python that works right now inside the Cartesian machine. I don't expect you to understand it right now, but it's just to show that it's simple, plain Python. And you can have libraries, you can have interactions within the machine, you can have access to other APIs that you develop.
00:35:21.052 - 00:36:26.880, Speaker C: So it's really a server used as a DAP. So Cartesi is a foundation that has been working on this since 2018. We've been a while building stuff, so it's not just some new company coming up when roll ups showed up and the team has been building this machine for a long while and then the rollups technique appeared and it just feeled like a glove. So we adapted the machine to be a roll up solution and scale Ethereum. So the main idea behind Cartesi, but I guess to some extent our roll ups is that Ethereum is awesome. There is a lot of interesting stuff about it, namely like it is secure, it's censorship resistant, it strives to be decentralized and that's really good. But that comes with a lot of consequences and costs.
00:36:26.880 - 00:37:12.960, Speaker C: It is low, it gets to be very expensive. And that means we are always building a process of gentrification of the network. So we are evicting DApps. They are not profitable, even though they may be important for the communities and for the newcomer developer. It's cumbersome because you need to understand about machine architecture. You need to learn how the EVM works and then a new language like solidity Viper and even low level stuff if you actually need to go that far. So it limits you in several ways, even though it brings a lot of new interesting features.
00:37:12.960 - 00:38:09.840, Speaker C: So the main idea is like what if we could have complex computation inside a blockchain and maintain security guarantees. So the Cortez solution is a transparent VM. So instead of being another EVM based network, a side chain or even a roll upset, we have a risk five emulator. Risk five is an instruction set for a generous purpose processor, just like the ones on your hand for your computer or your phone. So you can think of it like a docker machine of sorts or a VirtualBox and we made it deterministic so we got something. Risk five is open source, open hardware to be more specific. So we got it from the community and we made it deterministic and we applied it to blockchain.
00:38:09.840 - 00:39:04.448, Speaker C: So here's things that you get so like any company in person can build on top of risk five. It's auditable, it's more secure because of that because a lot of people have been working in this project. It's a platform processor, like I said, so you can run an operational system inside it. So that's why we were able to port Linux to the blockchain, we made it deterministic. So that means you can dispute any computation that happens on it. And of course, because it is a full machine, it's very able to do massive computation and you can expand on it like you would do in any server or server application. The main difference between most optimistic rollups and what we do at Cartesi is like we have a local consensus.
00:39:04.448 - 00:40:38.652, Speaker C: So if you think about Ethereum, the more computers you add to the network, you're adding on security decentralization, but you're not adding processing power, you're not adding throughput. However, with local consensus or DAP specific roll ups, what you have is DApps that don't fight for the resources, they don't fight amongst themselves, they have their own sets of validators. What that means is now the more DApps you have out there, you're actually increasing the overall capacity of Ethereum to process things and that is all really good and possible because of the dispute protocol. So whenever you have a problem, whenever there is a disagreement between validators, it is not a majority consensus, it really goes back to Ethereum and uses it as a judge. So the same emulator I just talked to you about, the risk five that you can run on a machine for katasi node is also implemented in solidity for the VM. So whatever process you can do off chain, you can do on chain as well. But with this verification game dispute, you actually go down to the very instruction cycle that you disagree with the other node and you only need to prove one instruction cycle on the Ethereum machine and that is possible because the machine is all mercalized.
00:40:38.652 - 00:41:40.484, Speaker C: So you know exactly what the instruction cycle needs to access, like the memory states and you just need to upload this section of the machine and all the mercury proofs for it. That means that even if there is collusion among validator nodes of a specific DAP, as long as you have one honest validator, you can go back to Ethereum and have the correct settlement. So how does. An optimistic roll upset actually work any roll ups in general, but specifically so you start with the Ethereum blockchain and whatever you do, you're always making state transitionings inside the main chain. The roll ups, it changes a little bit. So you go there to a certain block and you basically states the initial state of your computation outside. You say, hey, I'm starting a new machine here and this is the state in people who join your roll up.
00:41:40.484 - 00:42:27.120, Speaker C: Basically they are agreeing with you that the initial state is correct. Then you state outside for amount of time that you specify. Mostly nowadays we've been using seven days because of the security guarantees of it. So for seven days you go on doing things off chain. When the time is up, you go back to the main chain and say hey, after all that's happened, this is the new state of the machine and people have the chance to verify whether or not you're telling the truth. If they disagree, they can go back and do the dispute and fight you on exactly where you might have been wrong. However, if they agree after seven days everything is settled.
00:42:27.120 - 00:43:00.104, Speaker C: All this computation do not need to happen again inside Ethereum. So that's why optimistic rollups, they expand the main chain they are tied to in computational resources. So the overview here's just a baseline. So you always have some kind of UI. Mostly nowadays browser. Then you have the software for the browser that you want the UI to work with. Then you're going to have a connection.
00:43:00.104 - 00:43:32.840, Speaker C: It can be a socket connection, it can be HTPs. For instance, with a set of servers, they are centralized and they connect to a set of databases that are centralized as well. That's how web two works. Mostly. We are very familiar with that. Web three, especially with Ethereum, it changed the landscape because now your business logic doesn't live anywhere physically, it's in the blockchain itself. Supposedly everybody's running their own nodes so they can just communicate with their local nodes.
00:43:32.840 - 00:44:16.324, Speaker C: Honestly though, we know we've been using infuria too much, we've been using Quick node and whatnot it is, what it is. However, it's much more secure because whenever there is any issues, anybody can just spin up their own full node or even a light node and make sure the information they're receiving is correct. With Cartesi, it's very similar here. I just did a very clean version of it. We're going to break it down. But you still are connecting to nodes just like Ethereum nodes. So supposedly people should be running their own validator reader node of their DAP.
00:44:16.324 - 00:44:58.784, Speaker C: They are connecting to and inside a Cartesi machine. I made sure to have this image over here because we are used to the EVM. But how would a docker like machine work? Right? So there is no access to the internet. I need to stress this point a lot. So because it's a linux server, it doesn't mean it needs to have Internet connection. It communicates through the blockchain and that communication happens using Linux drives and that's cumbersome and difficult to use. So instead of teaching you how to use the operational system to that level, we've created this HTP dispatcher.
00:44:58.784 - 00:45:51.028, Speaker C: It's an API that's running on site, a machine that wraps up all this complexity and just changes it into several four endpoints that are really simple to use. So by just doing ras communication with these four endpoints you can receive information and output information back to the blockchain. So now it's the blown up version of it. So first you still see the JSON RPC over there and that's because we have the data availability problem. So blockchain is both data and computational power optimistic rollups. They're not solving the data problem, they're just solving the computational problem. So what it means is if we are playing chess in a roll ups, you still need to be able to prove that the moves happened.
00:45:51.028 - 00:46:39.764, Speaker C: So if we don't have the base layer as a data availability source for the information, it means people can cheat by just denying information. So let's say I'm playing someone here and they are about to lose. They can say no, I never did this move. How am I supposed to prove that they actually did it? Now you post this information to Ethereum and now you have a proof that they actually did the move in the chessboard. So that's why we still have the Gsmrpc communication. So it's still communicating with Ethereum node and people should be posting their transactions eventually. If you think about other solutions, other projects that have the same solution, so like Arbitrarium or optimism, you're going to see they use sequencers for that.
00:46:39.764 - 00:47:31.344, Speaker C: But effectively what they're doing is posting the things to the Ethereum network. And then the very end you see there is a graphical API. So this graphical APIs, it is useful for you when you're handling the UI, what is being sent, what is being produced from the node? So we have three main outputs from the Cartesian node. We have a report which is basically just a log. If you're running the node, you can still access the full log of the process. But it's really good way of having a clear and clean access to the machine when you are using other processes. So report for instance, is very useful, sorry, it's very useful as an Ethereum call, for instance.
00:47:31.344 - 00:48:12.704, Speaker C: So if you're checking a balance of your C 20, you don't want to make a transaction, you just want the EVM to tell you what is the balance at the current state. So you can generate reports for that. We're going to see this. A notice is like an Ethereum event. However, with spin you can prove that the event happened. So if somebody creates a game and there is like events about winners and losers of the game and suddenly another project shows up and say, you know what, I want to create a badge for whoever wins ten games. Now the person has a problem because how they are supposed to use the Ethereum events to prove they won.
00:48:12.704 - 00:48:37.572, Speaker C: You can't, you can't do that on chain. However, the notice that you produce here on the Cartesian machine is tied to the Cartesian machine state. So you have a merkel proof that the notice happened. So it's really useful in that way. The Voucher is just like the notice in that sense. So it's provable, but it's also going to become a transaction. So we call it Voucher, because you still need to wait for the seven day window.
00:48:37.572 - 00:49:18.836, Speaker C: So it's not truly a transaction until the moment it is. So whenever the roll ups is settled as a user or as a developer, you can automatize that as well. You can pick up the Voucher, for instance, a withdrawal request, and go to the system, to the roll up system and say, hey, I have a valid Voucher, I would like to execute it. So it becomes a true transaction on Ethereum. So you can use that to interact with other smart contracts and DApps. And finally we have the HTPs there, and that's your direct communication with the node. So the Ethereum call was talking about would be actually done through the inspect request.
00:49:18.836 - 00:50:12.516, Speaker C: So you send a quick request to the machine, it's going to wake up, spin up, do whatever you program it to do and die and roll back to the initial state. So it doesn't affect the internal state of the machine long term. So it's really useful for populating UI data. It's useful for you to be debugging the internal state of your program and whatever else you can think that this does not need to transition the state. So going back to the code I showed you before, you're going to notice at the very beginning, I'm sorry, 1 second, that we are actually importing Python libraries. This is not a Python like library. This is not a Python domain specific something for blockchain.
00:50:12.516 - 00:50:41.420, Speaker C: This is truly Python running. It was just compiled for RISC Five. On the yellow side. We created a utility for people, a CLI. It's based on hard hat, by the way, that helps you send quick data to the machine. So you don't have to be developing your own scripts just to test things out. So here we are basically creating a new transaction and sending hello there, payload.
00:50:41.420 - 00:51:24.300, Speaker C: And then you can use the same CLI to list any new notices, new reports, or Vouchers that was created since your last college. So here I have an example of a Python layer called DAP. So it's supposed to send back whatever I send it to it. So going back there, you're going to notice that I grabbed the information for the HTP. Dispatcher was talking before the rest API. That makes things easier from the environment, so you don't need to hard code it anywhere. And here how to say, I'm signing up two types of handlers.
00:51:24.300 - 00:51:47.450, Speaker C: So there's two high level of handlers inside a cartizing machine when it comes to these requests. One is the advanced state. So that's those ones I was talking about. Whenever there is an input, you're actually going to change the state of the machine. And the Inspect state is those that come from the HTP. Inspect request. Just talked about the Ephemeral stuff.
00:51:47.450 - 00:52:29.728, Speaker C: And here comes the most important request in this program. So whenever you start this program, you're actually starting things up, like registering, starting your process, heating up the machine in a way. So basically, the very first time your machine wakes up, you need to tell the architecture that it is done. It's ready. It's like deploying a new contract. So you call this Finish Endpoint over here. So what it does is tells the wrapper that I told you, it gets that information and tells the Framework that it's ready to accept new requests.
00:52:29.728 - 00:53:10.368, Speaker C: So from the perspective of your code, the machine went to sleep over here. So the line 24, your program dies for a second whenever there is a new request, wakes up exactly at the line 24 and resolves the post request. Returning to response their new request. Now we just unwrap the JSON request. We check what type of request we have, which is of the type advance or Inspect. Since it is an input that I've sent, it's going to be a handle advanced type. So we're going to go there to the function.
00:53:10.368 - 00:53:46.856, Speaker C: You're going to see them grabbing the data from the data, the payload from the data I just received, and I'm just putting it back into a new notice. So I'm creating a notice right now. I'm not going to do anything with this data because it's an echo. And now I just need to call the notice endpoint to create a new notice. With that, I've basically concluded most of the things that this needs to do. So line nine is just making sure that I finish with an Accept state. Because if you reject, you roll back the machine.
00:53:46.856 - 00:53:49.790, Speaker C: So you're going to see that in line 27.
00:53:50.500 - 00:53:54.304, Speaker A: I'm sorry, go forward.
00:53:54.422 - 00:54:27.348, Speaker C: Yeah, lines 27, I'm just refilling the Finish status with Accept. And because we are in a loop, I'm going to go back to the finish state. So I'm going to go back to the post on 1 second, I'm going to go back here and queue the machine again. I'm just telling the framework I'm done. I've done all the process that I needed. If I was sending an HTP request, you would come here to the Handle Inspect. In this case, I can only produce reports.
00:54:27.348 - 00:55:01.270, Speaker C: So, like I said, notices and vouchers, they come with proof. And because this is going to be rolled back, there is no proof for those. So you can create as much as you like, it's just not going to do anything. The framework doesn't enforce you, it does not break your machine. Just don't do anything. So here I'm creating a report and if I were to list the reports later, I would see on the other side finish, accept. Now supposedly I would be listing the new notices and you would see the payload over there.
00:55:01.270 - 00:56:12.468, Speaker C: That's it for the workshop. I'm open for questions now if you have some. So she asked me if I can change the state of a smart contract on chain while the operating system so yes, but through the Voucher. So let's say I need to transfer tokens to somebody. We create a Voucher that will be later executed and the execution of a transaction is actually changing the state of a smart contract, right? So that's how I would talk back with native Ethereum DApps. So we saw there that we have inputs being sent to the machine. How that is possible? On the Ethereum network, we are actually deploying a set of contracts for the roll up architecture and the set of contracts are actually an alias for the off chain code you see here.
00:56:12.468 - 00:57:08.746, Speaker C: So this DAP, this Cortesi DAP actually has a ethereum address. Whenever you interact with it, it's actually an input and whatever Vouchers get executed, it's executed with the message sender from that address. So all the other DApps understand that it's coming from this address, that it doesn't know what it is exactly, but it's basically the characterity DAP. So there is an alias, there a proxy and an alias at the same time. Does that make sense? Yes, sir. So it's not private key based. So it's a set of Validators, right? So you have a set of Validators.
00:57:08.746 - 00:57:33.682, Speaker C: They're enabled to interact with that and act as owners, so to speak. But it's also a voting in a sense. That's why you have the seven day window. So if anybody has anything they see is wrong, they can dispute that and you can keep disputing for a while until you get to the correct state. And that means no bodies is the owner.
00:57:33.746 - 00:57:34.360, Speaker A: Exactly.
00:57:34.810 - 00:57:50.080, Speaker C: But they are like responsible people for that. Does it make sense? It's like a voting season in a way. But you ensure that the execution is correct because you have the emulator on chain as well.
00:57:53.170 - 00:57:54.640, Speaker A: Resources for.
00:57:57.970 - 00:58:43.566, Speaker C: So that's a good question because it is an app specific roll up. As a developer, you define what is the requirement. So if it needs to run on a calculator, just don't use too much resources on your DAP. But if you needed to do like machine learning or something, it can be as beefy as you want your Validator node. Yes, but you need to be mindful as you are developing, like what kind of nodes do I want to have, do I want to have all my users running it? So if I want to my users running it. Maybe I don't should be putting the node to be so beefy. Right? Otherwise simple computers won't be running it.
00:58:43.566 - 00:59:04.600, Speaker C: So it's like on the DAP developer to decide what they want because of the other slide I showed like this one. Every DAP is its own little network in a way. So you decide it?
00:59:07.650 - 00:59:08.400, Speaker A: Yes.
00:59:11.170 - 00:59:22.658, Speaker C: So if you say that's only going to be like two validators sure. Maybe like a chess game and that's fine if you want something that is a bit bigger, but ten is fine.
00:59:22.824 - 00:59:23.538, Speaker A: Sure.
00:59:23.704 - 01:00:04.670, Speaker C: Then if you want to have something that everybody is able to at least validate then you need to be mindful of that. But there's no like intrinsic limitations just like docker in a way. Are we good? So we are here throughout the whole weekend at the table. You are so welcome to visit us and ask us any question. So at the very end have a link tree for cartesi here if you want to check documentations medium and why not? Thank you.
01:00:06.800 - 01:00:07.710, Speaker A: Thank you.
01:00:10.340 - 01:00:25.520, Speaker C: Guess the next person is already here. Oh by the way, we have some magazines and stickers for you there, but there's more at the booth. Yeah.
01:00:35.970 - 01:00:45.178, Speaker A: What will happen? End up running it. How does that get rejected?
01:00:45.294 - 01:00:48.834, Speaker C: No, not gonna reject. I'm gonna have a lot of trouble.
01:00:48.882 - 01:00:54.666, Speaker A: About dating at some point you can.
01:00:54.688 - 01:00:56.042, Speaker C: Be doing that stuff.
01:00:56.096 - 01:01:01.690, Speaker A: Maybe you're another notice. But it can be like sampling your.
01:01:01.760 - 01:01:17.454, Speaker C: Process and just doing certain pieces. So here at this point you said your sequences? Sure, I'll just assume it's true. But let's see if you actually correctly and they can start simply just keep.
01:01:17.492 - 01:01:43.088, Speaker A: After you and maintain. Thank you very much. Take more of a look. Yep. Sick. There's Ethernet back here in case you have any WiFi. No, don't need it.
01:01:43.088 - 01:02:08.650, Speaker A: You won't need it. Yes, I got all my slides. Is it not going to be on there? Welcome to running Linux. I will start a rap battle with somebody. No, I'm kidding. Oh shoot. Is my ex rander on here? Okay, let's grab presenter view.
01:02:08.650 - 01:02:42.698, Speaker A: Sweet. Okay. I've dragged it to another desktop. Give me a moment. Thank you. See this? Are we good to go? Can I? All right. Hello there.
01:02:42.698 - 01:03:00.630, Speaker A: Let me see if I can grab this. And there we go. I'll hold it. I think we'll figure it out. Can everybody hear me? Sweet. Okay, so good morning, afternoon or evening if you're watching this from the recording. But to those of you in the room, I suppose it's just afternoon.
01:03:00.630 - 01:03:48.614, Speaker A: I am zero x two two five F 137127 D 906-778-8314 BC seven FCC one F 3674. If I make a mistake, correct me. Six A, three C, three B five otherwise known as loop computer or looseman study if you want to go the OGE ENS way. And that right there is am I too loud? The core premise of ENS ENS the ethereum name service is simply the ability to convert human readable names like Nick ETH. I should have probably full screened this into machine readable names, such as zero XB eight, C two, C two. Okay, I will I'll cut you the pain. All right, this way.
01:03:48.614 - 01:03:50.002, Speaker A: And obviously backwards.
01:03:50.146 - 01:03:50.770, Speaker E: Sweet.
01:03:50.850 - 01:04:22.990, Speaker A: So ENS allows us to turn the general DAP experience that would look like this, right? This is my zero x two two five F 1373. You know the drill to this luke computer, my DNS name. I've been clicking on the wrong slides. So this one's behind. Lovely. It's going great. Okay, so if you're here and you already know ENS, I hope most of you do, you might want to keep watching because I do have some cool stuff to show in no particular order, and that is going to be chaotic.
01:04:22.990 - 01:04:48.058, Speaker A: Let me run you through the agenda. First, I'm going to talk about what ENS actually is and how the core logic works, all the fun stuff. Second, I'm going to be talking about resolvers and the DNS integration. There we go. That went great. The DNS integration for all sorts of fun stuff you can do with that. Records and resolvers and essentially how text records work, storing data on chain off chain resolving and all that fun stuff.
01:04:48.058 - 01:04:57.210, Speaker A: Cross chain interoperability, like I just mentioned, how to implement it. And last but not least, if you are new here, how to register your first DNS.
01:04:57.870 - 01:04:58.694, Speaker D: Sweet.
01:04:58.822 - 01:05:24.562, Speaker A: Before I do all of that, I want to point out some milestones. We're absolutely thriving. We've currently got 2.75 million names registered, which is ridiculous over 506 integrations that I am in group chats with. So I think that kind of explains my suffering. But there's a ton more. And if you do end up building a super cool project and you end up scaling and you end up needing my help beyond these walls, then feel free to send me a message.
01:05:24.562 - 01:05:59.982, Speaker A: We'll start up a group chat and I'll happily help you out. And 593,000 different people who have their own ENS name. Sweet. So let's look at another practical example, right, because we saw the lovely one I showed earlier, and you're probably all familiar with DAPs, but let's do it anyway. This is Tic Tacso, a stupid DAP that I built a hackathon project back in two, three months ago now, in Paris. I had a bit of time left over and I said, screw it, I'm going to build tic TAC toe in solidity because I'd like to not sleep tonight. And, yeah, it might not look good, but it works.
01:05:59.982 - 01:06:34.106, Speaker A: And if you look right there in the top right corner screen is too much brightness. You can see V three x E, which is back then. My ENS name, ENS, by the way, lets you swap between what currently your primary name is. And I'm pretty bipolar, so I keep switching between V three x ETH loop computer and loosemans ETH, but all of those will end up at my address. So that's me right there in the corner. I should have probably zoomed in earlier. So, yeah, now your favorite DAP obviously has all this cool stuff, and you go, okay, is that all ENS does? Lame, but bear with me here.
01:06:34.106 - 01:07:10.258, Speaker A: You want to invite your friends, so you press Create Game, and then right there, you can type the address or you can type their ENS name. So you type in Nick ETH, because casual flex. I played a game of TicTacToe with the founder, and right there, his name, his profile picture, and his address show up and you can verify it's the right Nick ETH. You're not getting rugged. It's a tic TAC toe game, who cares? And then you press Send Invite, and then he accepts, and then you can play TicTacToe with Nick ETH. And regardless of my shitty TicTacToe skills, it's not my strong suit, okay? I'm a developer. This is the core idea of ENS, right? We have my name there, his name there, and our profile pictures.
01:07:10.258 - 01:08:04.386, Speaker A: Sweet. So what you saw there, the simple DAP decentralized app shows just one of the things ENS does, which is usernames and profile pictures, but we do a fair bit more. So this is me, Lucemus ETH again, Loosemas ETH, three, three X, E, all the fun stuff, but it stores a whole ton more than just my cool profile picture and my address. Nick ETH is a better example because I don't have half of these set up stores. His ETH address stores his BTC address, his Doge address, his Litecoin address, his website, his email, his discord, his Twitter, his Reddit, his telegram, his GitHub, and who he delegates to, or at least his delegation page, if you want to know more about him and being part of the Dao. And it's just a forum link, who cares? And obviously, most importantly, the avatar. And specifically this is in a specification to link towards his NFT that he uses as his profile picture.
01:08:04.386 - 01:08:43.620, Speaker A: But this could be a simple HTP URL, this could be https, this could be on our Weaver, this could be on IPFS. So how does all of this work? ENS is pretty simple. We have a couple of core contracts and they work as follows. The core contract, and this is specifically the ETH section, stores the following information the name looseman E, the registrant, the person who is currently in charge of the domain. So that is me, zero, X, two, two five, F 1373. Okay? Yeah, when it expires and the current resolver. So a smart contract address that stores the rest of the information, the avatar, the telegram, the discord, all the other fun stuff and the Ensdelegate link.
01:08:43.620 - 01:09:10.230, Speaker A: The only difference between a ETH name and a DNS name or a subdomain is simply we don't store the expiration date because it's handled externally. So it stores that for Nick ETH. For Fatalic ETH. Those are real records and for everybody else. So what you do is you go over there and you're saying, hey, I'm looking for Nick ETH. And then the smart contract says, all right, here you go. Nick ETH registrant expires in resolver.
01:09:10.230 - 01:09:34.078, Speaker A: And then what you do is you look at the resolver, or at least the tooling does this for you. You don't have to put any effort into this. It grabs the resolver address, it goes to the contract because it's a smart contract. And the smart contract then gives us back all of the fun information we were looking for. But this is a little cooler than it seems. This is the public resolver. It's a simple smart contract that has a key value pair and key value pair storage.
01:09:34.078 - 01:09:58.220, Speaker A: And you can edit your records in there. But this could be your own contract, which means that you can write your own logic and you can change your profile picture depending on the day of the week, the current balance in your account happy face. Sad face. Very sad face. And whatever else you'd like. And a ton of other cool stuff. So this allows us to do all sorts of fancy things.
01:09:58.220 - 01:10:24.834, Speaker A: I hear you say, like, this is cool, fun, but we're still stuck on ETH main net. I want the new stuff, the shiny stuff, the fancy things, right? I want to build on all these things. I want to play my hackathon prize bingo. And I want to tick all the boxes. So do we. Well, not the hackathon prize thing, but playing with the fancy things, right? So I've got good news for you. You can, right? You can play with all of the fancy things.
01:10:24.834 - 01:10:47.738, Speaker A: We can play with optimism, we can play with polygon, we can play with galosis, you can play with whatever the hell. And off chain. The way we do this is using a spec that was written by a combination of people, but one of which was Nick, our founder. And it's the cross chain interoperability protocol. I misspelled protocol. Shoot. This presentation is old.
01:10:47.738 - 01:11:22.950, Speaker A: Oh, work me. Okay. Well, CCIP for short. Let's just call it CCIP and forget about the typo. So the cross chain interoperability protocol protocol allows us to do all sorts of cool stuff. It allows us to fetch data on chain whatever chain you'd like off chain on a roll up on a layer. Two using zero knowledge, using Https if you really fancy and you like April Fool's Day jokes from the IATF, using HTCPCP, the hypertext coffee pot control protocol, using your toaster or using anything else, which gives you a lot of control, it's pretty cool.
01:11:22.950 - 01:11:57.140, Speaker A: So how does it work? Thank you for photographing my face. This is going to haunt me, isn't it? So this is CCIP. I would recommend photographing that one. And essentially, this is a simple example of what ethers does when you store something on optimism. So the way that it works is the client library reaches out to ETH mainnet, grabs the resolver from the ENS core contract, goes to whatever smart contract is attached to it. In this case, zero x 49, seven, whatever. And the smart contract just throws a cross chain interoperability error, or in this case, off chain data.
01:11:57.140 - 01:12:32.798, Speaker A: It says, this is optimism, this is the contract on optimism, and this is the call data you should give to optimism. And then optimism will tell you where to go next. So then it goes back to Ethers. Ether says, oh, shoot, this transaction failed. It was an off chain data error, okay? And then it reaches out to your HTP server, to your toaster, to your coffee pot, or to optimism, which all scale just as well. It goes to optimism, your optimism smart contract, and decides what to do with it, returns your avatar, returns whatever other records you'd like to set, and voila, it works. Zero extra effort on your part, might I add.
01:12:32.798 - 01:12:51.166, Speaker A: So all of this is happening behind the scenes. All you do is use ENS name in your react app and it magically works. It's phenomenal. It's also half of my nightmares, but I make sure that it's phenomenal for you guys. So I recently built a cool example of this using off chain lookup. I'm running an HTP server. It connects to Twitter.
01:12:51.166 - 01:13:21.930, Speaker A: It simply does some lookups and it has some heavy caching on it because I'd not like my API key abused. It's called Twitter NGO. It's a web two domain that I ported over using DNS SEC. And the way that it works is you just go to any Twitter username, twitter NGO, the ENS smart contract on mainnets or previously on Gorely will then tell you here's error off chain data. Lookup, this is Luke's server address. This is the data you need to feed it. And then my server will start running.
01:13:21.930 - 01:13:55.800, Speaker A: Reach out to Twitter, fetch your Twitter data, get your username, see if there's an ENS name in there, do resolution there, and then return your address, your profile picture and your description. And then eventually you get something like this. So you go to Nicksdjohnson, Twitter NGO, and then everything magically loads in the background. And then ta DA. So now we have his address, his URL, which links to Twitter, his avatar, which is his Twitter avatar, and his Know. I don't know, I thought it was a fun use case. So this works in almost all the libraries out there.
01:13:55.800 - 01:14:22.674, Speaker A: Ethers Wagme in SJS that was supposed to be on the same slide. I don't know what happened here, my presentation is going great. Ethers Wagme, ensjs, web3 JS, web3 J K, ethereum, web3 Pi, go, ENS whatever library is on this list. If your library is not on this list, message me and I'll add it next time. But all of these support CCIP and it's super cool. So how. Do you use this? Right forward resolution, super simple.
01:14:22.674 - 01:14:32.046, Speaker A: This screen doesn't like my cool colors. I guess it's too white contrast. But for ethers, you simply just say Provider. Resolve.
01:14:32.078 - 01:14:32.370, Speaker F: Name.
01:14:32.440 - 01:14:49.726, Speaker A: You give it V three X ETH and it will output you. Zero x two two five, f one three seven. Okay, you get the drill. And with Wagme, the react library hooks. For Ethers you simply do use ENS Address, address v three X ETH, or the actual address, and it will return you with the address. Sweet. And you can also do reverse resolution.
01:14:49.726 - 01:15:26.794, Speaker A: So if you have the address, you can turn it into a name and a profile picture using Ether's, lookup Address and Wagme's use ENS Name or use ENS avatar and a bunch more. Obviously there's so much cool stuff to cover, I haven't even talked about subdomains, but that's a whole other rabbit hole. And you can build resolvers to control subdomains. And we have a new thing coming out, the Name Wrapper. That's essentially a resolver contract that allows you to sell subdomains as NFTs and control them that way. So you can transfer them to people and make it fully spec compliant. If you'd like to find out more, you can check the documentation.
01:15:26.794 - 01:15:45.194, Speaker A: This is Docs ENS domains. I technically maintain these. They need another cleanup, but that's all right. If you have any questions outside the Docs, just come to me and then I'll happily help you out. Now if you're sitting here and you're going, this is kind of cool, I don't have an ENS name. Seems pretty cool. I'd like one.
01:15:45.194 - 01:16:11.442, Speaker A: How do I register? You can always come to me, I'll happily help you out, or I'll even give you one. But otherwise you can use the ENS manager or any of the other cool things. So there's the ENS ferry. It's an application written by one of our community members. It allows you to give names at lower gas costs to new users. So instead of having to purchase the name, then change the records to the other person's address, and then transfer the thing and then get them to set it as their primary name. You can just do it in one transaction, which is super cool.
01:16:11.442 - 01:16:29.820, Speaker A: Still two, but costs less gas. And it looks nicer. It uses the new design system. You can do it directly from Rainbow. Rainbow, the mobile app has a built in coinbase hands out subdomains of CB ID. Because again, any valid DNS name is a valid ENS name. And you can verify them using DNS SEC.
01:16:29.820 - 01:16:55.790, Speaker A: If you just enter your.com or IO or whatever in the ENS app, it will magically tell you all about it. Lens if you have a lens profile, add XYZ behind it lucemans Lens XYZ and magically it'll work as your ENS name. Argent does it with argent XYZ. There's a whole bunch more cool stuff. There's also some Alpha I'm going to drop again. Yay, we have the new alpha Manager coming out soon.
01:16:55.790 - 01:17:23.158, Speaker A: TM it's fully mobile compatible, and we have a whole new design system for it because our current Manager is slightly outdated. So we've put a ton of effort into this one. It has cool animations, it does Caching, it does all sorts of fancy stuff, and it also works on desktop. And if you want to test it out and you happen to have Gorely ETH, then you can check out alpha ENS domains. There we go. My slides are also on my website, luke show, so can't be that bad. Alpha ENS domains.
01:17:23.158 - 01:17:43.680, Speaker A: I'll say that one more time. So the Events Manager in its current state, let me walk you through it real quick. So this is the ENS Manager. I know the alpha one looks cooler. App ENS domains, right? Seems pretty self explanatory. What you do is you click the box right there. You type, find your name, alice ETH, if that was hypothetically still available, and then you go to register your name.
01:17:43.680 - 01:18:27.680, Speaker A: So the way ENS names are registered is there are five USD a year, as long as it's five characters or longer, and then there's gas fees, et cetera, depending on the network situation. So you might want to register for multiple years because it might save you some gas. I think currently it's not too bad, but it used to be pretty bad because Ethereum. So yeah, you register your name. It does it in two transactions. The way that works is it uses a commit reveal system, so it hashes your name doesn't really matter, but it does cool stuff, so it prevents people from front running you. So if there's anybody between you and the ENS smart contract, whether that is Wallet Connect, whether that is Infura or Alchemy, or your fancy RPC provider, or a JavaScript Library or your ISP, they're not going to know what name you've registered until you've already gotten the name, which is super cool.
01:18:27.680 - 01:18:50.002, Speaker A: You wait 60 seconds because of the commit reveal situation, and then you do the second transaction. Send over five USD worth of Ethereum, and then you have your name. This is the new Manager already. It looks super cool. I'm too excited about it, so it looks cool. You sit there, you look at this and you go, okay, how do I set my avatar? Right? It's not that bad. This is the old manager.
01:18:50.002 - 01:19:19.918, Speaker A: You go over to the Fun Add or edit your records button. You click it and then you go to the avatar, which is like down here somewhere. You set it in this case, I set it to an IPFS link from NFT Storage, and then that's it. You set your profile picture and you're done. Sweet. One last thing, and all of you are probably going to harass me for this one afterwards, but that had to be in the presentation. I'm luzman studies V, three X studies luke computer, luke Contact, whatever.
01:19:19.918 - 01:19:33.970, Speaker A: Luzmanzenl on Twitter if you have any questions. I'm also hacking. I'm upstairs at the moment. I'm building a whole cool thing, or at least planning on working on. I don't know. We'll figure it out. So, yeah, keyboard go bur.
01:19:33.970 - 01:19:51.786, Speaker A: If you have any questions, feel free to reach out to me. I'll happily take a slight break, walk around and answer any questions you might have. If after this, you go, oh, my God, I really wanted to build something with ENS or I didn't get it included in my DAP. Just reach out luke contact. It's a website. It's an actual domain. My Twitter's on there.
01:19:51.786 - 01:20:20.100, Speaker A: My telegram is on there. My email, my phone number. Yes, my phone number is on the public Internet, and my address, yeah, I have regrets. Reach out to me and I'll happily help you out. Happy hacking. That picture is off the screen, and if you have any questions right now, you can ask them as well. Go for it.
01:20:20.100 - 01:21:07.860, Speaker A: Sweet. So the way that it works is if you go to the Docs, we have a template smart contract, also on GitHub available. And essentially there's just a smart contract function, and all of the functions get called with the name the person is trying to look up. So if I write a smart contract for Twitter, NGO, or I did it on chain, what I'm doing right now for verify ETH, what you can do is the smart contract will just get called, and the function will be called with hello, verify ETH or Foo or whatever. So the smart contract gets it as a parameter. You write your logic on how to reply to that, and then the library takes that in. Hope that sort of answers your question.
01:21:07.860 - 01:21:18.278, Speaker A: Sweet. Awesome. Otherwise, I'll happily help you out. Awesome. Any others? Speak now or forever. No? Okay. You can always ask.
01:21:18.364 - 01:21:18.834, Speaker E: Sweet.
01:21:18.882 - 01:21:38.038, Speaker A: Awesome. Thank you. Wow, there's a lot of people here's. What am I building? I'm building a decentralized blue check mark system. I don't know.
01:21:38.124 - 01:21:39.270, Speaker E: Very on brand.
01:21:40.570 - 01:22:08.670, Speaker A: One of my colleagues wrote a blog post, and I said, do you mind if I built why is it $8 a month? No, it's free. No monthly fees. Work for everyone. Thank you. Very good friend for a while. Crypto, nine a while. So integrated.
01:22:08.670 - 01:23:36.184, Speaker A: I had a great question about what kind of integrations. Like, our fundamentally, yeah, you could just swap out an address, like an EMS, integrate with a program, but, like, what do you see? The problem is I'm a serial builder. Something I'm gonna, like, add it to my list. I mean, yeah, but $8 a month, you maybe, but yeah, I don't otherwise yeah. Appreciate that question. A thousand projects similar to EMS drive right now on every chain. Would you like to see? Like, we because we have the whole off chain system, all it requires is one lookup on maintenance that simply says, here's where to go.
01:23:36.184 - 01:24:03.410, Speaker A: Here's where to reach, for example, and then polygon would be on Internet. Take like, ten years to organize everyone into one. I don't want to go back. I don't want to go back. Yeah, okay. Great colon as well. Awesome.
01:24:03.410 - 01:24:21.256, Speaker A: Thank you. Nice talk. I'm waiting for your blue. Now I mentioned it, I have to finish it. I didn't say hi. Welcome back.
01:24:21.358 - 01:24:22.010, Speaker D: Yeah.
01:24:26.540 - 01:25:02.440, Speaker A: Sure. So lens has lens X-Y-T. They've ENS verified it on emet name. So the way that it works is Lens XYD has its revolver address. It points to the smart contract. The smart contract throws custom error that points to the Lens API. And the lens API.
01:25:02.440 - 01:26:16.476, Speaker A: If you walk with me in a second, I'm well, it's not for me. David gives up Lens names, but because Lens has not come up. Yes, but Open and Kevin don't have to happily either help you or do it on my own. Write a whole improvement proposal to get it standardized, and then we'll build it into the manager and we'll do everything. So we're building a project called Table Databases on chain, but our users just create tables, so we want to give.
01:26:16.498 - 01:26:17.896, Speaker B: Them a way to create collections.
01:26:18.008 - 01:26:19.148, Speaker A: And we thought ENS would be a.
01:26:19.154 - 01:26:20.048, Speaker E: Really great way because we don't want.
01:26:20.054 - 01:26:23.872, Speaker A: To deal with naming. Right. And a collection is named. So we're trying to figure out if.
01:26:24.006 - 01:26:31.136, Speaker B: ENS could basically let the user register a new collection of tables that then they can run SQL queries that join.
01:26:31.168 - 01:26:40.276, Speaker A: Them and do really cool things. That's pretty cool. Hell yeah. How long have you been working on it? Like nine months or so. That's cool. There you go. Yeah.
01:26:40.276 - 01:27:07.136, Speaker A: I'll shoot you QR code on the back. Simple. Shoot me a message and then we can chat more about it. Thank you very much. Maybe, yeah. I have a quick question. A quick question is you know how some Ethereum wallets or doing Asymmetric encryption? I was wondering because basically it can.
01:27:07.158 - 01:27:08.640, Speaker B: Generate a public encryption.
01:27:11.380 - 01:27:22.420, Speaker A: I'm wondering if there's any way currently I'm thinking about it, but I can't really so what you can do is you can result, get their address.
01:27:25.190 - 01:27:31.060, Speaker F: One thing to know, the camera won't oh, yeah. Okay.
01:27:33.910 - 01:27:48.620, Speaker A: We have a file in person kind organization. Basically, let's say.
01:28:28.500 - 01:28:29.970, Speaker F: Oh, there we go.
01:28:33.750 - 01:28:34.114, Speaker A: See?
01:28:34.152 - 01:28:37.300, Speaker D: You think so?
01:28:37.910 - 01:28:40.290, Speaker F: There we go. A little vibrating.
01:28:44.630 - 01:28:45.380, Speaker A: Yeah.
01:28:48.490 - 01:28:49.606, Speaker F: Should I just do this one?
01:28:49.628 - 01:28:49.814, Speaker A: Yeah.
01:28:49.852 - 01:28:58.050, Speaker F: People been using okay. Thank you. I brought my own too, because I'm paranoid.
01:28:58.210 - 01:28:58.934, Speaker A: Yeah, that's good.
01:28:58.972 - 01:29:03.720, Speaker F: You should just in case, like, school presentation days.
01:29:04.690 - 01:29:05.440, Speaker A: It.
01:30:00.150 - 01:30:14.950, Speaker F: Hi. Maybe I'll give it like, one more minute and then get started. But thanks for coming, everyone. This is the workshop for Covalent and the Unified API. So let's give it like a minute or maybe like 30 seconds.
01:30:24.930 - 01:30:25.342, Speaker D: Okay.
01:30:25.396 - 01:30:26.480, Speaker A: Like $0.
01:30:30.200 - 01:31:25.688, Speaker F: Okay, I think I'm going to get started. So hi, my name is Leilani. I'm a product manager at Covalent, and I'm going to tell you how to build in web3 using our unified API. So today kind of the topics that we'll cover are a little bit of the current data challenges because there are multiple ways to pull data from the blockchain and it kind of depends on your use case. But I think there's definitely some common challenges that everyone's trying to solve. What is covalent? The unified API, how to actually access on chain data for some of your builds, and then just a bunch of resources and our bounty and demos and just like a whole bunch of stuff to get you started, basically. So at Covalent, we tend to think about the next couple of years of the blockchain ecosystem, what it's all going to look like, particularly how this is all going to scale, especially when it comes to data.
01:31:25.688 - 01:32:29.208, Speaker F: So right now there's a host of different applications, multiple blockchains, and pretty soon I think we're going to start seeing use cases like health data, government data, a lot more privacy blockchains, and in some cases a lot of applications where you might not even know that it's on chain. And at that point, things require a lot of interoperability. If you've kind of interacted in this space or you have different wallets or you build applications on different chains, you might already realize some of the frictions and the challenges that happen when you try to do that, and especially when it comes to extracting data, which is what we focus on. It's all kind of messy and it's in different formats, so we think that's a big problem to solve. So if you have ran your own nodes before, maybe or built your own transformation engines, some of this stuff can be one like pretty time consuming, complicated dating can be missing and delayed. We experience that on a daily basis. Even as a decent sized company, it's challenging.
01:32:29.208 - 01:33:18.648, Speaker F: And then there's the question whether to build or buy. So this can be at an individual level if you're going to pay for monthly plans for different services or at a company level where you have a use case that maybe you want to build your own indexer, but you realize that can take like six months to a year or something to do it properly. So lots of challenges in data. That leads us to what is covalent? Basically, we are a solution to access all on chain data. And we do this currently across unofficially 50 different blockchains, officially 40. But if you want any of the hidden chain IDs, you can just ask me afterwards. So what it is, is a single API, a unified API, which basically means that you can use the same tool but just change parameters to switch from chain to chain.
01:33:18.648 - 01:33:42.980, Speaker F: It's queryable from the cloud. You actually don't really need to be a developer to use it. Once I show you the docs and how we've kind of set it up. It's pretty user friendly. You can try it live and you can pull it in analyst mode, which means you get a CSV or like a spreadsheet that you can put into tools like Tableau or Power bi. If you are an analyst, or if you're looking at building something that requires analytics. Maybe for this hackathon.
01:33:42.980 - 01:34:46.008, Speaker F: And the best thing about this API is that you can pretty much build a multi chain application in minutes because all you have to do is change that one parameter. So, types of use cases with covalent today basically we crawl all the smart contracts on every single blockchain that we index. So we fully index the current and historical data, which means that the types of use cases are pretty endless. You can just kind of use any on chain data that you want, you just have to know how to get it. So we have quite a few out of the box endpoints for things like token balances transactions, historical transactions, NFTs, but you can always go through the log events and you can get a little more granular. And we also have different developer tools like Primer that you could use to specify your queries even more, but we see a lot of DeFi dashboards, NFT galleries, crypto, wallets, some dao tools. So if you are maybe not decided on what you're building, covalent is always a pretty good bet because you know that you'll be able to get some data for your project.
01:34:46.008 - 01:35:23.184, Speaker F: I don't know if that's the use case or if people already have an idea, but just thought I'd mention it. So how does it work? Basically we're kind of this data layer in between blockchains and nodes and then the actual applications that people are using. So for developers, you don't always need to interact directly with the blockchain. We're a read only API. So basically any data that you want to pull into your project, you don't need to necessarily be running your own nodes or paying for that to do it. You can just use our free API to pull all of that easily into your project and then support your applications. So the data layer we think is pretty essential to the crypto stack.
01:35:23.184 - 01:36:11.044, Speaker F: It's also something that helps everyone scale because you can build applications faster, basically and easier. So that's the goal. And yeah, we see this supporting a lot more users on chain and a lot more applications that are interoperable as well. Because if you've built your own kind of transformation engines in the past, then you either need to build that whole thing again for a different chain or you need to make changes maybe in the pipeline that cause you to reload all of that data. And with us it's instant, so it's a lot easier to kind of be creative, make some quick changes and build something different. So this is how it works basically, we run indexing nodes that take in all the data from different blockchains. Here's like a selection of some of them.
01:36:11.044 - 01:36:52.172, Speaker F: But I'll show you our API reference which shows you all the supported networks. And then we basically format them into a couple different classes of endpoints. So the most popular is class A endpoints. Those are basically just queries that you can make on any single chain that's supported. So questions like get token balances for this address, it returns all the balances for that address instead of querying it like token by token, it allows you to do your taxes. You can pull like NFT data, you can pull NFT metadata, so you can show up the images and the video URLs and all of that stuff. And then we have class B endpoints.
01:36:52.172 - 01:37:41.548, Speaker F: I'll go into these in the doc so you can actually see it. But class B endpoints are basically protocol specific. So we have one suite which is really popular, which is for Dex data. So basically most decentralized exchanges, or a lot of them are clones of uniswap. So like Spirit swap, Stella swap, Pancake swap, all of the swaps you can pull through those endpoints, you just have to change the Dex name in your query. And then we have something really exciting which is actually testing internally right now, but we're bringing a couple of people on that are interested in this to basically go through this process of building their own endpoints. So we realized our limitations with having these kind of like out of the box, easy to use endpoints was that sometimes it's hard for people to make specific queries or support specific use cases or just access the data that we have, but it's not packaged.
01:37:41.548 - 01:38:22.056, Speaker F: So class C is going to be solving that, building those through SQL and then saving your own endpoints. And that's going to launch pretty soon, but it's working. So if anyone's really interested and has like a burning use case, talk to me afterwards. Yeah, here's some of our users, currently over 40,000 developers, which is a pretty big chunk of the ones in this space. I don't think all of those are active, but that's like the history to date. And yeah, we're powering a lot of wallet applications, some tax use cases, currently some web, two companies that are more interested in adding crypto features to their projects, so it's pretty cool. And then yeah, basically support 50 blockchains.
01:38:22.056 - 01:39:01.050, Speaker F: Again, you won't see every single one of those on the reference because some of them aren't QAED, but you can unofficially support them. If we haven't done a marketing launch, we had a hackathon guy from ETH New York that built his whole project on a chain that wasn't exposed, but he knew that we supported it. So if you know the ID, then you're all good. Okay, so here's the bounty information. We're offering $5,000 for any projects that integrate the API in a meaningful way. So basically we judge that on three points. One is the feasibility or the quality of your use case if it's actually new and solving something for somebody and it's interesting.
01:39:01.050 - 01:39:40.880, Speaker F: And then two is the complexity of the endpoints you use. So how many the way that you integrate Covalent, how much basically instead of just like copy paste, although you can use our code templates and copy paste, you just want to make some stylistic changes maybe. And then three is just like the overall quality of the project. So things like design often stick out and stuff like that. So some ideas and I'll show you some past examples as well because I think we have lots of time. NFT storefronts are great on chain analytics, really easy with Covalent. Wallets are always an easy use case, anything tax related, you can get historical transactions.
01:39:40.880 - 01:40:07.308, Speaker F: And we do have a pretty new way to crawl historical transactions if you're looking at doing that at scale across any different chain. So I can walk you through that as well. Myself and my colleague Kia, who's here in the back are going to be just walking around all day tomorrow. We're not at a booth, but we'll show where we are in case you want to find us. Okay, so I'm going to open up the links. There's basically three primary resources. One is our knowledge base.
01:40:07.308 - 01:40:44.812, Speaker F: So that has things like tutorials, how to guides, example projects from past hackathons so you can get inspiration from that as well as just like general API info. And a second is our API reference. That's where you can actually try all the endpoints live and see what the response looks like. And then three is our code template section. So we have a repo on GitHub now that has a bunch of different components, code alongs or anything that you can basically fork and make some changes to. So it's an easy way to get started on a build as well. I think I'm going to basically go into those now.
01:40:44.812 - 01:40:53.276, Speaker F: So here is our knowledge base. So this is the first link, the API docs when you first go to it.
01:40:53.298 - 01:40:53.436, Speaker A: Yeah.
01:40:53.458 - 01:41:21.460, Speaker F: Okay, it looks normal on here. So you get to this from our website covalenthq.com slash docs. And then you'll land on the overview here. So it's going to tell you everything that I just did. But you can also scroll further down, see some of our launch updates, our chain supported networks, and this is probably the most relevant section. So developer tools, you can go into some of the examples how to use WebSocket connections for notifications from log events.
01:41:21.460 - 01:42:21.092, Speaker F: You can enable Covalent and postman if you're familiar with working with that environment. You can learn about Primer, just how to further specify your queries, or you can just go into any of the supported networks and learn a little bit more about those blockchains. So you can also go to the API reference from here, which is that second link where you can actually try endpoints live so I kind of did it before just because I always get really paranoid about Wi Fi, these things. But here's the class A endpoint so the categories here we kind of just bucketed them into common use cases. So balances like token balances if you want any sort of wallet use case and you need ERC 20 transfers, change in token holders, anything like that, it's in balances. And then NFT use case you can pull in again like all of the assets and the metadata that you need to build cool things. That was general transactions.
01:42:21.092 - 01:42:53.750, Speaker F: So you can get a transaction and get really detailed logs or you can get transactions for address and get all of the transactions for that address and then base. So like get a block, get all the chains that we support. For instance, this will give you all the chain IDs. These are just kind of like your building blocks for anything you want to do. And then for those Dex endpoints that I mentioned here's, a whole bunch of them. So you can get all of the liquidity pools, basically all of the dex data that you might need, token pairs, their prices, all of that.
01:42:54.280 - 01:42:54.644, Speaker A: Yeah.
01:42:54.682 - 01:43:42.420, Speaker F: So this is kind of like a sample response of what balances will give you. Again, I mentioned you put in wallet address and it just gives you all of the different tokens that is held in that address and it'll give you some with a balance of zero as well because we built this basically like a bank account. So if you've ever had that asset it shows up, you might not have it right now but it'll just give you everything because it's like a small window. I just pulled open the JSON and what you would get here but basically you just get all the tokens which is a really efficient way to call it. And then now moving on to our web3 resources. So this is our web3 resources pack. I think I have a QR code on this next slide afterwards when I go back so it's easier to find the link but again, just feel free to ask me anytime.
01:43:42.420 - 01:44:26.556, Speaker F: Also if you like this, would love it if you started. But basically this has our templates so you can make like a Dex dashboard, you can use all of that code and you can stylize it, you can make price trackers, you can make a mobile app. We have code along videos so depends kind of on your level. If you're a beginner, these can be really helpful or if you're referring people into blockchain, it's also a good resource. And then we also have an integration with third web who are some great partners of ours too. And this will link you to the web3 components library so more things that you can use. So basically we have a token balances component, a token transfers and then a token holders.
01:44:26.556 - 01:44:56.524, Speaker F: So these are what they look like. Basically. It works with ENS as well, which is always what I do because I hate copying addresses. So you can just put in like demo ETH for example, or whatever your ENS name, and it'll show you all of your balances as well as the logos, the type of the currency, the contract address. So pretty much build a wallet pretty easily out of that alone. And then you can integrate the, ERC, 20 transfers that that address has had and also like, the token holders for each of those different tokens. Yeah.
01:44:56.524 - 01:45:21.392, Speaker F: So where are we? I think there we go. Oh, past submissions. So while we have time, just because I thought it was cool. We do a lot of ETH global hackathons and sometimes I think it's cool to showcase what people have built or give others ideas. So these are a couple ones from ETH New York, which was a really great hackathon. So it'll just show you some example projects. This one's called Dow Dash.
01:45:21.392 - 01:45:56.320, Speaker F: So they basically used our log events endpoint went through to get really detailed Dow information to see how much people are participating in the governance votes, for instance. And based on that, and based on people's on chain involvement in a Dao, they could grow these little trees and grow these little people. So it's kind of like a tamagotchi but for Dao participation, which I thought was really cute. This one's. Brent NFT. Loved the name on this one. It's awkward if these people are here and I'm shouting out their projects, but this one basically allowed you to lend an NFT.
01:45:56.320 - 01:46:38.792, Speaker F: So sometimes events are like token gated, for instance, or there's other perks that you get by being a holder, but you might not want to buy that specific NFT or it might cost like $100,000. So what you can do is actually rent them. This was an integration using our data to display all the front end and then with Gnosis as well, where you could basically rent it for 24 hours, get into whatever you want to do and then give it back, which I thought was cool. Block Stories was a really good kind of like front end overlay with our data. So there's a big problem of human readable data in Blockchain. A lot of it's just really confusing. The terminology is quite a steep learning curve.
01:46:38.792 - 01:47:11.456, Speaker F: So Block Stories built this using our transactions endpoint where you could go in basically like open source, add information to a transaction to make that a little bit more meaningful on the chain. So you could go and search and find that this person sold this to this person and it's written in words. You can see the most traded punk, for instance, or other things like that. I'm kind of doing them a disservice by describing it all very slowly, but just thought it was cool. And then this was awesome. This was actually an ETH new. York finalist Wi Fi.
01:47:11.456 - 01:47:39.312, Speaker F: There we go. So they basically built like a simulator that you could add to MetaMask that would show you whether or not a transaction was fraudulent or dangerous. This is also a pretty big problem because blockchain transactions are super permanent. So you can send money to a burn address, for instance, and never get it back. So safe node. Basically, you just attach it to MetaMask. It simulates the transaction, shows you, like, dangerous addresses that might have interacted with Mixers before or anything like that.
01:47:39.312 - 01:48:03.130, Speaker F: So they used our data to simulate that. I can always go through other submissions if you want to find me tomorrow, but that's our developer resources. Hopefully the QR code is big enough. I also realized I'm not full screen. So there we go. So that'll take you to the GitHub Library that has all of those components and stuff. But from there, there's also links to the website.
01:48:03.130 - 01:48:20.270, Speaker F: I'll leave it for like, a couple more seconds and then thank you. That's all. If you have any questions, let me know or find me walking around afterwards. That's it?
01:48:21.040 - 01:48:21.790, Speaker A: Yes.
01:48:45.490 - 01:49:12.582, Speaker F: Yeah, it's a good question. There's definitely a lot of indexing services. It's kind of more about how they, I guess, translate the data to the customer. So for us, the biggest differentiator is that we're like an ELT data pipeline. So instead of others, where it's ETL extract, transform, and then load. In that case, basically, you build your entire project and then you load the data in once you've created that custom query. So it means that there's a little more wait time in getting that data.
01:49:12.582 - 01:49:45.842, Speaker F: And you have to be specific about creating that engine. And then you also have to do that separately for each blockchain that you want it to be on. Whereas our approach is to have an ELT framework, which basically means we load all of the data from all of the different blockchains everything into a database and then just make that accessible through the API, which is the transform level. So basically there's never any waiting, there's never any complex code that you need to write. And you can switch between chains really easily. You can loop through all of the different chains that we support. It's also free.
01:49:45.842 - 01:49:54.566, Speaker F: That's a big differentiator, too. Yeah. Does that answer a question? Did you have one?
01:49:54.668 - 01:49:55.320, Speaker A: Yeah.
01:50:17.270 - 01:50:45.994, Speaker F: Good question. I'm maybe not the best person to answer that because I wasn't there when they built Rest. But yeah, I think it's just easier with our setup to use. But we do actually have someone on our team has now built the API using GraphQL, and they've replicated everything just to expand to that language. I think for us, it was more like an addressable demographic. There was a lot of people that liked using Rest and found it enjoyable, so we did that. But yeah, there's other options as well.
01:50:45.994 - 01:51:18.600, Speaker F: In case you want to use GraphQL. It's all free right now. So we're launching a pricing like a paid tier, but we're only going to do that with certain endpoints that can really scale. But it's free. It's always been free. There will always be free. Yeah, basically we can support most use cases apart from we kind of hit like a limit from companies that have thousands of users and that's why we're creating a pricing tier, but it's not going to affect any other developers that are doing what they're doing today, basically.
01:51:18.600 - 01:52:07.722, Speaker F: Yeah, good question. Yeah, typically it's pretty easy to integrate because everything is so out of the box. It takes like a day, basically, so there's not a lot of maintenance costs or anything like that because you don't need to change your queries or like you don't need to reload any data. You don't need to pay for anything. I mean, if you are at that enterprise level, for instance, then we can talk. But yeah, the switching cost is typically really easy. I mean, most people we index blockchains in a matter of a week.
01:52:07.722 - 01:53:09.864, Speaker F: So if there's something else that you want us to index that we don't, and it's EVM, sorry, I should really clarify that it's EVM because non EVM takes months. But yeah, switching costs are really low. Yeah, yeah. So because we have a free API and we've had that for years, we have accumulated quite a fair bit of bot traffic, which is really kind of the downside, which means that we just have to be cautious with our rate limits. So the whole API is basically limited at four to five requests per second. So it's enough to do like, medium size kind of projects and companies, but not hammering our system millions of requests at a time from different users. But that's, again, kind of why we're creating that enterprise tier or that paid tier, because we've rebuilt a lot of the endpoints that we've had for years to just be a lot faster and lighter weight.
01:53:09.864 - 01:53:34.580, Speaker F: So once those launch, then some of them already, like our new balances endpoint, for instance, it's not publicly exposed, but that just doesn't have a rate limit because we've just built it in a different way that scales. Okay, if you have any more questions, I'll be over there for a bit and then I'll be around tomorrow all day. So, yeah. Thank you guys for joining.
01:54:24.160 - 01:54:39.070, Speaker A: Oh, yeah, there is it.
01:54:56.090 - 01:54:57.080, Speaker F: They are.
01:58:32.020 - 01:58:32.770, Speaker A: But.
01:59:12.840 - 01:59:14.430, Speaker B: You we need.
01:59:28.070 - 01:59:29.380, Speaker D: At one point it was.
01:59:53.810 - 02:00:39.100, Speaker G: So we're at about time. So we're at about time. So I'm just going to quickly go over how to add a uniswap widget into your site, if you're interested. And then afterwards it should be very quick and simple. And then afterwards, if you have any questions about how to integrate uniswap or how to use any of our other APIs, I'm happy to answer them or to just go over a few of the docs to show you where to look for answers? Yes. Is this better? Yeah. Okay.
02:00:39.100 - 02:01:17.500, Speaker G: So to make integration with Uniswap really easy, uniswap exposes a big chunk of the swap API in a widget. So the widget is just for swapping, it's not for Lping. You can find the repo@github.com slash Uniswap widgets and it's also on NPM. There's initial instructions for using it right here in the repo as well as branch to use it on create react app. And NextJS it is a react component. And then just to show you how simple it is, this is a create react app.
02:01:17.500 - 02:02:13.030, Speaker G: I'm just grabbing the window ethereum object. If it exists, initializing it with Ethers, passing it into the app, and then it's really just one line. Swap widget with the provider. You can add a bunch of other parameters to it. You can give it a default token to start on. You can use it as a controlled component instead of an uncontrolled component, where you would be able to listen to events like when a token changed, and then update the token appropriately. But what that gives you I lost it.
02:02:13.030 - 02:03:21.850, Speaker G: What that gives you is this. So if you have nothing connected, it takes care of wallet connection for you. Just connect that so there's a MetaMask connection and then it'll read out to you. Looks like I'm on sello. Get out of that. Let's go to main net, it'll give you your bounce and it will let you trade, including giving you the current price when it fetches. So, outside of this, Uniswap also has a whole doc site to introduce you to its contracts and the SDKs to work with them.
02:03:21.850 - 02:04:40.860, Speaker G: I can go over them briefly, but does anyone have any questions? This is really more of an FAQ than a directed. I started trying to go through the V three SDK to prep a demo, but really what we do on the website isn't following this v three SDK Quick guide. Sorry, the Internet is not very fast. What we do in the website is we actually mock trades through a client side router, which I believe is a public repo that you could use if you wanted to in your project. So we mock those trades and then use that to give you a price that it's going to run at, which is where a price like this will come from. Is anyone planning on using Uniswap SDKs in their hacker projects today? Cool. Do you guys have any questions about how to use them? I can point you to Docs, but a lot of the work that I do is around swapping.
02:04:40.860 - 02:05:21.420, Speaker G: I would recommend using this guide. Guide providing liquidity over the V three Quickstart guide, which I haven't looked through, so I don't want to just read this from the podium. Um.
02:05:30.900 - 02:05:31.600, Speaker A: Yeah.
02:05:31.750 - 02:05:55.050, Speaker G: So if you have your own project and you wanna if you have your own project and you want to make it easy to trade tokens into whatever ERC, 20 your project is using, you could use the widget for that. If you have your own project and you want to encourage Lping, you would need to do something more sophisticated. Use the contracts directly or link out to uniswap to do that.
02:06:20.950 - 02:06:21.314, Speaker A: Yeah.
02:06:21.352 - 02:07:37.820, Speaker G: So if you want to make it easy to trade a specific token, the easiest way to do that would be to grab the widget and just put it on your website and lock it into that one token. If you look at the Friends With Benefits website, I believe they do something very similar with our widget where they just let you use it directly. If you want to do something different, like just have a little info blurb where it says the current price that it's trading at, that would require you to integrate directly with the contracts and pull that yourself. So basically, if you have a need that's not the swap widget as it is, we would love to hear it and maybe meet that need over time. But right now the swap widget is just this guy and this works cross chain, so we're actually using it on the website itself. If you look at tokens, this guy on the right side is the widget. It does not do bridging, so it can only trade within one chain.
02:07:44.360 - 02:07:45.110, Speaker A: Cool.
02:07:46.040 - 02:08:20.640, Speaker G: This is short and there's not that much else to go over. So I'm going to bring up the POAP code if you want to grab that before you leave. If it loads, what.
02:08:56.320 - 02:08:57.230, Speaker D: Is that?
02:08:59.520 - 02:09:50.350, Speaker G: And I'll be at the uniFLOW booth for today and tomorrow if you have any questions. If you have more specific questions about the docs, feel free to flag me down. I'm happy to go through any of our interface code and talk about how it works. I can't do that's.
02:41:57.990 - 02:42:48.820, Speaker E: You could just open up this conversation here, send the message and then we're going to also want to pretty print something and I have some very helpful render methods here to just give you some very pretty text. And so this should be all you need to send a message on the Xmtp network. So this is built and let's try and send a hello world message to myself. So Xmtp send, this is my wallet address, hello world. And look at that, it's sent. And so I could check in the Xmtp chat app. Here it is.
02:42:48.820 - 02:43:50.560, Speaker E: And I can respond from any app in the Xmtb network, so that's great. Now we want to be able to see all these messages. So there's this list messages endpoint, so want to not throw an error here and instead we're going to go through the same first couple of steps and create a wallet and open up a conversation just like that. And we are going to get all the messages. So once you have a conversation, one function call to get the entire history between the current wallet and the address that this conversation is with.
02:43:52.930 - 02:43:53.614, Speaker C: And give.
02:43:53.652 - 02:44:18.200, Speaker E: This a nice title, since we want this to be a pretty and usable CLI. And we have this render method here that is going to render the message list. And so doing that, we should be able to see the list of messages in the CLI. Let's give this a try.
02:44:21.060 - 02:44:21.824, Speaker A: Oh, look at that.
02:44:21.862 - 02:45:05.060, Speaker E: We got a Hello, World and my response from the chat app. So that part totally working. So next up, we might want to stream messages. So you could just pipe messages into your terminal, know? Anywhere that they're coming in, whether know Lenster or the Xmdb chat app or the chat app that you're building, maybe it's someone else with the CLI. So streaming the messages in a command line application takes a little bit. More trickery. So we are going to get a conversation stream here.
02:45:05.060 - 02:45:58.828, Speaker E: Let's just do that. So notice the conversation class has this nice stream, all messages, which is going to give you every message from every address that might be sending you messages. This is going to give you an async iterable which we can then pass into a react component to do something with it. So we're going to do that, and then we'll go into how you might show a stream both in a command line app. But also, this is very similar to how we would do it in a web app. So we have these slick little renderers here. So this is a renderer for a message stream and it just has some messages, but takes a stream as an argument.
02:45:58.828 - 02:46:42.210, Speaker E: And we want to take that and actually listen continuously for new messages as they come in, update the state, and then it's going to show this message list with the updated set of messages. And so let's try that. So I've written this little use effect hook. This would work just the same in a browser as it does in a command line. Application because I'm using Ink, which is just a magic library for building slick CLIs using React. And so this could go into any sort of React component. Let's maybe go through what I am blindly copying pasting in here.
02:46:42.210 - 02:47:43.610, Speaker E: So it takes a stream which is an async iterable and it's just going to do 408 message of stream and it's going to check and see if we've already seen this message since it is possible in some of these streaming methods that you get a message twice. We don't guarantee exactly once delivery. So assuming that we haven't already seen this message, we're just going to add it to the message list, and then we're going to keep track of it so that we don't add it to the list a second time. Going to call this and it's always very helpful when you're dealing with streams in react if you clean up when the component unmounts so that it'll disconnect from the network and make sure this thing doesn't keep going. So we should have all the pieces in place. Maybe not quite all or I just forgot to hit save.
02:47:44.220 - 02:47:45.210, Speaker A: Let's see.
02:47:49.460 - 02:48:30.954, Speaker E: Okay so there's no messages here since nothing has come in since we opened up this stream. So let me send myself a message and see if it shows up. Which it did. Great. One more just for fun. And we have a stream of all these messages so with these pieces you should be able to send, receive and stream messages right over the command line. Maybe helpful to go into what we didn't do in the last 15 minutes.
02:48:30.954 - 02:49:53.190, Speaker E: One of the big gaping holes here is that I'm just randomly generating a wallet and saving the private key to a file on your computer for both security and practicality reasons. That's not how you'd want to go out and build a hackathon winning CLI. And so one of the corners that I cut is this key management problem but if someone were to go out and want to win some prizes with an Xmtp CLI you should be able to just create a web app using rainbow kit or Wagme that will get a signature from your wallet. And then we have this very nice method in the xmtp command line interface that is in the Xmtp SDK that is going to let you get the xmtp key pair out of that wallet. So you can have this little web app that gets a signature from the wallet and you run client get keys. And now you have an xmtp key pair that you could pass back to your CLI that would be a safer thing to maybe store on an individual developer's machine. And you could reuse that for both sending and receiving messages.
02:49:53.190 - 02:50:10.814, Speaker E: And so how you get that in between the web app and the command line interface that's up to you but should be very possible and would let you make a really nice user experience. So I think that is all I have for my talk today. Does anyone have some questions?
02:50:11.012 - 02:50:11.870, Speaker A: Shoot.
02:50:12.450 - 02:50:14.240, Speaker B: How long do you store?
02:50:18.170 - 02:51:20.636, Speaker E: Yeah, that's a great question. So conversations today are stored indefinitely and are paid for by us as we're running all the nodes in the network. As this decentralizes we're going to have payment for messages and those fees will be distributed to the people who are running the nodes. Not today but that's clearly something we are very actively working on. Any other questions? Yeah, it's obviously something we are thinking about a lot. We can't commit to anything just yet but it's a very important part of making this a self sustaining network and so we got people really studying and trying to figure out how we balance both the user experience and the sustainability of it. Goal is for this to be so cheap that an application developer could subsidize it on behalf of their users.
02:51:20.636 - 02:51:22.450, Speaker E: That would be the ideal state.
02:51:32.090 - 02:51:32.454, Speaker A: Yeah.
02:51:32.492 - 02:52:02.400, Speaker E: So the nodes right now are running Waku which is built by the Status team as a decentralized messaging protocol that we are building. On top of they have a storage system which we've written some improvements to to make it pretty scalable. So we can throw quite a lot of traffic at our nodes and they are holding up just fine. But it is Waku with a custom store and that may be subject to change but that is the network that we're running right now.
02:52:04.370 - 02:52:05.120, Speaker A: Sure.
02:52:13.380 - 02:53:03.356, Speaker E: Oh yeah, that is a great question. So we have a very flexible content system. Most of the messages on the network happen to be text but you can write your own codec and store anything that can be serialized to bytes and so you could store images. People are storing images on the network already. You can build application specific content types. We also have this XIP process where if you have a content type that you think is really special and great and other people should use it, you can put together an XIP, propose that this become a standard and get other developers to make their apps compatible with your custom content type. We also support fallback text, which is just plain text.
02:53:03.356 - 02:53:36.740, Speaker E: So if your app encounters a message in a format that it doesn't understand, there can be a safe fallback so that we can have some consistent user experience. When there's people doing experimental new content types, latency is quite fast, like in the hundreds of milliseconds to get a message to you. There is some rate limiting people don't hit it, their rates are quite high. So unless you're a bad actor or trying to really do something abusive to the system, rate limits aren't something you probably have to worry about.
02:53:39.110 - 02:53:40.100, Speaker A: Oh sure.
02:53:53.320 - 02:54:16.190, Speaker E: Yeah, everything is off chain, but it is persisted and we're committed to destroying messages for a long time in our network and the only time we would remove those guarantees is if we had a better solution where the messages could be stored elsewhere for a long time. But it makes for a really nice user experience to be able to open up any Xmtp app and get your entire messaging history.
02:54:16.720 - 02:54:17.580, Speaker A: Shoot.
02:54:37.580 - 02:55:24.410, Speaker E: Yeah so I think we tackle this in a couple of ways. One is just making sure that we're doing everything we can to enable interoperability at the SDK level, documenting things very clearly. So for example, in the case of the Lens ecosystem, we have this concept of a conversation ID that can be used to group together conversations. The Lenster app is the first app to use a new spec that we have out for a Lens Protocol conversation ID. And then we're getting other members of the Lens ecosystem to adopt that consistent naming for conversation IDs. And just with that one little bit of consistency, all those apps become compatible with one another if they start introducing content types. That's where the XIP process comes in.
02:55:24.410 - 02:55:41.280, Speaker E: And that is social consensus. And we can work with developers that if there's a content type that is really good and feels universally accessible, that we can get everyone to adopt it or potentially even include it in the SDK if it really feels central.
02:55:42.820 - 02:55:43.570, Speaker A: Yes.
02:55:46.740 - 02:56:37.040, Speaker E: Oh yeah. So there are some people who have built some hacky ways of doing multiparty messaging on top of one to one messaging where you would just send each individual participant and you have some sort of conversation ID and then you can kind of hack it together. The version of the SDK we launched this week would make that hacky solution better. But we are thinking about how we can do really great native support for group messaging. We certainly wouldn't make that very easy for you. The network just treats messages as bytes and so the nodes don't put any constraints on it because an encrypted piece of content is indistinguishable from noise. And so we can't check that it's encrypted.
02:56:37.040 - 02:57:22.102, Speaker E: But the default behavior is end to end encryption and we haven't seen a lot of demand for people asking for anything else. Yeah, so it's become a little more sophisticated than that. We actually have conversation scoped keys. So me and you, we're having a conversation. I send you a message that is encrypted using your public key and version of Signals X three DH. But then I send you this invitation. It's a totally random key and we use that in the scope of this conversation.
02:57:22.102 - 02:57:58.130, Speaker E: That's also how we could store the messages on a random place in the network. And so there's a little pointer in there that says, hey, when the two of us are talking, we will talk on this random topic ID. And that's how we get some of the privacy guarantees out of the protocol. Exactly. And that means that when us someone who can look at all the messages on the network, we have really no clue who's talking to who in these messages because the topic is the only thing that we can really see. And that's random.
02:58:00.630 - 02:58:01.380, Speaker B: Yes.
02:58:01.910 - 02:58:06.980, Speaker E: So you would send one copy of each message to the topic for both parties to be able to read it.
02:58:07.510 - 02:58:08.260, Speaker A: Yeah.
02:58:14.820 - 02:58:27.430, Speaker E: So we have some researchers working on how we're going to do group chat. We have some really cool stuff that I wish we could talk about, but not just yet. So right now, all messages are one to one.
02:58:28.300 - 02:58:29.050, Speaker A: Sure.
02:58:39.320 - 02:59:28.210, Speaker E: Oh yeah. So the way that it works right now is we have an Xmtp specific key bundle and your private key, and we create an encryption key for that using a signature from your wallet and a nonce. And then we encrypt your private key and actually store it on the network. And so everyone's private keys are on the network, they're just encrypted. And so when you come in with a new device, you can just sign the same message, get the decryption key and pull down your encrypted key bundle and decrypt it on your machine. And so makes for really seamless transition between devices because a lot of us use Web Three in things like mobile wallets where you don't have persistent storage available. And so the default use case is basically a recovery use case.
02:59:28.210 - 02:59:38.560, Speaker E: I am out of time here. I think I got to give up the room. All right, thank you guys so much.
03:00:28.740 - 03:00:31.890, Speaker A: Type. Yeah, we just have.
03:00:33.940 - 03:00:36.370, Speaker E: API. Like, you can.
03:00:40.950 - 03:00:41.682, Speaker A: Encrypt stuff.
03:00:41.736 - 03:00:44.546, Speaker E: And so, yes, you absolutely could put.
03:00:44.568 - 03:00:47.362, Speaker A: A message on the topic without encrypting it.
03:00:47.416 - 03:00:49.794, Speaker E: It would be a little fussier if.
03:00:49.832 - 03:00:54.810, Speaker A: It'S a lower level method, internal method, but it is.
03:00:55.000 - 03:00:56.940, Speaker E: So yeah.
03:01:15.660 - 03:01:22.770, Speaker A: Like, let's do we're here. Let's do that whole thing.
03:01:24.660 - 03:01:26.400, Speaker D: So it's it's already not there.
03:01:26.470 - 03:02:01.766, Speaker A: All right, but is it mirrored? It's mirrored, too. I'm not really sure how it does it on the I don't really ever use it. Yeah, look, this is less warm, though.
03:02:01.948 - 03:02:03.542, Speaker G: Oh, that's on you right here.
03:02:03.676 - 03:02:05.462, Speaker A: Yeah, but it's only doing it here.
03:02:05.516 - 03:02:06.120, Speaker C: Yeah.
03:02:08.650 - 03:02:10.280, Speaker D: It'S fine. I mean, it's fine.
03:02:13.370 - 03:02:28.220, Speaker A: It's because it's coming out of your external because it's mirroring right now. So maybe if I 1 second. Let's try it. It's okay. We'll figure this out.
03:02:30.750 - 03:02:31.500, Speaker C: Still.
03:02:34.190 - 03:02:39.662, Speaker A: Trying to trick it to tell it not to do it. Let's try something else.
03:02:39.716 - 03:02:42.580, Speaker D: Sorry, guys, we might have to stick with a very orange screen.
03:02:43.910 - 03:02:48.034, Speaker A: I could Google it real quick. No worries.
03:02:48.072 - 03:02:48.514, Speaker C: We got time.
03:02:48.552 - 03:02:51.374, Speaker A: You're fine. Someone chasing us. No one's.
03:02:51.502 - 03:02:53.250, Speaker D: I just saw someone who's, like, right after me.
03:02:53.320 - 03:03:06.970, Speaker A: It's okay. They'll be custom still, right? I don't know. I'll look it up and tell you after.
03:03:07.120 - 03:03:11.530, Speaker D: Thanks for trying. And then do I just start whenever.
03:03:16.510 - 03:03:19.318, Speaker A: Make this totally independent.
03:03:19.494 - 03:03:20.220, Speaker D: Okay.
03:03:21.390 - 03:03:49.316, Speaker A: Part one is there's more to it than that, but that's the best way to start. And later on down the road, we'll get into basically being able to add a proof, if you will, or an.
03:03:49.338 - 03:03:52.756, Speaker B: Accusation to a message itself, which can.
03:03:52.778 - 03:04:08.470, Speaker A: Then prove the network that it's about.
03:04:21.860 - 03:04:40.660, Speaker D: Hello, test. Okay, welcome to our do workshop for Ethf. Sorry. For some reason, my computer just decided that it wants to be in the night mode and it wants to sleep. So we're going to just go with this today. So my name is Jackie. I work as wizard relations.
03:04:40.660 - 03:05:07.784, Speaker D: So basically developer relations for Dune. I go by Agape online. And then I guess a little bit about my background. I used to be a developer for banking and then decided I want to do more data stuff for traditional finance. And then I found out about crypto, and I'm just like, oh, my God, I need to be in this field. And then I just started doing like when you do Web Three data, you cannot help but run into Dune, basically. So that's how I found out about Dune.
03:05:07.784 - 03:05:41.850, Speaker D: And then here I am working for Dune. So today we're going to go on a journey about how to build the frontier of Web Three data analytics. Okay, so if you want to follow along, there's like, links and stuff. This is the link for the slides itself. So I put some reference docs links there. I'll leave it on for like a few more seconds for you guys to scan. Put this a little lower.
03:05:41.850 - 03:06:09.424, Speaker D: Okay, cool. Looks like we are getting there. Okay, cool. Okay. Data, right? So up till now, the data in the old world where, like, the Web Two world where Harold lives thing, right? It's like, proprietary. You have to pay for the access, and it's very slow. So think about, like, I don't like JPMorgan, these big banks, everything for them is super close.
03:06:09.424 - 03:06:47.420, Speaker D: They want to make sure that they have the best competitive advantage so everything is preparatory for them. Close. And then you need to pay like Bloomberg. It's very expensive, right? Like, if you have a Bloomberg machine for your analytics, and then if you think about, oh, there's always talks about earnings, seasons, right? Like, you have quarterly reports, so you don't really have real time data about your firm, like the industry per se. So as a result of that, you're doing a lot of repeated work. So that could be like, data scientists from two different big banks, they might be working on the same project, but they're not really collaborating with each other and learning from each other. And because it's so expensive, you don't really have access to good data.
03:06:47.420 - 03:07:19.140, Speaker D: So it's like high barrier to entry. And as a result of all of this, it's just like less innovation for humans, for people who are interested in Web Three data in general. Crypto, though, on the other hand, we have a shared public back end, right? And then we are able to have a live view of the chain. So it's like real time. You can see what exactly is happening with all the transactions. Anyone can analyze it real time, flexible, and it's super collaborative. We're all building toward the same goal.
03:07:19.140 - 03:08:04.096, Speaker D: So as a result of this, a result of a super open system, a collaborative system, and everyone's building on top of each other, right. Real time. I would argue we would argue that the Anon crypto paper actually has better access to data about their system than, say, Jamie Dimon from Morgan, right, because of the crypto ethos and the way data is set. So for me personally, that was one of the big reasons I got into Web Three data. It's just like, for me, for the first time in history, I see, because before it would be like, kaggle, if you're a data scientist, it'll be just like, okay, Kaggle, we have free data, then we can train models. But now it's like, we have real data about blockchain. It's free and it's real time, and we can just like, everyone's building toward the same goal.
03:08:04.096 - 03:08:54.484, Speaker D: And that. Just really excited me. Okay, so how does Dune fit in with the whole Web Three data thing that we're just kind of talking about? So Dune is a leading community powered crypto data platform. And then our mission is to make crypto data accessible to everyone. So kind of assuming if you're here, you're interested about Blockchain and you hear about how Blockchain is open and everyone has access, but if you actually look at it from a node to when you can actually produce analytics, the journey is quite a lot, right? You have to first harvest the data and then you have to preprocess it to be the format you want. And if you do analytics, it's just like quite a lot of work in between actual data and then the data that's being produced from Blockchain. So what Dune can provide for you is that so basically in aligning with the Web Three Ethos, it's open to everyone.
03:08:54.484 - 03:09:22.732, Speaker D: It's composable. So you can building Lego style, you can build on each other's work. I can show a little bit more later and then it's very community driven. So everyone is here to build with everyone else and we're all here to help each other. So that is dune together with the web3 ethos. And a bit more specifically, the way I think about Dune is like two component. So you've got the data component which has the role tables, the decoded tables, and the spell book we call them.
03:09:22.732 - 03:10:05.896, Speaker D: They're like abstractions that are built on top of the role tables and decoded tables. I'll give you some examples, like later on right after this. So that's like the data side and there's the community side. So we call our community members wizards because they're just like making magic to the data. So they're like an essential part because if you think about it, when GitHub become really popular, you got these open source coding that's happening. So everyone's like open source software, right? And that's how we got to the space to be where we are today. And we're so early in the open source data field, right? So it's like tens of thousands of people eventually, hopefully millions of people are just like here and building the data analytics, right? So before this, people don't really think about engineering.
03:10:05.896 - 03:11:03.692, Speaker D: We're building data analytics, but we can because we have the same shared back end and why not? Okay, so for the rest of the talk, just going to kind of explain how you can use Dune to build the frontier of Web Three data through kind of like three different ways. They're not independent, they actually feed into each other, but just categorically speaking. These are the three ways. And then we're going to kind of go into the angle from NFT Marketplace analysis. So we're going to try to look at NFT Marketplace. Okay, so data, so just kind of like level setting data is produced by on chain activities, right? So here, we're just going to use a super simple example because we're talking about NFT marketplace, so we're talking about NFT trading. So simply put, person A just like get person B some money, and person B just transfers the NFT back to person A, right? Like in a very simple life format, that's like what happens.
03:11:03.692 - 03:12:03.948, Speaker D: So when this transfer event happens, kind of like the lifecycle of it, it's just like an externally owned wallet has to sign this transaction, right? And then the signed transaction would call certain functions, right? Let's say like a transfer function, and then also it should also emit an event. Not all of them do, but let's just say it complied with the standard and emit events. So after this, so from the functions in terms of how it generates data, so the call functions will generate call data along with the send transaction. And the data will get reflected in one of the raw tables called the transactions table, right? If you're familiar with the Ethereum architecture. So that's how the data gets mapped to the action. And then also the surface level transactions will trigger some internal transactions, right? So those data in turn goes into the traces table that we have another role table. And then for the emitted events, those are logged in the locks table.
03:12:03.948 - 03:12:46.092, Speaker D: So we can kind of walk through an example. So here I have an example of just like on Openc, somebody wanted to buy this KPR token NFD. And this is like the transaction hash for it. And then, so in turn, if I want to look at kind of like the transaction data associated with it, what I can do is I would grab the transaction hash from it, right? And then I can make this bigger so you can actually see. Okay, so here, remember I was kind of talking about the three types of data. Actually, let me minimize it one more time. So on the left hand side, you can see that we have the role table, right? The decoded projects and the spells.
03:12:46.092 - 03:13:28.744, Speaker D: So the role tables are just like transactions, traces and locks. Those raw data that's being emitted by the chain, like broadcasted by the chain the decoded projects come from, let's say you have uniswap and you have smart contract, and those produce data. But instead of just going straight up to the transactions, like the role tables, you can actually go to the decoded project to get better data. And it's really powerful if you know what you're looking for. And then the spells are just like abstractions built on top of both raw and decoded projects. And let's say if you want to analyze all the trades in the NFT sector, and then you might not know. So ask a person who might not have deep backgrounds about how is a trade being constituted.
03:13:28.744 - 03:14:07.048, Speaker D: How can you read the trade data basically from the solidity code level, right? You can go to this is like all community gathered data. So we have these NFT trades table. And then from here you can already see there's like the amount that's being traded, right? You can also see the buyer, the seller of it. So if you start from the top, we actually have table like this like spell book table that you can start. But those are kind of like diversion from what we're talking here. So those are three types of table that we have. So kind of coming back to the role table example we're talking about.
03:14:07.048 - 03:14:34.912, Speaker D: So we can query from Ethereum transactions table and then we just filter for the specific hash we're looking at, putting the block number just to optimize the performance a little bit. And then we can simply see, oh, from this person to this person. This is the transactions that's being triggered and then this is the data associated with it. But as you can see, it's very gibberish. You can't really read it. It's just like blah, blah, blah, blah, blah. So you need to do more work about this.
03:14:34.912 - 03:15:12.764, Speaker D: But yeah, so that's the transactions table and then I guess quickly show literally the same logic about the traces table. You just query the Ethereum traces, put the transaction hash, and then you get all the internal transactions that were triggered by this top level transactions. But again, the problem here is just like, it's still not very human readable. It requires you to have a lot of skills to be able to parse the data. Here you can, because in order to get the higher level tables that we talk about, someone has to be equipped with this knowledge. But that's like the beauty of the space. Only one person needs to find that and then everyone else can benefit from you.
03:15:12.764 - 03:15:55.708, Speaker D: So to me, that's the beauty of open source data. Okay, I'm going to skip the locks table. You kind of get the idea these are like the real tables and then just decoded table just to give you an idea. So with Openc, right, they release their support contracts and stuff so you can directly query for the OpenSea support contracts, this particular event order fulfilled. But again, this requires you to have some skills. You have to know how to parse these data tables. However, if you just go to spell book so for NFT trades table that I was just showing you guys, literally here, it's super clean.
03:15:55.708 - 03:16:39.160, Speaker D: You can just select the seller, the buyer amount, original currency symbol, and then you get a really clean results. I don't know. So when I started looking at I used to flip NFTs and then when I was looking at the data to support what NFT arbitrage opportunities I should look at, it was like so much to just look at the contract level data. But then once we have this energy trade table, it's just so beautiful. You're able to just do analytics so quickly and then it almost like, I feel like in a way, it's like the community itself is democratizing the community itself, right. Everyone's building toward a higher level table and then we're just going to get better and better as an ecosystem. But yeah, so those are the data tables.
03:16:39.160 - 03:17:11.604, Speaker D: And then just like quickly, a word, the way you get from some base level tables from transactions traces to NFT trades. We use this thing called DBT for data transformation. You can read more. I'm going to skip this part. I just want to show you guys there's a quite nice lineage trace from this abstraction table. How do you get from the lower level to abstraction table? There's like a lineage graph that you can go look at. But yeah, I'm going to skip this for today.
03:17:11.604 - 03:17:48.464, Speaker D: And if you want to know more about how to contribute to our spell book, you can check this link out. There's like three different guides. Depending on your style, you can go digest and do it. So yeah, that's how you can contribute to open source data from the data perspective. The second perspective is the Dashboard, which actually is tightly coupled with the first one because without data, you can't actually do dashboards. But just going to show you guys an example. So here we're talking about how do we do NFT marketplace metrics, right? So this goes back to the spell book that I was talking about.
03:17:48.464 - 03:18:27.390, Speaker D: So with the NFT trace table, we have data for OpenSea on Ethereum and Solana magic, Eden looksra, I'm not going to read all of them, but literally someone. So one person can go contribute to OpenSea on Ethereum and someone else can do OpenSea on Solana. And together we get this more complete system view of all the NFT marketplaces and that's just beautiful. Amazing. Right? So then with this table, what you can do is just like, okay, we want to see the total volume in USD term or in transaction count. You can just do that. The way you do that is super simple.
03:18:27.390 - 03:19:10.196, Speaker D: If you know SQL, you see like two lines of code select count, distinct, unique, trick ID from NFT trades. Right? So this really simplifies the process. When we think about aggregating total value locked in a protocol, it's just like such an insurmountable task, really. Right, because you have to know what protocols are out there, you have to aggregate it, blah, blah, blah. But with a table like NFT Trades, it's like everyone is trying to reach that complete picture for NFT marketplaces, right? And then as a result, the people who come after we're all benefiting from the people before us. So we can just write a simple query like this. But obviously the caveat is you have to understand what data you're querying.
03:19:10.196 - 03:19:43.440, Speaker D: So you have to understand the data you're querying only includes these marketplaces that are listed. But yeah, as long as you know what data story you're telling from. I guess that's like the trade off you're doing. You have more flexibility, but you also have more responsibility because you got to know what data story you're telling from. But yeah, so with this data set, you can also just do some visualizations about the market share from different marketplaces. You can rank them by their total volume. And all this is done by just like writing some simple SQL.
03:19:43.440 - 03:20:33.808, Speaker D: And then once you have the SQL ready, let me open one of these. So let's see with this pie chart, right? So you write some SQL, and then once you finish writing that SQL, you can generate a visualization from the results table and then you can just add it to your dashboards. I'm flying through all these. Just feel free to stop by our booth if you have any questions because there's quite a lot to cover for our platform. But yeah, so another thing I quite often do, feeding into learning from each other building in public. So I go to this Discover page for Doom and then I just look at what's trending. And I recently was really doing a deep dive on Uniswap, but I want to see what other people already did for Uniswap.
03:20:33.808 - 03:21:28.710, Speaker D: So I just came here and I just did, oh, uniswap. And then I just searched for it and then I see, oh my God, a lot of people already did similar things and I can go click into each of them, right? And then I just see what other people have done and then I just click into that query and I learn from it. So in this way, I feel like we're also building the frontier of web3 data through the dashboards. You're learning from each other, you're sharing it's like all in the public and they're just like, you're also having fun together. How nice is that? Okay, so lastly, also kind of like feeding to the data side, you can also build the frontier of web3 data through just apps, right? Through APIs. Okay, so we are still in the beta testing stage of API, but if you want it, come by our booth and we'll give you an API key to test it out. I'm just going to quickly show you like a demo of how we can do this.
03:21:28.710 - 03:22:02.290, Speaker D: Let me just pick something. Let's see, what did I pick over here? Okay, so we're going to just pull data for this one. So we're pulling data for the 24 hours volume on all the NFT marketplaces that we have on Doom. And it's just like a number. So the way you can use API to pull Doom data is you get this query ID, right? So the first chunk of number after queries. So you copy the query ID and then going to come back here. I'm going to paste it here.
03:22:02.290 - 03:22:32.328, Speaker D: Okay, I already did. Okay, so let's see. So nothing really hard. I'm going to just import the packages that are needed. And then I just wrote like a quick function, kind of like calling our endpoints to get the data. I can walk through that in a little bit, but pretty much like just standard call to get the data. Okay, so first I'm loading my environment to make sure I can have my Doom API key.
03:22:32.328 - 03:23:15.828, Speaker D: Cool, I do and make sure, okay, this is like the query that I want to query for. And then cool, I'm just like running this function. So all it does is just like first okay authentication and then calling our API Dune endpoint and putting the query ID and then say, okay, let's execute. Right? Once it execute, it's going to get the execution ID for this particular query ID. So you grab that and after you grab that execution ID, because it hits our back end, it's like literally running the query live in our engine. So you need to wait till the query finishes. So here I just have a simple while loop just waiting for the query to finish executing.
03:23:15.828 - 03:24:07.130, Speaker D: And once the query finished executing, then I basically call another endpoint to get the results for this particular execution ID. And then I just do some simple parsing to get like a pandas data frame. But yeah, we only have one number here, so it's pretty easy. We just got TADA like 24, 25.923. But yeah, like a very simple example, but you get the idea. So the way you can pull data from Dune is just like you write a query about whatever you want to analyze and then after that you grab the query ID and then with the Dune API key you just get the result and then you can feed into whatever application that you want to build. So going back to here and then this is like the link to API docs if you want to actually dive into a little bit more.
03:24:07.130 - 03:24:48.016, Speaker D: So today or this weekend, we are giving five times 2000 bounties to just kind of like for epic integration with our Dune API. Read more details online about this, obviously. And then you can fill out this form. If you want an API key, this is the QR code for the form. But yeah, so lastly, just want to leave with some inspiration idea, right? Because in a hackathon, I think sometimes unless you came with an idea, it's quite hard to know what you're building. So with doing API in the past, what people have done, they built like sector specific market intelligence. So like the Moonblocks they did like NFT sector market intelligence.
03:24:48.016 - 03:25:12.616, Speaker D: So they were just like pulling data from Dune. Like basically the NFT trades table that I was showing you guys and then they feed that into their own app. Or someone else did like a no code interface. So they basically use Dune API to integrate with Google Sheet functions. That's something you can also do. Or there's like data transparency tool. Tornado cache was just like such a hot topic.
03:25:12.616 - 03:25:52.510, Speaker D: So somebody like a team implemented where you can put in your address and it will tell you how much closer you are to being kind of like doxed by the government. But yeah, so some other things you can do. You can build trading automation because you can get trading data. Live from Dune, you can think about how to transform web Two things into Web Three. So like the same funnel that web Two analytics often do, you can do the same thing in Web Three just in the same stack, but yeah, so the data must flow. And happy hacking this weekend. Thank you.
03:25:52.510 - 03:26:56.066, Speaker D: So feel free to stop out questions. Yeah, so from my understanding the difference so graph will give you like subgraph endpoint, right? You can call directly but you can't really customize it. So if you have something that you really want to dig into, then it's not really possible. So basically with June you have SQL and you just built your own query and then you just call that it's more customizable. And then I think another not super totally different thing, but just like something else I was mentioning. We have such a vibrant community of wizards. So it's like everyone who's interested in through data who's in our community, they're building these queries and they're building these spell book.
03:26:56.066 - 03:27:41.656, Speaker D: Right? Like the extraction I was showing like NFT trades, that is something by one person. It's really hard to do, but you can just leverage on Doom, SQL or the Doom data set and then you can do that as so like we're going to forever have a free tier. So just as you demand more performance, same thing with on the app, we're on the UI, so we're going to on the app, we're on the API, we're going to charge you basically as you demand more performance. But also we believe in building in public. So if you're trying to do everything for the public goods, basically all these dashboards, right?
03:27:41.678 - 03:27:42.200, Speaker F: It's all public.
03:27:42.270 - 03:28:16.470, Speaker D: Then we don't really charge you if you just use the community version. But the moment you start making things private, you start pulling data for your private use, then that's when we start monetization. I believe it lasts for two weeks. Yeah, two weeks trial, I think. Yeah. So we're selling beta when it comes out. I believe there will also be like a community tier.
03:28:16.470 - 03:28:33.250, Speaker D: Yeah. And then like other higher level pay tier as you demand more performance. Okay, let's see if I can help answer it.
03:28:36.440 - 03:28:40.470, Speaker F: If I'm a user and I want to query something that someone has already built.
03:28:43.560 - 03:28:53.640, Speaker A: How can I trust that they are giving me the message that they say they are the logic that I like without having to find their actual query.
03:28:55.260 - 03:28:56.120, Speaker F: You know what I mean?
03:28:56.190 - 03:29:00.040, Speaker A: Where's that trust? That what is being pulled upon.
03:29:02.240 - 03:29:34.744, Speaker D: Yes. I think if I'm understanding correctly, the way you can pull data is through calling this query ID. Right? So if you have their query ID, you can check what goes into this query logic by just checking the SQL logic. So I guess the trust would come from you checking if you agree with the way they built this query. But if you don't check it, then I guess you can't. So you should check it. I guess based on what I'm saying, you should check their logic if you are worried about that.
03:29:34.744 - 03:29:48.440, Speaker D: Yeah. So are you more talking about like NFD trades? Like you don't really know what goes into NFD trades.
03:30:01.790 - 03:30:02.540, Speaker F: But.
03:30:04.270 - 03:30:36.598, Speaker D: Yeah, I don't know about Star. I mean, star is kind of like a good approximation, but okay, so first, like if you go to the basic level of ethereum, like roll tables, right? Like everyone has the same data. So if you have the wrong data, I imagine someone just will report that, but from there. So everything that's built on top of it, it's like open sourced. So you can go to our GitHub and see how is that being done. So if you're really caring about your data quality, you can just go check it yourself. Yes.
03:30:36.598 - 03:30:54.260, Speaker D: You guys went up at the same time. Sorry, can you decentralize the that is a great question. I will get back to you. I will ask my teammates and get back to you.
03:31:09.540 - 03:31:13.410, Speaker A: Smarter way of analytics. Better.
03:31:15.000 - 03:31:15.750, Speaker D: Yeah.
03:31:16.200 - 03:31:19.360, Speaker A: What's the difference between flexibility?
03:31:19.520 - 03:31:21.696, Speaker B: It just takes some indexer.
03:31:21.808 - 03:31:53.764, Speaker D: Yeah. Yes. So I think when you're talking about like, you're just indexing data, you get the raw data. So, okay, we have the same role, but as far as I know, we're the only one that decodes every contract that you submit. So it's just like if you want decoded data, we're like decoded. Yeah. So you have the Abi and you have the contract and then instead of, let's see.
03:31:53.764 - 03:32:28.316, Speaker D: So with the uniswap, right? Uniswap has these paired token, like uniswap. And then let's see, you've got the data that's generated by these calls. You can query with SQL and you can see the actual results of it instead of just parsing the role table. Yeah, we're the only one. As long as you submit the decoded contract to us, we're going to decode it for you. We are working on automatically scanning everything. Yes, we were working on it.
03:32:28.316 - 03:32:51.560, Speaker D: Yeah, exactly. So that's that and then also on top of that, we've got the abstraction on top of these two. Right. And then just like the community built toward that. And as a single team or one person, it's very difficult to get to a complete picture. Yeah. Yes.
03:32:51.560 - 03:33:28.770, Speaker D: Not only the yeah. So you're basically looking at like transfer into a particular decks, right? Like yeah, you can just track the transfer event. And I'm sure there's already abstraction tables built by the community out there. You can contribute to our spellbook. It's like, basically public GitHub. So it's pretty much just like, write more SQL to the yeah. Raise a pull request to our spell book and add to it.
03:33:28.770 - 03:33:31.730, Speaker D: Yeah, that's fine. No problem.
03:33:32.420 - 03:33:33.024, Speaker F: Cool.
03:33:33.142 - 03:33:49.690, Speaker D: Yes. That is a great question. I don't actually think our front end is open source. I don't think so. Yeah, I don't think so.
03:33:49.760 - 03:33:50.298, Speaker A: Thank you.
03:33:50.384 - 03:33:53.580, Speaker D: No problem. Yeah, no problem. No problem.
03:33:53.910 - 03:33:54.660, Speaker A: Yes.
03:33:57.350 - 03:34:03.986, Speaker B: It's not fixed by you'd be able.
03:34:04.008 - 03:34:06.290, Speaker A: To do the analytics. We have a custom contract.
03:34:12.280 - 03:34:33.550, Speaker D: No. Yeah. So as long as you give us a contract with the Abi, we'll decode it for you and the analytics is done by the community. Yeah, I feel like I'm out of time, but I don't know if there's another person after me.
03:34:34.560 - 03:34:36.188, Speaker A: Not a bunch of people coming in.
03:34:36.274 - 03:34:46.290, Speaker D: Okay, great. Cool. Yeah. I was worried to take away someone else's time, but yeah. Anyways, find me at the booth for more questions.
03:34:47.060 - 03:34:47.680, Speaker C: Thank you.
03:34:47.750 - 03:34:48.370, Speaker D: Yeah.
03:35:00.340 - 03:35:30.160, Speaker A: Building careers, and I think they have them break down fields, create relationship diagram.
03:35:30.320 - 03:35:39.090, Speaker B: So if you would like to find a database, you would say model and field.
