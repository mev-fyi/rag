00:00:00.330 - 00:00:52.890, Speaker A: Okay, I'm going to talk today about Fair Sequencing Services system we're building at chainlink turning into a product. I should emphasize that I'm speaking in my industry role, in other words, as chief scientist of Chainlink labs rather than my academic role. But you've already heard about the work that's gone on in my academic group from Phil and Nahimna who've talked about Flashboy's 20 and Iquitos and so on and so forth. And I'll allude to that work, but that's not the focus of this presentation. My own view of mev is that there are many different forms of mev. Some, very roughly speaking, are good and some, very roughly speaking, are bad. For example, there are certain forms of arbitrage that one can argue on Wall Street or in blockchain.
00:00:52.890 - 00:01:50.954, Speaker A: Systems are beneficial in a sense. They're beneficial in that they communicate valuable price information across markets, for instance, and therefore make those markets more efficient. I would contrast this with many forms of front running. Front running in general communicates essentially only the fact that users can be shafted in systems as they're designed today. I would allege now this distinction between good and bad is an open research problem, as is the formulation of good metrics to measure whether or not a form of mev is good or bad, and even the extent of mev. And there are different metrics used in different places in the economics literature. For instance, there's study of the impact of various forms of arbitrage, like latency arbitrage, on the cost of trading to investors.
00:01:50.954 - 00:02:35.434, Speaker A: And I think this is a good metric. Others today have spoken about, or will talk about other metrics. Mahimna talked about the metric underlying Icwitas, and P McGuin has an interesting take on metrics for measuring whether or not we have a fair system as well. But to be fair, this is an open prop. I would say that however we define bad mev, we probably can't eliminate it in its entirety. So what we can only hope to do is to build tools that help enact fairer policies for users. And by fairer I mean fair in the sense, for instance, that behemna discussed, or fair in terms of the fees incurred by users when they trade.
00:02:35.434 - 00:03:37.518, Speaker A: And this is the goal of Fair Sequencing services. The current model of transaction ordering we've reviewed over the course of the day. Very simply, transactions enter the mem pool in an L1 system in some order, and a miner or a validator picks them up and decides unilaterally how they're going to be sequenced in the block that the miner mines. Now, the miner may decide this on the basis of gas price, it may decide it on the basis of an mev auction. But the point is that this decision is being made exclusively by the miner that mines the winning authoritative block. And this is clearly a form of centralization, and its harms have been well documented in an older setting where mev was mostly extracted directly by bots in the Flashboys 20 paper. New models, of course, are emerging.
00:03:37.518 - 00:04:39.746, Speaker A: And an important impending model is one in which transactions go not to the mempool, but instead to an L2 system, like a roll up. And the important thing to observe here is that the L2 system now is ordering transactions unilaterally. Now, I won't say that this is a destructive or harmful form of centralization. It could be, it depends on how these systems are designed. And for instance, Arbitrum is looking to sequence transactions in a fair way that comports with the notions of fairness that I mentioned earlier. So it's not inevitable that we see the same degree of centralization that exists in today's world with miners. The idea in Fair Sequencing Services very simply is to decentralize the process of ordering transactions to leave it not in the hands of a single entity, but instead to invest a committee with the power to order transactions, a decentralized committee.
00:04:39.746 - 00:05:58.830, Speaker A: So the committee collectively decides how transactions are ordered on chain, and this decision takes place off chain. Users can send their transactions through the mempool and nodes in the committee can just observe the mempool. That's one possible design option. A better, more practical one, has users sending their transactions directly to committee members and then they decide in the aggregate how those transactions get ordered. Now, natural question to ask. Of course, the first question one would ask is where are these committee members going to come from? How are we going to compose this committee? What we've observed at Chainlink is that existing decentralized Oracle networks are already good, ready made committees with many of the trust properties that users are looking for. To begin with, these networks are already serving price feeds, for instance, across a range of DeFi products and staking and various exogenous crypto economic guarantees of type that, for instance, Mahim mentioned before, can help provide the assurances that users are looking for in this setting.
00:05:58.830 - 00:06:46.638, Speaker A: Another interesting observation is that ordering transactions is actually a very natural operation for an Oracle network. What do Oracle networks do today? They observe off chain behavior and they collectively decide on some value to convey on chain. So for instance, a collection of nodes may observe the price of some token, they may observe it from multiple sources. They get together and they reach consensus on an authoritative price and then they relay it on chain. What's happening in Fair sequencing services. Well, Oracle nodes are observing an off chain activity, namely the transmission of transactions. They're observing in particular the order in which transactions come in.
00:06:46.638 - 00:07:51.730, Speaker A: They're taking this data, they're collectively agreeing on an authoritative ordering, an authoritative observation of the events that they've seen in the real world, and conveying that on chain. So, as I said, very natural extension of what Oracle networks are already doing today. In the first phase of our design of FSS, we're going to use a notion of fairness called secure causal ordering or secure causal atomic broadcast to be a little bit more precise. This is the idea of encryption, essentially. But the intuition here is that no node sees a transaction payload before the transaction is ordered. Or to put it another way transactions get ordered or sequenced before anyone observes the transaction payloads. This idea is actually about three decades old devised by Mike Reiter, I think in his thesis PhD thesis at Cornell and adapted to the public key setting by Christian Cachan and others, including Klaus, who'll be speaking shortly.
00:07:51.730 - 00:08:34.030, Speaker A: The way this is implemented is relatively simple conceptually straightforward. Transactions are transmitted to the committee in encrypted form encrypted under public key belonging to the committee with a corresponding private key that is shared in a threshold way among committee members. The committee orders these encrypted transactions and after they've been ordered authoritatively then decrypts them. That's the idea. That's the way this notion is implemented. This works very well because it's hard to front run something that you can't see. But it does have some limitations.
00:08:34.030 - 00:09:08.810, Speaker A: And I point to two limitations in particular. One is that metadata are still visible in this setting. You know, for instance, from what account a transaction originated. And that can, in some circumstances leak significant information about the content of the transaction even if it's encrypted. The other problem is what I would call blind front running best defined perhaps by example. Suppose there's an ICO and one of the nodes in the committee wants its transaction sequenced. In this ICO first she wants to buy all of the tokens.
00:09:08.810 - 00:09:44.680, Speaker A: Secure causal ordering is not going to prevent this from happening at least not definitionally. But there's an interesting observation we can make here which is that secure causal ordering doesn't actually specify the ordering of transactions. It says that once transactions are ordered then they can be decrypted. But it doesn't specify exactly how transactions have to be ordered. Transactions can be ordered as they were received, as I show here. Or they could be ordered in some other way. And that would be consistent with the definition here.
00:09:44.680 - 00:10:49.114, Speaker A: This observation leads to the refinement we're planning for the second phase of development which is the addition of Aquatas. These are the protocols alluded to in the previous talk. This family of protocols developed by Mahimda Kelkar and some others in my group was proposed first in 2020 in a paper that's theoretical in nature uses consensus protocols in a black box way and therefore isn't terribly efficient but more efficient version should come out in a month or so maybe a little bit more than a month. So these protocols can be practical. The intuition here is that transactions essentially are ordered according to the time that they're received by a supermajority of nodes. And how the supermajority how large the supermajority has to be is a parameterizable feature of the protocol family. Things are a little bit more complicated than this.
00:10:49.114 - 00:11:31.050, Speaker A: But this is the basic intuition. How do we compose these two? Well, this is fairly straightforward. When transactions are sent to the committee in encrypted form the committee orders them exactly as I showed before. But now it uses equatos in particular to order the transactions. Once the transactions have been ordered, then they can be decrypted. And in this way you get causal ordering in addition to the features of Iquitos. Now, Iquatos in and of itself actually prevents the attacks that I described previously or at least mitigates them.
00:11:31.050 - 00:12:11.154, Speaker A: It prevents things like metadata based attacks because it's ordering transactions according to the time that they were received. So it's potentially stronger than secure causal ordering. In the right setting, it will be, but it's somewhat sensitive to network adversaries. If an adversary, for instance, in the limit controls the Internet, the adversary can decide how transactions are ordered and there's not much you can do about that. Iquitos isn't going to help. Secure causal ordering will actually help in that setting. Iquitos is also a little bit more complicated to implement than secure causal ordering.
00:12:11.154 - 00:12:45.010, Speaker A: But the two nicely complement one another. They act as hedges for the other protocol and this is the reason why we're interested in composing them. FSS can be used in any of a variety of settings. It can work, for instance, as a preprocessing stage for L. One, functionalities specific smart contracts can be FSS enabled. And this doesn't require terribly much of a developer. It's not much more than would be required, for instance, to integrate roll ups into a contract.
00:12:45.010 - 00:13:29.114, Speaker A: But of course, as we know we're living in a world in which ordering is increasingly taking place off chain. For instance, at L2 in roll ups, flash bots and so on and so forth. It's worth pointing out that FSS can work equally well in those settings. If we're talking about a roll up, for instance, you can use FSS to sequence transactions that then go into the rollup and the composition, again, is fairly natural. And this may well be the first place in which we see FSS used. That's it for my talk. If you're you're interested in learning more, I would direct you to the academic paper on Iquatas and those on secure causal ordering.
00:13:29.114 - 00:13:39.660, Speaker A: Classic papers. Now, if you're interested in FSS in particular you can read a bit about it in the chainlink 20 white paper at the URL given here. Thank you.
