00:00:00.330 - 00:00:03.050, Speaker A: Can. Okay, bernard floor is yours.
00:00:03.210 - 00:00:33.522, Speaker B: All right. Thanks, Nisha. Thanks for having me. Thanks everybody for being here. And since Flint has a couple of challenges with various prizes for this hackathon, want to go over a small workshop, 30 minutes. And if you have any questions, just shoot. The main point here actually is we want to build and compose Web Three protocols with Fluence and Aqua as part of the Web Three jam.
00:00:33.522 - 00:01:34.166, Speaker B: And as Nisha pointed out, I'm Bernhardt and I'm with Fluence Labs. So the rest of the presentation is pretty much unpacking. That statement, which is the head in the headlines and just as an overview for you, not familiar entirely with Fluence maybe, is that it's a peer to peer application platform and allows you to create applications free of proprietary and central centralized APIs and actors such as major cloud providers. And at the core of the Fluence P to P solution is a protocol which is very compute specific. And that basically means that developers have to bring their own store, distributed store to the solution to their applications. And we can do this by integrating with peer to peer solutions like IPFS, Filecoin, Ceramic, Textile, et cetera, which enables now a real wide variety of decentralized use cases. And as part of the solution, we provide everything's open source.
00:01:34.166 - 00:02:24.630, Speaker B: By the way, it's very permissive MIT or Apache two development stack. So you can actually program peer to peer applications through workflows and service compositions without relying on anybody in between, no centralized intermediaries. And so it really gets you right into the wheelhouse of Web Three, and particularly Web Three off chain, which is the really important part here. So fluence in a nutshell. So if you look at it from a network perspective, on the right you have a little mockup network three nodes, basically peer to peer, and the greenish round circles are client peers, which could be a browser, could be a very thin edge device, for example. So nodes in the peer to peer network commonly are referred to as peers. And one here is marked Relay.
00:02:24.630 - 00:03:30.154, Speaker B: Relay peers or relay nodes are nodes that are accessible publicly. There could be nodes or peers behind that relay that are not directly accessible because of Nat or some other restrictions. So Relay is just a node that's publicly accessible and that allows you to route to possibly publicly inaccessible nodes. The nodes that say service on top of it are SIL nodes. And basically what you do influenz as it is this application platform, a general purpose application platform, you create services and then you deploy these services onto one or more nodes. So if you have something very simple like Hello World, you create a service that basically takes an input and comes back with hello, your name, whatever, you deploy these services onto different nodes, one or more, and then you can compose these services into an application. Now, in order to be realistic we don't expect everything to be on the fluence network per se, which by itself actually is open and permissionless.
00:03:30.154 - 00:04:24.734, Speaker B: So anybody can join run nodes and be part of the network and allow you to integrate with external resources. Already available could be microservices, some basic API services and of course IPFS. And we call those services Adaptive services and you have to write them, which at the most minimal basically are wrappers around the API of that external network service. And some of those services adapters are already available for you, including an IPFS adapter. So if you look at this little network on the right and you see those services deployed. So now the big question of course is how do you actually access those services? How do you chain or compose those services into an application? It's peer to peer. So you don't access those services with Rest, API or JSON RPC.
00:04:24.734 - 00:05:14.686, Speaker B: Instead, what you do is we have a dedicated program language called Aqua which is very, very high level, super economic, dedicated towards marshalling and composing these distributed services on a peer to peer network into applications. And we'll get into examples just a little bit. And all that happens on top of lip P to P. So you really get this full peer to peer stack, and you even got a very simple, very powerful language that allows you to program these services into applications, which, if you do it right, actually ends up to be a decentralized application, which is the really important part. Again, in the context especially of off chain services and applications. So how does it work? We have two foundation parts. One is called Aqua and one is called Marine.
00:05:14.686 - 00:06:34.902, Speaker B: So we call it Aquamarine. Aqua is a set of tools including a programming language that facilitates the composition of those distributed services. Now, what are those services? Where do they come from? Those services actually WebAssembly modules and it's actually WebAssembly Interface type or Wazi 32. It is not your general Bind gen WebAssembly you generally see in the front end browser environment. Nevertheless, it does run in the browser and Marine is actually the general purpose runtime that allows you to execute those services. So what you end up is you write those modules and they are fundamentally shared nothing and then you provide some linking instructions and then upon deployment on a peer, you actually create a service which is a virtual construct over those modules and the linking instructions. And for that you actually end up having Aqua VM which is a virtual machine that runs on every peer as well as Marine on every peer that processes the compiled Aqua, the scripting language which we call Air, which is the Aqua intermediate representation.
00:06:34.902 - 00:07:31.382, Speaker B: And we'll go into this a little bit more by example. It should become very clear and it sounds a lot more complicated than it actually is from a user perspective. What that does is a highly distributed peer to peer environment and that allows you to really build distributed applications by composing services where the business logic is totally separate from the workflow. So that actually promotes tremendous reuse and a few other web3 attributes like decentralization and auditability in a decentralized manner. You get peer to peer applications. So this is particularly important, of course, if you are looking at messaging applications and you fundamentally end up with zero trust applications if you've been following sort of the trends in It zero trust frameworks are super important. Trust nothing essentially verify at every step and this is exactly what happens in this peer to peer network.
00:07:31.382 - 00:08:50.482, Speaker B: So those green dots here are what we call a particle and we'll get into this in one, like on the next slide. But basically what happens every time you execute a service on a particular peer? You have an Ingress and an Egress, and there are verification steps at each way, and that gets you by default to a zero trust composition. Of Zero Trust services which extends to Zero Trust applications, which again, since we are operating in an off chain open permissionless network this is super important and getting that out of the box for you is a tremendous help and ease of burden for developers. So the green dots, let me go back one more time, the green dots here. So we said we have this Aqua script, right? We compile it into error and then we sort of process it on the Aqua VM which is on each and every one of those peers deployed as is Marine, which actually executes the services. So how do we get from this peer to peer? How does that actually happen? And this is one of the core foundations of the Fluence model. It's what we call a particle.
00:08:50.482 - 00:10:00.780, Speaker B: You can think of it as a smart package and basically what it is, it is a conflict free replication data structure that combines data, the execution sequence as expressed in Aqua and some metadata. And what basically happens is that you have a forward chaining data model, a push data model that is very different from your traditional client server model. Instead of having a call out to your server getting the result back to your client, pushing it out to another server, getting the result back, you end up with this forward chaining of the data package. And since it is a conflict free replication data structure guaranteeing eventual consistency, you actually end up with very thin client requirements. And basically what we're doing is here so we send this particle, you can literally think of flinging it out. Let me just go back here. If we start out at this client peer, let's just say it's a browser and we want to call a service Hello World.
00:10:00.780 - 00:10:49.990, Speaker B: What we literally doing is we have the data which is say the name. So it's hello. Name? That's the service. We're flinging it out onto the network and then the network starts resolving the attached script, the air script on where to go, what to call, how to update that data structure and at the end get you back with what you expect to get back. And this is at the core of the foundation and this is an extremely ergonomic way of dealing with general purpose peer to peer networks. And it's extremely powerful because unlike on chain web3 solutions like in the blockchain, if you think about it, every transaction gets recomputed by every node. So you end up with eventually with the longest chain wins solution.
00:10:49.990 - 00:11:55.786, Speaker B: And that, of course has a lot of problems, not problems, but constraints, including scalability constraints attached to it. On the off chain side, where fluence comes in, it allows you to build these decentralized off chain applications. And the network itself is well, it's not infinitely scalable, but it's highly scalable because no node reruns your compute or your application, it's just run once. But what you end up with is you end up with this conflict free replication data structure which allows you to audit and actually rerun the computation and test that computation for correctness. And that is extremely powerful again, particularly for off chain because it gives you certain guarantees you wouldn't otherwise have. So let's actually go from the conceptual and the academic to some code, a little code example here and look at what it does. So if you look down at the code, this is aqua code.
00:11:55.786 - 00:12:37.294, Speaker B: So if you're familiar with Python or Scala or even JavaScript for that matter TypeScript, it should look very familiar. The part that's missing here, and this is what you see up in the little diagram is we have a service, we have a WebAssembly module that takes two parameters, a string and a Boolean. And it returns a string. And basically it's a fancy hello world. So where the string, let's say it's the name and the Bool determines the type of greeting. So if we have our name is Web Three jam and our Boolean the greeter is true, the service returns a string that says Hi Web Three jam. If the boolean is false, it says, Bye, Web Three.
00:12:37.294 - 00:13:20.250, Speaker B: Jam. So it's just a fancy hello world. What we're doing in line one through two, we are creating an interface binding to that deployed service. So that service is out on one or more nodes. And every time you create that service on the network, you end up with a unique service ID, which is a Uuid four, basically, which you see here, this is the reference. So if we want to bind that interface to an actual service on a particular node, we need to give it the service ID. If you are familiar with Solidity or especially Solidity, this is very similar to what you see in the Abis.
00:13:20.250 - 00:14:24.420, Speaker B: And then from line four through eight, we actually write our aqua code. So this is where you compose your services and one of the extremely powerful aspects of it is that even though it's not, I mean, I wouldn't call it content addressability, but there is location addressability. All you need to know as a developer, you need to know where your service is on which peer, which you should know once you deploy the service, or if you use somebody else's service, they should give you the location of that peer, which is the peer ID here and the actual service ID associated with that service. And then of course, you just provide your parameters to execute that service. So what we're doing here so this is where it gets really cool. Anybody who's ever done any peer to peer programming, particularly at the P to P level, you will appreciate the enormous convenience and ergonomic of Aqua. Basically what it says on this node, this particular peer ID, where we have it's a string, it's basically the peer ID, which usually starts as one 2D whatever.
00:14:24.420 - 00:14:49.830, Speaker B: We bind this service interface to this service ID, it's right here. Then we call that function associated with this interface, which we just call Greeting. We give it the name and the greeting type. So this is the name, the string and the boolean. And we get a result back. That result now is on that particular node. We initiated this through our particle.
00:14:49.830 - 00:15:27.062, Speaker B: Once it's compiled, this is our execution script attached to the particle. Now we want to get the result back to the actual client. And this is what happens here. If you look up in the diagram, this is exactly what's happening here. And this shows you the data push model. So how is Lib P to P utilized the actual nodes, the peers deployed that make up the peer to peer network sit on top of peer to peer Lip PDP. Sorry.
00:15:27.062 - 00:16:18.358, Speaker B: And so the whole gossip, the data exchange, the security model, the end to end description, this is where Lip PDP comes in. Does it answer the chat question? I hope it does. If not, post more. Instead of having to go down in your traditional peer to peer programming, resolve all this, how do you resolve, how do you do discovery, it's all taken care of for you or it's very easily accessible at a very high ergonomic level. This is what Aqua brings to the table. Now, once Aqua is compiled, it's not bytecode, but basically it looks like list like closure, for example, and it's machine readable and it's very not fun to manually program. We had to do it until Aqua came along.
00:16:18.358 - 00:17:30.230, Speaker B: So you are all being saved a lot of pain and suffering and so in order for the hackathon to really accelerate. So I understand there's a lot to be learned if you want to bring on Fluence off chain because I presume most of you haven't dealt with it yet. So we got pretty extensive documentation, but we also have ready integrations and examples. So for example, we have an IPFS library that allows you to directly integrate with IPFS using Mean. This is the important part. You use Aqua to not only program the stuff your services on the fluence peer to peer network, but also in this particular case, what's on the so you can you can actually what you can do and there's a very extensive example. In our examples, what you can do is you can actually create a service, deploy that service, or put that service on IPFS, and then use Aqua to load that service from IPFS to whatever nodes you want to.
00:17:30.230 - 00:18:57.618, Speaker B: And the way this happens, this is our IPFS library from Fluence. And the way what happens is you basically have an integration that runs IPFS as a sidecar to the Fluence node and then at the file system level transfers CID referenced data blobs to the Fluence node, which then is accessible by services deployed on that particular node. So now I may or may not have to, but I will tell you the following. In WebAssembly you don't have sockets and WebAssembly are single threaded and there's a strong security model through sandboxing, particularly WebAssembly interface types. So how do you actually interact with the outside world? This is like one of those outside inside jobs like you have on blockchain no, it's not part of the Marine environment. What it allows you to do is through explicit permissioning, it allows you to break through the or punch through the WebAssembly sandbox and actually interact with permissioned binaries on the Fluence node. That solves a whole bunch of problems, including saving files locally, as well as using curl among other things, or predominantly curl to actually interact with the outside world.
00:18:57.618 - 00:19:57.162, Speaker B: And as I said, WebAssembly modules themselves or WebAssembly, it is single threaded. So there are limits you have and through Marine we are reducing and fundamentally eliminating a lot of those constraints that come with it. So you can actually program very easily to interact with the outside world. In addition to the IPFS, we have examples on how to integrate ceramic and run ceramic. Now I'll get to that a little more because I want to look at the code with you guys and go through it. Then actually I listed some of previous hackathon examples. So we have an example from a previous hackathon for a really cool project where basically creates and manages NFTs on Ethereum testnet, I think it's COVID, I'm not quite sure and uses Fluence for that.
00:19:57.162 - 00:20:56.126, Speaker B: So this if you're interested in NFT and off chain management of NFTs in some shape or form, this is a great example, including a simple NFT contract to get started from a very recent hackathon we had with Ceramic. We have multiple solutions on how to use decentralized identities, including Ceramic self ID from Fluence and using Aqua to program it. So if that kind of authentication is something you need in your DAP, don't worry, it can be done. And there are some really cool building blocks available from previous hackathon winners. And lastly, as an example, there is a increasingly complex Ethereum integration. Example. JERA is doing it and he won also a previous hackathon, and he keeps on working on it and extending on it.
00:20:56.126 - 00:22:01.378, Speaker B: And there is a lot of interesting ways on how to interact with Ethereum using Fluence as an off chain complement. Any questions? I see. Yes. Okay, what are decentralized identities? Decentralized identities is a standard that lets you wrap public keys and on the back end, private keys so you can identify through that key and authenticate I think it's the id.org. And one of the most premier use cases right now is it's called Microsoft Ion, which is based on an implementation, a Merkel like implementation called Sitetree, who are looking into replacing your traditional, quote unquote, traditional login approach with username password using DIDs. One of the interesting part of DIDs is because they're chainable, so you can actually start building trust relationships. And it's a pretty good project.
00:22:01.378 - 00:23:23.754, Speaker B: It's in the draft stages of the Web Three consortium. But look it up. It's taken particularly the Web Three space by storm because it's the underlying technology for self sovereign identity, or it's positioning itself as the underlying technology for self sovereign identities. Okay, so any questions so far? I know I'm going fast, I know I'm going fast, but we only have half an hour, and if you have questions, keep asking or keep bringing them up. All right, now let me switch to so just so you know, when you're using Affluence, we're a relatively young project from a go to market perspective, been around for several years, but really pushing the features now on the project. And if you're using Vs code, for example, we have an Aqua extension which helps you with some syntax highlighting. And we also have a dev container.
00:23:23.754 - 00:24:20.640, Speaker B: A dev container basically is a development container that includes all the Fluence tools, everything you need, including a node. And you can run that as part of the Vs code container volume. Hang on, it's fluent Labs here and okay. Why can't she access it? Because I probably mistyped it. Okay, now we go ahead. Okay, so def I just saw it. Okay, here it is.
00:24:20.640 - 00:25:00.854, Speaker B: I'm not going to install it now because it takes a little bit, but it's extensively documented in the Fluence documentation on how to use it. And it's used in multiple examples in the Quickstart category in our example. So if you want to use that, have a look at that. Anyway, the point was Vs code integrates very nicely with Aqua and some of our other tools. So let's just have a look real quick. How do you interact with ceramics? And as I said, we could have gone through the IPFS code. However, there are at least three videos I've done on how to use Fluence with IPFS.
00:25:00.854 - 00:26:07.410, Speaker B: They're on our including at least one previous ETH global workshop. So you should look at that because not much has changed in terms of features, and I didn't want to redo that, because if you wanted to go into NTFS, particularly dynamic NTFS, ceramic might help you even. So, Ceramic is built on IPFS, and it's very interesting because basically it's an appendlock type database and you can anchor commitments in your append log in Ceramic on blockchain. So it brings a mutable capability that has yet reference anchors that are immutably committed onto the blockchain. It's Ethereum, or I think near is also a possibility. And Ceramic has two well, it has multiple APIs. One is the command line API and one is the HTP API.
00:26:07.410 - 00:26:42.798, Speaker B: So basically what you do is you create a stream. They call it Streams, and it's not unlike a Mongo document. And you basically start pushing your data, which could be a KV store, for example. Now, installing Ceramic locally is very easy. There's no big problem. However, the Ceramic IPFS backend does not interact well with the actual IPFS backend. So there are some challenges in installing it, and we've done that for you.
00:26:42.798 - 00:28:06.342, Speaker B: We have three testnets, and the testnet that has full ceramic nodes as a sidecar available is the Stage test net, really low on time I've implemented for you. So you can basically use those very ceramic services as is and basically access Ceramic from Aqua. So we have these services and they basically wrap the CLI or HTPs. So one of the interesting aspects of CLI versus HTPs API from Ceramicus with HTPs, for some reason, you cannot create a stream, but CLI lacks a whole bunch of chain information, such as which chain you're on, pinning and chain health and a few other things. Also, since there is some anchoring happening, it's only the HTP result that shows you whether or not an anchor is pending or actually committed. All right, so let me go back to the chat real quick. Yeah.
00:28:06.342 - 00:28:32.320, Speaker B: DAP three. C it's the web. Three consortium. Yeah, that's the one you're talking about. Okay, take more ten more minutes. All right, I'm sure everybody has things to do, so let me okay, so I obviously have done a few things before. Now I can't find them.
00:28:32.320 - 00:29:43.634, Speaker B: Okay, one of the parts so, as I said before, services run on peers and they get executed on Marine because fundamentally, a service is a virtual construct that links multiple one or more WebAssembly modules into a seamless API, if you will. Now, for a variety of reasons, you can actually run that Marine runtime locally, and that allows you to test and interact with your code locally. So here we have this is what I implemented for the Ceramic adapter to interact with Ceramic and everything that's Http is prefixed with Http. If it's not, it's a CLI. So one of the things we want to do is we want to create a stream. Where is it? Come on. Now I'm going blind.
00:29:43.634 - 00:30:37.480, Speaker B: Create Stream. There we go. So what you do is in order to call these services, we call it then we use the domain, the namespace, which is adapter and ceramic custom adapter. And then we want to do Create Stream and we use a KV JSON string where our key is foo and our value is bar open. All right, so we run that and we have an error no connect. And that is because my local ceramic daemon isn't running. So let's bring that up and let's run that again.
00:30:37.480 - 00:31:54.530, Speaker B: And here you go. So not unlike IPFS, you get an ID and it's called a stream ID in ceramic. And we can now check using actually the httpp interface for streams using the local node I have on I just brought up and it tells us now a lot of things. But the most important part is here, let me make this a little bit bigger is here. So the anchoring status of our request to write to the ceramic stream is pending in terms of on chain anchoring and it's going to take a while for this to come through. Now, if you look at the show stream just for just from the CLI perspective, you get a much poorer information content. That's why you really almost want to double up on CLI.
00:31:54.530 - 00:32:39.882, Speaker B: And if so, this would be a decentralized key here because ceramics actually enables that on its streams as well. Okay, let me get to this question at the end about the multiplayer now. All right, I'm scrambling now because I'm obviously already overtime and I didn't get anywhere near where I wanted to get. Let me go immediately to the prizes. This is why everybody's here. Let me go to the challenges we are offering and the prizes and then I'll go back and see what we can do. So we have two types of challenges.
00:32:39.882 - 00:33:24.186, Speaker B: One is the NFT challenge and one is sort of the best use of Fluence and Aqua and Adapt. Obviously in both challenges we want you to use Fluence and Aqua. And in the NFT we have two tracks, if you will. You can choose either one. And one is basically dynamic NFT lifecycle management with Fluence and Aqua. And the other one is to build an auction protocol with Fluence and Aqua for off chain NFT trading. And the reason off chain trading and even Dynamic NFTs off chain is important because right now a single bid on layer One Ethereum for example, costs you somewhere between 20 and $200 just for the bid.
00:33:24.186 - 00:34:03.418, Speaker B: That doesn't mean that the bid is guaranteed, right, to win. It just means you place the bid. And and here's a little bit more detail on those two challenges now. Dynamic NFT Lifecycle and this is why I actually kind of I think it's one of the coolest things in NFT. I mean, by long shot, this is actually to me, this is where NFTs are super valuable. And I would be super excited if somebody was taking this up in their challenge and go for their bounty. And this is where ceramic comes.
00:34:03.418 - 00:35:25.406, Speaker B: This is why actually because it makes it super easy to do. So, for example, think of a sports person card or a politician, and now you want to actually update their metadata according to external events. And you can use Fluence to source your Oracles, if you will, if that's what you want to call it, and drive these dynamic updates to the metadata. So you could literally, if your NFT, NFT represents, say, a football player or a basketball player or whatever a soccer player as a game runs, you can start updating the metadata, the stats on that player, on that persona. You can do the same for politicians if you're into it. I actually think this is really interesting because there is a lot of pools that monetization pools around politics and bet pools and crowdsourcing pools. And actually linking that with dynamic NFTs to me is like super interesting because you can almost look at Widgets now in your browsers, in your Apple and web applications backed by immutable decentralized data structures.
00:35:25.406 - 00:36:27.558, Speaker B: And to me this is a very exciting area of NFTs. The other part was to do auctions. As I said, high gas cost on a per bid undertaking is prohibitive to do anything unless you have like super highly expensive NFTs. So sure, if you have a digital artwork or a CryptoKitty that sells for $160,000 and it costs you to, I don't know, $300 to run through your auction and put your bids in, no big deal, right? But if you have less expensive, less valuable NFTs, then when the gas costs exceed the value of the actual item, it just doesn't make sense. And again, you can start tracking on IPFS or something like ceramic. Again you can start tracking bids. And since even though the log itself is mutable, you set these anchors on chain where you can track exactly what has happened, where the immutable data points are.
00:36:27.558 - 00:37:32.254, Speaker B: So if you have like, I don't know, ten bidders, one way of looking at, for example, if you could write ten ceramic streams and one for each bidder, basically, and really track those bids very nicely and keep anchoring those bids on chain very inexpensively. And so those are the NFT related examples we have. If you have a use case where you think in the NFT area that's not mentioned, reach out to us. We're certainly open to entertain other approaches. And then best use of your app. If you have a DAP and you want to use some off chain component to it, like Fluent, we would really like you to look at Fluent and Aqua and things like Oracle's indexing, cross chain indexing are super interesting from a compute perspective. And then again, with IPFS or IPFS related solutions like textile or ceramic, you can build these.
00:37:32.254 - 00:38:02.454, Speaker B: Peer to peer decentralized data layers that bring a lot of decentralization and even actually like really good performance, particularly compared to on chain solutions to your DAP. I think I'm definitely out of time. I saw Nisha Blen is up in, so this is good. I'm sorry I didn't get quite as much done as I wanted. We have telegram. We have a lot of channels. Discord, we have our own.
00:38:02.454 - 00:38:18.540, Speaker B: There's. The one with East Global. You can reach us. We are distributed through North America and most of Europe. So with a little bit of luck, you get 24/7 coverage. And that's it from my end. I see a few questions.
00:38:18.540 - 00:38:31.950, Speaker B: Okay. I think everything's been answered, so I said, I'm sorry. It's a little rushed. If you have questions, please reach out. We're super excited to be there. Thank you for having us. Thank you for being here.
00:38:31.950 - 00:38:37.966, Speaker B: And as I said, we're really looking forward for your contributions and solving those challenges. Thanks, everybody.
00:38:38.148 - 00:39:04.180, Speaker A: Yeah. Thank you so much, Bernard. Thank you to Fluence for sponsoring Web Three jam this year. Great workshop. And again, I want to emphasize that if anything comes up with Fluence or if you just want to talk to Bernard, I know this workshop was a little bit rushed, but you can always hit him up on our Discord and all the other platforms that he just mentioned. So, yeah, everybody have a really great day. Thank you again and.
