00:00:00.090 - 00:00:28.946, Speaker A: We'll be taking questions at the end of the session, so feel free to post them in the chat. And he'll be able to get to them in the Q A right after the slides are done. So make sure you take this opportunity to connect with them here. But I do recommend reaching out in Discord following this presentation to continue the conversation. It's a great place to link up with people who are here today, follow up with people from the team, and learn more about the stuff that you're building on. I'll want to take any more of your time. The floor is all yours.
00:00:28.946 - 00:00:31.720, Speaker A: I'll let you introduce yourself and kick things off.
00:00:32.330 - 00:00:43.446, Speaker B: Great. Thank you so much for the introduction. Hi, everybody. Excited to be presenting today. Welcome to Uniswap V. Three time weighted average price. Oracles workshop.
00:00:43.446 - 00:01:15.490, Speaker B: This is an introduction to Uniswap V Three Oracles, and we'll get into it. I'll start with a short introduction here. So. My name is Omer. I'm the founder and CEO at Chaos Labs. At Chaos Labs, we're building a cloud platform that enables runtime verification for DeFi protocols, working with quite a few DeFi protocols these days. And part of our work to enable our work is we build a lot of infrastructure for Oracles, hence this workshop.
00:01:15.490 - 00:01:45.200, Speaker B: We allow for agent based simulations, kind of spinning up any types of users, manipulating scenarios. And that's where the Oracle piece comes in, where you can control Oracle prices and a few other cool things. Now, at least for the architecture of this workshop, first we're going to discuss what an Oracle is, what problem it comes to solve. Then we'll have a quick overview of different types of Oracles, and then we'll drill and deep dive into what a Uniswap Oracle is and what makes it special.
00:01:46.930 - 00:01:47.680, Speaker A: Perfect.
00:01:49.010 - 00:03:03.218, Speaker B: So blockchains are these basically closed systems or closed networks? And besides knowing about balances from different accounts that exist on chain, they don't have access to data from the real world or from the world kind of living outside of the blockchain. So on a very high level, this is what Oracle's came to solve in the beginning, a way to kind of, in a decentralized manner plug in off chain data on chain. Now, when we talk about decentralized systems, an Oracle or an application, a blockchain application is only as decentralized as its weakest link. So kind of the question is asked like, how do we bring in off chain data on chain in a way that's decentralized? So having one node or one API server that we hit up is definitely not good enough because it's by definition centralized. So we kind of want to distribute it. Now, ultimately, in the beginning, kind of, there were some off chain Oracles which were the more popular solutions for this. But over the past few years, specifically in DeFi, and specifically with the work that Uniswap has introduced, we're seeing the emergence of on chain Oracles in order to kind of illustrate the problem broadly.
00:03:03.218 - 00:03:34.946, Speaker B: First we'll talk about off chain Oracles because I think that does a good job of explaining what we're trying to solve. And then we'll show the innovation introduced with on chain Oracles. So in order to kind of make this less abstract, we'll take two use cases here. We'll talk about chainlink oracles and uniswap oracles. Now specifically in these Oracles Oracles, like we said, it's a way to bring data from the off chain world on chain. Now this could be any data. It could be the result of a sports game, of an NBA game.
00:03:34.946 - 00:04:04.454, Speaker B: It could be the weather. Specifically for today, as we're focusing on Uniswap, we're going to hone in on price Oracles. So price Oracles give us the price information about a specific asset. Now, since we have kind of several ways to kind of fetch that, let's discuss what the best way to go about it is. All right, so we'll start with off chain Oracles. This is kind of the chainly kind of model. There are different Oracles, different types of solutions.
00:04:04.454 - 00:04:26.100, Speaker B: Each one is amazing for the different use cases. So we won't get into Oracle flame wars. But here we can see the architecture for chainlink. So there are a bunch of these node operators which live outside of the blockchain. You can just think of this as like API servers. In the case of chainlink, they're called node operators. And what they do is they're pulling in price information.
00:04:26.100 - 00:05:09.390, Speaker B: Now at predetermined intervals, everybody's going to submit all of that price information to what is called an aggregator. The aggregator, depending on its internal implementation, is going to run some type of average function. And then it's going to take the result of that average and write it to a smart contract that lives on chain. And then other contracts or other DFI applications or web3 applications for that matter, can query it and consume the price data. So what's important to kind of see in this architecture is if you see here this pink outline in this pink box, this is the part that lives off chain. In this case, the node operators. And everything else is happening, including the aggregator on chain.
00:05:09.390 - 00:06:28.600, Speaker B: Now, let's talk specifically about Uniswap v three Oracles. So taking a step back, time weighted average price Oracles or TWAP for short, which is what I'll be using to reference, these were kind of introduced in previous versions of Uniswap. And really the problem they came to solve was how can we solve or understand what the price is of a specific token pair on chain without having to depend on off chain Oracles feeding us data? All right, so first of all, time weighted advertiser Oracles, it's a very kind of some mouthful. Let's deep dive into what that actually means and kind of develop some intuition. So in an off chain oracle, in that example that we were speaking about, we had these servers, or kind of these node operators which were getting results, let's say, in an example of a price, feeding them to like an aggregator that was running some type of average and then writing it on chain and providing it for different applications. In this kind of implementation or example, we don't know how the servers kind of got those prices, but they got them somehow. And we trust that because we're depending on many, many Oracles in a decentralized manner, ultimately it's going to work and make sense.
00:06:28.600 - 00:07:21.638, Speaker B: Now, a time weighted average price Oracle, what it does is it records prices that are observed over a specified kind of time period on chain. And when you query the price at a given moment, it doesn't only give you a specific kind of what's happening at the second. You can actually specify that you want the price as an average over the last N observations. So instead of having one data point that returns a price, now you're taking an average of N data points. Now in Uniswap, there's kind of a lot of wiggle room to kind of configure what is N, how many observations you want to make, and so on and so forth. So we'll dive kind of even a layer deeper and try to understand this even better. All right, so we said earlier that Uniswap was recording kind of these observed prices.
00:07:21.638 - 00:08:29.342, Speaker B: So where does it store them? By the way, they're going to be some links here, but afterwards you can definitely go through the Uniswap v three GitHub repositories and everything is laid out really nicely along with the documentation. So you can see all of this kind of live. But Uniswap kind of has these internal structs in their contracts that are called observations and they record previously viewed ticks. So you can just imagine kind of to visualize it, that you have this kind of struct or this array that's holding basically each slot in the array observations from different time periods. Now we have these structs. How do we translate it into prices? So kind of without doing too much of a deep dive right now about kind of what ticks are and why they're important in Uniswap v three, uniswap stores these observations, also known as ticks in these structs. And when we query for a price over a given time, we specify kind of how many data points we want to look at.
00:08:29.342 - 00:09:17.050, Speaker B: And it's going to kind of look at everything that's in that struct for the relevant time period, sum them up, which you see here with a sigma and then divide by N to get kind of the average price tick over time, breaking it down a step further. This is what it looks like when you look at the math behind it. Now, Uniswap is storing in the observation something that's called ticks. Ticks are something that's related to how liquidity providers kind of express where they want to provide liquidity. We can leave that, I guess, for like the Q and A. But ticks are not exactly prices. So there is a pretty straightforward formula that you're going to see when we look at the source code for you to swap v three tops.
00:09:17.050 - 00:09:54.570, Speaker B: That basically translates a tick into a price by doing the square root of the price to the power of two I. There's some math behind it. I think most of the motivation behind doing it this way and not kind of with notations that are more straightforward are gas optimizations and they have some kind of other benefits behind the scenes. Now, luckily, we looked at a lot of math. You can dive a little bit deeper in the Q A. You don't need to know any of this in order to use or fetch prices from uniswap time weighted average price oracles on chain. This is just kind of to develop some of the mathematical intuition.
00:09:54.570 - 00:10:36.840, Speaker B: All right, so in practice, what does it look like when we want to query a uniswap pool and get the price for a given token pair? So let's look at this right here. We're importing at the top some of the uniswap interfaces. And this function takes in an address. So this address is going to point to a uniswap pool. Okay, so a pool kind of where two token pairs are being swapped and we also provide the interval. So if we kind of go back, remember we said that it's time weighted, so we need to also specify which price we want and for what time interval. So that's the second parameter here.
00:10:36.840 - 00:11:20.662, Speaker B: Now we can take a look at the code here. The first if here is just a safeguard so that we don't have any division by zero when we're getting the time weighted average price right, can't divide by zero. And let's focus on this internal block right here. What's important here is here we're getting the seconds ago, right? This is kind of specifying the range of the observations that we're going to fetch. We use uniswap interface with the address to kind of query a specific pool. And then we're using the observe method which exists on the interface. When we supply seconds ago, this is going to return the sum of the ticks, right? So if we go back here, we saw this.
00:11:20.662 - 00:11:59.314, Speaker B: This is going to give us this sigma right here. If we were looking for like a 32nd time frame that started at N, that's what we're going to get here at the bottom. Now, again, we did a summation on a specified time range and now we want to get the average. So of course we're going to divide by the interval which we provided as an input parameter to this function. So that really gives us the average and in turn the price. In this case, right, we saw here it's a square root of two to the power of I. We'll leave the math aside for a second? But this is what this does.
00:11:59.314 - 00:12:36.480, Speaker B: This is just kind of the implementation of that slide in code. So this is all you need. It's a few lines of code. You just need to know the address of the pool that you're trying to query. You specify the time frame that you want to take an average on and you literally just interface it by finding the average using the observe method which is provided on the interface of uniswap and do simple division and you're good to go. So we hear kind of all the time, or if you're kind of following DFI closely, you're doing any kind of DAP development. Oracles are always in the news.
00:12:36.480 - 00:13:06.738, Speaker B: And there's Chain link API three and also kind of uniswap. And they're different. So while the first bucket of ones that I described are all off chain, let's try and understand what are the use cases or the benefits of using an on chain. Oracle when is it appropriate? So security accuracy optimization. So, first of all, kind of a caveat in. Everything that I'm presenting right now. Oracles.
00:13:06.738 - 00:13:40.386, Speaker B: Just like any other tool in software development. It depends what job you're trying to accomplish, right? So nothing is absolutely better than the other. It's all a question or a function of what we're trying to kind of do here. Now, manipulating prices in onchain Oracles, especially ones with deep, deep, deep liquidity, is very difficult. Let's try to develop some intuition for why it's difficult. Okay. An attacker or somebody who's kind of trying to do some type of malicious activity, he can't kind of bring in a ton of liquidity for one block and then move it out the next time.
00:13:40.386 - 00:14:25.682, Speaker B: Later, to manipulate a price. If we're picking a large enough time frame for the time weighted average price movement, he or she would need to leave it there for quite a long time. Once it's in the pool, other traders would come in, potentially arbitrage it. This would be a very kind of economically expensive attack for the attacker. And kind of in a lot of cases, there's more motivation to kind of kind of mess with the prices in these deeper liquidity pools because they kind of affect more protocols in turn. So this kind of, in some ways mitigates that because it makes a lot of previously maybe attractive attacks a lot less attractive because of the prices attackers need to incur. So that's one thing.
00:14:25.682 - 00:15:19.406, Speaker B: The other thing is, when we're taking an average on an array of prices, we're a lot less sensitive to crazy spikes or drops in the price. So there could be some kind of weird trade action happening in a pool over one block that's undercorrected by Arbitragers. And if we take a large enough time frame, we're not susceptible to those because we're looking at the prices over time. So price precision. Okay, so this is maybe a kind of like it depends on the use case. Again, if you're looking for the fastest price in a second, maybe you can specify one slot, maybe one tick that you want to do. But again, the whole kind of idea behind Uniswap time weighted average Oracles is that you're looking at a range.
00:15:19.406 - 00:16:10.980, Speaker B: So it's better kind of as a lagging indicator of what's happening over the timeframe versus a singular data point from a very specific point in time, even though you can also kind of achieve that if you specify a time frame of just the last observation. All right, data sources uniswap, right? So kind of like we said, in off chain Oracles, you have the option or the ability to kind of bring data from many, many sources. When we're using Uniswap Oracle, it's looking at the liquidity in a single pool. Now, that's not necessarily bad. Uniswap is the leading dex on the market. The liquidity is often very deep, and it's enough for most cases. It's often considered kind of a source of truth when you're looking at prices of assets on the market.
00:16:10.980 - 00:16:20.280, Speaker B: All right, now we have a few more minutes, so Kyle, monitor the chat and kind of leave it open for questions.
00:16:50.990 - 00:17:17.960, Speaker A: Don't miss your chance to ask some questions real quick while we have him. Highly recommend connecting in discord afterwards. I know sometimes I remember a question right after I walk away from a conversation, so there's always a chance to continue communicating, and I highly recommend doing that. Thank you for such an excellent presentation. Day really walked us through some really cool stuff today. We do have a few more minutes. I don't know if anyone has any last questions.
00:17:17.960 - 00:17:25.270, Speaker A: I see one in the chat right now. Don't miss the opportunity, but we can close a little bit if we are wrapped.
00:17:27.770 - 00:18:37.200, Speaker B: Yeah. So I'll take a question here on can you change pool price on the data you get for coinbase? Can you change the pool price based on the data someone's asking here? Basically, how easy is it to manipulate the prices returned from the time weighted average price Oracles? So it's not that easy because the observations that are made are kind of a result of the liquidity in the pool. So for you to actually manipulate it, you will actually need to change the prices in the pool. And the only way to effectively change them is by executing trades. So this kind of goes into why it's expensive and maybe not attractive for a lot of attackers to try and manipulate Oracle data. And by the way, guys, I'm also reading questions here from another monitor, but feel free to also reach out on Twitter or Discord, like was mentioned earlier, if you have questions that come to mind, maybe after this presentation. Let's take a look here.
00:18:37.200 - 00:19:13.590, Speaker B: I see Mikhail asked a question, so let's go over that. Can you explain about the risk of under collateralization? I think there was a specific slide here that I want to talk about a little bit more, okay. About the risk. Okay. In the Q and A. Cool.
00:19:22.040 - 00:19:22.724, Speaker A: All right.
00:19:22.842 - 00:20:27.450, Speaker B: So it's not so much of a risk of under collateralization mark. Yeah. So, again, basically, like we said earlier, when pools Have Very Deep liquidity, it becomes Very expensive to kind of try and wage an attack and manipulate or modify kind of the Oracle prices to Kind Of reflect something that's not true and in kind of lower liquidity areas, kind of. The deeper the liquidity, the more expensive it becomes to do this. If it's a pool that has very low liquidity, there have been some attacks in the past weeks that we've seen, it becomes maybe financially more feasible. Again, this kind of depends on what other protocols or things might be kind of reading prices from there. And ultimately, if you have a loan that's using kind of an on chain price feed as a source of truth and you're able to trick it, it could kind of put you in an under collateralized position.
00:20:27.450 - 00:20:52.050, Speaker B: In practice, these things are very hard to do. With most pools where the liquidities are sufficient, it becomes too expensive to kind of try swap liquidity in and out or make trades just to move kind of prices. There have been use cases, but they're kind of rare. I think Uniswap V Three Oracle has proven themselves quite resilient over time.
00:20:53.460 - 00:20:55.650, Speaker C: Can I ask a question?
00:20:56.980 - 00:20:57.730, Speaker B: Yeah.
00:20:58.100 - 00:21:21.160, Speaker C: So you depending on uniswap to get the price right. And so on some pools, the pair is not a lot of people kind of buy and sell on the uniswap, but it's more active on a different pool, on different exchange. How can you solve the price difference between uniswap and other decks?
00:21:21.500 - 00:22:26.556, Speaker B: Yeah, that's a really good question. So the question is, when we're fetching a price using uniswap Oracles like we saw in the code, we're providing an address of a uniswap pool and we're treating that as a source of truth. Now, maybe this price is different than prices on Sushi or any other decks. How is that settled? All right, so in DeFi, kind of one of the most important things is arbitrage, right? So in an efficient market that's working well, you're going to have either keepers or traders who are noticing the differences in prices and who are actually executing trades in order to kind of profit from the spreads of the differences. And what they actually do is they actually bring the prices and make them kind of uniform over time across the market. So this is like something that kind of exists in all of finance DeFi, I think a few years ago, even today, there are still kind of instances of large arbitrage opportunities across kind of different exchanges. But with the pickup of activity in DeFi, there are less and less opportunities.
00:22:26.556 - 00:22:52.680, Speaker B: And that's especially true when you're looking at popular trading pairs, right? Popular trading pairs. Usually the prices are kind of very similar across different DEXes. It more can be an issue. Like if there are maybe new token pairs that are listed, they're listed in a few places. There's very low liquidity. People really aren't looking at them. But even then, there's a whole kind of research area.
00:22:52.680 - 00:23:42.324, Speaker B: If I focus on this, there are bots that can be listing for new token pair listings and try to kind of catch those price differences automatically. So it's true. To summarize, it's true that when you're looking at uniswap, you're focused on a single data source, which is what's happening in that trading pool. But oftentimes it's enough. If you're looking at a very esoteric kind of new or kind of unpopular trading pair, then maybe it's worth considering where you get the data from because you may or may not be more susceptible to this type of attack. Yeah, someone wrote here, what are the requirements of listing a token into uniswap? I think we'll leave that for it's a great question. There are no requirements.
00:23:42.324 - 00:23:57.308, Speaker B: It's permissionless. So anybody can list a new token pair and provide liquidity. That's one of the good things about DeFi, how you do it. We can leave that. Maybe it's out of scope for today. This is cool. Kenny writes, this is cool using swap and slippage info.
00:23:57.308 - 00:24:16.790, Speaker B: You should try and predict. Yeah. Another really nice thing about kind of any kind of blockchain based app is that all the data lives on the blockchain so you have access to it. You can build predictive models and try to basically understand where the price is moving. Definitely true.
00:24:26.990 - 00:24:45.858, Speaker A: Thank you for everyone coming in today. It's been a pretty killer presentation. Thank you, Omar. It's been incredible having you. I know. If anyone has any other questions following this, again, Reiterate reaching out in discord to continue that conversation or on Twitter. A great place to follow.
00:24:45.858 - 00:24:52.660, Speaker A: I don't know if you have any last closing thoughts, but I think we can end the session here today. I really appreciate everybody coming out.
00:24:53.350 - 00:25:08.860, Speaker B: Thank you for having me, guys. Good luck hacking over the next days and feel free to reach out and really recommend looking at the uniswap code because it's super clean. So I'll document did and you can learn a lot. So have fun everybody, and thanks for having me.
00:25:09.310 - 00:25:19.270, Speaker A: Of course we'll take that into the weekend. Good luck, everybody. Really looking forward to seeing what you build. We're going to be ending the session here, but really appreciate everybody's time and attention.
