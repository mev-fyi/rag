00:01:54.700 - 00:02:51.840, Speaker A: Yeah, I think we start the thing is recorded, but I'm also around at the booth for questions later, so hi, my name is Simone. I'm a solutions engineer at the company Edge and Node. That's a core dev working on the Graph Protocol. The Graph Protocol is also a sponsor of this hackathon. We will look at the prices later, but in this workshop I quickly show you how to build and publish a customized and decentralized NFT subgraph. So Eva Bailin, the director of the Graph Foundation, once tweeted and said like, yeah, if you build an app for the community but you using centralized components just for your VCs or whatever, then you're not really building a DAP, you're just building an app using web three stuff. Right, but the problem is really having a decentralized stack is quite challenging.
00:02:51.840 - 00:03:49.988, Speaker A: But I walk you through these steps. So the data storage of an NFT contract can be roughly be seen as just Google spreadsheet where you have like owners and then IDs and metadata and that's kind of the state of the blockchain. So you can always just query the blockchain, say who owns, let's say the first punk, but it's very hard to see who owned that punk before. You can do that by digging through the blockchain, but it's not easy. So that's what the NFT people call the provenance. So like who owned it before? Yeah, and the blockchain basically works like this. So you send a transaction to the blockchain and then with that transaction you change the state of the blockchain and then eventually and then immediately you can read the current state, but you cannot really read what is going on.
00:03:49.988 - 00:04:45.328, Speaker A: So what you would like to have is kind of this time travel feature that we know from macOS so that you actually have the same data, but you can actually go back in time and see how was it before and yeah, this is actually what the Graph enables. I said that this is the problem with the DApps in general. So initially the DAPs were kind of thinking about, yeah, we can have a user interface that is just HTML, CSS and JavaScript. It's deployed to IPFS, so it's already a permissionless storage and then it directly interacts with the blockchain. So everybody runs their own blockchain node on their computer in a fully decentralized manner. Time was telling this is not the case. And the biggest problem is actually blockchain is right optimized and incentivized.
00:04:45.328 - 00:08:13.240, Speaker A: So by sending transactions to the blockchain you pay gas and that gas the miners take and so they kind of are incentivized to run that stuff. But if you want to just read data from the blockchain, then you start to kind of talk to the miners and say or to the nodes and say like, hey, can I know this data? And there is no incentivization mechanism to do so. And that's the problem. EPNS uses it, so it's quite heavily used and there were like more than 1 billion queries per day on that hosted service. So that's quite a lot. And we are currently in the process of migrating all these queries to the decentralized network. So whoever has a subgraph on the hosted service and uses it currently, feel free to come to me.
00:08:13.240 - 00:08:39.600, Speaker A: I'm helping you to migrate those subgraphs over to the decentralized network. I also have t shirts and pops for those who do so. Yeah, grab me. As I said, it's a decentralized indexing protocol. Yeah, animated there are like more than 160 actually indexes world it's permissionless. So these indexes, they are kind of independent. Everybody can join.
00:08:39.600 - 00:09:16.776, Speaker A: And through that you have this redundancy across the globe that your data is always accessible. If one indexer goes down, another one is there to serve your queries. Also because they are across the globe, wherever your users are, when they query the graph, then they will receive a response from an index next to them or like from index that can give a quick result. The queries are kind of they are fast, cheap and reliable. What changes might be a little bit new is like now you pay for the queries. So that's why now the queries are incentived. So you pay a small amount for the queries.
00:09:16.776 - 00:09:46.200, Speaker A: It's not that much, but it kind of shifts this power structure towards the users who you are only in control of stuff when you somehow pay for it. Right. Otherwise we have kind of data miners and ads and stuff that try to make money out of it. Yeah. And so that's kind of the vision. We're going through this global, open, decentralized API and I would invite you to join and build on it. So this enables us to build truly decentralized apps.
00:09:47.820 - 00:09:48.184, Speaker B: Yeah.
00:09:48.222 - 00:10:18.560, Speaker A: So this is the rough overview kind of. Are there any questions about the graph on this level before we dive into the tech? No. Otherwise we are around. We have a booth come and find us. So what is a subgraph? So subgraph is kind of this piece that is at the core of the graph. You can think of it like as we saw before, the blockchain is kind of actually a mess. You have all these transactions for all these different protocols more or less on top of each other.
00:10:18.560 - 00:11:07.392, Speaker A: Now, if you want to make sense out of it and see what actually happened with let's say Sora, then you need to go through all these transactions and take the ones from Sora out and pull them together to make sense out of it. Right. So that's what happens and that's why it's so slow. But what would be nice is actually if we have separated databases per protocol which store that data for that protocols in a way that you can easily query it. And that's what actually a subgraph is. So a subgraph is the definition of how do I want to have my database schema and how do I want to put data that we see from the blockchain into that schema? And then it generates you automatically interface to query it. So in the end the lifecycle of a query or the whole thing works a little bit like this.
00:11:07.392 - 00:11:57.120, Speaker A: On the top we have the DAP. We know that kind of just the front end HTML CSS. It sends transactions to the Smart contract or to the blockchain node, which Smart contracts usually they emit events. So the graph node in the middle, it listens to those events on the blockchain. And when these events happen, they go through this mapping, which is a WebAssembly module and the mapping makes sense out of these events and stores it into the database that you see on the bottom right. And then on the other hand side, like if the DAP wants to send a query on the left, then it goes to this GraphQL API that we saw before, a very nice expressive query language to get that data out of the graph node. So this is roughly the system architecture.
00:11:57.120 - 00:12:52.704, Speaker A: So because there was this NFT NYC and because it's a cool example anyways, let's see how an NFT subgraph would look like and we can also kind of build one together quickly. So like at the nutshell, the ERC 721 standard is just you have the transfer events that you see like which token moved from who to whom. You have like this balance off function where you can check the balance of a certain address, you can check the owner and you have this transfer function that you can actually trigger transfers. So it's basically super simple. So we can look at this. When you get into subgraph development, then here are some tips and tricks. When you write the Smart contract, you should be a little bit verbal with the events.
00:12:52.704 - 00:13:33.628, Speaker A: Don't try to save gas there because you should do later in the food in kind of making sense again out of your contract. Then with the subgraph development there are these Eve calls. So let's try to not call back. Let's try to have all the data that you need in the subgraph in the event so that can make the subgraph indexing much, much faster. You can create entities for important objects and concepts. We'll look that later more in practice you can store aggregation data on those entities, like counts and stuff, and link those entities together so you can have more meaningful queries and also more explorational queries. And then there is kind of the standards NFT standards WTF.
00:13:33.628 - 00:14:31.140, Speaker A: It's a good resource but yeah, you can also ask me so then you can start to think about like okay, what kind of questions do I want to ask? What questions do I want to have an answer through with my subgroups? So for the NFTs kind of how many NFTs are there in total? How many NFTs have this trade X, who owns which NFT, what's the provenance, who owned it before? Is it available when we have on chain markets, what is the historic price, what's the current asking price and so on and so forth. So you start to think about that and then you can come up with a schema. So this is a rough schema. How I would like model an NFT. So you have a contract that's the collection has accounts about everything and it links to the owners. Then you have the accounts which are the owners. You see the holdings which will also link to the NFTs where you have the token ID, the metadata Uri.
00:14:31.140 - 00:14:56.348, Speaker A: Then you have like the events. You would just store the events. Also like the transfer the Mint bid asks and sales if you have them, block number, block hash. You want to have per event metadata and trades if available. So let's do this. So first you install the dependencies. I created actually a small GitHub repo that's here.
00:14:56.348 - 00:15:24.952, Speaker A: I will also tweet that later. So that's here on my GitHub that you actually can follow the steps. It's also linked to this slide. So basically you install this graph CLI globally to get started. And then we going to look at the hash Masks contract. So you can go to this to either scan you see that contract. So that's the hashmask.
00:15:24.952 - 00:16:11.312, Speaker A: So we know the contract address. But also what's interesting is kind of this start block, right? Because we do not want to start to index the blockchain from Genesis if we are just interested in a contract that was deployed at a certain amount of time, certain point in time. And now this one, this is actually the biggest time saver, especially for the hackathon project. If you want to quickly start a subgraph from an existing smart contract on Etherscan or on Ethereum or any other chain that is supported, not all of them are supported with this quick start. You can also do this if you can provide the Abi. It's a little bit more complex, but we want to move fast here. So what I do is just run this.
00:16:11.312 - 00:16:53.024, Speaker A: So what it does, it says, okay, graph initialize me a new subgraph. I want to deploy it to the subgraph studio which helps me to deploy it to the decentralized graph network. Then I kind of say like this is the contract address and this is the important one index event. So I want to have like a scaffold which automatically indexes the event. And then I want to have like that's the contract name I stay with hashmask, which network I'm indexing and then also the directory. So let's fire this. I did it before, now you need just me to trust me that this works because before it took very long to yarn install everything.
00:16:53.024 - 00:17:46.660, Speaker A: So I was like maybe we can skip that. So that will be the outcome. So you have this thing here. Let's make it a bit bigger. Is it big enough? So by looking at basically it's a JavaScript ish environment. So usually you can start to look at with package JSON. So we see here we have some dependencies and some scripts predefined.
00:17:46.660 - 00:18:04.232, Speaker A: So that's already good. Then the next thing that I look at is kind of the subgraph YAML here is defined like how the subgraph, it keeps it all together. It says like, okay, here are the data sources. You can have one or many. We see again. Like it's? Ethereum mainnet. This is the address, this is the abi.
00:18:04.232 - 00:18:29.504, Speaker A: These are the entities. We go later to the entities and then we also have the event handler. So this year 721, they emit these events like approval, approval for all name change. This is special for the hash mods because you can name them. Ownership transferred is also because ownable contract and also the transfer event. So this is here. And then you say like, okay, and I want to run this in this mapping TS.
00:18:29.504 - 00:18:55.240, Speaker A: But first we look quickly at the schema. This is auto generated. So like for every event, it automatically created an entity. So despite that, this is kind of named schema GraphQL. What this actually is, is kind of a database schema. It's not the exact GraphQL schema that will come out of it, but we will see that later. So everything has kind of an ID and more or less just whatever is in this event kind of stored.
00:18:55.240 - 00:19:29.112, Speaker A: And then also we have in source mappings, we also have the boilerplate stuff. We have all these handlers. Actually the most interesting one is the handle transfer. So every time a transfer happens on the Ethereum blockchain of a hash mask, this handler is triggered. And what it does is kind of it creates a new transfer entity. It creates this ID for it, which is just the transaction hash and the log index. So you have kind of canonical identification of that event.
00:19:29.112 - 00:20:10.106, Speaker A: And then you add those things to the entity and then you just save it. I mean, it's super simple, right? So you can check if everything works fine. You do yarn code gen, which generates the boilerplate code here. So it creates these helper functions that help you to interact with the entities and also the Abi helper functions. All right, so this works. I can check with yarn build if I actually can build it on my local machine. Yeah, okay, cool.
00:20:10.106 - 00:21:05.038, Speaker A: That works, right? So here it has created the WebAssembly files that I can now upload. I can go here to the graph.com studio and yeah, I'm already connected. So you connect with the MetaMask. I can go here and say like indexing Ethereum Mainnet and yeah, you're already here. And then I only need to do this graph auth and then graph deploy, I need to give a version. And then it creates again these WebAssembly files uploads.
00:21:05.038 - 00:21:57.700, Speaker A: It to IPFS and deploys this to the studio. The Graph studio is kind of a centralized service provided by Edge Node for you for easily develop subgraphs. So you see it's kind of deployed already. So I can quickly refresh here and it should index. So it already starts to scan. See, we can see here the locks and we can also see here that it didn't sync yet. All right, it will take a while, but that's okay because oh, I forgot to add the start block.
00:21:57.700 - 00:22:35.516, Speaker A: So if the start block it actually it indexes quicker. Cool, I change this and then I can just redeploy. And now probably need to give a new version and that should be quicker going back to the presentation. So this was just like the super quick start of getting started with the Graph. Now we have kind of just all the events stored in entities, but you probably want to do more complex stuff. So I'll show you some patterns. So you want to store these Immutable events.
00:22:35.516 - 00:23:06.970, Speaker A: That's actually what we did. Like events are typically Immutable events, immutable entities, because they are just happening once and you do not want to change an event after that. You just store it. And I also think about a little bit about events as the low level entities. On top of that you start to build more interesting stuff like the actual accounts, the actual NFTs, which you can derive from that event. So you see an event, so you basically see an event, it's a transfer. And by seeing the transfer, you can see okay, from who to who was the transfer.
00:23:06.970 - 00:23:32.016, Speaker A: So you have already two new entities, namely two new owners. And then you can just start to count up and down. So these are kind of a little bit the highers. But for the events I would go with Immutable. So this is the pattern for it. You can have those get or create owner helpers because you often want to get the owner or want to get the token or whatever. And it's always a little bit the same.
00:23:32.016 - 00:24:03.020, Speaker A: If you see it for the first time, you want to create it. And if you have it already, do you just want to load it and maybe add something to it? And in the schema you want to link the entities. So here the contract and the transfers are linked. And also you have the aggregation entities where you store counts. So for example, Uniswap has aggregation entities, so they store one line for every day and then just start to do the discounts so that in the end they can display their charts.
00:24:04.660 - 00:24:05.072, Speaker C: Yeah.
00:24:05.126 - 00:24:42.144, Speaker A: Before we go back to the code, there are two categories of prices from the Graph. The first is like best use of existing subgraphs. This is in my opinion, a little bit easier because you can just go for example to the Graph Explorer and then you look at an existing subgraph. You have very cool subgraphs here. So maybe this one is cool. The 721 Marketplace is one that indexes all the NFT sales actually. So you can go here and start to send your queries.
00:24:42.144 - 00:24:49.870, Speaker A: You can start to explore how it is set up, which entities you have, which.
00:24:52.240 - 00:24:52.700, Speaker D: Things.
00:24:52.770 - 00:25:24.184, Speaker A: You can just start to query it and can use the endpoint to start to query. So this is a little bit easier. You don't need to learn Subgraph development and you already kind of have the same price as for the new subgraphs. So kind of a trick. If you're a good front end developer, this is a cool track to get some prize money. The other track is the best new Subgraph. So here we expect you to write a new Subgraph and we look at complexity, innovation and that kind of stuff.
00:25:24.184 - 00:25:52.668, Speaker A: So, again, we have a first, second and third price. If you want to get some bonus points, there are two stuff that you can do. So use the decentralized graph network. That's what I showed you here. If you go to this Explorergraph.com, there is also the hosted service which you can still use. But if you use the decentralized network, you will get bonus points and also by using substreams.
00:25:52.668 - 00:26:26.508, Speaker A: So, substreams is the very new technology that we recently announced at the Graph Day in San Francisco. And it's actually kind of a new paradigm to write subgraphs. There will be written in Rust. The technology is very young, but it's very powerful. So like, if you're into Rust and into indexing blockchain data or kind of trying to stream blockchain data, think about to make your hand dirty with substreams. And that would be also kind of a big bonus point. So like, if you're writing a Substream, you will be very high up for this.
00:26:26.508 - 00:26:54.036, Speaker A: Best new subgraph. Yeah, so this is my Twitter. You can always my DMs are open. You can write me on Twitter or you come to the Graph booth. Or there's also the discord channel that you can go in. Now we can try to see if yes, if that had started to index. Yeah, already that's cool.
00:26:54.036 - 00:27:50.492, Speaker A: So see, we see, for example, like we have we can, we can check the approvals and we already have approvals here. Or we can check for the name changes. We can see which are the recent name changes that we saw from the hash masks. So this is just given by just indexing those events in my GitHub repo that I linked here, I was actually going further of then removing unused entities, extend the entities and write more stuff. Create these logical entities on top of it. And you can all kind of start to look into this. So there's the schema, how it looks like later on.
00:27:50.492 - 00:28:41.420, Speaker A: And there is kind of a mapping how it would look like if you really go through those steps. But you saw my goal for this presentation is just to say to you, look, with the graph init command, you can very quickly spin up the subgraph. It already kind of gives you very good insights, and from that you can start to explore the stuff. And if you have a very cool subgraph on the Decentralized Network on Ethereum, Mainet, and you want to publish it to The Decentralized Network, then you can click here on Publish. You say where you want to publish, and then you can do it in Rinkabee if you want to just test it out, or Mainet, if you wanted to do it. And then you can do this and really be part of the decentralization movement. Yeah, that's the finish, the end of my talk.
00:28:41.420 - 00:28:46.860, Speaker A: Are there any questions? Yes, for you to publish.
00:28:50.480 - 00:28:51.470, Speaker E: More or less.
00:28:52.500 - 00:29:33.550, Speaker A: No, publishing. So by publishing you, you should signal ten K TRT on it, and then just the on chain action is probably around 0.5 e or something like that. It's not super crazy. And for the GRTS, for the initial signal, you can actually reach out to me or to the graph foundation. So we help you bootstrap this. Other questions?
00:29:36.240 - 00:29:36.796, Speaker D: Cool.
00:29:36.898 - 00:29:46.700, Speaker A: Thank you so much for your attention. I bring my thing here again, and happy hacking.
00:35:42.290 - 00:36:19.162, Speaker E: I'll introduce myself, and I'll go into the talk in just a moment. But when I signed up to do this, I thought I was signing up for karaoke. This is not karaoke. It does have a similar setup, but it is definitely not karaoke. So just put a pin in that, because later, if anybody does want to do some karaoke, we'll probably do a little social media, maybe have a little get together at a local karaoke bar. Just follow us on Twitter or whatever social medias you all like, because I'm sure we have one there. So I'd like to introduce you to Apeworks closer to the mic.
00:36:19.162 - 00:36:53.990, Speaker E: All right. I'd like to introduce you to our company, Apeworks. My name is Evan. I'm an engineer at Apeworks, and today we're going to be learning how to Ape. So the product is actually Ape, and you may be asking yourself, what's up with all this Ape stuff? Well, let's figure it out. Okay, so Ape is an ethereum smart contract development framework. Frameworks, of course, help you with implementing things around your smart contracts if you want to maintain, develop, test, deploy all those good things, right? So a good framework starts your basis.
00:36:53.990 - 00:37:03.338, Speaker E: The other thing that's kind of unique about us in the space is that we're Python based and open source, so you don't have to pay to use our services, which is nice.
00:37:03.424 - 00:37:04.010, Speaker B: Right?
00:37:04.160 - 00:38:05.610, Speaker E: Python means that it is human readable code. So if you all have kind of dealt with some other languages where it's a little harder to understand what exactly is happening, there's a lot of numbers involved and some strange symbols. Python might be a good fit for you with that being said, we can support anyone from a beginner all the way up to an advanced user. So don't let the ease of use or simplicity of the language itself in terms of look make it feel like you're not going to get a full development experience out of it. The other good reason for using Python is that there's a lot of tool sets that exist. We really want to support data scientists and security, cybersecurity, and anybody interested in working on the blockchain with being able to access a lot of resources and little alpha leak. Here we're going to be talking about another thing that we have that's the Ape Academy, but we'll look at that in a moment, help you learn some resources.
00:38:05.610 - 00:38:45.754, Speaker E: The other thing that's unique about our framework is that it is a plugin based architecture, meaning that it's highly extensible. So as one of my coworkers says, if for some reason it does not exist, you wish to use it, just make it. We are also command line based, so you don't have to worry about our front end coding skills and how well you can kind of navigate our UI. We do provide a good UX experience through the command line. This is lightweight for us and also makes it very easy to script things. We'll see that a little later too. Plus, we also have really cool graphics and we've heard we've had some pretty good swag over the years.
00:38:45.754 - 00:39:11.550, Speaker E: So make sure you stop by and see our table. So let's see what this is like. Right, let's install eight. So it's as simple as saying Pip install E, or you can use Pipx. We've already basically installed it just like that. I can look at Ape now and see a few options that I have for running Ape as a product. And I can see some commands.
00:39:11.550 - 00:39:50.842, Speaker E: So the accounts allow you to manage basically your accounts, right? You're keeping your private key hidden and in a safe place, but allowing you to utilize your account. We'll see that we have support for hardware wallets. With that, you can compile your contracts picking multiple languages. We support Viper, solidity and Cairo. You can use Init to start a project. Networks allows you to switch, so we support multiple chains. Mention that we're plugin based and this is a way of installing and managing your plugins.
00:39:50.842 - 00:40:23.286, Speaker E: Using the plugin command run links up with the Scripts folder in our file structure and allows you to run scripts in the command line. And Test gives you access to things like Pytest and our testing suite. So, like I said before, we've got a new thing for us that we launched. When did we launch that? June 1. We just launched Ape Academy. This is our learning platform. We'll inform you quite a bit about smart contracts.
00:40:23.286 - 00:41:01.350, Speaker E: We're continuing to build it out. You should see new and dynamic content coming out through videos, transcripts, tutorials, downloadables. We really focus on viper, since we've found that in that space. Viper, which, if you don't know, is kind of a Python, ish language for writing smart contracts. So if you like the Python framework, you'll love the Viper language for writing your contracts. We have some additional information about testing up on Ape Academy that will help you test your smart contracts. So let's take just a second and look at Ape Academy, since I've already been talking about it a bunch.
00:41:01.350 - 00:41:42.100, Speaker E: So while this talk is only about half an hour long right. With some room for questions, inevitably, if you're using Ape, you're going to want to go back and reference something that either I've said or something that you want to do. You want to deep dive some information. That's where Ape Academy comes in. We've currently got some feature tutorials, including one that was just released today. My coworker Chris works really hard on creating a lot of these tutorials, and we're going to actually hands on go through deploying an ERC 20 contract in just a moment. And while we're going to go through that really quick, this will be a great place to come back and actually explore information about that.
00:41:42.100 - 00:42:39.614, Speaker E: So please check out Ape Academy. So one of the features that we also have is something called Ape template. So if you don't really know where to start on a contract and you want some rough framework for yourself, you want something that works out of the box and that you can easily customize. This is where Ape template really shines for us. So essentially, when you download Ape, the plugins, we don't decide for you what plugins make sense for the kind of project that you're working on, right? If you are never touching solidity or you're never touching Cairo, why should we kind of bulk up your system with additional plugins that you may never use? So this allows you to really customize and pick what things that you want to focus on. So with that being said, to use template, we're not forcing users to go ahead and have that as a download. It's an add on for you.
00:42:39.614 - 00:43:08.840, Speaker E: We do have a recommended plugins list that you can download. If you're just getting started, you're like, hey, yeah, let's go for it. So to install a template, we'll watch a little video here in just a second. And we're going to focus on the ERC 20 token. There's a standard for it, hence the ERC 20. The files that are generated. There's a token Vy file, which is a Viper file, and that is the ERC 20 standard.
00:43:08.840 - 00:43:36.814, Speaker E: This is for a fungible token. We've heard a lot about NFTs, but what was an NFT before an NFT? It was fungible. Right? Hey. So these are identical tokens. Another contract that we support is an ERC 721, which is the NFT standard. Once again, that's a non fungible token and therefore unique, and it has metadata associated with it that. Allows for linking assets and other things.
00:43:36.814 - 00:43:56.310, Speaker E: You can see on the right hand side here that it is on the right for you. All right. Or is it just for me? Okay. Sweet. Kind of the file structure that is created when you use the template. So let's build this real quick. So I can type in Ape plugins and point that to an install of template.
00:43:56.310 - 00:44:28.142, Speaker E: Should be fairly quick here. And now that it's installed, I can use it by calling Ape template and pointing it to the GitHub repository that I wish to connect to. This could also be an Http address. And this uses cookie cutter. So anything that is in square brackets is kind of a default value. Anything that I type in will override that default value. And so a lot of the interfaces that are going to be used in this token contract, you can decide whether or not you wish to engage with, right.
00:44:28.142 - 00:45:03.444, Speaker E: Whether you want to pre mint, whether or not you want something mintable or burnable or permittable. So I just let the defaults happen there and we can see that it's created the file structure for us. So I'm going to take a second to step away from the videos here and actually look at the structure. Hopefully this is big enough you can kind of see it. Everybody, we good? All right. So this is that same demo file that we had on the video earlier. And we can see the contract folder.
00:45:03.444 - 00:45:49.440, Speaker E: This is everywhere when you utilize Ape that you're going to store your contracts. You can have nested folders within there, but kind of starts with contracts. It's fully configurable. So if you don't like the word contract and you want to have, I don't know, letters or code, snippets or, I don't know, whatever you want to call it, you can customize that. It's one of the great things about our tool set is it's highly customizable. So just briefly looking at it, we can see where I overrode the words demo and DMO as the symbol for the token left 18 decimals as a default value. And once again, a shout out to Chris if you use Ape Academy and look at his video.
00:45:49.440 - 00:46:25.316, Speaker E: I had that up here earlier. Yeah. On how to make an ERC 20. He really goes into depth. There's both a transcript and a video here of all the components of setting this up and then telling you kind of the breakdown of the contract itself and even giving some tips about how you might use it or what it might mean to implement a certain interface. The other thing you have here is the scripts folder. So this allows you to use Ape run to run your scripts and that will automate a lot of your processes.
00:46:25.316 - 00:47:16.970, Speaker E: If you wish to have a more interactive experience, we have Ape console that we'll see in a moment when we do querying that allow you to do more of a hands on interactive environment with locals available to you. So the scripts folder that we have here has a deploy currently script in it. That's very simple. This is just going to ask me what account do I want to deploy with and then it is going to do the deploy action for me. The other thing that's really nice about using this template is that you get some things pre built inside of it. As far as the tests go, we give you some fixtures straight out of the box so that it can support these pre made tests around. Some of the questions that we were asked earlier, like do we want it to be able to be mintable? Do we want it to be burnable? Right? So the tests are already kind of built for you out of the box.
00:47:16.970 - 00:48:00.020, Speaker E: And the last thing I want to cover, at least in this screen, is the Ape config YAML. So inside here, you can basically configure your project to interact with the Ape framework and create a lot of overrides as well. We see that. Right now, all I'm doing is specifying that I have a dependency of a plugin, that is the Viper plugin that will help compile to the Abi code bytecode that I need to deploy. We'll see this compile. And one thing you'll also note is that we're going to use confirmations. So knowing that the block can change just a little bit as we're adding to it, right, we want to make sure that it's at a stable point before we consider our contract to be fully deployed.
00:48:00.020 - 00:48:57.020, Speaker E: If we wish to override any of these, we can actually do that here in the YAML. So with that said, let's try it. So I'm going to go I want to run this script that I've written or that's been generated for me, the deploy script, so I can say Ape run and I want to do deploy. And the thing is, I'm not ready to deploy this to mainnet just yet. I would like to use a test chain, right? So I'm going to use the network flag network to position this to which chain I actually want to use, what provider and what network and what ecosystem. So I want to use Ethereum and I would like to use Rinkbee if I could type. And lastly, I would like to use Alchemy as my provider.
00:48:57.020 - 00:49:25.004, Speaker E: So it's bringing up some accounts that I've already set as personal accounts. And I've given an alias to so that I at least know which account works for me. I'm going to select my account and I get a signing prompt here which at least allows me to look at the gap. So beforehand I can be like, yeah, that's acceptable to me. I would like to do that. I will sign. I'll enter my passphrase.
00:49:25.004 - 00:49:59.732, Speaker E: Please don't steal it. It will ask me if I want to leave this unlocked. I might have additional things that I wish to do and I don't want to have to unlock it every single time. For now, I'm going to say no. And now what I can see is it has begun the process of making sure that it is confirmed on the block. We can already go ahead and look at this Etherscan link. Etherscan is another plugin that we support and the Internet is just a little bit slow.
00:49:59.732 - 00:50:56.370, Speaker E: So we'll wait for this to load. Yes. So we now see that it has successfully the transaction itself is successful. The next thing we would want to confirm once we wait for the two confirmations here, is that the contract itself might be hitting that a little hard with the retries, is that the contract itself has deployed. So I can go back to Ether scan and check that my token is now available and we see demo token. ERC 20 DMO is the symbol. So we have actually, if you all want to even go out on the testnet on Rink B right now, you can see that I just deployed an ERC 20 token.
00:50:56.370 - 00:51:44.616, Speaker E: What, no claps? Hey. Thank you. All right, so we talked a little bit about the plugin architecture. Let's dive just a little bit deeper because one of our bounties is writing a plugin, so you might say Evan. All right, what's this plugin thing about? We got Ape Core, which is basically the glue and defines how these components are going to interact with each other. You have some core plugins that come kind of out of the box as soon as you download Ape. That are Ethereum guest Ethpm, which is a package manifest sorry, had a brain fart there.
00:51:44.616 - 00:52:15.570, Speaker E: Package manifest plugin. And then East Tester, which helps to set up and supply some of the locals that you can utilize in the testing environment. So then we have what we call supported plugins that are written by Apewworks employees like myself. They kind of fall into some different categories. We have compilers, so these are language based. This is what's going to convert your Viper Solidity Cairo into an Abi or contract type bytecode. Right.
00:52:15.570 - 00:53:10.770, Speaker E: Currently support hardware, wallets, ledger and tracer. This makes for a really great way of not exposing your private keys while interacting with the chains. We support L, two ecosystems like Phantom and StarkNet, which I do want to give a shout out to one of my coworkers for making the first non EVM plugin, Jules, who happens to be with us today. And we also have provider plugins like Hard Hat you saw me use Alchemy earlier in Fura and Foundry is currently in Alpha. We have a lot of projects that are currently in alpha and we'd love for you all to have a project in Alpha. Beta, gamma production, whatever. Right, so you're saying, Evan, how do I make a custom plugin? Well, let's walk through that real quick.
00:53:10.770 - 00:54:17.028, Speaker E: So the first place to start if you want to go for this bounty or you're interested in plugins, I would say is to look at some examples of plugins that we've already written. So if you want to know something about like Ape Solidity, you want to write a different kind of compiler. For languages, I would take a compiler API and kind of begin looking down that path providers, maybe something like infura using the provider API tracer using the count API. Or if you want to make a CLI extension, ape Tokens wraps the token list and provides that through the CLI. So here are the bare minimum requirements, right? You've got to start with Ape underscore give your plugin name, generally whatever the plugin is about, right? And then you kind of pick your own adventure here. This is an and or you can do both things. You can choose to do one thing, but you've got to implement one or more API classes from the Ape API module and or make a subcommand and point it to your entry points in your project setup.
00:54:17.028 - 00:55:22.940, Speaker E: If you're looking for ways to kind of organize your file set and look at the standard that we've already kind of created, we actually have an optional project template in GitHub that you can utilize. So as for the adventure path of implementing the API classes, here's a quick example of using the Alchemy, like we saw that I used earlier. You want to import the API class and then make that the base class. So, unfortunately, I cropped off the line numbers here, but where it says Alchemy Ethereum Provider and it has Web three Provider and Upstream Provider. Those are where you're utilizing your base class with the APIs, right? So a Web three provider allows access to the web three chains, and an upstream provider allows for forking. And you can see kind of here, even though I've collapsed everything, you've basically implemented the abstract methods for connect, disconnect, establish or not establish, but estimate gas cost and send transaction. So the details of how these things are done, you decide.
00:55:22.940 - 00:56:16.220, Speaker E: As long as the interfaces connect together, right? It makes sense. The next step to that is registering the API class, which this is a separate file. And we just see that we have a list of networks that we're providing within the Alchemy mainnet, robstein Rinkbe, which you saw me utilize, so on and so forth. And then we just yield after registering the plugin. Ethereum being the ecosystem name, whatever the name of the network is, which in this case would be Alchemy, and then the provider itself. If you're creating a CLI extension, you can look at an example like Ape Tokens, which wraps a token list. And we can see some click commands here and click groupings.
00:56:16.220 - 00:57:05.310, Speaker E: And the next part of that is just to register your entry points. So between lines 67 and 70 there, we see entry points. And we're just saying Ape Tokens as a command is actually going to point to the Ape Tokens library looking at the underscore client or CLI file and then point CLI method. And the final thing I'll leave you with is how to query the blockchain requirements here are just that you're connected to an active provider. We're going to look at this real quick in Ape Console, which is an interactive Python environment that has locals such as chain there's much more, but we'll point you to additional things in Ape Academy for the rest of it. But essentially it returns a data frame that lets you do some really neat things. So let's do that just really quick.
00:57:05.310 - 00:57:58.400, Speaker E: If I can find my there it is. Okay, so Ape console this time I'm doing a network of Ethereum mainnet and let's do infura. All right, so I currently have an active session here and I want to set up a few things. So I'm going to copy paste here. So the first thing I'm going to do is set up my stop block, which is going to look at the chain and get the very last block and get the number of that block. So if I want to know the last block there we are. Then I'm going to set up my start as being 50 blocks before the last block.
00:57:58.400 - 00:59:12.530, Speaker E: And then I can do something like looking at the average gas used over those 50 blocks. TADA. Or I could do something like looking at the average time of creation over those last 50 blocks. Like, how long does it take for a block to be generated? We're up to 17 seconds. This morning it was 14, so that's fun. Or we can do even more complex things like set up visuals with Matplotlib. So if I generate blocks and I go back over the last 20,000 blocks in steps of 1000 because I'm wanting to aggregate some data here and I use Matplotlib for the visualization and then a little magic here and let's show it, we can actually create some graphs based dynamically on the blockchain.
00:59:12.530 - 01:00:26.550, Speaker E: All right, and what's my time looking like? I got two minutes or so. The last thing I want to do is give a shout out to the bounties that we're running. So if you want to do any kind of smart contract project using Ape, we have a kind of first place at 3002nd, place at 200, 500 if you write a plugin, which we kind of went through 3000 for. That one and going over, like the blockchain data that we just did. That's 3000 for coming up with a really good story utilizing those analytics. Any questions? Yeah, so the question is about the Ape console. What kind of environment essentially is that? And it's essentially an IPython that has additional locals injected into it so you can access the eight specific functions, but you do have the full Python environment available to you.
01:00:26.550 - 01:00:46.270, Speaker E: Any other questions? All right, well, I will see everybody at the Karaoke later. Please be sure to hit us up on Discord, check out our GitHub, read our docs. We're kind of cool, just saying. But I'll talk to you all later.
01:04:13.150 - 01:04:19.340, Speaker B: Okay, let me start timing myself. All right.
01:04:20.750 - 01:04:21.162, Speaker E: Hello.
01:04:21.216 - 01:04:21.578, Speaker C: Hello.
01:04:21.664 - 01:04:54.214, Speaker B: My name is Kelvin. I work on optimism, which, if you don't know, is a layer two on Ethereum, one of the cool ones. And I'm going to spend this is going to be kind of a different talk than normal. I'm going to spend 1 minute showing you how to deploy to optimism, and then 29 minutes looking at cool, solidity EVM tricks. This is not all of the EVM tricks, because there are so many of them, but these are the cool ones. So here we go. All right, so back last year, optimism was really hard to deploy to.
01:04:54.214 - 01:05:15.046, Speaker B: It was really annoying. You used to have used this thing called the OVM, and you had to compile your contracts with a special OVM compiler, and it was a whole mess. So we rebuilt the thing and made it easy. So you don't have to do that now. It's just like deploying to any other network. So I'm not going to actually deploy, but I will show you how to do it. If you want to do it through remix.
01:05:15.046 - 01:05:33.326, Speaker B: If you really want to do this through remix, I guess you can use some tool to get connected to the optimism network in whatever your wallet is. I built this simple website called Chainid Link that you can use to connect to a bunch of different networks. So you can try that or chainlist.org, blah, blah, blah.
01:05:33.358 - 01:05:33.554, Speaker C: Right?
01:05:33.592 - 01:05:42.134, Speaker B: Get connected to optimism, change your network, go there, write a contract, deploy. That's it. You don't have to do anything special. It's just like deploying to Ethereum. Or you pick a different network, right?
01:05:42.172 - 01:05:42.760, Speaker A: Easy.
01:05:44.250 - 01:06:28.786, Speaker B: Same deal with hard hat, right? All you do is you set up a hard hat project and you add optimism to your hard hat config, and then you write a contract and you deploy with network optimism. How do you add optimism to your hard hat config? Well, here's the details of if you go to Community optimism IO, it'll tell you how to do all of that. It'll tell you what endpoints you can use. It's just like adding any other network to your hard hat config. It's really easy. And if you go to Dev docs, where are we using your favorite tools? There's a whole page on how to do this. Let me zoom in a little bit.
01:06:28.786 - 01:06:36.386, Speaker B: There you go. Here's an example of how you can add it to your hard hat config. Just add the URL. It's just like ethereum. Great. Fantastic.
01:06:36.498 - 01:06:37.160, Speaker C: Okay.
01:06:39.450 - 01:07:08.334, Speaker B: Same deal with Truffle. So that same page, community optimism IO, it just tells you how to add it to your Truffle config. It's really easy. You just write a contract, then deploy with network optimism. Just like you would do if you were deploying to Polygon or if you're deploying to Testnet or whatever, you just specify a new network. And that's because we did a lot of work to make sure that it was fully what we call EVM equivalent. So it just runs geth under the hood, and that's pretty cool.
01:07:08.334 - 01:07:37.034, Speaker B: Same deal with Brownie, except you don't even have to add optimism to your config for Brownie, you just do network optimism, and it's built into Brownie, which is very cool. Thank you, Brownie. That's basically it. That was longer than a minute, so too bad. All right, now the fun part of the workshop, EVM tips and tricks. A lot of them you will not want to use in production, but it's still fun. All right, so Invalid, let's start there.
01:07:37.034 - 01:08:01.402, Speaker B: Number ten. We'll do a top ten, invalid. Invalid is a really cool Opcode because it just reverts, sort of. It does not actually revert. It triggers what we call a non EVM error. Non revert EVM error. And what this means is that there's a class of errors that are not reverts that will cause your call to end and you will lose all of the available gas.
01:08:01.402 - 01:08:38.858, Speaker B: So an example of this is like a stack underflow. Let's say you try to pop a variable off the stack and there's nothing there, you're going to get an error like this. Invalid is really cool because originally people just started using this Opcode. They just picked it and they started using it. And it wasn't defined as an EIP, it was kind of defined by social consensus. And then in EIP 141, they set it aside as an official Opcode called Invalid, and it is the most efficient way to burn all of the gas that's available in a given call frame. So if you ever need to burn gas really quickly without actually doing work, you just trigger this Opcode and all of your gas will disappear immediately.
01:08:38.858 - 01:08:57.790, Speaker B: Very efficient. Okay, call code. Call code. I want to see someone actually find a use for callcode. Callcode is basically really useless. It's like the original version of delegate call, except they got it wrong. Delegate call, if you aren't familiar, is really useful for proxies.
01:08:57.790 - 01:09:31.200, Speaker B: And what it does is it allows you to run the code of another contract, but you still maintain the message sender and the value and all that stuff. So it allows you to do a proxy call. Code was really useless because it would call the code of another contract, but it would also change the message sender to be the address of the contract doing the calling. And so it never actually worked as a proxy. I don't know if anyone actually uses call code, but if you do, tell me, because I don't understand why you would use it. So that's just out there. Yes.
01:09:31.200 - 01:10:33.250, Speaker B: Why would you want to burn all the gas in the call? That's a really interesting. Well, optimism actually has one use case for this. I don't know if it's the only use case, but it is one where as a trick, because message value is really annoying and if you mark something as payable in solidity and then you want to call another function, you want to pass along value, that other function has to be marked payable too. And so one example of why you might want to do this is that what optimism does is when you send a message from Ethereum to optimism, you have to pay for that message somehow and you could make it payable. But now app developers, whenever they want to pay for a message have to make this whole chain of functions payable and it just looks really weird. And your users have to send value with a transaction which they're not used to doing. And so the trick was, well, why don't we just burn a bunch of gas on l one? And we wanted to do this in a way that wouldn't actually put a pressure on nodes because if you're actually doing work, you're putting pressure on nodes.
01:10:33.250 - 01:11:30.690, Speaker B: So we can just burn the gas really efficiently by just starting a new we do a call and then we just trigger the invalid opcode and then all the gas is gone and it's sort of how you pay for it is by burning gas, if that makes sense. All right, the identity precompile ethereum has a bunch of pre compiles. They're pretty cool. The identity precompile is probably the weirdest one. It's located at zero x blah blah blah four and all it does is it returns whatever you give it. So if you give it some call data, it's going to return that call data to you, which sounds really useless and mostly is really useless, but it is useful in certain cases. If you want to gas golf for copying lots of memory at a certain threshold, just doing straight up memory copying by taking reading a word of memory and then rewriting, it gets to be expensive.
01:11:30.690 - 01:11:57.366, Speaker B: So it's easier to just do a call and insert all of this call data and then say I want it to be returned over here instead and it's cheaper. So fun. If you want a gas golf, generally not that useful otherwise. Although it is also the source of various geth bugs. So risky. Pre compile. Okay, solidity tricks.
01:11:57.366 - 01:12:39.894, Speaker B: These are kind of mixed EVM and solidity tricks. I feel like I'm going a bit fast here, so I got to slow it down a little bit. Solidity exposes contract type information. If you aren't aware of this, you can use this type and then my contract and it gives you meta information, so it gives you stuff like the name of the contract, the creation code, the runtime code and the interface ID. All of these things are pretty useful. The name maybe not so much, although I could see use cases for it where let's say you want to do like a let's see what's a good example you could do something like I don't know what you would do. Do some version string, return some version string and it involves the name of the contract.
01:12:39.894 - 01:13:04.802, Speaker B: I don't know, whatever. The creation code though is really useful. If you want to, let's say, make instances of a contract, you can basically get access to the creation code instead of running new contract. You can do like a low level create and there's sort of useful cases for why you might want to do that.
01:13:04.936 - 01:13:05.620, Speaker C: Yes.
01:13:10.310 - 01:14:01.700, Speaker B: Sorry. So I will actually talk about this a little bit later. But in Ethereum when you create a contract, you have two sort of types of code. There's the creation code and the runtime code. And what happens is, or what happened was that Ethereum really wanted constructors and so what they decided to be able to have constructors was when you call the create opcode, you pass it some EVM bytecode and that EVM bytecode actually executes and whatever that EVM bytecode returns becomes the code of the contract that you have created. So every contract has these two pieces, the creation code and the runtime code. And so the creation code runs when the contract is being created and it's expected to return the runtime code.
01:14:01.700 - 01:14:55.782, Speaker B: And this is of course really useful for Constructors because it means that in the creation code you can do stuff like set a bunch of storage to initialize the contract and then once you're done, you can return the code and the contract has done some work in the initialization step. And then the Interface ID is really useful if you've ever used EIP one six five, which is this supports Interface thing where you can query a function and the function will tell you what interfaces a certain contract supports. You can just really simply return type myContract Interface ID and that's a very easy way. Instead of having to do this like whole XOR of different stuff, it does this for you. So very useful. Saves you a couple of lines of code. All right, another one that not a lot of people know about, but it's pretty cool.
01:14:55.782 - 01:16:06.810, Speaker B: Solidity has function types so you can actually pass references of functions into other functions which allows you to do things like Map, right? So this is one of the examples from the Solidity docs where you can let's say you want to define a Map function and it takes an array as the first parameter, an array of uns and it takes a function that takes a UN and returns a uint. And what Map is going to do here you can see it's going to create a results array and then it's going to loop over the input array. And then you can see here it's applying the function to each input value to generate the outputs. So this is pretty cool. You can do this for a lot of interesting things where you just want to save some code or save some lines of code by just passing functions around. It can be a little finicky sometimes with typings and external and public. I don't know if this has been fixed in more recent versions of Solidity, but when this first came out, it was a little finicky, but should mostly work and a cool way to do a little bit of this meta programming.
01:16:06.810 - 01:16:20.762, Speaker B: Okay, related to this, Solidity recently introduced this thing called Abi encode call. So if you have been writing Solidity for a while, you probably know.
01:16:20.836 - 01:16:21.460, Speaker C: Yes.
01:16:26.310 - 01:16:32.340, Speaker B: I believe so. Yeah, probably try. It should work.
01:16:35.290 - 01:16:36.070, Speaker D: Yeah, probably.
01:16:36.140 - 01:16:38.200, Speaker B: I mean, if it doesn't work, we'll find out.
01:16:40.250 - 01:16:41.010, Speaker C: Solidity.
01:16:41.090 - 01:17:40.806, Speaker B: Okay, so people are probably familiar with the classic Abi encode and Abi encode pact, but Solidity also has these cool things abi encode with signature and Abi encode with selector, which is really good for encoding function calls to other contracts. And relatively recently, the problem with these with encode with selector and encode with signature was that it wasn't type checked. So you didn't actually know if you were properly encoding the call to the target contract until you started testing. Presumably you write tests that show you whether you're properly encoding this or not, and you get some sort of error when you run your tests. But recently, Solidity introduced Abi encodecall where you pass myContract myfunction selector as the first parameter and you pass the params here. And in Solidity will actually compile this type check. It make sure that you are properly encoding your calls to the other contracts.
01:17:40.806 - 01:17:52.720, Speaker B: So this is a great way to make sure that you are encoding things correctly and save yourself the headache of having to write a bunch of tests and only finding out later that you mess something up.
01:17:53.410 - 01:17:53.822, Speaker A: Cool.
01:17:53.876 - 01:18:00.858, Speaker B: And that takes advantage, of course, of the fact that you can pass in function references. Well, in this case, I guess it's using the selector, but whatever.
01:18:00.964 - 01:18:01.860, Speaker C: Same idea.
01:18:03.430 - 01:18:44.154, Speaker B: All right, this one is something that not a lot of people know. You cannot deploy contracts that have bytecodes starting with zero x EF or actually just zero x EF, which implies zero x EF, but really it's just zero XEF. You're not allowed to do this. Try it. Try deploying a smart contract to Ethereum where the bytecode of the smart contract is zero x EF. You can't do it. And that's because of this thing called the Ethereum object format, which was starting to be introduced, which is I'll talk about when it was introduced.
01:18:44.154 - 01:19:49.618, Speaker B: And the Ethereum object format was initially trying to solve this problem of right now, code and data in smart contracts are the same thing. And this is how you get these weird things. Like technically, the constructor is something that you can jump to and execute, or technically, the hash at the end of the smart. Contract that solidity appends is code that you can jump to and you can run that code and you can use it to do cool capture the flag things or whatever puzzles. But this actually creates problems in the EVM because the EVM has to look for every single every time you do a jump in the EVM, it has to figure out is this somewhere I'm legally allowed to jump to in your code? And in order to do that, you have to check is the thing that I'm jumping to a jump desk opcode. And there's all these different things. But basically we can eliminate a lot of this analysis by explicitly separating code and data.
01:19:49.618 - 01:20:55.670, Speaker B: But you can use this ethereum object format to do a lot more interesting things. But of course we don't have this right now, so how do we make sure that we will have it in the future? We define some prefix and we block people from deploying contracts with that prefix. And then in the future we'll allow people to deploy that contracts with that prefix. Again with the assumption that the EVM reads that prefix and it says okay, I know that if it starts with EF something, this is an ethereum object format compatible smart contract and I know that it's going to have the following format and I'll talk a little bit about what you can do with that. How is this possible? So what happened was in the London hard fork EIP 35 41, it was announced that all contracts starting with zero XEF would be blocked. So of course people started deploying contracts that started with zero XEF. And then what people did was they just looked on chain and they figured out, well, sure they deployed something that started with zero X EF, but they didn't deploy anything that started with zero X EF.
01:20:55.670 - 01:21:29.490, Speaker B: So we'll just pick that instead and you can't deploy any new ones. So good enough, it has the potential to be really cool. So the EOF ethereum object format contracts would start with zero X EF and then a version byte. And that version byte tells the EF how it's supposed to parse the contract. So one example here is that let's say this is a version zero contract. We'll say that there is a specific area here defined as the length of the to tell you the length of the code. Then you have the code and then you have the length of the data and then you have the data, or something like that.
01:21:29.490 - 01:22:02.714, Speaker B: And you can also use the same trick to deprecate opcodes. So you can say, let's say that nobody is allowed to deploy any more version zero contracts and in version one you are not allowed to deploy a contract that includes some opcode that we don't want people using anymore because we hate it. So we can do this really interesting stuff. So not technically out yet, but will be and will be really cool. Create two. Okay, so this is something that you might already know. Create two is really useful.
01:22:02.714 - 01:22:33.542, Speaker B: If you don't know it, you should be using it more often. If you do know this, great. If you don't, you should. The original create Opcode, as it says here, generates addresses based on the creator address and the creator's nonce. But create two generates addresses based on the creator's address, the contract code, and the salt, which means that they're basically deterministic. And it doesn't depend what chain you're on. You can deploy the same contract to every single chain, which is really important, especially in the multi chain world.
01:22:33.542 - 01:22:51.102, Speaker B: You don't want a situation where two contracts can exist on different networks at the same address, but have different code that can be damaging. So use it generally more secure, be a little careful, whatever.
01:22:51.236 - 01:22:51.534, Speaker C: Fine.
01:22:51.572 - 01:23:28.598, Speaker B: I'm going to skip that. Self destruct is extremely sus, but it has some cool stuff. So self destruct will delete a contract from the state try, and it will transfer its balance to the beneficiary. Very cool. Very cool Opcode. A lot of people hate it and it's created a lot of bugs for people, but whatever. So a contract is sus, or self destruct is sus, because a contract that uses self destruct can delete itself and then it can be recreated at the same address with completely different code, which is kind of a cool way to do upgradable smart contracts.
01:23:28.598 - 01:24:19.018, Speaker B: And I think some people have done this before. It's a little terrifying. And there's definitely been situations where block explorers don't work or you end up with a parody situation where somebody just hits the kill button or whatever and you can't do anything about it. So be very careful with that. And then self destruct is the only way to send ETH to another address without triggering its code, which can be very useful if, let's say, a contract has code in it that says, when I receive ETH, revert immediately. So if you want to forcibly send ETH to somebody and they can't do anything about it, just use self destruct. Remember that if you're auditing a contract, make sure that you don't make assumptions about a contract not being able to receive ETH, because you will be able to receive ETH no matter what.
01:24:19.018 - 01:24:44.500, Speaker B: And it's also the only way to permanently delete ETH from the supply. So yes, of course you can send ETH to a burn address, like the zero address, but it's still technically in the supply even though it's not accessible. Self destruct is the only way. If you self destruct to yourself, it's the only way to delete ETH from the supply permanently. It just gets poof, it's gone. Right? All right. Yeah.
01:24:44.500 - 01:25:11.514, Speaker B: Self destruct just does it in the code for self destruct. It basically when you trigger the opcode, it will just increase the balance of the recipient and it won't actually trigger a call to the recipient. So it's the only way to do it. I'll have to run through these because I'm actually getting quite tight here. Block hash is the ultimate oracle that nobody uses. I wish more people did. It's really, really cool.
01:25:11.514 - 01:25:32.302, Speaker B: Block hash obviously contains information about the entire Ethereum blockchain. It's a blockchain. So the block hash contains information about the current block, but it also contains the previous block hash, which means you have a chain all the way back to block zero. And using merkel, Patricia try proofs. You can access literally anything in the Ethereum. Try not enough people do this. It's really cool.
01:25:32.302 - 01:25:50.226, Speaker B: Optimism has built a library for verifying merkel. Patricia, try proofs. So you can do this on chain and you can read the storage of other accounts. You can read event logs, you can do whatever, right? Everyone says like, well, contracts can't access events. No, they totally can access events. You just need to do a merkel. Try proof.
01:25:50.226 - 01:26:15.280, Speaker B: It's expensive, but you can. And there's a lot of reasons why people didn't want people to access this stuff. But anyway, you can access it. It's the ultimate Oracle and no one uses it. And I bet you could build a really sick hackathon project by just doing some unexpected thing by reading information from the Ethereum state. Like you can literally just go and read the storage of any other contract. You normally cannot do that.
01:26:15.280 - 01:26:57.222, Speaker B: Block hash only goes back 256 blocks, but you can always walk backwards by doing proofs. So you say, well, I'll prove about the current block and then I'll show you the contents of the previous block hash. And I'll just repeat this because the previous block hash contains the block hash before that. And you just go on this chain backwards. And Optimism really wants to build a block hash Oracle. So we would kind of have a chain of block hashes into eternity. So if you're interested in working on that as a hackathon project, it would be really cool, kind of like a collaborative way for the entire Ethereum community to store every block hash so that we have access to it, not just for the last 256 blocks, but for every single block.
01:26:57.222 - 01:27:39.186, Speaker B: Requires a lot of proofs, but I'm sure as a community we can do it together and great. So create this is number one. This is probably the coolest one that people don't really think about. When I talked earlier about contract creation, I said that create, executes init code this initialization code creation code and whatever that code returns becomes the contract code. And the secret thing in here is that create, executes the init code. So create, executes arbitrary EVM bytecode. You can literally just pass whatever you want, right? I don't actually have to create a contract.
01:27:39.186 - 01:28:05.890, Speaker B: I can pass push one, push one, add as the instructions, as the init code. And what it's going to do is it's going to push one to the stack. It's going to push one to the stack, it's going to add the two, and then it's going to have two, the value two on the stack. And then I don't know, then it just stops and it doesn't do anything. But what you can do is you can execute arbitrary bytecode. You can do whatever you want. You don't actually have to create a contract.
01:28:05.890 - 01:28:53.126, Speaker B: You can do math or whatever. You can basically have like, user provided scripts that you run and you can kind of do whatever you want. So you can make a simple scripting language where let's see, what did I yeah, okay, so here's an example, right? You could put let's say you want to do like, a scripting language that doesn't actually change state. You can do something like put all the inputs in call data, run, create with the user script as knit code. So it just runs these EVM opcodes. Then the user script reads the call data, so it reads the inputs, and then the user script is going to revert so it doesn't actually change anything and you read the result from the return data. The other reason to revert here is that, like I said, this is still a contract creation.
01:28:53.126 - 01:29:50.574, Speaker B: And if you return, then it actually goes and creates a contract with whatever is in the return data. But the EVM has a quirk where if you revert, then whatever you return, instead of being created as a contract, just gets put into the return data buffer so you can read it. So optimism almost did this. I was too scared to put it into production, but I built it where we had this whole system of these contracts that would drip ETH to other contracts. And originally I wrote this whole system where I wrote this whole system where we could provide these small EVM bytecode scripts. And the EVM bytecode scripts, they would get created and they would have to do a bunch of work, and they would have to either return or, I guess revert with a zero or a one. And if it was a one, that meant that I could go ahead and do whatever I wanted to do.
01:29:50.574 - 01:30:08.986, Speaker B: If it was a zero, that meant don't do this, it didn't work, revert, whatever. So, yeah, I think there's a lot of fun stuff you can do with this and nobody really does it, which means that I think you would look cool if you did it. Was that 29 minutes just about interesting.
01:30:09.088 - 01:30:09.740, Speaker C: Okay.
01:30:13.070 - 01:30:39.362, Speaker B: I was not expecting to get this far. Okay, no, that was 29 minutes. One bonus trick. One bonus trick. You can actually insolidity if you drop into assembly in the constructor, you can use the return instruction in the constructor to return whatever you want. And that returned bytecode becomes the code of the contract. So if you wanted to, I don't know, return, I don't know what you could return.
01:30:39.362 - 01:31:02.902, Speaker B: You can return whatever you want and that becomes the code of the constructor. And so you can do some really deranged things like in the constructor, read the code, replace the code with other stuff to be able to use Opcodes that Solidity won't let you use and then return and you do just all this hacky stuff that you should never do in production. Great. Okay, that's exactly 30 minutes. Perfect. Optimism is hiring, as always. Optimism.
01:31:02.902 - 01:31:08.810, Speaker B: Op Labs or just come hack. I'll be downstairs hacking on some deranged Solidity.
01:31:09.970 - 01:31:10.286, Speaker C: Cool.
01:31:10.308 - 01:31:14.640, Speaker B: If you have more questions, we can talk afterwards. All right.
01:34:23.260 - 01:34:54.732, Speaker D: All right, I think we're good. How is the am I close enough to the mic? I think I am. All right, fantastic. Thank you guys for all being here. What's up guys? Today we'll go through what Superfluid is and then we'll walk through building a money streaming application on one of the just well known Ethereum testnets. So first and foremost, what is Superfluid? So Superfluid is a protocol which enables real time finance. So what that means is we allow you to build digital native programmable cash flows.
01:34:54.732 - 01:35:55.504, Speaker D: And this includes things like streaming money with no capital lockups in a way that is 100% programmable and on chain. So one thing we think about a lot in this broader ecosystem, we think we're all building this Internet of value. So what we believe is that the Internet is to information, what blockchain is to value. And one place that we're trying to add value in this area is in real time finance. Right? So in the traditional financial world, when you provide a service to somebody, I provide the service, and a lot of times that service is decoupled from the payment that I receive for that service. Right? So if I provide a service to you as an employee at your company, I get paid maybe once a month, when in reality, I'm providing value every single day that I work or every single hour that I work. So why shouldn't you be paid for every single second that you're working? Or if I'm providing a valuable service like I'm Netflix, or I'm providing computational services like AWS, why shouldn't I be getting paid every single second the service is being provided?
01:35:55.552 - 01:35:55.716, Speaker E: Right?
01:35:55.738 - 01:36:38.280, Speaker D: So that's one thing that we really help with and we really focus on. So the way that this manifests itself is through money streaming. So a money stream is a continuous payment that's native to Web Three, right? So any recurring payment that you can think of, you can turn it into a money stream and send it on a second by second basis. So these are like a connection between two existing accounts, be it an EOA or a smart contract address, where instead of deciding, hey, look, I'm going to send you 1000 USDC per month and send it in a single transaction once a month. I can instead take that amount, divide it essentially amongst the number of seconds in that time period, and the money will flow from my account into your account in real time. Just like what you're seeing right here. This is actually directly from our dashboard.
01:36:38.280 - 01:36:50.488, Speaker D: We have like a stream details page you can pull up to see the stream flowing in real time. And this is an actual live money stream, sending real money from one account to another right now. So it's very cool stuff. So how does this work?
01:36:50.574 - 01:36:50.968, Speaker E: Right?
01:36:51.054 - 01:37:41.224, Speaker D: Well, we built a protocol to enable this, and it's made up of three high level parts. We'll go through them at a high level right now and then go through how to actually build money streams using Solidity and also using our SDK in a couple of minutes. So the protocol is really made up of three, like I said, high level parts. The first is the superfluid host contract, which serves as a kind of brain for the protocol, right? So things are plugged into the host contract and that helps to enable everything to kind of work together. And the other two are agreements and super tokens. So an agreement is a peer to peer financial relationship that defines how your token balance can change in real time. So the most commonly used agreement within superfluid is called the Constant Flow agreement, which allows me to send you money linearly through time.
01:37:41.224 - 01:37:50.856, Speaker D: So I agree to send you a certain number of tokens per second, and those tokens are just transferred to you per second. So that's cool in theory, but again, how does that work?
01:37:50.878 - 01:37:51.016, Speaker E: Right?
01:37:51.038 - 01:38:39.800, Speaker D: So many of you are probably used to sending native assets and also transferring ERC 20 tokens. If you're going to go back here and send money on a per second basis like this, right? How is this happening right to you? If you're only used to ERC 20 transfers, you'd have to hit transfer every single second. That wouldn't be feasible. So what we built is an extension onto the ERC 20 standard that enables this real time balance to be calculated every second. So this new standard is called the super token, right? And like I said, it's an extension under the ERC 20 standard, so it is compatible with ERC 20s. All of the standard transfer and approval mechanisms that you're used to are all on super token contracts. There are just extra features on these super tokens that plug them into those agreements that can modify balances in really custom and unique ways, right? Like the money streaming.
01:38:39.800 - 01:39:10.948, Speaker D: So, like I said, these are plugged directly into the superfluid protocol. They're usable anywhere in web three, and we have two separate kinds of super tokens you can use. So one type is a native super token which just has no underlying address. This is just deployed directly as a super token. The other is a wrapper contract. So I mentioned it's usable anywhere in Web three. The reason for that is that we allow you to wrap any existing either native assets or ERC, 20 token as a super token so that you can use it in other places as well.
01:39:10.948 - 01:39:58.320, Speaker D: Right, so we wanted to value interoperability because that's so important to our space, and wrapper contracts let you do that. So, again, how does this real time balance actually work though, right? So usually that's not quite enough to sell you on the fact that this actually is working in the way that you think it's working. And the idea here is what happens with these agreements is you define, like I said, a number of tokens you want to send per second. So all I have to do is send a single transaction to say, all right, I'm going to send Fran, for example, one token per second. Right. What we can do there is calculate the amount of time that's passed before you make another state changing operation and always have this accounting in place that can make sure that you're only performing a new state changing operation with tokens that are in your balance.
01:39:58.400 - 01:39:58.596, Speaker E: Right?
01:39:58.618 - 01:40:20.190, Speaker D: So this is all made up of what we call a static balance. So just the token sitting in your wallet and a dynamic balance which is made up of something called a NetFlow, which is taken as the number of tokens that's either being sent to you or sent from your account every single second. So that's the idea. If you have any more questions on that, feel free to just find me this weekend and we can walk through it.
01:40:21.200 - 01:40:21.564, Speaker C: Okay?
01:40:21.602 - 01:41:24.364, Speaker D: We've gone through agreements, super, tokens, real time balances. How about programmability? So you guys are all builders, we want to make cool stuff. Money streaming is cool, but you can do additional things with money streams that allow for lots of automation in really interesting applications. So you can build something called a super app, which is what we'll walk through in a couple of minutes, that allows you to implement callbacks that can react to events that are taken along with that individual contract, right? So let's say that you have a contract, you deploy that's a super app and you send a stream into that contract. That stream can run any arbitrary logic as soon as the stream is created into that contract, right? So the contract is able to react to these different actions. And the reason why this is able to happen is that it's all plugged in back to that host contract that I mentioned at the beginning, right? So you register a super app with the host contract, which is able to then call these callbacks and react to specific events that are happening with superfluid. So, again, I went through this a little bit.
01:41:24.364 - 01:41:59.532, Speaker D: Super apps, these are reactive smart contracts. We'll go a little bit deeper into this in a couple of minutes. But what this does is allows any of you here to build applications that are connecting cash flows together and building a really cool network. So what we expect to see is an explosion of these network cash flows. So this is a live depiction of a bunch of superfluid streams that are on Polygon right now. This is a live network. This is a fast growing network and all of you here have the opportunity to build things that grow this network and ideally help connect cash flows in a really interesting way.
01:41:59.532 - 01:42:30.036, Speaker D: So we see a network effect starting to emerge here and we're very excited about it. I'm impressed that this worked within the keynote presentation. I was a little worried it wasn't going to buffer, but we got it. Okay, so that's the high level of how to build on Superfluid. Let's get into a more tactical example. So before we get into a contract that we'll walk through together, I do want to highlight a couple of developer tools that we've built. We really care about developer experience.
01:42:30.036 - 01:43:02.908, Speaker D: It's hard to build good developer experience around technical products like this, but we do put a lot of effort into it. And this is really what a lot of my day to day is built around. So one tool we'll go through is the Superfluid Developer console that lets you see any streams that are associated with your accounts. It'll let you check super token balances and it's just a really useful tool overall. We also have a dashboard that lets you create, update or delete streams without writing any code at all. It's just a good thing. If you want to open a stream to a friend to try it out, you can go to the dashboard and test that live there.
01:43:02.908 - 01:43:37.796, Speaker D: We're deploying a new V two of our dashboard very soon, which is even cooler than the dashboard we have here. But I just want to still mention it because it is important. And the final thing that you need to be aware of is that we have built some what I think are pretty good SDKs that lets you if you just know JavaScript or TypeScript and aren't maybe great with solidity, yet, you can still interact with Superfluid just using our SDKs. So we'll use that in just a second. But just wanted to highlight those three things. So let's build okay, what are we going to build? We're going to build a Tradable cash flow contract. So what's the tradable? Cash flow.
01:43:37.796 - 01:44:16.676, Speaker D: The Tradable Cash Flow is a super app so it can react to these Superfluid events and implement it does implement callbacks, which react to these events and do something. And what it's going to do is send 100% of the inflows to the contract to the owner of the contract. And the contract is Tradable because it's an NFT. So this actually mirrors some real world financial assets. For example, if you have subscriptions, there are companies out there that let you go get revenue based financing against those subscriptions. So this is a kind of web three native version of that where maybe you can tokenize a subscription revenue and sell it. Maybe you can bundle in together and sell it.
01:44:16.676 - 01:44:45.250, Speaker D: We're not going to get into any of the more advanced futuristic things here today, but we are going to talk through the primitive of how this works. So I'm going to zoom out here and I'll show you where you can get this exact example code in our repo. And then we'll just kind of walk through it together. I'll show you how we can write some scripts to interact with the contract itself. And we can move from there. So I might have to zoom in quite a bit here because I chose to mirror. But hang on.
01:44:45.250 - 01:45:02.820, Speaker D: Just zoom in here. Here's our repo. It's just superfluid finance protocol monorepo. And it's in our Examples folder. You can fork it right here. You can fork it just from the main branch if you'd like. And this is our Examples folder.
01:45:02.820 - 01:45:09.576, Speaker D: We're going to go into the Tradable cash flow section and the contracts we're going to be working with are going.
01:45:09.578 - 01:45:10.470, Speaker E: To be in here.
01:45:10.920 - 01:45:43.910, Speaker D: We'll step through these two contracts in just a second. But I do also want to highlight that we have some scripts here too, that use our SDK. So you can go into the scripts folder and we're going to create, update and delete a flow here in real time together using our SDK as well. So you can see all this and follow along, if you'd like, in this section of our repo. We also have the console up in a separate tab, which we'll show in a second. But this is really, really going to be useful for us when showing you how the streams are being created, updated and deleted in real time. Okay, let's get into some code.
01:45:43.910 - 01:45:56.216, Speaker D: So I have a cloned version of that repo right here. Let me zoom in quite a bit. Do you guys see that? Okay, thumbs up.
01:45:56.398 - 01:45:56.840, Speaker C: Good.
01:45:56.910 - 01:46:20.328, Speaker D: Okay, exit out of this. Clear up some space. Okay, so we have this Tradable cash flow contract. And what is this? Right? So one, we know it's an NFT. It's Tradable. So it's going to inherit from the ERC 721 standard. It's also going to inherit from this redirect all contract, which has a lot of this superfluid automation on that contract.
01:46:20.328 - 01:46:48.272, Speaker D: We'll step through that in just a second. But in the constructor, what it's doing is it's number one, minting an NFT to the owner that we pass. It's going to be the first argument to our constructor. It's also going to take a name and symbol standard, ERC 721 stuff. And then it's also going to take the address of the superfluid host, and it's going to take in the address of a super token. So we're going to keep this confined to only working with one token. But you could make this generalized and work with any super token you'd like.
01:46:48.426 - 01:46:48.936, Speaker A: Okay.
01:46:49.038 - 01:47:30.068, Speaker D: And remember, the host contract is that what I compared it to is the brain of the protocol, right. So you will a lot of times when you're building on superfluid, need to pass in the host address to be able to initialize our libraries and access other things within the protocol as well. Okay. The only other piece of logic that I am implementing inside of the Tradable cash flow contract itself is this before Token transfer hook, this is actually straight from the open Zeppelin API around ERC 721. If you guys don't know, you can also implement hooks and things that run automatically when you transfer NFTs. This is one of those things. So before the token is transferred, we're going to override the logic here.
01:47:30.068 - 01:47:55.820, Speaker D: Only take the address that it's being sent to and we're going to call this change receiver function and pass that address in here. Okay. So what this is going to do is anytime I transfer the NFT, I want the cash flows that are coming out of the NFT to go to the new owner. Right. The cash flows should follow the NFT. Right? Makes sense. So let's go into this redirect all contract because this has the meat of the logic.
01:47:55.820 - 01:48:32.548, Speaker D: So what's happening here is I'm just importing a lot of the superfluid stuff we need for working with the protocol. The big one that I'm importing is the CFA library. This is going to make it really, really easy for us to create, update and delete streams in solidity with really just a line of code. It abstracts some of the lower level stuff away and ideally makes it much easier for you. We also import this super app base contract, which will make this a super app. And the reason why that's important is because we need this to have those reactive elements to it. We need to be able to implement the callbacks that will run on certain events.
01:48:32.548 - 01:49:00.672, Speaker D: That's the idea there. So at the top of this contract, we are going to initialize a library using this syntax here. So using the using for stuff that you're probably used to with importing libraries. And then what we do inside the constructor is pass in the superfluid host address that Token we want to use. And then the receiver, which is just going to double as the owner of the NFT. It's going to be the initial owner that the NFT is minted to. So we run a couple of checks here to make sure that we're not passing in the zero address for any of these things.
01:49:00.672 - 01:49:38.888, Speaker D: We assign these variables like we should. We initialize the CFA library as this CFAV one lib variable. And this final thing we do here is register the super app contract with that superfluid host contract. So this lets the superfluid host know, hey, look, there's a new super app being deployed. Call these callbacks on this contract whenever these events happen, right? And. By default, there are six different callbacks that will run. One is the before agreement created, another is the after agreement created.
01:49:38.888 - 01:50:12.968, Speaker D: And then the same thing is mirrored for after agreement is updated and after agreement is terminated. Right? So there's a maximum of six callbacks you can implement. A lot of times we'll usually see just the after agreement created callbacks being implemented. What you do to specify which callbacks you want to run is just you specify that there are certain callbacks I don't want to run. Right? So these are all no ops here. So we're not going to do any of the before stuff. The before agreement created stuff is useful in the case where maybe I want to reject a stream coming into the contract if it's below a certain amount.
01:50:12.968 - 01:50:33.656, Speaker D: Maybe I want there to be like a minimum amount sent into the contract. Maybe it's a subscription of some kind. It's got to be a minimum. I could do that kind of stuff in the before if I wanted to. So that's the setup. The first thing I'll show is not current this change receiver function. And then I'll get into the redirection of cash flows.
01:50:33.656 - 01:51:09.752, Speaker D: So remember, what's important with the change receiver is that we delete the streams going to the old owner and we create a stream to the new owner. That's the idea, right? We need to make sure that the cash flows are just following the NFT to the new owner. So we have a nice little getter function to get the current receiver, see who it is. And if I scroll down, we have the change receiver. So we run a couple of checks at the top and then we check what the outflow rate is to the current owner using this logic here. So all we have to do is call this get flow function and we can get information about the flow. One of the parameters that's returned is what the flow rate is.
01:51:09.752 - 01:51:49.290, Speaker D: We can check what that is if it's greater than zero, meaning that there's something that exists, we'll just delete that flow using this one line of code and create a new flow to the new receiver. Right? So simple enough, deleting creating a new. Now let's get into the automation stuff, right? This is the most important stuff. You'll see at the bottom we have a few of these callbacks that are implemented. One is the after agreement created, another is the after agreement updated and the final one is the after agreement terminated. We run this update outflow function in each of them. So let's step through that function because it's going to be very important for this app.
01:51:49.290 - 01:52:44.330, Speaker D: Okay, so the update outflow function, what it's going to do is it's going to check what the net flow rate is of the app and it's also going to check what the outflow rate is of the app. So the first thing we'll see is, okay, does the inflow rate now equal zero, right? If the inflow rate now equals zero, it means that the flow that was being sent into this contract was deleted. So if that was deleted, what that means we need to also delete the stream going to the owner because there's no cash flows left, right? So we'll run this deletion. Okay, the next thing we'll do is check if the outflow rate is not equal to zero. So if there's already a preexisting outflow and it's not equal to zero now, it means that we need to update the flow because it means that the flow coming into the contract was changed. So we'll update it and make sure that the flow rate coming in just matches the flow rate coming out. That's all.
01:52:44.330 - 01:53:24.436, Speaker D: Finally, if none of those two things are true, it means that there was no stream that was existing into the contract yet. So if there's no stream coming into the contract yet, what we need to do is just open a stream to the owner of the NFT. Simple enough. The creation case, the update case, and the deletion case and all of that will run automatically whenever a stream is created into the contract and then when that stream again is updated and then when it's deleted. So let's deploy this and test it live. So what I've done is I'm using the Hard Hat Deploy library, which is a convenient way to deploy contracts. You can also use the standard Hard Hat scripts, but I have the Hard Hat Deploy library all set up here.
01:53:24.436 - 01:54:08.382, Speaker D: So I have this all set for the Guerreli testnet just like this. And what I can do is just run MPX Hard Hat Deploy and we'll do this on, like I said, Guerreli. It'll compile here, I believe. Just a second. And then it will deploy for us. All right, so compiled successfully deploying any second now. So when this deploys, what we'll do is we'll take this here we go.
01:54:08.382 - 01:54:37.000, Speaker D: We have their address. We'll take this and then we'll write some scripts to send money into the contract, update that stream, and then delete that stream and just check to make sure that the contract is doing what we want it to do, right? So it's been deployed. Let me just copy this address and I'll go into our Create flow script. Okay, so we're going to use our SDK now to create a flow in JavaScript to show you. We've already shown you how you can create streams using Solidity. We can do the same thing in JavaScript and the process looks very, very similar.
01:54:37.450 - 01:54:38.200, Speaker A: Okay?
01:54:38.510 - 01:55:08.110, Speaker D: So here in the Create flow script, I'm just going to add the address to this variable that I have preset. And what we're doing here is just initializing the SDK using this framework create syntax. Here we're passing in the chain ID we want to use. In our case, we're going to use the Guerreli testnet. So the chain ID is five. We're also going to just make sure that we have the URL we want to use. In my case, I have an environment variable set up within an Alchemy URL, which is just going to allow me to deploy to Guerreli.
01:55:08.110 - 01:55:33.618, Speaker D: And what we're also going to do is we're just going to set up a signer here which basically just mirrors what an Ethers signer is. I could also just use Ethers get signers and it would give me a signer that I can use as well. So we have those things set up. We have a signer, we have the superfluid framework which allows us to use the SDK. Now what I need to do is get the address of the token that we want to use and then create the stream. So the first thing I need to do is get the address of the token. In our case, we're using Dix.
01:55:33.618 - 01:56:03.186, Speaker D: This is the address that I passed in when I deployed the contract saying this was the accepted token I wanted to use for this contract. So I'll use this to get the token. You can just load it by symbol, which is pretty cool. On testnets, we put a little F in front of the tokens that have been deployed there just to note that it's fake money and not real money. So it's not real. Got to be careful with that. And then here what we do is we create the operation we want to execute and then we execute it and we sign the message with the signer.
01:56:03.186 - 01:56:29.470, Speaker D: So here in this case, we are going to create a flow using this this year. So SF CFAV, one create flow. We pass in the receiver, which is the address of the Tradable cash flow. We're sending money into this contract. We pass in the address of the token, which I can get through calling the address of this. And then we pass in a flow rate as a string. And this is just the number of tokens I want to send per second, right? This is going to be a pretty small amount because it's all denominated in way, but it is some amount.
01:56:29.470 - 01:57:10.176, Speaker D: So let's send a stream into the contract here by running our script. And then what I'm going to do actually first is go to the contract address on the superfluid console. Like I said, the console is very, very useful for these kinds of operations. The second the stream transaction propagates, I'll be able to just search this address more easily because it will automatically pop up in the console. So give me a second here. Here we go. And we can see here that there's two streams now in relation to this contract.
01:57:10.176 - 01:57:52.492, Speaker D: We just created a stream. And then remember that the expectation is that 100% of that stream value is sent out of that contract immediately, right? And that's what's happening, right? Money is being streamed in and money is being streamed out in the same amount, right? So it's that simple. Now you have a Tradable cash flow contract. You can do the same thing and have the scaffolding for a really, really interesting project this weekend. If you fork this, I could go through and update the flow and delete the flow. But I think that would be a little bit tedious at this point because it is basically just the same thing. The syntax is just slightly different in the SDK, but that's the idea, right? If I were to trade this NFT, the cash flows are just going to follow the NFT holder and yeah, that's one very, very powerful thing you can build on Superfluid.
01:57:52.492 - 01:58:01.830, Speaker D: So if you have any questions on this, please feel free to let me know. I'll go back into Keynote and just kind of finish out our presentation. But we'd love to engage with any of you guys on this if you're interested.
01:58:02.600 - 01:58:03.350, Speaker A: Cool.
01:58:03.960 - 01:58:38.544, Speaker D: Let's go back in and we'll wrap this up. Okay, so we left off on the Tradable Cash Flow, explaining it a little bit. Another thing I want to talk through is this program called Superfluid Reactor. So what we really value with Superfluid is becoming a developer platform. That's part of our strategy here. We want to integrate with existing Web Three projects that are used widely, but also help you take whatever you're building to the next level. So if you're aspiring to be an entrepreneur in the space or just build a really valuable project that's maybe open source, we want to talk to you, right.
01:58:38.544 - 01:59:00.932, Speaker D: We just rolled out a program called Superfluid Reactor. That the entire goal, is that right? We want to find people like yourself to launch. And if you get into the program, there's an application process. But if you get into the program, we'll provide the best mentorship we have. We will help you raise money. We will connect you to other talent in the space. We will help you find your first thousand users.
01:59:00.932 - 01:59:50.390, Speaker D: We allocate a lot of time to this, so we'd love to help you. We've had some success stories already in a less formalized way. I mean, the reactor program is very new, but we've had protocols like Ricochet Exchange, which is a dollar cost averaging application, come through our system, and we've helped them quite a bit to get lots of users and get off the ground. Another is a protocol called Huma Finance that's allowing people like some of the people at Superfluid and maybe in this room, to borrow money against their salary stream or earn passive yield using their salary stream. And we've also had a protocol for Web Three native subscriptions called Stripe also come through our program, who just raised a $2.5 million precede round a couple of months ago. So lots of success stories, and we'd love for you guys to also be your own success stories, if you'd like.
01:59:50.390 - 02:00:09.084, Speaker D: That's it for today. If you want to get in touch, you can find us this weekend. I'll probably pull an all nighter or two this weekend, so if you're going to sleep here, I might also end up crashing here. We'll see. You can find me on Twitter at Esplamini five and in discord at Sam F. Superfluid. So if you're interested in Superfluid, please feel free to reach out.
02:00:09.084 - 02:00:17.090, Speaker D: If you have any Web Three questions, more broadly, let me know, and I'm happy to chat through anything. And yeah, appreciate all of your time today. Thank you.
02:02:31.950 - 02:02:59.426, Speaker C: Testing, testing, testing. Okay, are we ready to go? I'm going to assume so. Cool. So hello, everybody. We got 30 minutes, and we're going to talk a bit about Privy and how you can use Privy to build awesome apps to delight your users and protect them at the same time during this hackathon, which is super cool. So before we start, I'll introduce myself. So who am I? So I like to describe Web Two me as like, the past decade of what I've been doing, which is a lot of Web Two stuff.
02:02:59.426 - 02:03:29.786, Speaker C: I worked at cruise, self driving and Pinterest, social networking, and a whole bunch of things. And then six months ago, what happened was my curiosity kind of led me down a Web Three rabbit hole where I decided to build an NFT collection to kind of learn by building. And I took the red pill and I swallowed really, really hard. And that just led me down a whole rabbit hole where I got really excited about all this tech learning, solidity, all the infra that was missing and that was there, all the potential. And so what that has led to is a career change. And now I'm kind of a builder at Privy, which I'm going to talk to you about today. I'm the creator of the Blockchain Smokers.
02:03:29.786 - 02:04:20.400, Speaker C: So this right here is Blockchain Smoker 1921 of my collection, and I'm a big privacy tooling advocate. And so I'm here today to talk to you about Privy and what it can do to help you with your privacy infrastructure needs. So how are we going to structure this? We're going to talk a little bit about a problem that I like to call the user data problem. After that, we'll talk about how Privy is a solution to this problem. Privy fixes this, and finally we'll get into the fun stuff with a live demo. So what do I mean by the user data problem? So if you've either developed or even been a user in Web Three, you've probably seen and been confused by this screen. And this screen, like many others, is kind of like displaying the underlying issue that sessions are really hard, and having a session that kind of propagates between experiences is a very challenging problem to the point where even great companies like MetaMask do a poor job.
02:04:20.400 - 02:04:48.680, Speaker C: Now, in addition to this, we have another problem in Web Three. Which is kind of shocking. And there's a tweet here from earlier this year which is kind of funny and sad at the same time, where Megadao kind of couldn't reach out to some guy because they only had the wallet address on their lists. And if they couldn't reach out to him within an amount of time, they were going to have to dump 600 million worth of ETH. Now this is crazy and this is because notifying off chain is kind of unsolved which is wild. Like Web Three has a lot to do still. That's crazy.
02:04:48.680 - 02:05:24.420, Speaker C: Let's talk a bit about a positive example. So here we have the openc profile page and you'll find profile pages like this on a lot of Web Three DApps. And what do you see here? You see some information about the user. Some of it is public like the username and the bio, but then other stuff like the email maybe in this case there's none. But there could be like other kind of KYC data and you want to handle those, you want to have those so you can create personalized experiences like users come back to your app if it has a delightful experience. And you can only really do that if you personalize. And you can only really personalize if you have this kind of personal information.
02:05:24.420 - 02:05:56.586, Speaker C: So delightful and rich experiences require personalization. For that we need two things. At the very core you need more, but at the very core you need user sessions for like in between session state and you need user tables to persist that state and to persist user information between sessions. Okay, so we want to save user data. What do we do? That's hard? And there's a debate about this right now, you may have heard this debate, the on chain versus on chain problem. I think Vitalik was on a podcast recently literally debating this like two weeks ago. And there's a lot just it's not clear where the limit should be.
02:05:56.586 - 02:06:31.970, Speaker C: But I think it's very clear that there should be a limit and some data should never be on chain. And the example I like to give is like your Social Security number. You probably don't want that to be on chain ever were right? And so if some stuff is on chain and some stuff is off chain, then we need to bridge that. And so let's say you're ledger and you're keeping user data like name, postal address, all these things off chain. Well guess what, you can do it wrong. It's actually very hard to get right. And so ledger had a, they got porn basically where they were doing great on their security for their hardware wallets, but they were doing a lot less great on their POSTGRESDB that had PII data in plain text that got hacked.
02:06:31.970 - 02:06:56.858, Speaker C: And this shows that when you do decide to kind of take user data off chain, doing it right is really risky. Okay? If you are going to do it. There's an old famous adage that says, don't roll your own crypto. Now, there's a reason for this. It's really hard. There's many mistakes you can fall into which are typically terrible for you, like timing attacks and brute force attacks and weak randomness attacks, architecture flaws, which is a really big one. Injection attacks.
02:06:56.858 - 02:07:23.106, Speaker C: And I could go on. Now, you can build your own crypto, but if you are going to do it, you have to do it right. And doing it right taints an insane amount of time and energy and expertise. Now, you could choose to do this, but typically when you're building a DAP, that's not where you want to spend your time and expertise, and that's why you kind of shouldn't. So we have a problem here, right? Great products require personalization and PII, but collecting that is risky. And if you do collect it, it's hard. Privacy matters.
02:07:23.106 - 02:07:47.886, Speaker C: This is a big one. I really like this one. One of the reasons why I kind of pivoted my career to Web Three is that I think the Web Two got something really, really wrong, and it's privacy. And a lot of these business models are kind of built around an asymmetrical kind of knowledge of the users. And in Web Three, we have a crazy good opportunity to redefine how we do privacy and how we do interoperability of privacy. And that's really cool. And finally, we need a bridge for off chain data, as we discussed.
02:07:47.886 - 02:08:06.566, Speaker C: Cool. So we have an issue, and this is where Privy comes in. And I'm going to talk about it in a second, but you can find our homepage at Privy IO, and I'm going to talk now about kind of what it is and what we do. And you can follow along with Blobby, who's our mascot on the second one. Cute little ghost. Cool. So what is Privy now, at its core, our mission is very simple.
02:08:06.566 - 02:08:30.854, Speaker C: We want to allow you to associate user data to wallets privately. So bridging on and off chain data now at a very high level, the most core kind of thing we use in our JS libraries. Oh, actually, I'll get to that in a second. So, first of all, in a few bullets, what do we do? We have APIs. They're very simple. We have JavaScript libraries, and these help you manage your off chain data. We have end to end encryption user storage.
02:08:30.854 - 02:09:02.774, Speaker C: So how does that work? That means that on the client, everything gets encrypted, and then it gets sent over the wire like as ciphertext, and then you get it back as ciphertext, and you're going to decrypt it on the client. And I'll go deeper into this. But basically what it means is you have end to end encryption storage, which is the right way to do kind of privacy. And we also have sign in with Ethereum Session Management, which kind of solves those two issues I was talking about of data persistence and session management. We also have transparent cryptography we're building in public, and our crypto libraries are all open source. And Privy can never see your data in plain text. The way we architected this is like we never see it.
02:09:02.774 - 02:09:26.606, Speaker C: And finally, Privy is ready to use right now. And honestly, it's going to make you kind of develop on steroids. Cool. So at a very high level, what does our architecture look like at a high level? So at the bottom there, you have the browser. That's where you, the developer is building a DAP, and that's where your stuff lives. And maybe you have some on chain components which are on the right. And then you kind of want to link your user, which is in this case represented by the encryption keys and the little MetaMask logo.
02:09:26.606 - 02:09:51.762, Speaker C: You kind of want to link that and associate some off chain user data with it. And that's where Privy comes in. And you can see that from the browser. You can interact directly with our permissions engine, which we'll get into and our data store to store and retrieve this user data. So how do you do that? What does it actually look like? If you're going to remember one thing from this talk, remember this slide. This is like the thing that's super powerful that Privy does. It has two calls.
02:09:51.762 - 02:10:32.454, Speaker C: Privy put and privy get. Right? So in this example, I have a user ID, which is ox eight, seven, two, and I'm not going to read it all. And in the first four lines, I'm saving two fields, email and age, and I'm saving them to the scripted data store. And then on the second, I'm just retrieving them. Now, this looks really basic, but actually there's a lot of stuff that goes into this. So for this Put call, what's going on is like on the front end, privy is first checking with our permissions engine, that whoever is authenticated with the session, whether it be the user or the developer, like your app or a public kind of authentication. Like if they have access to this field, write or read access, depending on if they do, we kind of encrypt it all on the client and then send the ciphertext up.
02:10:32.454 - 02:10:57.606, Speaker C: And then for Privy Get, you're doing the same thing. You're kind of checking with the permissions engine if the person that's requiring these fields is allowed to see them. And if they are, then you're retrieving that as ciphertext and decrypting everything on the client. So this is ridiculous. Like, you're doing so much in so few characters with Put and Get, you're kind of doing user data, kind of encrypted storage in the best manner possible. That's awesome. So that's the storage.
02:10:57.606 - 02:11:23.026, Speaker C: And the other critical part is sessions, which I mentioned earlier. So how do sessions look like? So what we built and this is because after building a few apps. We realized that session management is something that is like a key pain. We built like a wrapper that makes it really easy to kind of manage user sessions. So this uses in browser providers like MetaMask or Coinbase wallet. And so in this slide, it's kind of showing you the API of our CWI session. CWI stands for sign in with Ethereum, which is an EAP standard.
02:11:23.026 - 02:11:42.010, Speaker C: And so you're initializing the session here and then you're just authenticating the user that's going to call up the MetaMask application. They're going to sign a message, you're going to know it's there. And then basically under the hood, we're saving things to local storage and we're persisting that in between your views. And then you can also create a client with that session and then you know who's authenticated it's? The user that signed that message.
02:11:42.080 - 02:11:42.362, Speaker B: Right.
02:11:42.416 - 02:12:04.210, Speaker C: So when you decide to retrieve fields later, you know that who it is. And so if they're fields that only the user can see, they can see them. And so in this last line, I'm doing that, I'm getting the email, and maybe in this case, only the user can view their own email. Cool. So that's storage and sessions done. So let's recap real quick. With Privy, you can kind of get back to building products really quickly and you can do it right.
02:12:04.210 - 02:12:18.342, Speaker C: And doing it right used to be really hard. You no longer have to have this trade off. We think that's really exciting. You can store encrypted user data. You can use signing with Ethereum sessions. And by the way, everything I just showed you, you don't even need a backend. This is why this is a very hackathon friendly project.
02:12:18.342 - 02:12:29.580, Speaker C: You could just do this in 2 seconds with only a front end. So we do have a console, which you'll need if you don't have a backend to kind of admin your fields and your permissions. And I'll get into this, we'll see how it works in the demo.
02:12:30.350 - 02:12:30.858, Speaker D: Cool.
02:12:30.944 - 02:12:53.038, Speaker C: So we talked about the privacy problem, we talked about the Privy solution, and now I have time to do a live demo with Privy flush. Now I hope the WiFi is going to be stable because it was a bit flaky earlier. Now before we get into the demo, I want to do a very quick primer on permissions. But you're a developer. This is probably sounding very familiar. Most things are defined by who can read them and who can write them. This is true of like Unix files all the way to like in Privy, the fields.
02:12:53.038 - 02:13:22.554, Speaker C: So in Privy, each field has read and write permissions associated with it. And who are the roles? Like, who essentially can read and write. And there are three in Privy, there's self and that's the authenticated user think the user that kind of signed the message with the MetaMask wallet. There's admin that's you the developer. That's kind of passing in the secret and public API keys that you got from us. And then there's public. And so you can imagine any kind of combination of these exactly like, you Schmod kind of like files on Unix to see who can read and write them.
02:13:22.554 - 02:13:51.758, Speaker C: Cool. So I'm going to show you a demo, and then we'll dive into the code on how it's working. So the demo is this funnel app called Privy Flush, which is kind of like encrypted Dropbox, where you can send encrypted files to an Ethereum address. So, like, everybody has an inbox by default, and you could send a file to someone. So you can maybe use this to send a love letter that was very secret or maybe you were a bit more serious and wants to send, like, KYC data, like someone's passport photo or driving license. Cool. So I'm going to switch to the browser now.
02:13:51.758 - 02:14:15.274, Speaker C: So here we go. This is privy flush. Please appreciate my design skills. So here what's going to happen, is that we're not logged in, so I can't do anything yet, but I'm going to sign in with Ethereum. And to make things more clear for you guys, I have two kind of addresses I'm using here, like my primary and my secondary on my MetaMask, and I put them here. Like, my primary is one D, four A, and my secondary is Ox eight eight five. Cool.
02:14:15.274 - 02:14:38.994, Speaker C: So I'm going to sign in with my primary. Here we go. So I'm signing in with Ethereum, and this is the sign in with Ethereum standard, by the way, which is an EAP that's super simple. And it's just like, it's normalizing and standardizing what this string looks like so that we get metadata. That is a machine passable. So we're signing this, and now the app knows that I'm signed in as this MetaMask account, which for me is called Pushix. Cool.
02:14:38.994 - 02:14:55.882, Speaker C: So my inbox is empty, and I'm signed in as one Ox, one DA, four. So it's this guy, right? And I'm going to send a file. And for now, I'm going to send a file for myself. And so this is the file. It's this driving license that I photoshopped. I'm a developer, not a designer, so please forgive me. And so I'm going to send it to myself.
02:14:55.882 - 02:15:11.194, Speaker C: So I'm just going to copy the address from here, and I'm going to put it in the wallet address and send. And it is flushing. Okay, so hopefully it worked. And now I'm going to refresh the page. And you got mail.
02:15:11.242 - 02:15:11.838, Speaker B: Look at that.
02:15:11.924 - 02:15:31.474, Speaker C: And so now I can download and indeed, I can see this. So I just want to go over what happened here. I encrypted a file all on the client. Then I saved, like, the encrypted ciphertext somewhere, and then I could retrieve it at a later time. But when I retrieved it, when I hit download on the client, we just downloaded the ciphertext, and the Privy client was. Decrypting it. So that's super cool.
02:15:31.474 - 02:15:48.890, Speaker C: We just implemented like, dropbox with encryption out of nowhere. And I'll show you how quick it was. It's kind of crazy. Now there's a problem here, though. I can't send files to other addresses. So we'll try I'll show you that it fails. So I'm going to try and send like the same oops, I don't know what I picked there.
02:15:48.890 - 02:15:55.680, Speaker C: I'm going to refresh. Something terrible has happened. 1 second.
02:15:57.410 - 02:15:59.360, Speaker B: Maybe the windows open behind.
02:16:00.210 - 02:16:17.570, Speaker C: I think you may be onto something. No, that's not it. Let me try hard. Quitting. I'm going to restart the server. This is what live demos are and this is what we're here for. Okay, restarting the server.
02:16:17.570 - 02:16:31.846, Speaker C: See if that refreshes things. Localhost 3000. Here we go. I'm still logged in. Here we go. Yay. Okay, so I'm going to transcend it.
02:16:31.846 - 02:16:51.102, Speaker C: And we said I'm going to try and send it to the second address, who is not me. Right. I'm logged in as ox one DA. I'm sending it to ox eight eight five. And so when I do this, I'm here. When I do this, I'm going to get an error. The error is not permitted to perform this operation on the field.
02:16:51.102 - 02:17:10.594, Speaker C: Cool. So why is that? It's actually super simple. If we go to the console, so we see the field here, by the way, it's inbox. That's the inbox for the user, the permissions is self. And so that means that I can read and I can write only me self being the authenticated user. So what I need to do is change this, and I'm going to change it to we need a special access group, actually. So let's create that.
02:17:10.594 - 02:17:36.490, Speaker C: We're going to do one where anybody can write to me and only I can read. So I'm going to create an access group. I'm going to call it public write, self read. And I'm going to say only I can read and anybody can write. So anybody can write me like a love message. So I'm saving this. And now I'm going to say, for my field, for my inbox field, I'm going to edit it and I'm going to say the default permissions are public write self read.
02:17:36.490 - 02:17:45.970, Speaker C: Cool. So now anybody can write me. So we've saved it. Now let's go back to our app here. And I'm going to refresh and I'm going to basically try this again. Board. Try a different file.
02:17:45.970 - 02:18:12.806, Speaker C: This is another NFT. So I'm going to send this and we're going to send it to the eight eight five. And it's going to flush. Cool. And now I won't see it here, right? So what I need to do is sign out and then sign in with the other address and we'll go and see if we got it back. Signing in with Ethereum. Not connected.
02:18:12.806 - 02:18:36.236, Speaker C: This should work. Come on. Okay, 1 second. I'm going to see if maybe it's because I'm connected. Sessions are hard. This is what I was telling you. So maybe if I disconnect this and I switch to this and I kind of refresh now, I sign in.
02:18:36.236 - 02:18:53.084, Speaker C: There we go. Sessions are hard, so I'm logging in as the second address. There we go. It had the queued things and we should have the file, which we don't. So something went wrong. Okay, I'm not going to live debug.
02:18:53.132 - 02:18:53.856, Speaker B: We should see it here.
02:18:53.878 - 02:19:02.944, Speaker C: And I probably made a mistake copy pasting the address. I apologize about that. Cool. So the demo is done. I want to kind of, kind of show what it would look like if we wanted to add a field. So let's jump into the code.
02:19:02.982 - 02:19:03.560, Speaker A: Real work.
02:19:03.630 - 02:19:31.790, Speaker C: So this is by the way, there's a lot of boilerplate code here, but it's just like a Create Next app. So if you're familiar with JavaScript and Next, this is like pretty straightforward. So I'm going to go to the pages, and there's the main page, which is indexed. And that's where most of the code that we're doing lives. So here we're using Session, which is using our sign in with Ethereum sessions that I talked about earlier. It's using a react hook to kind of persist it through our pages. But what we care about, and I'm going to look for it, is Privy session Privy, which is where all the Privy interactions are happening.
02:19:31.790 - 02:20:02.372, Speaker C: So we can see there's really two places where this is in action. And it's like on page load. We're loading the inbox by doing a Session Privy Get file, and we're saying for the logged in address, get the inbox field. And then the second one is on the send, which is the hook of when you post a form. It's saying Put file, and you're giving it to the destination address, and you're posting it to the field inbox and you're start pasting the file. So real quick, what would it look like to kind of add a message? Let's say we wanted to build over the hackathon, I don't know, encrypted messaging. You could do this with Privy really easily.
02:20:02.372 - 02:20:19.950, Speaker C: Now I'm going to just create a new field here. I'm going to call it Message. I'm going to do the same public read, self read, kind of permissions. Cool. And then in my app, I'm going to create a new constant. This is like a react hook. So I'm going to call it Message and a hook to call it Set Message.
02:20:19.950 - 02:20:36.660, Speaker C: And this is use state. It's a string and we default it to the empty string. Cool. Thank you very much. I forgot the closing bracket. The computer is like this and it's just breaking my wrist. Cool.
02:20:36.660 - 02:20:58.652, Speaker C: So then we're going to get it here, const Message, and we're going to do the same thing, session Privy Get. Remember that. And we're calling the Session address. That's for the Oops, for the logged in user. And the field was called Message. Cool. So we're getting it and then if it exists because it could be null, let's set it.
02:20:58.706 - 02:20:59.310, Speaker B: Set.
02:21:03.120 - 02:21:16.512, Speaker C: Message ulala. Okay, message. Here we go. Text. So this is like a Privy client thing. Cool. So if we get it, we're setting it to the variable message.
02:21:16.512 - 02:21:40.010, Speaker C: So now we have kind of the message in our handler memory in the thing message. We need to go and display it. So let's go display it beneath You Got Mail. So this is where you got mail is. So if you do, I'm going to kind of add a div that just shows the message. And I guess we could show this only if the message exists, which in react you do like this. There we go.
02:21:40.010 - 02:22:00.320, Speaker C: Cool. So what I forgot to do is that when I'm sending it, we need to set something to the message. So for now, let's go write hello world. So I'm going to do an away session. Privy Put. This time it's just put destination address. The field is message.
02:22:00.320 - 02:22:21.136, Speaker C: And let's just say whatever you guys want ethnyc hello world. And you could obviously make this more dynamic. I'm keeping it simple for now. Cool. So now we're saving it when we upload the form and we're hard coding it to this message and then we're going to get it. So let's go try it out. So we'll go back to Privy flush.
02:22:21.136 - 02:22:38.940, Speaker C: So now I'm going to send a file to myself. So I'm logged in as OXA 85. So I'll make sure to send it to that. So I'll send this lover boy and I'll send it to myself. O at X 85. Here we go. It's flashing.
02:22:38.940 - 02:22:42.044, Speaker C: Cool.
02:22:42.162 - 02:22:43.440, Speaker B: I'm going to refresh.
02:22:46.020 - 02:23:02.500, Speaker C: Something's not going right and I don't know what it is. Oh, there it is. It was just slow. You got mail. And why don't we see the message? Let's go see. In the console we can actually view data. And so for the user ox eight eight five, there is a message.
02:23:02.500 - 02:23:18.220, Speaker C: I can't see it. By the way. This is cool. So because only the user self can see it, like me as the admin can't see it. And so here it's not there, but there is a field and it's there somewhere. So I wonder why it's not seeing it. I promised this was working earlier.
02:23:18.220 - 02:23:41.200, Speaker C: Message text sessionprefy get okay, I'm not going to debug this live. I'm just going to do one last thing. Message. And it was called message. Yeah, this should work. I can't think about why it's not. Okay, one last time.
02:23:41.200 - 02:24:08.434, Speaker C: Okay, I will debug this and send it in our discord later. I'm sorry about that. Cool. I'll go back to the demo because we have only a few minutes left. So I just want to kind of emphasize it's broken at the end here, but I promise it works. I want to emphasize how easy it is to build really powerful kind of things with Privy. And so the demo I gave you is like, encrypted files or like, sending encrypted messages, but you can actually go and see at demos.
02:24:08.434 - 02:24:23.806, Speaker C: Privy IO. We have a few others. We have, like, a PII demo. Let's say you're like an NFT marketplace or someone who has to do KYC requirements. You could collect them here. You could go see that we have a send demo that shows how to collect email addresses to then notify your users. And we have a quick start to get going.
02:24:23.806 - 02:24:44.254, Speaker C: And all of this is open source, by the way. You can go find all our stuff at GitHub, privy IO. Cool. So let's go back to our presentation. So for this hackathon, you can kind of find us at Privy IO. You can make an account right now at console privy IO. And our documentation is at docs.
02:24:44.254 - 02:25:00.490, Speaker C: Privy IO. We have a discord, and we have prizes. So if you build anything with Privy kind of, we're going to consider you for this prize. You should go ahead. And so our three categories are best data driven, UX, most interesting data stored, and most creative. Cool. So I have a few minutes left.
02:25:00.490 - 02:25:48.198, Speaker C: I will take your questions. How does it work? Okay, so I wish I had the architecture diagram. I'm going to kind of talk you through it then. So the way it works is we use okay, I don't want to get this wrong live, because the cryptographers have a whole thing here, but we use a hardware security module, which is like, a dedicated hardware whose job it is to only kind of handle private keys and sign things. And for each customer, they have, like, a root key that's in that module. And then we use that to sign derived keys for each field. And so when you kind of request a field both to save or to put you first go through our permissions engine, we know kind of who you are, and we can say this person can or cannot see the field.
02:25:48.198 - 02:26:23.594, Speaker C: And if you can, then we go and fetch the root key. We ask it to create a public, private, symmetrical key pair, and we sign the field with that. And that's how you do it on the front and back end. Now, we can get into much more detail here, and this is public, and we want it to be publicly auditable. So come see me after. And I can kind of redirect you to the cryptography people at my company because it's not my specialty, and I don't want to miss that's. That's a great question right now there's.
02:26:23.594 - 02:27:14.690, Speaker C: I mean, so I don't want to talk too much about pricing, but right now you can send pretty much anything because we have free tiers, and then the first month is fine. Down the line, there'll be pricing per user, and so you'll kind of pay for usage there. Yeah, great question. So the question is, is it only about encryption or does it also have storage plugins like IPFS? So that's a really good question. So right now, the way we architected it, we can kind of swap out the storage component. So right now, it's kind of owned by us and our cloud storage. But down the line, we absolutely have plans so that you can kind of swap it out to either on Prem or IPFS Airwave or whatever you want.
02:27:14.690 - 02:27:36.890, Speaker C: Like, the storage is completely decoupled, right? Permissions engine that checks the permissions. And then there's, like, the encryption that happens on the client, and then you're sending ciphertext so you could really store it anywhere. And so that's something we plan to kind of open up later. Cool. Thank you.
