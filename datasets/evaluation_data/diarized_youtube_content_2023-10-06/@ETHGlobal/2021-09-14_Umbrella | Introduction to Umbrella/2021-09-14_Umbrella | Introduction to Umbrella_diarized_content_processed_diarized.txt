00:00:01.610 - 00:00:47.420, Speaker A: Hello. My name is Miguel Morales. I'm one of the product leads here at Umbrella. And today I'll be reviewing the Umbrella product. The purpose of this video is to show all the developers, all the different hackathon projects that we have available it's only a couple of them. And give developers an introduction to the Umbrella architecture, to the Umbrella APIs and SDKs, so that developers are able to build applications and to be able to participate in these hackathons and complete projects that are going to be judged well against their other competitors. So let's get started.
00:00:47.420 - 00:01:36.730, Speaker A: First, I just want to sort of give a very high level overview of what is Umbrella. Umbrella is an Oracle network, and we deliver data from a side chain onto the different blockchains, primarily Binance, smart chain and Ethereum. And that data includes cryptographic pair data. So, for example, the price of ETH USD and BTC USD and so on and so forth. And we also provide other types of data, such as such an options data. And we are also adding a lot more data. So for example, you can find different types of more obscure pairs.
00:01:36.730 - 00:02:20.394, Speaker A: And you can see the whole key list in our Block Explorer. So here you can see we can go and see our Finance Block Explorer. And all you have to do is click on layer two data, and that's going to show you all the different data points that Umbrella provides. So as you may have seen me mention, we have two types of data. Layer one data, which we call first class data. And then we have layer two data. And first class data is essentially just.
00:02:20.432 - 00:02:21.546, Speaker B: Sort of data that you can use.
00:02:21.568 - 00:02:48.340, Speaker A: Directly from your smart contracts. You can also use layer two data directly from your smart contracts. It just requires retrieving some data from an off chain API to submit to your smart contract. To be able to use layer two data in your smart contract, let me take a step back and let me present the architecture of the product for a little bit.
00:02:49.910 - 00:02:50.660, Speaker B: So.
00:02:52.630 - 00:03:47.382, Speaker A: The way that Oracle systems currently work is you have different feeds in which validators essentially submit the price of a crypto pair. Let's say, for example, you have the ETHUSD feed, an Oracle system, oracle validators essentially just submit a transaction to the smart contract, which is a feed contract, right? And this can be very expensive, especially for the validators, as they have to pay a transaction fee for each data pair. So imagine a validator has to pay for submitting the price of ETH USD, for ETHBTC BTC USD, and so on and so forth. And that's just very ineffective and very expensive for validators. And alongside that, for developers, it's actually.
00:03:47.516 - 00:03:48.678, Speaker B: Pretty easy to use.
00:03:48.764 - 00:04:45.814, Speaker A: So these feeds, you're able to just directly call from your smart contract and they're funded. And essentially you can just query, let's say, the price of ETH USD. Things get a little bit trickier when you're using sort of like data that's a little bit rarer, in which case traditional, well, at least like market leading Oracle systems have the concept of networks. And so you have different networks that holds all these different types of data. With umbrella, it's a lot different. So there is no need for different networks. And that is because we have two types of data, as we mentioned, there's first class data, which acts exactly like the native feats that Oracles traditionally have.
00:04:45.814 - 00:05:36.470, Speaker A: And then you have what we call layer two data. And so instead of creating all these different dispersed networks, we have one network, one global network that includes all these different types of data. So, for example, if we're to add like sports scores or the weather data, for example, those providers would simply provide an API. And then that gets added to our layer two data, which can ultimately be promoted to layer one data. But the way that this works is through the use of merkel trees. So here you can see a diagram of how our side chain works. So essentially, we have a side chain of different validators, decentralized, validators, and they come to a consensus.
00:05:36.470 - 00:06:17.940, Speaker A: And the nodes, basically they independently validate the data. So whenever there's consensus, they're double checking that no one is trying to manipulate the price. They're independently verifying and loading the data from the APIs and double checking it against other data. And then when they do arrive at a consensus, that consensus is memorialized on a smart contract. And what's in that consensus? So essentially, there's some key pieces of data. So one piece of data is called the merkel root. And so the merkel root just simply represents thousands of crypto pairs into one singular value.
00:06:17.940 - 00:06:33.146, Speaker A: And alongside with, we also include what we call again, the first class data. And that has a list of the crypto pairs natively. But for cases when it's like a little bit more rarer data, it will.
00:06:33.168 - 00:06:34.682, Speaker B: Be in the layer two data set.
00:06:34.816 - 00:07:18.790, Speaker A: Which is stored as a merkel tree. Here I'll give you a little bit sort of more insights into how our validator network works. Feel free to skip all this if you all want to learn how the network is architected I'll start talking about developing apps in a little bit. So essentially what we have is a validator registry. And in the validator registry, the validators is where they are registered. And you can find information such as their name, their blockchain address, and the location of their node, of their validator node. Validators are requested to set tokens at stake.
00:07:18.790 - 00:08:18.250, Speaker A: So they do that by depositing, UMB, tokens to set at stake in the staking bank. And then we have what's called the chain contract. And we're also adding delegation. And essentially the way that that works is the chain contract makes sure that the data being submitted has been signed by valid, registered, validators, and such, that the list of validators that signed it, their stake must be more than more than 50% of the total stake and that's how you achieve a majority wins, essentially. So the chain smart contract validates these signatures. So what essentially is happening is all this data is being batched into one transaction. So as opposed to another Oracle systems where it's like the validator submitting independent transactions.
00:08:18.250 - 00:08:53.846, Speaker A: In this case we just submit one transaction. Whoever's the leader in that round submits one transaction. That transaction includes the dozen or so of first class data, which represents all the popular feeds. And then alongside that with the merkel route of the consensus data and the signatures that say yes, we agreed that for this round, this is the merkel route, this is the values of the first class data. And then all that gets stuffed into a single transaction and that's what gets submitted into the blockchain. And yeah, a little bit.
00:08:53.868 - 00:08:56.534, Speaker B: Just to wrap up how consensus works.
00:08:56.732 - 00:09:57.702, Speaker A: There'S a leader that's deterministically elected and they are responsible for submitting the block for that round. If they fail to respond, then it rotates to the next leader. And so the leader basically proposes a block to other validators and other validators double check data. And if they agree on the value of that block, they sign off on it. That's when the leaders gathers the signatures off chain and then submits it as a batch on. And this is important because on chain you have this key pieces of data which again is like the merkel root and the first class data and the values and all of that. And so here's sort of a brief overview of how an application may interact with umbrella smart contracts.
00:09:57.846 - 00:10:53.740, Speaker B: Okay, now we'll go over first class data. So essentially, as I mentioned before, first class data is very much just like standard data that you can access just like you could from the standard feeds that other Oracles provide. So the best way to work with first class data is to first go and see the list of first class data available. Essentially one of these, you can think of it as a feed of data that's being continuously updated on the blockchain. So here I'm looking at the umbrella Block Explorer on the Binance chain. So binance is essentially our core anchor chain and then we have bridges to other chains. But for this hackathon and for the time being, we're only going to focus on the binance smart contracts on the binance first class data and not worry about bridges just yet.
00:10:53.740 - 00:11:49.150, Speaker B: So you can go here into the binance Block Explorer and click on first class data. And when you click on first class data, you're going to see a list of all the different first lambda keys and their latest value here. Now you can just simply query smart contract and I'll go over that in a second and get this value directly from your smart contracts. So that's the very basic concept. It's extremely easy. We have documentation onto a more comprehensive introduction to first class data and it tells you everything that you can do and how to access this specific set of keys from an API if you need that. We also have an SDK.
00:11:49.150 - 00:12:37.790, Speaker B: So this allows you to use the first class data from your smart contract. So essentially it's just a set of files that you can import from your smart contract to be able to use first class data. So here I'll just kind of go through the example and just kind of help you along understand some of these concepts. So the first thing that you want to do is to import the chain contract. This is an interface file, but it's essentially just a way to communicate with the chain contract. You'll also need to pull in the registry contract and you also need to pull in the decoder library. This allows you to decode the values essentially.
00:12:37.790 - 00:13:26.430, Speaker B: So essentially the registry is simply a pointer to the real chain contract because periodically there may be updates to the chain contract. You don't want to talk to the chain contract directly. You want to find out what is the latest chain contract first and then talk to that contract. So that's what essentially this registry is. This is called the contract registry. And so you're going to query the registry in order to find out what the latest chain is. So when you initialize your smart contract here, you need to make sure that you specify the correct contract, the contract registry.
00:13:26.430 - 00:14:15.150, Speaker B: We also have a page here that lists all the different contract registries for the different know. In this example we're using Binance mainnet. So this would be the registry address that we pass in. So that's the registry address that we pass in and then we store that address here and we're going to be working with that in a second. Now I'm going to just focus on the most common use case, the core functionality, and that's just being able to get the price of a crypto pair, for example. So here's the way that would work. So from your smart contract, you would essentially first query.
00:14:15.150 - 00:15:17.854, Speaker B: So here in this example, we have a helper method that essentially returns the chain by resolving it through the contract registry. So here we're first querying the registry and we're asking, hey contract registry, get me the address, the latest address of the chain contract. So that's this contract here and that essentially here, resolves the chain contract. Okay, once you have the chain contract resolved, you can start querying that contract. So the most common scenario is getting the current value for a given key. So again, for example, we want to find out what is the price of UMB, this is the key. And so there's a little nice little helper here in the block Explorer that allows you to just get the bytes directly that represent this key.
00:15:17.854 - 00:15:49.180, Speaker B: So we just copy that. And that's what you would pass in to the chain contract to get the value. And what you get in return is the value and the timestamp of when that value was last updated. So this is continuously updated. And so when you do this, you're going to get the latest, the latest value. Here you're just checking whether there is a value, maybe somebody passing the wrong key or something like that. And that's how you get the value for first class data.
00:15:49.180 - 00:16:15.780, Speaker B: So, yeah, it's very straightforward to use the block. You can find out more what exactly this chain contract interface looks like. So you have all the different methods and that's available in our SDK. Okay, so next we're going to go over layer two data.
00:16:16.230 - 00:16:17.746, Speaker A: Layer two data, it's a little bit.
00:16:17.768 - 00:17:18.150, Speaker B: More complex to work with. However, it's the mechanism that allows the umbrella network to support so much data and be able to store it compactly and be able to use it compactly within the blockchain, right? So first I'm going to just quickly review the concept at a high level. So the way that it works is that the umbrella network, the Umbrella Oracle system, uses a merkel tree to store data compactly. Now the way a merkel tree essentially allows somebody to prove the existence of a specific key within a data set. And the beauty of this is that you can prove the existence of a key within the data set without having to have the entire data set. And so merkel trees are pretty fantastic. They're used within Ethereum and other systems.
00:17:18.150 - 00:17:58.978, Speaker B: And essentially the way that it works is let's say that we want to store the price of BTC USD. It would be stored within one of these leaves in the merkel tree. And then if you want to be able to prove, to prove this value, let's say that the price of BTC USD is 50,000 at this point in time, you want to prove to a smart contract, specifically your smart contract, the smart contract that you're developing, that this value is essentially correct. And it's the value that was derived from the consensus mechanism, right?
00:17:59.144 - 00:18:02.194, Speaker A: So typically what developers will do is.
00:18:02.232 - 00:19:02.486, Speaker B: They will write an off chain service that periodically updates a value that they're interested in and sends it to their smart contract, right? So they're essentially running like their own Oracle node. But the beauty of it is that they don't need to run consensus, they don't need to do any of that. They essentially just copy the layer two data, include the latest value and the merkel proof, and send that to their smart contract. And the smart contract is going to validate the merkel proof to make sure that that value was derived from consensus. And this is where you have a trustless mechanism of natively promoting layer two data to layer one data. You don't necessarily need to do all this. But for example, every time you make a transaction in your smart contract, you.
00:19:02.508 - 00:19:05.014, Speaker A: Have the user pass to you the.
00:19:05.052 - 00:19:31.060, Speaker B: Value and the merkel proof. But the more typical scenario is the developer is going to write an off chain service that again sends that data, includes the merkle proof and the smart contract, essentially validates it and updates its own internal value. The first thing you're going to want to do when you're working with layer two data is go to the Block Explorer and there's two views that are important.
00:19:31.830 - 00:19:34.354, Speaker A: So first the layer two data view.
00:19:34.392 - 00:19:51.506, Speaker B: Here shows you all the different data points that are currently in the layer two data set. So right now we're close to 1000 data points. And as Umbrella gets developed and keeps improving, there's going to be a lot.
00:19:51.548 - 00:19:54.122, Speaker A: More data pairs to be available here.
00:19:54.256 - 00:20:54.794, Speaker B: And within this data set is a lot of more exotic data points. So various sort of more smaller cap coins that may not be available through traditional Oracle feeds. And this also includes VWAP data. There's going to be options data, and essentially it's going to be like sports scores and just anything. A merkel tree can encompass hundreds of thousands of entries and still be compacted to a 32 byte hash at the end. And the beauty of it is, and why is Umbrella better than other Oracles is because, for example, in the leading competitor, they have what's called the marketplace. And the marketplace allows different Oracle networks.
00:20:54.794 - 00:21:58.546, Speaker B: And you as a developer, you can select your nodes and you can select Oracle and the type of data that you want to use. But that creates this dispersed networks, right? Stability may not be the best stability, and it just creates all these different dispersed, dispersed, separated, segregated networks. And it may sound cool, right, someone's running a note, right? Like, oh, we have this data provider running, but you don't need to do that with Umbrella. We have just one global network, and that global network includes all the different data points from all the different categories. So a data provider doesn't have to run a node. They essentially just provide an API. The validators talk to that API and then the validators come to a consensus and it's all stored compactly without incurring any additional cost.
00:21:58.546 - 00:22:04.290, Speaker B: So that's kind of the beauty of the way that layer two data is designed.
00:22:05.670 - 00:22:30.460, Speaker A: Okay, so next we're going to show you how to get information necessary to use layer two data. And essentially we're going to go over one sort of scenario. One of the things that we have as a hackathon project is the ability to bring layer two data into layer one. So this is.
00:22:32.270 - 00:22:34.242, Speaker B: A typical workflow.
00:22:34.326 - 00:23:45.554, Speaker A: So let's say you're a developer and you want to have this layer two data delivered into your smart contract such that your smart contract can still be trustless. So your users can know that even though you are updating, let's say, the value of some certain key, it's still trustless because you're providing a cryptographic proof. So let's say that you're building an application that needs the latest sports or time weighted data or just something specific. The first thing that you want to do is first look at the entire data set of layer two data available. So you can see here there's a lot more sort of less popular data pairs with lower market caps. And you're also going to see again, time weighted averages and just other types of data. So find the data that you're interested in and you can see that here.
00:23:45.554 - 00:24:49.362, Speaker A: Currently we have a little less than 1000 data pairs available. And the way that it works is you need to basically get certain piece of information to be able to, let's say, submit a transaction to update a value so that your smart contract can validate that value. So here we can look at a specific block. So if you remember periodically there's a new block minted when there's consensus and this block includes the merkel rule. Let's say for example, we want to update the price of Aave BTC based on the latest consensus round to our smart contract. Essentially we would write an off chain service that periodically checks if there's a new block minted and will periodically send data for certain blocks. We'll send the key and the value and the merkle proof and then that on developer smart contract.
00:24:49.362 - 00:25:24.580, Speaker A: Then they would process whatever logic they need to process and then update the internal value within their system. At the same time you would be triggering any sort of process within your smart contract. So here you see an example. Let's say we want to update the price of Aave BTC. You will need some key pieces of information. As a developer, you're going to be communicating with the chain smart contract. Just like I went over in the first class data part.
00:25:24.580 - 00:26:21.058, Speaker A: You're going to need to communicate with the chainsmart contract and you're going to pass certain pieces of information to be able to validate a specific value. So there's a method within the chain contract called verify proof for block and you're going to pass in the block ID that you want to use this data from. You're going to pass the merkel proof and here is the key and the value that you're proving. So for example, here I would just copy the key, copy the value. This is what I'm proving. We're proving that the price of is this fraction of a penny here of A. So you're just going to be able to pass that key and value and then most importantly, you're going to pass the merkel proof.
00:26:21.154 - 00:26:23.062, Speaker B: So this merkel proof proves that this.
00:26:23.116 - 00:26:44.774, Speaker A: Was indeed the value and that it was contained and asked this value within this merkel root that we showed here earlier. So once you pass that data to the smart contract, you can just execute the function and it'll validate if that proof was correct. Okay, so next we're going to go.
00:26:44.812 - 00:26:46.454, Speaker B: Through the developer API.
00:26:46.582 - 00:27:30.582, Speaker A: And how do we retrieve these off chain proofs such that you can use them within your on chain smart contract? So there's different API endpoints. So we have an endpoint to get the first class data set and to get the layer two data set, you can get information about the latest blocks. So if you're scanning, you're scanning for new blocks and you want to update a value, this is where you'll be continuously polling is to get the blocks. You can get information about a certain block ID if you want to get all the leaves for a specific block. And then this is probably the most useful one. So what this does is this gets.
00:27:30.636 - 00:27:32.614, Speaker B: The proof for a specific set of.
00:27:32.652 - 00:27:43.558, Speaker A: Keys that you include and this is going to return the latest value from the latest block ID. So let's say that you want to update the value in your smart contract.
00:27:43.734 - 00:27:44.780, Speaker B: Every hour.
00:27:45.150 - 00:28:27.500, Speaker A: You would add the hour, retrieve the latest proof, and this is going to include all the information that I showed earlier that you need to pass to the chainsmart contract to validate it. There's also some very important things that you can find on our GitHub. So for the purposes of the hackathon, I think you're going to want to focus on two things. Number one is our example application and that's called Babel. And so this kind of has one smart contract that you can use sort of a building base to see the system in action. So we have two examples here. One how to use the first class data, and then another one on how to use the layer two data.
00:28:27.500 - 00:29:08.760, Speaker A: So here we're going to focus on the layer two data. So remember that you're going to want to import the SDK and that is called canvas. So you're going to want to import that. And there's of course information in our developer docs on how to import your SDK. You're going to want to import the chain contract interface, the contract registry interface, and the value decoder because the layer two data is encoded. So in order to be able to extract the actual decoded value, you're going to have to do some decoding. And I'll show you some examples here.
00:29:08.760 - 00:29:54.660, Speaker A: So imagine that this is your developer, your contract, and you want to update the price of Ave BTC or whatever it is that your contract is working on. So you will be developing this off chain service that is going to submit a transaction. Let's say you're doing it every hour. And what you're going to do is you're going to get that block ID, the latest block ID along with the latest value, and submit it. And your method here you can have your method validate the freshness of that block and other things. So you're going to first resolve the address of the chain through the contract registry. And this is the same for us as first class data.
00:29:54.660 - 00:30:45.830, Speaker A: After you do that, you can then validate a proof. And so in our example, we kept it simple, but you can also query the chain contract for information about a certain block. So let's say you pass in a block ID and theoretically it can be anybody, right? This is a public method because it's secure and you use cryptographic proofs to prove things. In this case, the developer is the one developing the service. They will get the latest block ID, get the key and the value that the contract cares about and the proof of that value. And so you can use this method to validate the merkel proof being passed in. And this is the exact same method with the exact same data that I went over that we did on Etherscan.
00:30:45.830 - 00:31:11.360, Speaker A: So this is just how you would do it on your on chain smart contract. And again, there's other methods here where you can get information about a block and you can get how old a given block is. Let's take this example. Let's look at the latest block or this block here.
00:31:13.090 - 00:31:18.446, Speaker B: And let's say when.
00:31:18.468 - 00:32:16.850, Speaker A: Was this block minted? And then we'll give you the timestamp. And so you can implement various things. Let's say that you would only accept the value based on freshness, right? So you can query the block ID, see if it's too old and not accepted. Or maybe you keep track of the block ID that was last submitted. You want to make sure that the new information being updated is the latest, or rather it's like at least fresher than the last time. You would check both the timestamp and then you would check to make sure that the last submitted block ID is lower than the new block ID being submitted. So you can have all these different conditions in your smart contract to make sure that your users trust and that you're using, even though you're submitting this data yourself, that the data itself was derived from consensus, from the umbrella validator network.
00:32:16.850 - 00:33:21.990, Speaker A: And so once your smart contract validates the merkel proof and you call the API to validate it, then you can just go ahead and update that value and use that value within your smart contract as you normally would, right? And so in this case, the developers, you're paying the cost of being your own oracle through the transaction fees. But in essence, you don't have to worry about integrating with APIs. You don't have to worry about like, oh, it's just me. You don't have to have consensus like you're proving that there was already consensus on this. And so this allows basically anybody to A, use the vast layer two data set and B integrate it into their smart contracts and essentially promoting that layer two data into native layer one. Data within your developer smart contract. So, as I mentioned, it's definitely the more complicated scenario instead of just using the first class data directly.
00:33:21.990 - 00:33:58.590, Speaker A: But that's why when we are judging this hackathons projects, we're looking for the complexity and how well you understood this more complex, complex methods and this more complicated way of using the more exotic data set. We definitely prefer to see projects using layer two data directly and it's, you know, and it's very easy to use this layer two data natively as layer one data on chain. So with that, good luck.
