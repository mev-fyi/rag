00:00:07.750 - 00:00:08.294, Speaker A: Hey, yo.
00:00:08.342 - 00:00:17.660, Speaker B: What is going on everyone? Sean on here again from ETH Global and welcome to the Graph Workshop. I'm here with David from the graph. Would you like to introduce yourself?
00:00:19.310 - 00:00:31.380, Speaker A: For sure. Yeah, I'm Dave. I've been working at the graph for the last three years, focusing on the smart contracts and the protocol and a lot of subgraph as well, hence why I'm doing this presentation today.
00:00:31.830 - 00:00:36.626, Speaker B: All right, that sounds really cool. Well, take it away, David. This is going to be awesome.
00:00:36.808 - 00:01:16.830, Speaker A: Awesome. Thanks for the lovely intro. I will now share my screen and let's get started. So I'm just starting off here, going over the prizes that we're giving out for this presentation or sorry, for this hackathon. So there's $7,500 in total and we'll get into the details of what a subgraph is for those of you who don't know. But essentially you can see there's a couple of prizes for different subgraphs. So the first prize to focus on is there's three prizes of 1500 die for the best subgraph on a scaling solution supported by the Graph's hosted service.
00:01:16.830 - 00:01:50.110, Speaker A: And we'll see what the hosted service is and what I mean by scaling solution. Then there's another prize worth 1000 die for the best new subgraph that could be any subgraph at all. And two prizes of 250 die for the best meme related to the subgraph. I didn't even know about this one. That's awesome. I hope somebody crushes that one. And we also got the Graph will award one prize of 1500 die to one of the following subgraphs built on one of the sponsors for Scaling Ethereum, which is Rarible, ENS, Maddox, Uniswap or Ave.
00:01:50.110 - 00:02:32.870, Speaker A: So those are the prizes, you can find them on the scaling Ethereum notion document you got there. And now I want to go into the graph and what it is and a little bit of background on what this presentation will be, a background of what the graph is. And then we're going to go over a really quick example and all the examples there for us to show you how easy it is to get blockchain data from any blockchain that the graph supports and how quickly it can be done. And really it gives a lot of power to any developer in the blockchain space. And so what we're looking at right here, this is the hosted service. This is for the Graph network. This is where anybody can come and deploy a subgraph for free.
00:02:32.870 - 00:03:33.302, Speaker A: And it's kind of like a testing ground. And you can see if we click on Uniswap v two here, there's a playground right here where you can test all these queries to get all this rich data back from the blockchain. So here's all this data that gets returned. And this is all from a subgraph, right? And we're going to see how to build all that. But this is essentially the hosted service and we're going to deploy a subgraph to the hosted service in this example. But one of the main things I want to focus on as well is that this is the scaling Ethereum hackathon and the graph originally was only supported Ethereum mainnet and the testnets for Ethereum. But now we've also been adding a lot of blockchains over the last year and so some of the blockchains we do support right now are Ethereum Xdai, POA binance Smart Chain, Phantom Fuse, Clover Silo, Avalanche, Polygon which was formerly known as Matic.
00:03:33.302 - 00:04:41.154, Speaker A: As well know we have other things in the pipeline as well. We previously supported optimism but that's on hold now until they actually launch their main net and we have a couple of blog posts on the multi blockchain future for the graph. And there's projects we've mentioned there such as Polkadot, such as Solana that we've looked at and we're planning on adding although they're not ready yet. That's kind of the vision of the graph, right? The graph is this big project that's going to index all the data in web3 and blockchains and make it available to people and that's why we're adding all these other blockchains. So for this actual tutorial I'll go through it and show you how to deploy to subgraph to a different network and really any of those networks I mentioned like Matic, Xi, POA binance Smart chain, you can deploy a subgraph to all those. And so there's some other valuable resources I want to share with you here before we hop. There's the Graph.com
00:04:41.154 - 00:05:23.370, Speaker A: docs and if you go to the front page there Docs home, there's the hosted service docs. This is what you'll be interested in for the hackathon most likely. And this will go through more in depth what I'm describing in this short presentation. And if you're really interested and you're a new person, this is where I would recommend you come to to understand what's going on. Right? So there's a lot of good information here. I'm not going to go over all of it, I'm going to go over a subsection of it to allow us to complete deployment of a subgraph today. So one other thing I should probably get into before I show you how to deploy a subgraph is really what is a subgraph.
00:05:23.370 - 00:06:15.470, Speaker A: And a subgraph is basically a subset of data that is being extracted from a blockchain and presented to somebody in an indexed way so it can be queried. You can take basic blockchain data, that's very simple. It's the stationary value that is updated on Ethereum and you can build historical data from it. So what it allows you to do is extract all this rich data out of blockchain's index that put it in a database and have it queryable in a super fast manner. Because if anyone's ever dealt with Ethereum development many years ago before the graph existed, it was really slow to query an EVM node directly. And part of that reason is the EVM node is not built to return queries. Right.
00:06:15.470 - 00:06:38.934, Speaker A: It's this decentralized network that its goal is to make sure that the blockchain goes in the right order. There's not too many uncles. The chain doesn't fork all this. That's what it's more focused on, the distributed peer to peer solving of blocks. Right. It doesn't care too much about allowing all the data to be accessed very easily. So that's where the graph comes in.
00:06:38.934 - 00:07:16.546, Speaker A: It's this layer on top of blockchains that allows data to be extracted. So that kind of defines what the graph is. Now, what is a subgraph? If you really dig into this whole document right here, the docs, it'll describe it, but essentially a subgraph. My favorite way to describe it to somebody new is looking at the subgraph manifest. So the subgraph manifest is a YAML file and it's actually really easy to digest once you read it. It's very human readable. And as you can see right here, this is just getting right into it.
00:07:16.546 - 00:07:31.826, Speaker A: The spec version is 0.1. That's pretty straightforward description. Gravitar for ethereum. So Gravatar is the name of the example subgraph that we're looking at today. Repository on GitHub schema. And we'll see what the schema is in a second. It's a GraphQL schema.
00:07:31.826 - 00:08:00.830, Speaker A: If you're familiar with GraphQL, that's great. If not, I'll give a very short explanation and then we get into the data sources. So this is where the subgraph itself starts to designate what specific blockchain data it wants from a specific blockchain and from what specific contracts. So if we go down this kind is an Ethereum contract. Its name is Gravity. It's on the ethereum. Mainet.
00:08:00.830 - 00:08:29.130, Speaker A: And here we go. This section right here source. So this is a contract on Ethereum main net and we're telling it the start block that this contract was deployed on chain. Reason for that is if you know when it was deployed, you can skip the first 6 million blocks here. The graph node does not have to index all those past blocks. You can skip right to when it was deployed. As you can see, that's how we're starting to really hone in on the specific information that we're trying to extract from the blockchain.
00:08:29.130 - 00:09:03.534, Speaker A: And now we've identified the blockchain, we've identified the contract we're looking at. Now let's figure out what we want from that specific contract. Now there's a few things that we can get. We have these things called event handlers, call handlers and block handlers. So if you're familiar with Solidity, there are events that can be emitted by smart contracts. And so a solidity developer will create events and it's basically just information that's output as an event. It's not stored persistently on chain anywhere.
00:09:03.534 - 00:09:52.066, Speaker A: It's in storage. So it's a lot cheaper to emit an event. And usually an event should be triggered after a function does something that updates the smart contract storage and then you want to release that information to the world in an easier manner, right? So that's what events are there for. And in my experience, most subgraphs can be written with just event handlers, but what we also have are call handlers. So call handlers are executed when a specific function is called on a smart contract. So each function has a specific function signature which can be detected by the graph node. And so if a function is called, we can trigger on that as well.
00:09:52.066 - 00:11:16.346, Speaker A: And when these event handlers and call handlers happen, what we're doing is we're running a mapping and then you'll see this, the mappings are written in TypeScript and this mapping called Handle New Gravitar, it actually gets run and it stores this information in the blockchain or sorry, in the subgraph. And so what we're doing with these handlers is really like it's taking specific information on the blockchain from events or from calls and then storing it in the subgraph specifically. And so it's really powerful. We've gone from you pick your blockchain, you pick your address on that specific blockchain of the smart contract you're looking at and you pick the specific functions that you're interested in and the specific events that are emitted. And then you can build really rich and important data structures that can be released in this subgraph that the whole world can query. And so one thing to also mention, because for example, there's a couple of blockchains that are EVM, like forks, like polygon, right? But if it's an EVM fork and they only support Geth, which is the case for polygon, it means that call handlers won't work. And the nuanced reason for that is that the call handlers only work on the open Ethereum node.
00:11:16.346 - 00:11:41.906, Speaker A: So that's why it works for Ethereum Mainnet. You just have to run an open Ethereum node, that's an archive node. And then you can do these call handlers. So if you're running on something like polygon, which is deliberately a fork of Geth, you'll only be able to use event handlers and block handlers. And so that's just something to note. If you ever have any questions, you can come visit us in our discord channel and we can help you out there for sure. And the last one are block handlers.
00:11:41.906 - 00:12:22.654, Speaker A: Obviously that just happens on a block. Whenever a block is ingested by the graph node, you can trigger something. But I don't see these used too often because it's actually quite expensive to trigger every time that a block is emitted. It's a lot of work to do and there's not many use cases that I've seen other than if you want to store specifically Ethereum block information in a block subgraph. So that's good to note. Most likely you'll be dealing with event handlers anyway, so you probably won't have to worry too much about the call handler scenario I just described. Next if we get into the GraphQL schema.
00:12:22.654 - 00:13:29.670, Speaker A: So yes, this is the schema that defines the objects that you want to be displayed in your subgraph. So if we quickly go back to the Uniswap subgraph, this is what I'm talking about. This is a entity as we call it. And if you're familiar with know there's a token, this could be the Graph token. It can be any token and it has all total supply in the Uniswap exchange or on chain exchange, right? And how much trade volume total all time, how many transactions have happened, the symbol, all this information, right? You have other ones as well, like a user, so you can see what liquidity positions a user has, what transactions they've done. And this is also interesting, we have pair day data and pair hour data. So this is information that allows us to store historical graphing data for the subgraph and then you can display it as we see here in Uniswap info.
00:13:29.670 - 00:14:17.434, Speaker A: This is all created by a subgraph. It's very rich and has a ton of information and that's just not stored in the Smart contracts because that would be super expensive, actually would never work on Ethereum, right? But you can create a subgraph and you can build these and then anybody can use it. It's really powerful. So that's basically a schema, right? It's GraphQL. There's a bunch of documentation on GraphQL online if you're not familiar, but essentially you come along and you define the entities for the Smart contract you're looking at. And for the Gravitar example, a Gravatar is like an avatar basically with an image and a display name and an owner on Ethereum. So it's like whatever your Twitter handle would be with a description, right? Same idea.
00:14:17.434 - 00:15:05.874, Speaker A: And as you can see, this is pretty much a straightforward entity. This is an entity we're storing within the subgraph. We're going to take the information from the Ethereum Smart contract and put it into the database with this structure and that's pretty much a subgraph schema. It's important to design your schema and put a lot of effort in upfront, but once you have your schema designed, it's pretty much like set. You might make a few changes or you might want to expand in the future. But really the bulk of the work that's going to happen is writing mappings. So I've just discussed the subgraph manifest with you guys and it kind of is like the instruction manual for the graph and like the graph node and the graph network to know what data you're specifically looking at and then the GraphQL schema.
00:15:05.874 - 00:15:56.546, Speaker A: That's kind of your thesis of what the subgraph is supposed to be, right? You're saying what data objects you want to be stored and how you want them to be queried. And lastly we're going to do writing the mappings, which is the bulk of the work really, because the two things I described are more or it's an instruction manual and a thesis. And this is the part where you connect what's on the blockchain to what you're trying to build in your thesis with your subgraph. And this is where the bulk of the work comes in. It's parsing all the data on chain and putting it into the format that you want to share with people in your subgraph. So the mappings are written in TypeScript and they compile down to assembly script. And essentially, as you can see here, we have a mapping.
00:15:56.546 - 00:16:33.410, Speaker A: This is TypeScript code. We have an event. So this is an event in the smart contract that you'll see in a little bit. It's called New Gravitar. And so there's this function handler handle new gravatar which we saw up in the manifest. And essentially that means when this event is emitted on chain, this code is going to run. So when it happens, we create a new Gravitar entity, we give it the ID that was emitted in the event and we're just simply setting the variables we saw on chain in the event to the entity we have in the subgraph.
00:16:33.410 - 00:17:39.850, Speaker A: So this is event parameters owner and we're storing it right in the subgraph. And then we have another one down here for handling the upgrade or the updating of a Gravitar. And this is a really simple mapping right here and it really isn't too complex, but you can do a ton if you look at the uniswap subgraph, which is open source, there's a ton of stuff that's happening there to make those rich charts that I showed you earlier. So now let's get into the actual deployment of one of these subgraphs now that I've explained it to you. So if we go here, this is the graph, we're at the Explorer, you are going to log in with your GitHub account and go to your dashboard and what you're going to do is you're going to add a subgraph. And so I'm going to name this scaling Ethereum presentation. And before I get into deploying this, I'd like to ask if there are any questions from the people viewing.
00:17:45.390 - 00:17:56.160, Speaker B: Yes, Dave, there's a question in the chat. Can we use the graph to build a merkle tree if the events were to build a view across multiple chains? Or can the graph only view one chain or a single chain at a time?
00:17:57.010 - 00:18:59.700, Speaker A: So that's a good question. Yeah, I would call it still a research question that we're dealing with at the graph. And so you can imagine you have a graph node and it's indexing a subgraph on Binance smart chain and it's indexing a subgraph on polygon and it's indexing a subgraph on Ethereum. Now all those chains have different block times and that is going to influence how the graph node operates. It's easy to do one in isolation, but let's say you want to create a subgraph that queries multiple different blockchains and has guarantees about what the query actually is and what it returns. It's a lot more of a complex problem to solve. So ultimately yeah, the goal of a graph is to be able to resolve blockchain information for multiple blockchains at a reasonable time, right? Like if it's 6 seconds like polka dot and 15 seconds like ethereum, we'd want to have those as live as possible.
00:18:59.700 - 00:19:22.730, Speaker A: But that is still an area of research that we're going to be doing because you get a lot of things crossing over in that scenario and it's going to be a complex part, but that's what we're here to do and we're excited to build that. Any other questions? Sorry, I need to pull up the chat here as well for Zoom.
00:19:24.430 - 00:19:29.462, Speaker B: No other questions in the Zoom chat for now, so you can feel free to keep going.
00:19:29.616 - 00:19:50.638, Speaker A: Great. Yeah, I have the chat open now as well. I will continue on. Oh, I see. Another question I'll answer really quick. Does it only work for EVM compatible? Right now that is the case. So the chains that I mentioned before is like Xdai, POA, BSc, Phantom, those are all EVM chains.
00:19:50.638 - 00:20:46.182, Speaker A: We do have blog posts out explaining the chains we're going to look at next because we are going multi blockchain and some of those names are like Polkadot and Solana, but those are also new endeavors for us. I wouldn't call them research like the one I just said previously. We're actually working on these other ones, these multi blockchain support, I guess, for the graph node. But it's a new domain that we need to master, essentially. I think everybody's familiar with the EVM, but as the graph, as these other chains like Polkadot and Solana same, so will the other service providers and people all in blockchain building, wallets, building block Explorers, all this stuff. So, yeah, we will be getting there and we're there to help these teams allow people to get information from their blockchains easily as well. Great.
00:20:46.182 - 00:21:20.222, Speaker A: So I'll get back to this. This is the juicy part of the presentation, doing all the coding and show you how to deploy a subgraph. Let's give this a quick subtitle just because it's needed some other information you could fill out here. Not needed. I'm going to hide the subgraph because it's a presentation subgraph and it doesn't need to be shown to the world. And now you get to this. And I've now created the subgraph on the hosted service.
00:21:20.222 - 00:22:00.590, Speaker A: So you look up here in the URL, it says Dave Cadge. It's my GitHub name and the name of the subgraph that I chose. And you can simply just follow the instructions here. So let's install Graph CLI now on my computer and that will allow me to deploy on chain or sorry, to the hosted service. So if I do this, just installing the graph CLI with yarn on my computer, let's go back to the presentation. All right, so that's installed. Now we need to init a project.
00:22:00.590 - 00:22:47.382, Speaker A: So this is the example project I'm going to do. We have to run this command here. So this is just creating the repository. We made this command for people to we made this command to make it easy to set up the repository. It's kind of like scaffolding code. And so you go Graph admit from example, what did I call it again? Scaling ethereum presentation. And this should work, it should take about 20 to 30 seconds.
00:22:47.382 - 00:23:27.114, Speaker A: And this is all that this command is doing is it's setting up this scaffolding code. And what we're going to see is it's actually going to set it up and it's going to be for Mainnet Ethereum. But something I want to focus on here is how you would deploy it to a different chain. And so I'm actually going to deploy this to Ethereum Mainnet, but I'm going to go through how you would deploy it to Matic or Binance smart chain or whatever EVM chain that you're actually using. We'll just keep waiting for it to finish here. Great. And so before I do that, let's go back here.
00:23:27.114 - 00:24:09.030, Speaker A: And it's asking me to run Yarn install and Yarn code gen. I already worked. So code gen is sorry, I have to actually CD into that folder. So now I'm in the folder that I just created with Graphinet. Now let's run yarn install. Now let's run Yarn code gen. And so code gen just creates these TypeScript kind of bindings to make it easier to interact with the smart contracts, basically so that you don't have to create them from scratch.
00:24:09.030 - 00:24:36.880, Speaker A: And so now we're at the point where we're going to deploy it and it asks us to run Graph Auth. And so we're deploying to the hosted service, which is this and the access token. So first I'm going to copy this and go to my terminal. It's asking for my access token. This allows you to deploy to the hosted service. So I copy my access token here, which is showing right there. It'll be different for yourself.
00:24:36.880 - 00:25:00.194, Speaker A: Just run that. It should say it's all good. All right, we are verified. And now if you go here, it's going to ask me to run Graph Deploy. And before I do that, I just want to quickly go over the code. Let's open it up with BS code. And this is the repository.
00:25:00.194 - 00:25:29.194, Speaker A: This is what a typical subgraph repository looks like. This was auto generated with Graph init. And I'll focus on the files I've already showed you guys. Let's go here. This is the manifest that I showed you guys earlier, right? We're on ethereum mainnet. This is the smart contract address. So the thing that I want to point out here is if you're deploying to a different chain, you're essentially going to type in the command here like polygon.
00:25:29.194 - 00:26:00.678, Speaker A: And that's all you have to do. Now you're pointing to a different chain. And now let's say you have your own smart contract on polygon. You're going to type in the address that you have for that or whatever project that you're indexing on there. So then if it's a different smart contract, you're probably going to have a different handler. So you say like handle transaction and you're just going through and updating this. I'm going to revert all the changes I did here because we're still going to be dealing with this Gravitar contract on Mainet.
00:26:00.678 - 00:26:38.440, Speaker A: But the other thing to focus on is I don't know the exact command for Binance smart chain, but it's probably BSc. If you're doing POA, it's going to be that. It's very simple. We have the documentation for all that as well, so let's replace that with mainnet. And that's how you can really deploy to any of these networks. And so in relation to the prizes and stuff, that'll be very helpful for you because likely with this hackathon, you might be deploying on something that is L2 or some other network. So that's something to pay attention to.
00:26:38.440 - 00:27:04.986, Speaker A: Here is the schema. As you can see, it's just very simple. It's a Gravitar, has the ID, owner, display, name, image, URL, and that's all we're storing in this subgraph, right? And so we go up here. You need the Abi to create the TypeScript bindings. This Abi comes with every smart contract that's created. You should be able to find it online or you should have it yourself. It's just a binary file.
00:27:04.986 - 00:27:21.694, Speaker A: We don't have to worry about the contracts now. You don't have to store the contracts in the folder. This is just here for convenience. And as you can see, these are the events I'm talking about. This is how the event handler runs. These events are emit new Gravitar. It's emitted when this function is ran.
00:27:21.694 - 00:27:48.060, Speaker A: And we're basically just going to store this information in the subgraph. So this contract, like I said, only here for learning purposes. You don't need to include that in your own subgraph folder. These are just generated files. That's what happens when you run yarn code. Gen migrations are the typical migrations that come with kind of like Truffle and everything. We don't have to worry about that.
00:27:48.060 - 00:28:16.530, Speaker A: A bunch of setup files and now the source code. And this is the mapping that I've been talking about. So as you can see, this is also very straightforward. It's triggering on that event and it's created a new Gravitar and storing this information and saving it. So saving it goes into the subgraph, you're saving it in the database. And once that's saved, that means you can now load that entity. And that's how you update it, essentially.
00:28:16.530 - 00:28:55.246, Speaker A: And this is a common pattern you see sometimes you might load it and it might not exist yet, so it returns null and then you create a new one. And so that's a mapping. And this is likely going to be where the bulk of your code is ran or created because this one's really simple. But if you go to the uniswap subgraph. I think it's thousands of line of code, thousands of lines of code and that's really where the bulk of the work is because it's where you're taking what exists and you're making it into what you want it to be. Right? So that's pretty much all you got to see in this repository. And let's now deploy this subgraph.
00:28:55.246 - 00:29:55.106, Speaker A: So let's copy this and I'll just have to replace this with what did I call again? I'll just get it from here. So scaling ethereum presentation. Next time I'll pick a shorter name and this should deploy. So right now this is connecting to the hosted service, sending all the subgraph WASM files to the hosted service, uploading the WASM files to IPFS so that they're out there. And so in the graph network, everybody could grab them. And now it's deployed. So if we go here before it was in an undeployed state, now it's deployed and you see it's already synced up.
00:29:55.106 - 00:30:38.002, Speaker A: It's already synced up 12 million blocks because this subgraph already exists. But as you can see, all this information is stored within the subgraph and we're extracting this from the blockchain. So this is the example query showing the first five. But really all this information is taken from on chain and it's really easy to query it's milliseconds to get this information. And now you have this endpoint that anybody can query around the world and get this information. And that's what makes the graph so powerful. And as we have this platform, people will continue to build on it and build and find new ways to present information to people around the world.
00:30:38.002 - 00:30:58.860, Speaker A: And as more information gets stored on blockchains, it just makes the graph that much more useful to the world to use as a querying protocol in an indexing protocol. So that's all I have to say for the presentation. I'd love to take any more questions that people have.
00:31:00.190 - 00:31:11.280, Speaker B: Wow, that was an amazing presentation. There is one question in the chat. Can the graph keep up with Solanas? Yeah, that's kind of the question.
00:31:11.970 - 00:31:54.620, Speaker A: Yeah, I think they said Salana has 400 millisecond block times. So that's a good question. Could the graph do it right now? I don't know, I'm not the graph node developer, but we have a team of Rust engineers who do that. Realistically, 400 milliseconds is a lot faster than 13 seconds, which we see on Ethereum. So could it do 400 milliseconds? Maybe, if there were not that many transactions. But there's a couple of different aspects of scaling here. Right? So if it's 400 millisecond block time and these blocks are filled with a ton of information, it's going to be more pressure on the graph nodes to run.
00:31:54.620 - 00:32:47.926, Speaker A: It also depends on the mappings that you're seeing. So in that uniswap subgraph I showed to create that graph, that pink graph that goes up to the right, that takes a lot more power and time because those. Mappings are creating all of these entities on one transaction, right? Like I trade on Uniswap, but it has to update six entities within the subgraph, so that is going to be a lot more stressful. So I think whenever we get Salana working, it'll be a progression of first dealing with the 402nd block times, which technically, of course, that's possible to do. Nothing's impossible in the world. You could debate that, I guess. But of course we can reach the 400 millisecond.
00:32:47.926 - 00:33:37.786, Speaker A: It'll be an engineering effort and one that we're working on this year. Then it's also going to be, can we keep up with Solana if they're fitting in 1000 transactions in each block? If so, then that's great. And maybe we're going to have to improve on that as time goes. And then lastly, we're also going to have to work with subgraph developers to teach them that you can't create a mapping that wants to solve all the information in the world. We're seeing this a little bit. If anybody's paid attention on the Pancake swap subgraph, it has fallen behind before in the past, and that's because Binance Smart chain is three second blocks. But it's also the subgraph wants to do a lot in a short amount of time, and you can easily ask it to do less.
00:33:37.786 - 00:33:51.600, Speaker A: You could even split it into two subgraphs and then it would be twice as fast. So there's a bunch of different ways we can optimize the Graph node to get to that 402nd block time, as well as working with subgraph developers to speed up the time.
00:33:53.490 - 00:34:25.482, Speaker B: That's an awesome answer. I want to be wary of your time and really appreciate you for chanting here. There are a lot of questions from both the Zoom chat and on YouTube, so I want to remind everyone that if you are a hacker, feel free to go on to the hashtag, sponsor the Graph channel and then just paste your question in there. Someone from the Graph team will help answer the question. But yeah, thanks for coming, everyone. Really appreciate your attention. And again.
00:34:25.482 - 00:34:27.546, Speaker B: Great presentation, David. Really appreciate it.
00:34:27.648 - 00:34:30.070, Speaker A: Thank you so much. Awesome guys. Have a great time. Hack.
