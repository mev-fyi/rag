00:00:06.010 - 00:00:06.302, Speaker A: All right.
00:00:06.356 - 00:00:19.440, Speaker B: Hello and welcome, everyone, to the Filecoin Workshop making storage deals on Filecoin EVM. Joining us today is Zach Ayesh, who will be taking us through this session. And with that, I will pass over to Zach to introduce himself and get the session started.
00:00:20.530 - 00:00:45.882, Speaker C: Hey, everyone. Yep. My name is Zach ayesh. You might have seen me around on a couple of other filecoin coding demos. I'm a developer advocate with the Filecoin Virtual Machine Team at Protocol Labs. And today I'm going to go over programming on the Fevm. And you might have seen this talk from me before at previous global events, but on this talk, we're going to do something a little bit new.
00:00:45.882 - 00:01:46.372, Speaker C: We're going to go over towards the end how to make storage deals with smart contracts on the Filecoin Virtual machine. So this is a really cool new functionality we've been working on for a long time. The engineers have been hard at work, and so I'm excited to go through this demo with you today. Yeah. So, quick story. One of my very first projects interacting with any of the Filecoin IPFS protocols was creating a dynamic NFT. And essentially it was like this nerdy shooting jerseys cat reference where you would mint an NFT box and it would use the chainlink VRF and randomly pick when you minted the cat to either be this attack cat or a sleeping cat.
00:01:46.426 - 00:01:46.644, Speaker A: Right.
00:01:46.682 - 00:02:34.736, Speaker C: And this was probably two years ago or so now, and little did I know I'd be working this closely with the filecoin stack and helping push things forward. So today we're actually going to be using this photo to store with filecoin storage providers using solidity smart contracts. You can find. This is the actual photo of me trying to get this demo working. We actually first got this demo working for ETH Denver, and I presented at the Filecoin hacker base. It was quite the experience working with engineers late into the night. They put such a phenomenal amount of effort into getting this working.
00:02:34.736 - 00:03:15.120, Speaker C: And so, yeah, it was quite the herculean task. But I'm happy to be a little bit more well rested and presenting to you today. And if you've seen any of my other presentations, you know I like to talk about Imposter Syndrome in a lot of my talks. And I just want to briefly mention that here, this is like me working with the engineers, trying to figure out how all of this works. I'm still figuring all this out too, so don't feel bad if any of this is confusing to you or feels overwhelming. It is for everybody. I just like to put that in in all of my talks.
00:03:15.120 - 00:03:59.550, Speaker C: All right, so today we're going to be going through just a short introduction on the Filecoin Virtual Machine. I want to focus more on the coding side of things. We'll do a demo and remix deploying a very basic solidity contract, doesn't use anything special. Filecoin related in it. Then we'll show an example using the Filecoin Solidity libraries that gives you filecoin specific functionalities and then we'll move on to hard hat and making a deal on a storage deal using Smart contracts which is kind of the special thing we're demoing in this talk.
00:04:02.720 - 00:04:03.276, Speaker A: Right.
00:04:03.378 - 00:04:52.796, Speaker C: So what is the filecoin? Virtual machine. It is a virtual machine that lives on the filecoin blockchain right. And it delivers on chain programmability to the filecoin network for the first time. So the Filecoin Virtual machine is actually made in WebAssembly but it was built to support multiple you might have you'll hear me talking about the Fevm, right? And that isn't running on Ethereum or anything like that, that is running on filecoin. And how it works is at the base layer you have the Filecoin Virtual machine, like running on top of filecoin nodes written in WebAssembly and that was designed specifically to be able to virtualize other runtimes on top of it.
00:04:52.898 - 00:04:53.356, Speaker A: Right.
00:04:53.458 - 00:06:00.630, Speaker C: So the first runtime the team targeted was the Ethereum virtual machine because everyone knows how to work with Solidity at this point in web three at least, it's the most common language to use. There's tons of tooling remix, hard app, MetaMask, everything supports it. So the Ethereum virtual machine is actually virtualized on top of the FVM. And this Ethereum virtual machine, when you're interacting with it, acts like any other EVM chain you may be used to whether it's Ethereum or polygon or avalanche or what have you. And so to you it shouldn't look any different and you should be able to use all of your tools in the future. This could be extended to other runtimes if they are developed and there is a roadmap for the team to develop. What we call native actors are the ability to compile smart contracts to WASM and deploy those directly to the chain as well if you like to program in any language that compiles to WASM WebAssembly, which is a lot.
00:06:00.630 - 00:06:44.020, Speaker C: So yeah, this is the new thing. This is the big new deal, is creating a storage deal via smart contracts. This is a relatively new development even on the SEM and we'll kind of go over how it works. Essentially, we'll be emitting an event, a solidity event that boost storage. Providers can listen to and store your data for you. But this is the FIP filecoin improvement protocol. You can find it in the Filecoin GitHub if you want to read up more on a little lower detail on how it works.
00:06:44.020 - 00:07:13.942, Speaker C: All right, so let's go ahead and let's just dive into the coding. Well, again, we're going to start with a remix and we're going to deploy a very basic contract called Simplecoin. You can think of it as a simplified ERC 20 contract. Very basic. And yeah, this is just going to show off the EVM compatibility. So let's start out first. Of course, you're going to need to download MetaMask you can get this at MetaMask.
00:07:13.942 - 00:07:46.130, Speaker C: IO. It is one of the most popular Ethereum wallets you can get. I use it as a hot wallet for testing development. Yeah. So you can download it on MetaMask IO and you see I already have it downloaded right here, right? And once you have MetaMask, it doesn't know about the file coin chain. It has some default chains. It knows about Ethereum and its testnets, but it doesn't default know about the filecoin chain.
00:07:46.130 - 00:08:01.606, Speaker C: And so we're actually going to point it to Hyperspace, which is the Filecoin testnet similar to Sepolio or Gurley before it became a whole for profit thing on Ethereum.
00:08:01.798 - 00:08:02.346, Speaker A: Right.
00:08:02.448 - 00:08:53.330, Speaker C: So to add hyperspace to MetaMask, we can just go to Chainlist.org, click Include, testnets this out of the way, and just type in Filecoin. And you'll see here, like all of the different file coin testnets mainet as well, we're going to click on Add to MetaMask for Hyperspace, since that's what we'll be using for the remainder of this demo for fevm support comes out on March 14. So no EVM yet, but very close on main net. So, yeah, you just click Add to MetaMask. A pop up will come up for MetaMask. I already have it added right here.
00:08:53.330 - 00:09:52.790, Speaker C: But yeah, that'll add Hyperspace to your MetaMask. And finally, you're going to need to get some testnet fill. Just like Ethereum and almost any other blockchain you work with, you need to have currency to interact with that chain to prevent spam prevention and to pay the node operators for running all this computation. But on a testnet, you can just get this from a faucet, right? Because testnets have no value. Most testnets now I have to add. So we'll click on Hyperspace Yoga, and this is the faucet you can use. Now, Filecoin has its own address scheme, which you'll see as like key addresses, like t four yada yada yada, or t one yada yada yada.
00:09:52.790 - 00:10:42.680, Speaker C: But everything is actually compatible with Ethereum addresses, right? So if I just copy my account address and I paste it in there just the Ethereum address, we get to go through this awesome captcha, which is always a fun challenge to do live. Now click on the bunnies next. Our new bunny usually have to go through two screens. All right, cool. And click Send and Testnet fill from the faucet is on the way to my wallet. It takes about a minute to get to my wallet. We'll kind of go over transactions on File point in a second.
00:10:42.680 - 00:11:32.178, Speaker C: All right. But with that, you have MetaMask, you have some Tfill, and we're ready to move on and deploy some contracts on Remix. And I already have Remix open, so that's nice. So once you come into Remix remix is an online IDE integrated developer environment. Basically just a quick and easy way for Devs to test and interact with smart contracts. Some people use it for the old dev flow we'll go over hard hat a bit more complex tool later but for now we're going to go and Remix. And you'll see on the left here we have a little file Explorer and you should get some pre build smart contracts storage sold.
00:11:32.178 - 00:12:26.002, Speaker C: But I've imported these smart contracts, simplecoin is one of them and you can see it here, right? And all Simplecoin does is it's a very simple coin. It takes a constructor you can pass in a value for the tokens you want to be minted and it will mint it to whoever deployed this contract onto the Fevm. And we just have a function to send that coin to other addresses and get our functions to get the amount of token held by a specific address. So we're going to come to the compiler tab, click Compile, Simplecoin Sol and everything is good. I have autocompile turned on to make my life easier. And we'll go to the Deploy tab.
00:12:26.066 - 00:12:26.680, Speaker A: Right?
00:12:27.050 - 00:13:04.020, Speaker C: You're going to want to make sure that injected provider MetaMask is chosen. When you come in. It will default to Remix VM, that is a local VM within MetaMask and it doesn't interact with any blockchain anywhere, just this like virtualized chain on your browser. Injected provider MetaMask will tell it to send all transactions to a MetaMask. And because my MetaMask is pointed to hyperspace it is going to go to hyperspace and it looks like I got my five T fail added. So that's awesome.
00:13:05.510 - 00:13:06.260, Speaker A: Right?
00:13:06.950 - 00:13:52.690, Speaker C: So then you're going to want to make sure that the contract you're pointing to is the one you want to deploy or you want to deploy Simplecoin. And we're going to put in the constructor since that has to be filled out before we deploy it to 1200 tokens. That's how many I'm going to mint for simple coin and they will be assigned to me. Again, click Deploy, we'll see metamass comes up with a transaction. It's going to estimate gas fees. We're going to click confirm. So if you're used to gas on ethereum, gas on filecoin is actually calculated a bit different and it does use filecoin gas and not the traditional EVM gas.
00:13:52.690 - 00:14:46.158, Speaker C: So the gas calculations, you can find more detail in the docs but they're based on WASM time runtimes for all these computations as opposed to the hard coded gas values that you'll find in most ethereum runtimes. Right, and so that's going to take about a minute to deploy. It's going to take some time. So I have a pre deployed contract we can look at while that goes through. So you can load any contract right here as long as you have the abi and the address is deployed at which Remix has the abi. Since we have the contract in here and we'll just click Add address and it turns out my contract deployed at the same time. So that's convenient.
00:14:46.158 - 00:16:07.044, Speaker C: We'll just go ahead and look at the contract we just deployed all right? So if I copy and paste my account in here and click balances, boom. So I have 1200 I minted to myself to initiate this token. So that's simple coin, right? So this is just basic solidity working on the Filecoin EVM. But now I know that's cool, but why EVM on Filecoin, right? There's a million other EVM chains out there. And remember, the history of Filecoin is that it was designed primarily for decentralized storage, storing the Internet's data. And I find that this is a very important part of the web three stack, right? A lot of front ends for web Three DApps are actually hosted on centralized servers. And so Filecoin is kind of there for cold storage, right, which is a very important sector.
00:16:07.092 - 00:16:07.316, Speaker A: Right.
00:16:07.358 - 00:16:11.400, Speaker C: So we don't have to trust on any one centralized entity.
00:16:11.480 - 00:16:12.110, Speaker A: Right.
00:16:13.360 - 00:16:24.156, Speaker C: So the Filecoin blockchain actually monitors the storage deals, right. The metadata for the storage providers.
00:16:24.188 - 00:16:24.768, Speaker A: Right.
00:16:24.934 - 00:17:21.082, Speaker C: And so how can you access these storage deals? You can do them through these Filecoin solidity libraries created by our friends with the team Zondex, right? So let's take a look at them right here. I'm about to go into some more detail about storage deals in A. So, you know, these are basically solidity APIs. You can't use these on any other chain because these are specifically for the Fevm and they again take advantage of these native actors, we call them, for interacting with storage deals. It is in beta at the moment, is being audited as we speak. It should be ready very soon. But I just need to put that disclaimer and yeah, you see, the README kind of explains some things.
00:17:21.082 - 00:18:20.030, Speaker C: If we look in the contracts directory you'll see here we have APIs. These represent APIs that were already open to Filecoin, but this opens them up to be used in solidity. So if we look at the market API solidity contract, this actually opens APIs like a bunch of gitter APIs for getting information about a specific deal on chain, getting the actual PCID, getting the client who asked for the deal, getting the provider, the address of the provider who's storing the deal, and so on. Right, so using these in your DApps really opens up the world of the Fevm when compared to other EVM chains.
00:18:26.890 - 00:18:31.560, Speaker B: Hey Zach, when you're in remix, can you zoom in a little bit as.
00:18:32.190 - 00:18:52.350, Speaker C: Yeah, sure, yeah, no problem. I'll make sure to do that when we go to the next contract. Yeah, appreciate that. Cool. So I'm mentioning these deals, right? So let's talk a little bit more about them and how they're created in the past and how we're going to create them later on in the demo.
00:18:52.420 - 00:18:52.990, Speaker A: Right?
00:18:53.140 - 00:19:05.330, Speaker C: So if we go to Phil Fox, which is a block explorer for Filecoin, you can click on the blockchain tab here and click on deal list.
00:19:05.400 - 00:19:06.020, Speaker A: Right?
00:19:06.950 - 00:19:26.054, Speaker C: And these are actual storage deals on chain. If we click on one, this deal ID. Right here you have the provider. These are usually miners on the file coin network and their address, their ID, and you have the client, right. The address of whoever requested data to be stored.
00:19:26.182 - 00:19:26.860, Speaker A: Right.
00:19:27.710 - 00:19:42.542, Speaker C: The data that are stored here in this deal is 32GB. And you can see when it was stored and the PCID, aka basically you can think of it as the root hash of the data that's stored there.
00:19:42.596 - 00:19:43.200, Speaker A: Right.
00:19:49.850 - 00:20:37.086, Speaker C: So we're going to talk a little bit more about that root hash that I mentioned earlier, also known as the PCID or the comp. So you'll see this big graphic. It may look confusing, but it really isn't much. Essentially, you take a file, let's say it's that cat photo that I showed earlier, right. And you want to prepare it to be stored in a firecorn storage tail, right? Well, one of the first steps is you're going to turn it into a car file, right, a compressed version of the actual file. And then you're going to want to compute what we call the IPLD Dag directed asyclic graph. Confusing.
00:20:37.086 - 00:21:27.650, Speaker C: It's just like a tree. If you're familiar with the inner workings of Ethereum or Merkel tree or a binary hash tree, that's essentially what it is, right? So it's going to take that data, it's going to take that file, that compressed file, it's going to split it up into chunks and then it's going to hash each of those chunks and then create a tree hash all the way up until you get your root hash. And this allows you to get like a hash that represents the whole data. And so that kind of just represents the raw file or the raw compressed file. You're going to want to pad the file to make sure it fits. And there's tools that do all of this. We're going to use one later in the demo with some zeros.
00:21:27.650 - 00:23:09.202, Speaker C: And essentially when you send this to a storage provider, you're going to send this padded compressed file along with the IPLD graph or Dag, to the storage provider and they're going to confirm that your file does in fact hash to that PCID or that root hash. And that's going to be what represents your deal on chain right here, right? So long story short, file, we create this graph, we get this piece of data that represents the file and that's what we send to the storage providers to store our files. So this is how deal making works at the protocol level and how it worked specifically before the FBM was a thing, right? Essentially, you, the client or whoever wants to store the data would decide what data you want to store. You would use a tool of your choice to compress it and create that file that we talked about earlier. You would do some research on storage providers and what deals they're offering, maybe, you know, a storage provider and you can negotiate with them either way. Say, okay, kind of find a deal that you think works. You need to lock some funds in escrow so that the storage provider knows you have the funds to pay for the deal.
00:23:09.202 - 00:23:14.622, Speaker C: Over time, you send what's called a deal proposal to the storage provider.
00:23:14.686 - 00:23:15.300, Speaker A: Right.
00:23:15.670 - 00:23:37.254, Speaker C: And the storage provider will look it over and make sure that that's what you all negotiated or what they deem as a fair deal. The storage provider would then say, okay, this looks good, we're ready to accept this and publish the deal. So then you need to actually transfer the data to the storage provider.
00:23:37.302 - 00:23:37.754, Speaker A: Right.
00:23:37.872 - 00:24:05.654, Speaker C: And all of these steps, there were tools to do this. There's marketplaces you can look to find storage providers. But yeah, this is quite a manual process. There was also things like Web Three Storage and NFT Storage that do all of these steps for you and make it a lot easier. Yeah. You would transfer the data over. They would make that check to make sure the data is actually what the PCID that's in the deal.
00:24:05.654 - 00:24:11.474, Speaker C: And then they would call function on the file. Queen APIs called publish storage.
00:24:11.522 - 00:24:11.830, Speaker A: Deal?
00:24:11.900 - 00:24:57.084, Speaker C: And that would actually prepare them for storing the data. And so that's kind of the traditional way of making the deals and how everything worked with the FVM. I know that was a lot of information. So I'm going to go ahead and check the chat to see if there's any questions about any of that before I move on. So, yeah, if you have any questions, feel free to drop them in the chat as we're going on and I'll try to make periodic checks like this. Yeah.
00:24:57.122 - 00:25:05.200, Speaker B: There was one question from Harsh how Fevin, Mainet would lead to burning Phil.
00:25:06.260 - 00:25:24.436, Speaker C: Burning Phil, yeah. So Filecoin, just like Ethereum, has a similar implementation for EIP 1559. So every transaction that's sent to the filecoin blockchain, some of that fill is burned.
00:25:24.468 - 00:25:24.904, Speaker A: Right.
00:25:25.022 - 00:25:38.090, Speaker C: And so with the Filecoin virtual machine live, you would expect more transactions to be coming through now because there's more utility and that probably increase the burn of fill.
00:25:41.640 - 00:25:42.016, Speaker A: Yes.
00:25:42.058 - 00:26:01.944, Speaker C: And I see some feedback on zooming in. We'll make sure to do that when we go back. Okay, cool. So I think that answers all the questions right now. We kind of talked about the traditional way they make deals. You can still totally make deals that way. By the way, none of this deprecates.
00:26:01.944 - 00:26:10.032, Speaker C: That filecoin still works that way. This is just adding on functionality and new ways to make deals using smart contracts now.
00:26:10.166 - 00:26:10.800, Speaker A: Right.
00:26:10.950 - 00:27:09.410, Speaker C: And so one of the first ways we demoed how to do this was what we call the bounty hunter method. And there's a contract you'll see in my hard hat later that does this. But essentially it's just a smart contract where you take that PCID again, that piece of data that represents it and the size of data you want to store and you just create a bounty in a smart contract for that, right? And so this is a very useful tool, I would say, for dows. Like maybe you're a decentralized science, a D side dow and you want to crowdfund for a specific piece of data to be stored on the filecoin network. You can use this flow to say, hey, this is the PCID for the data, this is the size of the data that we want stored. Let's crowdfund and see who can actually get this data stored on chain for us. And we'll reward them.
00:27:09.410 - 00:27:54.690, Speaker C: And it actually uses the filecoin libraries to make sure that the payment is sent to whoever actually the address of whoever made the deal, right? So this is one way, this is just kind of like, hey, please someone make my storage deal for me. This is what we're going to demo. And this, later on, is an even more automated flow for making a deal, which now let's say I have some data I want to store. I generate the car file and the Dag. And in part of my smart contract flow, I want to be able to call a method to store this data.
00:27:54.760 - 00:27:55.380, Speaker A: Right?
00:27:55.830 - 00:29:21.310, Speaker C: And so we can actually call a function in solidity as long as it admits that event I talked about earlier create deal proposal. Boost storage providers can listen for that event to be mitted from the EVM and read the data from it and use that as the deal proposal, right, and actually store your data from that. So we're going to tell them, hey, we have this already pre prepared data in a server somewhere. Here's the deal proposal, here's how much I'm willing to pay, here's the collateral, here's how much collateral I'll expect from you and how much this is all going to cost per block and send that into a function in our smart contract. That function then emits an event. The boost storage provider sees that event and says, hey, that looks like a fair deal, takes it up and stores your data, right? And a core thing I do want to point out here is that when the storage providers actually store your data, they are writing proofs to the filecoin blockchain that they are storing your data. That's super important, right? That's how we keep this all decentralized is that we're not just trusting the storage providers to keep your data live, they actually have to provide proofs and specific windows and if they don't, they risk getting slashed.
00:29:21.310 - 00:30:01.174, Speaker C: So we're going to first go through a demo and remix again using the filecoin example contract I call the filecoin market consumer. It just uses that Zondax filecoin solidity library and gets data for a specific deal on hyperspace, right? It's all the same things. We're just going to go here back to remix and I'll zoom in. Hopefully that is better. And we're not going to do a simple coin. We're going to come back here and we're going to do this file coin market consumer.
00:30:01.222 - 00:30:01.770, Speaker A: Right.
00:30:01.920 - 00:30:16.414, Speaker C: Really basic contract. We just have a bunch of state variables and a bunch of functions to call those getter functions in the market API for the Zondax.
00:30:16.462 - 00:30:16.674, Speaker A: Right.
00:30:16.712 - 00:31:02.986, Speaker C: So we're just calling all these getter functions and storing the data in our smart contract in these state variables here. Right, and then I have one function that calls all of these mini functions store all. Yeah, I see a question for repos. Would showcase the file coin storage deals working? Yeah, we're going to get to it right after this demo. So, yeah, we're just going to compile it here. We are calling the Zondex libraries and just like everything else, make sure it's injected provider MetaMask up here supporting your filecoin market consumer. You can hit deploy again.
00:31:02.986 - 00:31:11.280, Speaker C: To save us some time, I'm going to pull in a pre deployed contract. We don't have to wait for the transactions to go.
00:31:14.510 - 00:31:16.300, Speaker A: Oh, not that one.
00:31:24.720 - 00:31:50.394, Speaker C: Throw this right there. All right. So if we go to Phil Fox, we're going to go back to the main Phil Fox page. We're on main Net right now and we're actually working on Hyperspace. So we're going to switch the network it's running to to Hyperspace. And let's pick a deal we want to pull information on.
00:31:50.432 - 00:31:50.778, Speaker A: Right?
00:31:50.864 - 00:32:39.130, Speaker C: So let's just get information for Deal ID 1011 and we're going to remix. You can store deal 1011. Click store all. We'll confirm our MetaMask transaction, go through again, we aren't paying gas fees. It is going through with that EIP 1559 like structure where some of the fees are getting burned. But yeah, this should update with our information for that specific deal. If we look here, we actually have this old deal with old information in it, since this is a pre deployed contract.
00:32:39.130 - 00:33:12.274, Speaker C: And when this transaction goes through, we'll come in and we can see that like, hey, this deal matched with that. But it's going to take some time for the transaction to go through. So actually why transactions take time on the file coin blockchain is because there's what's called a delayed execution model, where it takes about 30 seconds for your transaction to be actually included in the chain and another 30 seconds for your transaction to actually be executed.
00:33:12.322 - 00:33:12.920, Speaker A: Right.
00:33:13.530 - 00:33:40.800, Speaker C: And yeah, so that's why it takes about a minute on average. So our transaction has gone through. And let's look at some of the information here. Right, so our size is two six two. Let's look at here. Yes. So 256 kilobytes, that's about where we're at on there.
00:33:40.800 - 00:33:52.094, Speaker C: And this is actually that PCID, but serialized and represented as ethereum bytes.
00:33:52.142 - 00:33:52.306, Speaker A: Right.
00:33:52.328 - 00:35:19.950, Speaker C: So if we convert it to the representation CID representation, which I believe is base 64, it can be represented as a CID that we see on chain the price per Epic, which is zero. Since this is on testnet, the deal provider actor ID 1036, which is their deal ID right there, right? So we got the information from that deal in our smart contract. And you can use this to create all kinds of cool logic, other applications that you may have heard earlier like data dows or perpetual storage contracts, all kinds of things we're excited about to be built, right? Okay, so now we're going to move on to the new cool part, right? And we're going to actually create storage deals with that method I talked about earlier on Hyperspace. And we're going to do it via hard hat, right? So you can find this Nifty hard hat starter kit under the file coin project GitHub. And here you will see if we go under contracts, you'll see the basic solidity examples. There's a simple coin we deployed earlier. You'll see that bounty contract I talked about in the market consumer we just interacted with.
00:35:19.950 - 00:36:28.160, Speaker C: But we're actually going to be dealing with basic deal client today and Dealcline Sol specifically, right? So let's go ahead and we're going to clone this repo, try to get this, got to minimize this. So we're going to go into a terminal. You see, I already have another repo open here, but we're just going to walk through this real quick. We're going to do Git clone and we're going to paste in that repo name, make it big so it's easier to read enter that's going to clone it in there. We're going to type in code. I have the Vs code shortcut that'll automatically open this in Vs code we don't need to update right now. I'm actually one directory up, right, so let's CD into the Fvmr kit now.
00:36:28.160 - 00:36:43.780, Speaker C: We'll open it from there. I'm goofing with my typing abilities right now. There we go. All right, cool. We'll open a terminal in here.
00:36:45.670 - 00:36:45.986, Speaker A: And.
00:36:46.008 - 00:37:39.190, Speaker C: One of the first things you're going to want to do is type in yarn to download packages. And this will get all the packages that we need into our project. And while that's going on, we'll just kind of talk about how this works, right? So again, just like I showed you in that repo, we have all of those contracts, including the Geoclient Sol contract. And it's going to give us some problems just because some downloaded yarn. But it's fine. We have a deploy script right here that deploys each of our contracts. And we have very importantly here tasks, right? And these tasks are how we can interact with our deployed smart contracts once they're on chain.
00:37:39.190 - 00:38:24.626, Speaker C: So if we go to, for instance, the market consumer, we have a task that calls that store all function, right, and sends it on chain. But what we're going to focus on here is we're going to go back to Dealclient Sol and we're actually going to focus on calling this function make deal proposal, right? So it takes in this struct called Deal and stores a bunch of information on. Chain does a lot of stuff, but the most important thing is it emits this event deal proposal create.
00:38:24.808 - 00:38:25.540, Speaker A: Right?
00:38:26.550 - 00:39:16.340, Speaker C: And that's the event that storage providers know to look out for. And if you want to see that struct, here's our deal request. We're going to pass in a PCID a piece size is the deal verified on fill plus the label, which is usually the raw CID, before we do any padding or anything to the car file. When we want the deal to actually start. The Epic we want it to start when the deal will end. How much we're going to pay per Epic? The collateral that the provider puts up in case they need to be slashed. The collateral the client puts up or you the client puts up to prove to the provider that you can continuously pay them for their services.
00:39:16.340 - 00:39:21.750, Speaker C: And these extra params here are where some interesting magic happens.
00:39:21.820 - 00:39:22.294, Speaker A: Right.
00:39:22.412 - 00:39:23.880, Speaker C: So this is where we're saying.
00:39:25.690 - 00:39:26.006, Speaker A: The.
00:39:26.028 - 00:39:49.374, Speaker C: Boost storage provider sees that there is an event emitted in Ethereum and they say, okay, this proposal looks good. I want to store that data. But they need to retrieve that data from somewhere, right. So we need to have that in some kind of open server somewhere else.
00:39:49.492 - 00:39:50.160, Speaker A: Right.
00:39:54.930 - 00:40:14.406, Speaker C: So, yeah, see, there's still some maybe issues with reading it, so hopefully this makes it a little bit more clear. Yeah, so that's kind of what we're doing here. We're giving them like an HTP ref or IPFS reference and the size of the file that they're actually going to store.
00:40:14.508 - 00:40:15.160, Speaker A: Right.
00:40:17.530 - 00:41:10.050, Speaker C: And then to deploy, you just type in Yarn Hard, Hat Deploy in the console, hit Enter, and I'll run the script and actually start deploying our contract. Oh, of course. One specific thing I missed here is we need to add our private key in a EMV file, right? So you're actually going to want to create a EMV and then put your wallet private key in there. So Hardhat knows what wallet to send this transaction with. Right, and you can do that by going into MetaMask. And again, I always have to put this disclaimer. Never ever show your private key to anyone and never ever check this into Git.
00:41:10.050 - 00:41:31.866, Speaker C: If someone gets your private key and you have mainnet funds in that wallet, they can and most likely will steal the funds, right? This is a dummy account I use just for demos, so there's no real money associated with this. And I want to show you the steps, but again, this is not advised to ever be shown.
00:41:31.898 - 00:41:32.094, Speaker A: Right.
00:41:32.132 - 00:42:26.400, Speaker C: So you're going to go here, going to type in our password and MetaMask and we're going to copy our private key over. Please don't steal my poor testnet fill. You just type in private key, private key. Put it in some quotes, paste save. Now we'll type in Yarn Hardhead Deploy and our deploy script will start and start deploying our it's going to compile our solidity files and it's going to start deploying them, right? We're not going to wait. That's why I have my other demo open. We're just going to go ahead and close that and we're going to go to the pre deployed one which real quick.
00:42:32.430 - 00:42:33.420, Speaker A: All right.
00:42:35.730 - 00:42:37.360, Speaker C: Go ahead and open this.
00:42:40.720 - 00:42:41.244, Speaker A: All right.
00:42:41.282 - 00:43:24.350, Speaker C: So in this repo we've already deployed the contracts. Everything is good there. We've done the yarn, I have the env file and so we're almost ready to call the method. The last thing we need to do here is we need to take a file and we need to generate that car file and we need to store it somewhere, right? So let me make sure this is big. Maybe that's a little too big. So what we're going to do.
00:43:28.990 - 00:43:29.306, Speaker A: Do.
00:43:29.328 - 00:44:08.802, Speaker C: I have my Explorer open here? All right. So if I just go to my pictures right here, you'll see I have my photo heattack JPEG as opposed to he sleep. And so that's the file we're going to turn into a car file. And how we're going to do this is we're going to use this Tools Go generate car tool right here, right? So if I see D into tools and I see D into go generate car. You can type make. I've already made it. This will compile it.
00:44:08.802 - 00:44:56.602, Speaker C: This tool is written in Go. Hopefully we'll write this tool in JavaScript so it'll be a little bit more native to hard hat. But for now it's written in Go. So make will actually compile the program and we can call it from this directory, right? So what we're going to do is just to save time, I'm going to put the script in here. We're going to call in this directory generate car. We're just going to say, hey, it's a single file and this is where the file is, right? And see attack JPEG. And this will actually generate the car file, right? And the IPL dag that goes with it.
00:44:56.602 - 00:46:01.730, Speaker C: So if I hit enter, you'll see we have all these CIDs are generated. The very important one we need is right here under Data CID we have PCID, right? So that is the CID of the file that we're going to store and that's the PCID that we're going to use to represent this to the storage providers. Now if I LS, you'll see here, this is that CID car and this is the size of the file we're going to store, right? So we've generated the car file. Now we know the size of the car file. We want to actually put this somewhere that the storage provider can store, right? This could be anywhere, right? This could be any open service. But an easy one we're going to go to today is web three storage. So we're just going to type in web three storage.
00:46:01.730 - 00:47:22.318, Speaker C: And I'm logged in and we're going to click Start now. And here you can just upload files and web three storage will actually go through that traditional deal making flow and make deals for you. But what we're actually using this for is they actually just store your data in their IPFS gateway and anyone can kind of pull it up that way, right? And so that's what we're going to so, you know, I uploaded the raw file here, but here is that generated car file I click on, the CID will come up right here and this will pull up like the gateway for it on IPFS right here. And that's actually what we're going to pass through and use as the URL signal to our storage provider. We want to store this file. Okay, so all of that said, we now have our file stored in a server somewhere or IPFS or wherever that the boost storage provider can look for. We're ready to call that function make deal proposal, pass in all of our deal information and see hopefully if the storage provider picks it up.
00:47:22.484 - 00:47:23.200, Speaker A: Right.
00:47:26.230 - 00:48:38.290, Speaker C: So we're going to go back out to the main hardhat kit directory here and we're going to call this task Make Git Deal proposal. And you see there's a lot of parameters it takes in and so this is one we're going to copy and paste into the terminal. And I can just show you because I have it in a Google doc right here, right? So this is the task we're running. So yarn hard hat tells it okay and then make deal proposals the name of the task. And we're pointing it at this contract f pre deployed and we're giving it that PCID of the data that we have stored, the size of the data, the verified deal is false. And we're passing it all this information in and where it can actually find the data to store. So that's the actual full task I'm running.
00:48:38.290 - 00:49:01.424, Speaker C: We'll hit enter and this is going to take a second to go through. Again, it's making the deal proposal network hyperspace and we're going to look at something cool because I'm actually SSH into a Boost storage provider, right? And so hopefully we can see it.
00:49:01.462 - 00:49:03.410, Speaker A: Pick it up live, right?
00:49:04.200 - 00:50:17.202, Speaker C: So here is a Gui for the boost storage provider. And hopefully once this dealer goes through, once the transaction goes through, we'll actually see a new deal added on here that the deal proposal picks up, the storage provider picks up. So we'll just give this a second to go through. We can kind of look here at the GUI for the Boost storage provider. So Boost is just a kind of helper binary you can run that storage providers typically run to make it easy to deal with storage deals and visualize them with this convenient GUI. So they usually run alongside a filecoin node, like a Lotus node, right? So this task is going to go through, it passes everything in and then actually listens for the event, right? And boom. You see our transaction went through.
00:50:17.202 - 00:50:51.406, Speaker C: It emitted the event. And right here, the storage provider has seen that event and it's actually pulling in the data, right. It's saying transfer installed. That may be because of like a Http gateway. It'll try to redo that, right? And boom, there we go. So it's transferred the data, it's made all the checks that the PCID matches the file, and it's saying, hey, this deal is good to go. Everything looks good, and we're ready to publish the storage deal.
00:50:51.406 - 00:51:51.672, Speaker C: So after that, if I was this SP, I can just come here and click Publish now. And it's going to publish that deal on chain for me. And of course, the SPS probably have automated systems to do this. This is just a very manual way to demo how this works, right? And again, that data they're storing is that picture of my cat, right? All done through smart contracts. So very excited about this. If we click on the deal here, you'll see that the client address is like a filecoin client address, a T Four address, right? But if we actually copy this, we'll just open it up and we'll copy it right here. We copy this and you go to like a translator tool.
00:51:51.672 - 00:52:08.270, Speaker C: There is one in the Hardhead kit script. Milwaukee translate addresses for you. Type it right here. No, because it's just converting. Just put it in here. And we need to put it on hyperspace. That's the issue here.
00:52:08.270 - 00:52:54.940, Speaker C: So if we do that, you will see that this is the ETH address of the contract that we admitted. So if you use the contract itself as the client of the event, right, and we can also look up this contract on Phil Fox, on hyperspace. We could put in the Ethereum address or the T Four address. Either one works. See, it's going to say actor EVM And it's going to show these. This is the transaction we made with a big deal proposal and the events we emitted, right? And so, yeah, this is the full workflow. This is how you create storage deals on filecoin.
00:52:54.940 - 00:53:52.220, Speaker C: And I'm going to blast you with a bunch of resources now before I save a couple of minutes for Q and A, right? So let me see here again. Here is the Hard Hat starter kit. If you missed it, you can find it in the GitHub for the Filecorn project Fevm Hardhat kit. And if you go within Hard Hat kit, you'll actually see if you scroll all the way down, I link to Foundry kits for each of the client contract and the bounty contract. That's where they're being developed currently under the Lotus Project. We are going to kind of bring all of this together. But if you are kind of privy to foundry, you can look at these and they have a little bit more technical detailed READMEs.
00:53:52.220 - 00:54:33.924, Speaker C: And I also want to shout out a community driven foundry starter Kit, right? So a great community member, very active. Shing developed this Foundry Kit right here and he's very active community member. He's active on the ETH Global Discord as Appeap. And yeah, I'm just super proud that this is getting made. He's updating it constantly. Very knowledgeable community member. And yeah, we're going to work on getting this completely up to par.
00:54:33.924 - 00:55:01.716, Speaker C: This will probably become the official Foundry Starter Kit that we push everyone to. So thank you very much Jinhang, for such an awesome job. And my colleagues Matt and Sarah are actually doing Twitch streams now, twitch Pvfilbuilders. The next two streams will be March 16 and 23rd at 09:00 a.m PST 12:00 p.m est. 05:00 p.m
00:55:01.716 - 00:55:02.592, Speaker C: UTC.
00:55:02.736 - 00:55:03.188, Speaker A: Right?
00:55:03.274 - 00:55:57.572, Speaker C: So feel free to go jump on those streams, ask questions, you'll find me there for some of the streams for sure. But we're excited to launch these Twitch streams. There is a request for startups out. So if you are a startup and you think you want some support, some kind of maybe some grant funding or just seeing what's going on with mainnet, feel free to come over here to the request for startup. So RFS, FVM dev and finally, all of this was done on Hyperspace testnet, but this will be launched March 14 next week. We are super excited on Pi Day. Of course, we are all nerds over here and we love it.
00:55:57.572 - 00:57:13.550, Speaker C: So you can watch the event for the FBM Mainet launch on the Filecoin YouTube and please go there subscribe wait, it'll be a big deal. And finally, for everything else, my colleague Sarah has made this awesome link tree that just has a bunch of other resources on Know an about page the docs. This hackathon cheat sheet is really convenient if you're going to be on the hackathon. It really combines all of these resources that we've talked about it's up to date now. And yeah, super useful resource. And finally we have our Mainnet Cohort, which you can apply for as well, which is just a combination of teams that are all looking to deploy to Mainnet and are ready to go and become active members of the Filecoin UVM launch. So thank you so much for listening to my talk.
00:57:13.550 - 00:57:25.170, Speaker C: Looks like I have just a couple of minutes to address any questions in the chat and I see there are some, so I will try to answer them.
00:57:25.860 - 00:57:32.500, Speaker B: Yeah, one of the first ones was were there any libraries other than Go for creating car files?
00:57:34.840 - 00:58:12.450, Speaker C: I think there might be a JavaScript library out there somewhere. I'm not sure if it's up to date in how well it works. Right now we're using this, but we are working on making more libraries and we're actually working on with the community to make a front end that will do all of this for you. Right, so just a convenient web app where you can go in, upload a file or generate the car the Dag Everything Store. It somewhere that storage providers can take up. That'll be all done in the browser. So we are definitely looking forward to that.
00:58:14.180 - 00:58:24.420, Speaker B: And William asked what is the difference between the piece CID and the CID you get when you upload the file to IPFS?
00:58:25.800 - 00:58:52.376, Speaker C: Yeah, that's a great question. So the IPFS CID is actually just kind of the raw called the comd CID, where you just take the file, turn it know, you generate the IPLD Dag for it and you generate that. The PCID is very specific since storage providers want these specific formats. So we turn into a car file, we do that padding and then that CID that we get is the PCID.
00:58:52.408 - 00:58:52.556, Speaker A: Right.
00:58:52.578 - 00:59:10.390, Speaker C: So it's just a very specific CID, but they look identical. Right. And if you were to put that car file with the Pading and everything on IPFS, I believe that might be the same CID that you would get, but don't quote me on that.
00:59:12.920 - 00:59:18.630, Speaker B: Harsh asked how to access the data once stored, like via IPFS only.
00:59:19.820 - 00:59:59.332, Speaker C: Yeah, so that's like the retrievability side of things. There's a lot of cool projects working on that. You can go to the I believe it's the Lotus Docs as a section on retrievability on here. You can also use a service like Filecoin Saturn, which is new. So this is basically a I don't think this works with Filecoin. It works with IPFS but not Filecoin just yet. But it is working.
00:59:59.332 - 01:00:22.548, Speaker C: So this is a CDN that caches IPFS requests and makes them super available. Anyone can run a node. You can go to Saturn network and they are working on being compatible with Filecoin as well to make data available on filecoin retrievable.
01:00:22.644 - 01:00:23.048, Speaker A: Right.
01:00:23.134 - 01:00:30.910, Speaker C: So there's a lot of know search on Filecoin retrievability and it's being made easier every day.
01:00:33.860 - 01:00:37.580, Speaker B: And what are the key advantages over IPFS?
01:00:37.740 - 01:00:53.924, Speaker C: Steven asked that fantastic question. So IPFS is its own peer to peer network for file sharing. I can pin data on IPFS, I do all the time and it's there. But there's no guarantees that your data on IPFS will stay there.
01:00:53.962 - 01:00:54.550, Speaker A: Right.
01:00:55.880 - 01:00:58.612, Speaker C: If everyone stops pinning that data, it's gone.
01:00:58.746 - 01:00:59.236, Speaker A: Right?
01:00:59.338 - 01:01:16.428, Speaker C: Someone could always repin it, but there's no guarantees, right. Filecoin, we have very strong guarantees that the data will still be stored because the storage providers have to provide those proofs on chain that they have it or else they risk slashing. So they're directly incentivized to keep your data.
01:01:16.514 - 01:01:16.860, Speaker A: Right.
01:01:16.930 - 01:01:25.550, Speaker C: So Filecoin is really used for cold storage of data, data that you want. Very strong guarantees will be stored and available.
01:01:28.560 - 01:01:32.080, Speaker B: Awesome. Okay, that was all the questions in the chat.
01:01:32.820 - 01:01:33.568, Speaker A: Awesome.
01:01:33.734 - 01:01:49.210, Speaker B: A little bit over. So yeah. So thank you for joining us today, everybody. And thanks Zach, for the great presentation. I'm going to drop in the Filecoin Discord channel. If anybody else has any other questions, feel free to reach out there.
01:01:50.460 - 01:02:07.320, Speaker C: Please do and thanks so much for having us. This was awesome. So I hope all of you found it helpful. Feel free to reach out to us on the Corn Slack, on the global discord and anywhere we can be found. And we'll try to reply. And happy hacking.
01:02:08.140 - 01:02:08.612, Speaker A: Cheers.
01:02:08.676 - 01:02:08.950, Speaker C: Thank you.
