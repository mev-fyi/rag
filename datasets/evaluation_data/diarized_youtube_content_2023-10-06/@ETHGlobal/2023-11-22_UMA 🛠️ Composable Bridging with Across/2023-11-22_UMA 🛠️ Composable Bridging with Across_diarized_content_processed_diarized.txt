00:00:07.210 - 00:01:05.970, Speaker A: My name is Paul. I am a contributor to the across protocol, and I'm here today to talk about composable bridging with across. So for those of you who don't know what across is, I'll just give you a little bit of an introduction and then kind of outline some of the use case for why is composable bridging useful? What does it actually do? I can give some instructions on how to do composable bridging. It's actually very simple, so we don't need to spend too much time there. We can also discuss some project ideas and then also just have some links and references to practicalities and resources that will be useful if you are building a project that is using across composable bridging. So what is across? If you don't know, it's extremely fast. We have cross chain transfers occurring usually within seconds or like worst case minutes of a deposit on an origin chain.
00:01:05.970 - 00:01:30.362, Speaker A: The fees are extremely low and there's a no slippage model, so there's no amms involved. We only work with the official tokens for each chain. So it's a bit different from some of the other bridges. We support the major chains and tokens. This is Ethereum, optimism, arbitram, polygon, Zksync and base. At the moment. There is of course scope for additional chains to be delivered in future.
00:01:30.362 - 00:02:11.282, Speaker A: And in terms of the tokens, it's also an emphasis on the major tokens. So this is Ethereum bitcoin or wrap bitcoin, USDC, DAI, USDT. And then there's also some governance tokens that are supported by across as well. One of the things that is really popular about across is that we actually have this decentralized relayer network. So when a user makes a deposit on an origin network, the relayer that makes the fill is actually permissionless. So any individual can actually operate a relayer and their bot will kind of start and will be scanning for new deposits. And then there's effectively a race to make a fill on a destination network.
00:02:11.282 - 00:02:55.042, Speaker A: And so relayers can, there can be custom implementations, we have those. And people apply different logic, different profitability constraints to their transfers in order to kind of optimize their profit, but also to deliver a good experience for the end user. We really, really try to be friendly to integrators. So predominantly this is in the form of aggregators, crosschain aggregators. So we have, for example, bungie exchange, jumper exchange. These are two kind of major examples of aggregators that if you've ever used them to make a transfer, they might actually have routed you via across. And we've actually found that in some cases people are routed via across so much that they actually come directly to us instead.
00:02:55.042 - 00:03:48.410, Speaker A: And they say, like, instead of going via an aggregator, we want to just integrate you directly, which is nice to see. And then when we have these interactions, we really try to support, give good support, make sure that our system is easy to integrate and that everything's working well, and give kind of good ongoing support. And the final thing is across has actually spun out of the UMA project, and across is like kind of a really good use case of how UMA's optimistic oracle can be used efficiently and effectively. And of course UMA is sponsoring this event. That's why I'm here for the workshop. So there is of course a $10,000 prize for the hackathon. So if we get into why composable bridging across is historically supported only bridging tokens.
00:03:48.410 - 00:04:34.820, Speaker A: So you can bridge a token from any of the supported chain to any of the supported chain. But of course, when someone's bridging tokens, the question is like, well, why are they doing that? They obviously have something that they want to do on the destination chain. Up until this point, it hasn't really been possible with across to kind of specify what you would like to occur. And if you think about it, like, the cross chain user experience when you have to do every step manually is actually not very good. And I would probably challenge anyone to actually with an address bridge funds and then interact with a contract on the other chain in probably like less than six steps. There's actually a lot of kind of manual steps that you need to take. If you're a user who doesn't know what to do, it's like this is a really hard learning curve to find out.
00:04:34.820 - 00:05:28.342, Speaker A: And then there's kind of all kinds of traps and gotchas. Like maybe you bridge an ESC 20 token like USDC, but maybe you don't have gas on the destination chain. So now you've got the value sitting there, but you actually can't do anything with it. And so you need to then figure out how am I going to get gas? Is there a faucet that I can go to? Do I need to do another bridge token like bridge transfer where I'm bridging in just the native gas token, and then I don't know if you like me, but I have multiple tabs open and there's all kind of dapps in the background, like fighting over who's got the RPC connection. It's not fantastic user experience and we think it can be a lot better. So what we have done with across is to now say when you're bridging a token, you can actually, at the time of deposit you can specify what do you want to do on the destination chain. And so this is a feature that other protocols can use.
00:05:28.342 - 00:06:10.066, Speaker A: They can actually integrate this feature to have contracts on maybe the destination chain that can receive the message that gets included with the token transfer and then to unpack it and do something further. So what we call this composable bridging. And the advantages are that basically the user doesn't need to do anything on the destination chain. Everything on the destination chain is handled by the across relayer. The user doesn't need to worry about gas, the user doesn't need to worry about token approvals. It basically is all facilitated by the relayer who is simply executing the message that was specified at the deposit time. So we can go into how.
00:06:10.066 - 00:06:33.930, Speaker A: And the how is, it's actually pretty simple. You can see up here on the display we have a deposit function here. This is how you make a deposit into a spoke pool. It's quite simple. You specify the recipient address, you specify the token that you are bridging on the origin chain. So this is an ERC 20 address, be USDC or weth or wrap bitcoin. You specify the destination chain id.
00:06:33.930 - 00:06:59.822, Speaker A: Where do you want the transfer to go? You specify a relayer fee percentage here, which is actually the fee that you pay to the relayer for completing this task. There's a quote timestamp which is specifying like what kind of rate you will get. You basically would set that to the current time. And then I've highlighted green here. We have this message. And the message is just arbitrary data. It doesn't mean anything to a cross.
00:06:59.822 - 00:07:53.450, Speaker A: It's just an array of data that gets passed in to the deposit. And then what happens is the relayer will supply this on the destination chain. So if we come down here to the destination chain, what happens is the depositor will have specified a contract as the recipient. So in order to use composable bridging and crosschain messaging with across, the recipient needs to be a contract. What happens is that that contract, which is the recipient, needs to implement this function called handle across message here. And that's like a callback. So this contract will kind of asynchronously receive, it'll be executed, it receives some information like what is the token that was received, how much was received? There's also completed in total because across actually supports at the moment, partial fills.
00:07:53.450 - 00:08:38.594, Speaker A: So you could actually have, the transfer could be completed by two different relayers in two fills. And this will tell you whether or not you have the complete amount or whether or not you've only received a partial fill. You also get to know on the recipient side, you get to know who the relayer is. So this is actually pretty interesting because this allows for gated permissioned transfers. So you could actually set up your own protocol and you could be handling your own fills all settled by across. Or you could, for instance, have a pool of relayers that you have relationships with. So maybe you have some kind of trust relationship with, then you can specify, I only want to allow my fills to be executed by these people who maybe I have some agreement with, or some kind of trust or relationship there.
00:08:38.594 - 00:09:34.100, Speaker A: Or maybe, for instance, you want to provide some additional incentive to the relayer to give you really good performance. Like you could offer some kind of bribes or incentives in some other governance token that says if any relayer fills this within some kind of time period, like within two minutes, they will get some of my governance token. And this gives a few different possibilities there. Of course, at the end we have the message here that's pulled out by the contract, and the contract needs to be able to unpack the message and do whatever it needs to do, and it needs to return successfully. If the contract reverts in this message, in this function, then the whole fill will cancel and it will not be completed. I will mention we have a tutorial on this on our developer docs site here. So we've basically got some different examples of how can you use messaging with across.
00:09:34.100 - 00:10:15.858, Speaker A: There's an example there. If you bridge weth, like you could have an instruction that says I want to actually unwrap that wealth into eth on the destination chain. There's another example of if you've bridged an ERC 20 in, perhaps you want to then take that to a Dex and swap it for something else. So there's like quite simple examples there. It's actually surprisingly little code in order to do this, and I just really want to make sure that people are aware that the docs are there. And there's good examples, like you can nearly copy paste it into your project if you are integrating this into your hackathon project. I'll just briefly talk about some different project ideas we have actually seen.
00:10:15.858 - 00:11:08.914, Speaker A: And across has some relationships with different projects at the moment who are kind of trialing different usages of composable bridging. And this includes like someone's actually built a cross chain auction. So from one chain you can be submitting tokens and bidding on an NFT auction on another chain. That seems like a pretty interesting use case. And in that case, when we talked to this project initially, they were using the official bridge to the destination chain, and they were incurring a penalty of like 30 minutes to bridge a message in. They were already bridging tokens via across. So they had a scenario where the tokens would arrive very quickly, within seconds or minutes of the initial deposit, but then they would have to wait for this message to arrive after like 2030 minutes to tell them what were those tokens for.
00:11:08.914 - 00:12:11.880, Speaker A: The advantage of using a cross composable bridging here is actually that the message and the tokens arrive together. Like by the time that the callback function is executing, you already have the tokens and you've received them in your contract. So you don't have any kind of synchronization to do about did one arrive before the other? Another example of what you could build with this is something we're calling it onboarding internally, but it's kind of like deposit automation. So say maybe you have some tokens on Ethereum and you want to bridge over to arbitram and you want to like as soon as your tokens arrive, you want to go further and deposit them into a lending protocol or something like that. What you can do, if you are that lending protocol or if you're some kind of service that's sitting in between, what you can do is you can integrate across composable bridging, and you can allow people to make their deposit directly from Ethereum. So it saves them a lot of hassle. They don't have to wait for first the tokens to arrive, and then they can go further and do something else.
00:12:11.880 - 00:12:48.946, Speaker A: They just bridge in and the deposit happens automatically. And so there's different variations on this you can do, like maybe you're just providing liquidity to a protocol. It could be, maybe you are actually borrowing, so maybe you're submitting a deposit it to actually borrow back against it. That could also be automated by this. We've also kind of speculated that there could be interacting with prediction markets. Obviously UMA has some quite large prediction market integrations, polymarket being the main one. And four is also coming along as well.
00:12:48.946 - 00:13:24.910, Speaker A: So these are on polygon. But what happens if you want to kind of buy a position in a prediction market from arbitram or Ethereum or Zksync. It's like you don't need to bridge first and then buy. You can actually bridge and then have the purchase executed as soon as the tokens arrive. And then there's again a bunch of different kind of variations on this. For instance, what we've kind of called here is like zaps. I think everyone's familiar with how you can zap into some kind of contract or zap into an asset.
00:13:24.910 - 00:13:57.474, Speaker A: There's a very big opportunity for saying offering kind of bespoke activity. Like if you want to deposit into some kind of two sided amm, then you can automate bridging the funds across to the destination chain, swap the right amount and make the deposit happen. Things like that. Just some practicalities as well. So we have a testnet up and running like this is actually supported in production. This can be used today. We also have testnets.
00:13:57.474 - 00:14:28.078, Speaker A: So all of the girly testnets, this is ethereum, arbitrum, optimism, base, zksync, girly testnets are supported. We also support Polygon Mumbai. So this is our complete setup for testnets. We do prefer if you bridge ether weth, but we can actually support some other tokens. So if you have a specific need for your project, then please just get in touch with us. You can find us in the big hole there. Another thing to mention is that the fees, so the fees that the depositor pays is a percentage.
00:14:28.078 - 00:15:01.670, Speaker A: So if you're depositing USDC, you'll pay a percentage of your USDC as a fee to the relayer and so on. Testnets, you can set this to 0.1%, you can copy paste this number here. That's fine. We also have on production, we have an API endpoint that you can query. So you collect all of your different deposit attributes and then you provide them to our API and it will respond with the fee that you just copy paste directly in. I should also mention we also have some scripts and tooling in one of our repositories.
00:15:01.670 - 00:15:43.370, Speaker A: So all of our code is public, you can find it on GitHub. And basically we have some scripts that help you to make deposits. So you can add the command line, you can type a single command and you can specify your message on the command line. So this allows you to test from your command line without having to kind of build a lot of other things. As long as you've got a message that you want to send to a recipient contract, you can just use this script to do it. And then we also have another script that will fetch like if you provided the transaction hash, it will fetch the right information and decode it for you. So then you can see like did I submit it correctly or did something go wrong? Also mentioned support.
00:15:43.370 - 00:16:06.478, Speaker A: This is really really important. We have the top part here, this notion page, tinyurl.com across istanbul. This is the place. This is like the headquarters for our hackathon here. We will make this all our references are from here. We're referring off to all of the necessary contract addresses, how to get into our discord, how to get in touch with us basically.
00:16:06.478 - 00:16:31.720, Speaker A: And we will update that running through the hackathon. So someone asks a question, has a use case that we have an address there. We will update that so that people can can see that as well. GitHub is also very important. The relayer v two repository and the contracts v two repositories are the main ones and of course our docs here as well. But it's all referenced from the notion page. So if you remember one thing, that's the one to pick.
00:16:31.720 - 00:16:36.770, Speaker A: And that was my presentation on composable bridging.
