00:00:00.170 - 00:01:49.382, Speaker A: Up next, last talk of the entire hackathon. Liam's going to talk about counterfactual state channels, presumably. Oh, I'm okay, I'm going to try and go through. I do have might need to charge in a bit, but I'll try and go through anyway. All right, so I'm going to talk about counterfactual, which is an open source initiative basically to make secure layer two applications, off chain applications, very easy to build. If you have tried to build something in this space that has to do with layer two, you might have realized it's very complicated. There's a lot of research, it's confusing.
00:01:49.382 - 00:02:36.750, Speaker A: Our goal is pretty simple is just abstract away all of the complexity to do with layer two applications. So you can write a layer two app that's as simple is writing simple contract in Ethereum that has some callers to it. So who am I? My name is Liam Horn. I'm the co founder of a company called L Four. We're effectively a kind of a software consultancy, but we do a lot of things in this space to try and help grow Ethereum and more generally helping growing decentralized applications that are usable as soon as possible. So what am I going to do here? I'm going to give a quick overview of what generalized a channels are because it's kind of this fancy buzword that people don't always have a good understanding of what counterfactual is, give a demo of an environment that we've built that shows the core functionality and then explain how the demo works. So, quick background on state channels.
00:02:36.750 - 00:03:29.040, Speaker A: If you think about the Lightning network, which you probably have familiarity with, state channels are effectively the generalization of that enlightening. You can effectively send money to somebody else over a network by initially locking it into that network. And then what you essentially do is you sign updates back and forth with other people in the network such that those payments can occur off the main chain and simply between the participants of that network. In state channels you can do the same general thing, except instead of sending money and just doing a send transaction, you actually can allocate some money into an application which can be adjudicated by smart contract code. So it's the same general idea. If you want to learn about all the details of this, which I'm not going to go into all the full complexities of it. There's a paper L Ford Adventures last Eight Channels PDF, which you can go to if you want to just go through all the full details, which is very useful if you're interested in more academic perspective of it.
00:03:29.040 - 00:04:12.554, Speaker A: So I think it's a pretty good description of what's going to come up of what a generalized A channel is in comparison to a payment channel. So you're probably familiar with a payment channel. The idea is that you have a blockchain and what you want to do is you want to lock up some amount of money between some participants, let's say two, for the sake of this example, and you want to keep track of how much they've locked up. So Alice might have locked up five, bob might have locked up five. And as time goes on, what you want to do is you want to have Alice and Bob effectively between themselves over any messaging protocol. It's not blockchain related at all, just Facebook Messenger works, sign updates, balance A, balance B at version zero, at version one, at version two. And this is effectively them sending money to each other.
00:04:12.554 - 00:04:53.658, Speaker A: And then whenever they're done and they no longer want to be in this quick transitory relationship where they can send money to each other, you simply go back to the blockchain, give the last signed update, and the money goes back. So that's a payment channel. You might have also seen state channels being described as application specific state channels. So if you're smiling, there's a company called Funfair which builds they call it fake channels. But basically what they do is they have casino games where you lock up some money, you the person at the casino and the casino as well, and you play a game roulette or 21 or whatever casino games you might want to play. And it kind of looks like this. It's the same idea.
00:04:53.658 - 00:05:57.338, Speaker A: You deposit money into the contract, but the contract has this extra application logic. So off chain, instead of just signing a Bell B Bell, which is one type of data structure, you sign some arbitrary data structure, right? If it's a roulette game, you're signing a little bit of randomness on both sides to guarantee that you can produce an output as to where the ball lands on the wheel and then how the ball landing in the wheel leads to an outcome. But basically, when you want to get the money back on chain, the contract has the logic to resolve that and so you can get the money back. So that's kind of an application specific state channel. The really cool stuff, though, is with generalized state channels and to think about this, it's the same basic setup. Alice puts money in, Bob puts money in, and at this point, everything's the same. But as time goes on, what you want to start to do is try to create brand new applications underneath the state channel, not necessarily pertaining to just one application that's been defined in the contract, but an application which you define while you're off chain itself.
00:05:57.338 - 00:06:44.314, Speaker A: So the idea is, it's intuitive if you think of it in English. Alice and Bob share some set of money between themselves and they want to reuse that pool of money between themselves for arbitrary applications. So they have one application that they could do it for, or they could do it with a second application, and they want to do it with the exact same money that they've allocated, right? You can think of this intuitively. If you're out with your friends one night and maybe you go and get food together, maybe you go and grab an Uber together, you've kind of pulled your money for that evening because you just want to move the evening along. And so you want to be able to use multiple applications while you're together. You don't want to necessarily commit everyone's money for one app and then commit to another app with an entirely new kind of entrance transaction. You want to just pull your money and reuse it for different applications, if that makes sense.
00:06:44.314 - 00:07:09.650, Speaker A: That's a generalized state channel. And then if there's ever a case when you want to get the money back on chain, you can just put the latest state back on chain and get your money out. There's some optimizations to specifically how you do that, but this is the general idea. By the way, as I'm going through this. Please just feel free to throw questions out if there's anything you want to go in more detail on. But this is the general idea. So what is counterfactual? The first thing that's important to note is that we're not a business.
00:07:09.650 - 00:07:50.594, Speaker A: There's no counterfactual inc. There's no token. There's nothing to do with that stuff. We're literally just a GitHub repo and a handful of passionate people that want to build this technology into a reusable framework that others like yourselves can use at hackathons like this one to build applications much faster. The mission, as I've stated earlier, is effectively to change this weird dynamic of everything being way too over the top, complicated and queer, cryptographic primitives and timeouts and challenge periods that you have to think about and just make. It so you can write your application, get it to users, and figure out how to make it more usable and more interesting for their lives. So now we get to the cool stuff, what specifically it is that we've built.
00:07:50.594 - 00:08:19.878, Speaker A: So I say three core pieces, but it's more like three core layers and four core pieces of technology or specifications that we've done. So I have a cool diagram here that I'll walk through, and I'm going to go through all the details here, so make sure everyone's on the same page. We've done these three layers. First of all, similar to how web Three JS and more generally client side APIs allow you to interact with the blockchain. Say, for example, the JSON. RPC. That MetaMask exposes.
00:08:19.878 - 00:09:03.286, Speaker A: We're building an application layer library that lets you interact with layer two, lets you interact with your funds that you've deposited with your peers, the same way that web Three JS lets you interact with the funds that you have in the blockchain. So we're building an application library for developers to build apps in layer two. The second is because it's complicated how those applications interact, right? Because the idea is you lock money up for a fixed group of people and then you use multiple applications. That's a complicated scenario. We needed to devise a protocol that you and your peers speak to each other with that allows you to guarantee that you're doing things like installing a new app in a safe way. So we've designed that protocol. If you want to see that part, it's at specs counterfactual.com,
00:09:03.286 - 00:09:48.438, Speaker A: and that gives you some security guarantees about these types of things that you can do with it. Third, we've designed this client node software. So what that just means is we have software running. It's a TypeScript library at the moment, but we have software running that implements those protocols, right? The protocols are just the specification of how you speak to your peers. Software we've also written that can run in browsers or in other environments, lets you communicate to those peers using software. And finally, because state channels are a layer two protocol, and for all layer two protocols, if you want it to be trustless, you need to have a dispute resolution layer, meaning that if I sign a message to send to Bob and Bob doesn't reply to me, I need to be able to get my money out. We've also implemented an entire state resolution layer on the ethereum blockchain that lets you get your money out.
00:09:48.438 - 00:10:12.078, Speaker A: And effectively, the protocols define what you need to be signing back and forth so that you can use that layer. Does that make sense? Does anyone have any questions at this point? All right, cool. Sorry. We're good. Cool demo. So I think I put a YouTube video embedded. So I'm going to show a very quick demo if I can go full screen here.
00:10:12.078 - 00:11:03.898, Speaker A: So I'm going to show a very quick demo and then I'm going to explain the demo afterwards. But this is an example of the type of experience you can have using the technology that we've built and how it will extend in the future, which you can get the idea of as I go through, I'll give a bit of context here before I jump into the entire thing. The idea here is that we have built a website. So this is itself kind of a DAP. It looks a little bit like what a wallet would look like. It looks a little bit like what a wallet would look like, where you can go to this website, you can create an account. What it's going to do is it's going to ask you to register with the website, deposit some of your funds effectively in that graph I showed you earlier, depositing money into that contract off chain where eventually off of which you're going to branch new applications, and then you're going to see that you're going to be able to run any type of application within this context.
00:11:03.898 - 00:11:37.658, Speaker A: See, the idea is put money in, run any number of applications, and you're going to see what that looks like. So this is this website. The first thing you do is you create an account. So this is just essentially authenticating with a server. Second thing you do is after you create your account, the server is going to get a message saying, okay, this is a new user that wants to authenticate with my service here and I'm going to create a state channel with them. Okay? So this service in the background is going to create a State channel with you. So it's not necessarily you and your buddy, it's you and this service.
00:11:37.658 - 00:12:09.746, Speaker A: And you're going to see why that's important in a second. And then it says, okay, well, how much do you want to deposit? And I put in how much I want to deposit. And then when the state channel is created, I will deposit, and then the service will also deposit an equal amount and I'll get to why that's important. So I put in how much I want to deposit. And then at the moment, this is Demos from Robson. So there's a bunch of confirmations that need to happen and it takes time, but eventually, once the state channel has been created, which is a contract on the chain, it'll prompt you and say, hey, the State channel is created, it's now your turn to deposit. So put in some money.
00:12:09.746 - 00:12:36.154, Speaker A: In the case of this demo, we're going to put in some ETH. It could be anything you want. It could be a token, it could be anything at all, any state at all in Ethereum. But let's say it's ETH right now. So it sends me a MetaMask. It asks me to send a Metamass transaction. I go to there, I click it, I send in the money, and then we wait a bit longer because now what's happening is I've deposited my money into the State Channel and then the service is now depositing their money.
00:12:36.154 - 00:13:12.934, Speaker A: So again, this takes a little bit of time because you have to do it synchronously. I go and then the service goes. So just bear with the block times here, which you can kind of see, takes a little while, but then once you've finished, you've deposited, they've deposited everything's good. You're now in this situation where the UI shows you a bunch of applications you can open. And so you saw there just a second ago that there's tic TAC toe and there was a dice rolling game. These are two entirely different applications, two entirely different sets of application code that it offers to you to play. And interestingly, what it's going to say is pick a bet amount.
00:13:12.934 - 00:14:04.934, Speaker A: So this is how much do you want to bet on this game and what it's going to do. You're going to click play, it's going to wait a couple of seconds and all of a sudden, boom, you're in a game. And what it's done is because this service is offering it to many different people, it's connected you with another person connected to the service for a real time game of TicTacToe, 100% collateralized by you and the counterparty, essentially and trustless. So you can just play it. It's not instant yet, the UI could make it instant if you want to do that, but effectively you're playing a game with no transactions against another user, every update of which is 100% trustless backed by the blockchain. And it's all fun. You won some ETH and you've actually gone ahead and just essentially accepted a payment of 0.1
00:14:04.934 - 00:14:48.200, Speaker A: ETH for having won Tic TAC toe game, which the interesting part is it'd be literally arbitrary EVM code and I should have recorded this demo with a few more games. So you can get the idea. But the idea here is this is a service that lets you put money into layer two and then with anyone else that's put their money into layer two, play any arbitrary EVM compatible game, 100% trustlessly, which is pretty cool. And then I think in this video, I do it. And then essentially what you can do after that is go ahead and get your money out and bring it back to the main chain, the 0.1 of which you just got out of thin air, essentially, in layer two, and use that for some other thing like CryptoKitties or something like that. So yeah, that's the demo.
00:14:48.200 - 00:15:39.750, Speaker A: Yep, that's right. So I have a slide, we'll show that briefly, but it's an important thing to note that there's no fancy go to chain with the state, wait a time appeared, all that stuff, if everyone's cooperative. If they're not cooperative, that's a different discussion and we have the protocol and the resolution layer to deal with that. But if everyone is cooperative, which they're incentivized to be, this is the experience. It's just instant and all you've done is you've deposited, you've withdrawn. Layer two is simply a deposit, withdraw API. If everyone's cooperative, the incentive is just to keep moving things along, probably because you're going to want to reuse that same channel with them again in the future.
00:15:39.750 - 00:16:23.290, Speaker A: So great. How do we go to the next slide? Yeah, that's right. And in this specific case, the service is effectively acting as a hub and you'll see in a second how it was able to do that. But basically it wants your business, it wants you to keep doing that. So let's dive into what we just saw. And again, please feel free to ask questions because I have found over the past year, working on this stuff, it always skips people's minds, like the subtle details. So please feel free to ask questions.
00:16:23.290 - 00:16:45.388, Speaker A: Yeah, I have a code snippet. I think it's on the slides. You'll see that in a second. So I want to dive into what we just saw. So I'll make it pretty like Eli five. You saw this screen, basically on this screen there was a handful of things going on. The first thing is you saw it was separated.
00:16:45.388 - 00:17:18.380, Speaker A: There was an app adaptively, a layer two app, a lap, I guess it was a Latoo app. And then you have this other thing on the top, this bar that says how much money you have in the environment within which that app is contained. Right? And these are in the implementation of this. And you'll be able to see this if you ever look at the source code, which is all open source. These are two very distinct environments. This demo site is acting like a state channel wallet. It's actually containing how much money you have available to use for all the other state channel based applications.
00:17:18.380 - 00:17:44.564, Speaker A: The state channel applications are implemented inside an Iframe. This is very similar to how MetaMask kind of is in the outside container of your Chrome browser. And the Chrome browser, the web page itself inside the Chrome browser is like a DAP communicating to your MetaMask wallet. It's the same thing. This is a layer two app communicating to your State Channel wallet. It's the exact same idea. The only thing is, we didn't write a Chrome extension because we want you to be able to go to the website and just play around with it.
00:17:44.564 - 00:18:35.636, Speaker A: But that's really the only reason. And so it implements this API that I was alluding to earlier that lets the DAP communicate to this other environment using basically the methods on the client node software that expose intuitive APIs for what you can do with this layer two environment. You can install an app when it's installed, meaning you've proposed it, you've signed it, your counterparty signed it, which is the general state channel mechanic. It gives you an event, hey, this app's installed and now render. So the app has a very obviously implementable lifecycle system to be able to offer you the API needs to build. You may have noticed also that at one point, MetaMask popped up because, like I said a second ago, you need to deposit money in. And if you want to withdraw money out, you have to communicate to some wallet to send the transactions to the chain to get your money out.
00:18:35.636 - 00:19:08.140, Speaker A: Now, this is basically how we've implemented this specific demo. And I think there's two slides in between this. We've actually done this work already with MetaMask to combine those two layers at the top. So what you can imagine is that instead of MetaMask being this separate thing that's like a layer one thing, and then our Iframe demo website being a layer two thing, why don't we just make this one thing? And so we've already begun working on this with MetaMask. It's basically what you'd imagine, right? MetaMask itself is already a wallet. It already has a mnemonic inside of it. It already has a private key inside of it.
00:19:08.140 - 00:19:37.140, Speaker A: Why don't we just build it inside MetaMask? And so you can imagine well, not even imagine. You can see this is what the demo internally that we're working on looks like, right? Now you just open up MetaMask. They have a web page UI now, and you can do all the exact same stuff I just showed you. You don't need to go to our website initially. It'll use the exact same mnemonic. And so you have kind of layer two features within your layer one wallet, which a lot of cool stuff is possible with that. And I just wanted to hammer home one point a second ago about this API.
00:19:37.140 - 00:20:07.490, Speaker A: This is literally what the code looks like. So that tic TAC toe thing you just saw is a react app. It's literally we get cloned create react app. And we ran the script, and it's very simple. When you click X in the corner, it calls this take action method, what's the X? What's the o? And effectively gets to this method that we've exposed using our API that lets you take an action. You say, hey, for this state channel app, tic TAC toe app, I want to take an action. There's a little bit of extra information here that's not as intuitive, but this is implemented by the developer, not by us.
00:20:07.490 - 00:20:31.240, Speaker A: We built this step, but not by us as the counterfetchal framework. You place x you place y you say whether or not you're claiming a victory or not. This API could be simpler. You could just say X and y. The coordinates on the grid of the Tic tattoo board and the API will it's an asynchronous request. If everything goes as plans, it'll return back and say, this is the new state of the app, and then you render it. So it's extremely intuitive.
00:20:31.240 - 00:21:05.572, Speaker A: So additionally, you might be wondering, you're doing all this stuff, you're signing messages back and forth to your counterparty. You have a representation of the app that's in layer two and the state channel itself. What's going on there right now? This specific demo is just putting all that in local storage. As you're building more production level environments, you're going to want to store this in better environments. But for now, if you want to go to this web page later, it's literally in local storage. All the commitments that are signed between you and your counterparties are stored in local storage. The state that represents your channel is stored here, and you can inspect it.
00:21:05.572 - 00:21:38.204, Speaker A: But the main point I want to put home is not that we use window local storage, is that you locally keep track of all of your state presently in this implementation. And this is kind of what it looks like. I'm not going to look over every single field here because there's a lot of stuff, but the interesting stuff is that this is a completely abstract data structure representing arbitrary applications on ethereum that are layer two compatible. So in this case, this is not TicTacToe. I should have put TicTacToe in this slide. This is a payment channel between two people. The data structure is literally using Abi encoder v two.
00:21:38.204 - 00:21:47.712, Speaker A: It's a struct. Alice address. Bob address. Alice balance. Bob balance. And what you do is you keep track of the state of that. You can see down there currently is that address.
00:21:47.712 - 00:22:21.116, Speaker A: That address, alice has zero. Bob has whatever that represents. And every time you update it, this data structure updates. And you can imagine that our API simply wraps this and exposes simple methods that you can call. So when you call take action, you give it a JSON object. It'll encode it properly, generate the thing that you need to sign, send it to your counterparty, get it back, put that in your database, the window, local storage, and then give you back a response to the API method with the new JSON, which is this is now what the board looks like. Anyway, it's all there.
00:22:21.116 - 00:22:57.396, Speaker A: So you can inspect all of this. So this is running in a laptop, as you can see. And there's another laptop. I played against somebody else and obviously there was some messaging protocol that was going on between them. But the thing that I haven't explained yet is that there was no on chain channel. When I initially made that deposit into the website, I clicked deposit. I wasn't sending that to this guy, the person I played against, I was sending it to what we call in state channels, a hub, somebody that's offering this service for me to be able to play other people also connected to the hub in the Lightning network.
00:22:57.396 - 00:23:24.796, Speaker A: You're familiar with this concept, you can route payments. It's the same thing here. You can route the use of capital for applications if there's an intermediary willing to collateralize that application. In this case, us, the people running that website are collateralizing that application. And I'll show you kind of generally what that looks like. This is me. Neema is my coworker, who actually just 2 hours ago gave this a similar talk to this at the MIT Bitcoin expo.
00:23:24.796 - 00:24:12.348, Speaker A: We were going to play each other in real time, but the timing was off and so basically I needed to communicate with him. There's no State channel, but there's a hub that we're running. And so we both created an account with the hub. We clicked register and then what we did is we used a technique called meta channels, which is the higher level abstract term for this other thing called virtual channels. The State channel research community is working on solid terminology, but generally speaking, we created this is not actually a contract on chain between me and NEMA, but we have all the exact same APIs as if there were a contract on chain between me and NEMA because this hub collateralized the payment. Again, our paper describes this in good detail as the P-E-R-U-N peru paper, which also describes it in great detail. And it's a really phenomenal concept that you can use in state channels.
00:24:12.348 - 00:24:38.360, Speaker A: This is kind of what we did there. The cool part from the engineering point of view is that that Hub, the service that we use to register an account with, there's almost no code that's unique to that server, except for when I deposit automatically. Also deposit like the specialized logic, right? But otherwise it's literally the exact same code. It's running the exact same code. It's a state channel node. We have a state channel node running in our browser. Neema had a state channel node running in his browser.
00:24:38.360 - 00:25:23.350, Speaker A: The only difference was that it stored its data in some heroku POSTGRESDB or something like that. However, otherwise it's just the exact same code running the exact same protocol that is using the exact same CF JS API, just locally. So what you saw is initially I proposed an install counterparty would get a request. I think in the one I showed you, it auto accepted because I sent out the request and you didn't see that this particular UI. And then after it accepted it, we went to the Hub and said, hey Hub, I want to install this application. Is that okay? We use the install virtual app protocol, which is essentially, remember, it's a specific exchange of messages to ensure that this is secure, which you can inspect if you want on our website. And it then allows you to collateralize this application.
00:25:23.350 - 00:25:46.704, Speaker A: That's really it. That's kind of the cool thing about it. All of this is possible with all of these applications that you can define in any arbitrary way. And I didn't show you the code snippet, but I can go to that in a second if you want to ask again. And yeah, this is entirely built today live on Robston. Cool. Yeah.
00:25:46.704 - 00:26:49.380, Speaker A: Any questions? And while if there are any, I'll pull up that code Snippet that you can look at. So this is more of a speculation question. I think that probably web based state channel games aren't going to be the big thing that takes over the world. I think there are a lot of interesting things that you can do between bots. So one idea that we have right now in the state channel community is, what if you wrote a bot to play some sufficiently complicated game, like not Go, because now you does Alpha Go? But maybe that's still interesting. Have a stage channel game around it, and then people have to compete to write bots and have them compete for money. So you're not just playing against another human, but you have to write the most optimum bot and they play against each other in real time and win money.
00:26:49.380 - 00:27:19.788, Speaker A: That would create an incentive for people to build the best bots besides just Google paying a lot of money to people to build bots that are cool. That'd be kind of interesting. One idea we had earlier when I was talking to Peter is that at OpenAI they have this really cool thing where they have. This evolutionary agent algorithm to figure out how you can basically have you just deploy agents into environments and they interact with each other and then some become dominant. Maybe you could inject some kind of payment system into that and that would use this and you could hook it up with real money like cryptocurrencies. I don't know. I think honestly, in this space no one really knows what the hell is going to happen.
00:27:19.788 - 00:27:47.816, Speaker A: So let's build really interesting stuff that it's just interesting and it's interesting because we're here and we're playing around with it and tinkering with it and as long as it's interesting to us, we are currently kind of the users. So at the presently the people in this building are for better or worse, we're kind of the users of this stuff. So what do we want to see? Let's keep building that and get other people interested and just see what happens that way. But I don't know. I have no idea where this industry is going. I just think it's kind of interesting. I wanted to address your question though.
00:27:47.816 - 00:28:31.296, Speaker A: So this is the interface for an application. So Tic TAC toe was the other file. It's kind of in the top there. I could show you all that code but it's kind of just basically implementing these four functions. So most importantly, is it's a state machine. So given some state of the state machine which in tic TAC toe is like the board where the pieces are, whose turn it is, stuff like that, and an action which could be something like apply X or rather place x or place o or place x and declare victory and place x and declare draw whatever action types you want to use for that state machine that you implement that. In this function there's a turntaker function which says that for some given state whose turn is it? Is it X's turn or is it O's turn? And there's also an is state terminal.
00:28:31.296 - 00:29:17.738, Speaker A: So if the game is won or it's a draw that's the state of the state machine, then it's terminal, it's done and that helps you instantly exit. And finally, for any given state of the state machine, how would the funds get distributed between each of the participants? So you can imagine if X wins, X should get the money. If O wins, O should get the money. If it's a draw, divide the money in half. Which is fairly intuitive. Yeah. So we have a bounty up if anyone wants to write a client side EVM JS interpreter that's built into Ethers.
00:29:17.738 - 00:29:44.426, Speaker A: Richard Moore from Ethers might beat you to it, but we really want that because you're right. What happens when I click X? Like literally when I click X in my browser? What happens is it says, okay, here's the contract for tic TAC toe. Do an ETH call to the contract with the current state of the board and the place X function. This function return back the result because it's a pure function. There's no gas cost. This is I'm just running code. It happens to be the case.
00:29:44.426 - 00:30:15.022, Speaker A: I'm running it on some other node and then it gives me back the new state of the board and I render it. That sucks a little bit because then I have to call some other node just to run code. But the only reason I do that is because there's not a good open source JS based EVM interpreter as of today. Maybe in like a month there will be there are some ones that are out there, but the API interface is not that great. That's literally it. But in the case of a dispute, then yes, this contract's on chain and the contract that adjudicates the dispute would call into this contract. So it needs to be EVM compatible.
00:30:15.022 - 00:31:22.640, Speaker A: Yeah, well, I mean, there's a handful of handful of things there. So you can always get the money out no matter what. If the person you're requesting to say, hey, can we just get the money out in a safe, smooth way says no, you can still get it out. Basically what you do is you put latest data on chain, you wait a timeout and you get the money out because of this thing called the speaker listener fault equivalence problem, which is that I can't tell if I blame you to the chain for not responding. The chain doesn't know whether it's me just griefing you or whether you're legitimately not responding. We can't calculate out that you should owe me some money because you're not responding. Unfortunately, the best we can do is pre agree that in a scenario like that we would split the fees.
00:31:22.640 - 00:31:54.920, Speaker A: Then in that scenario you would be negatively incentivized by a little bit for doing that because you would lose money versus just not losing money. You can guarantee you're going to lose money because that's exactly how the protocol is written. But maybe you want to do that because you don't like me. But if you don't like me, then I wouldn't want to be in a channel with you anyway. And this is the unfortunate edge case of state challenge. Is it's not perfect? There's always room for some external incentive to lead you to want to just grief me. But you can grief me at most the amount that you would also have to pay yourself, which is at the very least it's a negative incentive.
00:31:54.920 - 00:32:14.220, Speaker A: You asked about reputation systems as well. So we're building this stuff. We're not necessarily building every possible state channel related thing. We're just building this core primitive. The API, the protocol, the state resolution layer and the actual software that implements it. And all those things you described can be built on top. It can literally be an app for reputation.
00:32:14.220 - 00:32:55.200, Speaker A: That can be a default app that you add as a plugin for all nodes. If you want to do it that way. There's all kinds of stuff that can be built on top pretty easily. It doesn't necessarily need to be built into the protocol. Yeah. Theoretically, if someone had something of value that you pre agreed to, that in some circumstances like that you would distribute, then sure, but you still wouldn't be able to prove whether you're lying, whether you're griefing me or whether I'm griefing you. And so at best, you could just divide up the reputation loss in half, which is a bit of a griefing vector anyway.
00:32:55.200 - 00:33:57.224, Speaker A: Let me just so basically what you can do is you can play with any number of other users for which there is collateral in your channel to play with in parallel, where each of the channels themselves are using different private keys. And the money that you could lose if you lose those private keys are themselves capped at the amount that you've allocated to the app. So it's the exact same experience which you might have if you have different accounts on MetaMask, each of which using different systems. So, yeah, it's 100% parallelizable. Yeah. So the protocols that we've devised require that you don't double spend effectively. Right.
00:33:57.224 - 00:34:38.942, Speaker A: So if I'm with a group of people here and I want to play six different applications, I can't say to all of them, we're going to play these six apps. Because the protocol that's implemented that I'm running and that you're running, simply, there's no way to get into that state. It has to be you accept and then my state updates it's a new one in the next five, one after the other. Except, however, when you've done the installation of the applications updating, the state between each of those six people can happen in parallel. Cool. All right, thanks so much, guys. It is dinner happening outside.
00:34:38.942 - 00:34:43.000, Speaker A: Right? All right. Well, if you walk around just a couple of meters, you'll get free food.
