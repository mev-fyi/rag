00:00:09.060 - 00:00:30.490, Speaker A: You. All right. Hey, everybody. My name is Nick. I'm a developer from Xmtp, and today I'm going to be showing you all how to build your bot army with Xmtp. So first, let's back up. What is Xmtp? It is the secure messaging network for Web Three.
00:00:30.490 - 00:01:10.650, Speaker A: And so what problems is MTP designed to solve in the Web Three world? There are some problems that anyone who's built a DAP has probably experienced. It's hard to reach your users if all you have is a zero X address. If you're a creator in Web Three, you can't interact with your audience. Maybe you sold 10,000 NFTs, but how do you actually talk to them? How do you get feedback from them? And users can't reach each other. We see decentralized marketplaces, but there's no chat button. There's no way to communicate between different participants in this on chain economy. Xmdv is also designed to solve some of web two's biggest problems.
00:01:10.650 - 00:01:40.192, Speaker A: In Web two messaging is siloed. Inside each app, I can't send a WhatsApp message to Snapchat or a Twitter message to Facebook. That's because you don't own your messages, the apps do. And they want to control them very tightly. So Xmtp was created with Composability and Interoperability in mind, as you can see here. These are three different apps on Xmtp, and you can have one inbox shared between them. You can send a message from coinbase wallet to Lenster.
00:01:40.192 - 00:02:28.270, Speaker A: You can use Converse to see the exact same inbox as your Coinbase Wallet. And that's a really powerful unlock for developers. It means anyone getting started can have access to the inbox of their user, even if they've been using Coinbase Wallet for the last year. If you have a better app, it's really easy for people to switch over to yours. So if you want to say hi, you can scan one of these two QR codes, one's for Coinbase Wallet and one is for an app called Converse. And just shoot me a message and I can pull it up on the screen here's. Hold on, let me go back.
00:02:28.270 - 00:03:21.372, Speaker A: It all right. Somebody's got to send me a message. There we go. So this is our example app. Xmtp is not in the app business, but we have a nice little web example at Xmtp Chat, just so debs have something to play. So I want to show you a few of the apps built on top of Xmtp. This is probably the biggest bot army on the network right now.
00:03:21.372 - 00:04:08.914, Speaker A: Coinbase launched on chain Summer in August and built a massive list of users on the Xmtp network. They were getting drops every day for new NFTs to Mint, and you could actually mint an NFT in like, two taps from getting a message. So it became really popular. Orb is one of the most popular apps in the Lens ecosystem. All Lens apps use Xmtp as the default messaging layer. And so if you have Orb, you have Xmdp on your phone, even if you don't know it. At this event, we're launching a new bot that you can actually order toothpaste, deodorant, Red Bull anywhere in this venue.
00:04:08.914 - 00:04:36.110, Speaker A: On Xmtp. You can come by our booth, scan the QR code, and then order anything day or night and we will come deliver to you. This is powered by ENS and an app called Chainjet that built the bot framework for it. Very cool, highly recommend you try. And pretty much everything on the menu is $0. And biggest launch of this summer. We launched Messaging Inside Coinbase Wallet.
00:04:36.110 - 00:05:18.682, Speaker A: So anyone who has access to Coinbase Wallet can actually have an inbox and send messages inside Coinbase Wallet. Converse is an app based out of France. They have a really cool feature where they can do matchmaking based on your on chain interactions. So they'll look at your Farcaster or your Lens Social Graph and tell you who you should be chatting with. Very cool, highly recommend you try it out. And there's actually hundreds more apps built on top of Xmtp, including a whole lot that came out of hackathons just like this one. The reason we have so many apps is because this is designed to be a simple protocol for developers to pick up, send and receive messages.
00:05:18.682 - 00:06:02.530, Speaker A: You can see a bit of code here. This is really all you need to do a full round trip on the Xmtp network, create a random wallet, create a client, start a new conversation with some address, read the messages, send a message, and you can listen on a stream of all messages. And that's kind of all you need to build any sort of a messaging app. But what we found is that when you're building a bot, you have more demanding needs. And so we wanted to build a framework to allow any developer to build a really high quality bot. Bots are an essential part of any sort of messaging ecosystem. DApps use them to keep in touch with users.
00:06:02.530 - 00:06:49.482, Speaker A: They can connect from your wallet to all kinds of services like Chat, GPT and allow you to build really complex workflows without smart contracts or needing a lot of complicated on chain code. You can just spin up a bot, write JavaScript and have a very sophisticated application. And so that's what we're going to do today. Yeah, this botkit Pro was released last week, but I think you're the first people to ever look at it since we kind of soft launched it. But it's designed to just make building a high quality bot dead simple and follows all the best practices that we've been educating developers on for building a good bot. So I have a replet. If anyone has their laptop and wants to follow along at home, you certainly can.
00:06:49.482 - 00:08:10.580, Speaker A: And then I'm going to run you through what it looks like to build this bot. I'll give everyone a second to take down the address, then I'll pull up the code. All right, so this is the simplest bot you can build with Xmtp. This is all you need as a handler for the bot. It's just going to reply GM anytime a message comes in. We have this run function that lets you pass in that little bot here and connect to a database to store the messages and allow you to resume. If your bot gets interrupted, it can go back and fill in missing messages, which is a common pain point for people who are trying to run actual bots in production.
00:08:10.580 - 00:08:49.520, Speaker A: You don't want to miss anything, gives people a bad user experience. So we built this to smartly. Just pick up where it left off, fill in any missing messages, and send replies. So we can actually run this bot in the terminal right here. All right. And this printed a QR code of how to message this bot. If you want the very exciting experience of getting a GM back from this code, you can scan the QR code right now, shoot it a message in converse, and hopefully this will work.
00:08:49.520 - 00:09:57.294, Speaker A: Oh, I see messages coming in. So sending a GM, that's good and fun, but a lot of people want to build much more sophisticated things inside of their bots, and so we're going to run through a more powerful example using some of the advanced features of Xmtp. Xmtp has a notion of content types, and so in addition to text messages, you can also send images, videos, you can send reactions and replies. So we're going to use the remote attachment codec, which lets you upload media and a number of Xmtp apps already have built in support for the remote attachments, and we're going to use that to do a GIF search bot. And so let's make sure this thing runs. So let me show you what the code for our GIF search looks like. This is the bot handler.
00:09:57.294 - 00:10:33.914, Speaker A: So this is all the code that will run every time a message comes in, and so it comes with the Xmtp message that was delivered. Message content property is going to be the text. So someone's going to ask for know Office GIF, maybe. So search query is the Office. I wrote a little wrapper for the Tenor API, and so we're just going to search Tenor, which is free GIF search engine, and get back the URL to Jif. Since I don't work for Tenor, we're not going to go too deep into that. Once you have that, we got to create an attachment.
00:10:33.914 - 00:11:13.766, Speaker A: Attachments aren't actually stored on the Xmdp network. We're kind of designed for small, lightweight messages and movie files or multi megabyte gifs. Not a great fit. And so what we do is we actually upload this to IPFS, and then we have a pointer to the encrypted file on IPFS. So the file is public, but no one can read it except for the recipient of the message that has the decryption keys so I can run through the code here for creating an attachment. So we're actually going to download the file so we have the bytes. We're going to create this encrypted attachment where we have some very nice helpers built into the codec.
00:11:13.766 - 00:11:58.330, Speaker A: This is all a package called Xmtp Content type remote attachment, which you can use to send files, movies, whatever you want on the Xmtp network of unlimited size, since you're going to store it somewhere else. And you just have to take care of having enough credits in your IPFS token. So you create this attachment and then we can send it. And so when you send something with a custom content type, you just have to specify what content type it is. That also comes from the Xmtp Content type remote attachment repo. And you pass in that attachment and it'll send that reply. So we're going to restart this bot now with the GIF.
00:11:58.330 - 00:12:39.620, Speaker A: Going to turn off the GM bot. All right. And we got a new QR code. This bot is going to be on a totally different address, but let's see if it can actually send you a GIF. What do we ask? You could put in anything you want. It's going to search tenor, which is the equivalent of Jiffy, get you back a matching GIF. So yeah.
00:12:39.620 - 00:13:26.108, Speaker A: All right, so we have five minutes left on this talk. I want to open things up for Q and A. What can I answer for you about Xmtp? Shoot. Not currently. They have their own kind of custom. Oh. The question is, does Farcaster use Xmtp? And the answer is no, they have their own kind of homebrewed DM solution if you think they should use Xmtp.
00:13:26.108 - 00:13:52.166, Speaker A: Love it if people get vocal and in their face about it. We certainly have a lot of chats with the Farcaster team. I think everyone would love to move to a single interoperable standard. I think they'd like to see that there's support from their users as well. Yes. You said that attachment gets encrypted and it's only accessible by the receiver. That's right.
00:13:52.166 - 00:14:46.042, Speaker A: Can the sender can also access this data? Yes. So the way that it works is we just generate a random encryption key on the sender side and we send that as a message along with the URL of the encrypted content. And so both sides who have access to that message have all you need to decrypt the content. And so you can see it as well. Yes. Oh, what about heavy files? So, in the case of remote attachments, storage is handled off of our network and so you can make it as heavy as you want. Obviously, it's going to be a strain on the recipient if you have a five gigabyte file, we tell app developers to make it an explicit action to download the content so that you can't just accidentally download a four gigabyte movie on your phone.
00:14:46.042 - 00:15:09.522, Speaker A: If someone sends it to you. And that's kind of a good UX practice. But us, as a protocol, we don't specify that. It's just what we tell developers to do. And if you look at most apps in the ecosystem, they will try and do that. We also do include the size of the file. And so you could build an app that would download something if it's under five megabytes and then ask you to download it if it's over five megabytes, something like that.
00:15:09.522 - 00:16:04.876, Speaker A: That's all possible. All right, if there's no other questions, we will be at the booth right next to Base and the EF and ENS, and you can come by anytime and ping me for questions. I think this botkit Pro is going to be a fun tool to build hackathon projects with, so I hope to see a lot of people trying. Oh, the question is, is there an environment we recommend? I am the developer of this botkit Pro, and it's very new. It works definitely on Linux and macOS windows. Your mileage may vary, but I'm happy to help you work through whatever issues there are. It's a simple node.
00:16:04.876 - 00:18:36.246, Speaker A: JS app. It runs in docker too. So you could definitely make it work inside a docker container. All right, thank you, everyone. So hi, everyone. My name is Simeon. I'm integration lead for Neon EVM.
00:18:36.246 - 00:19:23.206, Speaker A: So how many of you are developers and hackers here? Are there any hackers? Okay, nice. How many of you use Hard Hat development framework? Okay, only a couple. How many of you use Foundry? Wow. A lot of Foundry users. Okay, that's good. And yeah, today I will talk about what Neon EVM is and how do we help scaling Ethereum DApps. So I guess for all of you happened a lot that you want to swap your ten USDC into some shit or scam coin on Ethereum.
00:19:23.206 - 00:20:21.454, Speaker A: And basically at the same time, some degen NFT collection is out and trending and everyone tries to mint it. And basically gas fees are going to eat all of your ten USDC that you have saved for months. And I think that's pretty bad. One of the main, I would say disadvantages for Ethereum is that one trending DAP can congest the whole network. And this actually is not really beneficial for all users. So what did we build in Neon EVM is we built an EVM that is using the architecture and basically execution layer of Solana. And a lot of people and hackers ask me, is it a layer two? Is it a layer one? Actually, it's neither a layer two.
00:20:21.454 - 00:21:26.222, Speaker A: It's nor a layer one. It's actually something in between. And let me just show you a quick slide of the architecture. So, as you can see, Neon EVM is actually not anything more than just a smart contract in Solana that can execute EVM bytecode in Solana virtual machine. So we have built a smart contract in Rust that understands of EVM bytecode and can execute this bytecode without the Solana virtual machine. But with only having this smart contract, basically we can't really bring up Ethereum developers and EVM users because basically they would need to change their tech stack and Ethereum users can't really use MetaMask or their EVM wallets. So we have also one more pretty important component called the Neon proxy.
00:21:26.222 - 00:22:30.806, Speaker A: And as you can see, the Neon proxy on the one side actually accepts Ethereum like transactions. It provides just an ethereum RPC API. And on the other side it unwraps the Ethereum transaction, creates a Solana transaction and calls our Neon EVM program inside it. And you're going to ask, okay, how do you, for example, solve scalability issues? And it's simple. It's simple because of Solana parallel execution. And actually how Solana works is that let me just show you one more slide. Yeah, I think Solana is actually stateless and basically when constructing a Solana transaction, this is actually what a Solana transaction looks like.
00:22:30.806 - 00:23:27.402, Speaker A: And as you can see below the header, we have the account list. So this account list basically defines all the accounts that are going to be read and written for this transaction. So if we have two different DApps, let's say we have one Dex and one NFT collection, and if we have two same transactions posted at the same time, those transactions are going to be executed not sequentially, but parallel. And that's actually the whole example that I gave you. That one DAP cannot congest the whole network actually holds for Ethereum but doesn't hold for Solana. The gas prices will go up only for that app. But for other DApps, the gas prices will remain low.
00:23:27.402 - 00:24:03.442, Speaker A: And this is something that you can actually use. And also let me just go to the other slides. So we enable developers deploy on Solana but without changing their tech stack. The same as users. They can use MetaMask, they can use their EVM accounts. So if you're using Hardhead, if you're using Foundry, it's all right, you just change the RPC to our RPC and you can deploy. Another good thing is that our main aim is to become fully interoperable with Solana.
00:24:03.442 - 00:24:48.820, Speaker A: So for now, we only showcase and I'm going to show you how we can deploy a Solana SPL token as a wrapped ERC 20. And basically you can underlyingly mint, you can underlyingly transfer from your MetaMask and SPL token and you can use in your DAP. So let's just go and see. This is just a very simple hard head project. And this is the interesting part. So you can see we have token that is called ERC for SPL. And you can see something very interesting.
00:24:48.820 - 00:25:50.546, Speaker A: Here are the two Solana token programs that are basically Neonivm has a pre compiled contracts that can interact natively with Solana, SPL and Metaplex. And you can see we have wrapped the whole ERC 20 interface with calling the underlying SPO token. So we also have a deployment script you can see. So what the deployment script does it deploys a token and then after that it means to the deployer account just 100 tokens. So let me show you, let's just run and wait a little bit. Let me just show you what in the configuration we have to do. Basically as you can see, we only add Neon DevNet as another network.
00:25:50.546 - 00:27:02.004, Speaker A: If you go to Neon Docs, you can see that here are all the materials so you can see how to configure and use DevTools. We have the neon faucet. Basically you can connect to your MetaMask just request 100 tokens. You're going to see our MetaMask? Yeah, we have received the tokens and yeah, you can just go ahead and deploy. So our token is deployed if we come and see let's find Neoscan. Yeah, so this is our native explorer. So if you go to DevNet okay, and now you can see that we have two transactions.
00:27:02.004 - 00:28:38.386, Speaker A: The first is contract created and the second one is Mint. Basically we can also if you want we can basically verify our contract. Let me just see we need the four parameters and we need the deployer address. Let's just take it from MetaMask because that's the deployer. Okay, so now we should verify our contract again is the same as verifying with Etterscan. Okay, false bytecode mismatch maybe we need to that's trench. Okay, anyways, let's just not lose time with that and I want to show you some interesting things here in this transaction.
00:28:38.386 - 00:30:15.894, Speaker A: So if we come and basically add our token I guess the problem here is in hardhead some cache so if I had just cleaned all the cache and artifacts maybe it will work. So it's not a big deal. Let's just add our token in our okay, you can see we have the token and we have 100 tokens. So the most important thing is that you can see the transaction hash and you can see we have one underlying Solana transaction, right? Because we have deployed our contract on Solana and it's an actual if we click we can basically see that this is the Solana explorer and we can basically see that we have Minted 100 tokens on Solana on SPL. So that showcased that we have actually interacted with the Solana SPL program and let's just try know we have the token here right now. Let's just send it to let's say this account just copy this account. Um just send 50 tokens.
00:30:15.894 - 00:31:32.372, Speaker A: Yeah, so right now we are transferring from one account to another EVM account but underlyingly we will also perform the SPL transfer in Solano network. So it's confirmed, let's see what happens. So this is the transfer as you can see, we can see that we have transferred and also we have one underlying Solana transactions and the Solana transaction actually transfer from this account to the other. As you can see this is something interesting here the addresses are the same but actually the transfer from and to is actually in this account metadata because basically Solana is a little bit different than Ethereum. Solana is stateless. So I can show you another slide. This is a typical Solana program in a nutshell.
00:31:32.372 - 00:32:22.392, Speaker A: Solana is like a big file system. So you have two types of accounts. You have program account and you have a data account. So you can see that a Solana program has some executable BPF bytecode and we have a flag executable. So this is an executable stateless contract. And how does the contract create a state by itself? Is it creates a Solana data account for itself and actually saves the state there. So basically how Neon EVM works is basically Neon EVM is a stateless smart contract that can execute bytecode and you can see we have Neon account which is like an externally owned account which is like a data account.
00:32:22.392 - 00:33:59.682, Speaker A: And inside the data we have all the Ethereum metadata. For example, Ether address, non balance and so on. And for example, Neon EVM can deploy another contract and the same those contracts, when they want to save their state, they create theirselves another data account. So that's pretty much it. I think we have three or four minutes left so I'll just leave it for some questions. So as we can see, we have native interoperability with Solana but in the future we will try to achieve a full interoperability so the developers can use any contract, can integrate with any Solana smart contract only by using Solidity and using their EVM DevTools. Yeah, I'll leave some time for questions if you have maybe something interesting like we have all the most important materials here in our docs.
00:33:59.682 - 00:35:16.974, Speaker A: We also have some tutorials how to deploy with Hardhead and so on and so on. So it doesn't really matter how. If you want you can just start as a beginner and just deploy on Neon EVM. It's not that hard. Maybe yeah, maybe I can share something interesting that we are almost going to start and introduce support for Solana NFTs. So for builders that are interested in some Solana collections they can deploy their DApps on Neon EVM and basically use their Solana collections soon and introduce them to their DAP. Or if you want to use Solana liquidity you can just, let's say, deploy a unisoft V two fork and basically deploy a pool with SPL tokens on Solana.
00:35:16.974 - 00:36:49.820, Speaker A: Or deploy a pool, maybe create like hybrid pairs like SPL and ERC 20 pair or anything like that. So it brings up a lot of other possibilities for DeFi as well. No questions. Maybe I have to do my homework better. Maybe no one didn't understand anything. Yeah, it's pretty new and usually it's hard to grasp your head around it's not layer two, it's not layer one then what it is but I think that actually this is the most I would say self explanatory diagram. But yeah, if you're not familiar also with Solana and it can be yeah, that's true.
00:36:49.820 - 00:37:38.538, Speaker A: Open my code. Yes. You want the last two lines of the deployment script. Yes, those lines. So this is the SPL Token program. So these are precompiles that Neon built as Ethereum have precompiles neon built, pre compiled contracts that can basically interact with the Solana programs. And those Solana programs are the SPL token program.
00:37:38.538 - 00:39:11.652, Speaker A: As you can see, they have a different interface and the metaplex. So SPL Token program is basically a program, a centralized registry that can transfer mint burn tokens, and Metaplex is for metadata. Yeah, we can talk later because my time is over, so yeah. Thank you very much, guys. Hello. Hello. All right.
00:39:11.652 - 00:39:23.050, Speaker A: Hey, everybody, thanks for coming. Let me throw my slides. All right. Hi, everybody. My name is Eric Nakagawa. I'm from the cella blockchain cela foundation. Sorry.
00:39:23.050 - 00:39:55.196, Speaker A: And I help to lead the developer relations team. So excited to be here at our third ETH global hackathon. First, let's talk a little bit about Cello. In case you don't know how many people don't know about cello right now, how many have never heard of it? One, two, three. Okay, cool. Cello is a project that started a couple years back, and we really want to talk today about helping build DApps to solve real world problems. I'm here with the team myself, Anna Daniel.
00:39:55.196 - 00:40:30.396, Speaker A: We are at the very bright yellow booth in the main stage area. So today I'm going to talk about what cello is, what's the future for the project. Jump straight into bounties because a lot of people want to know what those bounties are. I'm going to show a new project very excited to talk about this project and then go into a little bit more detail on the additional bounties. If you have any questions, I will try to speed through these to answer your questions, but if I don't get to that, come see us first. Again. What is cello? We look at Solo as a place to build with purpose, and we want to build for all.
00:40:30.396 - 00:41:13.790, Speaker A: And what we mean by that is truly just like everybody here trying to build for the entire world. The difference with Celo is we started several years back, launched the token in a carbon neutral manner back before it was popular, but now everybody's doing it, and we're very happy to hear that. We were launched back on Earth Day, and there have been several projects that have launched on Celo involving things like UBI. This is where everybody gets a little bit of some tokens every single day. They come in and claim it. Projects running that right now on Celo are called impact Market and Good Dollar. There's also the concept of natural capital backed currencies, so people locking up parts of a forest, things like that.
00:41:13.790 - 00:41:48.470, Speaker A: A lot of this stuff has been built on Cello. And if you're looking to build a company that touches these things. It's a great place to get started. Some of the features sello is an L One. We recently had a proposal on the forum to convert to an L2. And what that means, it's very complicated, but really making that change makes a lot of sense considering when Cello launched, there wasn't ethereum was still proof of work when Sello launched, it's proof of stake and it's been EVM compatible. But it would be great to come back home to the theorem community.
00:41:48.470 - 00:42:37.824, Speaker A: A lot of things that were built also were around mobile first. So when Cello first launched, one of the pitches was sort of like a crypto venmo and I think we've evolved past that point where everybody has a mobile device, everybody's using all sorts of mobile wallets. And so the Sello team also built some technology around phone number mapping. So one of the great features that I like about building on Sello is I may not know your wallet, but if I know your phone number, I can in many cases escrow some funds or I can send it to a phone number to be transferred to you at some point when you connect a phone number. Other features to think about, quick, finality, can do high throughput, but everybody says that I think we can handle quite a large bit. And I'll share this near the middle part of my presentation. You can also pay with your transaction fees and stablecoins.
00:42:37.824 - 00:43:26.384, Speaker A: So if you have, let's say you are sending some tokens to a phone number and you send them a stablecoin like CUSD, they can pay for gas with that CUSD, not require the Sello based token. So it's a lot of good things for, again, helping people get started. Like many projects, decentralized, community governed, we actually have a hard fork happening on, I'll talk about this in a little bit, happening in a couple of days and it's going to make every transaction fully carbon negative. So very excited about that kind of stuff. And if you're interested in more of these things, feel free to take a look@cello.org. So, yeah, we're looking to talk about an L One. Changing from L One to L2 is a very big, very big leap.
00:43:26.384 - 00:44:04.828, Speaker A: But again, the time is right. I think the examples I made around phone numbers, escrowing and all that is great. Ultralight clients, also a really big opportunity. And with the shift to L2, a lot of this needs to be discussed in the community and if you're a part of it, you're welcome to share your opinions. Recently, the Polygon team posted their proposal polygon ZK, just to be specific, posted their proposal in the forum, sharing their thoughts on how Cello L2 could transpire. And it's actually pretty exciting to see more people getting involved. So a little bit more, why would you build on the project? Lots of people using it, lots.
00:44:04.828 - 00:44:43.070, Speaker A: Of wallets. There are lots of organizations driving, keeping the project kind of focused on the core values. I'd mentioned things like carbon offsets. We can go a little bit more detailed there and then there's tons of projects, lots of a or is a very large ecosystem of people building. I would say we need a little yellow circle there for ETH Global New York in case any of you are building on Sello, this hackathon, but excited to see the community grow. Lots of different projects building on Celo. Some of these are projects that we've either partnered with or working with that you may know.
00:44:43.070 - 00:45:31.870, Speaker A: And there's also a lot of businesses that partner with Celo to reach as many people as possible. So very excited about that. In terms of ecosystem and refi, regenerative finance, a lot of the development that people have done have tried to bring on things like trying to bring carbon offsets in, trying to bring regenerative finance in. And if you're interested in this path, let's talk. One project is called Climate Collective, which is a funding mechanism to help people or projects that are building in that space raise the funding and capital that they need to grow a team. As I mentioned earlier, Ultra Green is our upcoming hard fork. There was this project called ultrasound money.
00:45:31.870 - 00:46:22.956, Speaker A: Everybody's inspired by other projects but we launched Ultragreen Money and that keeps track of how much of the offsets and on Tuesday the actual switch goes on and every transaction from that point on will be offsetting through either toucan or carbon path. So very excited about these things. And again, something to think about. One of the interesting things with this change is there is actually an 80% of the gas is going to be burnt and then 20% is going to be put into offsets. So it's like I'm no economist, but a deflationary model is very intriguing for many reasons and I think having the carbon offsets as a part of it will do really, really well. Especially with some of the new launches that just have come up. If you're here, you're a developer, you're a product person, marketing coming up with ideas and you want to get your idea out there.
00:46:22.956 - 00:47:15.080, Speaker A: There's a lot of partners you can be using to launch your project. We have infura Lava Quicknode and then if there's projects that you want to utilize, take a look at Impact Market, Good Dollar. There's also cross chain messaging, so hyperlane shout out to them. They also have a bounty in case you are trying to stack and I don't know if any of the other cross chain folks are here. There's also Chainlink Live on Sello and a couple other Oracles depending on what features that you need. In terms of stablecoins, you can utilize CUSD, Euro, Real and if you're looking for DeFi, we have Uniswap and Sushi Swap, several other options. In terms of wallets, there is the Valora, which was built by some teams that helped to build the protocol and then launch the wallet.
00:47:15.080 - 00:47:28.652, Speaker A: There's MetaMask, of course, you just add it into your wallet. Very easy. If you're looking for an Explorer as you're building. Ether scan is on sello. But it's called celloscan. So take a look at Celloscan or the native Explorer Sello.org, which is built on BlockScout.
00:47:28.652 - 00:48:04.216, Speaker A: So running into some of the bounties, which I think most of the time should be spent on. We're going to be offering three top prizes. We're looking for the best projects that align a lot with what I showed earlier. So if your ideas are kind of there and you want to nudge it a little bit, this is a great chance for you to win a potential prize. And then we're also adding another bounty on top of this, which is around building for real world use cases. And I'm going to showcase Minipay in a second. If you're also looking at building for account, third Web has launched and deployed their SDKs for testnet.
00:48:04.216 - 00:48:20.752, Speaker A: So happy to help you folks there. So quickly. I want to talk about Minipay. It's really exciting project launched by Opera. And if you're building for a railroad example, this is a bounty that you should sign up for. I'm going to play a quick video. This was announced just last week.
00:48:20.752 - 00:49:12.150, Speaker A: So super exciting stuff. Anyway, there's some audio if you all can play it. One cool. How many of the people here have heard of Opera browser? Very cool. So the great thing about the Opera Mini browser is actually a lot of traction in Africa. So large number of users in Africa. I'm trying to skip this, sorry.
00:49:12.150 - 00:49:22.004, Speaker A: So let's run through some of these benefits. So it's super simple. Wallet built on android. I got an Android phone. Got an Android phone right here. They're rolling out to users right now. And it's primarily focused on payments.
00:49:22.004 - 00:49:59.104, Speaker A: And so, I don't know, when I was getting prepared for my slides, I was thinking, how do I get people excited about this huge opportunity for building for several million people about to be in this wallet? And if that gets you excited, come chat with us. But I hopefully don't need to connect all the dots for you. There's a lot of really good opportunity. The wallet is self custody. Transaction fees are very low, as you see here. NGN is a Nigerian currency that they're using for folks who are in Nigeria. And then they also provide those folks access to stablecoins.
00:49:59.104 - 00:50:44.224, Speaker A: So it can be helpful for people that are trying to decide what to do with their money. They also do Opera team, not us. This is not Sello foundation or Sello ecosystem. This is the Opera team also provides some free mobile sorry, some free mobile data, which is very helpful for folks who in some regions, depending on where you live or where you're from, it can be very expensive to do to visit lots of websites or heavy websites, so they help to subsidize that. There's also mobile notifications. And so as you're building for your application nation, think about like, what would I want to do to push alert to, I don't know, 20,000 of my DAP users think that way and you have a really powerful opportunity. So that's the project.
00:50:44.224 - 00:51:27.452, Speaker A: It's called mini pay. You can actually download the beta from the App Store right now. And when we're looking for projects, ideas that you folks may have that fall into these categories, if they do, I think you have a strong chance of winning a bounty. Projects like personal finance, stablecoin yield. I am not an accountant or a lawyer, so you need to do your own homework. There merchants B, two B, or just using things like if you had a very simple user interface that had like a couple of buttons, I don't know, let's say one or two, what could you get people to do to help them try out your DeFi protocol? And finally, or a little bit more detail, how about a gift card idea, a grab app, something that kind of puts everything all in one place. Someone's going to build it.
00:51:27.452 - 00:51:45.636, Speaker A: It could be you. It could be payment control for families. So I've got kids, so maybe I want them to do maybe they want to buy something. But I'm like, I'm going to give you a loan. You have to pay me back. I'm that kind of dad, I guess. And then what about payment splitting amongst friends? Microwork is a very big opportunity for folks to do things.
00:51:45.636 - 00:52:34.630, Speaker A: It could be virtual work, it could be in person real life work, keeping track of things around assets or expense approvals and things like that. Some of these things may seem more businessy, but there's a very big opportunity again, because of the size of people that are coming in. So one project I came up with, again, I didn't talk to the lawyers, so don't get mad at me, but I built this project and I'm going to open I'm just putting it up online. It's built off of our very simple to build DAP framework called cello composer. And it's really simple. The idea is people can just play, put their name in, a little bit of money is set aside, and then at some point in the future, using a provably or Verifiably Provable randomization function, they could win. So I'm going to quickly switch to that just to show this.
00:52:34.630 - 00:52:59.052, Speaker A: Let's see. First off, let me show you minipay. So this is my wallet and and here's my obviously, I've been working on it. Here's my DAP. Super simple. It's a very simple, like, wagme wrapper. So it's not that hard.
00:52:59.052 - 00:53:32.344, Speaker A: I just have the concept of allowing people to play the game within. And if you want access to this, this is a beta feature. So in the discovery page, there's a test dev section. So I'm going to be testing this today for a live demo because that's always exciting. So I'm going to run both of the projects at the same place. And the concept is the way I want this to work is people from their phone. I need to, of course, improve the user interface here, but I want them to just be able to tap and play.
00:53:32.344 - 00:53:53.150, Speaker A: So I'm going to connect my wallet here. Very straightforward. I'll chip in a bit. And this should update to, I don't know, 40 something, 41.41 cello. That's the prize. And then in a perfect world, this will update, but maybe it won't today.
00:53:53.150 - 00:54:13.200, Speaker A: This project is meant to be just an example of cello composer. Cello composer is a great way to get started really quickly. Got hard hat integrated. It's actually a fork of Scaffold, but built for cello and added a bunch of features around mobile development. Oh, my God. Updated. So this is a quick project I wanted to show you folks.
00:54:13.200 - 00:54:34.120, Speaker A: And this is a link to the project. I'll show a link to the project in case you folks want to actually check it out. Oh, here it is. So super easy. Come see me if you actually want to play with it. And if you're interested in actually building for minipay, getting started on the project. Thank you.
00:54:34.120 - 00:54:53.068, Speaker A: If you're interested in building for the project, this is the one to scan. So here's some of the notes. So, yeah, one of the things is with minipay, you want to hide your connect wallet. Yeah. What about all the other wallets? Right? Yeah. Just imagine if you got rid of that, how much easier it would be if you just started with your wallet. So that's some of the simple things and it's not that hard to do some checks.
00:54:53.068 - 00:55:19.396, Speaker A: If you're interested in Minipay, scan this. You'll get invited to a WhatsApp group. And then I'll onboard you folks very quickly into the building for minipay. And I actually think if this hackathon isn't the time you build for it, this is a great opportunity. But even if you build a small thing, imagine if you could deploy it to several million users very soon. Seller composer. You can go to our docs sello.org.
00:55:19.396 - 00:55:40.752, Speaker A: Here's another link just to sell a composer itself. I will talk briefly. I'm going to run through these. You can find everything on Docs Sello.org. Just go sell a composer. But if you want to build for account abstraction, again, think about if you had access to millions of folks all over the world and you wanted to build something that made it easy to onboard account abstraction. Makes a lot of sense.
00:55:40.752 - 00:56:16.620, Speaker A: We've worked with third web to support their SDKs. I won't run through all these just because I'm running out of time, but quite easy to add in the just jumping straight to here. Quite easy to add in a kind of traction with cello composer. Again, it's just like Scaffold but updated for the cello community. And if there's other projects, other projects that are available on the cello network that you folks may be interested in using. This is our third hackathon we've been at. So we know that you folks are going to try to select every single box.
00:56:16.620 - 00:56:45.680, Speaker A: Here's some of our friends, and please look at their work for the Bounties. How are we going to judge it? If you're building from Minipay and you have access to that and you can put your app inside that and show it to us, check for me. If you have AA working on Alpha Horace testnet, it'll work. I think that will count. You get extra points if you run on Minipay. Not every feature is available, so it's still Beta. And then need to see your contract deployed in Alpha Horace follows all the rest of the ETH Global rules and just come demo it to our section.
00:56:45.680 - 00:58:19.828, Speaker A: If you need tokens, this is our testnet address for the Faucet. If you need Mainet tokens, come see me, Anna or Daniel. And we'll give you a little bit to get started because exchanges take a long time. So that's it from me. My name is Eric. Excited to see you folks build on Sello and thank you. I was everyone, can you hear me? Okay, we'll get right to it.
00:58:19.828 - 00:58:46.112, Speaker A: My name is Ben Weinberg, I'm a developer advocate for the Axflower team. I'm in from Toronto, Canada. Any Canadians here? Nice. Oh nice. Good numbers. Okay, so agenda for today, briefly, we're going to go over the need for interchain, how we got here, why this matters, the problem with pairwise bridges as they've existed over the past few years, an overview of the Ax Four network and the advantages which it brings. And then we're going to get into general message passing otherwise known as GMP.
00:58:46.112 - 00:59:09.872, Speaker A: This will hopefully be interesting for you guys. This is what our bounty is on, is best use of GMP. We're going to go through a code example of it and then we're going to end off with Axler in the wild and some fun stats. So a bit about myself. I got into the blockchain space in late 2017 and I'm sure many of you had the same experience for me. When I was trying to get in, I would go to many meetups, that was my thing. I try to meet as many people as I could, make friends with as many people.
00:59:09.872 - 00:59:40.040, Speaker A: And what I noticed is that you go to these events, you don't know anyone, and everyone seems to know a lot more than you. And everyone is extremely opinionated. And many people at the time were trying to promote certain projects which they were involved in. So there was of course Ethereum, but there were also projects that people were kind of promoting as like the Ethereum Killers. There was Neo, which was branded as like the Chinese ethereum. There's iota tron EOS, which was branded as like ethereum on steroids because it was faster and cheaper. And this mentality that people had at the time was that of chain maximalism.
00:59:40.040 - 01:00:15.272, Speaker A: This idea that there will be one blockchain to rule them all and the rest will kind of die. I think it's safe to say, looking back now, that what we've learned is chain maximalism is wrong. This never actually happened. Instead, what we saw was the rise of more and more blockchains. And if I could find my mouse here, this is a brief screen recording I have from a website called Chainlist. And what Chainlist does is it shows you the list of many of the blockchains that exist today. I say many, not all, because it's impossible to actually know how many blockchains exist today.
01:00:15.272 - 01:01:00.998, Speaker A: But I'm trying to show you here is that you can see just on Chainlist, there's hundreds, if not thousands of blockchains that exist today. And for our space to be successful, we need to find a way to connect them. And this question of interoperability, if I could get out of this. This idea of blockchain interoperability is nothing new. We've known for years now we need to have interoperability for the web3 space to be successful. But what we saw was the rise of pairwise bridges, which were using like wrapped assets and multisig to handle actual transactions between the chains. And the problem with multisig contracts as bridges is that they were extremely vulnerable to hackers, especially if the keys were compromised.
01:01:00.998 - 01:01:41.650, Speaker A: And you can see here some of the more famous headlines I pulled up. There are many more than these, but these are some of the famous headlines of some of the biggest hacks that we've seen. The most famous one probably being the 625,000,000 Ronan Bridge hack for all you Axio Infinity players out there. But there's also, like the polynetwork hack that happened just a few months ago, earlier this summer, who had a three of four multisig key compromised and more. So this interesting article by Chain Analysis, they estimated that in 2022, 69% of all funds stolen in crypto, it's about $2 billion that was stolen was actually a tax on bridges. So let's pause right here. What do we know? We know that the number of blockchains is rising.
01:01:41.650 - 01:02:07.338, Speaker A: Interoperability is more important now than ever before, but we, as a space, can do a bit better in the way we conduct interoperability. And that is where Axelr comes in. So axilar at its simplest is a blockchain that connects blockchains enabling universal web3 interoperability. And that's a bit of a mouthful. I don't expect you to take a lot out from that. So let's actually dissect this. We're going to dissect it by looking at the Axilar network.
01:02:07.338 - 01:02:35.410, Speaker A: So this is the easiest way to actually see Axler. It's a hub and spoke model. And I want to focus on the last three words from that previous definition, I had universal web3 interoperability. Why am I focusing on that? That's because if you look at some of the blockchains here, just notice it. We have ethereum, phantom polygon. These are examples of blockchains running the Ethereum virtual machine. We also have projects like Osmosis Juno, the Cosmos Hub Region Network.
01:02:35.410 - 01:02:59.360, Speaker A: These are projects built on top of the Cosmos SDK that are using Comet BFT Consensus. We also have Arbitrum. We also have linear base, though I don't think those two are on this diagram here. In total, we have 49 blockchains right now that are all connected with Axelr. And these are different blockchains with different consensus mechanisms, different virtual machines. We have app chains that are on here. Let me go back to this.
01:02:59.360 - 01:03:30.738, Speaker A: So that's its idea of universal web3 interoperability. And the two major improvements which Axflor brings right out of the box are that of scalability improvements and security improvements. So let's talk about scalability first. If you picture pairwise bridges sorry, I know it's a bit hard to read, but let's imagine we have three blockchains. In blue, we have ethereum. In yellow, we have BNB, and in purple we have polygon. Now, to connect each of those three blockchains to each other, for three chains, we need six bridges to connect each blockchain to each blockchain.
01:03:30.738 - 01:04:03.246, Speaker A: Say we want to add a fourth, say avalanche, just for that one extra blockchain. We're now at nine bridges to connect all these blockchains. And you can imagine, like with what I was showing you guys earlier on Chainlist, where there's like thousands of blockchains that exist to connect each blockchain to each blockchain. I don't even know how many bridges to connect each of those. But the point is, that number doesn't really scale. And if you contrast that with Axler, where we have a hub and spoke model, all you need is one connection to the Axler network and then you're connected to all the other blockchains that are connected with Axelr. And I like to think of this in my mind as like these pairwise bridges are kind of like train tracks.
01:04:03.246 - 01:04:28.710, Speaker A: You can go from point A to point B and that's it. Whereas with Axler it's more like an airport. All you need is a connection to Axler. You just need one airport in your city, and then you can connect to any other city in the world that also has a blockchain. So that's scalability improvements. If I go back to my second point here, there's also security improvements, and I touched on that a bit. But Axelr is a blockchain of blockchains.
01:04:28.710 - 01:05:07.410, Speaker A: So what does that mean? It means that we're built on top of the Cosmos SDK. We currently have 75 live validators. Anyone here in the Cosmos ecosystem might be familiar with some of these validators, like Figment Informal Systems, Pokachu. These are well known validators who are also validating many other chains in the Cosmos ecosystem as well and this is a tremendous step up, actually having a blockchain to handle Interoperability compared to just like a multi SIG contract. But now that we've covered the use case and how Axler is helpful, let's look at what we can do now that we couldn't do before. And that is general message passing. And this is the exciting part, I hope, for you guys, because it's what our bounty is on and it's best use case of GMP.
01:05:07.410 - 01:05:36.906, Speaker A: So what is GMP or General message passing? It's this idea that we could actually send a message between one blockchain to another. Pretty straightforward. And you can see myself on Ethereum. This is a picture of me from my first ever blockchain meetup. I spent way too long looking for it. And this is me here on Avalanche. So on the first message I'm sending like wagme, like, are we going to make it in this crazy amazing space that we're getting ourselves into? And then from Avalanche to Ethereum, I'm sending a message called Safe Mint five Board apes.
01:05:36.906 - 01:06:18.570, Speaker A: And what I'm trying to show you here is that in addition to just sending like kind of silly little hello world messages, you can also actually call functions between one blockchain from another blockchain. And that is true interoperability. It's the idea that we can actually interact with contracts and applications on a different blockchain as easily as if they were on our own blockchain. So a very brief diagram here. I know the text is a bit small, I apologize for that, but a brief diagram of how GMP works. So imagine we have let's start from the bottom left corner there we have our amazing hackathon project and we've deployed that on the Avalanche blockchain on the right. We have also deployed that application on the Polygon blockchain.
01:06:18.570 - 01:06:50.294, Speaker A: And we want to send an ERC 20 token from Avalanche, from our application there to our application on Polygon. So the first thing we have to do is interact with something called a gateway contract. A gateway contract is a contract which Axeler has deployed on every single blockchain that it interacts with. So the gateway contract exposes several different functions, including Call contract with Token. So step one, you have your DAP. Your DAP does some amazing idea. You're going to import the gateway contract and from the gateway contract you're going to call this.
01:06:50.294 - 01:07:20.766, Speaker A: Italicized Call contract with Token that jumpstarts a process through the gateway contract which emits an event. The event is then picked up by the Axler network. The Axler network member is a blockchain with 75 validators. Those validators come to consensus about the message that was sent. If they're all on board, we're all happy. They send a message to the gateway contract on Polygon, on the destination chain that the message was approved. And then via something called a relayer, the gateway contract triggers step four, execute with Token.
01:07:20.766 - 01:07:47.338, Speaker A: This Execute with Token is a function which you're going to define yourself in your contract and you can do whatever logic you'd like with it. With the message that's coming in, you see the bytes 32 payload and we're going to go through a quick code example so you can see that in action. But one more time. High level, your application is deployed on two blockchains. You call the call contract with token from the gateway contract. Under the hood, gateway emits an event picked up by the Axler network. Axler network lets the other gateway on the destination chain know that, hey, we're good.
01:07:47.338 - 01:08:20.114, Speaker A: Then the gateway calls the execute with token function via relayer. So let's see this in action and sorry, I know it's a lot, but trying to get through a lot in a little bit of time. So for time's sake, I'm not going to write out this code. You'll see how we're going to do it. But what we're doing here is we're trying to implement the previous example, which is to send an ERC 20 token from Avalanche from the source chain to Polygon, our destination chain. So first thing we do is import our ERC 20 interface from open Zeppelin, pretty standard. We then import the Axler executable, which I will get back to in a bit.
01:08:20.114 - 01:08:44.138, Speaker A: Sorry, this is small, let me make it bigger. This is as big as it goes. Are we happy? Can we see this? Okay. Next thing we do is import the Axler executable, which I'll get back to. Then we import the Axler gateway contract. Is this familiar to anyone? Axelar gateway that is remember this guy? The gateway contract which is going to expose the functions that we need to interact with. So we import the interface for that.
01:08:44.138 - 01:09:08.302, Speaker A: We then import the interface for the gas service. This is the other very important contract which I conveniently left out of that diagram. So let's think about it. If we want to send a transaction from Avalanche to Polygon, we're going to need three different tokens. One, AVAX for the avalanche blockchain, two Axl for the Axelar blockchain. Remember Axelar, which is facilitating this is itself a blockchain. And then three matic.
01:09:08.302 - 01:09:40.234, Speaker A: That is the token of the destination chain. Polygon, though, I think they're changing the name of that. And the problem is I don't want to hold three tokens every single time I want to send a transaction. I don't think you guys do either. So what the gas service does, it is extracts that difficulty. We can just via the gas service tell our contract like, hey, we need funds for the Polygon blockchain, we're sending it from the avalanche blockchain and I am the person sending this transaction. So now all what you need is the token of the source chain.
01:09:40.234 - 01:10:06.806, Speaker A: If you're sending from avalanche to Polygon, you just need AVAX and you're good to go. And the gas service will handle the rest. It'll handle the matic and the axl token. So you don't need to hold all three. That is what the gas service does. If I go to step two here, if I could find it, the first thing we do here is simply in our constructor, we pass in the address of the gateway and the address of the gas service. Remember, every blockchain which Axelar is on has a gateway and a gas service.
01:10:06.806 - 01:10:46.260, Speaker A: If I go to step three, we define our first function which we're going to be using here. This is not a specific name sentimenty. I just picked this. You can call it whatever function you want and send to many. When you call this function is going to jumpstart this interchange transaction. It's going to be the function that you call to send an ERC 20 token from chain A to chain B. And it takes five parameters, the destination chain like, hey, which blockchain are you going to? Destination contract, address, which is this contract itself, which will be deployed on both blockchains, the destination addresses which I will come back to, and then just the symbol and the amount of the ERC 20 token that we're passing in.
01:10:46.260 - 01:11:14.986, Speaker A: So if I go to step four, we have some pretty simple functionality here. First we require, say like, hey, make sure we pass in some gas. If not revert, then we grab the address of the ERC 20 token that we're sending. We can do that by just passing in the symbol of the token to the gateway. We then have some standard ERC 20 stuff. We transfer the tokens from me to this contract. We then approve the gateway to be able to handle our tokens.
01:11:14.986 - 01:11:47.160, Speaker A: Then we encode our third parameter, our destination addresses, which is a parameter I promised I'd come back to. Basically, if you think about it, all we're doing here is sending an ERC 20 token from one chain to another. But what's exciting, what I really wanted to show you guys for the bounty is general message passing. That's what this is all about. So what this third parameter is our message that we're going to be passing along with our token from one blockchain to the other blockchain. And to pass that message, we actually have to encode it into bytes. And that's what we're doing here.
01:11:47.160 - 01:12:42.380, Speaker A: If I go to step five, I now interact with our gas service and our gateway contract. And for time's sake, I'm not going to go through all this. But basically what we're doing is we're telling the gas service like, hey, call this super long function, pay native gas for contract call with token and we're telling the gas service like, hey, we're going to need funds for the polygon blockchain as well. We then call our gateway contract here on line 61. This is the call contract with token function, which, if you can recall, is the function that we had defined here in our diagram, which was being exposed to us from the gateway. So in our gateway contract. We say like, hey, we want to pass in the destination chain like Polygon, we want to pass in the destination contract address, the encoded recipient addresses so like our actual message which is coming and then our symbol and our token amount.
01:12:42.380 - 01:13:30.848, Speaker A: And once we call this function we are going to have kicked off our interchange transaction. So once I call this and all this logic gets executed, our transaction will now be leaving the avalanche source chain and going to the Axfar network which is great, but if you recall the diagram, we also need to do something on our destination chain. So the transaction goes to Axelar and then comes out the other side on Polygon. But like, what do we do there? So for that we have our final function which is execute with token. And now this function is going to be triggered on Polygon automatically and it's going to handle some logic with our message that gets passed. And this is our final step here. We're going to be taking our payload.
01:13:30.848 - 01:14:39.784, Speaker A: Notice the third parameter here, which is our message that was passed, our list of addresses and then on line 90 we're going to take our amount of tokens that was sent because remember, we're sending an ERC 20 token and a message. So let's say we send six USDC or aUSDC and we divide it by how many addresses we've sent and that is the amount that we're going to send to each address which is really, really powerful because not only are we sending the token but because we're sending a message with it as well. We can compute some logic in this case, very simple logic, but logic nonetheless that we're going to be doing on our destination chain after our transaction is sent. And I executed this earlier today, I figured I'd be short on time but it's all done through the hard hat CLI so I'm not going to go through this. But what I did want to show you guys is this transaction actually going through on the AxLR scan Block Explorer. So remember, since Axelr is a blockchain, it also has its own blockchain and you can see here the step by step of each step of the transaction process. So you can see step one, the transaction gets sent on avalanche, the gas gets paid on Avalanche.
01:14:39.784 - 01:15:20.920, Speaker A: The Axlar network confirms the transaction. I can scroll down here for more details. Step three is confirmed and approves the transaction and then the final step, it gets executed on the Polygon Block Explorer. And you can see here I can actually click right through from the AxLR scan Block Explorer from the Axilar scan Block Explorer to the Polygon scan Block Explorer. And you can see here our transaction actually our logic being executed. We send six tokens and then evenly send two tokens to each of the recipients. So that is a very high level of Axler GMP in action.
01:15:20.920 - 01:15:47.650, Speaker A: The thing I want to end off with is the more fun stuff, just Axler in the wild. So this is an application called Squid, which is being used today. It might look familiar to anyone here who's ever used the dex before. And you can see that. What's cool about Squid is that in addition to selecting the token that you want to send, you can also select the blockchain you want to send. So in this case, I'm sending GRT from Ethereum to USDC on optimism. And this is all in one click.
01:15:47.650 - 01:16:11.112, Speaker A: Really powerful stuff. And I want to end off with some stats here. This page might look oh, I didn't spend that much time on Axler scan, so a bit unfamiliar. But this is from the Axler scan Block Explorer. You can see just some of the stats about the Axler network. You can see 66,000 transactions, $3 billion of transaction volume sent. And the really exciting part is that this is just over the last 30 days.
01:16:11.112 - 01:16:38.130, Speaker A: I know it's a bit small, but it's a really, really exciting time to be familiarizing yourself with this stuff and using Axelr. Here are some resources for anyone doing the bounty. On the left I highly recommend it is a series of YouTube videos we have just explaining this stuff. And on the right is our GitHub repo of just examples using this stuff. And yeah, thank you very much. My name is Ben Weinberg. Hope to see you guys around.
01:16:38.130 - 01:18:26.612, Speaker A: Hi, everyone. Hi. Oh, hello, friends. All right, today we're here to talk about MetaMask Snaps. We have a bunch of bounties for you. So this is very exciting. We also launched Snaps about one week ago.
01:18:26.612 - 01:19:04.222, Speaker A: I'm going to tell you a little bit more about that, but first, about myself. My name is Ziad. I am the developer advocate for MetaMask Snaps. You can find me on Twitter, Instagram, all the social media, Ziad, MTL. And before we get started, this is a QR code for this presentation. And if you're hacking on one of our bounties for MetaMask snaps, you're going to want to get this presentation because it has all the resources that you're going to need in order to get started hacking with us. Very briefly, let's talk about MetaMask.
01:19:04.222 - 01:19:37.210, Speaker A: MetaMask is the most popular self custodial wallet, 30 million plus users. I'm very proud to work for MetaMask. I have beautiful colleagues, and we're doing some great stuff for Web Three. It was released as a browser extension, and it lets browsers connect to Ethereum compatible blockchains. But not just ethereum. As of September twelveTH, MetaMask is now able to do a lot more things thanks to Snaps. Snaps are add ons for MetaMask.
01:19:37.210 - 01:20:34.480, Speaker A: They enable the addition of new features to MetaMask, and you can develop those features anyone by using our APIs, and we're going to see how to do that. In this workshop, you build Snaps with TypeScript or JavaScript source code, ideally TypeScript and your Snap, your JavaScript codes runs in a secure sandboxed environment so that you can only do the things that we allow you to do and that the user of MetaMask allows you to do. Once you're done developing your Snap, you publish it as an NPM package. Anyone can install it and they can do a lot of things with it. Like what? Well, yeah, we launched on September twelveTH. So what can you do with Snaps? First, you can add non EVM chains to MetaMask. That means you can own Bitcoin inside MetaMask or Dogecoin or any other coin that you want.
01:20:34.480 - 01:21:31.490, Speaker A: You can increase the security of the wallet by providing the user with transaction insights, telling them that a transaction is maybe not safe based on some algorithms that you have or some proprietary information that you have. You can add distributed identity features to the wallet. You can add communication features to the wallet. And there's a whole bunch of other support APIs, such as networking, secure storage, custom UI that you can use as a support to build all those features that you're building. And there's a lot more on the way. If you looked at our bounties, which I'm going to present in a moment, you will see that we're already starting to develop more features just as we have launched. So what are some of the things that people are building with snaps? Well, if you go to Snaps MetaMask IO today, you are going to be able to download and install in your MetaMask browse in your MetaMask extension 35 different snaps.
01:21:31.490 - 01:22:07.310, Speaker A: The biggest category is interoperability. We have a cosmos snap. We have a bitcoin snap. We have a leap snap. We have all the snaps that you see here and all those can allow you to manage all these accounts securely from inside MetaMask, the same way that you manage your Ethereum. We have transaction Insight snaps which allow you as a developer to add some data inside the MetaMask UI to give more information to the user about a transaction that they're about to make. And we also have notification snaps that allow communication features.
01:22:07.310 - 01:22:40.182, Speaker A: So let's talk a little bit about our bounties before we start looking at a demo. For the ETHGlobal New York hackathon. We have two bounties. The first one is prompting you to build a transaction Insight Snap with a V, two that is so new that it's not yet in our documentation. So this presentation contains a link to a beta documentation that you're going to be able to use in order to hack on our bounties. We also have a bounty for a domain resolution Snap. This is a feature that's not even live.
01:22:40.182 - 01:23:10.922, Speaker A: You're going to have to use a special developer preview of MetaMask in order to be able to build on that bounty. And you're going to get all the information during this presentation. This is the link to it. You can scan it if you want, or if you scanned the QR code earlier, you will have access to it. And we also created a developer guide for you, especially for this hackathon, so that you can get started easily. All right, so now you're all excited. You've seen all the beautiful features that we can build with snaps.
01:23:10.922 - 01:23:43.974, Speaker A: So how do you get started? Well, it's very easy. All you have to do is run one command on your command line. We're going to run it in a minute, and it's going to provide you with a full repository that contains everything and a fully functioning Snap that you can start editing right away. So you don't have to start with a blank page. And there's one more thing you're going to need to get set up with a special version of MetaMask called Flask. It's a developer preview of MetaMask. It looks exactly like MetaMask.
01:23:43.974 - 01:24:31.100, Speaker A: It has a different icon so that you can know that it's a different one. And also don't put any live private keys in there that you care about. It's really meant to be used as a separate extension, ideally in a new browser profile or in a completely different profile. And you can get it on MetaMask, IO, Flask. All right. And the rest of this presentation contains a bunch of links for you that will also give you some inspiration, that will give you some more documentation about everything that you can do with Snaps. And that being said, now, I would like to walk you through what happens when you run that command that we looked at earlier and what kind of code you get.
01:24:31.100 - 01:25:04.500, Speaker A: And we're going to see how you can use that code, how you can debug a Snap. And we're going to get started right away. So the command was yarn. Create. You can also use NPM, if you like at MetaMask, snap and then the name of your Snap. And I was expecting the network to be a little bit slow here, so I've already set up a new Snap from scratch that we're going to be using for this presentation. Here it is.
01:25:04.500 - 01:25:41.240, Speaker A: And I want to double check how the font size is looking on the screen that you're seeing. It's a little bit small, so I'm going to make it a little bit larger. All right, so once you run that command, you get a full Yarn repository that has two packages in it and a bunch of setup files. So very quickly you get a site package. You don't need to use it. It's a DAP that allows a user to install the Snap. You can add some buttons to it that will allow you to interact with your Snap as you're building.
01:25:41.240 - 01:26:11.406, Speaker A: And the most important package is the Snap package. It contains some TypeScript code as well as some commands that you can use as a developer in order to quickly get started building with snaps. And how do you get started building? Very easy. You go on your command line and you run yarn. What? Yarn what? What do you think? Start. Yeah, simple, easy. Just yarn.
01:26:11.406 - 01:26:49.710, Speaker A: Start. And what is this command going to do? It's going to run two processes in parallel. The first one is a development server that is going to be constantly looking at your Snap code and rebuilding it on the fly as you're changing your code. And the second one is going to run the site package, which is a simple DAP that has a few buttons that allow you to install the Snap, interact with it, and get started. It's built using React, and it's very easy to get started with. We're not really going to be looking at it today. It's basically a react site with some buttons that are interacting with the Snap.
01:26:49.710 - 01:27:36.590, Speaker A: And once the development server has executed, you can just go in your browser, you go to localhost 8000 and you get presented with a very simple DAP that allows you to connect with the Snap. Now, because I've already connected with a Snap before with this Snap before, the button says Reconnect here. And this is very important as a developer. As you're making changes to your Snap, the Snap gets recompiled immediately. Your TypeScript code gets recompiled immediately. But if you want to see those changes, you have to click this Reconnect button so that the Snap will get reinstalled with all those latest changes. So this is what happens when you do that, asks you for your password.
01:27:36.590 - 01:28:22.780, Speaker A: I hope I remember my password all right. And then you get a dialog that asks you to install a Snap. This is exactly what your users will see once they install your Snap, once they interact with your Snap. And we can see here that in addition to giving you some information about the source of the Snap, the name of it, there's also a very important section here which lists all the different permissions that a Snap is requesting. A few moments ago, I mentioned that a Snap runs in a sandboxed environment. So even though you're writing TypeScript JavaScript, and it's seemingly running in a browser, your Snap code doesn't have access to anything, cannot fetch data from the network. It can't do anything.
01:28:22.780 - 01:29:22.666, Speaker A: And through this permission system, which you set up through a manifest file, you can ask the user to do things. For example, in this case, the Snap that you get as a template when you get started is asking for two permissions. It's asking to be able to communicate with websites, which means that your Snap is going to be able to provide an API, an RPC API that websites and other snaps will be able to use. And it's asking to display dialog windows using this custom UI feature that we're going to look at in a minute. So if I say install, the Snap is going to be installed and then where am I going to see this? In my MetaMask? If I go in my settings menu, there's an option that you might not have seen before. It's now live in the main extension. It used to be only in this MetaMask flask version called Snaps.
01:29:22.666 - 01:30:12.040, Speaker A: Right here and under here, you will see all the snaps that you've installed. And if you go in there, you will see all the DApps, all the websites that are connected with your snaps, all the permissions and the ability to remove the snap if you want to. In addition to this, the DAP contains a send message button. This is a button that is going to be calling a function from your browser from this web page using the Ethereum provider. And this is going to call the Snaps RPC API in the example that we give you. And it's just going to show a demo of the custom UI features that we have in MetaMask snaps. So when I clicked on this button, the DAP securely communicated with the snap through its RPC API.
01:30:12.040 - 01:30:47.750, Speaker A: And inside the Snap code, we're using the custom UI feature in order to bring up this dialog. And whether I click Approve or Reject is not going to have any effect in this DAP. But the snap will be able to have access to the response from this dialogue. It will see whether the user has rejected or approved. So if you're building a bitcoin Snap, for example, and the user is about to make a transaction, you're going to want to show them a confirmation. You're going to say, for example, hey, you're about to spend one BTC and you're going to send it to this address. And then they will have the ability to approve or reject it.
01:30:47.750 - 01:31:24.338, Speaker A: And based on that, you can continue the logic and the Asynchronous logic inside your code and decide what you want to do with that. So right now, it doesn't matter whether I click Approve or reject. We don't have a lot of time. So I want to show a little bit the code that's driving what we just looked at. So inside the Snap package, the source directory contains only one code file, index TS. And this is the only file that you need. If you start building a more complex snap, you're going to have modules.
01:31:24.338 - 01:32:10.470, Speaker A: You're going to have all sorts of files in there. But this index TS is going to export some functions that are going to allow MetaMask to interact with your Snap. The one that we're using here is called on RPC request. This function is detected by MetaMask and is called every time that adapt makes an RPC request to your Snap. Very simple. And how does Adapt make an RPC request to your Snap? Well, it has to have the permission for it. Our Snap asks for a permission to be communicated with by websites, and these permissions are located in the Snap manifest JSON file, which is at the root of the snap directory.
01:32:10.470 - 01:32:47.320, Speaker A: As you see, it's not in SRC. It's right at the root here and it contains a bunch of metadata about your Snap. And the permissions are inside this field called initial permissions. So this Snap that you're getting provided with asks for two permissions displaying dialogues and the ability to expose an RPC API that only DApps can communicate with. In this case, snaps are not allowed to communicate with this Snap because this is set to false. Thank you. And so what's in there? Well, in this case it's very simple.
01:32:47.320 - 01:33:24.114, Speaker A: It's a function that receives the origin of the RPC request as well as the request object itself, the JSON RPC request. And in this case, we're doing a very simple switch statement. If the method that comes back is hello, we are then using the Snap global variable to request a dialogue to be printed on the screen. This is the dialog that we saw earlier. It's a confirmation dialog. You can set up the content using these panels, these text elements. We have a copyable field and a lot more coming on the way.
01:33:24.114 - 01:33:54.258, Speaker A: And this is how you set up your Snap. And in this case, we're only returning that value to the DAP that has called us. So this is not very useful in this case. But with the few minutes that I have left, I want to show you something very important that you're going to need as you're starting to develop and debug with your Snap. What's the most common feature that we use for debugging as developers? Console log. Yeah, console log. It's everywhere.
01:33:54.258 - 01:34:42.330, Speaker A: I even have a T shirt with it. So you would think that if you were using a console log inside your Snap that the log would appear in your developer tools right here, but it doesn't. And so with the few minutes that we have left, I just want to show you how to debug your Snap so that you can more easily get started as you're working on our bounties. So I'm just going to change this code a little bit. I'm going to assign the result of this dialog request to a variable. And yeah, the function is sync. And then I'm just going to console log that right here.
01:34:42.330 - 01:35:21.990, Speaker A: And as I do this, if I switch back to my terminal, you will see that those changes are being recompiled immediately using the snaps bundler. And if I go back to the DAP, this is where I have to reconnect to the Snap. Those changes that were just built are not going to be detected by MetaMask right away. So I'm going to reconnect. The permissions haven't changed because I haven't touched the manifest file. And once the installation is complete, now I have the new Snap available to me. So how do I debug it? I just go to manage extension by right clicking on the MetaMask flask icon in my extensions.
01:35:21.990 - 01:35:54.654, Speaker A: And you want to make sure that developer I don't know if I can zoom in on this? Yeah, you want to make sure that Developer Mode is on. If Developer Mode is not on, you're not going to see the debugging option. So make sure Developer Mode is on. And then you're going to get an Inspect Views field here with background HTML. Thank you. And if you click there, it's going to open another Developer Tools, and this one is for the MetaMask extension. So there's going to be a whole bunch of things popping up in there about MetaMask itself and as you interact with the Snap.
01:35:54.654 - 01:36:37.810, Speaker A: For example, if I click Approve here, then I'm going to get an error that says Method Not Found. Well, let's debug that. I don't know what happened, but I did get my console log here, by the way, that says Dialog Result true. And I think the reason why it says Method Not Found is because I haven't returned anything here. So I'm going to just say, Return true. Then I recompile the Snap and that's going to take us towards the end of this presentation. So this time, get the dialog, I click Reject, everything works, and then I get my console log here that says Dialog Result false.
01:36:37.810 - 01:37:18.574, Speaker A: This is about all the time we have, so I wish I could have done a full workshop, but what I'm going to do instead is if you connect to me on social networks, on Twitter specifically, I'm going to be announcing in about a week, I'm going to be coding that live on Twitch. We're going to do a full session of coding a Snap from start to finish. I know it's not going to help you with this current hackathon, but we have a MetaMask booth. If you go all the way to the end and all the way to the corner, you can't miss it. It's right in the corner. It's a big white booth. And I'm going to be there most of the time to answer all your Snap's questions to help you with your Snap, whether it's validating your use case or debugging it with you.
01:37:18.574 - 01:39:43.120, Speaker A: And I think I'm out of time. So I want to thank you very much for joining us today. I hope you're going to be successful developing your Snaps, and I'll see you at the conference. Can you change it or do I need to press button? Do it. So. Hello. Eat global.
01:39:43.120 - 01:40:42.740, Speaker A: We are Sinu and Hendrik from the TLS Notary Team, which is part of the Privacy and Scaling Solutions from the Ethereum Foundation. So first I'm going to introduce you TLS Notary, show you why we build it, how it works, and then Sinu will give a demo of how you can use it for your projects. So first, why do we build TLS? NoTree? So I assume everybody knows what TLS is. The transport layer security. So it allows for a secure way for Alice to get data from a web server. And TLS guarantees that the data indeed originates from the origin and that the data was not tampered with so that the data is authentic. But what TLS does not help you with is make that data portable so you can share it with somebody else.
01:40:42.740 - 01:41:21.936, Speaker A: And so that's where TLS notary steps in. So TLS Notary gives you a way to make your data portable and also use your data with a third party. So this is more or less what TLS Notary looks like. So the magic sauce is that we introduce multiparty computation. So before we go move further, no confusion here, so it's not man in the middle. So it's not that the verifier of Bob gets in the middle. No, instead, multiparty computation, alice and Bob have to work together.
01:41:21.936 - 01:42:17.190, Speaker A: They each have a key share to communicate with the server. That way Bob knows that Alice follows the protocol and cannot cheat about the content of the data. And at the same time, Alice knows that Bob only sees encrypted information, so that Alice is in full control of what she shares with Bob in a later state. So this is also something very important for TLS Notary is privacy. So TLS notary also supports selective disclosure. So Alice can redact parts from the data before sharing the plaintext data with Bob. And this can also be further enhanced with zero knowledge tools, so that you also can share information about redacted parts in a way that Bob only knows statements about it instead of seeing the actual text.
01:42:17.190 - 01:43:24.730, Speaker A: The concept of checking the TLS communication can also be generalized so that you can get generic notaries that check that the data is authentic and in that way Bob only checks the content of the data. But in this scenario, of course, Bob has to trust the notary before he accepts that the data is trustworthy. So that was very quickly, but now the more interesting part, how you can use it for your project. Hi everyone. I'm just going to give a relatively short demo on how to use our project to query a server for some private information and generate a cryptographic proof that can be used to selectively disclose a discord DM to someone else without revealing the proverbs authentication token when doing so. First, let's hop over to our repo here. So this example is in our repo and you can follow along if you want to.
01:43:24.730 - 01:43:55.264, Speaker A: So it's under Tlsn examples discord and we have a README here for what's going to happen. So yeah, I'm approver. I want to prove to someone that I've received a private DM. I don't want to use OAuth, I don't want this server's help, but nonetheless I want to be able to selectively disclose that I've received a DM to someone else. So here's the Discord web app. I'm logged in already and I received a message for myself here. Hi youth Goldman, New York.
01:43:55.264 - 01:44:31.580, Speaker A: So what I'm going to do to just get the access token here is refresh and I'm going to go into the browser and I'm going to find an API request that contains my authentication token. And you could definitely hijack this account right now if you wanted to once you see this, but please don't do that. So here's my authorization token. So this is what the browser sends along with my request to the Discord server. I'm just going to grab that, I'm going to pull it out into my example here. So we just have an environment variable file here. I've already got my access token loaded into it.
01:44:31.580 - 01:45:03.832, Speaker A: And one more thing that I'm going to need here is the channel ID, or like, the conversation relevant to this message. So I'm trying to prove this message here from me, and the conversation ID is just up here in the URL. So I'm going to generate a cryptographic proof that I received this message and I'm going to show it to someone else. So to do this, we need two different things. So there's going to be the prover and there's going to be a notary. So the notary is going to essentially help me do this. I will just fire that up over here.
01:45:03.832 - 01:45:42.230, Speaker A: So I just started up a notary server. It's kind of generic, it just sits there listening for requests. And on the left side here, here, I'm just going to clear this out. The left side here will be the prover flow. So before I run this, I'm just going to quickly walk through what this actually looks like and how you could modify this to do something more interesting than disclosing a DM message. Essentially, you can query anything on the Internet and generate a cryptographic proof of its authenticity and disclose like portions of it to a Verifier. So any web server that supports TLS and any data that you can think of.
01:45:42.230 - 01:46:33.440, Speaker A: So, yeah, I'm just going to use our approver library here. So, yeah, we're going to connect to Discord and we're going to connect to the local notary that I have running in that other panel there. And we're just going to use basically just generic rust tooling, the hyper library, to construct a request and send it off to Discord server. But what we've done is you're essentially exposed to a generic TLS connection. So from your perspective, you just get this TLS connection, you pass it into the request library, and you can just interact with APIs as you normally would with any other connection. But then afterwards we're going to finalize it and get approved. So, yeah, I'm going to just set up some generic configuration for the prover here and it will connect to the notary.
01:46:33.440 - 01:47:08.476, Speaker A: They'll perform some MPC related setup at the beginning, and then after that, we're going to actually connect to the application server, send off the request, and get the response back. So, yeah, let's walk through that a little bit here. So here I'm just constructing the request. This is. Just the API endpoint for discord's. API? And I'm going to query for this specific conversation and I'm going to pass in like the user agent and auth token that I just pulled out of the browser. Once I do that, it's going to get the response.
01:47:08.476 - 01:47:39.240, Speaker A: I'm just going to print it out and from there we will finalize, I guess, the process with the notary. And from there we essentially do a bunch of finalization of MPC behind the scenes for you. And what you get is this kind of succinct proof of the transcript of all the communications with the server. And then once we get that proof, we can selectively disclose portions of it to a Verifier. So I'll just run it here. You're not really going to see anything interesting, but hopefully it works. This is a live demo.
01:47:39.240 - 01:48:10.818, Speaker A: So I'm querying discord's API right now and done. So yeah, I just connected to a notary. You see an error there? Let's just sweep that under the carpet for a second. It did actually successfully complete. So yeah, now it's saved this JSON file here. This is essentially just the notarized session. So this contains all the private data of the session as well as a signature from the notary.
01:48:10.818 - 01:49:16.660, Speaker A: And using all this data, you can construct proofs from it. I will go down to the actual proof generation section of this code and you can see that we essentially where's the so we're identifying all the ranges in the TLS transcript that actually contains public data and private data. We need to differentiate between that when it actually commits. So essentially what I've done is just implemented a simple helper function here, but it just looks for the Auth token in the TLS transcript and identifies the ranges in the transcript there. And then we commit to the surrounding data as well as the Auth token itself. And we get a bunch of different commitment IDs from this. And then later when we actually generate our proof down here, we just say, okay, we want to reveal the data that corresponds to only the public ranges and we're going to redact specifically just the auth token from the proof.
01:49:16.660 - 01:49:54.320, Speaker A: So, yeah, it builds the proof and that also just got saved down to a JSON file here. Once again, just a small JSON file that just contains essentially just the proof itself. And then we have another example here is what does the verification process look like for a proof like this? This is just a simple verifier. It just deserializes the proof from the JSON file and it verifies it for you. So it's pretty simple. You essentially just need to provide the notary's public key. So in this situation, we used a notary.
01:49:54.320 - 01:50:48.412, Speaker A: So the Verifier actually does need to trust the notary that the data is authentic. So we pass in this public key and it essentially verifies the server certificate and then it also is going to print out the redacted TLS transcript, run the Verifier and it's done. And I'll just show you the output here so you get the general gist of what just happened. So this is the entire TLS transcript that occurred with the Discord server. So the prover revealed essentially everything except here you can see that the authorization header in the request which would allow you to hijack their session if they had this. This has been redacted out and replaced with X's. So the Verifier here has done a few things.
01:50:48.412 - 01:51:33.250, Speaker A: One, they've verified the identity of the server. They check the server's TLS certificates so they know that this actually came from Discord server. They verified the notary's pub key and in this case, they trust the notary so that they know that the data is authentic. And now you can just parse this data out and I guess your application here could be like a DM Verifier and it would just parse the contents of the server response and say, oh, look, this message was in fact sent to this account at this time and this is the content of it. So again, you can think of replacing this DM flow with basically any information on the Internet. And yeah, that's essentially the demo. I'm glad that it worked for the most part.
01:51:33.250 - 01:52:05.038, Speaker A: So, yeah, you can go to our GitHub repo. We have a couple other examples. We have a Twitter DM example and just some example code for how to set up a notary and such. And then, yes, that's essentially, yeah, our repo, you can find our docs and stuff. Where's the presentation? Here we go. Yeah. So TLS notary.org,
01:52:05.038 - 01:52:38.810, Speaker A: you can find us there and you can also find our docs as well. Great, thank you. Do you have a question? Yes. Did you separate the public and private data after the notary sign? Well, you have to commit to it first. So before the notary gives you the signature, you essentially say, these are the ranges that I'm going to commit to. The notary doesn't see any of the private data, but you still have to identify where it is and then commit to it. Then the notary will sign your commitments and then you can take those commitments over to a Verifier and open specific commitments to the Verifier.
01:52:38.810 - 01:53:04.914, Speaker A: Are there any other questions? I think I only got five more minutes or so. So we do have a prize here. Hackathon. We have five K. Our project is very early stages, so you're going to be pretty brave and ambitious if you're going to try to use our libraries. But we thought that we'd come here and see if anyone has any cool ideas, can just hack on it, see what you can do. And yeah, any kind of application of course, will be super interesting, but any sort of tooling as well.
01:53:04.914 - 01:57:55.026, Speaker A: If you want to build anything that just complements or integrates with the protocol generally, that would be extremely helpful. As well and all right, I think I can end it there. Thanks everyone. Just feel it's. You feel it tonight. Today, so sorry, I'm going to be talking about cartesi is promoting as a layer two and how it's going to help people onboard more developers and how everything comes together in this Linux environment. I guess it's a little bit awkward and strange at first, especially because we are so used to EVM compatibility, solidity and all that good stuff.
01:57:55.026 - 01:58:43.240, Speaker A: But I'm going to show you guys there is something else out there as well. So today I'm going to introduce a little bit on how Cortez rollups work. And then I'm going to show you guys how the interfaces and how to program it for it. And by the end I'm going to show a few examples of things that have been built using Cartesi. So, just as an introduction, this is a small example of a smart contract already using Python inside the Cartesia ecosystem. And it is here to just incentivize you to pay attention to certain aspects of it. By the end of the presentation, I'm going to go back to it and I'm going to explain some of the lines that are more important over here.
01:58:43.240 - 01:59:46.410, Speaker A: So the overview, pretty sure you guys are already familiar with the trilemma and what it means for Ethereum and what it means to the security of blockchain systems. But we all know that we need scalability and we are trying to figure out how to make it work. And here I'm going to show you guys that it is possible to have complex computation and great tooling while developing smart contracts. Only if you introduce back again a very important concept that we are forgetting, an operational system. So how does Cortez make you work? Cortesi is an application specific rollup, so it's an optimistic roll up dedicated to a single DAP. That means that you have the flexibility to change parameters and change how validation might happen depending on what makes sense for your application. But at the same time it means that you can have it as a layer and solution.
01:59:46.410 - 02:00:41.878, Speaker A: So right now the current system is EVM compatible, meaning you can deploy to any EVM execution environment. So it can be a layer two, a layer three, whatever you think it makes sense. And the second part of the solution is the fact that instead of focusing on the EVM itself as an execution environment or WASM or something like that, cartesian focused on bringing RISC Five to the fold. And what we did is create this machine emulator that is deterministic. And because the instruction set of RISC Five is very complete, it means that you can use any OS on top of it. And therefore we chose to go with the Linux, of course. So how does it feel? Right, it feels like for all these years we've been playing with Pliers to make things work in the blockchain ecosystem.
02:00:41.878 - 02:01:31.610, Speaker A: And when you try to use Cartesi, it feels like you have the hole to set back. So it really improves the experience of developing applications. And this is how it looks like to actually be building your application. It's just a system of docker containers that builds up to be the Cortesi node that you're going to develop for your application. Meaning that you can just use any language, use any tooling, any of these things that we are used to have. So if you think it's interesting to have a postgres database inside, you can have it. If you think it's interesting to have a redis or to import frameworks such as OpenCV or large language models, we've seen examples doing that.
02:01:31.610 - 02:02:33.470, Speaker A: And as long as you can properly build your docker machine, you're fine. So that's what it means, right? It becomes very sexy. You can even import that one star repo that for some reason you're just so eager to. So to be fair and display a little bit how it feels, I'm going to be very generous to the Ethereum network and let's go with 30 million milligraphs of block size, which is already not ideal. And if we take just the addition of code, which is the lease that does something, you can have about 10 million instructions per block, right? And this is what it takes to boot Linux. It takes 3.6 million CPU cycles to boot it.
02:02:33.470 - 02:03:13.020, Speaker A: So it would never really be feasible, even interesting, to have Linux on top of Ethereum network. It's comparing apples to oranges, right? It does not make sense. They have different goals. And within 13 seconds, just to maintain some comparison, which is the block time on the Ethereum network, on a laptop such as this one, you can have 36 billion instruction cycles run. So that's a lot. That's a lot. Correction, guys.
02:03:13.020 - 02:03:56.758, Speaker A: 3,000,000,003.6 billion. And that's how it looks like. That little black dot over there, it's the scale of what Ethereum does in 13 seconds compared to a single laptop running a Cartesi node for your application. So the roll ups themselves, how the architecture looks for people who are familiar with rollaps, there's nothing new here. It's more for people who are trying to understand what it means to build a DAP using a app chain or application specific rollout. So here you have a browser representing some kind of UI and interactions of the user.
02:03:56.758 - 02:04:55.610, Speaker A: You're still going to be sending transactions to your base layer represented by Ethereum over here. And this Cartesi rollout framework, it really is the node with some other services that make it feasible and convenient to use, such as reading information for an Ethereum chain. But what you're going to be building is this Cartesian machine block inside and we package it already ready to use with a Http API that will be convenient to make inputs and outputs to the base layer. And the DAP backend little box is what you're going to be coding. So you can code it in Python in C sharp C, you can code in Brainfuck. You can use whatever really, as long as you can do, get and post requests to this API. It's going to handle the communication side of things.
02:04:55.610 - 02:05:19.362, Speaker A: So it really is a sandbox environment. And as you build it, it can put anything inside. But as long as you remind yourself that it needs to be self contained, it can run on cartesi. So, back to the code. I show you guys in the beginning. So this is a very simple smart contract. It's not smart at all, actually.
02:05:19.362 - 02:05:53.658, Speaker A: It's an echo Python example. What it does is whatever it receives as information, just plain text messages. It replies back using one of the output methods. So if it is a read only request, just like RPC call, you can recreate this report. Such they're kind of like logs, and if you have actual transactions, they're changing transactions. You can create these notices. And notices are kind of like ethereum events.
02:05:53.658 - 02:06:36.614, Speaker A: They have a merkel proof attached to it. So you can go back to the base layer and actually do something about this information. Finally not represented here there is the concept of Vouchers. And Vouchers are transactions that will be able to be executed in the future. So you go on throughout the settlement period, execution period of your roll up, creating these Vouchers. After you settle, they become executable because you have merkel proofs attached to it. So going back here, you can see on lines 18 to 20 that I'm declaring some high level handlers.
02:06:36.614 - 02:07:12.178, Speaker A: These are the basic handlers every cortez application should have. You can create many more just as routes in an API. And these two high levels are the ones that I was talking about before. One is for read only requests, the other one is for transactional requests, the read only. It's really interesting because the node manages snapshots of the machine. So if you try to change anything on the application, it's not going to be saved. The machine continues pristine from the last transactional request.
02:07:12.178 - 02:08:12.646, Speaker A: The same is true if you reject the input. So because of the way EVM works, and it's interesting in blockchain systems that you'll be able to handle, let's say, weird corner case scenarios. So you always have the ability to throw in solidity right and reject the input and still maintain the pristine state of your smart contract. Here is the same. After handling a transaction, it can send a reject response for the input and the machine is going to be reverted back as if it never processed the transaction in the first place. So the idea here is to enable the DApps that we've been developed to be further decentralized, not necessarily needing to rely on off chain computation or data sources and things like that. Also to have a faster development cycle and more concise and comprehensive.
02:08:12.646 - 02:09:16.734, Speaker A: By expressing more complex logics, by having the ability to import libraries and frameworks that many people have been building for so long, you have the ability to have extra processing power so you can think again that you can use loops even, and things like that. And you can leverage the traditional stacks because sometimes they're just nicer to use. And finally, as you're developing a new project, you got to know that eventually your project might need new developers. And there is a very small pool of developers on web3 right now, but it's easier to onboard web two developers if you have a framework where they can use the language they already know how to code with about the POCs. So at East Lisbon, east Global Lisbon. We had this hackathon winner change. EPT this person was concerned about the open source large language models and what the influence large companies can have on them.
02:09:16.734 - 02:10:18.126, Speaker A: And she just used a simple example. But what if Coca Cola managed to mess up with the responses of the model? And suddenly you have like ten year olds questioning like, what is a healthy drink? And Coca Cola is like the first response. How do you prove it? If it's basically a random, in essence, right? Are you going to do some statistical analysis? How do you prove it replied to your children? That kind of response. So she was like, okay, but if you run the inference in such an environment where you have validation process, you can prove that at that exact moment the response was such. So what she did was she imported the Paka model inside a Cartesi machine and ran an example showcasing the power of it. And the second one is kind of funny. Basically there is these systems where you can clock in and clock out of factories or government institutions using fingerprint.
02:10:18.126 - 02:11:25.942, Speaker A: And in Brazil, people are pretty good at hacking this thing between silicon fingers and just bribing the person next to the machine. It's not really reliable at all. So this guy who was just trying to understand how Cartesi works, thought it was going to be an interesting experiment to create such an application. He used OpenCV inside a machine to do the recognition of the fingerprint itself. And at the same time he used a machine learning model that he built to check against forgery and spoofing. So with these two models running alongside, people can scan the fingerprints and I guess optimally in a more private setting, send this information and be auditable. If you guys want to know a little bit more about other examples, other projects that have been built using Cartesi, even games, we have a bunch of games being built with Cartesi roll ups.
02:11:25.942 - 02:12:10.754, Speaker A: You can check rolluplab IO. People are sending their projects there. And also for this hackathon, we have such a distribution of prizes, we are tracked here. We're going to be throughout the whole weekend helping whoever's trying to build using Cortezi. Finally, pretty soon we are going to be launching a main net, a honeypot DAP. The idea here is to showcase the security of the roll up. So the foundation is going to be depositing some amount of money, periodically increasing the amount of value locked just to ensure, just to give insurance to people that there is something out there with a lot of money value locked.
02:12:10.754 - 02:13:00.600, Speaker A: And nobody was able to hack it. So they're actually inviting hackers and security experts, white hats, auto hats, to just try and steal this money. I'd say this is the end of this presentation. However, I have one more thing for you guys. So it happened a while back. Some guy was just rolling on Twitter asking what if EVM, if EVM in Ethereum is the global computer, why haven't we seen Doom running on it, right? And Eduardo, by the way, is he here? I thought he was here. He came here for a second, guys, you're going to see him around.
02:13:00.600 - 02:13:34.980, Speaker A: He just said like, fuck. It took a weekend and he put a Doom to the Cortesi machine. So this is actually running right now. You can stop by our booth and play a little bit with it. And the idea here is just showcase that even a freaking source code that is like 30 plus years old can be built and compiled and run without major efforts on top of such an execution environment. Now, yes, I'm open for questioning. Any doubts? Okay.
02:13:34.980 - 02:14:24.420, Speaker A: Cross chain messaging? Yeah, with sorry. So is there any way to like read so he's asking if there is any way to read the state of networks within the Cartesian machine, but more specifically, you're looking for cross chain stuff, right? Yeah. Okay. So yes and no. So the roll up itself is attached to some base layer so you can read the state from there. Of course, mostly the current state of the SDK is that you just get the messages that are coming towards the roll ups. But the idea is to have something like pre image.
02:14:24.420 - 02:15:04.676, Speaker A: We are calling actually the hashing device, where you can have a device inside a Linux machine where you can send it to it any hash related to the base layer and receive as a response the actual data. Because you have a proof for it. It's possible to do a verification game, a dispute game later on. So you can read from the base layer you attach to, but from others. There is no current solution under development. Any others? I hope to see you guys around. We are here throughout the whole weekend.
02:15:04.676 - 02:17:47.960, Speaker A: I'll be happy to help with any questions, any issues you have while trying to compile anything. Thank you guys. Dam sam. Sam hello everybody. How are you? Good. My name is Herman. I'm developer relations at Safe.
02:17:47.960 - 02:18:41.210, Speaker A: Today I'm going to be talking about developing on the SafeCore Protocol. So, SafeCore Protocol, does anybody know what it is? Can you raise your hand if you have heard of it. Good there, good there, awesome. There are so many questions, many new terms and concepts that were introduced in the SafeCore protocol in the last couple of months. Now I'm going to try to summarize most of them and you tell me at the end. So first of all I will be talking about the Safe Smart account, what it is and how it looks like. Then the SafeCore protocol the same, but also how it is connected with the account.
02:18:41.210 - 02:19:24.884, Speaker A: And also I will be sharing some resources that you may find useful for the hackathon if you are hacking with us. So let's start with the Safe Smart account. The Safe Smart account is a modular account framework. So it's basically an account with Safe. It allows many things, execute transactions, sign transactions, et cetera. But here primarily we are going to be sharing how the functionality can be extended via modules. For example, let's say a recovery module that at some points allows to execute a transaction in the Safe that replace the signers.
02:19:24.884 - 02:20:43.570, Speaker A: So if you lose access to the account, you can recover it later. We also have transaction guards. Transaction guards are logic that can be added when the transactions are executed so they are able to parse the transaction, read the destination, the value, the data and some other parameters and act on that. For example, we could have an allow list guard that has a list of addresses and then if a transaction is executed, this guard would check the destination and if it's not in the list, for example, the transaction would be reverted. And also we have fallback handlers that would allow to add new extra functions to the core contracts. So in case there's a standard introduced that is not natively supported in the account, then you could implement the required functions in this fallback handler, plug in it to the account and then everything would work. So I guess and hope that we all agree that modular smart accounts will fail without three things interoperability, discovery and security.
02:20:43.570 - 02:21:48.150, Speaker A: Interoperability because there is a risk of vendor locking different teams, working on different tools and creating a fragmented ecosystem. Also duplicating work on the same things on tools that are not compatible. Regarding discovery, there's currently no place to find these smart account extensions like the ones we saw before. So there's a lack of distribution and it's difficult for users to see what the market has ready for them. And regarding security, we still need to make sure that the funds of the users are secure and there are no risks. So in the last couple of months, the team at Safe has been working on the SafeCore protocol that tries to fix these three topics I just mentioned. So let's see what the SafeCore protocol is.
02:21:48.150 - 02:22:44.852, Speaker A: It's still in alpha version version 0.1. It's ready for hacking so you can use it this weekend, but it's not production ready yet, so expect changes and things to break. It's also designed to be account agnostic, but for now we are focusing on Safe Account version one, point X, just to make the development processes faster and to add some feedback. It's also open source and right now is the best time for you to provide feedback on the protocol. If you want to give us some ideas, share your pain points, et cetera. Now we are still building on it, so it's the best time for that. So this is what we had for the SafeSmart Account, right? The account in the middle and then different components that are enabled into the account directly.
02:22:44.852 - 02:23:45.656, Speaker A: So the owners of the account need to enable and disable this one by one. What the SafeCore Protocol introduces is a manager. This manager would be another smart account, sorry, another smart contract that will be placed in the middle of the account and all these modules, it will be orchestrating all the flows as well. This manager, like the Safe Protocol Manager, will also have access to some registries. We have an implementation for the Safe protocol manager and a Safe protocol registry. And this registry will be owned by maybe a person, maybe a company, maybe a Dao, ideally. And the owners of registries will be in charge of adding different modules there and setting the requirements for these additions.
02:23:45.656 - 02:24:53.170, Speaker A: For example, as an owner of a registry I can say okay, in order to list some modules there, they must be audited and blah, blah, blah, different criteria that they need to meet. And finally we have the modules. Modules can be of different types and now there will be a relation between these new ones and the ones we saw before that were enabling the account directly. So first of all we have plugins like the Recovery plugin. If you remember there was a recovery module that was connected to the account directly and here as a plugin, the functionality of this Recovery plugin will be the same. But plugins need to implement an interface that allows them to work with the manager. So not directly with the account, but they should be listed in a registry and then the manager will check that they are in the registry and they will connect it to the account.
02:24:53.170 - 02:25:40.960, Speaker A: Same happened for hooks. Hooks are very similar to the transaction guards we have. So for example, we can have an allow list hook, they will also work with the manager and can be added to registries. We also have the function handlers that will work very similarly as the fallback handler that you saw before. We also have Signature validators and in the future many more kind of modules can exist. So let's see now just focusing on a plugin, how to add a plugin to a registry, how to enable a plugin into an account and how to execute a transaction via a plugin. So let's start with adding the plugin to a registry.
02:25:40.960 - 02:27:13.944, Speaker A: We see the four main components here and to add a plugin in the registry, it is the owner of the registry, the one who should call a method add module to the registry and that's it. It's more bureaucratic for the owner of the plugin because they need to meet the requirements the owner of the registry defines. But technically it's as simple as this once a plugin is added to a registry, we can see how to enable this plugin into an account as a user of an account. So for that, if we have our own account, we need to execute a transaction that calls the manager and in this call we are calling the function enable plugin, passing the plugin address we want to enable and also a boolean variable that is called allowed root access. What is root access? Well, we have defined two different levels of access of permission for plugins, for modules and depending on if a plugin has root access or not, they will be able to execute certain transactions. Let's say a plugin does not have root access. This means they cannot execute delegate calls and they cannot execute transactions where the destination is the manager or the safe.
02:27:13.944 - 02:28:36.330, Speaker A: Why is that? Because if they were able to execute transactions where the destination is the manager or the safe, they would be able from a plugin to add new signers in the account or remove some signers from the account, and also in the manager, they would be able to add more plugins or remove some plugins. So these kind of actions, we are just restricting them for plugins who have root access, in the future this can be also be more granular, but for now it is like a boolean. Once we tell the manager that we want to add a plugin with a certain permission, the manager will call the registry that is attached to this manager and will check if the plugin exists there. If that is correct, then the manager will ask the plugin hey, do you require root access or not? And then at the end of this flow, the manager will store in the storage, okay, this save or this account has enabled this plugin with this kind of permission. So that's it. Now we just need to know how to execute a transaction from a plugin. So let's see that.
02:28:36.330 - 02:29:27.796, Speaker A: Now the flow starts from the plugin, somebody's calling it a method exec, let's say. And then the plugin, depending on the permission it has, it will call the manager. One of these two functions execute root access or execute transaction. It's clear which one it is, I think, right? And we need to pass two properties, two parameters save and transaction. Save is the account the plugin will be called, where this transaction will be executed and the transaction is the transaction itself, but also some metadata that will provide some context of the plugin and the transaction. So. Now the manager knows what is the account that will be called and what is the transaction that will be executed.
02:29:27.796 - 02:30:38.960, Speaker A: But first it will check that the Safe has that plugin enabled and also that the plugin is added to the registry that is attached to the manager. There are two conditions here in the registry that need to happen. One is that the plugin is added to the registry and the other one is that the plugin is not flagged. And what has been flagged that means that owners can block plugins if there's a vulnerability that is found, for example, the owner of our registry can say okay, from now on this plugin is not usable. So hackers could not exploit the plugin. This is a big advantage compared to enabling the plugins directly into the accounts because when plugins are connected to the accounts directly, it's the responsibility of each owner of the account to disable the plugin before it is exploited. But here is the owner of the registry who can decide to block everything at once just for this plugin.
02:30:38.960 - 02:31:31.440, Speaker A: So then in this flow where we are executing a transaction from the plugin, it is added to the registry, it is usable, it's not blocked. Then the manager will check again what is the kind of permission the plugin requires. We'll check the storage. If it is the same, then the manager will finally tell the account to execute the transaction, calling the function exec transaction from module. So for all of these four components we have defined interfaces. So we are offering a main implementation. But the protocol works with different implementations of these components as long as the interfaces are implemented.
02:31:31.440 - 02:32:46.212, Speaker A: And here, for example, I will be showing the interfaces for the plugin and the manager that are the most useful for you maybe. So the plugin needs to have like a name, a version, a metadata provider so where to find this metadata structure and then also if it requires root access or not. On the manager side, there are two functions you need to implement so the plugin can call them execute transaction and execute root access to say something. Execute transaction allows to batch multiple transactions and execute all of them at once while execute root access just allows to execute one transaction at a time. Also in the manager you can implement more functions that the ones defined in the interface. For example, how to enable plugins, disable plugins, get information from a plugin so you can create the storage. Now some resources you can check regarding the SafeCore protocol.
02:32:46.212 - 02:33:44.030, Speaker A: We have two organizations on GitHub the Safeglobal and then five AF, which is more of well, you will find more experimental things there. So in the first repository, the SafeCore protocol, you can find all the interfaces and the contracts we have implemented like the registry and the manager. Then there are some specs in the second one some diagrams and flows that are useful to understand how it works. You can also find a demo, which is a react application that can be used inside our web app. And you can see a registry with multiple plugins. There you can enable disable them. And also with the metadata, you can link URLs to these plugins so you can open their interface and operate with them.
02:33:44.030 - 02:34:38.792, Speaker A: So the Safe Ecosystem Foundation has $10,000 up for grabs for hackers participating. And we have split this into five K in total for the three best projects building on top of the SafeCore Protocol, integrating or implementing any part of it, and then five K in total for the three best projects working on the SafeCore account abstraction, SDK, integrating at least one of the existing kits we have. You can find us on Twitter at safe. We have some docs discord forum. So thank you very much. I don't know if we have time for questions, otherwise I'll be around. You can find us in the booth.
02:34:38.792 - 02:37:29.262, Speaker A: Also will be available on the discord for the hackathon. So thank you very much. Did you say? Please don't let me drown please don't let me drown please don't let me drown please don't let me drown give me all your life because you're my demon in disguise I learned to love the catch you came in with the walking clothing and I want to die. But your poison a beautiful good I perfect stone a beautiful you need me like you need every. And you want me to save you from me. I know that you try to find his way it's gonna save you it's gonna save you from me I can't see you drown I can't see you I can't see you drown I can't see you drown give me all your life because you're my demon in disguise I learned to love the catch you came in with the walking closing perfect storm a beautiful can everybody hear me? All right, let's get started. I'm Jason Goldberg, founder and CEO of airstack.
02:37:29.262 - 02:38:02.230, Speaker A: And we have my co founder Sarvesh here. And we're going to walk you through the airstack platform in 20 minutes. So, very simple. Top level in airstack is we enable web3 composability. We're the easiest way to grab any type of on chain transaction or data from across the ethereum ecosystem and to plug it into your applications. And so if you look at this query, for instance, that I have here, you'll see how you can use our AI engine a second to write queries. But this is a pretty complex query.
02:38:02.230 - 02:38:33.442, Speaker A: This is asking give me the wallet, address and the ENS of holders of this NFT collection with a very specific NFT collection. Show the NFT image in medium size, return the token ID and the name from metadata. Also show their Farcaster and lens if they have one, in Xmtp. So we are going to just plug this into the airstack AI. And so let's go here into the airstack studio. I'm just going to copy and paste this. And our AI engine actually helps you learn how to write the queries in airstack.
02:38:33.442 - 02:39:28.226, Speaker A: So the airstack AI is trained on all of our APIs and it'll write the GraphQL query for you and then also deliver the response. You can, of course, add more variables to your query and write queries directly, which Sarvesh is going to show you. But what we did here is in a matter of milliseconds, we have, the AI has written a very complex query of here's, a very specific NFT collection. Get me all the holders that empty collection, get me the images for the assets in that NFT collection, which we resize at airstack for you with our CDN. Get me all the details of the holders, including their lens or forecaster ID, if they have one, and whether they have Xmtp or not. So, really quickly, just to show you, these are all the APIs that we have at airstack or all the data points that you can bring back into your queries and response. And you can do all this in a single query and response.
02:39:28.226 - 02:40:10.398, Speaker A: So you don't have to do, say, ping this API and then this API and this API. You can literally just do one API call, get back all this data. So I'll show you two more queries with the AI and then Sarvesh is going to construct some manually and show you the details of how the APIs work. But way to think about it is, with airstack you have every ERC, 27, 20, 111, 55 on ethereum and polygon within seconds of the transaction. Finalizing, you have, ERC, six, five, one, if you're familiar with token bound accounts, 6551. airstack is the only indexer of 6551 you can index up and down the tree. You can even start off with an NFT that, say, several layers below in the tree and say who's the owner of it, get the EO address of it.
02:40:10.398 - 02:41:17.914, Speaker A: So we're also very strong in the areas of social and identity. So Lens Farcaster domains ENS both on chain and off chain ENS, as well as the only way that you can find out if someone has Xmtp. So a lot of apps, specifically almost every major Lens app using airstack to resolve what are basically people's ENS addresses to their FARC sorry, to their Lens name, to their zero X, so that the messages from Xmtb get through and you don't need to know someone's zero X address. Also, we do a lot with NFT market data as well. Let me just show you two more queries really quick in the airstack studio and then service will construct some from scratch. So I'm going to say, for instance, show you how complex you can do these composability. I'm going to do a query that says, show all attendees of ECC Six, which was a few weeks ago in Paris, and their Web Three socials and xmtp and the AI is going to write this query for us.
02:41:17.914 - 02:41:45.822, Speaker A: This is actually a really complex query. The ECC poop is on the Gnosis chain. You have web3. Socials Lens is on polygon, Farcasters on Optimism and off chain. And Farcaster Hubs Xmtp is off chain data and the AI is able to write the query and airstack is able to give you back that response. All in the same response to JSON file, where you see here's one user, their lens name, their lens handle, they have XMP enabled. This person has a lens and a forecaster.
02:41:45.822 - 02:42:17.366, Speaker A: And so you can get all this back in your application very easily. Last one I'll show you is I can also say show all followers of betashhop. This is me. Betashhop lens. And if they have Xmtp and airstack will go and grab my followers. It can be from Lens, can be from Farcaster, can be both. So you can build interoperable applications and also see right away whether the user is messageable through Xmtp.
02:42:17.366 - 02:42:41.988, Speaker A: I'm going to find out whether my name is betashop nine, sorry, on Lens. So we'll generate that again. And so here we have getting all the followers of betashop nine Lens. They have Xmtb enabled. And here you go. So here's all my followers and you can see this person has Xmtb enabled. You can also see their profile name, et cetera.
02:42:41.988 - 02:43:19.392, Speaker A: Last thing I'll show you in my hand to Sarvesh is we have very robust documentation. We have everything from how to do combinations. So like, show me everyone who, let's say, attended this event and this event or has this NFT and this NFT tokens in common. So let's say, do these two users have both owned this token. As I mentioned, 6551 Xmtp Lens, Farcaster Social follows Poop resolving identities, and you can also build very robust recommendation engines with airstack as well. Last thing is, we actually launched today with Xmtp, a number of spam filters. This is all about kind of proof of personhood.
02:43:19.392 - 02:43:52.210, Speaker A: So like knowing, let's say you follow this person on Forecast or Lens, so the message should get through into your primary inbox. Or we know this is a real person because they attended an in person event, or the high probability that you know this person, you both have attended multiple events together, or maybe both have high value NFTs together versus the inverse. This person looks like a likely spammer. So let's avoid them. So you can see all this in our docs, and I'm going to hand to Sarvesh, who's going to walk you through the details of how to build queries in airstack more than I could in the five minute little razzle dazzle I just did. Go ahead. Thank you.
02:43:52.210 - 02:44:13.716, Speaker A: Okay, let's get into it. Okay, so we'll start with the Explorer. As you can see, we have many APIs here. I'll start with a simple one, which is token balances. So in this API you can ask about. You can start from a token address or you can start from a wallet. So from the token address you will get the holders of the token and from the wallet you will find all the balances.
02:44:13.716 - 02:45:06.964, Speaker A: Right, so I'll build a simple query around it. So I'll select the amount and token ID, token type and I'll take the address of the wallet right now in the filter I'll start with an ENS name. So I'll put my name, yeah, and I'll run this query. I'll get all the balances that I have right now in the same query. If I see like I have NFDS and I want to know the images of the NFDS, then I can select the token NFDS. I can go to content value, I can select different sizes of the images, I can run the query again when I get all the different sizes of images. I can also add more details to the same query.
02:45:06.964 - 02:45:52.996, Speaker A: So I can add like the social profiles so I can select the DAP name and the profile name and I can run the same query. So in one query I'm asking the socials as well, along with the balances. Now, in terms of input, like you can start with the ENS and you can also start with a lens profile. So if you have a lens profile you can put a lens handle here and you still get the same response. And if you have a forecaster name then you can put that too. Yeah, and you get the same response. So there are multiple ways to use this API.
02:45:52.996 - 02:46:24.870, Speaker A: The token balances you can build like use cases like token gating around it. The next thing that I want to showcase is around socials if you want to know about the social profile of a wallet. So here we have identity as an input. So you can start with, again, an ENS name or a lens profile or a forecaster name. You can select fields that you are interested in. I'll select a couple of them. So I'll select a DAP name, followers count, following Count and the profile name.
02:46:24.870 - 02:47:31.012, Speaker A: So this query gives me like how many followers I have, how many people I follow. Now in the same query, if I want I can add the list of the followers so I can select the followers and I can add details about the follower. So I'll select the follower address and I want to know, let's say, their social profile so I can select the name and the DAP, right? So in one query I'm able to fetch all the followers for this identity. So this will give me followers across the protocols and I'm able to ask the social profiles they have. If I want, I can add more details to it so I can select the Xmtp if they have Xmtp. So if I have to build an app where I want to reach out to the followers and I want to use Xmtp protocol, I can use this query. Okay, next I want to show about the Poaps.
02:47:31.012 - 02:48:28.690, Speaker A: So I want to know what event particular identity attended, so I can start again with an ENS name and I can select the fields. So I will select some details about the event. So the description of the event, the country where it happened, I can select the image for the event that was used in the Poops event name. Yeah, so I can run this query. So you can see like I attended these events and I able to fetch data around it if I have to ask more details about the people who attended. Right, so you can go again in the addresses and you can ask about their primary domain. So all the data is connected with the wallet address so you can go deeper and ask more questions around it.
02:48:28.690 - 02:49:05.890, Speaker A: So we also have the token NFTs. In the token NFDS you can go very detailed about the metadata and you can query based on the metadata. Like if you want to find certain NFDS with the attributes given attributes. So you want BYC collection and I want all the images, all the NFDS which has background blue. So you can build using this attribute. So you'll go here and you can select the trade type as the background color and you will select the value as blue so you will be able to run those complex filters. Similarly, you have tokens and the balances too.
02:49:05.890 - 02:49:46.504, Speaker A: Yeah, if you are interested into NFT sales data, then you start with the NFT sales transaction API. You can filter based on the token addresses in the token ID and you can query all the sales data it's coming from OpenSea, Blur, looksrayer and wearable. So four marketplaces you can get all the data. So all of these are GraphQL APIs and you can use AI or you can manually build the query and once you have the query, there are multiple ways to use it. The one way is you can hit our GraphQL endpoint and put the query and you'll get the response. We also have like SDKs. So if you are building a front end application, you can use react SDK.
02:49:46.504 - 02:50:38.696, Speaker A: If you are building a backend system, then you can use node JS or Python SDK. We have a detailed examples on the GitHub. How do we use this SDK for all three languages? So, just to show everyone real quick, we have an airstack Explorer which is a good example of how you can build very robust GUIs on top of the airstack APIs without any backend at all. So this is a front end right on top of the airstack. Actually I'll use David and this is a live API call. Did I spell your name right? Hold on. DA W-F-I lens.
02:50:38.696 - 02:51:18.584, Speaker A: There you go. So there's a microphone in the way that's just a live API call and you have David's ERC 720 Ones poops all in one view. You have the social profile, including all the followers. I can click in here, for example, and see everyone that David is following on Farcaster, including whether they have Xmtv lens. I can also drill down on them and see how many of them also have Lens, actually, who he's following on both Farcaster and Lens. And again, this is just live. Like, just ping our APIs in real time and then can even click out and just get the API for that, which opens up the studio where we just were a second ago.
02:51:18.584 - 02:51:28.390, Speaker A: So it's really just that easy to build all sorts of front ends on top of this. You can use the SDKs or you can use the APIs directly, as Sarbas was saying. Any questions?
