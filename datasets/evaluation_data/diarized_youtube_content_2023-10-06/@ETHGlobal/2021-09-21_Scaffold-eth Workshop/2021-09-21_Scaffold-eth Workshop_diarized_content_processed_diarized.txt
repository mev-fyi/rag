00:00:00.570 - 00:00:17.070, Speaker A: Also a proud member of the Build Guild. So joining here with me is the boss himself, Austin Griffith, creator of Scaffold E. And it's great to have the man, the Mythologian here himself. So without further ado, the floor is yours. What's up? Sean on. Thanks a man. Yeah.
00:00:17.070 - 00:00:41.994, Speaker A: Build guild. Good shill. We'll get to the Build Guild here in a little bit. Yeah. If it's cool with everybody, I'm just going to dive in and get going. The goal today is just to put together a kind of speed run through Scaffold ETH. And it's really an ethereum speed run, but I'm kind of focusing on Scaffold ETH to show you builders out there just kind of like how to get started, how to get going.
00:00:41.994 - 00:01:13.950, Speaker A: And then just like, once, you know, solidity, it's a whole tour of duty to learn all the other different intricacies and gotchas about ethereum and building on top of it. I'm watching the chat. Oh, it's probably a YouTube chat, isn't me. Let me see if I can pull that up and mute it just so I can keep an eye on the chat there. Actually, Griffith, we've muted the YouTube. Okay. So there is no chat.
00:01:13.950 - 00:01:30.422, Speaker A: If you want to chat, if you want to talk to me, reach out to at Austin Griffith. I'm Austin Griffith on all the socials. I look like a just let me just start screen get. We'll get right into it. Here we go. Middle roll. Middle roll.
00:01:30.422 - 00:02:03.538, Speaker A: That one's for Sean on. I think we invented that on the NFT show off with a good one. It's funny, I'll see developers out and they'll do like, Yo Gaussic Rip with middle roll. So we definitely memed that into existence on that speed run. Okay, so here we go. This is scaffold ETH. And to zoom right in, it starts off where you get your smart contract over here and you have the front end over here.
00:02:03.538 - 00:02:58.102, Speaker A: And as we make a change to our smart contract and we yarn deploy, that's going to go to our local network and then those artifacts are going to get injected into our front end, and our front end should reload over here and give us that new value with some exclamation points. So this is kind of like the starting point for Scaffold ETH. This is your license to learn. And you can get in here and you can start adding things and start tinkering with Solidity and just get a feel for how Solidity works and then go from there. So the thing I like to show to everyone is the Ethereum dev Speed Run. If you know a web two developer or you're a web two developer just getting into Ethereum or you're a web3 developer, even trying to find your blind spots and go through the tour of duty check out. I'm just going to ETH dev Speed run.
00:02:58.102 - 00:03:19.446, Speaker A: Just tell your developer friends to go speed run. Ethereum. Right. And that Speed Run is important because it's not just about learning the syntax. It's about learning all the interesting gotchas and what ethereum is good at. And what ethereum is not good at. It really starts with just tinkering with Solidity.
00:03:19.446 - 00:03:40.530, Speaker A: You get this Scaffold ETH set up going, and the curriculum starts with just like, go to Solidity by example. You're a smart person. You understand how to code stuff. Or you could write a for loop. You know how to do this. Just get in here to Solidity by example. Look at the first hello world.
00:03:40.530 - 00:04:05.770, Speaker A: Get in here and start looking at primitives and data types, right? And what I mean by just copy and pasting in is you can really just grab something from over here and you can paste it in to Scaffold ETH and you can yarn. Oh, whoops. I don't think I hit save. Here we go. And then you should be able to see that new. So we created an address over here on Weird. The hot reload is not working over here.
00:04:05.770 - 00:04:35.362, Speaker A: There we go. And then our address shows up over here, right? And let's copy this dude's address and paste it in here and hit save. And let's go ahead and deploy that. You're seeing this dev loop that I'm doing here where I'm making small changes over here, and we're seeing in the front end that they reload over there. Okay. So we can kind of tinker and we can test our assumptions and we can try things out, but we can learn the language and we can learn the syntax. And if you've learned a programming language before, this is going to be super simple to pick up.
00:04:35.362 - 00:04:55.594, Speaker A: Solidity is actually a pretty simple language. I mean, you're not diving into assembly and everything. It can get very complicated. But picking it up and getting the basics should be pretty quick. So you've got integers and unsigned integers. And this address that we just posted in, you've got booleans, right? You can imagine. Let's see.
00:04:55.594 - 00:05:15.714, Speaker A: Let's put in a boolean just to see how it works. And save and deploy. So now we should have an address and we should have boo equal true. And let's see. There we go. There's boo equal true. Okay, so I'm just kind of tinkering with the syntax and getting a feel for it and learning how this works.
00:05:15.714 - 00:05:51.034, Speaker A: And that's the start of the Speed Run. Now you'll go through a handful of different topics. You'll learn about mapping, structs, modifiers events, inheritance, payable functions, the fallback function. We can kind of COVID some of these as we go here. But take the time, sit down, take a couple of hours, and really work through this stuff on your own using this setup, this Scaffold ETH setup. So just to back up just a little bit to get Scaffold ETH, you can just type in, let's see, I'm sure you can just Google it and probably the first thing yeah, the first thing is this Scaffold ETH GitHub repo. There we go.
00:05:51.034 - 00:06:08.894, Speaker A: And so there's Scaffold ETH to get it started. You'll clone down Scaffold ETH. Let me see if I can make this a little bigger. You'll clone down scaffold ETH with a Git clone. You'll yarn install and you'll yarn chain. And be careful with yarn. Some people end up using the yarn from Linux.
00:06:08.894 - 00:06:23.346, Speaker A: There's like a Linux command called Yarn. Be careful with that yarn. Make sure you like NPM install G Yarn and get it from NPM. But it's just an NPM drop in replacement. We use it because we have workspaces. We have a couple different things. We have hard hat react.
00:06:23.346 - 00:06:40.906, Speaker A: This kind of brings in a full stack. So we need like the front end and the back end. So we're using Yarn for that. Then Yarn Chain brings up your local blockchain. You'll have a local blockchain running thanks to Hard Hat. And then Yarn Start will fire up your front end. That's what renders this here.
00:06:40.906 - 00:07:10.070, Speaker A: So just follow that repo and you can kind of get in. And there's documentation there's the same kind of learn solidity that I have here in the Speed run. So it should be pretty straightforward and pretty easy to jump into. Okay, so let's just go learn. Let's see what's next. Let's do the set purpose first, right? Let's clean this out. The contract you start with, what was that comment up there? Oh, it was an event.
00:07:10.070 - 00:07:37.774, Speaker A: Okay. The contract you start out with looks just like this. We have this string that we're calling Purpose. So you've got some storage in your smart contract and then you have a function to update that storage location. So then let's go ahead and do something like this. Let's get it deployed and get this whole app back to the starting point and we can get in and start learning the first topic. There we go.
00:07:37.774 - 00:07:57.426, Speaker A: Okay, so scaffold ETH level one. Here we go. Let's try out accounts. We're going to need to learn accounts. So you'll notice that when you land on Scaffold ETH, let me open up an incognito window and let's look at what loads up here. See how I have a different address. 6582.
00:07:57.426 - 00:08:27.198, Speaker A: Let me close that and do that again and bring up another local host. Okay, there we go. We got a new address there, right? And I can just click this and it's just going to give me funds from this instance of Hard Hat that I have running there. See, it gave me some funds. You can also copy your address and paste it into this faucet. Or you can go as far as to pull up this wallet icon down here, paste in your address and send yourself like a bunch of money. Oh, I didn't even have enough.
00:08:27.198 - 00:08:47.494, Speaker A: Okay, let's try that again with a couple less zeros. There we go. Whoa, cool. Awesome. Okay, so we have lots of money there and you've got wallets for each user. So if I go over to this guy and I copy his address and I go over to the wallet, I paste it in, see how you've got the nice blocky preview. Scaffold ETH comes with a ton of components and hooks that are really handy and help you build.
00:08:47.494 - 00:09:11.114, Speaker A: Then let's go ahead and send that dude $10,000. Wow. Notice that these burner wallets aren't prompting us like MetaMask does. These burner wallets that are generated for you on Page load are really great for testing. I can say hello, world here, and I can hit send. And there's no annoying pop ups. There's no checks for chain IDs and nonsense and all that stuff.
00:09:11.114 - 00:09:53.626, Speaker A: It's handled behind the scenes for you. So while you're building, no need to go through that MetaMask stuff until you're getting to the point where you're deploying to a testnet and then you'll want to start logging in with Scaffold or with MetaMask and actually signing those transactions and feeling that, UX, okay, so we've got our accounts figured out. Accounts are basically generated for you on page load. When you land, you've got a burner account. A lot of apps carve that out before they go to production, but it's super easy for testing and figuring out. So then we've got basically this form and I should say, hello, world here to make sure we can do that there, too. Awesome.
00:09:53.626 - 00:10:25.186, Speaker A: Okay, so let's just write a little bit of Solidity just to get kind of a feel for how this could work. A lot of people will do something like they'll set up an ownership pattern. They'll do something like string public owner and they'll set it equal to their front end address. And let's just go ahead and deploy that and make sure it oh, what did I do? Oh, it's not a string public owner, it's an address public owner. Come on. Come on. Griffith all right, there we go.
00:10:25.186 - 00:10:52.310, Speaker A: There we go. There we go. And then over here, we should have this new owner that matches this. Okay, now, probably one of the first most powerful things you'll learn about Solidity is the require statement. Require is not like installing or bringing in an import like you might remember from Node, but it's like an assert we're testing a condition. We're going to require that the message sender equals equals the owner. And if not, we'll say not the owner.
00:10:52.310 - 00:11:28.566, Speaker A: And the message sender is basically whoever's calling this function. What this line does is say, hey, you have to be this address. You basically have to control the private key that goes along with this public address to be able to get in here and do this. If you sign a transaction and it's not from that specific person, then you won't be able to get in here and let's go test that out. So let's go ahead and yarn deploy that and let's go over here and test both the happy path and the sad path. Make sure that only the owner can set the purpose. So the new purpose is fire, fire, fire.
00:11:28.566 - 00:11:50.622, Speaker A: Right? And send. All right, totally works. Great. Then let's bring that incognito window up and come up with our this is our bad guy here. We don't want our bad guy to be able to set the purpose in our contract. So they grab some funds from the faucet and they I don't even know juggler send. Doesn't work.
00:11:50.622 - 00:12:26.474, Speaker A: Not the owner. See, we get that nice message in the front end letting us know that this address is not the owner's address. So that just shows off how that require statement works. It helps you to set some rules so you know who can get in here and who can update the purpose or do whatever you put into this function. Okay. And to zoom in onto that a little bit, let's see, let's go to our speed run and let's go up here. Primitives and data types, but I want to talk about inheritance for a second.
00:12:26.474 - 00:13:01.782, Speaker A: What you'll do as you start building these apps is you'll find that there's this ownership pattern and what you could do is actually bring in ownable, right? Ownable, just like that. So now all of a sudden this is the same where now only the owner can get in. But instead of me writing the code myself, I'm going to inherit it from Openzeppen. I'm not even sure this will compile because I think we have some versions differences. Yeah, exactly. So I would need to put this back to 67. That's definitely what is it? Zero, six, seven.
00:13:01.782 - 00:13:28.718, Speaker A: That's definitely a bug we need to fix in Scaffold ETH. I need to put that in my notes. Okay, cool. So let's go back to the working contract without the ownable that's inheritance. You'll find that you have a ton of different things that you can inherit from Open Zeppelin. If you just go check out the Open Zeppelin contracts. There they are.
00:13:28.718 - 00:13:55.606, Speaker A: And if we go to contracts, there's tons of stuff you can get into specifically like the tokens are really valuable. You see a lot of people using the tokens but I was also using what? Access. And then ownable. There's that ownable if you want to have an owner of your contract. Awesome. Okay, so kind of jumping around but inheritance, that explains how that works. And then let's see.
00:13:55.606 - 00:14:31.166, Speaker A: The best way to really show off a smart contract is this is kind of centralized. What we have here is we have a rule that says only this one owner can get in here and use this function. It'd be better. And it's best to think of Ethereum, like the greatest massive multiplayer created, right? Like you basically are building these vending machines in the sky and anyone can go talk to these vending machines. All they have to have is a little bit of ETH and these vending machines are like censorship resistant. Even if people didn't want you to get to them, you could still get to them. And these things are unstoppable.
00:14:31.166 - 00:15:01.498, Speaker A: Even the person who deploys the vending machine, if they do it correctly, can never stop it. So once we deploy a smart contract, even we can't stop it if we do it correctly. And that's kind of the power here. So this is actually pretty centralized. This is kind of like a little Attestation smart contract where only the owner can get in here and set this purpose. What would be cooler is if we made it more like a vending machine. So I'm going to add payable here and what we'll say is instead of checking the message sender, we're going to check the message value.
00:15:01.498 - 00:15:20.542, Speaker A: So we're going to make sure that the person sends in some money, but we're going to let anybody get in here. So anybody can get in here as long as they pay 0.1 Ether. And we'll say not enough. I'm just going to leave it like that. I like it. Happy accidents.
00:15:20.542 - 00:15:44.250, Speaker A: All right, here we go. Here we go. Now we're going to compile and deploy that and our front end should reload. And now we'll notice that this front end has auto adapted. Your front end will auto adapt with all your changes in the smart contract. Now, there's a new transaction value here. So if I say, hello, world, what I have to do here is I have to pay 0.1
00:15:44.250 - 00:16:14.946, Speaker A: Ether and I have to hit this little ten to the 18. And this is here for the developer. When you build your app and scaffold ETH, you obviously won't make people multiply it by ten to the 18 to take it from way to ETH or from ETH to way. But it's here for developers to learn and be clear that that's what they're doing when they're interacting with this contract. And we can zoom in on that just real quick. Basically, that 0.1 Ether is the exact same thing as saying that.
00:16:14.946 - 00:16:34.982, Speaker A: So I can say either one of these. But for humans, we want to read it as a decimal. It's easy for us to see, right? But the machines, the EVM is a simple machine. It doesn't want to f around with floating point math. So you have all whole numbers. And we have this trick where we divide or multiply by ten to the 18. So we kind of mimic having decimals.
00:16:34.982 - 00:16:57.646, Speaker A: So we've got 0.1 Ether over there. We've got this here. Are we ready to pay? Let's see what happens. I'm going to send this transaction and sure enough, I was able to update the purpose and pay a little bit of money. Right, let's go be that attacker again and let's have that same experience. We'll grab some money from the faucet, we'll say, hey, and we'll send in zero point.
00:16:57.646 - 00:17:22.874, Speaker A: I'm going to send in a little bit less just to prove that this doesn't work. This should yell at us and say, not earned enough. And then we add one more zero and we send it again and it works. Hey, so we were able to kind of test that line, make sure it works. Something really interesting has happened here with our smart contract. Though it has received value, it now has value in it. It itself is a player in this massive multiplayer game.
00:17:22.874 - 00:18:02.262, Speaker A: Your vending machine is starting to accrue money. But oh, no, we didn't put in a withdraw statement, right? So if we get in here and maybe make some kind of function, we're going to grab that require statement. We'll have a withdraw function that will require that the message sender again is equal to the owner, back to the first require statement that we had. And then we'll do something like, oh, we need to do a call. Okay, here's a little gotcha with another gotcha with ethereum. I'm going to go to solidity by example. There is a call and a transfer function.
00:18:02.262 - 00:18:29.040, Speaker A: You can do a call or a transfer on any address. So like this owner here, I have this address. It actually needs to be payable, but you can say address send. And you can send money to it or address transfer and transfer money. But that's not the best way to do it. The best way to do it is actually this janky way because of how gas limits are handled. What you want to do is actually do this right here.
00:18:29.040 - 00:18:52.662, Speaker A: Okay. That right there. Okay. And we bring this in and we don't need that. And we want to send okay, so how much do we want to send? Gas I'm not going to worry about. And this whole thing can go away and it can just be okay. What an ugly line.
00:18:52.662 - 00:19:23.486, Speaker A: But we also want to then require success and we'll say something like failed. Okay, so here we go. What I need to do is value, though. How much value do I want to send? What I want to send is it's going to be address this balance. What a weird line. But basically it takes this, the smart contract, turns it into an address and then gets the balance from it. So hopefully if I wrote this right, I'm not sure I did this.
00:19:23.486 - 00:19:44.118, Speaker A: Should actually this withdraws me? Let's see. Let's go try to compile it, see what the problems are and go from there. Addr is not the way I want to go. We want to go message sender. We want to send it back to the message sender. So this would be the two address. Actually, this could be the owner too, right? Either one owner call.
00:19:44.118 - 00:20:01.660, Speaker A: It's clearer when we say owner, because then we make sure the owner is the sender and then we send to the owner. Let's try again. Let's try again. Here we go. All right. There we go. It looks like it did and let's double check it, right? Let's reload this thing.
00:20:01.660 - 00:20:18.526, Speaker A: Let's set the purpose with this guy. Hey, can I hit send? Did it go? That was kind of weird how I did that. Let's try again. Hey, transaction value 0.1. Boom, boom. There we go. We paid in notice.
00:20:18.526 - 00:20:38.594, Speaker A: We have this new withdraw thing. There we go. So the contract has 0.1 in it, and if this guy tries to withdraw, it says not the owner. So he's able to send in what he's not able to withdraw. Right? And we should see that that contract is getting value over here and the purpose is set. But now we should be able to withdraw.
00:20:38.594 - 00:21:03.646, Speaker A: We're only going to get a little bit. What is it? Three, two, one. If we withdraw, then we have three, two, three. There we go. So we had to pay some gas for that, but basically we were able to build a little vending machine, put some rules in it that say we're going to track some purpose. We're going to have a function that lets someone update that purpose. And then we were able to build a withdraw function that says if the owner gets in here and wants to withdraw, they can pull those funds out.
00:21:03.646 - 00:21:35.446, Speaker A: So that is a very quick speed run through, just like getting started with Scaffold ETH. And now I'd like to do kind of more of just kind of a talk through of where to go from here. Okay. So once you get to this point, this really is like your license to learn. You're able to go to solidity by example, right? Let's pull that up and you're able to let's see. The next thing on the list is mappings, right on the list of the speed run. So we did primitives and data types here's.
00:21:35.446 - 00:21:55.874, Speaker A: Mapping. You're able to go here. You're able to copy and paste this. You're able to bring it into here, hit save and deploy. And then your map shows up over in your front end and you're able to do that over and over again and just kind of iterate on learning the language. There we go. Also, I need to put that on my list.
00:21:55.874 - 00:22:21.974, Speaker A: Not hot reloading. Okay, cool. And if we have a mapping, basically what a mapping does is it says some primitive data type is mapped to another primitive data type, right. Or something else. It could be a mapping to a mapping to a struct or something like that. What we have here is an address mapped to a UN, which the best way to say that is this is a balance, isn't it? Yeah. Okay, we got a balance.
00:22:21.974 - 00:22:42.414, Speaker A: And then what could we do? We could maybe set up a constructor. Where the balance? Let's bring the owner up here. Wait, it didn't need to be moved around. Just makes more sense. But if I say the owner, we're going to set the balance of the owner to 100. Okay. Let's go ahead and yarn deploy that.
00:22:42.414 - 00:23:26.190, Speaker A: So we're going to keep track of this balance mapping where any address has some number associated with it. And then for the owner, we're going to set their balance to 100. And so when we reload this and we go ask it, what is the balance of this? Dude, it's 100 cool, right? It's like, okay, well, maybe we should create like, I don't know, like a function called transfer that has an address two and a UN 256 amount. And you'll notice this UN and the UN 256, those are the same thing. This can be a UN eight and that's using eight bits. But a UN 256 is the same thing as UN. It's just cooler to have the 256 there because it's clearer what's going on.
00:23:26.190 - 00:24:09.340, Speaker A: Okay. And then the amount and then we'll make it public. And what happens, what happens when someone tries to transfer? Well, what we do is we say, well, the balance of the from address would be like message sender, right? That's the one calling in is going to minus equal the amount and the balance of the to address is going to plus equal the amount. Right. We're learning mappings. Okay, but we need one rule here. What's the rule? The rule would be, well, the balance needs to be greater than or equal to the amount or we're going to get some kind of underflow, right? It would go negative, but technically it'd roll all the way around.
00:24:09.340 - 00:24:33.618, Speaker A: Luckily, solidity eight actually blocks for that, so we could probably get away with it. But I feel like we want to be explicit and require that the balance of the message sender has to be greater than or equal to the amount. Or we say something like not enough. Okay, enough. All right, here we go, here we go, here we go, here we go. Save. Deploy that.
00:24:33.618 - 00:24:50.214, Speaker A: What did I do? Save. I think I just like deleted it with a keystroke. Save that. Let's see if it compiles. It might. No, it did not. Oh, no, my machine is empty.
00:24:50.214 - 00:25:05.920, Speaker A: Let's see if I can oh, man. See if I can empty some trash live on the that's a rough one to run into. Okay, let's try it again. Come on. A little bit of space left. A little bit of space left. Here we go.
00:25:05.920 - 00:25:24.402, Speaker A: There's not even enough space to write the artifacts. All right, it did. It deployed. Now let's go test out. If this works, we've got our owner and our owner has some kind of balance of 100, right? So then we open up some other person over here. We're going to run out of space. It's going to happen.
00:25:24.402 - 00:25:40.266, Speaker A: We're going to run out of space. Somewhere along here. Make sure this orange dude has some. So then let's use the transfer function. So our owner has 100, but they want to transfer notice that. Nice blocky preview. They want to transfer maybe 50 over to this guy.
00:25:40.266 - 00:26:05.906, Speaker A: And remember, we're transferring at this point, we're transferring way, not ETH, right? If this was 50 and we took it times ten, that would be 50 ETH. I'm actually just doing 50 way right now and let's go ahead and transfer it. Okay, it worked. So now if I go test this dude's balance, this dude's balance is 50. And what about this dude over here? It's 52. It worked. We were able to send 50 from one side to the other.
00:26:05.906 - 00:26:59.198, Speaker A: And this is basically how a token works, right? You keep some mapping for balances and then you have a transfer function that lets you move those balances from account to account. And all of a sudden you've built a digital currency without all the trouble of setting up that giant decentralized network. And that's kind of the superpower of ethereum is the network is taken care of for you. Your job is to build the rules that that little vending machine will operate on and anyone can get to it and anyone can pay a little ETH to interact with it. We've kind of tinkered with a mapping and if we go back to this, then you'll get into where's that speed run right here, structs. So when you get into structs, you'll create a struct. There's three different ways here to push that struct into an array.
00:26:59.198 - 00:27:44.058, Speaker A: But having a struct and having an array of structs learn through that modifiers make it a little easier to have. Instead of having this require every time where you have this require statement at the top of every function, you can just create a modifier like only named only owner. And then your functions can just have like only owner attached to it. And then it goes up here and it runs this first and then it runs your function. Events. Events are like a cheap way to do events. I'm googling events storage, right? So storing something on chain is super expensive because what happens is when you store that thing, it needs to be accessible by all the other smart contracts and it needs to be stored on behalf of that smart contract.
00:27:44.058 - 00:28:26.010, Speaker A: When I store it, it goes out to all the nodes on the network and they have to store it on here. So this is my ETH two node right here, right? And whenever you store something in a contract, once we get to the merge and everything that will have to be stored right here on my machine. So that value doesn't have to get stored on one machine, it has to get stored on all the machines. So it's pretty expensive to do storage. So there's this other way of doing kind of like on chain storage where your contract can emit an event and that event can be read from the chain and could be used in your front end. So it's a way for front ends or anyone to read from the smart contract. Some value that's stored.
00:28:26.010 - 00:28:56.950, Speaker A: But the gotcha there is other smart contracts can't read other smart contracts events. So if you have one smart contract that needs to say, has this thing happened over here? You need to write that into that other smart contract. So smart contract to smart contract interaction has to happen. Not using events basically, but events are a cheap way to store things and send things. Okay, here we go. Continuing on, inheritance payable functions fallbacks. You will learn those as you get started through this.
00:28:56.950 - 00:29:25.806, Speaker A: So basically the first step, the first 30 minutes of this is just like learning the language. And what you're doing is you're getting up the Dunning Kruger. It's probably over here, it's probably up the Dunning Kruger. And then you're going to have to go down and go through a tour of duty. You have to learn about ethereum and all the gotchas and all the things beyond just learning the language. Kind of what the ecosystem looks like, what it needs, what's good, what's not good, and that's what this is for. This will take you through.
00:29:25.806 - 00:30:14.986, Speaker A: There's tons and tons and tons of example branches in Scaffold ETH. If you just go to the Scaffold ETH repo, you go to branches and then you sort by active, you're going to find so many here challenges commit reveals, bonding curves NFT examples VRF I mean, it goes on forever. So really what you probably want to do, that's a good way to look at the active stuff. But if you're looking to do something specific, you can kind of pull up a branch and just type in kind of what you're looking for, right? So instead of Master, let's say I'm looking to do something NFT based. Holy moly, look at all these NFTs. Are you looking looking for a signature NFT auction? Are you looking for an 1155? Are you looking for a simple SVG NFT? Are you looking for a VRF? NFT. All of these are here and they'll get you dangerously close to the NFT you're thinking about building.
00:30:14.986 - 00:30:45.914, Speaker A: And hopefully you can kind of just extend it a little bit and have a prototype to get it in the hands of your users. All right, so let's see the first example. The first thing you should go through in the speed run, once you've kind of tinkered with solidity and you're pretty good at it. The first example is this simple NFT example. So simple NFT examples built with Scaffold ETH, your smart contracts will all be in the same place. It'll feel like Scaffold ETH, it'll be all the same commands. I think I have it up over here.
00:30:45.914 - 00:31:16.402, Speaker A: Yeah. So here's the simple NFT example and I've yarn installed it already, but let me do a yarn start and that'll take a little bit to come up and let me stop this. Okay, we'll leave this chain running. It's basically the same chain everywhere. And we'll bring this up and that's going to take a little bit. So what are we doing with this simple NFT example? Well, it has us clone it down. It has us yarn install, yarn start, bring up the chain, which we're just going to keep using this chain here.
00:31:16.402 - 00:31:37.050, Speaker A: I'll bring it with me though, just so it's there. We've got our yarn chain and then it's going to have us do a yarn deploy. I think we can actually do that while we wait for the front end to come up. Let's see if this works and what we're deploying. Let's get into that. Let's get into the code. What we're deploying is this smart contract? Nope, it's definitely not that smart.
00:31:37.050 - 00:31:55.600, Speaker A: Wait, get checkout. Simple NFT example. Oh, no. There we go. There we go. We probably need to yarn install now. Okay, now we should have don't save.
00:31:55.600 - 00:32:19.050, Speaker A: There we go. New contract. Okay, so now the contract is a little different. We did some inheritance here. We brought in that ownable like we talked about, but we also brought in some counters and ERC 721 from Open Zeppelin. And there's even a nice little link here that takes you to Open Zeppelin and kind of explains how to build your own 721. And they kind of talk through that.
00:32:19.050 - 00:32:35.502, Speaker A: But it's all built here for you. Yarn start. Okay, so we're going to start it. We've got our chain there. Let's try another yarn deploy. Close that one because I'll use it over here. Localhost 3000.
00:32:35.502 - 00:32:54.386, Speaker A: There we go. We're deploying. Okay, so we just deployed our NFT contract locally. So same thing as the your contract at first. This is the your collectible. So it's all very similar. Once you know Scaffold ETH, you're going to be able to quickly know where to go in all of these branches and understand how to dive in.
00:32:54.386 - 00:33:01.990, Speaker A: But your collectible. Okay, we're ready now. I think it's working. So let's follow that. Let's see if this comes up. There we go. Awesome.
00:33:01.990 - 00:33:18.570, Speaker A: Looks like Scaffold ETH, right? But guess what, it's a simple NFT example. Okay. And we did a yarn chain and that brought that up. We did a yarn deploy and we've deployed our contract tells us to go to the front end. All right. Next thing is it tells us to edit this mint script. Okay, cool.
00:33:18.570 - 00:33:38.414, Speaker A: So this minting script needs some address. You'll notice in the simple NFT example, you don't have to write like any code. This is just getting you context and getting you started. So I'm going to copy our front end address. I'm going to paste it in here and I'm going to do a yarn deploy. And now if I go over and debug these contracts, we're looking for the owner. The owner was that dude.
00:33:38.414 - 00:33:56.418, Speaker A: Oh, this isn't going to change the owner. Whoops, I went too far down a little tangent there. Okay, we've deployed the contract. We're not the owner. The key thing is we put our address in the to address. So the other dude still the owner. The contract is deployed.
00:33:56.418 - 00:34:18.798, Speaker A: We're not worried about that. What I'm doing here is there's a mint script, and it's going to mint to whoever I put in here. So I'm going to have it mint them to this front end address. You probably want to connect your MetaMask and mint them to them if you're doing it on a testnet or something like that. Here we're just local, so I'm just going to have whatever burner wallet I have. And let's see. I am going to try to mint these to that address.
00:34:18.798 - 00:34:50.022, Speaker A: Let's see what happens. Okay, so it looks like it takes yep, there we come. Here come the NFT. So it takes this little buffalo painting of mine, it uploads it to IPFS. You end up having to make a manifest for your NFTs. So an NFT is basically just a token Uri and an owner, it just says, this address owns this NFT. And so what we do here is we have this manifest.
00:34:50.022 - 00:35:27.974, Speaker A: So basically what you own is this manifest. And then there's an image that links to either another image, something else in IPFS, or something on some web server, but that's basically the ownership. You're owning this and it's going to IPFS, and you can read from there and learn more about IPFS. This will talk through it too. But this example is just meant to show you here's what an NFT contract looks like. Here's a minting script that sets you up to mint a bunch of NFTs. And then once you have that, you basically have an NFT front end that let's see.
00:35:27.974 - 00:35:58.222, Speaker A: Let's do that thing where we brought up the second account, right? And let's grab that second account address, and let's send that second account this cool bison. There we go. Now they have it, right? Let's send them another one. Send them another one. Or maybe we want to send it to, like, Vitalik ETH, right? It'll do ENS resolution. It'll look out Vitalik's address and it'll let me send this fish to Vitalik on my local testnet. For some reason, I don't know.
00:35:58.222 - 00:36:32.838, Speaker A: That's what I do, though. Okay, cool. So that's the simple NFT example that shows you how all of these branches of Scaffold ETH are very similar in terms of the setup, the location of things. You've got your hard hat folder, your React app folder, and then some subgraph stuff. And so your front end is just Reactapp app JSX, and your back end is just hard hat. And then your contracts are right there. Right? Then there's some scripts like Deploy and Mint, et cetera.
00:36:32.838 - 00:37:13.574, Speaker A: Okay, so next we are going to move on to the next branch, and that's the next challenge. So if we go to let's see here, theorem dev speedrun. And we go to challenge one is the Staking challenge. Okay, so here we go. The Staking challenge will take you through. And this is the point where you're going to have to write the code yourself, right? At this point, the contract is ready for you, but it's empty and you're going to have to have some knowledge. So this is when it's going to start testing you at this point.
00:37:13.574 - 00:37:44.538, Speaker A: So you'll want to have a pretty good amount of solidity learned, and you'll want to get in and have the context for things. You'll want to go through the simple NFT example. You may even want to extend the simple NFT example to a buyer mint, but then you're ready to go. We've got challenge one. So challenge one is to build a staking contract. It really is like kind of what ethereum is for. I mean, it's for a lot of things and we can come at it from a lot of different angles.
00:37:44.538 - 00:38:37.250, Speaker A: But if we think about a decentralized staking app, what we want to do is figure out how to get a bunch of jerks to be able to coordinate with each other, right? We're scaling up coordination. So with this smart contract, what you need to do is you need to build a contract in which a bunch of jerks can stake in and they don't have to trust each other. All they have to trust is the code in the smart contract and knowing the network is going to only do what that code says. So what we'll do is we'll set up a smart contract and we'll say only, there's a lot of extra writing here. Someone got in here and did some changing around. What we'll do is we'll create a smart contract and we'll set it up so everybody could stake in. And the way it'll work is it'll kind of be like a state machine.
00:38:37.250 - 00:39:00.630, Speaker A: The state machine will be in staking mode, and we'll allow anyone to stake in. And then we'll get to some timestamp. So you'll learn block timestamp. You'll learn man, I'm thrown off by all this writing. It's like way too verbose. I don't know. I don't even know who wrote this.
00:39:00.630 - 00:39:36.914, Speaker A: Okay, anyways, that is another note I will make, and I'll get to that later. Okay, so you've got your staking app like a state machine. You have a mode where you're in staking mode and someone can get in here and stake into their contract. You then get to a block timestamp and you write a rule in your smart contract that says if we're at some block timestamp, then we move that state machine into either deposit mode or continue on. So you'll learn payable functions. You'll learn how to stake into an app. You'll learn how block timestamp works.
00:39:36.914 - 00:40:09.402, Speaker A: You'll make sure all the jerks either get together and coordinate and you move on to the next level, or it flips to withdraw mode. And if you weren't able to get enough staked, then they can withdraw from it. Yeah, unlock mechanism, man, there's about 80% more words than there needs to be here. This has been rewritten by someone. Okay, next challenge two. Okay, challenge two. Once you learn how decentralized staking works, what you'll do is you'll build that smart contract.
00:40:09.402 - 00:40:42.854, Speaker A: A front end will show up for it, and you'll post it. You'll actually deploy an app, and you'll deploy a smart contract, and you'll deploy an app, and you'll post that into a telegram up to other people that are building on Scaffold ETH, and they'll stake into your contract. Challenge two, it's time to move on to the next challenge. What you'll do here is you're going to oh, man, so much text. Wow. Okay, what you'll do here is you will build a token vendor. So you're going to deploy an ERC 20 token.
00:40:42.854 - 00:41:27.634, Speaker A: And once you deploy that ERC 20 token, you're going to deploy a second contract that is a vendor, and those tokens will get locked up in the vendor. So you'll need to learn contract to contract. So in this one, we'll learn how an ERC 20 works, how to make contract to contract interactions, and then at the end down here, 40 pages longer, you'll find that what you need is you'll have an approved pattern somewhere. You'll have an approved pattern where the vendor needs to buy the tokens back. Once those tokens are locked up and you sell those tokens and someone else owns the tokens, you'll need to be able to sell the tokens back to the vendor. And so this is a really strange pattern in Ethereum, and it's a real gotcha. It's something to be learned.
00:41:27.634 - 00:41:57.822, Speaker A: So what you have to do is you have to go to the token contract. You have to approve the vendor contract. Then you have to go to the vendor contract with a second transaction and make your, I would like to sell these tokens. And the tokens are then taken from out of they're taken from you. So the vendor contract goes to the token contract and asks it for your tokens. You get your token, your tokens go to the vendor, and then the vendor does something with them. You'll see, you'll get into this like, oh, man, this is weird.
00:41:57.822 - 00:42:27.002, Speaker A: But it takes two transactions to make that happen. And it's good for you as a builder to understand that approved pattern and understand how that UX is not the best. And you'll experience it. If you're ever on Uniswap, if you swap ETH to a token, it's one transaction. But if you swap that token back to ETH, you have to hit approve. You have to wait for the transaction to finish, then you have to hit send, and it's a two transaction clunky thing. But that's how ERC 20s work, and that's something to be learned for sure.
00:42:27.002 - 00:42:56.520, Speaker A: Okay, now, moving on. Okay, after you've got those first two challenges, you're really kind of about to hit the ground running. You've kind of got a lot of things. If you're stuck on something, this is when you can reach out to me about, okay, what is next, austin, what should I be working on? And I'm probably going to say you should go build a Dex. And it sounds complicated, but it's actually not that bad. This article that I have in the speedrun takes you through what it takes to build a Dex. Oh, no.
00:42:56.520 - 00:43:26.366, Speaker A: Okay, so let's get down to really it comes down to to make a decentralized exchange. You have reserves of both tokens and anyone can come in and kind of swap between those reserves. And whoever provides those reserves has this LP token that represents their reserves. And as you swap, a small fee is left behind. And then when I withdraw my reserves, I get that fee on top of things. So the real key is that price function. Let's see if we can run it down.
00:43:26.366 - 00:43:53.494, Speaker A: Let's just do this. Yeah, there we go. The price function here is there it is. This bad boy right there. So you take that and you paste it into your scalpel ETH and you've got a price function. And then if someone wants to go from one to the other, they'll use that price function to swap. And if you zoom in there, it's basically looking at the output reserves over the input reserves minus what you want.
00:43:53.494 - 00:44:23.166, Speaker A: It figures out the ratio of what you're putting in and taking out versus the reserves that you have. And it gives you if I put one of these in, how many do I get out of the other token? So I'll probably have you go build that. If you finish both the challenges and you're like, hey, Austin, let's get on for a mentorship session. Hey, Austin, I want to go work for another company. Can you connect to me? I'm going to say did you do those first two challenges? I'll probably say did you build a Dex? Go build a dex. It's going to take you an hour or two. With scaffold ETH, you'll have a front end.
00:44:23.166 - 00:44:54.714, Speaker A: You'll be able to swap tokens to ETH within that Dex. Then at that point, let's get on a zoom call and let's talk through kind of your blind spots and let's figure out what's next. But what I can tell you is you'll probably want to make some kind of randomness game, some kind of little dice roll game or something, right? Don't deploy that to mainnet. You'll get me in trouble. Don't do that. But you'll want to set up a dice game, something to learn about randomness, right? Okay. Maybe not a dice game.
00:44:54.714 - 00:45:35.330, Speaker A: How about an NFT with a random trait or something like that? That's much better. But randomness is really hard on a deterministic public blockchain because all those nodes have to come to the same conclusion every time. So you can't just have like one node give you a random number, right? So what do you do? Do you go off chain and get a random number from an oracle do you get a random number using Commit Reveal? What the heck is commit. Reveal. You'll learn here. Go check out this branch and then for that VRF, go check out this branch and then what you'll find is the Oracle problem is another really interesting thing to dive into. Dive into oracles.
00:45:35.330 - 00:46:24.082, Speaker A: Dive into why? Oracles are complicated. Why can't we just have an API over here that's serving up the temperature in Fort Collins and then I can pay out crops if that temperature gets too cold or something like that, right? It's a really complicated problem. Dive in and learn why. Then you'll have a lot of DeFi things, right? There's a bonding curve. So if you want to learn how a bonding curve works, there's swaps, right? That's kind of what we did with that dex but then you can do it. Basically you probably don't want to write your own swap, you probably want to use uniswap and there's tons of other composable components within the space so you can just drop a swap component in from Scaffold ETH and it will back to uniswap. And then there's the lending component, right? DeFi and lending.
00:46:24.082 - 00:47:28.234, Speaker A: Lending was huge for DeFi. Once you can lend a token, then you can do all sorts of really crazy things like shorting tokens and leveraging up and stuff that everything beyond that is, like over my head, but tons of really neat DeFi stuff. And it kind of starts with lending and we have a whole kind of article and episode on how to build Aave into your Scaffold ETH. And it basically kind of like builds in the Aave interface and interaction, but it's in your own Scaffold ETH app. Then we build kind of an ape into Learning branch where we show you how to deploy a contract that leverages up by borrowing and swapping and borrowing and swapping a token. Okay, next gotcha in the world of Ethereum or next interesting thing to discover is signed messages. Now if you've ever seen me tinker around with ETH Build, I use ETH Build all the time to explain to people how all the fundamentals work.
00:47:28.234 - 00:48:28.170, Speaker A: If you have someone that's new to getting into Ethereum that isn't a Web Two developer send them to ETH Build and they can look through things and kind of learn here from the videos. If they're a Web Two developer just tell them to speed run Ethereum, of course, but let's get in here and build some. What I want to do is just build a quick little example of how signed messages work. So you have a key pair, right? And that's a private key and an address and you have some kind of let's see a way to generate that. So as long as this is sufficiently random then this address is not going to be used by anybody else, right? If I picked all zeros here, someone already has that one, right? But if it's sufficiently random, there's enough of these that you can try and try and try until the heat depth of the universe and not find a collision. Right? And so what are these key pairs really, really useful for? Well, they're really good for signing and recovering, right? And what I mean by that is I'm going to take this private key, I'm going to put a message in here like hello world, and I'm going to sign that message. Here's the message and here's the signature.
00:48:28.170 - 00:49:38.470, Speaker A: So this message along with this signature can go across any kind of insecure network, right? And if it gets tampered with, it's not going to recover, it's not going to work. So the only way this is going to end up working is if this is exactly this message and exactly this signature, it's going to recover to the same address. So what that means is I can sign something over on this side and I can send it through all sorts of whatever and if it gets tampered with or messed with, it won't work on the other side. But if everything comes together, someone can use maths to recover that. Sure enough, that dude did sign this message and that's cool for this. But what if this is more like an object, right, where it's more like a two Alice from Bob amount 100, right? All of a sudden now Bob has signed this message going to Alice and everyone on the network can see that it is valid. That's the trick we can have.
00:49:38.470 - 00:50:43.610, Speaker A: Now these transactions that are getting signed, so that's signed messages and being able to sign and recover is kind of a superpower here of the ECDSA signatures. So what you'll do though in this sign and recover is you'll learn about that and you'll learn that you can sign messages and you can send them to someone else and they can recover. And that can be all off chain. And this is called a state channel. You can create a state channel that sort of mostly works off chain, except for there's a smart contract and all of that stuff goes to the smart contract one time to kind of settle up the state channel or something like that. So you can do a lot of really cool stuff with off chain signatures. And just to dance on that a second, if we go to Scaffold ETH and we looked at Sign In with Web Three, there's this really cool branch of Scaffold ETH called Sign in with Web Three where it sets you up with an app where someone connects their wallet and then they sign a message, right? And that goes to a back end server and verifies that that message was correct and posts it up here.
00:50:43.610 - 00:51:30.742, Speaker A: So you can sign and recover messages using this server and you can verify them with the server. So you can do this kind of sign in with Ethereum and by the way. If you go to Austingriffith TV, there's like a live example of this where if you sign a message and prove that you have Ethereum, there's like a video where I chug a beer at the end or something like that. These message signatures are really powerful and you'll learn that in the speed run. And what you'll do, what's really cool is then these sign messages can also be recovered from within the smart contract. And by the way, that's what happens in that last signature of that state channel too. And what happens is not just signing and recovering off chain, but I can sign a message and send it to a smart contract.
00:51:30.742 - 00:52:24.166, Speaker A: And the smart contract can recover the person who sent it, which allows all sorts of things. Like I hint at Meta transactions here, but basically like I sign some kind of call day, I sign some kind of message and I give it to Alice and Alice pays the gas and puts it on chain. And then the smart contract takes that transaction from Alice and looks in there and gets the Meta transaction out and checks to see who signed that. And sure enough, it was. And so the smart contract can say, I don't care who submits it, but whoever signed this Metatransaction, I'm going to do something on their behalf or It absolutely has to be Austin or this couldn't work, or something like that. So that's signed messages, you'll go through that as part of the Speed run and then once you have the signed messages you'll want to do just real quick, you want to look at the applications here. There's so many good applications.
00:52:24.166 - 00:53:21.246, Speaker A: And also hacks like learn how all the hacks work. Just dig through these. It'll give you such a better perspective of how Ethereum works by learning how all those hacks work. But build a multi SIG wallet, build a smart contract that will track transaction data and then have people vote on it. And if three out of the four signers on this multi SIG say yes, then you can execute that transaction and it'll be the smart contract executing it, right? So it's like we have this smart contract and we all vote to buy an NFT. And if three out of four of us vote yes, then the smart contract goes and buys that NFT and now the smart contract owns it, right? We would have to set up a new transaction to go send that thing from within that NFT out of the multi SIG or something like that. Kind of hinting at a Dow, right? Most Dows only need a multi SIG, but eventually you get more complex stuff.
00:53:21.246 - 00:54:04.582, Speaker A: So right in here we've got this multi SIG wallet. And once you've learned that, you're ready for the final project of the multisig, and that is to build a signature based multi SIG. You can build a signature based multi SIG. There's a couple of tricks and some gotchas. It's not that complicated. But once you can do that, I can take your challenges that you've built on Scaveld e, and I can level you up to a handful of places in the ecosystem. Everybody is looking for Web Three developers, but it's so hard to figure out who's actually a Web Three developer because once you get up and up that Dunning Kruger and you learn the language and someone says, can you build a great smart contract? You're like, Heck yes, I can.
00:54:04.582 - 00:54:35.086, Speaker A: Because you think you know everything, but you have to go through this whole speed run, you have to go through all these gotchas. But once you have all of that, then it's going to be really easy to get hired in the space. It's going to be really easy to upgrade to like, now I want to start learning auditing or higher level stuff, or I want to just build my own product. And this will get you dangerously close to doing that. I want to look at maybe like one or two more really interesting examples. Speaking of that multi SIG, I think the Gnosis Safe Starter Kit is one of them. Whoops.
00:54:35.086 - 00:55:02.602, Speaker A: This is the open zeppelin one. Let's see. Gnosis safe starter kit. So what we're seeing is, as I talk to a lot of Dows, they don't need a really expensive, really in depth smart contract for some of the things they need. What they really need is to be able to prototype quickly. They need to be able to still be sufficiently decentralized, but prototype and build something cool. So this Gnosisafe Starter Kit is kind of this really handy thing for this.
00:55:02.602 - 00:56:17.762, Speaker A: Basically, it's a Gnosis safe. It's kind of like a smart contract wallet multisig, right? It's a really complicated multi SIG that does a lot of other cool things. But it's basically a multisig where you have multiple signers, you have some threshold of signers that you need to be able to send something. And that is pretty decentralized, right? If I have 15 signers on that and I have to get eight of them or twelve of them together to be able to make a transaction work, then basically we're voting each time, right? So the Scaffold or the Gnosisafe Starter Kit is saying, hey, build your decentralized experience, build your dow, build your results oracle, build your decentralized app kind of in the front end and with each action, that's really important. Make it be a vote within your multisig. So you're just signing the message to go to the multi SIG. Let's just say using the results Oracle, let's just say we're retroactively public goods, funding some project, and we say, did this project get finished? And we put me and Owalki and Vitalik on a multi SIG, and we put a hundred million dollars in there.
00:56:17.762 - 00:56:59.086, Speaker A: I just got it laying around, I just chuck it in, no big D. And then right there, the front end is not. This complicated multi SIG or anything like that. It's just a website that says, did this thing get completed? And if you're one of us signers, you land on the page and you just have a yes button and a no button, right? You hit the no button and all it does is sign the transaction that says, let's return the money. If you hit the yes button, then it signs a transaction to send the money to whoever it goes to. So it's just a nice way to make a quicker experience that settles to a Gnosis safe without actually having to write a complicated smart contract. So that's one of many different branches.
00:56:59.086 - 00:57:29.050, Speaker A: And once you're doing well and you're contributing a bunch to these branches, check out the Build Guild. And the Build Guild is basically we're a public good. We're a bunch of builders, and we're building generic components using Scaffold ETH. And then I'm streaming ETH using another smart contract we built to all these builders. So each one of these builders can get in and they can withdraw from their stream whenever they turn in. Some work. Let's just go look at this dude's recent work.
00:57:29.050 - 00:57:57.374, Speaker A: We can see that. Oh cool, he has built some stuff. What is it? A conditionally minted NFT. Right. So this dude was like, I'm going to build a Conditional Mint NFT, where I think it's like if you own a specific other NFT, then you can mint a new NFT, right? Handy little prototype, handy little thing to show off. And he got paid from the Build Guild to do that. And then you can even move on to like moonshotcollective space.
00:57:57.374 - 00:58:27.022, Speaker A: And we're doing something similar. We're building generic components, but it's more for the dao space. We're building coordination tools. We just launched like, Tip Party, which is another tool we built. We have a funding tool for coordinating where similar to coordinate, we're able to at project milestones, kind of get everyone together and vote and pay out, depending on how well that project went. Lots of good stuff. Check out Scaffold e.
00:58:27.022 - 00:59:05.446, Speaker A: Check out the speed run. I'll finish with I'm probably like way over time, but no one's kicking me off, so keep talking for a second. I'll finish with if you're a web two developer and you're thinking like, wow, I can't quite get my head around certain things. There's just a lot of gotchas with Ethereum and you kind of have to go through the speed run to really learn what they are. One good example of that is if you're a web two developer and you need, say, some compounding interest to happen once a day, I need this script to run. And you're like, well, I'm a programmer. I'll make a cron job, right? Well, you can't really do cron jobs in smart contracts.
00:59:05.446 - 01:00:03.806, Speaker A: It doesn't really work like that. But you're like, well, wait a minute, I can just build a script on my server and have it, check in and make a transaction every night to my smart contract. But then one day the power goes out or someone attacks or you forget to upgrade it, and then all of a sudden, the compounding interest doesn't happen and your whole DFI protocol falls apart, right? You can't have some centralized server just making that request, right? So the trick is you need to set it up so somehow you incentivize folks to do that, right? So you go into your smart contract and you set your smart contract up. So it says once, only once at midnight, anyone's allowed to check in, right? It's a vending machine. Anyone's allowed to get in here and poke this contract, and I'll pay them $10 to do it. And that's the trick. Like, I'll pay for your gas and an extra $100 on the top of it if you get in here and compound the interest each night for me.
01:00:03.806 - 01:00:37.122, Speaker A: And if you correctly incentivize the network, someone is going to check in. And if you correctly set the rules so only one person per week can do that, then you'll have correctly built a cron job, but on ethereum. So I think that's it. That's just a good example of just like, thinking in terms of Ethereum, thinking how to build a decentralized app. Hit me up. So I was going to share Austin Griffith a long time ago, but let me do it again. I am Austin Griffith on Twitter.
01:00:37.122 - 01:01:23.080, Speaker A: This dude right here, this dude right here, I'm a Lugie right now. I'm at Austin Griffith. Reach out to me on Twitter. Really what I'm going to say is, have you done the speedrun yet? So what you should really do is try to get as far as you can through the speedrun and then reach out to me on Twitter or Telegram, and I'm happy to help. We'll get you in, get you building something, get you kind of just learning how it works. And hopefully if you're providing value and building cool things, we can stream some ETH to you or get you somewhere where someone can support you or get your product launched, right? Get your product or prototype out there into the wild and into the hands of builders, users. Awesome.
01:01:23.080 - 01:01:43.934, Speaker A: Happy Monday. Sean on Andrew. Do I need to do anything else? How we doing on time? Are we good to go? Does anyone have any closing questions? We are good. Awesome. Thank you, guys. Thank you very much. Thank you.
01:01:43.934 - 01:02:53.234, Speaker A: Oh, I see. Someone say, would it make sense to migrate existing projects? There's a really cool way to do that. Since Scaffold E kind of has this smart contract editor, a great way to find out if you want to go to Scaffold E is to just take your smart contract and paste it into Scaffold E, and it'll take you a little bit, probably to get the version numbers and everything, right? But then you yarn deploy and as soon as you do that, once you'll have this whole front end that's already ready to go, that knows everything about your smart contracts and you can tinker with it. So it's like once you get that far, usually you're like, oh, wait, this is actually really easy to migrate. So I would say definitely if you want to find out if you want to migrate to scaffold beef to just try pasting in that smart contract and go from there. Let's see, realistic time span you could complete if you really did it quickly. I could probably complete the speed run in like, a couple of hours, but really it should take you a couple of weeks if you're learning it slow.
01:02:53.234 - 01:03:37.060, Speaker A: I mean, maybe a week. But then you'll do a week of the speed run, and then you'll do a week of maybe building your own projects or extending a few different things. And so within a couple of weeks, I think you can really get up to speed with a lot of things in Ethereum, but there's always, like, blind spots and things like flash bots and mev, and there's always a deeper rabbit hole to go down to. But just like, you can scratch the surface of ethereum in a couple of weeks going through all of these different topics. Awesome. Hopefully there'll be a recording of this. Let's see.
01:03:37.060 - 01:03:48.538, Speaker A: There will be a recording post. Awesome. ETH global. YouTube in a little bit. Dope. Awesome. All right, thank you, guys.
01:03:48.538 - 01:03:59.160, Speaker A: Middle roll, everyone. Thank you, Austin. That was awesome. Signing out, everyone. See Austin on the Internet. See you guys.
