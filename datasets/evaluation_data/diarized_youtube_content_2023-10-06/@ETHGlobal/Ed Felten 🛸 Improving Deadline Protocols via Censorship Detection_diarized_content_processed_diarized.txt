00:00:07.050 - 00:00:48.794, Speaker A: Thanks, everybody. Thanks for your time. I'm sorry I couldn't be there with you in Istanbul or Prague today, but I want to talk about improving deadline protocols via censorship detection. So this is a little bit different to talk about protection as opposed to prevention. But I think it's an important and useful thing to be doing. And the reason is simply that, of course, obviously we'd like to prevent censorship, but even in systems that prevent censorship, the worst case censorship time that you see is longer than you'd like it to be. So Ethereum being a good example, right.
00:00:48.794 - 00:01:31.974, Speaker A: Ethereum has a certain resistance to censorship. And I'll dig into this a little bit. A lot of it repeats earlier talks from today. But in practice, usually on Ethereum, you can get much faster inclusion than the worst case guarantee. So the idea here is that by being able to detect censorship on chain, that it's a chain to be able to detect whether it's being censored, that you can actually make protocols more efficient. But let me talk a little bit more in detail about what I mean by that. So I'm talking here about deadline protocols, and what I mean by a deadline protocol is any protocol that requires parties to act before a deadline.
00:01:31.974 - 00:02:31.680, Speaker A: So a classic example of this is something like an on chain auction, where parties have to submit their bids before a deadline, or some kind of interactive protocol that has some default thing that happens if a party doesn't act or if nobody does anything by a time. Of course, the example that is of most direct interest to me is fraud proofs and optimistic roll ups. Right, where some party might make a claim on Ethereum about what is the correct outcome of execution on arbitrum. And other parties have to respond by a deadline if they think that's wrong. Similarly, the veto in an optimistic side chain kind of design, that's a design that's like an optimistic roll up, except instead of having fraud proofs, you just have some kind of committee veto. In all of these cases, you have some kind of deadline. If a party misses a deadline, then either that party will be disadvantaged or the protocol will not work as well.
00:02:31.680 - 00:03:44.418, Speaker A: So any protocol that assumes an honest party will be able to act before a deadline is a deadline protocol. And these are pretty common, so. Sure. Okay, so that's what we're trying to protect. Okay, so our threat model here is the idea that there's an adversary, and the adversary is targeting some particular deadline protocol, and they want to censor transactions in that targeted deadline protocol. Not necessarily all the transactions in that protocol, but the transactions that are submitted by certain honest parties or certain kinds of transactions, or certain kinds of transactions that will advance the protocol in a way that the adversary doesn't like. So we assume that the adversary will be trying to compromise ethereum, block proposers or block builders, and compromise them either by becoming a proposer or builder at scale, or by paying proposers and builders to behave in a certain way or by attacking them some other way.
00:03:44.418 - 00:04:37.446, Speaker A: So we're going to assume the attacker has some control over some fraction of the proposing or building activity, and the adversary's motive here will be taken as financial gain. That is, the adversary has the idea that they can corrupt the operation of the deadline protocol by using their proposing and building power. And if they can do that, they can get some financial gain within the protocol, or that they can discredit the protocol in order to get financial gain. So in an online auction, they might bid low and then try to keep other bids from getting in. In some kind of an optimistic l two protocol, they might try to put in a false claim about the execution, and then try to censor any attempts to disagree with that and so on. So that's our basic threat model. Okay.
00:04:37.446 - 00:05:26.078, Speaker A: Common responses to this are basically two things. In a low stakes protocol, or in a protocol that's not carefully designed, you might just ignore the issue or make deadlines a little bit longer. Now, that might be a rational thing to do. If the stakes in your protocol are low, you might figure either a, that no attacker is likely to find it worthwhile to attack your protocol in this way, that an attack would be too cumbersome or expensive to do given the low value in a particular protocol. You might also decide that, well, there is a risk of an attack, but we would choose to make our protocol more responsive by having faster deadlines. And that's a good trade off. But in a high stakes protocol, that's really not going to cut it.
00:05:26.078 - 00:06:19.250, Speaker A: And the usual approach in a high stakes protocol is to make the deadline longer than the worst case assumed censorship. And of course, the extreme case of this is something like an optimistic roll up, where on arbitrum and other similar protocols, the deadline for action in the roll up or dispute protocol is conventionally set to seven days, because seven days is the worst case. Assumed censorship attack on Ethereum, that would not trigger some kind of a social response. Why seven days? Well, it's basically a social census, and it's kind of thing that Vitalik and other people say is safe to do in public. And so the worst case, assumed censorship. There is seven days. Obviously, we would like that to be shorter.
00:06:19.250 - 00:07:16.002, Speaker A: But in a protocol like Arbitrum, where an attacker could plausibly steal billions of dollars by carrying out a successful attack of this sort, we really do need to work with the worst case assumed censorship time. Okay, so the key idea in this talk, as I hinted earlier, is that we're going to design an on chain test for censorship on Ethereum with one sided error. And what I mean by that is that the test will say one of two things. It will say either that there has not been significant censorship since sometime, t zero, that's in the recent past, or that maybe there has been censorship. We don't know. Right. And the test is designed to be correct when it says no significant censorship.
00:07:16.002 - 00:07:59.730, Speaker A: Correct in its statistical sense, that we have extremely high statistical confidence that the result is correct. And then the idea is that in a deadline protocol, we can shorten the deadline if and only if the test says no censorship. So we might say, for example, that the deadline in some optimistic roll up is seven days. But if the test says that there's been 3 hours with no significant censorship, then we can declare that 3 hours to be enough. Right. And so it's sort of another form of optimistic protocol. Now, of course, the challenge is, how do we do that? How do we build an on chain test for censorship? It might seem a little paradoxical.
00:07:59.730 - 00:09:00.614, Speaker A: How can the chain know that its input has been censored? In fact, I don't know of any way of any example where it's possible to build a test with one side of the error in the other direction where the chain can know it's been censored. But it turns out it is possible in many cases, to build a test that allows a chain to know that it is not being censored. So let me talk about how to do that in ethereum, just by way of review, because I know earlier speakers have talked about this. And to establish the terminology I'm going to use, we can talk. In censorship attacks and ethereum, there are basically two different levels or strengths. What I'll call weak censorship is an attack against a particular transaction where some block proposers refuse to include the unwanted transactions in their blocks. Strong censorship, which typically, by the way, is applied on top of weak censorship.
00:09:00.614 - 00:10:19.998, Speaker A: The idea is not only to attack particular transactions to try to keep them out, but to attack blocks. So if an unwanted transaction unwanted by the censor is included in a block, then the attacker either refuses to attest to the block with their proposers to try to prevent that block from getting accepted, or if the block does get enough attestations, the attacker will reorg the chain to exclude that block. So, weak censorship, as is pretty well known, as long as some block proposers are not participating in the censorship. But strong censorship has the undesirable feature that if the attacker does control enough of the proposer or builder power, they can sustain a strong censorship attack for a long time. Okay, so, defeating weak censorship, and this is just well known. Again, review and setting up terminology for later. If we suppose that some fraction f of proposers are honest, which means that they build blocks that are not deliberately excluding, or the blocks they propose are not deliberately excluding a transaction.
00:10:19.998 - 00:11:55.358, Speaker A: And we're assuming here that the transaction that is the target of censorship has gas parameters and other characteristics that make the transaction valid, so it could be included, and also that it includes a generous tip so that a rational proposer or builder who's not trying to censor would include it. But suppose some fraction f of proposers are honest in the sense that they're going to build blocks that are not deliberately censoring this targeted transaction. And then if we say, well, let x be the number of honest slots, that is the number of slots in the consensus protocol that are built by honest proposers out of n total slots, then we have this result that says, basically, the probability that the number of honest slots is less than or equal to some number k is this binomial sum. And this is essentially just the formula for flipping a weighted coin, right? We're flipping a weighted coin, which with probability f comes up as honest, and with probability one minus f comes up as dishonest. So this is basic stuff, right? All right, against strong censorship. Again, the assumption is that the attacker, adversary is doing weak censorship, but when the weak censorship fails, they'll somehow suppress the honestly produced block, and we'll assume the adversary, we have to assume the adversary controls enough proposers to do this. So the key observation here that makes the test possible is that the attacker, if they're going to carry out a successful attack, they have to turn every honest slot in the consensus protocol into an empty slot.
00:11:55.358 - 00:12:49.134, Speaker A: A slot that does not include a block in the canonical chain, right? So they can do that either by arranging that there are not enough attestations to the block, or else by reorganating it away. But either way, in the eventual canonical chain, any slot built by an honest proposer will need to be made empty by the adversary in order for the attack to succeed. So then it follows that if the attack was successful. The number of honest slots during the attack time is going to be less than or equal to the number of empty slots, right? Because every honest slot will be empty. But of course some slots might be empty for other reasons. And then of course the other nice thing is that we can measure the number of empty slots on chain over some interval of time. We can look at how the timestamp advances.
00:12:49.134 - 00:13:10.506, Speaker A: Divide that by twelve. That gives us the number of slots. And then of course we can also see how many blocks were added to the canonical chain during that time. Subtract and that gives you the number of empty slots. So we can tell the number of empty slots and that's an upper bound on the number of honest slots. Okay, next step. Now let's go back, say again.
00:13:10.506 - 00:14:47.106, Speaker A: Suppose a fraction of f of proposers are honest and non censoring. And as before, we'll let x be the number of honest slots out of n total slots and we'll let y be the number of empty slots out of the same n total slots. Now we know from the previous slide that x, the honest slots, are less than equal to y the number of empty slots. And so this bound on probabilities follows that the probability that y, the number of empty slots is less than some bound, can't be bigger than the probability that the number of honest slots was less than that bound. And so it follows that if a strong attack has occurred, that we have this equation at the bottom, that the probability that the number of empty slots was less than k, given that an attack has occurred, is upper bounded by this binomial formula, which is just the probability that x is less than or equal to k copied over from the previous slot. So now we have a statistical property that we have this statistical property that will hold if a strong attack has occurred, right? And so now we can say this allows us to build a statistical test of the hypothesis that a successful attack has occurred. So in other words, it says if an attack, we can build a test such that if an attack occurred, that test will detect it with high probability.
00:14:47.106 - 00:15:58.234, Speaker A: So if we can reject the hypothesis that a successful attack occurred at a very high confidence level, very strong confidence level, say p equals ten to the minus six, meaning that the probability that the test would miss an actual attack is less than one in a million. That is, if k slots were missing out of n total slots, and this equation holds, then the test can say that there's no censorship. Okay, so now if we're given values of k, the number of actually empty slots, and the number of slots that elapsed, and an assumed value of f, the fraction of proposers who we assume will behave honestly, then we can actually implement the test. And the way to implement this test is in practice, we'll choose these parameters in advance, and we'll pre compute that summation off chain and then build a simple test that we can do on chain. So, for example, just running the numbers, if we assume 10% honest proposers, we can report no censorship. If at most, 34 out of 688 slots are empty, that's about 2 hours and 18 minutes, 688 slots. Or with the same assumption, we can report no censorship.
00:15:58.234 - 00:16:35.580, Speaker A: If at most four slots out of 225 were empty. That is no more than four empty slots out of 45 minutes. And by the way, these tests would always have passed in the entire history of Ethereum up to now. Well, since the merge, which was the first time that a test like this was possible. All right, now, there's a couple of annoying issues that we need to get past in order to make this real annoying issue. Number one is the adversary gets to know in advance the next few proposers. Worst case, the adversary might know the next 64 proposers, and so they can wait to launch the attack until it knows that all of those will be its friends.
00:16:35.580 - 00:17:21.882, Speaker A: And so we need to tweak the test a little bit. The mitigation here is to just add 64 slots to the end of the test, assuming that there will be no evidence that the attacker can arrange that there will be no empty slots out of the first 64. The second issue is that if the test fails, we'll be tempted to do it again over the following end blocks. But that's actually unsound. That's an example of what, in applied statistics is called p hacking. Basically, that if there's an epsilon chance of failing each time and we do the test over and over until it succeeds, then we don't have an epsilon chance of error. So the mitigation here is if we're going to do up to, let's say, r repetitions, we can do each one to a confidence level of epsilon over r.
00:17:21.882 - 00:18:02.098, Speaker A: Then we'll have overall an epsilon confidence at worst that we ever get it wrong. Or alternatively, we can set a total budget of epsilon and spend that over a set of repetitions, taking advantage of the fact that we probably won't need more than one. Either way, we need to make sure that we don't p hack by trying the test over and over till it succeeds. Okay, next steps here. What can we do for optimistic roll ups? Or optimistic side chains, you can decide on what value of f is safe to assume. I think you could reasonably do the test assuming f is 5% or 2% or 1%. It's kind of a policy decision.
00:18:02.098 - 00:18:32.540, Speaker A: You can then deploy on Ethereum a censorship oracle contract with some wired in values of these parameters, and we've actually built a test version of this on, I forget, either Gorley or sepolia. And then you can update the timeout in your protocol to be adaptive based on the censorship oracle result. And that's it. Thanks everybody. Please, if you have questions, please put them in the chat in the chat room that people are seeing in the event.
