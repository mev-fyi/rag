00:00:00.650 - 00:00:16.480, Speaker A: Thanks so much for taking the time to join us today. It's officially the first week of ETH Online, which is exciting. We have Tom Brand from Starkware who's going to give us an intro on Vidu. So I'll let you take it away Tom.
00:00:17.890 - 00:00:28.086, Speaker B: Thanks. So I will share my screen and hopefully we'll see it. Yeah, you see it, I guess.
00:00:28.188 - 00:00:29.240, Speaker A: Yeah, it's great.
00:00:29.690 - 00:01:09.326, Speaker B: Okay, great. Hi, so hello everybody and thank you very much for joining me today. My name is Tom, I work at Starcore. I'm doing product and research there. And today we're going to discuss, I'm going to present Vidu which is a randomness beacon based on VDFS and Starks. I'll explain a little bit how it works and then we'll see how you can use it and hopefully some of you will decide to build on top of it in the following months. So few words about Starcore.
00:01:09.326 - 00:02:12.210, Speaker B: So we're an Israeli based startup. Our mission is to bring both scalability and privacy to blockchains using zero knowledge proof technology. We're almost 40 team members did two rounds of funding and our first product is Starkx which is a scalability engines for a layer two scalability engine. And it's now live on Mainet since June together with our partners the Diversify, scaling a self custody exchange. So this is about Starquare and before we'll start diving into how Vidu works, the main purpose of Vidu is to generate secure and unbiased randomness. So what do we use randomness for in the blockchain? Ecospace and I guess general speaking. So there are a few applications that come to mind when we think about using randomness in Ethereum or in Blockchains.
00:02:12.210 - 00:03:05.190, Speaker B: The first one is just a lottery application. Assume users wants to buy some tickets and then we need to choose a winner. We want to make sure that the randomness that we're using to pick this winner is a secure randomness. Nice example for this kind of application is pull together which are also participants in It online and we are working closely with them on video. So this is lottery. Another application is proof of Stake protocols or for example Ethereum 2.0. So those protocols, generally speaking, require randomness in order to choose set of validators and also to choose who is eligible to propose a block.
00:03:05.190 - 00:03:46.446, Speaker B: And if this randomness is not secure or if an attacker can buy us this randomness, then the protocol many kinds of attack can be done on the protocols. And indeed east 2.0 is using VDF for randomness in its protocol. Another application which I'll describe shortly is gaming and for example, card meeting. So one of our partners is immutable. One of the things that they allow users to do is to mint cards for gaming applications. Imagine magic.
00:03:46.446 - 00:04:27.042, Speaker B: The gathering. So when I buy a pack of cards, I want to make sure that the randomness which is used to pick what cards I get in this pack is secure and unbiaseable. And that I truly get my chance in winning a Golden Dragon or a Diamond Dragon or whatever I want. So this is for gaming. And those are all applications that are running on Ethereum. They use randomness and they have a need for a better and more secure randomness. Fair swapping is a kind of idea that I hope that some of you will come up with at the end of this month.
00:04:27.042 - 00:05:02.382, Speaker B: And it's not something that I am aware of that is implemented and running. But the idea here is to use randomness in order, for example, to help automated market makers to prevent front running. I think it's very exciting and we are at work on designing such a spec. But I'll be very happy if any one of you choose to work on it. Okay, so this is the motivation for why we need randomness in Ethereum. Now let's dive into what is vidu and how it works. Okay, great.
00:05:02.382 - 00:05:53.360, Speaker B: So it seems a bit intimidating, but we'll pick part by part and you'll understand everything. So this is a high level description of the system. Here you have some off chain service. It can run in the cloud or in any server. And here you add Ethereum blockchain. And the general flow, which we'll explain in a minute, is a user wants to get some randomness, it makes a request to a contract on Ethereum, the off chain service pick the request, generate the randomness and somehow prove to the user that the randomness is secure and correct and the user can use it. Okay? Now, in the next few minutes I will explain the system and after that we'll take the footsteps of Alice and see how we can use this system.
00:05:53.360 - 00:07:04.660, Speaker B: Okay, great. I don't know how we will see answers, but if anyone has questions, I mean, if anyone has any question, feel free to ask at any time. So the first thing we need to understand here is what is exactly a VDF? Again, I will explain everything here very briefly because it's not needed in order to use the system. Feel free to either ask questions or come later to the discord server and we'll be happy to explain in more details. So VDF stands for Verifiable Delay Function and it was firstly introduced in a formal way in a paper last year by Dan Bono, Joseph Bono, Boons and Fish. And basically what it means is we're saying that F is a VDF if it has the following properties. First of all, computing F is slow and second, verifying F is fast.
00:07:04.660 - 00:09:05.478, Speaker B: And maybe to some of you immediately one kind of this function come to mind and it is proof of work, right? It takes a lot of time to find a solution to a proof of work, but it's very easy to verify it. And the question is, can't we just use it? So the answer is no, because we have another property which defines VDF and this is that the time delay that it takes to compute this function is sequential. Why is it important for us that this time is sequential? Because if we know that this computation is sequential and we can lower bound the step of computation, then we can get lower bound on the time of delay that this kind of computation gives us, right? So a VDF is basically a way to verify that a delay has passed and now we will talk about how we achieve it with those two building blocks. So first we'll explain the delay function. I won't get deeply into it, but basically, as we said, what we need from the delay function is that it will be sequential, that it won't be able to do the computation in a parallel way. And what we choose as a delay function for our construction is a well known construction which is basically taking the cube root of x, adding a constant and repeating this computation for t times. And we work with field elements where p is 126 bit prime and to the best of our knowledge, or to the best of the computer science community knowledge, there is a well known lower bound to this computation and it's sequential.
00:09:05.478 - 00:09:57.146, Speaker B: And so we can get a well defined lower bound if we decide what is T. For those of you who wants to get deeper on what is exactly the implementation, you can check the reference implementation here it is in our public repo, which is you can find it at the discord and also at east online. I will post it. There are many details here, but the one thing which is interesting to see is that at the end, the delay function is defined by those nine lines. And you can see that giving some input. We run the same computation, which is a cube square and then some scramble with the multiplication and constants for n iteration times. And then we return x.
00:09:57.146 - 00:10:26.522, Speaker B: This is the delay function. Great, so now I understand the delay function. Feel free to ask any questions about it afterwards. So now we have the delay function. Now we need to understand how we verify it. So for this we have the Stark provers. As I've said, Stark proofs and proof systems in general is the technology that we develop at Starkware.
00:10:26.522 - 00:11:16.066, Speaker B: I will explain it in a nutshell and we will understand how it applies to our construction. So proof system in general is a protocol which you have two players, the prover and the verifier. The prover wants to prove to the verifier that some statement is correct and he's able to generate a proof to it. And the nice properties of this proof is that first of all, the verifier does not need to trust the prover. Simply by verifying the proof it can know if the statement is correct or not. The proof itself is succinct. So if the prover proves some amount of computation the amount of work that the Verifier needs to do is exponentially smaller.
00:11:16.066 - 00:12:18.780, Speaker B: So for example, in our case what we want to verify is the delay function actually was computed correctly. So if we want to run the delay function two to the power of 20 iterations, the Verifier needs to do something on the order of 20 computation steps in order to verify it. So this is proof system descriptions in general. Specifically we are using Stark which is there are many implementations for what I just described. We're using the Stark protocol and here you can see some of its benefits. I won't go into it. But the main things which are relevant to our case is that the verification time itself is very fast and also the proving time, the time it takes to generate a proof is much faster than any other zero knowledge proof systems that we are aware of.
00:12:18.780 - 00:13:41.342, Speaker B: There are other things here, just something interesting, for example is that there's no trusted setup. Some proof systems require trusted setup which helps the trustlessness of the proof systems, but in Starks you don't need it. Okay, so we explained what is the delay function and what is the proof, how is it related to the construction of VDF itself? So the delay function gives us the slow side of computation and the start proof allows us to verify it in a fast way because as we said, the verification is exponentially faster than the computation. Okay, so now we have our construction of a VDF using a delay function in Starks. Now we need to understand how we take this primitive and use it to generate randomness in a secure way, right? So this is what we're going to explain right now. So for this let's go back to our gaming example and let's say I won a match and I got us a price loot box and now I want to open this loot box. But again I want to make sure that the randomness which is used to decide what is included in this loot box is indeed secure and unbiaseable.
00:13:41.342 - 00:14:43.094, Speaker B: So I will have the highest, I have a fair chance to receive my share. The way to do it is that at the moment that we purchase the loot box the randomness is not known and then we initiate the VDF. The first step is to compute the delay function. Let's say for example, that for the amount of iterations that I wanted to run the VDF, it takes about two minutes. Once we generated the output of the delay function, we now need to generate the proof so users on ethereum will be able to verify that this is indeed the randomness. This let's say, takes about half a minute and then once I have the randomness and the proof I can use it to open the loot box knowing that the randomness I used was unbiased or it is secure. Okay, great.
00:14:43.094 - 00:15:58.000, Speaker B: So we understand what is VDF, we understand how we use it to get secure randomness. Now, the missing piece is how we use this construction with actual users. So for this we introduced the notion of vending machine and I will try to explain what is the motivation and how it mean. In our view, it is inevitable to outsource heavy computations off chain. For example, if we would like to take the delay function that is used in our PDF and compute it and do a naive verification on chain, it will cost on the orders of billions of gas just for a simple two minute delay. So we must outsource the computation and have some kind of way to prove that the computation is correct in the same way that I just explained. Now, the question is, how can I do it in a trustless way that both the offchain service which generates the proof know that he will get compensated for it and the user knows that either he will get the result for the request that he asked for or he won't pay.
00:15:58.000 - 00:16:51.440, Speaker B: We propose the vending machine model, which is a user request a result from a computation and log some funds in advance, then some offchain service see this request and post the result and the proof. And if the proof is valid, meaning the result is indeed the correct result of the computation, the off chain service can receive the payment which was locked and if no valid proof was submitted, the user can, after some time lock, reclaim the payment. Okay, great. So now we understand every part of the system. The next step is to show how we use the system itself. But I think it's a good place to ask if anyone has questions. I'm not sure how we will be able to see them.
00:16:51.440 - 00:17:01.620, Speaker B: Maybe it means that there is no questions. Okay, Heather, is there any way I can see questions?
00:17:02.710 - 00:17:09.720, Speaker A: We do have a chat here in this zoom call and there are no questions right now. Derek says no, please continue.
00:17:10.250 - 00:17:46.530, Speaker B: Oh, great. Thanks Derek. Okay, great. So now we take the role of Alice and we want to just receive randomness. Let's say that me and Derek made a bet and the bet was I say that let's take the next block hash and generate a randomness based on the block hash as a seed. I'm saying that it will be even the result and Derek said that it will be OD. Right? So let's see how we do this bet.
00:17:46.530 - 00:18:13.930, Speaker B: Great. So basically all you need to start is GitHub and specifically our public video GitHub. So let's go there. I hope you can see, but this is the public video GitHub. You have here all the contracts which we'll go into in a second. You have here the reference code of the delay function that I've just shown. You can look at it and there's a documentation.
00:18:13.930 - 00:18:42.846, Speaker B: It covers what we just described. If you feel that something is missing here, feel free to ask in the discord and we also will just edit. But let's first look at the contract. As you remember, I go back here. We have two contracts. One is the vending machine and the other one is the Verifier. The Verifier is basically an implementation of the Star protocol on Ethereum.
00:18:42.846 - 00:19:22.298, Speaker B: We won't go into it, but what you need to know is that it holds the delay function statement and it can either reject or accept proofs. Now, let's look a little bit about on the Vending contract. It's not a complicated contract and it has three external functions which you will be able to use. Okay, you can see it here. The first one is the add payment function which basically allows the user to make a request. Right? This is the first step. If a user wants to get randomness, the request is on a specific seed.
00:19:22.298 - 00:20:07.360, Speaker B: For example, what we and Derek wants to understand is the seed is the block hash and N. ITER is the number of iterations that we want the delay function to run. More iterations, mirror more security, but more delay tag is just to allow more flexibility to build wrapper contracts around it. We won't get into it, but it is not get into the computation at all. And the payment amount is how much you are willing to pay. So this is the end function. It stores it and emit an event which we at the off chain service catch and decide if we want to use it or not.
00:20:07.360 - 00:21:06.030, Speaker B: In the case that a request was not served, the user can reclaim the payment if enough time has passed. Since the payment was made, specifically now it is one day. You can see it here. Okay, let's go back here. So this is the reclaimed payment and in case indeed the randomness was not registered and enough time has passed, the user gets back his money and the last function is Register and Collect. So in the happy case that a request was collected and a randomness was generated, the offchain service can call this function Register and Collect and basically register a randomness. As I've said before, the randomness will only be registered if a valid proof was first applied to the Verifier.
00:21:06.030 - 00:21:53.074, Speaker B: Now, where do we check it? We check it exactly. Here we go to the Verifier and check if he has seen approved to this public input. What is this public input? This public input means I've started with this VDF input. I ran for N iterations and I got this VDF output. Okay, if this is indeed valid, I register the randomness and the user can then look at the registered randomness. It's a public mapping and use the randomness for whatever is needed. Okay, was it too fast? I don't see any questions in the chat so we can go.
00:21:53.074 - 00:22:41.630, Speaker B: One thing to note is that this is vending machine ERC 20. So it knows how to receive payments in ERC 20. And when we deploy the contract yes, we define a specific token address. The Vending machine accepts payments only from this address. Great. So now let's go and process our bet. So we go here at the bottom, we look and we see exactly where the Vending contract is deployed.
00:22:41.630 - 00:23:17.370, Speaker B: Note that since it is only deployed on rockstone, we will probably deploy it next week or the next week after it. Maybe next week on Mainet. Currently, we only accept this amount of iterations. This is pretty small and it is mainly for testing purposes. Okay, let's go to the Vending contract. You can see it here. Now, the first thing I want to understand is what tokens does it accept? So I go to the read contract, I see which token address is registered.
00:23:17.370 - 00:23:51.350, Speaker B: Let's open it. Now, what I want to do is basically I want to call the function add payment with the block hash that we'll get from the blockchain in a second. Now, for that I need to have enough payment amount. So let's go just to show you how we're doing it on Robson. So this is a testnet Dai. It's pretty easy, but you first of all mint to yourself. So for that I will connect my wallet.
00:23:51.350 - 00:24:21.150, Speaker B: Let's look at my wallet, which is called hacking at random. And mint, let's say, will be very small, but will be enough. Now let's do approve to this same amount. And we want to approve the contract to be able to take it. So we approve this. This is the vending machine contract. We approve.
00:24:22.870 - 00:24:23.620, Speaker A: It.
00:24:29.030 - 00:25:02.430, Speaker B: Okay, great. Now we have enough funds and we can do add payment, right? So the payment amount is 1 million. The targets, I've said, is not used. It allows you to wrap it with other contracts and they can manage who is calling. But for this example, we won't use it. N ethers, as we've said, is only acceptable right now is this amount and the seed. Let's go to the ethereum and let's take the latest block hash.
00:25:02.430 - 00:25:36.242, Speaker B: Derek, is this good for you? I hope it is. Take the hash, he says. Yeah, okay, thank you. Now, if you notice, we need to convert it to uint. So let's just do it for a second and sorry. Great. So this is the uint of our block hash.
00:25:36.242 - 00:26:15.134, Speaker B: Let's see when we run it and write again. Connect parallel. Okay, great. What happened right now is that we sent a request to the Vending contract. Maybe let's go back here and understand exactly how much time it will take. So the first time it will take is the time the request will get mined on chain. Then we have the time for the off chain service to pick it it's quite immediately.
00:26:15.134 - 00:26:50.800, Speaker B: And then we have the delay function, which is an extra time. Then we have the generation of the proof. And then again we have when the transactions will be accepted back on chain. So we did the first step here. Now this is happening in the background behind me. And then we will get back a randomness and we will see who won. I think while we are waiting, it's a good time to I mean, there's no questions, but it's a good time to ask questions.
00:26:50.800 - 00:27:33.162, Speaker B: If there's nothing, there are a few things that we can still discuss. Okay, so let's see what happens here. So we got the request. You can see the event here. It's add payment. In a few minutes we'll see the event which says the log new randomness. And we will see here the randomness.
00:27:33.162 - 00:27:41.274, Speaker B: This is not it. Just to make sure. Okay. Thanks, Eric.
00:27:41.402 - 00:27:44.490, Speaker A: You're the best number one fan.
00:27:44.650 - 00:28:50.328, Speaker B: Yeah. Okay. It should take probably two and a half minutes, something like that. Okay, two minutes have passed. The provers are generating proofs. And maybe one thing I can discuss is why is it not good enough to use the block hash as randomness? And how using a VDF on top of the block hash adds security to it. So the easiest way to understand it is by looking at the Roulette example.
00:28:50.328 - 00:30:16.100, Speaker B: Right? Let's say that I'm a miner and I did this same bet I had. Now with Derek, I'm saying that the next block hash will be even and he's saying that the next block hash will be odd. Now, if I, as a miner, put some money into this bet, I can immediately, when I mine the block, know if I won or not, and I have the chance to effect on it and either discard a block which is not suitable to the results that I want, or to just try to find another one. What happens here, maybe I will go to the example here. So what happens here is that during all this time that nobody knows this randomness, because we have a lower bound on the time it takes to compute this delay function. The cost to then revert it and either do something else or find another block is then the number of blocks that fits in this delay function. So basically, if we have a delay function of two minutes, it means that we added two minutes of reorg time that is needed to the security of our protocol.
00:30:16.100 - 00:30:50.860, Speaker B: Now, if we know that, I don't know, we are able to reorg one block in few thousands of dollars, reorgang more minutes is exponentially harder. So it's much more harder. Okay, let's go back to our contract. Great. So a new transaction has entered. Now let's look at it. We have the log new randomness and it's OD, right? Let's make sure everybody believes.
00:30:50.860 - 00:31:34.268, Speaker B: Just to make sure I explain what happened. So we have the log new randomness. We see that this is indeed we will only get emitted if a valid proof was submitted. And we see that the seed and the number of iterations corresponds to the request that we made. And then we have here the randomness just to make sure we are so it's even I don't remember what I said, but one of us won. So this is how you use vending machine. And I think it's let's say you won.
00:31:34.268 - 00:32:11.530, Speaker B: Thank you. Great. So let's go back here. I didn't do it through the terminal or stuff like that because I mainly wanted to explain the interface with the vending machine. Now, what can be built on it? Right? I go back to the examples. So the most trivial thing is to build, for example, a lottery application. But we already have examples for it, so it might be not that interesting.
00:32:11.530 - 00:33:01.690, Speaker B: I think that very interesting stuff to do is to use randomness in applications that we have not thought about before. So, for example, using randomness to ensure some fair swapping and preventing front running might be a very interesting direction. I think that also building wrappers around this contract. So, for example, a very simple idea is to build a wrapper that just take the block hash and transfer it as a seed to the vending contract. The Vending contract is general, accept everything. This is the purpose of it. But we can build interface around it which makes it simpler to use.
00:33:01.690 - 00:33:06.490, Speaker B: Yeah, this is basically it.
00:33:08.460 - 00:33:15.820, Speaker A: Tom, there's a question from YouTube from Matt Solomon asking how does VDO compare to chainlink's VRF?
00:33:17.200 - 00:33:40.464, Speaker B: Okay, good question. So, first of all, hi Matt, and thank you for coming technology. I guess this is not the question, right? Because VRF is a verifiable random function which basically allows the user, very simplifying it to compute something using his private.
00:33:40.512 - 00:33:41.110, Speaker A: Key.
00:33:44.520 - 00:34:41.290, Speaker B: Generating a random function using his random key, and then providing proofs to everyone to verify that this is indeed a computation using its public key. But there's no delay here, meaning that the user that generates this VRF knows immediately what is the solution. So, for example, if some operator of an application that, um, uses randomness somehow collude with the VRF provider that he makes a request to, then they can know in advance what will be the solution, since there is no delay here. But it has other benefits, right? It has less just in my opinion, the security is lesser. Does this answer the question?
00:34:42.540 - 00:34:54.620, Speaker A: We'll wait, see what Matt says on the YouTube chat. We do have a question here from Fox Raymond in the Zoom chat. Once again, how do you prevent front running with randomness?
00:34:56.080 - 00:36:20.040, Speaker B: Okay, this is indeed very interesting. I will describe it very briefly and please let's discuss it later because this is an idea, it's not a complete design, but I think there is something to do there. So for example, let's take an ellie, stop me if you don't want to share it yet, but let's assume we take the interface of uniswap, right? And I will describe something right now which is in the naive implementation, is not possible on Ethereum. But I'll just describe the idea. So the problem in Uniswap is that the Miner can include or interfere with the sequence of the transactions or include a transaction of its own, and he can know exactly what will be the price that it will get, and he can front run traders. So an idea can be, let's say that all the traders that calls uniswap in a block get the same price, maybe the worst price that one of them got. And then we use randomness, which is not known in advance, to the Miner or to any other user, to distribute the extra profits between all the traders.
00:36:20.040 - 00:36:30.110, Speaker B: So, as I've said it's very briefly, it's not possible in the NAV implementation, but this is the idea.
00:36:33.360 - 00:36:47.330, Speaker A: Great. I don't see any more questions from the YouTube, but we could open the floor and if anyone in the zoom call wants to just jump in and ask Tom questions, we could do that if that sounds good.
00:36:48.900 - 00:36:49.728, Speaker B: Sounds good.
00:36:49.814 - 00:36:50.450, Speaker A: Great.
00:36:51.620 - 00:37:02.068, Speaker B: Thanks again, everybody, for coming and have a good night. Morning. I don't know, wherever you are. Thanks.
00:37:02.154 - 00:37:10.730, Speaker A: Awesome. Thank you, Tom. Oh, question from Derek. How do we find you?
00:37:13.340 - 00:37:17.444, Speaker B: I guess you can. This is my handle.
00:37:17.572 - 00:37:19.000, Speaker A: Yeah. On Discord.
00:37:19.900 - 00:37:29.880, Speaker B: Yes. I think also on discord. Yeah. So this is on discord.
00:37:31.580 - 00:37:32.610, Speaker A: Great. Great.
00:37:34.580 - 00:37:35.330, Speaker B: Okay.
00:37:35.780 - 00:37:38.592, Speaker A: Awesome. Thank you so much, Tom.
00:37:38.726 - 00:37:40.350, Speaker B: Bye. Thanks, everybody. Thanks.
