00:00:07.130 - 00:00:47.802, Speaker A: Hello everyone. Welcome to introduction to Protocid, aka the Mina Protocol presentation on how to build ZK rollups. My name is Mate, I'm one of the co founding engineers behind Protocid and today I would like to show you how you can build your own ZK roll up with little to no learning curve on the Mina Protocol. Well, you can see our socials right here. So if you have any questions, please write them down and ask them afterwards because I have quite a lot of content to go through. So let's get started. Before we get to the actual Zeekerola building section, I want to make sure that we are all on the same page when it comes to understanding of what zero knowledge actually is.
00:00:47.802 - 00:01:52.750, Speaker A: So let's get into it. So, the first question I want to answer is what is a ZK proof? So, ZK proof is a mathematical proof of computation that is done on top of using public or private inputs and it results into a public output. What can you do in a proof of computation? So you can verify signatures, you can verify merkel proofs, you can do addition, subtraction, multiplication or for example hashing using posatum and lot of other cool stuff that can be mathematically proven. To compute a ZK proof, you need to use a proof system. The proof system that we use for our product kit is called Kimchi and is the same proof system as the Mina L1 is based on. To generate a proof, you need to execute something that's called a circuit. And the thing that we'll be looking at at the next slide is a zkdsl written TypeScript called one JS that allows you to write circuits in TypeScript which you can then compile and generate a proof of the computation that you have defined.
00:01:52.750 - 00:02:54.990, Speaker A: So when you compile a circuit, you actually get two artifacts, so you get a prover key and a verification key. We'll see that later and how it ties into building your own ZK roll up. The most important part of why you should even care about proving your execution is that it allows you to run the execution once generate a proof and then anybody who wants to verify the result of that computation can cheaply verify the result without having to recompute the expensive computation again. So this will be very important when you, for example, try to design a blockchain with a consensus mechanism where all the validators have to revalidate transactions. When they're for example bootstrapping or simply participating in network. With a ZK proof they don't have to rerun the transactions again, they just have to validate the proof of applying the transactions by the person who created the block. So the zero knowledgeness of approve comes from the fact that the computation can be done on two kinds of inputs.
00:02:54.990 - 00:03:25.438, Speaker A: One is public or it could be also private. So when the Verifier is verifying your proof, they have no access to your private inputs only to the public results of the execution. I've already mentioned o one JS. So O one JS is a TypeScript library that allows you to write circuits. There are a couple of important primitives exposed. It's called, for example, ZK program. As you can see, we start with defining the inputs and the output types of the program and then methods which are the actual computation that we care about.
00:03:25.438 - 00:04:19.710, Speaker A: Every method can have its own private inputs and the following program is very simple. It's basically a program that proves a transition from one counter to another counter and it only allows you to perform the transition from a hash of a number to another hash of a number if you know the pre image of the hash, right? So just to go quickly through it, line number ten, we are hashing a private input A, which is a UN 64. Then we are ensuring that the hash that we have created from the private input of the number matches the public input of the number which is the current state, the current hash of the counter. Then we increment the raw number. So A plus B, that's line number twelve. And then we return the new state which is the hash of the addition that we have performed. So we have a hashed counter and we prove that we know the current value of the counter and transition the state to a new hash of the counter.
00:04:19.710 - 00:04:55.446, Speaker A: So how do we run the circuit? So, first you have to compile it. As I've said, that gives you a prover and a verifier key. The compilation itself is pretty expensive, so depending on your hardware, we are talking at least like tens of seconds. Then we define some state variables that we will feed into the increment method. And line number seven, we actually run the increment method of the circuit. This is another expensive part because you actually have to mathematically compute the proof behind all of the operations that you are trying to do. So you can expect another like tens of seconds to actually generate the proof.
00:04:55.446 - 00:05:39.762, Speaker A: Then we get a result which is our proof of increment. That proof can be verified very cheaply using the verification key. We see that at line number 13 and then in between we can just keep track of the state variables that we need to. So, very simple, we've just written a countercircuit. We've seen how to compile it, how to run it to get approved, and how to also verify the proof. Another important aspect of the Kimchi proof system, or actually the recursion layer on top of the Kimchi proof system, which is called Pickles, is that all of these programs and all of these proofs can also be recursive. So you can write a bunch of ZK programs and they can compose with each other, right? So this allows, for example, for effective parallelization of your chain.
00:05:39.762 - 00:06:29.846, Speaker A: So later we'll see how to write the ZK roll up and we'll go through what actually happens behind the scenes and we'll see how we split the execution into multiple parallel proofs so we can have increased efficiency using recursion. Recursion essentially means that the mathematical logic that's required to verify approve is implemented in the circuit itself. And that's pretty much it. So how is this helpful for blockchains? What is a blockchain like? That's the first question we need to understand. It's basically a distributed database with a consensus on the latest state. So nodes execute user transactions and a transaction is just an authorized intent to perform some state transition on top of the current chain data. That's like every blockchain out there it's applicable.
00:06:29.846 - 00:07:33.706, Speaker A: So after a block producer runs all the transactions on the behalf of the user, the transactions are then bundled into a block, and the block then signifies the new state of the blockchain. So, if you want to verify that the block and all the transactions in it are valid, for example, on Ethereum or on any other non ZK chain, you have to rerun all the transactions. This is super expensive and it means that you have pretty significant hardware requirements. To be able to do that, you need to store all of the data of the chain and you need to have like a beefy CPU to rerun the transactions. So, as I said, high hardware requirements, which means lower decentralization. So what Mina does differently as an L One, so the entire protocol is like written using zero knowledge circuits. So it means that whoever's participating in Amina network, once a block is produced and it arrives into your node or into your client, you don't have to rerun all the transactions again.
00:07:33.706 - 00:08:16.646, Speaker A: You just verify the block proof, and you can be 100% certain that the person who produced the block did everything that they should have done correctly. And they didn't try to cheat by, let's say, double spending or other common attack vectors. So, thanks to Mina's recursive proof design, a block is a simple recursive block proof, which means that the blocks can be verified cheaply and quickly without rerunning the transactions. So let's now talk about about Mina's native element smart contracts, and how they tie into the recursive proof design of the L One protocol. So smart. Contracts. Are mina.
00:08:16.646 - 00:08:51.906, Speaker A: You have to write them using the Omanjs Library. There's a primitive called smart contract. Smart contract is just a circuit, like the ZK program we have seen before, that runs on your client so literally in your browser and proves its own execution. So you don't need a block producer to run the contract anymore because you run it on the client side. This means that the blockchain can effectively scale pretty well because you don't have to do all the computation on the node side, but all the users do it for themselves. That is a pretty significant leap forward, I think, when it comes to design of blockchain. So they're executed off chain.
00:08:51.906 - 00:09:44.840, Speaker A: As I said on your client, the node operators don't have to execute them. And what this means is that if you run the smart contract off chain, so you run the contract on your device, the only thing that you have to send in the transaction to the L1 itself is a list of state transitions that you want to apply to the global chain state. In the concept of DL1, those are called account updates. The account updates are then authorized by the proof of execution of the contract or they can be also authorized by a signature. But that's less interesting. Then the block producer only verifies the proof of execution of the contract and applies the changes to the chain state that need to happen on deal one. After the block producer applies all of these account updates or the state transitions, you end up having a new block which has a new global change state.
00:09:44.840 - 00:10:36.518, Speaker A: Those were the good parts. But now we'll talk about a bit more about, let's say, the design limitations of this approach. Basically, if you have two clients or, like, everybody in the room would try to do a transaction to the same smart contract and they would be using what we call preconditions, which we'll explain later, they would essentially run into a race condition where they tried to update the same state, but the proof was calculated on outdated state. So it's like a race condition. All right, here we have the same circuit as we had for the ZK program, but now it's written as a smart contract. So the first thing that we see is we define what kind of onchain state do we want to store? So that's line number three. Smart contracts allow us to store eight fields worth of data on chain itself.
00:10:36.518 - 00:11:36.714, Speaker A: That's about eight times 255 ish bits of data on chain. This is a pretty severe limitation that we have to engineer around and we'll learn how to do that later. Again, we have to define a method to interact with the state of the program or the smart contract. And again, it's an increment that increments the counter or the commitment to the public state only if we know the pre image of the number. The most important part here is line number nine where we so line number eight, we fetch the on chain state by doing this commitment get. And then line number nine, we are doing an assertion in the proof itself that results into a transaction precondition which tells the block producer that hey, I have done this proof and it was done using this on chain state because the on chain state becomes the public input. And this is where the race conditions come from.
00:11:36.714 - 00:12:28.490, Speaker A: If multiple users are running the off chain proofs in parallel on their devices and they use the same preconditions, only one of them will end up having a valid transaction because the second one will get invalidated through the precondition or the commitment to the on chain state. This is how you can send transactions to Smart Contract Domina. It's super simple. So you just need to know the address of your deployed contract. Then you send a transaction, specifying the fee payer, you execute the method with the inputs that you want and then you'll have to prove the transaction and send it, as we can see, running the increment on the counter resulting to several account updates. And the account updates looks simply as the follow. So there you have the address, then the preconditions to the onchain state and then state updates since you are updating the onchain state plus of course the proof authorization.
00:12:28.490 - 00:13:05.106, Speaker A: This is like a pretty straightforward diagram, I believe, of how the Smart Contract layer looks like. So at the bottom you have what happens on the client, at the top you have what happens on the network on the node. So let's start from the left. Alice executes counter increment. That gives us an array of account updates which are authorized by approve and then sent to the network. So once the list of the account updates get sent to the network, what the block producer does iterates over all the account updates, tries to verify the proof attached with every account update. If it's valid, then it also checks the preconditions.
00:13:05.106 - 00:13:46.930, Speaker A: And if all of these things end up being true, then it applies the account updates to the state. So therefore you have a transition from the initial state to the resulting state on DL1. Now, let's talk about circulating the storage limitation of eight fields in the Smart Contract. So the reason why the limitation exists in the first place is because when you write zero knowledge circuits they have this property which we call they have to be fixed size. So it means that you cannot have dynamic size arrays because what a circuit is, is essentially just the trace of execution. And the trace of execution needs to be the same at compilation time and execution time. So if your input size changes, therefore your trace changes as well.
00:13:46.930 - 00:14:32.450, Speaker A: So since because the trace needs to be fixed or static size, the storage which you can work with needs to be fixed size as well. So what can we do about this? So first of all, you cannot have key value storage like this because that would be dynamic size. You cannot have a storage of a public key to uni 64 like you would have in an ERC 20 contract to store balances. However, what you can do is you can start using Merkel trees and store only the root hedge of the merkle tree in the Smart Contract's public storage. So let's go through what is a Merkel tree. So Merkel Tree is a cryptographical data structure that allows you to verify that certain data is part of a larger data set. And you can do that using Merkel Tree witnesses.
00:14:32.450 - 00:15:25.518, Speaker A: So if we apply this concept and we take a merkel tree and start using it within our smart contract. Proofs we can circumvent the storage limitation of the eight field and we can have essentially infinite state as long as it fits into our merkel tree. So if the tree is tall enough, we can have essentially unlimited state. So instead of storing counters for every users we can store a commitment to the tree of the data that we are working with and then the incremental. Method of the counter would have to get the commitment, therefore, the ruler of the tree, it would have to verify that the data we're working with, the actual counter, is part of the tree and then write the changes. To the tree itself by updating the rootage of the tree and storing the root hash on chain again. So this is how you would actually update the merkel tree.
00:15:25.518 - 00:16:00.430, Speaker A: You would have to add the numbers together as we've done before. And then you would have to compute the root hash of the merkel tree by using the new counter value. So pretty straightforward. Now we have to go back to the design limitations of preconditions we were discussing. Before. So since now everybody is working with the same mercury of data, they have to work with the same rude hedge of data. So if there are two clients computing something or trying to update the data concurrently only one of their transactions will be valid because the second one will get invalidated due to preconditions.
00:16:00.430 - 00:16:45.246, Speaker A: So again, preconditions pointing to the root of the tree causes issues to users. Transferring causes issues. There we go. And that's a diagram basically showcasing the precondition interaction. So we have Alice that's trying to execute counter increment some off chain storage component which stores the entire tree and the actual data, provides the data for Alice to do the computation in. Her proof that gives her account updates, which tries to set the counters to a new root hedge or new state, but it also has preconditions to the previous state because we were reading the existing counters of the users. So those were, like, the good parts and the bad parts of deal.
00:16:45.246 - 00:17:16.690, Speaker A: One smart contract. Me and my team raphael, who's sitting in the crowd there, we wrote a library that basically allows you to write your own ZK. Roll up where you won't have any of these concurrency issues, state limitations or anything of that nature. It's very simple to get started with the library. You just have to clone the starter kit and read the README, obviously. So what is Protocit? Protocol is a TypeScript based framework for building ZK chains. It's not using another Zkvm.
00:17:16.690 - 00:17:38.714, Speaker A: Instead, it uses a very custom, usage specific Zkvm. It has a hybrid execution model. Which means that you can have both off chain execution and on chain execution. Therefore, you get all the benefits of the L. One smart contract. Plus custom on chain behavior. Off chain execution means that you can do client side ZK proofs.
00:17:38.714 - 00:18:28.154, Speaker A: Therefore, all of the roll ups are privacy capable or privacy enabled. The execution of the protocol that powers your ZK roll up is end to end proven same as the L One. So therefore, if there's a centralized sequencer that's running the protocol for you, you don't have to be worried about the sequencer being malicious, because all of the execution is proven exactly as it should be. The framework itself is very customizable. We try to ride it in a way that doesn't force people to use certain libraries or certain techniques. So if you don't like the RPC library we created, you can just plug in your own, which makes it very flexible. I think that the framework has virtually no learning curve, assuming that you've built with the Smart Contracts before, or at least you have some TypeScript knowledge or existing solidity knowledge.
00:18:28.154 - 00:19:16.990, Speaker A: So should be pretty easy to get started and get building, which is important for a hackathon. So let's build your own ZK rollup. So, recursive ZK rollup is again just a series of recursive ZK circuits. We've seen ZK program before. ZK rollup is just a lot of ZK programs, and we provide the interface to make it as simple as possible for you, so you can focus on building your app instead of building infrastructure. Every user transaction in the roll up is essentially running a ZK program that results in state transitions, same as the account updates. And we prove all of that for you if you want to do this on DL One with the Smart Contract, there are some building primitives for sequencing or like mempool management, but you still have to write your own circuits.
00:19:16.990 - 00:20:04.430, Speaker A: So with Rotokit, you can build zero knowledge interoperable and privacy preserving application chains or ZK roll ups with no learning curve. You can roll your own ZK roll up in a few lines of code. And one thing that I want to mention is that if you write a ZK roll up, not a ZK app or the L One Smart Contract, it's going to be a superset of what's possible with the L One Smart Contract. So you will preserve all the privacy features of off chain execution and have new features thanks to onchain execution. Let's talk about a bit more about what the Zeke Robs are made of. So, we have the Runtime, which is our application logic. We have the Protocol, which is the underlying VM that handles the circuits for block production, transaction fees, et cetera.
00:20:04.430 - 00:20:55.680, Speaker A: And then we have the Sequencer, which contains modules for like the mempool orchestrating the block production or settling your role up to DL One. All right, so what kind of features can you expect? We are hoping for like a supercharged developer experience, but that's for you to tell us what you think you can use a bunch of reusable modules. So it's super easy to create a composable ecosystem where you just use NPM install to install, for example, runtime module. You won't have any data race conditions. Thanks to the fact that we have a sequencer which will sequence the transactions on chain on your behalf. You will have bottomless on chain storage, not just eight fields. You are still able to preserve privacy or anonymity thanks to the fact that we have the hybrid execution model.
00:20:55.680 - 00:21:49.550, Speaker A: You don't have to focus on infrastructure. Instead you can focus on building your business logic. It works well with the established ecosystem wallet and it's not another Zkvm. And if you wanted to, you could reimplement the entire L One Smart Contract back end in the framework itself, which is not something I would encourage you to do because it's pretty complex. But if you wanted to, you could you can add features that will be executed on chain much quicker than the L One will because it's application specific. And some of the additional things that we're working on is interoperability between all of these roll ups because you don't want to have liquidity fragmentation or like siloed roll ups and also data availability. And these two topics pretty much come hand in hand and are pretty important for further decentralization of the rollups.
00:21:49.550 - 00:22:35.360, Speaker A: So how does the lifecycle look like for a protocol roll up and a user transaction? So at the bottom left we have again Alice. She creates a transaction where she wants to transfer some balances. She doesn't have to prove anything, so therefore it won't take her several tens of seconds on the client side. Instead, she does a simple signature and sends the transaction to the roll up operator itself. Then the roll up operator sequences all the transactions received from the user and executes them one by one, proving the execution of every individual transaction and also approving all of the transitions that resulted from the transactions. This results into a block proof. That block proof is then taken and settled using L One Smart contracts to the L One.
00:22:35.360 - 00:23:18.330, Speaker A: Writing your own runtime for your own ZK roll up is relatively straightforward. It's essentially the same developer experience that you get from the L One Smart contracts, but you have more on chain storage and you have on chain execution. So this is, for example, how you would write a simple ERC 20 like module with the ability to transfer balances from one account to another. Testing your ZK roll up is also super simple. We offer something called the Starter Kit, which I've already mentioned. You basically have to create your testing app chain from a runtime object. So pass in your balances class, start the app chain and continue writing your tests.
00:23:18.330 - 00:24:09.194, Speaker A: In the test you would obviously have to execute the transaction. So the API is nearly identical to what you can expect from DL One Smart Contract. That was actually like one of the design goals to take all of these smart contract developers from DL One and allow them to transition to ZK roll ups with no learning curve. So you sign a transaction, you send it to the chain, then you manually produce a blog in your tests because you can have control over that. And then you can read the resulting state of the transaction using our Query API, which returns you the new state. So if you want to start hacking on Mina and you want to build your own ZK roll up, all you have to do is clone our Starter Kit, install the dependencies, start a sequencer that will start the example runtimes packaged into the Starter Kit. Plus you will also have to start a UI and get building.
00:24:09.194 - 00:25:00.198, Speaker A: The starter kit is pretty opinionated. It has a react tailwind chat CDN based UI, and it showcases how you can connect to the chain, how you can read state through our GraphQL APIs, how you can send transactions, and how you can connect to your browser wallet. So all of that is ready for you to start hacking. You just have to pick it up and get to work. All right, so what are we working on now? So we've built a bunch of tooling, obviously for ZK rollups. Now we are kind of like transitioning, not just like not stopping working on the tooling, but we are also focusing on the product side of things. So we're building like an open treasury governance system for the Mina ecosystem itself, or like for every ZK rollup built with the protocoling.
00:25:00.198 - 00:25:32.310, Speaker A: We've also built a dex called Copang. It's built using protocol. You can check it out. It's a nice demo that runs in the browser completely, even the sequencer itself and the whole chain runs in the browser. Find it on Twitter, check it out, let us know what you think. The question is, what would we like to see as, let's say, judges or developers of protocid? We would like you to work on the following things or any other ideas that you can bring to the table. We'll be here for the rest of the weekend to help you build.
00:25:32.310 - 00:26:10.800, Speaker A: So the things that I'm personally excited about is things like NFT standards, stablecoins lending markets, dispute resolution credentials, name services, or anything else that you can see in other ecosystems and we pretty much don't have it yet. You can find our website at protocol. Dev all the links to GitHub StarterKit, our discord server, where you can ask questions are there. I would like to wish you all good luck and have fun. And let's not forget about the fact that Mina Protocol has put out a pretty chunky price pool of 20K. So come and build. Thank you.
