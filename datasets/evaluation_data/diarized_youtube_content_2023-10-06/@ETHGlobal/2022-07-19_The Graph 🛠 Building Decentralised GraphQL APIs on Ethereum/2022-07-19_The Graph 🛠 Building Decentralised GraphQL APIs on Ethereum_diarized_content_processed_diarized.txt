00:00:05.850 - 00:00:30.280, Speaker A: Hey, everyone, welcome again. We have Wishwa here from the Graft with us and you're going to learn how to build decentralized GraphQL APIs on Ethereum. If you have any questions, feel free to pop them in the chat and Wishwa, I'll let you take the stage. Thanks. Awesome. Thank you so much. I will share my screen.
00:00:30.280 - 00:01:09.052, Speaker A: All right? Hope everyone can see this fine. Cool. Hey, everyone, thank you so much for tuning in. Today we're going to be learning how to build decentralized GraphQL APIs on Ethereum with the Graph. And we will be going over an example of how to use the Zora NFT Marketplace protocol to build our NFT API. But before we get started, a little bit about me. I am Vish and I'm a Developer relations Engineer at the Graph.
00:01:09.052 - 00:02:08.544, Speaker A: And my passion is building deeply engaged, dev communities. And I invest a lot of my time helping developers become successful with the frameworks and the tools that they're using through my content. Moving on, let's learn about the Graph. The Graph is a web3 indexing and querying protocol for blockchain networks like Ethereum and IPFS. And the Graph community plays a prominent role in supporting DAP developers by making open, decentralized data easily accessible with GraphQL. So, as an analogy, in simpler terms, the Graph does for open data on the blockchain what basically Google does for the web, you can index and query that data in a more efficient way so that you can serve it to your DApps on the front end. Now, using the Graph, anyone can build and publish open APIs known as subgraphs.
00:02:08.544 - 00:03:10.724, Speaker A: subgraphs is what we call them that make data on the blockchain more accessible. So with subgraphs as the main API layer, you can see this nifty diagram on the screen. And subgraphs sit between the UI layer and the contracts, which is like the data layer, basically all your decentralized data from smart contracts. So with subgraphs as the main API layer that sits between these two layers, the Graph is quickly becoming a default part of the web3 stack. And subgraphs are now becoming a web3 standard for building DApps. So whenever I talk about this, I get this question very often is, where does Graph coming to picture? In theory, it sounds all good, but how does it fit into the web3 stack? So this is how it goes in the data driven world that we live in. Our data is stored across huge storage networks and blockchains.
00:03:10.724 - 00:04:14.280, Speaker A: And the blockchain, of course, gets huge, huge number of transactions per day. So the applications that we build obviously needs index data for high performance and great UI UX, especially if these are decentralized applications. So as a solution to this, developers have been for a long, long time, developers have been building proprietary indexing servers to serve it to their DApps and make them more high performance and give it a better UI UX. The problem with proprietary indexing servers is that writing this business logic like writing these servers is expensive and the code is also error prone. So another problem that you can see here is that it also has a single point of failure. So if you're writing your own indexing server code, it definitely means that there's a single point of failure. So if one thing goes wrong, it just crashes.
00:04:14.280 - 00:05:01.956, Speaker A: And of course it needs engineering and hardware resources as well. So it's not very easy to manage. There's a lot of infrastructure that you need to manage that comes along with it. And of course, in the end it disrupts the core idea of decentralization. So enter the graph. The Graph is a global open API that is being used for use cases that include, but aren't limited to things like NFT marketplaces, galleries and metaverses, music, video, social and community platforms, communication platforms. Which is why we say that the Graph is the easiest way to index and query, blockchain data efficiently and serve it to your DAPs to give it a better UI.
00:05:01.956 - 00:05:46.920, Speaker A: UX. But it is not just that. It's not just a global open API, it is also a transparent and open network of participants. And these participants make up the decentralized network of the Graph and they include subgraph, developers, curators, indexers and delegators. On top of that, the API that we see is decentralized, robust, discoverable, it's more performant. But not just that, it's also built on top of GraphQL, which as a technology comes with its own benefits for the developer. The Graph has also been powering DeFi use cases for a long time.
00:05:46.920 - 00:06:44.040, Speaker A: So DeFi tabs that query on chain data like trades and exchange volumes, total borrowed supplied, staked yield, farming, total value logged, and so much more. Some of the complex applications that are running in production that you can see online that are powered by the Graph are use cases like websites, some of the popular ones like CoinGecko CoinMarketCap. There are also NFTs and Dao. Use cases like the foundation juicebox dao? There's also the graph. As I said earlier, Graph also powers DeFi use cases. So there's of course also Uniswap and synthetics. But these are just to name a few and last but not the least, graph, the hosted service, has been supporting creators across 25 different networks.
00:06:44.040 - 00:08:24.616, Speaker A: So the Graphs hosted service is supporting all of these networks that you may have seen and so many more, like Ethereum, Near, Polygon, Arbitrum, optimism, Avalanche and so many more. So that is basically some gist of some brief about what the Graph is, where it sits in your stack, what subgraphs are, why they are beneficial for developers in their web3 stack. So now that we've learned a bit about what the Graph is and what the benefits of building subgraphs are, I want to take you over the process of building your first subgraph, which is basically a decentralized GraphQL API that you can use to index and query data from the blockchain. So if there's networks such as Ethereum and there is a smart contract that you want to query data from, then you build this decentralized GraphQL API, which is super performance, super discoverable using the graph and then you can query that data from the smart chain sorry, the blockchain, the smart contract and then serve it on the front end to your DAP. So we will be going through the process of how to build this. Now, I usually do this as a live demo, like a full workshop, initializing a subgraph, designing it with all of the code, like explaining the functions and events and whatnot, and then finally deploying it. Today I'll be doing something different, just to be very brief, very crisp and concise.
00:08:24.616 - 00:09:32.668, Speaker A: I'll be sharing the code I already have just like five to 10 minutes ago. I've already deployed a brand new subgraph on the Zora smart contract using the Zora smart contract and I will be sharing code. So let's see it together. I'm actually not sharing my entire screen, so let me quickly share my desktop so that we can start seeing the code together. Awesome. Cool. So some time ago the team has launched this when we launched the Subgraph Studio, which is basically the IDE that you can use to build subgraphs.
00:09:32.668 - 00:10:31.300, Speaker A: We also launched this guide that you can use to learn how to like the entire process from A to Z. You can learn how to build subgraphs, all of the prerequisites that you need, all the commands are in there. And specifically it uses the example that I have spoken about, which uses the Zora NFT Marketplace smart contract. And you can find out everything about this here. So let me actually just pop in this link here. So anyone who wants to go over it, they can just start going through this in real time. So quickly before starting, some of the prerequisites are Node JS, you should have Node JS installed on your machine and a MetaMask mask wallet just to make sure that you can get the best out of this workshop when you get back to it and get into the coding.
00:10:31.300 - 00:11:22.852, Speaker A: So make sure that you have those two things set up. Apart from that, I would personally say that some knowledge of TypeScript and GraphQL would come in really handy when you're writing the assembly script code and the GraphQL schema. And when I start sharing the code, you'll learn why. But if you have some basic foundation knowledge of those two things, it would be really helpful to grasp some of the concepts of why we're writing particular code and what does it do. So, getting started, let me show you the Subgraph Studio. The first thing that you should be able to see is when you go to the Graph.com website and navigate to product, there are three things the Graph Explorer, the Subgraph Studio and the hosted service.
00:11:22.852 - 00:12:11.620, Speaker A: Something that's pertinent to us currently for this demo is the Subgraph Studio, where you can create, manage and publish your subgraphs and your API keys. So when you click on Subgraph Studio, it's going to it is connected with your wallet. And I have connected it using my MetaMask wallet. So make sure that you have a MetaMask extension just to make things a bit cleaner and easier while you're using the Subgraph Studio. And if you have a chrome extension, you just sign the message. It's basically like you logging in to the Subgraph Studio using your wallet. So if you can see here, I'm already logged in using my wallet and this is my Subgraph Studio dashboard.
00:12:11.620 - 00:12:33.964, Speaker A: And you can tell that I do these workshops a lot from the amount of demos that I have here. But, yeah, let's go ahead and create our first subgraph. And here you might want to name it something like, I don't know, NFT API. It's available. Thankfully. Ethereum main net. Click on continue.
00:12:33.964 - 00:13:00.340, Speaker A: And what this is going to do is it will create your subgraph on the dashboard. And this is yet not in your local machine. You're yet to initialize it using a command. But this is the first and foremost step. So you go into the Subgraph Studio and you create like a skeleton of your GraphQL API. I've just named it NFT API. You should know this.
00:13:00.340 - 00:13:59.320, Speaker A: This is going to be the name and the slug of your subgraph that you will be using later in commands. Now, another very important thing, if this is your first time using the graph and creating a subgraph, is that there is some documentation here on the right, and the first part of it is going to be installing the graph CLI. So if this is the first time, you should definitely go in and install the graph CLI. It comes with a lot of important commands that you can use to then initialize your subgraph, deploy it, authenticate it, and different things like that. So you should be able to do that using both NPM and Yarn. And all of the commands are given here. Good thing about the Subgraph Studio and the Subgraph Dashboard here is that you already have these commands that you can just copy and paste in Vs code.
00:13:59.320 - 00:14:54.836, Speaker A: So let me shift this. Yeah, so I've already set everything up here so that I can just take you over the code and I have the graph CLI installed. I've also initialized my subgraph. And to be able to do that, you go in and copy this command graph init Studio NFT API. Now, one thing here is that this is a very short command, but there is a longer version to this command here in this guide, and it has a few different let me bump up the there are a few. Different flags in this command that I want to talk about is that each flag has some purpose and you pass some argument for each flag. And what that's going to do is the graph init command basically creates a subgraph.
00:14:54.836 - 00:15:48.084, Speaker A: It initializes a new subgraph for you. So basically like boilerplate code that you can instantly get started with, get your hands dirty to try it out. And this comes in very handy if this is your first time. So you want to make sure that you know what each of these flags do. So that when you're scaffolding your subgraph using the graph in it command, then you're entering the right kind of information that will be feeded into each of the files that you will then further be working with. So the first one here is the contract name, but before that, let me talk about the From Contract flag which is going to make things clearer. Now the From Contract flag is the flag to which you pass the argument, the address of your smart contract.
00:15:48.084 - 00:16:35.880, Speaker A: So as the argument here, I have passed the smart contract address and now this is basically the Zora NFT smart contract public address that you can get from the Zora documentation and that will be passed in the From Contract flag. Similarly, there is also a contract name flag which is token. So this will then be fed into your subgraph YAML file. So there are different types of contracts in your smart contract and the one that we are using here is the token contract. So we'll be passing that here. Two other flags are the index events and Studio. We don't need to pass any arguments in these two flags.
00:16:35.880 - 00:18:07.620, Speaker A: Just one thing to know is that the index events flag basically gives you all of the code that you need to handle all of the events. It just makes sure that the subgraph is you're able to define your mappings file in a way that maps your smart contract events to your entities that you will be defining in GraphQL. And this might be a little bit confusing right now, but once we see the code in the subgraph folder then it will be clearer. And finally the Studio flag is the flag that we will be passing just to make sure that our local code knows that we will be using the subgraph Studio for building our subgraph. And done. Once you have entered this command, it should show you some kind of feedback here that shows you that the subgraph is being scaffolded. It might take a few seconds and then once your subgraph has been scaffolded, it will give you some bare bones boilerplate code which is pretty important to know and learn what it gives you right out of the box just so that you can start editing those kind of functions and those parameters later on.
00:18:07.620 - 00:19:35.020, Speaker A: So three main things that we will be working with, three main files that we will be editing whenever you want to define your subgraph and design it to then able to deploy it later on is the first one is subgraph YAML subgraph GraphQL and the mappings TS file in the source folder. Now, what subgraph YAML does is it's your generic YAML file. It's a configuration file that helps you define your subgraph, tells you what kind of smart Contract it is dealing with, what the start block of the Smart Contract is going to be, what kind of events your Smart Contract is going to be emitting, and where does it have the code to handle it, stuff like that. And then the second one, again, a pretty important file that we are supposed to be dealing with while building a subgraph is the Schema GraphQL file. So if you know GraphQL already, as the name suggests, this is your GraphQL schema file. And what this does is it defines your data basically. So from the Smart Contract on the blockchain, any data that you want to query using your subgraph should be described in this file.
00:19:35.020 - 00:20:35.840, Speaker A: You describe that data along with how to query it to your front end. So these are the two entities that we will be defining. I've already defined them here and I will explain later what each of these things does. But finally, there is a mappings file that we deal with. And this mappings file, as I briefly mentioned earlier, it has all of the code, the business logic that we need to map the events being emitted from the smart contract on the blockchain and map it to the local code, to the functions that we are writing here as part of our subgraph design, which that is the mappings file. And I will go deeper into it just in a bit. Yeah, so that is basically the folder structure and I think we're good to start getting into each of these files.
00:20:35.840 - 00:21:34.820, Speaker A: So I've made a few quick changes in the subgraph YAML file specific to our subgraph. Since we're using the Zora Smart Contract in the address field, I have passed the Smart Contract address. This was passed earlier as part of the graph init command. So if you use the shorter version, the only difference is that this field you will have to later on come into it. After scaffolding the subgraph, you will have to come into this file and then add the Smart Contract address. But if you've already passed it as part of the From Contract flag as an argument to it, then it will be passed in already. And this will be what you see when you come into this file and the abi that you see if you remembered, you pass the contract name flag and you pass the argument as token to that flag.
00:21:34.820 - 00:22:59.164, Speaker A: So this is that another important thing here is the start block and you can go on etherscan search for the last transaction on the Zora NFT Smart Contract and that should give you the start block of that Smart Contract. What this basically means is that instead of starting from the genesis of that smart contract, you want a particular start block from which it should start indexing, so that it doesn't take long, long amount of time to sync when you've deployed the subgraph. So that's basically the start block that I've passed in. Another quick thing that edit that I've made here is the entities. Now this is super important entities pertain to the GraphQL schema. So anything that you pass as part of the entities, it is basically the kind of data that you want to deal with, that you want your subgraph or your GraphQL API to query from the smart contract and it will then later on be defined in the GraphQL schema. So in this example, I want to deal with token data which is basically all of the NFTs that every user mints and holds and then finally the user metadata.
00:22:59.164 - 00:24:06.840, Speaker A: So these are the two entities that we'll be working with and we want our subgraph to be able to then query from the smart contract and provide to our front end. And then finally the last change that I made in the subgraph YAML file is the event handlers. So every smart contract, just to keep this very simple, every smart contract emits a few events. Now, when you start indexing that smart contract, there will be an event that will happen, for example a transfer event. So if you transfer the ownership, if the ownership of an NFT has been transferred from one user to another, then this is the kind of event that will be emitted. So there can be two cases in this one, whether the ownership of the NFT has been transferred from one user to another or a new NFT has been minted. So in that kind of an event being emitted on our subgraph side, we want some kind of code, some kind of business logic that we want to be executed to handle this event.
00:24:06.840 - 00:24:58.570, Speaker A: Which is why we have defined the handle transfer function as the event handler here. So in the event handlers, we want to define a handler for each event that will then be emitted from the smart contract. Now, you don't necessarily have to handle each event from the smart contract. The subgraph should only have the business logic for the events that you want to be interacting with. So basically in our example, I have taken the example of two events, which is the token Uri updated event. So in case of the Uri of an NFT being updated or changed, this is the event that will happen and we will be writing a function, some business logic to handle this event. And similarly for the transfer event that I already explained a bit.
00:24:58.570 - 00:26:10.508, Speaker A: So that is about the subgraph YAML file. Now moving on, next there is the schema GraphQL file. Now the schema GraphQL file, as I mentioned earlier, is your GraphQL schema where you will be describing the data that your subgraph will be querying and for any entity, entity is basically like a collection of data fields, data entries or data points in your API that you want to be querying, right? So these are all of the top level fields that we can see under each entity. This is entity token. There's another entity user, if you remember, from our entities section in our YAML file. And so here in this schema file, we are defining these two entities using the at entity directive, which is a GraphQL directive. So if you've used GraphQL before, you should know that this is the directive that we use to define each entity, declare something as an entity, this type token as an entity.
00:26:10.508 - 00:27:17.380, Speaker A: And these are the fields that we want our GraphQL API to be querying, which is the ID, the token ID, which is the NFT ID content Uri, which is basically the link to the NFT metadata Uri, some metadata for the NFT created that timestamp. So if there's a particular time at which the NFT is being created, then this timestamp will give you that creator and owner. So creator will be the user. As you can see, we've passed the object user, so every NFT will have a creator and an owner and both those types will be users. And in the user entity, we are basically defining it as a relationship here. And you can use the at derived from directive which is again, just like entity, it is a GraphQL directive that you can use to define a one too many relationship between two different fields. So there's a tokens field and there's a created field.
00:27:17.380 - 00:28:10.730, Speaker A: And what we want to do is that in the user entity, which is basically our user metadata, we want to define two things, which is tokens. So tokens that are being owned by owners and tokens that are being created by creators. So we're defining that kind of a one to many relationship using the at derived from directive. And I won't be going deeper into this because it's very GraphQL specific, but the reason why instead of an array, you can also use an array for defining this kind of a relationship, for saving this kind of data. But instead of defining an array, we are using this directive for performance benefits. And all of that has been explained briefly here in this guide as well. So make sure if you want to understand it deeper as to why we're using this derived from directive, make sure you come back to it later.
00:28:10.730 - 00:29:19.710, Speaker A: So basically this is our GraphQL schema and we're done defining all of our data. And the last step that we want to do is define our mappings TS file. Now, before we go into what is being described in the Mappings TS file, I want to make sure that you know about the Graph code gen command. Again, this is a command that has been given by the Graph CLI. So once you're done defining your schema GraphQL file, you then run your GraphQL cogen sorry, your graph code gen command that I've already run here earlier when I was defining, as you can see here, I was working on my subgraph. What this does is basically the graph CLI gives a TypeScript library to be able to interact with the smart contract and the graph node. And it also gives some assembly script code and helper functions that can be used.
00:29:19.710 - 00:31:03.800, Speaker A: To make sure that you can map the events happening on the smart contract to the event logic that you're writing in assembly script as part of your subgraph development process. So once you run the graph code gen command, there are some files and some code that is being generated which is why it's called the Graph code gen. There is some code being generated and this is specifically TypeScript and assembly script code and helper functions and we are then importing that code, those functions here, as you can see, importing from generated token token which is this file here, and then importing from generated schema which is this file. So what this code does is it lets you interact with the graph node which basically saves data or reads data or writes data on the graph node and it also lets you interact with the smart contract itself. So you cannot write data on it, but you can definitely read data from the smart contract which is why we use the Graph code gen command to help us with the spoiler plate code. Now, if you remember from our subgraph YAML file, we already have defined our events that we want to deal with and so what we want to do is we want to write two handler functions. So whenever this event, this particular event, for example the Token Uri updated event, whenever it is being emitted, we want to handle that.
00:31:03.800 - 00:31:58.050, Speaker A: So we want some business logic or some function to be executed and we are basically writing that function here. So this function handle transfer, handles the transfer event. So in case of the ownership of an NFT being transferred from one user to another or a new NFT being minted, this function will be executed. And similarly in case of the Uri of a particular NFT being updated, we want this function to be executed. And since we're running out of time super fast, I won't be going deeper into this function, into each of this. But once you go through it, if you have any questions, feel free to ping me on discord and I would love to take you over it. And the specifics of how we're writing each of these functions and what it does.
00:31:58.050 - 00:32:55.832, Speaker A: Basically we're retrieving information from the smart contract and then saving the new information to the graph node. For example in this one we're retrieving the information from the smart contract since the Uri has been updated and then we're saving it on the graph node to be able to then retrieve it later on, query it through our subgraph to our front end. Sorry. And finally, the last part, once we're done doing all of this editing and code changes, writing all of this code here in our subgraph folder, we want to be authenticating our subgraph and then deploying it. And that is the final part of building your subgraph. And it is here. So you can also see it here just to make it a little bit clearer.
00:32:55.832 - 00:33:43.024, Speaker A: The last part is authenticating and deploying. So to be able to authenticate your subgraph, what this does is it connects this local code here to your dashboard. Here your subgraph dashboard. And there is a deploy key that you can use as an auth key when you're authenticating your subgraph. So you just copy this command and run it and it should be able to authenticate your subgraph using the CLI. And then finally deploy the subgraph using this command graph deploy Studio along with your subgraph slug, which is basically NFT API in this case. And once that is done, I've already deployed it.
00:33:43.024 - 00:34:30.684, Speaker A: Once that is done, the deployed subgraph is here NFT. As you can see, the undeployed subgraphs will be written as undeployed and the deployed ones will have the flag deployed. And when it's synced, it will say progress 100% synced. The nifty thing that I love about the subgraph studio, the dashboard here is that it also has a GraphQL playground integrated. So it has various example queries. The first one is here. What this does is it retrieves the first five tokens and the first five users, the token data, basically five NFDS on the smart contract, the first five and the user metadata for each of those NFTs.
00:34:30.684 - 00:35:10.860, Speaker A: And this is a typical GraphQL query. So if you've worked with GraphQL before, you know how this works and what this query does. And so if you click on Run, this should be able to test your subgraph. And this is the response that you see as opposed to your query in your playground. And on the right you can see the entire schema. So you already know that we define these two entities, token and user as part of our GraphQL schema, which is why we have that here. And you can go in and see the different top level fields that we've defined in each entity.
00:35:10.860 - 00:36:06.252, Speaker A: And as you can see, this is the data that we retrieved. ID token ID content uri So this is just the testing part. You can then go ahead and integrate this in your front end using different front end clients for GraphQL, such as Apollo client, and then you can make sure that you're able to retrieve all of this data in your DAP. So, yeah, this is it for the subgraph building part. Like, this is how you build your first subgraph, first decentralized GraphQL API, if you want to be involved more into the Web three movement and. Whatever the Graph is working on, make sure that you check out our website. This is the official website but also has the docs, the Graph.com
00:36:06.252 - 00:36:41.450, Speaker A: docs follow us on Graph Protocol at Graph Protocol on Twitter. And we also have our own official discord, which is the Graph.com Discord. This is the public invite that you should be able to use to join it. So if you have any questions, if you want to meet the team behind all of these features and the things that we're working on, make sure that you connect with us. And of course, we are offering five K in Bounty Bounties at Hack FS this year. 2.5k
00:36:41.450 - 00:37:17.810, Speaker A: USDC for best new subgraphs. So if you build a new subgraph, then you get a price from that first price and second price and then there are two prices, grand prize and runner up for use of existing subgraphs. So you can also query on existing subgraphs and those are the two categories of the bounties. So I'd love to see how you folks use the Graph and the Subgraph studio to start building with the Graph and start using it in your projects. So thank you so much for tuning in.
