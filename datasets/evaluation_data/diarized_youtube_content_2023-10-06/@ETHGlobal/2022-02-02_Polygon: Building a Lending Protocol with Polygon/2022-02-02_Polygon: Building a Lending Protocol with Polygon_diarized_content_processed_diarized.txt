00:00:01.450 - 00:00:19.760, Speaker A: So welcome to the Polygons workshop. You're going to learn how to build a lending protocol with polygon. We have Siraj Rawal here who's leading the workshop. Feel free to pop your questions in the chat anytime and Siraj will take them as we go along. I'll let you take the lead there.
00:00:21.330 - 00:00:40.602, Speaker B: OK, perfect. Thank you so much. All right, everybody. So today we're going to be building a lending protocol and we're going to build it with polygon. But that's only because we want this thing to scale. We want to be able to affect as many users as we possibly can with this. And we want it to be something that they would actually use.
00:00:40.602 - 00:01:12.674, Speaker B: So that means low gas fees and high throughput for each transaction. Really, that's the two key metrics we're looking for. We want to build a decentralized lending protocol. So I'm going to share my screen and we're going to go through this process together of building it. And I might talk a little bit about the background of polygon as well before we get started. Feel free to ask questions. During this, I'm going to be periodically checking in for questions and then we're going to take some breaks to answer questions.
00:01:12.674 - 00:02:00.514, Speaker B: Okay, so this is the repository I want to talk about here. This is a repository by Alejo Costa and it is the ERC 20 token vault example project. And I think this is the best way to get started with lending. There's so many different lending sample applications on GitHub and across the web, but a lot of them are 2000 plus lines of code. This one in particular, it's like 120, which is still a lot. But I think it's the easiest way to get started understanding what these steps look like in the lending decentralized space. So we'll start off with this project description and then I'll talk a little bit about why Ethereum and why polygon specifically that we want to build with.
00:02:00.514 - 00:02:42.670, Speaker B: So at the highest level, the idea here is that we have a user and the user is interacting directly with a vault. And this vault is represented by a smart contract on the ethereum blockchain. So that is the human to machine interface. It is from a user to a vault. And what a user will do is they will send some ETH to the vault and the vault will then say, okay, now you've given me, say, 20 ETH, I'm going to give you that amount but in USD. So in order to be able to convert the cost of ETH that was deposited with the price of USD per ETH at the time, the vault is going to communicate with what's called a Price Oracle. The price.
00:02:42.670 - 00:03:31.358, Speaker B: Oracle is like a decentralized API. It's going to return a boolean value, not a Boolean value. It's going to return an unsigned integer value that represents the price per Ether in USD. And that's going to act as the one source of truth, that's off chain that the Vault smart contract is interacting with. Once it knows the price, it's then going to interact with the only other smart contract here, which is a stablecoin and that is represented by Coin sol and it's going to mint that equivalent amount of stablecoin. And then the user will then receive that stablecoin as a loan at any time up to a certain time period that we define programmatically. The user can return bits and pieces of the loan that they asked for and then they can get their collateral back.
00:03:31.358 - 00:04:31.482, Speaker B: Or they could pay a lump sum all at once and then receive it then. Now why is this better than traditional lending? Great question that I'm asking myself. It's because we want this to be able to be offered to people who don't have access to financial instruments, particularly in the developing world, large parts of Africa, India, South Asia, we need to get them like lending solutions ASAP today. So, you know, it doesn't really matter ideologically too much about which blockchains you're building with. All that matters is will users find a benefit from it today, will it make their lives better? And I think for a lot of small business owners, especially in agriculture tech, who are looking to grow their farms and we need sustainability and food solutions so badly, you can't really necessarily get that from a bank in a lot of countries. So they have to turn to protocols like this. So I think if you are a developer, now is a really exciting time to be building with these tools.
00:04:31.482 - 00:04:59.194, Speaker B: And I want to kind of show you what the stack is going to look like as we do this together here. So this is a good starter example and we can see that it exposes five main functions. Deposit lets that process that I first outlined, or we give it ETH. Withdraw is when we withdraw our Ether. Get vault gives us the total amount of collateral in the treasury of the smart contract. Estimate collateral amount, that is a machine to machine call. We don't interact with that.
00:04:59.194 - 00:05:20.722, Speaker B: That is what the Vault smart contract is going to ask the Oracle. And then there's estimate token amount. Again, a machine to machine function, it doesn't deal with us. All we do is deposit and withdraw. That's all we do as humans. But estimate token amount will estimate the amount of stablecoin to be minted given the Ether. So that's it.
00:05:20.722 - 00:05:55.230, Speaker B: Let's see what they're talking about in terms of installation and then running it. Okay, so it seems like we need two libraries here, Truffle and Ganache. And you're going to see these two libraries pop up all over the place when it comes to smart contract development. Now, if we wanted to just build this with Bitcoin, which is if you look on Coin market cap, it is currently the biggest cryptocurrency in terms of market capitalization. It's been around the longest. The only problem with Bitcoin is that it's not Turing complete. So there's a scripting language that comes with Bitcoin that is not Turing complete.
00:05:55.230 - 00:06:41.014, Speaker B: So we couldn't technically build something like this if it say had a for loop embedded in the code nor could we do a wide number of different computations. And that's why number two is Ethereum. Ethereum. Is Turing complete? It does allow you to be able to do anything that a virtual machine computer would be able to do and so that's what the origin of that computer science term is. But the problem with Ethereum, and this is the problem with every blockchain, not just Ethereum is that it has this thing called the blockchain trilemma. You may not have heard of it. The blockchain trilemma essentially states that you have three possible features that you can have but you can only pick two of these three.
00:06:41.014 - 00:07:19.314, Speaker B: So there's scalability, security and decentralization. You can't have all three. You can only pick two. What Ethereum has done is it has picked security and decentralization at the cost of scalability. Now how are they going to get scalability? This has been the hottest topic in the Ethereum community perhaps since its inception about eight years ago and there have been a wide range of solutions that have been proposed. The Ethereum core team primarily vitalik divides these classes of solutions into two layer one and layer two. Layer one is the main chain and layer two is the side chain which consists of a series of solutions.
00:07:19.314 - 00:07:49.618, Speaker B: E two isn't a one day event. It doesn't happen on June 1. Boom, e two is out. It's not like that. It's a series of upgrades that are made to the software over the course of hopefully this year. In terms of layer one solutions the ETH core team is working really hard on what they can control. That means sharding sharding is this idea of splitting up large chunks of data into smaller chunks and then having that spread out in a more distributed fashion across the nodes and that will hopefully speed up the main chain, layer one.
00:07:49.618 - 00:08:39.422, Speaker B: Then there's increasing the block size. That could speed things up. There's switching the consensus mechanism from proof of work, which is primarily what Bitcoin uses right now, to proof of stake where the network is not secured by computing power. Computers doing random mathematical work, solving the associated hashes for any changes in data takes forever to do that. Instead of doing that, the network consensus is decided by the number of tokens that each delegate in this space, or validator I should say, has who is securing the network. So it's more representative rather than direct. Is it as powerful as proof of work? I mean, Ethereum already uses this on a side chain and there are plenty of chains that are already proof of stake including polygon but those are layer one solutions.
00:08:39.422 - 00:09:05.030, Speaker B: You need layer two as well. They're both essentially a part of it. And layer two solutions include plasma side chains. And that's what Polygon is right now. It includes state channels. If you ever heard of the Lightning network for Bitcoin that uses what's called state channels. And then the end game, vitalik literally called it the end game in his last blog post, I think it's called Endgame, literally is what's called zero knowledge roll ups.
00:09:05.030 - 00:09:35.726, Speaker B: And Polygon has acquired a billion dollars worth of these zero knowledge roll ups. Here's the blog post I'm referring to. Endgame. Definitely read this if you're looking for a great read, but it's his last blog post. Anyway, the end game is our zero knowledge roll ups and Polygon has acquired so many of these different zero knowledge roll up startups Maiden and several others. Hermes because mere protocol. Because in order for Ethereum to be able to scale, it's going to need layer two solutions like Polygon.
00:09:35.726 - 00:10:21.726, Speaker B: So what does that mean for us as developers? We want to not get too confused here. We want to be able to build for a single stack and then just have that work for as many people as possible, right? We don't want to be building different things. Now, the great thing about Polygon is that if you are an Ethereum developer already, you are already a Polygon developer. So that means that you still program in Solidity, you still use Ganache, you still use Truffle. The entire stack is the exact same. Now, what's the difference? We're going to go into that difference today. It is a single line of code in your Truffle config JS file where instead of deploying your DAP to the Ethereum testnet, the London testnet, you deploy it to the Polygon testnet, the Mumbai testnet, and that is a simple single line RPC switch.
00:10:21.726 - 00:11:01.150, Speaker B: Once you make the switch, then everything is going to be deployed. And what happens is that on the network, what the validators of the network, the people securing the network that are paid to do so. What they're going to do is with zero knowledge roll ups, they're going to take many, many transactions, hundreds, thousands of transactions. They're going to roll them up into a single compressed hash. This hash represents all of those transactions. They're then going to communicate to the Ethereum main chain that, hey, I have all of these transactions that have been happening on my chain. They have not been using a lot of gas, they've been very fast, high throughput sub millisecond transactions.
00:11:01.150 - 00:11:50.462, Speaker B: You need to post a proof to your chain that these occurred. Ethereum is they're going to ask that transaction, it's going to ask that validator. Well, how can I know that these are valid transactions then? What the Validator will do is they're going to generate what's called a zero knowledge proof and that is a mathematical proof that's going to be able to tell the main chain, I can prove to you that all of these transactions are valid. With you having zero knowledge of the identities and the details and the metadata of those transactions. And that process is actually very difficult. It is in the RND stage right now. How do we design these ZK proofs? There are different versions of these ZK Starks, ZK, Snarks, Plonky, Two, all of these different acronym names that essentially represent the same idea.
00:11:50.462 - 00:12:28.694, Speaker B: And that is compressing transactional data into a smaller package that can then be pointed to from the main chain for its validity and doing this in the fastest way possible. But all of that is to say that we as developers can deploy our lending DAP to the Polygon chain. It will automatically be deployed to the Ethereum chain, and we don't have to worry about too much other than the specifics of our DAP and what the architecture looks like and what the experience looks like for end users, which we'll go into right now. So if I'm a new developer, I want to learn about Polygon. I'm looking at the basics on the website. Okay. It's a POS chain.
00:12:28.694 - 00:12:43.362, Speaker B: It's got some basics. Architecture looks cool. Got this nice image here. Awesome. Where do I begin? So let's start with this repository right here. So we're going to download this right here. We're going to do this together live.
00:12:43.362 - 00:13:05.154, Speaker B: We're going to download this. And while this is downloading, I'm going to periodically take some questions here. So let me just see how to see some messages here. Chat. Okay. We could use quantum computing. Okay, so Bitcoin is already quantum resistant.
00:13:05.154 - 00:13:31.994, Speaker B: The Core developers have been thinking about this for a long time. There are quantum resistant consensus algorithms already embedded in Bitcoin core, which is awesome. So we're okay for now. In terms of quantum resistance in Ethereum, that is also being worked on. Not at the same degree. Are we going to do it in parallel? Yes. Let me send this GitHub repository to everybody in the chat.
00:13:31.994 - 00:14:04.518, Speaker B: Let me answer questions for a few more minutes. How does polygon put proofs to the main chain? Is it using one of the ZK proofs algorithm? Yes, it's actually using both of the ZK proof algorithms. It's using ZK Snarks and ZK Starks. Okay, so these are both acronyms. We can go into the details, but Midn is the Snarks, and then I believe Starks is the Mirror Protocol acquisition. So they're both doing it differently in order to build with this. We're actually actively working on this in terms of, like, privacy and the associated features.
00:14:04.518 - 00:14:23.746, Speaker B: The link is not working. Let me see why the link is not working. Oh, you're right. Why is the link not working? Let me fix that right now. Here, this one will work. GitHub seems down. Oh, GitHub is down during a talk.
00:14:23.746 - 00:14:37.638, Speaker B: What? Unbelievable. How is GitHub down? That's crazy. Well, luckily, now this works. Okay, great. Okay, that worked. Okay, so let's go back to this. Let's start building again.
00:14:37.638 - 00:15:03.310, Speaker B: I'll remove the chat. Okay, so we have this lending DAP. It's this smart contract. We want to see what's in there. So we're going to open up node, we're going to CD into that directory, wherever that was, the downloads folder. Once we're in there. What's this called? This is called lending, DAP.
00:15:03.310 - 00:15:30.996, Speaker B: Let me just find that file. Hold on. Okay, hold on. CD into that, make sure it's there. It is unzipping, I guess it's quite big. It's quite big. Okay, great.
00:15:30.996 - 00:15:55.736, Speaker B: We got it here. All right, so let's build this. So we got to open this up in a text editor, see what's happening here before we do anything. So we'll open it up, see what's happening here. Okay, so we got some code, we got some packages. Okay, so Open Zeppelin is going to be used. It's like this test framework for building smart contracts.
00:15:55.736 - 00:16:19.024, Speaker B: It's got a lot of templates. And yes, it's good for running on Windows, by the way. And then Truffle is essentially our smart contract testing platform. It's got everything we need. But Open Zeppelin is for templates for very popular smart contracts. Stablecoins ERC 20s, NFTs ERC 721, all this stuff. There is an existing Open Zeppelin template for.
00:16:19.024 - 00:16:52.428, Speaker B: So that's package JSON, it contains our dependencies. And then we have this very crucial line here. Now, Truffleconfig JS basically tells Truffle where to deploy our DAP to, and we can see that for the networks listed here, we have one main network, and that's Covon infura. Now, this is going to link us directly to the Ethereum testnet. Now, if we want to switch this to polygon, we merely switch this link, and that's what we're going to switch when we do that. But let's just run this first. Let's see if this can run, given what we have.
00:16:52.428 - 00:17:23.130, Speaker B: Now, remember, here are the smart contracts I was talking about. When it comes to lending. We have this stablecoin token, and all this will do is it will mint new stablecoin. Every time that a user deposits some ETH. It will automatically mint that equivalent in USD stable token for the amount of ETH that has been deposited as collateral, and then it will burn it whenever someone withdraws their collateral. So it's not going to have that amount. So that's kind of the idea.
00:17:23.130 - 00:18:18.564, Speaker B: Say someone returns their money early, then it's going to be returned early. What do you mean by if we deploy on polygon, it is automatically deployed to Ethereum? What I mean specifically is that the polygon blockchain, it has timestamps of all the actions that occur that are occurring on the Ethereum blockchain. Actually, Satoshi, when he first wrote the white paper for bitcoin, he never used the word blockchain unbelievably. He used the phrase time chain to describe the bitcoin blockchain because essentially what it is is it's a collection of immutable timestamps. It represents time in an unchanging way. Just like time cannot be changed, the bitcoin blockchain cannot be changed. And in that way, the Ethereum blockchain, the time chain cannot be changed.
00:18:18.564 - 00:18:56.180, Speaker B: And what I mean specifically by connecting is that all of the activity that happens on Polygon is as valid as all of the activity that happens directly on the Ethereum time chain because there are still timestamps of it. But what we get as developers is we get to deploy adapt today that lets our users pay much lower gas fees. If you've ever had to use Ethereum, you know how much gas fees are. They're very expensive. You're going to lose a lot of money. People don't have the money to be paying for gas fees like that. And also throughput it's a lot of congestion on the Ethereum main chain, Polygon.
00:18:56.180 - 00:19:43.844, Speaker B: There are a lot faster transactions on Polygon. One more question then. We're going to keep going here. So is that Ethereum trust Polygon or Polygon works the same way as any other contract and the proof of work, miners have to validate that anyway, but as a whole commit basically bundle transactions, ethereum is able to there was a proposal for this specifically to accept zero knowledge proofs as trustless data. I don't remember the specific protocol number for that proposal, but there was an actual proposal that was accepted by the Ethereum Foundation into yes. Being able to give these trustless smart contracts validity. All right, let's keep going here.
00:19:43.844 - 00:20:14.440, Speaker B: So there are four different smart contracts here. Like I said, stablecoin does what? I said mock oracle. All this well, this one's actually a fake one. We don't have to worry about mock Oracle. We're not even going to use that. We're going to only use three coin sold to Mint Stablecoin price consumer to get the price of Stablecoin at the time USB from Ether from this contract address right here. Now this is a test smart contract on the main chain that already has a price aggregator.
00:20:14.440 - 00:20:41.732, Speaker B: So it's already pulling from it. All we have to do is transact with it and it will tell us the price, the transaction parameter, the input is going to be the amount of Ether. The output that it's going to give us is going to be the amount of Stable token. All right. And then the last one, this is really our main smart contract. This is the vault. And the vault is essentially a lender, except it is a human less lender.
00:20:41.732 - 00:21:30.036, Speaker B: It is totally automated. It is a fully automated lending platform that nobody runs. All of the transactions are publicly verifiable on this public time chain called the Blockchain, the Ethereum and the Polygon blockchain because you can actually explore both blockchains using Block Explorers, which are web apps. Okay, so let's just briefly go over this before we deploy it. Like I said, it's got the deposit functionality and that is going to take our deposit amount in Ether and then buy that amount or mint that amount of Stablecoin sorry. And return that to the user withdraw will do the opposite. We can withdraw our collateral and then it's going to burn the amount of stablecoin that it had reserved for us so that nobody gets it because you got your collateral back.
00:21:30.036 - 00:21:58.376, Speaker B: These are all helper functions getters and setters for different variables. But those are really the two key user facing functions deposited and withdraw that we'll want to work on. Okay, so those are the solidity files, three of them. And we have the migrations file, which is just kind of boilerplate code for truffle. We have initial migrations again, boilerplate truffle. So let's deploy this to the testnet together. So if we go here, we'll look at the two dependencies we have to install.
00:21:58.376 - 00:22:29.016, Speaker B: Okay, we're going to install both of these. Let's make the terminal a little bit bigger, pseudo install. And once I do that, then I'm going to do the same for Ganache, which is our test blockchain. Then I'm going to run NPM install to install the rest of our dependencies. And then we can actually run this. And once we run this, it's just going to be a collection of smart contracts on the ethereum testnet. Then we're going to need to move it to the polygon testnet by changing that truffle config file or line, I should say.
00:22:29.016 - 00:23:18.200, Speaker B: And then that is when we're going to be able to add a user interface to this. Right? Because smart contracts are great, but we want to be able to let the user interact with these smart contracts from the web deposit, add their MetaMask account, be able to say, hey, I've got ten ether in MetaMask, but I want a loan. Let me go to lendingdap.com and deposit that ether. It's going to connect to MetaMask. It's going to return stable token, let's say USDC to that same MetaMask account and fully automated, right? And it's interacting from the web with this smart contract on the ethereum blockchain. Now, where does this DAP live? Where is it stored? Right, that's a good question to be thinking about as we go through this thought process.
00:23:18.200 - 00:23:50.468, Speaker B: It's going to be stored on the Interplanetary file system, which is a decentralized AWS bits and pieces of our web app. DAP are going to be running from across different nodes that don't know each other, but that are all paid with their own token. It's called filecoin. But we don't have to look at any of that. We can deploy it directly using this great interface called fleek co. And fleek co is awesome. It's free.
00:23:50.468 - 00:24:11.828, Speaker B: It's a way to deploy an app. Think of it like a decentralized heroku. We just deploy our app to fleek. It will deploy it to a collection of IPFS nodes for us. And then all of this is timestamped on the ethereum blockchain. They're pointers to all this data. So that's the way to think about this architecture.
00:24:11.828 - 00:24:36.336, Speaker B: We have smart contracts, we have a user interface. The smart contracts are on the ethereum testnet, and then they're on the polygon testnet. Once we switch that and then we have the data that's stored in IPFS via fleek. And we as users interact with all of this via our regular Chrome or whatever mozilla web browser that we're using or Brave. And that's it. That's how it works. So let's do that now.
00:24:36.336 - 00:25:07.768, Speaker B: And I see that some people have some problems with installation that is going to happen. Did I have any problems? No, I did not. I personally did not have problems. Let me install ganache. I installed truffle. Now I'm going to install Ganache in terms of issues that could always happen, but for that, there's always stack overflow. I guess I could answer some questions here too, but let me continue this because I feel people would enjoy this.
00:25:07.768 - 00:25:43.428, Speaker B: So we installed both of our dependencies Truffle for building smart contracts, ganaj for running this on a test blockchain, and NPM Install for installing literally everything else. And then once we have that, we can run these tests and it's going to compile the smart contracts for us. Then we'll have to add a user interface to actually use yeah, let me see some of these chats. Can we actually mint USDC? I thought we meant a new stablecoin. Actually, Mark, you're right. These are new stablecoins. I just have a habit of calling stablecoins USDC.
00:25:43.428 - 00:26:40.708, Speaker B: But there are a wide range of stablecoins and it's not USDC. If we wanted USDC, we would use the USDC API specifically. But no, we're minting a new stablecoin one to one with the US dollar. Won't hosting it on IPFS slow down the process? I mean, slow down the website? So IPFS will not slow down the process if the nodes are located close to where the user is interacting with them. So basically, the more decentralized the DAP is, the more nodes there are, the faster it gets. So it's kind of this positive feedback loop where the more people that use it, it inherently gets faster without necessarily having to optimize a bunch of things manually. It's just the nature of how the distributed web works where it is not IP addressed, it is content addressed.
00:26:40.708 - 00:27:18.390, Speaker B: So the more decentralized and all over the web these pieces of content are, that means the more users that are fetching and getting and sending this content, the faster it gets because the content is then replicated more. And so it does basically depend on the number of nodes pleak can pin your content to. Yes, and you're right, it doesn't require pseudo. I just pseudo everything because I don't like errors. So let's run this test blockchain here. Like I said, we're going to run the test blockchain, make that bigger. So now Ganache is going to be running at port 75 45.
00:27:18.390 - 00:27:37.292, Speaker B: It's going to give me back a list of contract addresses. Okay, so now I've got these ten contact addresses, contract addresses. Each has a million ether. Don't worry about stealing them. They're all on the test net. So the money isn't real. But what is real anyway? That's a good question to ask.
00:27:37.292 - 00:28:29.704, Speaker B: What is real? Let's now execute the test suite. We have our contract, we have our testnet running of Ethereum and now we can run the testnet. So, unexpected token, what is going on here? Okay, so of course there's going to be a little issue when I try to run the test suite. So as any great or mediocre, I should say developer, I'm going to go to Stack Overflow and I'm going to see what the hell the problem is here with Truffle deploy. In terms of catch, there's a syntax error. Okay, so this person's getting it as well. It can be avoided using Bash.
00:28:29.704 - 00:28:56.772, Speaker B: I'm not on Windows, so why should I? Okay, this specifically doesn't matter to me. This is not related to my problem. But I have Ethereum Stack exchange here. Okay, so this was a single line. You got to delete the line in deploy Contracts JS. Okay, got you. Right? Just delete that file and edit it.
00:28:56.772 - 00:29:27.790, Speaker B: Got you. So I will do that. I will delete that file and edit it. Delete contracts, deployment JS and then in initial migrations, I'm going to deploy it says, change this to your contract name. So I will change that to Migration deploy to I'll just create a new file. Test. Call it test.
00:29:27.790 - 00:29:50.056, Speaker B: And it's called test sol. And it's just got nothing in there. And this is going to call migrations. Oh, not soul. I need to call it test. JS I'm going to remove this from okay, let's try that. JS whatever.
00:29:50.056 - 00:30:13.772, Speaker B: Okay, let's see if that works. Nice. That did not work. Okay, that's okay, that is fine. So we're going to do something different here entirely. We're going to deploy this to the web via Remix. Because Remix is a web IDE, we can just as easily deploy it.
00:30:13.772 - 00:31:01.960, Speaker B: But we don't have to deal with this right now because I'm probably not going to fix this within an hour. Okay, let's deploy this to Remix, which is a better way, a faster way, let's say it's not a better way, but it's a faster way. Yeah, let's see some of the oh, it might be the env variable right to the live demo. Gods. Yeah, that's how it is. That's how it is, right? Okay, so we're on remix. We're going to deploy this smart contract to Remix and we're going to call it what are we going to call it? We're going to call it lender Solnder solidity.
00:31:01.960 - 00:31:29.868, Speaker B: It's going to open that. I've got Lender solidity here. And then I'm going to go back, I'm going to see what are my three. All I care about really, from this repository are three different contracts. That's it. And I can deploy them from here anyway, right? So interfaces. And then I have the vault.
00:31:29.868 - 00:31:45.128, Speaker B: So the vault is easy. It doesn't. Have any dependencies. So I can just start with this one right here, the vault. And I will deploy that to remix. Just like that to remix. Here we go.
00:31:45.128 - 00:32:04.780, Speaker B: We got the vault. All right. And I'm going to call this I'll call it iVAULT. Yeah. Okay. So once that's there, we can compile it by going to the compiler and compile lender sol. That's going to compile this smart contract.
00:32:04.780 - 00:32:35.216, Speaker B: And once it's done compiling I think I compiled it. Yes, I did. Okay. I can publish it to IPFS. And this is going to give it a content address. These 25 characters are the content address that represents the smart contract. And then in the smart contract, what we can do if we want to create files for users and records for rows and different things, is we can add to this what IPFS, the file structure.
00:32:35.216 - 00:33:18.336, Speaker B: The way it works is it is a directed acyclic graph, a dag, a merkel dag. That means that for every new piece of data, a new node. In this merkel dag, it's kind of like a tree, a binary tree. It's very similar, is created. And all of these dags create new hashes and all the hashes point back to the mother hash, like the main hash from which everything chains off of. And so the highest level, you can think of our website, our DAP, as having a single hash that represents all of the content, all of the data inside of it, which is nested inside of this merkel dag, which IPFS creates. It's kind of like a file structure, but we don't have to worry about that functionality.
00:33:18.336 - 00:34:02.884, Speaker B: IPFS does it for us. All we need is the highest level hash of our content, which can be accessed via the IPFS web. And what Pleak does is it is a gateway between the IPFS web and the Http web so users can interact with your DAP but from the Http www web two, right? So they don't have to switch anything up too much. There's a gateway until there are native browsers for IPFS, which in a way, Brave is doing that and others. So let's keep going. We compiled it. Now we're going to deploy it and okay, it may be abstract, not implement an abstract parent.
00:34:02.884 - 00:34:22.932, Speaker B: Samantha completely. So we're going to get creative here and we're going to go ahead and do this locally. I know what to do. So here's what we're going to do. Because this doesn't want to play with us. This is development, by the way. I'm showing you the pain of development.
00:34:22.932 - 00:34:37.480, Speaker B: It's going to be hard, but then it gets easier. Let's keep going here. I have a great solution to this. We're going to go to the Academy. This is a newer initiative that we're launching at Polygon. It's called the academy. If you ever wanted to learn how to build with polygon.
00:34:37.480 - 00:34:52.832, Speaker B: I've been personally working on this for a few months. This is the best learning resource. I've curated all of the best from across the web. It's a great learning journey from start to finish, top to bottom. You'll earn NFTs as you do it for free. There are four levels. Check it out.
00:34:52.832 - 00:35:24.204, Speaker B: Academy polygon technology. All right, but what we're going to do is we're going to go to this DApp Starter kit, and we're going to add our smart contracts for this Lending DAP directly to the Starter kit. So it's already got the front end for us. It's already got the integrations we need with Truffle and Ganache and OpenZeppelin. And so we just have to run it, download it, compile it. Let me send it in the chat so people have a link to it, the Starter kit. So everybody has it.
00:35:24.204 - 00:36:00.458, Speaker B: Let me see what's going on. So definitely check out that link. I just sent it in the chat. I've downloaded it locally. We're going to run this starter kit and then add the Lending DAP smart contracts to it directly. So it's unzipping. I already have Ganache, I already have Truffle, and I'm going to create a new react app with the template polygon starter kit.
00:36:00.458 - 00:36:30.780, Speaker B: Okay, so I'm going to name my project something, and then with NPX, I'm going to do a different so Ganache is running, right? Ganache is already running. We just need to deploy some Lending DApps smart contracts to this. So I'm going to make sure this is open starter kits. And right now, let's see what it's doing. It's expanding it, so it needs to be able to expand that. Okay, look, it's got it. And now I will add it.
00:36:30.780 - 00:36:55.140, Speaker B: Hold on. Make sure I can add this. I can CD into it. Okay, so I'm in there, and now I will run this but my way. So it's going to be the project name is Blender, and it's going to have this starter kit here. Okay. Create react app.
00:36:55.140 - 00:37:12.982, Speaker B: Boom. Okay, so it's creating a new react app, installing the components, doing everything it's got to do. We're moving. We're going in the right direction here. We have Ganache running. We have a testnet waiting for us. Okay.
00:37:12.982 - 00:37:41.350, Speaker B: And actually that testnet right now, we can switch to polygon, by the way, so let's do that. So go we'll to Ganache run polygon command or something. What is it? It's like, run it on polygon. I think it's like yeah. CLI. Yeah. What is it with CLI? We can do it from the CLI.
00:37:41.350 - 00:38:11.794, Speaker B: All right, so this is taking a lot of doing a lot. Right now, let's do one thing at a time. So this is still loading. Okay, good. Let it load CLI and then we switch the network to polygon. There's a specific command I'm looking for right now. Yes, here it is.
00:38:11.794 - 00:38:52.462, Speaker B: It is in the docs. All right, so ganache CLI. There's a CLI. Okay, interesting. He's done. We'll testnet. So here's like that.
00:38:52.462 - 00:39:14.572, Speaker B: So we'll just do that. So we have that running in a different tab on terminal. I think that's going to work. Yeah. Okay. So now this is running on polygon. Our testnet is running on polygon.
00:39:14.572 - 00:39:40.504, Speaker B: We can close out the ethereum one. And this is at a different port. Now this is at what is this? This is at port 8545, not 7545-8545. So we have that good. We have our polygon blockchain running. We are waiting on the starter kit to load. We are so close to it.
00:39:40.504 - 00:39:59.312, Speaker B: So this will load. We'll take those solidity smart contracts that I explained, we'll add it to this. And then we'll have a user interface ready. Then we can deploy it to fleek. And we have a.com website, whatever, web two gateway. We call it specifically to access the decentralized web.
00:39:59.312 - 00:40:33.912, Speaker B: Okay, so I'm running pretty lost. Okay, let's slow it down then. We need to make sure we have everything for the starter kit running. So all I'm trying to do here, guys, is create this starter kit, which contains all the dependencies we need. That's all. And if we have that, we can CD into it and then we can just run it. Let's run this starter kit and also see what it looks like inside.
00:40:33.912 - 00:41:05.618, Speaker B: So I'll open it up with Sublime, and I'll also a bunch of node modules. It's got a package JSON. I can NPM run. Start that starts it locally. Missing the start script. Okay, how about now? It needs something else. I think it needs some test stuff.
00:41:05.618 - 00:41:26.440, Speaker B: No? Let's see. MPMI. Yes, that's the one. Thank you. Watch, it's going to get mad at me because I didn't pseudo, but that's okay. Yeah. All right.
00:41:26.440 - 00:41:41.050, Speaker B: Yes. Please ask all questions here. Thank you. Okay. Permission denied. See, I knew the pseudo would fail. Or the lack of pseudo, I should say.
00:41:41.050 - 00:42:09.794, Speaker B: Pseudo MPMI. See, this is really like that final step to really make sure everything's working here. Yeah. I just need to install this basic set of packages to run the starter kit. And then we're going to add the smart contracts and then deploy it to fleek. Right. Build it, have it run locally, make sure we can visualize it, it's on localhost, it's connected to the testnet.
00:42:09.794 - 00:42:40.542, Speaker B: And then add the smart contracts for lending, deploy it to the test blockchain, deploy it to fleek. Show people, show investors, raise money, rocket ship to the moon, go crazy in a good way. So that's what we're trying to do here. We're trying to build high quality DApps that people actually use. We don't want to just build another DAP. We want to actually build something scalable here. Yeah.
00:42:40.542 - 00:43:19.302, Speaker B: So we are using the starter kit to create a new react app. And then we have this set of smart contracts that is not user facing at all. They're just like test smart contracts. But what we're going to do is we're going to combine these two repositories into one in a lot of development today is essentially combining repositories right. And creating something novel. Something novel is almost always, if not always, a combination of the sum of its parts. Nothing is truly unique except it is a unique combination of what already exists.
00:43:19.302 - 00:43:53.960, Speaker B: So we have a starter kit. That one thing it does really well is it combines all of the necessary dependencies into one repository. Well, so nothing breaks. And then we have the lending smart contracts. And what it does well is it allows a user to be able to get a loan without having to consult a human to do that. So how about both? If we have both, that's why we're combining them, then we can have something that scales. So this is going to take a while to load the dependencies here.
00:43:55.050 - 00:44:03.926, Speaker A: Hey, siraz, sorry to interrupt, but we're just running a bit overtime. Maybe you can take some questions, wrap up and we can move it to discourse.
00:44:04.118 - 00:44:17.998, Speaker B: Yeah, sounds good. Sorry about that. We can take joanna asks. I'm building planet Earth. Global digital jurisdiction. Starting to build an interface with proof of humanity. Very cool.
00:44:17.998 - 00:44:51.874, Speaker B: Allowing people to get Planet Earth Global passports to live and work wherever they want. Do you think I can build this on polygon? So, first of all, that's a really cool idea. I love that idea. We definitely could use that as a society. So I just think that's a really cool idea in terms of can you build this on polygon? Yes, you can. I think it would be the easiest to build this on Polygon today. If I were to build something, I would do it with Polygon today because I want it to be scalable, turing, complete, but I don't want it to be slow and expensive.
00:44:51.874 - 00:45:29.910, Speaker B: So that's why I would make it for Polygon and especially for people in the developing world who can't afford some of that higher gas fees because they're priced in a different country's currency and subject to inflation and all of that. Your zip code where you live should not define who you are and the tools that you're able to use. Yeah, I need to install dependencies before the next session. Next time we're going to continue this on Discord. Yeah, we have an East Global planning meeting today as well, so that's going to happen in a few hours. We'll continue, I'll be on Discord.
00:45:31.850 - 00:45:43.270, Speaker A: Thanks again, siraj, very informative session. And yeah, if you have any more questions, we'll catch up over Discord and look forward to seeing you for the next workshop with Covalent. See you there.
00:45:43.420 - 00:45:43.894, Speaker B: Thank you.
00:45:43.932 - 00:45:44.690, Speaker A: Thanks, bye.
