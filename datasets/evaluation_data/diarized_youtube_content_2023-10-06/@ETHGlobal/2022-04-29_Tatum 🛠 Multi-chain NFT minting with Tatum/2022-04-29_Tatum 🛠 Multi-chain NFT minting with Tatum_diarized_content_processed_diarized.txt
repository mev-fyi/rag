00:00:34.090 - 00:01:01.878, Speaker A: Very briefly. What is Tatum? Tatum is a framework which helps developers build applications fast on different chains and on different protocols. We support a lot of features out of the box. You don't have to build your own node. You don't have to do the RPC calls. You just call one of the ready to use features and you can integrate it directly into the application. You can build basically any app.
00:01:01.878 - 00:01:44.070, Speaker A: You can build NFT Marketplace, you can build the wallet, you can build some D Five protocols, whatever you want. It's just up to you on more than 40 different blockchains. What's the benefits? Or why should you choose to work with some framework over the native RPCs? You don't have to know blockchain. You don't have to know how RPCs work. You just need to know how those common features works under common features, or like ready to go features from us. I mean, Mint NFT operation, create wallet, operation, sign transaction, operation. Something very, let's say, easily understandable from the developer perspective.
00:01:44.070 - 00:02:30.226, Speaker A: What actually like. What was the development process of building an app inside Atom. You as a developer will start with playing around with the APIs. You obviously has an idea. What do you want to build? You will just take a look like, okay, I'm going to build, let's say, NFT Marketplace. What I need to do that, I need NFT contract, I need some wallets, I need some APIs. But you find out, okay, Datum gives me, let's say, 90% of these ready to go features, but I need like 10% of some custom RPC call or some custom operations you need to do on a blockchain.
00:02:30.226 - 00:03:11.956, Speaker A: We don't lock you inside the tools we give you. And every good framework should give you freedom. And the freedom means if you don't find the things you need in the framework, you just go a level below that framework, and the level below is of course, RPC nodes. With the RPC node, you can do whatever you want. And that's basically very quickly the slides. And now I'm going to focus on some real live demo, real live hacking. I'm going to show you how the platform works, what you need to do.
00:03:11.956 - 00:03:49.460, Speaker A: We're going to Mint? NFDS. We're going to mint NFDS on solana. We're going to mint NFDS on polygon. I'm going to show you how Datum Kms works, what it actually is, and I'm going to show you how you can interact between Datum and a MetaMask if you want to build some kind of DeFi application. So let's quit this. Let's open postman. My best friend, and from the start, this whole postman collection and every example I'm going to show today is available on our public GitHub.
00:03:49.460 - 00:04:23.624, Speaker A: I believe you can find GitHub.com Tatumio, and when you search for the repositories, it should be DevConnect 2022. So there is visible Postman collection, there is present Postman collection MetaMask page I'm going to show later today and some README files. So everything is there. You can just play around by yourself. So today's workshop is going to let's say I'm going to shoot like three different topics. First topic, the most important one is NFTs.
00:04:23.624 - 00:05:23.116, Speaker A: I believe you're all curious, like how to work with NFTs. You don't know solidity, you don't know rust. You want to mint NFTs on Solana, on polygon, on anything else out there. And for that, we have done the abstraction for you, which means we have a ready endpoint where you can very easily mint NFT on the chain of your choice. The interface of basically all operations we have is trying to be as abstract, as similar between different chains as possible, which means most of the time what you need to change what you need to change when you're doing cross chain application and working with polygon or ethereum or I don't know, solana is just the chain parameter inside the request. You choose Sol, we're going to work with solana, you choose ETH, we're going to work with Ethereum. But let's start from the scratch.
00:05:23.116 - 00:06:09.984, Speaker A: Let's start from the first operation. In order to, let's say, work with NFTs, or let's say you want to build an application, your user has to have a wallet or address or something where he actually receives the NFT, or for the address from which he want to send some other transaction, maybe Solo or the NFTs away to someone else. We give you the choice very easily to just generate a Solana wallet. And the result of the operation is address and the private key. I want to say out loud that don't use this endpoint in your production apps because it exposes the private key. It travels through the Internet, which means it's compromised. You shouldn't use it.
00:06:09.984 - 00:07:09.270, Speaker A: Of course, we give you other tools which you can use locally in your app, like some client based SDK or Tatum Kms or Tatum CLI, where you can generate those wallets or do any operations with a private key securely in your perimeter. So we've created a wallet. I think let's use it like this for the demo purposes. I don't care what we have actually done. We have called an API call to our EU region, and you need to pass an API key you can obtain in our dashboard when you sign up, which I forgot to show you how to actually do it. So if you head to the Tatum IO, you hit get started. You can create an API key here.
00:07:09.270 - 00:08:01.140, Speaker A: You sign up, you create an account, and you can create free API keys for which you can build, you can run, you can play around in the list of the API keys. Of course, you can show it, copy, paste, use it in your app. So let's get back to the postman. So I have created an address. I should obviously send some Solana tokens there from the faucet so I can perform some transactions. Let's use Sol Faucet when you create testnet API key in our platform. For Solana, we are using DevNet because it's a chain which should be used for developers.
00:08:01.140 - 00:08:35.900, Speaker A: So let's send one soul to my address and let's check if it's there or not. Looks like it is. So I have some balance to work with right now. The next step for you, you create an address for a user or for your application. And right now we want to mint NFT. For minting NFT again, we have another operation which is mint NFT. Surprise, surprise.
00:08:35.900 - 00:09:19.516, Speaker A: And there are some couple of important fields you need to enter in order to mint NFT for Solana. This is a little bit different than for EVM chains. I'm going to show you later how to mint NFTs on a polygon, which is same for any EVM chain. But for Solana you just need to specify the metadata. The metadata are stored on chain in comparison with EVM chains, where you are storing just the URL to the IPFS or some other third party metadata storage. And we are going to use the address on which we're going to mint the NFT. So the recipient is going to be our address, and the minter could be our address as well.
00:09:19.516 - 00:10:00.360, Speaker A: Let's use the private key of our created address and let's mint the NFT. I'm going to mint the NFT. Some random stuff with some default metadata name, symbol and URL of the image. Yeah, I forgot to enter the verified creator, which is myself. And the result of the operation are three fields. The first and the most important field is a transaction ID. With this transaction ID, you can easily check on the Explorer if the transaction actually passed or not, or you can read the transaction through our API.
00:10:00.360 - 00:11:00.540, Speaker A: We can see that the transaction looks like passed, it's successful. And the result of the operation is new token which is minted. And when we check the token address, the NFT address here in the response, which is the same here, you will actually see the newly minted NFTs. For Solana, we are following the metaplex standard, which is like de facto the only way how to work with NFTs on Solana. So we are fully compatible with any NFT marketplaces or whatever which supports NFTs on the Solana chain. So great, we have created NFTs and we have sent it to us as the owner. Another step, the logical one is I want to send NFT from my address to somewhere else, which again requires transfer operation.
00:11:00.540 - 00:12:09.308, Speaker A: In the transfer operation, you again need to define from who you want to send the NFT, what's the private key of that address, who's going to be the recipient, and the contract address represents the actual physical address of that specific NFT. For the polygon example, we're going to see a small difference because obviously we are missing some kind of Identifier of the token. There is no token ID for EVM chain there are token IDs because it works slightly different for solana. Each NFT is a unique basically program on the chain which doesn't have additional Identifier. So let's use our sender parameters. Like I'm going to send the NFT from myself to someone else and I need to use the correct token which I want to transfer. And the result operation is again the transaction ID which we can verify on blockchain that the NFT has actually changed the ownership from myself.
00:12:09.308 - 00:12:55.820, Speaker A: It was sent to someone else very easily. Straightforward. In three operations you can create addresses, you can mint NFTs, you can transfer them. Of course, there's much more to that. In our API documentation you can find everything you need if you want to read operation, read metadata or do some other things with salana. And now let's do the comparison how the same NFT is minted or how this all is handled on a polygon, which is like L two for ethereum. This approach is valid for all EVM chains, ethereum, cello, binance, marching, polygon, harmony and anything else we have added in our platform.
00:12:55.820 - 00:13:43.514, Speaker A: So again, as for the solana, first step for polygon is generate the wallet. For EVM chains we support like HD wallets out of the box. So we give you the mnemonic and Xanipublic key which points to millions of addresses under this one specific mnemonic. So we need to do like two additional steps here in order to get one specific address and one specific private key. If you want to create an address from the wallet we have created, you need to say I want to create address number zero from this wallet extended public key. Bam. You have address.
00:13:43.514 - 00:14:31.620, Speaker A: If you want to create address number I don't know 1000, you just enter address 1000. You have, I think up to more than two billions addresses available in one mnemonic. But I think we are fine with one. So let's use address number zero, which is this one. We should send already some testnet assets. So let's go to Matic Faucet and let's send here some. Of course, I'm going to use my personal testnet faucet for this.
00:14:31.620 - 00:15:01.210, Speaker A: This could happen only on live demo, right, that the faucet is empty. So let's send here, I don't know, zero point. This is not enough. Let's pick different account. This one let's send there, I don't know 0.5 matics great. Thank you Matic Faucet for helping.
00:15:01.210 - 00:15:34.120, Speaker A: Let's go back. So in order to obtain a private key from the mnemonic we have created again there is operation generate private key from the mnemonic. Again I'm going to say out loud don't use it on production, use some safer ways. I'm going to show you which ones. So from this mnemonic we are generating private key for address zero. Zero address private key. It needs to match one of the biggest problem when developers are playing around.
00:15:34.120 - 00:16:07.774, Speaker A: I have used incorrect index. I have used different Xpap than mnemonic and it's not working. Blah blah blah blah blah. Just focus. So we have a private key here. The safest way how to actually validate if this private key points to the address you think it points to is just import it inside MetaMask and you will see that the address is correct and we have a balance. Safest way, just double check.
00:16:07.774 - 00:16:36.122, Speaker A: I'm going to keep this window open. It's wonderful. So we have a balance. We can actually proceed to finally minting some NFTs on EVM chains when you want to work with NFT. First of all we need to deploy NFT smart contract under the NFT abstraction. Here we are talking about ERC seven to ones. We also have erclam 55s available for you.
00:16:36.122 - 00:17:44.126, Speaker A: So semifungible tokens the let's say steps for working with them are basically the same as for seven to ones, just a small nuances. So let's create new NFT, let's deploy it on matic chain with some random symbol and we are going to pay the transaction cost from our private key from our address. The result is transaction ID. We have created very, let's say useful some kind of utilities for smooth flow of the application which means you want to deploy NFT. Obviously you want to find out what's the contract address of the deployed contract. So we have created a very, let's say small utility from this transaction ID. Tell me what's the contract address and voila the contract address is here so we don't have to verify it on a polygon scan or somewhere else.
00:17:44.126 - 00:18:52.420, Speaker A: And for example, if you are building some kind of, let's say NFT heavy application when you are like real time deploying new NFTs, you need to do programmatically these kind of operations. You must have a tool for that. So we have deployed a contract and right now we finally can mint our NFT. The difference again between Solana and EVM chains is that 1155 standards both requires the metadata to be stored off chain somewhere else and stores only the pointer to that metadata you want to attach to the NFT. So in order to actually meet NFT you need to have some kind of URL which you want to use. Most of the NFTs out there are using some decentralized storage systems like IPFS Filecoin, ARVU et cetera, et cetera. We have integrated IPFS where you can very easily again in one API call.
00:18:52.420 - 00:19:47.590, Speaker A: Basically store anything you want on IPFS and you receive the IPFS CID. So I'm going to store some crazy built smart contract compilation information to the NFT. I actually don't care. Usually what you are storing in the metadata is really up to any application. If you are building some, let's say if you're a content creator and are creating music or art or videos you are storing there some videos. If you are working on a project where you're going to mint those NFT as a utility, NFT which could represent tickets, represent memberships it could represent, I don't know what, some fractional ownership of some piece of land. Why not? You will obviously store the metadata something else than an image.
00:19:47.590 - 00:20:29.460, Speaker A: But let's just store this file on IPFS and the result is IPFS Identifier. So in the mint operation we can actually mint NFT with some metadata. We are going to use the deployed smart contract we have deployed as a contract address. We are going to work on matic chain. This is the recipient of the NFT we are going to mint. This is the private key which will mint NFT. So we need to use our private key.
00:20:29.460 - 00:21:36.080, Speaker A: We are going to send the NFT to us and we are going to mint NFT number one. The token ID in the seven to one world should be some integer or well integer really extremely huge integer, 256 bits it can have if someone is interested. So you can create really a lot, a lot of tokens under one contract. So let's mint. Obviously the result is the transaction ID of the operation and we can check this transaction ID on the faucet, on the polygon scan. The result of the operation is NFT, which was minted from zero address to me as a recipient with some metadata attached. Same as for solana, we want to transfer this NFT somewhere else.
00:21:36.080 - 00:22:57.810, Speaker A: So we're going to use the same v three NFT transaction operation as we were using for transferring the solana NFT. If you're going to work with ethereum again you're going to use the same operation, that's what we call code ones deploy on every chain. So let's transfer our NFT on matic chain, right, we're going to transfer NFT token number one to new recipient from and we're going to transfer it from our address. And here you go again, transaction ID. In the meantime, polygons can finally loaded our transaction and we can see that we have minted NFT from zero address to ourselves token number one. You can see that if we take a look on how the actual parameters of the operation look like, you can see that we have minted token number one to this recipient and this is the metadata connected to it. So everything we have entered into operation is visible on the chain and let's check the transfer transaction.
00:22:57.810 - 00:24:10.668, Speaker A: Transfer transaction is again very straightforward. We can see that we are transferring NFT number one from ourselves to someone else. And basically I don't think I have anything more to say regarding the transfer. If you want to now support not Matic, but you want to work on a binance smart chain or you want to work on Ethereum, or you want to work on Sello or you want to work on harmony, this all is available basically only via changing the configuration of the request. We give you not only the ride operations, but if you want to build some reasonable application and it should have full set of features, you want to use. You also need to read. You need to read which NFTs are hauled by which addresses, what you own, what was the NFT transactions, how the NFT travels between the different accounts on the chain.
00:24:10.668 - 00:25:07.300, Speaker A: We have these operations available for you as well. We got you covered. So, for example, if I want to see the balance of one specific address, which NFDS it owns, we can just check this one and you can see like, this was my address and the address owns these token IDs on this specific NFT contract with some metadata attached. So you can see I've already played around with my metadata file. I think I should have used something smaller, but I think you get the point where we are. You can see all the balances of a specific address. The time when those NFTs appears in this endpoint varies how fast we index the data internally.
00:25:07.300 - 00:25:52.720, Speaker A: On the faster chains, it's pretty fast. We can scan polygon quite near to real time. For slower chains like Ethereum, it can take like two to three minutes. Since the transaction appears in the blog, and since we do our internal stuff, there are of course more operations than just get NFTs by address. Everything can be found in the API doc, which I think I should show how you can get there. Inside the resources, there is a API doc link where you can see list of all the operations we support. And we were talking today about NFT section.
00:25:52.720 - 00:26:43.130, Speaker A: So you can see here all the operations you can do on top of the NFT. Here are some write operations, here are some read operations, get NFT transactions by address, et cetera, et cetera, et cetera. Everything you need to do in order to build something real. This is basically pretty much it in terms of the NFT workshop. And right now I want to focus on the Kms and I want to focus on the MetaMask because, yes, we have play around with the APIs. We have pretty decent understanding how the flow should look like, what operations should we do. But this is actually not how you're going to build your production application.
00:26:43.130 - 00:27:12.126, Speaker A: You're not going to send private keys over the internet to us to sign something. You can do it. Some projects do that, but please don't. Please don't. This is just for you for playing around. As I said at the beginning, we have other options how you can build the production application. One of the option is to use our client libraries, tatum JS.
00:27:12.126 - 00:28:05.250, Speaker A: It's a JavaScript SDK, which you can download. You can include it in your app on your back end or on your front end and do all these sensitive operations locally. I mean, generate wallets or Sunny transactions. The SDK looks pretty simple when I open some, let's say, unit test, which actually shows you how the SDK looks like you are building on top of the SDK. You want to work with a transaction section and you're going to mint NFTs. The body of those calls are near almost the same as for the API calls. It's just the different wrappers on top of some objects in the JavaScript.
00:28:05.250 - 00:29:18.160, Speaker A: But basically we are reusing one to one datum JS format inside rest APIs. But you can use your private key here because obviously you will include this in your back end. So if you are building some custodial application, some custodial wallet or custodial marketplace and you are already managing the private keys of your users, you can use the private keys on your site. If you are not building if you are not building custodial solution, but you are building something, let's say more DeFi, and you want your users to sign their own operations with MetaMask or with something else. You actually want to know how to do it, how to sign some transaction, how to sign Mint NFT operation with MetaMask. I want to use the same cool features, the same abstraction methods, same Mint NFT transfer NFT operations. But I want to let the users to sign that.
00:29:18.160 - 00:30:16.202, Speaker A: I have created very ugly example HTML page where we're actually going to connect this page with a MetaMask. We choose some account in the MetaMask and we're actually going to mint that specific NFT using MetaMask with a signing. And then we can take a look inside the code, how this all was done. I need to choose a correct account for this. I think it was this one. Yes, I think it was this one. So first of all, I need to enable MetaMask, connect some account from the MetaMask, and then I'm gonna internally Mint NFT with some specific token ID with some random metadata.
00:30:16.202 - 00:31:02.580, Speaker A: I actually don't care what I'm going to mint, I just want to show you how to mint it. So I don't think this will work because I think I have wrong account. Exactly. So let's dig dive into the code before that's. This is what needs to be changed. I need to use my API key, of course, because I'm going to communicate with the platform. I'm going to perform some post request to the API and I think there was another one here.
00:31:02.580 - 00:32:08.774, Speaker A: And what I'm going to do, I'm going to basically use the same request as I was using for Minting. I'm just going to replace the from private key with some placeholder value which we internally understand and we just give you the recipe to be used inside MetaMask. So I'm going to use this contract address I have deployed. I'm going to mint it here to this guy with some metadata and I need to connect the correct account inside MetaMask, which was the last one. EFD yeah. So let's connect to MetaMask. Let's try to minden FDES and MetaMask window pops up.
00:32:08.774 - 00:32:25.046, Speaker A: It was correctly connected. You can see that I can sign some transaction. Let's sign it. And the result is shown here. Again transaction ID. And we can check it on a polygon scan if it's actually working or not. This looks like a magic.
00:32:25.046 - 00:33:12.098, Speaker A: Internally, it's very simple. Internally, what we are actually doing, we are leveraging the standard MetaMask interface. How the MetaMask connects to the blockchain application where we just work with the ethereum object in the JavaScript world. And then for Minting NFT, as I said, we are using the same API call as we're using in the demo. But instead of a private key, we are using a signature ID. Signature ID for us means that we don't sign the transaction with the private key in our API. But we just prepare transaction object which should be signed later on.
00:33:12.098 - 00:33:50.070, Speaker A: It could be signed inside MetaMask or it could be signed inside our key management system, which is stateroom Kms, which I'm going to talk like in next 1 minute. You can enter any signature ID here. We just send the Mint operation. We receive some response. We perform reading. That response. So we're actually fetching the transaction object, which we want to sign inside MetaMask and just do some magic and send the transaction config for signing to the MetaMask.
00:33:50.070 - 00:34:17.790, Speaker A: I'm not saying it's simple. I'm saying it's like 30 lines of code. But this operation you are doing right now could be anything. It could be minting NFT, it could be sending ethereum, it could be transferring ERC 1155. It could be some approval on top of the smart contract. It could be whatever. Anything you want to prepare on the client could be signed with this approach, with MetaMask.
00:34:17.790 - 00:35:47.262, Speaker A: So if you want to build quite quickly some DeFi app you want to use MetaMask, you can leverage all our pre built pieces of functionality, all the features using this way and just let the MetaMask do the signing. And then like last part of the workshop is going to be the completely opposite type of application and we're going to talk about the custodial application you want to build and how to work securely with the private keys if you are building a custodial solution. I've seen crazy things. I've seen projects who are storing private keys, non hashed in the postgres database on their application server. I saw projects who were sending private keys over internet. They don't care. Eventually all of them stopped working because they got hacked or there was some other problems connected to that but none of like if you want to build something really serious, something which should survive at least first hacker attack from from some random guy, you need to really understand and pay attention to working with the private keys.
00:35:47.262 - 00:36:36.050, Speaker A: If you don't do it properly, you can be really in a bad place or in a bad situation. What's unfortunate is that it's not unfortunate but more and more new developers are joining web3 space. More and more web two people are trying to build something on top of the blockchain but they actually don't have any previous experience. They don't know what's the correct patterns. They don't know that private key must be stored securely. They don't know how to do it and what's the correct flow. And because of these, there's so many problems and so many failed projects or hacked projects out there in data.
00:36:36.050 - 00:37:55.978, Speaker A: We understand that and that's why we're trying to guide you to use proper design patterns while building your app. And actually, you can't do it badly if you follow these main ideas. And the Kms is basically that example. So I'm really going to start showing that because we are bed on time if you want to like Tatum, Kms is a key management system, which means it's a small tool which runs again on your infrastructure, which holds the private keys, the mnemonics, everything on your side. And it automatically communicates with our API on the cloud, like fetching some transactions which should be signed from the API, signs it locally and broadcasts to the blockchain. With this setup, your private keys never leaves your perimeter. The private keys lives in your server, secured as you secure them.
00:37:55.978 - 00:38:59.750, Speaker A: Because the transactions are being fetched, private keys are not being sent away. If you want to work with a Kms, you need to pull the Kms docker. And first step which you want to do is basically set up a wallet file which will securely hold all your private keys. For that, there is like a bunch of CLI commands you can work with. The most easiest one is generate managed wallet or store managed private key. If we have like external private key, I have example of these calls in the README. So right now, I'm going to store my pre generated private key for the existing polygon account.
00:38:59.750 - 00:39:39.490, Speaker A: I just need to point out the correct volume on my drive and say, hey, Tatum, Kms, I want to store managed private key for a matic on the testnet chain. The docker just start. It will ask me for the private key, which I want to store, which I believe is this one. It will ask me for the password which is used for encryption of the wallet file. For the first time, just enter some password you want. Second time will have to repeat it. My favorite password is 12345.
00:39:39.490 - 00:40:40.544, Speaker A: And the result of the operation is that Tatumkms grabs that private key, stores it in the wallet file, and generates signature ID, which actually represents that private key inside this Kms instance. Right now, my Kms can start fetching transactions which are connected or sent with this signature ID. So let's say I want to mint new NFT. I want to mint NFD number ten. But instead of a private key, I'm going to use signature ID. This body tells the API internally that, hey, this guy want to store the transaction for the Kms signatures later on. So the result of the operation is not the transaction.
00:40:40.544 - 00:42:15.576, Speaker A: ID on the chain because no signatures were done, no transaction was broadcasted to the chain. The result is some Identifier of the operation which should be signed later on. You can get the details of that operation using Kms, get details stuff and you can see here some, let's say information where the most important pieces are. The chain we are working on matic the serialized transaction field is actually the transaction which will be signed inside the Kms and the hashis field represent the private keys which should be used from Kms to sign the payload. So right now the transaction is still in, let's say, descending state and once the transaction is signed, there's going to be new field takes ID present with a specific transaction ID. What we need to do from the Kms perspective we need to run it in a docker mode if we want to start Kms fetching if we want a Kms to start fetching the transactions from our API, we need to run it as a docker demon. Using this command you are actually saying hey Kms, I want to start you in a demon mode.
00:42:15.576 - 00:43:16.480, Speaker A: This is my API key. So under this API key you should communicate with the API. I want to see only transactions which are connected to polygon on the testnet network. So right now I have one transaction pending inside my API key space. So Kms demon will start. You need to enter of course, the password to decrypt your wallet store and Kms starts fetching the transactions from the platform. I think we have a lot of transactions there under these signature IDs which I don't like for any reason but I think this one is the one.
00:43:16.480 - 00:43:56.410, Speaker A: Let's see if this one got processed. It got luckily. So let's take a look what happened here. Under my API key I have a lot of other pending transactions which should be signed. One of those pending transaction was mine and the transaction got picked up by the Kms. It was signed, broadcasted and the transaction ID was attached that Kms to that Kms transaction object. We can right now check on the polygon scan like if the transaction actually passed or not.
00:43:56.410 - 00:44:25.020, Speaker A: And yes, it looks like we have really minted token number ten as we want it. And when you take a look how we actually did it, we haven't sent the private key anywhere. The private key remains secret and safe inside our Kms. I know it was a lot, but right now it's time for any questions you might have for I think we have a microphone somewhere.
00:44:28.290 - 00:44:29.810, Speaker B: I don't need the microphone.
00:44:30.390 - 00:44:31.860, Speaker A: Okay, go ahead.
00:44:32.230 - 00:44:48.394, Speaker B: So, thank you very much for your presentation. It's very clear you use MetaMask but can I safely assume I could use any other kind of wallet and just replace MetaMask for the connection?
00:44:48.542 - 00:45:21.450, Speaker A: Yeah, for the stream. The question is if I can replace the MetaMask with any other wallet like wallet connect or whatever else. Yeah, if the principles how those wallets are working are similar to MetaMask so you are passing the transaction configuration which should be signed, then yes, you can use whatever. It's really up to you. Awesome. There's any more questions? We can another one. Great.
00:45:21.760 - 00:45:25.790, Speaker B: Can I implement it with NFD minted video?
00:45:30.880 - 00:45:32.430, Speaker A: What do you mean by that?
00:45:34.740 - 00:45:48.340, Speaker B: You have it with the NFT, but if I take for example, have an NFT minted video in this case, would this also work just restricted to NFT?
00:45:49.560 - 00:46:28.700, Speaker A: Well, if you mean like NFT minted video is like actually the existing NFT already on the chain and you want to remain it again, yes you can. Because technically speaking, this is just mint NFT and I don't care what I'm minting. Like you can mint whatever token with whatever metadata. So it's really up to you what you want to mint. If you want to create new NFT, this is the operation. What's actually inside that NFT, it's really up to you. Okay guys, if you will have any more questions, we are here like yeah, go ahead.
00:46:36.030 - 00:46:41.542, Speaker B: Function. Do you have plans to add Bridging functionality into your SDK?
00:46:41.606 - 00:47:46.260, Speaker A: Like the question was again for the stream that we have a lot of EVM chains integrated and if we plan to add some Bridging functionality, what we have available in each of our integration of every blockchain is that you can easily, let's say call smart contract. You can perform ride operation on any smart contract available on that specific chain. So if there is a breach already, which is a smart contract based, which usually they are, you can actually right now working with that breach just by invoking that breach method. For example, we're going to send an FD there and call something on a breach. Yes. From the abstraction perspective right now, we don't plan to add some custom bridges or do abstraction for existing bridges. If you want to bridge yourself those NFDS and build it by yourself, you have a couple of options.
00:47:46.260 - 00:48:41.580, Speaker A: You can integrate some existing bridge or you can deploy your NFT contract different chains and basically create your own bridge that you will burn on one or bin on another one and basically will bridge like this with some metadata connections between those or which is even better solution. You can basically send your NFT to some specific address which you own and you say that this is my breach, you will mint another one and do it by yourself? Yes, you can. Yeah, it would be great. Okay guys, I think we are on time. So thank you all. And as I said, we are here tomorrow, on Sunday as well to answer any questions. Thank you.
