00:00:05.290 - 00:00:17.040, Speaker A: Our next talk. So our next speaker is Marik. I want to invite him on stage to talk about Used app and I'll let him intro himself and talk about his amazing project. So without further ado, welcome.
00:00:18.370 - 00:00:30.178, Speaker B: Hey, Karik. Great to be here. Great to see you. Great to be here on this event and talking to you guys. One click disclaimer. I'm in a hotel in a public space. That's the only place where there is a working WiFi.
00:00:30.178 - 00:01:10.242, Speaker B: So there might be some distractions, but let's hope for the best. So today we're talking about Used up. It's a framework for rapid development of DApps. And when I say DApps, I really mean the web component, the web part of it. We're not going to talk about smart contracts today, so it's going to greatly connect to the previous presentation of Richard that some of you might have seen on Eturch JS. So why doing a framework might be a question that many of you might be asking yourself. And what could be possibly difficult about building front end for JS? Right? It's a simple web application.
00:01:10.242 - 00:01:41.660, Speaker B: It's a simple react application. Well, it turns out it's kind of hard and we would know. We kind of tried it all. We tried React, we tried React with Redux, we tried Ericsjs, we tried domain driven design. We tried everything throughout last four years or so. We looked at what different people are doing and we really didn't find an easy way to build the app. And I think there is no like any fundamental problem, not any major problem that makes it difficult.
00:01:41.660 - 00:02:37.194, Speaker B: There's this little, small, little problems everywhere that makes it difficult. And I give you a few examples, my seven top picks, right? So first of all, if you go to an application and obviously we want to make a good user experience, we want to build great UX for our applications, for our users. So first of all, when the user goes to the app for the first time, they want to be able to browse the app without connecting. They want to be in this read only mode before they connect their MetaMask, before they connect their wallet of choice, right? So the app should support this read only mode. And the other thing is, and that's not very hard, you just make a couple of leaves, make sure to connect to read only provider. Easy peasy, right? But now the problem is, you always want to show the most recent state of the application every 15 seconds or so, depending on the network. Might be different times, but new block might arise.
00:02:37.194 - 00:03:30.560, Speaker B: And when the new block arrives, some of the states might change. Some of the values that you display in your application might be different and you never know which one. It might have nothing to do with what user was doing. So what a lot of application developers do is they keep querying every time, every time, every few seconds, they keep querying and see, what is the status of this value over here? What is the status of this value over there? Now that makes a lot of requests. Which brings us to the next problem, which is how do we keep amount of requests small so that well, first of all, our Infuriawal Chemi bill is not that high. But second, that the UI is responsive and the user can see the Kind sign and there is no hundreds of requests in the background. That one is waiting for the other.
00:03:30.560 - 00:04:14.126, Speaker B: And then since we're talking about refreshing, there's a whole thing when we're switching wallets, right? So when we switch from one wallet to another, let's say I go to uniswap. I want to exchange from one currency to another. I set up the whole thing. I want to exchange A to B, and this is the exchange rate. It all looks good, but I'm connected with the wrong wallet. So I want to switch the wallet. I don't want to see the whole application reloading, right? And actually, if you go to documentation of Ethereum, they say if you change the wallet or you change the network, you should refresh the whole application because it's so complex to figure out what needs to be refreshed on more not on the more, not with Used up.
00:04:14.126 - 00:04:46.514, Speaker B: Use up is handling that for you, as you're going to see. So switching wallet, switching networks is becoming a thing now, because now we have more and more often we work with applications that have multiple net that support multiple networks. You're on layer one, you're on L2. You keep switching depending what you want to do. All kind of bridges are being built all the time. It's not anything extraordinary anymore, anything weird, anything fringe, as Richard would say. And then there is the whole training of transactions.
00:04:46.514 - 00:05:04.314, Speaker B: And I know it seems simple. You look for the transaction. If it's pending, if it's successful, fail. But then transactions tend to be slow. Users switch context. User wants to understand what happens. The transaction failed, he's already on the other screen.
00:05:04.314 - 00:05:54.330, Speaker B: Maybe it was replaced, maybe something else happened. Right? So we want to give user support to give him information about the history or the notifications of the transaction, right? History, what was done, notification, what just happened. And that's why we created used up. We created Used Up just earlier this year, I think it was March when we released kind of the first version. And it's already used by close to 500 applications, I believe. So Usedap is a framework for rapid app development, and it's built for Ethereum. But really, any EVM compatible blockchain should be able to handle you should be able to use that framework with any EVM based network.
00:05:54.330 - 00:06:44.346, Speaker B: And we didn't want to reinvent the wheel. So it's built on react. It builds on eaters that you might just seen Richard presentation. That was just before mine. It's built on top of Web three react which was developed by guys in uniswap and became kind of standard thing for managing the connection state and for testing it uses Swaffle which is popular framework which we also have developed for smart contract testing. Now it's extended, you can use it for testing your UI as well. So, without further ado, what are the features? We really have three major features connection, management, reading, blockchain, state and transactions.
00:06:44.346 - 00:07:41.550, Speaker B: And we really don't want to make it much more than that. We just want to do those three things and do them really well. There will be some plugins, there are already some plugins, so there are other things that you can do. It used up, but this is really the core stuff that we want to support, that we're already supporting and that we think should be done really well because that's what the apps are all about. So what connection is doing. First of all you have read only support out of the box you have support for network switching and coming soon we want to be able you can now support multiple networks but we want to be able to support multiple networks in parallel so that you can display content from many networks easily. So here's an example code this is really all the configuration you need to do you need to specify very simple configuration object which tells you what's your default network? In this case, it's Ethereum, Mainet.
00:07:41.550 - 00:08:03.270, Speaker B: What is going to be your address, your infura alchemy or whatever provider you want to use for your ethereum. JSON RPC. For your access to ethereum. And then you've wrapped your application with the app provider and give the config as an argument. And that's it. It's done. Your application is ready.
00:08:03.270 - 00:08:28.634, Speaker B: You can start developing your application without any further ado. And here is an example. Application what? It does is it allows you to connect to ethereum and it shows your balance. So you connect with your MetaMask or your favorite wallet. There is a new hook. So ethers is all about idiomatic, react, hooks, so everything. You do is a hook.
00:08:28.634 - 00:08:47.170, Speaker B: And it comes with all those great goodies that react hook comes with. Which is like, you don't need to think about refresh, you don't need to think about state. It just gives you stuff. And you can just use it. And in this case we're using Views Eaters. So again, shout out to Richard. And it gives you two things.
00:08:47.170 - 00:09:33.554, Speaker B: One is account, which is your current account can be null if the account is not connected and activate browser wallet which is a function then you can call to trigger connection to MetaMask. Then we ask for balance. Use ether balance, which is again hook which have one argument. Give me the account. You want balance for and the account in this case is just the account that we're connecting with again ITER balance might return null because we might be not connected or the balance was not yet retrieved. And then we have a simple piece of interface, the button to connect and we're just displaying eater balance and we format it with format eater, which is again, Ethers JS function. So here's how it looks like.
00:09:33.554 - 00:09:53.258, Speaker B: Here's a connect button. We click connect and boom, off we go. We can switch the accounts, we can switch the networks. And everything working, everything is refreshing. This is like all done under the hood. You don't need to know anything about it. And if you see this example application, you can see there is actually more than just the account.
00:09:53.258 - 00:10:21.262, Speaker B: There is more than just ITER balance. There's also the account and the value on Ether staking contracts. On ether. Two staking contracts. So here is the full code for the application without HTML and CSS. But this is basically the whole code except for the configuration, except for HTML and CSS that you need to have. So again, we use use eater balance in this case for Staking contract which is just a constant that contains the address of the Staking contract.
00:10:21.262 - 00:10:56.206, Speaker B: We use account from users and we use user balance from well, we just grab it from the hook and the hooks. Again, they're going to take care of all the refreshment, whether it's different wallet, different network, whether we're not connected, whether we read only mode, whether we're not in the read only mode. So that was pretty easy, I hope. Let's see. Again, pretty easy. We have this little notification at the bottom. I'm going to explain what it is a little bit later.
00:10:56.206 - 00:11:22.920, Speaker B: Everything just works. Boom. So that was just to show you connecting and very basic reading from the blockchain. Now we're going to dig deeper into other functions for reading from the blockchain. What is reading from the blockchain gives you more than just eaters? Well, it gives you auto refresh on your blog. It gives you auto refresh on wallet change. And here is a new thing.
00:11:22.920 - 00:11:52.474, Speaker B: Combine multiple calls into a single multicol. So everything that you see on the screen is aggregated into one collection. And every few seconds there is a single call asking to your node, hey, is there a new block? No new block, nothing to do. Is there a new block? Oh, no. New block, nothing to do. Is there a new block or there is a new block. And everything that is visible on the screen and nothing more going to be combined into a single multiple.
00:11:52.474 - 00:12:23.094, Speaker B: And a single request is going to retrieve all the data, get it back and distribute the data across the application, across the visible user interface. And it's all done by hooks. So you don't need to know anything about it. It just works. Right, so we've seen this example, I think we've seen this one example, yeah. So here we're going to send money from one account to another. So we continue on the same example that we've seen a moment before, but this time we're waiting for pending transaction.
00:12:23.094 - 00:13:10.302, Speaker B: Just to show you that any moment now when the transaction is going to finish, we're going to see the ITER balance going to change and boom, it just has changed to zero point 69. So again, nothing to do just works. So can we? Yeah. So here's an example because one question you might ask, okay, very nice about user balance, right? But what about if you want to read other things from smart contracts? So there's this convenient use contract call which is again the hook which you can use to define your own hooks to query blockchain for really anything. So you have used token balance. So we're going to create a new hook. This particular usetock and balance hook is actually part of ride blurry.
00:13:10.302 - 00:14:02.566, Speaker B: But imagine you need to recreate it from scratch or you want to do whatever other call to smart contracts that you want. You use contract call that returns the value that returns the same thing that smart contract is going to return. And it has four arguments. The first argument is ERC 20 interface. This is the same format that Etersjs is using. It takes an address of the contract you want to call, it takes the name of the method and it takes an array of arguments for the function that it then needs to call. Again, there is a little bit with those extra ends and extra question marks because the values might turn out to be null if you're not connected, if the value is not yet retrieved.
00:14:02.566 - 00:14:26.490, Speaker B: But other than that it's just a single function call. Good. So we talked about connecting to the blockchain and we talked about reading the state from the blockchain. Now we're going to talk a little bit more about making transactions. So here's an example. We're going to send a transaction. What we're going to use for that is we're going to use a hook surprise.
00:14:26.490 - 00:15:12.478, Speaker B: So you send transaction is a simple hook that allows you to send money, that allows you to send ether from one account to another and it returns well, three values. But for now we're going to focus on two values. One value is a sent transaction and second is state and the sent transaction is a function that takes as an argument ethereum transaction. So it has typical values like two value might be other things like nodes and whatnot or gas related fields. But for this example we're going to keep it simple. It just have two arguments, two and values. So we're sending some eater to a certain address and certain amount.
00:15:12.478 - 00:15:46.698, Speaker B: Again, we're using ethersjs parse eater function. And the nice thing about it is we have this additional variable that is state and state can be non mining success, failure and exception. So we might not yet send the transaction yet. That is non mining means the transaction is pending success and fail transaction is mined successfully or not really successfully, an exception might be coming. For example, if user cancel in MetaMask or there is a button of code. So this is how it works. This is an example.
00:15:46.698 - 00:16:16.526, Speaker B: If we go back to example, this is how it works. Just click send, opens your MetaMask and you have those really simple transactions being mined. This is just a piece of HTML that you display depending on the state. Transaction successful. Just a piece of HTML that you display depending on the state. And on the bottom you also have a notification. So we're going to talk about notifications in just two slides.
00:16:16.526 - 00:16:40.730, Speaker B: But for now we're going to go into more complex example. So that was just sending an Ether. Now we're going to actually call a function. We're actually going to issue a transaction that's going to execute a function on the blockchain. So for that we're going to use a very similar group that is called news contract function. And it really has two arguments. So the contract contract, again it's Ether's contract.
00:16:40.730 - 00:17:28.262, Speaker B: So we already have information about API and the address. And the second argument is the name of the function. Again, it returns two variables. It returns state which can attract the state of the transaction and the send function that you can use to send to execute the transaction to call a function. Now with Send it's a little bit more tricky because send takes the list of arguments that is the same as a function as solidity and it might also take one extra parameter which is override. So you might override some value of your transaction like value in eater or gas fields. So in this case, what we're going to do is we're going to wrap an unwrap eater.
00:17:28.262 - 00:18:17.622, Speaker B: So the first example from the top, what it does, it simply unwraps the eater, right? So you're calling the withdrawal function on wrapped eater contract and well, it sends just one argument which is the amount of wrapped eater that you want to unwrap. The example from the bottom goes the other side. So it wraps ITER. So it takes your reader and deposit and you get wrapped in return. In this case, function has no arguments but you need to override the value, you need to override the amount of ITER that you want to send. And this is how it works in practice. And again, you see very nice state management, very nice notification over here and you just wait, boom.
00:18:17.622 - 00:18:50.082, Speaker B: Transaction is complete, transaction is successful, everything that needed to be related, the balances are now updated. Good. And you've seen those little notification at the bottom. To get those, all you need to do is the use notification hook. So it gives you the list of all the notifications. Notification include things like wallet, connected, transaction, pending transaction, mine successfully, transaction, sale. There was an exception running transaction.
00:18:50.082 - 00:19:45.058, Speaker B: And again, because it's hook and it takes care of all the updating it's going to automatically make those notification disappear after a certain amount of time that is configurable. And if you want to have just leave the history of all your transactions, of all the user transactions that you've done, you can use Use transactions hook that gives you just persistent history and just think about the amount of work it takes to implement those hooks. They need to work on different networks, they need to work properly when you switch the network back and forth. They need to work when you close and reopen your browser. So there is significant amount of work to it that you don't just don't need to do if you're using Use up. And there is one more extra thing there's. This Use contract function returns one extra variable, that is events.
00:19:45.058 - 00:20:16.674, Speaker B: So we already have parse events and you can just dig in and see what the events are. If anybody's done it in Eterns before, usually it takes a few hours to do it first time and then it always takes time to figure it out again how to parse those events. Boom, off you go out of the box. So what else is there? There's plenty of other stuff. So there's a lot of hooks related to many different things. There is use lookup address hook that relates to NS. There is Use Gas Price that gets you the gas price.
00:20:16.674 - 00:21:06.010, Speaker B: You can use Use Block method that gives you the meta information about the current block. There's a lot of helper methods like Get Explorer Address Link that generates the Explorer link that works even if you keep switching networks. So that is pretty convenient as well. Get the current chain name, shorten your address if you want to display just a part of it in the interface and so on and so forth. Currently we support all the Ethereum networks mainnet and all the testnets. We support Binance, Exodus, Polygon, Teta, Moonriven and Mumbai which are the polkadot chains Harmony, Palm, Phantom and if you want to do local development we support local chains like for example on Hardhat. If you're developing on hardhat or Ganache.
00:21:06.010 - 00:21:50.122, Speaker B: And it's a really short pull request if you need to make it work with anything else. It's a few things that needs to configure and we keep seeing more and more those pull requests coming. So if your network is missing, I'm pretty sure there is an easy way to add it. And there is one nice bonus thing, which is a browser plugin. So we have a browser plugin and it's available for Firefox and Chrome and it tracks what's happening under the hood so we can see it might be a little bit unintuitive at the beginning what's going on under the hood, so it does that. It also manages your APIs and tags. So if you have specific accounts or specific contracts to interact with, you can make it very readable and understandable.
00:21:50.122 - 00:22:29.660, Speaker B: So here's an example you can see the history on the left. It was initialized. Calls updated means that there are new things displayed on the website that is now being tracked by the multi calls. And every time you connect to a different network, mainet Callban or anything else, you can see, right? Every time that happens, you're going to need to update calls again. Because you used to call on one network, now you're going to call on another network. Every time you switch screen, you change something in the interface, it's going to update calls, right? Every time there is a new block, it's going to check if it needs to update anything. If it does, it will let you know.
00:22:29.660 - 00:23:05.670, Speaker B: Calls updated, four states update. Sorry, right, that's the browser plugin. What's next? Really? I was really enjoying I was watching Richard Moore's presentation about Etherjs because he talked a lot about the challenges coming with this new reality of multi chain. Layer one, L2 solutions. So this is what we think is going to be the most important next thing to implement in use. DAP. So it's really great to see Richard is already working on that and going to take a lot of that work from our hands.
00:23:05.670 - 00:23:58.274, Speaker B: But yeah, we want to be able for you to define your environment when you might have multiple networks connected in the parallel, those networks might slightly differ and everything just works. And also, as I said, we think this is pretty much feature complete, so we don't want to add more and more features. But we do see a lot of opportunity to add plugins or separate NPMS. And one example is CoinGecko Oracle. That is just very simple package that gives you the current price using CoinGecko API. And it's just so addictive when you start writing this Idiomatic react hoops in this style, in this API manner, it's just so easy. So adding other things, they're just using the same Idioms, the same way of working and makes it so easy.
00:23:58.274 - 00:24:28.434, Speaker B: Like if you want to display the list of what's on the user wallet and how much is it worth, you hook up the CoinGecko Oracle, you hook up the standard Token API and then you just multiply one by the other. You don't need to worry about all those things. We're talking about refreshments wallets networks and yada yada yada. Yeah. So it's working. We have it in multi. I think I mentioned it's like 500 application is using it as of today.
00:24:28.434 - 00:24:55.420, Speaker B: It's a very young network, very young framework, but we're using it on production in several different applications ourselves. Everything I show you today, the examples are available. At example used up IO. So go check it. The code is available on the GitHub, check the documents, check our website, used up IO. And thank you very much for listening, guys. Let me know if you have any questions.
00:24:56.590 - 00:25:18.530, Speaker A: Mark that was really mean. Everybody and myself got super excited by all the amazing kind of tractions you have there. We have a couple of questions and a couple of comments and a couple of open ended things for you. I'll start off with something simple. Can you give us a framework of when somebody should think about using Usdap versus Scaffold ETH and kind of what are the differences?
00:25:18.870 - 00:25:48.534, Speaker B: Absolutely. So, first of all, I want to say, and I'm not sure if it's on the main brand or not, but Scaffold, it actually is using used app, at least in one of the versions because I think Austin had many versions of that. So I'm not sure which version exactly. Our philosophy is we want to do one thing and one thing really well. And I think Scaffolder is really good at being this boilerplate at place. Boom, off you go. And you can just start coding.
00:25:48.534 - 00:26:15.214, Speaker B: Right. And we don't try to compete with that. I think Austin is doing amazing work and we don't want to compete. We don't see there is a need to improve on that. What we did see the core problem is as we develop those applications for customers. So some of you might know me, I co founded E Force. E force was recently acquired by Token.
00:26:15.214 - 00:26:40.282, Speaker B: So but we're going to continue working on the open source. So don't worry, guys. But the point is we work over and over solving the same problem and the code gets obsculated. Right. And we thought that we need a better abstraction layer on connecting, reading and writing to the blockchain. It's really those two things because that's what you do with blockchain. And we want to be really good at that.
00:26:40.282 - 00:26:52.480, Speaker B: Right? We want to make it so it's super easy, super fast, super to. We're super happy that Scaffold is using it and I hope it's going to use more of it.
00:26:52.870 - 00:26:59.940, Speaker A: Awesome. Another question, is this production ready? And I think you kind of want to absolutely.
00:27:01.030 - 00:27:25.434, Speaker B: There is like with Tayley, I don't remember, but I looked pulled together with Taylor. I've seen at least a few serious guys using it on production and we use that on I wouldn't be able to tell you from the top of my head, but there's several projects production ready, like billion dollar total value locked and interfaces built in, usable at the top of that.
00:27:25.552 - 00:27:38.880, Speaker A: Awesome. And then I'll do a final question, which is I think been brought up as a theme from a couple people, but for Darryl, any plans to support Speddle in the future?
00:27:39.250 - 00:27:40.526, Speaker B: To support which one?
00:27:40.628 - 00:27:54.740, Speaker A: Speddle. S-E-E-T-L-E you have react. Okay. So I'll type this in chat, but your question I think directly got.
00:27:55.350 - 00:28:06.790, Speaker B: I see. Well, I didn't hear about this framework before, but I'll check it out and let you know. Guys, I know that there is a next person waiting to start, so thank you very much. Okay.
00:28:06.940 - 00:28:11.720, Speaker A: Thank you so much, Merrick. And yeah, everybody check out Usap. And we'll do it ourselves too.
00:28:13.130 - 00:28:14.498, Speaker B: Thank you very much. Bye.
