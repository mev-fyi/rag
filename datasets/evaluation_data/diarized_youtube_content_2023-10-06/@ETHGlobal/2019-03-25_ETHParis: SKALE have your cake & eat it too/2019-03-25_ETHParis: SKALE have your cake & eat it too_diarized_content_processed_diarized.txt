00:00:07.970 - 00:00:43.602, Speaker A: Hello. My name is Chadwick Strange, VP of product of Scale Labs. I'm joined on stage with Christine Perry, our solutions engineer. We're going to switch things up a little bit, so we decided to put on a little bit of a play between us, and we really wanted to get away from a technical talk. We really wanted to just show you how everyone can have their cake and eat it, too. How can you win? You're here to win bounties, so we want to try to help you out. All right, so we're going to do in the next 25 minutes is we're going to go over us being here at the Hackathon and joining a team.
00:00:43.602 - 00:00:47.742, Speaker A: So I just met Christine at the Hackathon. Hi, Christine.
00:00:47.886 - 00:00:48.580, Speaker B: Hi.
00:00:49.190 - 00:00:59.140, Speaker A: Hey. Let's build a project. Let's win some of these bounties. So we're here in Paris. What should we build? What things do you like? What should we build?
00:00:59.450 - 00:01:14.234, Speaker B: That's a good idea. I think that I want to try to digitize building a cake, because I really like cake, and I want to build it on a blockchain. I know it doesn't make sense, but I'm pretty sure I can extrapolate some part of it and put it on the blockchain. So are you with me?
00:01:14.432 - 00:01:34.910, Speaker A: I like that. We're in Paris. Some of the best pastries are here. So let's do I want when I want cake, I want to be sure that I order cake. I can get cake. Nothing prevents me from getting cake. How can we do this? How can we make this user experience of getting cake as simple as possible? So I think, first off, we need to have let's talk about the requirements.
00:01:34.910 - 00:01:48.360, Speaker A: If people want cake, we should make it as seamless as possible, allow them to order cake without any difficulties. So the user experience needs to be really solid, really good. What else do you think we should have?
00:01:48.810 - 00:02:13.014, Speaker B: Well, I think before just going full throttle, let's slow it down a bit and let's work with existing technology. So I want to deploy this on Rinkby, and then maybe we can see how we can improve it. So I already have something developed, and we can start there and then improve it. But I walked around, and the scale team gave me this prototyping pad that apparently I can use to model out my cake. Smart contract.
00:02:13.142 - 00:02:13.798, Speaker A: Brilliant.
00:02:13.894 - 00:02:23.534, Speaker B: Yeah. So I started to write down some ideas. It's just a team of you and me right now. We have room for two if anyone else wants to join us. Yeah, you. Okay, so we might have one more.
00:02:23.572 - 00:02:23.822, Speaker A: Awesome.
00:02:23.876 - 00:02:46.402, Speaker B: One more. But I also have design ideas, so we're going to need to upload some ingredients. Those are going to be our assets, and I'm assuming that we may want somewhere to store it. I know there's, like, foul storage out there, but is there any way we can still keep that decentralized and put on a blockchain? Too? Not sure, but we'll see. Of course, MetaMask. Because that seems to be like the standard today. Like, you have to interact with MetaMask.
00:02:46.402 - 00:02:50.630, Speaker B: And then I'm going to use Blockchain rinkbee and I have to write my smart contract.
00:02:50.790 - 00:02:58.266, Speaker A: Got it? Yeah. Everyone uses rinkabee. Everyone uses MetaMask. Let's use these tools that are available. Everyone uses and let's see how it works out.
00:02:58.368 - 00:03:03.278, Speaker B: All right, well, if you're with me, then let's go ahead and look at what I've built so far.
00:03:03.364 - 00:03:07.486, Speaker A: Cool. Yeah. You said that you built a smart contract first, so can we take a look at that?
00:03:07.508 - 00:03:34.290, Speaker B: Yes. Thanks for reminding me. Okay, so my smart contract here bakery. What I'm doing is I have a smart contract that I want to create other smart contracts from. So I'm not sure how that's going to work out, but I just have the basics here. And essentially what we're going to do is create a new cake. And each new cake is going to be a smart contract sorry, its own contract.
00:03:34.370 - 00:03:39.170, Speaker A: I see. So a contract that creates a transaction and that instantiates another contract.
00:03:39.250 - 00:03:47.202, Speaker B: Yeah. So I'm not finished with this yet. I'm going to need your help. I know you're really good at solidity, so you'll help me fix this. But right now, I just want to see if I could just deploy the basics.
00:03:47.266 - 00:03:48.342, Speaker A: All right. Let's try it out.
00:03:48.396 - 00:04:08.562, Speaker B: All right. So if I go to my application, I have some ingredients here. Every cake needs the basics. Eggs, flour, milk these are currently just stored on my desktop, so it's running really fast. But I want to see if I can find someone else to store that. But we'll worry about that in the future. So what's the first cake that you maybe want to make? What else should we add to it?
00:04:08.616 - 00:04:12.398, Speaker A: I don't know. I mean, a lot of people like fruitcake. It's definitely not my favorite cake.
00:04:12.494 - 00:04:30.090, Speaker B: Not mine either, but we'll just go with it. Let's see what a fruitcake turns out to be. So make cake button actually interacts with my smart contract on Rinkbead. And oh, it looks like I don't have enough gas. Let's fix that.
00:04:30.160 - 00:04:30.940, Speaker A: All right.
00:04:35.930 - 00:04:47.014, Speaker B: So I'm going to refresh. Let's re add our ingredients here. Fruit. Make a cake. All right. Looks like it's working.
00:04:47.132 - 00:04:48.150, Speaker A: It's taking a while.
00:04:48.220 - 00:04:54.806, Speaker B: It's taking a while. Okay, I'm going to wait. I'm pretty sure this is going to work. The transaction will come back eventually.
00:04:54.918 - 00:05:00.250, Speaker A: All right. Still waiting. It's a long time to wait for a cake.
00:05:00.330 - 00:05:02.186, Speaker B: Still waiting. Do you know a song?
00:05:02.298 - 00:05:03.322, Speaker A: I don't know a song.
00:05:03.386 - 00:05:03.662, Speaker B: No.
00:05:03.716 - 00:05:04.698, Speaker A: Not a good singer.
00:05:04.794 - 00:05:13.060, Speaker B: Darn. Okay. Well, you're in luck. The cake came back. We have our fruitcake. It's not that great. I would not eat this if it were me.
00:05:13.430 - 00:05:16.382, Speaker A: Doesn't look pleasing to me. It's fruitcake. Not my favorite cake.
00:05:16.446 - 00:05:22.642, Speaker B: All right, well how can I make that better? So let's see if we can put scale into the bank.
00:05:22.706 - 00:05:26.258, Speaker A: Sure. I've heard Scale has a scaling solution for smart contracts.
00:05:26.354 - 00:06:04.754, Speaker B: Okay. So I interacted with Chatwick already, and he gave me my S chain and documentation. Now, I saw a presentation on this yesterday that went through deploying this to Truffle, and there were code samples here. So I followed exactly that and copied this Snippet over and into mine, my code. And so if I go to my Truffle file and I paste that endpoint, it looks like all I have to do now is change this and use that new scale endpoint. So just like that, I'm able to deploy the scale pretty easy. You want to see how that works?
00:06:04.792 - 00:06:05.762, Speaker A: Let's try it out.
00:06:05.896 - 00:06:28.410, Speaker B: Okay. So if I go over here to my application, I'm going to use Truffle deploy reset, because I might have done some weird things. We'll choose that new network that I just created for Scale, and I won't compile all my contracts because I already have deployed the rinkobee. So I want to use the exact same APIs on both networks. So let's see if I can make that work.
00:06:28.480 - 00:06:29.180, Speaker A: All right.
00:06:30.830 - 00:06:52.562, Speaker B: It's executing. Hopefully, eventually I'll be able to see those smart contracts deploy to scale. One thing I'm noticing is it took me forever, almost 15 minutes to deploy the rinkby. Right now, I'm almost already through the migration, and I'm on my last contract here, and it's deployed. That went really fast.
00:06:52.616 - 00:06:53.378, Speaker A: It's a lot better.
00:06:53.464 - 00:07:08.818, Speaker B: So if that's just as fast, let's see what happens to the application using these smart contracts on Scale. All right, so I'm still going to have the end user use MetaMask. I'm going to switch to that Scale chain, and let's make a new cake.
00:07:08.914 - 00:07:17.174, Speaker A: All right, let's improve upon our last thing because we're using Scale. So instead of a fruitcake, what about cheesecake? I think that's a big improvement.
00:07:17.302 - 00:07:18.118, Speaker B: Cheesecake?
00:07:18.214 - 00:07:18.666, Speaker A: Yes.
00:07:18.768 - 00:07:33.338, Speaker B: All right. I'm not sure. I kind of like cheesecake, but we'll make it anyway. Okay, so same process looks the same. I'm going to go ahead and confirm that transaction, and I did not have to wait 45 seconds.
00:07:33.434 - 00:07:49.410, Speaker A: Nice. That's much better. Much better. But I did have to click a bunch of things. MetaMask keeps coming up. And why do I have to click Metamass? Still seems like a little bit too much for the user to have to click through these windows that pop up. Can we make that simpler?
00:07:49.750 - 00:07:59.318, Speaker B: You're right. When you think of applications today, no one has to go through these extra hoops to be able to interact or get the outcome from the application.
00:07:59.404 - 00:08:03.058, Speaker A: Interacting with it feels like a DAP. How can we make it feel more like an app?
00:08:03.164 - 00:08:26.478, Speaker B: Okay, let me see here. So let me go back to the documentation, see if there's anything else I can use here. There is this money transfer script. So let's ideate about this. Let's say that I wanted to have the user deposit a set amount of funds and then I'll be able to pull from that amount of funds every single time I want to do simple transactions by clicking a button.
00:08:26.564 - 00:08:27.360, Speaker A: Got you.
00:08:27.890 - 00:08:37.614, Speaker B: I can assume that they'll log in once. Maybe when they sign in, that sign in is them giving me the okay to approve all similar to like a 721 approve all method.
00:08:37.662 - 00:08:38.226, Speaker A: Got you.
00:08:38.328 - 00:08:55.062, Speaker B: And we will be able to then approve all of these transactions in the background. So with scale, I'm seeing that there's only a deposit in and an exit out. So even then I only had to interact with two methods from their smart contract to kind of frame out that functionality.
00:08:55.126 - 00:09:06.842, Speaker A: Got you. So it's like creating a new cake. Could be an ERC 721, a collectible. People do collect cake recipes per se. Yeah. So there could be something there with that. Yeah.
00:09:06.976 - 00:09:51.238, Speaker B: Okay, well, I don't think I'm going to go through and do that at this hackathon, but maybe I can at least do the signing piece. We're automatically signing for the user and having the transaction work in the background. So let me walk you through what I started so you can see what that looks like. All right, so if I go here to my source and this is in react so on any of my components, I have actions here. I'm bringing in that smart contract, as you can see here. But instead of making a cake and having MetaMask show up, I'm going to do make a cake with scale using that transaction. Essentially, I'm only doing a few things here because I use Truffle to deploy I'm going to use Truffle to retrieve my contract.
00:09:51.238 - 00:10:23.846, Speaker B: It's simple enough. Cake doc deploy. And then from there on, I'm then able to create a raw transaction switching over to just web3 JS technology. After that, I just have to simply sign it with a private key. And because I already have the money from the user and they gave me the go ahead, I'm just going to use the funds from that account. Lastly, what I'm going to do is send the signed transaction so that way everything happens in the background and the user does not even know they're interacting with a blockchain application.
00:10:23.948 - 00:10:25.122, Speaker A: Sounds like magic.
00:10:25.266 - 00:10:27.094, Speaker B: Sounds like magic. But will it work?
00:10:27.212 - 00:10:30.280, Speaker A: Will it work? Let's see. Okay. Can we try it?
00:10:30.730 - 00:10:45.542, Speaker B: Let's see. So I'm going to switch it over here to just use scale in the back end. Let me refresh my ingredients. So I have eggs, I have flour, I have milk. Are there any other ingredients?
00:10:45.686 - 00:10:55.722, Speaker A: Well, we don't have chocolate up there. And I think if we're really going to bring this up, we need to have something chocolate integrated. So maybe like a teramisu, something like that, or some sort of chocolate cake.
00:10:55.786 - 00:11:30.074, Speaker B: I love where this is going. So for teramisu, we will need chocolate. And I'm going to add an ingredient here to I'm going to add an ingredient to my application, and it's going to use scale's file storage that I also saw in their documentation to house that file. So let me walk you through what that looks like in the documentation here. What you have are a few set files that you set methods you can use. I can upload, I can delete, I can download to my browser or to a buffer. And they also had an NPM package to make it easy to work with my react application.
00:11:30.074 - 00:11:40.814, Speaker B: So instead of having to interact with a low level contract, even though I could, I had these easy methods to be able to add this functionality to my application. You want to see what that looks like?
00:11:40.852 - 00:11:42.094, Speaker A: Absolutely, yeah.
00:11:42.212 - 00:12:11.334, Speaker B: Okay. So in the same actions file here, if you see here, I'm using the Upload feature. File storage is the name of the NPM package that I pulled in. And then I'm using Upload file, and I'm passing some key parameters here. Now, I saw there was an option to still let MetaMask do its thing in the backend by not passing a private key, but we're trying to make sure that the user doesn't feel like they have to go through another hurdle to use our application. So let's just do it this way.
00:12:11.372 - 00:12:14.022, Speaker A: Awesome. It's all packaged all into one, so let's try it out.
00:12:14.076 - 00:12:24.122, Speaker B: All packaged all into one. So if I come back here, what I see is I now have that file, and I'm going to call it from the blockchain to add to my application.
00:12:24.256 - 00:12:24.762, Speaker A: Got you.
00:12:24.816 - 00:12:25.930, Speaker B: That happened pretty fast.
00:12:26.000 - 00:12:32.190, Speaker A: That's awesome. So that's pulling that file that we uploaded onto the scale chain directly onto our app, right?
00:12:32.260 - 00:12:38.686, Speaker B: Got you. So more decentralization for our application here. So let's go through and make the cake and see what happens.
00:12:38.868 - 00:12:41.234, Speaker A: That was pretty fast. Look at that.
00:12:41.352 - 00:12:44.526, Speaker B: Without MetaMask or without another click for the end user?
00:12:44.558 - 00:13:00.982, Speaker A: Yes, I clicked a button to add my ingredients. We stored a file onto the scale chain. We were able to pull that file from the scale blockchain and add all the ingredients together to adapt. That really feels like an app. I had to click one button. There was no MetaMask. Nothing.
00:13:00.982 - 00:13:04.762, Speaker A: This doesn't even feel like a blockchain at all. Pretty amazing.
00:13:04.896 - 00:13:05.740, Speaker B: I agree.
00:13:06.510 - 00:13:19.358, Speaker A: Awesome. So here's an example of how you all can have your cake and eat it too. So have we shown really good, UX, really good examples of this? And we actually have a chef in.
00:13:19.364 - 00:13:22.110, Speaker B: The audience who's an expert cake.
00:13:22.610 - 00:13:23.406, Speaker A: Yes.
00:13:23.588 - 00:13:24.670, Speaker B: Connoisseur.
00:13:26.530 - 00:13:28.154, Speaker A: With some macaroons.
00:13:28.282 - 00:13:38.580, Speaker B: Yes. So for those who do really want to eat cake and not just a digital ties one, we have some Macaroons in the audience, so please feel free to take one.
00:13:43.770 - 00:13:44.840, Speaker A: Any questions?
00:13:51.610 - 00:14:07.580, Speaker B: Yes. After this demo sorry, the question was, is a demo available to a download from our GitHub? And I will be adding it there right after this presentation. So you'll be able to have access to that. So if you interact with us on our discord, I'll be able to give you the link directly there so you won't have to search for it.
00:14:09.330 - 00:14:38.830, Speaker A: Any other questions? Great. Thanks to fast. Oh, yeah. How do we compare it to plasma? So plasma is another scaling technology that has a different architecture. We are a side chain, so we're a different style of layered scaling technology. Yeah. Yes.
00:14:38.830 - 00:15:21.660, Speaker A: Can you reconcile the state to the main chain? So we use a lot of messages to communicate between a scale side chain and to the main chain. So it's just messages that we send back and forth. So we don't send any state per se. It's just messaging. Excuse me. Yes. Well, if you do want a message to the main chain, we do offer a microservice that allows you to transmit those messages back and forth, but it's a very simple integration to enable that.
00:15:21.660 - 00:16:19.212, Speaker A: Yes, and we'll be happy to explain more details about this sort of snapshot service after this so we can meet with you and kind of discuss if you have a specific solution in mind, we can help you out with that. Yes, sure. So there's a network of permission nodes, they're validators that provide compute and storage power to the network. And so those are the people that are running the servers. So it's a permissionless network. And when you select a scale chain to scale your app onto, a subset of those nodes are chosen at random, and that allows your contract to operate really fast if all validators are colluding. Yes.
00:16:19.212 - 00:16:42.340, Speaker A: But as a DAP developer, you have no control over these servers. They are independent servers that operate independently and over time. The scale chain there's servers that are swapped in and out if N minus one are corrupted. So it's a Byzantine fault tolerant system, so it assumes that less than a third are malicious. All right, thank you.
