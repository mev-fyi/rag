00:00:00.170 - 00:00:20.814, Speaker A: I'm assuming that I'm not going to see myself show up on the zoom call here because I don't know how this works. We can just dive into the panel because it looks like we have most of the panelists here. I think the only person I haven't heard from yet is John Adler. Do we know if he's on the call?
00:00:20.932 - 00:00:21.902, Speaker B: I'm here.
00:00:22.036 - 00:00:42.862, Speaker A: Oh, perfect. And I can even see you. Cool. So this panel is about mev in the coming cross chain world. We only have about 30 minutes for it, and we have five people. So I'm going to try to get through the introduction really quickly so we can just dive into questions. I'm James Presrich.
00:00:42.862 - 00:01:20.002, Speaker A: I'm going to be moderating the panel today. I'm lucky enough to have with me five people who work on layer twos roll ups and cross chain environments like cosmos and Celestia. Throughout the panel, I'm going to be trying to say cross domain. Some of these things are not strictly speaking chains, although a lot of the semantics for connecting them are just the same. So whenever I say cross domain communication, just think cross chain. I'm just trying to be a little more technically accurate. So I know that each of the panelists has a lot of opinions on the subject.
00:01:20.002 - 00:01:34.540, Speaker A: I'm going to give each of them just a minute upfront to talk about themselves, their project, and give a brief introduction. Could we start with Zucky? Cool.
00:01:35.390 - 00:01:52.670, Speaker C: So I wear many hats. I think in this particular domain, I'm wearing the cosmos IBC hat representing sort of the live internet blockchain, like communicating light client system of inter blockchain communication.
00:01:53.430 - 00:01:56.754, Speaker A: Great. John, do you want to go next? Sure.
00:01:56.792 - 00:02:15.670, Speaker B: Hello, everyone. I'm John Adler. I'm with Celestia labs, where I do protocol, specification and research. And I guess I also wear several hats. And in this case, I guess I have been brought on to talk about things like shared security models when it comes to cross domain communication.
00:02:16.890 - 00:02:27.050, Speaker D: Ed hi, everybody. I'm ed Felton. I'm co founder and chief scientist at off chain labs. And we make Arbitrum, which is a layer two scaling solution for ethereum.
00:02:27.710 - 00:02:28.730, Speaker A: Ellie.
00:02:29.550 - 00:02:45.490, Speaker E: Ellie. Ben sasson, co founder and president of Starkware. We use ZK Starks, which I co invented with some of my co founders, to solve scalability on StarkNet and Ben.
00:02:46.390 - 00:02:54.402, Speaker F: Hey, folks, I'm Ben, co founder at optimism. We're building optimistic ethereum, and I will similarly take less than my minute a lot of time.
00:02:54.456 - 00:02:55.810, Speaker E: Well done, panelists.
00:02:56.570 - 00:03:40.210, Speaker A: We're moving through things quickly. I think it's interesting that we have a split of know, John and Zucky, who are working on multi chain environments and other non ethereum things. And we have primarily ethereum based roll ups, which are split between the optimistic with Ben and Ed and the ZK with Ellie. So I kind of want to start off by talking about the technology a little bit for each of you. How does your system handle cross domain communication for the roll ups? How do you communicate with the layer one and for the cosmos and Celestia? What does that even mean in your environment? And let's go in reverse order. Can we start with Ben?
00:03:43.110 - 00:04:19.950, Speaker F: You can indeed, yeah. So in layer twos, right, where we have this L One running the show, where the data is coming into and disputes are going to be handled if necessary. Basically, the L one is that source of truth. The cross domain messaging is sort of based in that L one. So we have two kind of levels of cross domain communication in our system. The first is a lower level one where basic, but the interfaces are very similar, and it's about the properties that these two bridges give you. So at the lower level, you basically have any smart contract or account on.
00:04:19.950 - 00:05:02.094, Speaker F: Layer one can send in a message which specifies a target, some data, and a gas limit. And that will eventually be included as a call in the L two chain or domain, I should say. So that's what it is. And then you have an opcode in the L two VM that lets you access who on L One sent that call. So there's one tricky part with L2 S, which is that you can be out of gas and you kind of can't know about it on L One. Right, because you have to impose a gas limit on L2. And because the whole point is that L two is a separate environment, l one can't know about it.
00:05:02.094 - 00:05:37.080, Speaker F: So basically we add an additional layer of messaging, which is like, really what's exposed to devs, which has the same properties, but basically wraps everything in a system that enforces atomicity. So it might be the case with that lower level message sending that a smart contract might send a message in. But on L two, that basically times out or can't be run because you're out of gas. The chain is too congested at the moment. So we add in another layer of messaging that gives you atomicity, where if you pass the message in, it's guaranteed to be received at some point in the future.
00:05:37.610 - 00:05:40.198, Speaker E: Some point in the future, some point, that's right.
00:05:40.284 - 00:05:43.146, Speaker F: So that's kind of the two levels of cross domain messaging that we have.
00:05:43.248 - 00:05:53.150, Speaker A: Cool. And let's go to Ellie. How does the Stark based roll ups handle cross domain communication?
00:05:54.370 - 00:06:32.300, Speaker E: So currently we have a few different systems that are alive in production. And the way that there's cross chain communication right now is basically through layer one and the way you would imagine it, that you pull something out and you take it in from the other side. And I like to speak more about what we actually have than about what might be in the future. I'll just stop here. We'll have better cross chain communication directly between things, but when it's ready.
00:06:34.190 - 00:06:34.614, Speaker C: We'Ll.
00:06:34.662 - 00:06:39.260, Speaker E: Be able to discuss it but yeah, that's the way we do it right now.
00:06:43.010 - 00:06:48.160, Speaker A: For people who might not be aware. How many different production systems is Starkware running right now?
00:06:48.530 - 00:07:21.180, Speaker E: Currently we're running three production systems. Spot trading, it's diversified. dYdX does margin trading or perpetuals, and just 1 second. And I'm at home with my kids and Immutable X does Minting and trading of NFTs, also third party. So they have a whole ecosystem running there. And very soon, Sorre is going to go live, which is going to be another NFT based thing. So three right now, in a few weeks, four.
00:07:23.470 - 00:07:30.266, Speaker A: Very cool. Ed, same question. How is Arbitrum handling communication with the L one?
00:07:30.448 - 00:07:30.986, Speaker E: Sure.
00:07:31.088 - 00:08:30.270, Speaker D: So some people will use specialized cross domain functionalities, like cross chain atomic swaps and so on, that would work pretty much across any pair of chains. But the general purpose cross domain communication and call mechanism we use is basically one that allows a contract that's running on one chain to send a call to the other chain so that's call data, call value, and a destination. And because the L one and L two run asynchronously from each other, what you get is that you can know synchronously that your call has been in queued for the other chain, but it does run asynchronously, which means you know it will run, but you don't get to see the result within your own transaction. And this is true in both directions. A contract on either chain can make a general call to any contract on the other chain by this mechanism. And then there's other functionalities built on top of that, such as Token Bridging.
00:08:33.910 - 00:08:39.810, Speaker A: Isn't that generally true of all cross domain communication, that everything will run asynchronously?
00:08:40.470 - 00:08:56.920, Speaker D: Pretty much. I think when you're talking about a roll up type of approach, asynchrony seems to be necessary, at least without if you were to lockstep things together more, it would have side effects that you wouldn't want.
00:08:57.610 - 00:09:06.522, Speaker A: Okay, and John, I think you're up next. Celestia, what is the concept of a domain and how do you communicate between them? Sure.
00:09:06.576 - 00:10:00.620, Speaker B: Thanks. So, for those unfamiliar, I'm going to do like a five second spiel of what Celestia is doing because otherwise my answer will make no sense. Essentially, it's the first and currently only general purpose data availability chain. It's a chain that's specifically built just for data availability throughput it doesn't execute any transactions. And before Dancrad crucifies me for saying general purpose, we can also call it overhead minimized. And because it doesn't execute any transactions, it doesn't actually have any notion of bridges with anything else enforced inside its VM, because it has no VM, essentially. So what this means is you can build applications on top of Celestia that leverage it for shared security, and those applications can define their own mechanisms for crushed domain communication, and Celestia does not enforce anything.
00:10:00.620 - 00:10:49.446, Speaker B: So to give an analogy, it'll be like asking, what how does it handle a cross roll up communication? Well, it doesn't because it's a credibly neutral layer that you can build applications on top of. Similarly, Celestia doesn't enforce anything around cross application communication. However, it does provide certain interesting things when you're dealing with cross domain communication. Namely, it allows shared security. And what that means, it's a shared time snapping server. So imagine if you had like a BTC relay or some sort of bitcoin relay where you would still have to do fraud proofs or blockheader validity or transaction validity and stuff, but you just straight up didn't have to deal with bitcoin reorgs. You just completely remove reorgs out of the equation.
00:10:49.446 - 00:11:21.670, Speaker B: And both chains can proceed in lockstep that if you try to reorg one chain, you would also, as a consequence, reorg the other chain. That kind of stuff can really help cross domain communication, and it allows general purpose chains to leverage the same nice token and smart contract call bridges that systems like starkware and optimism and that Arbitrum have been doing. You can leverage those kinds of mechanisms between more general purpose chains so long as you have the shared timestamping server.
00:11:23.050 - 00:11:29.254, Speaker A: So in a lot of ways, it's similar to a framework for roll ups and for communicating between roll ups.
00:11:29.302 - 00:11:30.474, Speaker B: You could say that, yes.
00:11:30.592 - 00:11:35.146, Speaker A: Okay, and Zucky, let's finish off this round of questions with you.
00:11:35.328 - 00:12:35.646, Speaker C: So IBC, which is Cosmos'flagship inter blockchain communication protocol, is an asynchronous packet based system between blockchains that have sort of fast finality between them and primarily exists between tendermint ecosystem blockchains. Let's see, what are the other sort like right now? I think one of the coolest things about IBC is its general tolerance for failures of any sort of intermediaries. So the chain that you're communicating may have lost liveness the chain you're communicating, there may not be a live relayer between them. And we have reasonable failure recovery paths between all of these things, which I think is relatively cool and unique and is running in production right now. And people are sending like tens of thousands of IBC packets every day, which is kind of cool.
00:12:35.828 - 00:12:59.462, Speaker A: Very cool. So this is more of an open question for the group. Are there any specific apps that we're seeing use cross domain communication? I think a lot of us have talked about token bridges is how do we get assets from one domain to another? Are there any other applications that we think are going to use this and anyone can just jump in here?
00:12:59.516 - 00:13:58.150, Speaker D: Yeah, I'll jump in. So in addition to token bridges, a common design pattern that we're seeing is applications that want to exist on multiple chains, say on L one, and on Arbitrum using one of two patterns. Either they're sort of homed on one of the chains and open up a sort of branch office contract on the other one, where the home is the ultimate source of truth, but they allow people on the other chain to have whatever functionality their application provides. And we're also seeing some that are genuinely dual homed where you have a contract on each chain and those communicate with each other through a combination of out of band mediated communication and also the on chain supported cross chain functionalities and they're jointly providing functionality. So we're seeing people, especially in the DeFi space, building a lot of interesting things in this design pattern.
00:13:58.310 - 00:14:00.650, Speaker A: Do you have an example of the second pattern?
00:14:03.150 - 00:14:30.580, Speaker D: So an example of this I don't want to name specific names, but we are seeing people who have token based systems, for example, that can do Minting and Minting and redemption type of activities on both chains. So it's not the case that you have to transfer your tokens to either particular chain in order to do those things, whether you can only Mint on one. So that's a simple example.
00:14:31.110 - 00:15:31.970, Speaker E: Interesting, I can offer another example with respect to or a class of things that could come either from l One or from other l Two S going towards StarkNet. So I think the main advantage of something like StarkNet is that you can really compress both computation and the nondeterministic witnesses that are needed in other things. Both l one and other l Two S. So you could sort of have a situation where you want basically to relay or ask from l one or from some other L two StarkNet to run this computation, let's say a VDF or an auction or something that has compute something an average based on many, many Oracle price feeds and things like that. And if you would have done it either optimistically or on l One, you would have paid either for the computation or for the computation and the transmission depending if it's on l One or some roll up that needs to put all the data. And so I could see those kinds of bridges as well. And so these are non token bridges.
00:15:31.970 - 00:16:01.120, Speaker E: These are basically bridges or the communication where you want to rely on the ability to compress computation and call data on something like mean they don't exist right now, but they exist implicitly. Like dYdX relies on multiple computations of price oracles and all of the signatures are abstracted away. But I could see use cases where there's demand from it from l One.
00:16:01.730 - 00:16:11.250, Speaker A: So kind of the general thing there is that you're using the cross domain communication to communicate about the validity of some computation right, right.
00:16:11.320 - 00:16:16.010, Speaker E: And nondeterministic witnesses that maybe you don't want to verify on chain.
00:16:16.190 - 00:16:29.580, Speaker A: Right. Things like large batches of signatures you can just drop from the message entirely. Got it. Very interesting. Any other examples of cross chain applications that we're seeing?
00:16:30.350 - 00:17:12.710, Speaker C: One of the things that the Cosmos ecosystem is most excited about is what we call interchain accounts, which is basically taking the idea of, like, a smart contract account or a smart contract, like wallet and extending it to the idea of an entire blockchain. Can be represented as an account on another blockchain and has all the powers of all the capabilities of the native blockchain on the other blockchain system. It's probably less abstract than the other examples that people have been giving, but I think it shows the level of excitement about it, shows the demand for things beyond token transfers generally.
00:17:14.010 - 00:17:23.526, Speaker A: So the idea there is basically that this other domain has an account and can call contracts or perform any normal blockchain action.
00:17:23.718 - 00:17:24.460, Speaker C: Yes.
00:17:25.070 - 00:17:26.060, Speaker A: Very interesting.
00:17:29.070 - 00:17:42.880, Speaker E: I wanted to add, James, another specific example of the kind I said is just voting. So you have a bunch of stakes, let's say some ERC or governance token. You want to collect votes. If you do it on L One, it's going to be very expensive. You could ask StarkNet to do that for you.
00:17:43.910 - 00:18:21.950, Speaker A: So you could take something like Snapshot and turn it into Stark based proof that the vote occurred. Okay, very cool. So we've identified a few cross chain applications, things like attesting to validity, allowing a blockchain to control an account in another blockchain, DeFi apps that are homed on multiple chains and can perform all of their functions. There are there specific ways that mev in this application differs from mev within a single domain.
00:18:25.410 - 00:19:18.240, Speaker E: I'm willing to go first and say something obvious, which is that even like in the conventional financial world, apparently a lot of the Arbitrage and high frequency trading is connected to having different systems or exchanges or markets where things are happening, sort of connecting the dots and acting on them. I think mev has this aspect to it, which is that you even can manipulate or do things. The more places that you have where things could sort of be manipulated, then of course it just raises the possibilities. But this is just a general statement. So like, if you could influence both the sequencing at one place or the transactions or the mem pool in one L two and then in another side chain, then of course you could have even more arbitrage opportunities. But this is, again, I think we'll see it in the future, probably.
00:19:20.050 - 00:19:26.270, Speaker A: This kind of ties into what Ed said earlier about computations running asynchronously in all these environments.
00:19:27.170 - 00:19:27.582, Speaker B: Sure.
00:19:27.636 - 00:20:34.354, Speaker D: And yeah, let me jump in. I think Ellie was talking about the sort of combinatorial explosion of different mev strategies and levers that happen when you have more than, say, two chains or domains. In the case of two, I think like the L two S, I think the roll ups probably are similar to what we see, which is there is a mechanism which determines the order of transactions or incoming inputs to our roll up chain. And that really is the mechanism that establishes order and where the mev and fairness questions are going to be dealt with. And that's because if it's an L One to L two call, then you have an L one contract that wants to put an event into the inbox of the L2 contract. And that essentially goes through that ordering mechanism. And if it's something that happens at L2, well, L2 transactions are ultimately triggered by inputs that come in and also go through that ordering mechanism.
00:20:34.354 - 00:20:56.240, Speaker D: So there's that single ordering mechanism. I think that would be true of other roll ups as well. And so the question is, how do you handle that? Because that's what determines ordering and mev and fairness consideration. So we've devoted a lot of attention to how we do that in a way that reduces the amount of value that gets extracted from users and that is as fair and transparent as we can make it as we evolve over time.
00:20:57.250 - 00:21:26.342, Speaker A: So the problem here, if I can restate, is that messages between domains and messages to a specific domain can be interleaved. Arbitrum has a shared ordering mechanism for these, but other cross domain systems might not. So given the example of IBC, there is probably no global ordering of IBC messages between domains, right?
00:21:26.396 - 00:21:29.100, Speaker C: Saki no, there could not be.
00:21:29.870 - 00:21:41.130, Speaker A: And for optimism, for example, does optimism maintain a separate mem pool that is ordered separately from incoming L one messages?
00:21:41.630 - 00:22:37.674, Speaker F: Yeah, we do. It's an interesting question and a great discussion. I think one of the interesting I will call out one difference between cross domain messages and other just like within the transactions within the L2. Ed's definitely right that at the end of the day the L2's ordering is determined by some mechanism which is on L2. One interesting thing though is that that mechanism is also required to follow the L one ordering. So one interesting thing that we see is that if you have a transaction which is just a piece of data that is like an L2 transaction, it's like a user transaction with a signature, then you can attempt to order that optimistically before it goes on chain and know the outcome. But this is not the case for the finality of deposits because if a smart contract calls into the chain that is dependent on the L One's finality.
00:22:37.674 - 00:23:04.040, Speaker F: So if you have an L one reorg, you might observe that a different message ends up coming into the chain because let's say the L one reorg moved some money away and now the deposit can't actually be deposited. So I think this is worth calling out that cross domain messages are going to be more restricted in how quickly we can get them in and choose an ordering for them because what they are doing is required to depend on the l one state.
00:23:06.730 - 00:23:39.620, Speaker D: Can I respond to that briefly? I think there's actually different ways of handling that use. Case question is do you need to evaluate the correctness of this thing at L One before you can establish it in order? Do you need to determine whether it will succeed at l One before you assign it a spot in the order, or do you assign it a spot in the order and then the result of it may be dependent on L One reorgs and there's some design choices there which do affect what outcome you get.
00:23:40.630 - 00:23:59.980, Speaker A: So do you think we're likely to see well, let me rephrase that. I think that we're seeing a wide spectrum of choices here from a more tight ordering to something like Celestia where there is no guarantee that any specific message will succeed or do anything. Is that right, John?
00:24:01.630 - 00:24:20.960, Speaker B: Not exactly. So for people, I guess, not familiar, but solutions like Arbitrum, for instance, use correct me if I'm wrong, Ed, but they use this inbox style system where anyone can submit a transaction for the roll up and they can submit it into an inbox contract on the L One. Is that correct?
00:24:21.650 - 00:24:28.494, Speaker D: Yeah, that's part of the story. We also have a sequencer which has limited power to reorder transactions in order to make faster guarantees.
00:24:28.622 - 00:25:09.034, Speaker B: Yeah. So you have those two components. So I think what James is alluding to is he's saying that Celestia would only have that first scheme of anyone can submit a transaction and then they come in any order for the L2. But that's not exactly correct because you can also do batches of transactions and in fact, you can have entire blocks on top of celestial application, can be blockchain based and they can have blocks and you can decide your own sequencer aggregator or however you call it. And for example, they can be the only ones that have the right to produce blocks with application. And everyone else, you just ignore the messages that they post. So you can get essentially the same thing that you get out of roll ups on top of Celestia.
00:25:09.034 - 00:26:07.986, Speaker B: You don't have to worry about this kind of anyone can just post anything at any time. But I did want to mention one thing relevant to your question, if that's okay, which is that I like to invoke what I call the law of conservation of mev when it comes to layers, which is basically that mev can't be created or destroyed. Well, it can be created, it can't be destroyed, it can only be moved from one layer to another, which is completely not scientific law or anything. It's just an observation, which is basically saying that if you have a roll up, you're not going to have less mev, you're just going to move the mev from the best you can do is move the mev from the main chain to the roll up, which isn't inherently bad, especially if you use only batch submission style systems and no inbox. Then the layer one doesn't see the mev, it just doesn't see it because the only people who can submit blocks are these layer two sequencers that comes with its own set of trade offs. But you can move the mev to a layer two. But you can't eliminate it.
00:26:07.986 - 00:26:09.810, Speaker B: It'll still be there in terms of quantity.
00:26:11.350 - 00:26:17.966, Speaker A: So the mev of the total cross domain system is always increasing at the very least?
00:26:18.008 - 00:26:19.522, Speaker B: Yes, it never decreases.
00:26:19.666 - 00:26:51.710, Speaker D: Interesting. I don't know that that's true in general, actually. There are degrees of freedom in design that you have in an L two system that don't exist in the fixed architecture that exists sort of on Ethereum L one. And so you do have opportunities for design that Ethereum doesn't have because Ethereum already exists and has baked in a certain approach. So I don't think it's at all Ethereum that you can't reduce mev. It's not easy. And if you're just careless about it, you probably will maintain or maybe even increase the extractable value.
00:26:51.710 - 00:26:55.342, Speaker D: But you can do better if you're willing to innovate in design.
00:26:55.476 - 00:27:28.250, Speaker B: So I should clarify that when I'm talking sorry, very quickly, if you don't mind. I should clarify that the observation I'm saying is mostly about if your layer two functions the most naive way and exactly the same as the layer one, then you're not removing mev. Of course, just like how you could change layer one to reduce mev, you could also apply those changes and experiment with new techniques for sequencing, aggregation, mev reduction on the layer two. But that's orthogonal to the fact that it's a layer two. Like you could do those same things on Ethereum if it wasn't for the fact that needed to maintain backwards compatibility.
00:27:30.110 - 00:28:05.080, Speaker A: Okay, so this kind of segues nicely into the last thing that I wanted to talk about before we wrap up the panel, which is whose job is it to reduce mev? Should it be the job of the system developer or the job of the application developer? And when we get into these cross domain systems, who has to do all of the work to minimize mev and communication between want to because we're wrapping up, I'd love to do this last one kind of round robin, give everyone a chance to speak again. And let's start with.
00:28:07.690 - 00:29:09.802, Speaker F: I mean, it's a great question, James, and it's the philosophical one that I think will get thrown out on every single flashbox talk from now to the end of time. I think the responsibility is on both parties and I think that there's a trade off between doing it within the system in terms of how universal you think those fairness properties are. So I think that the tricky thing is that we don't yet have a result that says that any particular system can have general applications that are mev resistant in some way by nature of the system. It's not obvious at all that for any system that is non trivial that actually can have economic activity, that there's not some application that you can put on that system that introduces mev. So fundamentally, that seems to put a lot of attention onto the application developer. If we don't know yet if it's even possible for a generalized mev resistant application. There are obviously things that we can do that are very useful heuristics and that feel very fair.
00:29:09.802 - 00:29:20.990, Speaker F: It may be different between who thinks what, but fundamentally some of it has to go on the application, I think because of the nature of that systemic unknown.
00:29:21.410 - 00:29:24.254, Speaker A: Interesting. Ed, do you want to go next?
00:29:24.372 - 00:29:30.542, Speaker D: I would agree with Ben that it has to be everyone's job because it's a hard problem and there are hard trade offs.
00:29:30.606 - 00:29:30.834, Speaker A: Right?
00:29:30.872 - 00:30:00.300, Speaker D: So system design should be trying to reduce or mitigate mev as much as possible, but then there'll be some part of the job that will fall onto applications. But it's also important for the system designers to create affordances that are useful to application designers so that they can fight the particular mev or front running issues that afflict their applications. So it's not just sort of fighting it separately in each layer, it's also about what can the base layer do to help the application developer have the tools they need.
00:30:01.570 - 00:31:05.310, Speaker E: Ellie so I take my inspiration from what happens in the conventional markets. There you are under the assumption that if there is a flaw, someone will use it and try to front run or do whatever wash trading or things that are illegal. And then it's the sort of at the system level you ban it by law and regulation. The analogy to that is that I think it is. Of course it's objectionable to front run do things like that and operators and whatnot shouldn't be doing it. But I think you would like in a decentralized protocol based system, you would like to put maximal effort in getting the protocol to eliminate reduce to maximal extent the ability to extract value from these things. Because especially in this anonymized permissionless world, it's going to be very hard to assume that DAP developers are going to be moral.
00:31:05.310 - 00:31:09.540, Speaker E: It's not the case. So you really need the protocol to solve it.
00:31:10.710 - 00:31:13.380, Speaker A: John sure.
00:31:13.750 - 00:32:08.918, Speaker B: I would say, and mirroring what Ed said, that the protocol development developers, under the assumption here that the protocol is some sort of credibly neutral public good, probably have responsibility to at least build tools so that application developers can minimize the mev that the applications they build have. I think it should provide appropriate tools for this. And so it is at least partially the responsibility of the protocol developers. I'm not really sure if the application developers have any responsibility. I guess it depends if you're talking about if it's like an ethical responsibility or a financial one, and it depends if the application is a public good or if it's just some financial application. Application developers, and I think the Ethereum protocol developers had to learn this the hard way with things like refunds, the application developers have one responsibility. Assuming the application is not a public good, the application developers have one responsibility, and that's to.
00:32:08.918 - 00:32:33.866, Speaker B: Make money for themselves and to a certain extent for the users, inasmuch as that makes themselves money. And in that regard, MAV doesn't matter as long as you can make money. And that's why you see things like gas token happen. So if the application is a public good, yeah, they should probably strive to reduce mev. If it's not, we shouldn't assume that they have any such responsibility, in my opinion.
00:32:34.058 - 00:32:37.070, Speaker A: Interesting. And let's wrap up with Zucky.
00:32:37.490 - 00:33:44.302, Speaker C: So, two things. What we found is practically attempting to reduce Mev propagates dependencies up and down the stack. So the demand to reduce Mev is like changing APIs within how tendermint interfaces with the application, which is this idea called ABCI Plus Plus that is sort of propagating mev related ideas all the way down into how tendermint works. And on the other hand, yes, mev is very application dependent and very much the idea of Cosmos is that people could coe evolve all layers of the stack to provide the optimal user experience and to go to a little bit of why would someone want to do this? Why do people care? People care because mev takes value away from their users and sends it to other parties. And you will probably be more successful in acquiring users if that doesn't happen.
00:33:44.436 - 00:33:50.820, Speaker A: All right, thanks for your time, everyone. Always a pleasure to see each of you. I think Sunny is up next.
