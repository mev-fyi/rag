00:00:04.410 - 00:00:24.110, Speaker A: All right, and we're live. Hey everyone, welcome. I appreciate all of you for joining me here today with Jordan and Kevin. We're here to kind of do the polywrap workshop. And without further ado, I'm super excited for this workshop, so I'm going to hand it over to Jordan and Kevin.
00:00:25.690 - 00:00:26.680, Speaker B: Hey, everyone.
00:00:28.010 - 00:00:29.000, Speaker C: Hey everyone.
00:00:31.210 - 00:00:41.900, Speaker B: Let me go ahead and share my screen and then Kevin's going to take us through a quick presentation and then we'll talk about a quick demo and yeah.
00:00:42.670 - 00:00:58.560, Speaker C: Hey guys, thanks for having us. ETH global. I'm Kevin. I'm the developer relations engineer at polywrap. And also here's Jordan, one of the original developers on the project. And we're polywrap. We're building next generation SDKs for web three.
00:00:58.560 - 00:01:55.886, Speaker C: So the issue that we're trying to solve is the issue called the integration problem. So what's that? Today, when we're trying to integrate different protocol business logic, we're using JavaScript SDKs. And the problem with that is that JavaScript is insecure. So when you're using JavaScript, it just takes one malicious dependency in your dependency tree to really cause a lot of harm to your users of your application or the application itself. JavaScript SDKs today, when it comes to web three, protocols are not composable. They're all built in their own way and it's just very hard to really compose the logic together. Finally, they're incompatible with enterprise gaming, metaverse and IoT because these type of applications use other type of languages besides JavaScript.
00:01:55.886 - 00:02:43.350, Speaker C: So a JavaScript SDK wouldn't be able to execute in this type of environment. And so at Polywap, we think that web three deserves a better solution. And that solution is polywap. And our whole mission here is to be a containerization protocol that brings web three anywhere and everywhere. Because today web three is stuck in the browser, a lot of DApps are in the browser, and we want to have it in enterprise back ends and just on your phone and everywhere else. And so Polywraps is a next generation SDK. It's very secure because underneath a polywrapper is using WebAssembly.
00:02:43.350 - 00:03:29.728, Speaker C: WebAssembly modules are allocated their own virtual memory and they're not allowed to really interact with other memory outside of it unless you really let them. They're hyper composable. Polywraps are based on interfaces that we define across all different polywrappers. And so it's easy to compose the logic together. And finally, it's compatible with different use cases. So because the logic is written in WebAssembly, it's able to compile down to WebAssembly and execute in JavaScript or other type of language backends. And so with the polywrap experience, the first step is to write your polywrap SDK, or Polywrapper.
00:03:29.728 - 00:04:50.070, Speaker C: You would then wrap it into the polywrapper, and then in step two, you would deploy it to decentralized hosting, like a decentralized storage like IPFS. And then as a DAP developer, you can just install the Polyrat client and at that point you're able to fetch business logic from IPFS and execute it into your application on any platform, whether it's IoT, mobile or laptop or whatever. And all of this comes together in the polygraph Hub. This is our UI that we have to do like a web three aggregator. It's able to bring all the polywrappers together in a marketplace type of app where you can search different polywrappers. For example, if you were to click the Uniswap protocol here, you can go ahead and do like queries and fetches right into the application and test them out as if you were using, for example, postman in web two development. And here's just a UI to show you that screen where you can put together a GraphQL query and do fetches and also connect your wallet to do mutation type of queries.
00:04:50.070 - 00:05:38.710, Speaker C: And so our first large case study was with Uniswap. So we were funded by the Uni grant team to create the Uniswap version two polywrapper. And what we did with this is that we forked the Uniswap interface, we took out all their Uniswap JavaScript SDK and we replaced it with a polywrapper to showcase this. And we were able to fetch Uniswap's business logic from IPFS through the polywrapper and able to execute swap functions right into the application without the JavaScript SDK. So this is powerful because this use case shows that in the future we'll extend support for this and be able to execute Uniswap in enterprise applications like PayPal or Robinhood.
00:05:39.770 - 00:05:51.260, Speaker B: Yeah, and one of the other benefits here is that it now becomes much easier to integrate Uniswap than with the JavaScript SDK. And so when we show you the demo, we can actually show you just how easy it is to integrate now.
00:05:54.580 - 00:06:29.500, Speaker C: And just an overview of our Dao. We started with a development shop called Dorg, and today the Dao is a lot more decentralized. For example, we have ChainSafe working on one of our potential future polka dot integrations. Consider it done. It's working on the hub and so on. We have 19 launch partners today. And what these launch partners do is that they help with our documentation and code and there get exclusive access to early access to products like the Hub.
00:06:29.500 - 00:06:49.616, Speaker C: And we chose these launch partners because they all have their unique needs and polywrap solves for those unique needs. Finally, we got $1 million in funding in December of last year and I'll hand it over to Jordan. He's going to show you a workshop.
00:06:49.808 - 00:07:23.070, Speaker B: Awesome. Thanks so much, Kevin. Yeah, so now we can get to actually seeing it in action. So, like Kevin had told you all before, we had created a fork of the Uniswap interface to show our polywrapper working for the Uniswap protocol. And so here we can see an example of this. All of the logic being executed here is being done through the wrapper executing in WebAssembly. And the user interface for this is very simple.
00:07:23.070 - 00:08:03.816, Speaker B: Here we are using the polywrap client to send a query. We're sending it to the endpoint, which is the ENS Uri, which I'll show you up here. It's v two uniswap web three API ETH and then lastly, we're sending a best trade exact in to figure out what the resulting output will be if we give it 0.1 E. And so upon sending this query, the client is going to fetch the WebAssembly, run it in the app and give us the result back. So, yeah, very easy user interface. It looks just like a Web Two API, hence why we used to call the project Web Three API.
00:08:03.816 - 00:08:44.600, Speaker B: But we recently renamed to polywrap. And so just to show you kind of what's going on under the covers here, this domain on ENS is pointing us to IPFS. And so this is the content hash of the package. And if we go over and we move zoom out of the way and we click on this tab here, we can see that this is what your package looks like. We have the mutation and query WebAssembly files in GraphQL. A mutation is used for writing operations and a query is used for reading operations. And we use GraphQL because it's a very well known interface definition language.
00:08:44.600 - 00:09:20.276, Speaker B: And it also gives us nice properties like separating reads and writes. If you look at the size of these packages, they're very small. This is actually about the size of the JavaScript package for Uniswap. So no size Bloat there. And yeah, we're able to do things like go ahead and execute a swap if we'd like. And so for the sake of this workshop, showing you this code base is a bit much because the Uniswap app is very large and it does lots of things. But what we did was we created a workshop for you all to check out.
00:09:20.276 - 00:10:07.524, Speaker B: This workshop has two different sections. So if you read down here in the README, the first section is for creating a custom DAP using the Uniswap polywrapper. And the second section is for creating your own polywrapper using Uniswap. So a good way to think of this is that this is for a user facing UI and this is for including Uniswap in your own custom SDK. And so if we check out these different sections, we can actually jump through how this works here for creating the custom app. And I'll actually show you this running. We have some steps like getting some prerequisites running the installation, all this fun stuff, and then we can actually start the application.
00:10:07.524 - 00:10:38.350, Speaker B: So over here I actually have the application running for you and it is the completed form of the app. So this is something I should tell you about. In the master branch, this is an incomplete application. So this is the start of the tutorial. And in the completed branch, this is where the app is already done. So everything's already working. And so all of these steps shown down here basically lead you through setting up the application so that it can fully function.
00:10:38.350 - 00:11:18.184, Speaker B: And so this first step is when you fetch the token output amounts. This is when you type in a number here, it'll go ahead and fetch the output amount. So that's what that's doing. In order to do so, it looks something like this. You do client query, you give it the ENS Uri and then you do pair output amount. And we can actually see this in the source code because it may look a little prettier. If we go to the DAP folder and we go to Source Web, three API and then fetch swap output amount, this is what that looks like.
00:11:18.184 - 00:11:54.784, Speaker B: So we have a client, we send a query and we get the result. So that's simple enough. And the rest of the tutorial will take you through doing the other pieces of functionality, like being able to approve your, ERC, 20 tokens. Here we're calling a contract view method to see if the allowance is enough for our swap. If it's not enough, we go ahead and we ask for approval. So we do Mutation Approve on the uniswap API or the Uniswap wrapper. And then the last step is actually doing a swap mutation.
00:11:54.784 - 00:12:42.660, Speaker B: And so this is what executing a swap looks like on the client. And the end result is that you will have a custom application running uniswap and you can actually go ahead and do things like create a swap. And so I'm going to go ahead and fire this off, purchase some uni. And so while we wait for that to complete, we can check out the other side of the workshop, which is creating your own wrapper. And so this is if you'd like to include uniswap in a new polywrapper. Why might you want to do this? Maybe you want to make a wrapper that swaps things on uniswap and it stakes them elsewhere. Or maybe you want to create a DeFi aggregator of sorts.
00:12:42.660 - 00:13:16.508, Speaker B: This is why you'd want to include uniswap. And so, here, let me just show you the code, actually. So let me go ahead and close this. As you can see, we have a DAP folder and a wrapper folder. Inside of our wrapper folder, we have Mutation and Query. As you might expect, starting with the query, if we look at the schema, this is a function that we have defined called Fetch token Total Supply. So this is just a helper function that we've created.
00:13:16.508 - 00:14:00.910, Speaker B: And as you can see up in the top here, we're actually importing sorry, this is blocking for me. We're actually importing the query type, chain ID and token amount from the uniswap polywrapper. So this is an example of how you can actually import types from other polywrappers into your own and these will actually get generated into your code. And so if we look at what this code looks like, it's very simple. All we have to do is define our function for fetch token total supply. And as you can see, our input types, our input types have gotten generated for us. So this is our generated folder, which does a lot of heavy lifting for us.
00:14:00.910 - 00:14:33.080, Speaker B: And then we can simply call uni underscore query fetch token data. So this is going to be another query to the uniswap wrapper. And then the last part is once we get the token data, we can get its total supply. And so we call fetch token total supply and we return that amount. And so that's really quick and easy. And then the last thing here that I'll show you is the mutation. We had defined a simple swap function and implementing it looks something like this.
00:14:33.080 - 00:15:15.030, Speaker B: We go ahead and we fetch some token data for the input and the output tokens, and then we perform a swap on the uniswap mutation module. And if we want to see all this actually working, we can actually run some tests. So if you look through the instructions, it'll teach you how to go ahead and build and deploy your wrapper. And then you can run a simple test like this. And what this will do is it's going to send a test query to the wrapper. It's going to take a second because it's going to first try your local and then it's going to try the remote to be able to resolve the packages. And then if we just give this a second, it'll go ahead and run the function.
00:15:15.030 - 00:16:03.264, Speaker B: Do let's also while we're waiting, we can go ahead and check this out. We can go ahead and see that our swap of Zero One Ether has succeeded. And so we were successfully able to buy some uni through our example application. And I'm not sure why this is halting. Oh, cool. All right, so we were able to actually fetch the token supply using our custom function. And the cool thing to note here is that the CLI that we just used to send this query had no clue about our custom wrapper.
00:16:03.264 - 00:16:40.770, Speaker B: But what it did was it went ahead and fetched it from our local deployment because we deployed it to our local IPFS node and it went ahead and called this function. So this is kind of showing you the powerful nature of being able to integrate Web Three on demand. So it's kind of like streaming Web Three into your applications, which is pretty cool. I'm going to stop there because I think that we should leave a little time for questions. And I think that the last thing I want to show is that we have other demos. So if you go to GitHub polywrap demos, you can find a whole bunch here. There's a whole bunch of different demos here.
00:16:40.770 - 00:17:18.110, Speaker B: And then also we do have a DeFi SDK, which I think is a very cool wrapper to look at. So the DeFi wrapper, if that still exists, yes. So this is a in development wrapper that one of our contributors, Naraj, is building. And it aims to be an aggregator for DeFi protocols. So it's a really cool example of how easy it is to compose protocols together using polywrap. And so, yeah, that's kind of the last thing I wanted to show. Would love to see if anyone has any questions.
00:17:18.110 - 00:17:51.276, Speaker B: All right, I'm just going to go ahead and read through the chat. Does it work with V 32? Great question, Kevin. We actually got a grant from the Uniswap dow to build a V Three wrapper. When we started building the V 21. V Three wasn't launched yet and so the timings didn't really work out too well in our favor. So we'll have the V Three wrapper built soon and yeah, we've been starting on that right now. Oh, cool.
00:17:51.276 - 00:18:05.750, Speaker B: It looks like Kevin no already answered that. This is the most kevin's I've seen. Amazing. A lot of Kevin love. Yeah. Kevin, do you know if there's any other questions that I missed here or that we should answer?
00:18:07.880 - 00:18:14.740, Speaker C: I didn't see any, but if you guys have any questions, feel free to unmute or ask or ask in the chat.
00:18:15.400 - 00:19:16.520, Speaker B: Yeah, definitely open a chat. One of the other things I'll go ahead and share here is just go ahead and share our website quickly because polywrap is kind of innovating at a different layer of the stack. We're innovating at the SDK layer. And so this actually gives us a whole bunch of benefits that we didn't previously have in web three. So just kind of reading through these. It allows you to build an SDK once and use it everywhere. So, for example, we no longer have to build language specific SDKs for things like, let's say, IPFS or Ethereum, where we have kind of like six different implementations of those SDKs for Python and Java and Go and Rust and JavaScript.
00:19:16.520 - 00:19:59.324, Speaker B: And so with polyureth, theoretically in the future we can just have one instance of those which would be very easy to maintain, which would be nice. It's more user friendly. So since we use a GraphQL syntax for doing everything, its interface looks just like a web two API. And so any web two developer can ideally come into polyrep and start using web three. Using polyrep, it's more secure because they're all sandboxed inside of WebAssembly. So if you had some malicious code that wanted to try and access your private key or anything like that, it wouldn't be able to access it because it's trapped inside of the WebAssembly it's executing in. Like it's its own module.
00:19:59.324 - 00:20:52.932, Speaker B: It can't break out of itself. It is more scalable because we fetch and download these wrappers on demand. So you can theoretically have an infinite number of integrations in your app without bloating the size of your app. So this is really great for aggregators today in web three. When we build aggregators, a lot of the times we end up recentralizing things by building central servers to do the aggregation for us. This is how apps like, let's say Zapper or Zurion oftentimes do their integrations as well as they use things like Smart Contracts to be able to do this on the fly. But with polywrap, all that can be done within the polywrap ecosystem, easily creating scalable modules that can be fetched and then also can use extendable interfaces to be able to fetch other implementations on demand.
00:20:52.932 - 00:21:47.428, Speaker B: So that's another really cool feature. It is more composable because we're using GraphQL. And so you can easily combine these together instead of having to stitch together a custom JavaScript SDK with another custom JavaScript SDK, you can simply just list a series of GraphQL queries and you can combine your wrappers together and then lastly they're upgradable. So this is really big for things like smart contract protocols because oftentimes when we make changes on chain to a smart contract protocol, we have to upgrade an SDK off chain as well as they use things like smart contracts. It looks like somebody's unmuted and there's a little echo. With polywrap, all that can be done polywrap ecosystem. Okay, I'm just going to keep talking, but there's a little echo if you don't mind meeting.
00:21:47.428 - 00:22:42.324, Speaker B: And then also can use extended. The other piece here with upgradable is if you upgrade an on chain contract at the same time as upgrading the contract on chain, you can also upgrade the wrapper either by changing the ENS domain's content hash or changing some other pointer, let's say if you're using some other domain name system. And what this allows you to do is not have to rebuild your apps, not have to rebuild your nodes and then relaunch everything, you can just go ahead and automatically be upgraded to the latest wrapper and it'll be compliant with the contracts. And so one of the things we're building in the future is an on chain registry. So this is similar to npmjs.com or crates IO. We're actually going to be building out a custom package repository for these polywrappers where you can publish to them and the GitHub links.
00:22:42.324 - 00:23:37.484, Speaker B: Yes, that's a great so you know, with the polywrap registry you'll be able to publish your wrappers, publish new versions, and then also we'll have verification for these versions. And so if you tried to, let's say, publish a patch upgrade going from 1.1.2 to 1.1.3, we can actually run verification to make sure that you're not introducing any breaking changes. And so this is really big for backwards compatibility and for making sure you don't break downstream dependence like applications. And so that's another really exciting part of the ecosystem that we're going to be launching in the near future. So, yeah, I think I've completely exhausted all of the things that I'd like to talk about.
00:23:37.484 - 00:23:52.930, Speaker B: This is pretty straightforward. Nice work, thank you so much. And yeah, please feel free to ask any questions. We're here to talk. Feel free to jump into our discord. Kevin, is there anything that you'd like to maybe close on or talk a bit more about?
00:23:53.460 - 00:24:31.630, Speaker C: Yeah, just want to end it by saying this is very easy to start up with with our CLI. It's similar to how you would start maybe like a create react app. So take a look at our documentation and ask us any questions. But in general, you can start up an application, like a starter application that has a very basic polywrap already, and you can start playing around with that. But the best way to learn and ask questions, I think, is going to be to start building with polywrap and also joining our discord and just introducing yourself, what you're building and asking questions in our help channel.
00:24:36.760 - 00:24:42.150, Speaker B: Amazing. Yeah. Do you want to close it off?
00:24:45.240 - 00:25:20.210, Speaker A: Yeah, sure thing. Yeah. Thanks, guys, for the really great presentation. And I just want to let everyone know, if you have any further questions, be sure to go to the sponsor channels or honestly, just kind of ask. Kevin and Jordan are both really active on discord, or maybe some other colleagues would be also really inclined to answer your questions. And with that, I want to give Kevin and Jordan another really big shout out for the wonderful, wonderful presentation today. And thanks, everyone.
00:25:24.430 - 00:25:24.840, Speaker C: Thank you.
