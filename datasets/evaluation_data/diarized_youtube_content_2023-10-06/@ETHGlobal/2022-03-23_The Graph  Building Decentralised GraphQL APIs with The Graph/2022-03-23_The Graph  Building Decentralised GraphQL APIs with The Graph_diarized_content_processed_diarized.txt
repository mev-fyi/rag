00:00:00.250 - 00:00:39.170, Speaker A: Great. And we're live. So here I have Vishwa here from the Graph who will be showing you how to build decentralized GraphQL APIs. Vishwash, I'll let you take the stage, and if you have any questions in the meantime, feel free to pop them in the chat and we can take them towards the end. Thanks. All right. Hope everyone can see my my screen.
00:00:39.170 - 00:01:03.060, Speaker A: Yes. Okay, awesome. Let me get started. Hey, everyone. Thank you so much for tuning in. I'm super excited to be here at LF Grow today, and lovely to be here for the workshop. Today, we are going to be learning how to build decentralized GraphQL APIs with the Graph.
00:01:03.060 - 00:01:39.410, Speaker A: And we will be using the Zoro NFT Marketplace protocol to build an NFT API. But before that, let me tell you a bit about myself. I am Bish. I'm a developer relations engineer at the Graph Foundation. And my passion is building deeply engaged developer communities. And I invest a lot of my time to help devs become successful with the frameworks and the tools that they're using. But I also enjoy creating a lot of content writing blog posts, doing workshops and hackathons, giving talks at conferences, and all the cool stuff.
00:01:39.410 - 00:01:56.200, Speaker A: Vishwa oh, yeah. Your slides are okay. Yeah. Thank you. Cool. So, let's talk about the graph. Well, the Graph is a bit three indexing and querying protocol for blockchain networks like Ethereum and IPFS.
00:01:56.200 - 00:03:16.064, Speaker A: And the Graph community plays a prominent role in supporting DAP developers by making open, decentralized data easily accessible with GraphQL. But in simpler terms, as an analogy, the Graph does for open data on the blockchain what Google does for the web. So, using the Graph, anyone can build and publish open APIs, known as subgraphs, that make data on the blockchain more accessible to developers. So let me go a bit more into this concept of what subgraphs are and what the Graph does for our web3 stack with the graphs is the main API layer that sits between your UI and your data layer, as you can see in the diagram. So your UI layer and the data layer, which is basically your decentralized data from smart contracts, the Graph is quickly becoming a default part of your web3 stack. And subgraphs with that are now becoming a Web Three standard. And we also get the question often about where does the Graph come into picture? Well, we like to say that the Graph is the easiest way to query open, decentralized data, but let me explain how.
00:03:16.064 - 00:04:43.368, Speaker A: So we live in this data driven world, right? And all of our data, I mean, not all, but so much of our data is stored across huge storage networks and blockchains. And the blockchain evidently gets large number of transactions per day, even hundreds and thousands, or a couple of thousands of transactions. And so the applications that we're building, they obviously need data that is organized, data that is indexed well so that we can build high performing applications and applications that have great UI UX. But with so much data that the blockchains get these decentralized storage, getting so much data and so many number of transactions happening per day, it is becoming increasingly difficult to index this data for the sake of our applications that we're building and query that data on our front end. So as a solution, developers are building, they were currently building proprietary indexing servers and writing these servers would have some overhead. So this is where the Graph comes in. The problem with the proprietary indexing servers is that there is a single point of failure.
00:04:43.368 - 00:05:23.124, Speaker A: That's the first. The second thing is that it obviously needs engineering and hardware resources if you're going to build out a custom indexing server to be indexing that blockchain data. And of course, lastly, it disrupts the core idea of decentralization. So there's a single point of failure, lots and lots of infrared to manage and costs involved with that. And obviously it is centralized, which disrupts the idea of decentralization at the core. And so this is where the Graph enters. It's a global open GraphQL API, which is why we say that it's the easiest way to index and query your blockchain data efficiently.
00:05:23.124 - 00:06:18.964, Speaker A: So no need to build out your own indexing server anymore. The Graph does that for you by building subgraph APIs that can index and query your data from the blockchain. And it has also built a transparent and open network of all of the builders who are building these subgraphs, people who are consuming these subgraphs for their decentralized applications, people who are curating on these subgraphs by signaling on them and stuff like that. So there is a transparent and open network of builders and consumers that are using the Graph, which obviously helps a lot with collaboration. And this entire network is decentralized and robust. And the Graph is also built on top of GraphQL, which comes with its own benefits of developer experience. But that's not in the scope of this workshop.
00:06:18.964 - 00:06:48.020, Speaker A: So we'll leave out the benefits of GraphQL. But if you want to learn a bit more about GraphQL, there are a bunch of cool resources that I'd love to share with you. Some of them off the top of my head are how to GraphQL. It's a cool platform with free resources. You can also go check out Eve Purcello's GraphQL Resources. She has a bunch of really cool workshops. She also has a book that she's written on GraphQL.
00:06:48.020 - 00:07:44.616, Speaker A: And I love to share more of these resources with you. So if you're on the hackathon discord server, please make sure that you come say hi on our Graph internal sorry, the Graph Sponsor channel. And I would love to share them with you. So, yeah, a global API for use cases that include but aren't limited to things like NFT marketplaces galleries and metaverses, music and video, social and communication platforms and so much more. So you can use the Graph build out subgraphs for use cases like these. And not just that, the Graph is also powering decentralized finance DeFi. DApps are querying on chain data using the Graph like trades and exchange volumes, total borrowed, supplied and staked, asset prices, wallet, balances, total value locked and so much more.
00:07:44.616 - 00:08:53.390, Speaker A: And all of these cute little logos that you can see are some of the best DeFi projects out there that are using the Graph, powered by the Graph. Also, we have some of the most complex applications running out there that allow for richer data on DApps and which are powered by the Graph. So if you know websites like CoinGecko or CoinMarketCap, these are using the Graph in production. And when it comes to NFTs and DAOs you might have heard about foundation which gives NFT marketplace data and it uses the Graph for that. There is also Juicebox, Dow and some of the most famous D Five projects like Uniswap and Synthetics. They're also using the graph. And the Graph's hosted service now supports over 25 networks supporting creators across 25 networks like Ethereum, Near, Polygon, Arbitrum, Optimism and so much more.
00:08:53.390 - 00:09:50.450, Speaker A: And last but not the least, let's talk about Bounties. So in this hackathon, if you will be building using the graph or if you'd like to test out the Subgraph Studio for yourself subgraph Studio is basically this developer environment that you will be using to build out a Subgraph. Then you might as well submit that project of yours that you built in this hackathon to our Bounties. We are offering a total of $3,500 in Bounties by the Graph. So 1500 die will be going to the first prize for the best use of an existing subgraph. So there are two ways to use subgraphs. You can either use an existing subgraph sorry, there are two ways of using on chain data.
00:09:50.450 - 00:10:49.248, Speaker A: You can index and query that on chain data either by using an existing subgraph that is on the Subgraph Explorer, the Graph Explorer or you can create your custom subgraph to index and query that on chain data through a smart contract. So we have two categories for that. The first one is best use of an existing subgraph and 1500 die will be going to that team or individual and 2000 die to the best new subgraph. So that 2000 die is further divided into two prices, the first price and the runners up. So 1500 die to the best new subgraph, first price and 500 to the runners up. So yeah, super excited to see what you folks build and my team will be in the Graph sponsor channel if you have any questions. But I'm sure you'll have more of them once we jump right into the demo.
00:10:49.248 - 00:11:34.640, Speaker A: So that was all about what the Graph is, what it does, the Graph network and the community, the ecosystem, what subgraphs are. But I have a demo for you. So let me get started with that. I think I'm not sharing the entire desktop, so let me quickly do that and we can go right to the Subgraph Studio. Cool. I hope everyone can see my screen. What I have right now is this really nifty guide that we've put together at the graph for everyone who wants to get started by building their first subgraph using the Subgraph Studio.
00:11:34.640 - 00:12:24.130, Speaker A: Let me actually drop this into the chat for everyone if anyone wants to follow along or maybe come back to it later after this workshop. But there are two basic prerequisites if you want to follow along. The first one is you should have Node JS installed on your machine. And the second one is having a MetaMask Wallet. MetaMask Wallet? If some of you might already know, it's a crypto wallet that you can use to manage all of your crypto assets. And you can use that to sign into the Subgraph Studio. So as you can see here, this is the Subgraph Studio that you can go to by going to thegraph.com
00:12:24.130 - 00:13:24.790, Speaker A: Studio. And this is the developer environment that you can use to build subgraphs. I have already signed in using my wallet, but this is something that you can do as the first step of getting started with the Subgraph Studio. If you have a MetaMask Wallet extension in your browser, like Chrome, you can use that easily to sign into your Subgraph Studio by connecting your MetaMask Wallet while signing in and signing a message. There's a button that says Sign Message when you log in and that should do it for you. So as you can see here, this is basically my identity on my Subgraph Studio. I have shared my connected my public wallet here and that's basically my user info and it creates a dashboard for me.
00:13:24.790 - 00:14:18.660, Speaker A: And it's basically like entering my email ID. But instead you're using your wallet to sign into your Subgraph Studio and it will create a dashboard for you where all of your API keys will be managed. You can see your subgraphs that you've either created or deployed or published and some of the documentation that you will need and all the cool stuff like that. So let's go ahead with the first step and get started by creating our first subgraph. I'm just going to call it Electro for the sake of this workshop and select Ethereum Mainet, which is the network that we'll be using. Click on continue. And what this is going to do is it's going to create a subgraph on the Subgraph Studio.
00:14:18.660 - 00:15:19.076, Speaker A: So no code done at the moment, nothing at all. All you're doing is creating your subgraph on the Subgraph Studio. And what that's going to do is show you a status which is currently undeployed, and the Subgraph Slug, which is basically the name of the subgraph that we will be using in CLI commands and a deploy key. The deploy key you can see it basically as a key, an API key that you can use as a bearer token. If you're using that token to connect it to your front end to query that GraphQL API that we're going to build. Or you can also use this Deploy key while you're authenticating your subgraph. So as you can see here, there are a bunch of things related to documentation that is provided to you when you create your first subgraph.
00:15:19.076 - 00:16:11.508, Speaker A: And this is specific to the subgraph that you created. So it will already have all of your information related to your subgraph, like your Subgraph slug and your Deploy key, which is something that I find super helpful. So if someone is just getting started, it they don't need to really go into the documentation and look for commands and then paste or type in their subgraph or the deployed gear or anything. All they have to do is create a subgraph and copy this command and that should work out for them. So you don't have to memorize your commands if you're just getting started with your first one. So building a subgraph can be seen as categorized into three different parts. The first one is something that you only do once, which is installing your Graph CLI.
00:16:11.508 - 00:17:07.292, Speaker A: So if this is your first time building a subgraph with the graph, then you install the Graph CLI using either NPM or Yarn. I have already installed it on my local machine, and how you can do it easily on yours is if you have Node JS already installed, then you should be able to paste this NPM command in your terminal or in your developer environment and that should install the Graph CLI for you. So the Graph CLI is a CLI which is built out by the Graph team, the Graph Protocol. And it gives a bunch of utility commands, really cool commands that you can use to build a subgraph right from your developer environment. And a great example of that is the Graph init command, which is the second section of building a subgraph. So you initialize your subgraph and then you write your own subgraph. You design it based on your needs.
00:17:07.292 - 00:18:10.568, Speaker A: So the kind of subgraph that we are going to build is an NFT API, and that NFT API is going to be used to index and query data from the Zora NFT Marketplace. If I can take you to that. This is the Zora NFT Marketplace and it also has a really cool smart contract for people who want to use it as a building block to build out nice and interesting NFT projects. So if you go to the developer documentation, you should find out all about that. And I believe they also have a new version of their Zora developer tools and their smart contracts. So you can check out that documentation later. But that was just to give you a quick gist of what kind of subgraph we're going to build and you should be able to initialize that subgraph using the graph init command.
00:18:10.568 - 00:19:00.584, Speaker A: And I will go more into it later when I actually run that command. But the last section is authenticating and deploying your subgraph. So once you're done initializing and designing your subgraph, all you need to do is authenticate your subgraph using the graph auth command and entering your deploy key which is already given to you here on your subgraph dashboard. So you'll have to copy it, paste it in your terminal and you should be good to go. And then the last part would be to deploy your subgraph and then it will start syncing here. The status will turn into deployed from Undeployed. And a cool and nifty thing about the subgraph studio is once you've deployed it, you can also test out your subgraph by using the playground.
00:19:00.584 - 00:19:35.690, Speaker A: But that is something that we will be able to do once we deploy it. So let's go ahead and get started. I actually am going to follow along this guide so that I can give you a proper look into what we're building and how we're building and all the steps in the same order. The first thing is installing the CLI. That's something that I've already done. So let me go ahead and copy the graph init command. This one is slightly different from the command that you see here on your subgraph dashboard, but I'll quickly tell you why that is.
00:19:35.690 - 00:20:30.120, Speaker A: So if you press Enter here, it's going to initialize a subgraph for you. So I'm on desktop right now and once this command is executed, it is going to initialize a subgraph repository or a subgraph folder where all of our project and our code files will be situated. So let me explain what this graph initialize command does init command does. So the graph init command has a bunch of flags like the Contract Name, Index, Event Studio and from contract flags. So each flag has a purpose. The from contract flag that you see here lets you enter the smart contract address that you will be using. In our case, we're going to be using the Zora NFT smart contract.
00:20:30.120 - 00:21:34.236, Speaker A: So we get this from the developer documentation of Zora that Know showed you earlier. So that is basically the address of the smart contract that you will be using for the subgraph. And then there is the Index events flag. So this is the flag that gives you all of the code, boilerplate code that you will be needing to handle these events that are emitted from the subgraph. So again, super nifty flag right here that if you pass into your graph init command, it should be really helpful to you in scaffolding your subgraph. So you don't really have to write all of the boilerplate code by yourself. The Studio flag that you see here is basically just to tell the graph init command that we will be using the subgraph studio to be creating our subgraph.
00:21:34.236 - 00:22:11.260, Speaker A: And the last one is the contract name flag which lets you pass the name of the contract that you will be using. In our case, this is the token contract in the Zora NFT smart contract that we're using. So when you run this command it's going to ask you for a few details and all you can do is go ahead and accept all of the defaults here. I'm going to accept Ethereum as the protocol pass LF Grow as the subgraph slug because that's the name of our subgraph. It's going to be different for everyone. So you can go ahead and choose yours. Accept default here.
00:22:11.260 - 00:22:58.156, Speaker A: Again, use mainnet as the network but you can accept any of it. Accept default here as the contract address. So it's going to fetch abis from Etherscan. Accept the default here as Token. So as you can see here, what this is doing if everyone can see it more clearly, it's creating a subgraph scaffold. What this means is this graph init command is initializing your subgraph with some basic boilerplate code depending on the flags and information we passed early on. So it's installing all of the dependencies, it's initializing the subgraph, generating the abis and yeah, here it is.
00:22:58.156 - 00:24:05.340, Speaker A: We're good to go. So if you see on your desktop you should be able to find the subgraph repository initialized. So I'm going to go ahead and open my subgraph repository and it should be on desktop lfcrow open it open terminal. So let me give you a quick look into the files that we have here that have been scaffolded for us using the graph edit command and the ones that we will be using to edit and basically design our subgraph. So there are three main files that we're going to touch for the scope of this workshop and all you have to do is make some few edits there and you're good to go. The first one is the subgraph YAML file, the second one is the schema GraphQL file and the third one is in source directory called the mappings TS file. So in the subgraph YAML file this is basically the configuration file that's going to define your subgraph configuration.
00:24:05.340 - 00:24:40.728, Speaker A: So your spec version, the schema file that it's going to be using, all of the data sources that it's going to be using to query data from or index data from. So you will define your data source. This is ethereum. The contract name is Token, network name is Mainnet. And then you also define the actual source of the data which is the address of your smart contract, et cetera. And it also has a few fields like entities and event handlers. So these are the ones that we will be editing.
00:24:40.728 - 00:26:03.536, Speaker A: But before that, let me also quickly introduce you to some of the other files that we will be using. The second one is the schema GraphQL file and we already have a few entities defined for us here, but we're going to get rid of those and define all of our new entities. What basically we're doing in the Schema GraphQL file is defining the data that we want our subgraph to query or index from the smart contract. So for example, if I'm defining token and user data as entities in my Schema GraphQL file, then what this means is that my front end should be able to use my subgraph to define those two entities and their subsequent fields, that kind of data from the smart contract. So first of all, it's going to index the smart contract to get that data and then I should be able to use my subgraph to query that data and serve it to my client or serve it on my front end. And last but not the least, the Mapping TS file. Not to make things super complex here and to keep things simple, basically the Mapping TS file is a TypeScript file that you will be using to define your event handlers.
00:26:03.536 - 00:27:11.436, Speaker A: And what this does is every smart contract has a few events that it emits when you start indexing it. And these events can be any of the things that are happening while you index. It could be something like a transfer event or a Token Uri, updated event when the Token Uri has been updated, stuff like that. So what you want to do is you want to map the business logic that you wrote locally on your machine to the events that are happening on the smart contract so that when the events are emitted, you have some business logic that runs when your subgraph is querying the data, the on chain data, right? And all of that code, all of that business logic we're going to be writing in the Mapping TS file. Yeah. So I think we're good to go ahead and start designing our subgraph. So the first thing that we're going to do is update our subgraph YAML file by making a few changes.
00:27:11.436 - 00:28:05.580, Speaker A: The first one is writing a start block. So why we define a start block is that if you don't define a start block for a smart contract, it's going to index from the Genesis block. And if we know a start block for that smart contract, then it's going to start from that particular transaction or that particular start block. And for us, we've already put the start block for our purpose here for the Zora NFT smart contract in this guide. And we've done so using Etherscan. But you can do that yourself by searching for the last transaction by using the smart contract address on Etherscan. So I'm going to enter the start block here so that it doesn't start indexing from the Genesis block, but instead it will use this as the first block to index.
00:28:05.580 - 00:29:17.060, Speaker A: The second thing that we're going to update is the entities. As I said, the entities are basically the things that you want, the data that you want your subgraph to serve or to query. And I'm going to define Token and User as the two entities that we want our subgraph to have or to serve when it's indexing and querying the Smart Contract and we'll get more into it later on. But basically we'll define these entities here in this Schema GraphQL file. And lastly, we have been given some events and some handlers using the index event flag that we ran in the Graph init command, if you remember. But for the sake of simplicity for this workshop, we're only going to be using the last two to keep it simple, which is the Token Uri updated event and the Transfer event. The Token Uri updated event is an event that happens when a user updates the Uri of an NFT or a token.
00:29:17.060 - 00:30:41.388, Speaker A: And we want to write a handler for that event to handle that event using some business logic or some code here in this mapping TS file, which is why we define it as an event handler in the subgraph YAML file. And the second one is a transfer event that happens on the Smart Contract when first, either a new NFT is being minted, a new token is being minted, or an existing token, the ownership of an existing token is being transferred from one point to another, one user to another. So of course we'll also write an event handler function for this event as well. So, yeah, those are the two events that we will be dealing with for the sake of this workshop, quickly, let me save this and let me go ahead and define our entities. So I'm going to copy this code because I know that we're running a bit over time and quickly to explain what these two entities does. Is it's going to define a type token and a few fields that the token will have. So all of the NFT data or the Token data that we want our subgraph to query, we're defining it here as an entity.
00:30:41.388 - 00:31:30.610, Speaker A: And the second is a user entity, just like the Token entity. And what we're doing here is we also want the user data along with the Token data, right? So we are creating an entity here in the Schema GraphQL file, so I'm going to go ahead and save that as well. The last thing that we need to do here is write the mappings, but before that we are going to run the Graph Cogent command. And what this command does is let me go ahead and run it first so while it happens. Okay, cool. It ran successfully. So the Graph Code Gen command, basically what it does is it generates a bunch of really cool libraries and functions and boilerplate code for us.
00:31:30.610 - 00:32:48.564, Speaker A: And how that happens is that the Graph CLI gives us a TypeScript library that we can use to be able to write our mappings here and so once we run the Graph code gen command, we're going to go ahead and write the mappings here or the event handlers here, get rid of this and then save this. Cool. So just to quickly explain what kind of code we're dealing with and what we're doing here, the Graph code gen command, as I said, it generates the boilerplate code that we need to be able to write these functions. It gives us a TypeScript library so that we can use some helper functions here from generated file, the token file generated and the schema file in generated. So basically what the token file does is it has all the code that we need to be able to interact with the smart contract itself. So to read data from it. And the schema file has all the code that we need to write functions that can interact with our graph node.
00:32:48.564 - 00:34:00.440, Speaker A: So we can either read data from it or we can write data onto the graph node and store data there. So these two event handlers or handler functions that we've written here are basically for the transfer event and the Token Uri updated event. So once the Token Uri updated event, that event is being emitted, it happens. This function in our subgraph will be run as business logic and it will get the updated Token Uri and save it to the graph node and display it when we query it. And in the transfer event, it's going to first check this. If block checks whether a new NFT is being minted, if it is being minted, then it gets all of the details of the NFTs and it stores it on the graph node, gets the new owner of that token and then saves it to the graph node. And if no new NFT is being minted, but only the ownership is being transferred, then only this part will be executed.
00:34:00.440 - 00:35:02.172, Speaker A: And then similarly, in case of a new user, a new user will be created and saved onto the graph node. But if not, then it will only run this part of the function. So that is all that we needed to do to design our subgraph. The code that we've written so far should be able to help us deploy a subgraph that will index and query data from the Zora NFT smart contract. So let's go ahead and actually, just to show you how this works, I'm going to copy this command, which is the Graph auth command that we will run as the next step. The Graph auth command has a studio flag and then passing the deploy key will help us authenticate the subgraph. What this does is this local code that you wrote on your local machine will be connected using the Graph auth command to your subgraph studio, to the subgraph that you created on your studio.
00:35:02.172 - 00:35:17.272, Speaker A: So that command has been run successfully. And the final one is the Graph Deploy command which is the. Graph. Deploy studio. Elipro command. And once you do that, it's going to ask you for a version label. Just write something like 0.1
00:35:17.272 - 00:36:28.940, Speaker A: as the first version, it's going to deploy our subgraph and once the build is complete, it's going to deploy to the Graph node and voila, the subgraph is now deployed. If you check, it has been synced 100%, the status has been changed from undeployed to deployed and we have our subgraph. So to test it out super quick, we go to our playground and we actually should have a sample query here because we have our token data and our user data. Interesting. Let me refresh super quick, but you should be able to test out a few oh, there it is. So a sample query here to query the first five tokens and users. So the tokens, their ID, token, ID content, Uri, and similarly for users, all of the user data for the first five tokens and users will be queried once we run this query.
00:36:28.940 - 00:37:34.564, Speaker A: And we should get yeah, here is the data that we get. So if you use this, let me actually pause share because I'm not sure if this is going to be safe for work or not, but if we use yeah, so this is the NFT. I wish it was a beautiful art or something, but yeah, this is the NFT that is there on this link. But that's just a simple way of testing out your queries and just to test out your subgraph whether it's able to query data or not. So, quickly, before we wrap up, that was all about this subgraph workshop and how you can build subgraphs using the Graph to query on chain data from Smart contracts. But before we end, if you want to join the Web Three movement, you should definitely get involved with us. You can go to the Graph official website@thegraph.com
00:37:34.564 - 00:38:15.568, Speaker A: or you can visit our official Docs@thegraph.com slash docs if you want to follow us and our events and the cool stuff that we do and the product updates, you should definitely follow us on Twitter and say hi by tweeting at us at Graph Protocol. And our discord is the graph.com slash discord. If you want to seek more support from our team of engineers and our amazing community and also showcase what you are building. And of course, I'd love to help answer all of your questions if you have any, and meet with you all in the LF Grow Discord server. So make sure you come say hi on the Graph sponsored channel.
00:38:15.568 - 00:38:29.580, Speaker A: And that's all for it. Thank you everyone. Thanks, Bishwa, for the informative session. We can follow up with questions over Discord and see everyone there. Thanks, bye.
