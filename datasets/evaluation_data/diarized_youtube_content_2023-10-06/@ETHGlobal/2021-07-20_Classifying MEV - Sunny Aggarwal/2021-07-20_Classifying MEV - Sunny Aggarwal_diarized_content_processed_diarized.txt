00:00:00.410 - 00:00:34.870, Speaker A: Wait, now you guys can hear me? Okay. Hey guys, my name is Sonny. I am one of the co founders of a project called Osmosis. It's a dex built on the Cosmos ecosystem. And one of our main things that we've been focused on is how to decrease front running in new L ones. And yeah, so I've been thinking about mev for a long time. I think initially started thinking about it with the flashbots team last summer, and so part of what I've been doing is thinking about how to classify mev and how to approach.
00:00:34.870 - 00:01:17.106, Speaker A: I feel like this mev terminology is just very broad and covers a whole swath of different kinds of things. And so I wanted to kind of dive deep into figuring out how to classify it, and then with each sort of category of mev, what kind of solutions are possible, and then just come up with a model for how to think about solutions. So to start off, I just want to get one thing out of the way. Mev stands for minor extractable value, but really it's proposer extractable value. Thank you, Phil. For end of time we're always going to have to start every single presentation with this caveat. But yeah, so as to some switch towards proof of stake, we don't have miners anymore, but we have proposers.
00:01:17.106 - 00:02:36.238, Speaker A: But really it's the same sort of thing. It's whoever is the block proposer has some ability. How are we defining mev? I like to think of it in terms of proposer powers. So what unique powers does a block proposer have that they can single handedly execute? So obviously it depends a little bit on the protocol, right? Like different protocols, block producers have different powers, but we can talk a little bit just about some of the generalized ones that are pretty common throughout most protocols. Obviously some protocols will have more, some will have less, but some of the most common ones, one of them that comes up often is the mess with the timestamps in their block proposal. So in many protocols, so including Bitcoin and Ethereum, and many protocols in a distributed system, you often need some form of decentralized clock and we often use the block proposers as a sort of oracle into wall clock. And because they're being used as oracles, there's very little that they can do here and so a lot of flexibility that they have and very little ability to slash them.
00:02:36.238 - 00:03:22.842, Speaker A: Both bitcoin and Ethereum have models of constraining their ability. Bitcoin does the whole has to be greater than the median of the last twelve and whatnot. But with this you can pull off a lot of different sort of attacks. There's randomness manipulation. So if you remember back in Ethereum a couple of years ago when everyone tried to started using timestamps as sources of randomness and that was just like a terrible idea. But the fact that a miner could mess with the timestamp and win a lottery or something, that is a form of mev because it is a type of power that the block proposer had single handedly. There's also attacks like Timejacking, where if you mess with the timestamps, you can screw around with the consensus protocol a bit and how you can solve this.
00:03:22.842 - 00:05:01.986, Speaker A: One way of doing it, this is something that we do with Tendermint is we use well, there's the application layer solution, which is like you stop using time as a randomness source, but then there's also protocol layer solutions and this is what we do in Tendermint. It's called BFT time. So the idea is basically you have every validator, because Tendermint is this BFT system where every validator contributes votes, you can have every validator give like, hey, this is what I think the time is. And so even if you have the block proposer, who has some weird time that completely out of band with everyone else, as long as you take the weighted median of all the votes, you'll end up with a BFT time that is more accurate than just depending on the block proposal themselves. So what is something else block proposals can single handedly do? You can do consensus vote censorship, right? So I would consider selfish mining and all the things that come from it, feather, forking and all these kind of things as types of mev, because the ability to censor other validators votes and not build on top of them is still a power that a single block proposer can have. What else can block proposers do? They have the ability to read transactions from the mempool. So normally everyone has the ability to read transactions from the mempool, but thank you to Flashbot, only the block proposals now have the ability to read transactions from the mempool, because now there's a system where Flashbot provides a way for users to send transactions directly to the miners and so it's not visible in the public mempool.
00:05:01.986 - 00:06:06.020, Speaker A: So now this has become sort of a power of the proposer that is not available widely, which is good in a lot of ways, because now instead of anyone being able to front run you, only a select few can front run you. Then they have the ability to control inclusion of transactions in their block proposal, so they get to choose which transactions to include in their block and they get to choose the order of transactions in their block proposal. So I think what's interesting is you notice these latter three all contain this transactions as a core piece of what they're trying to do. And so I think we can put this into a category called transaction based manipulations. So within transaction based manipulations, I think there's further subcategories, there's censorship, manipulation and ordering manipulation. Censorship could include you're just trying to censor people from a block. Maybe they have to close a payment channel or something and you're trying to censor them.
00:06:06.020 - 00:06:48.606, Speaker A: If you could do that successfully, that would be a form of mev because there might be a way to profit off of that as well. But ordering manipulation, I think there's a couple of different ways we need to think about it. So we'll build it into this sort of quadrant. So we'll start with things that are based on other transaction data. So you have relative ordering. So this is what normal front running is, where you see someone else's transaction and you do something with it. So in traditional finance, front running would be you see someone's trying to place an order for a large amount of shares and you put your order right in front of them and then sell right after them and you can profit off of this.
00:06:48.606 - 00:07:40.894, Speaker A: This is called a sandwich attack in a blockchain, it's very similar where there's a bunch of transactions in the mempool and then the block proposer can say, hey, I can read Alice's transaction and I want to do something with it. So I'm going to go ahead and add my transaction to the mempool and then make sure my transaction comes in front of Alice's because I wanted to do something off of that. Yeah, and then there's also what I'd call absolute ordering where it's dark Forest pack style things. This is know, it was written by Dan and Giorgios a couple almost a year guess. Um, and you know, the way this forms is know, you can assume that you can simplify it and say, hey, here's a reward for the first person that can show a solution to a puzzle on chain. And that puzzle could know it's vague, it could be an exploit, that's possible. Or it could be many different things that it could be.
00:07:40.894 - 00:08:40.642, Speaker A: But what would happen is Alice figures out the solution, she goes ahead and submits the solution to the Mempool sikka, which is a block proposer can now go ahead and read the transaction, add their own solution and then make sure their solution comes. So the difference between why I categorize these as two different things about relative ordering versus absolute ordering. Relative ordering has to do with positioning relative to another transaction. So in that case, the bachelor hozo, their goal is to be right before Alice's transaction or right after Alice's transaction in absolute ordering. They don't really care about where in the block, they care about the position in the block. They don't care where they are relative to Alice's transaction. So why that's important is they could just go ahead and remove Alice's transaction altogether and if they don't include Alice's transaction but they still go ahead and put their transaction as the first one in the block, they still have successfully executed the dark forest attack.
00:08:40.642 - 00:09:16.698, Speaker A: Which is why I think it's worth separating these two. One requires inclusion of Alice's transaction while the other one does not. And so you'll notice that this is based off of reading other people's data and both of these attacks come from the ability to read transactions from the Mempool. And so the solution to this, or one solution to this, is you have encrypted transaction in the Mempool. So at a high level, what would happen is Alice would go ahead and submit a encrypted transaction. All the transactions in the Mempool would be encrypted. The block proposal will create a block.
00:09:16.698 - 00:10:04.510, Speaker A: All the validators will commit and finalize on a block. And then some sort of private magic will happen, and the transactions will get decrypted and executed. And at this point, it is too late to do anything about it because they've already been committed and they must be executed in that order. There's many ways of doing this encryption which is not sort of I actually gave a talk at a previous Mev roast about sort of comparing the trade offs of all of these. But I'd say the three main ones that I'm aware of right now are trusted hardware, time lock encryption and threshold encryption. This is sort of the end result of that talk I gave last time, which is, here's the trade off summaries. I'm a little bit biased because our project, we're focused on threshold encryption because we think it makes the least trade offs.
00:10:04.510 - 00:11:01.690, Speaker A: Assuming if you use any of these solutions, if you're able to remove the ability to read transactions from the Mempool, you've solved sort of both of these sort of attacks. But there is another type of ordering manipulation where it's not really based on anyone else's transaction data. And so what I mean by that is, what if the puzzle was so simple that sickai didn't need to copy anyone else, we just knew the solution ourselves. So it's like $5 to the first person that can answer two plus two. And there could be all these solutions in the Mempool that are all encrypted and the block proposer doesn't need to be able to read the solutions because we're not that dumb. We know the answer is four. And we can always guarantee, because of our ability to choose ordering in a block, we can always guarantee that we will be the first one in the block.
00:11:01.690 - 00:11:24.066, Speaker A: And so it doesn't have to always be like the two plus two equals four. It could be, for example, a liquidation. Right? That's something that I don't need to copy someone else's transactions to know how to do it. It's a very simple thing. Everyone can do it pretty easily. And so I don't have a good term for this right now. I'm calling it blind front running, but I don't really like the term.
00:11:24.066 - 00:12:45.786, Speaker A: So if people can come up with a better one, that would be great. A relative ordering for something not based on another transaction doesn't make any sense because how can you be relative to nothing but absolute but not based on something else? We'll call that blindfront running. How do you prevent this? You can try to block off these powers that enable it. So the fact that the block proposer can choose the order of transactions, well, one solution you could do is some sort of order randomization, right? You could say, okay, once you decrypt the transactions, there's a second step where you use some sort of decentralized randomness in order to mix up the transactions and just tornado them around. And so they get into some random ordering. Does that solve this blind front running though? It doesn't, because even if we go ahead and randomize the order of the transactions, you still have a situation where sika, because the blockchain doesn't only have the control of the ordering of transactions, they also control the inclusion of transactions. And so if they create a block where they are the only transaction in the block, you can randomize it as much as you want, it will still be the one that will win, right? And so you still have to solve this other one, which is the control inclusion of transactions in a block proposal.
00:12:45.786 - 00:13:52.120, Speaker A: And I think this is sort of what a lot of these fair ordering protocols like Equitas and things try to aim to do, where you want to make sure that it's not just one person involved with making a block choosing which transaction to go in a proposal. And I'm kind of dubbing all of these in this idea called joint proposals, where you say hey instead of just the proposal including the transactions, everyone has a little bit of a say of which transactions get included and they can have overlaps, which is fine. But once you have the votes from the previous block, the next proposer has all of by having the votes which needed to commit, they by definition have to have the information of at least a bunch of other transactions. Even if they choose to do a little bit of censorship, they'll still have other people's, other votes that they have to include. And their block proposals will only be valid if they include all of those transactions. And so this basically makes it so the proposer is not single handedly choosing inclusion. All validators have some input into the inclusion process.
00:13:52.120 - 00:14:43.094, Speaker A: Obviously this helps you solve this sort of blindfront running problem. So to zoom out from what is this sort of taxonomy that we have designed so far? So we have this large category of MEB manipulations. I want to avoid the word attacks because I feel that provides a certain connotation which might not always be correct. Because you want someone to be doing liquidations, that's a good thing, right? So I'll call them manipulations. We have things that are like oracle based, because oftentimes block proposals are used as oracles in many protocols. So timestamp manipulation would be categorized as a type of oracle based manipulation. There could be other ones, right? Because many protocols rely on block proposals for other sorts of things.
00:14:43.094 - 00:15:41.526, Speaker A: So as ample gas pricing right, or in EIP. 1559, the block proposal has some amount of say in the minimum fee and if there's the ways to exploit that for gain, that would also fall under oracle based manipulations. Next would be consensus based where block proposals are obviously a very important piece of the consensus protocol. And so this is where the vote censorship and the selfish mining kind of stuff would fall under that category. And then we have the transaction based manipulations in which we have the censorship category which we talked about, and then we have the ordering based. And there's probably other types of transaction based censorship that I'm not sure of right now, but I'm sure people can come up with more. Within ordering based, you have the type that is based on other transactions, so this requires the ability to read other people's transactions and then you have the type that's not based on other people's transactions.
00:15:41.526 - 00:16:23.510, Speaker A: And then finally within the based on other transactions, we split it up into absolute ordering versus relative ordering. So the relative ordering would be what we term front running. Absolute ordering would be what we term dark forest. And then when you're not trying to be based on someone else's thing, it's called blind front running. And within the blind front running, I'm sure there's a whole swath of things to talk about. Are we talking about liquidations, are we talking about there's all these different things that fall into blindfront running. So I think that's going to, if you zoom into there, there's an entire subtree of categorizations that can be done that will probably be interesting for someone else to dive into further.
00:16:23.510 - 00:17:43.070, Speaker A: My project, we're focused mostly on preventing the adding mempool privacy, so we're trying to really focus on solving everything that's under that base on other transactions tree. But I think a lot of the stuff that has to do with auctions and mev auctions and things like that are really trying to solve a lot of the problems that happen in that blind front running category. And then I just want to provide a little bit of categorization to some of the different solutions that people have come up with. For mev mitigations, I'm just going to put them into three main buckets, but there's probably more. One is cryptographic, the second is threshold based, which makes a little bit of sense because blockchains are crypto distributed systems. So obviously it makes sense that your solutions will usually be cryptographic or distributed in some based and then there's also like application specific ones. So from the examples that we went over in today's presentation, some examples of cryptographic mitigations would include things like randomness, right? For the order randomization, you have some sort of randomness, whether it's from a VDF or some sort of threshold key, which I guess if it's from a threshold, it's somewhere in between cryptographic and threshold based.
00:17:43.070 - 00:18:26.138, Speaker A: But yeah, that would be a cryptographic solution. Time lock encryption is a type of cryptographic solution to the mempool privacy. And then I'm sure if you want to get really into it, you can design very brand new types of state machines that are used snarks and MPC that mitigate mev in a way that's very different than the state machines that we're currently used to. Anyways. Then you have the threshold base, and within that we have examples like the BFT time where you're saying, hey, the proposer doesn't get to choose. All validators get to choose. You have threshold encryption where you say, hey, all the validators have to contribute to decrypting these transactions.
00:18:26.138 - 00:19:24.560, Speaker A: You have the joint proposals, right, which is like the way of allowing for inclusion. And this is really interesting because I think, like I said, it's kind of my own definition. I posited at the beginning where mev refers to the types of manipulations that a block proposer can single handedly do. And if you take that as the definition, the idea of these threshold based solutions are you say, try to take these powers that only the block producer has and try to decentralize them across your entire validator set. And so you're basically trying to move these powers to have the same security model as your consensus system as itself. So with Threshold encryption, only two thirds of your validators have to come together to decrypt a proposal to decrypt the transactions. And so you make that follow the same security model of your proof of stake chain itself.
00:19:24.560 - 00:20:04.298, Speaker A: And obviously what you need to do is now figure out how to add slashing conditions for each of these. For Threshold encryption, we've come up with a lot of different slashing conditions that seem to work well. The tenderman core team has come up with a lot of slashing conditions for BFT time to make it work pretty well. I'm sure a lot of the people who are working on fair ordering systems have come up with things for joint proposals. But I think that's one of my main issues with a lot of the fair ordering protocols is I don't understand how the slashing conditions work. And so I think that's something that's important to be figured out. And then finally we have this last category of application specific solutions.
00:20:04.298 - 00:21:22.258, Speaker A: So this is where if you know the application you have in mind, you can design very specific solutions, which is why so an example would be things like slippage tolerance, right? The fact that AMMS and many DEXes have slippage tolerance is sort of in and of itself an mev mitigation. If you didn't have the slippage tolerance, someone could front run you and just cause you to buy things at an incorrect price. So the idea is that is a type of application specific mitigation that's already very widely adopted. You have batch execution, right? Batch execution is a form of how do you do DEXes and you provide more fair pricing for everyone that should say liquidity stability pool. So the liquidity protocol, one of the cool things that they did in their thing was they said, hey, in MakerDAO, the liquidation auctions are way too weird and too subject to mev. And so what they did was they said, hey, we're going to build into our protocol a stability pool that provides fair access to liquidation revenues for everyone who helps deposit into it. And so that's also another example of an application specific mitigation.
00:21:22.258 - 00:22:04.206, Speaker A: And then just like, tips and tricks like, don't use bad randomness like timestamp, manipulate timestamp as a randomness source. Right. That would also be a type of application specific mitigation where you're telling the application developers, hey, avoid this thing. So, yeah, that's the end of my talk. I hope it was pretty fast and lightning ground, but I hope that helps give some clarification of like, okay, these are different ways to start thinking about mev. And then once you really start to understand mev in terms of the powers of proposers, then you can start to work on solutions to start striking away at the different powers that proposers single handedly have. Thank you.
00:22:04.206 - 00:22:08.260, Speaker A: All right, thanks. Sunny hasu you're up next.
