00:00:00.330 - 00:00:27.722, Speaker A: Cool. Perfect. All right, guys, thank you so much for coming. Really appreciate you guys taking the time. Really excited to be here today. This is kind of my hometown. Lived in San Francisco for five years.
00:00:27.722 - 00:00:51.186, Speaker A: Now I live in Santa Cruz. So right up the freeway. Really excited to talk to you guys today about building on Ethereum. And real briefly, my name is Kevin Jones. I actually work full time for NGINX as a technical evangelist. Been there for a while, about seven years now. I'm focused on advocacy for Scaffold ETH, which is this awesome toolkit that I'm going to be showing you guys today.
00:00:51.186 - 00:01:22.320, Speaker A: I'm a member of the build guild. And yeah, Scaffold ETH is just this awesome toolkit that's going to allow you to build on top of Ethereum quickly and easily. I also have a nonprofit that I founded, and I also help out with a Solidity class for growic. So if you're learning Solidity, it's a good kind of option to get started. And we actually utilize all of Scaffold ETH and a lot of the tooling that I'm going to talk about today. And then I'm also a photographer, filmmaker, so you'll see me running around Photos. After this, I'm shooting the event, so if you want a photo, come grab me.
00:01:22.320 - 00:01:57.334, Speaker A: This is all my contact info. By the way, on Twitter, I'm known as Crypto Mastery underscore. And again, if you want to just find me and we'll chat about stuff later today, Scaffoldies is again, it's this awesome toolkit. If you want to get started building on Ethereum, it's really the kind of de facto way to have everything up and running in a localized development environment. These are what you need to get started, really, to be able to check out the repository. Obviously, it's in Git open source. You need node JS you need to have at least version 16 or above.
00:01:57.334 - 00:02:38.850, Speaker A: I would recommend just getting the newest version, which is 18. And then you need to have Yarn. Package manager Scaffold ETH utilizes Yarn because Yarn will install all the dependencies for you. And it will also has all the scripts written for you so that you don't have to remember all of the Hard Hat commands and react commands and different things that you would do. You can just use simple Yarn commands that are already written for you, right? And so when you check out Scaffold ETH, you're going to get a copy of Hard Hat running locally on your local machine, which is like Ethereum virtual machine set up and ready to go. And then we also deploy react for you on Localhost 3000. And obviously, everything I'm going to be showing you today is in Solidity.
00:02:38.850 - 00:03:31.794, Speaker A: Okay, what does it look like from the developer standpoint? So obviously you need to clone the repo. You do the Yarn install that's going to install all of your dependencies for you. You do a Yarn chain that's going to spin up your EVM and on a local host. And then Yarn Start is going to spin up React for you and then you just do a yarn deploy and then it takes a copy of your smart contract and it pushes it to the blockchain that you're running. And you have this kind of like play Ether that's available in hard hat to start testing your assumptions on your application, right? If you're looking to kind of test your skills, I would recommend you guys check out Speedrun Ethereum. It's this awesome tool built by Austin Griffith and the Build Guild that allows you to kind of go through these challenges and kind of test your abilities. And when you're done with the fourth challenge, you actually get invited to the Build Guild.
00:03:31.794 - 00:03:55.018, Speaker A: And I'm going to talk about that in a little bit. If you need help along the way, I'm going to be here obviously. Also, Austin Griffith is around so if you find him, he is like a wealth of knowledge and amazing. He's the creator of Scaffold ETH. But this is a good resource. It has the Telegram channel, it has the GitHub, it has the README, it has pretty much everything you need in one contact card. And you can save this to your phone, so don't get lost.
00:03:55.018 - 00:04:43.134, Speaker A: The telegram channel is awesome. There's about 2000 developers in it that are building on Scaffold. So I'm more of a fan of actually doing and showing how this works in real time. So again, if you do a search on Google, the first thing for Scaffold ETH that's going to come up is going to be the GitHub repository and all of the steps that I kind of went through earlier and I'm going to go through right now are available here. And then it kind of guides you through of how you edit your smart contract, how you can edit your React application, and then there's also some resources of how you could learn Solidity. If you're just getting started learning Solidity and then it actually guides you to Speedrun Ethereum where you can join the Build Guild. So this is some really good documentation and the link to the Telegram chat is also down here in the bottom and there's a great Docs page as well.
00:04:43.134 - 00:05:28.154, Speaker A: So there's a lot of cool integrations that we've done with the graph, which is a really cool implementation of the graph that runs in docker. So if you're looking to get a graph bounty, this is a great idea because you can just run your subgraph locally. We also have tenderly support like you can actually authenticate your Smart contract through them or Etherscan. And so this is a really good resource as well. If you get lost and you just want to kind of read the documentation. If you're getting started developing on ethereum and you're learning solidity, solidity by example is a really good spot because you can actually go there and kind of copy and paste snippets from various examples into your smart contract and kind of see how those work with scaffoldeth. And again, this is what Speedrun Ethereum looks like.
00:05:28.154 - 00:06:17.226, Speaker A: So you can connect your wallet here and you can connect to MetaMask. And then basically you can go through these quests and you can submit your work as you do it and it guides you through. And like the first one that you do is you deploy a simple NFT, then you deploy a Staking app, then a token vendor, then a dice game, and you kind of have to hack the dice game. It teaches you a little bit about game theory on Ethereum and then you get invited to the Build Guild. So that's my shill for the Build Guild, which I highly recommend you guys do that path because there's a lot of cool stuff going in the Build Guild. So far the Build Guild has streamed over 200 Ether to developers that are building in the ecosystem and doing things for Scaffold ETH. And there's about 584 builders in the system and there's over 500 builds of Scaffold ETH that allow you to do different things.
00:06:17.226 - 00:06:56.994, Speaker A: So an example would be is if you go to the GitHub repo and you come up here to the top, you can actually do a search for whatever build you're looking for. And so let's say you wanted to do an NFT. There's like tons of NFT examples. There's like a simple NFT. There's a SVG workshop that you can do. There's a chain link NFT, a buyer Mint NFT, where you can mint based off the buyer's interest in an NFT. So there's really cool examples for different standards that are already written for you, right? And so that's a really good starting point for a hackathon because you don't have to do all that work and kind of do all the different things and create the plugins and grab open Zeppelin contracts.
00:06:56.994 - 00:07:21.034, Speaker A: They're already there and ready to go. You can just check out that repository and then do a yarn install and you're set up as a starting point. And that's a perfectly viable starting point for the hackathons as well. Okay, so let's actually get into demo here. So I'm using tmux, which is just a terminal multiplexer. If you're not familiar, it's really cool because it just allows you to have different windows open. But you can also just do this in different terminal windows.
00:07:21.034 - 00:07:57.194, Speaker A: You kind of always have like three windows open with Scaffold ETH. I've gone ahead and I've checked out the repository here and I've also gone ahead and I did the yarn install and installed all the dependencies. That takes about a minute for you to get up and running, but after you get up and running, you're good to go. And then you can spin up your chain. So we do a yarn chain and that's going to spin up a copy of Hard Hat localized Ethereum virtual machine and then I'm going to come over to the second window which is in the same directory and I'm going to do a yarn start. So Yarn start is actually going to spin up React and it's going to run it on Localhost 3000. That takes about a minute to start up.
00:07:57.194 - 00:08:28.918, Speaker A: So we'll just kind of let that sit. And then on the last window is where you'll do your deploy. So if you do a yarn deploy, it's going to take a copy of your smart contract. It's going to push it to Hard Hat deploy it for you. It's going to tell you the transaction hash, it's going to tell you or the transaction ID and it's going to tell you where it was deployed, what the contract address is. And you'll see that, you're starting to see these console logs that are available in Hard Hat. So the smart contract comes with it already has Hard Hat console enabled, which I'll show in a SEC.
00:08:28.918 - 00:09:13.586, Speaker A: And so you can print some stuff here and use that as kind of like a debugger for your contract. And then it also tells you how long it took. We can see React started and we see some read calls that were made to the contract that we have. And first let's take a look at the smart contract and I'm going to blow that up. In Atom, any text editor works if you're using Vs code, it will automatically, I think, spin up a copy of Hard Hat and it will automatically spin up React for you in the terminal window, which is kind of useful but that can be a little caveat. Just you need to know it does that because you might try to open up another terminal and do that, but that last terminal you'll probably use to do your deploys. Okay, so this is kind of what the structure of Scaffoldeth looks like.
00:09:13.586 - 00:09:39.462, Speaker A: There's this Packages folder and that's pretty much where you're primarily going to be working with Scaffold. There's specifically a hard hat folder. And then inside there, there's a contract folder, right. And then we have a copy of your contract which is just kind of like the hello world starting contract. We can see here that we're defining what version of Solidity to use. We have a license obviously. And then we are importing the Hard Hat console so that we have that console support over here in this terminal.
00:09:39.462 - 00:10:30.474, Speaker A: And then you have the ability to do more imports which we're going to get to in a second. And then this is real basic smart contract. It's emitting well, first it's setting up an event that keeps track of the address of the sender of the transaction and then it also keeps track of a variable called purpose. And then we have that kind of hello world building, unstoppable apps variable that we set. We have an empty constructor. We're going to get to that in a little bit as well and then we have just this function that allows us to update that purpose, right? And then we have just come these are like default so that the smart contract can accept ETH and that there's a fallback function in case that you call the contract with some ether and don't call a function, it will actually allow it to store that value, right, so that money doesn't get lost. But really this is kind of what we're going to be looking at is really the set purpose and then the actual function here.
00:10:30.474 - 00:11:29.258, Speaker A: So let's look at what it looks like when you first get into Scaffold ETH. You'll see that there's these tabs here in the app home is kind of where you'll build your project. This is where you'll actually start to write react code and you can think of it as like an application or adapt that's inside of Scaffoldeth, right? And so eventually when you launch to production or mainnet, you're going to probably abstract some of this stuff and that just kind of makes it easy because you can build your app here and then it just kind of guides you, like, shows you where the contracts are, shows you about variables, stuff like that. But what's the really cool stuff about Scaffoldeth is it has the Debug contracts tab. And what this does is it's basically taking your contracts abi and it's automatically building a UI for you to start testing your assumptions, right? So we can actually come here if we want to interact with our contract. We can come here and say Ethsf like this and we can try to send a transaction. It's going to tell me that I don't have any gas, right? I need to pay gas to be able to change the state of that variable.
00:11:29.258 - 00:12:08.330, Speaker A: So up here on the right hand corner, you'll see that there's this funds from the faucet button. You can just quickly grab some funds from hard hat and it's going to inject those into your burner wallet. That's another cool thing about Scaffold ETH is it comes with this burner wallet support. So if you open up another tab and go to Localhost 3000 again, you'll see that we still have access to that wallet, right? Because that's inside of this browser session. But if I come over here and say new incognito window and go to localhost 3000, then I'm going to get a new blocky dude right here, right, we have this kind of like purple guy and he doesn't have any funds. But then I also have this kind of green blocky dude. That is what I want to use is like my permanent kind of burner account.
00:12:08.330 - 00:12:43.602, Speaker A: We could connect MetaMask if we wanted to, right? But it's really easy just to use the burner wallet because you don't have to worry about nonce errors with MetaMask on a local environment. And then we can also do things here. Like we can export the private key if we wanted to. We can import a private key. We can also just send a QR code. So if we want to send some funds on, like a testnet, which we're going to get to in a SEC, we can change that to a testnet. Or we can also grab the address and then we can come here to this kind of, like, other wallet which has all of the Hard Hat funds, which has about 10,000 ETH.
00:12:43.602 - 00:13:19.570, Speaker A: And we can send some funds here. So let's grab, I don't know, like $1,000 in ether. And we just did that transaction and now we'll see that our burner wallet updated with some funds from Hard Hat. So it's really easy, just you're up and running and ready to start testing. So now if I actually have some funds in my wallet, I can change that state, right? I can pay the gas and do a transaction, but that's not like a super kind of interesting smart contract so we can kind of see what it would look to start developing some stuff. So let's go back to here and we already have this function and it's payable, which is cool because we can actually accept some funds there. We don't have a requirement there.
00:13:19.570 - 00:14:01.086, Speaker A: We'll get to that. But the first thing you might find out with Solidity or with Building DApps is you want to have some kind of access control. And so let's just set up kind of a hacky access control. Let's define an owner and let's grab this public key from this burner wallet that we have, right? We've got access to the burner wallet and let's save that and then we can redeploy. So if you do a yarn deploy again, it's going to see that we have changes to our smart contract. And by the way, if you want to force your deploy, you can do a yarn deploy reset and it will force a new instance of your smart contract and you can keep doing this over and over again and you'll keep getting new instances of your smart contract. So we can see here we'll get a new one.
00:14:01.086 - 00:14:31.914, Speaker A: And so that really allows you to just reset the smart contract and start testing your assumptions. And so now we'll see that we have a new variable that we'd have defined. And now what we can do is say, okay, well, let's say we want to only allow the owner to set this purpose. So we could say something like this require message sender, which is the global variable that says who is actually signing the transaction. We'll make sure that it's equal to owner. Or we say you are not the owner. Like this.
00:14:31.914 - 00:15:13.474, Speaker A: Boom. Right? I don't know what I'm doing there. All right, safe. And then we'll redeploy again, right? And so now if I come over here to this kind of like purple blocky guy, I've got some funds in my faucet or got some funds from the faucet and I want to come in here and say yo, what's up? Like this and hit send. It's going to tell me you are not the owner, right? So I've been able to kind of set up like access control, really basic access control, but that's actually not the proper way to do access control. So we can actually do it a little different. Let's get rid of the require statement and let's get rid of this address and let's instead do inheritance of an Open Zeppelin ownable contract.
00:15:13.474 - 00:15:52.514, Speaker A: So if you don't know Open Zeppelin, open Zeppelin is like the de facto standard for doing different implementations or standards and one of those is Ownable. So it has all that functionality in there for you. So we can say your contract is and inherit that ownable like this. And then what we can do is because it's set up, we're inheriting all of the functions that are inside of this smart contract. Then we can actually get access to the modifier which is a part of ownable that is only owner. So we can actually grab that modifier, save that there and then redeploy. And so now we've kind of done the same thing.
00:15:52.514 - 00:16:29.706, Speaker A: But we've utilized Open Zeppelin's ownable contract and we'll see here now that we have a new function called renounce ownership, which is if you want to pull out ownership from a contract and make it live forever with no owner and then we have the transfer ownership function as well. And we have that address. First of all, you'll notice that the owner does not match what I think you would want because you don't have access to this account. This is just some kind of random account. This is actually coming from hard hat. So Hard Hat utilizes the very first account as the deployer account. And we can take a look at what that looks like inside of the deploy script.
00:16:29.706 - 00:17:07.260, Speaker A: So right below here we have the deploy script and we can see here this is how we're actually deploying our contract and we're setting up the settings for that. And you can see right here we're defining the deployer which is getting from Hard Hat all the named accounts. It uses the first one and then we can say that it's actually using that deployer. And then we can also see that we could pass arguments as well. So let's say you wanted to name your contract like a cat's NFT or something like that. You might be able to pass an argument in here like this and you could pass that in the constructor. We're not going to do that right now, but it's good to know that is if you want to pass a variable to the constructor, you can do that there.
00:17:07.260 - 00:17:37.746, Speaker A: But what I want to show you here is that we get a copy of your contract here. So const your contract and then we deploy the contract and we have access to it now inside of JavaScript. And so you'll see here there's automatically a thing that's kind of already written for you here. I'm just going to copy and paste that. That allows us to call that transfer ownership function. So let's go grab that address here and then let's paste that in here. So we're going to do the normal deploy.
00:17:37.746 - 00:18:18.974, Speaker A: It's going to use that hard Hat account, but then it's going to call the transfer ownership function, right? So we're going to do a deploy reset. Boom. There we go. And so now we see that we have access to the smart contract. Again, we have access control, but again, it's kind of like not a really interesting thing because why would we want to have a function that only the owner could call? So I'd rather show you kind of how you can start using the smart contract as a bank, right? So let's do something like that. Let's open up the smart contract, let's close the deploy script and let's set a variable. So we'll take away the only owner modifier and instead we'll define a price variable.
00:18:18.974 - 00:18:44.870, Speaker A: So we'll do a UN public and we'll call it price and we'll set it to whatever Ether we want. So we'll do zero, zero, one Ether like this. And what this is going to do is it's just going to create a variable that has the value. And by the way, I have my ID set up. So it tells me the calculation of how much Ether is to how much way. And I'll get to that in a second. But you could write way here or you could write Ether.
00:18:44.870 - 00:19:20.226, Speaker A: We're going to do Ether because it's easier to read. And then what we can do is instead do a require statement here that says, all right, let's require that the message value of the smart contract is equal to the price. Otherwise we're going to say you are broke. Something like that and save that and then deploy that. And so now we already had this and it's important that if you're going to do that with a function, you need to make sure it's payable. But it was already payable. So we know now that we can accept some value on this purpose.
00:19:20.226 - 00:19:49.038, Speaker A: So if I come over here now and I want to change this to SF like this, and I try to hit send, it's going to tell me that I haven't sent any money. So now I can come here and I can do 0.1 Ether right here. Click the little green button. And what this green button does is it just calculates the amount of way that I need to send in the transaction. So it just multiplies it by ten to the 18th power. And so anytime you're deploying on or making transactions, you do it in way.
00:19:49.038 - 00:20:29.440, Speaker A: So obviously you wouldn't want your user to have to type out way. So you would do that kind of calculation inside of your application using ethers JS, there's support for that. And then now if we hit send, it's going to allow us to do that, right? And so now we see that the smart contract actually has some value, right? It's got a dollar 65, but at this point, it's kind of black holed. It's stuck in the contract because we have no way to really get the funds out, right? So the next feasible thing would be that you would actually write a withdraw function. So we can do that. We can say function withdraw like this and we can make it public. We can do like set a boolean called success.
00:20:29.440 - 00:21:08.970, Speaker A: Otherwise we will not. And then we can do so again, message sender is the person that's calling the transaction, right, calling that function. And we can do what's called a call and we can set the value as the balance of the smart contract. So it's address this balance, I believe. And then I think we need to do this boom, boom, boom. Okay, but we don't want anyone to be able to access all the funds, right? We own the smart contract. We want to make some kind of function and variable so we could actually here, we can use that only owner like this, right, and save that.
00:21:08.970 - 00:21:47.334, Speaker A: But you see, what we're doing was we're getting in this kind of mode where we're making changes to our smart contract. Inside of your solidity code, you're coming over here, you're deploying your smart contract, and then you're kind of like testing your assumptions, right? And so now we'll see we have this withdraw function. So if I come over here and I'm this kind of like purple blocky dude and I'm using this DAP, and I'm like, okay, yo, what's up? I'm going to send some value. We could just copy this from here to here and send. Cool. I've changed the purpose to Yo, what's up? And then I'm like, oh, I want to grab all those funds so I can try to say send. And it's going to tell me that you're not the owner, right? Because we have the access control set up.
00:21:47.334 - 00:22:39.926, Speaker A: But if I come over here, it's got funds in there, I can hit that withdraw button. And I was able to withdraw those funds because I own this public and private key pair and I was able to call that smart contract. Okay. I want to show briefly kind of like the react code a little bit as well because I think it's very useful real quickly. What I also want to show is all this stuff that we're doing here is like local host, right? At some point you probably want to deploy your application to maybe a testnet, especially if you're like you're in the hackathon and you want to do it to polygon, right? You might want to deploy it to polygon. So right now we're using the hard hat accounts, right? You wouldn't want to use that if you're deploying to a testnet because the public key or the private key could be compromised. So you would actually want to do what's called Yarn Run generate on here.
00:22:39.926 - 00:23:19.966, Speaker A: And what that's going to do? Is it's going to spin up or it's going to create a mnemonic and it's going to store that in the root of your application here. You can see I have a couple of them here. And so these are the root mnemonics. I'm not going to click on them because there's actually, like, the mnemonic, the password. And then you can run Yarn account like this, and you can basically get a QR code for your account. So it takes your public address, creates a QR account, and then it also goes out and checks the balances of different chains that you're on. Right? So what I always do is another cool tool that is actually built by the Build Guild and Austin Griffith is called a Punk Wallet.
00:23:19.966 - 00:23:42.570, Speaker A: So I just always have a Punk Wallet on my phone. And then it's got a little scan feature so I can say Allow. And what I can do is right now I could send just by scanning this, I got to redo it again. And I just have this preloaded with some testnet ether. I also have some Polygon Mumbai stuff on here as well. And so now I have access to that, and I could send some ether to it. Right.
00:23:42.570 - 00:24:00.500, Speaker A: And then I have a deployer account that is generated, and I'm able to deploy my account. And then if you want to deploy, like, I could deploy this right now to actually let me send some ETH for it first. So we'll go to Goreli and let's see here.
00:24:01.670 - 00:24:02.834, Speaker B: Let's do.
00:24:03.032 - 00:24:18.440, Speaker A: I don't know. 0.1 e hit send. All right, looks like it's going. So I was able to send some funds from my wallet. We should be able to see that Goerily has some balance. Oh, not yet.
00:24:18.440 - 00:24:44.252, Speaker A: Try it again. It's not working. It's pending, so it might take a second. But then we can do what's called a yarn deploy again. But we can choose the network. So we could do network Guerrero like this. And just with that one command, let's see if it actually succeeds.
00:24:44.252 - 00:25:13.492, Speaker A: It's going to try to send the transaction, and we are deploying our contract. It looks like it worked. I think it's thinking Goreli is a little slow today. Usually it's a lot faster. While that's doing that, I also want to show real quick in the UI, you might want to take your React app and update it to a testnet as well. So inside this app JSX file and then inside Views. So app JSX is that kind of main component for Scaffold ETH.
00:25:13.492 - 00:25:34.684, Speaker A: And if we scroll down, there's just this one section where we can change the default network to Guerrero like this, save it, and then we can. Refresh our app. And so now we should if it successfully deployed, which it's not, I'm not sure why it's not deploying. Live demos, sometimes they don't work. Yeah, I'm not sure why it's not working. It could be that I'm not oh, there it goes. Finally went.
00:25:34.684 - 00:25:59.352, Speaker A: So I deployed the smart contract to Guerreli, and now I have a copy of this smart contract, and I've refreshed my app. And my app is also on Guerreli. So now I could actually connect my MetaMask. Let's do it. Let's switch to Guerreli and switch the network. So now I have a bunch of guerli ETH, right? Let's do it here. Let's set the purpose to Scaffold is awesome, actually.
00:25:59.352 - 00:26:32.960, Speaker A: Let's do scaffold ETH like that. And let's make sure we send some value. Boom, send. And then the next step I'm running out of time, but the next step would be that you would maybe want to ship your app to some other hosting service because right now we're running locally, and you can do that directly through here as well. You can do what's called Yarn Build, which is going to take a copy of your React app, and it's going to build it and make it optimized. And then you can do a yarn. Sorry.
00:26:32.960 - 00:26:57.290, Speaker A: CD projects ethereum scaffold ETH. Then you can do a yarn toy blank. Right now you can do a Yarn Surge, which will put it on a Surge endpoint. If you're not familiar with Surge, it's kind of like a simple static hosting service. Or you could also do it to IPFS with Yarn IPFS. So you have kind of some options of how you want to deploy your app, but this takes a while to do. So unfortunately it's not going to finish in time.
00:26:57.290 - 00:27:28.060, Speaker A: But yeah, that's Scaffold ETH in a nutshell. I do have a couple of minutes. I have 1 minute for questions, so I would love to see if you guys have any questions about it. It's got to be one question. Come on. Yeah, under the docs there's a Tenderly kind of like walkthrough. There's like a video, and it tells you how to verify on Tenderly.
00:27:28.060 - 00:28:08.170, Speaker A: Basically, you have to create this kind of script inside of your deployment script. And I think you have to do pass like an API key, I believe, as well, so that the instructions are here. But the only really thing is that you're authenticating your smart contract through Tenderly at least. I think that's the only current integration you can also do with Ether Scan as well. So there's Ether Scan is a little bit easier because you can just do Yarn Verify and then pass the network here that you're using. And then I think you have to update well, you should update your hard hat config also with your API key for Ether Scan as well. Yeah, that's a good question.
00:28:08.170 - 00:28:18.430, Speaker A: Any other questions? No? Awesome. Thank you guys so much for coming. And I'll be around. So if you need anything, let me know.
00:29:53.560 - 00:30:20.612, Speaker C: Good. Awesome. GM. GM, everyone. Yeah. So, I'm David, I'm a product manager from Ave Companies, where I work on our social products, including Lens Protocol, and want to talk to you all today to go a bit under the hood first into why we felt it was needed to build Lens. And the problem lens is kind of trying to solve why blockchain is really the only solution.
00:30:20.612 - 00:30:54.752, Speaker C: We have a little bit about the Lens architecture and then closing out with the Lens API, which is one of the best ways to build with Lens and to build this new class of Web Three apps we call the experience layer. Fancy marketing term. So the problem statement, web Two social media is fundamentally broken. Let's think about the login flow for the average app. When you sign into Facebook, you're authenticating to Facebook. They're then kind of looking up your data in the database, taking it and rendering an experience. That data is centralized.
00:30:54.752 - 00:31:45.108, Speaker C: It is not portable. Facebook has no incentive to make it portable. It is their monetary stream. All they really want to do is make sure they're getting more data they can then use to monetize further. And Snapchat has the same experience and LinkedIn has the same experience and YouTube has the same experience and TikTok has the same experience as does Rip Twitter. And the difference of what we're going for with Web Three is we want to kind of make it where you own your content, you bring it to an application so that it is fully portable and that really makes networks beholden to the users, as opposed to users being beholden to the network. In Web Three, in a Lens application, which is fundamentally different, you are not just authenticating with the application, but you are bringing the Identifier so that it can find your data, so you can bring it your data.
00:31:45.108 - 00:32:11.968, Speaker C: I sign into an application by bringing it data and then, and only then, can it render experience. The data is in this kind of more public area, which means it is forkable. I can switch experiences at will. Experience can specialize to different types of users. We've already started to see this in the Lens ecosystem. There are apps that specialize for creators, people who create content, and there are apps that are specialized for people who are trying to curate content. And there are apps that are specialized people trying to consume content.
00:32:11.968 - 00:32:49.836, Speaker C: And because it is a shared database that is user owned, it is not the same company, it is not the same development team building all of those which causes for better experiences for everyone. So in some web Three, social is about bringing power back to the user. So we are going to lower the barrier for developers by making it really easy to build social apps and tools on a composable decentralized social graph. And the key thing as a developer. You get to focus on the user experience and not customer acquisition. The name Lens is named after this plant. Like the Lens Caleris, it fertilizes the soil, allowing other plants to grow alongside it.
00:32:49.836 - 00:33:23.584, Speaker C: Lens apps want all of the apps in the ecosystem to do well because data generated on one app is available to a different application. As long as you're in the Lens ecosystem, everybody wins. It is a collaborative game, not a zero sum game for creators. You get to own the links between yourself and your community and you are able to move anywhere with ease. Pick the creator tool that you want and distribute to your users at the platform they are using, not just the one where your creator tool lives. So how are we actually building this? Well, we are on a blockchain. We are live on polygon.
00:33:23.584 - 00:33:53.020, Speaker C: Today we have a profile NFT. The profile NFT is minted and it has a publications array that you get to post to. We'll come back to Posts in a quick minute. That profile NFT has this thing called a follow logic that emits follow NFTs. So you get a follow NFT by following me david EV Lens and it gets dynamically updated with Posts. You can always see the latest thing that I have published. The follow NFT includes built in governance and delegation so I can set up mini votes for my community.
00:33:53.020 - 00:34:18.292, Speaker C: Maybe if you want to see me talk more about Lens, maybe you want to hear me give more hot takes about blockchain. I get to pull my followers for what they want to do. Token IDs are based on the order of following. Bradley in the audience was my first follower. Christina, my audience was my 10th follower and that has built in value if I pop off and they can be able to trade that in the future. Posts, comments and mirrors. They are part of my profile NFT.
00:34:18.292 - 00:34:59.910, Speaker C: They are part of who I am. As I move around with my profile, so does my content come with me. And they have this awesome thing called a collect function which allows them to be instantly monetized. I can set the rules for how collect NFTs are minted from a publication and that gives me a way to determine my own as a creator, determine my own monetization logic. One of the key things and design principles of Lens is we are as agnostic as possible to give as much power to developers. Nowhere in any of this did I specify where you need to store your data. We let you pick if you want IPFS, for example, shout out to the sponsor AR Weave or you can even go centralized links with S Three.
00:34:59.910 - 00:35:35.788, Speaker C: We also don't enforce any particular encryption scheme. You as the developer or the user can pick privacy you want or you can leave things fully public. The option is up to you. We are just providing a minimal spec to help organize the blockchain data into a social graph. And so far in our private beta, the community has really loved the Lensverse. We have over 90,000 profiles, they have a closer connectiveness than most of the major social networks. And we are seeing this concept of collect really take off as creators like to experiment with brand new collection of user generated content and micro purchases.
00:35:35.788 - 00:36:17.720, Speaker C: And there are tons of different people you can follow, from major content creators like GMoney to DAOs, like index cooperative to blockchains themselves like Polygon. Now, over to the Lens API, which is the fastest way to build your own social application or use Lens data at all. Now, to make it clear, Lens is entirely on chain, anyone can access the data as they see fit your node directly through a service like Alchemy or querying something like the graph. However, we all for our own API. With the Lens API, you don't need to worry about indexing, querying, reorgs or fetching data. That's all done for you. You don't have to worry about prefilling contract data or validating it, or using weird with SIG methods.
00:36:17.720 - 00:36:40.148, Speaker C: Our real goal is to offer something that is easy to approach for development. It looks and feels like a web. Two GraphQL API. It is simple to interact with the protocol and there is really not a huge learning curve. You can just focus on the stuff you want to build. In fact, some of the easiest things you can do to build is use a follow on Lens button, very similar to the kind of ones we have for existing social today. Or a sign in with Lens button.
00:36:40.148 - 00:37:17.760, Speaker C: This wraps sign in with Ethereum, so you're still getting validation that the user owns the address. But additionally, the Lens API will return all of the data it has on that user. Their Lens data, their ENS, their Poops, their proof of humanity or WorldCoin status. And more and plenty of people are using this today. Here's, ETH Global on their homepage has a link to their Lens profile as well as a way to follow them through the Lens API. And it's a great way to see content such as this talk and many of the others for Ethsf. So what's next and where are we going? On the middleware layer, we are going to be adding more and more data providers to allow you, as devs to build holistic experiences.
00:37:17.760 - 00:37:44.788, Speaker C: We already said ENS proof of humanity and WorldCoin. We have many more coming out. If there's a protocol you want, please stop by the table. We really want to build it to help give you guys a powerful development tool for experiences. We have this really awesome concept called Dispatcher and Relay, which allow applications to pay for gas on behalf of the users. It allows seamless onboarding for the masses. And already we have done four and a half million transactions since we released this feature in June.
00:37:44.788 - 00:38:47.976, Speaker C: Making the Lens API one of the largest EVM gasless relays. Additionally, we have plenty of teams that are working to extend the Lens contracts to support multi chain as well as off chain data to be read on polygon. Using really powerful protocols such as layer zero and Chainlink CCIP and Dbridge, you'll be able to read data from multiple chains onto polygon. So you'll have the ability to say you can only comment on my post if you hold a board ape, you can only follow me if you hold more than 15 SDK ave and the real desire is we are trying to power this thing that we call the Experience layer. This next generation of applications, the Lens API is stitching together data from Lens Live peer proof of Mandy ENS, WorldCoin Poop, Xmtp, Push and Aave itself in order to provide a data layer for Udevs to pick and choose what applications, regardless of chain, to put into the experience that you craft. Because at the end of the day, we have experiences. There are tons of different applications here, but they all want to have different UIs.
00:38:47.976 - 00:39:33.020, Speaker C: For Ave you can go to app ave.com zapper rainbow InstaDApp coinbase for Lens there are a ton live today lens friends lensda lens tube favor orb Lenster There are plenty of different UIs that are all using the same contracts under the hood. And for us, this is kind of the evolution of experiences that we think is going to be coming to Web Three. Things started out with singular app, single source. You can see that on the uniswap application, right? The only thing I can do is interact with the uniswap system of contracts and it's only on a singular chain. There's more current experiences like the Ave UI, which add in a few apps together. For example, the repay with collateral function stitches in paraswap to allow for a slightly better experience, but it's still fundamentally single chain.
00:39:33.020 - 00:40:05.684, Speaker C: Here is a screenshot from one of a Lens application's Lenster. It is stitching together data from multiple applications across multiple chains. There's ENS on mainnet, Lens on polygon, WorldCoin on Polygon, Poop on Gnosis chain and many more just in this one frame. That's not even the entire screen. And we really think that this is the future of Web Three applications. Additionally, we are upgrading our API to continuously provide powerful features to allow you to create Web Two native feeling experiences. The first thing is we believe that Gas is an application cost.
00:40:05.684 - 00:40:43.776, Speaker C: AWS bills are part of a business cost for an application and Gas is the Web Three equivalent. We believe that you should be building it into your business model and therefore our contracts offer metadata as well as permit as well as this concept called dispatcher. And many of the Lens apps have opted into this UX again 4.4 and a half million Gasless transactions through our API, representing an overwhelming majority of Lens usage. And it's not costing a lot. We also have this thing called the Optimistic UI or the Optimistic API, something we just released that causes users and apps not to know there is a blockchain running in the background. Apps are given an optimistic assumption that certain write calls succeed.
00:40:43.776 - 00:41:28.192, Speaker C: If I follow you on Lens, on a Lens app using the Lens Optimistic API, then any app reading from the Optimistic API will assume the follow succeeds and upgrade regardless of hard refreshing the session or otherwise. This allows zero wait time to reflect state changes to users and gives an incredible feeling of responsiveness. And we are going to be expanding this to many more calls in the Lens system and hope that other developers use this on their contracts or their SDKs. Lastly, unified queries APIs that return data from multiple applications across multiple chains. We've already integrated this into our profile function. With a singular call you can get Lens Poop, ENS, WorldCoin Poh, sybil.org Data and more in a singular call.
00:41:28.192 - 00:42:05.704, Speaker C: Those contracts are on multiple different chains, including off chain data. And that is something that we want to expand on more for developers. You guys deserve contextual data regardless of where the source chain is and we hope to continue building on that path. So that is what I have to talk about today. Happy to have plenty of time for questions. Awesome. Any questions? Where can I go to get a Lens profile? If you want to get a Lens profile, you can stop by the booth.
00:42:05.704 - 00:42:45.640, Speaker C: We are still in closed beta, but we have tons of spots left and want to make sure that anyone building today can get one. So the first question is where the contracts deployed? Are we only on Polygon or will we go multi chain? So the Lens contracts are open source, they're EVM, they can go anywhere. We have a deployment that we run on Polygon. We also have two testnets, both on Polygon Mumbai, one with zero permissions on it and one that mirrors the main net. We are happy on polygon. It is a chain that is scalable enough to handle the load of Lens. It is a massive number of transactions and Polygon has shown to be able to hold our scalability.
00:42:45.640 - 00:43:58.132, Speaker C: We look forward to continue building there. Yeah, so we have a creator program where you can email creators at Lens XYZ for creator grants and we have developer grants at ecosystem at Lens XYZ we want to help make sure that you help build awesome tools as part of this ecosystem. So the question was about closed beta. Closed beta for now just means the actual minting of profiles is limited for a variety of reasons. But basically that means that once you have a Lens profile you can use any of the Lens applications in the ecosystem. On mainnet, however no, until the mint block is removed, you're presumably in closed beta as well. The devs are working their best to do things to relieve it.
00:43:58.132 - 00:44:20.304, Speaker C: We are hoping to end it sometime early in the next year. Yeah. So the Lens contracts themselves are and I'll go to kind of the side I think that shows it out.
00:44:20.342 - 00:44:20.604, Speaker D: Yeah.
00:44:20.662 - 00:44:46.620, Speaker C: So the Lens contracts themselves are built on polygon and there are ways in which you can extend them. We call them modules, collect module, follow module, and reference module. These are ways for developers to hook in their own contracts into the Lens system. Lens does not itself specify any bridges for receiving or sending cross chain data. You can plug in any bridge you want. This follows the same design pattern we used in Jave V three. So we know that there are active teams building integrations with layer zero.
00:44:46.620 - 00:45:34.710, Speaker C: There are teams building integrations with chain link CCIP, another one of these messaging bridge protocols, as well as Dbridge and Stargate. So Lens is agnostic to the Bridging solution used. You, as the application developer, can pick which one you trust. So the roadmap, I think for us, the roadmap is more we're trying to be this kind of we want to be the social account, the account structure that is used. We're just here to kind of provide a minimal structure to allow for anyone to build social graph powered applications. This could be as simple as including a little bit more contextual data when you sign in. So oh, here's a cover photo, a profile image.
00:45:34.710 - 00:46:14.040, Speaker C: I know what people follow, so I can maybe give better recommendations. I can see my positions or my friends positions or people's who I follow's positions in a DeFi app for an NFT project. It might be able to I can recommend what you might want to mint or what you might want to buy in a marketplace based on what you follow. We're here to kind of provide information. And again, because Lens as a protocol is intentionally incomplete, it requires other things to be plugged into it. And so we're here for maximum integration, as we mentioned. I think just this week we announced integration with Xmtp to allow end to end encrypted direct messages between Lens profiles, again showing kind of the extensibility of the project.
00:46:14.040 - 00:46:57.374, Speaker C: Awesome. I think I'm at time Xmtv will be getting built into the API. So the API kind of sits on top of it's not any contract, right? It just is a series of indexers and plugs into various different protocols. So at some point, Xmtp will be built into the API to allow applications to easily pull conversations and other relevant information based on an authenticated user. Yeah. I believe folks from developer Dao have built a subgraph that you can query. We also do recommend that you use the API is open.
00:46:57.374 - 00:47:33.864, Speaker C: There is no key. There is no nothing to query. It no account needed. It is able to kind of stay up to date much faster than a traditional subgraph to allow you to get real time information from the social graph itself. Yeah. So the question is about other Web Three social options. I would say that Lens is one of the few true Web Three social protocols that exist.
00:47:33.864 - 00:48:20.360, Speaker C: We are directly on Chain, we are directly interoperable with other protocols. Some people have taken the approach of building your own blockchain or keeping your data off Chain entirely. We believe that by being on Chain, by being truly interoperable, by staying committed to Web Three principles, that is kind of the ethos behind Lens and I don't think we have seen others build in that kind of mindset, being fully decentralized on chain. Yeah. So we have an integration with ENS, where through the Lens XYZ ENS name, you can query any data about or various data about a Lens profile. So I'm Davidv Lens. If I want, I can query using ENS's off chain resolver.
00:48:20.360 - 00:49:13.240, Speaker C: Davidv lens XYZ. And I will pull up my profile picture on Lens, my cover photo, my avatar, my name, location, other various data that I have put into my Lens profile can be queried via ENS. If you want an alternative to the API, or if you're already using ENS resolvers in your project. And then there's also in the Lens API itself, there's an integration that will look up the profile holding a Lens profile and let you know what its ENS is. If reverse resolution is set, or what other names resolve to it to set reverse resolution. I would talk to the ENS team. You can find that out in their documentation.
00:49:13.240 - 00:49:17.660, Speaker C: There's a simple contract call you can do on Chain. There's a registry.
00:49:26.190 - 00:49:26.614, Speaker E: Yes.
00:49:26.672 - 00:49:45.250, Speaker C: The bounties we have there's a bounty for integrating the Lens API. Either sign with Lens, follow with Lens, the really simple integration. Let me see if I can find that example. And then there are larger prizes for those that build the best kind of social application, the best use case with Lens.
00:49:45.750 - 00:49:46.114, Speaker F: Yes.
00:49:46.152 - 00:50:13.840, Speaker C: The easiest way to be eligible for prize is just very simply integrate either sign up with Lens, which is a wrapper of signing with Ethereum, or follow on Lens button. We even have visual examples and simple HTML links. I have to go back and look. I don't know the top of my head. Awesome. Well, we'll be over at the booth, over by the hedges, by the main stage. Happy hacking, everyone.
00:57:48.050 - 00:57:48.800, Speaker D: You.
00:57:51.700 - 00:58:20.244, Speaker G: Hello, everyone. Thanks for coming. All right, so I'm going to talk about basic and advanced seaport techniques. If you guys aren't aware, seaport is a base protocol that OpenSea has developed and it's our marketplace that can transfer and handle NFTs and ERC twenty S. So let's get started. So the way CPORT works is you have an order. And an order has two main components to it an offer and a consideration.
00:58:20.244 - 00:59:07.844, Speaker G: An offer is what you are offering and a consideration is what you expect to receive back for that order. There are two other components. One is called a zone and one is called a conduit. So a zone can be an external contract that basically gives an approval or disproval if an order is valid or not. And that can be used several ways. We'll go in toward the end of the presentation and then a conduit is who you're giving your token approvals to, to help transfer and manage your tokens and the approvals. And the reason that the conduit is nice to have separate than the Seaport contract itself is that Seaport can be upgraded or changed or moved to another address and then the conduit can still be used for the approvals.
00:59:07.844 - 00:59:51.472, Speaker G: So you don't have to reapprove the conduit. If the Seaport contract has changed, the Seaport contract would just use the same conduit. Two other components of a Seaport order first is the salt, which is kind of like a randomness factor. But lately what we've been doing is we've been including our four byte domain hash. So openc IO, if you kezak hash it and take the first four bytes, we've been prepending that to the salt and that helps kind of with order attribution and finding out who is fulfilling or creating the order. And then the counter is an account level thing. Every order you create will be set to your current counter.
00:59:51.472 - 01:00:23.920, Speaker G: And if you increment your counter, it's a way to kind of bulk cancel all the orders that are below that counter. So here's a diagram of how CPORT kind of works under the hood. It's a little bit complicated, but it goes over at the very top. The things we've kind of gone over already, which is the offer and consideration and the zone. And the conduit key, which is a way to reference the conduit, is standardized. But the conduit key is like which version of a conduit you're using. Not version, but which kind of operator that has created the conduit.
01:00:23.920 - 01:00:52.820, Speaker G: So all those go into the order. And then when you have an order, you can do several things with it. You can fulfill the order, you can do a match order, which we'll go into, which is kind of like an advanced kind of matching. You can validate the order on chain. And what that does is you can pay some gas up front to validate it on chain. And then if someone fulfills that order later, the gas cost to fulfill it is actually cheaper. And then you could cancel an order which renders it invalid.
01:00:52.820 - 01:01:54.764, Speaker G: When you fulfill or match an order, it goes into this left part of the diagram, which is just kind of a series of contracts that help combine and set up the order for the fulfillment. And then as kind of the last part, the order is verified and the time, the signature, the order status are all verified before the tokens can be transferred. So if you've ever gone to the CPORT repository, we have a set of optimized contracts and a set of reference contracts. So if you're kind of trying to learn what's going on, it's nice to go to the reference contracts and see to read the code and it's quite digestible. The optimized contracts use a lot more kind of inline assembly and kind of little tricks to help reduce the kind of gas usage of the contracts. So, creating Orders so if you've ever created an order on OpenSea, you sign something like this. And this is kind of what we went over.
01:01:54.764 - 01:02:20.128, Speaker G: It's all the components of what an order looks like. It starts with the message and the offerer. The offer which in this case it's an NFT. And the ID of it is ID 31. And then the consideration is the first consideration item is the one that goes to the owner of the NFT. So that's what they're getting paid. And then the second one is the openc marketplace fee.
01:02:20.128 - 01:03:03.440, Speaker G: If there was a crater fee here, the third component of the consideration item would be the crater fee payment. And then you have the start time, end time zone, zone, hash, salt and conduit key and the counter which we kind of went over. So validating order on chain is pretty cool because as I mentioned, it makes it cheaper to fulfill later. It also emits an event called order validated on chain. So this is something you can do with contracts. If you have a contract that automatically wants to list the NFT on Seaport, you can do this. And then other people can understand that the order has been kind of like made available to be fulfilled.
01:03:03.440 - 01:03:37.096, Speaker G: And then there's EIP one two seven. So that was EIP seven one two, which is kind of manually signing an order, which you've probably seen like with MetaMask, it pops up and you sign it yourself. That's with an EOA. If you have a contract that's signing an order, there's this EIP 1271 which is a standard interface that provides is valid signature. And that's how a contract can create an order on seaport. And yes, that allows smart and multi SIG wallets to create. If you did order validated that's on chain, you pay a little bit of gas.
01:03:37.096 - 01:04:10.380, Speaker G: But if you sent it to the OpenSea API, that would be off chain and it wouldn't cost any gas. And then canceling an order. If you validated on chain, you can cancel it. Even if you created the order off chain, in most cases you still want to cancel it on chain because if someone found that order or got it later, they could kind of execute it as they want. And then the other option is incrementing the counter, which is account level kind of nonce. All right. Fulfilling orders.
01:04:10.380 - 01:04:42.288, Speaker G: So the very kind of basic way to fulfill an order is fulfill order. A fulfiller is the caller and it takes all the offer items and matches them with consideration items. So this is. Very standard way to fulfill an order. The other type of fulfillment is a fulfilled basic order. And what this does is it puts certain constraints on what a basic order is. In this case it's orders that have like a single offer item and have consideration items and they're all in ERC, 20 or native.
01:04:42.288 - 01:06:02.480, Speaker G: But what this does is allow us to use the call data in the method signature and access that more so that it costs less gas to use. For batch fulfillment there's fulfill available orders and you supply an amount of orders and you supply the max amount you want to fill. This is helpful if, for example, you're putting in ten floor orders and you say I'd like up to five of these, then if certain ones are taken during the processing, then you can still kind of allow the transaction to go through. And with the fulfill available orders you supply a fulfillment array which optimizes for fewer transfers, which also helps on the gas usage. One kind of advanced method that's available on the contract is match orders and it's not used very often, but what you can do in this case is mev searcher who finds orders that have that they can match together. If there's remaining amount after, what you can do is create a consideration item to pay yourself the leftover kind of amounts at the end of the end of the order. If you didn't do that, the amount would just stay with the person who offered it and they would only be charged as the amount that the order was matched.
01:06:02.480 - 01:07:31.416, Speaker G: Okay, and then we'll talk a little bit about zones. Zones are really cool because it kind of allows for pre or post order kind of validation or ratification. So some ideas of zones is like a dynamic NFT metadata zone and what that could be is as an experimental concept, if you had an NFT that had metadata that if it changes, it changes the value of the NFT itself, then you might want to cancel the orders that are out for the NFT. So if you had a zone that had kind of a registry of knowing when an NFT's metadata changed then when Seaport calls out to the zone to ask if the order is valid, then it could deny kind of the parameters of the order based on what the contract the zone itself kind of knows. A compromised NFT registry is another interesting way of creating a zone because a zone because it has control to say whether an order is valid or not. If you had a zone that had a registry or a merkel route of understanding which NFTs may or may not be compromised, then if it was marked as compromised, then it could deny the order and not allow people to transact for it. On the marketplace for front running resistance, this is another cool idea for a zone.
01:07:31.416 - 01:08:22.276, Speaker G: So if you take a zone and you do kind of a commit reveal where you tell the zone, okay, I'm interested in this seaport order. I want to kind of reserve it. Then the zone would make sure that only that caller would then maybe in some time frame, ten or 15 minutes only they could complete the order and then after that period it could be open again kind of to the public. But that'd be a cool way to kind of create a more kind of a secure way to use the public mempool, but not allow people to get their NFTs kind of snatched in the process. And then another cool zone would be like Oracle based price validation. So if you could find an Oracle that has NFT floor prices or the price of NFT based on its Rarity, then the zone could enforce that. If the value is too low, it could deny the order being fulfilled.
01:08:22.276 - 01:09:13.790, Speaker G: And sometimes that helps. In the case where NFT is stolen and it's listed for much lower than floor just to kind of get rid of it, this could help protect in those kinds of situations. So a little bit of alpha. We're working on CPORT V Two, and one of the concepts in there that we're working on now is an order type that it's a contract. So this allows us to do kind of more advanced contracts that can handle orders. Right now as we kind of went over, an order either has to be signed by an EOA or a contract. And in CPORT V Two, we're exploring ideas how we can make contracts more powerful to kind of create orders on the fly based on different parameters and custom logic that a contract itself could hold.
01:09:13.790 - 01:09:52.616, Speaker G: So yeah, here's some helpful links. The CPORT repository, the discussions page is a great place where a lot of people have asked questions. And while you guys are here, if you can't find me, you can post questions in there and we'll try to get to them and help you kind of answer any problems or questions you may have. CPORT JS is also a great kind of accessory. Utility Library has a lot of helpers if you're working in Node or JavaScript. It has a lot of things already built out, like driving order hashes and things that can be helpful utilities. There's a Seaport order validator as well.
01:09:52.616 - 01:10:40.296, Speaker G: It's an onchain contract that you can call out to that does like almost 50 to 60 kind of on chain validations for balances and approvals that we recommend kind of checking out. It's pretty cool. So yeah, thanks for attending, love to open them up for any questions. If you guys have any about seaport or building on it. And yeah, thanks. Yeah, you could build a zone that's kind of like a pass through that you could check multiple zones. At the end of the day, it's just CPORT when it's executing the order.
01:10:40.296 - 01:11:07.724, Speaker G: If it's a restricted order, which means that it calls out to the zone. There's a full order and restricted order type. And if it's a restricted, it calls out to the zone. That zone could do calls to other contracts or zones and then come back with one final call. The only caveat is today on OpenSea, you have to use kind of like the zone that we have just as like a security thing. We don't allow anyone to use any zone. But during these hackathons, we love to see people building zones.
01:11:07.724 - 01:11:53.616, Speaker G: And there's always the option of adding that to some kind of possibility in the future that you could use it on OpenSea itself too. Yeah, the Seaport repository should have so the current zone that's used on OpenSea, I believe it's called like Global pausable. And the reason it was developed was when Seaport was released in the summer, it was brand new contract. And just in case something happened, we wanted a way to pause the whole marketplace. And Seaport itself doesn't there's no owner, so we wouldn't be able to pause that. But if they're all going through this zone, then we can pause the zone and that kind of effectively halts Seaport. So that's currently the zone that's being used.
01:11:53.616 - 01:12:20.650, Speaker G: And it should be in the repository. So you can see kind of an example of how and there's a little bit of documentation about zones in the Docs folder too. Thanks. Any other questions? Yeah, so I'll be around this weekend. I'll try to wearing a Seatboard shirt now. I'll try to wear like an open Sea shirt tomorrow. But if you guys are building on Seatboard or doing anything with orders, I would love to talk and help answer any questions.
01:12:22.940 - 01:12:23.690, Speaker H: Yes.
01:12:30.540 - 01:12:40.050, Speaker G: We are a sponsor of the tackathon. I don't think we have any prize levels for this weekend, but yeah.
01:12:47.470 - 01:12:48.540, Speaker A: Any other questions?
01:12:50.670 - 01:12:51.274, Speaker E: Cool.
01:12:51.392 - 01:12:53.510, Speaker G: Well, all right. Thank you, everyone.
01:12:53.600 - 01:12:54.640, Speaker A: Appreciate it.
01:13:02.290 - 01:13:12.500, Speaker G: If you guys would like, you can scan it and get one. I actually kind of want one too. Yeah, best part.
01:13:15.590 - 01:13:19.042, Speaker A: Everyone'S going to be trying to claim, though, who can claim faster?
01:13:19.106 - 01:13:22.726, Speaker G: Yeah, they said there's 100 on this one. So I think everyone you might have.
01:13:22.748 - 01:13:23.960, Speaker A: To refresh because.
01:13:25.850 - 01:13:32.120, Speaker G: I'll refresh it. All right. Looks like someone has claimed it.
01:13:41.240 - 01:13:41.556, Speaker A: But.
01:13:41.578 - 01:13:45.670, Speaker G: You all stick around. If anyone has any questions, feel free to come ask.
01:13:47.080 - 01:13:53.100, Speaker D: All it's.
01:13:59.280 - 01:14:02.476, Speaker H: Sweet. Like, the V Two stuff is really interesting.
01:14:02.578 - 01:14:05.392, Speaker A: Like with the smart contract stuff, you could go crazy, right?
01:14:05.446 - 01:14:12.836, Speaker G: Yeah. It would be like a whole new world of ways you could kind of create pools or other types of yeah.
01:14:12.858 - 01:14:14.356, Speaker H: Because I was thinking, like, this is.
01:14:14.378 - 01:14:16.950, Speaker A: Basically like the thing that sort of.
01:14:17.560 - 01:14:18.964, Speaker H: Goes like, suited something out.
01:14:19.002 - 01:27:43.836, Speaker F: Right. All right, GM everyone. My name is Flywell. I'm here to talk to you today about WorldCoin world ID and proof of personhood. So just before we get into proof of personhood, I'm going to give a little bit of an introduction to WorldCoin. In case you haven't heard of us, here's the famous orb. So, today we're going to talk about World ID.
01:27:43.836 - 01:28:25.950, Speaker F: So, World ID is a privacy preserving proof of personhood protocol. What that means is it enables you to prove someone is a human doing something only once without revealing any personal information. So the way we started is crypto is obviously awesome. That's why we're all here. But the value is being captured only by around 2% of the population. So what we wanted to do is bring it to more people in the world. So we started with this premise of what would have happened if Bitcoin started by giving one coin to each person.
01:28:25.950 - 01:29:40.180, Speaker F: Of course, this is no longer possible with Bitcoin, but we thought it would be possible with a new token. So that's why we created the WorldCoin Token with a limited supply of 10 billion tokens, where every person gets a share of this new token for free, just for the fact of being a person. And then until supply runs out. Of course, the problem we immediately realize is how do you make sure each person only claims their part once? And this is where if someone's able to game the system or abuse it or any type of fraud, then the whole premise falls down. And we realize this is a very existing concept called civil attacks. And this is a concept that's present in a multitude of applications from social governance, and we'll talk about a few more in a bit. So we wanted to create a way where we could solve for the civil attacks in a way that was private, inclusive, and scalable.
01:29:40.180 - 01:30:28.036, Speaker F: So we went through all the obvious options email KYC, and then we got into Biometrics. All of these options, we realized, weren't enough for either one of these constraints or goals that we had in mind. So KYC is not really private, it's not inclusive. A lot of people don't have passports or other form of ID. So we got into biometrics. And the problem with Biometrics is fingerprint. There's not enough information in the fingerprint to distinguish billion people or much more.
01:30:28.036 - 01:31:34.200, Speaker F: So that was something we couldn't work with. And of course, DNA is logistically too complex and not very private. So that's why we decided to go with the Iris. And we created this little device called the ORV. What the ORV does is it takes a picture of your Iris, computes something called an Iris code on device, destroys the pictures, and then with that Iris code is able to check that you're a unique person not previously registered. So there's no need for contact information, KYC passport, and any other type of personal information. So this is already quite private, but we realize it may not be enough, especially if you have a single Identifier that's tied to your person, then whatever you do with this Identifier will be forever tied to you.
01:31:34.200 - 01:32:43.212, Speaker F: So we went a little bit deeper. And with something called zero knowledge proofs, we embedded this as a core part of the protocol. So with this zero knowledge proofs, what you're able to do is say, I'm a real person and I have never done whatever action it is before. And you can do this in a completely privacy preserving way, in a way that if today I use it to claim WorldCoin tokens and tomorrow I use it to mint an NFT, those are completely separate actions unable to be traced together. And this is what the WorldCoin protocol is all about. So World ID is privacy first decentralized identity protocol that is based on this concept of a person and is completely open and self custodial so anyone can make use of it. The way it works is it looks something like this.
01:32:43.212 - 01:33:07.540, Speaker F: Imagine you have this cool application called Mesha where you can get $50 of whatever AirDrop you're doing and you want to make sure a person only claims it once. So you would add the World ID widget that looks something like this, very similar to a captcha. It's just very intuitive for users.
01:33:09.720 - 01:33:10.036, Speaker D: They.
01:33:10.058 - 01:34:31.680, Speaker F: Would get a QR code, you would scan it with your WorldCoin app and the app would generate the zero knowledge proof that you verified that you're a unique person and you're only doing this once. So now I'm going to get into a little bit of the technical details. The protocol is a little bit complex on account of the zero knowledge stuff, but we've abstracted most of this complexity to make it easy to build on top of it. So from a user's perspective, first the user goes to an orb. The orb does this check I mentioned and then issues a World ID, the user in the background. What's happening is the WorldCoin app is generating a random secret and it's showing the public part of that secret to the ORV in a QR code. The ORV then takes a picture, computes the iris code, checks that it hasn't seen it before, and if you're a unique person, it'll insert the public key into this list of verified identities, which lives on chain, currently on polygon, and we're working on bringing it multi chain.
01:34:31.680 - 01:35:44.120, Speaker F: So at this point, this public identity that gets inserted on chain, it's a random number. It has nothing to do with you. It's not connected to your biometrics. And when you use it, it's never going to be obvious which person in the set of users actually made whatever action it is that you're doing. So this is the flow for how an application can interact with the protocol. So there's essentially two pieces the application needs to integrate the front end widget, the captcha box I showed, so that the user can actually interact with the protocol, with the WorldCoin app and generate that zero knowledge proof. The reason the user needs to do this through the WorldCoin app is because the secret is stored in the user's device is completely self custodial and the app needs to generate the zero knowledge proof.
01:35:44.120 - 01:37:13.044, Speaker F: The other piece is the WorldCoin app will generate the zero knowledge proof, give it back to your application. And now your application needs to verify that the zero knowledge proof is actually valid. So to do that, the application needs to call our smart contract with the proof and say is this user actually verified or not? As an alternative, if you're not building something that's on chain, we have an API that abstracts all of this and you can simply do a traditional Rest API request and we'll call the smart contract for you. The other important piece to keep in mind is, aside from the serial knowledge proof, the worldcon app will give you something called a nullifier hash. So what's cool about this nullifier hash is it's essentially a unique user Identifier with the Asterisk that you'll get a different nullifier hash for each application. That's how we ensure privacy. So if I claim my mesh AirDrop and I get user ID one, if I then go and mint an NFT with another project, I'll get user ID two.
01:37:13.044 - 01:37:51.650, Speaker F: So there's never a way to trace users together. But you as developers building an application, can always use this ID to ensure a unique person is doing something only once. So if your application requires that someone only does an action once, you need to store this nullifier and compare it whenever a user is executing whatever action it is that you need. So all of this complexity can be very easily abstracted. So you integrate the widget. It's quite simple. I'll show the code in a second.
01:37:51.650 - 01:38:27.288, Speaker F: When the user scans it, they'll see something like this in the WorldCoin app is as simple as clicking Verify and that will generate the zero knowledge proof. To load the widget, you simply install this NPM package, load it as it's shown there. As you see, you'll need to provide two things. One is the action ID, the other one is the signal. The action ID you get from the WorldCoin Developer Portal is quite simple. Developer Worldcoin.org. There's links everywhere.
01:38:27.288 - 01:39:24.020, Speaker F: I'll share all the links in a slide in a SEC and the signal is this additional security measure that you can make part of the zero knowledge proof to prevent tampering with the proof. So for instance, let's say you want to do an AirDrop and you want to make sure that you cannot tamper with the proof so that another person receives the AirDrop. If I set the wallet address of the recipient as the signal and then I'm a malicious user who intercepts your serial knowledge proof and change it to my address, the proof will become invalid. So not all applications require this signal. It depends on your use case and it can be any arbitrary string. The protection is giving you is that it hasn't been changed. It's basically an authentication by the user who's generating the zero knowledge proof.
01:39:24.020 - 01:40:17.040, Speaker F: And then once you receive it, you'll receive this proof along with the nullifier hash. And you can easily verify it by just calling our API. Very simple post request or calling our Smart contract. There's a bunch of use cases enabled by civil resistance here's, only a few. We have some other ideas in our docs if you're looking for inspiration, but there's a lot of possibilities for civil resistance. So here you can go into Idwalcoin.org. You'll find there all the documentation for all the libraries, API, protocol details.
01:40:17.040 - 01:41:27.204, Speaker F: If you're particularly curious about the zero knowledge part and the math, there's some details on that too. You can also join us on Discord. We'll be very active during the weekend in both the WorldCoin discord and it Global Discord. So if you have any questions, if you get stuck somewhere, feel free to ping us there. We do want to give a huge shout out to these open source projects that make the protocol possible. So Semaphore is implementation of zero knowledge circuit. So it's what powers World ID and what let us bring this layer of privacy to the protocol hovel we use for the WorldCoin token and Wallet Connect, which powers the connection between the WorldCoin app and the application.
01:41:27.204 - 01:42:05.180, Speaker F: So when you actually are building on this, you'll see the QR code and all of that. It won't look like Wallet Connect, but under the hood it's using Wallet Connect. And then where we are right now is we launched this alpha protocol about six, seven months ago. We've been iterating, it's very low key. We've now built different applications. Integrations. You can see WorldCoin and lens integration.
01:42:05.180 - 01:42:46.220, Speaker F: If you have a lens profile, you can actually get it verified with your wall ID. You'll get a very nice batch in Leinster and will know that your profile belongs to an actual person. We have a POAP integration, so make sure that a person is only claiming a POAP once. It's pretty cool to prevent farming of poaps and things like that. And we are now working on making the protocol multi chain. As I mentioned, it's currently on Polygon. If you're using the protocol on staging or testing mode, it'll be on Mumbai.
01:42:46.220 - 01:43:58.740, Speaker F: So choose whether to use production or staging depending on whether you're building on Polygon, Mainet or Mumbai. If you're building outside of the Polygon ecosystem, you can use the API for now. The other thing I forgot to mention is if you want to test your applications, recommend going to Simulator Worldcoin.org. It will basically let you generate any number of random identities on the staging network and let you verify them as if you've gone to an Orph. Because obviously, if you test in production, if you come to an or, sign up and then test in production, you're only going to be able to do it once. Try to use staging. So, just to summarize, world ID is a protocol that solves for several resistance at scale.
01:43:58.740 - 01:44:57.304, Speaker F: Private open source open protocol. Completely self custody for the user and very easy to use and implement. If you have any questions, here's the main resource link that you should take a look at. Here you'll find all the documentation, other information around this particular hackathon, information about the prices, anything relevant for this hackathon you can find here. The other thing worth mentioning is for those of you building and submitting a project for the world coin track, be very sure to look at the details for a qualifying submission. In particular, the project needs to be integrated both on the front end and either the back end or the smart contract. So be sure to do both.
01:44:57.304 - 01:45:31.990, Speaker F: The reason we do that is if you only integrate this in the front end, there's not really giving you any protection at all. It needs to be verified in a trusted environment, otherwise it loses the value. And finally, we're hiring all around. So if you're interested, come talk to us or welcome. You can find all of our open positions there. And that's it. Do we have any questions?
01:45:45.600 - 01:45:46.204, Speaker D: Yes.
01:45:46.322 - 01:46:47.750, Speaker F: So, short answer is yes. The protocol will incorporate being able to tie arbitrary data to this concept of a person and then being able to issue either full assertions or partial assertions. The typical example of I'm over 18 or I'm a citizen of X country. Yes. Yes. We are actually very close to open sourcing all of the hardware around the ORF. The ORF has a bunch of security features to prevent tampering.
01:46:47.750 - 01:47:54.520, Speaker F: In essence, the Orb has a secure enclave that has a private key. If there's tampering, the key will get destroyed. Yeah, we can get into more details offline if you want. Yes. So that's very much something that we're working on. You have to physically go to an Orb to get verified. We can say is on one hand, we're exploring options, other options to let you get a measure of several resistance that won't be as complete as going to an orph.
01:47:54.520 - 01:49:08.840, Speaker F: And then as a developer, you can choose to rely on something less effective. The other thing is we have a model where we distribute this across the globe in a way that is not operated by us. It's operated by entrepreneurs and people that believe in the project and they, they get a benefit from operating the Orbs. But there's a whole bidding process to ensure optimal allocation. And right now, with about 20 or something of these, we've signed up like 700,000 people across the globe over 20 countries. So I'm confident we can get the number up quickly. Yes, sure.
01:49:08.840 - 01:49:53.010, Speaker F: So, full disclaimer. I'm not fully aware of all the details of polygon ID as of late. However, world ID today is focused on just providing this proof of personhood signal. So it's intended for civil resistance. You get this very high assurance of a unique person because of the biometrics. The polygon ID on the other hand is a more abstract concept around identity and attaching other types of signals.
01:50:04.240 - 01:50:06.270, Speaker I: Are they public information?
01:50:10.660 - 01:50:52.430, Speaker F: Yeah. So these public attributes that I'm talking about, they're not part of the protocol yet. The way we're thinking about it is there's going to be some sort of commitment to those attributes public on chain and then the actual data will live somewhere else up to the developer and the user. So it could be self custodial on your device. It can be in a decentralized network like ceramic. It can be on a private database that's going to be agnostic to the protocol. The protocol will care about the commitment to ensure certain properties around it.
01:50:52.430 - 01:51:54.940, Speaker F: Any final questions? Yeah, I'm sorry, can you repeat? Ah yeah. So that is very much ongoing research as well in terms of how your iris changes over time. For many reasons, for different reasons. We currently don't allow children under 18 years old to enroll and yeah, it's ongoing research.
01:51:58.680 - 01:52:00.036, Speaker D: I have a lot of questions but.
01:52:00.058 - 01:52:01.270, Speaker A: We'Re running out of time.
01:52:04.750 - 01:52:36.840, Speaker F: Yeah, the best place to go for answers is Discord because we're always going to be there even if we're not here. So either WorldCoin Discord Discord Ggworldcoin or ifglobal just look for the Sponsor WorldCoin Channel and we have a booth here, we'll be around for as much as we can and you can just confine us. All right, thank you everyone.
02:01:04.630 - 02:01:38.584, Speaker H: All right, we good. Hey, can you guys hear me? Hey, GM. Everybody. We're going to make this pretty fun. I'm going to give you a brief overview of optimism. So like everything that we're about, obviously we're scaling Ethereum, but we're not just scaling Ethereum's tech, we're scaling its values as well. So unfortunately I can't edit the notes on the side so it's going to be this view but hope everyone's having a nice day.
02:01:38.584 - 02:02:09.252, Speaker H: So before beginning, I just want to talk a little bit about incentive structures. Like what are we doing here? What is crypto? Right? We live in a world of perpetual personal incentives that are pretty individualistic. It's passed down to us from society. Go to this college, get this job, do this thing, retire four hundred and one K, all that stuff. And a lot of times these are harmful, right? Like the environment's not doing great. There's a lot of selfish motives in the world. But what crypto allows us to do very interestingly is reprogram some of these incentives that we've been taught our whole lives.
02:02:09.252 - 02:02:40.716, Speaker H: So there is a mysticism found in blockchains that we don't find in any other technology. The superpower lies in the ability to reprogram incentive models that have been passed down throughout society. So enter ethereum. Ethereum lets you program money, money lets you program incentives and incentives lets you program novel social structures. What this means is now anyone can program incentives. You don't have to be a king to make a new governance system. You don't have to be chairman of the Fed to make a new monetary policy.
02:02:40.716 - 02:03:10.260, Speaker H: You can be in the basement and do this. You don't have to be a Hollywood artist to get exposure for your artwork and get royalties and get paid well, right? So this also lines in with this idea of the unbundling of everything that I think we're seeing in societies currently. So this is a great example of it in the form of the media, right? People magazine. This was, like, the dominant thing back in the day of everyone would read People magazine. This was the thing. And then came the kardashians. The Kardashians took over People magazine.
02:03:10.260 - 02:03:45.010, Speaker H: People were now following this family. I was like, Whoa, okay, great. And then came TikTok influencers. It's like, whoa, anyone can now create content and be seen. And it's this idea of the unbundling, right? Like, now, any individual who has a mission, who has a unique thing they want to express in the world, can express in it, can express it through crypto. The similar thing can happen within banks, right? You have these large institutions that are doing certain things now. Some people who are friends in a basement can program structures that end up having billions of dollars in TBL that people use for banking, right? It goes along the wave of unbundling everything.
02:03:45.010 - 02:04:31.180, Speaker H: So I think we all know that Ethereum is the best city in the world, right? Everyone wants to be on Ethereum. Everyone wants to go there, spend time, but it can get crowded. Like, when there's a lot of people in one spot, you get traffic jams, you get, like, a lot of fuss. How do we fix that? Enter optimism, right? So just like how big cities need skyscrapers and subways to operate properly, ethereum needs optimism. We are kind of providing the skyscrapers and the transport layer and everything for Ethereum to scale in a way and make that city that I was mentioning here more livable. But we don't just scale Ethereum's tech, we actually scale its values as well. How do we do that? Through this thing called retroactive public goods funding.
02:04:31.180 - 02:05:03.084, Speaker H: So if you look at the fees that Ethereum generates just today, it generated $5 million, 5 million. That's a lot, right? But where is this money going? Mainly, it used to go to miners. Now it's going like, validators, et cetera. It's going to specific people in a way, but it's not necessarily going to the community as much as maybe we would like. So with optimism, this is optimism. Sequencer revenue. We're just starting out average of about $30,000 a day.
02:05:03.084 - 02:05:47.160, Speaker H: Imagine what this can be as Ethereum scale to an S L two scale for the future. Like, this will just continue growing up in that trajectory, right? This is just the beginning. 100% of these fees that are generated daily go back towards the community, goes back towards public goods. So we've pioneered this model called retroactive public goods funding, where we essentially like, if you want to create a public good, you want to do something for free. You want to create educational content for the world, you can do so and know that you'll get retroactively funded by optimism. One of the things is, I think we live in a society that where if you want to do good, you kind of have to be a financial martyr. Like, you want to go help the world, you're going to have to be like, oh, I'm not going to get paid as much as a banker or as an NBA superstar.
02:05:47.160 - 02:06:31.992, Speaker H: Are we think that's wrong? I think we stand a chance doing what we do in this space to reprogram that model, to reprogram that incentive. And we aim to do that by removing the opportunity cost of doing things that benefit the greater good through Rpgf. So now who decides where these fees go? Right? Like, there's all these fees, they're going to get bigger, we're going to scale more. Who decides it? Well, around I think May, we had our AirDrop and we started our governance collective. So the governance system, which has two houses, gets to decide where these public goods profit, where that network revenue I showed earlier goes, essentially. So who gets retroactively funded for it? Right? This is a little meme. So initially, just like profit motive solves everything.
02:06:31.992 - 02:06:50.296, Speaker H: Donation funding. Okay, that helps quadratic funding a bit better. Retroactive public good funding. Let's go. Right? So this is a real world example of this. Let's say right now I want to plant trees. My contribution to humanity is I want to go and plant trees.
02:06:50.296 - 02:07:24.264, Speaker H: Now I walk over, I see a VC, I'm like, hey, VC, can you give me $5,000 to plant some trees? It's for the good of the world. The VC looks at me in the face and laughs at me. He's like, Why would I do that? There's no return on investment for me. Why would I do that? That's the pessimistic world of today, the optimistic world of tomorrow and today, because we've already done this is same thing. Now I want $5,000 to plant my trees. I go to a VC and I say if I do a good job with this, the optimism collective is going to retroactively fund me for this. Now a VC is looking at this and being like, that's an interesting model.
02:07:24.264 - 02:08:04.532, Speaker H: Like, yes, I'll bet on you, right? Every investment a venture capitalist makes, for example, is like an investment in a person. Like, oh, maybe they'll succeed here, they have a clear sign of an outcome where if they succeed, they might get retroactively funded. So that's a real world example of what Rpgf can become. And of course, it's not just limited to planting trees. Like everything from building infrastructure to educational content to pretty much everything that's an open source public good. So we fund public goods through network activity. So as people use optimism, as you deploy an optimism or do anything on our network, it goes to feed these fees, then goes to this pot of retroactive funding, then governance votes on where that funding goes.
02:08:04.532 - 02:08:40.512, Speaker H: So what's happening with the network? Why would you want to use our network, right? What do you want to do and what can optimism provide to you? So before that, the state of roll ups today. So up and to the right. Obviously, everyone's heard of roll ups now it's growing. A lot of folks are using roll ups, right? Like, I think we hit almost six. Wow. $6 billion in TVL across all L two S on ethereum. So there's a lot of traction and obviously there's a lot of fees that are being generated, as I explained before, but it's cheap, but maybe it's not cheap enough.
02:08:40.512 - 02:09:30.812, Speaker H: There'll still be some alt L ones in the world that are like, we're cheaper than you and all that. Second, is there's a little more decentralization needed, right, with a sequencer, with clients, et cetera. And lastly, some people might ask, what else? What else can a roll up do except for just scaling this and making it cheaper and faster and all of that? So, to address the first one, we do a little fee reduction. So we actually live in a world where we're planning on roll up fees going to zero and we're going to achieve that through Protodank sharding. So it's called EIP 4844. And Liam, who's over there, and Protolambda and a bunch of mophie and a bunch of people from the Op Labs client team have been working on this and trying to do this for everybody, because EIP 4844 actually benefits every single roll up out there. We strongly believe that a rising tide lifts all boats.
02:09:30.812 - 02:10:16.224, Speaker H: So EIP 4844 and a quick explanation of that, which I'm going to try to do the best I don't have my notes on here is a toilet metaphor, right? So how can we think about what EIP four A four four is or EIP four A four four? So let's say you're, like, in line at a crowded festival and you're going to the Ben's bathroom, right? The toilet only has stalls, so regardless of if you're, like, peeing or pooping, you have to use the stall, right? Obviously, a number one takes less time than number two, so it's not hyper efficient for everyone to be doing using the same stall. You can solve this problem by adding a Urinal, and essentially, urinals are only used by people who need to pee. At least I hope.
02:10:16.262 - 02:10:16.850, Speaker F: So.
02:10:18.260 - 02:10:58.712, Speaker H: Now, the toilet has two separate lines you can go to. So what does this example actually mean? Well, in this case, the toilet is ethereum, the toilet stalls are blocks, poops are transactions, p is data, p in a stall is call data, and Urinals are Blobs and the lines are the fee market. So the upgrade is EIP 4844. It's just essentially making it more efficient, right? Like not having everyone go to the same line, but have certain people go to lines that are more efficient for them. So that was a Twitter thread written by Razu ETH. It's a pretty good analogy there. Okay, and second thing we're doing, so this is about multi client architecture.
02:10:58.712 - 02:11:40.568, Speaker H: We are launching bedrock soon, which essentially is like a pragmatic way for us to start decentralizing. What bedrock encompasses is theoretically optimal. Call data submission, consensus and execution, client separation, a microscopic client difference, only 500 lines of code, faster peer to peer networking. And all of this is basically in tandem with our idea to not just become EVM equivalent, which we already are, but to become Ethereum equivalent at the very core. This also allows us to easily plug in EIP 4844 when it's ready, which should be soon as well. It also has smarter sync, sequencing and state submission. So, Bedrock, it's coming out soon.
02:11:40.568 - 02:12:07.476, Speaker H: And if you ever want to read up more on it, we have multiple articles, multiple Twitter threads that explain a bunch. As always, our code is always open source. We build everything openly so you can access that. Lastly, I think this is something I'm very, very stoked about is the idea of DOP stack. So the optimism code base has been forked multiple times. There's been a bunch of roll ups that have actually been using our code base and we're open source. We're very much ready for that.
02:12:07.476 - 02:12:51.730, Speaker H: That's something that we will always be. But we realized when people forked our code base, they started doing interesting things with it. Like they would mess around with DA layers, they'd add something else and it would be this new custom solution using the original stack that was forked. So we took a long, hard look at that and we were like, okay, what if we make that easier? What if we make it even easier for someone to do that? And then came the birth of the Op stack. So I think one way to think about it, and this tweet kind of explains it, is you can basically deploy a roll up however you wish with fully customizable features, right? Like, you want a ZK roll up that uses like, Celestia for a data availability layer. You can go and do that. You want extra throughput, you want to use another DA layer, you can go and do that.
02:12:51.730 - 02:13:19.636, Speaker H: We're making it as easy to deploy a roll up as plugging in APIs in Web Two. So you wanted like bits and pieces. You want to do bitcoin roll up. Like whatever it is, you can actually experiment and that's what the Op stack enables you to do. It's like we're fully making it very easy to run multiple experiments on the future of roll ups and whatever you want to create. With that comes the idea of the superchain so let's say the Op stack is there. We have a bunch of different Op chains.
02:13:19.636 - 02:14:21.916, Speaker H: People are building crazy sorts of roll ups and now you want to connect them. Now you're like, okay, I want all this to feed into one larger thing. Luckily, because the way the Op stack is structured, because everyone's using the same stack is you can actually have atomic composability. So because this idea of shared sequencing where you have all these Op chains, they all use like this shared sequencing model, you can basically connect all these Op chains together into what we call the superchain. Where this becomes interesting is basically the idea that the hardest thing right now to kind of deploy a roll up or anything in the space is you can do the tech, you can deploy your own chain, you can deploy and roll up, but then you have to do business development, right? Like you have to try to get an Ave on board or you have to get all these DApps on board and that takes a lot of time and that takes a lot of effort. A lot of times people just want to build cool stuff. So how do you build cool stuff without having to worry about the whole like oh no, how do I do this negotiation, how do I do this partnership? The superchain kind of enables that because you can create this off chain however you want.
02:14:21.916 - 02:14:51.640, Speaker H: It's connected to all the other chains. It's connected to optimism mainnet. You want to do something that's on optimism mainnet you can make it really easy for messages to pass through and basically interact with stuff that are on other chains. So it literally allows you to make really cool stuff that you've always wanted to do. Not have to worry too much about liquidity because everything's connected. But that is a superchain and it's a work in progress. I think when Bedrock is released, this is going to be easier to actually use.
02:14:51.640 - 02:15:23.652, Speaker H: We do have one example of an Op chain of sorts that's already come out by the folks at Latice. It was called Op craft. It's essentially a full Voxel game. That's its own blockchain and it was built on bedrock. So literally like an entire game that's its own blockchain. If you were to hack on it, you can make like an AMM that's like in a cave somewhere or something. So that's just like one example, I think the Op stack and the superchain kind of enables multiple avenues and we kind of have released this thing and we'll see what can get built on it.
02:15:23.652 - 02:16:21.060, Speaker H: But it's allowing for full composability. It's allowing people to run experiments and connecting all of them together into one larger superchain. So I think this is a question that comes around a lot as well, is like what is our path to decentralization? So our path to decentralization larger, sorry, 2023 we want to create a fault proof which proves L two bedrock blocks. We want to work towards decentralized sequencer selection FIAP, then deploy bonded sequencer using single client faultproof with instant upgrade keys sequencer auctions. These are works in progress. I wouldn't say it's like hyper finalized, but these are ways that we are currently might be thinking about it. And then by 2024, deploy bonded sequencer using MultiClient FallProof without instant upgrade keys and then we reach a world where we're a bit more decentralized and can look towards the future.
02:16:21.060 - 02:16:58.780, Speaker H: So to kind of summarize a few things here, what we're really aiming for is solving the blockchain trilemma and optimism is getting closer and closer towards being in that middle spot right there. This is our ecosystem at this point. Lots more lots more protocols being added every day. And I think when we look at what I just mentioned with the Op chains and the super chain at large, we'll have a lot of different things as well. You name it. Like you want a bitcoin CK roll up, different DA layer, all of these things are possible and we're excited to see what you guys will build. Thank you.
02:16:58.780 - 02:17:00.830, Speaker H: Happy to take any questions right now.
02:17:01.760 - 02:17:02.510, Speaker C: All.
02:17:21.150 - 02:17:43.720, Speaker H: Yeah. So we did a Rpgf round, we did a first one and don't remember the exact list, but solidity aragon Etherscan, there's a bunch like a bunch of public open source things that helped Ethereum because we're doing public goods that help both optimism and Ethereum. Yeah, those are those round one.
02:17:49.430 - 02:17:50.082, Speaker A: Cool.
02:17:50.216 - 02:18:30.180, Speaker H: Yeah, sorry, I can't quite speak on that right now, but yeah, currently it is a governance token that is used. The power there is again, you have the network fees that I showed you back here. Ethereum does like 5 million a day. Roll ups are going to scale larger and larger. The fees for our roll ups are increasing pretty much every day, average of like forty k a day, I think, right now. And the governance token basically helps allocate where this funding because all this fee revenue goes into this pot of Rpgf. The token helps decide where that funding goes.
02:18:30.180 - 02:18:52.426, Speaker H: That's an interesting question, I think. Are there gitcoin folks here? We should have a conversation. Yeah, I'll keep you in the loop, but yeah, that'd be awesome.
02:18:52.608 - 02:18:53.340, Speaker A: Good.
02:18:58.190 - 02:20:01.626, Speaker H: Do you guys have any crazy Op chain ideas? What's, like the craziest thing you can think of? Okay, I'm going to leave it here for a little bit just in case. Let these questions marinate a bit. Yeah, anything. Yeah, sorry. Yeah, great question. So I think a few things I believe Nitro might have changed this, but for a really long time we were the only EVM equivalent roll up. So we had the OVM before and we were like, okay, let's move this a little bit.
02:20:01.626 - 02:20:40.040, Speaker H: Let's be as equivalent to Ethereum as possible. So we moved towards EVM equivalents, which for any DAP developer just makes it a lot easier to deploy an optimism. It's just like literally chain ID switching. So that's one. I think the other thing is also the public goods funding route where all of our network IPS will go back towards our community. The bet there is if you have a community where you continuously invest in its public infrastructure, you'll basically have a place that's easier to build in, that just has more structure, has more bedrock foundations that can supercharge the power like the apps of the future. That's one of the main differences, I'd say.
02:20:40.040 - 02:21:00.560, Speaker H: Let's see. Yeah. Also one other thing that is different is because of bedrock. That's going to basically surcharge a lot of these differences a lot more because we allow for multiple clients that unlocks a whole series of use cases. Like, you can have a ZK client on bedrock basically as well.
02:21:14.950 - 02:21:16.180, Speaker G: That just came out.
02:21:17.370 - 02:21:34.730, Speaker H: Yeah, I think we'll have to see. Yeah, it's all really fresh right now. Does that come out yet? Okay, I see. Yeah. Liam's our CEO.
02:21:38.030 - 02:21:38.394, Speaker A: Yeah.
02:21:38.432 - 02:22:08.146, Speaker I: Basically. What's the deal with ZKE EVM? I think the whole idea with the Op stack is that all these things are pretty plug and play. If you want to have a ZK Foll proof, whether that's with EVM or whether that's with MIPS or Risk or some other like, it's kind of whatever you want. There's multiple projects building these things. Like there's the Hermes one, there's scrolls, there's risk zero doing it for risk. ZK Sync has their own kind of custom thing. From my standpoint, eventually these are going to be solved.
02:22:08.146 - 02:23:02.360, Speaker I: It might take a few years until we get a really performant one that anyone can run, but if it's not open source, I think the community will reject it. So it'll have to be open source. And the whole idea that we have from our approach is like, just focus on the community first, focus on the governance, focus on the funding distribution, and then plug in the proof system later. So from our standpoint, we basically think whichever one of these ZK approaches wins is the one that we'll use. And we're probably going to start finding ones that we want to even start funding or supporting to start competing to be one of the options that people can use for their proof system. I think it's kind of weird historically how we've ended up in this world where there's like optimistic roll ups and ZK roll ups as this competitive thing in this l two industry, because it's fundamentally we're just building core infrastructure to scale ethereum. And I think that I think it's a mistake to kind of think of these things as competitive right now.
02:23:02.360 - 02:23:35.620, Speaker I: Over the long term, the whole point like, this technology is going to commoditize, and the interesting thing is going to be the community on top and what kind of worlds you build with your own chain infrastructure, which, by the way, is very interesting. Why Cosmos? The Cosmos app chain thesis I think is very worth revisiting. And I think there's probably a world where on Ethereum we start seeing way more app chains emerge. So I would also look into that. If you're a hacker trying to figure out what to work on, you don't necessarily have to go into the app layer. Like there's still a ton of stuff to work on. Lower, lower down.
02:23:35.620 - 02:23:38.020, Speaker I: Yeah, sorry, it's a long winded answer.
02:23:42.210 - 02:24:05.330, Speaker A: How do you get exchanges provide a more direct path to layer two. Kind of an open question.
02:24:10.100 - 02:24:59.372, Speaker I: How will users get onto L two? So I think one big category is the really obvious one which is like people that could not use Ethereum, that want to use Ethereum but can't afford it. That class of people, I think they've either just left or they went to Polygon or maybe they went to Binance smart chain and maybe they are using some application there. But it's not like they're going to just stay there. It's like their favorite place in the world. They're going to all of a time shop around for where's the ecosystem going to the future. And so I think that category of people will likely, once it's clear like hey, there's an alternative from these less decentralized, from these centralized chains to use ethereum again. Then I think they might begin to flock over to optimism because they see this is like a better way to still have the sense of security and decentralization and ethereum community alignment that they want.
02:24:59.372 - 02:25:35.532, Speaker I: And so they'll maybe flock back in. But you're thinking more with the technology. I think that's again, kind of all at this point like the standard playbook, right? Every exchange should have a deposit and a withdrawal flow. Any on ramp, off ramp, all over the world at this point there's all these companies, they should just have an optimism integration on our side. There's like a whole partnerships team just going all over the place like making sure we have all those integrations. But I think a lot of those are just like existing crypto users. The more interesting thing is if we actually have the ability to say hey, Ethereum is cheap and it works the way you thought it did, it's like less than a penny for anything.
02:25:35.532 - 02:26:04.090, Speaker I: Then all of a sudden now Ethereum, the product of Ethereum, which is what we're trying to effectively scale with optimism, will be in the next bull market particularly will be super cheap. And so any of those people that went to Ethereum and turned they can actually now actually stick around. And so it could just be the net new audiences that come in the next bull market. What that is, is a big open question. But I think that's probably the more important one is where will the net new users come from.
02:26:08.890 - 02:26:22.460, Speaker A: Incremental risk for layer two versus layer one? Maybe from high level. How much should they store on the layer one versus layer two.
02:26:22.830 - 02:26:51.634, Speaker I: Yeah, that's a good question. So the question is, how much money should you store on L One versus on L2? I think I would think of these as like tiers of temperature of your money. Like, if your money is really cold, you're never going to touch it. You just want it in your like you want ave USD. You just want to keep it in one place. It's your savings account, it's your money under your mattress kind of situation. Then probably you want to keep it on L One because it's like nothing's going to change.
02:26:51.634 - 02:27:08.620, Speaker I: It's just a net kind of ossified almost system. You're just like, okay, that's like with Bitcoin, right? It's like not going to change. So you can keep your money there. You can feel pretty safe at night. On the L2 S. You want to probably have more of your money that you're going to use regularly. Right? It's more of a checking account.
02:27:08.620 - 02:27:34.820, Speaker I: Maybe once a week, once a month. You kind of use this money for some reason. Either you're leveraging something, you're saving something, you're spending it, you're sending it. Then L2 should kind of occupy more of the actual human usage. So it might also divide up the users to be more like you have bots and user and humans on L2, and then you have large institutions and hardware wallets on L One. That might be what happens, but it's hard to tell.
02:27:41.470 - 02:27:45.470, Speaker A: That are going to be important for the development.
02:27:50.840 - 02:28:29.612, Speaker I: Yeah, there's a few. One interesting one is 4444, which is kind of a history expiry. It's more like the lack of a necessity for clients to store long term history. For example, right now, if you're like the Geth team or if you're our team also every time there's some evolution to ethereum that changes the way it works. You're not upgrading your software, deleting a bunch of the old code. You have to add new code and also maintain all the old code. So the Geth team has to maintain all of the code from every previous hard fork.
02:28:29.612 - 02:28:49.088, Speaker I: And it all has to work perfectly. And that's an enormous amount of technical debt. So 4444 removes a huge amount of technical debt. And the reason why that's important for L2 S is that on L2 S you are reusing the client software. At least that's what we're doing. And that's what Arbitrum now is doing too. So you want that software to be minimal and simple and have the minimum possible technical debt.
02:28:49.088 - 02:29:32.996, Speaker I: So that's a big one. Another one is beam sync. I don't know the number, but beam sync is really interesting because it makes your wow, there's a lot of folks all of a sudden beam sync is really interesting because it enables you to sync a node from a lazy loading perspective. So instead of syncing block by block or syncing with merkel proofs or syncing sort of like through many proofs, you sync as you execute. So you want to run a transaction and your EVM trace reads gets to a point where it's like, hey, I don't have this data. It'll then find other nodes that have the data and then sync it. And the reason why that's important is that the way a fault proof works is that it's the exact same process where you execute the code and all of a sudden you don't have the data.
02:29:32.996 - 02:30:29.396, Speaker I: So you need to get a merkel proof to show that the data exists in some state route. So it makes the fault proof execution code look identical to the execution code, period. So again, it lowers the diff even more for writing an L2, which is, again, it's the whole philosophy that we have with the design. I want to mention one more wonderfully fast shout out. I think it's also a good hackathon kind of thing to think about is that eventually the EVM is going to ossify and you're going to have kind of L2 EVM, right? L two S can be an experimental ground for creating your own version of the EVM. So you can imagine a world where there's, like, an optimism with account abstraction and you can experiment with account abstraction on an L two, because you can actually get the whole ecosystem of the technology around the EIP. Like the developer tooling, the geth changes, the solidity changes and so on.
02:30:29.396 - 02:30:44.024, Speaker I: The wallet changes, all working on a main net production roll up before it's on l one. So L2 EVM and the evolution of the EIP process in general is also like, a really important category for people to think about. Is there another workshop?
02:30:44.072 - 02:30:44.572, Speaker A: Sorry.
02:30:44.706 - 02:30:47.656, Speaker I: Okay. Oh, it's polygon.
02:30:47.768 - 02:30:48.268, Speaker A: All right.
02:30:48.354 - 02:30:50.510, Speaker I: Go polygon. All right, thanks everyone.
02:31:56.690 - 02:32:22.590, Speaker D: Right. How are you guys doing today? Good? That was not excited at, like, whatsoever. How are you guys doing today? All right, a little bit better? All right, I can work with that. So thank you all for coming to my workshop. We're going to be talking about on chain verified credentials with Polygon ID. A little bit about me. Hi, I'm Rahat.
02:32:22.590 - 02:32:43.210, Speaker D: I'm the lead developer relations engineer over at Polygon. Previously been front end engineer, solidity engineer. I've done some anonymous work for various NFT rugs. I never said that out loud. Indie hacker, web3, enthusiast, done some failed startups in the past. So I can tell you everything that went wrong. I cannot tell you how to succeed.
02:32:43.210 - 02:33:11.958, Speaker D: A few places you can find me on Twitter, LinkedIn, GitHub, et cetera. But right now, we're going to play a game. This image is a claim. The claim is that I am a pixelated punk. Can you verify that these two images are the same? Yes or no? Yes. Am I a pixelated punk? That's not the answer I was looking for. Yes.
02:33:11.958 - 02:33:58.622, Speaker D: Okay, cool. So congratulations. You just participated in an IRL version of polygon ID. What the hell was that, right? What does that actually mean? Before we get into that, a little bit of an introduction onto what Polygon ID actually is. So it's a blockchain native identity system with programmable privacy that empowers people, enables creation of trusted interactions with Web Three services. I just read a definition for you. So that doesn't actually explain anything to you, right? But what it does is it provides you a way of having universal identity that you can take with you throughout your Web Three journey, right? You verify something at some point from some type of issuer.
02:33:58.622 - 02:34:44.500, Speaker D: An issuer could be some government facility, a DMV issuing you a license, someone giving you some Credential, saying that you graduated from some college and you as a person are carry around that Credential. And at some point someone needs to verify that this Credential exists, right? So that's kind of like the flow that I want you to remember as we go through this. So this is called the triangle of Trust. So in this case, the case that I showed you before here with the game that we played, the triangle of a trust exists this way. There's an issuer called Pixel Portraits. Shout out to pixel portraits. If you want a NFT of yourself like that, they do this.
02:34:44.500 - 02:35:44.082, Speaker D: Pixel portraits issued me an NFT. It is an image of my likeness as a pixelated punk, right? The ID holder is me. I am holding this NFT and I asked all of you to compare this ID, this NFT to myself and let me know if you think it actually is me or not. Right? So the way that this is done through Polygon ID is you have your issuer, that issuer issues. Some sort of claim can be, like I said, it can be some type of date of birth Credential. It can be something like a diploma, it can be, are you the owner of X item or whatever it is that issuer gives you that Credential and you never have to verify that you actually have that Credential ever again. Because now you have different verifiers who just look at that Credential and have some sort of trust with that issuer, saying, okay, I know this issuer.
02:35:44.082 - 02:36:20.042, Speaker D: If this issuer says that this is the actual thing, I believe it. And that is done through ACK proof. So let's talk about what exactly we're going to be building for today. So many social media platforms require you to be 13 years or older to use them. Instagram, I think Twitter requires that. I don't know, I don't know how it's enforced or if it is enforced. But what we're going to do is we're going to leverage Polygon ID to issue a soul bound NFT based on a specific age Credential.
02:36:20.042 - 02:36:48.678, Speaker D: So we're going to issue ourselves a claim. So we're not going to use some third party claim, we're not going to verify our age or anything. We're just going to issue it to ourselves. And that claim is going to contain our date of birth. We're going to create a smart contract that mints a soul bound NFT as long as our age is over 13. And there's going to be a front end where anyone with a polygon ID Wallet can claim this NFT. So all this is contingent upon you folks.
02:36:48.678 - 02:37:24.514, Speaker D: Downloading the Polygon ID Wallet app, which is available on the App Store as well as Google Play Store. There will be resources and links to download all of that when you start hacking on yourselves, but demo and code time. So the first thing I wanted to show you was this polygon ID platform. So I mentioned that we're going to be issuing the claims to ourselves. So we're not going to go through some third party issuer and have them check our ID or do anything. We're just going to do it ourselves just for the sake of this specific workshop. So this platform here, again, links will be sent out in discord.
02:37:24.514 - 02:37:56.450, Speaker D: I will also tweet them out. And this platform here is on the testnet right now. So what you can do once you've gone onto the platform is create a schema. So I'm just going to create a sample schema here. We're going to call it Mi 13 or older. And the attribute name we'll say is a KYC Age credential. Name it whatever you want.
02:37:56.450 - 02:38:25.850, Speaker D: And there are specific data types that are supported right now through these issuing claims. You can have a boolean, yes or no. You can have a date. So in this case, we're going to be using a date or you can have a number. So these are like different things you can think about when you're trying to issue specific claims. So we're just going to use the date because I'm going to be looking at a birthday. So if you want to put in a description, this will be birth date or whatever.
02:38:25.850 - 02:38:54.980, Speaker D: For each of these claims, you can add an expiration date if you want to. I'm not going to add one, so I'm going to uncheck this. But now you can either save your schema or save and offer the claim. So we're going to go ahead and save and offer the claim. So this claim has now been created. Now inside of this attribute for my KYC Age credential, I can select a date. Not going to use my real birthday, but let's say I was born.
02:38:54.980 - 02:39:24.892, Speaker D: I need to be at least 13, right? We'll just say 1990, February 7. Okay, I'm not going to put in an expiration date. So this claim is just going to exist forever. Going to hit generate claim offer, and this claim is going to be generated. And now we have this link. Copy this link, head over to it and you'll see that you received a claim offer from Rahat. Rahat is me.
02:39:24.892 - 02:40:11.692, Speaker D: I am the person who issued this claim, right? So now you would download your polygon ID wallet app, you would scan this QR code and then within your polygon ID app you're going to have a specific credential that says you are this specific age, right? So this is again a testnet version of you issuing yourself a claim to test out your polygon DApps. Cool. So now that's the first part. This is a claim. So this is kind of like the same thing as pixel portraits giving me an NFT of my punk, right, rather than a punk. And now I'm getting a QR code with a claim that says I am however old I am. Cool.
02:40:11.692 - 02:40:55.240, Speaker D: So now let's look at some smart contracts. So all of these contracts are going to be shared and available for you to go through afterwards. So I'll drop them in the discord as well as on Twitter so you'll be able to take a look at these. But to get this set up to actually start using polygon ID with your smart contracts, there's a couple of things you need to do. You're going to have a couple interfaces, libraries and Verifiers. You don't have to write any of this code, you can simply copy and paste from the repositories that are going to be shared with you. But just like a quick thing, if you just go through these, you'll see that these are what's actually powering the ZK proofs and Verifiers that are going to be looking at your credential and comparing them within the DAP.
02:40:55.240 - 02:41:35.604, Speaker D: All of these again are boilerplate code that you can just copy and paste. Where we're going to actually focus on and create our own code is going to be in this ERC 721 Verifier. So you'll see from line eight through ten that I imported all of those libraries eventually. What I'm hoping to do maybe later on is create like an NPM package so you can just install and import those rather than copy and pasting them. But as we're iterating and building, that's what you got to do for now. So for this NFT drop, I have imported a couple of things from Open Zeppelin. First is going to be the ERC 721 Uri storage.
02:41:35.604 - 02:42:15.060, Speaker D: Just to make it easy to set the Uri, I am importing counters for the ID of the NFT itself, strings, which is a really cool utility that I'm going to use to convert numbers to strings, which I'll show you in a bit base 64, which is going to be helpful for actually creating on chain NFTs. So everything that we do here is going to be completely on chain. No storage will be used off chain. So let's take a look at the contract itself. It's an ERC. 721 verifier. You can call it whatever you want, but it inherits everything from the ERC 721 URL storage as well as the ZKP Verifier.
02:42:15.060 - 02:42:56.412, Speaker D: There's a couple of variables here. This is really just keeping track of the addresses that have already minted and making sure that people only mint once. I'm using strings which I imported from open zeppelin for unsigned integers, which basically gives all of my unsigned integers the power to become strings counters which will be for my token IDs. The constructor is just going to deploy the ERC 721. But now we get into the cool part. Before proof submit, this is just some boilerplate code. But what before proof submit is going to do is going to check that the challenge input of the proof is equal to the message sender.
02:42:56.412 - 02:43:30.636, Speaker D: So we want to make sure the person who is actually trying to generate this proof that is trying to perform this action is the person who owns this specific proof. So that's what this is taking care of. After proof submit is where the actual magic happens. We first check to make sure that this proof has not been submitted before, they've only done it once. And then inside of this if statement, we actually execute the token mint. So I'm just incrementing the token Mint right away, the token ID right away. The Token ID from counter generally starts at zero.
02:43:30.636 - 02:43:51.116, Speaker D: I just like starting at one. So I increment it. I get the current token ID and then I call Safe Mint with message sender as well as the new item ID. And then I set the token Uri using the item ID. And this Get Token Uri function that I'm going to show you in a bit here. Next part. This is what makes this token a sol token.
02:43:51.116 - 02:44:29.256, Speaker D: This before token transfer is going to override the ERC 721 before token transfer and prevent you from ever actually being able to transfer this token. Because your age is your own age and not someone else's. Do not verify your age for someone else. That is a frowned upon action. Two more functions here, generating the SVG for the token as well as getting the actual token Uri. So I'll just go through this real quick. For generating the SVG, we just have this large SVG code that is going to be encoded and returned as a string and converted to a data image URL.
02:44:29.256 - 02:44:59.450, Speaker D: All it is is just like a black square that says you are over 18, I mean over 13. And I'm using the base 64 encode to encode all of that together. Finally, the actual Get Token Uri which is going to take your metadata. So this is the metadata that would appear on your NFT. So right now I'm just giving it a name description and the image. The name is just going to be 13 check. I'm sorry, I'm really bad at naming things.
02:44:59.450 - 02:45:28.480, Speaker D: And the actual Token ID. So this is why I brought in the strings package. It gives you this nice little two string utility description verified credential of age over 13. And then the image which is just going to be this generate SVG for token, which returns a string. Cool. So this part here is nothing specific to Polygon ID. This is simply for Minting, an on chain soulbound NFT.
02:45:28.480 - 02:45:51.348, Speaker D: Nothing special going on there. Cool. So now we've got this ERC 721 kind of written off for us. There's two scripts in here that are going to be super, super important. First of all, deploying your contract, making sure you deploy it. Nothing special here. I'm just taking my contract, deploying it onto Polygon.
02:45:51.348 - 02:46:36.868, Speaker D: The next part is going to be this set request script over here. So this is another thing that you'll be able to copy and paste. Most of this is boilerplate code, but there's a couple of key things that you can change depending on your use case. So the first thing is going to be the address where your contract was actually deployed. So this is my address that I deployed earlier and the actual query that you want to do and you want to check for. So the query that I want to check for here is to make sure that the person who supplies their date of birth, that this date of birth is less than or before January 1, 2009. I think I did the math correctly.
02:46:36.868 - 02:47:13.110, Speaker D: That should make you 13, but if it's not, just pretend it is. And you can take a look at this link here, which will show you the ZK query language, which is going to help you actually set up this query. But this operator here with the number two, I believe it means less than. So it's going to check if your date of birth is less than this. So you have your issuer that gave you that credential. This query is what's going to check that credential and make sure that you're 13 or older. So we've got that.
02:47:13.110 - 02:47:30.250, Speaker D: So you run both of those scripts. Great. Everything is now on the blockchain. Let's take a look at a front end that actually implements this. Have a little code sandbox here.
02:47:35.640 - 02:47:36.390, Speaker A: Cool.
02:47:36.840 - 02:48:20.330, Speaker D: Wi Fi. All right, so this is a very basic react application that I forked from my friend Steph, who did a version of this in Bogota. But here what we're going to do is claim our soulbound token on Polygon Mumbai. All you have to do is make sure you have your Polygon ID wallet that you issued yourself a claim that has your date of birth. Then you scan this. So rather than me taking out my phone and doing this here and you not being able to see it, I'm going to show you a video of me doing this earlier. This is like, okay, come on, WiFi.
02:48:20.330 - 02:48:30.146, Speaker D: Great. So this is my polygon ID wallet. I've opened it up. I already have my claims. I scan the QR code. It generates a proof request. So I hit continue.
02:48:30.146 - 02:49:12.882, Speaker D: It's going through creating the cryptographic proof, and it wants to connect to a wallet. So I'm going to connect it to my MetaMask wallet. And through MetaMask, I am just going to make sure that I connect to the actual website. Once I'm connected to the actual website, it's going to fully generate the proof to make and do that check. After it does that check, the last thing it needs to do is actually mint the NFT. So we're going to go back to MetaMask, which will just pop up and now actually approve the transaction to mint the NFT. So I hit go ahead and confirm that transaction to Mint and once that has been minted, pay some gas confirm and it'll finish up the process here.
02:49:12.882 - 02:49:49.178, Speaker D: So you'll see over here on my polygon scan link, about 7 hours ago, I successfully minted this NFT. Success. And this is the NFT on Openc right now. So on Openc testnets, you can check out 13 check number one, verify 13 or older. You cannot transfer this to anyone else. This is only available in the wallet that this was minted in. But now what do I do with this? Right? I have this specific NFT now with a proof that I am 13 years of age or older.
02:49:49.178 - 02:50:14.054, Speaker D: Great. It's wonderful. So now I can do really cool things with it. Token gated access to social apps built on Lens. You had the whole problem that I mentioned before with Instagram, with Twitter. Do you want to keep sending them your date of birth over and over again on every single platform that you're on? You're sharing your data across all of these platforms. At times.
02:50:14.054 - 02:50:41.920, Speaker D: If they need to do some deeper verification, maybe you're asked for an. Why? What is the need to go into all of that and share with them that data using this specific NFT? They don't need to know your date of birth. They know that this was issued by Polygon ID through an issuer that they trust. In this case, it was just us. But if it was done through an issuer they trust, then they know that they don't need access to your information. They know that you own this NFT. You get access to the platform.
02:50:41.920 - 02:51:16.138, Speaker D: You never have to share your actual age with social media platforms ever again. Just a verification of the fact that you are old enough so you're only sharing information that they need to know and nothing more than that. And you own your data and you're not actually going forward and sharing all of it. So I wanted to make sure you have some additional resources. This is a new thing, a new concept to kind of like learn. These will also be put into the discord. So first, definitely check out Steph's original Polygon ID workshop from she's here.
02:51:16.138 - 02:51:53.814, Speaker D: And you can definitely dive a little bit deeper into that as well. There are two GitHub repos from Steph and one of our teammates, Manny. Both of those go into using this with ERC 20 tokens, as well as another example with NFTs. Manny's GitHub also lists some potential error messages, common things that you might run into while you're going through and building all of this. So definitely take a look at that. And the last thing will be the polygon ID docs and tutorials that you definitely want to go through. So while going through this, I remember I forgot to actually go over one thing.
02:51:53.814 - 02:52:16.080, Speaker D: So we're going to go back to the front end, just so you're aware of what that one thing is. Very vital thing for you to actually do this. So let's go back.
02:52:23.210 - 02:52:24.550, Speaker A: Where'S arc.
02:52:27.390 - 02:53:15.578, Speaker D: Okay, so how did I actually make this QR code work? I never told you that part. So in this react application, we're just using this QR code generator to generate a proof request, which is just going to be a JSON object with a bunch of information. A bunch of it, again, is going to be boilerplate code. Once you go to this link over here, it'll tell you exactly what you need to fill out. Some of it is going to be information from the claim that you issued. So you have to make sure you have that in there properly as well as the actual deployed contract address, which I added up here and use as a variable down here. But all of this information needs to be put into your QR code.
02:53:15.578 - 02:53:59.320, Speaker D: So you take this JSON, put it into your QR code, and that's how this is generated. You scan that with your polygon ID wallet. It reads all of this information, including the contract address, as well as the type of credential that it needs to verify. And that's what's going to kick off the whole process for doing the NFT Mint. So all of that is going to be available on this link over here on the polygon ID GitHub, which will go through the query language on how to create this specific query. Throughout the weekend. Myself and Steph will also be here, so we'll be able to help you with any further questions that you may have as well.
02:53:59.320 - 02:54:25.520, Speaker D: But again, these are some of the resources. I will send them in the discord after this so that you have them and you don't have to take a picture and retype it or whatever. I'll also send these slides. Recording of this will also be available. If you did enjoy this workshop, please let us know. We're at zero x polygon devs. I'm also at Rahat codes and there's a couple of minutes left for questions anyone has.
02:54:25.970 - 02:54:26.720, Speaker H: Yes.
02:54:41.860 - 02:55:35.440, Speaker D: I mean, ultimately the security of your wallet is up to you. So this does not solve for that specific problem. There are cool things in the works like account abstraction and things like that that'll hopefully help with things like that. So that might be a good way to combine polygon ID with an account abstraction project. So right now this is all on testnet, on mainnet. There is an implementation with the polygon dow and through the polygon dow there's verification for like age credentials and things like that so that is possible. So as we roll out and put this into mainnet we'll be able to give you more information on that.
02:55:43.000 - 02:55:45.910, Speaker A: Create multiple different age.
02:55:46.620 - 02:56:32.898, Speaker D: So in this specific case I created claims myself just like to do the test. But the claims would have to be coming from trusted issuers. Right. So whoever is doing the verification has to trust this issuer. So if you're trying to go onto like a social media platform they might have specific issuers that they work with so they might say get yourself verified through this and if they say that you're good, you're good. Right, so that kind of like falls into that triangle of trusted issuer. Yeah.
02:56:32.898 - 02:57:35.350, Speaker D: So a lot of them will have to be centralized just because of the nature of what they're verifying. Like if they're verifying your passport ID for proof of personhood or verification of date of birth, that all exists on centralized servers. So it has to be from a centralized kind of like source of truth. But what we're doing here is taking that verification and allowing you to kind of control where it goes and only share the information with specific platforms that need it other than I would. So the polygon ID wallet is really just for the holding your claims but the actual transactions and everything that happens would happen in any wallet you choose. So in the demo I showed it went to my MetaMask wallet so that side of things the actual transactions will be with whatever wallet you have. The polygon ID wallet is really for holding your claims.
02:57:35.350 - 02:57:41.850, Speaker D: Cool question here.
02:57:49.180 - 02:58:03.280, Speaker A: Claims foundational one like for example, that when you walk up and let's say whatever country and your date, then they would check those two claims.
02:58:04.920 - 02:58:09.270, Speaker D: Yeah, something like that would definitely be a really good use case. Yeah.
02:58:11.560 - 02:58:15.296, Speaker F: Talks about an alliance of trusted.
02:58:15.328 - 02:58:18.296, Speaker A: Issuers such as say I wanted to.
02:58:18.318 - 02:58:22.792, Speaker F: Trust a collection and maybe I trust.
02:58:22.846 - 02:58:25.400, Speaker H: The alliance and then that alliance.
02:58:27.340 - 02:58:27.656, Speaker D: So.
02:58:27.678 - 02:58:30.010, Speaker C: That it allows decentralization yeah.
02:58:34.220 - 02:59:03.730, Speaker D: I don't know the specifics around that but I think that's a very good thing to be working on. I don't know the roadmap for how Verifiers will work in the future. Yeah, cool. Any other questions? No, they just need to trust that the issuer will do their job correctly.
02:59:05.590 - 02:59:14.030, Speaker A: How much is there a possibility?
02:59:22.110 - 03:00:09.050, Speaker D: Yeah, the example I showed here was like doing some on chain verification with that NFT, but you could bring in something like ENS. Like this is a person verified to have some ENS credential or whatever and bring that as like a claim so that as we kind of build out the issuer side of things, these are different use cases you could potentially bring in. Cool, well, thank you all for coming out today. We'll be around for any further questions. We also have like exclusive hoodies since you stayed all the way till the end. If you want to grab some, we have them outside. I lied.
03:00:09.050 - 03:02:56.710, Speaker D: Yeah.
03:03:10.620 - 03:03:17.050, Speaker B: How are we doing with time? Did you say we're a bit behind. Okay.
03:03:19.660 - 03:03:20.410, Speaker D: Sure.
03:03:24.920 - 03:03:56.460, Speaker B: All right, we'll kick this off. Cool. Well, welcome everybody. This is the scale workshop and today I'll be speaking John Frost, I'm the solutions engineer. I run the validators help with the DAP integration and partner integrations. Part of this presentation is also going to be with Sawyer, who's over there to the left. He's part of the scale team.
03:03:56.460 - 03:04:43.432, Speaker B: He's a software engineer. And in the room we've also got some scale team members. So maybe you guys can put your hands up and I'm going to quickly go around. So we got Jack, we've got Jace, Nicole, Fabio, I'm sorry if someone's behind that light because I can't see you there's Connor. And yeah, so that if you guys have any questions, by all means come out, come to speak to any of the team members or go to the booth as well. Straight after this we actually have a lightning talk from well, actually no, 30 minutes after this we got a lightning talk from Jack. So I don't want to steal his thunder on scale and its overview, but essentially scale is the proof of Stake decentralized infrastructure platform that is EVM compatible.
03:04:43.432 - 03:05:36.140, Speaker B: There's a lot of key features like zero gas fees, it's very modular, it's very flexible and so forth. But the agenda we're deciding upon what we're going to discuss today and I just wanted to showcase a couple of things. The title is how to leverage scale tools to build zero gas fee DApps. What I wanted to do is just showcase how easy it is to mint and deploy NFTs on the scale chain. So I'll just do a deploy and mint. After that I'll showcase how you can actually put it up to the file storage. We've got a Gui for that, just uploading the ones that I've minted and I've got some traits, metaport, so that is essentially going from scale chain to scale chain, which is very new, just released.
03:05:36.140 - 03:06:04.880, Speaker B: And the second part is Sawyer where he'll talk about the Sfuel station, the scale chain UI dashboard, which is also very new. And we'll follow that up with Q A. So let's get to the good stuff as well. We've got plenty of prizes here and if you're going to impress anyone, you got Jace and Connor, who are the judges. Jace loves coffee. Connor espresso martini. Prizes.
03:06:04.880 - 03:06:53.728, Speaker B: We've got 5000. So that is for one DAP. Then we've got 8000 for Metaverse gaming NFT prizes, 2000 for partners. So that can be the graph connects any of our partners in our ecosystem. And then we've got 5000 for the prize pool which will be evenly divided among the teams. But I just wanted to highlight some important links as you guys kind of go through hacking. And specifically on obviously scale, we've got the hackathonscale network that includes the documentation, some Endpoints, S, fuel and fire storage scale space that is essentially like developer Docs, that's just kind of our general website, the blog.
03:06:53.728 - 03:07:23.920, Speaker B: And you've also got Discord, where you can just reach out to us. You've got GitHub, so that's the scale network. So that's just the public repos with a lot of readmes. And then you've also got our Stats Page, which is a lot of statistics and metrics that keep going up, which is awesome. So let's kind of kick this off. So this is the demo that I wanted to showcase today. I'm going to close this presentation down and just showcase two things here.
03:07:23.920 - 03:08:02.424, Speaker B: So on the left we've got Block Scout, which is a Block Explorer. And on the right hand side we've got the repo that I actually created for this event. And you guys can use it if you want to. The intended use, as I've kind of written here, is for this event. Sure, you can use it for other events, but the project set up, there's some requirements here. You can clone the scale, demo, just NPM packages, setting the environment variables there, creating a private key, s fuel, compile deploy. And then you're essentially just going to do the minting.
03:08:02.424 - 03:08:51.128, Speaker B: So it's a five step process, easy to get up and running for you. So instead of making you guys watch me download all these packages and whatnot, I've already kind of gone ahead and updated my env. You can see here that I've already done the deployment of the address right here. And just below it, what I'm going to do is essentially just mint some tokens. So what we'll do is I'll just run this and you can see and I'll bring up the Explorer on the left side. And essentially you can see look at these transactions are coming through right here. And what I've done is used MTM multitransaction mode and essentially minted these and you can see them in the Block Explorer.
03:08:51.128 - 03:09:25.612, Speaker B: So that's the creation. So I'm just going to refresh this and then essentially what it's doing here is you can actually see I'll refresh it again. And then you can see there'll be essentially there's 31 here. And let me open this up a little bit more and it'll be on the blocks. And then you'll essentially see the hundred that's there. So you can see I just minted 100 tokens. That's how easy it is and how fast it is to essentially deploy and mint some tokens.
03:09:25.612 - 03:10:05.260, Speaker B: On the actual minting. I actually created some special traits. You can add whatever you guys want to those essentially use your own. And one awesome thing that not many people know about scale, and I've got it on the shirt here too, is our file storage. So you can upload any asset you want to the actual scale chain yourself. This is a simple kind of overview of file storage and how it's decentralized. And it tells you about the space that you've got and it walks you through the NPM install.
03:10:05.260 - 03:10:51.568, Speaker B: But just on the right hand side you can see how you can upload files, delete files, create directories and so forth. So I did go ahead before and this is the GUI that we just released as well. So you can go here, you can essentially upload files here. And what I did is one of the NFTs I minted is you just selected here and you can actually see this one there. And then this is just essentially the traits and whatnot. So I brought that up before and you can actually see, hey, that's the color, that's the stamina and so forth. So that was the second part of the second part of the talk.
03:10:51.568 - 03:11:21.256, Speaker B: And then I'm going into the third part, which is the scale chain to scale chain. And this is the metaport. Again, this is something fresh and new that we've just released. This is our staging environment. As you can see. Staging V three right here we've got the dog chain which is essentially the origin chain, and then the cat chain which is the receiver, essentially cloned there. And you can click on these.
03:11:21.256 - 03:11:59.416, Speaker B: You got the Explorer, you got all the RPC, all that jazz. You can see MTMs enabled up here and I'll go back here. It's going to be exactly the same for the cat, the receiver and you guys can go here. So metaport, demo, scale nodes and you guys can play around with this. We've got a lot of cool stuff on the left hand side here, sandbox. So that essentially just opens up the widget for you to play around with. All this is just an interface whereby your application and you can implement the widget which I'll show you in a second onto your application.
03:11:59.416 - 03:12:19.564, Speaker B: But you got different colors, different whatever color you prefer there. This one I'm keeping on the NFT theme. You can see ERC, 721, 1155 there. But I didn't actually highlight these. So this is scale chain. To scale chain I'll click on these so you can just play around with these. You can go to the sandbox at the top.
03:12:19.564 - 03:12:57.416, Speaker B: You can do the wrapped ETH there. But yeah, going back here, for example, I am going to move from dog chain to cat chain. And you can do it back as well. But you can see there's the collection. I've got seven out of 100 there. If I do, for example, two and I want to move it, what you can see on the right hand side is the widget. So this automatically fills the chains in here and then also in the metals you can see this is token ID one, token ID two, token ID three.
03:12:57.416 - 03:13:23.340, Speaker B: And the amount, see, I just put in two. It automatically does two and then I just do the transfer and I. Sign for this confirm. And then what we can do is I'll refresh this, and what you can see it there, right there. So you can see two. That was the token ID one. So you can see that's transferred to scale chain.
03:13:23.340 - 03:13:58.620, Speaker B: And the awesome thing is here you can see the post incoming messages here. And you can see the two and then one. And if you want to, you can just send it back and essentially do the same process there. But if you guys just want to play around with it, use the sandbox and so forth. Lastly, I just wanted to highlight the repo for the Metaport that you guys can use. And this is the hackathon scale network that you guys can use here. Jace did a great job of just updating this recently.
03:13:58.620 - 03:14:30.132, Speaker B: It just talks about deploying on scale using file storage. And you just put in your endpoint there and your wallet, and you can get Sfuel and reserve some space. And Sawyer, I don't want to steal your thunder. This is essentially moving over to you with the Sfuel station. And I wanted to lastly, just show some awesome stats that we've got that's just refreshing here. You can see anyone can go to this. It's not as if it's internal.
03:14:30.132 - 03:15:01.132, Speaker B: You can see the total transaction count, the total gas fees. And that's going back to the initial point where Scal is gas free to just recap. What we did was we essentially deployed. We minted some NFTs. We moved those NFTs to file storage. You could see it in the GUI. And then you saw the metaport where I was just moving the NFTs between two different chains.
03:15:01.132 - 03:15:17.690, Speaker B: So I'll end it there on my half, and then Sawyer will take it away with the rest of the community tools. And we'll have Q A at the end, and I'm going to invite Connor up to help with that as well.
03:15:33.190 - 03:16:15.650, Speaker E: All right, everybody, I'm Sawyer. As John mentioned, I am part of the solutions engineering team with Scale, and I'm going to follow up on the amazing kind of technical pieces available to the scale network and talk a little bit more about the tooling that's available and how you can use it to make amazing zero gas fee DApps on scale. So to start off, user experience is key, right? So blockchain. Everybody knows whether you're a user or developer. It's really complicated. Still, a lot of people are doing amazing things to simplify that. But ultimately sorry, guys, I just put the head on accident.
03:16:15.650 - 03:17:03.866, Speaker E: Simple onboarding is a common trait in web two. Not so much for web3. Anybody ever asked their parent or their grandmother to use MetaMask? It's not so simple. Additionally, web two, whether it's the Twitters or different Gmails and stuff like that, generally they're free to use, right? Or at least they have a freemium option. And lastly, they use just common things to onboard, whether it's email or text, right? You get your codes through things that everybody has, or at least most people in the world have them. Web Three, on the other hand, most blockchains require constant payment just for usage, right? Gas fees and all sorts of things there you're constantly getting chipped away at. Additionally, while we have this bleeding edge technology, crypto wallets are not really friendly to the average user.
03:17:03.866 - 03:17:42.670, Speaker E: And so what I'm going to talk about kind of throughout the rest of this, is one of the key components of scale, which is not just the tooling in general, but more specifically Sfuel. So Sfuel is, as many of the scale people know, one of the things I love, because I've worked on it quite a bit, and you can actually see that top left picture is the S Fuel station that John alluded to earlier. And it's kind of the precursor to Sfuel. So Sfuel is not gas. It actually stands for Scale Fuel. And it effectively represents the ability for any user to transact on any scale chain entirely for free. They do not have to pay money.
03:17:42.670 - 03:18:28.460, Speaker E: And that's a really, really big statement following that up. With Scale's Infinite scalability, you effectively have the ability for any user anywhere in the world to use a scale chain entirely for free at any time, as long as the service is there and they're running on scale. That being said, getting started with scale is kind of similar to many other blockchains, except we have some way cooler tools, in my opinion, because I built a lot of them. The File Storage UI I did not build, but the Sfuel station and the scale chain UI I did build the original versions, and I'm very proud of them. And I'm going to talk a little bit about them here in greater detail. So the Sfuel station and I have a little video here. We're going to hopefully make this work, maybe.
03:18:28.460 - 03:18:46.952, Speaker E: There we go. Okay, it's running. So you can see MetaMask or Rainbow Kit is popping up and I'm automatically connected. Just like that. My wallet's connected. I click Fuel wallet, which is that little black box. My address is in the field and we should see a spinning wheel in a second.
03:18:46.952 - 03:19:12.928, Speaker E: There might be a little delay. There we go. And now I'm changing the theme because I love dark mode, because I'm a developer. But if there's light mode, or if you like light mode, it's there for you. And there we go. We can actually see I know it's a little bit small, apologize, but what that little green text on the bottom was, was the list of chains that you actually just got filled up on with squel. It was cryptoblades scale community chain.
03:19:12.928 - 03:20:05.440, Speaker E: The Clips NFT hub, Europa Liquidity Hub and the Razor Network. And so what this basically means is, as a right, instead of having to go to Coinbase or go through a Fiat onramp or Binance, whatever, it may be purchase ethereum or some other token, transfer it out to a wallet, and then get started with DeFi or NFT Marketplaces. You can just go to the Sfuel station, connect your wallet, fill up, and go start using one of these DApps that does not require you to effectively be blocked by a paywall, because Scale basically removes that blocker, right? It's a community tool, which is really amazing, takes about three clicks, fully open source, and overall, it's just kind of that first step in a really smooth onboarding experience to the scale network. That's kind of the user experience side. Now, on the other side here sorry, there we go, is the scale chain UI.
03:20:05.600 - 03:20:05.972, Speaker H: Right?
03:20:06.026 - 03:20:28.460, Speaker E: So clean user experience really important for a blockchain. But on the flip side, I'm a developer. Building on most blockchains is really, really difficult. Most of the tools are either lacking in documentation, they're half baked, they don't work, whatever it may be. I won't lie, the scale chain UI is a little bit half baked. I'm the one that built it. It's currently undergoing an entire facelift, which I'll show you some mockups in a second.
03:20:28.460 - 03:21:21.816, Speaker E: But I'm going to use a couple analogies here to kind of explain why this tool is so important to the scale ecosystem. Scale chains, you can have a lot of them, you can technically have an infinite amount of them, and they can all connect together. And the cool part is they're actually effectively DAP chains, right? So technically, every company in the world could have their own scale chain if everybody wanted to use scale, which would be awesome. That being said, not everybody is technically minded in blockchain or in scale technology. Right this second, to be able to get going right away, the scale chain UI takes all this complexity and basically abstracts away for the scale chain owner or for the user that's in charge of setting up the chain for the company or for the DAP or for the project. It does this by basically taking all the amazing smart contracts built by the core engineering team at Scale and putting a nice GUI on top of them. I've basically alluded it to Web Three ops.
03:21:21.816 - 03:21:39.120, Speaker E: So for any of the engineers here DevOps. I hate DevOps. I'm not a fan. It's basically the DevOps for Web three. It's kind of taking all that functionality of administering something and putting it right in your hands. That being said, the pictures are small on purpose. It's really ugly.
03:21:39.120 - 03:22:22.720, Speaker E: I'm not a front end developer, but where it's going is somewhere more along the lines of this, which still a little bit small. But one of the product designers at Scale was amazing. Helped kind of redesign this. We took feedback from a whole slew of community members, and over the course of the next couple of months, we're actually going to be basically rebuilding the entire thing from the ground up. We're going to get more community members involved. And what we're going to effectively do is build the best administrative kind of tool available so that anybody, regardless of technical ability, can come to the scale network. Use this tool with their new scale chain that they just got spun up and deploy on scale.
03:22:22.720 - 03:22:51.812, Speaker E: And a couple more pictures you guys can see Multi SIG wallet. Multi SIG is really good for security, right? There will be a whole currently there is an abstraction for it, but like I said, not that pretty, that's much nicer. And then scale chain manager. Things like multi transaction mode that John showed off earlier, you can actually toggle that on and off. Doing it requires touching a smart contract. In this case, connect madamass, click a button. So things like that can just be abstracted away much simpler.
03:22:51.812 - 03:23:17.570, Speaker E: And lastly, I just want to say thank you to everybody. It's a pleasure to speak. And like I said, these are community tools that I'm showing off. If you're a developer here this weekend and you're not really sure what to build, instead of building a DAP, try building a tool for the scale network because there's plenty of stuff left to build. Thank you. All right. I think it's q a time now.
03:23:17.570 - 03:23:32.400, Speaker E: So if anybody's got questions, please feel free. Any machine learning applications? That is a good question for Connor.
03:23:44.340 - 03:23:47.810, Speaker A: There's a scale model.
03:23:54.000 - 03:23:55.150, Speaker E: Anybody else?
03:23:57.040 - 03:23:57.790, Speaker A: Yeah.
03:24:06.740 - 03:24:42.350, Speaker E: Absolutely. So, kind of a loaded question. But to simplify effectively what scale is, is a whole slew of EVM compatible blockchains that are run entirely by their own set of validators. There's not one validator that is run by the core team. Everything is run by external parties. Additionally, what's really cool is the scale network actually has smart contracts on the Ethereum Main net. Those smart contracts actually control which scale chains are effectively using which nodes, and it automatically handles the security and the rotation and things like that.
03:24:42.350 - 03:25:21.450, Speaker E: And so that's kind of the scale network in a nutshell. It's infinitely scalable because ultimately with the external validator set as more validators come on, right? You can basically keep adding blockchains. And because every blockchain is effectively its own blockchain, it's not necessarily contingent on the throughput capability of another chain. So let's say your buddy has an app that's doing 10 million transactions a day, but you're only doing 500. Your transactions are not getting slowed down by his chain because you're on your completely own separate chain. So that's why infinitely scalable. Just keep adding chains if we need to.
03:25:21.450 - 03:26:03.890, Speaker E: There's kind of two sets of security pieces here. I'll do my best to explain. I'm definitely not the expert here, but there is a huge chunk of security tied into the Ethereum Mainnet contracts from my understanding here. Additionally, there's some amazing engineering stuff going on under the hood with the BLS encryption and kind of the scale consensus model with the external validators. That effectively is another layer of security so the side chains effectively have one layer of security, but then the ethereum mainnet effectively acts as kind of an overarching model as well. In case something did happen. It's kind of the best way I can explain it.
03:26:05.940 - 03:26:44.184, Speaker A: I was just going to sum it up for you. So scale chains wise, we're horizontally scalable. So you continue to add more scale chains as your network grows and that's the demand side of the network and the supply side, which is also the decentralization is coming from the validator. We currently have 150 plus nodes running the network and those are able to be fractionalized or Sharded, which is a label to support all those nodes for pool security model that ends up balancing back and forth. That as. More chains are spun up and that demand grows. More tokens are deposited to the network, which incentivizes validators to build more nodes, which creates more capacity.
03:26:44.184 - 03:26:54.750, Speaker A: Horizontally scaling. So I guess the question here is Sharding.
03:26:57.010 - 03:27:00.090, Speaker H: So how do you guys handle Sharding.
03:27:00.170 - 03:27:22.980, Speaker A: And being able to keep up with not just linear? Yeah, it is linear. So if the network is running out of capacity, it costs more for your chains and incentivizes creates more capacity. The networking grow literally.
03:27:23.060 - 03:27:24.440, Speaker H: Each chain cannot.
03:27:27.020 - 03:27:39.730, Speaker A: Work some degree for running labor. Would you use scale on an IoT network?
03:27:40.350 - 03:27:51.786, Speaker B: It the specs I would need to look, we've got it all written down. If you're interested in becoming a validator, speak to the man directly in front.
03:27:51.808 - 03:27:53.040, Speaker D: Of you and myself.
03:27:53.570 - 03:28:03.040, Speaker B: But yeah, there is obviously some hardware requirements that you need for that list. It all there.
03:28:05.350 - 03:28:08.370, Speaker A: So you mentioned there's no gas fees for triggering.
03:28:11.830 - 03:28:15.534, Speaker H: Could there be a possibility of malicious.
03:28:15.582 - 03:28:18.660, Speaker A: Actor just triggering something and bottom down.
03:28:19.750 - 03:28:21.890, Speaker B: You can do rate limiting.
03:28:24.170 - 03:28:24.726, Speaker A: Situation.
03:28:24.828 - 03:28:46.140, Speaker B: So for example, when I did my demonstration, I did it in different blocks. You can definitely change that. It's up to you in terms of the rate limiting and what you want to do there. But yeah, to prevent DDoS, that is a concern and we don't want users to be taken away.
03:28:46.910 - 03:29:32.940, Speaker E: Basically, that was part of the reason for the S Fuel station design is the way the smart contracts behind that are running is they actually limit how much S Fuel can be given to any one user. So on top of the built in rate limiting and security of the network, basically we've built a whole set of abstractions for the developer as well to try to basically limit the amount of S fuel a user has at any given time. Ultimately it's technology. Someone might be able to get around it if they try hard enough, but the way correct. So a lot of different security measures, everything kind of stacked together makes it a pretty secure system. Anybody else?
03:29:34.350 - 03:29:41.040, Speaker A: Yeah, I'm wondering, is there any incentive, reward for the validator? I try to connect.
03:29:42.930 - 03:29:43.886, Speaker G: The benefit of.
03:29:43.908 - 03:29:51.920, Speaker A: Becoming a validator and right now the network is gas fee and where the reward comes from.
03:29:53.030 - 03:29:53.394, Speaker D: Yeah.
03:29:53.432 - 03:30:26.620, Speaker B: So the validators are paid in SKL that is different to Sfuel. So essentially what you would do is we're trying to have this self serving model as well in the future, but essentially what happens is you would pay the validators and then they would spin up the scale chain, which is essentially made up of 16 nodes in that situation, and that would pay the validators in that situation. And then fabio, did you want to add anything?
03:30:27.790 - 03:30:39.440, Speaker A: I can hop in there. So pretty much you're prepaid for computational resources. So instead of paying as you go as gas fees and it is like kind of traditional blockchains right now.
03:30:42.930 - 03:30:43.306, Speaker E: You'Re.
03:30:43.338 - 03:31:01.720, Speaker A: Actually prepaying for scale chain. You're aggregating all that computational power, and then that's getting put into a bounty pool, which then gets distributed to the validators over their instead of happening at that transaction level, it's happening at a rental level from the developer early on.
03:31:06.160 - 03:31:06.728, Speaker E: Awesome.
03:31:06.834 - 03:31:07.490, Speaker B: Questions?
03:31:08.020 - 03:31:08.770, Speaker D: Yes.
03:31:09.140 - 03:31:42.416, Speaker E: Anything else? All right then. Yeah, go ahead. I don't think you need less nodes, you need less resources. Right. So the cool part about the scale network as a whole right now is recently the hub model has been introduced. The hub model is basically shared DAP chains. So instead of you only need 5% of a scale chain, you have a whole scale chain.
03:31:42.416 - 03:32:17.900, Speaker E: We're wasting 95% of those resources as a whole. You can take 5% of a shared chain, which is a hub. So right now there's four hubs planned. The Europa hub, which is live, which is liquidity hub, the Calypso NFT hub, which the chain is live, and it's kind of been moving and pieces are coming together, the Nebula gaming hub, which is on the way, and then the scale community hub. And so let's say you build a DAP this weekend. You want to deploy it and you fit into one of the three kind of areas, or you're a bit more general, but you don't really need all those resources. You can say, hey, I want to go on a hub, and you have your sliver of the resources.
03:32:17.900 - 03:32:32.250, Speaker E: Awesome. Well, there's nothing else. Thank you everybody so much, and all the scale members and myself be here all weekend and please come up if you have any questions.
