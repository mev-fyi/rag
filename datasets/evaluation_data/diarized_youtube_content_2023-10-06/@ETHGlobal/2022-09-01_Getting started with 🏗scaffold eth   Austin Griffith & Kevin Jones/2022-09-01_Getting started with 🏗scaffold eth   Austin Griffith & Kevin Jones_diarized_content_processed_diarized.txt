00:00:06.410 - 00:00:27.670, Speaker A: All right, we are live. Good morning, good afternoon, good evening. Depending on where you're calling from, we have a really exciting workshop featuring Austin and Kevin doing a joint workshop on getting started with Scaffold ETH. Questions go into the Zoom chat if you have any. And with that being said, I'll pass the mic off to our two speakers is awesome.
00:00:27.740 - 00:00:40.902, Speaker B: Thank you for having us. I'm Austin Griffith. Here's Kevin shutter block. What some of this? Some of what? Some front rows. All right, here we get. Let's dive right into it. Kevin, thanks for being here.
00:00:40.902 - 00:01:23.986, Speaker B: Just in case I go into labor and I can't be here, kevin was here to back up, but we're going to do a dueling keyboards, dueling banjos kind of thing. GM in the chat. First thing I want to show off is scaffold ETH. Okay? So we're going to do a quick, like, five minute intro to what is Scaffold ETH? And then what did I do? And then Kevin will take over, and we'll build something quickly, and we'll deploy it, and then I'll build something to maybe try to attack it and play around with that. Okay, so scaffold ETH. Scaffold ETH is a starter kit you're about to take over and start building something for the next month for ETH Online, the Hackathon Stack. The hackathon stack is scaffold ETH.
00:01:23.986 - 00:02:01.646, Speaker B: You can use Scaffold ETH to quickly prototype an app. It helps you kind of get a feel for how your solidity works and helps you deploy something quickly and get that in the hands of other folks. Can we hit admit for all these folks that are coming in? Is it okay if I'm hitting admit and just allowing people in? Hope that's cool, because I'm just admitting people. Okay, here we go. Let's see. The first thing I want to show off is how you can live edit your smart contract and how it will auto adapt. So with Scaffold ETH, you'll follow the instructions here, you'll clone it down, you'll do a yarn install, you'll do a yarn chain, and that will fire up your hard hat node.
00:02:01.646 - 00:02:50.574, Speaker B: Then you'll do a yarn start, and that will fire up your front end react app. And then you'll do a yarn deploy. Yarn deploy right here, and that will deploy your app locally to your local blockchain. Now, this is where it gets interesting, because we can do an Atom and we can edit our smart contract here, and we can see our interface for our smart contract over here. And this is the initial kind of setup that you want to have with Scaffold E. You want to be able to add something to your contract, like an address, public owner, and set it equal to whoever this dude is right here. And you want to be able to do a yarn deploy.
00:02:50.574 - 00:03:17.946, Speaker B: Oh, man, I need to kind of have this organized a little bit more and do a yarn deploy over here. And this is going to deploy your app to your local chain. And notice this auto adapts to it. That's the key I'm trying to show here is you add something small to your contract and then you see it show up over here. Let's change that owner to this address for some reason and do that deployment again. And now watch over here as this should change. Actually we'll get a new contract and that red one will move down there.
00:03:17.946 - 00:03:59.100, Speaker B: Okay, cool. So we're in this live kind of feedback mode where we can change something quickly in our smart contract and we can interact with our smart contract. So this contract object right here is really nice because it auto adapts to whatever you've added to your smart contract. So let's just look at this contract real quick. We've got an event, we've got some storage here, right? So this is a string purpose that's stored in the smart contract basically on all the nodes, on all the network. That's why it's so expensive. And we have a set purpose that lets us set that value, right? So over here, if we wanted to go ahead and try to set that purpose, I'm going to grab some funds from the faucet and I'm going to say hello world.
00:03:59.100 - 00:04:25.966, Speaker B: And that should let me set that purpose, right? And let's add something a little bit different. Let's go back to our address, public owner and set it equal to this guy again. Okay. And then let's create a require statement. Probably one of the first things you learn when you're building something in Solidity is a require statement. And the second thing you learn is global variables. One of those main global variables is message sender.
00:04:25.966 - 00:05:04.410, Speaker B: You can learn this by looking at globals, solidity, globals, right? We can go find where these are. And this is kind of how you kind of get started working. You kind of have this iteration cycle where you can make changes to your contract and you have reference material like the Solidity docs and Solidity by example. And you kind of grab things from over here and paste them in over here and kind of get them to work. So right now we're looking at message sender and we want to make sure that the message sender is equal to the owner. Or we're going to throw some message. We're going to say not the owner, right? And we'll go ahead and save that and we'll yarn deploy.
00:05:04.410 - 00:05:29.794, Speaker B: And so that is going to set us up with a smart contract where only the owner should be able to set the purpose. So let's try a hello world and hit send. And we are the owner. So it works. Okay, so here's where we're going to learn about burner wallets. If I open an incognito window, notice this account is kind of like this yellow and green guy. And if I hit new and I go to local host, I get that yellow and green guy again.
00:05:29.794 - 00:05:58.206, Speaker B: But if I open up an incognito window and I go to local hosts, I'll get a different account. See, now I have this kind of red account, right? So I'm going to give them some money from the faucet, and I'm going to go ahead and try to set the purpose. And it should say something like, not the owner. Awesome. Okay. So we were able to create a second account and attack our contract and prove to ourselves that this require statement is working. And that's kind of like the key piece that I want to get you started with.
00:05:58.206 - 00:06:27.634, Speaker B: With Scaffold ETH, you need to be able to experiment and you need to be able to test your assumptions. And this will help you kind of do that very quickly. The faucet, Kevin will show off Burner wallets. I've showed off the deploy script. Okay, so then actually I'll show that off in the next section too. Let's not worry about the deploy script. Right now we've got only owner and we've got okay, so I think now I want to hand this off so basically I can get into this mode where I can write this stuff all day and I can tinker with my smart contract.
00:06:27.634 - 00:06:49.406, Speaker B: The next step though is once you have something built, you'll want to deploy it to a live network. So I'd like to throw it over to Kevin, have him build something quickly, and then have him deploy it to a live network like Covan. And then I'll take over again and kind of interface with his contract. But there we go. We got it. Awesome. You want to go ahead and start talking too? I'll kick it off to yeah, absolutely.
00:06:49.508 - 00:07:49.982, Speaker C: So, yeah, I've basically gone ahead and I've checked out Scaffold ETH, and I've already kind of spun up hard hat in this top left corner and I've already spun up React in the top right hand corner. So what I want to do now is actually just load up the smart contract and we're going to kind of just gut it a little bit, right? We're actually not going to be doing the unstoppable apps. We're not going to be setting a purpose for the smart contract. What we're going to do is we're actually going to build a smart contract from the ground up, right? And what we want to do first is basically create a mapping. We're going to create a bank. We're going to create this bank that kind of like stores value, and we can actually utilize the smart contract to keep track of the balances of who interacts with that. So one of the things you'll learn with Solidity is you might want to create a mapping where you map one variable to another variable and keep track of that, right? So we're going to take the address that is coming through and then we're going to map that to a uint, right? Integer right? And then we're going to make this publicly available and we're going to call it balances.
00:07:49.982 - 00:08:54.518, Speaker C: So this is going to keep track of all of our balances, right? And then what we want to do is create another function that is going to be a deposit. So we're going to say function, we're going to call it deposit and on this one we're going to make it public and we're also going to make it what's called payable. And the payable function is exactly that. It's just a function that can not only be called in the transaction but it can also receive some value, right? Austin talked about global variables and one of those things is the message value which is how much value is coming through in the transaction. So what we're going to do is just allow someone to call that if they make a transaction and then we're going to take the balances of that particular message sender which is whoever's calling the actual contact contract and then we're going to add to their balances, right? And we're going to do that by inspecting what the message value is for that. So let's go ahead and do that. Let's save this contract and let's go ahead and redeploy and we can just do a reset just to make sure that we get a new instance of the contract and let's load it up and see.
00:08:54.518 - 00:09:26.186, Speaker C: We should have a completely new transaction that was deployed. Looks like it worked and bam boom. So now we have a new contract and we have a balances function which is basically just to look up the balances of a particular address and we have a deposit function. So Austin already showed that you can just quickly grab some funds from the faucet but let's grab some more funds. This is only going to give us 0.1 Ether. We actually want to grab a little bit more than that so we can just click that little thing there and actually copy the address and then we can come down here to this I guess larger faucet and we can grab more funds.
00:09:26.186 - 00:09:53.878, Speaker C: So let's paste that address in here. We can switch this to Ether and then we can grab like ten ETH from the faucet and this is going to pull funds from hard hat and put them directly into our burner wallet that we have in the browser. You could also do this with like MetaMask if you had MetaMask there. But you see now that we have ten Ether which is a total of almost 15 and a half. So now I can do a deposit. I can say, well, I want to deposit one Ether. And you'll notice here that whenever you're transacting on your smart contract you need to do it in way.
00:09:53.878 - 00:10:19.202, Speaker C: There's this cool functionality right here that allows us to do the math which is basically going to calculate how much way that we're putting in here. So if we were to put in 0.5 ether we could click this and it would translate to how much way we need to send in the deposit. But we're going to do one whole ether. So let's do that and then let's send that. And we can see that it was successful and we can see now that the smart contract received some funds, received some value. So it's got some value.
00:10:19.202 - 00:10:55.402, Speaker C: It used to say zero, now it's got some funds. But we made a mistake. We didn't have a withdraw function here. So we need to actually add that, right? So let's go back and let's add the withdraw function. So for this one we're going to do function withdraw and we're going to make this one public as well. And then for this one we're going to do message sender. So this is the person that's calling the function and we're going to do what's called a call, which is basically when you want to extract a value from the contract, you do a call and we're going to send in the value of that call as an amount that is going to be taken over in the smart contract.
00:10:55.402 - 00:11:30.866, Speaker C: Okay? And then let's do this. And we need to take in that amount. So we're going to take UN 256 to take in the amount that we want to do and call that amount. So this function will allow us to specify how much we want to withdraw in that amount. And then we're also going to do what, we're going to make a little shift disclaimer. This is definitely not the way you normally do it but it's to showcase some shady stuff that you can do on ethereum. So we're going to do what's called unchecked which is basically just going to not validate, I guess the syntax.
00:11:30.866 - 00:11:49.406, Speaker C: I don't know, maybe you can explain that a little bit better Austin. But we're basically going to update the balances after we actually do the call, which is probably the most important function or I guess thing of the function that we're doing. So we're going to take this and specify the amount and I think this.
00:11:49.428 - 00:12:11.442, Speaker B: Is always a weird thing. Yeah, you want there we go. And unchecked and then yes. Okay, so there's two things happening. We're doing unchecked math and that means that if you roll over or you cause overflow it's not going to throw an error. Basically you see that we have solidity eight here. Solidity eight is going to bring the safe math safety stuff automatically.
00:12:11.442 - 00:12:51.250, Speaker B: And so by doing unchecked we're going to allow for us to do some unsafe math. And in combination with the fact that you're doing a call and then you're updating your state, that's basically a reentrancy. Any smart contract people out there should see that we're updating our state after we're doing our external call which makes us exposed to reentrancy. But then on top of that we're doing some unchecked math. So if our balance is overflow, it allows us to do that. So both of these two in combination are going to make it exposed to a reentrancy attack. And we're going to go ahead and pull that off in a little bit.
00:12:51.250 - 00:12:56.914, Speaker B: Looks like you're about to add your deposit function. Go ahead and do that first and then before you switch over to me. Oh, and we still got to deploy this whole thing, too.
00:12:56.952 - 00:13:18.950, Speaker C: Yeah, we got to deploy it. So let's keep going. Sorry, we're getting there. This is the fun stuff. All right, so we're also going to call the deposit function on the receive I guess not the fallback, but the receive function, which is just the default receive function so that when someone does call that they'll also in turn call the deposit function. That's where those funds will go so that we keep track of the balance.
00:13:19.110 - 00:13:31.578, Speaker B: Which means that you can yolo money directly to the contract's address from your wallet without calling the deposit function, and it will automatically deposit on your behalf and mark it in the mapping as part of your balance.
00:13:31.754 - 00:13:42.382, Speaker C: Right. So now we got a new field. We got the withdraw function, right? So we got the funds here. The contract is empty. So let's go ahead and deposit another ETH.
00:13:42.446 - 00:13:48.530, Speaker B: Let's do sending it directly to it instead of depositing it. Grab the address and use your wallet.
00:13:49.110 - 00:14:07.014, Speaker C: And then let's just go to the wallet. Oh, sorry, that's the wrong thing. That's not the right thing. So you go here to your wallet and I can say, oh, let's just send some funds here. Sorry, that's not the funds. We got to grab the address first. So let's grab the address for the smart contract, click the wallet, paste it in there, change this to ETH.
00:14:07.014 - 00:14:19.022, Speaker C: Let's send one whole to this smart contract. Send. Boom. And it was successful. I believe now that we can query that balances for that contract. Boom. So it kept track.
00:14:19.022 - 00:14:36.482, Speaker C: Okay, cool. So I'm going to leave that ETH in there. And we know that it's working, but now we need to deploy. So we have a smart contract. We've kind of attested the assumptions of what's going to happen, and we want to deploy it now. So the first thing you need to do with Scaffold ETH is you want to create a deployer account. So we're going to do what's called Yarn run Generate.
00:14:36.482 - 00:14:51.522, Speaker C: Yarn Run Generate is going to basically generate a mnemonic store it in your directory of your instance over here. You can see that it just appeared. It's basically the sorry, let me hide these panels. It's basically the password, right? The passphrase that's used to generate.
00:14:51.586 - 00:14:54.726, Speaker B: Never share that. Normally, yeah, we should share that screen.
00:14:54.828 - 00:14:57.158, Speaker C: But if you guys want to steal our test, eat that's.
00:14:57.174 - 00:15:02.122, Speaker B: Okay. You should actually delete that one and do another Yarn Generate just so we don't expose that.
00:15:02.176 - 00:15:03.438, Speaker C: All right, yeah, let's do that we.
00:15:03.444 - 00:15:12.638, Speaker B: Got Jabronis on this call. Who knows? They're going to drain us, generate a new one. Yeah, there we go. Now do a now we're going to.
00:15:12.644 - 00:15:22.254, Speaker C: Do a Yarn account, which is basically going to take that mnemonic account, and it's going to give us a QR code that Austin you're going to help me out with. Right? We're going to try to fund this with some COVID. So here we go.
00:15:22.292 - 00:15:22.606, Speaker B: Let's go.
00:15:22.628 - 00:15:27.254, Speaker C: Yarn account. It's going to give us a QR code, and hopefully you were able to scan that.
00:15:27.372 - 00:15:39.434, Speaker B: Yes. All right. Sending you $100 worth of Covan. Should be sent from a punk wallet at Punkwallet IO built with Scaffold ETH. All right, you should be good to deploy to Covan. Now let's try.
00:15:39.472 - 00:15:53.120, Speaker C: All right, so now we can do yarn deploy network Covan like this, and boom, we can deploy our smart contract to Covan because we're using that deployer account that Austin funded using that QR code.
00:15:53.490 - 00:15:56.618, Speaker B: It said, reusing your contract, do a reset.
00:15:56.714 - 00:15:57.134, Speaker C: Thank you.
00:15:57.172 - 00:16:01.694, Speaker B: For some reason, that contract already exists on Covan or something. I don't know.
00:16:01.732 - 00:16:12.354, Speaker C: We need a fresh yeah, it's because we were okay, so reset space network cover and like that. Yeah, that should work.
00:16:12.552 - 00:16:18.946, Speaker B: Wigglewog almost tricked us with Hard Hat deploy. There you go. That should give us a fresh one, right?
00:16:19.048 - 00:16:20.494, Speaker C: Yep, you're right. Good catch.
00:16:20.542 - 00:16:28.774, Speaker B: All right, let's see. You need to get your app working right. So you'd put your app on Covan. Should we go make a deposit to make sure that works?
00:16:28.892 - 00:16:56.186, Speaker C: Let's do that real quick. Let's go to the app. JSX file. So when you go to App JSX, it's basically the Scaffold ETH component, the main component for your app. All we got to do is come over here, change this to Covan, hit save, and then now our app, we should be able to refresh. And I've got my MetaMask account that I can sign in. I can switch to the right network because it detected now that the app is on Covan.
00:16:56.186 - 00:17:13.362, Speaker C: And I should have some play ETH in there. I do. Okay. So now I can actually because this network, because the smart contract was deployed successfully, it's on Covad now. So now I can deposit so I'll deposit one ether and send make sure we sign the transaction, make sure it's the right network.
00:17:13.506 - 00:17:14.514, Speaker B: It's Covan.
00:17:14.642 - 00:17:25.962, Speaker C: Covan. All right, here we go. So now I've deposited that ETH. Now it's processing. Obviously, it takes a little slower on a test network. Oh, while that's doing that, I'm going to do a yarn build. Yeah, sure.
00:17:26.096 - 00:17:27.146, Speaker B: You could get it.
00:17:27.328 - 00:17:32.140, Speaker C: So Yarn build is going to basically package it up in case we want to deploy it surge later, which we might want to do.
00:17:33.790 - 00:17:58.066, Speaker B: Another thing is verifying the contract, but you can do that in a little bit. Also, let's just make sure this balance works. It looks like there we got a response back there. We go. Okay, so you have one ETH locked in the bank on behalf of Crypto Mastery. And now our goal is you hand it off to me, go ahead and verify your contract and deploy your app kind of in the background. But hand it off to me and I'll take over and I'll start working on kind of an attack contract.
00:17:58.066 - 00:18:01.494, Speaker B: But you should hook me up with the address of that contract real quick.
00:18:01.532 - 00:18:03.270, Speaker C: I just sent it to you in telegram.
00:18:03.770 - 00:18:23.962, Speaker B: Okay, awesome. Okay, so let me steal the screen from you. Let's see. Okay, there we go. You got that guy there. You can see an empty contract, basically. So I brought in your bank, right? So I'm kind of creating a little interface up here since I want to talk to your contract.
00:18:23.962 - 00:18:56.082, Speaker B: I know that your bank has a balance. I know that it has a deposit function and a withdraw function. So what I'll do is I'll instantiate that bank here and let's make that public so we can see it. And then I'll have my constructor take in an address. Bank address, right, bank address, something like that. And then I'll go ahead and say bank equals. Now if I were to say new bank, this would be a factory contract and it would be deploying a bank contract.
00:18:56.082 - 00:19:33.314, Speaker B: But if I take that new out of there, then it's going to talk to an existing one at some address. There we go. So now we've instantiated a link from my smart contract to your bank, right? And then what I want to do is I want to have some function that we'll call attack, right? And it will be public payable. It will take in some amount and what will it do? Okay. So let's see. I think what we want to do is deposit. What do we want this to do? We want it to let's not let anybody call it first.
00:19:33.314 - 00:20:07.166, Speaker B: Let's limit this to only my MetaMask account being able to do this. So we'll do message sender must be equal to me or I'll say not Austin just to set it up so only I can do this attack function, I guess. Idk. And then what are we going to do? We're going to do bank deposit. So what I want to do here is I want to do a reenter and see attack. I want to deposit some money and then I want to withdraw it. And when I in the process of withdrawing it, it's going to call my receive function.
00:20:07.166 - 00:21:00.926, Speaker B: Then I'm going to have a little bit that I'm going to flip and say, okay, I've already attacked it and I'm going to withdraw one more time. So for one ETH withdraw, I'm going to withdraw two ETH and I'm going to steal Kevin's ETH from the contract, which is it takes kind of two mistakes. Basically, he has to have his reentrancy exposed and he has to have unchecked math. But we're going to try it out here. So I'm going to do a bank deposit of let's see, I'm sending value here, right? So I need to do message value. So I'll send money into the attack contract, and it will then take all of that money and immediately deposit it into the bank. And then it will immediately withdraw that same balance and the amount will be message value.
00:21:00.926 - 00:21:21.894, Speaker B: Okay. So at this point, I basically just put my money in and pulled my money out all in one attack. And maybe we should just save that and yarn deploy it first. Let me do a yarn generate on my side and a yarn account. Let's fund this guy. We're going to go straight to covan with this dude. We're going to be testing in prod here.
00:21:21.894 - 00:21:25.910, Speaker B: We only have 30 minutes total, so let me go ahead, Kevin. Were you going to say something?
00:21:25.980 - 00:21:30.540, Speaker C: Oh, double check your deposit. Someone mentioned that maybe it was a typo. And they're good.
00:21:31.390 - 00:21:44.990, Speaker B: S-I-T. Oh, man. Good call, right? Did I spell that wrong? Let's make sure. Thank you, Chat. Okay, there we go. So I need to send some covan to this dude. Maybe I already did.
00:21:44.990 - 00:22:08.754, Speaker B: Let's see. Just in case, let's send some more covan. Use a punk wallet here. Boop. Oh, yeah, I already sent some here, send some more. All right, so yarn compile, right? Let's make sure that recent change that I just put in there, it won't be ready to attack. We'll do a second step to attack, but let's do just a yarn deploy and put yarn deploy network covan.
00:22:08.754 - 00:22:38.330, Speaker B: Okay, there's an issue. The deploy script. I wanted to talk about the deploy script, and this error is telling me something about the deploy script. This constructor takes in an argument, so we need to put that in here. So in Scaffold ETH, you'll use Hard hat deploy and it uses these deploy scripts here and here's where you would put in an argument. And that's what we'll do. We'll put in I need your address, right? I need the address of contract.
00:22:38.330 - 00:22:57.794, Speaker B: There we go. So I'll deploy my contract kind of pointing at your bank. Let's see if it likes that. Oh, I think it's going to. I think it's going to. Okay, let's just see if we can deposit and withdraw all in one thing and make sure this transaction works. And then we'll add a little complexity to this.
00:22:57.794 - 00:23:01.926, Speaker B: We'll add an attack next. Okay, looks like it is.
00:23:01.948 - 00:23:02.086, Speaker C: Okay.
00:23:02.108 - 00:23:27.834, Speaker B: And then I'll do the same thing. I'm going to take my app notice. We've had like three different instances of Scaffold ETH here, all talking to the same contracts. That's just the power of composability, of ethereum. And I'm going to set this to covan and hit save. So now I should have a front end that lets me see my attack contract out on covan. We used a lot of burner wallets when we were doing local development, but now we're out on a public network.
00:23:27.834 - 00:23:45.122, Speaker B: So we'll connect our MetaMask, okay. And it's not even going to be an attack. Basically all this is going to do is do a deposit and a withdrawal and it should work. But let's just try it real quick. Let's just do 0.1 ETH and let's make sure this works. Basically, it's just going to deposit the money and withdraw it immediately.
00:23:45.122 - 00:23:59.546, Speaker B: We won't even be able to see without any events or anything. We won't even be able to see if this really worked. Another thing we can do is click on the bank and we can make sure that that One Ether is still there. Looks like it is. Well, what are they saying about Covent? Is COVID going to be depreciated too?
00:23:59.728 - 00:24:00.620, Speaker C: Oh no.
00:24:01.470 - 00:24:22.080, Speaker B: Off to gorli. I guess we're off to gorli. Okay, so it seems like our attacker contract at least can successfully deposit and withdraw 0.1 all in one atomic transaction. But here is where the magic happens. Here's where it gets really interesting. So let's just do this.
00:24:22.080 - 00:24:55.270, Speaker B: When we deposit it puts the money in and then the next step it withdraws the money out. And on the way out, it's going to land back in our contract and it's going to trigger this receive function. Just like Kevin was able to send money directly from his wallet to his contract and the receive function caught it and deposited it. We're going to catch that and we're going to do something here, right? We're going to execute. We're going to do some kind of execution here. So basically I just want to attack it just one more time. I want to put in one ETH.
00:24:55.270 - 00:25:35.270, Speaker B: I want to withdraw my ETH and then I want to withdraw one more ETH. And the way I'm going to do that is just set up a bool that's like has attacked and we'll set that to false, right? It'll start as false and then we'll say something like, actually, if we have attacked already, we'll do nothing, right? And if we haven't attacked yet, then we'll set has attack to true and then we'll do our attack. And our attack is incredibly simple. It just withdraws some amount out, right? And I'm just going to set it to one ether. I'm just going to hard code it. This is not the way to do this. There's a lot of little subtleties here that you could change to make this better or make this make more sense.
00:25:35.270 - 00:25:50.298, Speaker B: Hopefully it makes just enough sense to you as a scavenf builder that you can kind of follow this a little bit. But let's go see what's going to happen here. Hopefully this thing will compile. I'm just going to deploy it. We're just sending it. Just shit, I'm probably missing something. But let's see what happens here.
00:25:50.298 - 00:26:00.942, Speaker B: And we got maybe like five more minutes here. We got plenty of time. Okay, let's see what. Happens here. So your contract is still out there. We'll see this change too. There we go.
00:26:00.942 - 00:26:17.880, Speaker B: My contract just updated, so now I've got a new contract here. Did you verify your contract too? Can I go see it? Oh, very nice. Look at that. Verification. We can see the source code. Good work, dude. Okay, so let's steal this ether, right? That's the goal here.
00:26:17.880 - 00:26:29.240, Speaker B: Basically, I just put in one and I hit this and I hit attack. And it either works or it doesn't. Moment of truth. Here we go.
00:26:29.610 - 00:26:30.550, Speaker C: Drumroll.
00:26:31.770 - 00:26:45.646, Speaker B: It might work. It might work. Okay, here we go. Oh, you know what I didn't put on did I put a withdraw statement in here? I didn't. It's basically going to pull the money and it's going to land in my contract, and it's going to be locked in my contract forever. But that's okay. We're doing it.
00:26:45.646 - 00:26:57.034, Speaker B: That's fine, right? What I needed to do here is send the money to myself. The money is just going to end up getting locked in this contract. Let's do it real quick. We got time. Yeah.
00:26:57.092 - 00:26:58.002, Speaker C: Coded in.
00:26:58.136 - 00:27:28.780, Speaker B: Let's do function withdraw public. We only want me to be able to do it. Actually, we don't even care. We'll do this, we'll say anybody can call it and it just withdraws it to my address if anybody clicks here, right? Call and let's see. The value is going to be all the money in the contract. So we would do address this balance. Super weird line of code here.
00:27:28.780 - 00:27:47.410, Speaker B: That and I think sometimes people put quotes in there. Idk. Okay, so if someone calls the withdraw function, it is going to just send the whole balance of this contract to me. Let's see if that deploys. I'm not even checking. I'm not even, like, compiling. I'm just saying deploy it to covan.
00:27:47.410 - 00:28:11.254, Speaker B: Okay, so there's a little warning here that says that the low level return isn't used. Sometimes what you could do is you can set the result of this and you could set a require statement and require that send to be true. But we don't even care. We're yellowing here. There we go. All right, so now I have a new contract over here, and this one has a nice withdraw function. So if we steal money to it, we should be able to withdraw.
00:28:11.254 - 00:28:32.458, Speaker B: Okay, here we go. Moment of truth. Let's see if we can send in an ETH withdrawal and then on receive, grab another one back. Right? Let's see if this works and we'll know if it works. If well, our contract will have two ETH in it, right? Let's see what happens here. Please work first try. Here we go.
00:28:32.458 - 00:28:40.180, Speaker B: Come on. Reentrancy attack. Will it work? Will it work?
00:28:42.710 - 00:28:43.902, Speaker C: Contract is empty.
00:28:44.046 - 00:29:08.250, Speaker B: Look at that. The contract is empty, right? If we go here, yes. Okay, so what I want to do is I want to go to your screen and I want to show that you still have a balance. And I want to talk about the contract that you wrote and show people how to basically make it secure. Let's see one last thing. Maybe let's make sure my withdraw function actually withdraws it to me. And we have created a reentrancy attack.
00:29:08.250 - 00:29:34.446, Speaker B: Right? This will go up a tiny bit, hopefully. There it goes up to five. We were able to create the attacker contract, attack Kevin's contract, withdraw the money, and I'm headed to Mexico or something. I don't know what I'm going to do. Okay, kevin and I are going to Mexico. All right, here we go. So let's make this secure.
00:29:34.446 - 00:29:41.886, Speaker B: Let's fix our errors. So, first of all, no unchecked math. We want safe, right?
00:29:41.928 - 00:29:43.366, Speaker C: We want safe math. Yes.
00:29:43.468 - 00:29:47.830, Speaker B: First of all, if that ever rolls over, we want it to throw an exception.
00:29:48.170 - 00:29:57.420, Speaker C: Right? Update the balance first. You go, right? We want to update the balance first right here, because otherwise, something like that.
00:29:59.150 - 00:30:36.550, Speaker B: And again, we have safe math. So if they try to withdraw more than they have in their balance, it'll throw an error. And then if I try to reenter, my balance will have already been subtracted. So basically, that's how you fix this reentrancy bug by just simply doing things in the correct order and using safe math. I was going to steal the screen one last time for next steps. Okay, so you've figured out how to tinker with Scaffold ETH. You've built a few things you can kind of get in this iteration loop where you can deploy things even to testnets, let your friends share, and use your apps.
00:30:36.550 - 00:31:02.186, Speaker B: What's the next step? Where do you go from here? Even if you're out there and you're like, Dang, I don't even know where to get started with Scaffold ETH. There's a lot here. There's a lot going on. The best place to get started is Speedrun Ethereum.com. If you go to Speedrunethereum.com and I'm throwing it in the chat right now, you should be able to see some challenges here. Basically, it says the same thing we just said here, get Scaffold ETH downloaded locally.
00:31:02.186 - 00:31:26.946, Speaker B: Go through these concepts in solidity by example, looking at the solidity docs, copy paste stuff, test your assumptions. Then when you're ready, we have a handful of challenges ready for you. A simple NFT example just gets you started. It teaches you about burner wallets. It teaches you about how to get Scaffold ETH set up. It teaches you about the NFT contract and also going to a public network. Looks like we go to gorley.
00:31:26.946 - 00:31:52.974, Speaker B: Someone has already I think this was Rinkabee yesterday. Someone had got in here, probably Jason. Shout out to Jax, I bet. You need to learn how to deploy to a public network, just like Kevin did with his Co van Deploy. And this first challenge will teach you that. Then the next challenge really teaches you the superpower of Ethereum. It's allowing you the builder to create a simple set of rules so that an adversarial group of players can work together.
00:31:52.974 - 00:32:36.954, Speaker B: And let's zoom in on that. This is about people who don't trust each other, right? The only thing that you have to trust is that middleware, that code layer, and it's your job as a programmer to create the correct rules and the correct incentives in that middleware, that code layer that everybody can trust. So people that don't necessarily trust each other can get in and use your app to coordinate financially. And that's what challenge one teaches you. It teaches you how a smart contract sometimes is like a state machine, and you kind of need to move from one state to the other and nothing happens automatically. You have to poke it, right? Someone has to make the transaction to move it from one state to the other. You have to write your require statements correctly.
00:32:36.954 - 00:32:59.498, Speaker B: Then you move on to a token vendor. You deploy an ERC 20 token. You deploy a vendor, you learn the Dreaded approve pattern. And when you want one contract to grab tokens from someone else, you can't just send them in and have it execute. You actually have to approve it with one transaction and then call it with another transaction. The Dice challenge teaches you about randomness. Randomness is super tricky on a public deterministic blockchain.
00:32:59.498 - 00:33:23.420, Speaker B: This is going to teach you when you can use block hash and when you can't, and how to build an attacker contract to steal from weak forms of randomness. In a simple testnet game, you'll become eligible for the Build Guild. You can find out what the Build Guild is later. Then there's a Dex. You'll build your own Dex. This is when you're hitting your stride. You're getting good at things.
00:33:23.420 - 00:33:51.074, Speaker B: This Dex is susceptible to slippage attacks and stuff like that, but you don't need to know that. This Dex will just teach you about reserves and LP tokens and how a decentralized exchange works. And then you'll create a multi SIG wallet. You'll learn about different ways to store your ETH and how to use a signature based system. And then on to kind of like an SVG NFT and some more challenges that we're working on. The key is go. Speedrun.
00:33:51.074 - 00:34:07.434, Speaker B: Ethereum. This will get you started with Scaffold ETH. It will get you started learning how to be an Ethereum developer. It will get you right to the solidity first and then kind of work you out of the onion through all the other concepts. Anything else to add there, Kevin? Did we slay it? What do we have left?
00:34:07.472 - 00:34:29.620, Speaker C: No, that was awesome. Yeah, I think that was really cool. Oh, last thing, if you guys have problems and need help, there's a Telegram chat. So if you go on to Scaffold IO or actually, I think I don't know what the best way to be? If you just search Scaffold telegram. Yeah. It'll show up and there's like 2000 developers in there and they're awesome. Great community of developers who will help you if for some reason we're not available.
00:34:30.390 - 00:34:37.060, Speaker B: I think that's it. I think we got it. I think we're done. Ship. Yeah. Reentrancy on covan. We did it.
00:34:37.060 - 00:35:04.134, Speaker B: We had to do a lot of work to make that contract insecure. It actually was hard at this point, trust me, it's easy to make mistakes, but it was hard to get that reentrancy to work. It was throwing on us when we tried this ten minutes before the call and we didn't realize we needed to do unchecked math also. But I think we got it. Thank you ETH Global for having us. Thank you all for coming along on this fun journey. Don't forget to speed run ethereum.
00:35:04.262 - 00:35:07.882, Speaker C: Speedrun ethereum. And good luck hacking and build on Scaffold ETH.
00:35:08.026 - 00:35:21.570, Speaker B: Yes. Go get scaffold ETH. Get it started this weekend. So you're ready when, what is it? Tomorrow? Does the hackathon start tomorrow? Take a moment tonight just to do challenge one or zero and one and you'll be ready for the hackathon tomorrow.
00:35:22.470 - 00:35:29.538, Speaker A: Awesome. I think you have a question by Daniel. What are your opinions on TDD with smart contract development?
00:35:29.714 - 00:36:23.410, Speaker B: Oh, cool. Yes. So TDD would be the block difficulty and after the merge, block difficulty is going to become this previous ram dao. So it's going to work very much like the block hash where it's a randomness that's from the previous block hash that you could have guessed. And by the way, if you want to learn about this stuff, scaffolith has like five different branches using different forms of randomness and we're even working on a future TDD and I think that's going to be the best kind of cool randomness. Obviously there's like chain link VRF and other kind of oracle random sources. But what you can do is you can say a future block is going to have a specific difficulty and you can build your app to basically you make one transaction that's almost like a bet on a future block and then after that future block has happened, you can make another transaction.
00:36:23.410 - 00:37:16.098, Speaker B: If your bet was successful, you can turn it in and it'll go look at that previous block difficulty and it will pay you out based on that. It works with block hash a lot easier. But what we're finding with using future block difficulty and this was a shout out to Light client, he came up with this. Well, yeah, we would have never thought of this, but he dropped some sweet knowledge on us. Basically, if you want to have difficulty, difficulty isn't something you can query for a previous block like you can with block hash. What you do is you have them submit the entire block header, all the information that has to do with that block header, and you hash it in the smart contract and you make sure that hash is equal to a specific previous block hash. And if all of that is true, then the block difficulty they submitted is a good form of randomness.
00:37:16.098 - 00:37:38.160, Speaker B: So it's complicated. Go through Speedrun ethereum take on the dice challenge first. But we do have a future block difficulty build in motion. If you watch the Scaffold ETH repos, shout out to Ahomi Damu who's working on think that's. I think that answers the question. I didn't see that question. Are there more or did we cover them?
00:37:39.330 - 00:37:42.810, Speaker C: Could we use Scaffold ETH and other networks as polygon?
00:37:42.970 - 00:37:43.294, Speaker B: Yeah.
00:37:43.332 - 00:37:48.914, Speaker C: So it's EVM compatible. So anything that's layer two that's EVM compatible will work. Right.
00:37:49.032 - 00:38:08.230, Speaker B: Basically, Yarn deploy network polygon and it's going to work. Watch that. Sometimes you might get an issue with gas. You need to go into your hard hat config and look at the gas for the different networks. I'm going to look at polygon right now. It actually does have a gas price hard coded in there. I would pull that.
00:38:08.230 - 00:38:31.710, Speaker B: I would let the RPC here. If you go to your hard hat config right here and you go look at polygon, it does have this gas price hard coded. I'd pull that out. I'd do that right there and I'd deploy it just like that. And I think it'll automatically get the gas price and I think that'll give you a better time. So if you are having problems deploying to a specific network, keep an eye on that config file.
00:38:32.770 - 00:38:41.220, Speaker C: Awesome. Well, that was a lot of fun. Austin. Really cool to do this collab, so thank you so much.
00:38:42.070 - 00:39:09.750, Speaker A: Awesome. Well, thank you to the both of you, Austin and Kevin, that was super fun to be a part of and watch for real. Thank you to two of you for taking the time to do this workshop for our ETH Online hackers which is starting this week. So super excited to see what everyone builds and I hope you all learned a lot from this workshop. I think Austin and Kevin have this really great and fun dynamic. So it's super engaging and fun. But yeah.
00:39:09.750 - 00:39:15.470, Speaker A: Otherwise, I hope everyone a great rest of your day and see you at future workshop.
00:39:16.130 - 00:39:21.900, Speaker B: Thank you for having us. Thank you for having us. ETH global go hack. Go get them.
