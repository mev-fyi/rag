00:00:05.290 - 00:00:13.440, Speaker A: Talk. So next up we have Rick Moo and Rick's going to be talking about Ethers v Six. So without further ado, I'd like to welcome.
00:00:15.730 - 00:00:16.334, Speaker B: Screen.
00:00:16.452 - 00:00:19.246, Speaker A: Hey, can you hear me? Yes, we can.
00:00:19.348 - 00:00:22.798, Speaker B: Excellent, excellent. So I should just jump in then?
00:00:22.964 - 00:00:23.854, Speaker A: Yes, sir.
00:00:23.972 - 00:00:41.222, Speaker B: Excellent. So let me figure out how to go back to sharing screen. So as some full disclosure, I kind of got confused as to what talk I was giving today, and so I prepared the wrong one. So I spent the last hour throwing this together. So there might be typos and such. Can you see this?
00:00:41.356 - 00:00:41.938, Speaker A: Yep.
00:00:42.034 - 00:00:44.006, Speaker B: Excellent. Excellent route.
00:00:44.038 - 00:00:44.970, Speaker A: And do it live.
00:00:45.120 - 00:00:46.140, Speaker B: It's what? Sorry?
00:00:46.750 - 00:00:49.430, Speaker A: We'll do it live with the Bill O'Reilly route.
00:00:49.590 - 00:01:20.550, Speaker B: Yes, exactly. So this has not been fully thought through, but here's my best thing. So I think probably a lot of people are familiar with Ethers. So I just wanted to give a quick overview what V Six is going to be about. Right now, V Six only lives on my desktop as a local repository, but I'm hoping within the next two weeks to get a public beta out so people can start using it. I'm also hoping there's lots of questions that people have because I don't think this is going to take up the full half hour, but we will see. Also, awesome talk, Austin.
00:01:20.550 - 00:01:44.990, Speaker B: It felt like the movies where the counter is counting down and you're trying to get this contract deployed in the last it's counting down 5432 and then you're done. You saved it. You got just in the neck of time. So, anyways, back to ethers. V six. So one of the big things with Ethers V Six is it's ESM first. So there's no longer going to be any Es Three support.
00:01:44.990 - 00:02:46.046, Speaker B: So if you're running Node Eight or Node Ten or you're using an Ie era browser, things probably will not work out well with V Six. I plan to keep V Five running for a little bit for people who really need kind of those old platform supports. But there's also some things I'm changing in V Six that will make it easier to maybe use Babel to get those Es Three like things working. So also, because everything's ESM, the build process is far more simple for those that aren't familiar, the build process for V Five because it builds Es Three and it builds ESM modules, and also because TypeScript does not support multiple targets in that way during the build process. For composite packages, during the build process, it has to rewrite all the TS config files everywhere, all over disk, and then recompile it. This just leads to a really complicated build process. So this makes things much easier.
00:02:46.046 - 00:03:31.710, Speaker B: Also, ESM has much better tool support. Like I said, between Babel and all the different bundlers, things just work. Also, all the dependencies are ESM, which really helps the bundlers because the bundlers usually choke the second they hit elliptic. Or they hit BNJS or hash JS, these traditional JavaScript libraries. So basically, in a nutshell, ESM first is like a key part of V Six, and part of that is because now we can use modern Es features. For example, we can't even use Map or Weak Map or any of those really. Especially Proxies, those really cool features that JavaScript has introduced in the last five or six years, just because V Five tried to stay compatible with a very large audience.
00:03:31.710 - 00:04:11.694, Speaker B: So proxies are very cool. For those unfamiliar with Proxies, they're basically a JavaScript object that can trap when you're trying to do stuff with them. I've got a better slide next that kind of demonstrates that private members, a lot of the things in V Five, they were private just by virtue that they had an underscore in front of them. The problem with this is people kind of tinker with and break things they don't even realize they're breaking by interacting with these private members, especially other frameworks. I've definitely seen frameworks who are tinkering with private members, and then I get an issue because Ethers isn't working for them, but it's because it's been broken somewhere else along the way. Again, much better bundler support. This is an important thing, I think, for most people.
00:04:11.694 - 00:05:09.822, Speaker B: At the end of the day, everyone wants to make a react native app which needs Bundling or as OS was just showing with Scaffolding, you want this one thing all bundled up into one little concise package that can sit out on the web and be served from some CDN and your app should just work. Big Int. Es 2020 big Int is kind of like it's a weird point for me because on the one side it's really recent. Es 2020, if you have a browser that's made in September 29, or even if you have a react native app that was made in September 29 of 2020, it's going to fail to work with this version of the library. So for Es 2020 Big INTs, there's also an additional disk file which has got the Big Int stuff swapped out for the traditional big number libraries. So internally it'll be a bit slower, but it'll still work on older platforms. Backwards compatibility for those who don't know me is very important.
00:05:09.822 - 00:05:59.690, Speaker B: I maintain a lot of really old projects and it sucks when there's literally no path forward to keep them alive because I can't update this version of that thing without breaking this and vice versa. So next slide. Contract Proxies. So this is really where the Proxies are going to shine. So right now, if you use Ethers for a contract, if you've got a function called foo, if you've got multiple functions called foo, or in this case adder, it's hard for the system to know which one you mean. If you have one that takes in an adder and a UN 256, and one that takes in an adder and a UN 128. There's literally no way that it can tell which one you actually intended, which is why you then have to specify the actual signature, which gets complicated.
00:05:59.690 - 00:06:39.578, Speaker B: This might be too much detail for some people, I'm not sure, but those who've suffered this, they are very vocal about suffering this, and so they'll be the ones who appreciate this the most. And I'm hoping people going forward will appreciate this without realizing that they're appreciating it. But basically you can force a type. So in this case, we see that you've got a typed UN two six. You're casting this. So if there is, for example, if there was a function called adder that took in an address and a UN 256, and an adder and a UN 128, this is now non ambiguous. The system now knows exactly which one you meant because that chain ID is enforced into a UN 256.
00:06:39.578 - 00:07:31.870, Speaker B: The other big advantage of the Proxies, though, is if you see the next three examples, they're all referring to the exact same method, this address that takes an address in U into 256, well, it will normalize them before you even get to the point. So the proxy actually gets this string and gets a chance to normalize it into a string to do a lookup in its own lookup table. So it doesn't matter how you specify this method, it'll be able to find the one you want. Whether you have extra things in there, like the names or not the names, whether it's a view public, all those extra stuff, it just throws it away. So that's the biggest advantage of having Proxies is at Runtime. I can decide what you probably meant now. Ethers will still never guess if it's at all ambiguous, then you're going to get an error.
00:07:31.870 - 00:08:29.322, Speaker B: The problem with EV five though, is you start getting all these warnings in the console logs just by loading this Abi. This at Runtime can tell you you're wrong, go to jail, do not pass go, that sort of thing. So TypeScript, when I wrote V five, it was very much based on V four, and I had never used TypeScript before. And so as a result there was a lot of decisions that were made that were I mean, at the time TypeScript was still very young, but there was a lot of decisions I made based on JavaScript developers. JavaScript is still very important. The nice thing is modern TypeScript takes into account a lot of things for JavaScript developers that it did not back then. So it's been redesigned a lot with TypeScript as a first class citizen.
00:08:29.322 - 00:09:16.670, Speaker B: So TypeScript is like a fundamental part of the library now, not just kind of useful for people who use TypeScript. So all dependencies are fully typed TypeScript. There's no more weird little libraries lying around that have types that were made by hand and therefore maybe not quite right. It also, again, goes back to the bundler thing, because all the dependencies are TypeScript and all the dependencies are ECMAScript. They kind of cohesively work together better without weird foibles. There's also a lot more templating in V six and I'll give some examples of that next. But even with the templating, I don't think there's many places where you have to explicitly specify the templating.
00:09:16.670 - 00:09:51.900, Speaker B: It will fall back onto meaningful defaults for you. Strict error checking is in now, which is something I know a lot of people wanted in V five. Anything that returns something can always return something or null. And this means that you miss out on a lot of type checking because if you're not doing null checks, then you might get a null object back and you won't get any compile time error for that. And there's better separation between concrete classes and abstract interfaces there's. Moving around more on that in a few slides, I think. Again, the slide deck is really new in my head.
00:09:51.900 - 00:10:31.122, Speaker B: Oh, those came first. Excellent. So concrete classes. So I've moved some interfaces to concrete classes. So interfaces are kind of good for things that you want the flexibility of just what they should look like. Whereas classes are nice because you can actually do things to them so one of the big changes is networks networks are now an actual class there's actually another slide even later on about networks so I'll go more into it then but it means that they can do much more things at Runtime based on the parameters you gave them the other big one is transactions. Transactions for serializing and parsing.
00:10:31.122 - 00:11:20.918, Speaker B: They've always been a hassle because people do weird things. People specify a V as well as an Y parameter or they specify a Vs as well as an S. Like, there's all these things that I had to check and make sure they all worked together. So now that transactions are a proper object, it's much. Easier to set all the things on it, especially these days with EIP 29, 30, EIP 20, 718, EIP 1559 we have all these weird things that go with transactions, so this just helps bring them all together and much easier to either parse or serialize or pass them around. A transaction object is now a valid object, for example, to pass into a signer if you wanted to send it. And transaction responses, for example, inherit from transaction so it's just like all those that's actually a slide I should have made.
00:11:20.918 - 00:12:03.198, Speaker B: I'll make a mental note of that. So basically, the inheritance model makes more sense because you've got transaction requests, transaction responses, transaction objects, parse transactions all these different types of things. Now that there's a proper hierarchy to how they all interact with each other, you can pass one thing in from one thing into another thing that should accept that thing in V five, right? Now, it does a lot of checking to make sure you're not shooting yourself in the foot, but sometimes that shooting yourself in the foot is almost desired. So this makes sure that when you shoot yourself in the foot, you're shooting yourself in the foot safely, if that makes sense. Also, there's a much more flexible Web API. It provides pre flight checks and advanced retry logic. This is useful.
00:12:03.198 - 00:12:27.638, Speaker B: AWS has added a lot of functionality for blockchain type things, but the way they interact with authenticated requests means that there's a lot of things that are very hard to do right now. So the new web API. I'm looking forward to sharing. I use it actually in other non ethereum ethers based projects. So that's a bit on concrete classes. So abstract interfaces. I also moved the other direction.
00:12:27.638 - 00:13:08.534, Speaker B: Some things that used to be classes are now interfaces. So the signer and the provider used to be classes that you had to inherit. Which meant if you want to do really custom things, you sometimes couldn't because you had to inherit from provider, you had to inherit from signer. And now you're stuck because you might want to subclass something else that's more interesting, or you might not want to implement a thing that's in those abstract classes but that it needed that you don't want. Yeah, another big thing a lot of people ask for sorry, I'm just blowing through these I'm hoping for questions to help clarify anything people. So please write down questions and bug Kartik for things that come up. I think he'll pass those along to me.
00:13:08.534 - 00:13:43.362, Speaker B: So addressable. This is something that I know people really are frustrated with. There's weird errors because right now if there's a function call for a contract or there's a method on a provider that takes in an address, it accepts addresses and accepts ENS names. A lot of people have bugs where they pass in a signer instead. And a signer is 100% reconcilable as an address. It's just v five doesn't do that. So in V six you can pass in signers or accounts or anything that's meaningfully an address into something that expects an address.
00:13:43.362 - 00:14:26.814, Speaker B: And so there's this whole address type that things can implement to ensure that the system knows that they're inadcessible and that they'll just work the new Freezable API. So this is another thing that Ethers has always done and it's been a huge point of annoyance for a lot of people. Everything in ethers is immutable. This is really important for an asynchronous environment because you don't want to pass something into the provider, have it preparing to do something with it, and then you and another part of code start mutating that object. And now maybe the provider receives half of the mutated states and half the non mutated states. So everything in Ethers has historically been immutable. So with the new Freezable API, you can pass in a mutable or immutable object.
00:14:26.814 - 00:15:00.502, Speaker B: The first thing it's going to do is create an immutable copy of it internal to the provider. So you can go off and now do weird things to the thing you have and be assured it's not affecting anything else. There's also a lot of places in Ethers where it passes you an immutable copy. For example, a transaction. For example, you might hit a provider, ask for a transaction, want to change some things on that transaction and then send that transaction, maybe just update the nonce or something. Well, you can't do that as it stands right now because those things are all coming back as immutable. So with this you would get back an immutable copy.
00:15:00.502 - 00:15:44.886, Speaker B: But there's always on the freezable API you can do clone get immutable copy which allows you to modify the things you want to pass. So it kind of helps keep things safe by the things that need to be immutable or should be immutable are still. But when you need Immutable copy for doing something useful you can the Air interface. I'll actually go into more as well in another slide, but it provides a type safety for the property access because Ethers provides a very complex complex right word a very useful but not the way that most people are used to handling with errors. And yeah, I'll get to that in a second anyways. Oh, actually, I'll get to it next currently. So errors.
00:15:44.886 - 00:16:07.170, Speaker B: So here's a great example. So if you have a modern TypeScript thing, errors come back as unknown. You don't know what the error is. So this actually uses conditional type in TypeScript. So it knows that the transaction replaced is an enum. And so once you're inside this is error. I don't know if you can see my cursor, I'm wiggling over top of the Air replacement.
00:16:07.170 - 00:16:55.300, Speaker B: Once you're inside this block for is error, the typing system is now fully aware that the error object is of type, which is an interface, is the interface of a transaction replaced error. Sorry, I'm talking fast. Okay. So yes, once you're inside this block, it knows that's the type, so it knows what properties exist. It also knows what types of properties are. And so it also means that everywhere in the code that throws a transaction replaced error, it must provide all the properties associated with that. So it kind of helps on the coding side to make sure I'm not missing a property that you really want to exist and to make sure that when you want to use a property that you can have the type checking in place that verifies the property is the right thing.
00:16:55.300 - 00:17:47.326, Speaker B: Don't know how much more I think I'm almost done this was talking about before. One of the biggest issues Ethers has right now, issues, but requests I have from Ethers is people start having these weird chains. They have chains that no one's ever heard of or they're chains that I've never heard of at the very least because I don't really follow a lot of these like fringe or even some of the common ones chains. So the network now bundles a lot more stuff into it. But as a result, the network is often enough to specify a chain. That's weird in a strange way. If it has a different address format, if it hashes things differently, if it needs to talk to L ones to do something, the Network Object is now more cohesive, more flexible.
00:17:47.326 - 00:18:38.834, Speaker B: You can do a lot of those things. So, for example, right now for BSc and for Polygon and for Arbitrum, I don't know how to pronounce that one, but for those types of chains, they actually sometimes require a whole different package, which provides a new JSON RPC provider, and therefore new static JSON RPC provider and a new Ether scan provider. All these extra things just because they changed something that's kind of fundamental to Ethereum, but for their chains, it made sense. So with the Network Object being pulled out, it means that you can now have just a BSc based network and things will just work. The world's a happy place. All that extra work that needs to be done is done inside the Network Object instead of inside the provider. On that note, the plugins the plugins are kind of part of that as well.
00:18:38.834 - 00:19:15.130, Speaker B: It means that a network can use a plugin to describe a more complex behavior. One of the biggest issues with L Two S right now is that the ENS support is not obvious for how it should work. ENS on an L Two is somewhat complicated. So with the new Network Object, we're now able to fully support L Two S. With ENS, basically, they need an L One connection, but all that happens internal to the network and the provider object. So you can just start using ENS names on Polygon, for example, and also Durin. I'm not sure if people familiar with Durin.
00:19:15.130 - 00:19:45.320, Speaker B: It's an awesome way for L Two S to interact with anything. It basically means anything can become an L Two. It's really awesome. If you don't know about it, check it out, but there's built in support for it. One of the big advantages of using plugins is we can, in a very backwards compatible way, add support or remove support for things like Durin. So Durin right now will be by default off, but we'll have a plugin that will turn it on in the future, we have it by default on and have a plugin that turns it off. Yeah, lots of awesome.
00:19:45.320 - 00:20:00.940, Speaker B: Ah, excellent. I'm done. So I guess I will open up the floor to questions if anyone has anything to sorry, I blew through everything really fast, but I'm hoping to fill in the time with questions or the things I blew through too quickly or did not describe enough words to like.
00:20:01.310 - 00:20:21.154, Speaker A: Yes, it's a good rate, we're good here. All right, so a few questions, few comments, and a lot of amazing comments. First of all, everybody's excited about TypeScript support. So that's great. That's not a question, that's just a lot of happiness. Obvious question, what is the timeline of the release? How are you thinking about that? And when can people try this out?
00:20:21.352 - 00:20:53.518, Speaker B: Right, so I'm hoping for a public beta in maybe two, maybe three weeks. I have a minor bump. I need to get out this week. I'm hoping that's going to be the last minor bump of V Five. So hopefully in three weeks time, and maybe even earlier, I might not have a version up on NPM, but earlier I am hoping to even maybe have a GitHub repo up so people can kind of see the differences and if they're really ambitious, try it out from that. Without NPM support. But it'll be on NPM hopefully within, I'm hoping two to three weeks.
00:20:53.518 - 00:20:56.510, Speaker B: But this is Ethereum, so two weeks TM.
00:20:58.610 - 00:21:19.718, Speaker A: Give or take a month. This is great. Okay. So another kind of question and a theme is talking about you sort of touched on this, but talking about multiple networks. Is the fallback provider the best approach still? Or how do you think about supporting multiple networks more appropriately? And you kind of talked about some of them like optimism or arbitram and a handful of those.
00:21:19.884 - 00:22:02.500, Speaker B: Absolutely. So you should always still use the fallback provider if you have that opportunity. One of the cool things I'm doing with that is plugins. So there's ancillary packages So for example, if you pull in the ancillary package for polygon or for BSc, one of the things it can now do is that new package that you have that somebody else can even maintain, not Richard, someone else can maintain that package. It can actually call into the default provider and register itself as a plugin. Basically, you would include Ethers, then you would include the BSc package. But then when you do Ethers get default provider BSc, it's actually going to be the BSc package that's responding to that and populating the object as you need.
00:22:02.500 - 00:22:32.954, Speaker B: That, for example, will automatically handle deciding how to connect to L ones so that you get ENS support. It'll figure out whether the network supports EIP 1559 or all those extra little things it needs to do. So weird networks can do the weird things they need. And I don't use weird as a negative connotation. I use weird as in different. It's behaving not as Ethereum does specifically, but it's ethereum enough to work. Yes.
00:22:33.152 - 00:22:49.540, Speaker A: Cool. Another kind of question, which is we can go as deep as you'd like here. What are some kind of extensions that you personally wish existed that still don't? And sort of like how does the V Six architecture sort of help enable some of those things from your own personal wish list?
00:22:51.190 - 00:23:25.550, Speaker B: In terms of extensions, I'm not quite sure what that means. I'm going to guess maybe like ancillary packages. That's one of the things I'm focusing on in V five, a lot is making more ancillary packages and I'm trying to move a lot of the things. So there's actually a lot of packages in V six that will not exist, that exist in V five. I'm merging some packages, but for example, Hardware Wallets is being moved out into its own ancillary package. So the advantage of this is it makes the turnaround time faster because I don't want people mucking around with the core. The core is still something I want to make sure is secure and concise and adheres to all the things I want to adhere to.
00:23:25.550 - 00:24:13.978, Speaker B: But the ancillary packages are a little bit more open ended and so for example, what I'm hoping to at some point is to just give ledger the ability to have contributor rights to the ancillary package for Hardware waltz so that when they make an update, they can go in and make that change. It'd be nice if Trezor can also go in and make the changes as well. There's still going to be a gatekeeping thing. I still control publishing things to NPM, but I can at least let other people manage that sort of exact. So it's the same thing as well for other extensions, for maybe like diamonds. Maybe somebody wants a diamond API. I don't necessarily need that built right into Ethers, but if there's ancillary package for diamonds, the author of that EIP, I could even give him or her, I'm not sure, permission to modify or update that as necessary.
00:24:13.978 - 00:24:24.690, Speaker B: So that's part of V Five ish but with V six I'm making a much stronger push towards moving more things out of the core and into ancillary packages.
00:24:25.030 - 00:24:44.534, Speaker A: Awesome. Another question is around how you think Ethers will evolve to support more cutting edge stuff like building or testing or interacting with zero knowledge applications or just circuits. Do you kind of see that that's Ethers JS's role or what should somebody think about in this case?
00:24:44.652 - 00:25:24.050, Speaker B: It would depend a lot, actually. I've not thought of it before, but I think it would make sense. So for example, there should be probably some sort of ZK you could imagine ZK Sync could have like a ZK Sync provider and again, this would be an ancillary package. Anything that they need kind of bundled inside, I would totally be willing to add to Ethers. But a lot of that stuff can just be added kind of like as an extension library. If you don't need ZK snarks inside Ethers, I'd rather not have it directly in Ethers. But if there starts becoming a thing where all networks start using ZK roll ups for the specific thing, then it totally makes sense to put in there and possibly even wrap into a plugin for networks.
00:25:24.050 - 00:26:11.054, Speaker B: And oh, that's another thing I forgot to mention as well. A big chunk of the redesigning for V Six is breaking things into a ridiculous number of files. So in V five everything was one file inside each package. The problem is bundlers, and specifically tree shaking fail. Tragically, when you have one file, it has to be so pessimistic as to what is going to be possibly called that it includes stuff that is remotely completely impossible to be involved. So the nice thing is, most tree shaking systems, they understand file boundaries. So if something requires something from their file, it's completely out of scope of what's going to be necessary.
00:26:11.054 - 00:26:33.210, Speaker B: And so it drops. It going back to what we were talking about a second ago. It's actually possible, because of the splitting of files, to include ZK snark stuff in Ethers, and because it'd be in its own file, separate from everything else. If you're not including something that includes something that includes something that includes this, it'll automatically get ripped out by most bundlers.
00:26:33.550 - 00:26:44.490, Speaker A: No, exactly. And I think in that world, even if something is part of the core Ethers library and not being used, you can still kind of make the argument that ZKS could be actually part of the core.
00:26:45.570 - 00:27:03.042, Speaker B: I was going to say that's one more quick point as well, is the size of this library should be much smaller. I'm using noble's, sexy two, five, six, and a different big number library. And because of es 2020 INTs, it's going to chop like a ridiculous amount. I feel like between ten and 20% of the size is going to get knocked off by this one library change.
00:27:03.176 - 00:27:15.586, Speaker A: Amazing. Two more questions before we close off today. How can people kind of contribute to the project? Do you need any help with certain things? What's kind of the process or things that you prioritize?
00:27:15.778 - 00:27:49.394, Speaker B: Right, so this is one of the biggest reasons why I want to move to ancillary packages, because everyone wants to help. I love the idea of people helping, but reviewing code is hard. And the other thing is any code, people want little features added. And once you add a feature, you may spend three days making the feature, but now I'm supporting it for life. So I'm looking forward to more ancillary packages so that I can actually just kind of give some of the ownership up. If you really want this feature, then you can add it. It's kind of hard right now for me to kind of give pieces off to people to work on.
00:27:49.394 - 00:28:04.998, Speaker B: Documentation is always appreciated. I love it when people contribute to the documentation. I love tutorials. And once ancillary packages are more of a thing, I'm looking forward to having more people be able to just take that and run with it. So that will be coming soon.
00:28:05.084 - 00:28:17.622, Speaker A: Again, TM and final question, which has been asked a couple of times. Can you share the slides with our audience? So if you can, just send that link to me and I'll be able to send it to everybody in the chat. So whenever that absolutely.
00:28:17.676 - 00:28:18.998, Speaker B: Yep, I'll send those out. Perfect.
00:28:19.084 - 00:28:19.398, Speaker A: Thank you.
00:28:19.404 - 00:28:19.526, Speaker B: So.
00:28:19.548 - 00:28:20.622, Speaker A: Much. Rick awesome.
00:28:20.676 - 00:28:23.486, Speaker B: Thanks, Karthik. Take care. All right.
00:28:23.508 - 00:28:25.660, Speaker A: With that, we are ready for our next talk.
