00:00:25.070 - 00:00:34.820, Speaker A: Hello everyone, and welcome to the LFGO Ave Labs workshop analyzing go data. Joining us today is Matt Cole, who will be taking us through this session. And with that I'll pass over to Matt to get the session started.
00:00:35.270 - 00:01:28.470, Speaker B: Awesome, thanks so much. So hey everyone, today we're going to be talking about analyzing go data. My name is Matt, I am a data scientist at Avara. And welcome to the lfgho Hackathon. So without further ado, what are we going to talk about today? So we're going to really quickly just intro go and talk about what is blockchain data, how can we access it? The two types of data we're going to talk about is querying contract state and using logs for go. And then we're going to get into how go is not just a single contract, it's not an island. There's a whole ecosystem in facilitators that are contributing to go and how we can use data from all of these other different contracts.
00:01:28.470 - 00:02:15.006, Speaker B: I think it's worth taking a minute to talk about what we're not going to cover. We're going to be connecting to a blockchain node to query some data here, and we're not going to necessarily talk about how to select a node provider and how to connect to them necessarily. If this is all news to you, if you haven't done this before, don't worry. I've put together a couple of links at the end of how you can connect to a node and kind of get started. So we're going to keep this pretty high level. So even if this is completely new to you, I think that you can still absorb it and then later you can use some of these links to get yourself up to speed. Likewise, we're not going to be talking about specific libraries of how to connect to nodes.
00:02:15.006 - 00:03:28.618, Speaker B: Again, this is going to be pretty high level, so don't worry. If you really want to use javascript and we're using something else, or you really want to use web3 py or web3 js or something like that, and we're using something else. Don't stress high level. And a lot of this information or all of this information will translate from one to another. And then also we're not going to be getting too much into exact syntax or anything like that. So what is go, right? I have the pleasure of being, I think the first workshop, so we should talk about what is go. So go is the ave native stablecoin, and what's exciting about us all being here today is that from my perspective, at least, go is in a lot of ways what you make it, because go, is it the stablecoin that's powering a really cool payments app? Is it a stablecoin that's powering some sort of savings protocol? Is it something else that I've never even thought about? That's up to you, right? You guys are building the future of go, and I think that's really cool.
00:03:28.618 - 00:04:27.630, Speaker B: And I think what could really augment and elevate a lot of these applications is using data in a clear and coherent way to help create the best product possible. So what is blockchain data? What is go data? Where can we get it? All these questions, I think are really important, and I think there's two types of really important blockchain data that we're going to be talking about today. The first is contract state data. So this is any data that's stored within a smart contract on Ethereum, on our blockchain. And we have up here in the top right here, we zoom in. This is just an ether scan UI of us querying the balance of a particular user. So I think this is like a very common way to collect data for a particular smart contract.
00:04:27.630 - 00:05:02.826, Speaker B: And another type of data that we're going to be talking about a lot is event logs. So a lot of smart contract developers, they'll add logs to their smart contract. So when certain important events are occurring, little pieces of data will be emitted, saying, hey, this is what's happening here. A deposit is being made, a swap is being made. Here's who's making it, here are the assets, and here's what's going on. So we're going to dive into both of these two. There's other types of blockchain data too, but we're not really going to get too much into those today.
00:05:02.826 - 00:05:58.746, Speaker B: I think contract state and event logs is already a lot, so we're going to really get into it. So what can we do with go? How can we query go data? So I think it's important to, right off the bat, note that go is an ERC 20 token. So an ERC 20 token is a token that follows a particular set of standards that make it really easy for blockchain developers to interact with ERC 20 tokens generally. So go is an ERC 20 token. Other tokens that are well known, like USDC, are also ERC 20 tokens. And that means that applications, data, applications protocols can all interact with them in a similar way because they have a similar set or the same set of functions. So go is a superset of an ERC 20 token, right.
00:05:58.746 - 00:06:39.930, Speaker B: It has a lot more functionality than a basic ERC 20 token, but it does also have this kind of common set of functions that we can use to query data from. So right here I actually included all six of the ERC 20 specified view functions. So these are functions that just return data from the contract. And these are functions. These six functions are ones that are included in all compliant ERC 20 tokens. So we see them right here. This is how we can get the name, symbol decimals, the total supply of go, as well as the balance of a particular user.
00:06:39.930 - 00:07:13.860, Speaker B: So let's see that in action. Like what might that look like? We could kind of easily query just using this one call, right? The total supply of go, which might be pretty important to know. And I think even more relevant might be we can query the balance of a particular user. So that's it. Over here we have this particular user we might want to query. How much does this person have or this address have right now? And that's great because it'll always update. If we call this function in 2 hours, maybe they've sent some go to their friends or something like that.
00:07:13.860 - 00:07:58.930, Speaker B: This will always change and reflect the current state of this user. So we have that. And that's a really powerful way, kind of table stakes, really, to have an application. We should probably know how much go a particular user has. The other type of data that I want to talk about is event logs. So as we kind of mentioned before, event logs are put into contracts by developers to flag when certain big kind of events are happening. Typically things that change the state are accompanied by a log.
00:07:58.930 - 00:08:56.338, Speaker B: So the logs will be emitted and they will kind of give almost like a minimum, sufficient amount of information to describe what's happening. So a very common event for tokens might be the transfer event. So the transfer event is emitted when we have a transfer occurring when basically tokens are moving from one address to another. And what's cool about logs that is a little bit different than just querying state is that they're emitted at particular times. We could actually construct histories and actually see, basically just see the whole history. We're not seeing the cumulative sum of all the transactions, which would be the current balance, but we can actually see discreetly all of the little things that have led up to a current balance. And there's events for many different types of events, right? Like we have.
00:08:56.338 - 00:09:32.480, Speaker B: If you consider an application like uniswap that might be swapping, go. We can see that there might be swap events and things like that. But just as an example, we can look at how might we find the historical balance of a particular user using events. So as we kind of talked about, whenever there's a transfer. So whenever go moves from one address to another, a transfer event gets emitted. And this transfer event has a couple of pieces of information. I kind of think about it as like the minimum, sufficient amount of information to kind of describe what's happening.
00:09:32.480 - 00:10:38.760, Speaker B: And it has the from field, which is where the tokens are coming from, the to field where the tokens are going to, and the value field. How many tokens are we dealing with here? So this is kind of like if you look at your bank account or something like that, or a credit card statement, right? It's all the money maybe flowing in or out, and that's each transaction in the credit card world, right? It's kind of each transfer event here. So how might we get historical balance? Well, we can grab all of the transfer events that relate to a particular user, and we could kind of compute a rolling sum. So whenever there's a transfer event from that user, we know that they're losing tokens because they're transferring them to someone. And whenever they are transferring to, we know that they're going to be gaining balance. They're going to be increasing their balance. So we'll go grab these events and then compute the rolling balance, and then we can do whatever we want with it.
00:10:38.760 - 00:11:22.660, Speaker B: So let's look at how we actually do that. So there's a lot of ways to query event data in blockchain. Actually, some people are very passionate about a particular way of querying event data. I think for me, the easiest way to communicate how to do it is using event filters. So basically we could kind of think about this as Ethereum has our Ethereum node has many, many events, and we only want to look at the ones that we're interested in, right. We don't necessarily care about some random event that has occurred a long time ago that has nothing to do with go, right? We just want go transfer events. So we could filter to do that.
00:11:22.660 - 00:12:17.734, Speaker B: So if we look here, a lot of these libraries that interact with our blockchain nodes have this functionality to define an event filter, and they usually require a couple of different things. So one thing is it requires the address. So we only want go transfer events, right? So we'll specify that, hey, the address we're interested in is go. So only look for the events that were emitted by the go contract. And then we also only want to look at transfer events right now. So we could also add in here, this is like a little bit, maybe strange the first time you're exposed to it, but we only want to find transfer events. We have to find the transfer event signature, which is a hash of the name of the event as well as the data types of the event.
00:12:17.734 - 00:13:17.586, Speaker B: Basically, we don't really need to get into it too much, but I linked to a really great blog post at the end that if you're interested in this, you could read, and it really dives into all these different intricacies of events. But yes, this will basically tell us this transfer event signature is basically the fingerprint of a transfer event. So we say, hey, we only want to look for go events or go events, and we only want to look for transfer events. So that's these two right here. And then just to kind of speed things up, we can actually tell the node, hey, only look between these two blocks. So we could say, hey, only look from between when go was deployed, because there wouldn't be any events that were emitted by go before it was deployed to the current block. So we kind of say, hey, we don't really need to worry about blocks that were produced in 2019 because go wasn't deployed then we could kind of skip that and only look at the most recent blocks.
00:13:17.586 - 00:13:50.718, Speaker B: So if we do this, we could get our big list of blocks and we can kind of turn them into. I don't want this to be like a python lesson or anything like that, but we basically get these three fields, right? We get the from the to and then the value. So this is all transfer events that were sent to and from anyone, all go users. So we could basically filter this down to the user that we're interested in. And I just picked a. It's not even a user. I picked a uniswap v three pool.
00:13:50.718 - 00:15:00.234, Speaker B: So we can look at how much go is in this pool, and we could do exactly what we said before, right? We could say, hey, increase the balance when there's a transfer to our address, and then decrease the balance when there's a transfer from this address. So we can get something like this. So this is pretty interesting, right? This is a much more rich way to kind of see the token balance because we can see historical balances through time. And this is pretty interesting, right? Because if we are building an application, maybe this isn't something that we need, but maybe it is something we need, right? It all depends, of course, on what we're building, but this could be a really good view to, a good way to view maybe go held by an address over time or things like that. We could also imagine these transfer events. We could also imagine if we're building something like a payment protocol or something like that, or a payment app. It might be important to know, hey, this address that the user is trying to send to, have they sent to them before, because if they have, then maybe they know that person and it's okay.
00:15:00.234 - 00:15:48.474, Speaker B: But maybe if it's a new address, we need to be a little bit more careful that they're not being scammed or something like that. So this historical information about who these tokens were sent to and who they were received from can be very valuable depending on what the application is. So I think that's something definitely. That's pretty neat. So we just talked about querying state data to get the balance of a particular user and then using logs to do pretty much the same thing to get the balance of a user. And it might be a case where you're wondering, which one should we use, what's better? And a lot of web3 Uis use the state. They query the contract state.
00:15:48.474 - 00:16:54.954, Speaker B: And that's because for a single user, it could be very fast to look up the state of that particular user. And also you're assured it's real time. And it's actually very literally what the contract says the balance is. Right? In some ways, the contract is the truth, right? So if the contract says, hey, the balance of this user is x, you can be pretty sure that it's x. But the thing about querying the contract state is we don't get anything historical, right? We're just very much point in time right now, what's the balance of this user? So if it is important to look at historical data, that's sometimes where logs can be of use and not just historical balance data, right? Like I was saying before, maybe we're interested in knowing the history of who a particular address has sent to and who they've received from. If that's important too, we can use logs to kind of get that data as well. Maybe a bit out of the scope of this presentation.
00:16:54.954 - 00:17:42.174, Speaker B: But if we're storing logs, it doesn't necessarily make sense to always be querying our nodes. These are things that we can store in a tabular table in a database or something like that for easier retrieval. But I definitely wanted to expose you to logs and querying state data as both different options. So everything we talked about so far has been just querying the go contract, which is great. And I think that there's a lot of really good data there. But the truth is go is not a single contract. The go token is, but the go ecosystem, which when I hear go, I think the go ecosystem really is so much more than that.
00:17:42.174 - 00:18:24.074, Speaker B: Right? So go is a big part of Defi. It's in a lot of different decentralized exchange pools. It's being used for payments, people are holding it, it's being used outside of the ecosystem. And then there's this entire facilitator, very interesting mechanisms where facilitators are creating go and really controlling the supply. And I think that to really understand go is to kind of really understand how all these pieces play together. And I think you'll be getting exposed to the facilitators much more in the near future. So I'm not going to go into them too much.
00:18:24.074 - 00:18:59.142, Speaker B: But I think the important thing right here, we're going to talk about them a little bit, of course. But the important thing here is that the facilitators are the contracts that actually you can create go with, right? So if you want go, you could actually mint go using the Ave V three ethereum facilitator. And this facilitator has a lot of different parts, right. It's part of Ave, which is a very elegant protocol. Very elegant. But there's a few pieces to it too. It's not just a very extremely simple protocol too.
00:18:59.142 - 00:19:36.254, Speaker B: Right. We have pool contracts, debt tokens, oracles, even governance is all a very important part of the AAve protocol and of this facilitator too. Right? So we want to know what facilitators are available to go. Right. And that's a function as well that we have within go. So we can figure out what facilitators there are for go. And then we could actually see a very important part of the go kind of risk mechanism is understanding how much go each of these facilitators are allowed to mint or create.
00:19:36.254 - 00:20:17.114, Speaker B: So we actually see here on this bottom screenshot that the Ave v three Ethereum pool has a bucket capacity of 100 million. So that means that go is saying the go contract says, hey, we permit you to mint up to 100 million. And currently there's about 34.7 million, which is the same number that we saw before. Right, when we queried the total supply of go. So we'll spend a quick minute or two on the Ave v three ethereum facilitator. So what is this facilitator? So the very short version of the Ave v three ethereum facilitator is we can mint go using this facilitator in an over collateralized manner.
00:20:17.114 - 00:21:34.982, Speaker B: So that means that we can supply assets to ave and then we could mint against that collateral. So typically maybe we can supply $2 worth of eth, and then maybe we can borrow one dollars worth of go. One go. And right now it's actually the only way. I think why it's so important is the only way to obtain persistent go. So go that you could actually have in your wallet is through the Ave v three ethereum facilitator. So if we're building any protocol or any interface that kind of gives information about Go, or maybe is informing a user on if they want to borrow go or otherwise obtain it, it might actually be pretty important to really understand Ave v three just as a whole, but also the ave v three data, because there's a lot of moving parts with Ave, and it might be important to kind of inform, like, is this a good financial decision for a user to understand how much yield if I deposit to Ave, how much yield am I going to get? What's the borrow rate? Or what's the fee to maybe mint go and hold on to that debt? These are all questions that are very important.
00:21:34.982 - 00:22:18.790, Speaker B: So I put down here some that I was just thinking of, but there's many more. Part of this whole thing, right, I think, is to understand what is important for your application, what data you might need for your application. But here's a couple that I could imagine might be important, like which assets can be used as collateral, right? You can't necessarily use any token as collateral. So what assets can be used as collateral, how much go can be borrowed, right? There might be a cap on the amount of go that can be borrowed. It might also be important to know that what's the go rate and how much interest is the protocol offering for the collateral. Right. These are all things that might be pretty important to make an informed decision.
00:22:18.790 - 00:23:17.358, Speaker B: So this is the ave v three Ethereum, front end, right? And we'll actually notice that this is a great UI. It has all of the information that I don't know that we were just talking about, right? It has the supply rates for different collaterals. It's a list, I cut it off, of course, but there's a list of all the collaterals that you could supply. So this is like a really great way to see how all the information we need to make a decision on if minting go is right for us. So in order to get all this data, though, there's a lot of contracts we might be needing to interact with. We might need to interact with the Ethereum v. Three Ethereum pool contract to get some data on the rates of all these assets and what assets are allowed.
00:23:17.358 - 00:24:17.626, Speaker B: We might need to hook into oracles to see the price of all these assets. Right? There's a lot of things kind of going on, but luckily the ave interface is actually using a really nice helper contract that I just think could be really good for some of your projects. Maybe because it collects all of this data into one spot. So maybe this is like a way to kind of, if you need extra data, of course you can grab it, but maybe you can take a look at this if you're building a UI with some of your ave data. I think this might be like the 80 20 of the presentation is like, hey, here's a contract that has a lot of relevant data for you. So if we go on over here, there's two key functions, and again, I know we're going pretty fast, but this data or this information, it's in the documentation and I have some links to it in the repo that I'm going to share at the end. So definitely take a look at that if you're interested in using more.
00:24:17.626 - 00:25:00.922, Speaker B: But we have two great functions. One gets really detailed reserve data and the other gets really detailed user position data. Basically we call them user reserve data. So we could see here again, it's not a python class or anything like that, but if we just call get reserves data, we get a ton of data on all of the reserves. And we could really use this for a ton of different use cases. But we can easily get, if we're curious, how much of an asset can I supply, how much can I borrow against a particular asset? It's all kind of collected here. The team did a great job putting this together.
00:25:00.922 - 00:25:55.130, Speaker B: So this is a really great way to see the list of assets and a lot of information about them, including the current rates and how much is available to borrow. So I definitely recommend taking a look at this. And again, don't worry, all this code and everything like that is also in the link, so I hope no one's trying to write this down or anything like that. So in summary, we can get a ton of data from the state of our contracts, like just in that example right there. It's a very powerful way to get the current data from go and then events could help us understand a little bit more, contextualize a little bit more data. Right. We can get historical data and we can see the little pieces that maybe we lose, and we just look at these almost like summarized versions on the contract.
00:25:55.130 - 00:26:26.530, Speaker B: And then maybe this is the main point, right? Like go is more than just an ERC 20 token. Go is so much more than just one token, right? Go is an entire ecosystem, and of course, so is go data. So I think it's really important to keep all of that in mind as we're building our projects. I think the facilitators and the wider defi ecosystem is just a key part of go. So. Yeah, thanks so much. So that was the presentation.
00:26:26.530 - 00:26:53.726, Speaker B: Here is this link. You'll find, I think, two main files in this repo. One is just a readme that has some links in it if you're interested in learning more. And then the other one is just a Jupyter notebook with some of the code. So you should be able to run that and do everything we did today if you want to. Here's where you can find me on exon lens. And I'm happy to.
00:26:53.726 - 00:27:02.446, Speaker B: I know we have a couple of minutes. I'm happy to answer any. Oh my gosh. We have the chat here. Okay, let's see.
00:27:02.468 - 00:27:13.780, Speaker A: Yeah, there was one question earlier on that was already addressed, and then Tommy had asked, is there a way to query the historical borrows lens of an address?
00:27:15.690 - 00:27:44.986, Speaker B: Yes, we want to query the historical borrows. That's a great question. Yeah. So that we can use with events as well. The ave pool contract has an event called Borrow, and that will actually give us who borrowed. It's actually a bit more complicated of an event. There's many more fields, but basically it'll tell us who borrowed, what asset was borrowed, and how much of that asset was borrowed.
00:27:44.986 - 00:27:48.240, Speaker B: Right. So that gives us pretty good information.
00:27:50.450 - 00:28:20.234, Speaker A: Awesome. And then Vincent had asked, can we get a proper documentation? Most documentation on ethglobal is empty. I think this might be referring to maybe some of the resources that I think the team was updating. So Vincent, if you probably go back and check on the website, then all those resources should be updated. But Matt, I don't know if you have anything else to add to that, although I'm not really sure. It's kind of a broad question.
00:28:20.432 - 00:28:46.942, Speaker B: The link is maybe I did a type. It should be lf. Okay, here it is. I don't know if I maybe did a typo, but it should be LFG. Okay, cool. And then the other question was, I see something cross chain bridging. There's no ave cross chain bridging.
00:28:46.942 - 00:28:52.820, Speaker B: For go yet, but that could be something that maybe you look into for the project.
00:29:02.340 - 00:29:18.600, Speaker A: Nandi Ba asked about multi blockchain with implementation on multiple blockchain chain and governance contracts. Go is currently on Ethereum, but it was created aave to have multiple implementation to share the same orchestrator contract.
00:29:20.380 - 00:30:09.704, Speaker B: If I understand this question correctly, this might be about like multichain go, which is something that go right now is only on Ethereum basically. But yeah, I could imagine a facilitator is Ave v three. Ethereum is a facilitator. It might not be that hard to imagine that maybe arbitrum v three could be a facilitator in the future, right? And that would be a different maybe contract. I'm not actually sure how that would work, but that could be something that happens and then is querying event similar as querying a state on a blockchain actually logs. Event logs are not stored literally on the blockchain. Usually the nodes kind of store them.
00:30:09.704 - 00:30:34.610, Speaker B: So they are actually a bit different. They are a bit different. If you're interested in logs, I definitely recommend the blog post. I put it in the notes. That could be a really great read for you. Bridged asset. I don't know the rules, but across bridge go sounds pretty cool to me.
00:30:34.980 - 00:30:40.276, Speaker A: Yeah, that's fair game. If you can do it, go for it.
00:30:40.378 - 00:31:16.060, Speaker B: Yeah, that sounds good to me too. Is testnet go? Maybe someone else can answer what testnet, but I think maybe that is true. Okay, awesome. I think that's all the questions for creating a new facilitator. Maybe the testnet has different governance. I'm not sure that would work for creating a new facilitator, but I think that there might be a workaround.
00:31:19.390 - 00:31:28.778, Speaker A: This is a long one and yeah, we'll probably maybe end it in about two minutes. So this might be the last question.
00:31:28.944 - 00:31:30.060, Speaker B: Okay, perfect.
00:31:46.510 - 00:32:00.660, Speaker A: Folks, if you have other questions, definitely once this ends, you can always drop them into the partner Discord channel as well, and some of the mentors will be able to address them too. If you have a question that we weren't able to address in time.
00:32:02.390 - 00:32:52.146, Speaker B: Yes, this question about borrowing. Yeah, basically it might sound a little bit strange, but yeah, if you borrow 100 go and say you're the only person that borrows go at the end of one year, you would owe more go than you borrowed and there actually wouldn't be that much go in existence. Right. That might sound weird and maybe concerning, but the idea would be that if that were the case, which it isn't, then the price of go would probably go up and then people would borrow go to kind of arbitrage that difference. Right. And then there would be much more go in a vacuum. This sounds very strange, but the go peg would kind of facilitate minting more go.
00:32:52.146 - 00:33:11.350, Speaker B: So I think that's a good question that maybe deserves a lot more of an answer than I gave, but yeah. And yeah. Ave V three is the only facilitator as well as the Ave the flash mint facilitator. Cool.
00:33:11.420 - 00:33:37.274, Speaker A: Awesome. Well, thanks, everybody for attending, and thank you, Matt, for the great presentation. And yeah, like I said, if you have questions still, please send them into the partner channels on Discord. And if you haven't done so already, connect your hacker dashboard to discord too. But yeah, we look forward to continuing the rest of the day. Don't forget opening ceremony and summit. It starts in a couple of hours and there will be more workshops throughout the day as well.
00:33:37.274 - 00:33:39.646, Speaker A: So cheers all. Thank you, everybody. Thank Matt.
00:33:39.678 - 00:33:40.430, Speaker B: Thank you. Bye.
