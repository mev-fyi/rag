00:00:06.330 - 00:00:37.590, Speaker A: All right, everyone, thank you for joining the workshop today. We have Neil Davis here. It's going to be a half hour workshop. Workshop is titled Urbit Apps on Herbit. So the Herbit team is going to be obviously engaging in discord throughout the upcoming hackathon. You can reach them there and also in their own channels. You'll be able to ask questions throughout.
00:00:37.590 - 00:00:48.730, Speaker A: I'll point your attention to the zoom chat is probably the best way as we go, and with that, I will hand it off to Neil.
00:00:49.890 - 00:01:55.700, Speaker B: All right, thank you. I hope my audio is coming through clear there. So I would like to talk about what it looks like to develop on Urbit. Architecturally, I'm not going to spend a lot of time talking about the underlying programming language and some of the other details. If that's something that you need to get into to participate in this component of the hackathon, then there are a lot of resources I can point you at. But what I'd like to mainly focus on is the architecture of the Urbit system and how this impacts the kinds of apps that you'd be able to build and how it would relate to something like IPFS or Filecoin and other kinds of decentralized applications as these things come out. So as we look at Urbit as a system, I'm going to enumerate a little bit of what Urbit does for you and try and give you a feel for what it is.
00:01:55.700 - 00:03:27.674, Speaker B: It sometimes gets described as a personal server, which means something, and I think it's a correct way to say it, but I think a lot of people miss exactly what's trying to be communicated by that. So in the first place, Urbit is essentially it's an operating system, we call it, and we generally treat it as an overlay operating system, which means that it's running as a platform within some other operating system. This is similar to the way that a lot of cloud services run, for instance, and it's built as a functional as in language platform. So when you operate with it, you can treat the main kernel as a persistent event state machine. Here, persistence refers to the fact that events are written to memory before the output of those events is emitted, which means that it is completely stateful and an event log is retained that yields your current state at any particular time. It also means that in principle, whatever state you get your operating system into is understandable and you can find exit paths and adaptation paths and upgrade paths that can restore it if you've gotten into some kind of unworkable state. There are a lot of advantages of having a functionalism language OS in this sense, that's the Urbit OS component.
00:03:27.674 - 00:03:59.820, Speaker B: And there's another part of Urbit which is the Urbit ID, which serves as a cryptographic identity. So this is a unique point. It's like an address space point, similar to a regular IPV four. I-P-V six Internet address. A URL. But they're not dynamic, they're static. Once you have that, it is identity that you can treat as something that you can attest cryptographically that you own and you can interact with.
00:03:59.820 - 00:05:24.180, Speaker B: This gives you true peer to peer decentralization and it gives you end to end encrypted networking and the ability to build apps on top of these OS level primitives. So these aren't services and third party components that are built on top of your operating system. These are pieces that are baked into your operating system at the ground level that it has these capabilities. And it also means that when you build applications, what I may call apps or sometimes agents, it means that they have a standard structure on the back end, similar to if you're writing a Chrome extension, it's expected to have a certain shape and interact a certain way, because chrome is the platform that it will always be working on top of. If you're writing a net application, there's going to be certain requirements that that has. And by defining and requiring a certain standard application structure for everything that runs on Urbit, it means that you're able to define very portable ways of interacting with data that are held by other agents. You can start to treat the entire operating system as an ecosystem rather than a set of ivory towers that sit next to each other and that you'd have to interact with that way.
00:05:24.180 - 00:06:05.170, Speaker B: Now I'm going to turn the system on its side and talk for a moment about what urban looks like for the developer. This is a little bit complicated. You can imagine that if you were drawing a diagram like this for developers to take a look at for Unix or a lot of other systems, it would sort of be equally as complicated of a system. But I want to start us in the middle there with that red block, which is the Urbit OS. That was the first part I was talking about. This is the state machine. This is the event handler, the processor that takes care of everything that you do on Orbit.
00:06:05.170 - 00:07:07.960, Speaker B: And this essentially serves as a backend and an application running layer that handles everything that goes on above it. So these letters that I have, ABCDE, these are components of the system that I'll talk about more in a moment. They're called Veins, but they're essentially system daemons. They're system services that persist, that provide certain like system d or something where they're persistent services that are available to you through one of those, the J one, which is short for jail, it interacts with Urban ID, which is bootstrapped on Ethereum. And so you're able to pull the state and you understand the state of your own, the cryptographic state of your own identity and the cryptographic state of any other urban instances that you are interacting with on the network. And then on top of the G the user space vein. This is where everything that a user does is interacted with as they do things on the system.
00:07:07.960 - 00:08:00.946, Speaker B: Most of the time when you're building an application in Orbit, you only really care about the top parts of this. You don't have to worry about what's going on on the host OS or the hardware or everything down at the bottom. However, it's worth discussing this briefly because it does inform a lot of the architectural design decisions that were made that make Urbit what it is. So Urbit is designed so that everything that runs on it compiles to a language specification called NOC. This is similar to a bytecode or kind of what an LLVM or a JVM or other systems do. It serves as kind of a microlisp VM specification. This is what the system runtime.
00:08:00.946 - 00:08:54.390, Speaker B: The executable file is actually operating it's, interpreting these instructions, translating them down to whatever the host OS and the hardware layer needs to look like to actually evaluate those. But we can treat it the same way we would treat JVM or EVM or anything else. That's a virtual machine that we don't care about the underlying hardware, we just care what it does for us. And we assume that that runtime is doing the translations for us correctly. Now, when we write things that would interact with, say, IPFS, most of those things are going to take place through the system veins, which are the colored letters here right above Arvo, or they're going to take place entirely in user space, which is where end user applications live. Urbit serves as a backend in many respects. I described it at the beginning as a personal server.
00:08:54.390 - 00:09:46.054, Speaker B: This means that you have a CLI or a REPL interface that you can interact with. You can work with it, but for the most part, you're using some other application to provide a front end for you. Most frequently, this is the browser. There are a lot of react based apps, front end apps, that talk to Urbit via a regular Http API. And so you're able to do a lot of things in just pure JSON put get requests, and you don't have to worry so much about what programming on Urbit, as long as you know the architecture that it expects. Right? Like any other API, you can treat it that way. But we do need to talk a little bit about what the operating system does and how it handles these messages and everything.
00:09:46.054 - 00:10:18.318, Speaker B: And so I'm going to take the top part of this from Urbanos Arvo up, and I'm going to map it in a slightly different way, which gives us a different view on what's going on. And I'm going to briefly check chat. Okay. Nothing in chat. All right, so turning this on its side, what I'm envisioning here is that this central circle in the middle represents the runtime system that's actually operating everything. There's a ring around that that's in the brighter colors. That's Hoon, Arvo, zeus and Lull.
00:10:18.318 - 00:10:52.246, Speaker B: This is Arvo, which is the urban OS layer. Hoon is the language. So this is the components of the language. And then Zeus and Lull are the standard library. And then on top of those run the system services. And then based on those system services would be applications and end user applications that we'll talk a little bit more at the end here. So if we expand this down and we just look at what the system services are, these are essentially your operating system primitives.
00:10:52.246 - 00:11:39.530, Speaker B: These are the things that Urbit as an OS knows how to do for you that you don't have to worry about provisioning if you're writing an application that works on these, some of these make a lot of sense. Putting networking, it's UDP based packet networking, like I said, end to end encrypted. So this is handled by one of the veins which is Ames. There's a timer vein which does wake ups after a guaranteed time. There's a file system internal to an urban ship. You could think of this the same way you would like it's not an S three bucket, but you could think of it as similar to that, right? It's a way of representing all of the data on the system as a tree. There's a terminal interface.
00:11:39.530 - 00:12:22.300, Speaker B: The relative sizes of these are drawn from the size of the code base in terms of lines of code. So you can sort of see basically how prominent different parts of this system are, or conversely, how relatively simple it is to implement different parts of this. There are server services, client services, user space refers to the apps and having a standard interface the way you would for a net or a chrome extension. There's some cryptography, there's some various tools for doing that. Most of them are architected towards urban ID. But there are some other cryptographic primitives that you can use as well. So largely that's what this is built around.
00:12:22.300 - 00:13:07.686, Speaker B: As a back end system, this makes a reasonable amount of sense. You might think of a few other system primitives that it would be nice to have. But if you're looking at a system that's going to act as a server instance or behave like a server to the things that are interacting with it, you have a lot of things that make sense here. You don't have things that at the current time don't make sense to put into an application like this. So you don't see for instance, machine learning algorithms. These would be relatively inefficient to do on a VM style system. Of course, we do this all the time on the cloud as things currently stand, but you take my meaning there.
00:13:07.686 - 00:13:45.960, Speaker B: You want to run things like that as close to the metal as possible. There aren't visualization tools for instance, because those would typically reside in the front end. And this is kind of purely a backend view of the system. And of course you can do that in user space. You can do that for end user applications, but primarily that's going to live in whatever client is talking to Urbit as a server. Inside of that you have the operating system layer itself, which is the standard library components, the event handler and event log, and the language which is designed to build everything and work efficiently. In that regard.
00:13:45.960 - 00:14:32.286, Speaker B: Urbit has its own language called Hoon that things are done in. It has some interesting features from a computer science perspective. Everything in it is built as a binary tree, so everything in it is a leaf or a pair of nouns. And we have lots of materials on that. If you find yourself needing to delve into the language, it's kind of a refreshingly different way of thinking about language construction. And I've found it to be a helpful and rewarding way of thinking about what's going on with this. And then at the center of this we have the actual runtime, which is our VM layer, which is doing it's, actually evaluating and executing the NOC specification.
00:14:32.286 - 00:15:16.610, Speaker B: However, it receives that from the urban OS layer that is above it. As a hackathon participant, you are primarily going to be interested in three components of the Urban system. This is the file system, the server, vein, and user space. User space refers to apps or agents. This runs in a system the percent G refers to. Gaul is the name of the agent. Basically every end user application behaves as a persistent daemon that may or may not currently have a front end client session that's attached to it.
00:15:16.610 - 00:16:01.642, Speaker B: So it's running in the background. Sometimes you open up a browser or an app and you talk to it, but you're not always doing that, but the stateful identity of that application continues and you're able to work with it. As I said, these all have a standard form. I find that this makes it relatively quick to spin up new instances when I need to write something new because I know exactly, basically the handshake that it needs to make with the system to work with everything. The vein itself, gall will broker your access to all of the other Arvo services. It's kind of a message passing interface. They pass discrete messages called cards to each other and this is how they communicate.
00:16:01.642 - 00:16:40.362, Speaker B: These are the events that are handled by the event handler and event log in the middle. And then it's going to communicate with whatever front end you have via Http API using the Air server, which is this one. So it has. Http API endpoints It tends to prefer a data subscription model. So there's different ways you can think about constructing an API. Urbit likes a dataflow model wherein you open a channel and you listen for that channel. You listen for events to come over that channel.
00:16:40.362 - 00:17:27.260, Speaker B: So there's a cookie based authentication that sets up this channel. And then you either emit JSON events down this channel or you receive them back from this channel. So you can communicate entirely in JSON and get put requests, so you don't have to know the internal language of the system to understand how to talk to the system. And then mine types are Arbo level primitives, they're urban OS level primitives. And so it's relatively straightforward to do conversions from the JSON that you're sending in or whatever values you have stored inside of that, to whatever internal representation you need. Stepping back for a moment to the file system, this is an interesting one. So Clay is a typed file system.
00:17:27.260 - 00:18:37.726, Speaker B: Every bit of data on it has a type associated with it. It's also a version controlled file system, which means that the file system doesn't treat everything as a binary blob, it actually understands something about the structure of the files that are stored there. Right. The same way that if we change the extension on a file name in macOS or Windows or whatever else, we may get a warning from the system. But of course it doesn't change the data, right? Changing TXT to PDF doesn't do anything to the data, it just confuses the system because you've labeled it wrong. Ervet actually attaches that as metadata to the file data, which means that you are only able to access it through a type, which is called a mark. And so once you have data in some form on the system, you can access it through different equivalent marks, right? If there's more than one equivalent way to access it, if it's a JSON, maybe you can open it as an XML because there's a well defined mapping between JSON and XML.
00:18:37.726 - 00:19:13.146, Speaker B: And of course you can open it as a text file. So you get this for free by working on this operating system. It's also referentially transparent, so it collapses everything down. It's a global namespace, which means that part of the prefix that is on the location, the path for any file resource there is the cryptographic identity that refers to it. And so in principle you're able to refer to anything on any system. In practice, of course, there are permissions and everything that you have to worry about. And then currently there's a two gigabyte limit on what can be stored in Clay.
00:19:13.146 - 00:20:06.110, Speaker B: This isn't a fundamental limit, it's basically just an in media res development limit while we work on that and at some point that will be taken off. But it also means that something like IPFS and Filecoin is very desirable for us because we would like to be able to store larger, decentralized files without filling up our nice typed version controlled file system for applications where those guarantees may not be as important. Right. If you're storing an MP3 or an MPEG or something, you don't really want it under version control so much, probably because as a binary blob. That doesn't matter, right? Your diff is just going to be deleted and re uploaded. It's not going to be a sensible diff. So those are the three components there.
00:20:06.110 - 00:20:59.038, Speaker B: Before I field questions, I want to make a few comments for hackathon participants. So you have three weeks, right? Hackathons are accelerated and they require you to focus on the economy of what you can learn and get done in that time frame. So my suggestion at this point is to focus on client side applications that build on your strengths coming into this. So, for instance, a browser front end or an app front end that communicates with Urban on the back end, but doesn't require you to do as much server side development. For many of you, that will probably be faster. You can work from good code models. So there's currently an S three integration which can be found in the Urban code base, and I'm happy to point anyone at that.
00:20:59.038 - 00:22:04.800, Speaker B: That's the sort of thing that you would extend if you, for instance, wanted to do a filecoin s three integration layer, that would be the part you would look at. So there's a lot of good code models in the current code base that you can use to reason analogically about how to build other things during your hackathon window. And then we have some specific learning resources called Hoon School and App School, which are available at developers Urbit.org. I myself will be present on the Discord. You can find me on Twitter at Sigilante or on Urban at Lagravnokfeb, but I'll be on the Discord as well. And so this is my lightning fast look at what is going on with Urbit. Are there any questions? Yes, I can show you some example apps and what that would look like.
00:22:04.800 - 00:22:58.074, Speaker B: Let me show you what it actually looks like to run Urban really quick. All right, so what I have here, I have my regular bash bash prompt. So I'm going to go into Urbit and I'm going to locate a particular Urbit executable. And then I have an Urbit instance already sitting here in a folder not currently running. I'm going to go ahead and open it and then this takes me to a REPL. So it'll sit at a REPL. There's nothing really going on here that's particularly interesting, but you will notice that it has web interface live on http localhost 80 81.
00:22:58.074 - 00:23:33.590, Speaker B: So if I come over here and I open that up, it asks me for a login. So to log in, I have to get a code from the back end. It's always the same code for the default example ship here. So I'm not revealing any secrets by showing you the password in this case. But I'm only running this locally, so of course you'd want to be more cautious with that and I don't need to save that. And when you open that up, it will open to some window that looks like this. So these are apps that are installed by default when you run such a ship for the first time.
00:23:33.590 - 00:24:17.550, Speaker B: And so there's a web terminal which is similar to the command line REPL here. There's Groups, which is the main social media application. There's a Bitcoin wallet that I can link to and then you can install other applications if you're on the live network. This particular example ship is not, but if I go to my personal ship which is running on the network, then I can show you the kinds of things that are available. So there's a lot of applications that other people have built and shared. All of these show up in this single box. All of these are peer to peer distributed.
00:24:17.550 - 00:24:55.122, Speaker B: So it's kind of like BitTorrent where if someone decides to put something out there, I can synchronize directly with it. So if I click into one of these like the Docs app, it'll go ahead and open this up. So all of this is talking to my server backend process that in my case is running on a Raspberry pi. People run them on hosting, people run them on their own laptops. You can run it on a digital ocean droplet wherever you want, right? Run it in whatever case. This is a Docs application, so it's not like the most flashy and exciting one to look at. But there are some other ones that people have built.
00:24:55.122 - 00:25:44.160, Speaker B: There's a few game ones like a Wordle clone here that you can go through. So this is what it looks like to run an urban instance. What the actual experience is, like the code itself. Let me briefly show you some system code, all right? Hoon is a language that is not keyword based. And so it looks more like something like APL. Everything that starts with a double colon is a comment. So most of this is actually comments on the line that I'm looking here.
00:25:44.160 - 00:26:44.500, Speaker B: So it's like APL, but it's like an ASCII based APL. So these are defining structural or syntactic relationships between the data that are part of the system. It's a very expressive language and there's a lot of equivalent structures that you can set up that would do something similar but give you different ways of thinking about or structuring or interacting with the underlying data. It sometimes blows minds a little bit when you see it for the first time because it does look like this kind of very terse language, but there's a lot of power in that. And for instance, most of this is defining instances of these are data types that are going to be used down file in this particular instance here. So this is the Arvo definition file itself, right? So it's an open source operating system. So of course you can open up the hood and look at anything that's going on inside of that.
00:26:44.500 - 00:28:13.040, Speaker B: All right, other questions. Okay, very quickly, what would you tell someone to convince them to use Urbit, what's the value proposition? Who's the target user? Okay, so if you need true, decentralization peer to peer apps, if you value end end encryption, and if you value data ownership, then Urban is a good application for that. It has been shifting in the past year to focus more on web three applications for doing things like maintaining off chain state ideas, where you could do attestations where you do a calculation and you post the hash of the calculation to the chain and then anyone else can go verify that you did the calculation that was actually involved. If you need cryptographic identity, that's really valuable. I think if you use Urbit you will find that not having to worry about re implementing a lot of common primitives like password systems and handshakes and web server APIs, API, endpoints systems, these sorts of things. Not having to re implement these things and not having to pull in tons of libraries to make them work is powerful and valuable to you. So that's the quick version of my value proposition and I think I'm about out of time on this.
00:28:18.530 - 00:28:50.654, Speaker A: It we're about at the end here in terms of the scheduled time, but if anyone has any other questions, we could take a minute or two more, but if not, just to remind everyone that the Urban Team is available in the discord and in their other channels. Also, thank you very much, Neil, for an excellent workshop today. Encourage everyone to keep the conversations going.
00:28:50.812 - 00:28:51.866, Speaker B: My pleasure.
00:28:52.058 - 00:28:55.390, Speaker A: And thanks everyone for joining. Much appreciated.
00:28:56.290 - 00:28:58.890, Speaker B: All right, see you around. Bye.
