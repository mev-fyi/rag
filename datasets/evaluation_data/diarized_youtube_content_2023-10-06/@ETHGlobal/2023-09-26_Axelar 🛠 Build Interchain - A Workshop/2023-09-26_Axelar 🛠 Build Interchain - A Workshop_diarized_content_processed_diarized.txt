00:00:07.050 - 00:00:33.238, Speaker A: Agenda for today. Briefly, we're going to go over the need for interchain, how we got here, why this matters, the problem with pairwise bridges as they've existed over the past few years, an overview of the Axfor network and the advantages which it brings. And then we're going to get into general message passing, otherwise known as GMP. This will hopefully be interesting for you guys. This is what our bounties on is best use of a GMP. We're going to go through a code example of it and then we're going to end off with Axelar in the wild and some fun stats. So, a bit about myself.
00:00:33.238 - 00:00:58.874, Speaker A: I got into the blockchain space in late 2017 and I'm sure many of you had the same experience for me. When I was trying to get in, I would go to many meetups, that was my thing. I try to meet as many people as I could, make friends with as many people. And what I noticed is that you go to these events, you don't know anyone, and everyone seems to know a lot more than you. And everyone is extremely opinionated. And many people at the time were trying to promote certain projects which they were involved in. So there was of course, ethereum.
00:00:58.874 - 00:01:27.362, Speaker A: But there were also projects that people were kind of promoting as like the Ethereum killers. There was Neo, which was branded as like the Chinese Ethereum. There's Iota Tron EOS, which was branded as like ethereum on steroids because it was faster and cheaper. And this mentality that people had at the time was that of chain maximalism. This idea that there will be one blockchain to rule them all and the rest will kind of die. I think it's safe to say, looking back now, that what we've learned is chain maximalism is wrong. This never actually happened.
00:01:27.362 - 00:02:07.800, Speaker A: Instead, what we saw was the rise of more and more blockchains. And if I could find my mouse here, this is a brief screen recording I have from a website called Chainlist. And what Chainlist does is it shows you the list of many of the blockchains that exist today. I say many, not all, because it's impossible to actually know how many blockchains exist today. What I'm trying to show you here is that you can see just on Chainlist, there's hundreds, if not thousands of blockchains that exist today. And for our space to be successful, we need to find a way to connect them. And this question of interoperability, if I could get out of this.
00:02:07.800 - 00:02:49.958, Speaker A: This idea of blockchain interoperability is nothing new. We've known for years now we need to have interoperability for the web3 space to be successful. But what we saw was the rise of pairwise bridges which were using like wrapped assets and multisig to handle actual transactions between the chains. And the problem with multisig contracts as bridges is that they were extremely vulnerable to attackers, especially if the keys were compromised. And you can see here some of the more famous headlines I pulled up. There are many more than these, but these are some of the famous headlines of some of the biggest hacks that we've seen. The most famous one probably being the 625,000,000 Ronan Bridge hack for all you Axio Infinity players out there.
00:02:49.958 - 00:03:27.922, Speaker A: But there's also, like the polynetwork hack that happened just a few months ago, earlier this summer, who had a three of four multisig key compromised and more. So this interesting article by chain analysis. They estimated that in 2022, 69% of all funds stolen in crypto, it's about $2 billion that was stolen was actually attacks on bridges. So let's pause right here. What do we know? We know that the number of blockchains is rising. Interoperability is more important now than ever before, but we as a space, can do a bit better in the way we conduct interoperability. And that is where Axilar comes in.
00:03:27.922 - 00:03:46.438, Speaker A: So Axilar at its simplest is a blockchain that connects blockchains enabling universal web3 interoperability. That's a bit of a mouthful. I don't expect you to take a lot out from that. So let's actually dissect this. We're going to dissect it by looking at the Axler network. So this is the easiest way to actually see Axelar. It's a hub and spoke model.
00:03:46.438 - 00:04:15.802, Speaker A: And I want to focus on the last three words from that previous definition. I had universal web3 interoperability. Why am I focusing on that? That's because if you look at some of the blockchains here, just notice it. We have ethereum, phantom polygon. These are examples of blockchains running the Ethereum virtual machine. We also have projects like Osmosis, Juno, the Cosmos Hub Region Network. These are projects built on top of the Cosmos SDK that are using Comet BFT Consensus.
00:04:15.802 - 00:04:38.850, Speaker A: We also have Arbitrum. We also have Linear Base, though I don't think those two are on this diagram here. In total, we have 49 blockchains right now that are all connected with Axelr. And these are different blockchains with different consensus mechanisms, different virtual machines. We have app chains that are on here. Let me go back to this. So that's its idea of universal web3 interoperability.
00:04:38.850 - 00:05:06.218, Speaker A: And the two major improvements which Axler brings right out of the box are that of scalability improvements and security improvements. So let's talk about scalability first. If you picture pairwise bridges sorry, I know it's a bit hard to read, but let's imagine we have three blockchains. In blue. We have ethereum. In yellow, we have BNB, and in purple, we have polygon. Now, to connect each of those three blockchains to each other, for three chains, we need six bridges to connect each blockchain to each blockchain.
00:05:06.218 - 00:05:43.174, Speaker A: Say we want to add a fourth, say avalanche, just for that one extra blockchain. We're now at nine bridges to connect all these blockchains. And you can imagine, like with what I was showing you guys earlier on chainlist where there's like thousands of blockchains that exist to connect each blockchain to each blockchain, or I don't even know how many bridges to connect each of those, but the point is that number doesn't really scale. And if you contrast that with Axlair, where we have a Hub Ben spoke model, all you need is one connection to the Axelr network and then you're connected to all the other blockchains that are connected with Axelr. And I like to think of this in my mind as like these pairwise bridges are kind of like train tracks. You can go from point A to point B and that's it. Whereas with Axelr it's more like an airport.
00:05:43.174 - 00:06:10.514, Speaker A: All you need is a connection to Axelr. You just need one airport in your city and then you can connect to any other city in the world that also has a blockchain. So that's scalability improvements. If I go back to my second point here, there's also security improvements, and I touched on that a bit. But Axelr is a blockchain of blockchains. So what does that mean? It means that we're built on top of the Cosmos SDK. We currently have 75 live Validators.
00:06:10.514 - 00:06:51.806, Speaker A: Anyone here in the Cosmos ecosystem might be familiar with some of these Validators, like Figment, informal systems, poker Chu, these are well known Validators who are also validating many other chains in the Cosmos ecosystem as well. And this is a tremendous step up, actually having a blockchain to handle Interoperability compared to just like a multi SIG contract. But now that we've covered the use case and how Axler is helpful, let's look at what we can do now that we couldn't do before. And that is general message passing. And this is the exciting part, I hope, for you guys, because it's what our bounty is on and it's best use case of GMP. So what is GMP or General message passing? It's this idea that we could actually send a message between one blockchain to another. Pretty straightforward.
00:06:51.806 - 00:07:25.114, Speaker A: And you can see myself on ethereum. This is a picture of me from my first ever blockchain meetup. I spent way too long looking for it. And this is me here on Avalanche. So on the first message I'm sending, like wagme, like, are we going to make it in this crazy amazing space that we're getting ourselves into? And then from Avalanche to Ethereum, I'm sending a message called Safe Mint five Board apes. And what I'm trying to show you here is that in addition to just sending like kind of silly little hello world messages, you can also actually call functions between one blockchain from another blockchain. And that is true interoperability.
00:07:25.114 - 00:08:04.374, Speaker A: It's the idea that we can actually interact with contracts and applications on different blockchain as easily as if they were on our own blockchain. So a very brief diagram here. I know the text is a bit small, I apologize for that, but a brief diagram of how GMP works. So imagine we have let's start from the bottom left corner there we have our amazing hackathon project and we've deployed that on the Avalanche blockchain on the right. We have also deployed that application on the Polygon blockchain. And we want to send an ERC 20 token from Avalanche, from our application there to our application on Polygon. So the first thing we have to do is interact with something called a gateway contract.
00:08:04.374 - 00:08:36.350, Speaker A: A gateway contract is a contract which Axler has deployed on every single blockchain that it interacts with. So the gateway contract exposes several different functions, including call contract with Token. So step one, you have your DAP. Your DAP does some amazing idea. You're going to import the gateway contract and from the gateway contract you're going to call this italicized Call contract with Token. That jump starts a process through the gateway contract which emits an event. The event is then picked up by the Axflar network.
00:08:36.350 - 00:09:02.490, Speaker A: The Axflar network member is a blockchain with 75 validators. Those validators come to consensus about the message that was sent. If they're all on board, we're all happy. They send a message to the gateway contract on Polygon, on the destination chain that the message was approved. And then via something called a relayer, the gateway contract triggers step four, execute with Token. This Execute with Token is a function which you're going to define yourself in your contract. And you can do whatever logic you'd like with it.
00:09:02.490 - 00:09:28.254, Speaker A: With the message that's coming in, you see the Bytes 32 payload. And we're going to go through a quick code example so you can see that in action. But one more time, high level, your application is deployed on two blockchains. You call the Call contract with Token from the gateway contract under the hood, gateway emits an event picked up by the Axler network. Axler Network lets the other gateway on the destination chain know that, hey, we're good. Then the gateway calls the Execute with Token function via relayer. So let's see this in action.
00:09:28.254 - 00:09:57.630, Speaker A: And sorry, I know it's a lot, but trying to get through a lot in a little bit of time. So for time's sake, I'm not going to write out this code and we'll see how we're going to do it. But what we're doing here is we're trying to implement the previous example, which is to send an ERC 20 token from Avalanche from the source chain to Polygon, our destination chain. So first thing we do is import our ERC 20 interface from Open Zeppelin, pretty standard. We then import the Axleware Executable, which I will get back to in a bit. Sorry, this is small. Let me make it bigger.
00:09:57.630 - 00:10:22.342, Speaker A: This is as big as it goes. Are we happy? Can we see this? Okay. Next thing we do is import the Axler Executable, which I'll get back to. Then we import the Axler gateway contract. Is this familiar to anyone? Axelar Gateway that is, remember this guy? The gateway contract which is going to expose the functions that we need to interact with. So we import the interface for that. We then import the interface for the gas service.
00:10:22.342 - 00:10:48.880, Speaker A: This is the other very important contract which I conveniently left out, is that diagram. So let's think about it. If we want to send a transaction from avalanche to Polygon, we're going to need three different tokens. One, AVAX for the avalanche blockchain, two Axl for the Axelar blockchain. Remember Axelar, which is facilitating this is itself a blockchain and then three matic. That is the token of the destination chain. Polygon, though I think they're changing the name of that.
00:10:48.880 - 00:11:23.414, Speaker A: And the problem is I don't want to hold three tokens every single time I want to send a transaction. I don't think you guys do either. So the gas service does it, it extracts that difficulty. We can just via the gas service teller contract like, hey, we need funds for the matic, for the Polygon blockchain, we're sending it from the avalanche blockchain and I am the person sending this transaction. So now all you need is the token of the source chain. If you're sending from avalanche to Polygon, you just need AVAX and you're good to go and the gas service will handle the rest. They'll handle the matic and the Axl token.
00:11:23.414 - 00:11:51.026, Speaker A: So you don't need to hold all three. That is what the gas service does. If I go to step two here, if I could find it, the first thing we do here is simply in our constructor we pass in the address of the gateway and the address of the gas service. Remember, every blockchain which Axelr is on has a gateway and a gas service. If I go to step three, we define our first function which we're going to be using here. This is not a specific name send to many. I just picked this.
00:11:51.026 - 00:12:41.902, Speaker A: You can call it whatever function you want and send to many. When you call this function, it's going to jumpstart this interchange transaction. It's going to be the function that you call to send an ERC 20 token from chain A to chain B and it takes five parameters, the destination chain like hey, which blockchain are you going to? Destination contract address, which is this contract itself, which will be deployed on both blockchains, the destination addresses which I will come back to and then just the symbol and the amount of the ERC 20 token that we're passing it. So if I go to step four, we have some pretty simple functionality here. First we require, say like, hey, make sure we pass in some gas, if not revert. Then we grab the address of the ERC 20 token that we're sending. We can do that by just passing in the symbol of the token to the gateway.
00:12:41.902 - 00:13:16.986, Speaker A: We then have some standard ERC 20 stuff. We transfer the tokens from me to this contract, we then approve the gateway to be able to handle our tokens. Then we encode our third parameter, our destination addresses, which is a parameter I promised I'd come back to. Basically, if you think about it, all we're doing here is sending an ERC 20 token from one chain to another. But what's exciting, what I really wanted to show you guys for the bounty is general message passing. That's what this is all about. So what this third parameter is our message that we're going to be passing along with our token from one blockchain to the other blockchain.
00:13:16.986 - 00:14:01.752, Speaker A: And to pass that message, we actually have to encode it into bytes. And that's what we're doing here. If I go to step five, I now interact with our gas service and our gateway contract. And for time's sake, I'm not going to go through all this. But basically what we're doing is we're telling the gas service like hey, call this super long function, pay native gas for contract, call with token and we're telling the gas service like hey, we're going to need funds for the polygon blockchain as well. We then call our gateway contract here on line 61. This is the call contract with token function which if you can recall is the function that we had defined here in our diagram which was being exposed to us from the gateway.
00:14:01.752 - 00:14:52.140, Speaker A: So on our gateway contract we say like, hey, we want to pass in the destination chain like Polygon, we want to pass in the destination contract address the encoded recipient addresses. So like our actual message which is coming and then our symbol and our token amount. And once we call this function we are going to have kicked off our interchange transaction. So once I call this and all this logic gets executed, our transaction will now be leaving the avalanche source chain and going to the Axfar network, which is great. But if you recall the diagram, we also need to do something on our destination chain. So the transaction goes to Axlar and then comes out the other side on polygon. But like, what do we do there? So for that we have our final function which is execute with token.
00:14:52.140 - 00:15:38.344, Speaker A: And now this function is going to be triggered on polygon automatically and it's going to handle some logic with our message that gets passed. And this is our final step here. We're going to be taking our payload. Notice the third parameter here, which is our message that was passed, our list of addresses. And then on line 90 we're going to take our amount of tokens that was sent because remember, we're sending an ERC 20 token and a message. So let's say we send six USDC or aUSDC and we divide it by how many addresses we've sent and that is the amount that we're going to send to each address, which is really, really powerful because not only are we sending the token. But because we're sending a message with it as well, we can compute some logic.
00:15:38.344 - 00:16:09.912, Speaker A: In this case, very simple logic, but logic nonetheless that we're going to be doing on our destination chain after our transaction is sent. And I executed this earlier today. I figured I'd be short on time, but it's all done through the hard hat CLI. So I'm not going to go through this. But what I did want to show you guys is this transaction actually going through on the Axelr Scan Block Explorer. So remember, since Axelr is a blockchain, it also has its own blockchain. And you can see here the step by step of each step of the transaction process.
00:16:09.912 - 00:16:38.812, Speaker A: So you can see step one, the transaction gets sent on avalanche. The gas gets paid on Avalanche. The Axflor network confirms the transaction. I can scroll down here for more details. Step three is confirmed and approves the transaction. And then the final step, it gets executed on the Polygon Block Explorer. And you can see here, I can actually click right through from the AxLR scan block Explorer, from the AxLR scan block Explorer to the polygon scan block Explorer.
00:16:38.812 - 00:17:17.340, Speaker A: And you can see here our transaction actually our logic being executed. We send six tokens and then evenly send two tokens to each of the recipients. So that is a very high level of Axelr GMP in action. The thing I want to end off with is the more fun stuff, just Axler in the wild. So this is an application called Squid, which is being used today. It might look familiar to anyone here who's ever used the Dex before. And you can see that what's cool about Squid is that in addition to selecting the token that you want to send, you can also select the blockchain you want to send.
00:17:17.340 - 00:17:37.120, Speaker A: So in this case, I'm sending GRT from Ethereum to USDC on optimism. This is all in one click. Really powerful stuff. And I want to end off with some stats here. This page might look oh, I didn't spend that much time on Axler scan, so a bit unfamiliar. But this is from the Axler scan Block Explorer. You can see just some of the stats about the Axler network.
00:17:37.120 - 00:18:10.876, Speaker A: You can see 66,000 transactions, $3 billion of transaction volume sent. And the really exciting part is that this is just over the last 30 days. I know it's a bit small, but it's a really, really exciting time to be familiarizing yourself with this stuff and using Axelr. Here are some resources for anyone doing the bounty. On the left I highly recommend it is a series of YouTube videos we have just explaining this stuff. And on the right is our GitHub repo of just examples using this stuff. And yeah, thank you very much.
00:18:10.876 - 00:18:13.050, Speaker A: My name is Ben Weinberg. Hope to see you guys around.
