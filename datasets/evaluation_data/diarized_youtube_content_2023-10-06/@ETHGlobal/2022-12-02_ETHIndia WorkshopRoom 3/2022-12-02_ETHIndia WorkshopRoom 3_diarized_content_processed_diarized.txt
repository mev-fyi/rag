00:04:36.150 - 00:04:36.700, Speaker A: It.
00:09:21.290 - 00:10:08.984, Speaker B: I think they're set if it works. No, sorry. Yeah. Yes, it's working. Thank you. All right, I think I've been given the light to proceed. So, as one of the first speakers, I would like to welcome you all to ETH India.
00:10:08.984 - 00:10:57.460, Speaker B: And I'm Rajiv, I'm a security researcher and founder of Securium. I'll be talking more about that later. But this talk, it's definitely not a workshop, it's a talk. 30 minutes is not enough to dig into how to do smart contact securely, but we'll be talking a lot. Well, I'll be talking a lot about the high level aspects, trying to impress upon you the status of smart contract security today. What is the status, is it enough? Why isn't it enough? What is being done, what are the challenges, what are the opportunities? And so on. So hopefully it's going to be very relevant to you all as you hack away your projects.
00:10:57.460 - 00:12:05.868, Speaker B: You need to pay attention to this so that your projects don't get hacked later on. Right? And just a quick note about the title. I don't know how many here are old enough to be fans of the western genre of movies, but my dad really likes one of these Wild West classics, the Good, Bad and the Ugly with Clint Eastwood and several other characters. So that's what we are going to I'm going to talk about that. Well, taking inspiration from that, but really flipping it and starting with the more skeptical pessimistic outlook as to what is wrong, what the ugly side of security, the state of security today, then get into all the things that are being done badly in smart contract security. And then finally we'll end with an optimistic tone of the good parts of why we are here and all the things that we can look up to. So if you Google for a stock image of security and Swiss cheese, so Swiss cheese is one of the favorites of all the security researchers.
00:12:05.868 - 00:13:07.732, Speaker B: And it looks like this, it's one of the cheeses, if you have eaten it has lot of holes. And that's how the security folks see all the platforms, right? So there are several layers to the platform. There's typically a front end, a middleware, a back end, and all of them have bugs, vulnerabilities, some small, some big, some of them are patched and many are not. So when you look at the vulnerabilities, right, the hazards, as the stock image says, so you have lot of vulnerabilities that are being exploited, that are attempted to being exploited. And if you notice, there are a few of them that get prevented because of all the security measures at different layers and then some of them pass through. So the arrow that passes through is the loss that is not prevented, right? And in the case of the crypto Wild West are we still on? Can you guys hear me?
00:13:07.786 - 00:13:08.390, Speaker C: Okay?
00:13:09.880 - 00:14:16.964, Speaker B: So in the case of the crypto wild west. This is amplified, I would say like ten x, if not more. So there are lot more layers, lot more holes, lot more arrows being shot at the target and many of them going through, right? And we have very few plugs that actually prevent these hacks today. So security is all about I mean, it's all really about assets, right? Security really looks at three aspects. We have assets that are protected by the good actors, and then you have the bad actors who are trying to get those assets without the right authentication. And then we have a lot of actions that make these two things possible, right? This is sort of a way of life, but it gets amplified many, many times over in the crypto Wild West. So you have the good actors, but wherever there are a lot of assets, you obviously attract the bad actors who go after those assets, and many of them actually succeed.
00:14:16.964 - 00:15:09.144, Speaker B: And you have a lot of these wanted posters that we have to deal with later on. So how bad is it, right? How ugly is the situation? Here's a dashboard from DeFi llama, which you may have heard of. So this was a statistic that was collated by one researcher over there and the dashboard was created. And we'll also look at the framework later on. But this is what it is. This is the state. And if you can't notice the numbers, what this is showing is the top hundred most severe exploits in terms of the funds lost only in the last two years, right? And if you look at the y axis, I mean, that tells a story.
00:15:09.144 - 00:15:58.064, Speaker B: So we are not looking at thousands of dollars, we are looking at hundreds of millions of dollars, right? So every line that you see in that axis is 100 mil, 200 and so on. And then the story really starts all the way back to the Dow exploit. So that's the first bar that you see. That happened in November of 2016. And then there was, I think the one in 2017 was the Parity hack, and then all the others are really in the last two years, right? So we'll dig deeper. But this is the state of security today, or Insecurity today. And if you look at the total value hacked, it's a nontrivial number, right? It's close to $6 billion and most of it and we'll talk more about bridges.
00:15:58.064 - 00:17:08.480, Speaker B: So a lot of it was lost because of bridges or because bridges got exploited, but close to $5 billion got lost in DFI across the various protocols. And this is all in smart contracts, right? This discounts any of the centralized exchanges, all the mess that you guys have been, you know, that we all have been reading about in the last several months. So this is unacceptable, right? If we want to be a layer that settles financial transactions, where we want really to trust in code, it has to be, everything else should be trustless or trust minimized. And we want to trust in code, then the code cannot be this insecure because if this is a state of the art, then we cannot expect people, retail institutions to really trust their money and put into these contracts, right over time. So this has to change. So this is really the ugly part. Now let's sort of dig deeper into a few of these statistics.
00:17:08.480 - 00:18:22.890, Speaker B: And this particular analysis created a framework for the different types of hacks to categorize the different types of hacks. I haven't analyzed if the data is complete or if it is accurate, but I think it's a good running example to hopefully make the point over to everyone here. But if you look at the frequency of hacks by categories, right? So the analyst decided that there are four categories. We have infrastructure protocol, ecosystem and smart contracts. But the way to think about it is infrastructure is really everything that is not related to smart contracts. So anything in the web two space, anything that is off chain, anything to do with custody of private keys, all that falls in that sector, right, in that bucket and that is nontrivial, right? So that is 23% in this analysis. So the story here, the moral here is that, yes, smart contract and all the other three sectors add up to 77%, right? So smart contract security is way, way more important.
00:18:22.890 - 00:20:07.784, Speaker B: But you cannot ignore the infrastructure, the web two, the off chain parts, right? So that's the takeaway here. And maybe there's a good point to talk about some of the categories, right? So protocol, according to the analysts, the protocol category really is all about the smart contract logic that's been implemented within your protocol, right? So as you go and hack away your projects, whatever the application is, it could be a Dex, it could be anything, it could be an NFT trading platform, anything, right? So the logic that you write in solidity or anything else, that is the protocol logic, right? And there could be bugs, there could be vulnerabilities in that logic. Those could be exploited to really get all the tokens in your protocol ecosystem, according to this analyst, is anything where your particular application works with other applications, right? So think of flash loans and we'll get more into so anything external to your protocol, but that is still on chain oracles, other protocols, other dependencies, you have all that comes into the ecosystem category. And finally, the smart contract is actually the smart contract language or platform category. That is really all the hacks enabled by virtue of the EVM or the language itself in which the smart contracts have been coded up, right? So let's dig deeper before that. So, if you look at the frequency over time, there is no sort of key takeaway here, except that these are happening every month. And note that these were the top hundred exploits right.
00:20:07.784 - 00:20:59.228, Speaker B: The minimum was I think, like three or $5 million exploited. So there's a long tail of exploits that have not been considered in this analysis. Right, and day in and day out. I mean, if you're active on Twitter just this morning, I think there was an incident that was bubbling with one of the protocols on the binance chain, where I think a deployer key got stolen and then the attacker actually deployed, upgraded the contract, which had sort of a different mint function that could be rugged. And the attacker minted, I think billions of those tokens. And that was still being analyzed. Right, so there are all these things happening on I think the takeaway here is that these hacks are happening every day, right? I mean every week, if not every day, right.
00:20:59.228 - 00:21:30.276, Speaker B: Something is growing and the funds stolen are nontrivial. Right. So look at the Y axis. It's 200, 400, $600 million. And the numbers have been compressed to report on a monthly basis. So if you look at some of the longest polls here, right, the longest bars, the longest columns here, there have been hacks. I think the largest amount was north of $600 million.
00:21:30.276 - 00:22:08.284, Speaker B: Right. So those were, most of them in the 600, 500 range were all bridge related attacks just because they hold so many assets. But those are the ones that you see here in red and yellow. So this categorizes some of that into the different categories. And the hacks, again, the bridges stand out. So if you are interacting with a bridge, if you are building a bridge, if you're building a protocol that works with bridges, something to pay a lot of attention to. Now let's go into the smart contract language, that category.
00:22:08.284 - 00:22:45.416, Speaker B: Right. So the two things that I would like to call out here are the reentrancy and the delegate call exploits. So the first major exploit on Ethereum, which is well known, well publicized, is the Dow exploit. Right. This was in 2016 of November. It really opened our eyes to a reentrancy exploit. And since then you'll be surprised to see how often the reentrancy exploits, I mean the vulnerabilities exist in different code bases and they're exploited on a regular basis.
00:22:45.416 - 00:23:25.544, Speaker B: And the second one would be the delegate call exploit. I mean, delegate call is something that we need to wrap our heads around because this is a functionality that if you have coded it in any of the other languages, you wouldn't have really paid attention to. But in smart contact languages, when you do a delegate call, there's a lot of things that happens in the background that if you are not paying attention to it could be a recipe for disaster. Right. So those are the big takeaways here. And when it comes to the ecosystem hacks, the keyword, like I said earlier, is flash loans. And one of the big categories there is the Oracle price manipulation attack.
00:23:25.544 - 00:24:08.136, Speaker B: Right. So just google for it. There are fantastic ad articles written about it. So this is extremely common, right? So this is like 50% of this category is all price oracle manipulation hacks that continue to happen. The second category is the Flash Loan governance attacks. So if you have looked at any of the token based governance models, then flash loan introduces a new vector where somebody can flash loan a whole bunch of tokens that are used for governance and they can make the governance go one way or the other, right? So all these pretty graphs, pie charts are there in the source. I didn't create them.
00:24:08.136 - 00:25:11.740, Speaker B: I think it's a very good way to sort of convey the point. So do feel free to go and take a look at it later then, if you look at the protocol logic. So if you recall, I mean, this was one of the biggest sectors, right, of the hacks. So in this case, there are obviously many, many components to this because that is the nature of application logic. Depending on what your application is doing, you could have new ways, attackers could have new ways to exploit it, right? So there are many categories here, but the ones that stand out are access control, exploit. So access control, if you know, is something that is fundamental to security. If you don't have the right access controls, some unauthorized, in this case, an attacker can mint, can do something else with your contracts and exploit the funds, right? And the other one that is really common is the math mistakes.
00:25:11.740 - 00:26:36.468, Speaker B: So if you're looking at anything in the space, unless it's a very simple contract, there is going to be a lot of math, especially in the DeFi space. You have numerous protocols that are trying to optimize every aspect of DeFi lending, derivatives, all those aspects, right? So those again are places where developers make mistakes and these are not very easy to spot, right? Because these are extremely you need to understand the protocol logic, you need to understand the math. There are certain corner cases in Solidity or the math library that you're using. You need to be aware of all of that. This is an interesting one, right? So if you look at the hacks by chain, the wrong takeaway from this is to say that oh, the biggest chains, right, the biggest sectors here are the most insecure. Now, the reason why you see Ethereum or BSc or the other L ones, or any of the other L two S, right? So these are the places where there is a lot of innovation happening, right? There are a lot of protocols being deployed, either originals or in some cases clones. And in the process of cloning, you may have copy paste bugs as well.
00:26:36.468 - 00:27:38.074, Speaker B: So this is where there's a lot of activity, this is where you have a lot of assets, where a lot of actors, lot of actions are persisting over time. And so it's natural for the security or for the attackers to go after places, chains where there is a lot of activity happening or where there are a lot of assets logged, because that is how they get to exploit it. Right. So that's sort of the takeaway. All right, so we talked about sort of the ugly and the bad pictures. Yeah. Can we get to the questions at the I'll get to it at the end, I think there's a different setup I need to use for Q A, but I'll get to so if you're not convinced that the state of affairs is bad or ugly right, then please reach out to me after the talk.
00:27:38.074 - 00:28:17.366, Speaker B: I would like to chat with you, but this is not the state where we want to be and definitely not the state where we want to head towards. Right. And the reason for why this may be the case. So I have sort of listed ten aspects of web three, which makes thinking about security in this space very different from web two. Right. So let's sort of dig into each of them and see why those matter. When it comes to thinking about the security of the space, keys and tokens, I mean, this is something that is fundamental to web three, I'm sure you've heard of.
00:28:17.366 - 00:28:45.440, Speaker B: Not your keys, not your tokens, the way we think about security in this space, right. Unlike the web two space, where you think about passwords, here we are looking at keys and tokens. Once you sign a transaction, once it's gone, right, it's not reversible. Right. There are challenges, not just with custody of keys, there are challenges with how it is used, with every aspect of it. Right. And tokens, there's a whole bunch of them.
00:28:45.440 - 00:29:23.134, Speaker B: And that itself, over the last five or six years, have led to unique exploits. If you have heard of ERC, 20, you know the exploits there ERC 721, ERC seven. Seven. So each of them comes with its own flavor of attack surface, right? So that is one that makes this very different. But the thing that is fundamentally different in this space when it comes to thinking about security is the threat model. So in security, you always think about two things trust model and threat model. Who do you trust? Who are your threats? Blockchains are all about the Byzantine threat model.
00:29:23.134 - 00:30:04.966, Speaker B: So look it up. This is a threat model where anything, anywhere, any place can be arbitrarily malicious. There's really no notion of a trusted insider and everyone else like how we do in the web two space. Anyone, right? It could be the miners, the validators, the developers could rug, the users could abuse the system over time. It's really all about the mechanism design. So this is something that has to be critical. I mean, that has to be front right and center when you think about security in this space and obviously unstoppable and immutable, I mean, this is where we are headed to, definitely with the layer ones, smart contracts.
00:30:04.966 - 00:30:26.062, Speaker B: I think that's the ultimate goal. But then you do have the possible features, emergency recovery, upgradability and other things where a lot of things can go wrong. But this aspect, I mean, imagine if your contract that you deploy, right, is unstoppable and immutable. Think about what if there are bugs in it, can you fix it? Can you stop it? Can you apply a patch?
00:30:26.126 - 00:30:26.402, Speaker A: Right?
00:30:26.456 - 00:30:55.254, Speaker B: All these are very different. I mean, the way you need to approach it in this space is very different. We are less in this space, ethereum space. We are less than ten years into this. You saw the history of Ethereum as you walked along the hall, right? So like 2013, 2014 and we are less than ten years, right? So we have a new architecture. It's EVM based, 256 bit, stack based. We have new languages, mostly solidity.
00:30:55.254 - 00:31:56.846, Speaker B: We have wiper, a bunch of them coming up. We have many tool chains. I don't know what you use, hard Hat, Brownie, but now there's foundry, whole bunch of them, right? So all these things are still very early and they themselves may have bugs that could lead to security exploits. The other interesting aspect is that this space, the ethos in this space is open source and transparent by default, right? With smart contracts, you deploy them, the expectation is that the source is going to be verified, it's going to be open and it's going to be transparent, right? So there is no more walled gardens where you can hide behind security by obscurity, right? Everything is transparent to anyone, right? To your users, to the abusers, to the attackers. So it's not just in the technical layers, but it's also in the social and governance layers where security is different. Pseudonymous, teams, reputation has to be thought out in a very different way. Dow governance has to be thought out in a very different way.
00:31:56.846 - 00:32:45.402, Speaker B: The way that you can roll out security patches on a protocol that is governed by a dao. There's going to be a window compound, for example, had an interesting incident with that. Then composability by design. This is again, your protocol is not going to operate in a silo, right? It's going to work with maybe an Oracle feed, maybe other protocols, maybe definitely the off chain stuff. Lot of things happening. So the attack surface here, when you think of composability and this composability is changing over time, this makes the attack surface grow exponentially. What your constants are, what your constraints are, what configurations are, all these things keep changing.
00:32:45.402 - 00:33:59.926, Speaker B: So it's really a moving goalpost that has to be paid attention to. And all this is happening in compressed time scales. And what I mean by that is if you've been in crypto, you know that one day or one week in crypto is like ten for the rest of the world right there's. So many things that happen in crypto that it's really hard to keep track of. But then there are all these new things that are happening. So how does that affect security? Security becomes an afterthought, right? So there are a lot of shortcuts that are taken, there are a lot of corners that are cut and think of your development, right? So as you finish your hackathon, how much time have you spent in thinking about the design? Do you have a documentation for it? Have you written a spec for it? Right? What are the invariants, what are the properties? Right? All these things sort of get moved to the side or get pushed under the rug and then projects get deployed, which is a significant factor in them getting exploited, right? So this is not right. And this leads to this.
00:33:59.926 - 00:35:15.920, Speaker B: If you've heard of the test in prod meme, this is what causes where the actual test is happening in production. So you see failures, you see exploits that are undesirable. And finally I've talked to many developers in this space and when we say security, the first thing that comes up is audit. So security has audits have become synonymous with security in this space, which is not desirable, right? I mean, audit being treated as a silver bullet is I mean, if you understand security, that is not the place to be, right? I mean, audits are critical today, but you can't just put it over the fence, throw it over the wall and say hey, you know what, I got an audit. Great, everything is going to be good. I mean, majority of the hacks that have happened, right, if you look at the details, a lot of them would have got audited, right? So things would have got missed things, I mean, a lot of things that could have gone wrong in the process. So these I think ten sort of vectors really make I mean should forces to think about security in this space with smart contracts in a very different way.
00:35:15.920 - 00:36:14.942, Speaker B: It's not all bad. Let's talk about the good, right? So there are again insecurity. This is something that's very well known, right? In security you think about three stages, things that you can prevent, things that get through because you couldn't prevent, so you had to detect them so that you can remediate and respond. So today a lot of the focus in security is happening in the prevention space, which is good, right? I mean, there are still big gaps. So audits, for example, is something that I mentioned, there is a lot of emphasis on audits, lot of reliance on audits that needs to be tempered with an understanding of what an audit is and what it buys you. It is not a guarantee of zero bugs by any measure. So there are multiple teams innovating in the audit space.
00:36:14.942 - 00:36:58.426, Speaker B: So audit contests are something that is interesting. So you may have seen Code Arena and Sherlock where you have audit contests where the audits are being crowdsourced, right? So that is an interesting sort of innovation that is happening in this space. Then there are a bunch of tools and methodologies that are being innovated here. You have Slither echidna from trailer bets, you have Scribble and others from consensus, you have formal verification tools from Mean. This is a space where formal verification actually becomes much more tractable doable and very attractive for various reasons. So I won't get into that. But Sertora has a talk tomorrow.
00:36:58.426 - 00:37:48.426, Speaker B: So if you're interested do attend, I think you'll find it interesting. So, lot of things happening in the prevention space. Then we get into detection. These are things where projects have been deployed on chain and now there may be bugs. So what do you do? Right? So you do have bug bounties, bug body platforms like Immunify which you may have heard of the bug bounties, I think the last number was like 60 plus million dollars have been handed out by Immunify to various white hat hackers who reported these bounties, right? So that tells you the scale of things in the space. Then you do have innovation happening with tenderly on the monitoring side and folder. So look them up.
00:37:48.426 - 00:38:56.580, Speaker B: So all these they monitor on chain activity for what may be anomalies in the behavior and then they send you reports, right? I mean Open, Zeppelin, defender, whole bunch of tools in this space. So lot of things happening. Response is I would say probably not. I mean the space that hasn't I mean it's very ad hoc today, right? What happens when there is an somebody somebody notices something wrong with the protocol based on on chain analysis, they send a message in the protocol's discord or telegram, then something gets posted on Twitter, one of the white hat hackers or security researchers learns about it and then they start diving and discussing this on Twitter. And then if there was an exploit, I mean, an active exploit that could potentially be that's still happening, that can be stopped, then there is an ad hoc war room that is set up. And then you do have sort of an ad hoc set of white hats who get called into the War Room, who try to go and frontrun the attackers and all these things. Right.
00:38:56.580 - 00:39:49.542, Speaker B: This is good that it's being done, but there's a lot of scope for improvement in this space in terms of response, right? And there are a lot of people, lot of teams that are working on various solutions in this space. These are like 64 security researchers and teams who are building tools and services in this space. And they were all speakers at Trust X, which was an event that secureum hosted in Ampsvam earlier this year. So we do have lot of people but you saw the scale of things, right? $6 billion. We have like 600 plus protocols being tracked by, let's say, DFI llama. Right. So we need many, many more.
00:39:49.542 - 00:40:14.750, Speaker B: So as you go and hack your projects, think about the security. And if you're really interested in security, do come. There are many of us here. Do come and reach out. There are many ideas that need to be worked on. There's a lot of heavy lifting that needs to be done, not necessarily by people dressed like this, but there is a lot of work to be done. Right.
00:40:14.750 - 00:40:42.710, Speaker B: And we have a long way to go. Right. So how does Securium fit into the space? So Secureium is the mission is really about educating and evaluating Ethereum security. It started about a year ago, and Secureum is known, really, for its bootcamps free Smart Contract security bootcamps entirely online. And you see the QR code. That's the address of the discord. Everything happens over there.
00:40:42.710 - 00:41:18.450, Speaker B: It started about a year ago with a grant from the Ethereum Foundation, where we also collaborated with some leading partners in this space that you see here. Completely free. We had 1000 plus people sign up, 600 plus people who took I mean, this was a boot camp, right? This was a boot camp for three months. Right. And fantastic turnout. And since then, what we have done is we have moved away from a discrete three month, one month kind of a boot camp. We now have an always running bootcamp that is free for all the participants.
00:41:18.450 - 00:41:41.034, Speaker B: Every month, there is a Smart Contact Security quiz that is designed by Securium or one of the mentors. And, yeah, I mean, challenge yourself. Come reach out to us. And there are many other security players, like I said as well. And with that, I'm done. So I'll be around for the rest of the event. So if you want to talk about security, do reach out.
00:41:41.034 - 00:42:32.336, Speaker B: We'll be happy to chat more. And I think I have a few minutes for questions for which if you speak I think if you speak into the microphone, then I should be able to hear and respond to you. Well, one are there any questions? I think there was one question from here. Okay. All right, let's see if this works. No. Does he need a microphone? I think you have to use a microphone.
00:42:32.336 - 00:42:46.216, Speaker B: I think you had a question about this. So this different color are different protocols. No, these are the layer one chains. Right. So you have ethereum. Okay. This doesn't show.
00:42:46.216 - 00:42:52.720, Speaker B: So all the protocols on Ethereum that got exploited are in that blue sector.
00:42:52.820 - 00:42:53.324, Speaker C: Okay.
00:42:53.442 - 00:43:04.072, Speaker B: Yeah. So there is a protocol. So why Ethereum is in multiple times. Those are all the bridges. Okay. So, yeah, that's the question. Like, the different color represent a different protocol and bridges.
00:43:04.072 - 00:43:22.980, Speaker B: Yes. So you do have L ones, and then you do have the bridges where you have multiple L ones, and then you have some L two S as well. So you see Arbitrum, you see polygon. I don't. Think you see optimism, but yeah, I have one more question. Sure, yeah.
00:43:23.050 - 00:43:23.670, Speaker D: Okay.
00:43:24.040 - 00:43:34.168, Speaker B: The question is the Oracle is a very critical part of if we want to as a blockchain, currently we have the access of data which are the on chain and all.
00:43:34.334 - 00:43:36.408, Speaker D: But if you want to accessible the.
00:43:36.414 - 00:43:51.416, Speaker B: Smart contract application or the use case of a normal people. So Oracle is one of the key part of that. So some of the companies are doing good Oracle, but they are not efficient. So the modular wise as per our application requires.
00:43:51.448 - 00:43:54.320, Speaker D: So how the Oracle solution?
00:43:55.220 - 00:44:02.416, Speaker B: We can improve on a better way in the future maybe like which type of Oracles should be the best and.
00:44:02.438 - 00:44:04.928, Speaker D: The secure way to use those Oracle actually.
00:44:05.094 - 00:44:31.016, Speaker B: Right, so I think there's a lot that we can get into the details of the Oracles. But in general, the things that you want are from an Oracle, you want it to be decentralized. Right? And I talked about the Flash loan and the price manipulation, so you really don't want that. Right. So I can point you to entire blog articles and research articles that have been written all that.
00:44:31.118 - 00:44:31.492, Speaker C: Right.
00:44:31.566 - 00:45:22.350, Speaker B: So as a user, I mean, I don't know if you're asking from a user's perspective or from a protocol developer's perspective, but from a protocol developer perspective, if you have a choice of Oracles, you need to think about decentralization, you need to think about availability and really dig. I'm just scratching the surface. I mean, these are the key points and then how are you using that data? Right. The staleness aspect of Oracles, right. Whatever feeds you're getting, price feeds, anything else that you may be interested, if they get stale, what is the impact to your protocol? Right, so I think those are all the things basically means as Oracle, for example, Oracle got hacked or some project got hacked, as in the Jews said the response detects. And so if you detect after deployment some response. So there is one tricky thing.
00:45:22.350 - 00:45:56.464, Speaker B: Some people tell that upgradable contract are not good because that are basically the key part of that. You don't owning that contract. Anyone can come and the protocol can change this upgradable contract. So basically if you detect the on chain, any issue or any security bug, so you recommended to have the contract protocol or DeFi protocol. Should we have upgradable or it should be the migration, like migrate to one to other or what was the best. So there are pros and cons. I think the community is divided between upgradability.
00:45:56.464 - 00:46:37.392, Speaker B: I mean, the good thing about upgradability is you can upgrade, fix the bugs. The bad thing is that process itself, very few people understand how to do it in a proper way. There are so many proxy patterns that you can look at and each one has so many nuances. Right. So again, happy to chat to go into the details. I don't think there's a clear answer because it's about ease of upgradability, I mean ease of fixing bugs and anything else versus the downsides being if you don't do it the right way, forget about upgrading, you're done. So I don't know if you have time, but yeah, maybe one more.
00:46:37.392 - 00:47:03.020, Speaker B: Sir, I have two small questions. First thing is in the recent times lot of hacks have been on the bridges end of things. So how can we improve on that security part on the bridges side? And the second thing is, like me and my friend here, we are the part of an in house auditing team at a service based company and we are extremely interested into security. We have started doing all that online CTFs that are there and even reading the secure blogs as well.
00:47:03.090 - 00:47:04.830, Speaker A: So what else can we do to.
00:47:06.800 - 00:47:57.000, Speaker B: Get speed up on the security side of things? Like learning that. Yeah. So I think the second part I'll take it offline, we can chat more right, because there are so many things you can do to speed up, but I think it's also about how much time you spend and the resources and so on. But to your first question, I think the bridges out of the top four bridge hacks, I think one was really based on the web. Two side of things, right. There was a spear phishing, somebody's laptop got, I mean server, whatever got hacked and then they got access to the validation keys, so validator keys and that caused, you know, they got all the five out of the nine and so on. Right, but the others were about smart contracts, about the logic.
00:47:57.000 - 00:48:20.036, Speaker B: Right. I don't think there's a simple answer of would one thing have prevented each one of those, but I think it's really all about the entire process, right? So there are many things that can be done and we are still working on it. All right, I had one question. Yeah. Okay. Sorry. I think I'm done.
00:48:20.036 - 00:48:24.870, Speaker B: We shouldn't find me outside. Happy to talk to you. Thank you.
00:55:22.430 - 00:55:23.178, Speaker C: Hello.
00:55:23.344 - 00:55:34.414, Speaker D: Okay everyone, we're about to start. You all have headphones with you. Just tune into channel number three to listen to what Alec has to say. And we're about to start.
00:55:34.532 - 00:55:35.886, Speaker A: We're going to close the doors but.
00:55:35.908 - 00:55:43.874, Speaker D: Obviously entry is still allowed and please do not take the headphones with you. And after the talk is done you will also have time for A-Q-A.
00:55:43.912 - 00:55:44.660, Speaker B: All right.
00:55:46.790 - 00:56:21.934, Speaker E: Thank you. Thank you. Welcome everyone. Thanks for tuning in, super excited to be here. I am Alec Wontak, co founder and CEO of Vallast and we do universal software deployment and monetization and I'm going to tell you about what that is and hopefully we're going to be able to do a demo here, but the internet has been quite shaky and unfortunately my demo does require internet access. But we'll go over the overview and I'll show you some great links where you could find some resources to get started either way. But yeah, let's just jump into it.
00:56:21.934 - 00:57:14.906, Speaker E: But yeah, at the end of the day, right now, today Web Three is not fully decentralized. And even though we're putting massive amounts of energy into decentralization, it's pretty much completely centralized at the distribution layer. So even though we're building all these Web Three protocols, we're falling back to Web Two platforms like GitHub and Versal, Netlify and App stores. And so really, at the end of the day, these have major problems in that they own all of your products because they have ultimate control over it. They actually own all of your users as well. And the crazy thing is that when your users actually buy something, they don't actually own it either because it's just a mark in the database somewhere and that they could control that and remove it whenever they feel like it. So it's this really crazy situation that we found ourselves in because we're relying on all these centralized companies and gatekeepers for distributing our software.
00:57:14.906 - 00:57:55.354, Speaker E: And at the end of the day, also they take often 30 plus percent of your revenue. And when you're actually distributing software, you often have to tie multiple different SaaS products together and everything like that. So at the end of the day, all we're trying to do is publish and potentially monetize our software and they're making it pretty insane. But it's a good thing that we do have the tools to solve this, and that is Valust. So Vallast is a Web Three native software deployment protocol that is designed to replace all of these traditional gatekeepers. It is an easy way to deploy any type of application. You could deploy Web apps, mobile apps, and desktop apps in a super seamless easy way, and then we deliver it to every single platform as well.
00:57:55.354 - 00:58:56.058, Speaker E: And basically what we're doing with Vallus protocol is we're taking the same security that powers these multi billion dollar blockchain networks and applying that to the software distribution process. And so we're basically getting the security that we get from all these multi billion dollar networks right out of the box. And really it lets you save a bunch of time and money from configuring things and reducing the operational costs and the ability to avoid these crazy fees as far as the marketplaces go as well, because now you can directly monetize things to your users instead of going through a company. So Valus also securely delivers software to any platform. You could take pretty much anything as input, you can connect it to a GitHub repo, or you could drag and drop your build. We support web, desktop and mobile platforms, which includes of course, websites, mac apps, windows apps, android apps, and Linux apps. And then everything is stored on IPFS and filecoin.
00:58:56.058 - 00:59:57.986, Speaker E: And we use Polygon for managing the access control and managing the accounts, the projects, and then the versions underneath. So all the core logic of the protocol is powered by polygon and basically it just ties together all these different protocols in a super easy to use interface. And then once it's all deployed there, we make it available on regular Http so you get an IPFS gateway URL out of the box as well as a Web Two subdomain for free out of the box. And then it's of course available on IPFS and our desktop mobile clients as well. And then we're rolling out the ability to also publish two of the existing app stores so that you can get the best of both worlds. And then to avoid the 30% fees, you could direct them to the vallast desktop launcher and mobile launcher, so you can avoid that 30% marketplace fee and replace it with a 5% protocol fee. That protocol fee also covers the gasless transactions, so you don't have to actually hold any crypto to get started.
00:59:57.986 - 01:01:04.662, Speaker E: You could just basically publish for free and get it going. It also covers all of the decentralized storage and everything that surrounds it. And instead of having to tie together multiple SaaS products like GitHub, Versal, Netlify or Fastlane and Configuring, all these build pipelines which could take weeks to even months to do in a production ready environment. It's just one single interface and you could just go ahead and pick your platform, pick your targets and click Deploy and you should be ready to go in really minutes. And what does Web Three Web software distribution really look like? So it includes the base fundamental features that you would expect from any software distribution system, which includes being able to deploy your application, being able to fetch and install it in an easy and secure way, as well as auto updating it. And then we have this awesome thing called software license NFTs so that if you're actually trying to sell an application, you could go ahead and create we use ERC 1155 for it. Basically all you have to do is set pricing for your product and you can accept any types of tokens as payment mechanism.
01:01:04.662 - 01:02:09.200, Speaker E: And then we're also adding fiat gateway on and off ramp support so that your users can also purchase with cards if they want to. And then you could withdraw into fiat currency as well. Basically it's using crypto as the backbone and the rails with awesome interfaces on top to make it super easy. Even if you've never used Web Three before, or if you're a Web Two developer and you're not even trying to get into Web Three, you can definitely still use this and get all the benefits from both. And really, this looks pretty familiar to existing things. Like we port over the common features from platforms like Versal and Steam and GitHub, which includes the ability to version your software, publish and auto update your artifacts, and manage both the team level access control and project level access control, so you can add any addresses to an account, then they can publish to any projects underneath. And then you could also be more specific about the access control and say, hey, this key can only publish to this project.
01:02:09.200 - 01:03:02.890, Speaker E: And you could also do really interesting things like multi SIG releases. So if you're very security conscious about this, or you're a larger organization, or if it's a protocol that multiple teams are helping build, they can actually come to consensus and coordinate on these builds as well. So it's a really interesting way that we could sort of escape the web two version. And once reported over, again, we have a unified interface for publishing web desktop and mobile software and then we're no longer relying on a single entity for distribution. And if you're using the native Vallast desktop and mobile clients, that has its own IPFS node built in. So the more people that download and use your software, the more resilient it becomes. We also host backend infrastructure and synchronize and make sure that everything that is uploaded to Valust has a copy on IPFS and filecoin.
01:03:02.890 - 01:03:39.818, Speaker E: But you could plug in your own infrastructure, you could plug in your own IPFS nodes, you could plug in your own polygon nodes, whatever you like, or you can even do hybrid deployments and use some valust IO stuff for some things, your own infrastructure for others. So it's really up to you however you want to configure it. Or you could completely self host and not rely on anyone at all. And you can basically monetize software, like I mentioned, with software licensed NFTs. And so essentially this is a new way to do digital rights management DRM. And traditionally we have to go through Apple, Google or Steam and basically give them 30% of our revenue for that.
01:03:39.984 - 01:03:41.158, Speaker C: Or we have to tie a bunch.
01:03:41.174 - 01:04:19.202, Speaker E: Of these other crazy APIs together. And licensing systems are usually very complex and they're changing a lot. But this is the most modern way and it's the web three version of the DRM. And this is the future of digital rights management. And again, you're monetizing it directly with your users, so you don't have to go through any entity for doing that. And like I mentioned as well, DAOs can coordinate releases, organizations can coordinate releases in various ways and add different levels of security there. And then we could do really cool stuff like creating an auto update system powered by smart contracts and IPFS.
01:04:19.202 - 01:05:37.230, Speaker E: So for even use cases like critical infrastructure, you can imagine that these things could be updated whenever you push an update. The rest of the devices can actually pull that update from each other since it's all decentralized storage and CDN from that. And so yeah, it's again a more advanced way to deploy auto updates to your infrastructure, regardless of what type of platform it is. And how does it work? Well, basically I'll keep this as high level as possible, but we use web three native building blocks to create this secure infrastructure and basically create a new software publishing protocol layer for this. So from the software developers perspective, all you have to do is just publish your software and we use your wallet as a web three native identity. But if you don't have a wallet, we have passwordless, email login, so you could just log in with your email address and get moving, no problem. And then you can manage pricing via the software license NFTs say, hey, if I'm selling a game for 20 USDC, I can do that, or if I'm selling an app for five USDC, something like that, or even your own custom token, whatever you prefer, you could configure that way and multiple options as such.
01:05:37.230 - 01:06:30.018, Speaker E: And then you could go ahead and withdraw balances in crypto and in the future in Fiat as well, upcoming pretty soon here. And then everything is stored on decentralized file storage, so all the software in Valis Protocol gets stored and archived onto IPFS and filecoin and duplicated on different miners around the world. So you're pretty much guaranteed that that software is going to exist. And then the cryptographic hash of your software is then registered in the Valus Registry smart contract. So all of the stuff gets uploaded to decentralized storage and then you take the result of that and then we put it in the smart contract. And this basically manages the entire core logic of the protocol. So it manages the entire version history across your entire organization, and it also manages the accounts and the projects as well.
01:06:30.018 - 01:07:15.598, Speaker E: So it's a three layer system, so it's the account that control the projects that publish releases, and so it keeps track of everything there and it coordinates all of the organization members and it manages all the security features as well. So super, super easy stuff there. And then if you're monetizing software, we support various software licensed NFT networks, we're deploying to several others right now as well. But the idea is that you could go ahead and create that on any network and then accept payments like I mentioned as well. And then from the end user's perspective, it should be pretty seamless. There's a few different ways that you can launch it. We give you a Web Two URL as well as IPFS Gateway URLs, so you could direct your users there.
01:07:15.598 - 01:07:54.374, Speaker E: You could also embed that stuff into your existing websites and do download links and stuff like that as well. But from the end user's perspective, they're launching and downloading things in just as easy as ever, but in a super secure and decentralized way. And then they can go ahead and purchase the software licenses super easily. And then very soon here, they'll be able to also purchase that with credit cards in Fiat as well. So that is basically the high level overview of the way that the protocol works. But then this creates that base infrastructure that anyone could build upon as well. So how do we use it? There's a few different methods.
01:07:54.374 - 01:08:24.022, Speaker E: So, we have a web front end and again, the Internet is not loading and everything right now, apologies for that. But we have a web front end that is our main dashboard. You can manage everything. It's super, super easy. It looks like Versal, it's very familiar. You can navigate and you can see your accounts and all the projects underneath and manage everything in a nice clean UI, as well as set up automatic deployments with your GitHub repo. So that's the main interface most people use.
01:08:24.022 - 01:09:01.698, Speaker E: And then I'll show you this in a second. But the Sapphire Launcher is our native desktop and mobile client. So this is essentially you could think of that as an alternative app store or a Steam, but for Web Three. And that has its own built in IPFS node and its own built in wallet that passes everything through super transparently. So that from your end user's perspective, let's say you're building a game right now most of the time. If they were to go and pick up an item, if you were minting an NFT there, it would actually stop your gameplay and you'd have to jump out and sign a message. Whereas with this, it can do it super transparently when you need it.
01:09:01.698 - 01:09:45.530, Speaker E: And then anything that affects money past a certain threshold, it'll do a nice Steam like overlay that's, like, hey, by the way, just to confirm, this might withdraw some matic from your wallet, just making sure that you want to do that. And then it makes it super, super seamless for the user as well. And then we also have a CLI. So you could publish with the CLI super, super easily. You could put it in any CI CD system. So if you're using GitHub, GitLab, whatever you prefer, circle CI, you can put that there as well as publish it from your local machine. That also supports advanced configurations for multiplatform releases.
01:09:45.530 - 01:10:26.318, Speaker E: So again, just like the web front end, you could configure, hey, I want to publish my web, my Mac version and my Android version all in the same release. And the CLI does that super easily as well. And then our GitHub action is basically taking the SDK and making it native for GitHub. But you could also tie that in with the automatic deployments as well. So if you're already using GitHub actions, all you have to do is add the Valus publish at the end of your workflow and it's super, super seamless. And then we also have TypeScript and Go SDKs. So basically the TypeScript SDK is what powers all of these other things.
01:10:26.318 - 01:11:23.466, Speaker E: So it just wraps all of the different protocols together. And again, is basically the core logic of Vallus protocol. And then we also have Go SDKs for depending on your use case as well. So if you're doing like you could do cool things like auto update your go binary by fetching the latest release and doing that so really cool stuff there the web, hopefully I'll show you this and hopefully the internet will work but otherwise this is basically what the web front end looks like. You have your accounts, you have your projects underneath you could create more projects when you go inside of these. You could create new releases, you could configure the project settings as well as the different types of platforms that you're targeting and again all the logic of the protocol is available here in a super easy familiar way. And then the Sapphire Launcher is the cross platform game and app launcher.
01:11:23.466 - 01:12:18.290, Speaker E: And so you can see here this is a web three game that is launched super natively. It's got a built in wallet there that passes everything through and again provides that super easy familiar interface for you. So instead of having to rely on the app stores you could direct your users to this and avoid those 30% fees. But it also has its own built in IPFS node as well so everything that it's downloading gets cached to local IPFS. So it becomes more and more redundant as people use your software and so the more and more people that use it, the more and more copies exist and the more and more censorship resistant it becomes as well. And so this is available on Mac, Windows and Linux and Android and iOS. We're figuring that out, there's definitely a lot of restrictions there but that'll be coming soon.
01:12:18.290 - 01:13:15.522, Speaker E: But the CLI again super easy interface basically you just install it. Basically we use your native keychain on macOS, on Linux we use Gnome keyring and on Windows it is the Credential Vault I believe it's called. But basically these are all super secure ways that are powered by hardware security on your desktops. It stores a fresh ethereum key in there and since it's powered by Metatransactions we can add that to the account and then to publish you just publish your account, name your project, name the version and then the folder that you want to publish. You could also do a more advanced configuration by configuring a Vallus YML file and I'll show that to you in a second. But this is a really easy way to get started and to just super easily publish. And then the GitHub action is something very similar.
01:13:15.522 - 01:14:12.898, Speaker E: So all you have to do is say, hey, whenever I'm pushing to the main branch, go ahead and give it a publish. And you could pre fill any of the previous steps here in this example. Basically, we're publishing to Acmeco under the test project, and we're publishing the build folder from that. And again, do the access control features. With this you could generate a fresh key that only has access to that one project or it could have access to multiple if you want you can add it to as many as you like, but it allows you to restrict the access for that particular key and you don't have to hold any crypto inside of it. So you could basically store that as a GitHub repository secret on your repo and then it will use that as a signer and we have metatransactions out of the box so you don't have to pay anything for crypto and it will automatically publish super easily there. And so that's really nice if you already have workflows.
01:14:12.898 - 01:15:06.470, Speaker E: And then we have an automated deployment system as well. So on the web front end you could click the deployments tab and you could choose the GitHub repo and it will automatically generate the keys for you, add it as a secret and set up the deployment process and open up a pull request that has this GitHub action on your repo. And so you don't have to rely on any third party infrastructure except for the stuff that you're already using, instead of having to trust random build servers that who knows who's running that. We could already use the existing stuff there, or you could use your local machines, or you could use a combination of and then we also have an SDK. This is just a quick example of fetching the latest release. You can generate the project IDs release IDs from there and basically this allows you to interact with the Valus protocol programmatically. And the Valus SDK contains all the logic of everything.
01:15:06.470 - 01:16:11.194, Speaker E: So you could create accounts with this, you could create releases or projects, you could create releases, you can also manage the pricing for your products as well as purchasing the products. And you could also use it to write files to IPFS super easily. We have really nice helper functions like called Write JSON, write file and Write folder and all you do is just pass in the file or the array of files and it gets it onto IPFS super easily. And then you could use that to programmatically create a release. So if you're doing dynamic assets or things like that, you could basically use that for version control, any type of data that you want. So some use cases for that can be like if you're building a game, you can upload certain assets programmatically and then load them in. And then we have some awesome other use cases too, where folks can create other accounts and even universities and stuff like that underneath with certificates and stuff like they were mentioning as well.
01:16:11.194 - 01:17:00.410, Speaker E: But basically you could use that to get access to all the access control features, the versioning features for whatever type of use cases you need that aren't necessarily supported by the front end or the CLI out of the box. You could also use this to contribute new types of software as well. But yeah, where do we find this and how do we get started with it? Everything you need is on Vallus IO right now there's a banner at the very top as well that says, hey, if you're here at ETH India, click here and it'll send you the guides and shows all the bounty information that we have as well. You could find everything on the Docs as well and then join our discord. We're always super happy to help. We have folks from around the world, so someone's going to be online if you need help. And we're always really excited to hear what you're building.
01:17:00.410 - 01:17:28.980, Speaker E: So please send us a DM of what you're building and we're happy to help you anytime. And then like I said as well, everything about Vallast is open source. From the ground up, from the smart contracts to the SDKs, the sub graphs, front end, everything is open source. And you can find it on our GitHub at Vallast IO. And you could see everything I'm saying here is actually true. So there's that. And thank you so much.
01:17:28.980 - 01:18:09.094, Speaker E: I really hope this Internet is going to work out for us here. Let me just see real quick. If it does, it looks like it's not going to we'll give it a shot. All right, we'll give it a shot. But I'm going to go over the if you go to the main website, you could see this link here. If you click that banner, it'll send you the guides that has information for everything that you need. So it has the bounty information for ETH India, and it also shows you how to create an account, how to create the project, and then different ways to publish.
01:18:09.094 - 01:18:49.520, Speaker E: And so like I mentioned, you could use the web dashboard for that. We have examples for publishing Next JS apps, react apps, unity apps, other types of binaries, and then ways to monetize your apps as well using the software license NFTs. And then we're also doing social media challenge for this actually should be hoodies, but yeah, for the hoodies that we're giving away as well. Yeah, just share a pic with some of our team members and we'll do that. And then we're also doing a ledger giveaway as well. So the top three projects that also participate in these challenges are eligible for that. So, really exciting stuff there.
01:18:49.520 - 01:19:43.486, Speaker E: It looks like this Internet isn't going to work out for us, unfortunately. Here, that's definitely apologies for that. But basically through the web front end, you could configure all the automatic deployments and sorry if anyone heard that, but this mic over here, basically we just released this new automation piece. If you go to your project, there's a little rocket icon in the top that's called deployments. You click that, you pick your GitHub repo, and then it'll automatically generate the key for you. All you have to do is give it the build and install commands we have out of the box build and install stuff for Next JS as well. So if you're building that, you should just be able to.
01:19:43.486 - 01:20:32.906, Speaker E: Click continue. And then the ability to also publish to different targets is coming as well. So by default, everything is being published over the Valves protocol, but we're also enabling automatic ways to then publish to these other app stores as well. So you basically get the best of both worlds there. So you get access to if someone is already using these app stores, which we all are, right, they can download your app from there. But if they're more like Hardcore Web Three, then they could use the Sapphire Launcher and you as well can embed download links on your website and directly use that for the payment flows and everything like that to bypass a lot of these fees. And then if you're downloading the Sapphire Client for mobile as well, it'll do everything super seamlessly.
01:20:32.906 - 01:21:23.550, Speaker E: So all you have to say is, hey, just download Sapphire and you can install all my apps from there. And yeah, again, since that all has the built in stuff, the more people that use that, the more resilient the software gets. And so, yeah, unfortunately I guess I'm not going to be able to do the demo because it does require internet access and it looks like the WiFi just keeps disconnecting and reconnecting. So definitely apologies there. But again, the guides should have everything that you need, but I will show you what at least it looks like to configure the CLI and I'll give you a preview of this Sapphire Client as well. So for this, basically this is the desktop client. Okay, sorry, lots of technical difficulties here, but okay, cool.
01:21:23.700 - 01:21:24.062, Speaker C: Yeah.
01:21:24.116 - 01:21:39.380, Speaker E: All right, let me just maybe just this here. All right, well, we're rolling with it. Okay, yeah, there's the nature of demos, right?
01:21:41.210 - 01:21:41.766, Speaker F: Okay.
01:21:41.868 - 01:22:03.980, Speaker E: It's stable. All right, cool. Maybe not. Okay, cool. Anyway, whenever you do see it, every couple of seconds you could see that we show different featured apps and different featured games. And again, send us your apps and games. We'd love to feature you.
01:22:03.980 - 01:22:44.546, Speaker E: You could also see what's featured on Testnet. I will say it does require for the Bounties for ETH India, it does require using the mainnet Valust site, but you could see top publishers, I'm sure you might see some familiar faces there. You could see recently updated stuff, newest stuff from there and then you can also launch these things as well, potentially. Yeah. So again, internet stuff going on here. It's pretty intermittent anyway, so we'll roll from there. But that is the desktop client that is available for beta.
01:22:44.546 - 01:23:26.360, Speaker E: So join our Discord and send us a DM and I will send you a copy of that and would love to integrate your apps as well into that and make sure that your app gets the perfect seamless experience that it deserves as well. And then for the CLI, we have an example projects repo on our GitHub as well. So you could check that out and we have different examples for multiplatform projects NextJS projects, react projects using the SDK and Node JS examples and pretty much anything you need. But I'm going to zoom in here a little bit. Hopefully everyone can see that.
01:23:26.970 - 01:23:27.750, Speaker C: Boom.
01:23:28.730 - 01:24:38.150, Speaker E: Basically what this project is multiplatform project demonstrates the full capabilities of the Valus protocol here. So essentially what this is is a combination of a go binary and a website. So most organizations tend to build cross platform like we'll have a mobile app and a website or a desktop app and a website or various combinations of so you can include them all in a single release with this. So we just have an example for a Hello World go binary that gets compiled to Mac builds both for intel and M one arm 64 Linux. We have AMD 64 in here, we have a web front end here and then as well as Windows. And then all you need to do to configure that is basically you just set up your account, you point it at the account on Vallast that you're trying to publish to you set up the project, same thing. And then you could give it a release here that can come from wherever you'd like as well, but you just basically give it a version and it'll publish from there.
01:24:38.150 - 01:25:53.510, Speaker E: And then to configure the different platforms, all you have to say is which platform it is and where it's at. So for the web build you just say web and then we have it in the disk web folder we have Darwin AMD 64 so Mac Intel builds Darwin Arm 64, mac Arm builds Linux Windows and then we have a bunch of other supported stuff as well. And you could also add custom platforms as well so there's no limitations there. And again with this SDK, if there's a custom platform you have you can always implement it that way. But then basically we combine all of this together into a single release and then when you view that on the project page you can actually see Mac icon, a web icon, Linux icon depending on what it is, the launch button will default to your preference. It'll default to the web first and if you don't have that it'll default to the current running platform and then same thing for the ability to install and everything like that. And then all you have to do to publish is type Valis publish and basically what it'll do is pull the same keys that are inside of your keychain.
01:25:53.510 - 01:26:37.982, Speaker E: That also is shared by the Sapphire launcher but it'll use that to sign a message, it'll upload everything to IPFS automatically and it'll publish the release in the exact same way that the website does as well. So you can stick this in a CI CD system, you can run this on your local machine. I just ran this a little bit ago and that's the log that we got. So I just published 215 with that. And then we get a couple of different URLs here as well so you can access it in various ways. And then we also provide automatic subdomains for you. So basically whenever you publish a release, you automatically get your projectaccount name on Vallass IO.
01:26:37.982 - 01:27:09.740, Speaker E: So we give you an out of the box URL similar to things like Versal as well from there. But yeah, I really wish I could be demoing this right now because it's super cool and super seamless. But yeah, again, if you go to the website and you view the guides there and you come reach out to me, anyone on the Vallus team, we're super excited to help get you published and yeah, I guess we open it up for QA right now and yeah, sounds good.
01:27:10.270 - 01:27:10.682, Speaker C: Cool.
01:27:10.736 - 01:27:11.734, Speaker F: I'm going to put on some headphones.
01:27:11.782 - 01:28:05.860, Speaker E: So I can hear everyone and then, yeah, whoever has the mic can can go ahead and ask their question, but give me just 1 second. Okay, cool. I can hear myself. All right, well, anyone who has a question, please feel free to grab a mic and yeah, we have a couple of minutes here to go over questions. Yeah, exciting stuff. So, yeah, we'll get some mics going. I don't know if the system there, but cool.
01:28:05.860 - 01:28:09.860, Speaker E: All right. Got one coming here.
01:28:14.170 - 01:28:14.920, Speaker G: Cool.
01:28:15.850 - 01:28:24.540, Speaker E: By the way, I like this set up as a way to avoid cross noise and stuff. I think that's pretty cool. Definitely very clever there.
01:28:24.910 - 01:28:40.042, Speaker B: Yeah. So I wanted to ask that if I'm hosting my application on Valid, so do I have the option? Does it always run on the Sapphire Launcher? If it is running on the Sapphire Launcher, then what are the benefits that I'm getting? If it is running on the Sapphire Launcher?
01:28:40.106 - 01:29:18.630, Speaker E: For sure, so you can always run it on the website, you can access it in all those different ways, but the benefits you get out of the Sapphire Launcher is that it gets cached automatically to the local nodes as well, and then it has a built in wallet. So instead of having to constantly sign stuff and constantly pop out of your application to do things, it passes it through every app that is included here. So basically, if I were to launch this, you could see that this is just a regular DAP here, really awesome DAP. And then it passes through. If I were to switch the network.
01:29:18.710 - 01:29:19.340, Speaker C: To.
01:29:22.670 - 01:29:48.558, Speaker E: I'll deal with that, but basically, yeah, you could pass through the wallet and it'll automatically go from there and then same thing from here. So if I were to launch this, I got to cache this, but yeah, basically as you're playing the games, it'll pass through automatically, so you won't have to worry about having them configure anything. This just has everything built in, so.
01:29:48.584 - 01:29:54.870, Speaker B: Basically it goes live. Like, it just goes along if I'm playing a game, just goes along with it. So there's no interruption and nothing else.
01:29:54.940 - 01:30:03.770, Speaker E: Exactly. And if you're building a DAP, then this is a way to install your DAP locally so that you can access it without having to rely on another endpoint in the future.
01:30:03.840 - 01:30:14.506, Speaker B: Yeah. So it's basically, like there's no this thing hardware or this thing any resistance that I'm facing if I'm just running on the Sapphire launcher.
01:30:14.538 - 01:30:14.974, Speaker A: Got it.
01:30:15.012 - 01:30:15.310, Speaker G: Yes.
01:30:15.380 - 01:30:22.942, Speaker E: And then there's an additional benefit here so that all of the things that are purchased through this bypass, all the App Store fees and everything like that.
01:30:22.996 - 01:30:25.186, Speaker B: Yeah, got it. Thank you. Awesome. Yeah.
01:30:25.208 - 01:30:26.180, Speaker E: Thanks for your question.
01:30:27.670 - 01:30:28.254, Speaker D: Sweet.
01:30:28.302 - 01:30:30.180, Speaker E: I think we have time for a couple more.
01:30:33.770 - 01:30:34.278, Speaker B: Cool.
01:30:34.364 - 01:30:49.702, Speaker E: Sounds good. Sounds good. All right. Well, anyway, yeah, I guess if we don't have any more questions, but yeah, definitely. Again, sorry for the technical difficulties demo stuff, but we roll with it. We're in web three. We're scrappy.
01:30:49.702 - 01:31:13.762, Speaker E: We got this. No problem. But, yeah, please find us whenever you're publishing. And, yeah, we're looking forward to seeing your apps, and, yeah, send it to us in the discord, and we'd love to highlight it. We'd love to spotlight you on our Twitter spaces or do a play session in our discord as well. We've been doing that as well with our community members for that. So really exciting stuff there.
01:31:13.762 - 01:31:21.140, Speaker E: And, yeah, looking forward to seeing what people build. Good luck, everyone. Thank you.
01:38:55.330 - 01:39:29.190, Speaker D: Let me just change the display for you. Can anyone hear me? Okay, awesome. Hello, everyone. This is Sanchez, Amito. And here we are. I'm from Connect. I'm one of the leading juniors at.
01:39:29.560 - 01:39:31.030, Speaker E: You Cannot Hear Me.
01:39:32.880 - 01:39:33.630, Speaker D: Hello?
01:39:34.160 - 01:39:35.310, Speaker G: Is it good?
01:39:36.320 - 01:39:38.140, Speaker D: Can you guys increase the volume?
01:39:43.640 - 01:39:44.390, Speaker E: Hello.
01:39:45.320 - 01:39:46.276, Speaker D: Is it better now?
01:39:46.298 - 01:39:46.870, Speaker B: Guys.
01:39:50.850 - 01:40:09.710, Speaker D: Cannot no, they cannot hear. Hello now? Is it better?
01:40:12.560 - 01:40:14.030, Speaker E: Nobody can hear me.
01:40:16.680 - 01:40:17.140, Speaker F: Hello?
01:40:17.210 - 01:40:17.830, Speaker D: Hello.
01:40:30.060 - 01:40:31.690, Speaker B: See, this is full.
01:40:34.380 - 01:40:35.130, Speaker F: Hello.
01:40:38.940 - 01:40:43.710, Speaker G: Two. Check it's coming, two.
01:40:48.920 - 01:40:49.716, Speaker B: Hello.
01:40:49.898 - 01:40:50.820, Speaker D: Tk.
01:40:52.520 - 01:40:53.750, Speaker B: Does this work?
01:40:55.400 - 01:41:21.820, Speaker D: Hello, everyone. This is Sanchez Mithal from Connect. I'm a leading engineer at Connect. We have been here from 2017. We have been into the interoperable solution, and let's start with how we can build a Zap where everyone okay, I'm assuming that here we have an audience who is kind of aware of how the contracts work, how the solidity details, and we don't have a slide.
01:41:22.160 - 01:41:22.910, Speaker E: Okay.
01:41:35.390 - 01:41:56.934, Speaker D: I will start some intro if anyone can hear. Yeah? Yeah. Okay. It sounds good. Again, I think I already gave my intro. I can do it. Third time.
01:41:56.934 - 01:42:12.074, Speaker D: This is Sanchez Mittal, and I don't know if Mike is working or not. I'm going to shout it out. Yes. So we are building cross chain domain applications. Everyone is aware of DApps. I'm assuming that's the case. Everyone is aware of how the smart contract works.
01:42:12.074 - 01:42:36.446, Speaker D: If not, we will go through that. No worry at all. But let's start with the mindset that if we are building any applications, they are not existing only on Ethereum. Now we have polygon. We have optimism. We have multiple chains which are coming up and they have their own incentive. The whole liquidity segment is all across these chains.
01:42:36.446 - 01:43:14.970, Speaker D: One has bigger or one has another. They have these incentives which are run multiple times and that's why people are getting more and more interested in Zaps. Or we call it cross chain DApps. Let's start with a basic intro which we will be using these terminologies a lot. We are not going to say chain because we know that there are multiple networks which are not exactly a chain. We can categorize it in a protocol or it could be a roll up which is very dedicated to a specific problem. So any L one L, two side chain and non EVM compatible, we will just call it domain.
01:43:14.970 - 01:44:13.662, Speaker D: Right? So I'm assuming you guys are with me right now and as I said, Zap is a cross chain domain native app. So any application which we will be building right now is going to be a cross chain DAP. That means it is available on ethereum, polygon, any of the EVM chains, any of the non EVM chains as long as we are supporting and we are agnostic, as long as it's secure, right? So let's start with the second part. Yes, we are a bridge and people have this question are we secure? We have seen a terrible year last year and we saw three billions of hack and are we the same? No, but everyone says that. So let's explain how we are different. But let's start with why bridge are unsecure. Why we saw this 3 million 3 million oh, sorry, 3 billion.
01:44:13.662 - 01:45:17.030, Speaker D: 3 billion of hack which happened last year. What happened is that there are bridges which use these trust assumptions which are basically validator sets, multi six. So you are depending on these ten people okay, can I bridge my million of dollars and I will trust you guys? Okay, you three, I love you and you will take care of me, right? And that's the trust assumptions which we are making with these stupid bridges which are using multi six or validator set, that is simply third party and how we can stop it. And yes, there were some code bugs which we have to make sure that we have simply much more large audience. We have these TVL caps and we have much more audited, power audited contracts so people can go through it and they can report any security issues which they are seeing. So let's jump on to why Connect and how we approach this problem. So Connect uses modular stack.
01:45:17.030 - 01:45:54.366, Speaker D: We don't create any new cross assumptions, we are not adding any sort of value data set, we are not adding any multi six. What we are doing this is the interoperable trilemma. If you guys are not aware of I'll run through you very quickly. So everyone, if people don't know about scalable trelema, that's okay. So when we are talking about interoperable trellima. That is where we are talking about trust minimization, generalizability and extensible. So when people try to create these bridges they try to take these shortcuts where they do trust assumptions and try to avail generalizability and extensibility.
01:45:54.366 - 01:46:51.250, Speaker D: So they can use a common interface for the bridges and they can have like a bunch of money goes from one side to another. But don't never think about the trust minimization. But we as connects, we take pride in it. We absolutely take pride in is that we 100% focus on trust minimization. We make sure that this is happening and then the user interface or the user experience. Yes, it's very important that if it's going to be horrible, I'm like you are secure guys, but that's a shit show, right? So we want to make sure that we have cross minimization, we have good user experience and how we can expand it to more chains, how we can make sure that anyone who is coming cross chain can easily come and they don't even think about it like okay, which roll up or which chain I'm using? I just have these six five params which I have to put in and I'm all done, all good. So what we do is that first let's start with how we are focusing on security.
01:46:51.250 - 01:47:33.162, Speaker D: We focus on security by using transport layer which are underlined which are present for these bridges. So we don't create a new messaging layer. We use these existing messaging layer which are pretty secure already or they are the secures one for those bridges. So when I'm talking about polygon the POS tech is the secureest. They use validator set but that validator set actually runs the whole chain. So even anything happens to POS tech the chain will dissolve itself, right? So the POS tech is the secureest one right now for polygon. And same when I'm talking about Cosmos ecosystem it's going to be IBC, right? And when I'm talking about roll ups it's going to be roll ups.
01:47:33.162 - 01:48:07.422, Speaker D: So we use that as a transport layer and then we have another security layer above it where we have watcher set. Whenever you are sending a message from one side to another. When we are receiving this message from polygon to ethereum, we have this watcher set where we have 20 minutes where you can make sure that okay. Anyone sees that this information is not correct. Guys, even if you are using Amb, if it's falsified, we can make sure that doesn't happen to us. We can report it and stop that bridging which is coming up. So running through quickly how we can do it.
01:48:07.422 - 01:48:56.086, Speaker D: We have pause button. So on each contract we see that something is going wrong we have this pause button press it sell, right? Nothing is stolen, everything is secured. We have TBL caps. We make sure that we have a TBL caps. We know that we will start with some TBL cap and once we are increasing it, we will have another audit. We'll run through the community that please, if you see anything, report us. We have incentive for them and we have fire drills which we run through every time where we see that if anything happens, how we can do it, I mean you have to run through it, right? You have to be prepared if anything worse happens, we have to be there and formal verification, additional audits, we do it all the time, generalizability, we have an arbitrary message passing.
01:48:56.086 - 01:49:56.894, Speaker D: That means that you can pass any message. It could be any piece of information. It's not only token, it could be NFT, it could be a simple I love you message. I don't know anyone wants to do that and if they want to send like do a Dow Governance, they want to see if there is Aave in case right now we have polygon ethereum on multiple chains existing. But how do they do a Dow Governance? They can use cross chain and they can have the voting mechanism properly done through this and extensibility we are present on all the chains, how connects works. So it's very simple for a user or adapt developer, what they have to do only is that use this X call, I will run through the interface itself, they have to go through the X call and that's all is needed for the DAP, right? You have these seven params you have to put in there and everything is taken care the connect. You can absolutely understand how the architecture works.
01:49:56.894 - 01:50:54.834, Speaker D: And we have these active help providers, what they do is that they see okay, there is a request of completing this message. I will run through it, I will wait for the messaging layer for one and 2 hours. But for users for the DAP, it's going to be one to three minutes at most at most, right? So you are having these transactions which are happening from polygon to optimism in two minutes in a single call and you can have multiple features available, you can put it in the encoding and you can have a uniswap trade happening. You can have abundance of use cases available where you can do anything cool in a single call which can happen in one to two minutes. Right? Let's run through how we can do this. So let's start that ten minutes which is on the clock, she'll be on the Zap. So why it's one click UX as I explained, better liquidity what we have right now.
01:50:54.834 - 01:51:28.794, Speaker D: We can avail better liquidity if we know that there are incentives provided to the routers and there are users who wants to use it cheaper and faster transactions. Of course, if you go like each and every chain it's going to take like a huge time apps also it's not going to cheaper at all. You have to make these three to four or five calls where you have to execute it. Right, you go make polygon Ethereum optimism. On Optimism you make a swap. So four calls already added, right? Four transactions already added. Here we are doing arbitrary message passing, so you can do a lot cool stuff and that's what it is.
01:51:28.794 - 01:52:01.666, Speaker D: And we don't pick anyone winning. We are chain agnostic. Users are going to use these multiple platforms. So we have to make sure that we can actually onboard a lot of users. And that's for the DApps, right? And we have a unified interface for all the chains, so it's not going to be different for anyone. And as I said, we can pass any message and that can be encoded into call data. Okay, so I will run through really quickly how we can do everything on these slides.
01:52:01.666 - 01:52:45.126, Speaker D: I was going to do a live examples that would have been so clue, but the internet is not working over here. So let's start with the anatomy of a Zap when we are talking about these. That one simple use case of interaction would be that you can use simple Xcall which is available on connects Sol. You can make provide the parameters and then you can execute it. Another one is that you can have something cool over here happening on source Sol, right? You can have some functionality over happening here and then you can transfer the money. So you can maybe do some swap which happens over here and then you can use Xcall and then you go over there and then do another swap or anything, whatever you like, right? And let's jump on to what we.
01:52:45.148 - 01:52:46.920, Speaker B: Can build with this, right?
01:52:47.770 - 01:53:45.238, Speaker D: I will run through this really quickly and we have these code examples where I will explain how exactly you can do it. It's over here, right? So what we can build, we can do token bridging, we can do simple Xcall where you have to transfer your money from one chain to another. You can have cross chain governance where you can do voting yield optimization. So Ethereum has already consumed everything like any best API which is already available. So let's find out crossing, right, we can have really better API which is available on Optimism Arbitrum or any other chain which is popping up right now, right? They provide these incentive for the users to come and provide the liquidity over there, so you can get much better APY all across these chains. Dex, Arbitrage, you can have different swaps rate dex liquidity, you can provide the liquidity to the Dex. Again.
01:53:45.238 - 01:54:37.294, Speaker D: Better APY. Cross chain vault strategy. It's really cool, really cool. So if you have these vaults and strategy management, you can have these funds which are already available on these multiple chains and can execute really it's more like LP providing as well as you can have these strategies which are already given through yarn possibly. And it's really amazing. I'll go through that in one SEC and we have these cross chain loans so you can broader on one chain and provide like Pay on other chain, right? We have cross chain NFTs so let's make it cross chain. Right? So if we have an NFT on Ethereum we want to use it on a game of optimism or the gas fee which is provided on polygon is going to be cheaper.
01:54:37.294 - 01:55:10.818, Speaker D: So we want to make a marketplace which is available on optimism. We can trade on polygon. So once we have these things cross chain we can have much more functionality available. Guys, I know that we don't have internet but you can scan the QR code. You can start with this template which is available on Zap starter where you can I will give like 1020 seconds. Just scan the QR code or read the link or click a pick and then you can go through that later on, right? Okay, yes.
01:55:10.984 - 01:55:11.700, Speaker C: So.
01:55:13.830 - 01:55:46.496, Speaker D: Connect with us but we can show this QR code later on. Let's jump onto this rate on the code side right now. Yes, so we have docs which are available, you can open that as well. Quickly click a pick and I will just go through the next slides. Awesome. So when I said Xcall, xcall is the main function which DAP or the user needs to understand or user doesn't even need to understand. DAP needs to understand that.
01:55:46.496 - 01:56:38.432, Speaker D: So we have this X call function where we have these seven parameters which you need to provide to make any cross chain call, right? So you're providing a definition chain where you want to execute this function or where you want to receive these funds and then you have these target address, this is two address so it could be a receiver address or where you want to execute like a new functionality that would be your target address. ERC 220 the token which you are transferring, if it's not related to token you can address zero this and you can send any arbitrary message through that delegate. This is of safe functionality. If something happens I will go through that later on. Amount slippage and call data. Call data is one of the main way you can actually encode something if you are not encoding. It's a simple transfer, you can just zero exit slippage, maybe mention 3%.
01:56:38.432 - 01:57:42.548, Speaker D: So we know that if it's going through the AMM we wouldn't suffer loss. So there are like two types of billing which would be simpler, which we can do. That is Xcall through SDK so you don't even have to jump on the contract side and if you are doing a contract integration that is going to be asset transfers, unauthenticated calls where you don't have to know on the target side from where this call is coming up. Let's start with SDK. It's pretty simple, right? So we have these X calls available, we are doing an approve for the token and once we have done that we are simply creating a call x call using the NXTP SDK base so you can download the SDK you just create this simple call and you are done with it and that's all. You are already across chain app for this. As I said, there are lots of functionality I will mention one of them which is very popular to you guys.
01:57:42.634 - 01:57:44.384, Speaker E: Is that Dex Arbitrage.
01:57:44.512 - 01:58:45.190, Speaker D: So if you are talking about a price probably of ETH on ethereum it could be way different on polygon, it could be way different on optimism and you have to spot these decks arbitrage and you can make a good trade, you can make money out of it and that will happen in one to two minutes. So you spot that, you make these transactions your money and that's what the Dex arbitrage is going to be about. This is a simple transfer as similar to the SDK but we are not using SDK, we simply want to use contract. You can just encode everything which is happening over here. So you have alliance happening, you transfer the tokens and you have the approve happen, you just x column. Let's jump on to the really cool part. So as I explained initially, we had the source contract, we have these target contract, right? So in source contract what we are doing over here is that we are sending a simple message that is a new greeting.
01:58:45.190 - 01:59:39.742, Speaker D: We are sending a simple hello world over here and we are just creating X call over here, right? So when we already saw like if you want to transfer a token that can happen, right? That can easily happen. You just put where the address zero is, you can put the token address and you can put the amount and that's what is needed. But when we are sending an arbitrary message, you don't even want to use the token transfers. You can do this where you can simply have these target contract created where this is going to exist on destination chain and this is the target address which will be on the source contract. Once you do that you are simply checking that okay, did I receive suffice amount? If you want to and you can receive the message by simply decoding it. So you encode the call data, you decode it and send it to the function. So we have a simple, very simple example where we are sending a simple message.
01:59:39.742 - 02:00:46.194, Speaker D: But just think about this, if we are encoding a swap data for uniswap and we are sending that, we are encoding that and decodes over here and then we process that function further here. So you can put any functions on the destination side and easily can execute it through this. So you're talking about a one to three minutes of execution where you are doing impractical where you have to do five calls, five transactions if you are not crosschain and you can do simply through this and yes, these. Are the three examples which I'm providing over here. Where can you do yield optimizations? You can spot the best yield out of all the networks can unknown cross loans. You can borrow one side, you can give it to another side. Think of it this way, we have a position created on ethereum but I have funds on polygon, right? So I would just want to send the funds from polygon and complete my position on the ethereum and that can happen in single call.
02:00:46.194 - 02:01:48.582, Speaker D: That's what the cross chain loans are about, cross chain NFTs. I've already gone through this. There is another part of this in the target contract we can have authenticated target calls. So sometimes we want to make sure that this call, where it is coming from, we want to make sure that this is the address I want to trust for, right? So the source address where I'm receiving that, I want to make sure that on target, that it is the one and that is required in case of crosschain governance or in case of crossing vault strategies, even in case of cross chain NFDS where I want to make sure that from where I'm receiving this address, these funds or these NFDS, or I'm getting a call of executing or transferring the funds from this destination to, like, a C chain that is coming from this source address. And that time we have to use this authenticate call. So here we have a modifier where we are putting only source and we are sending these origin. Sender and origin.
02:01:48.582 - 02:02:21.342, Speaker D: That would be a part of the reconciled call which happens underline the bridge. And it will provide you the address where the call came from. And that's what will authorize that, authenticate this. And that will take 30 minutes. So you have these two cases where you can execute things in one to two, three minutes and where you have use cases where you can do 30 minutes to 1 hour depending on. So you have these two really cool ways to actually implement multiple ideas. Thank you very much guys, that's all from me.
02:02:21.342 - 02:02:54.090, Speaker D: We can run through this. All the ideas I would love to hear from anyone. If you are online you can send us these ideas on the discord which is available on the connects. So you go to theconnects network, you connect with us on the discord and we can chat more over there. Anything else? I would love to hear the questions right now. Anyone with the questions I'm happy to take right now.
02:02:56.620 - 02:02:57.370, Speaker E: Awesome.
02:03:24.800 - 02:03:28.430, Speaker D: Yeah hi, I'm Adav here so basically.
02:03:28.740 - 02:03:30.800, Speaker H: We are trying to build something on.
02:03:30.870 - 02:03:33.650, Speaker D: Connect and trying to build.
02:03:49.930 - 02:03:50.902, Speaker C: Can you hear me now?
02:03:50.956 - 02:03:52.280, Speaker D: Yeah, I can hear you.
02:03:53.930 - 02:04:02.394, Speaker H: What my question was like basically we are trying to build a smart contract in which we can transfer the tokens from one chain to the other and.
02:04:02.432 - 02:04:04.506, Speaker D: I saw the slide that basically we.
02:04:04.528 - 02:04:06.618, Speaker A: Can use the Xcall functionality of connect.
02:04:06.704 - 02:04:08.458, Speaker H: And would love to build on that.
02:04:08.624 - 02:04:10.206, Speaker A: One more thing that I wanted to.
02:04:10.228 - 02:04:33.310, Speaker D: Know is that can we have the access to the PPT slide as well? Because the code was not quite visible from back here. Yes, for sure. These slides will be shared on the Discord Channel. We will share it on the ETH India as well. We will have our group. You can connect on the Discord where we can share that there as well. And also you can run through all of this on the Zap Starter.
02:04:33.310 - 02:04:53.690, Speaker D: So everything is provided on Zap Starter. You can simply use this template and can go through the contract examples we have been put in. So even if you want to use contract examples, you can go through this. We have these multiple examples already provided here, as well as the SDK example is on the page behind us. So yes, everything is available.
02:04:53.840 - 02:04:54.682, Speaker C: Hit us up.
02:04:54.736 - 02:05:12.710, Speaker D: We will be happy to help in any way possible. If you guys want to brainstorm, we will be available throughout the night. We will be available tomorrow. So, yes, thank you very much. Awesome. Thank you guys very much.
02:14:12.560 - 02:15:04.860, Speaker A: Can you hear me? But there's no queen, I guess. Hello, can you hear me? Okay. Hi, good afternoon. I'm Hari from EY Blockchain Research and Development Team. Today I'm going to be talking about Starlight, one of our R D products. It's a ZK compiler which allows solidary developers to generate privacy preserving applications without knowing much about ZKP or much about what cryptography go behind the scenes. Before I get started, I want to just quickly explain what evidence and what Evide does in blockchain space, basically.
02:15:04.860 - 02:15:52.362, Speaker A: So we have been building a lot of blockchain products over the past few years, and we are fully focused and open and vocal about our support for public blockchains. And everything we build is on public blockchain. And not just any public blockchain, but specifically on Ethereum. Global blockchain leader Paul Brody has recently taken a chair seat at Ethereum Foundation. So that kind of shows the collaboration and commitment we have with Ethereum Foundation, ethereum Ecosystem. Now if you work in a firm like Know, many people ask me as what does Evi have to do with a public blockchain? And a lot of our clients are banks and accounting firms and enterprises who doesn't want to put their data into public blockchain. And very rarely that we get a use case.
02:15:52.362 - 02:16:32.470, Speaker A: Like, for example, you could have an ESG use case where somebody wants just one enterprise, want to create a carbon offset, and they just want to create some NFT tokens and put it in the blockchain. And that's fine for them because they don't want privacy. But more often than not, privacy is a very important factor for enterprises to use public blockchain. So most of the work that we do in our R D team is based on creating privacy tools to build on Ethereum and in our privacy suit, we have two solutions. One is nightfall. Nightfall is a ZK optimistic roll up solution on Liar. Two, we have already joined with Polygon and it's already in testing beta version.
02:16:32.470 - 02:17:19.894, Speaker A: It allows you to transfer your ERC 20, ERC seven to one W, one double five, whatever it is, under privacy. So that's one bit of the puzzle, right? You can transfer privacy, you can transfer data in private. The second bit is, and this is the most important and mostly neglected one, is what about the business logic? What about when you want to create a business logic in privacy? Or in other words, what if you want Ethereum to understand privacy, right? Ethereum's brain is a smart contract. Smart contracts doesn't really understand privacy. Everything you put around the smart contract is public and anybody can see it. And a lot of companies don't want the data to be put in public. For example, your age, medical records or your business agreements, you don't want them to be in.
02:17:19.894 - 02:18:03.666, Speaker A: And the difficult part is, it's not like a ZK roll up solution where you're just transferring a token. It's very customized and it's very specific to the Use case. So you can't really quickly have a tool where you can just put it in and then you create a private network out of it. But Starlight aims to kind of solve these problems. Another problem that we ran into when people came up, a lot of clients came up to us and asking for privacy to be included in the solution was it took a lot of time for us to educate our developers on what Zkpe is, how to use this, what elliptic curve is, what the points are, and all these things. So out of all this frustration is what Starlight was born. Starlight kind of tries to solve all these issues.
02:18:03.666 - 02:18:40.186, Speaker A: It removes the learning time. It takes all the burden off developers. All we do is, all we do is a pretty trimble three steps and you can take your normal smart contract and you can have a fully private smart contract ready. So I'll explain the three simple steps, which are pretty easy. First step is write your solidity smart contract, which you already know, right? So step one is check. Step two is you add certain decorators into the smart contracts. And what I mean by decorators are like decorators are like your keywords that you use in a normal programming language, like private, protected or anything, which the ZK compiler, the Starlight compiler, understands.
02:18:40.186 - 02:19:13.434, Speaker A: Here we have three decorators which our smart contract understands, compiler understands, and based on the Use case, you have to choose which decorator you have to use. Third step, my favorite, and the easy one is just to run the Zapify. It does everything for you. It creates a complete zero knowledge application with circuits with the Shield contract and all the backend containers as well ready for you. So you don't have to really worry about what goes behind the scenes, what happens, how to build a circuit and what are the commitments to be used. Everything is done in the backend for you. This is pretty easy if you're use case.
02:19:13.434 - 02:19:43.454, Speaker A: There are a lot of use cases where this can be applied. Now that's it's pretty easy to use, right, we can start using, but let's open the COVID a little bit and understand what happens under the hood here. Okay, so in Starlight, when you run the Zapify command, three steps happen. First step is Pass, then transform and then generate in Pass. And this is how the compiler basically works. In Pass, what we do is we take the solidity contract, which is decorated. Now we kind of split them into two halves.
02:19:43.454 - 02:20:08.598, Speaker A: The first half contains a contract and then we have these decorators. The mapping between the two still remains. And now we take the solidity contract and we convert it into an abstract syntax tree or basically into its JSON form of the code itself. All programming languages have this AST, which you can have. Now, this AST is a pure solid AST to which we kind of add back the decorators we splitted previously. That's what happens in the first stage. So you do the passing.
02:20:08.598 - 02:20:40.630, Speaker A: Eventually you will get an AST, which is the normal solidity code plus a little bit of what the decorators were added. Now, in step two is the transformation where we take this ASD and we convert it into three different abstracts and tax streams. One is for generating your circuits, which is for your zero knowledge, proof generation and stuff. Second is for your smart contract. Smart contract basically does the onchain verification of proofs. And then we have the third orchestration AST, which is for the backend containers and testing. Now, once we have the three ASTS ready, then we do the reverse of what we did in the first step.
02:20:40.630 - 02:21:15.386, Speaker A: That is we take the AST and then we create the code from it. We create the zero knowledge code from the circuit AST. We create a Shield smart contract from smart contract AST and we create kind of an orchestration code which kind of connects all these things together. Now that's it. So we get the AP with these three steps. Now, so I spoke about the decorators and how these decorators are, right? So now let's just look at how the transpiler works. So you can assign that you have a variable, unsigned variable X and that you want to kind of keep secret in your smart contract.
02:21:15.386 - 02:21:37.130, Speaker A: It could be your age, it could be a phone number, it could be anything that you want to hide from your Shield contracts, hide from the public. Now you add a decorator. Secret is one of the decorators that we have. Unfortunately, we couldn't use Private because private is already used. So Secret is a decorator that we have and then that's the second step where we kind of decorated. Third step is running Zapify. Once you run Zapify, it creates everything that's on the outside.
02:21:37.130 - 02:22:04.078, Speaker A: Zap is kind of short form for zero knowledge application. It contains the contract circuits and the backend containers. Circuits are basically building Socrates in Starlight and these circuits contain your private public input and your information and your kind of the code as well. Contracts contracts is a Shield contract. It's not really your smart contract. The Shield contract is for your on chain verification. The only thing that happens on chain is your verification of your commitments.
02:22:04.078 - 02:22:47.598, Speaker A: And in the backend containers we have a blockchain client which could be your Gynash geth or anything that you can just configure and connect like you try and connect eyes. Socrates is the backend that we use to create generate proofs and to kind of do the setup. We have timber. Timber is another excellent product by our EY team. It's a merkel tree which stores commitment in a very efficient way so that you don't really have to pass through too much or you have to reveal the commitment to view what it is. And then finally we have a testing infrastructure which is ready where you can deploy to different testnets in Ethereum and see how it works. Now, I spoke about a lot about decorators so let's see them now.
02:22:47.598 - 02:23:28.298, Speaker A: Right, the first decorator is Secret, secret as it names that if you want to keep a variable as secret, if you want to keep a variable confidential from the information, you call it secret. Now you can have it for state variables, you can have it for function parameters, we intend to add it for functions. But basically whenever you want to have a variable that has to be kept in the circuit which has to be in private state, you name it a secret. Now, once you focus on the right side here and the yellow bits so here you have an unsigned integer x which is kept as secret and also a function parameter y in the function add which is secret. Now what you're basically doing is adding x into x plus y and I'll.
02:23:28.314 - 02:23:29.294, Speaker D: Get to known in a bit.
02:23:29.332 - 02:24:03.126, Speaker A: But this is what basically does. Then the next step we have something called known known. So now we can do the contract. Right now it depends upon we have the state variables and all but what's the use of it if we can't modify it, if we can't use it a lot. So that's where the other two decorators come in. The first one is called known. Known is when only the owner of that particular smart contract, owner of that nullifier can edit it.
02:24:03.126 - 02:24:43.010, Speaker A: Now the second one is Unknown, where anybody can basically edit the data. Now I'll get a bit more in detail into how the known works and it's important to know how the commitment structure of known and unknown works. Here so when you say a known, what it basically means is that only the owner of that particular commitment should be able to edit the data. Only the owner of the particular commitment should be able to increment the data x plus y. When somebody else tries to know it, the zero knowledge application kind of throws an error. So for a non to work for somebody to call the non function you have to submit a couple of proofs. The first one is the proof of knowledge of the existence of the old commitment.
02:24:43.010 - 02:25:21.566, Speaker A: This is done without really revealing the commitment by using the timber tree. Second is providing the knowledge of secret key. Knowledge of secret key is basically related to what the public key is and you just have to kind of authenticate who you are. And then once you do that, you have to nullify the commitment which means that you have to kind of delete that commitment from database and then you add the new commitment. So that's what known does. It's pretty easy because you only have one state every time you delete the previous commitment and you have only one commitment. Unknown is a bit different and there are a lot of use cases when you want a lot of people to kind of many people to kind of edit into your secret information.
02:25:21.566 - 02:26:11.594, Speaker A: For example your balances where you want people who want to transfer you money but you don't want them to debit from your account, right? So you want the credit to be given by everyone, but the debit to be only by one person. This is the case where multiple people are trying to edit a particular secret variable at certain situations. That's when we use unknown. What unknown does is it creates something called partition variables or partition commitments where you don't have just one single state. In previous state we had only one state and we kind of delete the state and we override it with a new state. In this one in unknown statement we have a lot of part commitments and these part commitments come together and kind of summation of it is what the whole value is. On the example, as you can see, balances is something that is kept as unknown.
02:26:11.594 - 02:26:45.770, Speaker A: So anybody who's holding the balances anybody can transfer to my balance. So if somebody who is a sender here it debits from his account and from the unknown. The unknown balances is actually of the recipient so it's not his own account. But with unknown you can kind of edit his secret seat as well. Next one. It's important to know the commitment structure a little bit the commitment the first thing that holds is the state variable ID. Now Solidity has this state variable ID in itself which is a unique ID that is given to each variable then is a state value.
02:26:45.770 - 02:27:29.020, Speaker A: State value is the value that it holds. It could be a number, it could be a string or anything and then the public key of the owner and we have a solve to kind of award duplicate commitments or commitments that have duplicates. It's pretty easy for a normal state variable because we have a state variable ID that is unique. Now, it's a bit tricky when you have mappings or when you have arrays where you can have one state value and there are a lot of elements that are related to it. In this case, what we do is we take the mapping key, we take something called a mapping key which could be your address, which could be the array index and then that is replaced instead of the state variable ID. So it's basically a hash of the state variable ID and the mapping key that's the first input. The rest of three inputs are pretty same.
02:27:29.020 - 02:28:09.158, Speaker A: I'll give you an example here of a developer use case and what really happens. Now we have a secret mapping here of an address to an answer integer which is the invoice of the people that they are. And then we have two functions add invoice and pay invoice. What add invoice basically does is that you can add invoice someone's account and then pay invoice is you can pay off somebody, whoever you're owning it. Now, in this case, basically when you call the add invoice API, what happens is it checks for the commitments in the database for this particular honor that we have. For example, if you want to add invoice to the honor, it checks in database for this honor's database is there or not. It can be done by anybody.
02:28:09.158 - 02:28:47.890, Speaker A: So it checks for that particular honor and then once that check is done, you create a new zero knowledge proof using Socrates and you push into the database. Now this proof is then given back to the orchestrator file. So the orchestrator first calls the Socrates and it creates a shielded proof, means zero knowledge proof and gives it back to the orchestrator. The orchestrator now contacts the shield contract which is on chain and the on chain proof is verified. Once the proof is verified, we update the states and everything is done. Now, you don't have to know all of this to build on Starlight. All you need to know is to write a solid smart contract and add these decorators as required.
02:28:47.890 - 02:29:57.980, Speaker A: Now, something that we understood is that privacy has become a big factor and something that we haven't worked on a lot. A lot of industry applications or general applications require privacy and people to be building on privacy application. We believe Starlight is a good tool that can help you build it. Now you can use our repo here. So all our products in R D, both Nightfall and Starlight are completely open source for people to look at. Please have a look and provide feedback and work on it as well. And I'll take maybe a couple of minutes for quick questions and then I'll hand over the mic that's it from any questions? Yes can somebody your mic pleased.
02:30:07.540 - 02:30:09.490, Speaker D: So how will it.
02:30:12.500 - 02:30:13.904, Speaker B: So how it will.
02:30:13.942 - 02:30:23.716, Speaker D: Integrate with existing tool like Hard Hat and truffle because basic solidity has like Abi and here you have AST so.
02:30:23.818 - 02:30:24.710, Speaker B: Will those.
02:30:32.120 - 02:31:06.230, Speaker A: Sorry so yeah you can try it on Infuria. We have tested it on Infura. We are deployed on polygon testnet we usually use Ganache to kind of test it we are deployed on Get so it doesn't really matter you can deploy it on any platform that uses we haven't tested on Hardhat but I'm pretty confident it will work as well any more questions?
02:38:38.540 - 02:40:22.990, Speaker C: And today we are going to see a talk about the safe but specifically the safe core SDK and we are going to mention what are the safe modules and safe transaction guards and also how the safe core SDK can help us manage them. So the content we'll be covering today is an overview of the safe architecture. Then we're going to see the safe core SDK monorepo that is in GitHub available, how the transaction flow works on the safe where multiple signers must need to sign a transaction. Then we are going to talk about the Safe modules and how they can expand the functionality of a safe also Safe transaction guards, how they can check or add some constraints to the transactions that are being executed and then we are going to see what hackathon bounties do we have and how to contact us and what resources we have to help you during the hackathon. So first of all I would like to ask you if you please could raise your hand to see who knows about the safe what the safe is, okay, who's using the safe, who knows about transaction guards or modules. Okay, pretty good, so pretty good. So let's start with the safe architecture, a brief overview we have different layers, the main one will be the contracts, the most critical one and there we can find the safe contract itself.
02:40:22.990 - 02:41:36.150, Speaker C: There are a couple of contracts that interact among each other. Then we have some libraries, for example the multisend that allows to execute batch transactions. We have also the safe modules and safe transaction guards that we'll see later. We also have a layer of services that we run but you can also run by yourselves being the most important one regarding this talk, the Safe transaction service because it will allow us to collect the transactions that are proposed by any of the signers and also the signatures from the other signers so somebody can execute the transaction finally. And the last layer are the interfaces. So we have different interfaces like the web interface, mobile apps, CLI and some SDKs. Here we will covering in the SDKs the safe core SDK so let's see how the SDK monoreppo looks like and what it is the SafeCore SDK, it is software developer tools that facilitate the interaction with the smart contracts and also the services.
02:41:36.150 - 02:42:25.800, Speaker C: And because it is a monorepo, there are some packages inside of it. So let's see what they do quickly. The first two, the SafeCore SDK types and SafeCore SDK Utils. It's pretty easy to see what they do, right? One of them exports types makes them available to the other packages and the util has some utility functions. Then we have the next two, the Safe Web Three library and the Safe Ethers library. These are two wrappers of the web three JS and the Ethers JS libraries and also allow to get instances of the Safe smart contracts depending on the version you want to use and the network you have your provided connected to. After that, we have the SafeCore.
02:42:25.800 - 02:43:14.700, Speaker C: SDK. This is the most important package in this monorepo. It will need one of the previous packages like web three or Ethers that will provide the connection to the network and then you would need to provide a safe address in order to initialize this package. If you don't have a safe address, you can also deploy one with it. And this package is all about interacting with the smart contracts. Everything there happens on chain and you can get information from the Safe like getting the owners, the threshold, the nons, whatever. You can also create and prepare transactions you want to execute, sign them and execute them.
02:43:14.700 - 02:44:13.220, Speaker C: And finally we have the Safe service client. As if you remember before there was one service, the Safe transaction Service that allows to collect transactions that are proposed and its signatures. And this Safe service client consumes that API. So you can also get information from the Safe by consuming this API but also have access to the history of transactions, check the transactions that are pending and required your signature. You can also propose a new transaction, you can get the balances of the save, the USDC conversion, et cetera. So in this monorepo we have these packages. We also have a guide that will show you step by step how to use the SDK, how to propose a transaction, sign it, execute it.
02:44:13.220 - 02:45:19.364, Speaker C: And we have a playground. This playground is something new, it is a folder called Playground where you already have a few scripts, just have to modify a couple of configuration parameters like your Safe, the RPC you want to use, et cetera. And then you will be able to deploy a Safe to propose a transaction, to sign it and to execute it. So let's see how the transaction flow looks like and how it is different from the external owned accounts. For external own account, the transaction flow is easy, right? You have just an account with a private key that gives you access to everything inside that account. However, the Safe, because it is a smart contract, where its main functionality is being a multi signature wallet. We need a couple of signatures so these signatures together can approve the transactions we want to execute if they reach a threshold we can define.
02:45:19.364 - 02:45:50.800, Speaker C: So, for example, two out of these three signers need to approve every transaction. We can use the Safe Transaction service to collect these signatures off chain. This is something optional, but we will use it to afford some gas. And as we saw before, the flow would be to initialize the core SDK. Deploy a safety if we don't have it. Create, propose, confirm and execute. So let's see how it looks.
02:45:50.800 - 02:46:23.270, Speaker C: The code we need to import the SafeCore. SDK library safe. Ethers. If we are using Ethers and then the safe. Service client. We need to define our provider, get the signer, and then initialize each of these packages by providing these parameters. After that, we can create a transaction object with the destination value.
02:46:23.270 - 02:46:58.530, Speaker C: Data operation. If it's a call. Or delegate call, et cetera. We can convert this object into a safe transaction object that will also be able to handle the signatures. And then we need to use the service, the method, proposed transaction to propose it and to send this transaction to the service then if we are running a client like this one using a different signer, we have the service to get a transaction. If we already know the safe transaction has, we can use. It to get the transaction completely.
02:46:58.530 - 02:47:56.774, Speaker C: Otherwise, we have a variety of methods we can use, like get pending transactions, for example. And then from there, we can get the transaction we want to execute. Finally, we can call the service confirm transaction. But before we need to sign it with the SafeCore SDK calling sign transaction hash. And once we call the service, this signature will be submitted. After that, we just need to execute the transaction. Once we have enough signatures so before that before executing there's optionally a method that is called is valid transaction that will check if this transaction will fail or not here if the transaction is executable then we can call the method safe execute transaction passing this object so that's how the basic flow works.
02:47:56.774 - 02:49:12.750, Speaker C: Now let's see what are the safe modules? This is the main flow and the safe modules are very flexible and allowed to increment or to expand the functionality of the safe because they offer us another flow for these transactions that is more flexible that don't depend on the signers. So we need to deploy a safe module in the same network where our safe is. And all the safe module needs to do is just call the method exec transaction from module in the safe so the current flow when you want to execute a transaction you are calling the method in the safe exec transaction. Inside of that method there contain all the logic that checks if the signers did sign the signature the transaction. But here this safe module you can start with an empty one. Just calling exec transaction from. Module passing the transaction and it will have root access to execute the transaction.
02:49:12.750 - 02:50:08.030, Speaker C: This is very flexible because safe modules are like a white paper you can feel but also the responsibility of doing it well it's on you. So all the logic not for checking designers but for designing how do you want to make a transaction valid or executable or not depends on you. So multi signature control is the basic functionality the Safe has. But Safe modules also give us the opportunity to increase it. For example, assigning roles. We could decide to assign admin rights or token voting or spending limits. For example, how this would look like admin rights if you know Zodiac, which is a Dao tooling standard.
02:50:08.030 - 02:51:26.792, Speaker C: Or they are building tools for DAOs. They have a module that is the role modifier and there you can define okay, for this you can define different roles and assign addresses to these roles. Meaning that some addresses will be able to execute or to call specific basically to execute transactions where the parameters of these transactions are checked. So somebody could execute a transaction where the destination is one specific address but other addresses won't be able to do that but they will be able to do other things depending on the roles. For token voting. For example, you can decide to check if the approvers of this transaction have some balance of a token or NFT and if some of them approve a transaction then allow them to execute it or spend in limit you. Could define that some account is able without anybody with any other confirmation, they will be able to spend a certain amount of a certain token in a certain period of time.
02:51:26.792 - 02:52:33.544, Speaker C: Like weekly. Daily, monthly. This is for roles. But also for recovery mechanisms. Modules would allow at some point of time when, depending on your logic, a safe is not used to trigger a transaction or replace the current owners with the people who is activating this mechanism or just transferring the funds somewhere else. And we could do that with social recovery by defining your friend's addresses and giving them access later in time or a secret questions like if you remember long ago when you were logging into a web page there was do you remember your password? And then it would ask you what was the name of your first teacher or whatever you could do something like that or custodial recovery or hybrid custody, et cetera. And also modifiers.
02:52:33.544 - 02:54:14.430, Speaker C: Modifiers are kind of modules that allow to be chained so each of them offers adds some constraints for example adding time locks to the transactions so you have a queue establishing cooldown periods or bonds where the people who confirms if a transaction can be executed or not have to deposit something, et cetera. How does the core SDK facilitate the interaction or the management of safe modules? There are a few methods that are available for example get modules where you can get a list of the modules you have enabled into your Safe, then is module enabled? Because I think I didn't say that in order to execute the transactions from the module, it is mandatory that the module is enabled in the safe. That means that at the beginning the signers need to create a transaction to enable that module. It's not that anybody can just deploy its own module and connect it to your safe. So that's the basic thing. So with the SDK you can enable a module, disable a module, check if a module is enabled or not, and get the list. So that's four modules and then we have the transaction guards safe transaction guards are also smart contracts that need to be deployed in the same network and they somehow are connected to the safe, but they are not a starting point in the transaction flow, but somehow they will take its place.
02:54:14.430 - 02:55:28.976, Speaker C: So here we see the transaction flow, the signers, the safe, the network and the safe. Transaction guards that are connected to the safe the same as before. Transaction guards need to be enabled or disabled by the signers and once a transaction guard is enabled, what they do is they have to implement an interface with two methods. Each of these methods will be run before and after the transaction does some state changes in the contract. So we will have a method to do a PreCheck and another method to do a post check and these methods will receive the transaction and will be able to parse it and act on it depending on the values of the parameters. If the checks that are there pass, the transaction will be successful, otherwise the transaction will fail and you won't be able to execute it. We saw the advantages or how the functionality can be expanded with the modules.
02:55:28.976 - 02:56:34.648, Speaker C: What transaction guards add is basically more protection. You can define an allow list or deny list, you could freeze an account, et cetera. How this would look like for example, for creating an allow or deny list, you can deploy or create your own transaction guard with these two methods. And in the storage of the smart contract you could have a data storage structure to keep a track of a list of addresses. And then in the first check, for example, you could check if the destination of the transaction that is going to be executed, it is inside the list or not, and act on that. To freeze an account. For example, you could have a variable in the storage of the smart contract that is a switch, a boolean, where you can say okay, this account is freezed or it's not.
02:56:34.648 - 02:58:23.070, Speaker C: Do you see any problem with that? It is very cool to be able to freeze an account, but if you turn the switch off then the next transaction there won't be any more transactions, right? Because there's no way to turn the switch on again. So it's very important that this kind of transaction guards parse a specific way of turning them on, just denying all the transaction except the one that where the data of that transaction or the encoding data allows to turn this switch on. So it's very cool but also you have to know what you are doing now how the Safe Core SDK helps with Safe transaction guards similar to what we had for Modules. We have the method getguard in this case Safes can only have one transaction guard and you can enable them or disable them. These methods return a transaction that is ready to be signed by the signers. Okay, so that was basically it, we had the Safe Core SDK, safe Modules, Safe transaction guards and now what you are all expecting, what are our bounties for this hackathon? So the Safe Ecosystem Foundation has available $10,000 up for grabs and this will be given to the best projects that are built on top of the Safe. It is an open bounty so everything that is built on top of it will apply.
02:58:23.070 - 02:59:30.130, Speaker C: But we have some suggestions or ideas you can use. For example having a subdao management tool right now DAOs like to have subdos with different funds and would be cool to have a tool that allows to do all the accounting thing for all of them. Just an idea, improving the security with transaction guards anything like the deny list or the Allow list. Everything you can think of. Also working with modules thinking for example on a family that shares an account and the different people have different kind of access to the funds, different rights. Also anything related with account abstractions that you can think of. Another thing for example to create a chat where designers of the Safe can interact or can chat with among themselves.
02:59:30.130 - 03:01:15.650, Speaker C: Also a tool that allows a Safe to publish official messages so anybody can read them and whatever you want. So last thing you can find us on Discord at chadnosis minusafe IO our forum and also on Twitter at safe. Now I will show a QR code if you want to get your phones ready with a Safe hackathon. Successful guide, success Guide there we have some learning materials, past workshops we did, also past hackathon projects and the winners so we can have some idea of what others built and also some general ideas like the ones you see with Safe modules, transaction guards and Safe apps. So now take your time to scan it or take a picture of it, otherwise we will be all the weekend in our booth so feel free to come share your idea with us and we will try to help. Okay and now some links that are also included in the guide for our GitHub the SafeCore SDK repo also the Safe Contracts repo or the Zodiac if you want to check some modules and guards and then some documentation so that's it thank you very much, and good luck with the hackathon. Thank you.
03:01:15.650 - 03:01:35.230, Speaker C: Also, if you have any question, just.
03:05:00.840 - 03:05:06.752, Speaker D: It'S working on the thing is, people will be able to hear you from their headphones.
03:05:06.816 - 03:05:07.430, Speaker G: Yeah.
03:05:08.280 - 03:05:10.180, Speaker B: And they have questions you'll have to.
03:05:10.330 - 03:05:11.030, Speaker G: Okay.
03:05:16.280 - 03:05:16.596, Speaker B: Sure.
03:05:16.618 - 03:05:46.700, Speaker G: If I'm running late. Yeah, sure, I'll do it. And then 27 eight, I think. All right. Hello?
03:05:46.770 - 03:05:47.004, Speaker C: Test?
03:05:47.042 - 03:06:01.436, Speaker G: Test. Can everybody hear me? Yes. All right. How's everybody doing? It's been a long day. It's going to be a long weekend. Well, I appreciate you taking the time to learn more about Hyperlane. My name is Nam.
03:06:01.436 - 03:06:59.200, Speaker G: I'm one of the co founders here at Hyperlane, and we are doing what we're calling building the interchain highway. So first you might ask yourself, like, what the fuck is the interchange highway? And what we think of the interchange highway is basically kind of the situation that we find ourselves today, where we have all of these really amazing blockchains, right? Like, blockchains are really all about kind of valuable state that can be accessed by anybody and modified by anybody, right? Like the analogy, usually it's like inner computers, but now we have so many of them that there's a lot of valuable state, but they're all isolated. And so those kind of computers might as well be different galaxies. And the problem that arises is that the state is fragmented. And so when you build an application today, you have to pick one chain, which also means that you won't be able to access all the state on all the other chains. And so developers can only really serve users on that chain. They can't compose with protocols who are not on that chain.
03:06:59.200 - 03:07:53.296, Speaker G: And oftentimes people, what they do is they end up just like uniswap or sushi, right? They just end up deploying contracts on multiple chains. But for all intents and purposes, those deployments of the contracts are completely independent, right? Basically, effectively different applications. And so we know that that's just not going to be tenable, right? There's no world in where, let's say, the Internet is not composable across many different websites. And so the question is, what is the end state? And so people have thought about this problem for a while, right? We're not the first ones. There are what we call different eras of interoperability. So in 2016, we started with the Cosmos and polka dots of the world, right? That's where they got started. And so basically, they were able to derive interoperability protocols that are able to natively verify other chains that are built within the same context.
03:07:53.296 - 03:08:56.650, Speaker G: So that's where kind of the Cosmos app chains kind of arise, right? Like, IBC is able to natively verify the consensus of other chains via IBC. However, 2020 comes around, and there's all of these alternate L ones popping up. And there was no interoperability protocol that existed between all of these other L ones, but at the same time, there were all these users who had this kind of goal of like hey, there's salana popping up, avalanche popping up. So how do I get to use these applications? Right? And so there's what we call these kind of like makeshift user facing bridges that came up and are now what we consider bridges for the most part, right? It's like end users going to a bridge, depositing your tokens into the bridge and then getting either a representation on the other side for them then to use. And so yeah, most kind of bridge volume is basically through those bridges. But we also have seen, I think the kind of downside of those bridges because they're oftentimes built in an ad hoc way. There's been a lot of bridge hacks because there's no kind of native verification that can really happen.
03:08:56.650 - 03:09:52.068, Speaker G: And oftentimes new chains just come up with like an ad hoc bridge to build because they needed some value to come from Ethereum to their chain. And so we believe that 2022 is the start of what we call app centric interoperability. And so instead of an application making the user figure out a way to come to the application's chain, we think that applications will incorporate kind of that problem of interoperability into the application itself and so that users are able to use the application from whatever chain they happen to be in. So we call those interchain applications. And so to be able to build these interchain applications, what you need is what we call interchange highway, right? Like this kind of division of the interchange singularity is like applications that just live on every chain. Users can use them wherever they happen to be. And so important piece for you to realize here is that hyperlain is not in of itself another blockchain.
03:09:52.068 - 03:10:39.188, Speaker G: And it doesn't rely on another blockchain to kind of like be solving all of our blockchain problems. And instead hyperlain is a network in between blockchains that facilitates state transfers between the blockchains that we have today, but especially the blockchains that will come up in the future. And so our effort basically relies on us creating this safe, fast and accessible kind of highway between blockchains. And so how does it work at the kind of service? It's pretty simple. So we basically have what we call mailbox contracts on every chain. And so you as a sender, whether you have smart contract or like an EOA, you basically call the dispatch function on the mailbox. When you call the dispatch function on the mailbox, what ends up happening is that message gets enqued in the on chain merkel tree in the mailbox.
03:10:39.188 - 03:11:24.548, Speaker G: And so then validators can observe that merkel tree on that origin chain mailbox create a signature and then on the destination chain the mailbox contract can verify those signatures alongside with a merkel proof for that message. Can then process the message by calling handle on the recipient of that message. And so the API is pretty simple. We think it's like this. So, on the mailbox, on the origin chain side, you call dispatch with the destination chain, which is, like, just an ID for the chain, the recipient. So the address on the destination chain, and then the message, which is just, like, arbitrary bytes that you can specify. And then on a destination chain, the recipient will be called with three parameters the origin chain.
03:11:24.548 - 03:11:57.068, Speaker G: So where did the message come from? The sender. Who sent the message? And then again, the message bytes that were sent. And we have a Message Explorer that can kind of show you the progress of the message as it crosses the chain. And if I'm bold enough, I'll try the live demo right now. I think the Internet has been pretty rough, but let's see if that works. So, basically, what I will be doing is I'll just go through the quickstart tutorial and basically using MetaMask. And so first, what we do is we have to find the mailbox contract on our origin chain.
03:11:57.068 - 03:12:21.770, Speaker G: So there's a list of them right here. Can open them up. Oops. Of course. I don't think that will work. I guess see, that's what happens when you try to do a live demo. We might have to come back to this.
03:12:21.770 - 03:12:50.136, Speaker G: Let me try my phone. Nope. All right. Give it 30 more seconds, and if not, I'll just have to skip the demo today. Up. Cool. All right.
03:12:50.136 - 03:13:15.984, Speaker G: Yeah. So, basically, on our docs here, you could find kind of, like, all the mailbox contracts on all the different chains. So let's say right now, let's try to send from Fuji to Mumbai. And so, basically, what you can see here is we call the dispatch function. The first argument is, as I said, the domain IDs. And so you can find them on the docs as well. So the domain ID of Mumbai in this case is 80,001 the recipient address.
03:13:15.984 - 03:14:07.570, Speaker G: So in this case, it is bytes 32 instead of address, because not every chain has just 20 bytes for addresses, right? Like, eventually, like, Cosmos and Salana and others actually have 32 bytes for an address. And so if you send it to an EVM chain, you'll have to zero padded to 32 bytes. We have kind of pre deployed test recipient contracts on every chain, but you could also, obviously, just enter your own recipient in here right now, and as a message body, you can again send arbitrary bytes. And so we can just say, do hello from Eve, India. Right? And then that's just ETF encoding into a particular string. So we'll do this, and then we can send the transaction. And hopefully, if everything goes well, we just call MetaMask right here.
03:14:07.570 - 03:14:55.612, Speaker G: We get the transaction. There you go. So, in a moment, it will be mined right here. And as I mentioned, you can use the Hyperlink Explorer to kind of track the status of your message. And so, hopefully, if you can see here that we are sending from Fuji to Mumbai, right? So you can kind of open it here so you can see the phases here that we send. A message transaction has to be finalized before validators can attest to the validity of the message in the merkel tree. And then once the validators basically sign the merkel route, the relayer, which is permissionless, can process the transaction on the destination chain.
03:14:55.612 - 03:15:36.216, Speaker G: And so I think we'll have to wait a couple of seconds. And in the meantime, I'll show you the test recipient contract. So this is the contract that we specified here on the sending side, right? And so all the contract does, let me show you what it does. Recipient here is on the handle function, right? Like it receives the origin, the sender and the call data. And so it will emit a message event here and it will set these two state variables. Okay, cool. So it processed, we can look at the destination processing here on a destination chain.
03:15:36.216 - 03:16:32.768, Speaker G: And then if we look at the logs, we can see the received message that was emitted by the test recipient, right? And so as you saw like a very simple sending a message across the chains. And it's as simple as calling a function call on a smart contract. So one thing we have noticed is that to be able to do this, you need to have a smart contract on the origin chain and a smart contract on a destination chain. And we were constantly thinking like, how can we make the developer experience better? Because basically the message API has no concept of what the data is that you're sending and how it's structured. However oftentimes what you want to do is you want to be able to make a function call on the destination chain, right? So let's say you have a Dao. Let's say you have a Dao on Ethereum where it lives. It wants to own assets on other, like you could totally use the message API to basically deploy a smart contract on both sides and basically relay authenticated calls across.
03:16:32.768 - 03:17:15.836, Speaker G: But we can just do this for you. And so interchange accounts are basically a middleware abstraction that allows senders on an origin chain to have a proxy account on the destination chain. And that proxy account will only ever accept basically function calls that were sent from the origin sender. And so that basically allows for what we call a much kind of nicer experience because you basically abi and call the function call. You give that to hyperlane? Hyperlane will basically forward the call to that proxy account, what we call the ICA, and then that proxy account will make the call to the recipient. And so kind of the outcome of this is that on the origin chain you make this function call, which is very similar. You just abi encode the call as you normally would.
03:17:15.836 - 03:18:18.564, Speaker G: If it's a single chain context. And on the destination chain you actually have to have no contract at all. Like you're just making a direct function call from the ICA and so we can highlight that as well. So again, on the page here on accounts, we have the quickstart tutorial. So all we have to do is we have to go to the ICA router, which is this address, and we basically here have this dish function, right? Again we have to specify the destination domain. So actually let's do it again to Mumbai, the target, which is again our test recipient. And then this is the abi encoded function call, right? So in our quick start, you will see here that we're just going to call FUBAR with these two arguments and I just kind of encoded these two arguments in here and that will ultimately generate this API encoded function call.
03:18:18.564 - 03:18:43.880, Speaker G: And so if we once again write this and do this on MetaMask, we'll have a transaction. And just to show you what the test recipient, this is the Fuba function call. That what got called. And so let's once again look at our messages.
03:18:47.820 - 03:18:48.920, Speaker E: Refresh.
03:18:53.520 - 03:20:06.400, Speaker G: Once again sending from Fuji to Mumbai. And then once this is processed in a hot second, actually I'll just show this later because you can imagine what's going to happen. Like the call will be made and then on here, as you saw, we just emit this emit receive call event and we write those two variables that I can show you whenever that's done. All right, next one. So that's if you want to basically write from an origin chain to a destination chain. But let's say, what if you want to actually do the reverse, right? So let's say you have a contract on polygon and you really want to access some state on Ethereum, right? For example, like the V three TWAP on E to USDC, which is probably the most secure TWAP, but you're on polygon, so what do you do? Once again, we've kind of thought about what it would be a better developer experience. And the best thing would be if you on polygon can just abi encode the view call, send it to hyperlane and hyperlane will basically do the view call on Ethereum for you and then call your contract on polygon with the results of that query.
03:20:06.400 - 03:20:42.988, Speaker G: And so that's what interchange queries is. So the way it works once again is that you basically pass to a query function your abi encoder function call. And then the callback, which is the function on your own contract that should be called hyperlane, will relay that message over to the hyperlain code on a destination chain. It will make that call as you specified onto the sender. And then the result will be put again into a message back to the origin chain and that result will be put into the callback function as you specified. And so again, the nice thing is that on the destination chain. There's no contract that you have to write just on the origin chain.
03:20:42.988 - 03:22:06.700, Speaker G: You specify destination chain the target you want to make the view call against the query like the view call itself API encoded and obviously the callback on the sender as well. And so once again let's do a demo which is right here. Actually wait, it's not right here. It is right here. So basically this time it's a little different because we have this test query sender contract on the origin chain which will do the query right because in this particular case the way you receive the result is a function call on yourself on the sender and so we've pre deployed those contracts right here. You can see the interface of it here if you want to look at the contract real quick test query sender, right? So basically when you call query address all it will do is we'll call the query router on the hyperlain contract with the destination main the Abi encoded call and then the callback which is handle query address result which is this function. So basically if you as the developer just have to kind of like make this call then you can expect that the hyperlain contract will call handle a query address result with the actual result that happened on the destination chain.
03:22:06.700 - 03:22:52.920, Speaker G: And so let's actually do that. So in this case, let's say we are sending the girly which is the domain five right here. In this quick start example what we're doing is we are just reading the owner state variable of a particular contract. So in this case this is just a contract that we have and the owner of that is like one of our keys. But then basically the view call that we're making right, is like this owner and so that's Abi encoded. It's just this particular byte string. And so basically, if we do those three things, pass that to query address can once again make the query.
03:22:52.920 - 03:24:24.100, Speaker G: And this is maybe interesting because once the transaction is finalized, we can also see that our previous ICA account call was delivered. Let's see. Okay so we're sending from Fuji to Girly, right? And this is the query the first leg, right where we're basically saying like hey, what is the owner address of this particular account? And so let's wait until the transaction gets processed on the destination chain. And so to be clear what we're doing is right now is this part right? Like we're sending this message right? So let's just see once that goes through. I think Gurley and Mumbai have been pretty congested or not congested but it's just like not as easy to include transactions lately anymore. But so once that goes through there you go right? I guess it took only like what, 20, 30 seconds. So basically we're going to see is just open it in a Block Explorer, right? Like basically we returned this query so this is the address that we were reading.
03:24:24.100 - 03:25:08.340, Speaker G: This is the result of the address. And so this transaction hash actually ends up sending a message back to Fuji. And so if we add this transaction hash to our search, you can see it's actually two messages, right? Like one is the one from Fuji to Girly. And then here is the one from Girly back to Fuji. And so that already processed. And so here on the Block Explorer, we are able to see that the query was resolved with this data. And that is the last address result here, right? Like you can see that this is the address that we got returned.
03:25:08.340 - 03:25:50.688, Speaker G: Cool. All right. So last but not least, sometimes what you want to do is you don't want to just send messages, but you actually want to send value, right? So the message API, all it does, it sends arbitrary bytes. But how do we decide what value is is obviously like a much bigger topic. If you're interested, come back to our booth to talk and talk more about it. But one thing that's a key part here is that whether you're actually sending canonical tokens versus wrapped tokens, right? So right now when you say let's use wormhole to send USDC from ETH to solana, actually what you end up doing is you're depositing USDC on ethereum and then portal mints like a wrapped USDC version on solana. And there's obviously all kinds of good and bad things about that.
03:25:50.688 - 03:26:31.680, Speaker G: We believe that there's going to be many different ways of transferring value. And so we have what we call the liquid layer API, which allows you to use through a single interface, different value bridges, right? And so, for example, you will be able to use portal but also like circle's native USDC bridge, which burns USDC on, let's say, ethereum and then mints it on avalanche. And so you never have this kind of like wrapped token issue. And so the API looks very simpler. It's similar to the message API where you send your specified destination chain, a recipient, a message. And then the three additional arguments are the token that you're trying to bridge an amount, and then the string of the bridge itself. So in this case would be either Circle or portal.
03:26:31.680 - 03:27:44.356, Speaker G: I'm going to skip the API demo here, but if you're curious, it is obviously on our docs page right here. And last but not least, the thing that I want to kind of highlight as well is that when I had this diagram here, it was very simplified, right, because basically it said like, oh, the mailbox will verify signatures. But one of the key points I think everyone should take away from this talk is that bridge security is very hard, right? Like every second bridge basically has been hacked. And part of the reason why is that there's no such thing as one security model fits all. A hacker here at. India has very different security requirements than, let's say, uniswap when it wants to do governance decisions across chains. And so we have what we call sovereign consensus, which allows the recipient to specify the security model under which the recipient accepts messages, right? And so, for example, in the simple case here, if India, you could say, oh, any validator signing a message is okay for me to accept a message, but if I'm uniswap, I might actually want higher security to accept messages.
03:27:44.356 - 03:28:29.910, Speaker G: And so basically, you can create these things. What we call isms interchange security modules, which the recipient points to. And then basically the hyperlain API will first call the Ism with like an Is valid function call. And only if that is true, it will actually call handle on the recipient. And so that allows applications to kind of specify their own security. And so in default case right now of hyperlane, you have this validator set that you use, but you could imagine isms that have optimistic modules, or you could imagine isms that for specific chain pairs actually use ZK bridge or something. And so we think that as a developer, you are able to kind of opt in into the same API, but will have different security going forward.
03:28:29.910 - 03:29:10.130, Speaker G: All right, I think that's it. I know we are all running behind, so if you have any questions, we have a booth over there. We'll be here all weekend. We also have Bounties ten K and we're generally just looking for very creative uses of hyperlane. As we mentioned in the beginning of the talk, we believe that the future are interchange applications, applications that live on every chain. It just doesn't make sense to me to have an application that only lives on one chain and then all the other users, you're just like shit out of luck. You have to figure out a way to come to us, right? Like in no world are applications successful if they just force users to jump through hoops to use your application.
03:29:10.130 - 03:29:20.730, Speaker G: So, yeah, if you have any more questions, please come by our booth. And yeah, hope you have a good weekend. Bye. It.
03:44:07.080 - 03:44:08.436, Speaker B: Was there. Click there.
03:44:08.618 - 03:45:28.588, Speaker H: I mean, I saw him. It is this working? Finally. Can you folks hear me? Awesome. You folks were so patient. I'm super grateful for patient audience always, because you never know what goes wrong with demos. And the demo gods are not happy with me ever. So I think that's what happened today.
03:45:28.588 - 03:46:08.024, Speaker H: But we're going to make do with what we have. Super excited to be presenting here in my home country. eGlobal hackathons have always been super close to my heart because I started in the beginning of this year in a new space with my passion for GraphQL. And I think that's what I'm bringing to the table for you folks today. So we're going to be learning how to build decentralized GraphQL APIs using the graph. So a quick show of hands before I give my introduction or go into the specifics of it. How many people here know GraphQL or have heard about GraphQL? That's a good number.
03:46:08.024 - 03:46:36.160, Speaker H: I'm impressed. How many people know about the graph? Awesome. We could work with. Awesome. Awesome. So today we're going to be learning how to build a Zora NFT Smart contract, an API for the Zora NFT Smart contract using the graph. But before we jump into that hi I am Vish, short for Vishwametha and I am a Developer Relations Engineer at the Graph Foundation.
03:46:36.160 - 03:47:22.690, Speaker H: And this is what I do. I am super passionate about developer education. And right from the start, right from my university days, I've always been really excited about talks and giving workshops, making sure that any content format that I can contribute to is helpful for developers so that I can help them become successful with the tools and the frameworks that they're using. So that brings me here again. If you have any questions by the end of this workshop, presentation, talk, whatever, feel free to reach out to me on Twitter at Vishwametha 30. And with that, we jump right into it. No, doesn't want to move.
03:47:22.690 - 03:48:03.420, Speaker H: Okay, so let's talk about what the graph is. Let's start with right from the beginning. So the graph is a protocol, an indexing and querying protocol for Web three, for networks like Ethereum, IPFS and so much more. But that's a lot of jargon web Three decentralization GraphQL, the graph indexing querying. So I get a lot of questions around where it fits into the stack. So let's look at the stack. You folks are here at a hackathon, right? So you will be building projects, you will be building DApps.
03:48:03.420 - 03:49:21.620, Speaker H: So let's kind of like picturize where the graph fits into your DAP stack, right? Your web development stack. So I really love this diagram because it shows the UI layer, the subgraph indexing layer, and there's the contracts, which is your data layer. So the graph as an indexing layer sits right between your front end, which is your UI, and your back end, which is basically all of the data that is coming from smart contracts on the blockchain, right? And with that, subgraphs are becoming a de facto standard of how you query data that is being indexed by the graph protocol from the blockchain. And that's why we say that the graph is now a default part of the Web Three stack. Awesome. Moving forward, let's talk about the data scenario here. I often get the question like, where does the graph come into picture? We saw where it fits into the stack, but we haven't yet talked about why exactly the graph, right? Why should you be using the graph, how it is going to be helping you in your journey? So I think I need to begin from the data bottleneck that we have in this data driven world of ours.
03:49:21.620 - 03:50:03.824, Speaker H: Nothing is possible without accessible data, right? And especially with blockchain data, if you're building decentralized applications, you want to make sure that your UI has a very robust experience for your users. You're bringing very fast and performant and efficient UI UX to your clients. And for that, we need index data. So that is point number one. Point number two is that blockchain has can anyone guess how many blocks so far Ethereum has the block count? Any guesses? Wild guesses. That's an accurate one. It keeps changing.
03:50:03.824 - 03:50:37.360, Speaker H: And yeah, I think the number that I saw right now is like 16 million. So it's in the same ballpark, but it just keeps on increasing. And every block has thousands of transactions. Again, it just keeps on increasing by the hour, by the day. So what I'm trying to say is, if you want to build a DAP using blockchain data, which is increasing, like day by day, it becomes increasingly difficult to index that kind of heterogeneous data which is out there on the blockchain. It is DeFi data. It is NFT data.
03:50:37.360 - 03:51:30.364, Speaker H: Dows governance. Whatnot? So what if you want like a very specific piece of data, right? Do you start indexing the entire blockchain? Do you start indexing all of Ethereum? No. So that's why we need organized data which is well suited for your Web Three applications, your decentralized applications. And as a solution, developers have been building proprietary indexing servers so far. Now, let's jump into why we don't want to do that is because it is error prone. It is a lot of complex code that you will need to write but three main points. The first one is that if you're building a proprietary indexing server, it is a centralized point of failure, which defies the ethos of web three, which is decentralization.
03:51:30.364 - 03:52:12.616, Speaker H: It just goes against why all of us are here hacking and learning at this hackathon, right? So that's point number one. The second is that it's a single point of failure. So if the indexing server goes down, everything goes down. You don't want to do that. And the third, but again, most important point, is that it's a lot of infrastructure to manage. It is a lot of investment of hardware and engineering and monetary resources in running that one indexing server all by yourself, whether you're a team or an individual engineer. Now, that is where the graph enters the scenario.
03:52:12.616 - 03:53:00.088, Speaker H: And that's why we say that the graph is in. It gives you a global open API. But it's not just an API. It's a decentralized, transparent and open network of participants like subgraph developers, indexers curators, and delegators. And it is making sure that you can index your blockchain data efficiently, but also can do it in a more decentralized manner. And of course, it's built on top of GraphQL, so it brings the benefits of GraphQL to your table. If you want to learn more about GraphQL, I think it's a pretty nifty thing for front end developers and it has been a game changer in the data accessibility landscape.
03:53:00.088 - 03:54:07.048, Speaker H: So basically, using GraphQL, the Graph has built a unified data access layer for blockchain. So no matter which data is coming from which smart contract, it is woven into your subgraph, which is basically like a single endpoint that you just query every time you want your data from the blockchain to your application. And the Graph has been powering DeFi applications, not just DeFi applications, but this has been like one vigorous use case and also a really exciting one. So it has been querying on chain data like trades and exchange volumes, total borrowed, supplied, stake yield, farming, total value locked and so much more. So all of these cute little icons that you see, these are like projects that have been powered by the Graph, DeFi projects. And if you talk about some of the other leading projects in, let's say, websites is CoinMarketCap. CoinGecko, if you've heard about it, then there's like NFTs and DAOs.
03:54:07.048 - 03:54:50.000, Speaker H: So Juicebox, Dao, there's foundation in the world of DeFi, I'm sure you've heard about it, it's uniswap. And then there's synthetix. All of them are powered by subgraph data through the Graph. And we have a hosted service that we started with about four years ago. So for four years it has been supporting subgraphs and subgraph developers. But it was a way to start with our initial idea so that we can make sure that we achieve product market fit. We have tested it out before we go live with the decentralized network and we have had the time to get good feedback from our developers.
03:54:50.000 - 03:55:50.180, Speaker H: So we started with the hosted service, which was run by one of our core dev teams, our original core dev team, Edge and Node. But from that now we're moving away by sunsetting the hosted service, because we want to make sure that we can find a solution which is more scalable and more sustainable and also fits into the Web Three mission, which is a decentralized network of the Graph. And so we've successfully migrated 350 plus DApps and they've been paying queries for GRT in GRT on the network. So 39 plus. I think the count is a little bit higher now. All of these chains, amazing chains that you see and you've probably worked with, built on, are supported by our hosted service. And with that, I think we've discussed the Graph a lot.
03:55:50.180 - 03:56:53.832, Speaker H: We've talked about what subgraphs are and we've talked about why it makes sense for you as a developer who is building DApps to absolutely use the Graph in your stack. So let's see some code. Now, I typically do like a live demo of this, like a live coding session, so that I can take you through the entire process of how to use the subgraph studio, how to get started by initializing your subgraph. Scaffolding it, designing it as per your use case, as per the data that you want, and then finally deploying it. But just to make sure that we're right on time and also to make sure that nothing breaks because of the WiFi. I'm just going to run you through the code here if you see the subgraph. So this hasn't loaded yet, but basically if you want to get started, you just need to go ahead and go to the subgraphstudio on the graph.com
03:56:53.832 - 03:57:38.344, Speaker H: website and create a subgraph. So I'm just going to show you like a nice little screenshot of it. So this is something that you will be seeing. The prerequisite here would be that you will need node JS installed on your machine to make sure that you can install the graph CLI and then that you also have a MetaMask wallet using which you can sign into the subgraph studio. And you go ahead and first create a subgraph slug. Basically just create a subgraph on your dashboard. The next thing you see will be this kind of like a dashboard for your subgraph with some documentation, really helpful documentation on the side.
03:57:38.344 - 03:58:27.588, Speaker H: And now I'm going to run you through the kind of commands that we need. The first one is the NPM install command for the graph protocol CLI. So this is just a one time thing. Once you've installed the graph CLI, it's going to give you some really cool utility commands that you can use to scaffold and design and deploy your subgraph. For that you can either use node JS or NPM or you can use Yarn. When you're done with that, we want to initialize our subgraph. So the graph init command is one of those commands given by the graph CLI that you see here and it basically scaffolds your subgraph.
03:58:27.588 - 03:59:04.154, Speaker H: It gives you some boilerplate code to get started with. And let's go ahead and see what kind of boilerplate code it has given us. And this is frozen. Think I'm just going to give it a second, I guess. Yes, we got it. Awesome. So once you've initialized the graph your subgraph, this is what you're going to be seeing basically.
03:59:04.154 - 04:00:07.038, Speaker H: And I think it's a pretty cool folder structure right here because it's super clean. You see it and you know that there are three main files that we want to be looking at. The first one is the subgraph YAML file, which is your typical configuration file that describes your subgraph, like which kind of network you're working with, the name of the token that you're working with, and your data source that you want to pull in as a smart contract from the blockchain. So that is basically this right here that you want to enter. And this is basically the smart contract address of the Zora NFT smart contract that you can get from the Zora documentation and just want to call out. One really useful information is that you would also want to define a start block is because you don't want to start indexing from the Genesis block. If you know which block you want to start indexing from, just go ahead and pop in the Start block ID.
04:00:07.038 - 04:00:42.278, Speaker H: Here the address. And then there are a couple of entities here. So entities, I will go more deeper into this when I talk about the Schema GraphQL file. But just as a quick overview, entities are basically all of the fields of data that you want your subgraph to query from the Smart contract. So for example, there is the Zora NFT Smart contract, right? So here we're defining two types of entities, which is like token. The first one is Token, which is all of the NFT data. And the second one is user, which is the user metadata.
04:00:42.278 - 04:01:34.870, Speaker H: And I think it's going to start making more sense once you see the Schema GraphQL file. But before we move on to that, one last thing here in the subgraph YAML file that you would want to define is the event handlers. So every smart contract will have events that it emits every time you start indexing it. And you want your subgraph to listen to those events to make sure that there is some kind of business logic that is implemented when you listen to those events. And then when the business logic is implemented, your local code and the events is being mapped and you can query all of that data from the events to your client. So here we will be dealing with two kinds of events. Basic events from the Zora NFT Smart contract which is token Uri updated.
04:01:34.870 - 04:02:16.920, Speaker H: So every time the Uri of your NFT is updated, this event will be emitted. And we want our subgraph to listen using mappings to make sure that we can query that data. And the second one is the transferred event. So there are two scenarios here. Either a new NFT would be minted and in that case this event will be emitted, but it could also be an existing NFT whose ownership is being transferred from one owner to a new one. And with that we can move on to the Schema GraphQL file. I know we're moving fast here, but you can always come back to me with questions.
04:02:16.920 - 04:03:13.382, Speaker H: I'm just trying to make sure that I can give you a good overview of the folder structure of the subgraph. But everything else that you see right now is super specific to what kind of subgraph you are defining. Is it like an NFT API? Is it for your DeFi use case? Is it for governance, et cetera? So the Schema GraphQL file you see right now is basically a GraphQL file. If you work with GraphQL at all, you can understand what this does is that you're telling your subgraph what kind of data it wants to query, it needs to query from the blockchain. So I want all of the NFT data and the corresponding user metadata. So that's why I'm defining using at entity directive, I'm defining two types which is token and user. So for all of the token data and the user metadata, I'm defining these two types.
04:03:13.382 - 04:04:43.426, Speaker H: And the at entity directive is a basic GraphQL directive that lets you define types with top level fields for all of the data that you want your GraphQL API to query and give a response of. So it comes with all of the other fields, like if the token has an ID a created at timestamp metadata and Content Uri, et cetera. And then the corresponding creators and users of the NFT are then being stored as using the user object type here. So there can be a simple type in GraphQL and there can be an object type which is basically the user type that we've defined here, which can then further have its own sublevel fields that you can query. So for the user metadata we want to be querying all of the tokens that are being owned by an owner and all of the tokens that are being created by a creator, all of the tokens that are being minted, right? So those are the two relations that we're defining as part of the user entity, the user type that you want to query using your subgraph. And we're doing that again with another really cool, really nifty directive, the GraphQL directive which is add derived from directive. Now basically, instead of this directive you can use alternatively you can create an array of all of these creators and owners.
04:04:43.426 - 04:05:54.298, Speaker H: But this is something that's a bit more performant, that's why we're using it here. And once you've done that, you want to move to the Mapping TS file. So basically what the Mapping TS file is? It's a file where you define all of the business logic that you want to run once your subgraph has started using like querying all of the index data and the smart contract is emitting the data. So you want to map the events that are being emitted by the smart contract to some kind of locally defined functions or let's say like event handlers basically. So you want to handle those events that are being emitted. And the cool part of the graph CLI is that it comes with TypeScript support out of the box. So it gives you really cool TypeScript library that gives you some helper functions that you can import while writing your mapping TS file to make sure that you're writing your event handler as well and easily.
04:05:54.298 - 04:07:09.026, Speaker H: So to be able to do that, there's another command which is called the Graph code gen command. It's basically just you just enter graph code gen, you run it and it will give you like the out of the box TypeScript library that there is. It will generate all of the helper functions and that you can go ahead and import here in the Mapping TS file. And once you've done that so if you can see here in the generated folder, the functions that it has generated for us to import. There are basically two types of functions. The first one that you see, token is something so you can only read data from the smart contract from the blockchain, but you can both read and write data to the graph node, which is like a local storage. So the generated schema file is basically giving you all of the functions that you need to interact with your graph node, which is basically reading and writing data onto it because you also want to save data that you have gotten from the smart contract.
04:07:09.026 - 04:08:08.278, Speaker H: And then the token one is the generated file that gives you functions that will help you interact with your smart contract, like read data from the smart contract. And finally, we have defined here the two event handlers for the two events that we were dealing with here in our subgraph. It's basically handle transfer event and the Handle Token Uri updated event. So any events that you're dealing with, you would want to write an event handler so that you can perform some kind of business logic in your subgraph once you start listening to those events. This is basically like assembly script. So anyone who's used JavaScript or TypeScript, this should be very familiar kind of syntax for you. And just to stay within timing, I wouldn't go deeper into what this exact code does, but basically I've already defined what each of those events meant.
04:08:08.278 - 04:09:18.990, Speaker H: And so we're making sure that every time the event happens and there's an updated piece of information, we're saving it to the graph node, we're retrieving it from the smart contract and we're saving it to the graph node so that we can query it via our subgraph later. And once we've done that, I think we're super close to the end of it, which is that you have initialized your graph, your subgraph, you have defined it based on the smart contract that you want to be using and the kind of data that the kind of events that you want to deal with. And the final piece here would be to deploy, let's see if it's not happening. So the final piece here would be to deploy your subgraph. So we have another command here that lastly you would want to run is the graph deploy command. And if you go to the graph documentation, you should be able to see the graph deploy command. So you authenticate your subgraph finally and then using your API access key, and then you deploy the subgraph.
04:09:18.990 - 04:09:49.178, Speaker H: Let's see if we can move this tab. Getting a little stuck here and there, but while that happens, so sorry about that. While that happens, I think we've concluded our code walkthrough of how to initialize a subgraph, how to define it and deploy it. And once it has been deployed in your subgraph dashboard, you should be able to see that the subgraph is now it just went off.
04:09:49.344 - 04:09:50.060, Speaker A: Cool.
04:09:52.180 - 04:10:42.352, Speaker H: You will be able to see that the subgraph has now been deployed and there is like a really cool graphical playground that you can see where you can run some sample queries and you can test out whether your subgraph is working or not. And I think I lost my presentation. Never mind. Once you've deployed your subgraph, you should be able to test out the sample queries in your GraphQL playground. So come by the booth. I might be able to show you the actual live demo. So if this is interesting to you, test out subgraphs.
04:10:42.352 - 04:11:47.892, Speaker H: We are giving away cheat sheets at our booth, and I think Simone has already done that here as well. So the cheat sheet is basically a good 101 of how to use subgraphs, what kind of commands you need to learn to basically initialize, create and deploy a subgraph. And so if you're hacking at this hackathon, if you're building a DAP, the main takeaway here from this talk workshop is that subgraphs are a really cool way to efficiently access data from the blockchain. And it's a really cool, decentralized GraphQL API that you could be building for your DAP as long as you're dealing with on chain data. So basically, there's no programming language barrier, it's language agnostic. So whether you're using Python on your front end, you're using JavaScript, any kind of, like, react framework, view framework, subgraphs are still relevant. The graph is still relevant and it is also network agnostic.
04:11:47.892 - 04:12:08.910, Speaker H: So if you're using the hosted service, as I said, we're live on 39 plus chains, so it also doesn't depend on what kind of network you're using. And with that, I will conclude my talk and thank you so much for being such a patience audience. Thank you.
04:14:41.560 - 04:14:42.276, Speaker F: It does work.
04:14:42.298 - 04:14:42.676, Speaker C: There we go.
04:14:42.698 - 04:14:43.300, Speaker F: We got it.
04:14:43.370 - 04:14:43.990, Speaker D: Okay.
04:14:45.000 - 04:15:13.438, Speaker F: Wow, this is very weird. I didn't realize how strange it is talking into a microphone and not being able to hear yourself. So I'm going to go pretty quick because it looks like we're way behind schedule. I'm Jack. I work at a company called wait. I think this only works if I stand right in front of it, so we'll give it a go. Okay.
04:15:13.438 - 04:15:41.346, Speaker F: I'm Jack, I work at a company called O of One Labs, and we incubated the MENA Protocol, which is a layer one blockchain that we're going to be talking about today. I'm based in Denver, Colorado. That's my Twitter, and I'm a developer relations engineer. Okay, I'm just not going to use this. I think it doesn't work. Okay, so what are we going to go through? We're going to talk about Snarky JS, which is the smart contract language that we use for Mina. We're going to do a simple example of a smart contract that checks.
04:15:41.346 - 04:16:10.430, Speaker F: If the number you submit is passing as an argument is the next value in a Fibonacci sequence, then we're going to make this recursive and then finally we're going to talk about the Mina Protocol and we'll talk about where you can learn more and we'll do questions and answers. After you can come grab me. I'll stand next to the door for a little bit. Okay? So snarky JS It's a TypeScript library for defining zero knowledge proofs. And it's also the smart contract language for the Mina Protocol. This is what it looks like.
04:16:10.500 - 04:16:10.906, Speaker B: Hopefully.
04:16:10.938 - 04:16:16.174, Speaker F: It looks like something that you can figure out because it is something that you can figure out. Everything is in TypeScript.
04:16:16.222 - 04:16:17.198, Speaker C: So you can keep using the tools.
04:16:17.214 - 04:16:36.514, Speaker F: You'Re familiar with like NPM prettier ESLint vs. Code. And it's very easy to learn. You can see here the IntelliSense support is super good. So you can just dive into a code base and if you're curious about what something does, hover over it and you'll get a pretty good explanation. It's also extremely powerful. This is for two reasons.
04:16:36.514 - 04:16:56.800, Speaker F: One is Kimchi, which is our proof system. And we have fully trust the setup. We have custom constraints for hash functions, elliptic curves and encryption. This just means that these operations are very efficient. The proof size is constant. Thus the o of one, it's recursive, meaning that we can verify proofs inside of other proofs and it's plonked. So we can add new features like dynamic array access and a couple of other things.
04:16:56.800 - 04:16:59.326, Speaker F: Really the point of this is just.
04:16:59.348 - 04:17:00.686, Speaker G: That we've put all the horsepower that.
04:17:00.708 - 04:17:22.214, Speaker F: We can under the hood here. So that's one side. And then the other side is what does it actually look like to use this? What does the snarky JS library look like? And there's a few things that make it really powerful. One of the first is we have method chaining. This makes it very easy for developers to think through their programs in a pretty linear way. So you can kind of see here we have an example. We've got this value guess.
04:17:22.214 - 04:17:50.286, Speaker F: We can call the equals method on it, pass in zero and then we can call the not method. And so we're going to take something in this case, I think, an array of fields we're going to get a boolean out in. This is not red peg. This probably seems pretty familiar and that's the point. We've done our best to make programming in Snarky. JS feel a lot like programming in ecosystems you're familiar with already. Also we have structs, which are exactly what they sound like.
04:17:50.286 - 04:18:24.998, Speaker F: They provide a layer of abstraction that makes data quite a bit easier to think about. We can see an example here we have this struct. It has an array with public key and string and it's called My Tuple. And then we can down here pass this in as an argument this type. And so a fundamental requirement of all zero knowledge proof systems is that the values are ultimately represented as something called a finite field element. And these are for the. Most part like unsigned integers, but there's a couple interesting features or things that work differently.
04:18:24.998 - 04:18:59.250, Speaker F: And so Structs, eventually, fundamentally, they're all composed out of these field elements. But with this abstraction, we can define things like this that are much easier to work with. And so the Struct will figure out how to take this information that we know how to work with in a format that makes sense and turn it into this underlying field representation. So finally, plenty of the stuff that you need is already implemented in Starky JS. So we have all sorts of different types. These are these Structs for groups, public keys, private keys, signatures, scalars, et cetera. Efficient hash functions, efficient encryption and decryption efficient signatures.
04:18:59.250 - 04:19:20.302, Speaker F: We have merkel trees and an API for recursion and more coming all the time. So a lot of stuff that you need is just included in the Snarky JS library to begin with. Okay, why did we choose TypeScript? Because we're ecosystem focused. So the idea is that probably some people want to build crazy cryptographic primitives that let you do things that seem impossible, and that's awesome.
04:19:20.356 - 04:19:21.662, Speaker G: You should totally build those.
04:19:21.796 - 04:20:03.958, Speaker F: And then there's other people who might want to ship user facing products that make use of these powerful primitives. And the idea is that you'll just be able to import a library with whatever crazy thing like card shuffling or something that's hard to do. And we want to have code reuse that's as high as it is in the JavaScript ecosystem. I think that that will kind of allow a whole new type of application to kind of come forward, which is applications that have the best product people and the best sort of like cryptographers working together to sort of open doors. This is just a rehash. We'll go through it because we're going real quick. So how does Snarky JS work? Here it is in five sentences.
04:20:03.958 - 04:20:49.290, Speaker F: It's a TypeScript library. All the information is represented in one of these Snarky Jest compatible types. So these are all composed of the field type and can be constructed using this Struct abstraction. It provides classes and functions that are compatible with this field type or the Structs that are composed of them. So we have, like, for example, if we have a field of value one, then we have an add method on this field type that we can use to add another field to it. Okay, so Snarky JS can represent any of the operations that we do this way as this Kimchi Arithmetization, which is basically a math problem that represents the program that we write in Snarky JS. Then when a user interacts with the Snarky JS program, we can use this math problem version of the program to generate a zero knowledge proof that their interaction was legal.
04:20:49.290 - 04:21:23.558, Speaker F: How do the Smart contracts work? Developers write the Smart contracts in TypeScript, and they deploy the verification key to the Zkap account. So a Zkap account is just like a contract account on Ethereum. I mean, it works a little bit differently, but it's the same idea. So a user generates this verification key for their program and they deploy the verification key to Mina. And then we have a new smart contract on the MENA network. Users run the smart contract in their browser and then they generate a zero knowledge proof that their interaction was valid when it comes time for people to actually interact with the app once it's deployed. So we can kind of see what this looks like.
04:21:23.558 - 04:21:45.418, Speaker F: We have my cool ZK app. A user does some stuff with it in the browser. They make a transaction and the transaction has a zero knowledge proof and they send it to MENA. And if it's valid, then everything associated with that transaction gets committed. And if it's invalid, then it's dropped. So if the MENA blockchain can validate this zero knowledge proof, then it commits any of the relevant state updates. This is kind of what this ends up looking like.
04:21:45.418 - 04:22:12.840, Speaker F: We have a smart contract method. It takes in some arguments, some state from the smart contract and some values from the state of the world. So smart contract state is exactly what it sounds like. Arguments are things that the user provide, and values from the world can be things like block height, verifiable, randomness, that kind of thing. And what we get out when we run it is updates to the state and updates to the state of the smart contract and updates to the state of the world and a zero knowledge proof. And so we pass this zero knowledge proof on to Mina, and.
04:22:15.210 - 04:22:15.718, Speaker C: If the.
04:22:15.724 - 04:22:51.502, Speaker F: Proof is valid, then the state gets updated as described here. We'll skip through that real quick. Okay, how do ZK apps work? So you install your smart contract in your UI repository and then you deploy it and that's all. It's just TypeScript so you can publish it however you want to on GitHub or using NPM, and then you can just install it exactly as you would any other dependency. The smart contract is really just a dependency of your front end in this case. And you call it just like you would any other library. Okay, so we'll get on to an example.
04:22:51.502 - 04:23:29.386, Speaker F: And I'm sorry that I'm going so fast. Like I said, we're way behind time, so come stop me after if you have any questions. I know I'm kind of glossing over some stuff, but here's what we'll do. We're going to write a smart contract that calculates the next number of the Fibonacci sequence and it'll have two pieces of state, n minus two and N minus one. And it'll have a method update. This will let us update N minus two and N minus one, but only if we pass in the correct number, the correct next number in the sequence. To write our ZK app, we're just going to extend this Smart Contract class of Snarky JS into Fibonacci sequence.
04:23:29.386 - 04:24:19.526, Speaker F: And now we have a Smart Contract and we'll define some state. And so Zkapps can contain on chain state and in this case we need two pieces of it, n minus one and N minus two and they're both of the type field. We use this state decorator to basically tell Snarky JS, hey, this is a variable and you should do all the sort of work to make sure that when a user alters this variable in their browser, then if necessary, we reflect this change in the actual blockchain itself. So only types that are built out of field or structs that are composed of fields can be used for these state variables. And I think that's kind of all there is to say about state. We'll come back to it in just a second. The next thing that we're going to do is we're going to override this deploy method.
04:24:19.526 - 04:25:11.742, Speaker F: So this deploy method is a method that's run when the Smart Contract is deployed. It's kind of like the constructor or like if you have like a truffle file, it's the JavaScript trunk that deploys your contract. So in this case we're going to pass in some things from basically our deploy tool and then we're also going to set N minus one and N minus two to their initial values. And so we're going to set N minus two to field element of value zero and N minus one to a field element of value one. And so now when the Smart Contract is deployed, we know that these values will be initialized to zero and one respectively. Finally, we're going to define a user callable method, in this case Update. And so Update will take one argument N of type field and we can make as many methods as we want.
04:25:11.742 - 04:26:03.466, Speaker F: Each one can have its own logic and do as much computation as you'd like. So the methods of the Smart Contract describe how it can be invoked once the Smart Contract is actually deployed. And it's worth kind of calling out here that this value is actually private. Anything that we pass into these user defined methods is private until the point that it gets mutated and emitted in an event or used to update some sort of on chain state. So of course the state of the blockchain is public and the events and stuff are public, but the actual execution of this code is not public. You do it yourself in your browser and you only share a zero knowledge proof that says that you did it correctly and then any meaningful output of this. So in this case, this end value is not going to be revealed.
04:26:03.466 - 04:26:45.130, Speaker F: We pass it in, but we are passing it in on our local machine. It doesn't ever reach the nodes. That's something kind of worth calling out is that anything that you pass in is private. And along the course of the execution, it remains private until you do something not private with it, basically. So the update method, we're going to use this Git method on n minus two and n minus one. And this is going to grab these values from the blockchain and then store them in these local variables. So when we run this code, we're going to grab the values from the actual blockchain and put them in our local runtime.
04:26:45.130 - 04:28:00.580, Speaker F: And then what we're going to do is we're going to add n minus two to n minus one in order to get the next number in the Fibonacci sequence. And we're going to assert that this new state, the next number in the Fibonacci sequence is equal to N, the value that we pass in. And what this assertion statement does is it basically says, well, first of all, if this doesn't hold true, stop the execution. But second of all, set up the zero knowledge proof in such a way that even if a user could override the error that this throws, they will not be able to generate a valid zero knowledge proof. There's cryptographically nothing that they can do in order to make a valid zero knowledge proof for invoking this method, unless what they pass in does equal new state which also equals n minus two added to n minus one. Finally, the last thing that we have to do is we'll set our on chain state to new values. So we're going to basically take our new, the value that we passed in the next number in the sequence and we're going to set that to n minus one and then we're going to move n minus one over to n minus two and n minus two is going to get sort of pushed off the end.
04:28:02.390 - 04:28:03.186, Speaker D: So that's it.
04:28:03.208 - 04:28:48.958, Speaker F: That's kind of the basic structure of the smart contract. We define state, set up our deployment and then define the methods that users will be able to call once the smart contract is deployed. Now we're going to do something extra cool and I'll just blow through this really quickly. The point is kind of like to understand what's possible just because we have limited time. So what we can do, this smart contract as it works right now is the same as an ethereum smart contract a user calls a method. They create a transaction, they send a transaction, they wait for it to be mined and they pay a fee. But Mina allows you to structure things quite differently using recursive zero knowledge proofs.
04:28:48.958 - 04:29:08.746, Speaker F: And so instead of writing a smart contract, what we do here is we create a ZK program. And a ZK program is kind of like a subset of a smart contract. It's a provable program, it doesn't have the connective tissue for things like state and that kind of thing. So it's a provable program. But what's really cool is that if we look at these methods we can.
04:29:08.768 - 04:29:09.340, Speaker E: See.
04:29:11.470 - 04:30:00.170, Speaker F: As input, we can actually take proofs. And the output of sort of running this is also a proof. And so we can verify that the proofs that we pass in are valid inside of this proof. So we can have a proof that accepts other proofs as arguments and then verifies that these proofs are valid and then also does some other thing. And this is really powerful because you have arbitrary branches and merges, and you can do it an infinite number of times. So you could do something like use this to prove that you've kept a correct moving average for 100 years or ten years without having to store all of the previous data. You could use this to do something like make a smart contract that, I don't know, maybe does, like machine learning inferencing or something, and has to scale horizontally across many machines.
04:30:00.170 - 04:30:36.994, Speaker F: And you can do it for simpler, more practical things. Like if you want to build a game, you can build a game where one user makes a proof, sends it to the other user, the user validates their proof and then builds a proof on top of their proof that proves that their move is legal. And so you could do something like build a game where users go back and forth, peer to peer. There's no blocks, there's no fees. And at the end, we get a single proof that attests to the fact that the entire game has been played correctly. And then we can pass that proof as an input into Amina smart contract and settle the game that way. So this opens the door to all kinds of crazy stuff, mostly probably people who are interested in kind of the scalability aspect.
04:30:36.994 - 04:30:59.370, Speaker F: So come talk to me about this more after if you're interested. Yeah, it's pretty simple. We can just have we basically make a type for the type of proof that we're going to use and then we pass this in as an argument in our smart contract and call verify on it. Okay, now let's talk about the Mina protocol.
04:30:59.530 - 04:31:00.730, Speaker C: What is Mina?
04:31:00.890 - 04:31:31.862, Speaker F: It's a layer on blockchain that proves its entire finalized state using recursive zero knowledge proofs. So it works kind of like we just described. While other blockchains grow, they need all of the information in order to be able to verify any of the information. Basically, Mina does not. You just need a zero knowledge proof and the information that you're interested in in order to be able to verify that information is valid. And so it stays at fixed size 22. This cool, or is it actually useful? It's both.
04:31:31.862 - 04:32:07.314, Speaker F: It's really cool and it's really useful. So the first reason is obviously privacy. I think we kind of touched on this a little bit before, but Ethereum smart contracts run on every single node, so all the information is public. You can see what this kind of looks like if we call some method on an Ethereum smart contract. We send it to every single node, and every single node has to run this method. Mina smart contracts run in the browser, and so the arguments and the intermediate values are private by default. What this means is that the user runs this smart contract themselves.
04:32:07.314 - 04:32:47.418, Speaker F: They don't have to share what that looks like with anybody, and then they just take the relevant state updates and the proof and send that onto the MENA blockchain. Mina simply verifies the proof and updates the state on chain if the proof is valid. Okay, what about scalability? There's no gas model for ZK apps. They run off chain. And so the amount of computation doesn't affect the transaction cost. You can actually do an unlimited amount of computation, especially using this recursive proof mechanism, and then send a single transaction that attests to all of this. So developers can use recursion to build application specific roll ups.
04:32:47.418 - 04:33:31.630, Speaker F: We kind of touched on this a little bit earlier. What about decentralization? Okay, so as we talked about, Mina stays 22. So the amount of information you need in order to verify that the current state route of Mina is valid is 22. So it's possible in practice is that there's no need to rely on trusted third party node operators like Inferior or Alchemy or something like that. You can run, basically a node that only worries about your account, but doesn't have any sort of other security concessions. It's a full node, but it's a full node only for your account. Bridging is another thing that we can do kind of differently than I think, a lot of other blockchains.
04:33:31.630 - 04:34:11.398, Speaker F: A smart contract on another chain can bridge the whole Mina state just by verifying the most recent proof that generates. And so what that means is that, well, I guess here's a good example. We can write a smart contract on Ethereum with a method, and the method will take in as an argument the, you know, the root of this merkel tree, and it will also take in the most recent Mina zero knowledge proof. And we can pass in the zero. You know, then any user can call this method pass in the most recent zero knowledge proof and pass in the Mina state route. And this Ethereum contract can check that the zero knowledge proof is valid. And if it is, then it can update the state route on Ethereum.
04:34:11.398 - 04:34:57.690, Speaker F: And then when a user wants to use some specific information from Mina, they can, I don't know, grab this chunk down here and provide the rest of the merkel path and then validate it against the actual state route that's stored in this bridge contract in this case. And so this is not just hypothetical. The Nil Foundation is working on this right now with a joint grant from the Ethereum Foundation and the MENA Foundation. So, yeah, you can actually check out a demo. We'll have a QR code at the end that has this demo, we pass in our three relevant pieces of information and create a transaction and actually eventually send it through MetaMask to one of the ethereum testnets. I forget which one. Another thing that can work kind of differently is Oracles.
04:34:57.690 - 04:36:07.790, Speaker F: This is something that I'm not quite as exposed to, but the kind of broad strokes idea is that users will be able to create proofs that they've accessed a website through this SSL exchange. And so when you go to a website right now, you have a little lock in your browser and it basically says, we use some protocol to ensure that I'm talking to the party that I think I'm talking to, and they're talking to me, and nobody's tampering with anything in the middle. But the problem with this is that it's an interactive exchange, and so it's only compelling to the two parties involved in it. Using zero knowledge truce, we can take this interactive exchange and make it non interactive. And so what this would end up looking like in practice is a user might be able to do something like go to, I don't know, a website that publishes the results of soccer games, and they could prove I went to the New York Times or whatever website publishes soccer games. And I saw that on this page. We had the result of this soccer game I'm sorry, football game published as, let's say, I don't know, America Lost.
04:36:07.790 - 04:37:13.154, Speaker F: Let's say that then we can take this information and pass it straight into a smart contract. We can get a non interactive proof that we went to this website and that it said that this was true, and then we can pass it into another smart contract on the blockchain. So this opens the door to kind of people being able to create Oracles without having to set up these complicated pools of relayers that are going to, I don't know, stake some sort of capital and participate in some kind of game theory thing. You can just cryptographically know that this person really did go to this website and the website really did say this thing. What else is possible? Well, we actually don't even know everything that's possible yet. And that's why we're really excited to be here because there's plenty of things that we hadn't really thought about six months ago that seem like a good idea and like a feasible idea now. And that's kind of what we're hoping is know everybody at ETH India probably has a lot of collective brain power and maybe we can find new things that we can do with Mina that we didn't even know were possible yet.
04:37:13.154 - 04:37:38.698, Speaker F: We have all this technology and it opens a bunch of unique doors that nobody has really explored yet. And with a bunch of people, I think we can kind of explore all these avenues together and maybe find some really cool things that nobody has even thought about doing yet. We'll skip this and now we'll talk about where can we get more. So how do you get started? It's really simple. We have a single developer tool. It's called the Zkapp CLI. It's very powerful and it's very easy to use.
04:37:38.698 - 04:38:15.322, Speaker F: It's just an NPN package. You can install it and then you can run ZK project and then a name, let's say hello. When you do this, it'll create a project for you, scaffold it and also include an example smart contract and an example test. And so you can just install the Zkap CLI, create a project and then start poking around with it and look at the IntelliSense in Vs code and get a sense for what's going on. And you can even deploy this to Berkeley Testnet tonight. There will be cards next to the door when you leave that have simple instructions for this. So, yeah, you can get started in like five minutes.
04:38:15.322 - 04:38:42.234, Speaker F: This way we also have a bunch of tutorials and other documentation. I will have a link for that after. How else can you get involved? So you can visit our docs. That's probably the easiest way to get started. You can also apply for retroactive grants. We have a retroactive grant program. We have also ZK Ignite, which is a I don't know, I think we'll have more details at the desk.
04:38:42.234 - 04:38:52.790, Speaker F: But it's basically a program where we have I think, I think we have the next slide talks about it. And then finally you can also build a ZK app, which is a good thing to do because Zkaps.
04:38:55.130 - 04:38:55.894, Speaker E: Are all.
04:38:56.012 - 04:39:34.386, Speaker F: Eligible for the prizes here at ETH India. Okay, so, yeah, ZK Ignite, you can start building ZK apps and get rewarded from a pool of 250,000 mina with some bonus prizes. This is a code you can scan to kind of get signed up. And then in order to kind of get yourself up to speed on all of this, you can also check out the Docs@minaprotocol.com Zkapps. And this is a QR code that you can scan really quickly if you're I'll snap back to the other QR code in a second. This one has got links to the presentation here and some of the things that I talked about in it.
04:39:34.386 - 04:40:05.630, Speaker F: Like, for example, the Nil Foundation bridge. I think it has links to the docs, some GitHub repositories, some other things. So I'll do this one for a second and then I'll flip back to the other one in 54321. And if you miss it, just come stop me after. Our booth is in the middle kind of right between the hallway, between the left section of the room and the right section of the room. And here's the ZK Ignite Cohort zero QR code. Awesome.
04:40:05.630 - 04:40:16.800, Speaker F: I'm sorry I went so fast. If you have any questions, come talk to me after. I will have way better answers for you then. But thank you so much for having me and I hope this was interesting.
