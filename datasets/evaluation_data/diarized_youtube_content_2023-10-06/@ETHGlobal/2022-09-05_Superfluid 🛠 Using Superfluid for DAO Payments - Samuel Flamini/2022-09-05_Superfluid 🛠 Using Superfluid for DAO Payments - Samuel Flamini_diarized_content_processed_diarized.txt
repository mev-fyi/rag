00:00:06.890 - 00:00:28.854, Speaker A: Sweet. Okay. Hi, everyone. Welcome, welcome. We have Sam here from Superfluid, and he's going to do his workshop using Superfluid for Dow payments. So, yeah, super excited. I am obviously like a Superfluid fan girl and and yeah, we will have a Q and A towards the end.
00:00:28.854 - 00:00:53.200, Speaker A: So maybe like the last five or ten minutes, if everyone has questions, you can raise your hand or feel free, like, while Sam's talking, just so you don't forget your question. If you want to, just drop it on the chat and then we'll make sure to answer it. But if you're a little bit shy like me, you can always just wait and ask your question in the Superfluid discord. So cool. Yeah. I'll let Sam share his screen and take it away.
00:00:54.450 - 00:01:15.474, Speaker B: All right. Hello, everybody. It's good to be here. Thank you, Cree. I will just share my screen and we will go into this. So I'll share my whole desktop. And today what we're going to do is we're going to start off with a little slide deck presentation and then get into some code and show you how you can use Superfluid both the easy way, using our SDKs and stuff, and also at the smart contract level with some more advanced things.
00:01:15.474 - 00:01:46.506, Speaker B: But let me start presenting here in Keynote. All right, so we're super happy to be sponsoring Ethanline 2022. This is always a very fun event, and it's good to have so many people here. This will be fun. So what is Superfluid from a high level point of view? Some of you might have seen Superfluid, but I will give you the 101. So, Superfluid is a protocol that will allow you to transfer value in really novel and interesting ways. Right? And the way that you'll see this referenced most often is through something called money streaming.
00:01:46.506 - 00:02:47.566, Speaker B: So we like to talk about Superfluid at these events as a protocol that enables digital native programmable cash flows. Right? So we allow you to stream money with no capital lockup in a way that is 100% programmable and on chain. So at Superflu, we have this saying we like to bring up a lot, and that is Internet is to information with blockchain is to value. So one way that we want to bring this idea of value transfer into the age of the Internet is by allowing payment to flow in real time. If you think about this in terms of how the world works, if I provide you a service, whether I'm a consultant, an employee, or just providing some other random service, I provide that value to you in real time. But the way that it works today is that payment for the service is not connected to the value that I'm providing. If I'm an employee at your company, I might work for you right now, but I have to wait seven to 14 or maybe even 31 days if it's the entire month, to actually receive payment for the work that I've done.
00:02:47.566 - 00:03:32.080, Speaker B: So we believe that there should be a direct link between the two and money streaming enables this, right? So a money stream is a continuous payment. So you can think of it as a kind of recurring payment taken to its extreme. That is frictionless and open ended between two accounts. So this enables that real time direct link between value transfer and payment for that value. Right? So the other cool thing about this is that once I execute a transaction to open a stream, that is an on chain event, so what you get out of that is what's called a flow rate, which is how many tokens are being sent per second. And that gives you an on chain proof of payment so that I have less on payment risk, no delays. And also, because it's on chain, there's no intermediary either.
00:03:32.080 - 00:04:28.738, Speaker B: So this is all made possible by the superfluid protocol, which is an EVM focused smart contract framework that is deployed all over the place on L2s and side chains. And it's made up of these three high level parts, right? So you can see we have that big thing down there at the bottom, the superfluid host contract, which you can think of as the brain of the protocol. We have a library of agreements that allow balances to be changed in really novel and unique ways. And we have a new primitive that extends the ERC 20 and ERC seven seven standard called the super token that really makes all this possible and ties it in. So what are super tokens? Right, these are again an extension on the ERC 20 and ERC seven seven standard that are plugged into the superfluid protocol. So they're, ERC 20 compatible, meaning they have all of these standard methods you're used to on an ERC 20 token contract. There's the approve function, transfer from symbol, total supply, all that good stuff.
00:04:28.738 - 00:05:22.962, Speaker B: However, the way that balances are calculated on them are a bit novel, right, so because they're plugged directly into the protocol, they can have balances that change according to superfluid agreements. Right? So there's an agreement contract. There's actually multiple agreement contracts, but the one that I'm going to focus on today is the one that will enable money streaming. Right? So there's an agreement contract called the constant flow agreement that I can engage in as someone with an ethereum address. Or if I was building smart contracts, which we do later, I could do this with a smart contract address. If I call a function which creates a stream, what that will do is it will hook me into an agreement that is completely open ended, that I have full control over. Because this is Web Three, I have full custody over all of my funds and control over what happens.
00:05:22.962 - 00:06:18.194, Speaker B: But this agreement will connect me to a separate address. And when I create a stream, what that will do is define using that agreement, a number of tokens that I will send per second to a different address. And this amount using this agreement is reflected back into this thing called a real time balance. So with the real time balance, what we're doing is, instead of just checking discrete amounts to see how many tokens you have in your wallet at any given point in time, we're also taking into consideration all of those agreements you have set up, both on the receiving end and in the sending end. Right? So what we get from each agreement you're engaged in is this thing called the flow rate. And we can just aggregate those things together to get a net flow rate. So imagine I'm sending one stream, that's ten tokens per day, and then on the other end, I'm receiving one stream at five tokens per day.
00:06:18.194 - 00:07:00.034, Speaker B: What we get there is five coming in, ten going out. So we have a net flow rate of minus five tokens per day, right? So this will tell the protocol, okay, five tokens should be going out of Sam's balance every day. And what we can do is cheat a little bit and use the block timestamp value that we get at every single new block to calculate each time. Maybe I want to create a new stream or check what my balance is. We can calculate the number of seconds that have passed since that net flow rate has changed. And because that amount is defined at a per second value, we can always know how many tokens each individual address should have. So if you have any questions on that, please let me know.
00:07:00.034 - 00:07:29.734, Speaker B: That's me taking it from the high level all the way down to the low level explanation of what's going on. But I'm happy to answer specific questions about this in the Q A. But that's really how the streaming is working. The other cool thing about Superfluid, beyond the streaming and all that good stuff, is that it's programmable. So you can build these contracts that are also plugged into the protocol. I can build a thing called the super app that I register with the protocol we saw back here. There's this thing called the Superfluid Host contract.
00:07:29.734 - 00:08:21.590, Speaker B: There at the bottom, I can register a contract with the host and have it be aware of all the different money streams being sent into it and sent out of it as well. So I can create really cool stuff where I can take in incoming streams and then automatically do things with those incoming streams, right? We have this example in our super examples repo that I'll point to later called the money router that can take in streams and send streams out. And we also have an example called the Tradable Cash Flow that I'll demo using some code here in a few minutes that will show how these callbacks on these contracts work so they can take in streams and send them elsewhere in a programmatic way that you can define. So, again, these are called super apps. We'll get into them later. There are three callbacks that I'll reference in a bit. One of them can react to streams coming into the contract.
00:08:21.590 - 00:08:54.066, Speaker B: Another can react to those streams being updated. And then another can react to any deletions that happen. This is a way to build applications that connect with other applications. And what you get once you start chaining these things together, what we already have is this really cool network of cash flows, right? So this is actually live right now of what's recording. It's not fully, fully live, but this is the polygon network as of a couple of months ago, with all the different Superfluid activity taking place on it. Right. So you have each individual node.
00:08:54.066 - 00:09:37.790, Speaker B: Here is one of those green balls, and then all the connections are cash flows. And you can see the clusters are all smart. Most of them are smart contracts where there are different applications people are running that are taking in streams and doing really cool things with them. Right? So you as someone working in this hackathon, if you want to build on Superfluid, you have the opportunity to plug into this entire network of accounts and addresses already interacting with Superfluid and make it bigger while also having a potential interesting user base to start with. Right? So I implore you to help grow this network. Again, if you're building on Superfood at ETH Online, I want to highlight some of our prizes. We have about 20K worth in prizes at this hackathon.
00:09:37.790 - 00:10:26.174, Speaker B: I think this is the most money we've ever put out at a hackathon, so we're pretty excited about it. Should show you that we're pretty bullish on ETH Online 2022, but it ranges here from best overall project built on Superfluid down to if you submit a Superfluid based project and don't qualify for one of these other prizes, you can still be someone that wins a portion of our prize pool. So we have a $4,000 prize pool for everyone that doesn't win one of these amazing prizes. If you submit a Superfluid project and you actually use Superfluid in some way, don't you say you did, but actually implement our SDK or our contracts, you'll qualify for one of these things. So build on us. Right? We're really helpful, and we hope you consider exploring our tech. But okay, that was a mouthful.
00:10:26.174 - 00:10:52.326, Speaker B: That was a lot. Let's get into actually building on Superfluid. How do we do this? Well, there are a few things you should know about before we actually get started building. One of those things is the Superfluid developer console. This is a really, really useful tool for exploring different activity on Superfluid network and also tracking your own streams. There's also a really cool Subgraph Explorer thing that we'll go through later as well. There's a superfluid dashboard.
00:10:52.326 - 00:11:25.346, Speaker B: This is actually an outdated pick we have a really cool new version of our dashboard, dashboard V two that is live. Now, you can use that to get tokens and create streams in a no code way. And then we also have our SDK core. This is an SDK that will allow you to create streams in as little as five to ten lines of code total. And we'll go through an example of how to use this in a few minutes. But let's go through the basics. Some basic low level things you'll need to know before we actually get into specific examples and contracts.
00:11:25.346 - 00:12:10.918, Speaker B: So when you go to interact with superfluid, remember, there are three general classes of contracts you need to be aware of. I went through these a bit earlier, but they are the superfluid host contract, they are superfluid agreements and super tokens. Most of the time, the only thing you really need to be aware of are like, how to interact with super tokens directly, because our SDKs and libraries will distract some of the other low level stuff away from you. But when it comes to super tokens themselves, you should know that these are most of the time, if you're interacting with a token, that is a wrapper contract. Meaning if it's a token like die that you want to stream or USDC or ETH, you're interacting with something that's a wrapper around that underlying asset. So there's this thing called an ERC 20 wrapper token. You can deploy if you want.
00:12:10.918 - 00:13:08.226, Speaker B: You can take any ERC 20 token and deploy your own wrapper. But if I want to stream die, what I'll need to do is upgrade my existing ERC 20 die to the super token version. And there's a function on the super token contract called upgrade that will allow you to do that. What that's doing under the hood is just depositing your ERC 20 die into the super token die contract and minting you back a corresponding amount of the super token die, right? It's just a one to one amount. And the inverse of that operation is the downgrade method. So if I call downgrade, what that's going to do is burn the super token asset and just give me back my underlying, okay, that's super tokens. The final thing I'll go through just in terms of diagrams of how calls are working and things, is this diagram here, right? So under the hood, what's happening when I create a stream? Well, let's say I'm the sender there in the bottom left hand corner.
00:13:08.226 - 00:14:12.686, Speaker B: What's happening under the hood is I'm making a call to the superfluid host contract, okay? The host contract will then take in a call that specifies as a part of that transaction an action that I want to take using the agreement, right? So under the hood, let's say I want to create a stream to Cree for one token per day. I would define those as parameters there, and then that call will be passed through to the agreement and create the stream from me, the sender to Cree, the receiver, right? Pretty simple. Again, you don't have to really keep in mind at all times that it's the host making the call to the CFA, but it's worth having that as some just baseline context, right? In case you're curious, when you're looking on Ether scan, like, why am I calling this host thing? Why is it using call agreement? This is the explanation as to why it looks like that. Okay, so it's time to build. All right, let's actually get into some code, okay? Let's see how much time I have left here. I have maybe about ten minutes for actual code. I'll go through this relatively quickly.
00:14:12.686 - 00:14:37.954, Speaker B: Okay? So the first thing that I'm going to do is go through an example using our SDK. All right? Let me just pull this down slightly here, inside of our docs. Let's go to the Superfluid Docs. All right, let me stop real quick just to make sure I don't have any outstanding questions. Everything is all right. We just have some sheesh good emojis. Let's go.
00:14:37.954 - 00:14:53.734, Speaker B: People are excited. All right. Nothing too crazy in the chat. Shivali, I will answer your question in just a bit. Your short answer there is you don't need to deploy any contracts to do that, but I'll go deeper into that in just a few minutes. All right, so I'm in our docs. These are really helpful.
00:14:53.734 - 00:15:32.662, Speaker B: I highly recommend you go to Docs Superflu Finance before you start building. It's useful stuff there. We've worked pretty hard on them. But the first example I want to show you is an example that exists inside of the interactive tutorial section under Money Streaming. Okay? So this Money Streaming page is going to show you how to create, update, and delete money streams using our SDK, okay? The first few examples will use just an unlocked private key to show you how things are working. If you interact with these, put in your address and create a stream to yourself, it will send you some free tokens. If you need free tokens as well, we have a faucet you can use.
00:15:32.662 - 00:16:10.900, Speaker B: I recommend that it'll give you a bunch of fake dye, which is fun. But the example that I specifically want to show is this one where I have a connected wallet. Okay? Let me move around this little zoom thing and I'll show you this. Okay, so we have on this page a really simple example with a really ugly UI of a creative flow modal, right? What this lets you do is connect the wallets and create a stream. Okay? So here I have the code sandbox up. You're welcome to fork this and use it in your own project. I recommend you make it prettier than this because, again, I'm not the greatest front end dev in the world, but I can do it.
00:16:10.900 - 00:16:59.762, Speaker B: But here I just have a simple example that uses their SDK to create these streams, right? So what I'm doing here is importing this framework object from the SDK core, which is important for initializing the SDK. And then what I'm doing is I just have this function that will run when I click this button to create a stream that does the following. Okay? So the first thing is it will set up the SDK. Here we have this initialization. So this await framework create will create a framework object that I can call to open a stream. And all I need to pass to it is the chain ID that I'm using. So what I'm doing up top here is I'm getting the chain ID from MetaMask and then I'm also just getting the provider from MetaMask as well.
00:16:59.762 - 00:17:45.818, Speaker B: You could use an RPC provider here for this section if you like. But here I'm just using the window ethereum little thing here. Then what I'm doing is I'm loading the Dix contract from the SDK. I can do this just by calling SF load super token and I paste in the symbol there. Keep in mind that if you are using a test token, it is called Fdix to make it sound fake, right? F dix is the token I'm using here. I'm getting the address of that and then I have this operation that is going to create a flow for me. Okay? So here in this Create flow operation, I'm just going to call SF CFAV One Create Flow and I'm going to pass in a few parameters, okay? The first one we need is the recipient.
00:17:45.818 - 00:18:10.262, Speaker B: So in the example where I'm sending a stream to Cree, I'm just going to have Cree's address in here. In this case, I'd paste it in here to the form. I'd also need the flow rate. Okay, so the flow rate is denominated in way. So you can imagine these amounts having 18. Imagine if they had like 18 decimals. It's going to look like a very large number, but this is going to be the number of tokens I want to send per second.
00:18:10.262 - 00:18:32.814, Speaker B: Okay? So again, it's denominated in way. So a large number is actually really going to correspond to a small amount, but that's my flow rate. And the final thing I need here is the super token that I want to use. In this case it's going to be Dix. Okay? So this X here at the end is the denomination we use for super tokens. If it's a wrapper super token, we'll call it Dix. Okay, so you have Dix here.
00:18:32.814 - 00:18:59.850, Speaker B: If it was ETH, that'd be wrapped ETH and so on. Okay, then what we're going to do is execute this operation using the Createflow operation exec here. And I'm going to pass in my signer. In this case, just going to be the connected wallet to MetaMask. But that could be a signer and hard hat or something like that as well. All right, so we can create a stream like this. Let's say that I want to go to this end to end, connect a wallet.
00:18:59.850 - 00:19:33.966, Speaker B: I'm going to pick a kind of obscure address here that I have not used. Let's just go to the console and grab a random address I'm going to send a stream to. This is the superfluid console, by the way, guys. It's a pretty useful tool, but if I go to home in the console, I'll see all the recent streams created on any network here. I'm just going to take a random address and I'm going to give some really lucky random person a stream of fake die on Guerreli. Okay. Let's make sure I'm on Guerrelli.
00:19:33.966 - 00:19:52.694, Speaker B: Yes, I'm on Guerreli. Wonderful. Send a stream to this person and then I'm going to create a flow rate, right? So this is going to be 25 die per month. Again. You see, it looks like a pretty large number per second, but it's actually denominated in way. So in reality it's quite small. So I'm going to create a stream.
00:19:52.694 - 00:20:08.010, Speaker B: Let's hope this works. We're live. All right, wonderful. Modal pops up. Looks good. All right. Our stream is in the process of being created.
00:20:08.010 - 00:20:37.640, Speaker B: Okay, so what I'm going to do is I know which address we have here. Hang on a minute. It's this one. And we can see here if I search this address, this address has a lot of streams. Okay. What you can do once you have a stream open is see a bunch of different incoming and outgoing streams we have here. You can see here I have a ton of outgoing streams like this one, for example.
00:20:37.640 - 00:20:55.822, Speaker B: It'll take a few seconds for the previous stream I just created to show up here. But what's going to happen here is it'll look like this. I could search it. It'll show me what the flow rate looks like. It'll show me how much has been streamed. It'll show me when it was last updated. It and you'll be able to see for any given address all the incoming and outgoing streams that any address has.
00:20:55.822 - 00:21:30.810, Speaker B: So the council is very cool. You can also do this and look at it actually on the subgraph as well. It'll give you a specific subgraph query you can use to search this, which is pretty awesome, especially if you need to get data in for your application. Okay, so that's a really simple example to show you how to create, update and delete money streams. That's pretty useful for you. What I'll do now, we're running low on time, but I'm going to give you a quick overview and at least show you where to go to play around with a more advanced smart contract example. Okay, so there is a contract in our examples repository called the Tradable Cash flow contract.
00:21:30.810 - 00:22:28.342, Speaker B: I'll reshare here. So we went through this one with our beautiful UI. But this Tradable cash flow contract. What does this do? This is one of those super apps that can automatically react to changes in streams with regard to that contract. So we can deploy one of these contracts, register it with the Superfluid protocol, and then anytime that a stream is sent into this contract, anytime it's updated, or anytime that stream is deleted, we can do things automatically within that contract inside of these callback functions, right? So in this case, what the Tradable cash flow does is it receives streams. It's also an NFT contract at the same time, which is pretty cool, and it can automatically send 100% of the inflow into the contract to the owner of that NFT contract, right? So it is literally a Tradable cash flow. Anytime the stream is stopped, the outgoing streams are stopped.
00:22:28.342 - 00:23:13.546, Speaker B: Anytime the NFT is traded, all the cash flow will follow. That owner will follow the NFT to the new owner, which makes it literally like an asset that can be plugged into the rest of DeFi. Okay, I highly recommend playing around with this. Many of you that are here, repeat builders on Superfluid have probably seen this field with a Tradable cash flow before, but it's a very powerful primitive that can unlock a lot of really cool things and gives a lot of people a light bulb moment as to how programmable superfluid actually can be. Okay? So if you ever want to fork this example, what you can do is go to our Examples repo and I'll just do that for you here live to show you where you can find it. But it is in the Super Examples folder. Okay, so if you go to GitHub.com
00:23:13.546 - 00:23:51.622, Speaker B: Superfluid Finance and go to Super Examples, you can see it in the Examples folder right here. Okay, so you want to go right here. I'm literally going to put this exact link in the chat for you guys so you can see it yourself in case you're curious. All right, so go click on that and then I'll just quickly go through the architecture of the contract and then we'll stop for some Q and A. Okay, so if I go into the contracts themselves, you see there's two. One of them is this Tradable cash flow sol. This creates a contract which does two things.
00:23:51.622 - 00:24:30.180, Speaker B: One, it inherits from the NFT contract that we're all familiar with, right? The ERC. 721. And it also is going to use this before token transfer hook that is optional that you can implement on NFT contracts themselves. You can read about the Before Token transfer hook in the open Zeppelin docs, but it does this really cool thing where it allows me to insert some logic anytime the token is transferred. Okay? That's what that's going to do. And then we're also going to inherit from this Redirect All contract which has all of our cool superfluid logic in it. All right? So you'll want to go into the Redirect All contract, read through it, and you'll want to notice really two key things.
00:24:30.180 - 00:24:58.906, Speaker B: The first thing is that we're importing and setting up this CFA library. Okay. The CFA library makes it really easy to create, update, and delete streams for us. And you can see its usage all over the place. So if I just look up CFA V One, we can see that it is being used to let's see here. I'll find a create example. Yes, it's being used to create a flow right here.
00:24:58.906 - 00:25:16.334, Speaker B: It's being used to delete flows. You want to get familiar with the CFA library. If you're using Solidity to create streams, we have lots of docs on it. Look up CFAB One library in our docs. Okay. That's thing number one. Thing number two is that you'll also want to check out these callback functions.
00:25:16.334 - 00:25:46.010, Speaker B: So look for this little after agreement keyword. All right, so we have after agreement created, after agreement updated, and after agreement terminated. Inside of these functions, I can insert any arbitrary logic I want such that that logic will run each time a stream is created, updated, or deleted into the contract. Okay. You can put anything you want in here. Get creative as you'd like, do something weird. We'd love to see it, but the only thing that's running is this update outflow function, which will, if I search.
00:25:46.080 - 00:25:46.700, Speaker A: That.
00:25:49.790 - 00:26:14.786, Speaker B: This go back up one. This is going to facilitate all of the logic where we looked to see. All right, is there a stream now coming into the contract? Okay, what do we need to know about that stream? We need to make sure that 100% of that stream is being sent to our owner, and this is just handling each of those cases. Right. So I'll kind of pause there. If you have any questions specific on how this function works and how all this stuff works, please let me know. Reach out to me.
00:26:14.786 - 00:26:26.870, Speaker B: I'm happy to help you in discord, but for now, if we have a minute of the minute or two, it sounds like Cream might be giving me that little time to stop, but let me know and we can answer some questions here live.
00:26:27.020 - 00:26:32.460, Speaker A: Awesome. No, you're good for about, like, another minute or two if there's anyone that has any questions.
00:26:33.310 - 00:27:09.426, Speaker B: Okay, so I will go into the chat here and I will officially answer Shivali's question. Do we need to deploy all three contracts, host agreement and super token? All these contracts are actually already deployed. You can interact with them pretty easily either using our SDK, like, I went through that CFAV One library I just briefly showed, and in case you need to actually set things up or you need the addresses, you can go to the console and go to this protocol section. Right. This was the place where you'll get all the addresses for these contracts when you want to interact with them. Okay, so check those out there. And then the last question here is, good.
00:27:09.426 - 00:27:49.262, Speaker B: Day, sir, may I please ask what happens in the case when an asset you are trying to create a stream for is not 18 decimal places such as USDT? Is there a specific list of supported assets? And secondly, can you confirm if the contracts addresses deployed for the protocol are proxy contracts? Number one, yes, they are proxy contracts. They are upgradable in terms of how we upgrade them. We have a governance process. We very rarely upgrade things except for extremely technical reasons. But you're welcome to ask me additional questions on that. The deployed contracts are going to be found in that protocol link that you'll want to go to that I just pasted in the chat. And all super tokens as they're deployed right now, have 18 decimals.
00:27:49.262 - 00:28:20.038, Speaker B: Right. So if you have a contract, I think USDC doesn't have 18 decimals, but the Usdcx contract, the super token version, will have 18 decimals. That is a bit of a standard we have arbitrarily chosen. Just try to keep things simple within super tokens. If you want to deploy your own new ERC 20 token wrapper, we'd also ask that you make it decimals 18. Right. I don't believe it's hard coded, but obviously if you're going to deploy your own contract, you can do whatever you want, but keep it 18 decimals.
00:28:20.038 - 00:28:45.426, Speaker B: For simplicity, please, could you go into a bit of detail on how the money streaming itself works on a technical level? Okay, so I tried to do that a little bit earlier with the real time balance explanation. I'm not going to have time to probably go through it again here, unfortunately. But hit me up in discord. Go to the superfluid support channel in discord in the ETH Global server. Just paste the same question there, and I'll get into it in more depth. Thank you so much, sir. Got you.
00:28:45.426 - 00:29:12.202, Speaker B: Thank you for the explanation. And then last question I'll answer here. Can you interact with the smart contract directly on the back end? Yes, you can. So all the contracts, again, are available at those addresses in the protocol section. If you click on any of those or if you search them on Etherscan polygon scan, all the different block explorers, they're all verified. You'll be able to see all the functions there on the block explorers. If you want to interact with them directly there, you can.
00:29:12.202 - 00:29:26.286, Speaker B: I'd recommend going to our docs first and reading about how each thing's working first, but, yeah, it's all open source code. You can do whatever you like with the already deployed code there. And I think that's it.
00:29:26.388 - 00:29:39.926, Speaker A: Yeah, I think so. Awesome. Thanks so much, Sam. Always, always super informative. You always know someone is super smart if they can explain complicated things in a way that I understand. So thanks again. Awesome.
00:29:39.926 - 00:29:44.600, Speaker A: All right, everyone. Yeah, go ask more questions in the discord. And thanks for coming.
00:29:45.290 - 00:29:47.540, Speaker B: Cool. Thanks for being thanks, everybody. Have a good one.
