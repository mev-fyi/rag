00:00:07.130 - 00:00:53.242, Speaker A: Thanks for coming for this workshop. In this workshop, I'll very quickly show you how you can get started with Zkavm, how you can build your projects on ZkaVM. But first of all, GMGM, or I should say ZMZM because we are moving into this world of ZK. So what is Polygon ZK EVM. So Polygon ZkvM is an EVM equivalent, ZK rollup. It harnesses the power of ZK to reduce the transaction cost and increase the throughput. And why Polygon ZKM? We feel that it's the next chapter of Ethereum scaling.
00:00:53.242 - 00:01:32.326, Speaker A: So it's very exciting for developers because you can use all the same tools and technologies that you have been familiar with, like different wallets, like tools for developing smart contracts, like foundry hard art. You can code in solidity. So it works pretty seamlessly. They all work out of the box. Just I need to highlight that. The only thing is that I want to call out is that we don't support three pre compile opcodes. So if you're building on that, just be aware.
00:01:32.326 - 00:01:58.958, Speaker A: Otherwise everything works pretty seamlessly, which is very great for a dev. So first half of ZKE EVM is ZK. I'll explain this with an example. So everyone must have played this game called where is Waldo in their childhood. Basically it's kind of a puzzle and you want to find out, you need to figure out where Waldo exactly is.
00:01:59.044 - 00:01:59.680, Speaker B: Right?
00:02:01.910 - 00:03:24.720, Speaker A: So what if I say I know the location of Waldo, but I can prove to you without actually revealing the actual location of it, how am I going to do it? So I'm going to take a big piece of black paper, I'll cut out the shape of Waldo and I'll place it over the picture. So in this way I can prove to you the exact location of Waldo. But I could have placed the puzzle in any of the corners or anywhere around the black paper. So in this way, you don't know what's the location? Only I know, but I have proof to you that I know the location. So this is technically how ZK works, right? So in real life, ZK works with complex maths and cryptography to prove a validity of a statement without actually revealing that statement. So we have talked about zero knowledge, but what exactly is a roll up? So zero knowledge roll ups are L2 scaling solutions that increase the throughput. That increase, basically they scale Ethereum by increasing the throughput and reducing the transaction cost.
00:03:24.720 - 00:04:27.630, Speaker A: Yeah. So in case of a ZKe EVM rollup. So Zke EVM rollup is technically a Zk roll up that is designed to mimic the same transaction execution environment as Mainnet, Ethereum or Polygon Pos, or any other EVM chain. So what's the benefits and features? So it enhances the Ethereum's battle tested security. So the proof is being posted on Ethereum. And Ethereum has been running successfully for years, right? So we trust it, we love it for defi, it's scalable. We achieve this scalability by batching many transactions together to unlock higher performance, right? And obviously it brings down the cost, like gradually low and it's EVM equivalent.
00:04:27.630 - 00:05:37.398, Speaker A: So the benefit, as I explained before, is that you can use all the tools out of the box. So I'll quickly explain the architecture of polygon Zke EVM. So think about this as a transaction cycle. So we'll get into a small journey from where a transaction is sent by a user till this transaction is completely final on Ethereum, right? So we start by receiving this transaction on the node sent by a wallet or any script if you are working on a project. So this transaction goes to a pending transaction pool, and at some point the sequencer, you can see there to the top, right, it's part of the node, it picks up the transactions, it executes these transactions and then puts them into an order. So this ordering is actually what we call as the trusted state. It's trusted because it's not yet on layer one.
00:05:37.398 - 00:06:38.970, Speaker A: And the sequencer essentially just says that hey, this transaction will be included in this block. This info then can be shared to the other nodes in the network via the broadcasting service. And this information can be shared to the users as well. So this is where we actually achieve the first level of finality, or first level of confirmation, right? Then after a certain time, the sequencer, when it has accumulated enough transactions in the trusted state, it'll send this transaction in a batch to layer one. It sends it to the roll up contract that's called as Polynzkavm soul to be precise. So you can see the contract there. So the main goal of this interaction is to put the DA, the data availability on Ethereum, basically the data of the transactions to Ethereum.
00:06:38.970 - 00:07:39.790, Speaker A: After we have done that, the key point is that any node in the network can then read this Ethereum smart contract and rebuild the state using this info. And we can rely on the data that is posted on Ethereum, because what's on Ethereum, it will stay there for, well, long enough, we hope, right? And now because of this, we can rely on the state of L2 roll up as it's on Ethereum, right? It is what we call as virtual state. Now here we realize that we haven't talked much about ZK, right? It's Zke EVM. So here's the thing. Although we have this data on Ethereum, but the Ethereum smart contract doesn't understand the processing of these transactions. It just knows that there's bunch of data. And in order to make it aware of the latest state of L2, it's when we need the ZK proof.
00:07:39.790 - 00:09:13.120, Speaker A: There is another role in the node called aggregator which will fetch this data and generate a ZK proof after talking to another service called prover and say hey, after processing this data, the state of the network is this. And of course we compress this state into a hash, a Merkel root to be precise, and then submit this ZK proof to Ethereum. This state is called consolidated state and that's how we are scaling transaction while we are inheriting the security of Ethereum. So these are the three stages of finality that I talked before, the trusted, virtual and consolidated. So it's the trusted state where the badge generation and the broadcast happens to the l two node and it's basically given by the trusted sequencer. Then we have the virtual state where we are putting the data availability onto Ethereum and then we have the consolidated state where we are generating the proof and we are actually putting this proof on Ethereum. So yeah, some of the industry use cases and things that we are really excited you all will be building this weekend are defi and in tradefi space when you are transferring value.
00:09:13.120 - 00:10:21.970, Speaker A: So when you are transferring value you want high levels of security. So for finance we highly suggest using ZkaVM. Even like in other use cases like healthcare, gaming, supply chain, you need high level of trust. We highly recommend using Polygon, Zkavm when you are figuring out what chain to go for. So to get started with building with Polygon, you first need to bridge some funds from Ethereum. And technically you need to bridge ether from Ethereum to get zke evm eth that you can use to submit transactions, pay for gas fees, et cetera, right? So you can do that by going to wallet polygon technology. There you can just select based on if you want to go for Testnet or Mainnet, you can select the network, you can select Ethereum and then basically you can just click the button, start bridging and you will have zkavm eth in your wallet.
00:10:21.970 - 00:11:22.294, Speaker A: So for Mainnet, obviously you need to bridge over the real ETH. But for testnet what else you can do is go to faucet polygon technology, paste your wallet address there and click polygon zkavm there the network, and you'll receive Zkavm ETH. Yeah, so as you can see, it's very simple to deploy and get started with ZkavM and swapping your development environment from Ethereum or any other EVM chain that you're using to Polygon ZkVM. And this can happen just by changing one line that is basically changing the JSON RPC. So that's really what you need to do. So I'll just show you how we can do this very quickly using hard art. So I'll just jump to vs code.
00:11:22.294 - 00:12:15.442, Speaker A: So this is a very basic project of hard art and I have a contract here called greeter soul that you get out of the box with hard art. So in this contract you can see obviously we have the pragma statement, then we have a constructor function, we have a view function that is greet to actually see the value of greeting that we have defined here. So the contract is maintaining the state of this particular variable. We can use this function to get the value of greeting. We can use the set greeting function here to actually see what is the current value of greeting. And we have this constructor function to set the initial value for greeting. Then I've written this small deploy JS script.
00:12:15.442 - 00:13:20.682, Speaker A: This is to actually deploy this contract. So I'm using this dependency called Hardad ethers and I'm calling this deploy contract method to create an instance of the contract and then deploying it. Then I'm just printing the address for the contract that I've deployed, right. So what I was mentioning was that how you can just deploy on polygon, you just need to change one line of code, right? So it's this simple line of code that I was referring to, that's the JSON RPC. So this is the config file, right? So I've named the network as Zkavm. I'm mentioning the URL and I'm also mentioning what my private key is, so that to make Hardad aware of from what account I want to deploy my contract from. So I've put the value for this in my env file.
00:13:20.682 - 00:13:58.760, Speaker A: So if you just want to deploy this contract, what you can do is say NPX hardhat run. And I want to run this particular deploy js file. So I'll just say scripts, it's in scripts folder say deploy js and I'll just select the network which is in this case is Zkevm. And I'll just hit enter.
00:14:00.890 - 00:14:04.650, Speaker B: Don, I'm having it. Yeah.
00:14:04.720 - 00:14:32.482, Speaker A: As you can see the contract. I'll just move this up a little bit. So as you can see, the contract is deployed to this particular address. We can go and have a look as well. For that we have the explorer at Zkavm polygon technology. Sorry, zkavm polygonscan.com and for testnet it's testnet zkvm polygon.com.
00:14:32.482 - 00:15:12.560, Speaker A: So right now, as I have deployed it on Testnet, I've just copied the address, I'll just paste it here. As you can see it was deployed 1 minute ago. So I was able to do it because I had some funds in my wallet. But for you to get it again you can just go to wallet polygon technology to bridge over the ETH or you can go to faucet if you're developing on Testnet. So yeah, that'll be all from my side. Thank you. Anyone has any questions?
00:15:13.170 - 00:15:32.822, Speaker B: All tested? Yeah. Right, next room. I have to really or more get back on the gas. Yeah.
00:15:32.876 - 00:16:00.400, Speaker A: So the gas price is definitely lot less than Ethereum, but for NFT use case probably. I'll say you can choose whether you can go for PoS or you can go for ZkavM. What ZkaVM gives you other than POS is that it gives you a high level of security as it's a roll up.
00:16:01.410 - 00:16:02.880, Speaker B: Okay, yeah, thanks.
00:16:04.370 - 00:16:05.360, Speaker A: The question.
00:16:06.050 - 00:16:20.454, Speaker B: Yeah, hello. I could not quite understand what was meant by changing one line in the module. What was meant by changing one line in the module? Exports. Yeah.
00:16:20.572 - 00:16:31.000, Speaker A: So basically if you're developing on Ethereum or you were developing on any EVM chain, let's say Polygon PoS and.
00:16:32.830 - 00:16:33.146, Speaker B: You.
00:16:33.168 - 00:17:29.340, Speaker A: Already have your contracts, right? You must have deployed them using any of the smart contract development framework like hardat foundry, or you can do it via remix as well. So technically the whole idea was that you don't need to change anything with respect to contracts, right? You can just connect to the RPC and deploy your contract there. So in the line, show you. I'm just mentioning which network I need to connect in. So if, let's say I just mentioned the RPC URL of Ethereum here, the contract would be deployed to Ethereum. Or if I mentioned the RPCRL of Polygon, PoS, it'll deploy on PoS. The whole idea of this one line change is that it's very easy to deploy on ZKVM that you don't need to change anything.
00:17:29.340 - 00:17:37.870, Speaker A: The DApps that you are already familiar with or you already have built, they can straight work out of the box with ZkVM.
00:17:38.770 - 00:18:01.010, Speaker B: So actually, how can you say that you are achieving much more throughput rather than the traditional method, although you are doing much more computation to the JSK calculation you are doing? So how can you say that you are achieving once more throughput in JK APM process rather than the traditional method?
00:18:01.370 - 00:18:04.546, Speaker A: So you're saying with respect to Ethereum.
00:18:04.658 - 00:18:05.318, Speaker B: Yeah.
00:18:05.484 - 00:18:36.782, Speaker A: So in Ethereum, as you know, there's a block time of 15 seconds, right? So the throughput is really less. And here, what traditionally we are doing is we are batching all the transactions and then submitting them on Ethereum. And if you see in Ethereum, whenever you want to transact, there's a separate transaction for every transaction that you are doing. Right. Every thing that you need to change the state of Ethereum for.
00:18:36.836 - 00:18:37.246, Speaker B: Right.
00:18:37.348 - 00:18:53.480, Speaker A: But with ZKVM, what you're traditionally doing is that you're batching all those transactions and then just submitting one transaction on Ethereum. Basically that's submitting the validity proof to it. So the throughput is much more than that.
00:18:59.690 - 00:19:00.550, Speaker B: Beware.
00:19:01.450 - 00:19:15.242, Speaker A: Any other questions? We have plenty of time, so please take advantage of the time. We still have a whole another 10 minutes if anyone would like to ask a question. Come on, closer too, so we can hear you better.
00:19:15.296 - 00:19:16.410, Speaker C: For those in the back.
00:19:16.560 - 00:19:17.342, Speaker D: Can you hear me?
00:19:17.396 - 00:19:17.710, Speaker B: Yeah.
00:19:17.780 - 00:19:25.578, Speaker D: All right, I have a bunch of questions, I guess. So, as I understand, the whole system is basically zero knowledge proofs based roll ups.
00:19:25.594 - 00:19:26.160, Speaker B: Right.
00:19:26.530 - 00:19:44.930, Speaker D: How it is being batched and how it is being submitted to Ethereum. Now, from an EVM perspective, do you have anything extra that has been added which sort of gives smart contracts, maybe zero knowledge proof sort of functionalities or something like that, that you can execute?
00:19:45.090 - 00:19:59.882, Speaker A: No. So from smart contract level, it's exactly the same. If you compare it with Ethereum and Pos, what we are leveraging, zero knowledge proofs, is just to scale for basically.
00:19:59.936 - 00:20:01.162, Speaker D: The roll up thing.
00:20:01.296 - 00:20:01.980, Speaker A: Exactly.
00:20:02.510 - 00:20:11.466, Speaker D: That also means that the transactions on the whole system are actually visible. The transactions themselves are not zero knowledge.
00:20:11.578 - 00:20:12.560, Speaker B: Right? Yeah.
00:20:13.330 - 00:20:27.986, Speaker D: Are there any plans in which you have either this network upgraded to or maybe a new network in which the whole network itself is zero knowledge so that you basically cannot see who is doing what?
00:20:28.168 - 00:20:28.850, Speaker B: Yeah.
00:20:29.000 - 00:20:50.614, Speaker A: So the thing here is that with zero knowledge, zero knowledge here, how it is being used is that when I am transacting on polygon Zkavm. All the transactional data stays on Zkevm itself. It's just that the summary is posted on Ethereum.
00:20:50.662 - 00:20:51.018, Speaker B: Right.
00:20:51.104 - 00:21:01.594, Speaker A: So if you see, Ethereum doesn't know about that data, but still it knows the state of Zkavm. So in that sense, it's zero knowledge for Ethereum.
00:21:01.642 - 00:21:02.046, Speaker B: Right.
00:21:02.148 - 00:21:16.254, Speaker A: But to your point, I think we don't have any plans for that. Because technically, if you want the whole chain to be zero knowledge, that's actually the role of consortium or private blockchains.
00:21:16.302 - 00:21:16.610, Speaker B: Right.
00:21:16.680 - 00:21:24.946, Speaker A: And as you know, our main vision is to scale Ethereum, which is a public chain. So we are going to have a public chain.
00:21:24.978 - 00:21:26.166, Speaker B: Yeah, got it.
00:21:26.188 - 00:21:39.900, Speaker D: I mean, you can have a public chain also in which you have zero knowledge based transaction. I think Aztec initially was trying to do that or something like that. But, yeah, that completely depends upon what the plans are.
00:21:40.270 - 00:21:40.874, Speaker A: But, yeah.
00:21:40.912 - 00:21:51.040, Speaker B: Thank you. So through JKVM, we are creating a JK proof of our smart contract. Can we say that?
00:21:51.650 - 00:22:27.254, Speaker A: No, technically, you can say that you are technically just creating a proof of the latest state of Zkavm and then posting it on Ethereum. So that Ethereum is aware of the latest state of Zkavm. This is very useful when you are bridging, basically. So to bridge, if you see, if you want to do it from Ethereum to Zkavm, Zkavm can just fetch the state of Ethereum and know that you have deposited your funds.
00:22:27.302 - 00:22:27.706, Speaker B: Right.
00:22:27.808 - 00:22:36.258, Speaker A: But in order to withdraw back to Ethereum, Ethereum smart contracts, or Ethereum should also be aware of the state of Zkavm.
00:22:36.294 - 00:22:36.638, Speaker B: Right.
00:22:36.724 - 00:22:40.190, Speaker A: So that is done via the ZK proofs.
00:22:40.610 - 00:22:43.040, Speaker B: Okay, thanks. Thank you.
00:22:44.130 - 00:22:56.530, Speaker C: Hello. Yeah, so from my understanding. So it's like we are having a normal polygon chain, and this zero knowledge chain is like a different one, right?
00:22:56.680 - 00:23:15.406, Speaker A: Yeah, both are very different. So the ZK EVM is a roll up, and that's traditional PoS chain. This works on a consensus mechanism known as proof of efficiency. Completely different chain.
00:23:15.458 - 00:23:15.626, Speaker B: Yeah.
00:23:15.648 - 00:23:31.578, Speaker C: So my question is just from a perspective of one who develops the Dapps or just a contract. So when can I decide? Okay, this is the right time to use this zero knowledge chain. So can you give maybe a direction?
00:23:31.674 - 00:23:32.030, Speaker B: Yeah.
00:23:32.100 - 00:24:28.366, Speaker A: So basically, if you still have a lot of transactions, or if, let's say, you are building a Dap in defi, right, or you are building a defi product, then security is very essential for you. Right. You don't want someone to steal your funds or go somewhere else. I'm not saying that POS is not secured, but Zkavm is much more secured than PoS right. So the thing is that if security is your thing, you should go for ZK avium. But some use cases like nfts where you want a lot of transactions. And if you see the gas fees, the gas fees on PoS is cheaper than Zkavm, right.
00:24:28.366 - 00:24:33.922, Speaker A: So if you want to go for bulk transactions and low gas fees, you can select.
00:24:33.976 - 00:24:42.962, Speaker C: PoS actually one of our use case is like we want to include a lot of NFT minting. So would you suggest go for the zero knowledge chain?
00:24:43.026 - 00:24:48.760, Speaker A: Yeah, you can totally go for ZKe EVM. In that case it'll work totally fine.
00:24:49.130 - 00:24:50.440, Speaker B: Okay, thank you.
00:24:51.290 - 00:24:53.850, Speaker A: Cool, excellent.
00:24:55.310 - 00:25:09.040, Speaker B: Can we visualize the JK proof? What is the JK proof of our smart contract? And can we verify the JK proof we are generating is actually representing our smart contract? Is there any way of doing that?
00:25:11.170 - 00:25:14.906, Speaker A: So you're basically saying of your smart.
00:25:14.938 - 00:25:29.620, Speaker B: Contract, our smart contract, we are creating the JK proof of our smart contract. So is there any way to verify that the proof we are creating is actually mimicking the smart contract of.
00:25:29.990 - 00:25:40.246, Speaker A: Okay, you're not creating a proof for the smart contract when you are transacting with that smart contract. You're creating a proof for that.
00:25:40.348 - 00:25:40.806, Speaker B: Right.
00:25:40.908 - 00:25:51.814, Speaker A: And then basically when you're submitting the proof. So let's say you send a transaction and that changes the state of Zkavm.
00:25:51.862 - 00:25:52.458, Speaker B: Right.
00:25:52.624 - 00:25:59.360, Speaker A: Now for Ethereum to be aware of that state, you are sending that proof there.
00:26:02.130 - 00:26:04.814, Speaker B: Yeah, I got it. Thank you.
00:26:05.012 - 00:26:20.830, Speaker A: Yeah, can you hear me? So you mentioned that you have some certain opcodes which are not compatible with the ZkVM, right. It's just three pre compile opcodes. Other than that, all the opcodes are supported.
00:26:20.910 - 00:26:21.298, Speaker B: Yeah.
00:26:21.384 - 00:26:48.590, Speaker A: So how can we know which are those opcodes? So we can avoid it in our contracts when deploying. Yeah, so for that you can just go to Wiki polygon technology. I can just show you quickly as well. So here's the documentation. So here's the quick start guide to. Actually you can find the RPC details about the Testnet and ZkaVM. And if you go to faqs and you go to EVM equivalents.
00:26:48.590 - 00:27:00.850, Speaker A: Yeah you can just see that these pre compiled are not supported. It's SHA 256 Blake and pairings. Other than that, all the opcodes are supported.
00:27:01.510 - 00:27:02.500, Speaker B: Thank you.
00:27:05.300 - 00:27:27.492, Speaker A: Any other questions? Still have 3 minutes. Actually I'm trying to build a DAP D five DAP, which is trying to run a job, and that job will be containing hundreds of transactions. So can I do that in zero knowledge? ZkVM, you mean? Yeah, totally.
00:27:27.636 - 00:27:27.992, Speaker B: Okay.
00:27:28.046 - 00:27:33.332, Speaker A: Because in Ethereum mainnet, the gas prices are exorbitant.
00:27:33.476 - 00:27:33.832, Speaker B: Yeah.
00:27:33.886 - 00:28:00.788, Speaker A: So if you see with polygon ZKVM, the transaction fees are very low as compared to Ethereum. So even if you see the contract that I deploy, it's zero point 25 ETH is the transaction fee. In case of Ethereum, it would have been much more than.
00:28:00.834 - 00:28:09.890, Speaker B: Right. Yeah. So you can totally use EKVM for deploying it, appear.
