00:00:07.290 - 00:01:01.914, Speaker A: Today we're going to do a workshop where you're going to be able to deploy your own Rust ERC 721. That is, we're going to make NFTs together using the Rust programming language and Arbitrum stylus. So if you actually want to follow along and deploy this NF, which you're going to see is pretty cool and straightforward, you'll need to go to this link. So there's this GitHub repo. And if you follow along with this, you'll be able to actually create your NFT and use it to do a bunch of fun stuff. So this workshop kind of has two parts to it in the beginning here, while we're all getting the things installed on that GitHub page set up. So that's just like the Rust programming language, cargo Stylus, the tool we use to actually deploy stylus programs and some free testnet ether.
00:01:01.914 - 00:01:43.662, Speaker A: So if you're low on testnet ETH, we have that too. All of that is on this page here. So this is on the off chain Labs account. There is a stylus workshop NFT repo, and we'll look at this together. So while everyone's setting that up, we're going to look at an example ERC 721 implementation together to try and learn a little bit more about how Rust and stuff works from a perspective of a Solidity developer and what actually working in it in an Arbitrum setting looks like. And then at the end, we'll just work on NFTs together. Okay, so this repo is where you want to go.
00:01:43.662 - 00:02:11.906, Speaker A: I'll show the link again later, but it's on the off chain Labs just search stylus workshop NFT. That'll take you to this repo here. And it's kind of what you expect from a git repo. You just clone this thing and okay, good, you can see this. I'm going to jump into code together, but just real quick. So you're going to install Rust, you're going to install Cargo Stylus, and here's the commands for it. And then you're going to get some free test ether from this faucet.
00:02:11.906 - 00:02:30.090, Speaker A: So you won't have to buy anything. You can just do it. Okay. So, yeah, you'll just go through this repo. We hope too later that this will be of educational value just looking at this code together. But let's do a little deep dive together with it. So I'm going to open it up in my editor.
00:02:30.090 - 00:03:33.294, Speaker A: You're going to find that when you look at this NFT project, there is this source directory and various files in it. There's only a few. The first one, which will be of particular interest to anybody who's actually done a lot of work with Solidity before, is this 721 Rs. So Rs is the extension for Rust. And you'll actually see as we scroll through this together, that what it means to write an ERC 721 in Stylus using Rust is actually quite similar to what it means in Solidity. You'll find that every program begins with a set of storage definitions and you'll notice that using the Stylus SDK, that is the special Rust library that Offchain Labs provides, you're actually able to declare the various pieces of state using Solidity syntax. So you'll notice here that this ERC 721, this is the object that implements, that actually implements the interface that provides that NFT standard.
00:03:33.294 - 00:04:17.754, Speaker A: You'll notice that it has a few pieces of state, it has a mapping of UN two hundred and fifty six s to addresses. Those are owners of various token IDs. It's got approvals and balances and all of that good stuff, right? All the stuff you would expect from that standard. So from the perspective of somebody actually using Stylus, you just declare the various pieces of state that you want, oftentimes by just copying and pasting whatever solidity definitions that you like into your code. And you use this special macro called Soul Storage for it. Definitely feel free to read the code in further detail later to really grock like all the ins and outs of it. But you're just going to notice just from a high level, like looking at this together, we've got events that are declared much the same way as in Salinity.
00:04:17.754 - 00:05:11.806, Speaker A: We've got errors and all of that good stuff. And what's kind of cool about Rust is the way the methods work is similar. So there's this external macro that we often apply and that actually allows you to declare each of the methods of your Smart Contract and have them be exposed to the world in the same way a Solidity Smart Contract's methods are marked external. So when you look at these Rust definitions, like for example, this name, or this symbol, or this balance of right, this should look eerily similar to what you would see in Solidity, right? Well, here's the cool thing. You can actually call it from Solidity because under the hood, the Stylus SDK uses the same Solidity abi. Every contract written in Rust really just looks like a solidity contract. And I say rust here.
00:05:11.806 - 00:06:25.778, Speaker A: But of course the Stylus SDK has other languages too. And so what that means actually, by the way, is that without any modifications to a Dex, say like Uniswap or pick your favorite, right, you can actually deploy and list Rust smart contracts like Rust, Tokens, Rust, NFTs, whatever, to these standard protocols without those protocols having to have any kinds of modifications. So you just write your code in whatever language you like and then from the perspective of the chain, everything just looks like, you know, different methods do different things like transferring the NFT around or approving other accounts to be able to spin the NFT on your behalf. That's a pretty dangerous thing, actually, as numerous exploits have shown. But the really cool part about this is like this standard, this ERC 721 standard that you're very familiar with, if you've ever worked with NFTs before, can be replicated in different languages. And all that really looks like is just providing definitions for each of those mechanisms or each of those methods in Rust or in whatever language we're thinking of. And you'll actually notice that the Stylus SDK that you can download on that page has all of the affordances you would expect to have in an EVM environment.
00:06:25.778 - 00:07:18.614, Speaker A: So, for example, you're actually able to emit logs and you're able to well, you can't really do this as easily in Solidity, but you can print to the console and stuff. There's all sorts of really nice things that you're able to do like inspect your message sender or transfer value around, have payable methods, a lot of great stuff. So I strongly recommend reading the ERC 721 file under the source directory for a bit of a nice parallel side by side. But there's actually more that we're able to do because this is Rust. So if you actually go to the Art Rs file, you're going to see that together we're going to make some NFTs here. So because this is Rust, which has like really nice low level types and stuff, you can actually do things like import an existing image library and create PNGs from your application on chain. That's right.
00:07:18.614 - 00:08:25.658, Speaker A: The NFT that we're going to be making today is entirely on chain, so there's no hash that it stores and some other website that's trusted presents the data or whatever. All of this stuff happens on chain is fully generative and just has all that censorship, resistance, all those great properties that you would have of a fully on chain product. And what's cool about it is instead of having to say in Solidity, right, like do a bunch of low level assembly code, you just use familiar programming paradigms and nice high level construct when working on your stuff. Okay, so from the purpose of today's tutorial, and you'll see this also on the GitHub repo, there is a function that we're going to modify together to create new NFTs. So there's this generate NFT function and it takes as an input the token ID. So that's like every new NFT has a unique identifier and that Identifier you can use to generate different kinds of art. And you'll see that in this example project, you're able to generate an image and then make modifications to that image in a procedural manner.
00:08:25.658 - 00:08:56.834, Speaker A: So here we're drawing a gradient, we draw a line on it, then we draw another line that goes from this point to that point. We draw an ellipse. And let me just actually show you what that looks like. So what's really cool about this is because this is Rust and you have access to the console, we can actually print our NFT out. So take a look at this together. Those steps that I showed earlier, we have well, from the top left corner to the bottom right, we have the gradient line. This was that draw gradient.
00:08:56.834 - 00:09:52.170, Speaker A: And then we have various lines to make the eyeballs in this picture and then the ellipse to make the smiley face. And what's so cool about this is it shows that the future of actually working on blockchain applications is one where all the familiar tooling that you already have is much more easily accessible, right? Like if we're able to have languages like Rust, we get test cases from Rust and stuff like that. And I'm actually using that to generate different versions of this NFT. You'll notice that in the code right now, the only way it varies is the color it uses for the smiley face. But hey, you can notice here that with different Identifiers, I can each time print this out. So what's really cool about that too, is it means that debugging and working on your NFT is actually really straightforward because you actually have access to a really nice console where you can do all of the things that you'd expect in tracing and all of that good stuff. So you can just use a simple command which you'll see in the GitHub repo to print your NFT out.
00:09:52.170 - 00:10:23.714, Speaker A: And by the way, here's actually a website that's showing them the internet's. Kind of a problem, but I'll get it to reconnect. But the cool thing here is when you guys using that GitHub repo to pull your NFT, it's going to show up on this web page. So if someone wants to draw something and edit that code together, you're going to be able to actually change what's on this screen. So that's kind of fun. And how this is literally working is it's just reading the blockchain, looking for any deployments of this contract. Let me actually show you what it looks like to deploy it.
00:10:23.714 - 00:10:59.966, Speaker A: Okay, so assuming I have Internet, we're going to make sure you actually have this really cool tool called Cargo Stylus that we use. The installation instructions are there, but it's really simple. It's just a single line. But what Cargo Stylus lets you do is, well, you can check and deploy transactions. So when you're programming your code, it's often good to run test cases to make sure things work. And what this Cargo Stylus check tool does is it will actually go and make sure that if we were to go deploy this to the blockchain, that everything works. And if you go and you've made some changes to your NFT, you can run.
00:10:59.966 - 00:12:02.242, Speaker A: Actually, I need a private key file, so let me find that previously my history, you can actually run Cargo Stylus deploy and then point that to a private key somewhere and it will then go and deploy and then activate your NFT on chain. And what's so cool about that is in just like one little step, right, using these very familiar Rust tools, cargo is like the standard Rust tool. We're able to, with stylus, have just some minor extensions and then suddenly, bam, you've got all this great on chain goodness. So I think our goal today is this. Now that we've kind of like taken a look at various we've looked together, how the code works, I invite everybody to take a big deeper dive or whatever. Let's actually edit these NFTs together so we can just take this function, this generate NFT function and make whatever modifications we want. So, for example, maybe I want to add another line, right? All you got to do to do that is in your editor, you add another line that says line and then pick another position to start drawing from.
00:12:02.242 - 00:12:28.534, Speaker A: So maybe I'll start from the coordinate 810 and draw all the way to the coordinate, I guess 1516. That sounds fun. That'll be nice and diagonal. And you can pick what color you want to draw it in. Right? So maybe I'll pick another maybe I'll pick another hex color. Let's do pink. Let's do actually a nice stylus pink.
00:12:28.534 - 00:13:05.282, Speaker A: So the stylus hex code is e three six E. So that should draw a pink line if our reasoning was right. And so, well, let's just test it. Let's just make sure NFT works and hey, there it is. There's our pink line, right? And what's so fun about that is there's this really nice iterative feedback you can do when you're working in your work in Rust. Don't get me wrong, in the solidity world, we have hard hat, we have well, Truffle sunsetted, but you have all this great stuff, right, and you'll actually find that printing to the console or doing things like that are kind of high friction. It's not really super well supported.
00:13:05.282 - 00:13:55.830, Speaker A: And you have to use these kind of awkward function signatures. Well, in this paradigm, you can just do all the familiar stuff that you're used to. And by the way, that includes with Debugging and all the familiar tools, we're soon to release the ability to do GDB on the blockchain. So you'll be able to like when you're in the middle of your smart contract, if something goes wrong, you might want to go jump in and see what exactly went wrong. Well, you can then fire up GDB. This is a very common debugger that people use in Rust or C, et cetera, and just go see for yourself what exactly went wrong and step through it and use all that without having to learn new tooling and stuff. Okay, so I think since we've looked at this together, we're just going to go around the room and help anyone who wants to set up an NFT, do so and yeah, get these deployed and shown up here.
00:13:55.830 - 00:14:00.130, Speaker A: So that's part one of the talks. Let's collaborate.
