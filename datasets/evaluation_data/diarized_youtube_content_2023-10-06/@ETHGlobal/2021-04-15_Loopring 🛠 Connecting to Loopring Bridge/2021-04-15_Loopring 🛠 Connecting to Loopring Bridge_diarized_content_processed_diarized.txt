00:00:10.250 - 00:00:25.200, Speaker A: Welcome, everyone, to the Connecting to Loop Ring Bridge workshop. Joining us today is Bret and, yeah, I'm going to hand it over to him to give a quick introduction to himself and kick the session off.
00:00:26.890 - 00:00:45.020, Speaker B: Okay. Hey, everybody. I'm Breckt. I work at Loop Ring. I'm working on the Alt protocol side. So I helped create, like the ZK roll up that we are running now on Mainet. So we are a layer two depth specific layer two.
00:00:45.020 - 00:01:41.914, Speaker B: And we have been working on some cool features. One that I'll be mainly talking about the loop ring bridge and like, the different design patterns which are utilized by the bridge. And also one of the other challenges is, of course, also the Block Explorer. So we will have a subgraph which is now still being developed, but it's almost ready, and it's ready enough so people can actually already use it and start building a UI for a Block Explorer. So, yeah, let's start with the presentation about the Loop ring bridge. Let me share my screen. All right, well, there's loop ring first.
00:01:41.914 - 00:02:12.520, Speaker B: The basic stuff out of the way is loop ring Ziggy roll up. So we can do only a couple of things. So we can do transfers, we can do order book trading, and we can also do EMM trading, which is already quite a lot. So most people those are basic stuff that most people want, and so those are already available completely on layer two. But sometimes people also want to do other stuff. Of course. Yeah.
00:02:14.330 - 00:02:20.220, Speaker A: Emily, maybe you just want to present full screen. Present full screen.
00:02:20.990 - 00:02:55.054, Speaker B: Present full screen. Okay. Present better. Okay. So, yeah, there's lots of stuff to do on Ethereum. And if you are on layer two, then you probably also want to do some of those things. And the good thing is that most layer one applications actually expose functionality by using a token.
00:02:55.054 - 00:03:56.530, Speaker B: So if you want to deposit to a vault, then in most cases you actually get another token in return. So it can be done with a trade. On layer two, we can actually use the basic building stuff that the basic blocks that we have on layer two to actually do lots of stuff that are still on layer one without actually having to migrate everything over to layer two. And of course, there will be multiple layer twos that will be going live now and in the near future. And people will want to move from and to loop ring to and from those other L two S. So otherwise people have to like, if they want to move from loop ring to another L two, they would first have to withdraw and then do another deposit to the other L two. And because the gas costs are high, even that could be quite expensive just doing that for each user independently.
00:03:56.530 - 00:05:11.710, Speaker B: So if you have a system where people can actually do lots of stuff together so we can actually do like one single l one operation, then yeah, the gas cost savings are high. This design is actually called like D five pooling in some cases of a mass migration. So those are the terms that are often used for describing these features. Okay, so the good thing is that we are a ZK roll up and ZK roll up is actually very well fit for doing these kinds of l one interactions because we use a validity proof. So unlike some other L two S, we actually have fast withdrawal times because once a block is on chain and the block is validated with the validity proof, then we are sure that everything is valid and we can actually change l one state immediately. So we don't have to wait on any fraud proof or something like that before we can actually change l one state we can do it immediately. And if the validity proof is submitted next to the block, then we can do everything at once.
00:05:11.710 - 00:06:16.882, Speaker B: So we can do l two block validation and at the same time we can do l one transactions. So that just makes the design a lot easier because otherwise there's like the extra delay and there can also be extra reverts. So if a revert is possible with a fraud proof, then all the l one interactions that were done need to be reverted as well, which is kind of like very hard to do. It's also very capital efficient because there is no lockup. There doesn't need to be any kind of liquidity providers which can actually do these, which actually provide funds quickly with optimistic roll ups. And even our ZK roll ups, we have these extra liquidity providers which can make it even faster. But yeah, you need to have those liquidity providers to facilitate that.
00:06:16.882 - 00:07:33.774, Speaker B: But with ZK roll ups, those aren't really that important because the basic flow is actually good enough in most cases, especially if there are a lot of transactions. So in Zeker rollup you mostly want to wait until you have quite enough transactions to actually fill a block. So it's cost effective to submit the block on chain to do everything. But if there are lots of transactions, we can actually submit lots of blocks very quickly. The delay is very short. But the one caveat is that if we do these l one transactions next to the l two transactions, then if we modify L two state in some way, which depends on how the l one interaction finishes. So if you want to swap, let's say, one ETH for one bitcoin, and we really want that to happen on layer two, then because there is a delay between doing stuff on layer two and layer one, there could be a chance that the exchange rate already changed once we actually submit the block on layer one.
00:07:33.774 - 00:08:42.900, Speaker B: So if the exchange rate like, let's say one ETH is now two bitcoins, then that's a problem. Because if we did the trade on layer two for one bitcoin for one ETH, then the difference between the exchange rate needs to come from somewhere. And if we would just resubmit the block with the updated exchange rate, then we would have to revert state and all that stuff. So, it's just much simpler if we can just depend on the L one state to be deterministic, or if it's not deterministic, use some design which makes it deterministic. And these kind of designs, I will talk about these now. So, the first naive solutions to get these DeFi tokens, like fault tokens or other tokens no matter what on there too, is to have liquidity providers. So, if you want to put some money in urine in a urine vault, like you want to put some ETH in a urine vault, you will get Y ETH back.
00:08:42.900 - 00:10:03.550, Speaker B: And if there is some liquidity provider which just creates all those orders on layer two, so provides layer two directly, then this works. So people can just trade against this liquidity provider and get their Y tokens back. So, it's the same thing as just depositing on layer one directly. Of course, the main downside of that is that it's quite capital limited because this liquidity provider needs to have enough funds to actually facilitate all these trades. And it's also quite capital inefficient because this liquidity provider needs to have these funds on hand and do the L One interactions as needed as they are, as users want to trade on L two. So, if you have enough money, it's actually quite a good system, especially on ZK roll up because you can move funds around quite quickly, but it's still not that good because, yeah, you really don't want to count too much on liquidity providers if you don't need to. So, the first way to solve that is like what we call the single phase converter, is to actually do the trades on layer two with flash loans.
00:10:03.550 - 00:10:43.162, Speaker B: And in our case, we can actually do flash minting. So the good thing on layer two is that we can basically create tokens out of thin air on layer two no matter what. So we don't even have to use L One flash loans on layer one, or we don't even need to have access to these tokens at all. So these tokens may not even exist on layer one or anywhere. We can just increase the balance on layer two. And as long as we are able to repay that balance, then everything works out fine. So, that's what we have also implemented on our ZK roll up.
00:10:43.162 - 00:11:45.550, Speaker B: We can flash mint whatever amount of tokens on layer two that we want, and then just a basic constraint that these have to be paid back. So, let's say that we want to facilitate lots of trades between a token and the Y token from a urine vault, for example. Then there is some party which will likely be the block producer, which just bundles all of these transactions together. So without any capital needed, he can just do all these trades by flash minting the necessary amount of Y tokens, then collect all the tokens that these Y tokens need. And so these can be like hundreds or thousands of just simple L2 trades. Then, because the block producer operator has collected all these funds, now these funds can be withdrawn, then the actual deposits to the L One depth can be done. So in this case, urine.
00:11:45.550 - 00:12:39.514, Speaker B: Let's say there's 100 people that want to put one ETH in the Urine vault. So there's 100 trades between one ETH and one Y e. The operator collected one ETH, in this case withdrawals. This 100 ETH does the actual conversion in the Urine vault. So 100 ETH is swapped against, let's just say, to keep things up of 100 Y e. And then, because 100 y ETH was first minted to facilitate all these trades, the 100 y ETH can now be used to repay the initial flash mint to make the amount flash minted zero. So that's of course, the important constraint for the flash minting.
00:12:39.514 - 00:13:26.474, Speaker B: Everything that was flash minted can be easily repaid like this. So this works for any kind of token. So if there's just one token conversion to one other token conversion, this system works. But there is a problem if the exchange rate isn't that deterministic. So it works well for something that has a fixed exchange rate. So something like a swap from ETH to wrapped ETH, of course is a perfect example because that will always work and the exchange rate is fixed. Something like Ave Staking I think is also always like one Ave token or one staked Ave token.
00:13:26.474 - 00:14:06.682, Speaker B: So there are some cases where this works perfectly and it's very efficient. But if the exchange rate can actually change on L One all the time, then there is a problem. Because we flash mint some amount of tokens, we withdraw the main token that's used for the swap, and then this exchange rate is done on L One. But we don't know how much tokens we actually get in return for the tokens that we have withdrawn. It can be like exactly the amount that we expected. It can be more than we expected, which is also fine. It can also be less than the amount of tokens that we expect.
00:14:06.682 - 00:14:53.686, Speaker B: And then we will have a problem with repaying the amount of tokens that we flash minted. Either this fails and we have to revert all kinds of stuff. So the block needs to be reverted and we have to recreate the block, regenerate the zero knowledge proof and all that kind of stuff. So we don't want to do that. So if there's too much, the amount of tokens is not enough, then the converters will also have some extra funds laying around here to help pay repay the flash minting. But of course, that's also not ideal. So the use case for this is limited if we don't fully control this L One depth.
00:14:53.686 - 00:15:37.160, Speaker B: So if you fully control the L One depth, there's also no problem, because if we do these trades on L2 and we are the only party that actually can change the exchange rate on L One, then it's still fully deterministic. So in that case, there's also no problem. So it can work in quite a lot of cases, but in some cases, especially with existing L One dots on L One, in quite a few cases, there are potential problems. So some extra improvements are needed to make it more deterministic. Yeah, maybe I'll pause a little bit to see if there are any questions.
00:15:44.350 - 00:15:48.010, Speaker A: If not, there is a question in the chat.
00:15:48.990 - 00:16:55.810, Speaker B: Let me see. Okay, what sort of ZK roll up tech are you guys using? For example, ZK sync is using ZK snarks and Plunks. How is your roll up process different? Well, it's quite similar now to ZK Sync in that we use zkSNARKs. ZK sync uses Plunk We still use Grot 16 for the proving system, but yeah, otherwise they are quite similar. The main benefits of Plunks is that they only need a universal trusted setup, and we use Grot 16, which still needs a circuit specific trusted setup. Okay, let's continue with the double phase converter, which solves the deterministic part of the exchange. So it may look a little bit more difficult, but it's still quite easy process.
00:16:55.810 - 00:18:03.560, Speaker B: It's just doing things twice instead of a single time. So instead of doing the swap immediately from the token to Y token, we do the conversion in two steps. And to do that, we actually can add some vault specific logic to converter. So the first thing we do is actually swap the token for the converter token, which is just a one to one exchange ratio. So if you want to put one ETH in urine, then you will get one V E for this converter here. And this token just represents your share in the conversion process. So if there are 100 people that want to put one ETH in urine, then, yeah, if you put one ETH in and there are 100 people, then you have 1% of the share in this vault, which is still one ETH at a time.
00:18:03.560 - 00:18:40.290, Speaker B: So that's what happens in the first phase. So you just do one to one swap for this vault token, which is, of course, like, fully deterministic. The exchange rate is always one to one, and that's also the only thing the converter can do. So nobody else can actually access this converter. And then we do the actual L One interaction. So we go from the token that all these people deposited, we do one L One interaction to do the swap, and then we get the Y token back. And this can be any number.
00:18:40.290 - 00:20:09.438, Speaker B: So if there's 100 ETH, then the amount of Y tokens we got might be like 95 Y e or might be 105 Y e, but it doesn't matter. It doesn't matter, of course, for the exchange rate, but it doesn't matter for the system, because every user on L two still has their shared tokens, which are exactly the amount of tokens that they put in. So if you put in 1% of all the ETH, then you will have 1% of all the Y e that this converter had converted. By doing that, all the operations on L two are fully deterministic in the first phase and the second phase. So because this is a one to one ratio, so all the traits here on the left side will be simple. So one to one swap and then all the interactions in the second block that will be created after this L one interactions was done will also be deterministic because we will create this block after the actual L one interaction has been done. So in the second part, we just exchange the shared tokens against the actual tokens the people want and then withdraw again, use Flash Minting to aggregate all these trades on the other two and give the people the actual token they want.
00:20:09.438 - 00:21:24.438, Speaker B: So instead, compared to the single phase converter, this conversion needs two phases. And because people always have access to their share token on L2, even if we wouldn't submit the second block, they can still withdraw their share token to L one and actually get their Y token back themselves on layer two. And that could happen if the operator stops doing things or doesn't actually want to do the second steps, like the distribution step. If somebody like the operator doesn't want to do that anymore, for whatever reason, then people are still sure that they can get access back to their money. Okay, so let's go to the third design. And this is the design that actually will be used for the workshop, and that's the loop ring bridge. So compared to the converters, the converters are limited in a way in that they can only do token swaps represented in some kind of sense.
00:21:24.438 - 00:22:19.146, Speaker B: Also, it's always the case that one token is exchanged for another token, which is often the case, but sometimes, of course, it's not the case. Let's say you want to move from one roll up like you want to move from loop ring to another roll up, then you don't swap tokens. You actually move the tokens from one place to the other. And to do that, people can use the bridge design. So instead of doing L2 trades on l two trades, they actually do a simple L two transfer to the bridge. And by doing this L two transfer, they don't just do the L two transfer immediately like any other kind of L two transfer. So they do like a conditional transfer to the bridge account, and only when it's actually processed by the bridge, the transfer will be valid and the bridge will use those l two transfers to actually do stuff on layer one.
00:22:19.146 - 00:23:27.358, Speaker B: So all the users that want to interact with the bridge, first we aggregate all of them. So all these transfers are accumulated in one account and then we do single withdrawals for each distinct account. So if people want to interact with urine, if people want to interact with uniswap, people want to move, to roll up, it doesn't matter. All the withdrawals are batched together in one withdrawal per token, which makes us very efficient. And then once they are in the bridge, then we actually do the necessary L one operations. So these connectors are just simple contracts which do the conversion from the aggregations to the l one interaction. So if there's like 100 people that want to interact with the urine connector, then this urine connector will just get as input a list of those 100 users with address the token they deposited and the amount.
00:23:27.358 - 00:24:18.302, Speaker B: This connector can do whatever is needed on layer one. So probably just run over the list, do the l one interaction one time for all those users and then redeplow it back to the users on layer two. And that can be done for Enmel one DAP which has the necessary connector. And this connector is very easy. So, yeah, it's just very efficient because all these connectors actually work on the same bridge contract and the bridge contract contains all the funds. So once the urine connector contract is called, which will mostly be done with a delegate call, so there's delegate calls here to the different connectors. So these can just do whatever logic is needed without having to move funds around a lot.
00:24:18.302 - 00:25:14.794, Speaker B: So once they are withdrawn, the connector can be executed with a deleted call. The necessary funds are directly available in this contract and once the swap is done on this contract, the necessary funds will already be in the bridge and they can be batch deposited back to the users on layer two, which is also just done with simple transfer. So all the actual l one token transfers are batched in a batch deposit and then all the different users get their money back on layer two with simple transfers, which are very cheap. So here's a little bit of a different batch deposit line. It's just that these are like interactions that originate from layer two. So these layer two people want to interact with layer one and they can do something like which we call bridge calls. So they say like, I want to interact with the urine collector.
00:25:14.794 - 00:26:06.978, Speaker B: Okay, we will just aggregate them all and do those. But there's also of course the case where people from other ZK roll ups or other L two S want to join loopring. And for that the bridge contract had just a simple function called that's called batch deposit, which takes just a list of all the deposits that will be handled in the same way. Like this deposit is done. So if there's 100 eat for 100 users, then first the 100 ETH will be done by a single deposit to the exchange contract to the ZK roll up, and then all those other transfers will be done on layer two. Very cheaply using layer two transfers. And so the cost savings here are that every normal deposits that user does is like a full layer one transfer.
00:26:06.978 - 00:26:41.018, Speaker B: So it's quite expensive. And by using the batch deposits, we only do the costs once for all these users together and then just cheaper l two transfers. Okay, let's see, no answers in the chat. Let's continue. Okay, not that much time anymore. So, yeah, the converters are very cheap mostly, so they only need like one or two l two traits per user. And the l one overhead is always the same because all the aggregation is done on l two.
00:26:41.018 - 00:27:37.774, Speaker B: And so not much is left to do on layer one next to just the main l one interactions that's needed for the bridge account, mostly the same. Also like one or two l two transfers per user. Also this fixed l one overhead to do the actual l one operation. But there are also some extra l one overhead because some extra aggregation is needed on the bridge contract. So we have to run over all these different bridge interactions and then pause them around to the necessary contracts, which makes it a little bit more expensive, but also much more flexible because the bridge can do more stuff than the converters, which are mainly like token swap batching. The fees, I think I'll skip that, but the fees are done in a way that makes sense. I'll just skip this one because there's not enough time.
00:27:37.774 - 00:28:47.560, Speaker B: Okay, the bridge interface is very easy. So to do a batch deposit to the bridge, so people want to move funds from another layer two or even a centralized exchange to loop ring. They can just call this batch deposit contract, which will do all these deposits just passed in with a list as efficient as possible. So if there's like one token that's need to be deposited for this list, one actual deposit will be done and other deposits will be done with layer two transfers. But if there are multiple tokens in this list, then yeah, multiple deposits will also be done, but the least minimum amount as necessary. For the bridge conductors, there's also just two calls and just this main one. Basically the other one is just for the fee system, which I'll drop now, but the process calls is just like, okay, all these bridge calls were collected in the bridge and this function just gets a nicely formatted list sorted on the group.
00:28:47.560 - 00:29:46.230, Speaker B: And the group is just like a kind of l one interaction. And then all the token transfers that were done on layer two. So it's just what you'd expect. So the owner, the token amount, some extra user data, so some extra custom logic can be done per user in the connector and some less important data. So I'll first little bit of time so I'll show a sample first of such a connector. Nope. So this is how you would create a connection to a urine vault uniswap connector or some kind of token swap connector.
00:29:46.230 - 00:30:41.098, Speaker B: You just implement the process calls, you get the groups the group is like this is like a swap example, it mostly follows like a uniswap layer one depth. So the group is just the EMM that the user wants to interact with. So if it's ETH against LRC, then this would be the group and all the users that want to do this LRC swap are aggregated together in this group. So the first thing we do is run over all the groups. We decode which AMM pool that we want to interact with and then run over all over the transfers that were done by the users. We check what the minimum amount is for the total amount. We check what the slippage is basically.
00:30:41.098 - 00:31:37.302, Speaker B: So we have this total combined which is transferred by users but every user actually has a custom slippage limit. So we check here if this slippage limit is reached, if it's set, so if the amount that is received by the user is less than expected then we actually won't do the trade for that user. So we just skip it and we return the user's initial funds instead of the swap token. So that's done here. So we check if it's valid. If it's valid is okay, then we actually do the swap here with the funds from users that achieved the minimum slippage and then we run over all the transfers. So if the swap was successful we transferred the new token out and with the new amount that was exchanged.
00:31:37.302 - 00:32:39.920, Speaker B: But if it's not valid we just return the amount that the user transfers to the bridge. This is what I was also talking about, the deterministic part. So this case can handle both cases. So the swap here with uniswap or whatever can actually fail and user tokens will be returned as if. So we don't depend on the swap to actually function correctly so it can fail and even if it doesn't fail we still have this fallback method with the slippage. So yeah, lots of flexibility there and not much time anymore and then all these resulting transfers are just also returned to the bridge. So most of the implementation details are just handled by the bridge and you get a nicely formatted input so the logic can be quite easy.
00:32:39.920 - 00:33:45.640, Speaker B: There's also like a migration example which is basically the same thing but because it's a migration sample, you don't actually return any transfers because funds are moved out of the exchange and none are returned. So that's the main difference. So let's quickly end this workshop. Okay, the main challenge that we have two challenges. The first is the block explorer front end for the looping subgraph. So on the discord, I shared the link with the subgraph, so it's actually failing because there's some problem with there's a bug and subgraph, but it doesn't matter because it only fails on a block that's quite there's enough blocks that are processed, so there's enough state available to actually start building the front end. And the subgraph will be updated once things are fixed, but it's ready to build on whenever you need.
00:33:45.640 - 00:34:49.820, Speaker B: And the second is of course, use the loop ring bridge to interact with another roll up or another L one depth. So we don't really want to give too many IDs. You can be creative. So if you think an L one depth is very well fit for this kind of system, then, yeah, just let us know what you are planning to do. We like creativity here, so of course the more basic ones would be like doing a connector for uniswap or doing a connector for luan vaults or interacting, like doing a mass migration for something like Hermes, which has support for that. Yeah, lots of possibilities there. Just don't start doing something that may not work or we are not that interested.
00:34:49.820 - 00:35:03.710, Speaker B: We have $5,000 in prizes and there's mostly be like creativity and how well the contracts or the web UI is developed.
00:35:08.130 - 00:35:24.730, Speaker A: Great, thanks so much, Bret, that was a really great session. And if anybody has questions, don't hesitate to reach out in the sponsor loop ring channel. Yeah, and thanks everybody for joining us today. And yeah, once again, thanks Bret.
