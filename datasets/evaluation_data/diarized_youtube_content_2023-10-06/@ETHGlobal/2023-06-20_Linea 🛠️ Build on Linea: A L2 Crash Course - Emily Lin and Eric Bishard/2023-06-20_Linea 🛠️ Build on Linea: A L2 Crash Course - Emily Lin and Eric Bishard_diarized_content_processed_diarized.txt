00:00:07.210 - 00:00:33.910, Speaker A: Hi guys. I'm Emily. I'm the developer advocate at Linear and I'm here today to give a crash course on L two S Linear and then hand it over to my colleague Eric to actually teach you how to build a DAP. But yeah, let's get started. I'm going to make my face a little bit smaller, bringing it off to the side and start off with this statement. Linea will be a type two ZK roll up. What does that mean? I don't know.
00:00:33.910 - 00:01:15.090, Speaker A: Let's go from the very top. So, blockchain trilemma, what is it? So the blockchain trilemma is essentially a pick two situation between security, scalability and decentralization. Essentially, to build a secure and scalable blockchain, you'll have to sacrifice decentralization. However, if you want to build, for example, a secure and decentralized blockchain, then you have to sacrifice scalability. That's the problem. What does the save the world today? Well, with Ethereum, we've chosen security and decentralization. However, sacrificing scalability means that we've chosen to increase gas prices as well as decrease transaction times.
00:01:15.090 - 00:01:48.174, Speaker A: This jeopardizes the adoption of Ethereum by pricing out users as well as degrading our user experience. That sounds kind of bad. How do we solve this? Well, it's called the L2 solution. So before we dive into L2 solution, let's actually talk about layer one. So layer one is the underlying foundation and base blockchain. So this is going to be comprised of the node operators, the block producers, history of transaction data, consensus mechanism, et cetera. Examples basically easiest is going to be bitcoin ethereum, avalanche, things like that.
00:01:48.174 - 00:02:26.234, Speaker A: So here on the left side, that is layer one. Once we get into L2, then L2 is basically a scaling solution that increases transaction speed and throughput while fully or partially deriving its security from Ethereum. So essentially what it does is it pulls off that execution layer away from the layer one, but then posts all of that data back onto Ethereum for data availability. So basically, the most popular implementation of L2s are going to be roll ups. So pretty self explanatory. You can think of it. Instead of submitting all of your transactions, blah, blah blah blah, you can roll them up together and submit it once.
00:02:26.234 - 00:03:09.282, Speaker A: Right? That's kind of the most popular and winning implementation right now. Again, I do want to really call out that part about posting its transaction data back to Ethereum, making Ethereum that data availability layer. That is what differentiates a L2 scaling solution from a scaling solution such as a side chain, right? So for example, Polygon proof of stake is a sidechain that is not a L2 a scaling solution because it has its own consensus mechanisms, its own security and trust assumptions. So L2 is a far more secure scaling solution than a side chain, for example. But anyways, that's the leveled L two space. That is what linear is, a scaling solution. And now that that has been defined.
00:03:09.282 - 00:03:37.470, Speaker A: Let's move on to the next piece. So I talked about roll ups, but what exactly is a roll up? Well, the anatomy of roll up is made up like this. There is an on chain contract on the L1. Basically, it stores the roll up blocks, monitors the state, tracks deposits. There's the off chain VM. So this is where that computation is happening for pulling off that execution layer. And then the last piece here, kind of an umbrella term operators validators, aggregator, sequencers.
00:03:37.470 - 00:04:23.294, Speaker A: They are essentially responsible for aggregating the transactions that are coming in, compressing the data, and then publishing that block back onto ethereum. In terms of key kind of vocabulary words you'll need to know when talking about L two S, we have deposits and withdrawals. So deposits are when we move ETH from L One to L two. The way you do that is you lock up ETH on the roll up contract. An equivalent amount of ETH is minted and then used on the L two. And the withdrawal process then is if I want to pull it out of L two, essentially it burned on linear, the L2, and then it's going to be released back onto the L One, an equivalent amount. So anyways, now we kind of know what a roll up is, how it's made up.
00:04:23.294 - 00:04:59.482, Speaker A: Let's talk about the two different types, right? So there's two types of roll ups based on how they actually verify whether or not the transaction data is true or false. So the way a roll up works, actually when you submit that data, how do you know that the data you're being submitted is correct? There's two popular ways of going about it right now. So there's optimistic roll ups. In this case, transactions are just assumed to be valid. So rather than checking anything, we're just going to say, hey, we're going to be optimistic. It's correct. However, we are going to, before fully publishing this data, have a seven day challenge period, basically.
00:04:59.482 - 00:05:37.378, Speaker A: And during the seven days, anyone can come and submit a fraud proof to see whether or not indeed this is true. Obviously, this can be a problem if you want things like instant liquidity. There are existing workarounds such as trusted bridges which will do that for you. But however, they don't handle cases like NFTs. Anyways, examples of optimistic rollups include optimism, arbitram, and base. So then we move into the zero knowledge roll up space. This is where linear sits, right? So instead of saying, hey, let's wait seven days for a fraud proof, let's actually, just on submission, submit a validity proof that immediately says whether or not this is true or false.
00:05:37.378 - 00:06:07.394, Speaker A: And this is verified by a separate verifier contract on ethereum L One. Note that because of this way ZK roll ups do not require a challenge period, unlike optimistic roll ups. And I do want to also note one common misconception, I think especially for people who are just entering the space. ZK people think a lot about privacy, which is absolutely the use case. However, ZK rollup is not often a privacy solution. It is a scaling solution. Right.
00:06:07.394 - 00:06:46.026, Speaker A: So examples of ZK rollups scaling solutions are linear. ZK, sync, polygon, zkvm scroll and StarkNet. So yeah, now that we've gotten to that point, let's actually talk about Zkems now. So what is a Zkvm? So Zkvm is a zero knowledge Ethereum virtual machine which basically executes smart contract transactions in a way that uses existing Ethereum infrastructure and also in a way that ZK proofs can understand. Right. So essentially the way the prover works is going to be we need to submit computer programs and translate that into math. Right? So that then pulled out a proof that says true or false.
00:06:46.026 - 00:07:06.658, Speaker A: Right. How do you do that? That's something called arithmetization. To actually do that is very difficult. So that's actually why we have kind of four different types of Zkebms now. So starting from kind of the very top, we have type four. This is going to be high level language equivalent. So this is I can write in solidity, I can write in Viper.
00:07:06.658 - 00:07:51.330, Speaker A: However, it's compiled down to some different language that is explicitly designed to be friendly for ZK proof. So it's friendly for that Arithmetization. Things like this are going to be like StarkNet ZK sync. The issue here is because it is not 100% like, the EVM tooling changes, right? So for you as a developer, some opcodes might not be covered. Hardhat has to have a very specific different plugin just to understand the code that is coming from, like ZkSync for example, as you move further down, type two is going to be language equivalent. I could write in solidity and bytecode equivalent. What this means for as a developer is nothing changes.
00:07:51.330 - 00:08:14.362, Speaker A: It's exactly the same. The real draw here is like network effects, right? So none of my tooling needs to change. I don't need to train a whole new slew of, I guess, engineers. If I'm building on Ethereum, I can also build on linear, I can also build on Scroll, I can also build on polygon, KVM. It's all interchangeable. That's really beautiful. So that's type two.
00:08:14.362 - 00:09:06.106, Speaker A: Type three you can think of as more of the transitionary period on the way to type two. And then type one is going to be fully Ethereum equivalent so that's any part of the Ethereum system is not changed. There's a few ways that type two and type one are a little bit different. I think the primary way that most people notice a difference is probably the way the data is hashed when put into guess. It hasn't been the most materially problematic for most developers. Which is why I think linear sits in the type two space because we say that is where we win in terms of being able to be easily translatable for ZK proof to understand, whereas also taking advantage of the network effects of sitting within the ethereum ecosystem, not changing kind of the underlying tooling architecture that is there. Cool.
00:09:06.106 - 00:09:49.206, Speaker A: So now that we have that, here's one last slide actually to kind of give you a visualization of the trade offs. So basically compatibility versus performance. The closer you are to the ethereum, the harder it is to get that performance in a ZK proof. However, I do want to note that actually Linear statement is that that's not necessarily the case. We are doing some really interesting things on the Arithmetization and Prover side that I think makes us feel confident that we can say we can get to the good speeds of a type four as a type two Ckevm. So, yeah, that is where we're at. But anyways, moving forward, let's actually summarize with like linear itself, right? So Linear will be a type two Ze roll up.
00:09:49.206 - 00:10:22.974, Speaker A: Hopefully all of you guys understand all of what that means now. But let's actually dive in a little bit more specifically. Right? So Linear is a product of four years in research and development at Consensus. We are on the way to a type two Zke EVM powered by an award winning prover providing industry leading speed. I pulled these stats maybe like a little two ish three ish two ish months after we went public testnet. But yeah, we are at like what? Almost 20 million quant transactions now. I'm sure by the time whenever you're watching this video today is what, May 26, check out our Explorer.
00:10:22.974 - 00:11:07.730, Speaker A: It's probably much higher than this, but huge amount of volume, huge amount of attention. Why do you build on Linear? So why build on an L two in the first place? Right? So the first piece is we are a ZK roll up, right? So that means we have faster finality. While optimistic roll ups have challenge periods, right? When we think about building on a roll up, for example, we think about how much liquidity is on the roll up. So right now, optimistic roll ups are going to be the ones that win. They came in the earliest, there were the fastest to build to mainnet. However, do know that challenge periods can create capital Efficiencies CK tech is much newer, but people are joining in. So I think this number in terms of who wins in terms of TBL is going to be changing and I think it is going to be going to AZK roll up.
00:11:07.730 - 00:12:13.362, Speaker A: But the other piece is network effects, right? So especially as a dev, when I'm choosing to build, how do I choose where to build? Like the ecosystem? So that is anywhere from can I leverage existing tools that I'm using? Can I write in solidity? What is the developer friendliness like? What does the community look like? How is the support system? What do the docs look like? The other piece, as maybe as an entrepreneur trying to figure out where to build. I think a lot about how large is my addressable audience, and the last piece again, is like security, right? What are the trust assumptions that I'm making when I'm building on this l two. So again, factoring in that kind of like challenge period optimistic versus ZK play. So those are kind of the things that you would consider where does linear fit in that kind of story? Again, we're ZK roll up, so we have kind of the low gas fees, low latency, high throughput higher trust assumptions, no challenge period kind of aspect of that. Those are just table stakes, I think, right? Fully compatible with all DevTools. So that's the type two part coming in. I think the real differentiator here is going to be that default integration with MetaMask.
00:12:13.362 - 00:12:42.606, Speaker A: So if you guys don't know if you go into your MetaMask account, linear is actually already built in there. You don't actually need to do any sort of add network flow. That's actually a really smooth UX, I think a lot of times for developers, we're so caught up and that is a very normal button for us to click. So it's not scary. I don't have the number off the top of my head, but there is actually significant churn for the standard users flow when they're going through the process and they have to hit add network. It's a little shady. If you don't know what's going on, you're not going to do it.
00:12:42.606 - 00:13:15.062, Speaker A: So that's actually a really big, strong point that I think people some devs sleep on. At least I slept on it until I saw the numbers and I was like, oh yeah, that makes sense. Anyways, yeah, so that's linear. How to build on it, eric will take you into a much deeper dive, but just kind of briefly touch on it. Things you'll need is you're going to need girly ETH to transact on linear. So to do that, you can either get girly ETH and then bridge it onto linear, or you can sign up for an inferior account and actually drip it directly onto the linear network for your wallet. And then after that it's just swapping out your RPC.
00:13:15.062 - 00:13:50.278, Speaker A: It's like very easy. There's a public permissionless, one RPC girly linear build. I recommend actually just signing up for a free infuria account and using the infuria one to get your own self, kind of, because that way it's not going to be rate limited just in case. But anyways, for Truffle Hard Hat and Foundry super simple with dashboard, you can let me just see if I can do a live demo right now with dashboard. And so you can use this with Hard Hat as well. You'll just do a truffle dashboard like this. Cool.
00:13:50.278 - 00:14:23.970, Speaker A: And so if I wanted to deploy this on Gurley, all I would do is switch the Gurley network, hit confirm and connect to it and then do a truffle migrate. But actually I want to do this on linear. So I'm actually going to switch back. Cool. And then connect. Where am I? So I'll go to the code right here and the same thing. Truffle, migrate, network dashboard.
00:14:23.970 - 00:14:49.500, Speaker A: And that should basically be right here. Hit confirm and hit confirm. And that should have migrated deployed it on Truffle. And so you can use the dashboard with hard hat as well. Anyways, going back to my slides. Oh, why is this frozen? Whoops. Where are my slides? Here we go.
00:14:49.500 - 00:15:06.038, Speaker A: That's that if you want to see on hard hat. Again, very simple. Basically linear. Here's us using the public RPCRPC gurley linear build. You just swap it out, your code does not change at all. Same thing with Foundry. This one.
00:15:06.038 - 00:15:36.070, Speaker A: In this case, we're using the infura girly versus the public permissions. One without the infuria API key. Anyways, yeah, that's kind of all there is to it. If you want to get in touch, please contact follow me on Twitter underscore emjli n. Otherwise, linear build and consensus on Twitter as well. Here are a list of links. I'm going to now exit this video and pass it off to Eric, who will actually take you through the SDK and then show you how to build a DAP on linea.
00:15:37.850 - 00:16:36.298, Speaker B: All right, yeah. Thank you very much, Emily, for showing us how to get started with linear and talking a little bit more about what linear is all about. As I'm sure she told you, linear is just like deploying to ethereum. In fact, in this workshop, if you don't have any linear ETH, although I'll show you how to get that, you can actually deploy to Mumbai to test out the application. But I'm going to try to show you how to get linear ETH, which I'm sure she's already talked a little bit about that, but also how to set up a we're going to set up a VJs project. Actually, it's going to already be set up and we're just going to walk you through everything you need to know on how to get this app started, all the steps you need to go through, and then we'll review the code as well. So, yeah, without further ado, let's get started.
00:16:36.298 - 00:17:15.158, Speaker B: First off, I just want to share some links. So if you want to get this same repo and take a look at the branch that this specific workshop is on, it's tinyurl.com linear, sorry, tinyurl.com SDK linear as well. You can reach me at http junkie on Twitter. And if you want to install the MetaMask SDK into your own project, you can NPM install it at MetaMask SDK. So I'm going to go ahead and clear that out again.
00:17:15.158 - 00:17:54.862, Speaker B: Here is my Twitter. If you want to get a hold of me, if you have requests for features, if you just want to give some feedback, you can always reach out to me. And as well, if I see you or if you see me out at ETH Global Waterloo, feel free to come up, ask me any questions. We can take a look at code. I am the devrel for MetaMask SDK specific to JavaScript, but you can also use the SDK for other things like unity building games, all sorts of stuff. We're going to focus on JavaScript today. So the first thing we're going to do is take a look at the repo where you can find basically this branch.
00:17:54.862 - 00:18:41.298, Speaker B: So tinyurl.com Sdklinea will bring you right here and all you're going to have to do really is just follow the instructions here. So this branch of the Onchain SVG Workshop repo is a workshop that will walk you through an existing monorepo that has a blockchain project located in Apps blockchain that utilizes truffle to deploy solidity smart contracts. It'll allow you to allow us to mint on chain SVG tickets to a fictitious event that in our app is called ETH Atlantis. In no way associated with ETH Global event. Again, it's fictitious. We also have a client application in Apps Web and that's where our VJs react application is.
00:18:41.298 - 00:19:26.898, Speaker B: We do some cool stuff in there. We show you how to conditionally render UI, how to switch chains, how to programmatically do that stuff. And also the SDK allows you to connect to the MetaMask browser extension or MetaMask mobile. We also have a context provider in there and a use MetaMask hook to help you manage state in your React application. So that's really cool. And we'll even talk about some of the features coming up in the SDK that might not be available right now, but maybe by the time of ETH waterloo, since we're recording this a little bit early, some of those might be available, and some of those features might be available, but they can at least kind of point you in the right direction. And I can get you started here.
00:19:26.898 - 00:20:06.574, Speaker B: And then as you implement this into your own projects or work on our bounties, these other features you can know are just down the road. The SDK is kind of in developer preview right now. It's 0.30. And we're just going to walk through using that current version to make sure that we can connect to the MetaMask browser extension or MetaMask mobile on your phone. Let me go ahead and turn my phone on because we're going to need that here soon and yeah, so let's just go ahead and get started. And what we're going to do is first just show you how to get started in this application. There's nothing to build here.
00:20:06.574 - 00:20:51.462, Speaker B: Everything's kind of already built for you, but there's some configuration that we're going to need to do. So first off, we're just going to run this first command which is going to clone this repo down. We're going to switch into the on chain SVG NFT tickets repo or directory. And then we're going to check out that linear SDK branch next we're going to just open up in whatever code editor you want. I'm going to use Visual Studio code and then go ahead and close this terminal for right now because we don't need that. And at this point, we are just going to follow along in this README. And if anything changes between now and then, I will update this README.
00:20:51.462 - 00:21:13.518, Speaker B: So if it's not in the video and there's something extra that we do, I'll make sure that it's inside the README for you and potentially even update the video. But let's go ahead and get started. So the first thing that we need to do is NPM install. So let's go ahead and get that done. NPM install. And we're going to do that right from the root directory. This is a mono repo using Turbo.
00:21:13.518 - 00:21:54.266, Speaker B: So it will go through. It'll go into the apps web and blockchain directories, look at their package JSON install everything where it needs to be. We're going to have three node modules directories at the end of this NPM install. That's normal with turbo repo. Sometimes packages get hoisted into different areas. A little bit confusing to me at first when I went into the web looking for the MetaMask installation and it was in the main directory, but I've been reassured that this is exactly how Turbo repo works and there's a good reason for it anyways. So we'll let that go ahead and install and we'll kind of look at what our next instruction is.
00:21:54.266 - 00:22:34.394, Speaker B: And like I said, it's a developer preview. So what good is a developer preview without typos? Right? So the first thing that we're going to need to do if you're using version 0.30, you will need to go into your project into the Node modules directory here, find at MetaMask. And this isn't a huge problem, but if you're using TypeScript, it's going to mess you up. So just go into SDK. There's a package JSON find in here, this types definition, and just replace it. Basically, we're just adding this forward slash source.
00:22:34.394 - 00:22:57.350, Speaker B: Okay, someone forgot to put that in. We've already made a pull request. It's already being taken care of. When 0.31 comes out, it'll be there and it won't be a problem anymore. But I just wanted to highlight that just in case anyone checks out this video a little bit early. And when they install MetaMask or I haven't updated the repo by then, they just know how to deal with that.
00:22:57.350 - 00:23:28.606, Speaker B: So, yeah, it's supposed to be this instead of this. Okay. All right. Beyond that, you need to have an Infura account or a node provider. But in reality, right now, infura is the only one that's going to be able to connect you to linear, right? So Infura is part of the consensus suite of products. So is linear, so is MetaMask. So what you need to do is need to create a new API key and you're going to just use the web API and you can name it whatever you want.
00:23:28.606 - 00:23:58.690, Speaker B: And once you create that, you'll have a project here and you can click on it. And don't worry, this one will be deleted by the time you see this video. So don't use my key. Definitely set up your own. But also just understand here are all the connections, all the providers to your node for all the different chains that you might need. So here's linea right there's. Only a testnet right now, but again, we have Bounties to get you guys working on the testnet, to get you guys working with MetaMask SDK.
00:23:58.690 - 00:24:31.250, Speaker B: We need your feedback. We need to work with the developer community to know how we can make these tools. You know, if you wanted polygon, you could click down here and hit Mumbai so you can get the testnet string URL for that. And yeah, so we've got the API key copied. That's all we need from Inferior for right now. So I'm just going to close this out and we're going to go into our project and what we're going to do is we're going to update our env files. So we have a env file over here.
00:24:31.250 - 00:25:10.366, Speaker B: And what we're going to do is we're just going to rename this to env and at that point this project stops tracking it. Remember, you do not want to upload this type of sensitive information. And yes, your node API key is sensitive information. This right here, not really. This is just going to indicate to our application since it's a mono repo and it needs to do some magic, I just need to tell it what chain that we're going to be dealing with. And I'm picking Linear because I've got some linear test ETH already. Oh, and that's one thing I should show you real quick.
00:25:10.366 - 00:25:38.390, Speaker B: Let's reopen up infura and I just wanted to show you at the top here that if you go to Faucets, you can get test ETH for Sepolia or Linea. You just click the right button here at the top. Sorry, I'm on hotel Wi Fi. It's a little bit slow. So you got Sepolia and you got linea here and you just put your wallet number in there. I think I've already done mine today, so I can't do it. Plus I don't have MetaMask enabled right now.
00:25:38.390 - 00:26:07.618, Speaker B: But just put your wallet public key in there and yeah, it should send you some ETH. Hey, do it every day for like a week and get a little bit saved up. So you can play around with Linear or reach out to me http junkie on Twitter. And if you really need it, I can send you some but try to get it yourself. But if you need it, we can get it to you. Contact me or Emily. All right, next we want to do the same thing in our blockchain folder here.
00:26:07.618 - 00:26:47.518, Speaker B: So let me go ahead and rename this as env now this one's a little bit more sensitive because it needs the Infura Project ID. So let's go ahead and copy that and paste it over here. The reason why we need it in two places is because Vite needs veet public as an environment variable to use in our app and Blockchain doesn't. I'm sure there's other ways to do this where I can get the same one from one env, but I'm lazy. I did it this way. But the private key here, we're going to need to kind of start up MetaMask in order to get that. So let me do that really quickly.
00:26:47.518 - 00:27:32.954, Speaker B: I'm going to go in here and enable MetaMask and log into that real quick. So copy that and we're not going to paste it in here. So you don't want to just copy that and paste it in. That's just your public address, right? So what you need to do and I'm going to show you how to do this on one of my these are imported accounts. So these come from Ganache. So it's okay to show you here that you go to account details and then you do export private key. And then you type in your MetaMask password right here and then it'll give you a private key back.
00:27:32.954 - 00:27:59.062, Speaker B: So that's how you do it. And what I'm going to do is I'm going to pause my recording really quickly so I can get mine and paste it in there without showing the whole world. So just one moment and okay, so I went and got mine. I've put it into my env. And so I've got both the values there. I've got my Infuria and my private key in there. Remember to never share your private key.
00:27:59.062 - 00:28:14.778, Speaker B: Never share your seed phrase. Never share your env files. Make sure that they're always in your git. Ignore. Right? We can see what that looks like. We don't want our env to be uploaded to GitHub. Someone will take your private key.
00:28:14.778 - 00:28:33.594, Speaker B: They'll first drain your wallet. If not, if there's nothing in it, they will set up a bot and they will take anything. If ever gets put into that wallet, it's not good. Ask me how I know. Okay, so good to go. We've got our env files taken care of. Now we're kind of off to the races.
00:28:33.594 - 00:28:59.610, Speaker B: We just need to build, deploy, and run our application. So at this point, I'm going to go ahead and do NPM run, build at the root of the directory. And I think I've done everything we need to. Should be good here. Cool. Compiling contracts. One thing I'm going to note here is that one thing that we'll see already is that in our Lib folder we've got this contract abis.
00:28:59.610 - 00:29:36.818, Speaker B: So I'm having these outputted from my Truffle config. So right here is where I define those. So if you have a project set up like mine, you can have it output those files into your web. Directory so that you can get at them. And I'll show you why we need to do that here in a moment. But if we go and look at our ETH tickets one now our contract that we're going to be deploying is ETH tickets and it's just basically on chain SVGs. You can take a look at this on your own.
00:29:36.818 - 00:30:21.970, Speaker B: I'm kind of assuming that most people know a little bit about Solidity at this point. But if you're not super familiar with Solidity, we've got some other great content on Emily's channel. So, yeah, you can go through here. We've just basically got this mint NFT function and then we create our NFTs as SVGs and we store them on it's again for this workshop. For the idea around this contract. It makes sense because these are tickets that are going to be unique, that anyone can generate. And maybe you can get them into a conference or a party or whatever, right? So take a look in there.
00:30:21.970 - 00:30:58.126, Speaker B: But the contract needs to get built and we need to get Abis out into our web directory. And inside there, let's see, we'll just go ahead and collapse a few of these and we'll see this networks. Now notice that networks is empty right now. I'm going to come back to this file in just a moment whenever I run these next few commands. So the next one is we've got deploy contract on Linear or Mumbai. So we're going to do Linear. We're actually going to do both of them just to show you kind of what happens here.
00:30:58.126 - 00:31:31.530, Speaker B: But let's go to my terminal and let's go ahead and deploy the linea. Remember, since I put my private key into that env file, that is the wallet that's going to get charged for this deployment, so to speak. But it's all test ETH, so no worries. Let's go ahead and deploy that. We'll see that it gives us a contract address back. And I'm going to do this kind of the hard way. So I'm going to just copy this and go put it into my config file.
00:31:31.530 - 00:31:56.100, Speaker B: But you can get around that. I'll tell you how to do that. So this might take a moment. All right, so we've got this contract address here. I'm going to go ahead and copy that. So this is the contract address from our contract that got deployed. And in here in our config, I'm just going to pop that into Linear right here.
00:31:56.100 - 00:32:28.234, Speaker B: All right. And then, hey, let's go ahead and run the Mumbai one. Also, I just deployed out to Linear. Let's also deploy to Mumbai real quick, just so I can show you how this works. If you don't kind of know how these Abis work or how kind of deploying contracts works, we're not going to actually run our application against this one. I just want to show you what happens. So we're going to go into this contract Abis Ethickets JSON well, let's wait for this to finish for a moment.
00:32:28.234 - 00:32:58.374, Speaker B: So let's copy this contract address. Let's go ahead and put that into our config. Now I can show you how to not have to copy this stuff. So what you can do is let's look at that networks again. Let's scroll up to the top here. This got generated again. So if we go down here to networks, you can now see that we've got 59140, that is the Linear chain ID.
00:32:58.374 - 00:33:50.962, Speaker B: And 80,001, that is the Mumbai chain ID. And you'll see that they're the exact same address numbers. So what we could do in this config file is we could up here, let's see, we could do an import and then we could do ETH tickets. And we want to get that actually from Libcontractabis Ethickets. JSON right. And then what we could do is we could use this down here and what it would look like is something like let's go back here. We would have networks.
00:33:50.962 - 00:34:33.374, Speaker B: Yeah. So we would do networks and then we would do we have a number in there, it would be like 80,001, whatever for Mumbai. And then of course, at the end here, you could just do contract address, right. So it already finds it here. I just wanted to show you how you could do that. We're not going to do that right now. The reason I kind of go in and copy these in here and kind of show you that is just so you know where to find all this stuff because everyone's going to have a little bit different deployment, especially if you're deploying out to production.
00:34:33.374 - 00:35:11.050, Speaker B: You may not have the same set up. You may build your front end and your blockchain app separately. And therefore you would need to kind of figure out how to deploy and migrate your contracts out to the testnet, how to get that contract address, how to put that Abi into your client. So you could do it a couple of different ways. Let's go ahead and move on here. So after we've deployed, we're pretty much good to go. We can run this command which will so this is called NPM run dev testnet.
00:35:11.050 - 00:36:22.534, Speaker B: Let me just show you what that's doing here in our Turbo repo. So Turbo is a way of kind of being able to have workspaces in a monorepo. So if we go into web, we can notice here in the package JSON, we've got like scripts, right? And in the blockchain one we have deploy Garly, deploy Mumbai, deploy Linear, right? And then also we can run NPM, run dev testnet. And that will just kind of ensure that whatever we've put in our env file for this network ID, this is the hex version of that network ID that it uses that chain in order to set some things in our project. You can dig into the project and see how all that works. I'll go over a little bit with you. But just know that once you set your network ID here, like when we run this NPM run dev testnet, you can be sure that the application is going to know that's the chain that we need to be on.
00:36:22.534 - 00:36:53.360, Speaker B: And if they're not on it with their wallet, when they hook up their wallet, then we'll go ahead and give them a button to switch over to it. So you can see here dev testnet. And all that's saying is, hey, go into my web folder in my Web workspace and run NPM run dev, which would then come in here and run NPX Vite. And again, in context will be that chain ID. Our application is going to kind of know that that's what we're running on. And you'll see that here in a moment. So let's go ahead and run that.
00:36:53.360 - 00:38:14.166, Speaker B: I'll go ahead and open up my wallet here because we're going to test both the browser extension and the mobile, and then we're going to have a look at the code and just kind of try to look at as much of the code as possible before our time runs out. We've got a window for this workshop, but I think this project is a great starting point for you if you're building a DAP and you want to deploy to any testnet, hopefully Linear, hopefully you're working on the Linear bounty and you want to use the SDK to kind of do both bounties. Hopefully you can take this workshop and put on your computer, strip some stuff out, put what you want in, but it'll all work, right? Or at least you'll have some good examples of how it could work. All right, so let's go ahead and open this up in a browser and let's just do a hard refresh here. Okay, so we have our MetaMask wallet ready to go, and I'm going to start it actually on a different network. So even though we deployed to Moombi, I told it that we're running on Linear in the environment variable file. So I'm going to switch to Moombi before we connect because I want to make sure that once I connect with MetaMask that it recognizes that, hey, you're on the wrong chain.
00:38:14.166 - 00:38:51.138, Speaker B: So let's go ahead and connect here and it does. So see this switch chain? So you can see Linear right here. And if we click on this, we'll get our contract that we deployed and we'll be able to open it up on Block Scout, which is where this is kind of like the ether scan for Linear testnet. And then also the wallet, it shows the wallet's connected. It shows my balance of test ETH that I have. But notice it says switch chain because I am not on Linear and it wants me to be on linea. And nothing's really going to work unless I'm on Linear.
00:38:51.138 - 00:39:44.198, Speaker B: So let's go ahead and hit switch chain. That'll pop my MetaMask and it'll tell me to switch, and then that will go away. And now everything it's kind of happy with everything now, and I have less ETH on Linear than I do Mumbai. All right, so we want to test a few things before we start Minting tickets, right? Since we're connected to two different accounts right now, we want to be able to switch to another account and see that the application is responding correctly. Right? So that's a big thing about connecting to MetaMask in any application. And here we're on a react application. So we want to build some type of a context provider, some global state, if you will, so that we can keep our wallet in sync with our application, so that if we change something in the wallet, that it changes there.
00:39:44.198 - 00:40:20.610, Speaker B: So you can see I've changed over to test two account, and then if I disconnect test two, it should go back to the first one, and it does. I can see that up there already, so I can close that, go back to one, and we can see that one's still connected. And then again, I can change this, and it's going to tell me to switch chains again. Hey, switch back to linear. Great. And finally, I want to be able to disconnect here, and it should take me back to connect to MetaMask. Great.
00:40:20.610 - 00:40:53.418, Speaker B: So that works, and we'll see how some of that code works here in a few minutes. So let's go ahead and connect back to MetaMask again. We're just going to connect to one account this time, the one that we actually want to use, the one that we have our test linear ETH on that we got from the Linear Faucet. And now what we're going to do is we're going to mint a ticket. So before you connect to MetaMask, if you try to mint one of these tickets, these buttons are actually disabled. And again, I'll show you some of the code of how all that stuff works. But basically, we know whether we're connected to MetaMask or not.
00:40:53.418 - 00:41:17.398, Speaker B: We know whether we're on the right chain. We also can know if we're connected to MetaMask mobile versus MetaMask extension. I'll show you some cool stuff you can do with that. Right, because we have to make all these decisions in our application of what button to show. I got to show the connect MetaMask button. If nothing's connected, I've got to connect to the mobile. If they don't have extension, if they're not on Anya, if they're on Mumbai, I need to switch them over.
00:41:17.398 - 00:41:37.398, Speaker B: Right. We want to try and do as much for the user as possible so that they don't have to go, oh, I'm on the wrong chain. Pop up something that says, you're on the wrong chain. Go into your wallet and change it yourself. No, let's change it for them. Right, cool. So let's go ahead and hit Mint ticket, and that'll pop this up, and we'll have a little confirmation here and we'll confirm.
00:41:37.398 - 00:42:01.182, Speaker B: And notice I can't click on this while it's minting. Again, when minting, we want to put the component in a loading state and make sure that we disable that button. Now, when this comes back online, this button will also within about a second or two, we'll see that. Yeah, there we go. It kind of showed up beforehand. Interesting. So this is the ticket that we just minted.
00:42:01.182 - 00:42:28.454, Speaker B: Now, this is a unique SVG on chain. There's no IPFS, right? We've got an SVG stored on chain, and it's unique. There is no other ticket like this. This contract always creates a unique ticket because they've either got a general admission or a VIP. So this is ticket number 1000. The next one will be 1001. And then also we print out their public address on the ticket.
00:42:28.454 - 00:43:04.502, Speaker B: There's a date on it, and there's a name out of an event, right? So, yeah, it's kind of contrived a little bit. But this is a unique SVG, and every NFT that this application generates is unique. So that's pretty cool. Let's print a VIP one. So one more cool thing about the tickets is that if it's Ga or VIP, they're going to be different colors, right? And all that stuff is done inside that contract. That contract I've created. So the contract, when it creates a general admission and it knows whether your general admission or VIP by the amount of ETH that you paid.
00:43:04.502 - 00:43:28.078, Speaker B: So it's really cool. It's kind of hacky, but at the same time, kind of cool that if you mint 0.1 ticket with 0.1 ETH, you get a general admission ticket. If you spend 0.2, you get a VIP ticket. And of course, they want to go through the application.
00:43:28.078 - 00:44:35.806, Speaker B: We don't want to just be sending random amounts of ETH to that contract, even though I don't think you can. I think you can only send those two amounts. But yeah, it gives us a different color, a different ID, a different kind of type of ticket date, all that stuff is configurable in that contract. So very cool, right? We're trying to show you ways that you can create good UI, good UX. Right? Now, this isn't the greatest application in the world, but with the things that we're showing you in here, it enables you as the developer, to be able to make these decisions, to be able to like, when I mint a ticket, shouldn't I see that ticket immediately and know which ones this wallet has created? Notice, I don't know why they just switched around like that real quick, but notice if I switch over to another account like this one and connect to it, these are going to disappear, right? Because now I'm on a different address and the application knows about that. It says, hey, you just switched your address. You're no longer this other ETH address anymore.
00:44:35.806 - 00:45:07.626, Speaker B: You're this new one, and you haven't bought any tickets yet. But if I go back to it and I go back to account one, boom, there's my tickets back. Right. So the tickets that show up here are the ones that this wallet has minted, and it will always be that way. All right, so now that we have done that, I think the next thing to test would be to click on manage extensions here. And I've got another wallet with a different address. So let's go ahead and kill MetaMask.
00:45:07.626 - 00:45:24.546, Speaker B: By the way, I'm using MetaMask flask. This is just a developer version of MetaMask. It is in no way different than the regular version. So don't be confused by the purple icon. It's still MetaMask. If you're a snaps developer, you'll know exactly what I'm talking about. That's bad.
00:45:24.546 - 00:45:51.674, Speaker B: I forgot to disconnect from MetaMask Mobile, so we saw a little flash of something weird there. All right, cool. So let's first of know I've been testing this before I did the workshop, so I probably left a connection open there. Yep. All right. So now the wallet that I'm going to use is my MetaMask Mobile wallet. So when I don't have MetaMask enabled and this is how the SDK works.
00:45:51.674 - 00:46:26.870, Speaker B: Right now we're trying to make it to where the user always has the option of choosing MetaMask Mobile or the browser extension. But right now the way it works is that if MetaMask SDK does not detect a browser extension, it's going to try to connect you to MetaMask Mobile. It's going to give you a QR code. And I can just go into MetaMask. On the top right, there's a QR code button, and I can scan this. And then I don't know how well you'll be able to see this, but you can see that the transaction has come up here. And if I click OK on that, we're going to see that I'm connected here now with a new wallet.
00:46:26.870 - 00:46:45.866, Speaker B: Cool. Well, we're not going to go through all the other stuff that we went through with the regular wallet. We're just going to try and mint NFTs now just to make sure that our application is still working. Cool. We'll mint ticket. We're going to get another prompt here in our MetaMask Mobile. Sometimes it takes a minute.
00:46:45.866 - 00:47:17.590, Speaker B: There it is. Going to go ahead and hit I'm doing this through the camera. Okay, cool. So it looks like transaction submitted, waiting for confirmation. And there we go. So it takes a minute for it to communicate back with the DAP, but as soon as it does, we're going to see a ticket pop up, hopefully if our application works well. So one thing to know about MetaMask Mobile, and especially when you're testing it, is it does take a little bit longer.
00:47:17.590 - 00:47:53.620, Speaker B: Right. One, I'm on a hotel connection. Two is my application is communicating with a mobile application. All the more reason to make sure that you have loading states in your components so that the page knows when you are. Did I accept that transaction? All right, transaction complete. Finally, something weird just happened here. Let's go ahead and try this one more time.
00:47:53.620 - 00:48:40.746, Speaker B: All right, so when you disconnect from MetaMask, that comes up, and let's just go ahead and refresh here. Cool. So we're going to connect with MetaMask mobile this time, and when we click on that, we're going to be able to get a QR code here and we can scan that with MetaMask. And then we're going to be able to connect. And now we'll see our information up on the screen there. That's the right address that I'm connected to. And I'm going to go ahead and mint a ticket.
00:48:40.746 - 00:49:01.302, Speaker B: See, there is the ticket before that came up. I don't know what I did there. I think I disconnected when I was accepting it. I think I somehow disconnected. Don't know what happened. Hey, live demo. Sometimes things don't go as we planned, but I think next we'll try to mint a VIP ticket just to make sure everything's still working.
00:49:01.302 - 00:49:24.720, Speaker B: Okay. It all right. So transaction submitted. Waiting for confirmation. I also made a bunch of changes right before I started recording, so I'm hoping it's not something oh, no. There it goes. Great.
00:49:24.720 - 00:49:52.166, Speaker B: Awesome. Yeah. And it went away that time, so yeah, it was something that I did on my phone. The thing here is you got to test when you're dealing with MetaMask browser extension versus MetaMask mobile, you need to test both wallets out, right. You need to find these edge cases, find out if there's any difference between the two. And there actually is. So let's go back and look at the code real quick.
00:49:52.166 - 00:50:37.954, Speaker B: And what I'm going to do is give you a quick tour through the code. We don't have a ton of time, but I'm going to take you through as much as possible. I shouldn't have got out of that, but we can come back in a moment. So the first thing I want to show you is kind of how our client side application is set up. And we have this components directory here, and we also have this hooks directory. So our app TSX has a MetaMask context provider around the entire application. Inside that we have a navigation, a display area, which is like the middle area of the application, and a MetaMask error.
00:50:37.954 - 00:50:58.286, Speaker B: Oh, that's one thing I didn't show. If I reject connecting to MetaMask, you'll see a nice little thing come at the bottom. We can test that in a few minutes. It's another component, another reason to have state in your application. Right. We want to track all of the MetaMask state. Now this is a little bit daunting of a file, and there's a lot going on here.
00:50:58.286 - 00:51:45.760, Speaker B: We can't go over it all, but if you're good with JavaScript and TypeScript, all of this should make sense. We switched it over so that it's not using any reducers or anything and it's pretty cut and dry. What's going on? There's a connect to MetaMask function. There's a use effect that connects to the SDK and creates a MetaMask SDK instance. Basically, once you do that in your application, the injected provider kind of gets taken over by MetaMask SDK. And no matter whether you connect to the browser extension or mobile, like when you connect to MetaMask mobile, it kind of replicates that injected provider for you. And that's how we're able to connect to both from adapt use deep linking if we needed to.
00:51:45.760 - 00:52:43.418, Speaker B: And then I think the next thing we want to look at is this use effect here. So here we are making sure that the SDK is initialized. We're calling Update Wallet and Accounts, which is basically a function up here, which we are getting the ETH accounts from our wallet and also doing any updates. So we might be updating our wallet or account at any time and we're just setting up a bunch of event listeners. The thing that I'll point out here is that initialized connect these two right here, these are specific to MetaMask mobile, accounts changed, chain changed. These are not specific to MetaMask mobile. These apply to both MetaMask mobile and MetaMask browser extension.
00:52:43.418 - 00:53:18.890, Speaker B: And then disconnect is also associated with just MetaMask mobile. So our docs will be updated with all the information on how all of this works. But it's good to know that because if you've ever used these listener events before, these might be the only two that you've ever ran into. And when we were only connecting to the MetaMask browser, these are the only two that we would use. And so these other ones, you need to know about those for MetaMask mobile. But we can set them all up here and we can break them all down in a use effect. The way that you kind of clean up is through a return function.
00:53:18.890 - 00:53:57.462, Speaker B: So we're removing those listeners and we've got a bunch of dependencies here. We've got to run this code at certain times. And so I'm sure you know how dependencies work for use effects. And then we have our MetaMask context provider, which these are all the things that we might need any component in our application to be able to use or know about. So the wallet has like address and balance and chain ID and all that stuff in there. That's how we're able to when the wallet changes, the application changes, right? Those components are subscribing to this state and when one of these states change, the component gets rerendered. It's how react works.
00:53:57.462 - 00:54:15.694, Speaker B: One way data flow. Awesome. That's why we always use React. Cool. We also have this use networks Switch or Use Switch Network, which is used by our Switch Network button. You saw that pop up when I was on the wrong chain. But let's go into our navigation real quick.
00:54:15.694 - 00:54:38.066, Speaker B: So we have a navigation this is kind of the first place to start. So we have some basic code set up here. It's actually not a lot. We're just pulling in that use MetaMask. So this use MetaMask allows us to get access to that wallet is connecting connect MetaMask function. And this one called SDK connected. And this is the one I wanted to show you.
00:54:38.066 - 00:55:58.542, Speaker B: So if I uncomment this code here, I could do something based on whether or not I'm connected to MetaMask browser extension or MetaMask mobile. And so I wanted to show you this because you might do something a little bit more in your application that I haven't done, which you need to know. Like, hey, am I connected to the browser extension or am I connected to their MetaMask mobile iPhone or Android app? And this SDK connected will tell you that. One more thing to note is that use MetaMask and our hooks and our provider that we have in this application, these are all things that we plan on giving you from the MetaMask SDK, but it's going to come in a different package called like SDK React, right? And you're going to have components that do all of this conditional rendering for you. But I still think it's cool to show you all of the different conditional rendering I'm doing here based off of the context provider that I've created in order to be able to manage your state, keep your wallet in sync with your application. It provides some data about the wallet to other components like this navigation. And I can make decisions based off of different things.
00:55:58.542 - 00:56:31.880, Speaker B: So I can give you the switch network button if the account's length is more than zero, which means we have a wallet address, but you're not on the supported network. Right? We set the supported network at the beginning in that EMV file, and we set linear. So if they're not on linear, this thing's going to pop up. If they're connected, if SDK connected, which is just what I called it, this should really be called like mobile SDK connected. And you could rename that if you want. Then we would show mobile versus extension. That's what I'm going to show here in a moment.
00:56:31.880 - 00:57:35.040, Speaker B: Also, if we have a wallet and the account's length is more than zero, we're going to show the chain information, we're going to let them link out to that block Explorer, and we're going to show the address of their wallet in a formatted kind of way and then let them link out to Ether scan to see their wallet. Just some things I wanted to do here's where the balance is being shown. So not a lot going on here. It's basic stuff. Now let's go ahead and run our testnet one more time. And what I'm going to do is I'm actually going to turn my extension back on and I'm going to refresh just to make sure. All right, so what I wanted to show you now is we're going to connect to MetaMask and go ahead and connect.
00:57:35.040 - 00:58:09.640, Speaker B: All right, so now we see extension here, right? So then let's go ahead and manage extensions. Let's go ahead and kill that. And then I'm going to refresh. And then I keep leaving this connection open. There is a way. Also, I've got some of the code set up to where you can actually create a button that'll disconnect the MetaMask mobile, but it's not hooked up in here. So we're just going to have to deal with that thing popping up for a moment.
00:58:09.640 - 00:58:38.660, Speaker B: All right, so I'm going to go ahead and connect. And now we see mobile up here, right? So cool. This is awesome. The ability to be able to connect to MetaMask mobile or extension from adapt. I've shown you some code. I've showed you how to take this repo, clone it down, get started. We've only got a few minutes left.
00:58:38.660 - 00:59:02.380, Speaker B: Any questions? Okay, cool. Since there are no questions, I think I will just oh, I'll show you the MetaMask error. We can do that real quick. So again, let's disconnect from MetaMask mobile. So I'm going to go in here. I'm going to go to manage extensions and just hit disconnect. All clear.
00:59:02.380 - 00:59:33.538, Speaker B: And look, cool little thing pops up, lets you know you're leaving. And then what I'm going to do is I'm going to turn the regular one back on because it's easier to reject a connection from and show you in real time. So we'll go ahead and we got to refresh. I think connect. Got to do this again. Everyone knows how long my password is now.
00:59:33.704 - 00:59:34.034, Speaker A: Cool.
00:59:34.072 - 01:00:08.318, Speaker B: This is my test wallet. Don't care. So I'm going to go ahead and hit cancel. And notice down here at the bottom, we get this error. User rejected the request, right? Because we have all of this stuff considered in this application, right? We have this MetaMask error that's at the bottom, it hugs the bottom of the page, and if you click on it, it goes away, right? So if there's ever any error while dealing with MetaMask, it'll show up down there. When you're minting, it'll show up right underneath the mint button. So we just try to think of everything we could.
01:00:08.318 - 01:00:27.790, Speaker B: Anyway. So that's really all that I have. I just want to thank you all for checking out our workshop. Remember? Check out Emily Lynn. Go back to the beginning of the video if you don't have her information. She's awesome. She's going to be at ETH Global Waterloo with me.
01:00:27.790 - 01:00:36.020, Speaker B: And also, I want you guys to sign up for the linear and MetaMask SDK bounties. And with that, see you later.
