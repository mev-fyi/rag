00:00:07.130 - 00:00:48.294, Speaker A: So what is Axiom? Well, Axiom essentially enables ZK superpowers for your smart contract. And what exactly does that mean? Right? I'm sure you're wondering. Well, let's just back up a little bit. So right now, smart contracts really only know the current state of the blockchain. They can only see things like, let's say you go to Etherscan, right? And you look at some random account. You can only see the current balance of that account on chain and things like how many transactions that account is sent via the nonce. So all this data that's in the red here is actually data that is not available on chain.
00:00:48.294 - 00:01:50.480, Speaker A: And what that means is that you can't use that in your smart contract until now, right? So much of this rich on chain history is just not available. So you can see the number of transactions, but you can't actually see what's in those transactions. So accessing more data on chain generally just requires trade offs, right? So you can either pay more to store data in the state of Ethereum because the contracts can't access the history, but that imposes some extra costs on each user. When you store more state, you increase gas costs, essentially. Or you can reduce security and use trusted Oracles. So that also introduces additional trust assumptions on users and it also prevents you to scale in a lot of ways. So developers either have this conundrum, right? They can either increase the cost or decrease the security.
00:01:50.480 - 00:03:28.494, Speaker A: So then the question is how do we enable smart contracts to leverage the rich history of on chain data? So what Axiom allows you to do is access data with ZK cryptography instead of consensus, right? So if you look here, this is essentially a model of a blockchain, right? So each pass block commits to the entire history of the blockchain and each block has commitments to the state, the transaction, and receipts. And so proving that data in ZK enables scale and composition because when you prove it in ZK, you're able to basically get all this data and put it and use it in your smart contract. And what we have is this REPL that we have online, it's REPL ICM XYZ. It's basically an interface that allows people to write their own circuit in a JavaScript edsl that's a wrapper over halo two. And so what this means is that you can grab historical data like block headers, accounts, storage and you can also get data like transactions, receipts and mappings. And so what we do essentially is we let you specify this application logic in the REPL interface and then you can export a client side ZK prover that you can use in your webd app. So where does Axiom fit in in this whole stack, right? So essentially you have the front end, which is like your client app.
00:03:28.494 - 00:04:40.870, Speaker A: And then on the back end you have like a data aggregator or indexer that could be anything like alchemy, covalent, QuickNote, et cetera, et cetera. And then between the back end and the blockchain itself sits Axiom. So we have off chain and on chain components and then essentially we will send a callback to the developer's contract and the developer can then process that data in whatever way they see fit. So I'll just really quickly go over this workflow. But essentially we start off with generating a compute proof via a client side prover, right? And then with that proof we send a query into the Axiom contract. The Axiom contract then generates a proof on the proving server and then the proving server sends the result of that proof to the Axiom contract, which then calls the onchain Verifier. And so that data is verified before it's sent via a callback to the developer's DApp contract.
00:04:40.870 - 00:04:41.862, Speaker A: Yes.
00:04:41.916 - 00:04:43.986, Speaker B: Is it possible to access the proof.
00:04:44.098 - 00:06:00.074, Speaker A: In the callback, the actual proof itself? Not right now, but that proof data is available. Like if you look in, we have a thing called Axiom Explorer and so that proof data is actually available there. And so we aggregate all this data via universal aggregation. So the compute proof and dataproof that is generated on the client side in Axiom REPL, that circuit is put into a universal aggregator and then we then are able to verify it using a universal on chain Verifier. So what this essentially means is that there's no ZK related Smart contract deploys that developers need to deploy in order to use Axiom. And so using results for Axiom in your Smart contract is as simple as just adding this very specific function to your contract to receive the callback. And so this is just a toy example that we'll be going over and it's on Governance.
00:06:00.074 - 00:06:51.920, Speaker A: So how is Governance done today? Right, users will vote on a proposal. If the proposal passes, then we trust some entity or entities to implement that proposal and sometimes they don't. So what exactly are we building here? We're building a contract and DAP whose parameters are autonomously governed by users who meet specific criteria based on their past on chain actions. And so well, let me back up in this specific case. The past on chain action that we are looking at is whether a user minted an NFT and are still holding it. So essentially we have four pieces to this, right? We have this first piece, which is the NFT project useless NFT, which is an ERC 21. We'll pretend it was minted like a year ago or something.
00:06:51.920 - 00:07:34.778, Speaker A: And then the ZK circuit with Axiom REPL. So we write a circuit that checks that a user minted this useless NFT. We have the NFT project's new useless Governance token that they want to deploy. And this is where the Axiom callback is implemented. And users who've minted the useless NFT and still hold it can influence the token's parameters directly. So basically, each of these users who have minted the NFT and still hold it are able to vote to increase or decrease a token's tax and stake rates by 0.1%. Whether this is something that you actually want to do or not, that's a question for yourselves.
00:07:34.778 - 00:08:13.910, Speaker A: But then we have this webdap front end, right? So users will connect wallet. An app uses an indexer to find the useless NFT Mint event and then qualified users can vote. And then it generates and sends a query to Axiom. All right, so this is part one, part two, part three, and part four. All right, so the high level architecture is as such, so you basically just have this user that mints this useless NFT. And then the developer creates a circuit. In Axiom REPL, they have this web app and then some data that talks to an indexer.
00:08:13.910 - 00:08:33.166, Speaker A: Once this query is sent, it's sent to Axiom v Two query who sends the data to the prover. And then the prover generates the proof. And then it's verified in ZK, it's verified on the onchain Verifier and then the callback is sent to the useless governance token. Yes.
00:08:33.268 - 00:08:38.686, Speaker B: Is the prover or the V two query like on chain verification? Is that open source?
00:08:38.878 - 00:08:51.686, Speaker A: Yes, it is. So actually right now it is still, I think, closed sourced and in development and audit. But once it's all done, that will be open sourced. And we've open sourced. Axiom v one already.
00:08:51.868 - 00:08:54.098, Speaker B: It's kind of like the high level API.
00:08:54.274 - 00:09:10.022, Speaker A: Yeah. No. Axiom v one and axiom v two are completely different. Okay, so this is the GitHub to the actual thing that we'll be talking about today. It's. Axiom crypto. Governancepramsexample.
00:09:10.022 - 00:09:57.450, Speaker A: Axiom crypto slash governancepramsexample. And we'll have a link to this at the end as well. So first part is this useless NFT, right? So it's just like a standard, completely unremarkable ERC 721. And then we have an external Mint function that allows anyone to mint NFT. I'm not going to go over this at all because it's just very standard. But for Axiom REPL, what we're interested in is this Mint event, which is actually a transfer event, right, where the zero address is from, and the two address is the person who minted the NFT. And then we have the token ID as well, who we're interested in, and then the address of the contract that emitted the event, which is the NFT contract.
00:09:57.450 - 00:11:17.720, Speaker A: So in Axiom REPL, when you go to the website, there's two separate parts and each part, well, there's one part that's code and one part that's inputs. And so the code is essentially like how you're specifying getting data from the blockchain and then also doing any sort of compute on that data. And essentially you can think of it as your circuit. The inputs is actually what your web app can override or basically use as inputs to the circuit when you export it. So this Mint block and Mint TX number will be different for each user and also the vote value as well, but going over each part of this. So we have the transfer event schema, right? So you have the log where you get the receipt and so for these transactions there's only one log and so we know that's always at index zero and then we check that the address that's emitted is the NFT contract itself. And then we also want to check that the transaction is a Mint transaction, right? So it's from address zero.
00:11:17.720 - 00:12:16.390, Speaker A: And then we also want to make sure that the Minter's address and the Token ID that we get the Minter's address and the token ID. And then we also just want to check that the vote value is either a one or two, where one is yes, two is no. And we're not using zero just to not handle any default issues. And then scrolling down a little bit, then we have these add to callback calls. And so these are what lets you add values to the callback that will get the data to your contract. And so the data that we're interested in getting is the to address the Token ID and the vote which we will handle in our contract later. And so what we're able to do here is export this TypeScript circuit in axiom REPL and then also we want to check grab this query schema and so the query schema is pretty important.
00:12:16.390 - 00:13:15.798, Speaker A: It's basically a commitment to your circuit and what that means is that when a callback is received to your contract we want to make sure that that callback is talking about the same circuit that you wrote. And so if you change any part of the circuit that query schema is going to be different. And so we want to make sure that the callback that you get is for the circuit that you wrote. Okay, so next part is the ERC 20 Token aka the useless Governance Token that receives the Axiom callback. So it's a standard ERC 20 Token and it has state variables that hold the tax rate, the reward rate and the number of votes, number of voters who voted. And so this has a function to receive and validate the axiom callback. And for a production contract, obviously you could have like a mapping of Structs that holds voting requirements and data for each proposal.
00:13:15.798 - 00:14:32.660, Speaker A: But in this case we are just doing a toy example and so we just have one contract that has all this data and so let's go over this part real quick. So here's the axiom callback query schema that we want to put in here and this is saved on contract deploy and then we have the tax rate, reward rate and total votes as well as a mapping of people and their Token IDs that did vote. And so we have a function that checks if the user voted already and so we just basically hash the address and the Token ID and then that just returns a true or false. But the main meat of this is this Axiom v two callback. And so I'm just going to jump over to this other file here called Axiom v two client. And so this is essentially what our other contract derives from. And so this contract has a function called Axiom v two callback that has the correct function signature, right? And then essentially we are just overriding these two functions here.
00:14:32.660 - 00:15:32.550, Speaker A: So let's go over this again. So in this part we want to parse the results array, right? If you remember earlier, we had three add to callback calls and so we'll have three results in the array and these results are ZK verified results of your history. So at this point we parse the results array, right? So we get the NFT holder, the token ID, and the vote value. And then at this point we want to make sure that the owner of this token ID is still holding it. And then we just want to make sure that we go through all these different validation checks as well. I'm running a little bit low on time, so I'm going to skip over a few parts here. But essentially we have the vote values that are updated and then we have event that is emitted.
00:15:32.550 - 00:16:08.930, Speaker A: And then this is some of the validation stuff. But the next part is this webd app and it kind of like has this flow where a user connects wallet mints. And actually I'll just go over these screenshots real quick here. So we have this page where a user can just mint the NFT, check whether they're eligible. And this is a toy example. So of course they can still just mint the NFT and then they're able to vote and then submit this vote. And then once that's updated, then once that vote goes through, then the tax rate and reward rate and the contract itself are updated.
00:16:08.930 - 00:17:03.410, Speaker A: And so this is kind of like the whole webdapp flow. And essentially we have something that parses this transaction data or checks the transaction data from Alchemy and then we just make sure that we find the one that we care about. And then these are just things that you can use to build the Axiom query itself. And then, yeah, this is also just building the Axiom query. And then essentially what happens is we get this ether scan transaction where we see the new tax rate and reward rate that have been updated. So let's talk about the project ideas real quick. So, computing the total volume traded by uniswap pair, providing that a user lost at least ten ETH by buying and selling NFT.
00:17:03.410 - 00:17:50.750, Speaker A: Gaining access to a DFI protocol trustless settlement of onchain gas price derivatives. Proving that a block contained a Sandwich attack algorithmically. Adjusting DeFi protocol parameters. Proving an off chain solver ran correctly. Giving users incentives or Airdrops based on their onchain actions. Minting an NFT or badge for achievements for an onchain game or giving incentives for prior users of a competing protocol to switch protocols. And so we have these five prizes and each prize is worth $2,000 and you have best overall use, most collaborative, best use of Axiom for on chain identity, best use of Axiom for DFI and best use of Axiom for onchain incentivization.
00:17:50.750 - 00:18:09.880, Speaker A: So you can build these ideas with axiom v two on test net available today. And these are all the different links that we have here. The example that I went over is in this examples v two repository here and then the hackathon guide is at ETHGlobal axiom XYZ. Thank you very much.
