00:00:01.290 - 00:00:29.094, Speaker A: Really optimistic. Thanks for joining us. And today we'll be starting the workshop with Kelvin and Ben from Optimism. An overview on code, an overview and code walkthrough. And without further ado, I will let Kevin and Ben take it over. If you have any question, you feel free to post it in the chat. We'll get back to them.
00:00:29.094 - 00:00:34.760, Speaker A: If not, during this workshop, after in the sponsorship channel in discord. Thanks.
00:00:36.890 - 00:00:54.190, Speaker B: Yo. Thank you. Hello, everyone. Welcome, welcome. Kelvin, can you help me with this screen share of the presentation? I don't want to accidentally reveal your social media or something. Hey, everyone, what's going? Welcome, welcome. Give us a SEC as we throw up these slides.
00:00:54.190 - 00:01:15.102, Speaker B: How are you all doing today? I'm very excited to see some unmuted faces. Incredibly exciting. I hope that we get lots of excellent questions that Kelvin will help me surface as we go. So it's great to see you all. It's good to be here. Sweet. All right, so we are preparing to hack, folks.
00:01:15.102 - 00:01:41.614, Speaker B: Let's get ready. It's the scaling ethereum hackathon. Get hype. Before we begin, I do want to let you guys know that if you're hoping to walk through the code alongside Kelvin, that Kelvin will be going over later, you can check out this link, which will redirect you to some pre reqs that you can get downloading in the background. However, no pressure at all if you don't want docker to kill your neighbor's Netflix or something like that. Of course, all this will be recorded. All of the code and stuff is public.
00:01:41.614 - 00:02:11.506, Speaker B: So you can go back, take your sweet time, pause Mr. Kelvin with some of these incredible shots that we're getting here with these incredible glasses. Damn, son. Where'd you find this? So in addition to that, I will say that I'm Ben, and next to me is Kelvin, who is currently manning the little soundboard we put together for this workshop. So if you hear random noise in the background, that's what that is. Yeah. So I'm Ben and this is Kelvin.
00:02:11.506 - 00:02:43.120, Speaker B: And we work at Optimism. And we're going to be talking to you all today about a couple of things. So the first thing we're going to do, and I think the most important thing that we're going to do is to give you guys a little taste of optimistic ethereum. Now, there's going to be some very familiar tastes there that you've hopefully already acquired, which is just the ethereum developer stack. There's also some new tastes that will be unfamiliar, but hopefully very, umami or choose your favorite flavor. They'll be new, but hopefully they'll be fun. We think they're a lot of fun.
00:02:43.120 - 00:03:14.102, Speaker B: So first I'm just going to talk through conceptually some of those components, and then I'm going to step back, and Kelvin's going to hop in. I will take over the soundboard, and Kelvin will do some coding with you all. So first we'll do it in words, then we'll do it in code. And then we're going to wrap up talking just very briefly about our plans for the hackathon and how we're going to support you lovely people. All right, kelvin, are we checking questions on chat, by the way? I love questions. I love questions, folks. If you guys can get us to not finish this presentation because of questions, I'll be very pleased.
00:03:14.166 - 00:03:16.682, Speaker C: First question, when one? L two, sir.
00:03:16.816 - 00:03:23.920, Speaker B: Soon. Okay, we have a soundboard, so I guess we're buying into it. We have to accept some level of memory questions.
00:03:26.050 - 00:03:28.880, Speaker C: First question down. Let's go.
00:03:29.330 - 00:04:09.754, Speaker B: All right, so what are we building? So we are here building optimistic ethereum. Now, what is optimistic ethereum? In one exhale of a hit? Or optimistic ethereum is just like ethereum, but with better scalability, ten to 100 x cheaper and secured by L One. So basically, if you want to sum it up in a simple meme, we can make it look something like that. Okay, so there's the TLDR. I'm going to very quickly go over some of the underpinnings of how optimist ethereum works and how optimistic roll ups work. I'm going to assume some context. If you guys want more, you can go check out other talks that we've done.
00:04:09.754 - 00:04:13.674, Speaker B: If you guys have seen those other talks, you'll notice that I stole those exact same slides here.
00:04:13.712 - 00:04:14.154, Speaker A: Again.
00:04:14.272 - 00:04:30.370, Speaker B: Sorry I'm not original. If it ain't broke, I'm not going to fix it. So thank you. Thank you. But the basic premise of optimistic execution in general can be summed up in the following way. You don't go to court to cash a check. You go to court if the check bounces.
00:04:30.370 - 00:05:18.366, Speaker B: So basically what we're saying is that we can get increased scalability in layer Two, because only in the event of a dispute do we need to execute the gas, the sort of full gas for the transaction right. And actually run it on chain. And so this is where we get our scaling properties. Okay, so what does that mean in a little more detail? Okay, so I'm just going to walk you through very basically what's going on. So up on the top half of the screen here, we have L One, that's ethereum, and on L2 is down below, and we have this roll up state. And basically what we do is we go through a repeated process whereby a new transaction and a new proposed state is rolled up. Now, this is probably the most useful, although it does play very nicely.
00:05:18.366 - 00:06:16.354, Speaker B: I hadn't thought of this into the whole taste eating analogy, but what does rolled up actually mean? Basically, it means that it's notarized on L One. It basically means we've put it into L One in such a way that if we need to do a dispute, we can. But the other thing that happens is a proposal comes along with that transaction, and that proposal claims what the notarized transaction should do and would do now, the key property is that we have a period of time that is like a dispute period. It's called the withdrawal window, sometimes as well, in which someone can basically challenge this behavior. But if no challenges, if the proposal basically goes unchallenged for this period of time, then we optimistically accept it. Basically, we assume that it must be right because it's past the period of time at which it could be disputed. Okay, so again, this is a repeated process, right? We do it once, twice, let's say.
00:06:16.354 - 00:06:52.800, Speaker B: Now we have this new transaction getting added, and someone proposes that they have all the money afterwards, right? That doesn't seem right. That seems like a problem. So what do you want to do? You want to do a fraud proof? So you go to L One and you say, hey, guys, this proposal for S two here looks really good, but if you take S two and you apply TX two to it, I'm going to show you you are not going to get S three. And so you basically prove that the proposal is wrong and you blow it out of the water and it gets eliminated. Damn, son. Where'd you find this? Okay, so there's our soundboard for that.
00:06:53.330 - 00:06:53.694, Speaker A: Okay.
00:06:53.732 - 00:08:03.570, Speaker B: And then the other important thing, I think, to go over as I just try to breeze through this, is that we basically have built something called the OVM, which allows that execute function during the fraud proof to basically be an EVM transaction. And so this is where you get all the wonderful EVM like properties replicated into your L2. All right? So I've tried to breeze through that a little quicker than I normally do, because what I want to focus on for this hackathon and for this presentation, for kicking things off, what do these things actually mean for someone as a developer? What does it mean if you're a hacker that's trying to go through and use our stack over the course of this month? So I think the first thing to say, right, I said before that there's some similar tastes, right? And effectively, that's quite true. I think the Hello World example for a blockchain project at this point pretty much is to launch an ERC 20. I mean, at least that's the case for ethereum. And of course, that's the case on our chain as well. So Kelvin will go through very quick how to take an ERC 20, turn it into an optimistic ERC 20, and the TLDR is that it requires almost nothing because you should be able to use all your same tooling that you love to deploy and interact with ethereum, but now do so interacting with optimistic ethereum.
00:08:03.570 - 00:08:27.994, Speaker B: So that all should be the same and super familiar. Now, there are new components that happen in this L2 paradigm, and namely those arise from the fact that we now have two layers. So these layers need a way to talk to each other. And it turns out that that talking sort of by necessity is a little bit different. Okay. And generally the way that two layers talk for 90% of use cases is a deposit or a withdrawal.
00:08:28.042 - 00:08:28.206, Speaker C: Right.
00:08:28.228 - 00:08:37.860, Speaker B: You're either putting your money in from layer one so that you can use it more cheaply in L2, or you're pulling it out so that you can take it or send it to an exchange or whatever.
00:08:38.390 - 00:08:39.140, Speaker C: Cool.
00:08:39.990 - 00:09:13.374, Speaker B: Okay. Another piece of context that I want to share is that all of the deposit withdrawal tooling should be very easy for you. And for a lot of use cases, you can just use out of the box deposits and withdrawals. But it's still useful, I think, and very important for developers to understand what they are building when they're using some deposited funds on l Two. What does it actually mean? Where did it come from? And how does the system work behind the scenes? So I'm going into a little more depth here than the abstraction for developers needs to be taken. But, hey, we're at a workshop. We're going to kick things off.
00:09:13.412 - 00:09:15.502, Speaker C: That's what we're going to do. Okay?
00:09:15.556 - 00:09:33.474, Speaker B: So it's pretty simple. Again. Up on the top we have l One. On the bottom, we have L2. And basically what happens is to deposit. What that really means is you're locking up funds on l One because you want to move them to l Two. And while they're in use on l Two, they shouldn't be also be usable on l One.
00:09:33.474 - 00:09:58.074, Speaker B: Right. That would be like a double spend or it wouldn't really make sense. So all you do is you have a contract on l One that locks funds and it tells l Two. Hey, I locked up this number of funds mint, and this was the person who did it. So mint them the equal amount of tokens onto l Two. So these two pieces together are what we would call a deposit. Great.
00:09:58.074 - 00:10:22.546, Speaker B: And of course, the exact inverse holds true in the opposite direction. To get your funds out of l Two, you should no longer be able to use them on l Two. So what you do is you burn those funds on l Two, and once the dispute period pass and the optimistic state is accepted, this will unlock your funds on l One and let you get them out. Yeah. Excellent, excellent. Make sure we're checking for questions, Kelvin. Come on.
00:10:22.546 - 00:10:23.860, Speaker B: You all got to stop me.
00:10:25.110 - 00:10:28.446, Speaker C: Who triggers the mint of the l Two funds?
00:10:28.638 - 00:11:13.890, Speaker B: Who triggers the mint of the l Two funds? That is a very good question, and it's a great segue, so I'm glad we caught it. I just have this little slide here that's making these arrows bigger. But to emphasize that, this is what I want to talk about. What mints the l Two funds? In some sense, you could even call it a cross chain transaction, right? In reality, we call it a cross chain message because it's more like the transaction starts, sends the message, and then there's a transaction that is receiving the message on L2. But in effect, what allows this minting to occur are smart contracts talking to each other between chains. And so there are differences in similarities in the ways that contracts can talk to each other between chains. So I'm going to talk through those differences and those similarities.
00:11:13.890 - 00:12:02.014, Speaker B: What we have strived to do in optimizing Ethereum is make that part of the protocol as similar to what we do in Ethereum as possible. So in Ethereum, the way that contracts talk to each other is a cross contract call. And when you do a cross contract call, you say who you're calling and you give some data that you want to call them with. It's like your message, right, that encodes information such as, I am calling this function and I am providing these inputs to this function along with calling that function and of course, how much gas you're going to spend. So we've tried to replicate that intuition as much as possible for sending messages across chain. But you do have to do it with a different contract because it has to work with L2. So here's the interface and exactly equivalently to what you can do on Ethereum.
00:12:02.014 - 00:12:24.490, Speaker B: Now, when you get a message in a smart contract, you can check the message sender and you can see, who is this message sender? Do I want to trust them or not? Or maybe they've just given me some money so I want to do something for them. So the other thing you can do, just like you can get the message sender in normal Ethereum, you can get the cross chain message sender from a contract.
00:12:25.550 - 00:12:27.034, Speaker C: Question two down.
00:12:27.152 - 00:12:48.910, Speaker B: Question two down. Cool. Okay, so a couple of different things. I want to speed up here, Kelvin, to make sure I got time for you. A couple of different things. The biggest difference in some sense is that there is no return data. So you can't do a cross chain call to a getter function, for example, and expect that data to be returned.
00:12:48.910 - 00:13:13.018, Speaker B: And this is basically because they occur in different blocks on each chain. And so because it's not the same block, because they're two different layers, they can't sort of have that round trip communication. This is a very, very fun design space. Hint, hint, wink, wink. You might think of callbacks when you see this and see that you can only call functions one way. And indeed, we think there's a lot of cool stuff that can come out of this hackathon related to that. But that's the one difference.
00:13:13.018 - 00:13:58.826, Speaker B: The other difference that's sort of related is that this communication is asynchronous. So there's a bit of a time delay. So we have a crazy time graphic here to describe that and basically what that time delay is is pretty short when you go in and you deposit funds, because a layer one message can sort of force things on L2, because layer one is the source of truth. But to withdraw your money or to send a L2 to layer one message, that takes a little bit more time because you have to wait for the dispute. Some of that is basically what is the same and what is different at a very high level when you're developing on a system like optimus Ethereum. So I think if we have any other questions, Kelvin, let me know. And if we don't, we're going to switch off to Kelvin, who's going to actually walk you guys through coding this stuff up.
00:13:58.826 - 00:13:59.962, Speaker B: Anything else?
00:14:00.096 - 00:14:01.178, Speaker C: I think that's it.
00:14:01.264 - 00:14:07.740, Speaker B: All right, let's go. Let me switch seats and pass it over to Mr. Fisher. Let's go.
00:14:08.190 - 00:14:32.162, Speaker C: All right, let's write some code. Well, I'm not actually going to write any code because it's bad practice to write code on stream. But why don't we switch? All right, so here's what we're going to do. I hope that everyone can see this. Yes, everyone can see this. Great. So I asked everyone to prepare for this.
00:14:32.162 - 00:15:07.120, Speaker C: If you aren't prepared for this, don't worry about it. Don't do it now because it'll take you too long. So just watch the stream afterwards and follow along then. But essentially what we're going to do is we're going to run through the basic tutorial and then we're going to sort of also run through what, like an L1, L two communication flow would look like and give you an example of how you can do that if you want to hack on that. So the basic tutorial is just sort of getting an ERC 20 contract deployed and compiling and working. Right. Pretty simple stuff.
00:15:07.120 - 00:15:39.406, Speaker C: So if you download, if you go to Optimism tutorial, you will be able to clone this repo and then all you really need to do is install it. Right. Pretty simple. And then we're using hard hat. So Hard Hat has this nice little compile, so I can run Hard Hat compile and boom, my ERC 20 contract just got compiled. This is a sort of standard flow. So the only sort of difference in Optimus Ethereum is we do yarn.
00:15:39.406 - 00:16:16.162, Speaker C: Add this plugin, add a plugin and great. And then we just add this plugin to our Hard Hat config. And we're also going to create a new network. I'm going to just copy the same mnemonic. And then we are going to specifically set this little flag that says OVM equals True. And for now, just to make our lives easier, because we don't have accounts and balance, we're just going to set a gas price to zero. Great.
00:16:16.162 - 00:16:29.020, Speaker C: So pretty simple. And then compiling for the OVM is really simple. All we have to do, just like we did NPX Hard Hat Compile. Right. We just add network optimism. Great. Cool.
00:16:29.020 - 00:16:53.278, Speaker C: Oh, sorry, I forgot to put a URL in here. So we're going to have a node running at 8545 standard port. It doesn't matter right now, but let's first compile. Great. So this is now compiling our contracts with the optimistic Ethereum solidity compiler.
00:16:53.374 - 00:16:54.020, Speaker B: Great.
00:16:56.070 - 00:17:13.990, Speaker C: Perfect. So, wonderful. So now you can see we have these two artifacts folders artifacts and artifact OVM. OVM means optimistic virtual machine, right? Sort of just like the very slight Tweak on the Ethereum virtual machine. Wonderful. Great. So similarly, this is how we would test a solidity contract.
00:17:13.990 - 00:17:22.550, Speaker C: Boom. Test it. Right. Come on. Go. Great. Wonderful.
00:17:22.550 - 00:18:02.920, Speaker C: Perfect. Now what we're going to do is spin up our simulated development l One L two system. So this is if you download the optimism monorepo and install it and follow the instructions that are in the tutorial. Here we have this little docker compose up thing that will spin up the entire system. And it spins up not only the l two node, but it also spins up an L1 node, which is really nice for being able to sort of, like, simulate the behavior between these two systems. So this takes a minute to spin up. So we're going to give that a second.
00:18:02.920 - 00:18:31.102, Speaker C: I should have probably spun this up before. That's life. Anyway, let that run. Unfortunately, there's no clear indication when this thing is done, you'll just kind of know that it's done because it starts doing a lot. We need to change that. Sorry. Anyway, once this is done, we'll be able to do hard hat test network optimism, and I'll give this a second to sort of finish up here.
00:18:31.236 - 00:18:41.438, Speaker B: Kevin's machine is chugging along while simultaneously screen sharing, downloading, like, 17 zoom videos and spinning up an L One blockchain and an L two blockchain.
00:18:41.534 - 00:19:01.482, Speaker C: And an L. Two blockchain. And the software that makes the two communicate with one another. But, hey, it works. All right, so I think we're ready. Now, sometimes it's a little bit slow because Ethers has an annoying little polling interval that takes 4 seconds. So sometimes it takes 4 seconds per test, which we need to fix.
00:19:01.482 - 00:19:16.094, Speaker C: I don't know why Ethers does this, but let's see. Great. So we are starting our test now. Come on. Go. There we go. So it starts and then there you go.
00:19:16.094 - 00:19:19.840, Speaker C: So you can see there's like this weird four second delay, which is.
00:19:22.130 - 00:19:22.542, Speaker B: Cool.
00:19:22.596 - 00:19:22.910, Speaker C: Okay.
00:19:22.980 - 00:19:36.082, Speaker B: Can I ask a question, Kelvin? What am I seeing right now? I'm actually seeing on the right hand side a bunch of transactions that are this ERC, 20 test transactions, but they're being run on L2.
00:19:36.136 - 00:19:52.346, Speaker C: On L two in your local l Two environment. So we showed how to do it to deploy to L One. Right? That's the flow that everyone is familiar with. Deploy in your C 20 to l one. This is just the basic flow of, like, okay, we deploy in your C 20 to L two. Now you can see again, this annoying four second delay. Whatever.
00:19:52.346 - 00:20:11.598, Speaker C: Anyway, point is, you deploy to L two. The whole point of this section is just to show you the similarities between deploying to optimism and deploying to L1. Perfect. Great. All right. So now we're going to keep this chain running in the background here. Whatever.
00:20:11.598 - 00:20:44.746, Speaker C: Sorry for all the spam. You know what, let's move it kind of into its own little corner. So that's the basic flow, right? That's all we did. It's just a basic ERC 20. We add this plugin, we add our optimism network, and we're good to go. But then let's go into sort of what the more interesting communication between the two systems looks like. So we've set up this example, this very minimal example of what it looks like when you want to deposit an ERC 20 on layer one.
00:20:44.746 - 00:21:03.522, Speaker C: This is locking it up on layer one, and then it sort of gets spit out on L2. And then we're going to do the whole process backwards. So we have these two files very similar. This is the same exact ERC 20 contract that we have in the tutorial. Boom. Nothing different. And the only difference is we have this L two deposited ERC 20.
00:21:03.522 - 00:21:48.894, Speaker C: So this is the sort of the contract that represents the tokens that have been sort of deposited from layer one. And essentially, we've kind of abstracted a few things for developers to create a nice interface. But we have these two handlers, one for withdrawals and one for deposits. You'll extend this or inherit this contract, which will give you these deposit and withdraw functions. And in this case, when a user calls withdraw, this function will be triggered. And in this case, you can see we're just burning the tokens on L2. Similarly, when tokens are deposited, we just mint on L2.
00:21:48.894 - 00:22:28.940, Speaker C: And a lot of this complexity is kind of hidden for you in this sort of helper contract that we've built. If you want to see sort of the low level information about how this works, you can take a look at this contract and get more information there. And then basically, the flow will be that we have a standard ERC 20. Nothing special about it. We're going to have a gateway contract and we're going to put funds into the gateway contract. And then when you lock up those funds in the gateway contract, they're sort of just going to appear on L2 after a little bit. And then we're going to burn those funds on L2 and we're going to sort of unlock them again in the gateway contract on layer one.
00:22:28.940 - 00:23:05.910, Speaker C: And this example JS file, you can ignore all this junk, but you can follow along. And it's pretty simple, right? We connect to both of our networks. We're going to have a wallet on each one of our chains, and then we have these two addresses that you don't really need to worry about. They're called the messengers. They're kind of the contracts that are responsible for doing this communication. And a watcher, which sort of just helps you see when a specific thing when a specific transaction, cross chain transaction has been finalized. So the flow is really simple.
00:23:05.910 - 00:23:34.122, Speaker C: Right? So step one, we deploy our ERC 20 to layer one. Simple. This is ethereum. ERC 20. Step two, we're going to deploy our ERC 20 to L2, right? So we're going to have two ERC 20s now, and this is that special deposited ERC 20 contract. Then step three, we're going to create this gateway, an ERC 20 gateway. This is a standardized contract that we provide for you so you can also look at that contract and understand how that works under the hood.
00:23:34.122 - 00:23:41.890, Speaker C: But the point is, it's sort of this contract on layer one that you hook up to both of the contracts. You say, this is the one on layer one, this is the one on L2.
00:23:42.040 - 00:23:53.382, Speaker B: So one way to think about it, am I right? Kelvin is like, the gateway on L1 is like the thing that was locking and unlocking on the top of my diagram. And then on L two, the thing that was minting and burning is the ERC 20.
00:23:53.436 - 00:23:54.242, Speaker C: Yeah, saddle.
00:23:54.306 - 00:23:55.014, Speaker B: Right, got it.
00:23:55.052 - 00:24:29.374, Speaker C: And the reason we've chosen this design pattern is just because a lot of people already have existing ERC 20s. You could, if you wanted to build this gateway directly into the ERC 20 implementation, but that's for another time anyway. So then once you've deployed the gateway onto layer one, you need to sort of initialize L2 and make it aware of the gateway, the L2, ERC 20. And so then we're going to show you what the balances are. Right, so on layer one, we should have some balance. On L2, we don't have anything. Then we're going to approve the gateway to spend some of our tokens.
00:24:29.374 - 00:25:02.554, Speaker C: We're going to call the deposit function and actually deposit those tokens into L2. We're going to wait for that deposit to be picked up on L2, and we're going to see that we have a balance on L2. And then we're going to do the process in reverse. We're going to withdraw the tokens back to layer one. We're going to wait for that withdrawal to be relayed and we're going to see that we have a balance. Right, so pretty straightforward. Now, we still have this node running here, so I'm just going to run the example and hopefully this all completely works great.
00:25:02.554 - 00:25:17.810, Speaker C: All right. So we can see it's deploying to layer one, then it's deploying to L2. Yes. And then we are deploying the gateway. We're initializing the L2 ERC 20. Boom. You can see that we have 1234 on layer one and zero on L2.
00:25:17.810 - 00:25:29.720, Speaker C: Now we're waiting. Now we have zero on layer one and 1234 on L2. Now we're waiting for it to come back. And it worked.
00:25:30.890 - 00:25:32.550, Speaker A: Oh, baby.
00:25:33.770 - 00:26:00.606, Speaker C: Yeah, it works. It's functional. Oh, yeah. So this is really the using these two examples, I think you can get a pretty clear idea of sort of what it takes to deploy just a basic contract to L2 and then what it takes to sort of build an application that communicates between layer one and L2. And this is where the really interesting stuff comes in. So I don't know if we had a slide for it.
00:26:00.788 - 00:26:01.982, Speaker B: We have a slide for it, yes.
00:26:02.036 - 00:26:05.386, Speaker C: For the info, of course. Where's the slide?
00:26:05.418 - 00:26:07.694, Speaker B: Of course, we got a slide. Should just be at the end of that presentation.
00:26:07.742 - 00:26:52.640, Speaker C: All right, we're going to switch you back to our slide so we can give you some information really quickly. All right, where are we? Okay, great. Okay, here we go. So if you would like to hack on Optimism, during this hackathon, we will be very much active on Discord. If you go to Optimism IO Discord, I think you should get redirected, assuming we set that up correctly. Otherwise, if you go to Community Optimism IO, you will find links to the Discord, and you will also find links to Docs and stuff like that. So we're going to make a hackathon channel on Discord, and if you'd like to learn more or if you'd like to start messing around, come hang and we will be around.
00:26:54.310 - 00:26:56.290, Speaker B: Sweet. Thanks, y'all.
00:26:56.790 - 00:27:23.654, Speaker A: Thank you, guys. That was great. That was really great. Thank you. Yeah, I mean, of course, the best way to communicate is through Discord at the moment, if you want to have feedback from if you want to make sure someone catches it within the eat global community, it can be easier. But of course, being directly connected to the optimism team, to their own discord works.
00:27:23.772 - 00:27:27.800, Speaker B: We'll go hang out at the we'll be in the Global Discord right after this.
00:27:31.410 - 00:27:32.254, Speaker A: No, for sure.
00:27:32.292 - 00:27:32.494, Speaker B: Yeah.
00:27:32.532 - 00:27:47.980, Speaker A: It would be great to see you there, everyone, if you I know there was a lot of questions. I'm not sure everybody got answered, so feel free to come and post them in the Global Discord Channel, and Kevin and Ben will be there for you. So thanks, everyone.
