00:00:31.340 - 00:00:42.850, Speaker A: Hello and welcome, everyone, to the scroll workshop scaling ethereum with roll ups and zero knowledge proofs. Joining us today is Daniel Helm who will be taking us through this session. And with that I will pass it over to Daniel to get the session started.
00:00:44.420 - 00:00:46.640, Speaker B: Hi everyone. Thanks for joining.
00:00:48.660 - 00:00:51.996, Speaker C: This is scaling ethereum with roll ups.
00:00:52.028 - 00:00:54.568, Speaker B: And zero knowledge proofs. And it section to scroll and the.
00:00:54.574 - 00:00:57.784, Speaker D: ZKE EVM Just for a heads up.
00:00:57.822 - 00:01:16.696, Speaker B: This is a pretty non technical talk hoping to give a real overview, get people's I don't know get the basic building blocks and mental models of roll ups there for people who it might still be confusing to. Our co founder Haish and gave a little bit of a demo going deep.
00:01:16.728 - 00:01:21.276, Speaker D: Into some of the architecture and how Zkevms work. So if that is up your alley.
00:01:21.308 - 00:01:24.012, Speaker B: A bit more, check out the YouTube recording.
00:01:24.076 - 00:01:26.050, Speaker D: But with that I'm going to jump in here.
00:01:26.580 - 00:01:27.836, Speaker C: I am Daniel Helm.
00:01:27.868 - 00:01:34.816, Speaker B: I lead developer relations at scroll. And if you are unfamiliar with scroll, we are building a scaling solution for.
00:01:34.838 - 00:01:38.180, Speaker D: Ethereum that is a ZK roll up. Okay?
00:01:38.250 - 00:01:50.356, Speaker B: So that might be a lot. If you don't know who we are, you might go to our website and you see this. You see the Native ZKE EVM scaling solution for ethereum. It's a Zkevm based ZK roll up on ethereum.
00:01:50.548 - 00:01:52.552, Speaker C: And all this jargon, right?
00:01:52.606 - 00:01:59.028, Speaker B: Like if you read this and you're unfamiliar with even what a scaling solution for Ethereum means, it might leave you.
00:01:59.054 - 00:02:00.316, Speaker D: Feeling a bit like this.
00:02:00.418 - 00:02:08.808, Speaker B: So the goal of this talk is to get people more accustomed to what this jargon means and get you started building and deploying on scroll.
00:02:08.904 - 00:02:12.720, Speaker D: If you're only kind of getting started with these kind of solutions.
00:02:14.180 - 00:02:22.320, Speaker B: But if you are new here and you only take away one thing, I want it to be that for users and devs scroll is pretty much Ethereum.
00:02:23.380 - 00:02:24.224, Speaker C: For the most part.
00:02:24.262 - 00:02:30.516, Speaker B: It's going to feel and look just like using Ethereum. And to show that, to make it a little bit less scary to think.
00:02:30.538 - 00:02:33.284, Speaker D: About ZK roll ups I want to do a quick live demo.
00:02:33.482 - 00:02:35.684, Speaker B: We could go to something like Uniswapv.
00:02:35.732 - 00:02:38.152, Speaker D: Three skirl IO, just a little demo.
00:02:38.206 - 00:02:41.656, Speaker B: Test app we've got here. And I could go to connect my.
00:02:41.678 - 00:02:45.930, Speaker C: Wallet and it's going to ask me to not connect.
00:02:47.100 - 00:02:52.716, Speaker B: Well, it'll ask me to connect. I do that and then it'll say that I need to connect to the.
00:02:52.738 - 00:02:56.344, Speaker D: Scroll alpha network which is a testnet.
00:02:56.392 - 00:03:04.572, Speaker B: That we deployed about a week and a half ago, maybe two weeks on top of Guerli. But I can then change my network.
00:03:04.716 - 00:03:08.828, Speaker C: Put in the amount of ridge Guerley.
00:03:08.844 - 00:03:11.500, Speaker B: ETH that maybe I want to wrap into WETH.
00:03:11.660 - 00:03:12.788, Speaker C: I can wrap those.
00:03:12.874 - 00:03:20.848, Speaker B: And just like interacting with any other DAP or smart contract here it's going to look and feel just like interacting.
00:03:20.864 - 00:03:22.592, Speaker D: With main net or a testnet.
00:03:22.736 - 00:03:24.256, Speaker B: The only difference being that the block.
00:03:24.288 - 00:03:26.128, Speaker D: Times are going to be a little bit faster.
00:03:26.224 - 00:03:28.616, Speaker B: So we'll get into a bit of.
00:03:28.638 - 00:03:30.488, Speaker D: That here in the middle of the talk.
00:03:30.574 - 00:03:34.872, Speaker B: But I just wanted to show nothing scary here. For the most part, you're just talking.
00:03:34.926 - 00:03:39.240, Speaker D: About interacting with what feels like Ethereum.
00:03:39.400 - 00:03:48.876, Speaker B: And that's by design. So let's get into understanding what scroll is, what we're building. And we have to start this kind.
00:03:48.898 - 00:03:52.720, Speaker D: Of story off with part one blockchain scalability.
00:03:54.100 - 00:04:12.020, Speaker B: So you're at an ETH global hackathon. I'm sure you know a little bit about the promise of Ethereum, right? But it is this platform for decentralized applications and we have this one network where we can share code and data, create all these new possibilities and it is open to all. Anyone can join in on doing this.
00:04:12.090 - 00:04:14.804, Speaker D: Great collective work where we are doing.
00:04:14.842 - 00:04:21.368, Speaker B: All sorts of new consensus problems and everyone joins in as long as there's not too many people at once, right?
00:04:21.454 - 00:04:22.504, Speaker C: This is the problem.
00:04:22.622 - 00:04:42.536, Speaker B: If you have too many people at once, you might run into this, right? You go to deploy your smart contract, you go to swap a token, maybe mint an NFT and you see that the estimated gas fee is insane, right? And that is not usability. You see this and you say, oh, maybe this network isn't open to me.
00:04:42.578 - 00:04:44.690, Speaker D: It no longer feels accessible to me.
00:04:45.460 - 00:05:05.428, Speaker B: So that's the scalability issue, right? And why do we run into this? Well, this is the issue of Ethereum blocks, which I'm sure this audience is very acquainted with. We have transactions that are asking the network to do some amount of work, right? Computational work. We measure these things in gas and every block can only do so much work. This is limited.
00:05:05.524 - 00:05:09.944, Speaker C: And at some point the block has.
00:05:09.982 - 00:05:14.628, Speaker B: To decide, okay, we have too much work, too many transactions. Who do we decide?
00:05:14.724 - 00:05:15.976, Speaker C: Well, we're going to choose the work.
00:05:15.998 - 00:05:17.668, Speaker B: Of the transactions that are paying the.
00:05:17.694 - 00:05:18.990, Speaker D: Most for that work.
00:05:20.000 - 00:05:21.676, Speaker C: And so this is generally just the.
00:05:21.698 - 00:05:24.092, Speaker D: Idea of block space that you'll hear, right?
00:05:24.146 - 00:05:34.480, Speaker B: If it fills up, gas prices increase in order to incentivize people to only make transactions that need to be making transactions. But you also are edging out people.
00:05:34.550 - 00:05:36.130, Speaker C: That can't afford it.
00:05:37.700 - 00:05:59.796, Speaker B: So people, this is the general problem. Scalability. As engineers and developers, I think the first thing we start to do is say, all right, that sounds like a problem, let's fix it. There's an annoyance. There's got to be an engineering solution here. And I think the first kind of approach you can take is say, well, let's make the chain do more work. If we can only do so much work in a block, let's just double.
00:05:59.828 - 00:06:00.996, Speaker D: That and then we half the fees.
00:06:01.028 - 00:06:02.410, Speaker C: And we're good to go, right?
00:06:03.260 - 00:06:15.596, Speaker B: Well, then we have to look back at Ethereum. Ethereum is this decentralized network of nodes and validators. And every time we have something happening on the network, right? Every single one of these nodes has.
00:06:15.618 - 00:06:16.588, Speaker D: To do that work.
00:06:16.674 - 00:06:25.696, Speaker B: Everyone has to do the work so they can come to consensus and say, this was our old state. We caught this transaction, did some work. This is our new state. And now we all agree on where.
00:06:25.718 - 00:06:26.930, Speaker C: The chain should be.
00:06:27.860 - 00:06:41.300, Speaker B: And so what we see when we look at that is that when you say make the chain do more work, what you're actually saying is make every single node in the network do more work.
00:06:41.370 - 00:06:41.796, Speaker C: Right?
00:06:41.898 - 00:06:48.056, Speaker B: And that can maybe become a problem because when you have a supercomputer, it's going to say, sure, I can do.
00:06:48.078 - 00:06:48.824, Speaker D: A lot more work.
00:06:48.862 - 00:06:54.376, Speaker B: Like ethereum is easy. A couple of transactions, doing a little bit of work, not a big deal.
00:06:54.558 - 00:06:55.844, Speaker C: But then when you look at people.
00:06:55.902 - 00:07:08.268, Speaker B: Running Raspberry PiS for their Validators smaller machines, maybe other resource constraints like bandwidth or whatever else, not so happy anymore, right? You start pricing out or resourcing out.
00:07:08.434 - 00:07:10.540, Speaker D: These players from your network.
00:07:11.360 - 00:07:20.128, Speaker B: And so then we have what was a happy, healthy network looking a bit more like this. And when we have all these sad nodes that can no longer participate in.
00:07:20.134 - 00:07:23.236, Speaker C: The network, the network becomes weaker, it.
00:07:23.258 - 00:07:27.216, Speaker D: Becomes more sensitive to bad actors.
00:07:27.408 - 00:07:29.430, Speaker C: And that's not what we want.
00:07:30.040 - 00:07:37.332, Speaker B: So this is a super high level understanding of one aspect of what we call the Scalability Trilemma.
00:07:37.396 - 00:07:39.684, Speaker D: This thing has a name, I'm sure, scaling Ethereum.
00:07:39.732 - 00:07:41.930, Speaker B: You've heard this stated many times.
00:07:42.460 - 00:07:44.420, Speaker C: But the general gist of the Scalability.
00:07:44.500 - 00:07:49.596, Speaker B: Trilemma is this you have to pick two of these three items at the.
00:07:49.618 - 00:07:51.068, Speaker D: Tips of the triangle, right?
00:07:51.154 - 00:07:55.240, Speaker B: You need to be scalable or secure or decentralized.
00:07:55.400 - 00:07:58.590, Speaker D: As a blockchain network, you only get to pick two.
00:07:59.040 - 00:08:00.736, Speaker C: So when we said let's make the.
00:08:00.758 - 00:08:44.120, Speaker B: Chain do more work, what we were really doing is going with this typical high TPS chain solution, right? Maybe the Solana solution, where we might resource out. We push out resource weak nodes in our network, but in an effort to scale it. So what's our new solution? Well, what if we said make a new network? We can just spin up a whole new one, right? This might look like this. We have a whole bunch of Validators on Ethereum and we can just kind of split them in half. And we'll say on the left half you'll still be called Ethereum, but on the right half we'll call you Ethereum Prime. You'll be this kind of other network that looks and feels and acts just like Ethereum.
00:08:44.200 - 00:08:48.270, Speaker C: But now we have twice as much block space, right? This is great.
00:08:49.440 - 00:09:00.432, Speaker B: Well, this is great until we start seeing that. Now we have maybe half the amount of security, half the amount of Validators that are securing each network. So now the network on the left.
00:09:00.486 - 00:09:03.936, Speaker D: Becomes more prone to bad actors.
00:09:04.128 - 00:09:08.916, Speaker B: Not to mention we also have to figure out how to bridge this divide of the line that's now separating the.
00:09:08.938 - 00:09:11.460, Speaker D: Networks because we have two blockchain networks.
00:09:12.840 - 00:09:16.584, Speaker B: And so this might be considered like the MultiChain ecosystem, right?
00:09:16.622 - 00:09:18.936, Speaker D: This is another solution that you'll see.
00:09:19.038 - 00:09:20.824, Speaker B: In the space, but it has its.
00:09:20.862 - 00:09:23.690, Speaker D: Trade offs and things we don't like about.
00:09:27.500 - 00:09:35.336, Speaker B: Yeah, that's the Scalability Trilemma in a nutshell. If you want to learn more about this, we're going to keep talking about it. But Vitalik has kind of a classic.
00:09:35.368 - 00:09:43.330, Speaker D: Blog post that introduces this idea. So if you just search like Vitalik Scalability Trilemma, I bet you'll find it.
00:09:43.940 - 00:09:46.636, Speaker C: So let's jump into part two, layer.
00:09:46.668 - 00:09:48.896, Speaker B: Twos and roll ups. How are we going to try and.
00:09:48.918 - 00:09:51.490, Speaker D: Get around this annoying problem?
00:09:52.360 - 00:10:05.896, Speaker B: Well, remember, we've got Ethereum, this great decentralized network that we've done all this work to make secure. And we said that what it does is it does work, right? It has blocks and every block it.
00:10:05.918 - 00:10:08.548, Speaker C: Does a big chunk of work modeled.
00:10:08.564 - 00:10:10.330, Speaker D: Here by a beautiful gray box.
00:10:11.020 - 00:10:20.540, Speaker B: But what if we break down this box into the sub work that it does? And maybe this is our minting an NFT, this is our swapping some tokens.
00:10:21.040 - 00:10:23.436, Speaker C: And try to imagine what would it.
00:10:23.458 - 00:10:31.408, Speaker B: Look like if we took some piece of Ethereum's work and we said, okay, what if we just devoted that work.
00:10:31.574 - 00:10:33.932, Speaker C: To securing some other network?
00:10:33.996 - 00:10:51.604, Speaker B: What if we made sure that a new network wasn't breaking its rules using work on Ethereum? So this is kind of the novel idea here, right? What we can do is we can have an off chain protocol that we secure using Ethereum. So some kind of like definitions here.
00:10:51.642 - 00:10:53.604, Speaker C: We have a L2 and it.
00:10:53.642 - 00:10:58.760, Speaker B: Exists as its own off chain protocol using a layer one as an important.
00:10:58.830 - 00:11:00.052, Speaker D: Piece of its architecture.
00:11:00.116 - 00:11:01.816, Speaker B: And we call this being deployed on.
00:11:01.838 - 00:11:03.290, Speaker D: Top of that layer one.
00:11:04.460 - 00:11:05.704, Speaker C: When we get into the idea of.
00:11:05.742 - 00:11:18.992, Speaker B: Roll ups specifically, we're going to be using that layer one for certain security guarantees. So that could be ordering our transactions. That could be data availability, censorship resistant correctness things that you can go find.
00:11:19.046 - 00:11:26.080, Speaker D: Probably more technical talks about in the larger scaling Ethereum presentations.
00:11:28.100 - 00:11:41.440, Speaker B: But the kind of key insight here is that when we talk about roll ups on Ethereum, what we want to do is inherit the security of Ethereum. And that's the word that gets used by taking all these things that are these security guarantees.
00:11:41.520 - 00:11:43.988, Speaker C: We get to outsource them from the.
00:11:43.994 - 00:11:46.232, Speaker B: Perspective of the off chain protocol and.
00:11:46.286 - 00:11:49.370, Speaker D: Rely on Ethereum to take care of these things.
00:11:50.620 - 00:11:54.984, Speaker B: And so what that looks like in our triangle here is that we get.
00:11:55.022 - 00:11:57.770, Speaker D: Ethereum to lock down our security side.
00:11:58.140 - 00:12:01.052, Speaker C: And at that point we can actually.
00:12:01.106 - 00:12:16.832, Speaker B: Start to say things like make a new network and make the chain do more work, right? Because we no longer have the issue of these security aspects and we can move towards scalability by doing both of these things. We can make a new network that is able to do more work but.
00:12:16.886 - 00:12:21.490, Speaker D: Still inherit the security that Ethereum brings to us.
00:12:23.700 - 00:12:32.016, Speaker B: So you've probably seen a ton of these different projects that build on this, right? We have a layer one, like Ethereum, and then we have all these layer.
00:12:32.048 - 00:12:38.890, Speaker D: Twos and a whole ecosystem of them. And you can see some icons here, but scroll is playing in this space as well.
00:12:42.060 - 00:12:44.612, Speaker C: So we're playing this game of engineers.
00:12:44.676 - 00:12:58.044, Speaker B: We're designing our way to scale Ethereum. We've already decided that Ethereum can give us our security. But what should we make our roll up do, right? Because now we just have an off chain protocol. We haven't specified anything about it.
00:12:58.082 - 00:13:00.510, Speaker D: We can do it whatever we want here.
00:13:01.520 - 00:13:11.792, Speaker B: And maybe the insight that I would bring here is that Ethereum has an incredible ecosystem already. We're all kind of a part of this community by being part of things like ETH global.
00:13:11.936 - 00:13:14.836, Speaker C: And we already get to gain the.
00:13:14.858 - 00:13:24.596, Speaker B: Benefits of the tools, the educational resources, the users, the communities, the smart contracts. All of these things preexist in the Ethereum ecosystem and they're what make it.
00:13:24.618 - 00:13:28.120, Speaker D: So rich and kind of like so attractive to developers.
00:13:29.260 - 00:13:30.792, Speaker C: And so the kind of question is.
00:13:30.846 - 00:13:34.056, Speaker B: If we're going to inherit Ethereum security, why not try to inherit all of.
00:13:34.078 - 00:13:35.016, Speaker D: These things too, right?
00:13:35.038 - 00:13:41.964, Speaker B: Like, why make someone learn a whole new paradigm if we can make these things also kind of get extracted into.
00:13:42.082 - 00:13:44.060, Speaker D: What we're building on top of Ethereum?
00:13:45.680 - 00:13:48.284, Speaker C: And so where we can let's just.
00:13:48.322 - 00:13:50.968, Speaker D: Behave like Ethereum's virtual machine.
00:13:51.144 - 00:14:08.464, Speaker B: That's the thing that takes in the transactions and does the work on the network. If we can just mimic that as closely as possible, then we're in a special position where all of the tools and resources and communities can just basically copy paste their code and redeploy somewhere.
00:14:08.512 - 00:14:12.550, Speaker D: Else and benefit from the scalability benefits.
00:14:13.480 - 00:14:16.884, Speaker B: And surprise, surprise, this is what scroll.
00:14:16.932 - 00:14:18.810, Speaker D: Is doing and this is what we're building.
00:14:19.340 - 00:14:22.184, Speaker C: So let's get a little bit more.
00:14:22.222 - 00:14:32.910, Speaker B: Into the technicals of how we're doing that. But generally, like I said, for most users in Devs, using scroll is just like using Ethereum. And that's because we're designed in this way here.
00:14:35.520 - 00:14:36.076, Speaker C: Okay?
00:14:36.178 - 00:14:41.824, Speaker B: So we said we're going to use some of Ethereum's work to make sure that an off chain protocol, a new.
00:14:41.862 - 00:14:44.400, Speaker D: Network, isn't breaking its rules.
00:14:45.860 - 00:14:47.744, Speaker B: There's different flavors of this and different.
00:14:47.782 - 00:14:50.480, Speaker D: Rollups are doing different ways to approach this.
00:14:50.630 - 00:15:03.844, Speaker B: So you've got Skrull on the top here and a project like optimism or Arbitrum on the bottom. If you've learned anything about them, you have probably heard them labeled as optimistic roll ups, right?
00:15:04.042 - 00:15:05.476, Speaker C: And what they do is they have.
00:15:05.498 - 00:15:29.728, Speaker B: Something called a fraud proof or a fault proof. The idea is that they do a bunch of data, they do a bunch of work off chain, but they put the transaction data back on the l one. And then they wait a little while and they say, we're going to assume that this is all good to go. And then we'll give someone seven days to say, no, someone's breaking the rules. And if no one says that, then.
00:15:29.894 - 00:15:35.120, Speaker D: We'Ll just continue knowing that everything's good in the off chain protocol.
00:15:37.300 - 00:15:39.344, Speaker B: Now, scroll, on the other hand, we.
00:15:39.382 - 00:15:40.944, Speaker D: Are not an optimistic roll up.
00:15:40.982 - 00:15:44.004, Speaker B: We are a ZK roll up back to this kind of jargon thing, a.
00:15:44.042 - 00:15:45.732, Speaker D: Zero knowledge roll up.
00:15:45.866 - 00:15:47.364, Speaker B: And let's take a look a little.
00:15:47.402 - 00:15:53.792, Speaker D: Bit at what is securing scroll. If we don't have the optimistic ideas.
00:15:53.856 - 00:15:56.776, Speaker C: Of the other roll ups, to get.
00:15:56.798 - 00:16:01.700, Speaker B: Into this, we're going to need a super fast primer on zero knowledge proofs.
00:16:01.860 - 00:16:03.956, Speaker C: So, deep breath.
00:16:03.988 - 00:16:08.796, Speaker B: We've made it through two parts. We've looked at the scalability problem, we've looked at kind of the protocol and.
00:16:08.898 - 00:16:11.710, Speaker D: How layer ones can secure our L2.
00:16:13.600 - 00:16:14.684, Speaker C: But now we have to get into.
00:16:14.722 - 00:16:16.216, Speaker B: This kind of magic of zero knowledge.
00:16:16.248 - 00:16:21.048, Speaker C: Proofs, which I think can oftentimes get.
00:16:21.074 - 00:16:24.656, Speaker B: Really complicated, really mathy. But hopefully this is going to be.
00:16:24.678 - 00:16:27.664, Speaker D: The simplest explanation you've ever seen, and.
00:16:27.702 - 00:16:29.376, Speaker B: It'Ll hopefully get you the gist of.
00:16:29.398 - 00:16:30.530, Speaker D: What you need to know.
00:16:31.780 - 00:16:34.020, Speaker B: So let's do a little thought experiment.
00:16:34.520 - 00:16:35.696, Speaker C: What if we had a big block.
00:16:35.728 - 00:16:41.940, Speaker B: Of work, any sort of work, and we wanted to do this work over some sort of data or input?
00:16:43.000 - 00:16:44.452, Speaker C: And it's a lot of work.
00:16:44.506 - 00:16:47.144, Speaker B: It's a really big amount of work that can only be done by an.
00:16:47.182 - 00:16:48.984, Speaker D: Army of supercomputers, right?
00:16:49.102 - 00:16:51.368, Speaker B: A really crazy amount.
00:16:51.534 - 00:16:53.064, Speaker C: But we can imagine that we had.
00:16:53.102 - 00:17:19.616, Speaker B: This special magical wand that made a receipt of that work, and that proof of the work could be then passed to a much smaller computer that had a different program that was used to just verify it. So this smaller computer didn't have to go redo all the work. It maybe didn't even have to look back at the data. But somehow there was a magical incantation that could create a receipt where we were able to verify the proof and.
00:17:19.638 - 00:17:21.360, Speaker D: Just kind of trust the output.
00:17:22.180 - 00:17:29.984, Speaker B: All right, this seems pretty magical. So magical that I think we'd have to use a time machine to get something like this. We'd have to take the time machine.
00:17:30.032 - 00:17:33.430, Speaker C: All the way back to 1991.
00:17:33.740 - 00:18:01.840, Speaker B: Okay, so in 1991, we had a field emerging with papers like checking computations and polylogarithmic time. And in the summary abstract here, you'll see descriptions. Like in this setup, a single reliable PC can monitor the operation of a herd of supercomputers working with possibly extremely powerful but unreliable software and untrusted hardware.
00:18:02.260 - 00:18:05.584, Speaker C: So this is the idea of our.
00:18:05.622 - 00:18:07.856, Speaker B: Small little raspberry Pi being able to.
00:18:07.878 - 00:18:11.830, Speaker D: Verify the work of an army of supercomputers, right?
00:18:12.840 - 00:18:14.804, Speaker C: So this is a field that's been.
00:18:14.842 - 00:18:19.444, Speaker B: Around for a while. Recently, it's been evolving very quickly.
00:18:19.642 - 00:18:23.140, Speaker D: And this is the field of zero knowledge proofs.
00:18:23.640 - 00:18:44.984, Speaker B: So we can change our kind of hypothetical here. And to better understand how we're using zero knowledge proofs, we can say what if the work being done is not just some random work? What if the work being done is actually the EVM? And what we have as input are a bunch of transactions. So we had new transactions, the EVM.
00:18:45.032 - 00:18:48.700, Speaker D: Processes them and updates us to the newest state of the blockchain.
00:18:49.360 - 00:18:50.796, Speaker C: And what if the network was not.
00:18:50.818 - 00:18:55.216, Speaker B: A bunch of supercomputers, but a network like scroll? So what if scroll was doing this.
00:18:55.238 - 00:18:59.600, Speaker C: Kind of work and we need someone that we know.
00:18:59.670 - 00:19:02.724, Speaker B: We might not trust scroll as a network, but we need something that we.
00:19:02.762 - 00:19:05.376, Speaker D: Trust to verify this proof or receipt.
00:19:05.488 - 00:19:09.364, Speaker B: And we trust Ethereum, right? We trust the computations that are done.
00:19:09.402 - 00:19:12.816, Speaker D: There because of all the reasons that we love Ethereum.
00:19:12.928 - 00:19:19.992, Speaker B: And so we can use a little bit of that computational work on Ethereum to verify the proof of everything off.
00:19:20.046 - 00:19:23.284, Speaker D: Chain happening on scroll and say yep.
00:19:23.332 - 00:19:27.756, Speaker B: Scroll's following the rules. Scroll is acting just like an EVM should act.
00:19:27.858 - 00:19:33.390, Speaker D: And now we can trust now that we've verified that the next state is the true state.
00:19:34.720 - 00:19:43.520, Speaker B: Okay, this explanation totally ignores this idea of private inputs into zero knowledge proofs. This is things like privacy protocols.
00:19:43.860 - 00:19:45.856, Speaker D: A ZKE EVM doesn't need these, so.
00:19:45.878 - 00:19:52.064, Speaker B: I'm glossing over them here. But just so you know, this is a whole nother fascinating and exciting part.
00:19:52.102 - 00:19:53.516, Speaker D: Of zero knowledge proofs.
00:19:53.628 - 00:19:55.712, Speaker B: But we are not using the privacy aspect.
00:19:55.776 - 00:20:04.840, Speaker D: We are using what's called the succinctness aspect of this proofs. And so we're able to take a bunch of computation and smush it down into a tiny proof.
00:20:07.660 - 00:20:10.244, Speaker B: Okay, so scroll it is a ZK.
00:20:10.292 - 00:20:14.644, Speaker C: Roll up and on chain, on layer.
00:20:14.692 - 00:20:22.252, Speaker B: One, we have a smart contract that is a ZKE EVM proof verifier. And so we are able to pass.
00:20:22.306 - 00:20:30.080, Speaker D: Proofs to that verifier along with some other data in order to say we are secured as an off chain protocol.
00:20:32.580 - 00:20:38.064, Speaker C: All right, so part four into scroll. Now. Why?
00:20:38.102 - 00:20:42.416, Speaker B: Scroll? So I talked a little bit about this, but ultimately we've designed scroll so.
00:20:42.438 - 00:20:45.148, Speaker D: That it has great developer experience in.
00:20:45.174 - 00:20:50.836, Speaker B: Terms of other roll ups, you might hear of other ZKE EVMs. But what is important about scroll is.
00:20:50.858 - 00:20:53.488, Speaker D: That we are bytecode equivalent with the EVM.
00:20:53.584 - 00:20:57.044, Speaker C: That means when you compile your smart.
00:20:57.092 - 00:21:00.468, Speaker B: Contract, you end up with some bytecode.
00:21:00.564 - 00:21:03.032, Speaker D: And those things refer to different opcodes and stuff.
00:21:03.086 - 00:21:05.476, Speaker C: But that bytecode that you would commit.
00:21:05.508 - 00:21:07.608, Speaker B: On mainnet is the exact same bytecode.
00:21:07.624 - 00:21:09.528, Speaker D: That you would put on our network.
00:21:09.704 - 00:21:12.524, Speaker B: Which gives it really good compatibility with.
00:21:12.562 - 00:21:14.984, Speaker D: Developer tooling existing contracts.
00:21:15.032 - 00:21:16.216, Speaker B: You don't have to go re audit.
00:21:16.248 - 00:21:19.856, Speaker D: Anything because you're not just compatible with.
00:21:19.878 - 00:21:21.616, Speaker B: Solidity as a language, but what the.
00:21:21.638 - 00:21:23.490, Speaker D: Solidity compiles down into.
00:21:26.660 - 00:21:28.896, Speaker C: Scroll now, as.
00:21:28.918 - 00:21:33.036, Speaker B: This off chain protocol gives us a lot more throughput. And so we have created more secure.
00:21:33.068 - 00:21:35.668, Speaker D: Block space for Ethereum, which means that.
00:21:35.754 - 00:21:47.064, Speaker B: Scroll is going to save your users in gas fees. And because we're able to do this work faster, we can also get quicker feedback to users. So scroll aims at having about three.
00:21:47.102 - 00:21:50.730, Speaker D: Second block times compared to Ethereum's twelve.
00:21:52.620 - 00:21:59.036, Speaker B: And the last thing that I think is like a why scroll that I like to emphasize is alignment, right? So we like to really believe that.
00:21:59.058 - 00:22:01.020, Speaker D: We'Re building on Ethereum's vision.
00:22:02.080 - 00:22:04.396, Speaker C: This plays out in a lot of.
00:22:04.418 - 00:22:17.472, Speaker B: Ways but the way I like to think about it is that there's scaling Ethereum the technology, but there's also scaling community, there's scaling ethos, there's scaling all these things that aren't purely technological that.
00:22:17.526 - 00:22:20.050, Speaker D: Make Ethereum a special community.
00:22:20.580 - 00:22:37.668, Speaker B: And we try to be heavily aligned with those things. And I think it comes through also in our origins. We are an open source project. We initially actually came out of work on the Ethereum Foundation's privacy and Scaling Explorations Project where they're building a zkevm.
00:22:37.764 - 00:22:41.908, Speaker D: And we're still constantly committing code back to that repo.
00:22:42.084 - 00:22:44.404, Speaker B: And if you're more interested in alignment.
00:22:44.452 - 00:22:51.150, Speaker D: And our vision for long term check out our website and some of the blog articles there.
00:22:52.640 - 00:22:53.948, Speaker C: So I'd like to just take a.
00:22:53.954 - 00:22:55.708, Speaker B: Quick look at what it looks like.
00:22:55.874 - 00:22:58.280, Speaker D: As transactions come into our sequencer.
00:22:58.360 - 00:22:59.950, Speaker B: So like on a layer one.
00:23:01.780 - 00:23:02.336, Speaker C: Well.
00:23:02.438 - 00:23:05.456, Speaker B: Let'S jump into a L2. We have transactions, they come into a.
00:23:05.478 - 00:23:07.404, Speaker D: Sequencer and they get executed.
00:23:07.452 - 00:23:08.000, Speaker C: Right?
00:23:08.150 - 00:23:13.520, Speaker B: Our execution environment is just guessed if you're familiar with it, just slightly modified.
00:23:14.260 - 00:23:18.244, Speaker C: But what happens is our sequencer does a few things.
00:23:18.282 - 00:23:25.830, Speaker B: It's going to execute transactions that are coming in. It's also going to watch for new deposits and our bridge contract on the layer one.
00:23:26.360 - 00:23:27.800, Speaker C: And then it's going to roll up.
00:23:27.870 - 00:23:35.796, Speaker B: These not blocks but batches of blocks and say all that call data, all this transaction data, it's going to stick.
00:23:35.828 - 00:23:41.560, Speaker D: That back on Ethereum and that's for data availability purposes.
00:23:41.720 - 00:23:47.848, Speaker B: So all the swaps and mints that you're doing, that data actually gets committed to Ethereum.
00:23:48.024 - 00:23:53.744, Speaker C: So that later when we use approver to create a proof, we can also.
00:23:53.782 - 00:23:55.936, Speaker B: Commit the proof on chain and that.
00:23:55.958 - 00:23:59.136, Speaker C: Roll up contract can say for all.
00:23:59.158 - 00:24:01.344, Speaker B: This data coming in and the old.
00:24:01.462 - 00:24:04.720, Speaker C: State, we can say this new proof.
00:24:04.880 - 00:24:07.670, Speaker D: We can verify the update to that state.
00:24:08.600 - 00:24:10.964, Speaker B: And this prover here is oversimplified because.
00:24:11.002 - 00:24:13.488, Speaker D: This is actually a whole proving network.
00:24:13.664 - 00:24:22.616, Speaker B: And the goal right now is to get main net out and then the next work is to make this a fully decentralized prover network so that it.
00:24:22.638 - 00:24:27.240, Speaker D: Is open and permissionless for anyone to provide proofs for scroll.
00:24:27.820 - 00:24:34.780, Speaker B: And then the beautiful goal after that is to decentralize our sequencer. But this is a pretty complicated design.
00:24:34.850 - 00:24:39.310, Speaker D: Space and we're still working through exactly what the details of that are going to be.
00:24:42.980 - 00:24:47.856, Speaker B: Yeah, so I'm going to just block by block give a walkthrough of what.
00:24:47.878 - 00:24:49.696, Speaker D: It looks like when transactions come in.
00:24:49.718 - 00:25:07.080, Speaker B: On scroll running a tight on time. So I'm going to try to do this quickly. But we can imagine scroll having all of these blocks that come in. We can batch these together and then literally write that to Ethereum. And then once we have the proof generated at a later block on Ethereum.
00:25:07.660 - 00:25:10.330, Speaker D: Commit that to Ethereum as well.
00:25:11.500 - 00:25:17.224, Speaker B: And so you can think about different transactions having different states. I won't get too much into this.
00:25:17.342 - 00:25:21.012, Speaker C: But when a transaction is in scroll.
00:25:21.076 - 00:25:25.064, Speaker B: At all, we can call it pre committed. Once we've written that back to Ethereum.
00:25:25.112 - 00:25:28.028, Speaker D: You can consider that committed. We've committed to that data.
00:25:28.194 - 00:25:33.136, Speaker B: But not until that proof has been finalized on chain can we really say.
00:25:33.158 - 00:25:35.052, Speaker D: That the transaction is finalized.
00:25:35.196 - 00:25:40.624, Speaker B: And so this could be 20 minutes, but that's quite different than the seven.
00:25:40.662 - 00:25:43.540, Speaker D: Day waiting period for optimistic roll ups.
00:25:45.560 - 00:25:48.212, Speaker C: And what this looks like kind of working across time.
00:25:48.266 - 00:25:55.344, Speaker B: We can imagine transactions coming into our sequencer that get bundled in a block. The data and call data from that.
00:25:55.402 - 00:26:02.100, Speaker D: Get committed onto the roll up contract on L One. And we now have that block being committed.
00:26:02.180 - 00:26:06.404, Speaker C: Right. That information then gets passed to the coordinator.
00:26:06.452 - 00:26:21.536, Speaker B: We call this a trace of the work that's done and that gets passed to approver who's going to generate a proof. This might take several blocks, but that's okay. We can make these things in parallel. And so we can go through and create a handful of these blocks and.
00:26:21.558 - 00:26:24.400, Speaker D: Keep passing them off to different proof generators.
00:26:25.780 - 00:26:33.212, Speaker B: Eventually, these proofs will get created. And this is actually our pre alpha network. On Alpha.
00:26:33.276 - 00:26:37.796, Speaker D: We have blocks. We have batches of these blocks that.
00:26:37.898 - 00:26:39.556, Speaker B: Kind of similar to this will then.
00:26:39.578 - 00:26:41.700, Speaker D: Get committed on chain and verified.
00:26:42.120 - 00:26:43.476, Speaker B: And so now we see that once.
00:26:43.498 - 00:26:46.544, Speaker C: We'Ve verified this, all the blocks included.
00:26:46.592 - 00:26:51.720, Speaker D: In it are now finalized. And that's kind of those states that I described earlier.
00:26:53.180 - 00:26:55.064, Speaker C: If you're interested in diving deeper into.
00:26:55.102 - 00:26:58.350, Speaker D: This, we have a roll up explorer that shows a little bit of how this works.
00:26:59.680 - 00:27:04.456, Speaker B: But remember, for most users in Devs, scroll is pretty much Ethereum, but faster.
00:27:04.488 - 00:27:07.310, Speaker D: Cheaper, and accessible to more users at once.
00:27:08.480 - 00:27:13.404, Speaker B: If you're interested in trying out scroll, we launched our alpha testnet on Guerly.
00:27:13.532 - 00:27:18.784, Speaker C: About two weeks ago, and you can use it.
00:27:18.902 - 00:27:24.188, Speaker B: As you saw, I used our uniswap example here, but all it takes is.
00:27:24.214 - 00:27:27.236, Speaker D: An RPC change to deploy there or.
00:27:27.258 - 00:27:28.550, Speaker C: To interact with it.
00:27:29.160 - 00:27:34.116, Speaker B: It's on top of Guerly. And if you need some bridged Guerly, don't hesitate to reach out in the.
00:27:34.138 - 00:27:38.980, Speaker D: ETHGlobal discord and the scroll channel. Let us know and we will send you some Guerli.
00:27:39.580 - 00:27:41.128, Speaker C: If you're interested in looking at how.
00:27:41.134 - 00:27:42.856, Speaker B: To connect your wallet, testing out the.
00:27:42.878 - 00:27:45.480, Speaker D: Bridge, that's at scroll IO Alpha.
00:27:45.820 - 00:28:14.160, Speaker B: And really importantly, we have guide Scroll IO and there you'll find our developer documentation. So if you go here, you'll find our developer info. But most importantly, you'll find our developer Quickstart, which not only shows the network information, but also copy pasting lines for Hard Hat, Foundry Remix, Truffle Brownie, Ethers.
00:28:14.240 - 00:28:20.420, Speaker D: And Scaffold ETH to get going with just some copy pastes into your current deployment.
00:28:27.610 - 00:28:50.378, Speaker B: So if you're going to be hacking, just want to do one last show for our prizes. We're going to have $20,000 in prizes in total. We have a prize pool for just deploying your smart contract on scroll. No matter what other prizes you apply to, you can deploy on scroll as well to be part of our prize pool for $10,000. We also have a track for Applied ZK projects. We don't expose any of those ZK primitives we talked about, but if you're.
00:28:50.394 - 00:28:52.954, Speaker D: Building in ZK, we want you on our chain.
00:28:53.002 - 00:29:03.186, Speaker B: So we've got two prizes for $2,500, and then we have the last one here called Cheap and Fast Block Space Utilizer. And we really just want to see.
00:29:03.208 - 00:29:06.022, Speaker D: People testing the design space of what.
00:29:06.156 - 00:29:08.614, Speaker B: Is possible with cheaper gas fees and.
00:29:08.652 - 00:29:13.010, Speaker D: Three second confirmation times from the DAP perspective.
00:29:13.170 - 00:29:18.074, Speaker C: So check out our prizes and happy.
00:29:18.112 - 00:29:20.602, Speaker B: To answer questions if I have 60.
00:29:20.656 - 00:29:22.060, Speaker D: Seconds to do so.
00:29:23.950 - 00:29:25.500, Speaker C: Yeah, you've got some time.
00:29:27.470 - 00:29:40.830, Speaker A: There was one question about from stephen, how long does it usually take for scroll to go through a ZKP? From pre commit to finalized, and what are the differences between scroll and ZK Sync polycon and ZKE EVM?
00:29:41.650 - 00:29:42.526, Speaker C: Great question.
00:29:42.628 - 00:29:51.006, Speaker B: So from pre commit to finalized, pre commit to committed is the fast one, right? Basically, we wait until there's enough blocks.
00:29:51.118 - 00:29:56.106, Speaker D: To fill up about 50 million gas, which just depends on how much activity.
00:29:56.158 - 00:30:01.234, Speaker B: There is on the network. But let's say it's 9 seconds and then we make a transaction on Ethereum.
00:30:01.282 - 00:30:03.800, Speaker D: And so then we're committed there.
00:30:05.610 - 00:30:18.986, Speaker B: The longer one is the proof. When we hit main net, I believe the goal is for those to always come in at under 20 minutes. Right now, I don't know that we.
00:30:19.008 - 00:30:21.246, Speaker D: Have enough Provers on the network to.
00:30:21.268 - 00:30:26.206, Speaker C: Keep up with the demand, but the.
00:30:26.228 - 00:30:27.326, Speaker D: Fast way to check is to check.
00:30:27.348 - 00:30:31.326, Speaker C: Our Roll Up Explorer, and you can.
00:30:31.348 - 00:30:35.758, Speaker B: See that the last handful of blocks, because they're coming in very quickly, are all in pre committed.
00:30:35.854 - 00:30:38.114, Speaker D: But let's just say we looked at.
00:30:38.312 - 00:30:39.698, Speaker B: Quite a few here.
00:30:39.864 - 00:30:53.758, Speaker C: We have a lot committed, and so.
00:30:53.924 - 00:30:56.094, Speaker B: I've already gone back an hour, and.
00:30:56.132 - 00:30:57.374, Speaker D: These are still at committed.
00:30:57.422 - 00:30:59.266, Speaker B: So it seems like our Provers are.
00:30:59.288 - 00:31:01.186, Speaker D: Not keeping up with the amount of.
00:31:01.208 - 00:31:06.360, Speaker C: Transactions we're having coming in, which is.
00:31:06.890 - 00:31:08.278, Speaker B: A blessing and a curse to have.
00:31:08.284 - 00:31:10.790, Speaker D: A whole lot of testnet activity on your network.
00:31:11.210 - 00:31:14.694, Speaker B: But, yeah, right now it seems like it is several hours.
00:31:14.892 - 00:31:18.414, Speaker D: But yeah, 20 minutes is where we're.
00:31:18.482 - 00:31:20.246, Speaker B: Aiming for, but we have to scale.
00:31:20.278 - 00:31:21.658, Speaker D: Up the number of Provers on the.
00:31:21.664 - 00:31:24.682, Speaker C: Network to do that. Okay.
00:31:24.816 - 00:31:28.614, Speaker B: What are the differences between scroll and ZK? Sync and polygon?
00:31:28.662 - 00:31:29.930, Speaker D: ZKE EVM.
00:31:30.830 - 00:31:52.306, Speaker B: One. Of the major differences between us and ZK Sync is that idea that I described earlier where ZK Sync is what we call language compatible with solidity. And so you are taking Solidity, you're compiling it into an environment for their VM whereas Polygon and ourselves have a.
00:31:52.328 - 00:31:54.238, Speaker D: Model where we are bytecode compatible.
00:31:54.334 - 00:31:55.846, Speaker B: You are compiling it just like you.
00:31:55.868 - 00:32:00.710, Speaker D: Would for Mainnet and that thing gets deployed on our networks.
00:32:01.130 - 00:32:07.420, Speaker B: There are other kind of architectural differences about the approach that us and Polygon are taking.
00:32:08.910 - 00:32:11.606, Speaker C: I don't think I want to dive.
00:32:11.638 - 00:32:13.980, Speaker D: Too deeply in there, but yeah.
00:32:15.310 - 00:32:18.422, Speaker C: So curious.
00:32:18.566 - 00:32:22.480, Speaker D: What are popular use cases of scroll at the moment?
00:32:24.130 - 00:32:47.038, Speaker B: So right now? Yeah, it's been two weeks. We are a general application platform and so really what we've been mostly seeing are the things that we've been encouraging people to make. And so at ETH Denver two weeks ago, we got a lot of projects that were like applied ZK because we had Bounties there. We had a lot of projects around.
00:32:47.144 - 00:32:50.278, Speaker D: Decentralized social media because we had a bounty for that.
00:32:50.444 - 00:32:54.614, Speaker B: But we've also had a handful of game devs using scroll, which is really.
00:32:54.652 - 00:32:56.774, Speaker D: Exciting because that's a place where cheap.
00:32:56.822 - 00:33:03.146, Speaker B: Transactions and fast transactions are really helpful and in general, just anything designed for.
00:33:03.168 - 00:33:07.206, Speaker D: Ethereum already it's a good use case for scroll.
00:33:07.398 - 00:33:22.718, Speaker B: And yeah, we've also gone through some governance processes for projects like Uniswap and Ave and so on our testnet we'll have those contracts that you can interact with. The Uniswap ones are live, but the.
00:33:22.724 - 00:33:29.890, Speaker D: Ave ones are still a little bit away. If you want to interact with pre existing environments on scroll.
00:33:32.310 - 00:33:33.042, Speaker B: Is it possible.
00:33:33.096 - 00:33:35.990, Speaker D: To use scroll with Snarkjs or Iden?
00:33:36.970 - 00:33:38.818, Speaker C: I know the answer for Snarkjs.
00:33:38.914 - 00:33:39.654, Speaker B: Yes.
00:33:39.852 - 00:33:42.440, Speaker C: Just like you can.
00:33:44.170 - 00:33:56.246, Speaker B: Yeah, basically I think the setup for that I'm not a ZK developer, but my understanding is that in Cairo you can compile a solidity contract to verify a proof.
00:33:56.358 - 00:34:00.054, Speaker C: And so you could compile that proof.
00:34:00.102 - 00:34:10.800, Speaker B: For generation using Snarkjs either in Node or in a browser and then commit that on chain using MetaMask or whatever.
00:34:11.190 - 00:34:13.854, Speaker C: And if it works in the EVM.
00:34:13.902 - 00:34:18.210, Speaker D: Context, it's going to also work in the scroll context.
00:34:19.990 - 00:34:22.254, Speaker C: Is it possible to deploy Scroll EVM.
00:34:22.302 - 00:34:25.030, Speaker B: To a different data availability layer?
00:34:26.650 - 00:34:27.750, Speaker C: In theory, yes.
00:34:27.820 - 00:34:32.594, Speaker B: Right. Like, we have the ZKE EVM and that kind of lives as a separate.
00:34:32.642 - 00:34:36.166, Speaker C: Component to the roll up architecture that.
00:34:36.188 - 00:34:40.540, Speaker D: We'Re doing the data availability kind of commitments and proofs to.
00:34:40.990 - 00:34:44.170, Speaker C: So if you wanted to put together.
00:34:44.240 - 00:34:57.146, Speaker B: A weird project where you took our open source repos and you committed to Eigen layer's DA or Celestia's DA and then verified somewhere else, that could be fascinating, but it's not necessarily what we're.
00:34:57.178 - 00:34:58.622, Speaker D: Looking at doing for the moment.
00:34:58.676 - 00:35:03.330, Speaker B: We're really interested in committing to Ethereum.
00:35:03.990 - 00:35:06.174, Speaker D: You pay gas in Ethereum on our network.
00:35:06.222 - 00:35:10.738, Speaker B: Right. We're very interested in inheriting the security.
00:35:10.904 - 00:35:19.910, Speaker D: Of Ethereum and furthering the goals of Ethereum itself. And 4844 is going to really help us do that. In terms of data availability.
00:35:22.730 - 00:35:27.034, Speaker B: This question was missed. Is the proof block posted directly after.
00:35:27.072 - 00:35:28.746, Speaker D: The data block on L One?
00:35:28.848 - 00:35:30.140, Speaker B: No. So.
00:35:32.430 - 00:35:33.562, Speaker C: Kind of, as you can maybe.
00:35:33.616 - 00:35:35.370, Speaker B: See in this diagram.
00:35:37.870 - 00:35:39.662, Speaker C: The proof for.
00:35:39.716 - 00:35:52.720, Speaker B: These three data availability blocks can come way later. And that's fine, right? We can keep committing to the newest state of what our off chain protocol thinks is the latest state.
00:35:53.650 - 00:35:56.898, Speaker C: But from the l one, from the.
00:35:56.904 - 00:36:01.394, Speaker B: Bridge perspective and maybe pulling funds out we're only going to trust that once.
00:36:01.432 - 00:36:15.990, Speaker D: We have a ZK proof that can kind of prove up to a certain chain head. If that makes sense. Hopefully that answers your question, Rory. I don't know if I've missed any.
00:36:16.520 - 00:36:31.160, Speaker A: No, that was one that was missed, so I just copied and pasted it down. There everything else. There was just one comment, I guess, that Meyer mentioned, that it took 17 minutes for theirs to get finalized.
00:36:33.520 - 00:36:39.390, Speaker B: Yeah, and that's another interesting thing, I think, for the 17 minutes, too, that's probably how long it will take to.
00:36:41.360 - 00:36:45.644, Speaker C: Get Bridged from funds from the L.
00:36:45.682 - 00:36:46.716, Speaker D: One to the L2. Right.
00:36:46.738 - 00:36:48.096, Speaker B: If you're bridging worly from L One.
00:36:48.118 - 00:36:49.936, Speaker C: To L2, we have to make.
00:36:49.958 - 00:37:00.644, Speaker B: That transaction and then basically that sits on a relayer and it's going to say, I'm not going to make this on the L2 until the L.
00:37:00.682 - 00:37:07.524, Speaker D: One has called this transaction safe. And that just has to do with epochs and finality on the layer one.
00:37:07.562 - 00:37:10.360, Speaker B: Is that why it takes somewhere usually.
00:37:10.430 - 00:37:16.200, Speaker D: Around, I think, eight to 16 minutes for that Bridging to occur?
00:37:19.810 - 00:37:20.560, Speaker C: Awesome.
00:37:20.930 - 00:37:42.120, Speaker A: Well, cheers. I think that's all the questions we have. Thanks so much for joining us today and for the great presentation, Daniel. And if anybody has any follow up questions, I'm just going to post the discord link to the scroll channel. Feel free to reach out there.
00:37:43.370 - 00:37:44.678, Speaker C: Thank you so much.
00:37:44.844 - 00:37:57.926, Speaker B: I'm going to answer the last coming question on my way out here and it says what circuits to scroll use? Check out Haishun's talk from the intro, but we have a repo that was Forked from the Ethereum Foundation's.
00:37:57.958 - 00:37:59.174, Speaker D: Privacy and scaling.
00:37:59.222 - 00:38:16.382, Speaker B: Explorations, ZKE, EVM repo. It's all available on GitHub. It's all written in Halo Two. And yeah, if you are a smart contract developer that also wants to be thinking about the circuit side of things, check out those repos.
00:38:16.446 - 00:38:18.930, Speaker D: And we love open source contributors.
00:38:20.150 - 00:38:23.042, Speaker B: All right, last answer there. Thank you so much, Rory and everyone.
00:38:23.096 - 00:38:24.960, Speaker D: For listening and hope to see some.
