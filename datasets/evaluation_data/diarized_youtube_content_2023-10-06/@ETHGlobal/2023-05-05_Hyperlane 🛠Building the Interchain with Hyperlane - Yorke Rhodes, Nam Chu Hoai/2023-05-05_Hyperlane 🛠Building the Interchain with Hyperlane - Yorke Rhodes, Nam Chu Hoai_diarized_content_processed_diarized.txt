00:00:07.930 - 00:00:29.442, Speaker A: Yo. I'm york. Welcome to permissionless. Interoperability and warp routes. I'm from a project called Hyperlan. We're an interoperability protocol focused on modular security and bringing operability to all chains. So we're very chain agnostic.
00:00:29.442 - 00:01:21.270, Speaker A: We're hoping to kind of support whatever chain you guys want to be working on in this hackathon. You can stack some bounties. It's my colleague Nam. We're going to hopefully do a live demo for you guys at the end here. Fingers crossed. But yeah, first, let's hop into what is Permissionless interoperability and what are warp routes and why should you care? So, just as a definition to start with, interoperability, in our eyes, is composability amongst DApps that are on different infrastructure. So whether that's, like a DAP that's on an L two, composing with a DAP that's on an L one, or Cosmos app chain with a DAP on Ethereum or something more exotic, that's what we define as interoperability.
00:01:21.270 - 00:02:49.250, Speaker A: And if you look at the DAP ecosystem in the past couple years, what you'll find is that the infrastructure that DApps are choosing to deploy on is kind of increasingly divergent as people start to realize the benefits of different trade offs. Throughout the kind of layers of the blockchain stack, they're choosing more and more diverse trade offs. So we have kind of the hot stuff right now is, like, data availability layers, like having this infrastructure layer that's optimized for this specific task. There's also a lot of people thinking about app chains and kind of the different economics that you can capture as an app developer by kind of controlling the entire blockchain stack. So these are just a few examples, but it should be abundantly clear by now that this is only going to become increasingly diverse. So the Ethereum ecosystem is focused mostly on kind of the roll up side of things. They've kind of committed the past couple of years to that scaling strategy, but it's by no means kind of like, I think, a final destination.
00:02:49.250 - 00:03:48.230, Speaker A: They still want to work on these other things plasma, Sharding, et cetera. And we're seeing DApps adopt these new roll up architectures in the Ethereum ecosystem. So Arbitrum, Optimism kind of the two canonical examples of, like, big roll up ecosystems. There's a bunch of DeFi happening on both chains. And the challenge for DAP developers is the developer interfaces for interoperability between all these different layers is super fragmented. So each one of these roll ups, like, let's say, Arbitrum and Optimism, they all have a custom bridge implementation. And so if you want your DAP to be interoperable between Arbitrum, Optimism, and Ethereum, you got to implement, like, three different interfaces depending on what you're trying to do.
00:03:48.230 - 00:04:34.530, Speaker A: The action, you have to use a different pathway. So deposits and withdrawals are one pathway, and then there's, like, separate pathways for bridging wrapped assets or doing arbitrary message passing or arbitrary contract calls on these other chains. All these generally, you have to use some different pathway. Maybe the canonical bridge doesn't provide this or it doesn't provide it at a latency that you're happy with. And so, yeah, this is super hard as a DAP developer to actually take advantage of all these new things. So typically what we're seeing is people are just choosing a roll up. They're like, oh, I think Arbitrum is winning, so I'm just going to be an Arbitrum DAP.
00:04:34.530 - 00:06:05.220, Speaker A: But there's no reason that they should have to take on that risk of making that choice so early on in their product development. These are just a couple of examples of things that get unlocked once we start getting real interoperability between heterogeneous blockchain architectures that at the infrastructure layer provide different capabilities or features. I'm going to move quickly through this. Yeah, I'm going to also just move quickly through his, but okay, so Hyperland's kind of one of Hyperlan's core ideas or insights is that in order to provide this modular interoperability layer that developers can use across all these different infrastructure layers, we need to separate the transport layer and the application layer. And so at the application layer, we can have a consistent interface that developers can use across all of these different infrastructure layers. And depending on the kind of pair that developers are having, communication move between the transport layer might look slightly different. But all of that is going to be kind of abstracted away from the application interface that DAP developers need to understand.
00:06:05.220 - 00:07:34.446, Speaker A: And this allows DAP developers to basically no longer have to think about maintaining multiple implementations, other protocol for different chains, for different roll ups. And furthermore, DAP developers should be able to express their preferences for security and kind of the trade offs that they want to make in their application. So if you look at kind of like the canonical roll up bridges like we just talked about, Arbitrum optimism, we have a very specific fraud proof mechanism that implies some security constraints, some latency. But it's this omnibus model that all applications on that roll up need to opt into. And that might not make sense for your application, or it might only make sense for one type of action that happens in your application, but otherwise you maybe don't need all that security or you'd prefer the lower latency, like faster finality settlement pathway. So we want to allow DAP developers somehow to express their preference for these trade offs in the interface. And as stronger verification mechanisms become available from kind of the R D side of the ecosystem, like a bunch of people are working on ZK Lake clients, all this signature aggregation stuff.
00:07:34.446 - 00:09:14.880, Speaker A: As those become available, the DApp developer can just change a very simple configuration without changing any of the implementation to say, hey, I'm going to now apply this new security module to these set of actions that are happening between these set of chains. And that's just like a configuration layer in their smart contract instead of a whole new implementation that they need to do to now go and verify some new security models like messaging format. Yeah, and the final kind of core idea that we're excited about at Hyperlane is extending this capability and this developer interface and modular security paradigm to any chain that you guys want to be on. So we have a feature that we've been working super hard on recently that we call permissionless deployment. And it's this idea that someone who's maybe spinning up their own roll up, let's say they're using the Op stack or something, they should be able to just bring Hyperlane there independently from our organization. And so we've basically built out the tooling for developers to deploy our protocol to their chains. And this is just way more scalable than what we've seen with the existing bridging and messaging providers where you have to kind of go and lobby them and they have to take on some amount of risk to operate on your chain and maybe there's not enough economic incentive for them to do that.
00:09:14.880 - 00:09:28.500, Speaker A: Yeah, so this is hopefully what we're going to live demo today. In a moment. Already went through that.
00:09:31.270 - 00:09:31.778, Speaker B: Cool.
00:09:31.864 - 00:10:30.950, Speaker A: So switching gears a little bit, the application that we're going to try and deploy today across a few different chains is called a warp route. A warp route is basically like this collection of contracts that allows you to route tokens between chains. There's a few different flavors of our warp route implementation. So we have like the native flavor which allows you to wrap native assets like, let's say ETH, and in a single transaction route them to some other chain. The collateral flavor is for existing tokens and then synthetic is for how to represent those collateral tokens on chains where they're being warped to. So a warp route is like some collection of these set of primitives. And I'm not going to go super in depth here, but you should definitely check out our docs.
00:10:30.950 - 00:11:55.890, Speaker A: I think the basic premise is like we yeah, I don't even really want to get into the kind of how hyperlane protocol works in this workshop because I think it's less interesting for the hackathon context. But yeah, there's a bunch of stuff going on here. You can imagine Bob being like a recipient application. And the idea is Bob can specify his security preferences for what types of warped assets he wants to accept into his application. Whereas today we have let's say wormhole USDC, that's bridged everywhere, that has some kind of global security model that everyone is basically opting into. If they're using wormhole, you can actually have different I guess you can almost look at them as tranches of a warped asset. That is like using some specific risk tolerance or security model to verify that those assets have indeed been kind of locked up and collateralized on some other chain if that's the instantiation.
00:11:57.990 - 00:11:58.594, Speaker B: Cool.
00:11:58.712 - 00:13:03.494, Speaker A: So yeah, we've basically built a bunch of off the shelf tools for you guys to play with this warp route primitive. So the idea is you don't even have to necessarily write your own contracts. You can deploy one of these warp routes between any chain that you want to deploy hyperlane to and that'll allow you to just import liquidity. It's like a big use case that a lot of new chains are really struggling with right now. Because in order to launch a new chain, you need to establish some reason for people to come to your chain and that usually implies having some economic activity. And so you need to bootstrap that somehow. And an easy way to do that is just like importing liquidity from some existing chain, you kind of can leverage existing network effects, but if there's no token bridge operating to your new chain, you can't do that.
00:13:03.494 - 00:13:19.900, Speaker A: So the combination of being able to deploy hyperlink to your chain and having this nice warp route primitive allows you to spin up a chain which can solve this kind of cold start bootstrapping problem.
00:13:21.970 - 00:13:22.720, Speaker B: Cool.
00:13:23.730 - 00:13:43.310, Speaker A: So yeah, we have a bunch of different tools here for what I just described. I think Nom is going to try and demonstrate us deploying hyperlane to a testnet and then deploy a warp route between that testnet and maybe some public testnet.
00:14:07.530 - 00:14:43.794, Speaker B: Cool. All right. So like York said, we'll be doing a live demo of what it's like to deploy hyperlane to your own chain. So let's set the context here. Let's say you create your own roll up and you're like, oh, this is all great, but obviously now you have to convince developers and users to come your own roll up. And traditional world you maybe have to convince, I don't know, like Coinbase or Binance to ultimately list your token for people to actually be able to move economic value to your roll up, right, to your own chain. I'm just using roll up as a specific instance of that.
00:14:43.794 - 00:15:15.500, Speaker B: And so now with hyperlane, you can basically deploy interoperability to your chain and connect it to any other chain that is connected to hyperlane. And so that's what we're going to be doing. So on our docs here in our guide, we have this kind of like five step process of deploying hyperlane. So the first steps is just generating keys. So I guess that doesn't even count as a step. The second point is to basically deploy contracts. And so we have a hyperlain deploy repo, which I've kind of cloned here already.
00:15:15.500 - 00:15:57.480, Speaker B: And basically all you have to do is you have to add your chain, right? So basically in chains, JSON oops actually this is the wrong one here. Basically in chains, you just kind of add your chains information. All of this really like the name, the chain ID, and then an RPC URL. So in this case, we're going to be deploying to Coinbase's new chain called base, right? And obviously if, you're know, I guess you have your own exchange. But again if you have deploy your own roll up here today, it's going to be very hard to convince anybody to deploy anything on your chain. So he's going to do it ourselves. So all you have to do is basically add your chain here.
00:15:57.480 - 00:17:00.922, Speaker B: Like York said, we have modular security and so in this case what we'll be doing is we'll just deploy a one out of one, kind of like multi SIG ism as we call it to basically validate messages going from your chain to all the other chains. But actually you get to reuse the security that we already have existing on existing kind of default chains as we call them. So for us we should just be deploying between let's say base and Sepolia. And so then all you have to do is I guess I can just copy and paste that here. So basically you add your chain, you kind of configure the security, add the default security from your chain and all you have to do is run the script, right? And I'm not going to deploy this because it's like a bunch of transactions going to take a little bit too long. But at the end of this deployment you basically get kind of these addresses. So in here you get basically all the artifacts of the addresses that got deployed on both base and Sepolia.
00:17:00.922 - 00:18:26.714, Speaker B: And so that's kind of just the contracts and then the two remaining steps are basically to run the validator which basically validates state from your chain, in this case base to all the other chains, right? So that's the first step. So all you have to basically do is kind of run, we have docker images or you can just build it from source as we did here and you basically say hey what's the origin chain name that I want to validate on? Where do I want to write my signatures to? So in this case I'm just writing it to a local folder and then basically the config file that you got from the contract deploy. And so basically once you run that, that validator will now observe the contract on your own chain and basically anytime there's a new message it will kind of like attest to that new message. The next step then is after running a validator is to run a relayer. And so basically a relayer is a permissionless role that basically sends, that uses the signatures from the validator to ultimately pass them on to the destination chain mailbox contract and that mailbox contract basically then uses a security module that is specified to validate. Hey, does this actually happen on the origin chain and then process the message. And so basically we have relayers that run basically from one chain to another.
00:18:26.714 - 00:19:15.660, Speaker B: So in this case you can see here I think this is from base to Sepolia. So we'll just run that right here. And then equivalently we have another relayer that runs from Sepolia to base. And so that's basically all the kind of like off chain infrastructure that you would have to run. And now we're connected, we can kind of like easily there's a test script can run right now that basically just sends two messages, one from base to Sepolia and one from Sepolia to base. And then we should see those being delivered in 1 second if all goes well.
00:19:17.390 - 00:19:20.730, Speaker A: Yeah, I realized I didn't go into.
00:19:20.800 - 00:19:23.274, Speaker B: A lot of depth like what's happening.
00:19:23.312 - 00:20:54.470, Speaker A: At contract layer, but just provides color there when your patrek wants to interact with the contract describing that interaction. And that message needs to be authenticated such that someone can actually know that it was your contract that dispatched this action rather than some malicious attacker. And so we have a few different security models that you can select off the shelf to perform that authentication. One is this multi SIG validator setup where basically there's validators on the source chain that are signing commitments to the messages that have been dispatched from that chain such that those signatures can be used on the destination chain as an attestation that, hey, this message was dispatched on this source chain eventually. The idea is to have kind of like permissionless economic security model where anyone can be a validator if they're putting up enough stake and provide security to this type of authentication system. But yeah, what's happening here is the message is being committed to on, let's say, Sepolia. And then the validator that nom's running on his machine is signing commitment.
00:20:54.470 - 00:21:38.710, Speaker A: And then the relayer that he's running on his machine is taking that signature and passing it to the destination chain contracts, which is like one of these warp route contracts that's basically verifying. Like we saw in the multisig ism config that he had up earlier. It's verifying that we've reached a threshold of the specified validators that have attested to the fact that this message was committed to on the source chain. But yeah, definitely. For more details, check out our docs on kind of all the different types of security configurations.
00:21:39.450 - 00:22:32.674, Speaker B: Cool. So basically now that we've kind of verified that we can send messages back and forth, right? Like we've kind of connected this new chain that didn't have hyperlane before to all the other chains that have hyperlain. And so now that you have kind of this base messaging layer kind of set up, you can build applications on top of that, right? And like York said, I think a very common application is effectively a token bridge. Right. So let's say again, if you're a new chain, one of the first things you probably want is like you want a stable coin, right? And so why don't we just kind of create a warp route of, let's say something like USDC that exists on Sepolia to your new chain, which in this case is base. And so we once again have a guide for that, right? So under warp routes here, you again just go off hyperlane deploy and you just run a different script. The script basically is configured with the swarp route config.
00:22:32.674 - 00:23:32.220, Speaker B: So let's say in this case swarp, I guess we call it warp tokens now, right? So that's basically we say like on the base chain, I guess it's like the collateral chain. We basically say like, hey, we want to collateralize this token, which in this case I think that's just a link token because there's a good faucet on it on Sepolia. And basically we want to say like, hey, we want to create synthetic versions of that token on, let's say, a dutter chain, in this case our base token. I see how that naming can be a little confusing in this particular instance, right, but basically we allow now to create a warp route between Sepolia and base. And so then all we have to do is what's it called deploy war brows, right, with basically our private key to kind of deploy the contracts. And I think that's what happened above here. So again, I'm not going to run through it because the transactions take, I think, a couple of minutes.
00:23:32.220 - 00:24:44.734, Speaker B: And the cool thing is that once you've kind of deployed this warp route, right, which is basically just a set of smart contracts on both chains, we actually have a out of the box UI that you can use to kind of let your users now leverage this warp route to kind of have these synthetic tokens. And so all you have to do is basically take the output of your warp route deployment and basically add that to this template repo that we have that you can clone. Again, all you have to do is add your chain information in here and you add the token information from the warp route deployment. And I can do like in this case, I can just kind of run it locally right here, but it also super easily deploys traversal or any other NextJS hoster. And so basically then here on localhost, it will basically fetch kind of the warp route information and then after a little bit will show you the chain options for your warp route. You can see the token that you can kind of warp. You can say, hey, I want to send this much to the recipient.
00:24:44.734 - 00:25:08.140, Speaker B: You can just say it to yourself and then basically send it to base. And again, this is all out of the box, right? I didn't have to change any code. It will prompt me to approve my link token to the warp route contract on Sepolia. And once the approval happens and if the Wi Fi is good enough, ultimately it will.
00:25:09.470 - 00:25:32.100, Speaker A: If you guys saw the layer zero, like Gorely ETH market drama a couple weeks ago, this is like a tool where you can create those type of markets between any chains assets super easily. So if you guys want to in this hackathon, go mess with someone else's testnet, you could maybe do that.
00:25:32.870 - 00:26:09.600, Speaker B: Cool. All right. Then we saw basically the second transaction, right, is to actually ultimately send the tokens over to base. And so that, I guess, just confirmed on Sepolia. So like York said previously, again, Valders will basically attest to that transfer on Sepolia, create signatures, and then the relayer that I'm running right here will basically observe that message and will ultimately process it on base. And so I think what we can do actually, is just to take the.
00:26:13.730 - 00:26:15.310, Speaker A: Open it in the Explorer.
00:26:15.650 - 00:27:09.480, Speaker B: Yes. So we can basically take the this is the token address on base, right? So we can just go to base, I think. Was it Base ether scan? I forget what it is. What was it? I just had it. I think they're called base scan. And then you can put in the token address, right, so that's basically know you can already see here it shows up as Chain Link, even though I'm pretty sure Chain Link doesn't have it deployed, the token on base. And then under I think that tokens transfers you can see here, like 25 seconds ago, we just minted ourselves one chain link token on base.
00:27:09.480 - 00:27:46.062, Speaker B: And then I think in the UI, you can kind of see the same thing. And then if we wanted to, we can send it back from base, back to Sepolia again. And yeah, you can imagine what the kind of outcome of that is. I'm told we're out of time, so if you have any more questions, feel free to jump by our booth. Today we have three bounties. One is for the best use of permissionless interoperability. So basically you could deploy to many of the networks that are represented here today as well, and kind of like, would love to see kind of some cool use cases between, let's say, a new chain and an existing chain.
00:27:46.062 - 00:28:26.600, Speaker B: The second bounty is for best use of the warp routes, right? So bring your token to some new chain and kind of do something useful for that. And the third is, like we said, we have this kind of modular security approach where developers can choose different trade offs. And we would love for developers to kind of build some kind of alternative models, like an optimistic one or maybe one based on succincts, like kind of like ZK Lite clients. But yeah, because we believe that the story hasn't been kind of finished telling yet about what security models they're out there for cross chain interoperability. We would love for hackers to kind of play around with that. I think that's it. Thank you.
