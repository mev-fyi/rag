00:00:00.090 - 00:00:00.878, Speaker A: Go ahead.
00:00:01.044 - 00:00:25.630, Speaker B: For sure. How does that look, Emily?
00:00:30.990 - 00:00:36.794, Speaker A: Cool. Twitter's up. Oh, yeah.
00:00:36.832 - 00:00:37.618, Speaker B: There we go.
00:00:37.704 - 00:00:39.474, Speaker A: Yeah. Cool. So good.
00:00:39.592 - 00:00:53.798, Speaker B: Awesome. We're going to get started. Welcome, everybody who has signed up for this session. Hopefully you're in the right place. We have with us, scott Bigelow. How do you pronounce that?
00:00:53.884 - 00:00:54.966, Speaker A: Yep, you got it.
00:00:55.068 - 00:00:57.880, Speaker B: Perfect. Scott's going to be going through.
00:00:59.930 - 00:01:00.246, Speaker A: Some.
00:01:00.268 - 00:01:22.126, Speaker B: Of the techniques to discover solidity vulnerabilities, and we're super excited that he's going to be sharing some of that expertise with us. Scott, if you want to just start off by giving a little bit intro to your background before Ethereum, how you got into the space and what you're doing now.
00:01:22.308 - 00:02:15.514, Speaker A: Sure thing. Awesome. Thanks for the introduction. Yeah. So, my name is Scott Bigelow, and I'm currently working with the Ethereum Foundation on something we're calling the Spot Check Program, where currently it's just myself and it's a program to provide resources to projects that have either shipped or are about to ship to provide some high level security auditing and guidance services. There is a lot of projects that are that are nearing completion, that this could be the first Ethereum project that they're shipping. And so we're providing just a little bit of guidance on some of the best practices before they hit Mainet, because I think we all know once you hit Mainet with your contracts, these issues are really difficult to recover from, either requiring like, redeploys and migrations or maybe there could be some loss.
00:02:15.514 - 00:02:59.338, Speaker A: And so whatever we can do to provide something before they get to that immutable point usually has a really big benefit for these projects. Sure. Now, we haven't actually fully published this thing on like a blog post or anything. We do have a mission statement here, but really it's projects can get this sort of feedback and guidance and we'll also be scanning the blockchain and proactively looking for issues in smart contracts that are usually that hold funds and are vulnerable and we can figure out whose smart contract they are. So there's really two sides of it. There's the proactive monitoring and then the kind of consulting services before this. I've been working in Ethereum for a few years now, probably since about maybe early 2017.
00:02:59.338 - 00:03:37.020, Speaker A: I worked on Auger Shipping. Auger v one. I worked again for another company called Amber Data, which is a blockchain explorer. They provide a lot of really nice data for an API. But yeah, I've just really found myself drawn into the Ethereum space and really the security aspects of it because there's just so much on the stake. Every single block is a bug bounty that is being declined for anything that is wrong out there. And what we can do to help projects before those bug bounties get cashed in by black hat is it just makes the ecosystem just a lot more positive place to work in.
00:03:37.020 - 00:03:43.740, Speaker A: So should I just go into it then?
00:03:44.110 - 00:03:49.706, Speaker B: Yeah, that's a great summary of what you've done and what you're doing now.
00:03:49.808 - 00:03:50.342, Speaker A: All right.
00:03:50.416 - 00:03:57.694, Speaker B: Do you want to just give a quick outline of how you're organizing the session when you'll be taking questions?
00:03:57.892 - 00:04:28.614, Speaker A: Sure. I think organizing might be overstating it. Yeah. So I was hoping to have a pretty informal session here. I have a bunch of stuff I would like to run through and talk about, but I'm really hoping for questions in the middle. I'd like to know when we're talking about things that are interesting and maybe things that aren't. It's hard to know who to target in this, but yeah, if you could please just chime in and engage about these topics that are interesting or we could take them in a different direction.
00:04:28.614 - 00:05:08.662, Speaker A: I'd be very open to that. If you don't ask questions, we're going to be sitting here all looking at each other awkwardly in about 20 minutes. So if you could save me from that, it would be a huge favor. All right, so let's talk about Ethereum Security. One resource that I like to use here is this SWC registry. There is kind of an outline. It's a little bit technical in the way that these things are written up, but it's a fairly decent resource for all of the types of ways that smart contracts that we found.
00:05:08.662 - 00:05:38.814, Speaker A: Smart contracts can have problems. They all have these identifications. You can kind of talk about them when you're using auditing tools. They'll be like, oh, you've got an SWC 135 here. But it's kind of helpful to kind of have these Identifiers for these things and they have pretty good descriptions for it here. I really like the test cases they have for these. You can go down and look at some code for some examples of ways in which these smart contracts are secure or insecure.
00:05:38.814 - 00:06:47.398, Speaker A: And then they'll show you a way that it is vulnerable and they'll show you a way that they were able to fix it. The problem with this list is that it is very long. And so unless you are doing Ethereum Security work all day, every day, where do you start? How do you go from looking at this list of technical definitions of ways that smart contracts can be vulnerable to actually improving your own code to avoid some of the most common pitfalls of smart contract development? And one of the ways that I would like to promote here is I'd like to really just call out a couple of these methods and talk about ways that we can look at our code to avoid those specific issues. So I actually have a list here and it is just let's see, how do I pick out here? Just five. So of these I don't know, what is this? Maybe like 50? Actually. How many are there? Yeah, 36. There's about five that I think are really, really important to talk about.
00:06:47.398 - 00:07:34.962, Speaker A: And when I am doing my audits of projects, that are about to be released. Literally every single one of them has been one of these five issues. Not to say that these other issues don't happen, but a lot of times it's just around something that people don't really do anymore. Or it means that you're doing something crazy, like going into what they call solidity assembly, where you're writing these really low level codes. Or sometimes it's a honeypot where these are vulnerabilities that people intentionally put into their code. Some of these are people will try to create these tricky, smart contracts that would you think are vulnerable but aren't. And many of these are for watching out for nefarious authors and assuming that Ethereum project creators are not nefarious.
00:07:34.962 - 00:08:18.642, Speaker A: A lot of these aren't actually going to apply to ways that you can practically improve the security of your code. So let's start with one of these. This is one that I've been seeing a whole lot. It is what we call it's SWC 106. We have unprotected self destruct instruction. I think many of you might if you've been around the space for a little bit longer, you might recognize it better as this one. First of all, this is my first interactive point.
00:08:18.642 - 00:08:24.214, Speaker A: Are people familiar with this, the parody multi SIG self destruct that occurred a couple of few years ago? Yes.
00:08:24.332 - 00:08:25.858, Speaker B: It's pretty infamous.
00:08:26.034 - 00:08:27.846, Speaker A: Pretty infamous. Love it.
00:08:27.948 - 00:08:32.518, Speaker B: Feel free to unmute people if you want to chime in or ask a question.
00:08:32.684 - 00:09:09.362, Speaker A: Yeah, please. Right. So what I find really interesting about this is that this happened like, what is this, late 2017? This is this parody multisig hack. Literally everybody knew about it. But the problem is that so many people knew about it that we don't really talk about it anymore. And so I have been working with projects in the last couple of years that have fallen prey or have created code that is vulnerable to this specific thing, but because it's so ingrained into the people who were around in late 2017, we don't talk about it anymore. And then people who join in 2019, they don't know about this.
00:09:09.362 - 00:10:04.390, Speaker A: Right? Because it's so obvious that it's hidden. And many projects are vulnerable to this issue in kind of new and novel ways, but it's still the same underlying issue. And the issue was related to let's call this where is it, this one? So many projects nowadays are coming up, are deploying with something called an admin proxy, where they'll deploy a contract where they can later turn around and say, like, hey, I know this contract usually runs this code, but now this contract is going to run this code over here. Are people familiar with the admin proxy system or should I talk about that more? I'm good with that. Good with it. You got it. You understand everybody knows what we're talking about here.
00:10:04.460 - 00:10:07.334, Speaker C: Yeah, it's mostly the delegate call that.
00:10:07.372 - 00:10:16.620, Speaker A: Performs that thing, right? It's exactly right. So it's a delegate call, but the owner gets to come along and say, hey, I know you're delegating over here, but now I want to delegate over here.
00:10:18.110 - 00:10:23.066, Speaker C: Sorry. Basically he can arbitrary update implementation, is that correct?
00:10:23.248 - 00:11:30.100, Speaker A: It's 100% right. And so normally when you run a smart contract, you're looking at it like this, right? It's like I deploy this thing, this code, it lives at this address and it has this storage. When you run an admin proxy, instead you use your storage but reference somebody else's code through a delegate, right? So you're like the only thing the code here does is delegate to this other code you still write to your own storage. But the code over here is the one that gets executed, right? Now, what many people forget, and this is what they forgot when they had this whole parity multi state thing is that this over here, this one that you're delegating to itself is a contract with its own storage, with its own ability to self execute. And if this thing contains a self destruct, somebody else could initialize and then self destruct that call, just like it happened with the parody multisig years ago. But one of the things that we found more common is that let's say that this contract itself, instead of having a self destruct right in it because that's become a little bit rare. Let's say this code itself has a delegate call in it.
00:11:30.100 - 00:12:41.814, Speaker A: Well, an owner, anybody can come along and initialize this, become the owner of it, and then delegate call to something that does a self destruct. So there's another path to self destruct if you can take over a contract that itself has a delegate call. And what we're finding is that people who are using these admin proxies to reference another contract, they've kind of forgot about this thing or they weren't around during this whole parity multi SIG thing and we can end up with a situation where they've lost this contract because of a delegate call. And now their implementation is totally hooked. Now, luckily, because hopefully if it's an admin upgradability proxy, it's not the end of the world, but it could cause some harm for the way some of this logic executes. And one of the things that I did in response to this, it's kind of an aside here maybe you'll find interesting. So I wrote this little program here.
00:12:41.814 - 00:13:24.070, Speaker A: This is more kind of on the spot check side that basically looks scans the blockchain for things that are delegated to pulls things out of a blacklist sees if the things that are delegated to can perform a self destruct or a delegate call because either one of these allows the path that allows you to destroy the code. And then it also checks to make sure that nobody has initialized the contract to see if maybe there's because if somebody's already initialized it, but it already has an owner, then this thing that gets delegated to is kind of safe, theoretically.
00:13:25.290 - 00:13:30.978, Speaker B: We've got one question. Sai, do you want to go ahead and yes, Scott.
00:13:31.074 - 00:13:48.720, Speaker D: Hi. So basically, if the source contract is, like, for example, killed okay, so will the admin proxy contract be affected? Because you can also point out to another address if there are any set of methods over there.
00:13:49.410 - 00:13:50.160, Speaker A: Yes.
00:13:52.050 - 00:14:03.490, Speaker D: If the source contract is killed or something crazy happens with that, we can also shift to another like we can deliver to another smart contract.
00:14:03.990 - 00:14:05.220, Speaker A: Absolutely, yes.
00:14:06.230 - 00:14:07.780, Speaker D: Some points on this.
00:14:08.230 - 00:14:44.714, Speaker A: Yeah, that's exactly true. If we're using this admin upgradability proxy, then yeah, you could like, oh, somebody just killed my implementation. They killed this one over here. But because it's an admin upgradability proxy okay, well, now I can deploy a new one. Now I know that I should be the one that initializes it, or I should make sure that it can't be initialized later directly, and then I can repoint to it. And so long as the implementation is good, then things should be okay. Now, while that code was dead, some weird things could happen because it's going to do a delegate call to nothing, which succeeds.
00:14:44.714 - 00:15:11.174, Speaker A: Right. There's nothing wrong with delegating to nothing. And then if somebody sent like four Ether to your actual address, the one that actually is the proxy, while there was something deleted back here, this code likely just accepted four Ether and didn't do anything with it. They didn't do the things that the user was expecting. So there's still some really bad artifacts of that while the code is deleted. But if it's an upgradability proxy yeah, you can't fix it.
00:15:11.372 - 00:15:25.770, Speaker D: So do you think each and every smart contract should have setter functions to actually provide these functionalities so that one can upgrade the contact address the delegate calls?
00:15:26.910 - 00:16:07.338, Speaker A: Well, here's the problem. First of all, this is a very religious debate because in a way, it's like, hey, look, I can fix all my problems. But then, hey, look, my system kind of lacks one of the key features of Ethereum, which is decentralization from operator control. Also, this vulnerability is created by this vulnerability is able to be fixed, but also created by a user, a project trying to maintain this upgradability control. Right. It's kind of funny because the problem is the solution. Right?
00:16:07.424 - 00:16:08.010, Speaker D: Yeah.
00:16:08.160 - 00:16:13.946, Speaker A: The separation of implementation from code allows you to fix it, but also cause this problem in the first place.
00:16:14.128 - 00:16:15.920, Speaker D: Exactly, yeah.
00:16:18.530 - 00:16:44.086, Speaker A: I think that this is like training wheels. This is just me, like, my opinion about this. I generally think of when you do this, it's kind of like a nice training wheels for like, hey, we just launched this, let's see if it works. Hey, there's a problem, let's fix it. But I think that eventually it's really nice to get to this part where it's like, this code can't change, I can't change it, I don't need to worry about, oh my God, these project. People didn't handle their private key. Right.
00:16:44.086 - 00:16:50.150, Speaker A: And they took everybody's assets. That's just not a super fun post mortem to write up.
00:16:50.300 - 00:16:51.000, Speaker D: Yeah.
00:16:52.410 - 00:17:18.800, Speaker A: So usually when I see projects do this, I'm like, hey, watch out for this problem. Also, it'd be nice if it didn't do this eventually. And I think most projects agree. And you can actually go from this to this really easily without redeploying. If you just burn your owner keys, you just, hey, I'm going to transfer ownership to the zero address. You have effectively done this. So there are kind of ways to upgrade yourself later.
00:17:18.800 - 00:17:38.502, Speaker A: Yeah, good question. One other question. So this is kind of only a vulnerability if one of the contracts has a self destruct coded into it, right? Absolutely right. If a self destruct or a delegate, because you can always delegate to a self destruct. Okay. Delegating to another. Got you.
00:17:38.502 - 00:18:07.034, Speaker A: Right, yeah, exactly. But if it delegates hard coded to a contract that doesn't have a self destruct, then that's okay. Absolutely. Unless that contract, if there's a dead end in the delegation, that's okay. Absolutely right. Yeah. And so when I have this thing here, one of the things I look for in this code here, I'm able to over a bunch of blocks.
00:18:07.034 - 00:19:01.766, Speaker A: I'm able to get all the things that are delegated to I have a blacklist of things that I've already checked are safe. You have to have a self destructor delegate in the delegate recipient's call, and then I make sure that it doesn't have any storage written that would likely be from an initialization because that means I couldn't come along and initialize it. Just curious, how are you checking for self destruct? Is that looking for the Opcode in the deployed contract? Got you. Yeah, it's pretty simple, really. So it's just this small little TypeScript function that iterates through it. And the only thing that's weird about going through bytecode, byte, byte by is that every bytecode is all these things are like one byte except for pushes. Like when you do like, push 32, the next 32 bytes aren't Opcodes, but they're literals.
00:19:01.766 - 00:19:40.106, Speaker A: And so the only reason that this isn't just like Lurch looking for that code is that I actually have to skip those because it's very common for the self destruct or delegate Opcode to appear in an address that's getting pushed into the stack or like some other literal. So you actually have to skip that stuff. But yeah, it's pretty simple to just go through that. Cool, thanks. I was hoping to actually find one because I usually find about one a week, and I'll usually just initialize it and burn it and try to contact them, but half the time I can't even figure out whose it is. But it's fun to do that. Although it's less fun to do it when gas prices are like 30 gray.
00:19:40.106 - 00:19:41.200, Speaker A: That's less fun.
00:19:42.770 - 00:19:45.390, Speaker B: One quick question for anybody. Yeah.
00:19:45.460 - 00:19:55.810, Speaker C: Gas price is crazy right now. One quick question around that. So is that finding code just finding possible self destruct.
00:19:56.150 - 00:19:56.850, Speaker A: Okay.
00:19:57.000 - 00:20:04.262, Speaker C: Because you're not sure whether you can really reach it or not, but it's just existing in the bytecode, is that correct?
00:20:04.316 - 00:20:41.970, Speaker A: Exactly. It gives me a list of things that I can then go and manually look at. And when things show up there normally about when things show up in that list, there's probably about a maybe ten to 20% chance that it's actually exploitable. And it was somebody early who said, like, oh, what if they delegate to a fixed address? That's actually really common. That's something that I've been seeing a lot of in contracts. And I think it's because they're calling themselves there's something weird about I don't know, I've been seeing a lot of fixed delegation. And so, yeah, with that again, it's like, oh, well, that's a dead end because I can't provide my own delegation destination that just contains a self destruct opcode.
00:20:41.970 - 00:21:45.266, Speaker A: So, yeah, one of the things we do here is we just look for things globally. But this is the case for knowing the history of these things and also understanding about the delegate thing is a little bit new. There's been a bunch of vulnerabilities that have been discovered because of the delegate self destruct variant of the oops, I accidentally killed it's. My notes here. Yeah. So the protection against this is really to make sure that your implementations initialize themselves in their own constructors, or whenever you deploy them, initialize them yourselves. Probably the best to do it in the constructors, but because implementations are separated from storage, a lot of times people don't think like, oh, this isn't a contract, this is just a bunch of functions I'm writing.
00:21:45.266 - 00:21:52.710, Speaker A: I don't need a constructor, without realizing that the constructor is the thing that would actually save them and prevent anybody from ever harming their contracts.
00:21:54.750 - 00:22:12.942, Speaker C: Kind of want to comment on that. So one thing I've been noticing is that on Open Zeppelin, it actually says that you shouldn't have a constructor for the Upgradability implementation. And that's kind of misleading for some people that they don't initialize it any, like, at all.
00:22:13.076 - 00:22:14.400, Speaker A: I didn't know that.
00:22:15.090 - 00:22:15.840, Speaker C: Yeah.
00:22:20.790 - 00:22:24.182, Speaker D: So that is how Japan OS does the job.
00:22:24.236 - 00:22:24.840, Speaker A: Right.
00:22:29.290 - 00:22:30.680, Speaker C: Sorry, say that again.
00:22:30.990 - 00:22:39.850, Speaker D: So I think Zeppelin OS does the job by taking the right to use constructor from their side.
00:22:40.000 - 00:22:42.266, Speaker A: Like the Zeppelin OS takes care of.
00:22:42.288 - 00:22:59.730, Speaker C: The that could be, yeah. But in general, they just suggest you shouldn't have a constructor for the implementation stuff. Most of the people actually well, at least most of the project I see don't use Zeppelin OS.
00:23:03.030 - 00:23:07.330, Speaker A: Actually. Yeah, I didn't know that they recommended against it. That's very interesting.
00:23:07.480 - 00:23:09.438, Speaker C: Yeah, I can find it and send it to you.
00:23:09.464 - 00:23:21.740, Speaker A: No, I'm positive. That's very interesting. But it basically puts the onus on you to make sure as part of your deployment process, that you're running whatever initializer you have in there?
00:23:22.350 - 00:23:33.494, Speaker C: I think there is a possible reason for new people noobs that don't really understand having a constructor in the implementation.
00:23:33.542 - 00:23:34.806, Speaker A: Might get them confused.
00:23:34.918 - 00:23:42.654, Speaker C: But then, as you said yeah, I think it's just kind of like a different level of issue, right?
00:23:42.772 - 00:24:18.150, Speaker A: Yeah. And a lot of times when I see people using these admin upgradability proxies, it's actually not tied into their overall deployment. Like they're writing their contracts, they have all these things in place. They're doing it all locally in Truffle. Then when it comes time to do deployment, they kind of like manually stitch all these things together to put a proxy in front of it, only in mainnet because it's not really something they care about in Dev. And that's another kind of separation between dev and mainnet that provides the possibility for problem. I think one thing with Zeppelin is I think their tool does that initialization.
00:24:18.150 - 00:24:24.638, Speaker A: So if you use their tool, it'll handle it. But if you kind of just stick with Truffle then you might not.
00:24:24.804 - 00:24:37.182, Speaker C: Well, yeah, that part I'm actually not sure because I remember that they just said you shouldn't have constructor in the implementation.
00:24:37.246 - 00:24:37.474, Speaker A: Right.
00:24:37.512 - 00:24:51.640, Speaker C: So if you don't have that, I'm just not sure whether their tool initializes the implementation contract or not. If it does not, then yeah, but that's the open Zeppelin Zos stuff.
00:24:55.130 - 00:25:30.666, Speaker A: Okay. So I think that's kind of like what's the big deal right there with those self destructs is just that I think people need to be more aware of them. People who come later in the F miss the boat on the excitement. That was the parity multi SIG. So I was going to walk through a couple of tools that I use to kind of like look at smart contracts. I wanted to kind of talk a little bit about the big one, of course, which is reentrancy. This is kind of like the premier exploit.
00:25:30.666 - 00:25:48.040, Speaker A: Like almost everything we talk about in Ethereum that is a major exploit is due to reentrancy. So I was going to talk about some of the ways that I find these and some of the ways that I think about them. Oh, look, hold on a second. We got a couple of contracts here. Is anybody interested to look at that? Do you want to look at these contracts or do you to want talk about reintroduce? What do you think?
00:25:48.890 - 00:25:51.580, Speaker C: Take a look at it will be cool. That's like beautiful.
00:25:52.430 - 00:26:21.940, Speaker A: Wait, which one? These ones? All right, look anyway okay, actually, you know what? Maybe that's a bad idea. Let's not look at those. Let's look at those. Let's not look at stuff live on Ethereum right now. Okay. Let's talk about ranch and see, because I just realized if I found something, I don't know if that would be if now would be the best time to discover that.
00:26:22.310 - 00:26:24.830, Speaker B: But yeah, basically this is streamed.
00:26:24.990 - 00:26:58.080, Speaker A: Yes. I just realized that it felt like a very intimate conversation. But basically those addresses down there which we won't go into have a delegate call on them, are delegated to and are likely not initialized. But that doesn't mean that they're vulnerable because they could be fixed or they could be not. There's a lot of other ways to protect against it. But anyway, let's talk about Reentrancy. It sounds like from the questions that people are asking here that everybody here, it seems like many people know what Reentrancy is.
00:26:58.080 - 00:27:51.870, Speaker A: The problem that I've had with Reentrancy is whenever I read something about Reentrancy it's always this one, this one exact function where they use to describe what Reentrancy is. Right. It's this sort of like, hey, if you look at this code you can see that if somebody has a balance here, it reads the balance, it sends them the balance. But the process of receiving this send here, this forwarding of Ether would allow them to basically reenter this and withdraw their balance twice or more times. So that if they had one Ether here but the contract had ten, they could call into it nine times and they're going to set zero at the end here but have received nine different transactions for nine E each. Are most people familiar with this or should we talk a little bit more about the function of Reentrancy?
00:27:52.850 - 00:27:57.650, Speaker C: I'm pretty familiar. I think the key is there's actually external execution.
00:27:58.070 - 00:27:58.820, Speaker A: Yes.
00:27:59.430 - 00:28:12.020, Speaker C: But this example kind of limit the scope. Like some people just see it like, oh, if I send Ether then I would have the Reentrancy problem which is I think the ERC seven seven issue.
00:28:13.190 - 00:28:48.286, Speaker A: Yeah, exactly right. It's not just sending ether. So the one thing that I think that makes reintrancy a really important topic right now is that for a long, long, long time the best practice was oh my God, don't ever do this. That was kind of the way that people were talking about sending Ether. It's like, okay, everybody stop sending Ether to an account using call because you forward all your gas and you give them the opportunity to call back into you and find a bug we're supposed to be using what is it we're supposed to be using? Like message transfer. That's kind of been the new one. Or message send which only forwards a little bit of gas.
00:28:48.286 - 00:29:58.626, Speaker A: But it seems like the new best practice has kind of come back to Call value where you send all gas in your Ether transfers. There's been a whole bunch of there's been a big push here for hey, stop using transfer and start using call value again. So this makes the discovery of Reentrancies really important because they're going to be more possible as more and more people adopt this. I'm not saying I disagree with their logic here, but yeah, it's going to become more important to understand how to look at these and think about these and just protect against them. Without relying on limiting the gas to get sent to the recipient. I also feel like when we talk about this, once you think about this for a while, you can see how a reentrancy here is possible, but they don't really talk about why or really like how to think about it or how to discover more advanced versions of discovering reentrancy.
00:29:58.818 - 00:30:00.870, Speaker B: I want to make that full screen, Scott.
00:30:01.230 - 00:30:01.980, Speaker A: Sure.
00:30:03.310 - 00:30:05.322, Speaker B: Like that awesome. Yeah.
00:30:05.376 - 00:30:41.860, Speaker A: Cool. Sorry. Thank you. Right. But how do we talk about ones that are more elegant than this? How do we kind of extract rules for how we can think about finding something that's a lot more complicated in our code? Because I doubt anybody has written this code in their contract. So the way that I kind of think about this is I look for the point at which control is handed off and that's via this message that call where you forward all gas. That is a point at which you are handing off control of the EVM to somebody else with all the gas that you have now somebody else mentioned in here.
00:30:41.860 - 00:31:07.054, Speaker A: ERC, seven. Seven, seven. And other things. And there's other ways to hand off control even when you're not forwarding ether. So I kind of break this thing down into two parts. One is finding the lines which forward control over to another contract in the middle of your contract, in the middle of your function call. And once I've kind of established found all those lines, like highlight them with a highlighter, I kind of look for these things.
00:31:07.054 - 00:31:55.020, Speaker A: It's like anything before that line that is related to control flow. Anything where a variable is created before it and then used after. And then any storage, right, that comes after. And just start to think about the different ways that those three things can kind of kind of hurt you. And I wanted to walk through a few examples of that. So in this one, let's kind of like walk through those rules so we find a line where a reentry could happen and start going through our rules. What do we have here? It's like, oh, well, after this we have a storage, right? This is the point where you really shouldn't be doing storage rights after external calls if you can help it, because you've kind of changed the state in a way that was kind of inconsistent with how you expected the flow of this function to go.
00:31:55.020 - 00:32:38.954, Speaker A: I think many of us again, if you've been around for a long time, we have the Dow, it's always kind of fun to look at some of the new rules we have here. For old ones, this payout is actually a sending of ether. And what rules have we violated here that create the issues of reentrancy? Okay, well, we have a after storage, right? So after we handed off control, we wrote storage after that happened. We also have a variable that was. Created before and then used after. And then we also have control flow based on storage values that happened above. So if it wasn't this one, there was going to be something else.
00:32:38.954 - 00:33:26.090, Speaker A: So there's a lot of things going on here. Again, somebody brought up seven seven seven. That was a nice little note lead into this because I want this is what I think is one of the most interesting ones. So I think many of us are familiar with the Uniswap and ERC seven seven issue where if you put seven seven seven tokens on Uniswap, they can actually be stolen via reentrancy. And this happened, I think what was that about three weeks ago, maybe a month ago, where this imBTC ended up putting like quite a bit of it on there. And whoever was funding this thing didn't maybe they weren't here two years ago when everybody knew. When did this come out? Maybe they weren't in the ecosystem.
00:33:26.090 - 00:34:31.914, Speaker A: Mid last year when it became really publicized that don't put seven seven seven s in Uniswap, but they kind of missed that memo and so now we're left with this. But this one is really interesting because this doesn't seem to really violate any of the rules that we came up with ourselves. Right? If you look at this, we have send is the way that it sends ether to the recipient and then it does a token transfer and then it does a log which isn't really like a storage update. It's not a variable setting, but still this was able to create a reentrancy. And the reason is very interesting. So this is the line where the reentrance vulnerability comes from and when it shells out to another program, to this other ERC seven seven, well, it has a callback hook for whoever is buying is saying like, hey, we're about to take tokens away from you. Okay? So you get a callback hook for that and then it increases the balance.
00:34:31.914 - 00:36:01.820, Speaker A: But again, in the context of this function, it was at the end. So what's the problem? The problem is that uniswap uses another contract storage natively as if it was its own and so it might as well be its own storage, right? So here we have the write that comes after right here. But it is effectively a variable that is used directly by Uniswap itself. And so we violate that constraint of don't write after, don't have storage rights that come after shelling out to another contract. There's the after storage, right? So what's, what's interesting about that is that I think it would be really hard for some sort of an analyzer or something to figure out that there was a problem here because they seem to have obeyed all the rules. But there's kind of a problem here when it hit production and with the way that people actually interacted with it, a separate vulnerability could potentially be a contract that did something funky in balance of, right? Because balance of is another external call. It is, but it is a static call.
00:36:01.820 - 00:37:05.002, Speaker A: So when it shells out to balance of, it doesn't do so with a call type that is allowed to update storage. Got you. Yeah. Um, so yeah. So then the real question comes down to it's like, okay, well, once we have a few of these rules and let me pull them back up again, once we have a few of these rules, how can we find some of the places where this happens? And there's really two things that I'm looking for here. One of them, of course, is basically anytime you have call without providing a fixed supply of gas, you're going to have a problem like this. But again, that's not what happened here, right? What happened here was a vulnerability based on self dot token.
00:37:05.002 - 00:37:54.814, Speaker A: Right. Here's an address. She want to pull up the swap contract like here. Yeah, pull up the code to this thing really quick. So again, since this is a delegate contract, this is a contract that only delegates to another contract. So there's the real one. So when this gets set up, it gets set up with a user specified token address that gets stored here and then it gets used later for like token balance of, token transfer.
00:37:54.814 - 00:38:54.946, Speaker A: So anytime that you're passing in an address to your contracts anywhere, the question is, what am I doing with this address? Am I writing it to storage or am I calling a function on it like transfer from or balance of or any of these things because there's many token contracts. You'll just grab the address, oh, I'm just going to write the storage based on this address. Like, oh, you have four tokens now you have zero tokens, but anytime you wrap it in as if it was an ERC 20 and then start calling functions on it, it's user supplied. And every one of those is a point at which you're handing off complete control of the contract. I was going to go through a couple of tools I have here for visualizing this a little bit better. Actually, I'm going to remove all these things. Okay, so here's one of the things that I looked at a couple of months ago.
00:38:54.946 - 00:39:38.110, Speaker A: It was called async artwork. There's a couple of tools that I like to use here. One of them is Slither, which is a Trail of Bits program. It's really good at looking your code, finding vulnerabilities, but also visualizing the code and how things are inherited and how things are related and what Fires thing has create like a nice little table of that. We can look at that and then you can figure out like, oh wow, I'm passing in an address here. I wasn't really thinking about how this thing is accepting an address and passing along to something else. The other one I'm looking at is Mithral and Mythics.
00:39:38.110 - 00:40:10.460, Speaker A: Let's start with slither. So I have my things here done in a I have a bunch of different solidity versions in different docker images. There might be a better way to handle this, but I just have like a whole bunch of these things built. So I can just use a Slither that has Solc 0.5.16 built in. And if we run this, is the text font big enough or should I increase the font size? It looks good. Okay.
00:40:10.460 - 00:40:41.114, Speaker A: Yeah. So you get some pretty useful things here. So they talk about sending ETH to arbitrary users. This is a chance for somebody to reject a call and to make an entire system fail. This is maybe if you've been around for a long time, it's kind of called the king of ether problem. We have variables that are never used. We have reentrancy.
00:40:41.114 - 00:41:34.854, Speaker A: These are reentrancy warnings. They don't know if a reentrancy vulnerability is created, but they are recognizing points at which external calls are being made on potentially user supplied addresses. And this can be a really good way. Again, we talked about our formula here of finding the point first before you start kind of applying the rules about what to look for when you are kind of before and after a reentrancy call. This can be a good way to find those lines, to recognize the points at which you are handing off control and then seeing if there is some sort of an attack that can be created out of that. I'm going to look at some other ones here. I've got another it's called it again.
00:41:34.854 - 00:42:24.642, Speaker A: I got different Persians. Here's another one. Yeah, this is one that I found a vulnerability in. And the vulnerability was actually what was discovered right here. This is one of the most classic reentrance vulnerabilities when it comes to an exchange is to be executing a buy or sell order. And when you get control handed to you from the contract because you provided like a bad token in the middle of that call, you cancel your order. So you're in the middle of filling something, you cancel the order, they give you your funds back.
00:42:24.642 - 00:43:16.422, Speaker A: They've already loaded up what they plan on giving you and then they proceed to give you it on both sides. So you both withdraw and take it's. Kind of like you got like a quarter on a string, right? It's exactly what it looks like in solidity. But Slither here is a really good tool for really finding the points where you can start this is what happened, where you can start thinking about what's happening around this call both before and after. And how can I use that to my advantage. While we talk about Slither, I can show some other pretty cool stuff here. So they have different printers, print, see what's one of the printers function.
00:43:16.422 - 00:43:33.850, Speaker A: Summary. Okay. Helps to have much higher resolution. Here, let me do it. You won't be able to see it, but let me just show you what it looks like. It's really pretty. I'm not expecting anybody to be able to read this.
00:43:33.850 - 00:44:15.914, Speaker A: I'll blow it back up in a second. But you can see here we get all the functions, what the external calls that that function makes, what storage variables are written in each function. And it can really kind of help you understand it's like a map of what this thing's doing. And so when you're evaluating, it's like, hey, I've got this reentrancy here. If I could just modify the order book while I'm in the middle of this call. You're like, oh, well, which functions here modify order book as a result of being called. And you can start kind of going through those, like targeting those is like, oh, what if I reentered into this? What if I reentered into cancel order while I'm in the middle of filling this order? Blow back up so you can see it.
00:44:15.914 - 00:44:48.290, Speaker A: But yeah, it's just way more consumable than just, like, browsing, doing control F and just looking for that, because there could be different ways that it gets updated via different paths that you kind of forgot about. So it just kind of like flattens it all into a really consumable way. There's also let's do VARs and off blow it back up again. I'll need to shrink it down a little bit. Not that bad. Yeah. So here's these functions.
00:44:48.290 - 00:45:31.530, Speaker A: These variables are written, and these are the conditions that they found on message sender, right? So it's like, hey, if you want to modify, here are the functions where you can modify these things without being admin or without being a token. Right? Again, if you're trying to attack order book, it's just a great way to see which function calls allow you to modify which things and be like, oh, I have to be admin to be in this. Well, let's check that off the list. I'll focus on ones where I don't need to be admin. It just really helps you hone in on the functions that are going to yield you the most results. Are we good here? Is this interesting? Yeah, this is really good. Okay, great.
00:45:31.530 - 00:45:52.194, Speaker A: All right, great. Let's do this one then call graph. This one's super cool. Oh, I told myself I wasn't going to screw this up. We do a different one. Let me do async artwork. Okay, so we have here zero 516.
00:45:52.194 - 00:46:20.148, Speaker A: Let's do print, call graph. And before I do this, I didn't actually run that notice. I don't have very many files in here. It's got these files. Let me go ahead and run this. So I asked my slither docker container to run this call graph. And now when I look here, I've got a whole bunch of these dot files and created one for every contract in there, like the interface for the 721 receiver.
00:46:20.148 - 00:46:49.324, Speaker A: But we really only care about the real one, right? The main contract that gets deployed and it creates this little dot file which you can do with it. I'm just going to copy that to my clipboard. Pop over here, go to web graphviz. But really anything that can display a dot file. This is just like a quick and easy one that I have. It shows you the relationship between these things, like how they call them. Now there's a bunch of solid.
00:46:49.324 - 00:47:16.472, Speaker A: It looks a little ugly, right? Well, we can actually clean it up a little bit. So let me do this. So I've got this thing in my paste bin, right? I actually don't care about any of the things that say require. I'm just kind of trying to figure out just the way that the functions are related to each other. I don't really care about the requires. Maybe in some case I would care about that, but today I don't. And then there's also another one I have over here which is is approved or owner.
00:47:16.472 - 00:47:49.360, Speaker A: Another one I don't really care about. It's a modifier and not one that I'm really looking for. So let's just do this. So I just sort of like just literally pulled those lines out, copy it again, come back to my browser. Just going to paste that back in. It's like, okay, well this is a little bit more consumable now, right? It's not quite as bad and it can just be a really nice high level way to understand all the different ways to get into safe transfer from. Let's say a lot of times when there's an ERC seven seven seven vulnerability, safe transfer from is the way that those callbacks are initiated.
00:47:49.360 - 00:48:18.930, Speaker A: See this check? 721 received. This is actually for the 721s, but it has the same sort of callback. You can kind of find out like, oh, that happens on token sold. Oh, that happens on accept bid and take buy price. Let's think about ways that this can cause a reentrancy somewhere else here and again going back to the bears and authentic. You can start to really piece together an attack using these. It's like a map of how you might want to construct it.
00:48:18.930 - 00:49:29.230, Speaker A: See here? Oh, I mean maybe you've seen some of these tools here. This will be you. So we have MPX Truffle. Let's move on from Slither and let's move on to what do you call it? What do we call it? Myth. Mythx. So there's like a myth row program that Census creates, but they also have like a nice little paid service that allows you to run very similar stuff. And if you have Truffle built into your system, you can actually just say, hey Truffle, take all the contracts that you are aware of and compile them and flatten them and do all the stuff you need to do.
00:49:29.230 - 00:49:57.736, Speaker A: Oh no, don't do this to me. Probably need run mythx. Like NPX truffle run mythics. I just tried this before I hopped in. Look at my notes. You say NPX truffle run mythx. Yes.
00:49:57.736 - 00:50:17.208, Speaker A: You are right? Yeah. You're super right. Thank you. No worries. Awesome. All right, so it's just a cool way to pass this off. It seems like they find more stuff in their Mythx than their open source.
00:50:17.208 - 00:50:38.652, Speaker A: They also run it really fast. It's way faster to run it this way than I can run locally. It provides like a really nice web interface for jumping around. And so, again, we kind of only want to find the ones that we care about here. Just follow the link here from the output. Again, this is just the one that we care about. That's the main contract that gets deployed.
00:50:38.652 - 00:51:24.850, Speaker A: And if we go back, we can see like, oh, well, there's a loop over unbounded data structure. That's interesting. It goes all the way down here and yeah, in this. Wow, that is kind of interesting, right? They could run out of gas if they have too many unique token creators and that should be bounded somewhere. See here. Yeah, this one actually looks like it did not see the I like to run both tools just because this one actually looks like it did not find the reentrance possibility. But I think it's because of the way that the 721 is created in one contract and this is used in a different contract and they didn't get kind of like pushed together.
00:51:24.850 - 00:52:17.636, Speaker A: You have to use that 721 with this contract, with this Async artwork contract in order to find that vulnerability on the 721 callback. But both tools are nice to use. See here and then of course, you can use Mithral directly, but just run it kind of like manually on so that's going to be Async, but it takes a very long time and it doesn't usually yield as good a results as just running Mythx. Yeah.
00:52:17.658 - 00:52:19.910, Speaker C: And Mythx takes a lot of memory space.
00:52:21.480 - 00:53:04.868, Speaker A: Yeah, let's not wait for this. It's probably going to take another few minutes to run and the results aren't going to be as good and the results aren't going to be as pretty and it didn't look at all the contracts, but other than that, they're both really good tools. And METEX is like $50 a month, so it's not terribly priced. There's also here. I actually haven't used this one, so I actually haven't used this one. But this is the Slither service, kind of like Mythx, and it really integrates with your GitHub and then it kind of acts like a continuous integration. For security.
00:53:04.868 - 00:54:02.490, Speaker A: Which is nice, because you can see just, like, state changes in your pull request before you merge them. And, like, hey, I didn't think there was a reentry before this pull request, and now I do. Maybe you should think about that because it can be really easy to like it's like, oh, this thing's always there, or if you're not really tracking them as they move forward with each code change, it could be not quite as eye opening when it changes, not quite as obvious when it changes. So there's one more, and this is maybe one more I wanted to talk about that I thought might be interesting. See here. So the other SWC that I wanted to talk about, where is it at? Here they are. The other SWC that I thought was kind of interesting was that one down.
00:54:02.490 - 00:54:43.060, Speaker A: Wow. Well, basically it comes down to front running. I can't remember what the number is for. It's like order transaction order dependence. Maybe it's not one. Anyway, this is kind of like maybe not quite as advanced advice as the other ones. But here's kind of an interesting vulnerability that I found in one of the ways that I thought about thinking through it.
00:54:43.060 - 00:55:15.562, Speaker A: We don't need to go through this whole contract. And I pruned it down a little bit, but there was this project that had this notion of like a taxed token where you buy a token and you also need to pay some small amount of ether per block for the right to hold it. This is kind of becoming a more popular model. I've seen in a bunch of new projects. They're calling it like the Harbinger model. It's similar to this artwork is always for sale. That's like a project from a long time ago.
00:55:15.562 - 00:56:10.110, Speaker A: And one of the things that you can do in this thing is like, oh, well, you could buy something, you could buy one of these tokens. And if you bought this token, it basically looked at what the price of the token was, deducted that from the value that you sent in to the contract, and you would pay whoever you bought the token from. Whatever. The price was. And then whatever was left over that became your deposit for holding that token for however long you wanted to keep holding it for. And the code was functional and it worked. But the problem was that the code was vulnerable to front running because somebody's going to say, like, hey, I'm going to buy that token for one ETH, and I want to have like five E in my reserves that gets deposited so that I can kind of pay this per second holding tax on this token.
00:56:10.110 - 00:56:53.130, Speaker A: The problem is that somebody could, at the very, very last minute, after somebody says, hey, I'll go ahead and buy that for one ETH, could submit a transaction that says I would like to buy that for one ETH and I would like to sell it for 5.9 E. And they would only hold it for maybe within a single block. And somebody who thought they were going to have five ETH of deposit when the whole thing was done ends up with 0.1 ETH of deposit because somebody bought and flipped it in just a second or maybe even within a block. See if I can find the code here that talks about that, right? So the deposit here is whatever they had before, plus how much they're including, minus what the price is. But that price can change between when they created their transaction and when they shipped their transaction.
00:56:53.130 - 00:57:26.966, Speaker A: And these ones are kind of sometimes hard to find a little bit. One of the ways that I think about it is for every token that I'm looking at, for every transaction I'm looking at, I'm thinking about like, oh, if I called this, what would happen? I just try to imagine that the block time instead of being 15 seconds, is like 15 minutes. So when I'm thinking about, okay, I'm going to buy this. But imagine you're like looking at Ether scan. There's like a pending transaction here and there's just somebody sitting there looking at it. And there's just a huge amount of time, maybe even 15 hours. It doesn't really matter how long there is.
00:57:26.966 - 00:58:04.380, Speaker A: Just like pretend this is Bitcoin, right? Pretend we're as slow as bitcoin. What could you do in that period of time? And for me, when I start thinking about really long periods of time, it really helps me think about what I would do if I was trying to make money and just hitting refresh on Etherscan all day. I don't have a good tool necessarily for discovering these. It's really just more of like a thought process around the kinds of things that can be influenced via front running. I'll stop there. Are there any questions, anything that we should talk about?
00:58:06.990 - 00:58:42.006, Speaker C: Well, so I just kind of want to comment on this one. The way I think about this is kind of like if there is a lack of confirmation or commitment when someone sends out a transaction, is the blockchain state the same as he was expecting it? Typically what I would recommend some project developers is that they have this commitment specifically in the argument. I'm not sure whether you think about that.
00:58:42.108 - 00:59:29.030, Speaker A: Absolutely. Yeah, that was the suggestion here. The suggestion here was minimum deposit expected. Really? When you're at I think that probably is the good general advice, which is if you're dealing with a price that is stored on chain, you should probably be passing in an argument to confirm that it is close enough to that that you want to proceed because that can change very quickly and unexpectedly. Like what uniswap does, right? You mean you like, hey, I want to exchange this, but I don't want to take worse than this rate because it could change between creation time and execution time. Anytime you're reading storage values that can change and negatively impact the user, you really got to be passing in another argument.
00:59:33.110 - 00:59:45.240, Speaker C: So kind of one follow up question. So thank you for the presentation. I think especially the tools and then how you think about it is really helpful. I was wondering whether.
00:59:47.130 - 00:59:48.022, Speaker A: So do you.
00:59:48.076 - 01:00:05.100, Speaker C: See any missing parts of the tools? Like, for example, what would you want to inspect these security vulnerabilities better. What kind of tools do you think that is kind of lacking out there?
01:00:05.470 - 01:00:24.418, Speaker A: That's a good question. I think just bringing all the tools together because I think you saw like, hey, look, I'm thinking about I ran this like VARs and Auth and then I ran that web mapping one and then I ran the one where the calls happen. It seems like it's still like I.
01:00:24.424 - 01:00:27.282, Speaker C: Don'T know, still a very manual process.
01:00:27.416 - 01:01:07.726, Speaker A: It's a very manual process and I kind of in my brain need to think like, okay, now I'm looking at take by price. Now I got to go over here and remember that take by price had these modifiers modified this state and made an external call. I think that if you could just make these tools really slick and together, I think that a user could start to have their own ideas about it just based on bubbling that up in a way that is just like kind of beautiful. Imagine if all that data was available on that chart. Or imagine if I could say really quickly it's like, oh, get rid of the solidity requires that junks up my thing too much. I can't see enough. Right.
01:01:07.726 - 01:01:27.862, Speaker A: If you could make that easier instead of me just like pulling things out, I'm working with dot files and graph biz. If you could make that like a really slick I don't even know what it would look like, but something that brought it all together. That's where the discoveries happen. They don't happen in the solidity code. Usually they get confirmed in the solidity code. Yeah.
01:01:27.916 - 01:02:05.940, Speaker C: Because it is really hard to trace through especially complex projects. And then when I was looking at some project code that sometimes they have combining all these things, they have delegate call to other extensible modules that they have, then it's really hard to trace right there. And I think the graph also kind of stops there because if you do delegate call, if you just look at the code itself, it's going to an address right, which on the smart contract level, like just looking at the code, it doesn't know where to trace it.
01:02:06.550 - 01:02:37.674, Speaker A: Yeah, absolutely. You're absolutely right. This whole time we've been talking about code. But yeah, this code goes and lives on main net and it gets wired up to other things and we have no visibility into that. At least I don't I don't really have any great tooling for understanding what this code does when it interacts with other things out mean. So Mithril can run against a deployed contract and understands a little bit about some of the storage values, but it's not enough. It's not as good as like Slither or Mithril when it's running against the solidity code.
01:02:37.674 - 01:02:48.900, Speaker A: It's not nearly as advanced. We lose visibility once money goes into the code. Right? Yeah.
01:02:49.430 - 01:02:53.170, Speaker C: Then what do you think about the fork option in Truffle.
01:02:57.030 - 01:03:25.350, Speaker A: Where you fork main net yeah, I don't use that as I have a different actually, maybe you find this interesting. I'll show this. I actually don't use it that much. I started doing something a long time ago before that was available, and it works for me. Let's see where it is. I've seen people use it and I'm always like, amazed and I always think I should totally do that. Old habits.
01:03:25.350 - 01:04:00.360, Speaker A: So Parity has like a whole bunch of these really nice tools for doing deep inspection of how calls happen. And so I can put together a whole bunch of calls and ship them to Parity using Parity Call and Parity Multi Call. That's how I generally do the kind of like fork thing where it's like, hey, what would happen if I ran this series of transactions in it? But I actually haven't used fork. Do you use it a lot?
01:04:01.130 - 01:04:27.086, Speaker C: I do not. And the reason I do not use it a lot is that when you're testing against mainnet, for example, if you just need some dye, then you have to figure out how to get dye on the main net. Even if you can have Ganachi give you a bunch of ether, you have to figure out a way to get all those dives. So I think that's kind of the blocker for testing and walking around with.
01:04:27.108 - 01:04:48.390, Speaker A: It when I use my system. So this is Parity Call and Trace Call. Many. So when I use these things, what's nice about it is I can have like a from. And to be the from can be something that I don't actually have the private key to. In fact, I can actually make the from be a contract address, but I can pretend like it isn't.
01:04:49.210 - 01:04:50.342, Speaker C: That's very cool.
01:04:50.476 - 01:05:06.220, Speaker A: Let me see if I can find the documentation for this because this is super handy. Yeah, because then I could just say, like, I'll just go find a die whale. And my first transaction would be like, hey, die whale, what happens if the die whale gave me all of the die and then I did a whole bunch of stuff.
01:05:07.810 - 01:05:09.466, Speaker C: Yeah, that's super useful.
01:05:09.578 - 01:05:29.090, Speaker A: Yeah. So here we go. You pass it an array of just like, things you want to do, and then it returns you an array of the things that happened. In this case, nothing happened, but it would give you a really nice list of things that occurred.
01:05:30.790 - 01:05:39.480, Speaker C: So just one quick question. So this is ran on Ganachi, or there's a different set of tools, which.
01:05:40.490 - 01:06:04.622, Speaker A: This is just Parity. You have to have a parity node, and the parity node has to be fully synced. Now, there is a web service for this. Somebody actually took this and said, this is so useful, I'm going to make a web interface where you can just basically put these Parity call payloads and then we'll just run it against our node and give you the results. I think it was even an. Archive node. I don't remember the address, but I could send it to you or I could post it in the follow up.
01:06:04.756 - 01:06:06.366, Speaker C: Thank you. That would be really is this a.
01:06:06.388 - 01:06:09.246, Speaker B: Recent service or something that's been around for a while?
01:06:09.348 - 01:06:11.986, Speaker A: It's like maybe like two months or three months or something.
01:06:12.088 - 01:06:19.700, Speaker C: Okay, but downside I see you have to have a fully synced parody node then.
01:06:20.470 - 01:06:33.960, Speaker A: Yeah, it has to be fully has to be fully synced and it has to be parody. I remember that the demo they had was like, check out Vitalik's Die or something. It was like I was looking for that.
01:06:36.190 - 01:06:54.510, Speaker B: For anybody who might be new and they're searching for resources. The Parity client is actually called Open Ethereum now, so if you're searching around online, you might see two different names for it. And some of the documentation is probably old as well for the previous maintainers.
01:06:54.850 - 01:07:03.586, Speaker A: Yeah, I'm a huge fan of those tools and I don't know what's going to happen to them, but for now they work great.
01:07:03.768 - 01:07:08.382, Speaker B: Yeah, I mean, from what I understand, Gnosis has picked up a lot of the responsibility.
01:07:08.446 - 01:07:11.140, Speaker A: Yeah, I see a bunch of stuff there. Maybe it goes better.
01:07:13.930 - 01:07:22.662, Speaker B: I think the Nethermind client has started supporting similar functions as like the old school parody stuff.
01:07:22.796 - 01:07:32.234, Speaker A: Yeah, but I could be no, no, you're right. That's the one that I'm looking for. It seems like they're the ones that are more they plan on pushing the boundaries of some of the RPC stuff.
01:07:32.272 - 01:07:32.938, Speaker B: A little bit more.
01:07:33.024 - 01:07:48.926, Speaker A: Definitely. I'm probably going to be switching to that pretty soon just because some of the disk utilization stuff in Netherbind is really nice. Yeah, I can't seem to so there.
01:07:48.948 - 01:07:54.418, Speaker B: Are a few questions from the streams. Are you good if I just feed them to you?
01:07:54.504 - 01:07:55.380, Speaker A: Yeah, sure.
01:07:55.750 - 01:08:16.198, Speaker B: The first one, and maybe I asked for more context. So maybe this question isn't clear without the context, but one person asked back when we were going over, I think it was Slither. The person asked, perhaps these patterns should become syntax. Maybe that was like ten minutes ago. I don't know if that means anything to you.
01:08:16.284 - 01:08:22.714, Speaker A: Perhaps these patterns should become syntax. I wish I knew what that one applied to. Let me think what that means.
01:08:22.752 - 01:08:26.410, Speaker B: All right, I'll get back to you if they provide any other context.
01:08:28.510 - 01:08:58.470, Speaker A: Maybe what they're talking about is we're coding up all these different things and writing the code from scratch every time and it's hard for us to parse what it does when everything is just like ad hoc EVM code. I don't know. Yeah, my guess is maybe they were maybe asking about some more language features and solidity to kind of ensure some of these things. Maybe. Yeah, totally. Literally that delegate call stuff. Not only is it not a language feature, that implementation that we went over, that was assembly.
01:08:58.470 - 01:09:13.210, Speaker A: It's going to be a pretty sad day when all this code that we're running goes to these admin proxies and you take a hop through assembly every single time. That's dangerous.
01:09:15.070 - 01:09:18.934, Speaker C: Yeah, but at the same time, sometimes there are features, not bugs.
01:09:18.982 - 01:09:42.530, Speaker A: Oh, totally. No, they didn't do the wrong thing, but the fact that the one thing that we do in almost every one of our contracts isn't well supported as a high level language thing. One of the things that they should have in here in this SWC registry is just like users assembly at all. That's where things go off the rails.
01:09:43.030 - 01:09:49.394, Speaker C: Yeah, but it's also like all the features come from all the interesting features somehow.
01:09:49.442 - 01:09:58.940, Speaker A: Absolutely. Yeah, totally. But I mean, that's how Zero X had that first major issue, is like, used assembly typed assembly bracket. Yep. Nope. You got a security problem.
01:10:01.070 - 01:10:04.060, Speaker B: Will, do you want to bring up your question?
01:10:07.660 - 01:10:54.344, Speaker A: Yeah, I just wanted to get your opinion on Fuzzers because you're saying how it's kind of hard to test stuff on mainnet, especially when it's delegating. You don't really know what's getting executed and what maybe is your experience with pulling out some vulnerabilities using Fuzzers. I actually haven't used Fuzzers that much. I probably should add them to my toolbox. Do you use them and do you find good results from them? I haven't personally used them because that's actually why I'm asking about them. Yeah, I actually got some of these other tools, but that hasn't been kind of on my know. Yeah, it hasn't been on my menu either.
01:10:54.344 - 01:11:27.300, Speaker A: There was a couple when I first started this spot check program. I talked to Trail of Bits, and they were promoting two tools. It was manticore and kidna. And it kind of seemed from that conversation that those are tools that I think one of those is a Fuzzer. I know one of those is a symbolic execution. It requires kind of like putting up really integrating deeply with the contract. It's something that you were going to do if you're going to do like a one week or greater audit on something.
01:11:27.300 - 01:11:45.290, Speaker A: And I generally honestly can I'll be honest with you guys? I'm looking at all the easy stuff because it's out there. I haven't really had to go too deep to find what I've found, and I hope that somebody does, but maybe somebody's smarter than me.
01:11:47.180 - 01:11:50.884, Speaker C: By the way, it's echidna.
01:11:51.012 - 01:12:06.256, Speaker A: Echidna the one yeah. It seemed like I'm just trying to run, like slither. I get like, a table, I go and do some stuff. It seemed like Echidna was sort of like, okay, let's set apart part of your data, integrate with it, and to plug in to put your develop inside of it.
01:12:06.438 - 01:12:14.770, Speaker C: Yeah, I kind of had an impression because some people from my team has used it before and then yeah.
01:12:16.600 - 01:12:17.012, Speaker A: It.
01:12:17.066 - 01:12:22.548, Speaker C: Was not as user friendly, I would say, so it's very hard to set up.
01:12:22.714 - 01:12:53.280, Speaker A: Yeah. Oh, you know, it does have the feature that we're talking about here now. I think Tenderly might sorry to interrupt. Remember that call where you can put multiple calls and see what they happen to execution? I think Tenderly came out with a feature for that. I'd have to check. I've been playing around with the Tenderly debugger, and it's really cool. Yeah, I'm really impressed with some of the stuff I've seen on Tinderlay.
01:12:53.280 - 01:13:35.708, Speaker A: It's login don't hack. They had like a bunch like a simulator, I think they think, what they called it. Maybe you can only do one inside of it, though. Yeah, maybe. This has provided some of the features that I think Parity has generally provided me before. Yeah, I'll look for that free service. I was looking for it on my phone here.
01:13:35.708 - 01:13:53.372, Speaker A: I was looking for that free service that offered that same kind of like, do this, then this, then this. And I don't need the private keys for anything because I'm not actually doing yeah. Is there a place, Trent, that I could post a link after I find it so that it can send out to those that might be interested?
01:13:53.506 - 01:14:05.612, Speaker B: Yes. So I'll just loop back with you after and we'll collect all the links to the stuff we talked about and we'll drop it in discord. We'll put it in the YouTube video description everywhere.
01:14:05.756 - 01:14:06.930, Speaker A: Awesome. Cool.
01:14:08.280 - 01:14:18.740, Speaker B: And I got some more context from that previous question, and yes, it was related to explicit security by language features. The person asking about syntax.
01:14:19.160 - 01:14:25.930, Speaker C: Yeah, come to speak of that. How do you think of Viper? Because I think that was the goal of.
01:14:27.820 - 01:15:00.532, Speaker A: I mean, yeah, Viper is supposed to have what, built in overflow protection, built in a bunch of built in other stuff. I don't know. It seems like it's good to have a language that's very geared towards security. It also seems like very insecure to use such a new language and store millions of dollars on it. So it's just kind of like this weird. It's going to have to get a lot more people using it before I think I would feel safe using it. Not that there's anything even specifically wrong with it.
01:15:00.532 - 01:15:04.660, Speaker A: I want somebody else's $100 billion on there first. Not my own.
01:15:04.810 - 01:15:40.720, Speaker D: That makes sense. Hey, Scott, I have a few questions for you. Can we also discuss few things on when the transaction fails? It's hard for developer to find exactly what's happening and where the transaction is failing. I faced a lot of number of transaction revert error messages. It's hard to find out the way to sort out the error from just looking at the ether scan link on the main net or like the testnets.
01:15:41.060 - 01:15:51.060, Speaker A: Yeah, absolutely. It's getting a little bit better. I think one of the things that has really helped is require messages.
01:15:51.720 - 01:15:56.470, Speaker D: Yeah, require revert messages. So I frequently face a lot of problems with this.
01:15:57.240 - 01:16:19.870, Speaker A: But the problem is, I think if you're interacting with something else, if the failure happens inside of somebody else's contract and they didn't have those messages, then, yeah, you're in a bad shape. I'm going to stop my share real quick and then I'm going to start it back up again. Let me show you what I do for that.
01:16:25.300 - 01:16:34.720, Speaker D: So I basically use VM Trace that Ethoscan provides to get the messages where the transaction is actually failing.
01:16:37.620 - 01:16:47.204, Speaker A: Is that? VM trace. Is that the one I use? Let me see. I always forget which trace is which. Is that the internal calls one like.
01:16:47.242 - 01:16:58.840, Speaker D: Etherscan provides you if you go through your particular transaction, on the right side, you will find the three dots, vertical dots. So if you click on that, there will be option for VM Trace.
01:16:59.660 - 01:17:23.766, Speaker A: I'm looking up right now. Let me see. That might be the one I was just going to show you on the command line because it was a trace that I use. So three dots. Oh, Ether SCAN's tracers are broken. What's going on? I didn't get that option in this one. The one I use is called Parity trace.
01:17:23.766 - 01:17:26.122, Speaker A: Actually, here, let me just show it. Let me just share my screen again.
01:17:26.256 - 01:17:27.260, Speaker D: Yeah, exactly.
01:17:27.870 - 01:17:59.670, Speaker A: Parity Trace. Yeah, parity Trace is the one that I use for all these things. In fact, I mean, Parity Trace and that other one I was talking about where I could do a bunch of things at once, it's really two parts of the same coin. It's like, am I tracing a transaction that has already occurred? Am I tracing a transaction that I am considering executing? Oh, yeah, VM Traces, that's what it's called. Totally. I don't currently have a better method than require messages. And this I know there are people out there who do debuggers.
01:17:59.670 - 01:18:07.962, Speaker A: I just haven't really by the way, he's talking about this. Let me find one that actually does something more interesting than nothing.
01:18:08.096 - 01:18:26.720, Speaker D: Could you please just give me an example? Like, how do you trace the exact error messages that one can go and just change in the code? And how to find the waste transaction is failing. Exactly.
01:18:29.490 - 01:18:32.020, Speaker A: When these things fail, can we find one of these?
01:18:32.630 - 01:18:33.380, Speaker D: Yes.
01:18:36.230 - 01:18:55.560, Speaker A: But if you fail with the require, then it will tell you right here, it should tell you the reason that it failed. Whatever message you put in there, it should tell you that it failed for that reason. Like, oh, you didn't have enough die, or you none of these people are.
01:18:56.270 - 01:18:58.060, Speaker D: If this is a revert case.
01:19:00.110 - 01:19:02.380, Speaker A: If it's a revert case, yes.
01:19:05.710 - 01:19:13.950, Speaker D: The transaction reverts, so there will be no error message over there. So it's really hard to find out the execution.
01:19:14.450 - 01:19:29.410, Speaker A: I mean, if it reverts, it either reverts because it hit a require and the require could have had an error message on it, or it reverts because it hit an unknown opcode, or it reverts because what's the other one?
01:19:29.560 - 01:19:32.850, Speaker D: If it fails to require met the condition.
01:19:33.830 - 01:19:43.366, Speaker A: Right, but that should just give me an example of one, because I'm pretty sure that there should be requires for all those that have error messages out of gas, right?
01:19:43.548 - 01:19:44.326, Speaker D: Yes.
01:19:44.508 - 01:20:11.360, Speaker A: Right. So it either should run out of gas, revert, or fail. And we shouldn't be getting too many fails because that's just like you had an opcode that's invalid. Okay. For the other ones, there should be I can't believe I can't find any examples of anybody using revert messages. Well, here, let me show you. You know what? Maybe this is interesting.
01:20:11.360 - 01:21:57.764, Speaker A: Um, trying to find a good example here. You only see my Chrome screen, right? Yes, correct. Okay. Trying to find a good example here. This maker governance. Is this one's good? Let me share my screen again. It okay.
01:21:57.764 - 01:22:36.450, Speaker A: So I got this little script here that all it does is really just kind of creates a little JSON payload and asks my supposedly local parity node if it has this. It submits a query to my local parity node for a trace call. Many I have one here. This is just something that I was looking at, and this is kind of what one of these payloads looks like. So if you could structure your things like this payload, you could get these traces. But when you get these traces let me get this parity call. This is kind of the thing I was talking about, where they had that web service.
01:22:36.450 - 01:23:24.236, Speaker A: You get back results that look like this, which are like, it's an array of the output and what it did and who it talked to and why it did it and all these cool things. Now, what's interesting is that when you have a revert here and I don't know if I'll need to find a good revert case, we have here the result. The output will actually have an encoding, like, even deeper down in the stack, the output will have an encoding of what that required revert message was, let me see if I can find one. It'd be kind of hard, actually. No, it won't. Let's look at Die. So let's just take, like, somebody's Die transaction.
01:23:24.236 - 01:23:42.470, Speaker A: I don't know who this is. What's this person doing? They're transferring die. Perfect. Cool. So let's view that input as the original. Let's go ahead and dump that into our this is our file here. We're generating so we can go.
01:23:42.470 - 01:24:22.624, Speaker A: So I'm going to try to send this, but I'm send it from and then the destination, of course, is going to be the Die contract. So we're saying, like, hey, I want you to do whatever transaction that person just did. We're sending it to that contract. We're sending it from somebody. This is just like a maker contract that I was, like, testing around somewhere else. So it doesn't have any dive, probably. So if we run this now, we see that it reverted, but we also see that the overall output here is what it returned, and you'll get this, like, per I believe you'll get this per call, per sub call.
01:24:22.624 - 01:25:09.260, Speaker A: And this is weird. Maybe do, like, web three to no, sorry. Hex to ASCII actually pull messages out of any individual subcall that you have. I know it's kind of not very friendly, but the ability to kind of, like, look at the revert message for whatever internal message depth you have can be helpful, but I believe it should bubble up all the way. But if it's not bubbling up, if something is, anything that fails with a revert message should appear in this VM trace we've been talking about. Is that helpful, or did I go too?
01:25:11.230 - 01:25:12.262, Speaker C: That was really helpful.
01:25:12.326 - 01:26:03.520, Speaker A: Thank you. Okay. But yeah, these things get returned everywhere, and so they should be able to get parsed again. It kind of comes down to the question about, like, boy, what tooling do you want? It's like, well, this sucks, right? This is not a great way to have to interact with these things. I mean, the data is there, but it should be a little easier to get these traces and to inspect them in a way that's that's more actionable. Yeah, I mean, the debugging I know other people do step debuggers, and other people have other things that they do. I generally just do it with internal traces that I look at and try to understand from there.
01:26:03.520 - 01:26:34.150, Speaker A: But if you're doing a lot of logic in one function and not making a lot of internal calls, it's less helpful. Right. Anything else, or should we trent, do you think maybe now is a good time to call it or any more outstanding questions?
01:26:36.840 - 01:26:44.410, Speaker B: Yeah, I mean, this has been super helpful for a lot of people, I think. Does anybody have any final questions?
01:26:46.460 - 01:26:49.508, Speaker C: No, not really, but it was really great. Thank you, Scott.
01:26:49.604 - 01:26:58.700, Speaker A: Awesome. Thank you. Thanks for showing up. And thanks for the questions. We weren't just sitting here awkwardly 20 minutes after I started, so I appreciate all the questions.
01:26:58.850 - 01:27:10.290, Speaker B: Do you want to give any final wrap up comments on just I guess it's up to you general about your practice, what you're doing.
01:27:11.780 - 01:27:59.490, Speaker A: It seems like the skill level that people have showed up here, it's pretty high. So normally what I recommend people do if they are really interested is there's like a couple of the games that we have here. There's like, what is it? Ethernotes, but it sounds like most of the people here are beyond that. But I find this to be just a great way to kind of get to recognize things in your own contracts. And there's also the capture the ether. These are both like, really good tools. If you're earlier on in your career and want to check these things out, this is a great way to see how to identify these things and exploit them and make sure they don't happen to yourself.
01:27:59.490 - 01:28:19.610, Speaker A: And if you have projects that you're interested in having me check out. This Spot Check program just offers free, several hour quick, high level reviews. Again, just looking for the really basic stuff because a lot of times the basic stuff still is out there. So I'd be happy to take a look as part of that Ethereum Foundation Spot Check program.
01:28:21.420 - 01:28:22.264, Speaker B: Awesome.
01:28:22.462 - 01:28:23.064, Speaker A: Cool.
01:28:23.182 - 01:28:40.700, Speaker B: Really appreciate you spending this time. Like I said, it's going to be super helpful for people who are on the call and then also the recording that people can watch and refer to later. If there are some hack money hackers that are interested in connecting with you. Where's the best place to do that? In the discord.
01:28:41.520 - 01:28:49.250, Speaker A: Yeah, I'm on the discord. I'm also eph eph on Twitter. But yeah, I'm also on the Discord too. So, yeah, hit me up anyway.
01:28:50.100 - 01:29:26.030, Speaker B: Awesome. All right, final points before we sign off. Obviously, today was the solidity vulnerability session. Tomorrow we have a session with Ken from the Ecosystem Support Program about how to take your project from a hackathon to mainnet and beyond, how to produce, basically how to become sustainable, how to develop your project outside of short term events like this. It's going to be a really great session. I encourage everybody to sign up for that and attend. Then Thursday is the final.
01:29:26.030 - 01:29:49.604, Speaker B: Yeah, I think there will be the final hack feedback session. So we'll have mentors. You can come. You get a ten minute slot to present and get feedback from mentors. Again, highly encourage people to come to that. Get any last minute feedback from people before you create your pitch videos for Judging, which is happening all of next week. We dropped some links and also sent an email about how judging is going to work.
01:29:49.604 - 01:30:18.652, Speaker B: So definitely check that out. There are some requirements you have to make a short video to present with. You're going to want to make sure you understand what all the requirements are. And then Friday, there's an AMA with Hayden from Uniswap. So again, a bunch of really great events this week as we finish out Hack Money. Make sure you're checking in with East Global team members if you have any last minute blockers or any issues before submission on Sunday. Again.
01:30:18.652 - 01:30:40.244, Speaker B: Remember that's Sunday 1159 Eastern time? So we're super excited to see everybody's submissions and can't wait to get on to Judging next week. It's going to be awesome. Thank you, everybody, for coming. We're going to sign off here. Have a good rest of the day.
01:30:40.442 - 01:30:41.664, Speaker A: Thank you. Bye.
01:30:41.792 - 01:30:43.360, Speaker B: See you. Bye.
