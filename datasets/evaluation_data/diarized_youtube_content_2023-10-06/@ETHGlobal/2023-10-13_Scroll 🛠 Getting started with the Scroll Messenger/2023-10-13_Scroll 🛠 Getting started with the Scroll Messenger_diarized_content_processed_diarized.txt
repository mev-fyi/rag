00:00:07.130 - 00:00:56.400, Speaker A: Thanks eglobal for having me and scroll excited to talk to the devs about Scroll messenger and also deploying on scroll. Yeah, so we're going to talk a little bit about zero knowledge and scaling ethereum being that they're the reason why is in this space what is scroll? Talk a little bit about roll ups and then we will dive into the bridge side of things which is the scroll messenger. Short intro about myself. I'm Raza, a coding nerd. You can find me everywhere at Raza codes and definitely check out scroll IO as a quick notification to everyone. If you have a question or anything is not clear, please feel free to interrupt me. Would love to answer anything as we go.
00:00:56.400 - 00:01:57.182, Speaker A: And also a quick reminder on our prizes. We've got 20k in prizes, a price pool of 4k, which means you just deploy and verify your smart contract and you're already eligible for a part of the price pool. We've got three prizes of two k per team and ten prizes of one k per team. You can read the criteria here, they're also on the ETH global website and if you have any questions regarding them, feel free to approach me either on Twitter or we have a telegram group which I will just quickly share inside the chat. So if you have a need of let's say testnet eth or if you have any questions, feel free to join this telegram group and the scroll team will be there to answer any questions. So let's dive into it. ZK rollups we're going to talk a little bit about roll ups and the distinguishments between roll ups.
00:01:57.182 - 00:02:35.914, Speaker A: ZK roll up specifically as mentioned by Vitalik, the holy grill of scaling solutions. So very quickly, what is a roll up? I won't dive into too deep. I mean crypto Twitter is always added and everyone has their definition, but it simply put a roll up batches transactions off chain. So not on an l one, l one being ethereum, and then posts the resulting data on chain. Meaning in this case l one ethereum. So how does it solve scalability problems? Well, an l one doesn't need to re execute the transactions. However, an L one does need to prove that these transactions have been processed correctly.
00:02:35.914 - 00:03:19.850, Speaker A: And typically there are two types of proofs, validity proofs which we will talk about, and fraud proofs. If you're familiar with optimistic roll ups, they utilize fraud proofs and they work slightly different. But we won't talk about optimistic roll ups in this talk as the time is obviously limited. So validity proofs are utilized in a ZK roll up a ZK rollup submits transactions together with a ZK proof that the transactions are valid. And a ZK rollup will generate the ZK proofs primarily to prove the states and that everything is updated correctly. So Ethereum knows hey, the transactions are correct. But how does Ethereum know it? Well, that's because on Ethereum there's a smart contract that can verify the transactions.
00:03:19.850 - 00:04:15.806, Speaker A: Sorry, verify the proof along with the transactions that are posted on that smart contract. So typically speaking, if you look at the ZK roller space right now, this is a graph from the article from Vitalik where he explained the different types of ZK robes out there. I usually like to look at it simplified like this, and I'll touch upon in a moment why this is important. So, typically speaking right now, if you look at all the different types of ZK roll ups, you can either be very close to Ethereum, I. E. Being EVM compatible, or there's a trade up to be made in the performance the time to generate a proof now what does this mean? To generate a zero knowledge proof requires quite a bit of computation and overhead. So if we go back, you can see that as you go move down in the type, I.
00:04:15.806 - 00:05:05.750, Speaker A: E. You go closer to type one, it takes a long time to generate the proof. That's because if a ZK roll up wants to stay close to the EVM, I. E. Act and behave just like Ethereum, it takes a long time to generate the proof because of all the behaviors that needs to be proven that would normally occur for a smart contract in EVM. If you would pick a different type of virtual machine, the trade off is that you wouldn't have an EVM compatible chain, but you'd be able to generate faster proofs. Now, if you look at the typical qualification, it's usually EVM compatible for this language compatible ZK rollups.
00:05:05.750 - 00:06:08.846, Speaker A: An example of language compatible is Starkware and Zksync and EVM compatible being Ethereum. So why would you choose for EVM compatible even though it takes a longer time to generate proofs? Well, that is because you as a developer will be able to use all your existing skills, I. E. Yule, solidity, Viper and your existing devtools, just the way you would utilize them on Ethereum. So the major benefit of EVM compatibility is that even though the performance of time to generate proof takes longer for the developer, the developer experience is much more pleasant because it's a lift and shift from what you're used to in the Ethereum ecosystem. So let's talk a little bit about how scroll works. And this will be essential to understand why we need a bridge, something like scroll messenger, in order to, let's say, move assets or else send data back and forth.
00:06:08.846 - 00:06:40.106, Speaker A: So the scroll architecture, like I mentioned before, we're a ZK roll up. So on the first layer you can see here, that would be Ethereum, where we have mainly two contracts. The bridge contract, we will dive in a bit, and the roll up contract. On our ZK roll up, we basically have two different layers. One is a sequencing layer, you might have heard of a sequencer. This is a node that processes all the transactions. So any user that interacts with scroll, you would interact with it.
00:06:40.106 - 00:07:21.046, Speaker A: Just like with Ethereum, it's just an RPC URL change. You would send any transactions to that RPC endpoint, and the execution node takes care of that. What happens simultaneously is that there's a different network of nodes, the proving network, that takes care of generating the proof. And not to dive into too deep. If you have any questions, feel free to approach me or drop them in telegram group. But simply put, what we do is transactions are batched into blocks, blocks are batched into chunks, and then we generate a proof for every chunk and then the prover network. So this is done in a parallelized manner.
00:07:21.046 - 00:08:14.358, Speaker A: The proving network generates an aggregated proof over all these proof that are generated per chunk, sends it to the coordinator, and that's sent to the roll up node, and then the roll up node sends it to the roll up contract. Remember in my story, I explained that if you have an l, one such as Ethereum, a roll up posts the batches of transactions on Ethereum. But Ethereum needs to understand, hey, are these correct or not? And so there's a smart contract on Ethereum that has the ability to verify the proof that a roll up, a ZK roll up, also posts. And that happens over here. So that's in a nutshell, how the scroll architecture works. And over here you can see an overview of what each of these nodes do. One quick comment I would like to make is that our proven network today is actually decentralized.
00:08:14.358 - 00:08:58.070, Speaker A: It is permissioned, but it's one of the things that scroll is very much focused on is that some components right now are centralized. Most of some components are decentralized. We're now on the road to making sure that everything will be decentralized. And our objective is to make sure that everything's decentralized and permissionless. So I briefly spoke about the architecture, and over here you can see a more deep dive of the transaction lifecycle. Again, we won't dive in too deep into this because I want to show to you guys how easy it is to deploy on scroll the main benefit of being EVM compatible and then also diving to the bridge side of things. So over here you can see a user just like any other user.
00:08:58.070 - 00:09:41.826, Speaker A: Just like Ethereum would send their transactions, the execution node batches them together, sends it to the roll up node which posts it on the roll up contract. And side by side you have the coordinator that takes care of that, coordinates the prover network, and the proven network generates a ZK proof. It goes back and the roll of nodes posts it on the roll up contract. You can, by the way, find all of these images on our docs, but we also have a good explanation. So whole transaction lifecycle is documented. Probably something to mention is the phases of a transaction. So I'm going to go back and forth between each slide.
00:09:41.826 - 00:10:31.750, Speaker A: Phase one is when a user submits a transaction, and what happens is that the sequencer basically processes the transactions and generates the block. This usually takes one to 2 seconds, and this is known as the pre committed phase. At this stage, transactions are available on the ZK rollout. The second phase is when the blocks of transactions are committed on l one. So before we commit the ZK proof, we already commit the batch of transaction. So that would be in this case over here, as you can see, in a matter of minutes we commit the batch transactions on Ethereum. And then the phase number three is when we have generated the ZK proof and committed and verified it on chain as well.
00:10:31.750 - 00:11:28.546, Speaker A: And that takes roughly ten minutes. Now I just want to quickly pause here. You might think, hey, ten minutes, that takes quite a bit of time. And this is something that is being improved over time. And we will see great things in the zero knowledge scaling space. But the comparison is not necessarily instant versus ten minutes, but ten minutes versus, for instance, when you look at optimistic roll ups where there's an arbitrary period, if you know about the arbitrary period, sorry, if you don't know about the arbitrary period, I'm just going to briefly touch upon it, which is, as you might know, in an optimistic roll up, it's also a roll up commits the batches of transaction, and then there is an arbitrary period, meaning a set of predefined period that can be either three days, can be one day, can be one week, where anyone can challenge these transactions. And if there is a fraud, if there are a malicious transaction, a fraud proof can be committed.
00:11:28.546 - 00:12:30.022, Speaker A: So I know there is a whole debate about what the arbitrary period is, but let's assume that it's around three days or seven days. That's basically the comparison to make that it's ten minutes versus the seven days or three days that an optimistic roll up would have to be exposed to. So that was in a nutshell, how scroll works. Now, again, scroll is an L two ZK roll up, meaning it's a different blockchain network, but it commits everything back to a layer one. And this is a very important point that I will touch upon again when we're going to go and talk about the bridge. But now I want to quickly showcase to everyone how easy it is to actually deploy on scroll. So I'm just going to show over here my code editor going to launch here and I've set everything up terminal.
00:12:30.022 - 00:13:01.794, Speaker A: I just want to showcase the benefit of EVM compatibility. So this is just a basic smart contract that I grabbed from the solidity by example website. If you don't know, it's a great resource for you to look at solidity examples. And it's a basic ether wallet. And over here I have a deploy script that will utilize to deploy this smart contract. I'm going to showcase the hardhead config. And over here I'm going to utilize truffle dashboard.
00:13:01.794 - 00:13:39.410, Speaker A: Now if you know a little bit about truffle, unfortunately it has been decommissioned or they're going to stop supporting it. I'm still going to use it till the end. It's where my journey started and I think it's a great tool to use. But we'll utilize the truffle dash to deploy. And over here I have configured the URL, the RPC URL for Sepolia scroll for local testing. If need be, you can find all this information inside our docs as well. So what I'll do is I'll just compile my contract.
00:13:39.410 - 00:14:16.526, Speaker A: Already compiled it. So I'm starting to compile. And then what I'll do is I will run this command which will basically launch, send the bytecode to the truffle dashboard to deploy on scrolls. I'm just going to go ahead and pull up first the truffle dashboard so you guys can see it as well and check if I'm connected to the right network. I am. By the way, a very easy way to connect to any network that you would like is chainlist. So I'm just going to show that to everyone.
00:14:16.526 - 00:15:00.310, Speaker A: If you type over here, scroll sepolia over here you can see the correct network and you can click add to Metamask. I won't do that because I've already done that. If you add it to Metamask, it's a very easy way for you to add the scroll network to your wallet. And by the way, if you want to add it manually to your devtool, this is a page of our developer, Quickstart. And over here you can see the RPC URL, the chain Id, everything that you basically need in order to connect to the scroll network. So I'm just going to go back, just going to go back and move this. And over here you can see truffle dashboard.
00:15:00.310 - 00:15:36.350, Speaker A: I will go ahead and run the command, go back to the dashboard, and over here you can see that the transaction has been sent. I'm going to click on confirm. Metamass pops up, confirm the transaction. And over here we can see the contract that's being deployed. We'll give it a second and it's confirmed. We can view it on a block explorer. We've got an Etoscan block explorer.
00:15:36.350 - 00:16:13.166, Speaker A: And over here you can see 15 seconds ago it's a success. And we deployed our smart contract so the same way you could do that, if you've added to Metamask with the scroll network, you can do it, utilize remix, for instance. And it is as easy as that to deploy on scroll. It's just an RPC URL change. You copy paste and you basically deploy to scroll. If your favorite devtool is maybe ape because you like Python or foundry, you've been red pilled and you like foundry. Nowadays it all works out of the box the same way as well.
00:16:13.166 - 00:16:42.738, Speaker A: It's just an RPC endpoint change. So now that I've showncased on how to deploy on scroll, I quickly want to touch upon bridges. So I've mentioned that. Am I good on time? Yes. So I've mentioned that scroll is a different network and blockchain networks are isolated. I-E-A network such as L one, such as Ethereum, cannot natively communicate with an l two such as scroll. So enter blockchains.
00:16:42.738 - 00:17:30.674, Speaker A: And here is just like a very simple example as a use case of what if you would like to transfer an asset from one blockchain to another? Well, the way that happens is through something called bridge contracts. So one bridge contract would communicate with another. And the specific methods of transferring the tokens, they differ. It could be that there are wrap tokens being minted. There could be a different form of asset where this bridge contract actually holds specific assets. ERC twenty s and sends them to the user's wallet once the contract has been triggered. But you might see something missing actually in this overview because like I said, blockchains are isolated.
00:17:30.674 - 00:18:32.554, Speaker A: So how do these two bridge contracts communicate? Well, that's usually through a third party service or a relayer. So this is actually how a bridge usually works is where a bridge has a contract on both sides on a blockchain a and a blockchain b also refers sometimes as a source blockchain and the target blockchain. So the target blockchain is where you're going and then utilizing a relayer, which is usually a service that listens to both contracts and makes sure that communication either in one way or both ways is possible. And that's what the scroll messenger is. The scroll messenger is a bridge. And so over here, what you see is what I'll showcase to you guys in the smart contract is we're going to send a message from l one. So a testnet sepolia to the scroll testnet and then we'll send a message from the scroll testnet to l one back to Sepolia and we'll do that step by step.
00:18:32.554 - 00:18:55.746, Speaker A: Now very important to note, when I say message, I mean that's arbitrary data, meaning it's just any data. If you would like to transfer ERC 20 assets, if you would like to transfer an NFT, that's all possible. And we've got specific guides for that. Right now I will showcase to you the bare bone version of this, I. E. Any data that you would like to send from left to right, I. E.
00:18:55.746 - 00:20:01.442, Speaker A: In this case from Ethereum to scroll. So what happens over here is, and I'll show the code in a bit, we have one smart contract and this can be any smart contract. In this case it's called the operator that we have deployed on sepolia. And what we want to do is say, hey, from this operator we want to change the message that is on l two inside our greeter contract. Now what will happen is that we will tell this smart contract, hey, talk to the scroll messenger, the bridge contract, and we want to target this smart contract. And then we send an arbitrary piece of data. Now when we do that, we send a little bit of eth and that has to do with the fact that when you send a message or data from an l one to an l two, the transactions on l two have to be processed and the l two messenger needs some eth in order to update the state of, in this case the greeter smart contract.
00:20:01.442 - 00:20:32.590, Speaker A: Now you might notice saying, hey, I'm not seeing the third party relay. And that's because when we go from l one to l two, I'm just going to go back a couple of slides over here. You can see that we have in our sequencer on l two, the sync service. And what this does is it listens to the bridge contract and it pulls in any l one transactions that are committed on the bridge contract. And this is the scroll messenger contract on l one. So that's why in this specific overview, you can't see that. But this is a simplified overview.
00:20:32.590 - 00:21:07.954, Speaker A: So when we go back, I'm going to pull up remix final, not remix. Over here. And over here I have a set of four contracts. Just going to go to this one. And I'm just going to walk everyone through the set of contracts that delivered a message from l one to l two. So I'm just going to open these contracts. That is this contract and this contract.
00:21:07.954 - 00:21:26.206, Speaker A: So over here you can see we have a greeter on scroll. So I'm going to go back. That's this one. This is our smart contract on Altud. And the greeter on scroll looks something like this. It's a very simple smart contract. It has a variable where it says with a string says hello world.
00:21:26.206 - 00:22:06.166, Speaker A: And over here you can see a function that allows this variable greeting to be updated. Now if you pay close attention, you can see that the variable is actually called hello world. But over here, when I call the variable, it says hello world from Sepolian. And that is because prior to this session, I actually sent a message from l one to l two. And I'm going to show you how I did it. I won't do it during the workshop, being that it can usually take up to four or five minutes, up to ten minutes. And at the risk of during a demo, everything breaks.
00:22:06.166 - 00:22:30.926, Speaker A: I'm just going to showcase how it works. But again, feel free to approach me or any of the team if you run into something. So again, we have a greeter contract on l two. And that's where we want to change state. When we say change state, we just want to update. We want to update some data, some arbitrary data. So I'm going to go and showcase the operator contract on sepolia.
00:22:30.926 - 00:22:55.530, Speaker A: So this is on l one. And what this contract does is actually a very simple bunch of things. What it will do is we need to tell this contract what the smart contract address of this l one bridge contract is. So that's what I've done over here. If you're wondering where you can get this information. Over here in the docs, we have two places. I'm sorry, I need to remove.
00:22:55.530 - 00:23:19.250, Speaker A: Just lift this. Yeah. We have in our docs all the contracts that are available on all our scrolls. Smart contracts. So over here you can see the l one and l two messenger. In this case, I need the l one messenger because remember, I want to send a message from l one to l two. So what I do first is this contract.
00:23:19.250 - 00:23:46.422, Speaker A: I copy and paste it in the scroll messenger address. The second thing I need to tell the scroll bridges is which smart contract I'm targeting on l two. In this case, remember, we want the greeter contract, and that is smart contract over here. So I copy and paste that address. We send zero value because in this case, we're not actually sending any eth to the target address. And over here, you can see the greeting that I sent. And we set the gas limit.
00:23:46.422 - 00:24:20.274, Speaker A: This gas limit is pretty high. I mean, 10,000 would work as well. The only gas that actually they utilize will be spent and then the remaining will be sent back. And so over here, you can see that as soon as I click here, transact, which I won't do right now, basically what happens is that the state on l two will be updated. And over here, you can see that's what I did a moment ago. Quick side note again. When we send it from l one to l two, we want to send some eth along.
00:24:20.274 - 00:24:55.258, Speaker A: Doesn't need to be a lot, but we want to make sure that our transaction doesn't revert on l two. And so we send a little bit eth to l two. Sorry. Along with smart contract, so the transactions can be processed. Something that I've noticed right now I haven't mentioned is the native currency on scroll is eth, and again, EVM compatible, staying close to the Ethereum ecosystem. So when you develop on scroll, you use eth as a native currency to pay your gas transactions. The way you get your eth there is through the scroll bridge.
00:24:55.258 - 00:25:46.530, Speaker A: Or if you just want some testnet e, remember to join our telegram group and we will send you some. So this is how we send it from l one to l two. Now, if you go back to our slide and we want to send it from l two to l one, there's one addition that we need to consider now. When we send the message from l two to l one, ethereum needs to know. Hey, first of all, is this transaction correct or not? Remember, when we look at all the transactions and then messages at the end of this also transaction they're batched together and they're sent to l one. So the Zk proof is generated for that as well. But also on l one we want to make sure that the correct user is allowed to withdraw any data.
00:25:46.530 - 00:26:44.834, Speaker A: So in order to do that on l ones we're going to need something called Merkel proof. And so I'm just going to go back to remix and over here what I'll do is I'll showcase a part of our doc which is important to just dive in if you need any more information. But basically what we're going to do is we're going to make a call. We have a relay service for this. And what this does is over here you can see the API call that you can make is by sending the smart contract address of your operator you will make an API call and I'll show you what it looks like. Looks like something like this and that looks like a lot. I'm just going to increase the size of my screen and basically what it will give you back is all the transaction data that you will need to fill in in a specific page.
00:26:44.834 - 00:27:50.566, Speaker A: I'll show you that in a bit. You will need to tell the l one messenger, smart contract messenger. Hey, this transaction was either sent for me or is sent by me. And I have the proof and that starts over here you can see proof, I have the merkle proof to withdraw this piece of data and that will allow to update state and I think I've got a couple of minutes and then I'll show you guys a video of how that exactly looks like. So over here on the etoscansapolia, if you click on the link inside the docs it will take you to the messenger contract. And over here you fill out all the data and I hope I'm not walking through this too quickly, but over here you can see I'll quickly showcase a video that when all your data is filled in what you can do is click on write and that will send the transaction. And over here and this can view the transaction.
00:27:50.566 - 00:28:20.846, Speaker A: And then once the transaction is sent, as you can see over here, I'm just going to click back again. Once the transaction is sent successfully to the l one messenger and the proof has been submitted, over here you can see I click reading and it changed from hello world to hello from scroll. All right, we're 1 minute left on the clock. I'm not sure if there are any questions. Would love to answer some. I hope this was useful. I know there was kind of like a speed run, but again, a drop.
00:28:20.846 - 00:28:27.600, Speaker A: Telegram link. Any questions you have, feel free to approach us. We would love to help you. Super stoked to see what you guys will build.
