00:03:42.960 - 00:03:43.510, Speaker A: You.
00:03:46.200 - 00:06:21.984, Speaker B: And for those who are listening to live stream because that's what they told me most of the people are today. Tonight we're going to talk a little bit about proof of stake and the merge and actually I'm going to do it in Spanish so I'm going to be practicing my Spanish a little bit so you can help me out if I struggle when I struggle, maybe. And for those of you who only speak English I've done a similar version of this talk in Buenos Aires last week so you can find that recording there or ask me for it or talk to me afterwards. Pero bueno empezamos oye bamasolar estonocalar the proof of stake el merge joe travahokon el fundasion de ethereum especimente con el capo de DevCon BNA abogata ESTA anio and octubre pro primeroves and sudamerica esperaque les vemos aja I perlosquendo. Oro viendo ora tenemosunku area donde sepuen applicar poor undesquento tambien manana con booth el centro peroi nostamasolano de DevCon bamasolar de proof of stake. El merge algo mass technico pero bamasolar and poco MAS de los Basicos estamos cambiano. Al merge proof of stake per KVNA el merge basic proof of stake contra proof of work e m pesamos con ethereum and henial EKS locatemos de ethereum global neotral yes, lamas importante lamente neotro systema c nasisitamos k SS promuchus nose mutus personas independientesigimos.
00:06:21.984 - 00:07:31.052, Speaker B: Unsistema quesos personas Independientes. Elinia online VERTO mente ilavaresque super deficie Perque super fasci Copias o sibyls de uno mismo Elinia puerto unascota una salares and agunas lugaris mass personas solo tumismo entones nasitamos prevenir. Esto persona sejama sybil civil inaccessamos unprotection civil parataneer UN systema. Neotral Maharo per muccos Noros MUTOs personas poromundo e tanto el proof of stake coma. Proof of work son mechanisms. The protection civil civil protection mechanisms. ETosis queson queson? KS proof of stake e proof of work.
00:07:31.052 - 00:07:48.480, Speaker B: Real mente queson son perevas de recurso Escaso comoskers resource e Perque unscarce resource necessitamos algo deficie paracopier deficie paracopier.
00:07:51.220 - 00:07:51.584, Speaker A: No.
00:07:51.622 - 00:09:57.040, Speaker B: As fasci para para pretender mass influencia sobre el CEMA KS. Algo KS deficie para paradiplicar paracopia algo economico como capital proof of stake of stake comma proof of work son proof of capital como pro de capital pro de niro los dos mpasan condinero and proof of stake TNS dinero conesa dinero compress ether e demuestras kela tienes poor staking dondela la pues proof of work. TNS dinero compress Narcia pararezover UNOS acertillos essottos risottas parademostra el dinero fuegastaro peron los dos casos and piezas con el dinero el capital. Lostosom prevas de capital enlos casos no puerto duplicar el capital paratratar de almentar la influencia ketianis el proof of stake EOP of work. I June guarantees manejao promuchos personas defrantes crayebla mente ESO ajura agar una neutrale cona red. De ethereum or bitcoin olokesaya enthusias bueno SOS on poco de porque proof of stake Perque ethereum estacambiando a proof of stake peropimero coneSo creole pianzoke respondemos. Proof of stake proof of work in toros los santiros.
00:09:57.040 - 00:11:53.504, Speaker B: It proof of work no e Pascal SKC el noro Sisunoro valedidor say desconnecta dorante mesis ike confia and una migo own campagnaro, own serviceio parabtener eltimola style el Granos in proof of work perotoloville existe and algonos warmas convientoes de los clientes. Los blockes de genesis elos initial IPS de boot nodes. Proceed, menos otra posile de proof of work. Escalos attackes. A Proof of Work somas de tactales anterior mente location esque sevan atacar a Proof Of Work la Campra de miles de mijones, de dores, de hardware de minaria es problemnte notable pero Conesto de RIA. Joe notables in physico iatacarlos entonces perozi bueno es MAS no table antarumente. Itres el proof of work.
00:11:53.504 - 00:13:00.252, Speaker B: TNA unamejor distribution del token lejos de los mineros. Location SKUF of work obliga alos mineros Avander parte de sucensa procosto de Narcia e hardware ESOC exist massomenos and Professor C existe mass como paracero minero tinesquendo cassie constantimente constantimente la recompenses the proof of work versus proof of stake. Le recomiento estos dos recoursos uno de vitale articulo e otra as UNPORT Justin Drake elina alden de bankless. Estos. Exactly. Estoso. Estos.
00:13:00.252 - 00:13:17.508, Speaker B: Yablamas. And Poco de la posible has the proof of work enthusiasm. Proof of stake. So yes. Ventize the proof of work existence. I see. I organize.
00:13:17.508 - 00:14:51.444, Speaker B: Ventahes the proof of work perozmas ventas the proof of stake. Ian Henry MUTOs and proof of stake. E bamosa kugrier says ventahans the Proof of Stake k existing and consensus Mechanism la primera SK el proof of Stake nostalgoridad ikes nivierzo skoridad esgoridas el cantidan de Dolores la carena escomo sin quinte uno PORCIENTO del control sovereign la red iquantos dores necessita partner esto st Quenta uno porciente de control. A proof of Stake of rese approximate antre cinco adiers Veses mass seguridan poor mismo coste una takante necessitaria andresinco avente Veses mass capital parare unattachento in ethereum. Proof of stake. Ethereum proof of work. Elos numeros secret inverter este articulo de vitalek donde les moistra e bueno cuando ablomos dije el proof of steak, of rese massegoridan pural mismo coste ikwando kondo dij coste de k de castamos Ablando el.
00:14:51.444 - 00:18:42.716, Speaker B: Coste s LOCE ike pagar par in Santavia Alos validators cake Valeris incentivial red ILO pagamos and messionones de ether comoblach reward e comProof of stake. Poemos Reyucier la messiones paracon segue una seguridad igual Omayer mayor proof of work it e convenos emissiones peremos del Quese CREA e Conesto de etherio esto de donde vino el meme de Otres monday money loca dondemos uno ferte denuendo Desmondo posilamente tenremos unmayor pracio del ether. Location unmayor coste paratakar la carena de professe. La Carenda ethereum verlo muifasimente aka ultrasound. Punto money estamos per cara. Transaction chaos. Cara transaction chaos per KL ape quince estasque mando ether echo ether estamos emetiento como issuance del murge estamos imprimento cinco punto cinco migiones etherones de ether carano e tenemosun inflacion de dos punto trace PORCIENTO caranio e despoist del merge despite proof of stake perevercal burn nova cambriar per issuance ciendo bawahar pormasomenos diaz vases menos ibamos de IFRA caraano locanosva de and flaccion negativo uno punto ocho portiento location disminuendo bueno otraventaja de professe SK nosta mass de santrezacion mahinamos una hemplo como convertierse and unminero independiente and proof of work necessitas k inverter mijones de Doris And la creacion de supropia granha minera supropia mining farm Paracer to propio to independiente minero o puerto menos pero estaras andrando enun pool enun mining pool esto estacontrobugiendo alessandrasacion del red o inverter menos pero peronois rentale is he invertes menos novaser rentale otra hemplo and proof of stake.
00:18:42.716 - 00:20:17.888, Speaker B: Como convertierse invalid and proof of stake. Puerto Ningun hardware especial puerto Nusar UN raspberry pi portray Cientos Dodres o la composidora TNN connors or mismo solo Nasacita. Los Trentaidos ether locomar de amigos ointra cambios exchanges olokesea e los Trentidos ether question como tin quinta cinco meal Dodres loco paragunos e pero lavaresque no esmucco comparao CONOS migones CAS necessario para seropio granja minero tupropio mining pool, mining farm and proof of work e ctns menos de los Trentos ether in proof of stake, puerto Staking pools desantrizas como rocket pool Otres QuestAn crendo Esono mining pools DeSantis no railment existing and proof of work e bueno porque convert validator. Is mass ssclay Paramas personas significant. Okay. Bueno otra ventaha de proof of stake. Esque nosvadar mass reese estente alas and sora hemplo sialgobier no quierre ubicara los grandes mineros de proof of work.
00:20:17.888 - 00:24:17.292, Speaker B: Es fasci solo ake Prague electrica parubicar los los castanosando mucco in Arjia de mapeo cadecalor como say as marijuana localizar ungran validator de proof of stake. No estan fasci el bajo USO de la INARIA anseke los validators miles mining rigs e usaran una Doradora paradest icon de los destrogion. See Cpres aldera CPR possibility estos aquipostaking itor to vieiran las Javes keys to validator puerto rian validator and oto lugar bueno ultra ventana the proof of stake SK esmas amale conal medio ambiente bueno existing algunos aja and las camoridares the proof of work. La proof of work in Santiva la inarjia verde per lavarez can no SSE proof of work in Santiva la inarjia barranta e and algonos casos c la enarjia verde es la MAS barata pero emotos casas casos la enarjia MAS barata no as la verde e bueno I porque proof of stake as Masame amabeli cona Miente mahinamos locke real mente is Solo proof of proof of work. Real mente a solo proof of stake compassos adesianales con extra steps e m proof of workiona and Lugarde as her stake contu capital nasicitas tildizarlo parkemar in aria I reserve demonstrate improve a stake solo de moistres CA erres Dueno del capital por staking porponerlo temperamente and el steak marlon, Notina parquemar and Arjia nara entonces con proof of stake Puerto marijaro the ethereum con menos the diaz vatios proof of stake, says Barakay. Ethereum reduce messiones the Nrja. And novente nueva punto novente cinco PORCIENTO estamosinas okay.
00:24:17.292 - 00:26:16.628, Speaker B: La ultima ventaha. The proof of stake esto nosvadara hakathan escoja mayor pero real mente parata car sequential de bitcoin ethereum questa Andre Diaz avente mil migones de Dodres EC SOS. Mucho portu ajo so es mucco dinero inovamasatakar ethereum or bitcoin aura. Pero porlos estals no real el Presupuesto de defense and dos mildia. Siento quarante, says Mil. Migones de Dodres. Per unanio el presupues de los ESTAS NIOS and dos mil vente uno era cinco meal migones de Dodres econ la pose of work.
00:26:16.628 - 00:28:42.940, Speaker B: Los attackes son mucho mass facilities de recuperar and proof of work. El capital ESTA fuera del cystema entialian estatacando no sepuer k mineros estanatacando no savage don de estanos mineros kestan atacondo in no sepuer and pararlos miandratando and el proof of stake. El capital estaendro de CEMA as ether e sialion ESTA atacondo. El capital atacante as visible sacao ala fueza oborao perla intervencion de la camorida esto donde proof of stakehort proof of workup improve a stake c as possibly de recuperar e akiviana unhackathon project idea. Bueno el idea mazomenosva como taka desente r necitamos primero identification parakeel lahente normales comosta is a Joe Nesitamos como dashboards o hermientos dies and quesia red de bajo denitake aura puerto los estan atacondo como kianastan los validators lahente o losatos kestanatacandolo. Bueno nos, nosvaidar acer una intervencion de la camridar recuperar is alvar el red de ethereum e los dashboards real mente nodes de crayar los los data's existing and already hackathon project Idea. Itanemos del EF de la fundas in the ethereum merge testing al merge etoro e el pere sitin and Preguntas medicine o ladies and projecto car e nos.
00:28:42.940 - 00:32:42.288, Speaker B: I don't know if that translation was right, but common misconceptions boya cupir. Okay, Kiesta bueno el misconception numero uno SK proof of stake as unsistema de lo ricos say asin ma ricos proof of work no, los lavarezque is incorrect, requiring quitanto proof of stake comma proof of work some proevas de capital toron pieza concapital tanto proof of stake comma proof of work don unpercentahe de rotorno de la inversion. Proof of stake L-R-O-I-S constante sibas inverter cincomial dors and apuestas and Abdenair el mismo percentage e invertes Cinquenta migones de dores I parquetoque proof of work TNA opportunity economo sivas inverter cinco sequenta migones de dores Paracer to propio grana mineria basa acero donde electricidar es tabarata les vanadar como desuantos de la traceda fresca I puerto menos in cooling e les vanadar desquentos proceedes como cinco mildores no les vanadar nada de ESOS beneficios. Anton says el proof of stake no TNA EconomA itini el mismo Arroy paratoros. In conclusion proof of work s don de Loris MAS ricos km proof of stake console numerodos proof of stake significant error estojeva algunas activos de proof of stakes on mass paracidos alas axiones perkella pienza eronomiente estavadorosco stakers de Cedan los cambios de protocolo mente los valedors no de Cedan cake cambios say producing and a protocol. Agamos and a protocolo no I gobierna de la Votacion de la monet NOI control plutocratico Sopre los cambios and a protocolo ethereum TNA ungobierna informal del mimotipo bitcoin la conclusion esque proof of stake no as soon gobierno de loricos noah comparable equity ELO stakers nos cambios del Protocolos asungovierno informal similar alo del bitcoin. How much time do I have? Wrap it up.
00:32:42.288 - 00:33:41.710, Speaker B: Wrap it up. Okay, bueno. Okay, bueno. Pogo del Stalo del del merge USA de la fucion del emerge. Bueno estamos amos estalo travando and I'll merge and proof of stake des del principio de protocolo and dosmil quince e perfin estamos superserca tenemos poisi lanzamosum beacon chain ace dosanos and octubri de dosmil vente emos e and Junio and Pesamos asianolo el merge the merge contestnet realis los keusan real mente lahante los de la camunidad. Ian Pesamas Con Robson and June Eigth and ocho de junio Sepolio. Julio exito Gerlai ASE una samana and Aldo esofue la ultimate testnet antes al main net.
00:33:41.710 - 00:34:32.400, Speaker B: Buenos Elmer. Mass importante crypto des the alonzo Miento de ethereum and dos mil quince IPOR primese de septi emre and menos cayun mace vienna el merge bamosa celebraraca. A lot of the independent VR on DM and Twitter. I aquison los los los los slides kieran fromastardre gracias. Porto isuerte controlos projectos inos Vemos say and algonos de los aventos masquera Latin America. Bueno gracias.
00:36:27.920 - 00:36:52.752, Speaker C: But first I'm steph. I'm a devrel engineer at Polygon. You can also find me on Twitter at oceans 404. But the O is a zero. It's kind of hard to read, but we're talking about evolving NFTs. I just wanted to throw this up because this is kind of my ETH global evolution. The first time I was on the main stage was virtually on Zoom and then in Amsterdam.
00:36:52.752 - 00:37:34.064, Speaker C: So it's pretty cool to be back in Mexico as a sponsor. Full circle. Okay, so let's talk about NFTs. And we'll just start with, like, fundamentals. So NFTs allow for the creation of non fungible tokens for tracking ownership of different things. So we've seen that as digital collectibles, like the Board eight yacht club collection, but we've also seen physical properties being sold as NFTs and then even assets with negative value, like loans. But this is just an ERC 721 token standard.
00:37:34.064 - 00:38:09.528, Speaker C: So you can see all the required functions and also events. If you create an NFT contract, you'll probably extend a contract like this, and you'll have to have all of these functions and events as part of your NFT. This is my PFP. It's a doodle. But what is really important about it is the token Uri. So the image, the name, the description, and all of the different attributes that describe this NFT. So you can see the face has a happy note, the hair is long and purple, the body is a white puffer.
00:38:09.528 - 00:39:10.640, Speaker C: And one of the things about NFTs historically is that if they're used for collectibles like my doodle, it's pretty important that these images and also the metadata are immutable so that they don't change, so that this stays a rare asset for different features that it has that the rest of the collection doesn't have. So with collectibles, it does make sense to have immutability. But can you think of any other use cases where maybe immutable assets aren't as fun or they just don't fit the problem statement? I thought of a few. So the first one is in gaming, if you have NFTs or assets that level up or change the way they look based on different things that happen in the game. Another thing I thought about was a COVID passport. So I have this really annoying piece of paper I have to carry around, and then every time I get a vaccine or a booster, somebody physically writes it into my passport, which is pretty ridiculous. I think that should be on chain.
00:39:10.640 - 00:39:43.944, Speaker C: So a digital passport is something that could be a cool, evolving NFT. Also, baseball cards. I'm from La. So I watch the Dodgers. Hopefully Cody Bellinger never leaves, but if he does, his baseball card team would change and this baseball card wouldn't be relevant anymore. And then this is just kind of a dig at Board Ape Yacht Club because static NFTs are boring. But how are we going to build this? So we're going to use Polygon POS in Table land just to give you a quick refresher on Polygon.
00:39:43.944 - 00:40:13.664, Speaker C: It's an ethereum scaling solution. It's great because transactions are really fast, they're low cost. We're also going carbon negative this year, which I'm really excited about. So nice and sustainable. And then Tableland, which you might have heard about, I don't think they're here, so I'll just talk about it. But Tableland lets us write SQL to create tables to store mutable NFT metadata that is governed by immutable rules. And the table land data exists on both Polygon and Mumbai.
00:40:13.664 - 00:40:40.440, Speaker C: So whichever network you choose to deploy on, you'll be able to do that. And so in this DAP that I created, I made two different tables. A main table and an attributes table. So the main table has ID, name, description and image. And then the Attributes table has all of the different trait types and values that you would see as part of an NFT. So this is an example of one that I made today. I called it tequila NFT.
00:40:40.440 - 00:41:16.344, Speaker C: My Spanish has been pretty bad this trip, but I can always say the word tequila. So that's what we went with for this demo. But just to go back to the doodle really quick, you can see that the attributes are the same way, where it's an array of different objects and each object has a trait type as well as a value. Cool. So I created some drink NFTs. I had five different images that we can update and you can see that the glass goes down, down. I actually sent these to some of my friends who are in this room.
00:41:16.344 - 00:41:43.520, Speaker C: Christina, you have one. Kartik and Jacob, I also sent you drinks because I thought you deserved them. But I'm going to modify your NFTs to drain your drinks and I'll show you how to do that, which is pretty rude in the real world. Don't drink your friend's drinks. But we'll do it today. So we're going to mutate the image URL and then we'll also mutate different attributes. Two call outs for this.
00:41:43.520 - 00:42:26.530, Speaker C: The first one is just that. The default for Table Land is that you can only mutate data if you are the contract owner. So if you've deployed it, you can mutate it, but you can override that behavior by adding something called a table land controller, which allows you to have the owner of the NFT mutate it if you were interested in that type of behavior. And then the other call out for this demo is we're going to be manually updating the NFT just like from the command line. But you could do this automatically with chain link keepers or a different solution like that. So let's get to the code. I created a GitHub repo for this.
00:42:26.530 - 00:43:09.230, Speaker C: It's just under my GitHub, oceans 404. It's called mutable NFTs table land and polygon. I'm pretty proud of the README, so take a look at that. If you wanted to duplicate this or do it in your own projects, it just has the two intros and then building instructions. In case you wanted to deploy this yourself, you would just create a env file, add three different API keys for our Mumbai Alchemy key, PolyScan, and then your private key, and then you just install. And you could run this smart contract to create your own contract. Where was I? Let me get into the code.
00:43:09.230 - 00:43:44.570, Speaker C: Okay, so the first thing that's pretty specific to my Tequila NFTs are that this custom metadata generation. I'm just setting it, it's a naive solution. I don't have trait randomness for these NFTs. I have three different tequila types and two different drink names and they're being randomly added as attributes, attribute values. These are just the starter values. I'll show you how to update these values since that's kind of the interesting part of this demo. But I just wanted to give you a sense of how we're creating the metadata first.
00:43:44.570 - 00:44:42.876, Speaker C: So the first thing I did was just deployed that smart contract and I'll show you the PolyScan of that. So this is the smart contract and then each of the Table land tables also has its own transaction and it's actually a little NFT, which is kind of cool. I didn't know that. But each of these main table and attributes table is minted as an NFT that you also own as the contract creator. So kind of fun. Okay, so let's get to updating the metadata. Like I said, I already deployed this, but we're going to run the update metadata function to change some of these values around.
00:44:42.876 - 00:45:23.290, Speaker C: So I created a big block. So you can probably update these on your own, but there's two different update lines that I was playing with today. The first one is changing the image. So the main table had that image property. So I'm going to change the image to an empty Tequila Cup where ID is zero. So just to prove that we're actually doing this, this is the NFT, it is full and we're going to change this image so that it's empty and it's an on chain transaction. Okay, so I have the image link here.
00:45:23.290 - 00:46:18.360, Speaker C: I am pinning it on IPFS and it's stored decentralized in storage. But I'm just going to change this so that it has this new image and then I'll save this file and then I'll run the script to update metadata. And we should see this image change on OpenSea. So just going into my terminal, I'll clear that out. So it's a little easier to see, but it's just an NPX hardhat run script, update metadata and you can see the network is Polygon Mumbai. So this is just doing a read of the different tables that we already have and it is updating that image and once it's updated, we'll see the transaction hash and be able to look at that on PolyScan. Cool.
00:46:18.360 - 00:47:30.220, Speaker C: So again, back in the code, we were just updating that main table with the new image where ID equals zero. And I really like Table Land because you can write SQL queries, which is just super user friendly in my opinion. So I'm just going to put in that hash transaction and you can see it was successful. And if you look at the input, you can actually see when you decode this happened on chain, so you can see that this image changed where ID is zero. And now if we go back to this NFT, I think we'll have to run a refresh on the metadata because OpenSea is a little slow, but in a minute we should see a completely new image that is an empty cup. Oh, not yet. All right, empty cup.
00:47:30.220 - 00:47:58.460, Speaker C: Okay, so that worked for nobody has ever cheered for an empty drink before. Okay, so that's how you would update an image. But you can also do this for the actual metadata properties. So right now the drink name is Margarita and the Tequila type is Eniejo. Somebody correct that? Yes. Okay, you look like you know your Tequilas. What is your favorite type of drink? We're going to change this metadata.
00:47:58.460 - 00:48:57.460, Speaker C: Tequila Sunrise. Okay, that's the orange juice one, right? No shade. Okay, so I'm going to change this value to a Tequila Sunrise. I commented out that line above just so that we have it for easier reference, but we're looking for trait type drink name and we're updating value to Tequila Sunrise where main ID is zero because it's that first ID. So I'm going to run update metadata one more time. We'll get a new transaction hash and hopefully we'll see a Tequila Sunrise. And I'm not super artistic, but if you were and you wanted to play with SVG data, you could do fun things with pixel art to actually make it look like the drinks.
00:48:57.460 - 00:49:51.840, Speaker C: Someday I'll get to that level of artistry. So we're just back in PolyScan looking for that new transaction. It was successful 23 seconds ago. Again, we'll decode that input data and we see Tequila Sunrise at ID zero. So let's refresh the metadata one more time and we have an empty Tequila Sunrise. All right, I'm just going to go back to my slides. Cool.
00:49:51.840 - 00:50:33.548, Speaker C: So, yeah, check out that repo. I hope it's relatively easy for you all to change values and stuff in case you wanted to create some mutable NFTs this weekend, but just wanted to go over the Polygon prizes one more time. We have four different prize categories for the following problem statements. So public Goods Refi, which is Regenerative, Finance, metaverse or Gaming, and then the best UX or User onboarding experience to your DAP. So really excited to see what you all create. We'll probably give away two to three prizes in each of these categories. And then here's some developer resources if you want to take a picture of that.
00:50:33.548 - 00:51:03.108, Speaker C: They're also all online, so you should be able to find everything. If you can't, come complain to me because that's bad user experience. Cool. And then this is our Polygon devs Twitter. A lot of my teammates aren't here this weekend, but they love to see what you're building. So tweet at them and use the hashtag on Polygon so that we can amplify your work. And then last but not least, Wagmeet.
00:51:03.108 - 00:51:24.960, Speaker C: I'm in the middle next to Jordy. This is an iconic photo because he is like the creator of DKE EVM, and I'm not worthy to be standing next to him, but fun photo. All right, thank you so much. Feel free to come up to me and ask any more questions or just chat, tell me what you're building. And yeah, have a great weekend.
00:58:18.890 - 00:58:59.302, Speaker D: Thank you for coming to the Walletnike Workshop. This workshop is just a quick introduction of how to use Wall Connect. I'm first going to do it in English, and then if there's any questions, I can also do it in Spanish. Again, just don't have that. So I'm going to start. So Wall Connect is basically a remote signing secure signing protocol. It allows for easy integration between Wallets and DApps by using a QR code.
00:58:59.302 - 00:59:57.596, Speaker D: Basically allows you to sign transactions from your wallet without your private keys ever leaving your wallet. The main integration point with Wallet Connect is with this QR code, and we provide this. We have a specific application or package, an NPM package that you can use to get started with Wallet Connect. This is the Web Three model, and basically it's just a single provider that you can see here in this image that gives you the ability to either use MetaMask, Wallet Connect ToRs coinbase. It basically allows you to use any web3 provider with just a single NPM package. So if you want to develop a DAP that is enabled with Wallow Connect, you would use this NPM package. Let's just go through it.
00:59:57.596 - 01:00:58.990, Speaker D: So this is the package that you need. If you already have a DAP, a website that is already set up, all you need to do is just to add this dependency for enabling the Web three model and then let's show you how you can get started with. So this is the easiest way to get started with a QR code pretty much by setting it up with this object. You can see that in the object we got web3 model and then we pass it an object parameter and we have the network mainnet and you need to get an infuria project ID. And just to repeat, this is just for version one of Wallconnect. I should have mentioned this earlier. Version one of Wallconnect is the current most stable version that we have right now and it's the one that you're likely going to have the easiest time with.
01:00:58.990 - 01:01:06.236, Speaker D: From our perspective. The bad things about version one is that you can only use for EVM.
01:01:06.268 - 01:01:07.730, Speaker E: Chains and.
01:01:10.840 - 01:01:21.030, Speaker D: I'll go over V two later. But this is just if you want to have a working DAP, we recommend that you use V One for now.
01:01:24.360 - 01:01:25.270, Speaker C: What else?
01:01:27.870 - 01:02:22.134, Speaker D: So once you have the web free model initiated, you can do the connect and this will allow the user once they click on the connect button, it will display this four options. And then you can just select on the wall connect option that will display to you a QR code that you can see like here. It will display a QR code that you can just scan with a wallet. So while developing a DAP with using this web3 model you will get returned this provider object. You get given this provider object. This is the traditional provider object that you might find in a lot of DApps that you use. And this provider object gives you basically some events that you need to subscribe to just to get an understanding of when the user changes a wallet or when the user changes a chain.
01:02:22.134 - 01:02:50.754, Speaker D: And it's important to follow the event types just to have an idea that what to expect. And so we recommend that you pay attention to the EIP 1119 event types and this is what the provider object will be following, the standard that's going to be following. So sometimes you want to quickly test.
01:02:50.792 - 01:02:51.858, Speaker E: With one wallet and then you want.
01:02:51.864 - 01:03:12.982, Speaker D: To disconnect it's like okay, I want to test it with another wallet. We recommend that you also clear the cache just to make sure that you have a complete clean session. Because sometimes when you reload the web browser, I mean the website, you're still going to have the previous account saved.
01:03:13.126 - 01:03:14.170, Speaker E: In the Web three model.
01:03:14.240 - 01:03:51.302, Speaker D: And so. It's because it has a browser cache for remembering the previous accounts that it interacted with. But for development purposes, it's better to disconnect and also clear the cache provider just to make it easier for you on your license. Don't have like a laggard accounts left over and that might interfere your development process during this hackathon. So this is the same package right at the bottom left, you can see all the different types of providers that you can use.
01:03:51.436 - 01:03:52.946, Speaker E: You have wallet connect you have coinbase.
01:03:52.978 - 01:04:00.986, Speaker D: Wallet the web3 object or like MetaMask. There's a big list there.
01:04:01.008 - 01:04:01.900, Speaker E: You can see.
01:04:05.070 - 01:05:07.680, Speaker D: If anyone wants to scan these docs, now is the time. There's more QR codes at the end. So yeah, so just to repeat, the easiest way to interact with Wallet Connect is to first use this package, this Web Three modal package that gives you this interface that you see on the left that has these several options. And with these options you can have a provider object that allows you to either send transactions and request information from the wallet. I recommend that you look at the doc so you can understand the full scope of features that this Web Three model package can give you for developing your DAP. Here's a very good example repo. It's basically a quick start for a DAP and it has the Web Three model enabled.
01:05:07.680 - 01:06:02.780, Speaker D: And yeah, this is like the easiest way for you to get started with Wallet Connect. Okay, so everything before here was for version one, and I want to be clear that for this hackathon, that version one is the easiest way to get something working for you. Now we have also a version two recently that we just released and we're trying to push it more because it's the direction we want to take the software, the our SDK. Right now the version two, Wallet Connect, doesn't have a web free model. So you would have to fork one of our existing example repositories that I'll show you later. And the only API that's supported is the sign API. So it's like you can sign for transactions and the wallet can respond.
01:06:02.780 - 01:06:12.484, Speaker D: Right now these are the wallets that support version two. So this is a good list in case you want to be testing them.
01:06:12.522 - 01:06:13.636, Speaker E: Just to have an idea because not.
01:06:13.658 - 01:06:42.050, Speaker D: All wallets currently support version two of Wallet Connect. We have a website, a react wallet that you can use for testing purposes. So if like, for example, if you find something that's not working for you, you can go to this react wallet walletconnect.com, and that should provide you a very simple browser based wallet that you can then use with Wall Connect version two.
01:06:42.420 - 01:06:43.936, Speaker E: And then on the right side you.
01:06:43.958 - 01:07:35.592, Speaker D: Have a react app that is using Welcomenect version two at this domain. React app react app welcome. So just to be clear, just to repeat what I said, these are some wallets that already have integrated Connect version two. And so it's not all of them, just a specific list. But if you find issues developing with these wallets that's on this list, we also have this react wallet that you can use for version two. Another important thing for version two is that we have a Project ID gateway that you need to use to set up your provider.
01:07:35.736 - 01:07:37.516, Speaker E: You'll see in the docs, if you.
01:07:37.538 - 01:08:09.850, Speaker D: Go to in the docs website wallet options of how to set up a version two wildconnect client. And it's important that you go to set up a Project ID. So you have to get a Project ID before anything else. For version two, this is different to how v one where we don't have a Project ID. On the other hand, version two, we do require a Project ID. And recently we just released this new feature with sign in with Ethereum just recently for our own website. So it's actually quite easy.
01:08:09.850 - 01:08:12.076, Speaker D: If you already have a version one.
01:08:12.098 - 01:08:13.228, Speaker E: Of Wallet Connect, you can scan the.
01:08:13.234 - 01:08:17.500, Speaker D: QR code and you can basically create an account and get a Project ID without email.
01:08:17.570 - 01:08:18.190, Speaker E: Just.
01:08:20.000 - 01:08:52.360, Speaker D: Ethereum matters. So please try it out. And we're quite excited about just this feature. Yeah, so on the first QR code, the V Two websites, this is the repository which has there's a lot of QR codes here. It's probably a bit too crowded for this. This has all the information you need to get started with version two. For v two, for version one two and also the whole repository, our whole organization.
01:08:52.360 - 01:09:19.310, Speaker D: Yeah. So that's what I have for now. Any questions I should answer or any curiosities? Go ahead. Yeah.
01:09:24.560 - 01:09:26.030, Speaker C: If I try to create.
01:09:35.260 - 01:10:29.950, Speaker D: Yeah, so just to repeat the question, the question is like, how do you do a request for a transaction the way you would do it. So both MetaMask and Wallowconnect would be providing will have this provider object. And if you look at our documentation for the web free model, should I have the QR code? My bad. Yeah, so if you look at the documentation for the Web Three model, you have some quick starts on how to request for transactions. And the nice thing about the Web Three model is that allows you to use both MetaMask and Wallet Connect at the same time. So it's a user choice so you can request a transaction. And there's examples on how to do this in the docs that are here.
01:10:29.950 - 01:11:37.750, Speaker D: Yeah, so just if you have like if you want to test different EVM chains, you have to pay attention to listen to the chain change ID event. So if you want to listen to, for example, Polygon Mumbai or some other EVM for version one of Wallet Connect, like some EVM chains, it's important to pay the wallet initiates that change request. So the wallet sends to the DAP, it's like, okay, I need to change the chain ID and then the DAP that is using this provider has to listen to these events when the chain changed. So this is just something important if you're using multiple chains for development purposes. The MetaMask mobile wallet is good. The rainbow wallet is also pretty good. There's a lot of wallets out there that use wildconnect and just use what's best for you.
01:11:37.750 - 01:11:45.404, Speaker D: Yeah. Any more questions and I could try.
01:11:45.442 - 01:11:46.584, Speaker E: To do this again in Spanish.
01:11:46.632 - 01:11:52.140, Speaker D: It's not going to be as good. You got to try in Spanish. Okay.
01:11:52.210 - 01:11:52.990, Speaker A: Why not?
01:11:54.800 - 01:12:34.300, Speaker E: Espanol say but para vistas welcome protocol interaction and thread apps cryptomonias basic promos connection encrypta para transmitted mensahes entrepreneur are the crypto monasquerma principal.
01:12:36.960 - 01:12:37.900, Speaker D: QR.
01:12:39.680 - 01:12:42.952, Speaker E: Connecto despite.
01:12:43.016 - 01:12:45.820, Speaker D: And losientes slides boya and senor.
01:13:14.000 - 01:13:14.750, Speaker A: A.
01:13:15.760 - 01:15:00.300, Speaker E: Tamiyan Pamos bellas de la version lance La version dosiononi lavarcion dos pero de caust bana Hakia ESTA Vasila la forma maspasi paruste tenure app Capunciona Parisa Hackathon per KC US and Siwano Sala connect Bana Banatan mass Prolemas implement software nestle Momentum. See Karen acer algo chiva bonito connect more comoporhemplo multicarenas integracinos ALAMINTA has ketmos convertosi casio dos carinas okay, don says para a Paratone accused ESPO ember application. The NTM can also trust me los connection web3 providers the permit MetaMask wallet connect taurus coinbase much as obsionas.
01:15:01.760 - 01:15:02.510, Speaker F: Quest.
01:15:07.280 - 01:16:23.860, Speaker E: Basiometes comonali radiates permit differentes Prioris firmas cryptographicas it akias commonosotros initiamos eloheto parabasigmente configuralo as importante paralla the wall of 19 balances it the crypto monastian auditor says on EVM compatible.
01:16:27.880 - 01:16:28.630, Speaker D: Okay.
01:16:30.120 - 01:17:27.260, Speaker E: Web three model initial poemos a crown pro este prior mass frequentimente transactionasiones cambio de carinas tonsis el provider elohepto provider masvan territory connect an estimate estafuncion. Web three puntomoro connect as a laca Parese uno permit Lucido selection or MetaMask or walloconnect.
01:17:31.600 - 01:17:32.540, Speaker D: Provider.
01:17:36.080 - 01:18:45.520, Speaker E: Selection of metamasknet levapara de moi lasquentas Cambian sila carina cambio is the EIP 1193 standard paratrona una buena de los tipo eventos standard tamiyan Mentras castrojandos connectors quandostasis connected tamiyen.
01:18:48.340 - 01:18:49.100, Speaker A: Borin.
01:18:49.180 - 01:19:17.980, Speaker E: La memorial del del browser. Web three model montana una quinta Cartera del mol del model paracino interferacola miracle disconnect is PACIF clear cash providers.
01:19:25.200 - 01:19:25.564, Speaker D: I.
01:19:25.602 - 01:19:31.540, Speaker E: Keep in laskin periodic alisa de los tallest providers.
01:19:32.280 - 01:19:38.420, Speaker D: Web three model essos providers.
01:19:43.160 - 01:19:56.140, Speaker E: Quatros optionis baloch nectaros coinbase election parasavercomunt isari KOMO transactionists.
01:20:05.120 - 01:20:06.060, Speaker D: Ethereum.
01:20:19.560 - 01:21:20.036, Speaker E: Tamian tenemos Estef repository of the hemplo sakoligo de hemplo basic esclonarlo e repository instructions in lomosajuar initiates the estate repository of citrine prolemas. Estopinalisa lavarcino. Sisters estamostrohanda lava. Brand taminoscomos formasal laurcion dos the wall.
01:21:20.058 - 01:21:20.820, Speaker A: Of NECT.
01:21:22.760 - 01:22:51.780, Speaker E: Algonas de la escatino. Laurcion dos the wall of connect multi chain to the basic barris carinas alamin taminamosolo una WebSocket paratolo stema estopermitic console una connection. Altrivior connection is from various DApps taminoscomo UN systema de permissos permit control per CLE permit la Cartera electronic atomis. Permissions unalista de tolas Carteras mobile esparake merlo banner siwana version dose version dos. See ninguna application elsconciona taminamos una Cartera justafuncina version. See SS Cartera mobile.
01:22:53.640 - 01:22:54.580, Speaker D: Browser.
01:22:57.000 - 01:23:00.020, Speaker E: Basic dos dominions demos react.
01:23:03.400 - 01:23:05.568, Speaker D: React wallet punto wallet.
01:23:05.584 - 01:23:28.416, Speaker E: Connect punt react app punto wallet connect puntukomosunap la cartera yala an application. The version dosa has the opirumas, the Cosmos pyramids. I have the polygon poispy mensah has.
01:23:28.438 - 01:23:29.280, Speaker D: The ethereum.
01:23:31.140 - 01:23:33.148, Speaker E: The polka dot amin polka.
01:23:33.164 - 01:23:33.760, Speaker A: Dot.
01:23:36.660 - 01:24:23.550, Speaker E: Algimate coupon project ID paracel los de la version dos de wconnectio KES cloud punto wall connect punto para porinic una sacion. Congratulations a unfeatured crown utrizando la version solomon ethereum capacity and.
01:24:25.280 - 01:24:26.030, Speaker D: Okay.
01:24:29.000 - 01:25:11.180, Speaker E: Alisquerda tianan las SSL repository la cartera and el lagor del DAPAs multicarenas and el centro Tienn el repository of larciono quickstart. Simply para Asian application simply e where I organization dos.
01:25:12.800 - 01:25:13.596, Speaker D: Okay.
01:25:13.778 - 01:25:41.420, Speaker E: Preguntas Alante. It see taminra and polygon la cartera lake the cualcarinasion polygon SS polygon Mumbai, laplicacion but telosepta port EVM compatible.
01:25:43.360 - 01:25:46.390, Speaker A: EVM. It.
01:25:50.680 - 01:25:51.430, Speaker D: See.
01:25:54.040 - 01:26:12.490, Speaker E: Lavarcino puerto polygon Alante, ESTA lavarcino esther. Esther. La Prague siesta repository ESTA connect.
01:30:43.330 - 01:31:20.250, Speaker G: Yeah, we are here to talk about why crypto is really, really awesome. Before of that, though, I would love to throw a shoe of hands. Who here understands Spanish? Because we may be able to think in Spanish if everyone understands it otherwise, no. So if you understand Spanish, put your hand up. I think we're going to fall back to English still, but thank you for that. If you have any questions about that, you can come ask us in Spanish afterwards. But yeah, we are World Coin and we are here to talk about why crypto is really, really awesome.
01:31:20.250 - 01:31:36.874, Speaker G: That did not switch there. That seems wrong. There we go. Okay, so crypto is really, really awesome. I don't think I have to explain it. I feel like everyone agrees why crypto is really good. It has unlimited distribution, it's decentralized, all of these really cool things.
01:31:36.874 - 01:32:27.770, Speaker G: The issue though is that while it is really, really cool, it has a big hoarding problem where the people that got to it first got most of it and now the new people getting in had less advantage. It's like less inclusive. You have to be early, basically. And at Wallcoin, we had this idea of what if Bitcoin has started by giving each person in the world one Bitcoin? How would the network effects play out? How would accessibility to this technology improve the world? And so Bitcoin is unfortunately really expensive. So we cannot just buy 8 billion Bitcoins and give it to everyone. But we thought, let's do it with a different currency, let's do it with a wallcoin. And pretty quickly we got into a big problem, which is if we're going to give something that is valuable for free to everyone, people are going to try to game it, they are going to try to claim multiple pieces.
01:32:27.770 - 01:33:09.302, Speaker G: And so how do we make sure that each person only claims their part once? And there's this thing called civil attacks. It's pretty common, especially in airdrops from the company, which is from different projects, which is when someone just creates multiple wallets and pretends to be multiple people, maybe they are doing some activity to seem active and then just give them the money and they sell it. So that's not really good for the project. That's not really good for pretty much anyone except for those people. And that is called a civil attack. And we wanted something called civil resistance. We wanted to be able to tell people online and we wanted specifically something that was both private, inclusive and scalable.
01:33:09.302 - 01:33:52.998, Speaker G: Something that the whole world could be onboarded into. Something that didn't require you to give out your personal information and something that didn't really differentiate from early or late that anyone really could sign up to something universal. And so we started looking into the options. Asking for email or phone serves as a way of identity, but it's like I personally have more than ten emails, so it's not super civil resistant. Then maybe you could ask for a passport or an ID. But aside from some people in some place of the world not really having IDs, this has a big problem with the privacy part because then we need to store your info. Then we looked into something called Web of Trust, which is when people authenticate other people.
01:33:52.998 - 01:34:22.142, Speaker G: And the issue there, aside from a bunch of mathematical stuff, is that you need an initial web of trust source. So you need an initial set of users that you trust and then people that are super separated from those people. Maybe someone here in LATAM. If this gets started in SF, it will be much harder for them to get authenticated as humans. So it's not super scalable. And then we looked into biometrics, which is something that everyone has. It's relatively easy to sign up and we say, okay, maybe this will work.
01:34:22.142 - 01:34:48.274, Speaker G: And so there are multiple biometrics that we could use. The most important measure here was what we call entropy. Whatever we use has to have enough information so that we can tell 8 billion humans apart. An example of this is the fingerprint. Fingerprints are not different enough so that you could tell 8 billion humans apart yes, from the fingerprint. And also if you make a little cut on your fingerprint now, it's a completely new one. So it is also super simpler systems.
01:34:48.274 - 01:35:13.534, Speaker G: We have the Face, but the Face kind of has the same problem. Face ID from the iPhone can tell you apart from around like 30 million people. Obviously it locks after ten attempts, but if 30 million people try to unlock it, one of them could. So it's also not super scalable for us. We have the Palm, which has the same issue with the fingertip, where you can just make a little cut or have someone finger in the middle. And that's, again, a unique one. You have DNA, which could make me work.
01:35:13.534 - 01:35:59.530, Speaker G: But aside from being even more creepy than scanning your eye, it's also pretty expensive to process and takes time, and it's a mess. So we got to the Iris, which stays constant after you have grown up. And it's unique, it's easy to verify and it's really, really hard to change. And so we started looking, what can we use for these services? Maybe we can use our phone cameras. Turns out you need a really, really high resolution for these things and the phone cameras are unfortunately not enough. Same thing for off the shelf devices, devices that are built for this, like whatever clear uses or all of these other sources, these also have the issue of they're usually made to verify, not identify. So what that means is you will put in your ID and it will say, okay, let's make sure that this is Miguel.
01:35:59.530 - 01:36:19.974, Speaker G: I'm going to check their iris with the iris that we have stored for Miguel. What we want to do is make sure that my iris is not in a list of 8 billion iris. And so those tools are not built for that. And they were like, okay, maybe we have to build custom hardware. And that is not great. No one wants to build custom hardware. It's a really, really hard problem.
01:36:19.974 - 01:37:14.434, Speaker G: But after a while we ended up building this thing, the Arm. This one is the special Mexican edition, which basically takes care of making sure that you're real, making sure that you're not trying to trick it by scanning a dead body or a pet or just like showing a picture of an eye to it. And then it will look at your iris and it will compute what we call an iris code, which is then used to register you without actually having to save the photo of your iris because again, privacy is really important. And so we have a solution. Is this thing one slide? Kind of have the feeling that every time that I press the button, it's just like one slide below. Anyways, we can work with that. I'm just like, sorry for the context before, but basically we have a solution that doesn't require images or your name or contact info in any ways or tracing a KYC.
01:37:14.434 - 01:38:04.454, Speaker G: We just have this iris code that is computed from your iris. But that's not really enough. We wanted something more because even with the system, if we just said, okay, this wallet is verified, then you can kind of track your wallet across different users of the protocol and figure out who they are. And so we looked into using CNR's proofs now it jumped to anyways, we looked into using CNS proofs in order to fix this and we ended up with a system that is pretty complex, jumping around. Anyways, we ended up for a system which is like pretty complex, but it works really well. It preserves your privacy. It's fully private, even maybe anonymous, where you can just get scanned, you get added to the list and then you can anonymously verify that you are on the list without revealing which entry of the list you are.
01:38:04.454 - 01:39:09.646, Speaker G: So this was great. We said, let's go outside, let's trade out. We went all around the world to more than oh, it's just like delayed a few seconds, okay, to more than 25 countries. And we tried it pretty much anywhere that we can think of. We onboarded more than 650,000 people change a little bit since the Cmax because we keep growing and it is fully open source as well. You can check the code for the open source protocol and we're going to continue open source in the hardware of the orb and everything else. But there was one thing that kept coming up since everyone was saying you built this whole system to give out your coin, to give out Wallcoin to everyone, isn't it a shame that you're only going to use it once and then throw it away? And there's a bunch of other apps that could also use this civil resistance that you're building and something that is as scalable as this.
01:39:09.646 - 01:39:11.680, Speaker G: Why can we not reuse it?
01:39:15.110 - 01:39:16.546, Speaker E: We want to rebuild that.
01:39:16.648 - 01:40:05.778, Speaker G: And we build a protocol called Wall ID, which allows you to reuse the same security and verification that we have created ourselves to do all of these things. And so Wall ID is a protocol to anonymously verify that first of all, someone is a real person, but also they've never done something before like claiming warcoin or voting a governance proposal. And it does this completely anonymously. It will not reveal any information. So, for example, I can prove I'm a real human, and I have never claimed Wallcoin, or I have never voted in a poll, or mint the NFT, or within this AirDrop, or even completely web to things like join the discord or follow someone on Twitter. And the system that enables all of this is really, really complex, specifically because you want to maintain privacy. But the really good news is that you don't need to really care about any of these things.
01:40:05.778 - 01:40:58.418, Speaker G: Integrating this whole thing into your app basically takes this code, you put this in, it will show a captcha like Widget, which is there, that captcha. And so users can just click that, scan the QR that shows up with their Wallcoin app, actually using Wallet, connect with the saw before, and then you just verify that either through an API or on chain with our contracts. And there you go, you have zero. So for example, if you have this example AirDrop app, you literally just have to add a Wall ID in there and there you go. It will pop up in the app as this application wants to verify your human. You click Verify and you get the whole thing that you can then verify anywhere. So it's really, really easy.
01:40:58.418 - 01:41:21.242, Speaker G: And it's really, really powerful too. It's super flexible. We've been talking for ages about all of the really cool things that having simple assistance could enable. And now we have simple assistance, so we can start playing with all of these forms of quadratic voting and funding. We can do errors, we can do social incentives, all of these really cool things. And also you can use it, obviously. Right now.
01:41:21.242 - 01:41:50.606, Speaker G: We have Developers Worldcoin.org. We also have Slash Mexico, which has all of the resources that you guys will need. And just like to show again how easy this is, paolo here is going to actually add wall ID to an app from scratch. So we're going to take an app to Mintapo app, and we're going to show you how you would make that sibling system. It's a really simple app. It doesn't even use on chain. It makes use of the API.
01:41:50.606 - 01:42:42.290, Speaker G: But I feel like it's a really good example of how easy it is in literally five minutes to make sure that your users can only make an action once or register or any of these things while that's loading. I'll share a bunch of examples of what we've been using this for. One of the things that we've been doing is we have a discord bot where discord has this really big spam problem. Traditionally, even though they have CAPTCHAs for signing up, because someone can just complete the captcha multiple times and then just join with multiple accounts and start DMing and spamming people. And so we made this bot that allows you to verify wall ID once you join the discord. And then it will make sure that you can only have access to the channels that you want to your users chat to if you've been verified once. So that makes sure that only one account per this one account on your server will be a human.
01:42:42.290 - 01:42:56.310, Speaker G: And also, if you ban someone, they're gone forever. They cannot come back. So I feel like it fits really well the ideas we traditionally have of one user equal to one human. Now Paolo is going to demo how you would set up from scratch.
01:43:03.070 - 01:43:03.882, Speaker B: All right.
01:43:04.016 - 01:43:34.046, Speaker H: Thanks, Miguel. I'm going to do a live coding session, show you how easy it is to integrate World ID. This is a demo, so hopefully something will go wrong. But let's get started. So, easiest way to get started with World ID is going into our developer portal. Our developer portal will walk you through all the ways that you can integrate World ID. And basically, we have two ways you can integrate on chain, or you can integrate with our API under the hood.
01:43:34.046 - 01:44:11.470, Speaker H: The API is doing the same thing. It's calling our smart contract to verify everything on chain. We just abstract that complexity for you if you just want to do something off chain. So, as Miguel mentioned, what I'm going to do is show you an example of claiming Poaps. But you can only claim once verifying that you're a unique person claiming a POAP. So we have this very simple website where I can claim a POAP, but anyone can come in and just get all the Poaps for themselves. So what we're going to do is we're going to create an action in our developer portal.
01:44:11.470 - 01:45:07.104, Speaker H: Should be very simple. This is the important part where you select if you want to run this on what we call cloud, which uses our API, or if you want to run it on chain. We're going to do cloud for this example and create an action here. So it's going to give you all the instructions of what you need to do, which we're going to skip for now because I'm going to do it. And the only extra thing that you need to configure is how you want to display the verification in the world Coin app. So you can say something like claim my PO app once and you'll get here something called an action ID. The action ID is what scopes the verification for the user.
01:45:07.104 - 01:45:39.880, Speaker H: So when you get a verification from world ID, you'll get three things. One is the zero knowledge proof that verifies that you're a unique human. Two is the merkel root, which AIDS with that verification. And number three, it's a nullifier hash. That hash is quite important because that is the unique Identifier for that person for your app. So you can use that as a unique user Identifier. But the cool thing is it will not track users across apps.
01:45:39.880 - 01:46:38.014, Speaker H: So I'm going to take this here and then we're going to start with the development. So I'm going to set this action ID. Now I'm going to install here the WorldCoin SDK. Sorry, I think I need my glasses. Looks like internet is not helping us out here. There we go. So I just need to very important if you're using next, the JavaScript widget uses a dependency that requires Windows.
01:46:38.014 - 01:47:23.258, Speaker H: So you're going to have to do a dynamic import. Should be quite simple. So you import the widget. We're going to say that this takes widget props and I have the widget. So I'm going to insert the widget here. The signal is a string that you need to pass. It's part of the zero knowledge proof verification.
01:47:23.258 - 01:48:12.330, Speaker H: It's an important security measure depending on what your app is. In this case, it's not necessary. So I'm just going to add an arbitrary string. I'm going to mount the action ID and then we're going to say on success, set proof, which we're going to create here. All right. And then we're going to say like, don't let the person claim the POAP unless the proof is set. And we're going to run this.
01:48:12.330 - 01:49:18.850, Speaker H: Now I have the widget here. Now I need to verify the proof. So I'm going to go to my handle claim process and then we're going to do call our API here. Where we send the signal is my pop and then the proof. And then if the response is successful, we're going to redirect the user to the claim URL. And if it's not, we're just going to console error and then set error. Error claiming.
01:49:18.850 - 01:50:02.080, Speaker H: There we go. And this is our API request. So the cool thing is, if you're using our API in the developer portal, you just need to call our API to verify the response. So it will look something like this. There we go. And then we'll just send rec body. And then again, if verification response is successful, we'll send the pop URL.
01:50:02.080 - 01:50:26.226, Speaker H: If it's not, we'll just send an error. And I think we should be fine here. We're missing and I wait. All right, so let's try this out. So I'm going to verify I'm only claiming my pop once I have my World Coin app here, which you should.
01:50:26.248 - 01:50:27.554, Speaker G: Be able to see.
01:50:27.752 - 01:50:51.930, Speaker H: So the user flow is the user clicks on the captcha. Then on your WorldCoin app, after you've verified an orb, you have your role ID. You scan the QR code. We connect through wallet connect, which is like a pretty cool thing you get. Here the prompt you can see here. This is what we configure. Claim my pop once you can add whatever text that you want and you can do the verification.
01:50:51.930 - 01:51:56.194, Speaker H: Once the verification is done, I can actually go and claim my pop. Looks like there was an error. Thank you. I missed a little thing here. Let's try this again. And I can actually go and claim my pop. And the cool thing is, if I go back and I ask the same person using the same World ID, try to do this again, I'll get an error saying that I previously verified this.
01:51:56.194 - 01:52:24.138, Speaker H: So it's quite easy to integrate. If you want to go the smart contract route, you should just go to our starter kit, it's Worldcoinworldidstarter. We have a very simple smart contract that will let you do this. Verification on chain. As you can see, the critical code is just calling our smart contract to verify the proof. And if it's valid, you just execute your action. If it's not valid, it'll just revert.
01:52:24.138 - 01:52:34.080, Speaker H: So, should be quite simple. If you guys have any questions, we'll be around and we're happy to answer. English or Spanish and yeah, thank you so much.
01:52:36.530 - 01:52:37.280, Speaker B: What.
01:52:40.710 - 01:53:30.248, Speaker G: We can go, we can do. Yeah. And also we have 20K in prices. We have three main prices. We have two honorable prices, and then we have a poll for everyone. And we also have we have this URL that you can go to, which I mentioned before, wallcoin.org, Mexico, that has all of the information about the prices, starter resources, the documentation, the developer portal, everything that we mentioned here and everything that you will ever need.
01:53:30.248 - 01:53:52.428, Speaker G: It's on that page again. It's Walcoin. Orgmexico. And as I was saying before, we have 20K in prices, which is for best use of the protocol. We have five K, three K, and two K for the three best uses. We also have two one K prices for honorable mentions.
01:53:52.444 - 01:53:52.528, Speaker F: That.
01:53:52.534 - 01:54:06.340, Speaker G: Didn't make the topra. Still really cool. And then we have eight K distributed amongst everyone else. That qualifies. And yeah, really really excited to see what you build. Like we said, we'll be on the booth most of the day. We're also in the discord.
01:54:06.340 - 01:54:11.560, Speaker G: Anything that you need, we're willing to help in English or Spanish and good luck.
02:03:46.180 - 02:04:08.052, Speaker A: Nice. This feels cool. I mean, like I flew in from Europe yesterday and for me my body is probably kind of giving that talk at an after hour at 06:00 a.m. In the morning. But let's do this. Eat, sleep, hack, repeat. Yeah, what I will do is kind of a quick start to subgraph development and also querying.
02:04:08.052 - 02:04:44.916, Speaker A: I mean the problem with a lot of Devs when we talk with them about the Graph is like they are a little bit afraid about the technology because the graph is such a powerful thing. But it seems like at the first sight overwhelming. Like how get I into it and how can I use it and what exactly does it I think it's cool. Everybody uses it, but I don't know how. So I want to kind of reduce that fear and give you kind of a quick intro. So let's have a quick repetition about what is actually a smart contract. So I think about the smart contract actually in the thing that it is just data.
02:04:44.916 - 02:05:28.150, Speaker A: So it's structured data that lives on the blockchain, it's immutable or kind of actually mutable and then you have rules how to change that data. That's a smart contract basically. And the smart contract by itself, it always knows about its current state, who owns which NFT right now. But it does not really know about historical state but the blockchain knows but the smart contract by itself knows only about the current state. So let's look at that example. So if you look at the standard NFT smart contract, this is the data like you have just a list with token IDs owners and then some random metadata Uris. If you're lucky then they're not on Google cloud.
02:05:28.150 - 02:06:39.400, Speaker A: That's the state. You can always create a smart contract who owns which token, but what you don't know by just looking at the state of the smart contract who owned it before. So that's problem especially for NFTs like there's this big word about the provenance but it's also other stuff that's interesting when we want to look into the past, like for example on uniswap, how did the prices of a pair kind of develop or how did the TVL of a certain protocol change over time? Very interesting data but you need to look into the past of smart contract state, right? So it would be nice to have kind of something like a time machine, right, that you can just kind of go back in time and see how was the state of that smart contract yesterday or like before yesterday, a week ago? And so on and so forth. So that's one way how you could look at what the graph is. It kind of gives you this possibility for this time machine. But not only that, or kind of to understand it a little bit better. First I said the smart contracts are basically data and rules how to change the data.
02:06:39.400 - 02:07:44.768, Speaker A: And if you want to change the data, what you do is you send a transaction to the blockchain so that data actually gets changed, right? And that's what we look at with the graph. We look at the transactions. Another angle on the whole thing is when you start to develop depth. So initially, kind of in the early days of Ethereum, there was this idea of having the user interface, just HTML, CSS and JavaScript deployed somewhere on a decentralized storage, censorship, resistance and so on. Then you run your own blockchain on your computer, right? And then you download that front end on your computer and start to run and start to interact directly. But yeah, there was a problem because the blockchain by itself is write optimized and the JSON RPC interface that you use to interact with your Node is also kind of for writing data. Mostly the reading stuff is a little bit kind of afterthought, but like the modern front ends that we see today, usually you read data, right? You want to see kind of how did the token price develop, who traded which and what's going on.
02:07:44.768 - 02:08:51.888, Speaker A: And there was not really a thing. That's also why a lot of centralized companies jump in to fill the gap, to kind of provide that data somehow in an efficient way. But we want to be decentralized, right? So in the wild we see code like this. This was actually one of the projects that I worked with, kind of looking at the code and for those that understand JavaScript, you see like all these await statements. Those are then kind of the loop through an arbitrary big number of balances and all these await statements. They get 200, 300, 400 milliseconds to resolve. And if you have like ten NFDS or 20 NFTs here and all of those are awaited and then in the end kind of this simple page that just shows you how your NFTs take seconds to load, which is a super bad experience, right? How should it be? Like you should have a user interface on top that actually writes to the blockchain and that you have kind of this indexing query protocol in the middle that gives you this data efficiently.
02:08:51.888 - 02:09:16.540, Speaker A: So in the end you can write queries that look like this, right? Kind of very nice. And I love GraphQL because it's such a nice language. So this does actually the same. And like to send this query, it's kind of a matter of milliseconds. This is actually where the graph comes in. It's kind of these APIs for this vibrant, decentralized future. Like on the hosted service.
02:09:16.540 - 02:10:04.540, Speaker A: Currently we have roughly 1 billion billion queries per day. Big names like Audios, Uniswap, Mstable enzyme used the graph, it's well used. And now there's also kind of this decentralized indexing network protocol launched one year ago. So you were not only able to kind of use the centralized hosted service which was a proof of concept, but you can really have decentralized subgraphs and data. So there is kind of this network with 170 indexers that are kind of individuals. There's this redundancy across the world, it's fast ship, reliable and we're going towards this global open API. So in the end you can build truly decentralized.
02:10:04.540 - 02:10:48.484, Speaker A: But again to get back to what we can do here is there are two bounties from the graph and I'll show you how to get those. Now there's the best use of an existing subgraph which is a little bit easier. So we have a winner and a runner up. So the winner gets two k and the runner up 500 and then the best new subgraph which is more heavy but also more cool to do is the same. So it's kind of a little bit of strategy. So what do you want to do? Do you want to do the easy stuff but you have more competition? Or do you want to do the hard stuff but it takes you more time, but that's up to you, but we're happy to help. Bonus points for the charging is if you go with the new technologies like substream.
02:10:48.484 - 02:11:32.810, Speaker A: I do not talk about this in that talk but you can read it online or you use the decentralized graph network. Right, so how do we do it? Yeah, a subgraph explained again is kind of this thing where you write kind of a data structure. It's actually a database for those who know about databases. And then you have instruction set, so you look at the blockchain, what's going on there, and then you start to write in the database. So you have it easily retrievable later on. So you can think about the transactions on the blockchain are kind of a mess, everything is kind of on the same thing. What you want to do is you want to kind of have databases per protocol so you can easily query it and make sense out of it.
02:11:32.810 - 02:12:27.130, Speaker A: So roughly then how it works on top you have the DAP as we said, you send transactional smart contract to change the state which will emit some events. The graph node kind of having the information from the subgraph will take those events, put it into a database so that on the other side you can then just query that database and have quickly your front end. So in the end like a subgraph is more or less what's going on here. You have this mess of different stuff and magically it kind of is organized in a way that you can reuse. Now you have learned about the graph so you can now scan that QR code and tell all the people that you learned about the graph. Marketing team told me to bring in the slide so you could do it or not. Three, you want to do it? Nice.
02:12:27.130 - 02:13:08.230, Speaker A: You got it. Cool, thanks. So NFT subgraph development like I always use NFTs as an example because you understand it's the super easy thing. So how does an NFT contract look like? You have a transfer event, which is the most important one actually. And then you have those functions, kind of balance of owner which are read functions and you have this transfer from which is a write function more or less. That's it. There is some other stuff around with allowances but in a nutshell that's kind of an NFT.
02:13:08.230 - 02:13:45.506, Speaker A: You just have some contract that emits that event and kind of provides those functions. It's very simple but that's also the beauty because you can build so much out of it. But it's also easy then to index. So I have some tips tricks here, but we skip through these because I want to show you also how we can query but the slides are online so it's more kind of a reference for you. So you can think about like what queries do I really want? Before you start to write a subgraph for NFTs. It's kind of how many NFTs are in total, who owns what, what's the provenance. You have kind of a rough schema how you would model that in a database.
02:13:45.506 - 02:14:31.494, Speaker A: So you have a contract which represents the collection. You have an account which are the owners, then you have the NFTs which are then linked to the account and also the contract. Then you can store all the events for later reference and store the metadata if you have it and trades also if you have it. That's roughly how I would model it. And then what you do is kind of you install dependencies, find the contract and then you start to initialize and then you just deploy it to the studio and then you enhance the subgraph and then deploy again and so on and so forth until you're ready and then you can publish. I also have kind of a collection of pattern in this presentation, but it's also probably better for looking into that later. But they are here.
02:14:31.494 - 02:15:40.682, Speaker A: It's kind of some stuff that you could do, but I would say let's just do it. Can I go into this terminal list or something? Okay, so I hope you have graph installed right on latest version. So what can we do? We can go to Etherscan and I know I could just go for a random NFT. Then you can just copy the contract out actually you can just do graph in it. What is it? Index events and this index events actually it's kind of the trick to make the initialization much much faster and we need to document this a little bit better. But now I tell you. And if you do this, then a visit starts and then they ask you, so, okay, which protocol do we want to index? The graph supports RV ethereum near Cosmos.
02:15:40.682 - 02:15:59.798, Speaker A: We are on ethereum here. So let's go with Ethereum then. In which product you want to initialize? There is the Subgraph Studio, which is the new one, where you can publish to the decentralized network. So we always go with the cool new stuff. Then we give it a slug. So let's name it hashmasks Subgraph. All right.
02:15:59.798 - 02:16:19.260, Speaker A: Directory to create in. Yeah, let's go with this Hashma Subgraph. Why not? Before we use the protocol now we kind of take the chain. So we go with Ethereum mainnet contract address. I already got it. So it's this one. You just go with the address.
02:16:19.260 - 02:16:58.396, Speaker A: Oh, shit. What did I do wrong? Can I just try again? All right.
02:16:58.578 - 02:16:58.924, Speaker F: Yeah.
02:16:58.962 - 02:17:43.770, Speaker A: The alternative is that you have the Abi, maybe for the hackers around you, especially when you start to write your contract, you can also just add the path to an Abi. But I think it would take too much time here to do this. But actually, I want to show you anyways. There is a much cooler possibility currently with new tools. So now we have the Soulbound Studio, which more or less does the same that I've just tried to do in the command line. But let's see, maybe this is a little bit more reliable. So actually how this works.
02:17:43.770 - 02:18:15.188, Speaker A: So you can go on this sole mounted XYZ. And then there is this Subgraph canvas. And here you have very nice UI, so we can give it a name. I don't know what's going on here. I don't want this. So we add a contract, and now I can paste in the address and what it does in the background kind of it starts to download Abi and also resolves the start block eventually. Nice.
02:18:15.188 - 02:18:46.212, Speaker A: And then that's it. And I can save the smart contract probably now in the Explorer. Nice. Okay, cool. So you see, I have the contract and you see, okay, the contract has these events. I have the approval events. I don't really care about the approval, actually.
02:18:46.212 - 02:19:05.560, Speaker A: I just want the hash must have a funny feature. So the names who have the name change event. So let's change this. The ownership is also kind of just internal and then the transfer. So you can easily go and say like, okay, I want to just index those events. And here they are, and it's all kind of prepared for you. And go back to edit Subgraph.
02:19:05.560 - 02:20:01.730, Speaker A: Maybe I need to there are box today. I'm not lucky with my live coding. Maybe it's because of this. Yeah, I know that they worked on it today. And now also this demo doesn't work. But what we have is the Abi. So let's go the other route again.
02:20:01.730 - 02:21:27.226, Speaker A: Shit. I cannot work with VI on the English keyboard. Any private data that would reveal if I do this, maybe let's do a new folder. All right. Okay. Graph in it theorem hash main it I will see that coming. All right, yeah.
02:21:27.226 - 02:22:07.886, Speaker A: The dependencies will take some time probably in the meantime. So what it does, it now creates the scaffold, which is cool. So we can go to the graph.com studio or actually if you want to follow, then you have it here in the products. You go to the studio sign and then you can just create a subgraph. You get main net, hash mask continue. And actually you just need to do graph auth.
02:22:07.886 - 02:22:55.810, Speaker A: Let's see where we are here. So what we have here is now it initialized the subgraph for us already. So you have the subgraph YAML which says like, which source? We can also add the start block here, which is we can see the transaction when it was deployed. It saves us time thinking and so on and so forth. You also have like auto generated schema. You see similar, like all the events are just indexed and you have also the auto generated mappings. So you can easily just get started with that stuff and don't need to overthink.
02:22:55.810 - 02:23:33.160, Speaker A: I would not really do much now. We just kind of say yeah, that looks good, just deploy. I probably need to do graph code gen first. Deploy. Nice. It's here. See, it's already syncing.
02:23:33.160 - 02:24:17.812, Speaker A: Did it fail now? And then you can go already in the playground and start to yeah, and it already see, it already starts to have data. Very cool. Also when you do this here, you see this query endpoint and this actually comes the next thing how to query the stuff from the graph. So from the studio you have this GraphQL endpoint that you can also use in your front end then. But you can also go here and start to inspect. And I know, for example, like, the hash masks, they can change names. So I can say, like, okay, ID name, new name, what happened here? And then you can just send this query.
02:24:17.812 - 02:24:58.900, Speaker A: And then you see, okay, someone changed the name to this or eleven mark Cuban dosh Nikola Tesla. So we already have like you see it took me five minutes and we already have very valuable data about the contract ready in a nice GraphQL interface. Yeah, so that's about developing subgraphs. So if you want to go like if you just do this, you probably don't get the bounty. You should then start to change the schema, change the mappings and so on. But if you have that first step and you want to extend your subgraph, then come to our booth and I'm happy kind of to explain the concept. You can also go to the documentation.
02:24:58.900 - 02:25:37.784, Speaker A: How to proceed from here further. But I want to spend some time also here this next slide, how to query data from the decentralized network. We also don't need to go through the slides, but this works like this. So you have again the graph. And then there is this one product called Graph Explorer. And here you see all the subgraphs, like all the 439 subgraphs which are deployed to a decentralized network yet now. And you can scroll through them and there are very interesting ones.
02:25:37.784 - 02:26:14.708, Speaker A: So, for example, you have Lido ray Mainet pull together sushi Hop protocol, some doodles ethereum blocks. You can query if you want. There's this ERC 721 marketplace that tracks kind of marketplace volumes and stuff. But the one that I like the most actually is the CryptoPunks. So you can search for CryptoPunks and then you need to be careful. Always go for the ones with the highest signal. That's what Queration is here for.
02:26:14.708 - 02:26:27.930, Speaker A: I think this one is a scam. But yeah, it's a decentralized network everybody can deploy. Right. So how it works again here you have a playground similar to before. So we can see like, okay.
02:26:31.260 - 02:26:31.672, Speaker F: Which.
02:26:31.726 - 02:27:24.410, Speaker A: Accounts do we have sent a graphical query. We can start to a little bit explore it. But actually it really gets cool if you do this. So you can get that query URL here and then you go to Graphic Online and paste it here. But like, the next step is also you need to have an API key. You can also go again into the studio and then you can create API keys here. You can just create one and then you can use it so you can copy that API key.
02:27:24.410 - 02:28:12.444, Speaker A: There are thousands free API keys initially, Queries, if you do this. And then you just need to replace the API key here with your API key. Sorry, should I take the other here? Okay. All right, get the API key. Nice. Again. And now I can say, for example, this is actually interesting.
02:28:12.444 - 02:28:52.952, Speaker A: So who wants to know actually the sales for the punks? It's interesting. The highest sale. So I can say like the NFT ID, and then amount order by amount order, direction, descending send. And see, this is interesting. Nobody knows that, but actually the highest sale on the crypto punks was that much and it was a wash trading. If you go to the Larva labs or now Uvalabs website and you want to see this, you don't see that wash trading here. But it's true.
02:28:52.952 - 02:29:22.660, Speaker A: Like somebody did it, get a flash loan, get the highest sale and then get the flash loan back. So it was interesting. So now we had kind of this walkthrough from what is the graph, how you can create the subgraph, and how you can query existing subgraphs on the decentralized network. Yeah, I know it was a lot packed in 30 minutes, but yeah, thanks for watching. And if you have any more questions, we're trying to be at the booth as much as possible. And then there is discord and other channels. Yeah, happy hacking.
02:33:02.820 - 02:33:34.652, Speaker F: I'm here to present Solkyl before I do that formalities. First, a big thank you to the ETH Global team for obviously organizing this event and in particular this workshop onto business. What ISQL I'm going to say what it isn't first. It isn't a querying language so why is QL in the name? The same reason Java is in JavaScript. Sounds cool. I've told you what it isn't. I'm going to show you what it is.
02:33:34.652 - 02:34:32.464, Speaker F: Now, the most brief description would be it is a tool that mimics hardhat forking but is much quicker than hard hat forking. I'll show you in a moment. So here I've got a standard hard hat environment set up. I've got a config file with the compiler version provider URL, the forking standard setup. If you have used hard hat this will be pretty familiar to you, obviously. So the smart contract I'm going to be testing today is called the query contract and in order for this to work, we need to impose some restrictions on this query contract. So one of those restrictions is it has to have a function with this signature right here.
02:34:32.464 - 02:35:52.876, Speaker F: So it has to have a function named query which returns bytes memory. So what is going on here? Basically what we're doing is we're taking the Uniswap v two factory contract on girly testnet and we are calling the all pairs function to get the ith pair. And then once we have the ith pair we call the token zero function to get its first token. Now there is a specific reason why this example was chosen, I'll explain that later but let's get into the comparison first. So this benchmark repo is available on our website over here so you can try running the benchmark yourself, see if you get similar results. Without further ado, let's test sole QL first and then I'll test hard hat forking afterwards. Okay, 7.9
02:35:52.876 - 02:36:04.028, Speaker F: seconds. To do what? To get ten pair contracts from the uniswap v two factory and then get their first token.
02:36:04.204 - 02:36:04.640, Speaker G: Cool.
02:36:04.710 - 02:37:19.960, Speaker F: Now, 7 seconds does sound slow but we are offering this as an alternative to hardhat forking which gives us the following result. Wait a while. Okay, 13 seconds. Now that doesn't seem like much of a difference even though it is almost a two x gain. But what ends up happening is as we increase the number of token addresses we are fetching, the difference goes up quite quickly. An example would be assuming that hard hat forking grows linearly with the number of tokens that we query whereas Solkyl would grow logarithmically so much slower. Now, before I explain how this performance game comes to life, I'm going to go through some caveats there's two main ones.
02:37:19.960 - 02:38:01.568, Speaker F: Firstly, we do not have Hardhat's console log functionality yet, although it's possible just will take a while. And two, we don't have the functionality to be able to pass constructor parameters to contracts yet again. That can be implemented. So here you'll notice that there is no constructor. Every piece of information that we need has been declared inside as a literal. And that is because as of right now, there is no support for being able to pass data into a constructor. Okay, so this is what I was talking about earlier.
02:38:01.568 - 02:39:00.568, Speaker F: This is a graph representing on the x axis we have the number of pair contracts we're querying and on the y axis we have the number of milliseconds taken to get a result. So as you can see, Sokyo the blue dots here stays pretty constant, whereas hard hat grows pretty quickly. So at this point right here, at 2000 pairs, we're looking at about a 30 x gain in performance. So that would be comparing around 6 seconds to 1800 seconds. So just to put things into perspective, that's 6 seconds compared to 30 minutes, which is a pretty big difference. Okay? And at the very far end, so here we have 9507 pairs. At that point, Hard hat doesn't even work.
02:39:00.568 - 02:39:41.136, Speaker F: You will probably get a timeout or some other form of networking error. So again, for this demonstration, just because it takes a while, we're not going to demonstrate these data points right here because they would quite literally take the rest of the workshop to show. But yes, so that shows the speed gain that you would have from using Soulql. Now we do have examples you could follow along with. So if I open here, go to the docs. Obviously we have this warning here. This is still an alpha.
02:39:41.136 - 02:40:29.768, Speaker F: So breaking changes will happen. But installation, you go to a directory and you run this command right here. Basically what it does is it clones a repo that we have set up and it installs the dependencies I'll actually show you. So right here, if I do NPX Solql, at zero point twelve, we're going to call this test two. So we get this test two directory. We've already run NPM install. So all of your dependencies are already installed.
02:40:29.768 - 02:41:05.004, Speaker F: So here what you have is the exact same smart contract I just showed you. But we also have this main script which shows the usage of the Soulql API. So basically the way this works is you import the Soulql class from the package. Obviously you instantiate an Ethers provider. With your provider link, you would have a contract name. This name would be this name right here. So if I turn this into query two, I'd also have to turn this right here into query two.
02:41:05.004 - 02:41:49.120, Speaker F: For this to work. We are passing the chain ID and we instantiate a solql interface. Like so the reason you pass the chain ID and your provider at the same time is because if you already know what chain ID your provider has, obviously we don't need to make an asynchronous call to figure out your chain ID for you. That would take an extra couple hundred milliseconds don't want that. You also have to pass the Hard Hat runtime environment to this Solkyo class. Reason being, Hardhat does quite a bit behind the scenes. So rather than reinventing the wheel ourselves, we just decided to rely on Hardhat.
02:41:49.120 - 02:43:04.770, Speaker F: So that is quite essential over there. And then to get the results, all we have to do is run the following line. This gives you an encoded string of bytes like this. But we can obviously use the default Abi coder of Ethers JS to decode our result and have it in a nicer format. Reason this is address 100 is because over here, this address 100 array is what we are packing and returning as bytes memory. So, just to show you where was I, if I go here, that is, by the way, if you there we go. That was quicker than before.
02:43:04.770 - 02:44:13.804, Speaker F: Anyway, so this is your encoded result, basically, which you use the Ethers, the JS decoder to turn into this right here. Okay, now, with that out of the way, where were my slides? This is diving a bit into the nitty gritty of how this thing works and why it gives us the performance gain it does give us. So firstly, I'll explain what Solkyl is doing and then I'll go through what Hardhat is doing and why Hard Hat is slower than Soulql. So basically what Solkyl does is it takes your contract, it uses the built in Hardhat compiler to compile it down to EVM bytecode. It then sends that bytecode to the provider. You give the Solql API and it gives you the results back. Now there is one step in the middle here.
02:44:13.804 - 02:45:05.436, Speaker F: So the way this actually works is we also have these Oracle contracts. These are contracts that we deploy. So these are actually deployed right now just on Gurley, but we are on the verge of deploying it to other chains as well. So what is happening here is basically we call this function here when we want to simulate our smart contract, which takes in the bytecode of that smart contract, and then deploys that contract using this assembly block here, runs the query method on it and returns the result. Now, in real life, this would cost gas. However, we're not actually signing this transaction, we're simulating it. So if you've used call static before, that's what we're doing here.
02:45:05.436 - 02:45:43.850, Speaker F: So we don't actually pay any gas for this. So that's how that works. Now, it would be more helpful to see all of this happen on the provider's dashboard so that you can see the type of JSON RPC request you get for Hard Hat forking as opposed to solve PR. So I'm going to run the Hard Hat forking script again and we don't need to wait for it to finish. We can just come here. Don't steal my API keys. Thank you.
02:45:43.850 - 02:46:29.454, Speaker F: Okay, this is what Hardhat does. Recall that smart contracts have a storage address on the global Ethereum. State. So what Hard Hat does is it has a local EVM instance, but it doesn't obviously have access to the entire ethereum streat state because if it did, it would be a full node, but it isn't. So what it does is to get the data it needs to do its computation, it sends your provider ETH getstorage at requests. So this parameter here is actually a smart contract address. So if you look this up, this could be the V Two factory, or it could be pair.
02:46:29.454 - 02:47:08.100, Speaker F: Actually, we can probably do that. Yes. There we go. So this address here is the uniswap V Two factory deployed on Gurley. So obviously we're getting data from the smart contract, but we don't have the data locally. So we send JSON RPC requests to our provider to get the data. So basically, the bottom line is, when you're using Hardhat, you are sending a lot of JSON RPC requests, and Hard Hat deliberately slows this down just so you don't get rate limited, which is actually a fair call.
02:47:08.100 - 02:47:58.954, Speaker F: But then let's see the alternative approach of Solarql. Again, we don't really need for it to finish. Right, this is all we get, a single ETH call. Reason being we are passing the bytecode of our smart contract. That's what this mysterious looking string here is to the provider. And the provider simulates deploying a smart contract using the spytecode, using the Oracle smart contract that we genuinely have deployed. So this is the result that you then get.
02:47:58.954 - 02:49:05.950, Speaker F: So essentially the performance gain we get from using Solql comes from making fewer JSON RPC requests. We make exactly one request. So obviously that has a lot less networking overhead, which is what results in. Where is it? This graph right here. So as you increase the number of pairs that you're querying, obviously you get proportionally more ETH gets storage at JSON RPC requests, whereas with Solql, if you increase the number of iterations you're doing in your loop, you're really just changing the jump I bytecode. So the length of the bytecode of the smart contract doesn't change that much as you increase the number of pairs. So what ends up happening is, firstly, the data you have to send to the provider to be able to simulate this smart contract doesn't increase linearly as the number of reads from storage you do increases.
02:49:05.950 - 02:49:41.770, Speaker F: And secondly, because the provider is doing all of the reads from state locally, they can obviously do it much, much quicker than the Hard Hat EVM on your machine having to make a separate JSON RPC request each time it needs to read a contract's storage. So, yes, that's what Solq does. Any questions? No questions. All right, I believe we are early. Ten minutes early.
02:49:41.840 - 02:49:42.170, Speaker G: Cool.
02:49:42.240 - 02:49:44.230, Speaker F: Well, that's it for me. Thank you for listening.
