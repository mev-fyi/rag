00:00:19.570 - 00:00:33.474, Speaker A: I think I lost the network some reason. I think I lost the network for some reason. I can't hear you, Nisha.
00:00:33.522 - 00:00:34.120, Speaker B: Okay.
00:00:36.890 - 00:01:17.770, Speaker A: Just give me a second. I'm going to switch my network quickly. Okay? Can you create a hotspot extender? Hello? Can you hear me? Am I audible?
00:01:18.110 - 00:01:18.486, Speaker B: Yeah.
00:01:18.528 - 00:01:57.090, Speaker A: Okay, cool. So hello everyone. Sorry for the initial problem, it was just some network issue here. So I am Shresth and I am currently speaking from India and I am a backend algorithm designer at Paraswap and I'm super excited to build cross chain Arbitrage bot with you guys. So let's get started. I'm going to quickly share my screen. Do you guys see my screen? Just.
00:01:59.460 - 00:02:00.530, Speaker B: Looks good.
00:02:01.540 - 00:02:56.784, Speaker A: Cool. Maybe a lot of people who are listening to this conversation might already be familiar with what Arbitrage is if they are from DeFi space. But to people who are not familiar, arbitrage are basically inefficiencies in the market which leads to risk free profits. So basically you can make money with basically nothing. Let's take a concrete example, right, so let's take an example in the DFI space. So let's suppose if you swap ETH to die and you swap one ETH and you get 3000 die, and then you use uniswap for that, and then you swap your 3000 die to let's suppose 1.1 e using Sushi swap and you just get an extra .1
00:02:56.784 - 00:03:37.410, Speaker A: e. So this is basically your arbitrage. Just because there was a difference in the prices for uniswap and Sushi swap. So there are different ways of doing Arbitrage, but today we're going to look at cross chain Arbitrage. So where does Paraswap come into play? So Paraswap is a liquidity aggregator and when I say a liquidity aggregator, it basically gets prices from multiple DEXs and gives you the best price when you want to swap from one token to another. I think the best way to see it is to just look at it. So I'm going to just open Paraswap and go through it.
00:03:37.410 - 00:04:42.420, Speaker A: So let me just quickly open Paraswap. So first of all, Parasop supports like ethereum, polygon, BSc. So let's just look into ethereum and you can just put like from and token. So Parasop will basically give you let's take some big amount to see some good stuff happening and you can use uniswap V three to route it and you can see how many different exchanges we are looking through to give you this price. Maybe let's look into polygon and you can see like with polygon just going from Matic to USDC, we are looking through not only multiple exchanges but also multiple routes. So yeah, parasite basically tries to beat the market using different exchanges and different connectors and that's what is liquidity aggregation. So let's come back to our presentation.
00:04:42.420 - 00:05:39.830, Speaker A: Cool, so now we know what Paraswap does and how we can use it in our Arbitrage bot is basically when we want to get the price for swapping one token to another. We can use Paraswap and we can also use Paras to building transactions. What is a cross chain arbitrage? So we understood what an arbitrage was but what is crosschain arbitrage? So a cross chain arbitrage is basically when one of the transaction is in one chain, another is in another chain. I mean the simple example is again we take ETH and Matic and you do like one e g matic and you get let's suppose 1500 matic and then you do 1500 matic to eat in like polygon chain and then you get 1.1 e. So you got like 0.1 e extra.
00:05:39.830 - 00:06:43.176, Speaker A: Now the interesting thing is one of the transaction is in main net, another is in polygon and there are quite some things you need to take care of. First of all, you need to get pricing for both the chains simultaneously and then you need to execute the transactions and then also make sure that your tokens are balanced in both the chain. So yeah, we're going to try to build that in today's workshop. And for simplicity we'll actually just use eat and Matic because those are like just native tokens in both the yeah, let's get started with mean we are all here for so before we start yeah, everything is open source at Paraswap's GitHub. So let me just quickly show that as well. So you can come here all the code is open source and feel free to fork it and start working with it. This is just like a sample code.
00:06:43.176 - 00:07:26.466, Speaker A: It's quite simple. I'm going to go through it now. So we'll start with first integrating with Paraswap API and just quickly open the code. So we are writing the code in JS node JS and it should be fairly easy to understand also for people who are not very familiar with node JS. So I'll just try to give you basic idea of how to build it. So even if you want to build it in some different language, you can build it easily. So first of all we need the Parasop URL to integrate with the Parasop API and this is the URL.
00:07:26.466 - 00:08:14.082, Speaker A: And then we create Parasop class which has two basic operation get price and bill transaction. Let's actually first look into the Parasop documentation. It's quite explanatory before we actually start. So just copy the URL for the documentation. Parasoft has like basically two main endpoints, I would say. One is the pricing endpoint and other is like the transaction building endpoint. So we looked into pricing right and once we do the pricing we can actually connect the wallet and build a transaction to actually execute the swap.
00:08:14.082 - 00:09:09.462, Speaker A: So the pricing endpoint does the pricing part where you will get like a route and with the best price and then you can call the transaction building endpoint with your final route and then you can get a transaction object which you can then send to your full node and then you can execute the transaction. So that's the basic two endpoints. And for the pricing one, if you look it's quite simple. What you need to pass is like the from token. This could be your address or the symbol itself. Then two token the amount and then you have side and network. I would also recommend to pass from decimals and two decimal because if you want to like parasop allows you to swap arbitrary ERC 20 token to arbitrary ERC 20 token and if you pass decimals then you can do that.
00:09:09.462 - 00:09:55.590, Speaker A: Otherwise Parasop has to list that token. So yeah, let's look into the code. So, quite simple. So we have a try catch block just because if there is an error in pricing and the request URL is basically the URL prices and then you have the from which is so the get price takes from to source amount and network. And from is basically a token object which has an address and a decimal. So we just put the from address to address source amount, from decimals to decimal cell and the network. So the interesting thing here is you have the same API and you can query both the networks.
00:09:55.590 - 00:10:33.890, Speaker A: So that's very good actually for our arbitrage bot. And then you basically do a simple get request and then you get a price route. I can also quickly just show you how the price route looks like. We should actually have some price routes, just some random query. So we just did like an e to die or some big amount. And the price route you get the best route and this was a mega route. So a mega route in terms of Paraswap is basically like the most complicated one where you have multiple routes going through.
00:10:33.890 - 00:10:58.486, Speaker A: So you have multiple routes using multiple exchanges. So here we're using you see quick swap, curve v two sushi swap and curve V one. So that's pretty good. And then we have the destination amount here, which is what is important. I think we also have the destination amount here. Let's see this one. So that's what I'm using here.
00:10:58.486 - 00:11:50.886, Speaker A: If you see the price is like data price, it out deskt amount and the payload is the whole payload. When you build a transaction it's important that you give the exact price route payload because the payload is like just it has a hash at HMAC. So you should not modify the price out payload, just the payload and then let's come into the build transaction. It's also quite simple. So if you look at the documentation here build transaction the important thing is your again two decimal from decimal refer user address. So refer is not required I think, but maybe it's typo here. User address is the address that's going to execute the transaction.
00:11:50.886 - 00:13:04.606, Speaker A: It is important because Paraswap just checks certain things like balances there correctly and stuff like that. Then there's price route which is the exact payload that you got from the pricing destination amount, source amount, desk token which can again be your token address or the symbol. So this is pretty clear I would say you can see that. So you can see it's just like putting the price route which is the payload that we got from to and the source decimal. And I'm also actually passing the refer if you see here and the refer is set to be our bot. Now the reason I'm doing this is when you pass a refer, what would happen is when you do the on chain, like when you execute the transaction and there's a swap event that's released and the refer will also be there in the swap event. So in future if you want to build like a cool dashboard where you want to check what kind of transaction did artbot did and all kind of statistics, we can very easily do that because we can just get all the swap events where the referral was art bought and we can easily use the parasop subgraph.
00:13:04.606 - 00:13:53.954, Speaker A: So there is also a parasop subgraph which has like you can index using the referral. So I just chose some random name arpbot school. Yeah so for the pricing you need to pass the referral index partner and for the transaction building you just pass it in the transaction like the request data and then you do a post. So here in the pricing we did a get request for building transaction, we do a post request and then you get the transaction object. I just create another transaction object just using this and I make sure those are in the right format. So we convert it into Hex. So we get the hack gas value which we convert into Hex, the value which we also convert into Hex and that's it.
00:13:53.954 - 00:14:14.600, Speaker A: So I think this is pretty simple. If there is any questions here, please put it in the chat. Don't feel to hesitate. Let me see if there was anything that was posted in the chat as well. Not sure if I can see that. Anyways, I will go ahead. Maybe I will check that later on.
00:14:14.600 - 00:15:02.770, Speaker A: Cool. So let's see what do we have next in our timeline. So we understood how to query parasop API. The next is like going through the bot draft. So how would the bot look like the bot logic and this is basically the I've commented out all the code and I will just go through it and comment it part by part to understand each part of the know. First I think I should explain the end sample. So we need like a private key which holds some funds in mainnet and a private key which holds some funds in polygon.
00:15:02.770 - 00:15:48.006, Speaker A: Also Http provider for mainnet I think you can use Intuitive or Alchemy and Http provider for polygon just create like an N file, copy all these variables and put appropriate providers and then in our index file. What we're doing is we're just like importing them. So for that we need the N so that we can add it in the environment variable and just add it here. And I'm just putting into a map with network with different network IDs so that we can easily access it. So for main net we know the network ID is one and for polygon we know the network ID is 137. For now you can just ignore these variables. I'll come to this later on.
00:15:48.006 - 00:16:27.442, Speaker A: So I also import like the Paraswap class that we created here. Right? So this class that we created here and also we need like big numbers library. So usually whenever you work with web3 stuff in JS you would need some kind of big number support because JS doesn't has that. Also we need Ethers to send the transaction and do all kind of web3 stuff. So for that we are using Ethers you can also use web3 JS. That's also cool. Yeah.
00:16:27.442 - 00:17:30.310, Speaker A: And then what we do is we just create like a map of tokens so that we can use it and as we saw in Parasov we use like an address and a decimal. So that's what I'm doing here. I'm creating a map with network, different network and ETH and Matic for both the networks. So ETH address this and Matic address in ETH is this whereas Matic address in Matic is just like ETH address but ETH itself has a different address. So it's pretty cool because the native addresses is always this and others are like ERC 20 in each other's network. So yeah, we can quickly see that as well. This is your Matic token and the decimals is also like 18 so this is fine and also for this one to quickly verify.
00:17:30.310 - 00:18:53.502, Speaker A: And this is like your wheat, it's wheat and 18. So the reason I chose actually, ETH and Matic for cross chain arbitrage is basically because these are like the native tokens and when you do like swap, you can just put them in the value and you don't need to give an allowance or approval. And that will just give us some more space to not add more complexity, but make it simple. But we can use any arbitrary token. So you can put any token which is supported in both the network and then you should be able to use it for the crosschain arbitrage bot. And then let's come to the main bot logic and we have the crosschain arbitrage bot class where you have like an alive which is basically making the bot alive. Then you have some internal function execute TX rebalance we'll come to this and then there's this main logic run and if you see the logic inside alive is quite simple, it's basically you try to run the bot, if it throws the error you just cancel the error or else you just keep on keeping it alive.
00:18:53.502 - 00:19:22.518, Speaker A: It recursively just calls it itself. The bot just tries to keep itself alive. We'll come to the main bot logic later on, but let's come to the main function. And first what we do here in the main function is we create the providers just like initialize the providers. So we just create a JSON RPC provider with main network ID and polygon network ID. Again a map. And then we create wallets.
00:19:22.518 - 00:20:15.740, Speaker A: So to find the transaction here we use like the private key and the provider and then use the ethers wallet. You can also look into the documentation ethers JS docs just to so this is the one we use. We pass the private key and the provider. And then what we do is we just create an instance of the parasop class that we created before an instance of the bot class. I just name it cross chain Arbitrator. Yeah. And then we just make the bot alive, right? And then wait for it.
00:20:15.740 - 00:20:46.946, Speaker A: Cool. So that completes the second part as well, the draft of the bot. And then we can come to the cool stuff. I would say the main part that we are here for the Arbitrage logic. So build the arbitrage algorithm. And so let's start with understanding. These are just helper functions.
00:20:46.946 - 00:21:20.160, Speaker A: So normalize basically takes any amount and a token and then converts into decimal representation. So if you have like ETH has 18 decimals, so one e 18 would be one e. But if you have one e 18 and you want to convert into one e, what you would do is just yeah, if you want to convert one into one. E 18, you will basically just take mount one and then times ten to the power token decimal. And this is just the reverse. And you just divide. So that's pretty clear.
00:21:20.160 - 00:22:01.840, Speaker A: And then we come to the run logic. So what we do is we first just take some source amount. I just took an arbitrary amount 0.5 E that we want to try and we take the token and we normalize it. So what we'll get is something like zero five times one E 18, right? That's what we're going to get. So it will be five and then 16 zeros. So then we call the paraswap to get the first price.
00:22:01.840 - 00:23:06.958, Speaker A: So we call the price first, get the paraswap pricing. Then what we do is maybe I can just console log this so that we can see what happens. Should be able to do that. Let's see solog price first running me on start. So you can see that we just got like a payload from the parasop API and this is the price and this is the whole payload. So this is working. You can see I don't see the route here, but their best route is inside this which is like an object.
00:23:06.958 - 00:23:44.026, Speaker A: So we need to expand this to see that, if you want to see that as well. But this is cool. And then what we can do is we can take the destination. So source amount first. Let me see what I'm doing here. Yeah, I'm just taking the source amount and just putting it in a denormalized form, which is just the reverse of the separation. And then I am denormalizing also the price that we got here.
00:23:44.026 - 00:24:19.542, Speaker A: So basically this price in the denormalized form for Matic. So we can just do log it and then we just have good log of the price. Let's see. So for the first swap, we want to get the price from ETH to Matic and for the main net and the source amount is 0.5 E and the destination amount is like 77.81. Eightyk. Cool.
00:24:19.542 - 00:25:16.790, Speaker A: So that's working. And then what we do is the idea is we want to swap from E to Matic and there can be some small slippage, right? A slippage. So what is a slippage is basically when you get a price and then you execute a transaction, you might not get the exact same price when you execute the transaction. And you can basically set a slippage so that if the price that you get on chain is less than this particular value, then the transaction will automatically reward. So you can set the slippage when you build a transaction in the parasol. So when you think about the arbitrage logic, you should actually consider the slippage. You should consider the worst case scenario so that you always are profitable, right? And if you swap from certain token to certain other token, you should consider that you will be hit worst case slippage.
00:25:16.790 - 00:25:58.482, Speaker A: And then you should take that amount as your destination amount. So I'm just doing that calculation here. So we can take any arbitrary slippage, and for our case, we can just set it to, like, 3% slippage, which is 0.3. And then I just do a simple whatever price that we got, we just multiply it with one minus slippage so that we get like this is the actual amount. Considering that we will be hit by the slippage and then use this amount. So you converted ETH to Matic, subtracted your slippage and take this amount. To again get to eat in polygon chain.
00:25:58.482 - 00:27:08.938, Speaker A: So here you see when you did the pricing we use main net and then we will do the pricing here. So we will again press get price and we will use our token list polygon Network. Take the matic to ETH in Polygon Network and then take the destination amount with slippage. So the destination amount that we got from the first swap we will use as a source amount for the next swap and also use Polygon network as the network ID and then we can again log everything. So I'm just basically denormalizing the desk amount. flippage this is basically the source amount for the second swap denormalized form. And this is like the denormalized of the destination amount for the second swap.
00:27:08.938 - 00:27:51.904, Speaker A: And that's basically matic to eat main net. And we can just see both of them running together, right? So you see the first swap eat to matic source amount was this, the destination was this and then you have second swap matic to eat. This is the typo, let's correct this. This should be polygon. So you have matrix to ETH happening in polygon and source amount was this and the destination amount was this. And you see this destination amount was 77. But the source amount here is 75.
00:27:51.904 - 00:29:09.784, Speaker A: So it's already considering 3%. Slippage that's working. And then what we do is we calculate the desk amount for the second swap with Slippage. So we need to get the destination amount of the second swap with Slippage, and then we check if the current price is actually an arbitrage price. So what we have to do is now we need to check that if the destination amount with slippage for the second swap is actually greater than the first amount, right? So maybe I can use these slides again to quickly show. So if you started with one eat, let's suppose then you get into 1500 matic but with slippage it would be something like let's suppose four 50, right? And then you take this four 50 and you swap here, right? So you have four 50 and then you get something like 1.1. Let's suppose and then you consider like a slippage here which would be let's suppose one point like five, right? And this is still greater than this then it's an arbitrage trade but let's suppose it was not.
00:29:09.784 - 00:30:06.532, Speaker A: So it was something like 9.8, right? Then it will not be an arbitrage trade. So this is the basic logic, I mean, this is really simple Arbitrage logic. There can be a lot of different complicated ways to do it but you just want to build up something that works on the scope of the time. So coming back here we just basically check if the source amount first is less than the final amount that we get including slippage and if it is so we just log it that we found an arbitrage. If not we basically just if there is then we execute this part, if not, then we do this logic. If there's Arbitrage, we do the transaction executing.
00:30:06.532 - 00:31:14.608, Speaker A: If there is no Arbitrage, then we basically just take some rest time. So we just have a constant here declaring how much is the rest time which is basically just 5 seconds. So we wait for 5 seconds and then we try to check arbitrage again, right? So this is the logic that we do here where we just keep ourselves alive. So we run and then if there was no arbitrage we wait and then we call alive again which will call run again and then coming to the transaction executing. So we have to build the transaction parallel. So first of all, we already did these transactions sequentially so we had to first query the first pricing and the second pricing. But if you think the block execution time for Matic is like I think 2 seconds or 3 seconds and also for the whole Arbitrage bot should be quite fast to actually get the price and build the transaction every block, otherwise the price will already change.
00:31:14.608 - 00:32:03.088, Speaker A: Meanwhile here we did it sequentially, maybe we can improve it later on. But for now, for build transaction, actually we can do it parallel. So what we'll do is basically use promise all which is basically calls both the Async compressions and we call the transaction building from the parasop that we wrote before and we pass the pricing. Payload pricing first payload, pricing second payload. We have to pass the tokens again. So ETH to Matic, Matic to ETH here, source amount first and then here we need to pass destination amount with slippage. So if you remember here in the paraswap we had like minimum destination amount that we had to pass.
00:32:03.088 - 00:33:11.160, Speaker A: This is the amount that considers slippage here, right? So here we have the destination amount first with slippage here and this destination amount second with slippage and the network IDs and also the wallet. This basically gives you the address of the user so for which we use the private key here. So the private key that's here we create the wallets and the wallets are basically passed as a constructive parameter and that's what we are using here for the address. Cool. And then we just log that we're executing the transaction and then we actually execute the transaction, log the transaction object and then rebalance. So before coming to rebalance, let's look into the execute TX function which is here. And what it does is it just basically calls the wallet with the correct network and then sends a transaction object.
00:33:11.160 - 00:34:19.672, Speaker A: So the transaction object that we got from the build transaction, from the pricing just pass here, right? And that's being basically used here. And then once we get the transaction object we need to wait for it so that the transaction is actually mined. So send transaction only sends the transaction but then we call the wait function to actually wait for it to be mined and that's it. So then the transaction is mined. So if you have a wallet and you have certain ETH in the ETH wallet and certain Matic in the Matic wallet and then you keep on doing Arbitrage, at some point your ETH will get depleted and you will only have Matic on the main net and like ETH on the polygon chain. So what you need to do is somehow also use maybe the bridge to put back your polygon to the polygon chain and eat the ETH chain so that you have to keep on balancing. Basically that's why you need to have a rebalance every time you do Arbitrage.
00:34:19.672 - 00:34:51.684, Speaker A: I haven't implemented the rebalance yet because it gets more complicated. So I just wanted to keep it simple. But the code is completely open source. Feel free to add the logic for rebalancing. It should be straightforward. If there's a balance which is less, then you can just use the bridge to, again, put it to another chain and that should be good. And yeah, that basically completes the whole logic of the Arbitrage part.
00:34:51.684 - 00:35:16.396, Speaker A: And I think we can just run the whole thing and test it out. Before I go to testing, maybe I can answer a few questions. If there was something I'm not sure how I can see the questions. Let me just chats. Cool. Questions on the chat. Question from YouTube.
00:35:16.396 - 00:35:44.040, Speaker A: From Jan. Does parasop support the fuse main net? No, I don't think we support Fuse yet. Is fuse. Another blockchain. I'm sorry, I'm not aware of that. Is it also EVM compatible? If so, you know, you can reach out to us on our channels and if they have enough liquidity, we can of course look into it and support it. We are always looking for expanding to different chains.
00:35:44.040 - 00:36:46.568, Speaker A: So yeah, for sure. Questions from YouTube is there a WebSocket API plan? Rest is just to show to run proper Arbitrage. We haven't planned to use like a WebSocket API yet, but good suggestion, maybe we can look into that. But at the moment we're just using Rest to subscribe to where is the main infrastructure location? So again, the same question. So we don't have a WebSocket for pricing yet, but as I see, there is already quite two people asking for the same person, right? Yeah. So we don't have a WebSocket yet and the main infrastructure location is, I think, in Europe. Do you have a subgraph for polygon? Yes, we do have a subgraph for polygon and you can actually find it in the subgraph.
00:36:46.568 - 00:37:35.370, Speaker A: I can also paste the link. Give me a second. So this is the subgraph for polygon. Did you run in HFP wise? I'm not sure what HFP is. Ek more than 200 to 300 swaps a day. Yeah. So? I'm not sure.
00:37:35.370 - 00:37:58.924, Speaker A: So I haven't really did a lot of Arbitrage using this code. It's just to demonstrate the idea and yeah. Is there any other questions? Can you do this with splash loans? Of course. I think, yeah, you can improve the logic with using flash loans and stuff. So that's for sure. You can do that.
00:37:59.122 - 00:38:06.420, Speaker B: Hey, I'm so we're a little bit overtime right now. If people have questions for you, they can send it to you on Discord.
00:38:07.000 - 00:38:07.604, Speaker A: Okay?
00:38:07.722 - 00:38:20.000, Speaker B: But I'd like to thank you again for running this workshop. It was really great. Like to thank Paraswap for sponsoring ETH Global and yeah, everybody have a really great day. If you have questions, reach out to him on Discord.
