00:12:27.070 - 00:12:27.620, Speaker A: Right.
00:12:28.070 - 00:12:43.554, Speaker B: GM, I guess. Good night. But it's GM. So, super excited to show you guys the new version of the World ID SDK. This is the very first time we're bringing Orbs to the US. It's the first time world ID is available on mainnet. It's the first time for a bunch of things.
00:12:43.554 - 00:13:20.446, Speaker B: So we're super, super excited to share this with you. I will give a short intro, then Miguel will give you a full demo of how to integrate World ID into your own apps so that you can play around it for the weekend. Before that, I want to give just a bit of background on why we're doing this and how we got here in the first place. And so a world when we think crypto is really awesome, but it has two problems. First of all, very, very few people have actually tried it. And then all of the value that's being generated by cryptocurrencies around the world and blockchains is being hoarded by a bunch of people like you and I, like early adopters or insiders. And we think that sucks.
00:13:20.446 - 00:14:10.258, Speaker B: And so a few years ago, we had this crazy thought of what would have happened if Bitcoin had launched by giving one bitcoin to every person who was alive, there's a bunch of really cool things that could have happened. And so we said, what the heck, let's just give it a shot. Let's give a token to everyone in the world and see what happens. And now, in doing this, we ran into a problem that many of you have probably ran into your projects, which is, how do you make sure people don't abuse it? In our case, it was, how do we make sure, if you're grieving away a free token, that people don't double dip, right? That they only claim it once? And so we started looking into it, and it turns out this is a very common problem. This is known as civil attacks. And it's basically this idea that online you cannot distinguish whether 20 accounts are 20 different people or one person that has 20 accounts. And so we started doing a lot of thinking of how to solve this.
00:14:10.258 - 00:14:30.730, Speaker B: And there was three basic requirements of how we wanted to solve this. Whatever we did had to respect privacy of people. It also had to be inclusive. We were trying to do something for the world, which meant it had to work in the entire world. And then lastly, it had to be scalable, right? We didn't want to do this experiment on a scale of 10,000 people. We wanted to have a billion people try this. So we went through a bunch of things.
00:14:30.730 - 00:14:51.822, Speaker B: I'm not going to dive in detail. We have another workshop tomorrow for this. But basically, we thought about email and phone verification. This doesn't work, right? It's super easy to get another one. We thought about KYC, which is verifying official IDs. This is super expensive. Most of the world doesn't actually have an ID or APIs to verify that ID, and it's not very private at all.
00:14:51.822 - 00:15:32.358, Speaker B: Right, then we run into Web of Trust, this idea of people endorsing each other so that you essentially build a model that allows you to be sure that people are unique. And we actually really like this. The problem with Web of Trust is that you needed a very large initial set of users that you can really trust. And so we actually think this is how we are going to scale WorldCoin from 1 billion users to 8 billion people. But you still have the problem of how do you get that first billion people that you can trust to build that Web of Trust so that you're not building a house of cards. And so after a bunch of things we landed on Biometrics. Then for a bunch of reasons that I'm also not going to get into, we went through faces and fingerprints.
00:15:32.358 - 00:16:10.390, Speaker B: We landed on we have to use Irises. And then when you decide that you want to do okay, Biometrics and Irises, your first thing that you say is, okay, let me use Face ID or Let me use my iPhone. But it turns out that phone sensors just don't have enough resolution to distinguish between one in 10 billion people and they also cannot operate in an untrusted environments. Then we said, okay, let's look at something like clear or like off the shelf hybrid scanners. And this has the same problem. And the reason for this is all of these devices do one to one comparisons, right? You're saying? Hey, I'm Tiago SADA. And so compare me to the previous biometrics of Tiago SADA, right? And so that is fairly easy to do.
00:16:10.390 - 00:16:43.550, Speaker B: We have a different problem, which is, hey, I'm a person that has never done something before. Which means we have to compare your biometrics with everyone else who has come before you. And so something like Face ID can only distinguish between one in 10 million people, which means that after 5 million people, there's a 50% chance that when you try it, it tells you, no, you've already done this even if you haven't. And so for what we were building, we wanted to be able to distinguish between a billion people. And so we just realized we have to build custom hardware. There's nothing that does this. It's like shit.
00:16:43.550 - 00:17:08.890, Speaker B: Now do we do it or not? And so we did do it. We spent two years doing R and D. There has been about five generations of the Orb hardware and this little beauty came out right? Now, I'm going to leave you in suspense here because we have a full workshop tomorrow. For 45 minutes, we'll actually go more in depth into why we built the Orb and how exactly it works. We will go piece by piece of the hardware. We're going to get very nitty gritty. It's really cool engineering.
00:17:08.890 - 00:17:46.390, Speaker B: So that's tomorrow here at 04:00 P.m.. But in general, the orb does three things. First of all, it looks at your face and makes sure that you're real, that you're not trying to cheat. So it does with you a bunch of sensors IR, it creates a 3D mapping of your face, makes sure that you're not wearing prosthetics, things like that. Secondly, it generates a code from your iris and that code leaves the device and is compared against every other code that has ever been successfully verified. And if it's unique, the orb then triggers a verification. It basically approves some private keys on your phone that we call World ID.
00:17:46.390 - 00:18:34.854, Speaker B: They're completely separate from your wallet, completely separate from your biometrics, and it marks that as verified. And so again, we will talk about this tomorrow. And so we really like this because it means we don't need to take pictures of you in the app, we don't need selfies, we don't need your name, we don't need your contact info, we don't need to do KYC. But Biometrics is pretty sensitive and so we wanted even more privacy. And so then we heard about this really cool new technology called Zero Knowledge Proofs. There is a blog post on our website if you search Privacy preserving improve a Personhood Protocol, where it's the Pppop where you can see how exactly this works. But basically we married the biometrics that we're already doing on device with Serial Knowledge Proofs to make this really private system that really nothing out there has today.
00:18:34.854 - 00:19:08.354, Speaker B: And like I said, the breakdown of this is pretty complex, but it's on our website, it's a really cool system. And so with that in hand, we actually went out to the world. We started trying this out, trying to give people the world coin token and signing up, giving them the world ID. And we've been to 25 countries or something more than this around the world. Everything from Norway to Mexico where I'm from, to Chile and Kenya and Indonesia and India and Portugal. We've had very few orbs because up until now we had to make orbs in eleven. So we only had 25.
00:19:08.354 - 00:19:35.866, Speaker B: And we would like ship them around. Right now we are finally producing orbs in a factory. Just last month we made 250 orbs. And then now we're going to be making a couple of hundred orbs every month, which is insane, because with just 25, we actually signed up over 600,000 people in less than a year. And so now with hundreds of orbs and thousands of orbs, very soon the scale of this is going to get pretty ridiculous. So all of this was great. We recently announced we're open sourcing all of this.
00:19:35.866 - 00:19:54.154, Speaker B: Part of this is already open source. Part of this we're in the process and we started seeing the community. We now have a discord. We're starting to build in public. We're setting really the foundations for decentralization. There's some parts of WorldCoin that will be decentralized before others. Obviously we do hardware, but the end goal is to have everything decentralized.
00:19:54.154 - 00:20:26.746, Speaker B: But there was one question we kept getting from people like you, which is all of you, your project is pretty cute, but how can I reuse your verification on my project? Right? Because I don't really care about your token. I don't really care about whatever floppy thing you want to do, but I want to issue loans or I want to do another AirDrop. And you've already solved civil resistance. And honestly, for a while, we resisted doing this because of privacy. We know how we treat privacy. We know we use CKPS and all of these things. And it just makes us very nervous to share this SDK with other people.
00:20:26.746 - 00:21:07.894, Speaker B: But eventually it's just a fact that you can build really cool stuff if you can prevent civil attacks. And so let's, okay, let's actually do some thinking. And so about three months ago, we said, okay, how can we open up an SDK for people to start playing with this? And with one condition of preserving privacy at all cost us? And so for us, that meant a couple of things. A lot of times people ask us, hey, can you just issue like, a Social Security number that's like your crypto SSN? And people have one of those, and we don't want to do that. We don't like the idea of people even able to track you across crypto. Another suggestion that we got is, well, can you just whitelist a wallet, right? Can you tell me which wallets have been seen by an orb? And I can just query that. And again, we don't like that.
00:21:07.894 - 00:21:31.022, Speaker B: We like the idea of people being able to use many identities, be pseudonymous, and we think that humanity should be separate from your identities. And so the solution was actually really obvious. It's just use the same zero knowledge proofs that we use on our own. And so with these, we created something called world ID. What you're going to see today is the alpha version of that. We're super, super excited to share it with you. And this is very simple.
00:21:31.022 - 00:22:08.070, Speaker B: It's a protocol that allows you to anonymously verify that someone is a real person and is performing an action only once. So, for example, for WorldCoin, people prove us with a zero knowledge proof like, hey, I'm a real person and I've never claimed WorldCoin before. Now with the SDK, with world ID going forward, developers can create any other actions. And so let's say that you're an artist. I want to do an NFT that each person can claim only once for free. Now that artist can verify, hey, this person is a real human, and they've never claimed this NFT before. The actions can be anything that is on chain, anything that can be triggered by a web API.
00:22:08.070 - 00:22:45.894, Speaker B: It's very, very cool stuff. Now, while all of the things behind it are super complex. We actually wanted to make it both really easy for developers and for users. And so for developers, all you need to do is add like two lines of code. And for users and starting today, there's a very nice developer portal that actually walks you through the process of implementing this, choosing whether you're doing something on chain or you're triggering something with an API and how to integrate the widget and all of these things. And you can manage different actions. For example, us as WorldCoin, we have a bunch of different actions that people prove in the app that they are unique and that they haven't done before.
00:22:45.894 - 00:23:11.566, Speaker B: And so you can manage all of those things. And then for users, what this looks like is very similar to a captcha. It's like a captcha that when you click it, it either takes you to the app if you're on mobile or it shows you a QR code that allows you to generate that serial knowledge proof. And so this is what it looks like. Let's say that someone wants to do an AirDrop and instead of having just a claim button, they would now have like this captcha thingy there. And you can customize the style. People will click on it, they can get a QR code.
00:23:11.566 - 00:23:30.920, Speaker B: They scan it with the WorldCoin app. The WorldCoin app asks them like, hey, this developer wants to verify that you haven't done this before, in this case, receiving an initial AirDrop. So you verify that we submit the CKP and then that button is enabled. And so rather than telling you more about this, I will just let Miguel show you how this works live and then I'll be back in a bit.
00:23:45.560 - 00:24:31.264, Speaker A: If I wasn't anything up. There we go. Okay, so as Diego said, we've made this really amazing protocol and we trailed that a little bit on the last global hackathon hackmoney, which was an online hackathon. And we got a lot of really feedback from developers about how it was great, but there were a bunch of things that could be improved about understanding how it works, make it easier to people to get started. And so since then, we just went and did exactly that. We have this developer documentation with all of the introductions. And now instead of having to install five different things to get started, we have this really cool dev portal.
00:24:31.264 - 00:25:09.776, Speaker A: So, for example, we have a bunch of examples here, but let's say that I just want to create a new action and I'm going to say it's like testing anyways. And this is going to be for staging. One of the really cool things that we've implemented is instead of just like rolling your own smart contracts and that's it, and that's all you have to do. We have a cloud version now where all of the proofs are still verified on Chain, but we just provide you an API so you can implement your front end. You can get all of the details from the widget and then you just send that to our API. We take care of verification. We take care of everything.
00:25:09.776 - 00:25:41.870, Speaker A: And we even have a Kios mode that I will demo in a second. That is the easiest way to do wall ID in any way, where we just have a page shows the QR code. People scan it, it Verifies people and that's it. If you're in person, give them some socks or you give them something, you can also redirect to a URL. So for all of the web, two people or all the people that don't really want to get into Smart Contracts right now, this is great. But what we're really here for, I think, is what is on Chain and verifying all of these things on Chain. And so oh well.
00:25:41.870 - 00:26:35.298, Speaker A: So we've made also this simulator while the connection comes back, which allows you to test all of this. The issue with Proof of Personhood is that it's really freaking hard to test because you try it once and then you cannot try it again if it works properly. And so this acts kind of like a faucet or a temporary testnet where instead of going to an orb every time and having to just hunt for humans around the conference to try your thing, you can just add identities to a test network and then deploy your Smart Contracts to a testnet and verify with this. So this was a small pause and this would be kind of like going through an orb. And it's now verified. I will go back to where I was before. So, as we mentioned, we have the API and JavaScript widget.
00:26:35.298 - 00:27:08.066, Speaker A: First you have to integrate JavaScript widget. This works both on Chain and with the API. You just add an NPM package, throw in a div anywhere where you want the captcha to appear, and then call Wallet init with the ID and an action ID you get from the portal. Then you call Enable and that will get you the result. Afterwards, you can either verify the proof with the API or you can send it to Smart Contracts, which we'll take care of verifying. So how that looks like is here. I have the code for this app.
00:27:08.066 - 00:27:50.702, Speaker A: That Tiago showed the whole AirDrop example where you just connect your wallet. I'm going to pull in my rainbow wallet here to connect. And this would be which wallet receives the AirDrop. The really cool thing about Proof of Personhood is that I can just receive the AirDrop with different wallets each time or maybe with even different identities, and no one will be able to track me between those usages or even if I use the same identity all the time. Since everything is like self contained wallet leaks. No information about you, not even that you were the same person that did these three things. So then afterwards it shows up.
00:27:50.702 - 00:28:36.522, Speaker A: I'm doing this once check. I would scan this QR code with my phone for demonstration purposes. And because again, poor personhood testing is really hard, I can just copy this QR code and paste it on the simulator that I mentioned before, paste it here, that will show me the same prompt that would show up in the app and I can just click Verify. And then when I go back, verification confirmed. And then I would just click Claim, which should pop up a transaction in my wallet to actually submit a transaction behind the scenes. What is happening is we're just generating the proof so that it's just like in react. We have a hook, we run the widget, we set the proof to a variable.
00:28:36.522 - 00:29:12.250, Speaker A: Here we have enough examples and code and all the code that I'm showing is open source. So you'll be able to copy and paste this if you want to. And then afterwards you just call the contract that you want. In this case we have called it Day contract with the parameters that you want to pass. For example, the wallet address that will receive the AirDrop and then these three items from the wallet approved that you can just drop in there and the contract will take care of verifying everything. How that looks is you first have to check that the user has done it before. You just have a mapping for nullified hashes on the contract that is just like a number to a boolean.
00:29:12.250 - 00:30:09.690, Speaker A: You then call the verify proof function on our contract, passing both the parameters that the user provided to make sure that someone cannot intercept this transaction and inject their own wallet to receive the tokens. And then also the action ID that you get from the dashboard. If the proof isn't successful because the user has not been verified, because they have already done this, or for any other options, this will revert. Otherwise this goes through, we mark the user as done and we can do literally anything that we want. And this example, this code we're doing here is for a project that we made for this hackathon called Petorbs, where you can adopt one of the little plushes that we made. One of these guys are kind of like the kids for the orb, a little bit less threatening. And you just would go in, connect your wallet, switchpot to polygon, you get to name the orb.
00:30:09.690 - 00:30:20.400, Speaker A: And then again you say I'm doing this once. And in this case, since this is in production, I'm going to grab my wallcoin app and scan this app.
00:30:22.290 - 00:30:22.606, Speaker B: And.
00:30:22.628 - 00:31:06.080, Speaker A: It will show me the same UI that we saw before with this project wants to verify, although a little bit slower because Wi Fi. And then the key here is I have already verified here because I already have my Petror at home. So what's going to happen if it loads otherwise, we can just all pretend it did is it will actually succeed here. We're still working on ways to verify show feedback to user before they submit the transaction. That would probably come up in the next release, hopefully. But when I click the adopt button which shows up after this, it would throw an error because the transaction reverts because the proof has not been verified. I'm going to try this one last time and otherwise we'll just move on.
00:31:06.080 - 00:31:55.550, Speaker A: In the meantime, as I mentioned, we have this developer, this documentation, it goes really in depth into all of the different options that the welcome widgets has. How to specify a signal, which is a way of encoding all of these parameters to make sure that no one intercepts the transaction. Also how to use this with non crypto projects. We've made a bunch of demos. For example, we have a Discord bot that can verify that you are a unique human that has never joined a survey before and give you a special role so you can see some channels, the roadmap, how to do more custom integrations. And we also have a bunch of examples like the drop that I described, the Discord bot. The code is also here, Hyperdrop, which is a parade where you would send contracts, tokens to a smart contract that then splits them between all humans on Earth, which is really cool.
00:31:55.550 - 00:32:25.206, Speaker A: And hopefully whatever you guys build on the hackathon, you can get like PR to show. Also here for other people, we also have the API again for more web. Two things and it doesn't seem like this is going to want to load again, I blame the WiFi. Yeah, that's pretty much everything that we've made. We have this dev portal, we have the simulator, we have the Docs. It's really easy to create all of the actions here. You can also customize them and even verify them.
00:32:25.206 - 00:32:36.060, Speaker A: So the application shows a fancy logo and a check to make sure that no one is pretending to be you. And yeah, hope that you really enjoy building with this.
00:32:47.730 - 00:32:52.962, Speaker B: All right, amazing. So just to all these loads, just.
00:32:53.016 - 00:32:53.620, Speaker C: To.
00:32:55.830 - 00:33:33.120, Speaker B: Emphasize what Miguel said is we're super excited about what the developer portal enables and how it can make the development experience a lot easier. The example that you saw today is if you want to execute an action on chain, right? If you want World ID to trigger something on chain. Now we've gotten a lot of requests and we've actually even used it ourselves for the discord. But hey, maybe I'm a crypto project, but for whatever reason, I just need an API call on a web server and that's fine, right? That's what cloud actions are for. Everything is still verified on chain. We just handle all of that complexity for you. So no need to be deploying smart contracts or things like that.
00:33:33.120 - 00:33:59.670, Speaker B: So that is the world ID flow. Basically, a World ID visits an.org just like this one to get their World ID. You as a developer can integrate the World ID widget or one of the other options that we have for World ID through the developer portal. Then the user interacts with that. They have to approve the verification through the app. That generates a zero knowledge proof it, submits it, and then you as a developer execute whatever action you're trying to do.
00:33:59.670 - 00:34:34.682, Speaker B: So this is super flexible, as you can imagine. We've seen people do this, do projects for like polls for this, for voting, whether it's one person, one vote, or quadratic voting, or conviction voting. There's a bunch of fundraising examples and soul bound tokens and there's a bunch of things you can build with this. And you probably have better ideas than us. Starting today, for the first time on Polygon, you can actually use this for real. In the past, when we shared a sneak peek of this, you could only use the simulator and no real people could use this. There was no developer portal, no cloud actions.
00:34:34.682 - 00:35:05.158, Speaker B: So starting today, all of this stuff is live on Polygon. The on chain actions only work on Polygon. The web actions you don't really care about. We will verify the actions for you on Polygon, but for you it doesn't really matter. Your app can be wherever you want it. And if you see an orb around the conference, you can actually download the app yourself, get your World ID and you can test things yourself. So before wrapping up, we want to give a huge shout out to a bunch of open source projects that we are building this on top of mainly Semaphore.
00:35:05.158 - 00:35:23.486, Speaker B: All of the cr knowledge proof that you see is an open source project called Semaphore. Super, super cool. The world going AirDrop, which is not available in the US. But we still work a lot with this team, is a team called Hubble. It's an L two that came out of the Ethereum Foundation. It's an optimistic roll up, so we're huge fans of them. And lastly, Wallet Connect.
00:35:23.486 - 00:35:54.522, Speaker B: You might not have realized, but the way World ID works is actually the connection between the wallet, the user's app and your widget is actually happening with Wallet Connect, even if it has nothing to do with your wallet. We just use all of their WebSockets and things like that. So we're super grateful for that. If you have any questions, we are on Discord, both on the official hackathon one and on the WorldCoin Discord. We can just chat one on one or you can just look for us. Just to summarize, World ID is a new protocol. It allows you to build several assistance into your app within ten minutes.
00:35:54.522 - 00:36:22.500, Speaker B: It's super private, it's self custodial, which we're very excited about, and it's open source already today. And more than anything, it's very flexible, right? You can use it basically for anything you can imagine with that. Again, you can get your world ID. Today we were having some wi Fi issues at the booth, so you might see us walking around randomly with the orbs. Just stop us. Or if you see us somewhere, just say like, hey, I want my world ID. For example, Hag here has a world ID, an orb, and we can help you set it up in like two minutes.
00:36:22.500 - 00:36:49.878, Speaker B: We do have a track on the hackathon with a bunch of prices. I'm sure we'll already look at them, so I won't go over them. There's first place, 2nd, 3rd place, and also a pool price. And in general, we are some Alpha League here. We are about to launch a grants program, so anyone that's hacking on these will probably be fast tracked on those community grants that we will launch during the summer. Last two things, if you are curious about the orb, why we made the orb. You hate the orb.
00:36:49.878 - 00:37:21.058, Speaker B: You love the orb. You have a weird attraction to the orb. Tomorrow is the place, is the day for you. We're going to, for 45 minutes, dive super in depth into everything or related here in this building in some room at 04:00 p.m.. And then also, if you really like what we're doing, we're hiring across the board. Whether it's for product design, a bunch of engineering, like, pretty much, if you can imagine it, we're hiring for it. And so please come and talk to someone in the team or just email me directly at Yahweh@worldcoin.org.
00:37:21.058 - 00:37:27.640, Speaker B: So with that, I want to leave the last minutes that we have for questions, mostly for Miguel, but also for myself.
00:37:36.750 - 00:37:37.578, Speaker A: What do you think of some of.
00:37:37.584 - 00:38:15.766, Speaker B: The potential attack vectors? First of all, it's not really an identity protocol, right? Because everyone gets the same proof of personhood. It actually is not very useful for some things where you would want to distinguish people. What we give you is a way of knowing that someone is a person that hasn't done something before. So in terms of a downside, that is a downside, right? If you do KYC, you don't just know that they're real, you also know who they are. So that is a downside of this. Obviously, we have to get everyone on the system and so we have to find a way to scale this to the world. We think we have a path to that.
00:38:15.766 - 00:38:45.460, Speaker B: And there is one trusted component here, which is the orb. The orb is essentially a real world oracle, and we do a lot of work both to prevent abuse and to react to abuse. So for example, every orb signs each verification. So if an orb was misused or it was compromised us right now and in the future, the community can actually retroactively expire the verifications from that orb and just tell people that they should return to another orb. So there's things that we do to mitigate that, but there is inherent trust in the. Orb. And that is just perhaps the downside of the project.
00:38:45.460 - 00:39:23.706, Speaker B: But we think it's by far like the best path, obviously. Yeah. So we're not really talking about the World Coin AirDrop today. You can throw questions on the discord on that. In summary, there's just not enough regulatory certainty in the US for us to feel comfortable running the worldcraft AirDrop in the US. Yes. So right now, in other countries, people can try the beta.
00:39:23.706 - 00:39:33.854, Speaker B: So we're issuing what we call beta tokens, which is World tokens on a testnet that will hopefully convert I would rather not talk about the AirDrop. Let's focus on world.
00:39:33.892 - 00:39:34.622, Speaker C: ID today.
00:39:34.756 - 00:39:56.040, Speaker B: Yes. Let's focus on world ID today. Sorry. No, I'm happy to respond on discord. It's just right now we're not talking about the AirDrop in the US. For now, we're not talking about the AirDrop in the US. Yes.
00:39:56.040 - 00:40:32.402, Speaker B: Great question. So we're actually hoping to open up the hardware of the ORV before this conference. The spirit of the workshop that we're doing tomorrow is that it's pretty much sharing everything that we would share anyways we are ready to do. So the special consideration with the hardware is the licensing. It's a double edged sword opening it up. Right, because people could choose to misuse technology that we've developed. And so all of the blueprints and everything will be opened up.
00:40:32.402 - 00:40:39.038, Speaker B: We are working with really cool open source advocates on exactly what license we.
00:40:39.064 - 00:40:39.862, Speaker C: Will do this with.
00:40:39.916 - 00:40:51.240, Speaker B: And so during the summer, the hardware of the will be open sourced and then hopefully within a year, the firmware will also be open source as well. All right. Yeah.
00:40:51.850 - 00:40:53.160, Speaker A: Is this used?
00:40:59.850 - 00:41:00.982, Speaker B: Do you want to take this?
00:41:01.116 - 00:41:01.702, Speaker A: That's right.
00:41:01.756 - 00:41:25.920, Speaker B: Do we use this? I can just take so no, you do not use this in place of a wallet. When you download the WorldCoin app, you get a self custodial wallet. Right now it supports hubble on ethereum and polygon. World ID is completely separate. It's wallet agnostic. And so when you sign up to WorldCoin, you do get a wallet. You can use that or you can just use any other wallet you want and just use World ad through the WorldCoin app.
00:41:25.920 - 00:42:17.886, Speaker B: What if I lose my yeah, great question. So unlike your World ID, private keys, you can backup just as you can backup wallet, private keys. So right now we support cloud backup. In the near future, we'll support social recovery as well. The additional thing that we can do in this case is we can also let you go back to an orb expire or revoke your old World ID and get a fresh one with that same iris code. Because while there is not a link between your wallet and your iris code and there's also not a link between other stuff that you do and your iris code, there is a link between your World ID public key and your iris code. So we can revoke that verification that is on that World ID public key and assign a new one.
00:42:17.886 - 00:42:56.346, Speaker B: Right? And that's fine because the actions that you do with world ID are not tied to your World ID public key. This is the very cool thing. You cannot query some World ID public key and ask, what has this person done? Every action is completely unrelated to each other, unlike it would be in the case of wallets. Yeah, so if you lost your eyes, or if you don't have eyes, then in the short term, we don't have a mechanism yet. This is what I was talking about. The way we see scaling, this is actually through something like a web of trust. But in the short term, the vast majority of population has two eyes.
00:42:56.346 - 00:43:34.866, Speaker B: The vast majority of population don't lose their eyes, fortunately. And so we think that's good enough to issue it. You would only need to return to an orb if you lose access to your world ID in the first place. So even if for whatever reason you have an accident, as long as you don't lose access to your world ID and you have it backed up, you should be fine. Anyone else have a question? All right then, let's take one last one from you. Yes, so we'll talk about this tomorrow. The orb has a superior enclave.
00:43:34.866 - 00:43:53.902, Speaker B: Each orb is provisioned its own signature. That's what it uses to sign the verifications. And so there is a whole flow around that you can imagine very similar to how you provision hardware wallets. And so, yeah, that's in short the answer. We'll talk a lot about that tomorrow. All right, sounds good. Thank you so much, everyone.
00:43:53.902 - 00:56:54.480, Speaker B: We will be around all weekend long. We will also stick around here in the back. If you have any questions or if you want to ask one on one stuff. Super happy to see you and happy hacking. Okay.
00:56:55.170 - 00:57:37.290, Speaker C: Hello everybody. My name is Herman. I'm here on behalf of Nosisafe. We would like to introduce you or to talk about safe modules and a little bit of safeguards, how to create your own safe module. So first of all, I would like to ask a few quick questions. Please raise your hands. Who knows what Nosisafe is? Okay? Quite a lot of people who is using the Nosisafe currently individually or in a team who has built anything related with Nosisafe development.
00:57:37.290 - 00:58:25.814, Speaker C: Okay? And finally, who knows what safeguards and safe modules are? Just a few then that's good. We will talk about that today. So the key points of this talk are going to be the Safe Modules architecture. What are the different components that form the safe architecture? What they are. The Safe Modules applications. Like, why are they useful? Safe Modules Management. How to use them? We can enable, disabling them, execute transactions using modules, and finally some repositories where you can find some examples of safe modules.
00:58:25.814 - 00:59:03.400, Speaker C: So where to find them? You have probably noticed that we have the what, the why, the how, the where and we are missing who and when. Well, that's obvious I guess. Who is you and when is this hackathon. So let's start. Thank you. Safe Modules Architecture if we talk about external loan accounts, we see that, we see that the architecture is simple. We have a private key and a public key and the private key needs to sign every transaction in order to execute it.
00:59:03.400 - 01:00:03.110, Speaker C: However, with Safe, because we are a smart contract and a multi signature wallet, we need to define a list of signers and with their private keys they need to sign every transaction. We can define how many of them are required to sign each transaction and after that they become executable. That happens on chain. We also have some services that allow us to collect the signatures off chain. And once we have the transaction and the signatures, we can just call the contract once to afford some gas and make the user experience easier. So this is the regular flow of a transaction execution where signers need to sign each transaction. But there are also another flow and this is using Safe Modules.
01:00:03.110 - 01:01:26.634, Speaker C: Safe Modules are used by third parties that are external accounts that they can call a Safe Module. And a Safe Module is a smart contract that is deployed in the Safe network than the Nosisafe and it has root access to execute transactions in the Safe. They are very powerful, but also we need to take care because it's critical they have root access, meaning that they can execute transactions without the confirmation or the approvals of the signers. So the developers need to define a different logic in the Safe modules and the transactions will become executable or not if those checks are passed. So we have the regular flow with the signers and the other with the modules in case the signers become unavailable or the private keys are lost. The Safe Modules flow is still available and if we have a Safe module, for example, that implements a recovery mechanism, we could somehow replace the original signers and add new ones. There are also another type of modules and these are the Safe modifiers.
01:01:26.634 - 01:02:30.570, Speaker C: Safe modifiers are usually called by Safe Modules that are used by third parties. So Safe modifiers are placed between Safe modules and the Safe and they allow to add some filters to the transactions that are triggered from a module. So we are allowed to chain different safe modifiers and when a transaction from a third party is sent to a safe module, the transaction is relayed in case we have a complex architecture that is not needed and we should try to simplify everything as possible. But this transaction could go through every safe module and modifier and having some checks there. The Safe Wallet allows to have multiple Safe modules that offer extra functionality. Also Safe modifiers allow to have safe modules plugged into them. And of course we can also have multiple safe modifiers.
01:02:30.570 - 01:03:51.102, Speaker C: So safe modules allow to expand the functionality of the safe and we also have another piece of another element that are safeguards. Safeguards can be enabled to a safe and they can execute some checks before a transaction is executed and after a transaction is executed. So there every transaction that is triggered even if it's from a safe module or from the signers will pass those checks. If any of these checks after or before reverts then the transaction will be reverted also very critical element. So let's see some applications that modules and guards can offer. We have the multisignature control, the common flow and we also can add some functionality to implement roles recovery mechanism, add protection layers and some things modifiers allow us regarding roles. We can create for example a safe module that gives or grants admin rights to some specific accounts.
01:03:51.102 - 01:05:49.080, Speaker C: So you could imagine having a safe module where some roles are defined and this role could refer to what are the kind of transactions that can be executed, like what are the target contracts that can be called, which specific functions could be called, which range of parameters of the values could be used and give some accounts those roles. We could also implement a token voting where a safe module is related with a ERC 20 token and do something similar like Dows do where the holders of this token have voting power in order to execute transactions. We could also have a safe module that handles spending limits. So we could allow some accounts to withdraw a specific amount of funds for a specific token without the need of creating of all the signers approving each of these withdrawals regarding recovery. For example, we could implement a social recovery mechanism where we define some accounts that belong to our friends or family and at some point they together could execute a transaction via that module and replace the original signers of the safe if the private keys were lost. We could also, for example, these are just examples you see, we could implement secret questions. If you remember long time ago in web two pages, if you forgot your password, they would allow you to answer a question like what was the name of your first teacher, what was the name of your first dog, whatever.
01:05:49.080 - 01:07:15.890, Speaker C: Here you could implement something like that where you could submit an answer and if it is the correct one, then replace the owners or allow a custodial recovery party to execute that kind of transactions. Regarding the safeguards, for example, because all the transactions pass through the checks that the guards have, we could implement an allow or deny list where we allow some well, it would be like a filter for all the transactions checking what the target contract is. And allow or not to execute a transaction. We could freeze an account if before executing it there's a parameter that designers can turn on and off, et cetera. Also with modifiers that have multiple Safe Modules plugged into it, we could add a modifier that implements, for example, a queue. And all the transactions that are coming from these modules would stay in that queue for one day, for example. There are unlimited possibilities that you could explore.
01:07:15.890 - 01:08:32.170, Speaker C: So how we can manage these modules and use them? The different operations that can be done are enabling a Safe module, disable it, check if a module is enabled or not into a specific Safe, get in all the enabled modules in a Safe and finally execute a transaction. For the setup, we would need to deploy a Safe or use an existing one. Deploy a Safe module or use an existing one, if that module is built in a way that allows multiple Safe to use it and finally execute a transaction via that module. So, let's see from the Nosisafe Smart contract side and from the module side, some code. So, here we see two contracts. The first one is a super simplified Nosisafe contract, that is a Module Manager. Module Manager is one of the core contracts of the Safe that has all the functionality that allows to enable modules, disable them, et cetera.
01:08:32.170 - 01:09:22.474, Speaker C: So, when we set up a new Safe inside the function setup, there is a call to the setup Modules function inside the Module Manager. And if we see below the Module Manager, we have two variables. One is a mapping called Modules, where the keys and values are addresses. And we use a sentinel module. That is the address Zero x one that we use in the beginning and at the end of this mapping to see well, to navigate it. So I'm not going to talk very deep about this. We can enable a module, it cannot be null or the sentinel the address we are using it for the module.
01:09:22.474 - 01:10:14.238, Speaker C: And also Modules cannot be added twice. We can disable a module and making sure that the module was already enabled before. We also can see if a module is enabled or not. By checking this Modules mapping, we can get the enabled Modules list that is paginated and we can iterate on it. And finally, and the most interesting thing is that we can execute a transaction. So, in the Safe contract, there are two methods execute transaction that uses the regular flow, checking the signatures of the signers, and then we have the method exec transaction from Module. This is a public method that can be called by any account.
01:10:14.238 - 01:11:16.822, Speaker C: However, inside of it there is a check where the message sender needs to be inside of the Modules mapping. Meaning that the message sender the account that is calling this method is a module that is enabled, that was inside of the Nosisafe contracts. And now, if you decide to build a custom module, you could create a contract. In this case, we call it custom module, that is a module. Module is an interface that defines, well, it is an abstract class that defines the methods that are required and that can be implemented here. So for this case, we have the custom method function that receives some parameters of a transaction, like the two value data and operation. And inside of it we are calling a target.
01:11:16.822 - 01:12:22.830, Speaker C: This target is an address that was set before and if this is a module, the target can be a modifier or an Osisafe. And there we can call the function exec transaction from module and pass all these parameters. So this way we are relaying the transaction from the module to the safe. Now let's see a little bit how to use the safeguards equally to the safe modules. We can have a safe deploy a safeguard, enable a guard into the safe or disable it. The difference is that safes only allow to have one safeguard instead of well, we can have multiple modules, but just one safeguard. Safeguards are enabled in the safe by the signers.
01:12:22.830 - 01:13:37.160, Speaker C: And then in the safe contract there is the function exec transaction, and inside of it I just simplify the code here, but the signatures are checked. And then we get the safeguard. We see. Or we check if that guard is different than the address zero, meaning that we indeed are using a guard. If that is correct and we are using it, then we will call the method check transaction. Then the transaction will happen and after it there will be another call to the guard calling the method check after execution. If one of these methods reverts, everything will revert and a custom guard could be implemented with two functions check transaction that receives all the parameters from anosisafe transaction and also the function check after execution that receives the transaction hash and if the transaction was successful or not.
01:13:37.160 - 01:14:48.060, Speaker C: So some module repositories and examples you can read. We have the safe contracts repo in the safeglobal user on GitHub. There you can find the core contracts, the module manager and the guard manager that implements the functions to manage these elements. Then we have the Safe modules repository where there are some examples of modules that are used. And also a very interesting one is the Zodiac repository under the nosis user. Zodiac is a Dao tooling standard that implements multiple safe modules for DAOs that are built on top of the safe. And you probably will find that interesting here I will provide the slides in the discord of it global so you could check these links there.
01:14:48.060 - 01:15:35.686, Speaker C: So we have the modules that implement or that indicate what are the functions that are required to implement if you build a module. Well, here we have some examples of modules and modifiers. Sorry, I'm running out of time. Same for the guards. We have a base guard and also an example of a guard that debugs a transaction, checking the data before and after the transaction is executed. And now the question is, will you build the next big Safe module or guard? Well, we hope so. You can find us on Twitter Nosisafe.
01:15:35.686 - 01:16:59.030, Speaker C: We also have a Discord and forum on Chat or forum nosis Safe IO and we also have a channel Nosisafe in it, global Discord. Also feel free to come to our booth and claim your Nosisafe is New York POAP. And for the hackathon we have $10,000 up for grabs and two bounties. The first one is a wild card like any integration with the Nosisafe on different layers on the front end infra or contract layer in the front end you could create a new front end use our SDKs like the SafeCore. SDK if you are building an app that runs standalone and separated from our app or the Safe Apps SDK if you want to build a Safe app that runs inside our Safe Apps store in the infra if you want to play around signatures that are sorry. Like collecting all the signatures off chain before a transaction is executed. Or in the contract layer if you want to play around with modules and guards.
01:16:59.030 - 01:17:33.330, Speaker C: That is the first bounty and the second one would be specifically related to the Roles module from Zodiac, the best use case for it. So, thank you very much. We are going to stay here all the weekend at our booth. Feel free to pop up and well, we can help you with your questions and good luck with the hackathon.
01:22:38.520 - 01:23:39.448, Speaker D: GM or actually, good evening. Good night. GN. I'm Steph, and I'm a developers advocate at Polygon. And today I'm going to present on a quick start guide to Polygon for biddlers or builders, which you all are. So quick definition of biddle or B-U-I-D-L It kind of comes from Hodl, which I always think of Hodor from Game of Thrones when he's like hold the door, but hold on for dear life to all of your crypto through the winter with me and also build for dear life because a bear market is a build market. So about half of the hackers at East New York this year are first time Web Three developers, which is really cool to me because I started my journey in Web Three with ETH Online in October last year.
01:23:39.448 - 01:24:14.448, Speaker D: And so the main difference between a Web Two app and a Web Three DAP is just a back end. There's components of blockchain on the back end, but from a front end perspective, it's very similar. So if you're used to creating front ends, awesome, you're in the right place. And I'll run you through how to compile and deploy a smart contract on Polygon today. But really quick, I just want to go through a couple fundamentals. So what is a blockchain? A blockchain is just a public database that's updated and shared across many computers in a network. We consider that a decentralized system.
01:24:14.448 - 01:25:02.832, Speaker D: And a block in a blockchain is just the data or the state that's being stored in those consecutive groups of blocks. So if you've ever sent crypto to someone or received it from someone, the transaction data needs to be added to the block on the chain in order for it to be a successful transaction and to be accepted as a transaction on the network. And I took this nice little definition from the Ethereum Foundation. They have a great article called what is a Blockchain? I love the Ethereum Foundation for all of their different resources. It's where I start when I'm learning something new. So, next up, what is Polygon? This is kind of a quick overview of a bunch of the different products that Polygon offers. You've probably heard of Polygon POS the most.
01:25:02.832 - 01:25:38.428, Speaker D: I'll go over that in a little more detail, but we also have a bunch of different ZK solutions. We have supernets and we also have Polygon ID. And we actually just announced an integration with Polygon Dao, I believe, two days ago. And then we went into more detail about that today at Polygon Ignite. So we would love to see you at a future Ignite event. But Polygon POS, which is proof of stake, is an Ethereum scaling solution. And some of the reasons why I've always loved developing on Polygon is because Polygon is really fast.
01:25:38.428 - 01:26:07.540, Speaker D: So the transaction speeds go through super fast, 7000 transactions a second versus Ethereum at 15. It's also very scalable, so it's built to scale with you. We've had over 1.4 billion with a B transactions recorded so far, and also 29,000 DApps on Polygon, which is awesome. Also very flexible. It's EVM compatible. And if you've ever developed on Ethereum, you're already a Polygon developer, which is very cool.
01:26:07.540 - 01:26:58.710, Speaker D: We use all of the same tooling and that's all built in, so none of that has to change just because you're on Polygon. And then one of the best parts to me is the cost. So, as a developer, if you're deploying a contract on Polygon, it costs far less than Ethereum, with an average transaction being just a fraction of a penny, which I absolutely love. And then the other reason to deploy on Polygon this weekend is that we're giving away $20,000 in prizes. We have four different tracks, and we also have a pool prize which will be split between the top ten projects that deploy on either Polygon POS testnet or the main net. So I'm going to go over how to compile and deploy a smart contract on our testnet, which is called Mumbai. So the first thing you have to have is a wallet set up.
01:26:58.710 - 01:27:29.020, Speaker D: So download MetaMask, create a new address, add the test network, and then go to the faucet. That's a lot of steps. So I'm just going to run through the whole thing as a demo. I already have MetaMask, which is a browser extension. You can see it up here. And I'm also already connected to the polygon testnet, but I'll show you how to add that so you can download MetaMask from this link. But the next thing you're going to do is create a new address for test development.
01:27:29.020 - 01:28:10.172, Speaker D: So within MetaMask, open up your profile by clicking that upper right hand little dot, and then go to Create account, I like to name my accounts with the date. So I'm just going to call this Wagme, which stands for we're all going to make it. And then I like to give it a date of like, 624 so that I remember what I was doing. And this is a test account, so I'm never going to use this for real transactions because just security reasons. So now I've got a new account, and the next thing I need to do is add the Polygon Mumbai test network. So the easiest way to do this is to go to PolyScan. So I'm just going to open that link.
01:28:10.172 - 01:29:00.888, Speaker D: PolyScan shows all of the different transactions on Polygon. It's very similar to Etherscan, but it's for the polygon test network because you can see the little Mumbai flag up here. But if you scroll all the way to the bottom of PolyScan, you'll see a little Add Mumbai network button to MetaMask. So that's just a way to quickly and easily add the RPC so we can connect to this network by changing it within MetaMask. So I'm just going to switch the network. I'm going to connect to the wallet I just created, and we can see that Wagme 624 account is on the polygon testnet, which is exactly what I wanted. So the next step is to add some Polygon Mumbai testmatic from a faucet.
01:29:00.888 - 01:29:36.452, Speaker D: A faucet is just a mechanism for receiving test crypto so that you can play with it and do different development. So you can see that I'm on the faucet account, and I'm going to get some test tokens. Again, the network is Mumbai, which is our testnet, and I want matic tokens. I'm going to grab the wallet address from MetaMask and paste it in here. And I'm going to send myself some crypto. If only this worked for Bitcoin and Ethereum on the main net, I'd be so rich. Okay, so request is submitted.
01:29:36.452 - 01:30:14.090, Speaker D: This should take one to two minutes, and we'll see it directly in my MetaMask account as soon as this funding goes through. So I don't think it'll take one to two full minutes, but we'll see. But once that happens, we have our wallet fully set up for actual smart contract deployment. So next we're going to get into how to actually deploy your first smart contract using Remix. And Remix is this really awesome IDE. It kind of reminds me of Visual Studio code. But not only can you write your smart contracts in Solidity in Remix, but you can also directly compile and deploy them.
01:30:14.090 - 01:30:40.718, Speaker D: So you don't need a different tool. Like, I don't know what you use for your front ends, but you can do all of this straight in Remix, which is great. I'm just going to click right into Remix and open this in a new tab. But first let's check MetaMask and see. Yeah, so you can see that we got that 0.2 testmatic from the faucet successfully. And so let's get into the actual coding.
01:30:40.718 - 01:31:07.386, Speaker D: So again, this is the Remix IDE where you can create your smart contracts and also compile and deploy them. I'm going to go straight into the Contracts folder and we're just going to look at the first contract. This comes built in with Remix for you to play with. This is written in solidity. On line three you can see I'm just going to zoom in. Hopefully you all can see that. But this is just on line three.
01:31:07.386 - 01:31:39.170, Speaker D: This is defining the Solidity version so that it's pinned when you're developing. And on line ten you can see this contract is called Storage. Line twelve has a piece of state which is just number that's being defined. And on lines 18 and 26 we have two different functions. So on line 18 we have the Store function. This is taking in a number to store within the smart contract. So if we did something like store three, three would be stored in the smart contract and that would be like the piece of state that we're keeping.
01:31:39.170 - 01:32:28.108, Speaker D: And then anytime we call the Retrieve function, it would print the number. So if you've developed in JavaScript, I think it looks very similar, which I like because I'm a JavaScript developer in a former life. But we're just going to practice compiling and deploying this smart contract. So I'm going to save this within the Remix editor and then go to the Compile tab, which is the third one down, and click Compile. So this is just compiling the code. Okay, so this compiled and the next thing we need to do is deploy this compiled code. So the fourth tab down is the Deploy and Run Transactions tab.
01:32:28.108 - 01:33:18.210, Speaker D: I'm going to switch my environment to injected web three because this will read the environment directly from my MetaMask account. You can see there's this custom 8001 network and that corresponds to my Polygon Mumbai test network. So I'll connect to my account and just to show you that the network actually changes, I'm going to change into the Ethereum main net and watch the injected web three network appear change when we do that. So now we're in the main net, but I'm going to go back to the Polygon testnet. But that's just to show you that as you change your network, it also changes within Remix. So this is an easy way to deploy to any EVM compatible chain. Although we would really like you to do it on Polygon, of course.
01:33:18.210 - 01:33:46.616, Speaker D: So now we have our injected web three. We have the account. Hooked up and the last thing to do is deploy, which I do by clicking the beautiful orange deploy button. It shows an estimated gas fee. So it's like zero, zero, three matic. I'm going to confirm that transaction. And you can see down here, creation of storage, which is this smart contract, is pending.
01:33:46.616 - 01:34:25.992, Speaker D: And we can see there was a successful transaction with this nice little green button checkmark. So at the bottom here, you can see deployed contracts. We just have this one that we just created and hopefully we all remember. Oh, no, my mouse got stuck. Let's see, technical difficulties, mouse difficulties. There we go. Okay, so back in that contract again, on line 18, we had the store function defined and then also the retrieve function.
01:34:25.992 - 01:34:55.650, Speaker D: And those correspond on the left to two different callable functions within our contract. So remember, the store function takes in a number. So does anyone have a favorite number? Shout it out. Four. I heard four. So I'm going to set four as the store number by clicking Store. Again, this is a transaction, so I'm going to confirm the transaction.
01:34:55.650 - 01:35:19.770, Speaker D: You can see it's pending down here. And then if all goes right, once this has posted, we can retrieve whatever the number is in state and hopefully it will also be four. I know it will be because my code always works. You're supposed to laugh at that. It's not true. My code never works. But let's retrieve.
01:35:19.770 - 01:36:12.014, Speaker D: And you can see down here that decoded output we retrieved was four. And so just to prove this really works, I'm going to update it to 4000 and store this new number on chain. So I'm posting a new transaction to store the value, and then we'll retrieve the new stored value and it should be 4000. Okay, so the transaction posted and let's retrieve that value. 4000. Sweet. So this is how you can interact with the contract within remix, but you can also do this from a front end in a very similar way to how you would call an API.
01:36:12.014 - 01:36:54.618, Speaker D: I'm going to show you a link to another tutorial for how to call from the front end. But this walkthrough was really just to show you how quick and relatively easy it is to deploy a contract. Because I know when I was starting out, this was something that intimidated me just because I don't know why it did it shouldn't have. But I've got all of these steps within the presentation, so you can look at it later. But just back to this. Here's four more developer resources. We have our Dev library on Notion, the Polygon Documentation Polygon Academy, which has four levels of different courses that you can take after the hackathon.
01:36:54.618 - 01:37:17.026, Speaker D: And then also some web, three concepts from the Ethereum Foundation. If you're building with us, we would love for you to tweet. This is our Twitter account. Tweet, tweet. Tell us what you're building on polygon and our hashtag is hashtag on Polygon. And then the last thing to plug is another hackathon we have going on. It's actually a two month hackathon called Biddle It.
01:37:17.026 - 01:37:48.814, Speaker D: And this is a great way to keep learning in Web three, improve your skills. We have a bunch more workshops that we'll be running. It's a great way to meet friends and network. This is also fully virtual, so if your friends weren't able to make it out to New York, you can still totally hack with them and connect with other builders by searching for them on our social media using our two hashtags. One more plug. We're also doing a video series called Wagme with Polygon. Some of my beautiful coworkers, Mitch and Rahat, have been filming different clips hey, guys.
01:37:48.814 - 01:38:07.814, Speaker D: But they would love to meet you and hear about what you're building. And we'll get it on video. We'll make it look super cool. So we would love to see you at our booth. And thank you again. I'm Steph. I'm Oceans 404 on Twitter and this whole presentation and the slides can be found at this tinyurl, so tinyurl.com
01:38:07.814 - 01:38:10.900, Speaker D: polygon ethnyc. Thank you so much.
