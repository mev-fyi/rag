00:00:00.410 - 00:00:12.106, Speaker A: We've got Sachin and Tarun who are going to give their presentation and we've got time for questions and answers at the end. Here you go, Sachin.
00:00:12.298 - 00:00:39.012, Speaker B: Okay, cool. Thank you. Thank you Heather, for the intro. I'm just going to share my screen quickly and then we can just start. You can see the screen. Hello. Yeah.
00:00:39.012 - 00:00:59.340, Speaker B: All okay, cool, cool. So, thank you guys for joining in. Let me start off with a quick intro. I'm sachin Tomur. I am the CTO and co founder of Biconomy. And with me I have Tarun Gupta who is a platform lead engineer at Biconomy. So we are going to be presenting the session today.
00:00:59.340 - 00:01:49.340, Speaker B: So in today's session, we'll cover a bit about Biconomy, what we are doing, what problem we are solving, and how we are solving that problem. And then we'll discuss about different use cases, what Pycony enables for the DApps in the Web Three space. And then we'll also show you a live demo. We'll integrate Pyconmy in a sample, ERC, 20 token transfer application and we'll show you how the Pyconmy solution can be used in an application. And then at the end, Tarun will discuss some more use cases of Pyconmy. And then we'll talk about some bounties we have. And then we would be open for any question and answers.
00:01:49.340 - 00:02:55.168, Speaker B: So let me start off with introduce Biconomy, what Biconomy is. So, as you can see, our vision statement is we are here to simplify the Web Three experiences and we are doing it with the blockchain transactions for the starting. So what we have built is we have built a scalable relayer infrastructure that any DAP can plug and play in their application in just very easy three simple steps. And what it enables is it just improves the user experience on that application. It just takes the user experience to the next level and we'll talk about what friction points are there when a user use an application built on blockchain technology today. And then we'll showcase how we are solving those problems. So one question that will come in anyone's mind is why should I use Biconomy like what it does? So, let me start with discussing the problem statement here.
00:02:55.168 - 00:03:48.672, Speaker B: So, let's say you are creating an application on Web Three using blockchain. So right now, building a Web Three application is itself not an easy way to build an application. But even after building the application, when you ship it to the market, when it comes to use that application and the end user uses it, still there is a lot of friction points today. And what these developers do is, of course you can't just ship a DAP that is not easily usable by its end users. So of course the developers would want to solve this user experience problem. So what they do is they try to solve it in house and of course it will take some time, some development time. So we have surveyed many applications in this space.
00:03:48.672 - 00:05:25.600, Speaker B: And we came to a conclusion that it would take up to three months of development time to build a solution that will solve these user experience problems. And in terms of cost, it could take around $40,000 in the development and of course the maintenance will be required and you could end up spending around $4,000 in monthly cost for the maintenance of this solution that solved the user experience. And also when you do that, there are high risk involved because we have to consider the security point of view, the scalability point of view, and usually these are not the core competencies of the developers who are building the applications. So if we go down the stack of the stack of these technologies, when you build application, some of them are partially solved. You have solutions for node provider, server provider, you have these wallets out there. But when you see these unsolved components, the transaction management, the relayer infrastructure and the gas optimization, these are the areas that no one has actually covered properly and no one has put out a solution in a proper way that is easily usable by our applications. Of course, most people have tried to solve these problem in their own way, but there hasn't been any solution that is a complete solution that can be easily used by other DAP developers.
00:05:25.600 - 00:06:04.860, Speaker B: So this is what we are doing. We are providing this solution in the form of an SDK and an API that is easily used by these DAP developers and that is fast, safe and cost effective. We will explain what these fast, safe and cost effective mean while I show you the demo. And what are the advantages of using Pyconmy? As previously mentioned, it would take a lot of time to develop that solution, but we have already developed the solution. So you just need to integrate that in less than 2 hours. You can enable that solution in your application. There is no maintenance needed because we are doing all the maintenance on our side.
00:06:04.860 - 00:07:12.230, Speaker B: You just focus on your core business and there are lower risk involved because we take care about the security and scalability. And there would be no Oshit moments if you are going live with the DAP. And there are those moments where you see, okay, I did not see this, I did not think about the security or you end up having a lot of traffic on your application, but you are not able to manage that. So those sort of things will be removed if you use Pyconomy. And as I mentioned previously, we have surveyed those companies who previously were trying to build similar solution, but only for themselves. For example, Argent has a relayer infrastructure, but that is only applicable to the Argent application. But what we are doing is we are building a generalized solution that is used by any blockchain application that you can think of, be it in the gaming space, be it a wallet, be it a Dex or any social network platform.
00:07:12.230 - 00:08:24.244, Speaker B: So our solution is pretty much generalized. Next, why Devs loves Pycony and I have not written it on myself. Devs do love Biconomy because we have been hearing feedback from these developers that Biconomy is really simple to use and we are doing what is actually needed in the space and that too providing the solution in a very simple form. So let's see what this simple solution means. So when we were building this solution, I am a developer myself, when I use a third party solution, I don't want to spend more than a day in integrating that solution. So while building the solution, we always kept in mind that this has to be very easy to integrate for the developers and it has to of course function properly and it has to properly solve the problem which we are solving. So we ended up building this infrastructure and these HDKs and APIs using which you can access those infrastructure.
00:08:24.244 - 00:09:14.840, Speaker B: And you can see like here, three lines of code are there and I'll show you these three lines of code only when I show you a demo that only these three lines of code can actually change the user experience in your application. And apart from let's see what features we provide, gasless transaction is something which we provide. So if a user uses an application that has integrated by economy, he does not have to pay for the Gas fees. That sort of user experience we enable. Once we process your DApps transaction, we make sure that we optimize that transaction in terms of Gas as much as possible. So you don't have to overpay for the gas for your transactions. We have a dashboard for the developers.
00:09:14.840 - 00:09:45.552, Speaker B: They can easily manage their application. Our solution is blockchain agnostic. So we kept in mind right from the day one that whatever we are building, the whole solution should be blockchain agnostic. Because we are seeing these multiple blockchains out there, each one solving a different problem in a different way, but we are agnostic to it. For example, we are live on Ethereum main net. We are live on Matic network. That is L2 blockchain.
00:09:45.552 - 00:10:09.004, Speaker B: We are live on XDI blockchain. That's another L2 solution. And we are looking to integrate our solution into more blockchain. So that gives us more exposure there. And we will talk about the L2 interoperability. We have been hearing a lot of stuff about L2 recently. So our solution is actually interoperable between layer one and L2.
00:10:09.004 - 00:10:42.112, Speaker B: And Tarun will discuss more about that later. So this was about the developer experience. Let's talk about the end user experience. Let's say a developer has integrated Biconi. What will the end user get when they use the transaction? So they get to experience no stuck transactions once you do the transaction, we take the responsibility of getting that transaction included in the next block. So you don't have to worry about it. You get free transactions.
00:10:42.112 - 00:11:57.710, Speaker B: The gas is subsidized by either a third party or by the DAP developer itself. And recently we are enabling another use case in which the DAP developer don't have to pay on behalf of their users, but the user itself can pay the gas fees, but not in the native currency of that blockchain. For example on Ethereum you don't have to have Ether to pay for the gas fees. You can just pay in the ERC 20 token itself, which you are dealing with in that particular transaction. So those sort of use cases also we are enabling, as I mentioned, gas optimized. We make sure we optimize for gas as much as possible by applying various techniques. And the last thing is the end user don't need to think about accruing the Ether for paying the transaction, they don't need to think about where they can get this gas and they don't have to make financial decisions in each transaction like how much gas price should I put so that my transaction will be included? So all those sort of friction points are removed if adapt integrates Pyconi solution so the user onboarding becomes really easy.
00:11:57.710 - 00:12:47.340, Speaker B: User gets to have a web two experience like feel in your web3 application. So those are the benefits for the end user and who is using Pycony today. We started our beta in around 4 May and then since then a lot of applications have come on boarded. And for example, Curve is one of the big applications in the D five space. The Curve is using Biconomy to enable the gasless deposits of BTC in two of the BTC pools. On curve matic is actually a L2 blockchain. Matic is using Pycony solution to enable that seamless experience on that L2 blockchain.
00:12:47.340 - 00:13:53.860, Speaker B: Badbit is a casino game on L2 that is using Pycony and Idle Finance is the one Sapien is there. So almost around more than ten applications are using Bicon Me right now. Some of them are already on main net, some are on their way to the main net and we are seeing very exponential growth in the DAP onboarding Biconomy. So let's take an example of Curve finance. So when Curve Finance integrated Biconomy in two of the pools which you can see is Rent, BTC and SPTC, they were able to do more than 10 million in deposits and swap in those two pools in just a single month. That's what you can achieve if you improve the user experience of these applications today. And Biconomy makes it really easy to enable these experiences and recently also integrated byconmy in its governance voting.
00:13:53.860 - 00:15:04.600, Speaker B: So you should be able to do the voting without worrying about the gas in your wallet. And for example, when Idle Finance integrated Biconomy, it saw 40% increase in the number of users and 1.2 million in deposits on the idle platform in just two months and they have been hearing this feedback from the end user that the experience is really seamless. Now, as I mentioned earlier, you get to have more user, you get to retain those user because as compared to other applications, the experience is really superlative in the applications. That was a lot of chitchat. Let straight to the demo part where I can show you a simple application which I have built for this hackathon sorry, this workshop. So here you can see this is just ERC 20 token transfer and mint application.
00:15:04.600 - 00:16:06.200, Speaker B: I have just named the token as Biconvi token here we don't have a token right now so you can see this is a test token. I can show you the code second, so this is the token code, just a normal ERC 20 token. I have taken the code from Open Zeppelin, just a regular transfer functionality, main functionality and if you see the transfer function, just a basic transfer. So one thing to note here, usually you have this message sender here in the transfer method but this is how OpenZeppelin has written it. They have called a method. But eventually the method is actually returning the message sender only and let's try to do a transaction. And let me show you in my MetaMask.
00:16:06.200 - 00:16:37.768, Speaker B: This is the user. It does not have any ether. And if I try to let's say this already has 300 Piconi tokens. If I try to mint ten more tokens, of course, as usual it will ask for the gas payment from my wallet. And of course I don't have gas, so I have to reject this. I just cannot mint the tokens unless I have the ether in my so that's the problem. Those are the friction points you have in today's application.
00:16:37.768 - 00:17:20.500, Speaker B: And even if I had ether in my wallet, I would still need to worry about the gas prices. Like, what gas price should I put so that my transaction quickly go through. And that usually result in high gas prices on the network. Also when people keep on selecting high gas prices. So these are the problem. Now let's come to the solution. So talking about the solution, it's a two step process so as I mentioned, you have this message sender dependency in your smart contract so let's understand first how the metatransaction works.
00:17:20.500 - 00:18:24.116, Speaker B: So there is an application and here's the blockchain you initiate a transaction, it directly calls a method on your smart contract and you pay the gas fees, transaction is done. But in case of meta transaction, there is a third party relayer in between so you don't directly send the transaction to the blockchain, you send the transaction to a third party relayer and that relayer actually signs the transaction and sent to the blockchain. So eventually when it lands on the smart contract, the message sender would be the Relayer's address, not the user address. So that's why we need to get rid of this message sender dependency in your smart contract. And for removing that dependency is what we call enabling native metatransaction in your smart contract. There could be multiple ways to do that, but we have created a standard for that. If you want to use that, you would quickly be able to enable those native metatransaction feature.
00:18:24.116 - 00:19:14.980, Speaker B: Let me quickly show you this smart contract which we have. So this is a metatransaction standard repository. You can just go there, go to source contracts. This is the method which the main important method is execute metatransaction that has the capability to call any method in your smart contract. And this method take care of the signature verification from the user and the replay protection strategy. This is the main method and another method which we need to consider is this underscore message sender. So as we saw like in the token transfer, we have used this method.
00:19:14.980 - 00:20:39.328, Speaker B: But instead of just returning message or sender, we have implemented this logic which will take care to retain the ownership of the user when a user do a transaction via a relayer, okay? So when it comes to enable that, all you need to do is inherit this basic metatransaction smart contract. So this basic metatransaction just take the signature, just operate on personal signature and for EIP seven, one two type signature, we have another smart contract that you can just inherit and replace all the message sender occurrences with this method which we have already done. So this is all you have to do on the smart contract side, let's come on the client side. So on the client side, this is a basic react application. I have these, you know, on token transfer, on token Mint, on for example, while Minting the token, I'm just, you know, calling this Mint method directly. But when you enable native metatransaction using this way, by inheriting those basic metatransaction here, you need to call that execute metatransaction method and pass the Mint method information in this function signature. So that this method will first verify the user signature.
00:20:39.328 - 00:21:12.272, Speaker B: It will increment the nuns for replay protection. And then using the function signature, it will actually call the actual function and then your transaction would be executed. So to make it really easy for you to do client side changes, what we have done is we have created this gist for you. You just need to follow the instruction here. You just add these dependencies in your code. Let me add these. You initialize web3.
00:21:12.272 - 00:21:51.416, Speaker B: I have already initialized my web3 here. I'm just using the provider by the MetaMask window ethereum and we have some helper methods. You just copy paste these method and these methods works for any application. So you just copy paste them. I didn't copy perfect. So one last step. For example, whenever you are calling this transfer method or Mint method or any method directly, all you need to do is you need to just call this execute metatransaction method.
00:21:51.416 - 00:22:27.576, Speaker B: Now let me copy this and on token Minting here, I am calling this Mint method. I just pasted this and let me verify all the variables are in proper order or not. User address is in my selected address variable. This function signature, I need to get it from here. So I just rename this variable to function signature. And instead of calling the Mint method, what I do is I just encode this method into the function signature and pass it on to this method. I have the contract object.
00:22:27.576 - 00:23:04.420, Speaker B: My contract address is in this variable. So I change it to this and this is the chain ID. So this demo is on Coburn network. So I've used 42 here and that's it. Like you have just enabled native metatransaction in your application. Let me copy this on the token transfer functionality. Also, quickly just rename this function signature and instead of calling the actual transfer method, what I do is I do the encode API.
00:23:04.420 - 00:23:58.070, Speaker B: Let's see how it has affected our UI. Let me try to do the Mint operation again. We try to mint ten tokens. So here you can see instead of asking for the gas, it is initially asking for the signature. And then after the signature is done, now it is asking for the actual transaction. So you must be wondering what different we have done here because I still am not able to do the transaction and that's because we have not integrated by convey yet. What we have done is just enable the native metatransaction functionality in your application.
00:23:58.070 - 00:24:31.132, Speaker B: But the best part is you see this transaction. Now this transaction can be submitted by anyone. It doesn't have to be the user itself. That's the thing we have enabled right now here. And of course I don't have any ether, so I have to reject this application. Now let's do the magic part where we integrate Biconomy and we would be just able to mint those tokens without having gas in our wallet. So, for doing that, let me head to the Biconomy documentation.
00:24:31.132 - 00:25:25.696, Speaker B: You can refer here at docs Biconomy IO in the Getting Started section. If you see there are two steps to integrate Biconi. First is you have to go to the dashboard, you have to register an account and upload those smart contracts and selecting those methods from the smart contract, which Tarun will talk about, he'll just give you a dashboard walkthrough after said I'll just log in with my account here, I can see these tabs. So I've already created this application. I'll just go to this tab and if you see in the documentation it says and copy the API key generated for adapt. So don't worry about how this is generated. For now, we'll just keep this.
00:25:25.696 - 00:26:03.660, Speaker B: Next step is to integrate Biconomy SDK, which we call MexA in the client side code. So all you need to do is install Pyconomy let me do that differential. So while it is installing, let me perform other steps. So, these are the three lines of code which I was talking about. Just import Bicone in your application. Let me do that. You initialize the Bicony object and I'll do that in my init function.
00:26:03.660 - 00:26:24.880, Speaker B: Here where I'm initializing my application. And just after I have initialized my provider objects. And I have already defined the Bicony object on top. So I'll just remove this const keyword here. Bicony constructor. Just need a web3 provider object. So it could be any provider provided by your wallet if it's MetaMask.
00:26:24.880 - 00:26:57.052, Speaker B: I have used MetaMask. So I am just using mineral ethereum. I am just going to pass this provider object here. And it needs an API key. And this API key which I just showed you on the dashboard for now, we're just going to copy this and paste it here. One last initialization. Yeah, one step is now we have to initialize web3 object with Bicony object instead of the Web three provider which you were using before.
00:26:57.052 - 00:27:26.372, Speaker B: So I'll just use bicon me here. I'll just save. And this is the last step, the initialization step. No business logic here. Once the Biconomy object initializes, it will emit this Biconomy ready event. And whatever initialization you want to do in your application, just do it in that section. So here I am, initializing my contract.
00:27:26.372 - 00:28:15.098, Speaker B: I'm getting the token symbol, the token balance, all these things I can move here in this section. And that's it. That's all it says on the documentation, nothing else. Let this install it. And now I'm hoping we should be able to mint those tokens without paying any gas fees. My laptop. Okay, perfect.
00:28:15.098 - 00:29:09.240, Speaker B: This has been installed. Application is okay, showing some error. Let me stop this application. It I'll just restart it. This is some library error. Let's see it. Starting the server.
00:29:09.240 - 00:30:24.670, Speaker B: Okay, let me install this. Okay, I have used these dependencies, but I did not install it. Let me do that. Events you. So while this is being installed, let me recap what I have done so far. I had this token. I enabled the native metatransaction capability in this smart contract by inheriting this basic metatransaction and by replacing the message sender by this underscore message sender method which is available inside this contract.
00:30:24.670 - 00:31:08.120, Speaker B: And after that, what I did is I went on my client side. I go to this list. I followed these steps, import these dependencies, add those helper methods. And instead of calling the actual method, for example, Mint or transfer, what I did is I called this execute metatransaction method on token Mint here. And then I just pass a function signature to this. So, okay, the dependencies has been installed. Let me run the project now.
00:31:08.120 - 00:32:12.122, Speaker B: It's taking some time. Perfect. The application has started. It is initializing it. It perfect. You can see again, I have these 300 Biconi tokens. Let me again, check the gas.
00:32:12.122 - 00:32:37.186, Speaker B: If I have gas in my wallet. No, I don't. And let me cross check this Minting address also. Where I want to mint this, I just copy and I just paste here. Let me try to mint 100 more tokens. I click mint. It will ask for the signature just to verify that I have initiated this Mint operation.
00:32:37.186 - 00:33:02.010, Speaker B: I sign this, and this should be here we go. And you see, the transaction happened. It was relayed by Biconomy relayers, and soon we know it will confirm. And this 300 should change to 400 because we are minting more tokens here. It's on COVID network. So anytime, yeah, here we go. You can see the balance is updated.
00:33:02.010 - 00:33:50.014, Speaker B: And we can actually check the transaction on Coven Etherscan Explorer. Here you can see 100 tokens being minted to this address. And one more important thing to see here, the from address is not the same as the user address, because this is the relayer address, the Biconomy's relayer address, who actually paid for the gas fees for this particular transaction. But for the end user, he doesn't care who pay the gas fees as far as he's minting these tokens without paying any gas fees. This is the demo I wanted to show you. And after enabling native meta transaction, we just imported by economy. We just initialized Bycony and we just changed the provider object in the Web Three object.
00:33:50.014 - 00:34:25.270, Speaker B: And we did not need to change anything else in our code. So, yeah, that's how easy it is to integrate Biconomy. And you could see how drastically the user experience was improved in this particular application. So let me come back to the presentation and I'll hand over to, you know, to discuss more use cases of Pycony. I'll stop sharing here. Tarun, you can take over. You there, tarun.
00:34:25.270 - 00:34:39.754, Speaker B: Okay, looks like he dropped.
00:34:39.802 - 00:34:42.142, Speaker A: He's just joining again. There we go.
00:34:42.196 - 00:35:05.846, Speaker B: No worries. I can continue. I can continue. So, we just saw this one use case of Pyconmy where we did those gasless transactions. Here is another use case of Picordmy. So, there is one application that is handling payroll for the companies. Here.
00:35:05.846 - 00:35:52.390, Speaker B: You are trying to do some operation here. So this application is actually on layer one also and on L2 also. So it needs to interact with the L2 also and layer one also. But if you would have used the Web Three application, you would need to change those RPC endpoints in your wallet to interact with a different blockchain every time. But using bycon, you can actually get rid of those situations. And as you can see here in this demo, which I accidentally skipped, so here the user is trying to initiate a transaction. And if you see here, it is Rinky By network.
00:35:52.390 - 00:36:23.054, Speaker B: See here? Rinky by test network. So it is on layer one. But the transaction which user did using Biconomy actually executed on L2. So being on layer one, you were able to interact with the L2, which in this case is Matic network. And you can see this transaction on the L2. So this is another use case of Pyconmy using which you can drastically improve the user experience on those applications that deal with layer one and L2. Also.
00:36:23.054 - 00:37:03.320, Speaker B: And this is a link which Matic Network team has prepared a sort of documentation on how you can achieve this on Matic network. You can refer to that demo and talking let's summarize what we did so far. So we initially enabled the native metatransaction in a smart contract by following our metatransaction standard. We deployed the contract. I already deployed it. Okay. I think Tarun has shared his screen.
00:37:03.320 - 00:37:05.800, Speaker B: Tarun, did you share the screen?
00:37:11.520 - 00:37:14.300, Speaker A: He seems to be muted. I've just unmuted him.
00:37:14.450 - 00:37:30.050, Speaker B: Yeah. Okay, so you can carry on from here. I was just talking about like I have explained the L2 interaction part. You can carry on with this slide now.
00:37:31.540 - 00:38:31.590, Speaker C: Yeah. As you have clearly seen how to integrate economy, and this is like the summary point. So to summarize, the first step you need to do is just enable native metatransaction in your smart contract by following maybe our standard, which is like a basic metatransaction solve file. And then you can deploy it on any network. If you're using Biconomy, you need to check our documentation, like, what are the main networks we support on testnet as well as on mainnet? And then you just upload the contracts address and its abi on Biconomy Dashboard, which I'm going to show in the next section. And then you can enable metatransactions on specific methods. So in the previous example, you can see the Mint and transfer function should have enabled metatransaction on the Dashboard before integrating the max size decay in the client side.
00:38:31.590 - 00:39:32.366, Speaker C: And then just simply change your web3 provider to Biconomy provider with the API key provided by our Dashboard and you're done. So now I think we can go to documentation. This is the documentation which is docs by Economy IO, and you can see more detailed information of all the things we have shown in the demo as well as in the PPT. And everything is there, as you have already seen how MexA is integrated in the front end. So I think only the Dashboard part is left. So let me give you a detailed overview like how to register your application on our Dashboard. So I have already created an account.
00:39:32.366 - 00:40:23.450, Speaker C: If you are a new user, you can just go to register now and you can register the application. And after successful verification of the email, you will be able to register your application. So as I've already verified my email, I'm going to register a new application. So you can see and you have multiple options for the test networks. So we have various Propstand, Rink, B, Coven, and various L2 networks as. Well like Xdai and Matic and for the main net access definitely hinted to contact us. So let me do it on COVID I guess my internet is slow.
00:40:23.450 - 00:41:51.712, Speaker C: Yeah so my DAP has been created and if you go inside the DAP you have multiple options here. One is like you can see API key which is basically as the single most important thing we need to know like you are an authenticated DAP on our platform and you have one more thing is API whitelist token which simply means when you generate this token you can whitelist various contract addresses. So let's say you want to only whitelist certain contract addresses for which you want to enable metatransactions. You can do it via simple API and that API is being mentioned in the documentation and then you have the section configurations in which you can just restrict various domains website URLs through which you want to relay your transaction. So you have a DAP registered on any domain you can just whitelist here. And now you can see this action sections in which we have provided this meta transaction limit basically to stop abuse for the gas fee you are sponsoring for your users. So we are providing metatransaction limits on various levels.
00:41:51.712 - 00:42:45.300, Speaker C: So the first thing is like DAP limit. So DAP limit simply means let's say you have a DAP and you want to sponsor only certain number of meta transactions on this DAP or maybe certain amount of dollars worth of ETH for this application. You can easily on this limit from here. So if you go to addle limit section you can see type like you can apply a limit on ETH, amount of ETH on number of metatransactions. So let's say you want to restrict ten meta transaction for this DAP for a duration of for every day. So you can just save this limit. Yeah so you can see the DAP limit is being enabled and now this DAP will only have ten meta transactions provided by economy.
00:42:45.300 - 00:43:28.084, Speaker C: You can also have user limit. User limit simply means enabling limit on per user level. It means to sponsor certain amount of ETH or number of transactions to particular address. So yeah, this is like a user limit. You can also see here you can do this with this only per user level and then you have this API limit. API limit simply specifies what are the methods of your contracts you want to apply limits on. So let's say you have Transfer or Mint method and you just want to.
00:43:28.122 - 00:43:28.710, Speaker B: Apply.
00:43:30.440 - 00:43:49.944, Speaker C: 0.2 e only for this method. So you can just specify that also here and then you can add Smart contract. So I'm going to show you how to add smart contract. So here there is two sections. One is smart contract and other is smart contract. Wallet.
00:43:49.944 - 00:44:21.690, Speaker C: So we also provide support for Gnosis. So if you have already created your proxy contract using Gnosis and you want to enable metatransactions. Through that, you can do it via economy and just upload the Gnosis abi here. But for the sake of this demo, just upload, I think, normal contract address in its Abi. So I'm uploading it. This is the address.
00:44:25.340 - 00:44:27.880, Speaker B: This is the Abi.
00:44:29.020 - 00:45:16.250, Speaker C: And you can see the smart contract is being populated here and the type is SC. And then you can see this DAP API section where you can manage your contract methods. So if you go inside it, there is no currently APIs registered. Then go here. And here you can see your contract is populated with its methods. And to enable metatransactions, we need to select the method, like to which we want to enable metatransaction. So, as Sachin explained, if you are integrating that basic metatransaction solve file, you need to choose execute metatransactions because it takes like function signature and the address.
00:45:16.250 - 00:45:44.240, Speaker C: But let's say you have any custom implementation of yours of the basic metatransaction, you need to support this native meta transaction on that particular method. For now, we will just include this execute native meta transaction and we can name anything here. And we need to take this box. Like on this method, we can just.
00:45:44.310 - 00:45:45.250, Speaker B: Add here.
00:45:50.420 - 00:46:48.240, Speaker C: Mind is released. Yeah, see that the method is registered like execute metatransaction. And we have this API ID. As let's say you want to use Biconomy infrastructure through mobile app and you don't have any client side application in the browser. You can also use this API provided by Biconomy and in which if you want to enable metatronic change, you can just pass this API ID and you can refer this in the documentation. So, yeah, that's pretty much it for the dashboard. And I think let's come to Bounties now.
00:46:49.250 - 00:46:53.200, Speaker B: Yes. Okay.
00:46:54.070 - 00:47:33.870, Speaker C: Just before that, I also want to show you something. So, yeah, in the documentation, if you are like a complete beginner and you don't really know how to make a DAP and how to integrate native meta transactions, you can follow this tutorial, native meta transactions. So in this you have complete tutorial like how to build your first DAP and then enable metatransaction and then integrate by economy. So you can also refer that. And then in the API section, you can see we have various APIs getting the status of the limits, whitelisting API, and directly you can interact with the native metatransaction.
00:47:38.690 - 00:48:45.270, Speaker B: Awesome. Thank you. Thank you, Tarun, for showcasing the documentation and the dashboard. Let me move on to the bounties quickly and then we can wrap the presentation and we can open the session for Q-A-I closed my browser accidentally. Let me open that workshop. We have four bounties available in this hackathon and they are worth $4,000 prizes. So we have divided it into four different bounties, which I'll explain just a minute.
00:48:45.270 - 00:49:28.582, Speaker B: Cool. Yeah. So, as I mentioned, $4,000 worth of bounties to be awarded to four teams. And let's quote one by one with the bounties. First one is L2 exit. So we have been seeing this problem recently with the L2 getting traction recently. But this L2 exit problem is there where you cannot quickly exit from L2 to layer one.
00:49:28.582 - 00:51:02.998, Speaker B: So what we want from this hackathon from the hackers is to come up with a solution that provides an instant layer to exit. And one way of doing at doing this is by maintaining a pool of tokens on both layer one and L2 and by making a bridge between layer one and L2. And let's say someone exits from L2 so they transfer those tokens to you and you get to have those token in your pool and on the layer one you instantly release those tokens on the corresponding token on layer one and you could charge maybe some transaction fees for enabling the instance exits. And what we want developers to do is integrate Biconomy in the whole experience and make the whole experience cashless whether you are going from layer one to L2 or L2 to layer one. So this is like the biggest bounty we have kept like $1,500 price for that. Second bounty is regarding I mentioned previously, we are enabling those ways in which the end user itself can pay the gas fees in ERC 20 tokens and as long as they are stable tokens, that's perfect to accept the fees in stable token. But when it comes to accepting the fees in non stable tokens there is a risk because that actual token might be volatile and the price of that might go up and down.
00:51:02.998 - 00:52:12.282, Speaker B: So what we need from you guys is to find a solution that if not remove completely, but minimize the risk or volatility of the situation where relayer accept the payment in the ERC 20 token as gas fees and the user gets to have this seamless experience though they don't have to pay the gas fees in Ether. But at the same time we also need to remove the minimize that risk of accepting those payments. So that's the solution we want from you guys. Third is Pyconmy explorer. So this would be a pretty cool UI explorer to build that could track all Biconomy transactions because eventually all the transactions are public on Ethereum blockchain. So you just make a nice UI to track all those transactions to show some the gas usage data for a particular transaction or for a particular smart contract address by showcasing it. Maybe a graphical user interface or pie chart or something like that.
00:52:12.282 - 00:53:13.402, Speaker B: So a very nice user, the Biconomy Explorer where you can track all the transactions related by Biconomy and all the gas usage and all the events that might be emitted in those transactions. Fourth, we have kept an open track. Any awesome idea you can come up with be it in DeFi gaming or I mean recently NFT Space has been gaining a lot of traction so maybe you can come up with a nice idea using Pyconomy showcasing a use case with the NFT space. So anything you can come up with in this particular track. Yeah, that's it. Regarding the Bounties and you could check our documentation for any technical help. You can check out our medium page for all the articles we have published and you can actually reach out to us on the Telegram, on the discord.
00:53:13.402 - 00:53:45.900, Speaker B: Also we are almost active all the time because we are a distributed team around the world and we also have business hours, I think every Saturday information regarding which will be uploaded on our website. So you can book those office hours with us every Saturday and ask questions if you have any doubt regarding integration. So yeah, that's it from our side. Thank you and we are open to any questions now.
00:53:49.450 - 00:54:09.590, Speaker A: Great, thanks guys. If anyone's on the zoom call who wants to ask a question, just go ahead and unmute yourself, it seems.
00:54:10.920 - 00:54:11.990, Speaker B: Could you.
00:54:17.560 - 00:54:26.250, Speaker C: Hello. Is there any possible chance you could use this to AirDrop NFTs gasless to people then?
00:54:26.780 - 00:54:47.010, Speaker B: Yeah, as long as those NFTs have support of this native meta know you could just AirDrop those to anyone and that person should be able to transfer those NFTs without having cash in their wallet using Biconv. So yeah, that would be a pretty practical use case.
00:55:04.790 - 00:55:05.186, Speaker C: I think.
00:55:05.208 - 00:56:57.722, Speaker B: I have a question in the chat business hours PDT. Yeah, I think the business hours during the daytime PDT time zone, I think the exact time I think we need to update, you can check out our telegram or we'll update it on the website. Also any questions from YouTube stream while anyone ask any questions like I can iterate over here. That the solution which we have made is very general in nature. So you could apply this solution to any blockchain transaction so it's not specific to any particular type of tap or anything like that. Any blockchain transaction can be made gasless using Pyconmy as long as you follow the certain standards and steps. So that's why we are actually hoping for some pretty cool use cases from this hackathon because the solution is very generic.
00:56:57.722 - 00:57:10.860, Speaker B: Apply it to any field and come up with some unique solutions. It.
00:57:50.280 - 00:57:58.340, Speaker A: Great. Thank you guys, that was an excellent workshop. I know a lot of people are going to be excited to use Biconomy for Ethan.
00:57:58.920 - 00:58:06.948, Speaker B: Thank you Heather, for arranging this session and it was great, great presenting. Thanks. Awesome.
00:58:07.114 - 00:58:08.150, Speaker A: Thanks guys.
00:58:09.720 - 00:58:11.810, Speaker B: Thank you. Goodbye. Thank.
