00:00:07.290 - 00:00:22.202, Speaker A: So welcome to basecam. Cohort four. This is session one, one of seven. Okay. My name is David Barretto. I'm one of the developers advocates from Stagware. Focus on stagnet.
00:00:22.202 - 00:00:50.570, Speaker A: Of course. You can see here my socials, my Twitter, my blog as well. And I'm here with also Manmeet and Omar. We're also developer advocates from Stackware. So in this cohort of Basecam Cohort Four, we're going to have seven sessions in seven weeks. Each session lasts for 2 hours. What we expect roughly is that out of those 2 hours, 90 minutes is going to be the presentation or some light coding.
00:00:50.570 - 00:01:25.650, Speaker A: We have 20 minutes for questions which you don't have to wait for the end or just whatever question you have. Use the Q and A and Manmit and Omar will do their best to try to answer them. If any of you don't know the answer, you want to discuss it, please omar, Mamit, interrupt me. We have a discussion live as well. We will share in the Q and A for you guys after the session in an email so you have that as a reference. We will have ten minutes break as well. And just so you know, the last session of Basecamp Core Four is going to happen May 24.
00:01:25.650 - 00:01:45.726, Speaker A: So it's going to be kind of like two months in the future. We have some homework, but it's optional if you want to do or not. Just take basecam as a way to learn everything about strengthnet and Cairo. It's up to you how much you want to get out of that. So we don't have any formal aggravation. We're going to be reviewing the code. We're just here to support you.
00:01:45.726 - 00:01:56.100, Speaker A: That's why the discord is important. If you get stuck with homework, go to discord, try to get support from your peers. We will also get to hang out there to help you guys as well.
00:01:58.230 - 00:02:02.514, Speaker B: David, there's a question regarding the slides. Can we share the link?
00:02:02.552 - 00:02:26.380, Speaker A: Oh yeah, that's a good point. Yeah. Okay, let me share. Publish is there in a Q and A? Yeah. Type an answer. So it stays there in the chat as well. OK.
00:02:26.750 - 00:02:27.740, Speaker B: Yes please.
00:02:35.340 - 00:03:08.180, Speaker A: I should be working. Is it working for you, Omar? Can you open it? Or anyone in the chat can come in? Let me know if you can open the slides. Okay, cool. People are able to look at the slides. So as I mentioned, we're going to have seven sessions for a basecam. So today is about fundamentals, just the getting started, about everything. About STARnet Cairo, hopefully to have a basic dev environment set up in our machines and to deploy an example of smart contract to Stagnate so you get to interact with the network as well.
00:03:08.180 - 00:03:41.872, Speaker A: Session two next week is going to be a deep dive. So basically it's like a part two of this same talk today. Session three is actually about caro one going through the syntax and if any of you have been at stock there for a while, you will know that caro zero is a very different language from caro one. So we want to take some time to go through all the details about the syntax. Session four is about testing and how do you test cara one smart contract. Then session five is about the STARnet architecture. We will see some architecture today at a foundational level.
00:03:41.872 - 00:04:21.368, Speaker A: But then session five, we're going to go deeper into it. Session six, we're going to look at Cairo's architecture, because Cairo has a very specific CPU architecture that we're going to discuss there. And the final session is going to be about Starks, the ZK proof that underpins StarkNet. Okay, so some things that you should know is that after each session you will receive an email that's going to have a link to the recording. It's going to be a link to a YouTube video, a video that's going to be unlisted. So you will need the link to see it. We're going to also share the Q A from the session.
00:04:21.368 - 00:04:52.110, Speaker A: That's why we're trying to push people to have any question. Use the Q A because that way we can share with you after. So you have it as a reference. We're also going to send a feedback form because we want to hear from you guys. How do we improve basecam session only basecam as general, how do we improve for next session, for next week? So please give us your feedback. We're going to tell you what's going to be the homework in the email and also a form so you can submit your homework. In this case, any GitHub repo or your Stagnant address where you actually deploy it.
00:04:52.110 - 00:05:30.344, Speaker A: Use the Q A system to ask questions instead of the chat. And use Discord to get help from peers. So if you provide your Discord username when you register to basecam, you should already been added to a private channel on Discord in the Stagnant channel, the Stagnant Discord server. If you didn't it's because there are some issues. Either you were not part of the Discord server. So try to first of all get into the Discord for Stagware and then we will add you. Some people we were unable to actually add you because there's some rules about security, about the bots that we cannot bypass.
00:05:30.344 - 00:06:14.962, Speaker A: So I'm sorry that's one of you, if that's your case, please use this session to ask all the questions that you have. So for today's agenda, we are going to cover why Cairo, why Stagnate? So cairo the programming language stagnate. The layer two with Cairo is used. We're going to also see a basic view of the stagnet architecture. We're going to do also basic view of Cairo. One, we're going to discuss some of the tooling that you have available as a developer. We're going to have a little break and then we're going to do some live sessions setting up a basic dev environment from scratch.
00:06:14.962 - 00:06:52.994, Speaker A: So I'll be using in this case a VM with Ubuntu, so you can see the whole process from start to finish. And we also have that documented. I'll share the links to where that has been documented. Any interesting questions omar Manmit to discuss now live, you can vote on your favorite question, the Q A as well. So that gives us more visibility. We lost some admit. So this is some question here.
00:06:52.994 - 00:07:33.210, Speaker A: Which disco server channels is dedicated to the bootstrap, the bootcamp. Thank you. It's called bootcamp, sorry, base camp, corporate four. Yeah, that's inside of the stagnet discord server. All right, let's get started. So, why Cairo? So, I like to start this with actually a story. So, imagine you are the head of a space exploration agency in a small country and your task is to send a spacecraft, a small one, like a robot, to a planet, let's say Mars.
00:07:33.210 - 00:08:09.990, Speaker A: So of course you have to do a bunch of calculations. And the most important one is when is the right launch window in the best trajectory. So you use the least amount of fuel, so the rocket is the smallest as possible and it takes the least amount of time. So those competitions are very complex. To perform requires a lot of computing power. So probably you will go to your engineer, say, hey, could you ride in the algorithm in some very high performing language like Rust for example, so we can get those results. We can just know those two variables, the best launch window and the best trajectory.
00:08:09.990 - 00:09:16.630, Speaker A: So sure enough, they create the algorithm. But it's very complex because so complex actually requires a supercomputer to be executed in any reasonable amount of time. But you had the issue that you don't have a supercomputer because you are in a small country, you don't have access to a lot of resources, but there is a rival country that has been willing to help you out. They have one and they have offered to execute your code and give you the answer. But then you have the issue that sure, you can provide the code to them, to the arrival country, they execute it in their supercomputer and they will give you back the answer, right? So they give you those two variables, launch window and the trajectory. But then you have a problem. How do you know that that is the right answer? That is actually the result of executing your programming exactly the way you write it? How do you know that the supercomputer didn't malfunction like one bit flop doing the calculation? Or maybe there was some kind of sabotage, maybe even a small change in how the computation is performed could be a disaster for your space exploration.
00:09:16.630 - 00:10:43.430, Speaker A: So you don't have a way to meaningfully to be convinced that result is actually what the algorithm that you wrote or your team wrote actually was supposed to find so not even with any traditional language you cannot have that certain thing, not even Ros, not C, not any language. But with Cairo you actually can because Cairo is a provable language that when you execute it let's repeat the scenario this time you write the algorithm in Cairo instead of Rust you provide that code to the supercomputer of the Rally Country. But now then, because it's been used with Cairo, not only do we give you the result back, they also will give you a cryptographic proof that verifies or will let you verify the validity of the computation or the integrity of the computation. So now you can take that proof and you can use any regular computer and just verify the proof and that verification will let you know in non certain terms or in a mathematical certainty way that the result that you're getting is actually what was supposed to came out of the execution of your program. This is called computational integrity. So now if the execution is intentionally or unintentionally modified the proof will be invalid and you will know it right away, right? So there's no chance someone's going to sabotage your program or that there was some malfunction and you didn't know. You will know right away.
00:10:43.430 - 00:11:11.360, Speaker A: So with this, with Cairo and the fact that you get cryptographic proofs out of execution a regular computer, this case a laptop is able to keep a supercomputer honest and that is a superpower that only languages specialized like Cairo specialized for validity proofs can provide. Okay, just a SEC. Trying to make the Q A visible for me as well.
00:11:12.390 - 00:11:20.994, Speaker B: David, just one question here we have channel in Discord for do we do.
00:11:21.032 - 00:11:23.810, Speaker A: Someone actually provided basecamp cohort port that's the name.
00:11:23.880 - 00:11:29.080, Speaker B: Excellent, thank you very much shipping I saw that. Okay, perfect.
00:11:29.930 - 00:11:49.180, Speaker A: Yeah, if you provided your Discord username with your register you should be in the channel already unless you were not part of the Discord server so if you were not, try to join the Discord server for Stagnate and then we will review the list again and add the new people that enter the server later.
00:11:49.870 - 00:11:57.550, Speaker C: David, if it takes just a you, could you please add me so I can also take a look at the questions and be able to answer them on zoom.
00:11:59.410 - 00:12:01.786, Speaker A: To add you to Discord.
00:12:01.978 - 00:12:04.320, Speaker C: Just the Q-A-I have the.
00:12:08.610 - 00:12:10.450, Speaker A: Added you can just open the window.
00:12:11.110 - 00:12:12.770, Speaker B: Yeah, it's opening.
00:12:14.950 - 00:12:16.180, Speaker C: We can say that.
00:12:16.890 - 00:12:28.150, Speaker B: Yeah, no problem, go ahead, David. Okay, so we have a lot of questions here but we're trying to answer them and let you know what can we answer live?
00:12:28.300 - 00:13:11.880, Speaker A: Let me just try to answer a couple of them. Maybe you can type the answer as well so they have it as a reference but let me just see interact with the audience let me see some of the questions at least the one have been voted that have not been answered already, sir, I skip the intro. So what do I have to do to graduate? Can attend all the sessions 100% do the work we don't have a formal graduation this time we're going to give you homework it's up to you if you want to do it or not just take base cam as a way to learn as much as you want from Cairo and stagnet. This is because we don't have capacity to assess hundreds of people submitting homeworks every week a reliable way and we realize that the goal here is just for you guys to learn more or anything.
00:13:14.010 - 00:13:23.080, Speaker B: We can do cool stuff you will see that it goes to something it will be worth it.
00:13:24.090 - 00:14:23.444, Speaker A: Fox says we really need have to focus on Cairo One. No reason to do Cairo Zero anymore. Yes, in this base camp we're not going to do any Cairo Zero. It's just all about Cairo One this time just be mindful car one is super new was just released to Mainnet very recently. So it's going to be a little bit rough around the edges but it will improve over time. How can we sure that the proof is not tampered? So the probability of you being able to create a cryptographic proof that is going to fold the verifier is one over 1 billion times 1 billion times 1 billion times 1 million so it's very small that you can actually do that. To understand exactly the reason why, you have to wait until session seven when we discuss actually stark the math behind these validity proofs please turn on caption.
00:14:23.444 - 00:14:39.250, Speaker A: It will be super helpful. You know what? I try less time. I don't know where it is. Can you omar, you're the host. Can you take a look to see if there's a way to enable captions? I know the last time or some previous time we were able to I just don't remember where.
00:14:42.020 - 00:14:46.210, Speaker B: Sure I'm looking for this I don't promise anything.
00:14:48.040 - 00:14:56.870, Speaker A: All right, let me continue. Omar, if you see any interesting question, please interrupt me and we can have a discussion. Sure.
00:15:02.120 - 00:15:03.510, Speaker B: I don't know go ahead.
00:15:04.700 - 00:15:49.952, Speaker A: Okay, so to summarize, why Cairo? So first of all, it allows you to create what's called a provable program. You can create a cryptographic proof that attests to the integrity of the computation. So as I mentioned, the cryptographic proof is generated alongside the result proof verification can detect cheating or malfunctioning without reexecution. That last word is the key to why we use proof for scaling ethereum. We're gonna look more into that in the next section. So you can summarize this by saying that a regular computer is able to keep a supercomputer honest when you use a language like Cairo. Okay, so we talk about Cairo.
00:15:49.952 - 00:16:34.816, Speaker A: So why do we need StarkNet? So let's think about the issue of scaling on layer one sorry, just a second. It disabled disco because I hear so many notifications that are distracting me. Okay, so in layer one in case of Ethereum, we have what's called a block producer which is going to give you, okay, it's going to tell the network, hey, here's a new state of the network. Let's say the state is 42. But of course all the other validators in the network, they just don't going to take the word for it and say, oh yeah, sure it's 42. They will actually execute independently the same block and verify that they all get to the same result independently. So that's part of the consensus.
00:16:34.816 - 00:17:15.568, Speaker A: That the actual result. They all get to a consensus is actually 42. So as you can see, even a small or a simple computation takes tens of thousands of computer to actually execute, right? Because they all need to execute that independently and get to a consensus. So you can see that is fairly inefficient in that regard. So this is how ethereum achieves computational integrity, but by re executing the same transaction over and over. In the case of a stagnant, we execute only once, but then we verify everywhere. So when you on a stagnate, you will do something similar.
00:17:15.568 - 00:17:59.516, Speaker A: You process transactions and then you propose a new state. Let's say the new state is 42, but not only you provide the new state, you also provide the cryptographic proof. And now the validators were just ethereum nodes, ethereum validators. They don't have to re execute the same block to see if it's 42. They only have to verify the cryptographic proof that was provided and that will give them mathematical certainty that the actual answer of the new state is 42 without having to re execute all the transactions in the block. And as you can see, the verification takes only a fraction of the actual underlying computation. So you can see visually here why a layer two like a stagnant is so much more performant.
00:17:59.516 - 00:19:12.456, Speaker A: Because now you don't require every single node of the network on layer one to re execute all the transactions. They only need to verify the cryptographic proof and that takes much less effort. What's the connection? How less of an effort? Well, if the execution takes N steps, the execution done by the sequencer on a STARnet, then the validation of the cryptographic proof associated with it actually takes lock square of N. So this polylogarithmic relationship and it's easier to see in this graph, so this blue line going vertical sorry, going in the diagonal is actually the amount of steps of certain computation. And you can see the red line is the amount of steps of the verification of the associated cryptographic proof. So the bigger the gap between these two curves, the more you achieve in saving computing power from the whole network to achieve the same result of creating new states. So you can think of validity proofs, this analogy, validity proof is to computation what zip is to a file size.
00:19:12.456 - 00:19:34.284, Speaker A: It's all about compression. Just in the case of validity proof it's a compression of computation while Zip is a compression of file size let's see any interesting questions? Any question here Omar manmade yes if.
00:19:34.322 - 00:19:40.620, Speaker B: I inquire is asking what is honest supercomputer honest supercomputer?
00:19:42.420 - 00:20:13.240, Speaker A: You don't need the supercomputer to be honest. As long as they use the Cairo VM and you have access, we're going to have to see. You'll need to have access to the underlying Cairo program. So we all have an agreement which program is being executed. But as long as the supercomputer uses Cairo VM it will able to generate this cryptographic proof that the computer will not be able to tamper. Or if they do you with a verifier independently you will be able to spot when they are trying to cheat.
00:20:18.000 - 00:20:23.980, Speaker B: Sorry, when you say cheating and being honest, what do you mean? What is cheating in this context?
00:20:24.800 - 00:20:54.872, Speaker A: Cheating will be trying to create a validity proof that try to attest to a computation that didn't happen or to attest that some computation that apparently happened provide a completely different result that it should have done. And you've been trying to fool the verifier that you have on your side. So it's the combination of both. I give the security of a system. Great.
00:20:54.926 - 00:20:56.440, Speaker B: Thank you. Secure workstation.
00:20:58.780 - 00:21:07.164, Speaker A: Please. People in the chat, please use the Q A. Don't use the chat for questions so we can keep track. Yes.
00:21:07.202 - 00:21:22.770, Speaker B: We're focusing on the Q A. And also, David, here's a question. How can Aslio join the discord? I guess they simply go into the discord of StarkNet join and whatever.
00:21:24.100 - 00:21:29.840, Speaker A: If you can share the invite link to the discord server, put it there in the Q A will be helpful.
00:21:30.180 - 00:21:47.240, Speaker B: Also, let me invite you to the telegram. I will send you a link in the chat so you can join the telegram here of English pickers. It's only for builders. So if you want to go there and we can just talk a little bit more and contribute, you can ask questions and so on, so I will send you the link also for the discord.
00:21:49.100 - 00:22:21.380, Speaker A: Cool. Thank you, Omar. All right, let's talk a little bit more about validity proofs. So, validity proofs are an implementation, what's called the zero knowledge proofs, or CK proofs, and it uses CK proof to guarantee computational integrity. That's basically to guarantee that certain output is a result of computation with input. So you can think about that as, like, doing the right thing even when no one is looking. That's one way to think about computational integrity.
00:22:21.380 - 00:22:50.700, Speaker A: So we use validity proofs and CK proofs not for privacy, which is a common misconception about STARnet. We use it for scaling ethereum. As I showed you before, the comparison of the layer one and the layer two validators. So STARnet right now is not about privacy. It might be in the future, but right now it's not. That's why we think that ZK rollup is a misnomer, because it kind of implies some privacy. We prefer the term validity roll up for starting it.
00:22:50.700 - 00:23:35.892, Speaker A: And to be fair, pretty much any other ZK roll up out there uses validity roll ups. None of them, to my knowledge, actually are focused on privacy after, I think Aztec shut down their own layer two. And very importantly, the type of ZK proof that STARnet uses is Starks. We don't use Snarks, probably have heard both being Zika proofs, but we use Starks. And there's an important reason why we chose to go with Starks and Snarks that I want to review here. So if you compare these two type of ZK proofs, the verification time for a Stark proof is polylogarithmic. If you recall the chart that I showed you, in the case of a Stark, it's actually constant.
00:23:35.892 - 00:24:20.680, Speaker A: So it doesn't matter how complex the underlying computation is, the amount of work to verify the computation is always the same. Now, the proof size that we send to layer one for verification in the case of Stark is pretty big. It's about 400 KB. In the case of a Snark, it's pretty small. It's only close to 300 bytes. So it begs the question, if the Snarks are so much better than the Stack, why did we actually chose a stack and Snark for stagnet? There are very two important reasons for that. First of all, when you use Snarks, you have to go through the trusted setup, the trusted ceremony, where you have to fit the system with a secret and you have to make sure that the secret is properly disposed, because if that secret is being leaked, the whole system is compromised.
00:24:20.680 - 00:24:52.372, Speaker A: In the case of Stark, we don't need a trusted setup. It works even without that. So it's one less trust assumption for the security of the system. It's also very important the Starks are quantum secure, which Snarks are not. So whenever quantum computers come alive with sufficient power, they will actually break a Stark, but they will not break a Stark. So we are making a bet on the future to the maximum level of security that we can think of. Of course, that has a price in the proof size, but it's better to be safe than sorry in the future.
00:24:52.372 - 00:24:53.830, Speaker A: That's all. At least we'll be thinking.
00:24:57.130 - 00:25:11.580, Speaker B: David, good question here. So there are some people that join the Discord of STARnet. What? They have not been added yet to the channel. So how can we proceed in that case?
00:25:12.190 - 00:25:45.062, Speaker A: If you joined just recently, allow me some time to get in touch with the Discord mod who is in charge of the channel so they can add you just make sure that you actually provided that your Discord username when you register and we will try again to add you to the server. Some people might try to join the Starware server and might not be able to. And that's because some security bots, that's something that we cannot do anything about that. But if you actually were able to join we will add you to the discord server. Just maybe tomorrow morning maybe they can.
00:25:45.116 - 00:25:52.006, Speaker B: Send their discord name in the chat, right? And we can add it.
00:25:52.028 - 00:26:05.900, Speaker A: Omar, if you can take a note of that, it will be super helpful. Perfect. Okay, so maybe start A-Q-A and people add their discord username. So we have one place to track all the people who were added to the channel.
00:26:06.210 - 00:26:19.840, Speaker B: I think it's okay. In the chat we can download it and then please add to the chat your discord name in case you haven't been added to the discord channel. And we will add.
00:26:20.210 - 00:27:01.050, Speaker A: Thank you. Okay, let me see more questions. I wonder if this is a way to hide the one that's been answered. Okay, is there a possibility to keep the algorithm private so the supercomputer cannot steal algorithm and they use it later, not now? No, because as I mentioned, STARnet is not about privacy, it's about scaling. And so you have to share the algorithm. So basically when you use STARnet, you have to publish your smart contract so it becomes visible to anyone to use it.
00:27:03.930 - 00:27:31.120, Speaker B: If you answer it. David, please click on answer like so we know you already answered. Okay, there's some questions from Fox, from XRP so man, you know that there are okay, what do you think about the Snarks using a trusted without trusted setup? They are using some kind of PRFs. What do you think about them?
00:27:32.370 - 00:28:05.000, Speaker A: That I'm not sure. I haven't digs so deeper into the tech sector know what's the implication but I know that for Ethereum there's a push right now for KCG commitments. I think that's part of the secret, right? We're all collectively creating a secret to fit into the system to provide security to the stocks. So that's why it can be done. But now you have to make sure that you do the KCG commitment ceremony correctly. Can I pop? Yes.
00:28:05.370 - 00:29:16.190, Speaker C: Second real quick. So when you have a circuit and the Verifier has to read it's basically of two parties, prover and Verifier, all of this trusted set of yada yada yada is basically done. So the Verifier can read something shorter than the actual circuit and verify that the circuit is correct. So we have to, as David has been saying go through some sort of a compression process from circuit to compressed information. And then that compressed information is what the Verifier reads this compression requires in the case of Snarks, which is the first protocol to have been introduced in this space, it requires some randomness. Now, whether you use Verifiable randomness or I guess unverifiable randomness, that doesn't change the security vulnerability that we are talking about is that even if you do have verifiable randomness and someone is able to get access to that, or leak that information after the trusted setup, then the prover can basically cheat and create false proofs and the verifier will not be able to figure out what's going on. That's kind of like what we're doing here.
00:29:16.190 - 00:29:31.380, Speaker C: Starks required no randomness to generate they only use a collision resistant hash function, which is also why they're quantum secure. So that's kind of like just fundamentally superior tech stack, I guess.
00:29:33.290 - 00:30:38.998, Speaker A: There's a very interesting question from Zebrin Islary that says, aside from blockchain, where can Cairo be to I see some very good answers already from your peers, so let me just provide my own answer as well. One example that I like to think about is in the future you should be able to generate proofs directly on your computer, right, and then submit that proofs to some server. And the server is the one who runs the Verifier. And I like to think gaming is a good example of this. It's a common issue in gaming that people actually modify their client to cheat, right? And that's an issue. When you have a multiplayer game with language like Cairo, you can technically request your client to every so often create a validity proof out of the execution of your client, and send that validity proof to a server, which runs the verifier just to check that you are not cheating, that you're actually securing the client the way that it was supposed to be. So if you try to cheat, if you try to modify your client, the server will know because the validity proof that you send regularly will fail.
00:30:38.998 - 00:31:00.130, Speaker A: So that's one use case, and there are people actually doing research in the topic to actually run even on a smartphone. The main issue right now is that creating proof is a very resource intensive process. So there's a lot of research that needs to be done to get to that point. But it's an interesting thought as well, how to use Cairo in a different setting that is not stagnant.
00:31:04.760 - 00:31:07.190, Speaker B: We're also doing something with Bitcoin, right?
00:31:08.040 - 00:31:11.510, Speaker A: Oh, that's great. Yeah. Can you explain? Can you elaborate, any of you?
00:31:12.280 - 00:31:37.820, Speaker B: To be honest, I am not very aware of what is happening, but I know that there is something being built. I will send you the report to the chats. Something is being built, I don't know exactly what, but it is in order to scale start and it has been very successful within the you know, that's something we can say about it. Also, David, there's a question about the pool will be open source.
00:31:38.160 - 00:32:10.648, Speaker A: Let me first answer the question about the bitcoin. Actually, that's something that the Bitcoin community is very well aware of. I think the Ethereum community is not as much, but on the Ethereum community, they're actually using our technology to create a very light Bitcoin client. I think the basic idea is that a cryptographic proof or validity proof is generated out of a regular Bitcoin client. And then when you want to sync a new Bitcoin client. Yourself. You don't have to download the whole blockchain to calculate the UTXO yourself.
00:32:10.648 - 00:32:38.108, Speaker A: You can just verify the cryptographic proof of all the calculation that other server actually perform for you, and then you can sync to the latest UTXO, just download the database and verify the cryptographic proof associated with the execution to get to the current UTXO. So now you can zing a Bitcoin client in a matter of probably minutes instead of days. I forgot the name of the project. Was it clement?
00:32:38.204 - 00:32:56.010, Speaker B: Kofitz here added the link to the Rip with the chat. Thank you very much, Clement. You can go and see it. To be honest, there's a lot of very cool stuff that is being built right now at the edge of the technology. The Star community is amazing, to be honest. It's amazing. They are building some very cool stuff and yeah.
00:32:56.010 - 00:33:03.450, Speaker B: David, do you want to do the proverb open source question?
00:33:04.780 - 00:33:33.264, Speaker A: The proverb open source? Yes. So right now it's not open source, but we made a commitment to actually we will make it open source. We're just trying to tackle other areas of the blockchain first. Especially the sequencer is our first target. It's just already we're doing a full rewrite in Rust. Open source want to decentralize also the sequencers before we can tackle the prover. But it is the goal to decentralize the whole stack.
00:33:33.264 - 00:33:50.920, Speaker A: It's just not yet. We're not at that level yet. So right now, the sequencer and the prover are actually centralized, which is the same for every other CK roll up right now that is centralized. That's all. They're not actually open source. Yeah. Go ahead, Omar.
00:33:52.380 - 00:34:29.380, Speaker B: There's also a question from Paul asking, can you explain why Stark is secure and not Stark? So, real quick, the part of the cryptography that is being vulnerable right now to quantum attacks are those using elliptic corp cryptography, such as Narcs and Ethereum and Bitcoin and so on. And Starks are not relying on this kind of primitives. They are not using elliptic corpse. They are using JSON functions as symmetric key encryptions. So it is believed that these particular primitives will be quantum resistant. So that's the main reason the elliptic corp cryptography.
00:34:29.720 - 00:34:49.310, Speaker A: Yeah. At least right now, we don't know any algorithm able to break hash function using quantum computers, but we do know an algorithm to break elliptic curves and other cryptography primitives using elliptic curves using quantum computers. The algorithm exists. It's just waiting for a quantum computer to be sufficiently powerful to run it.
00:34:49.760 - 00:35:13.440, Speaker B: And they will come when we have that. A lot of development has been done in the quantum computing side, and one of the goals they have is actually trying to use this algorithm to break the electrical cryptography is actually a metric for how good these computers are. So it will come a day, and when that day comes, the first thing they will do is break this liptical.
00:35:15.220 - 00:35:41.400, Speaker A: All right, thank you. For the question. Meet Omar. Feel free to keep answering them on the Q A. I'm just going to keep moving forward because of time constraints. All right, so you probably have heard, like in Stagnate we use the Caro VM, we don't use the EVM. So why is that? So on one side, you have Zke EVMs, right, which some famous one are like the Polygon Hermes, Scroll, CK sync.
00:35:41.400 - 00:36:35.100, Speaker A: They try to be as compatible as possible to the Ethereum virtual machine, while STARnet is actually using its own virtual machine called the Carobm. So these two approaches, they're trying to optimize for very different things. So CK EDM is trying to optimize for having max compatibility with current smart contracts deployed on layer one. But they sacrifice performance because the EVM was created for a particular CPU architecture or a traditional CPU architecture that is not really friendly to CK circuits. That's why Cairo VM or Stargrave, we decided to create our own virtual machine. So we can create our model, a computer that is exactly or fine tuned for validity proofs. So we're thinking about how do we track the most performance of the network long term.
00:36:35.100 - 00:36:41.330, Speaker A: Amit, do you have any more comments? You're more an expert at this area than I am. Probably.
00:36:44.260 - 00:37:00.724, Speaker C: I would leave it at that today, but we can. But yeah, the main difference is, of course, you can compile your code directly into EBM by code on Zkebms. With us, you have to go through Sierra and maybe I'll let you speak.
00:37:00.762 - 00:37:38.160, Speaker A: More about we have a session six. It's going to be about the Cairo architecture. So probably a lot of these questions are going to get answered how the architecture of Cairo actually looks like. The Cairo VM actually looks like. Just a quick comparison. If you have read Vitalik's article about the Ckevm classification, he classifies Ckevm in four categories, type one to four. So type one is basically no changes to the theorem virtual machine, full compatibility, but the performance will be very slow to create the cryptographic proof out of those execution.
00:37:38.160 - 00:38:22.620, Speaker A: So pretty much no one is attempting this right now. Type two is that you use most of the EVM, but you change at least the data structure for storage. You achieve high compatibility, at least you're going to have some smart contracts that you will need to be modified, but the performance is still very slow. Then you have type three, where you have compatibility, but you have to modify something like storage hashes pre compiles to make it a little more friendly to the new architecture. So you have partial compatibility. It's not like you can deploy every single smart contract as is to a layer two. With these characteristics, the performance is still going to be slow, at least in theory, technically.
00:38:22.620 - 00:39:02.648, Speaker A: And we have projects doing that like Scroll, Polygon, Hermit, ZK Sync, even Katarot, which is a layer three on top of STARnet, are actually tended to be type three Cke EVMs. But then you have the type four where they implement a completely different virtual machine. They're not compatible with the smart contracts deployed on Ethereum using Solidity. But the upside is that it's very fast to create the validity proofs. So you have two main projects competing in this space. Obviously stagnat is one of them. And you can consider to be a CKE EVM because you can use stagnet with a compiler called Warp to compile Solidity smart contract into Cairo VM.
00:39:02.648 - 00:39:11.360, Speaker A: And the other one is Polygon Smiting. So we are really focused on performance and long term view of scaling ethereum.
00:39:14.060 - 00:39:57.600, Speaker B: Okay, to summarize, maybe quoting here eleven Sasson, he said, we really believe in Star Wars that the future of scalability will be built using Cairo or astronomy GVM. Because David said the only focus of Cairo, the only focus of Cairo, its goal is to scale Ethereum. That is not the goal of the EVM. The EVM goal is to maximize centralization, which is great, and it's very relevant. But in Cairo we're already thinking as a given the part of the security and the centralization that ethereum gives. So now we're focusing only on scaling. And that's why we really believe that car is the way to scale Ethereum.
00:39:57.600 - 00:40:23.944, Speaker B: The problem here is, of course, image from David's show. There's already an Ethereum building tooling, tooling, Foundry. We have profile and so on. And those we don't have in Cairo or STARnet. We need to build a new tooling. However, the toolkit is being built by the day. So we have total Star, which is kind of similar to Foundry.
00:40:23.944 - 00:40:44.900, Speaker B: We have actually, which we have several APIs and SDKs that we can use to interact with the starter. And kyo. So tooling is getting much better. So we are able to write Kyo and scale both the social part and the scalability as lower fees and faster transactions.
00:40:45.800 - 00:41:10.296, Speaker A: Cool. Thank you, Omar. All right, to summarize why stagnet? First of all, it guarantees computational integrity without re execution. Proof verification is cheaper than the underlying computation. So remember the polylogarithmic relationship with the underlying computation. We can think about that as computation compression. So we use ZK proof for scaling, not for privacy.
00:41:10.296 - 00:41:48.548, Speaker A: That's very important to keep in mind, at least not yet. And we use ZK proofs, we use Starks CK proofs and not Snarks because Starks are quantum secure. That's really the main reason we're thinking long term. And this is why we have the tradeoff. Cool. Let's talk about, at a high level the architecture of STARnet. So in my previous example, the story about the head of the space exploration, the person actually got convinced that the result is 42, whatever that is, right? Because he was able to verify in the penalty the cryptographic proof in his laptop.
00:41:48.548 - 00:42:25.030, Speaker A: But then how is other people going to trust that that is actually the result? Right? Because so far only this guy was able to verify the late proof, but not Alice. So that's why for Alice to trust, a couple of things are needed. First, you need to make the Cairo promon publicly accessible for anyone. She should be able to independently verify the proof, basically run her own layer two node. So she needs a STARnet. So STARnet is a layer two, right. So that's why I present here ethereum at the bottom as layer one.
00:42:25.030 - 00:43:24.490, Speaker A: So on a STARnet, when you send a transaction, you send a transaction to what's called the sequencer. Right? And the sequencer is like the block producer of it uses that's where the Cairo VM lives and also where the stagnet OS lives. And the sequencer is just going to take all the transactions, it's going to validate them just to make sure that the signature is correct, that the person is able to do these things or been able to use this user account. It's going to bundle them into blocks and it's going to calculate what's the new state of the network based on the execution of this block. Right? Similar to a block producer on layer one in this case. The interesting thing here is that out of the execution of all the transactions in a block, the sequencer sends what's called an execution trace to the prover that we call it sharp. In the case of a stagnant, sharp is because shared prover is used by Stagnate, it's used by stackx as well.
00:43:24.490 - 00:44:21.320, Speaker A: So with this execution trace, the prover is able to compute the validity proof to attest to the integrity of the computation done by the sequencer. And this validity proof is eventually sent to layer one as cold data to a Verifier smart contract that is written in solidity, right, since open source anyone can see it. So the Verifier is going to take the validity proof and it's actually going to perform the verification on layer one. This case, the ten thousands of Ethereum computers are going to perform this computation independently and if the verification is actually successful, then the sequencer is going to change the state difference. But changing the state before and after the block was executed again to the layer one as call data, to a different smart contract that we call a stagnant core. And we use that as our data availability layer. We want to publish this data on layer one.
00:44:21.320 - 00:45:19.836, Speaker A: So now we can have full nodes or stagnant full nodes, who gets what is the state of the latest block or the state of the network? It gets that from the sequencer correctly because as of now, these are two centralized entities. But the fact that we send this state diff to layer one, it means that if for some reason the sequencer or the connection between the full node and sequencer fails, you are able to recreate the layer two current state by reading or indexing data from the standard core smart contract. So you can recreate the data from layer one independently if there is a situation that the sequencer stopped responding to layer two full nodes. So at a very high level, this is how Stagnant works. So I went through some of the modules. So as I mentioned, the sequencer validates executes and bundle transactions into blocks. The proverb creates Stark proofs for a STARnet and a Starkx.
00:45:19.836 - 00:45:41.840, Speaker A: That's what's called Sharp or shared prover. The Verifier is a layer one smart contract. Verifies. A stack proof sent from Sharp. Stack core is another layer one smart contract that just stores. Stores is a big word because actually we only send it as cold data. It's not get stored at the contact level, storage or cost reasons.
00:45:41.840 - 00:45:50.080, Speaker A: And we use that as the data availability layer. Finally, the full node provides data to layer two. DApps.
00:45:52.850 - 00:45:53.790, Speaker B: David.
00:45:57.030 - 00:45:57.490, Speaker A: Perfect.
00:45:57.560 - 00:46:12.280, Speaker B: So regarding the start of your presentation, there was a question from Eliel. Sorry for coming. There are a lot of questions, we're answering each of them. So Eliel asked do we send algorithm or the data to rival country when you were talking about this part?
00:46:14.650 - 00:46:17.526, Speaker A: Oh, you mean in the example at the very beginning?
00:46:17.718 - 00:46:21.500, Speaker B: Yes, at the very beginning. So what are we sending, the algorithm or the data?
00:46:22.510 - 00:46:49.522, Speaker A: The algorithm. Like the program, you can send the program, it's just in reality you don't send the program as is. You send the bytecode of the program, the low level Cairo assembly program to the supercomputer. Okay, perfect. Yes. Thank you very much, David. A lot of questions from ahead.
00:46:49.522 - 00:46:58.742, Speaker A: Go ahead. Romar is asking can you use a different data availability layer, like Celestia, for example? The answer is yes.
00:46:58.876 - 00:47:33.098, Speaker B: We are working on the value views, which is going to be I'm working the innovations where we will be able to do the data availability part using different kind of services. For example, Celestia pyco USB if you want. So it's going to be very interesting. You will be able to write Cairo code where you can declare variables that are going to be stored on chain and some variables that will be not stored on chain. It will be stored off chain or maybe Senestia or somebody else. So that would be very cool with Valid.
00:47:33.274 - 00:48:23.650, Speaker A: Yeah, just a comment. It's called volition because validium is what volition uses. So we have three different data availability modes right now, only two really roll up is the one user by stagnet will be published to layer one, Validium, which is used by Starkx that we are not covering here. But it's another technology developed by Stackware. And then we have Volition that we want to implement on stagnet, I don't know, this year at some point, which is going to allow you to choose where to store your data so you have different cost for your transaction. Are you going to store it on layer one or have a maximum security or do you want to store it in some other place that could be Celestia or a consortium of people storing data that's going to make be cheaper. So we don't have a lot of details about that but we know that is a path forward for Stagnant to enable volition.
00:48:25.670 - 00:48:33.380, Speaker B: David, do you have curious is asking for the link to the repo of the Verifier smart contract linker one? Do we have.
00:48:42.470 - 00:49:13.780, Speaker A: The repo? Wait, you go to the Caroline repo useful info, important addresses the Verifier address is there a question here? I don't know where the question is, I put it on the chat but owa can you please put it on the Q and A?
00:49:15.030 - 00:49:21.346, Speaker B: Yes, the question is can we get a link to the repo to verify a smart contract? So I will show all right, so.
00:49:21.368 - 00:49:47.626, Speaker A: This is the link to the deploy smart contract. To see the actual source code you have to go to the Caroline on GitHub and in here I think it's know I know I saw it somewhere here but I don't remember yeah, no.
00:49:47.648 - 00:49:49.260, Speaker B: Problem, I can search for it.
00:49:52.110 - 00:50:41.292, Speaker A: I've seen it, it's there somewhere I just need to find perfect cool search of four. So let's talk about Carawan. We just recently released this new version of the language which is very different from Cairo Zero, but it's much better than Cairo Zero. So Cairo One is a high level language, right, which makes it easier to learn compared to Cairo Zero, which was more of a low level language. The syntax of Cairo one is heavily inspired by Rust which also makes it like a strongly typed language. So if you know Rust, you will feel comfortable with Cairo one. When you compile a Cairo smart contract, it doesn't directly compile to the Cairo VM bycode which we call it the Cairo assembly.
00:50:41.292 - 00:51:37.220, Speaker A: It compiles to the intermediate language called Sierra. Sierra stands for safe intermediate representation because this is what allows to create validity proofs even when a transaction fails, which was not possible before and now because of Sierra, basically signatures are always compensated for their work even if a transaction fails. And in the near future we allow for transactions to be reverted much in the way that happens on layer one. So you can see on the right side, you start with a car one smart contract, you compile it to Sierra and then you send this to the sequencer, the sequencer that compiles to Cara assembly that we also call it chasm. And from the car assembly, the execution of this car assembly by code, by the signature, that's where we derive the validity proof on the proof and we send to layer one. So take a look. This is how it looks like an example a smart contract on Cara one.
00:51:37.220 - 00:52:09.580, Speaker A: You can see at a glimpse it looks a lot like Rust where you can do some metaprogramming with macros. This is how you bring functions into scope, this is how you define storage variables. You have to name a stroke. Storage has to be the name. And then you define all the properties of all the storage variables. Felt is still the data neta type, but then we have more data types that we can use that before in Carol Zero was not possible. One very commonly used is U 256, which is commonly used in solidity.
00:52:09.580 - 00:52:33.488, Speaker A: This is how you write to storage. This is the syntax. This is how you read from storage. For now, just take a look. Today is not the day to focus on Kyro one a lot just for you to have a taste of how it looks like. And now this is how you define variables with the keyword length, which if you use Kyro Zero, you know that before there was like a four different ways to define a variable. Now we have only one.
00:52:33.488 - 00:53:21.252, Speaker A: So it's a much nicer language to play with. So there's a thing called Regenesis that is all about closing the gap. So as I mentioned briefly that in Cairo Zero transactions, failed transactions cannot be proven. And because they cannot be proven, that opens the door for what's called a denial of service attack on the sequencer. Because the sequencer gets to execute a transaction to the point where it fails and then it cannot add it to the block because validity proofs cannot be created out of a failed transaction in caro zero. Caro one actually fixes this problem, but it means that eventually carousel Zero smart contracts needs to be disabled from the network for security reasons. So we have two important events that happen over time.
00:53:21.252 - 00:54:10.308, Speaker A: The one that happened recently is the deployment of standard zero point eleven to Mainet. Because before zero point eleven, mainet only supported Carol Zero point Ten smart contract. Right after the deployment, the standard Zero point eleven. Now both languages are supported. Carol zero point ten and Carol one. At some point in time we're going to go through Regenesis, maybe four, six months, where we actually going to disable all the Cairo Zero Smart contract and only Carol One is going to be supported from that point forward. But in the meantime, we have a migration window where we provide mechanism for you to be able to upgrade your already deployed smart contract from Cairo Zero to Cairo One while preserving your same storage layout, the same storage values, the same address.
00:54:10.308 - 00:54:47.472, Speaker A: So in a way that is completely transparent to your end users using your Smart contracts. But you will have this migration window to go through it, because after Regenesis, we got to disable all the Cairo Zero smart contract and from that point forward, it's only going to be Carol One from that point on. And this is where we are right now, just at the very beginning of the migration window. Let me go to the summary and I stopped for some questions. Probably there's some. So Carawan. Carawan is a high level language inspired by Rust Sierra allows for reverted transactions before.
00:54:47.472 - 00:55:18.444, Speaker A: We're not possible. We don't have reverted transactions just yet. We need a little bit more work on the Stargate to allow that, but it's now technically feasible to do it. Smart contracts can be upgraded from caro zero to caro one while preserving the state and their current address where they're being deployed. Target already supports caro one in the tested and on main net as well. And regenesis will disable Cairo zero code. And that's going to happen before six months in the future.
00:55:18.444 - 00:55:22.750, Speaker A: So let me stop here for questions by better some.
00:55:24.880 - 00:55:33.090, Speaker B: There's a question from anonymous attendee. Is it possible to build circuits like Circum or Noir with Chiro one?
00:55:36.420 - 00:55:45.910, Speaker A: I don't think so, because this is a high level language, but I'm not that much of an expert to get deeper into the reason why, but intuitively I don't think so.
00:55:47.000 - 00:56:11.450, Speaker B: But from what I've seen, using layer three, we can be able to use Noir and then that compile it so you can get into Kyro, so it will be interesting. And actually, Francis mentioned something before. You can be able to prove Snarks into STARnet. It's something that's been working.
00:56:12.620 - 00:56:37.152, Speaker A: Can can you you can create your own verifier with Cairo, right? It's a smart contract. It actually exists. There are stacks verifier, there are different stack verifiers as well. So really you can implement your own layer three right now and not wait for a stack where we're stagnant to evolve to the point that we make all these things the official verifier available on layer two. Perfect.
00:56:37.286 - 00:56:45.590, Speaker B: Also, Sephirne is asking, can we expand more on Sierra? Sierra will be looking at sessions six whites. David, more about?
00:56:48.120 - 00:57:14.720, Speaker A: I haven't we haven't discussed exactly what's going to be coming in the chapter, but probably yes. For now, just keep in mind that it's going to be an intermediate language. When you compile in your computer before you deploy, you no longer compile directly to car assembly, you compile to Sierra and that's what you deploy to stagnet. And then on stagnet, the signature compiles your Sierra bytecode to Kyra assembly code. Yeah.
00:57:14.790 - 00:57:28.550, Speaker B: This is a great invention for those of you who want to, for example, do audits, security audits, learning Sierra will be key for you. It's very important. It's like learning jewel for layer one.
00:57:32.600 - 00:57:40.520, Speaker A: Yeah. More question. Go. Can you order by most of? Because I see some questions being unanswered with four votes, three votes.
00:57:41.260 - 00:57:50.244, Speaker B: Yeah, we're working on that. We have a lot of votes. So there's a question by Gleem. He's asking Gleem, by the way. He's French living in Mexico.
00:57:50.292 - 00:57:51.108, Speaker A: Hey, Gleem.
00:57:51.204 - 00:58:07.330, Speaker B: So if the centralized started, the sequencer will be a full note and there will also be a full node that are not a sequencer line, which means only sequences will participate to consensus and all other full nodes are only relaying data to that or other nodes. Is that correct?
00:58:13.830 - 00:58:51.214, Speaker A: Consensus. So how decentralized stagger is going to look like is a moving target? I don't have a clear answer. Of course, the first sequencer will be the first one to be decentralized, and it means that they need to reach consensus as any decentralized system. Do they need to be full nodes? I mean, sequencer will they need to store the current state of the network right, as well as a full node. But a full node can exist independently from a sequencer. They don't have to be the same thing. They can be independently, and I think that's the future.
00:58:51.214 - 00:59:12.070, Speaker A: But they will probably share some modules. Like right now, for example, if you use Papyrus as a full node, it uses a module called Glockifier that we are going to introduce also into the new sequencer that has been rewritten in rust. So they're going to share some of the same primitives for storing the state. But they are two different systems in the network.
00:59:13.210 - 00:59:17.654, Speaker B: Also, we have, like, clients, right? Like bureaus being built also by the community.
00:59:17.852 - 00:59:38.240, Speaker A: We also have bureaus, which is inspired by I forgot the name of the other, not Horus forgot. There's a light client developed by a 16 Z for ethereum that we're using to build Horus. On top of that, which I forgot the name.
00:59:40.210 - 00:59:42.266, Speaker B: Also worth mentioning, that Francois.
00:59:42.298 - 00:59:42.910, Speaker A: Thank you very much.
00:59:42.980 - 00:59:52.290, Speaker B: He has been answering a lot of questions, so thank you very much, Francois. What else can we do? Start with caution to reduce the proof size, like the Mina protocol with Snobs.
00:59:55.430 - 01:00:02.566, Speaker A: Okay, can we do some questions? We do do that. Yeah. Sharp manmir. Go ahead, please. You can answer that. Yeah.
01:00:02.588 - 01:00:33.680, Speaker C: So I was just going to say, initially we generate one proof object per computation, but then basically, whilst we're still in the off chain environment, we batch those proofs together and keep on generating smaller proofs for a certain period of time. And only at the end of that period of time do we send the one really sort of like root proof down to ethereum layer one. So in that way, we're actually getting hundreds of thousands of transactions through one proof object.
01:00:35.170 - 01:01:17.292, Speaker A: Yeah. On session four, when we go deeper into standard architecture, we're going to look at how the proverb achieves recursion. All right, sorry, let me move on, because the time is if we have time at the end, we will go back to see some of these questions, but please try to answer some of them directly on the Q A. So some of the tools that you should have if you want to get into STARnet, first of all, is a wallet, and there are two main ones. You have Argentx. And you have Bravos. Argentx, they have a browser extension, as you can see, for Google Chrome, for Brave, for Firefox, bravos the same.
01:01:17.292 - 01:01:39.990, Speaker A: Also a browser extension. But Bravos also has a mobile wallet, which is very interesting, how they implement that and how they use account abstraction. So pick the one you like the most and make sure that you have installed in your browser so you can follow along some of the exercises. We have two different block explorers. Welcome, Voyager. And the other one called Stark scan. Both are great options, so pick the one you like the most.
01:01:39.990 - 01:02:35.568, Speaker A: And we have some tools for developers. One of them is Protostar, which right now I actually was thinking about removing Protostar for now because it's definitely a full rewrite of how Protestar works with Car One using a thing called Scarb, so maybe put that on ice in the meantime. But just know that there's a tool similar to Foundry on Ethereum, so you can test your smart contract using the same language you use to program the smart contract, in this case Cairo. And also we have collaboration with Open Seplin that they actually develop smart contracts for Cairo. Always all the best practices for ESC 27, 21 and so forth. Other tools that we have available, we have a plugin for Hardhut if you want to test using JavaScript. We have a defnet similar to Ganache as well, if you want to run it locally.
01:02:35.568 - 01:03:12.956, Speaker A: We have a library for React for your decentralized app. We have different SDKs for different languages for TypeScript, or JavaScript for Python, for Java Kotlin Scala and for iOS. So whatever you're building, we have an SDK for that. Many of them right now are going through the process of upgrading to support Cairo One, so just be mindful of that. All right, so let's take a break. Ten minutes. Do we have ten minutes? What do we have? Let's have sorry, five minutes, because we're going to jump into the live coding session.
01:03:12.956 - 01:03:58.056, Speaker A: So just have washroom breaks and get some coffee and we'll get back in five minutes. Sorry, I'm just going to mute myself and turn on the camera and I'll be back in a moment. All right, so let's go and set up a dev environment for Car One. So, first of all, just a warning, we are going to be using a lot of tools. We're very new, so we're going to be living on the edge, which means that some of these toolings are still rough around the edges. So we have two main repositories that we're going to use. One's called Cairo Lang, which is written in Python is where we have the STARnet CLI and where we have the Cairo Zero to Cairo Assembly compiler.
01:03:58.056 - 01:04:41.948, Speaker A: It's like the old compiler, but it still has the STARnet CLI. And then we have the Cairo repo without the Lang, which that's where we have the Cairo One compiler, the compiler to Sierra, and then also we have a compiler from Sierra to Chasm. And I'm going to go into detail why we have two different compilers. I'm going to explain that in section four, I think, but this one is written in Rust, not in Python, and it also has. A Vs code extension that we can use, but we're going to have to build it from source so you can have some syntax completion and validation as well. So we're going to need three main languages for setting up this dev environment. As I mentioned, it's going to simplify as time goes by but for now we're going with three.
01:04:41.948 - 01:05:33.148, Speaker A: We're going to need Rust to compile the Cara One compilers and I know it's a mouthful, but that's what we need to do. And also to compile the Vs code extension because right now it's not yet published to a marketplace. We're going to need Python especially, particularly 3.9 to create an account so we can deploy and declare all these things and invoke to use the STARnet CLI because the Cairo line where the CLI lives is written in Python and we also needed to sorry to declare to deploy and to invoke transactions on a STARnet. Finally, we need Node JS for packaging the Vs code extension before we can actually install it on our IDE. So this is the plan for the light coding part. Hopefully you can follow along but we have the instructions shared for you here at the bottom.
01:05:33.148 - 01:06:03.860, Speaker A: So first we're going to compile Caro One from source. Then we're going to test that the compiler is actually working by compiling a simple smart contract. Car One smart contract. Then we're going to install the Vs code extension for Car One. Then we're going to install the STARnet CLI. We're going to create a user account local in your computer so then you can declare an example of smart contract. You can deploy it to STARnet testnet and then interact with it using Block Explorer and a regular wallet.
01:06:03.860 - 01:07:25.360, Speaker A: So you have two links here at the bottom. I'm using the guide today, but in the starting book we also have steps for performing this as well. I'm going to start a virtual machine so we can follow the steps from the beginning, basically. So let me see, give me a SEC to start this Ubuntu. Do this cleanstall and start just a moment while the VM starts and I log in. Share the screen in a moment. Okay, I'm in and I'm going to follow my guidelines here.
01:07:25.360 - 01:08:04.730, Speaker A: Sorry guys, I just tried to set up my computer here with all the things that I need or I can start doing live coding. Perfect. Wait, in the meantime cool, I'll be ready. So as I mentioned, I have a clean installation of an Ubuntu machine. The instruction for macOS are very similar in the guide I put whenever there's a small difference, I put there comment like an if else kind of blog. So the first step is to install Rust. So to install Rust, you basically you follow the official instructions of how to install it.
01:08:04.730 - 01:08:55.160, Speaker A: We want the release version of Rust. Why it came like that, we need to use Curl to get it. Let's see how can I increase the font size of this? I'm just going to proceed with installation. How is the font size? Not that good if you can zoom in. Yeah. Join email size columns, rows, custom fonts here already change it. Custom fonts can increase it to a thing.
01:08:55.160 - 01:09:04.380, Speaker A: Better now? Yes, looking better.
01:09:04.990 - 01:09:09.760, Speaker B: What do you think, guys? They say it's okay. Perfect. Thank you very much.
01:09:11.570 - 01:09:34.840, Speaker A: Make it a little smaller. Okay. All right, cool. So I have Rosk installed. It asks you to activate some things on your shell. So you can just run this source, or you can just close the terminal, which you're going to do, and open a new one. So the configuration takes place.
01:09:34.840 - 01:10:10.030, Speaker A: And just to verify that Rust is installed, at least rust up. Do this rust up version and yes. So we have version 1.25.2. So rust installed. As I mentioned, we need Rust to compile the Car One compiler from source. So the next step is to actually download or clone the repo where the compiler for Car One lives. So I have this command, here what I copy.
01:10:10.030 - 01:10:59.018, Speaker A: All right, so this is the repo where the Cairo One compiler lives. I'm going to clone it to a specific folder on my home directory just called Cairo. I just want to have a particular location that I can always go back to, because we're going to have to do some mapping of the binaries. That's why I put it here. So after clone it, we should have it in the Cairo folder. So if I come here so we have here in the repository for Cairo One. So we need to activate a very particular tag, the latest tag available in the repo, because that's the compiler that was used or supported right now by Stagnate.
01:10:59.018 - 01:11:34.854, Speaker A: So we need to make sure that we use the same. So this is why we enable or activate this particular tag, which is the latest tag on this repository. Tag version one, point alpha six. So we are in detached mode in this particular commit of the Car One repo. So now we can actually build all the binaries using cargo, using this command. I'm sorry, I went a little too fast. Just because Rajiv and also former memory.
01:11:34.982 - 01:11:37.710, Speaker B: Are asking if we can share the commands.
01:11:39.090 - 01:11:50.960, Speaker A: Yeah. In the slides, which I share with you at the bottom of the last slide, where I have the live coding plan, you see the reference. Let me just put it here.
01:11:53.590 - 01:11:56.740, Speaker B: You can share again the link to the slides. WP, correct.
01:11:58.790 - 01:12:17.310, Speaker A: Okay. Link to the slides. Publish the web. These are the links. Where do I put it? In the chat? Yes, please. In the chat. Okay.
01:12:17.310 - 01:12:39.936, Speaker A: So I put in the chat the link to the slides. And if you go to this last slide before let's start the setup. You see a link to the guide. I share this link, too. This is the steps that I'm following. Basically, that you don't see on the screen, just using a secondary screen. But you also have this target book as a guide.
01:12:39.936 - 01:13:14.524, Speaker A: This is what I'm following in this session. You shouldn't see it. Cool. Thank you, Eric. All right, so going back here just a SEC, I'm setting up again my environment. I should do it shad the link.
01:13:14.562 - 01:13:23.976, Speaker B: To the STARnet book where you can also see the commands. Please bear in mind that the STARnet book is very we're working on that, but that part is finished.
01:13:24.168 - 01:13:25.980, Speaker A: Could you share that link, Omar?
01:13:27.680 - 01:13:29.052, Speaker B: I will share the link right now.
01:13:29.106 - 01:13:29.372, Speaker A: Okay.
01:13:29.426 - 01:13:30.850, Speaker B: Link to the STARnet book.
01:13:31.220 - 01:13:51.030, Speaker A: All right, so next step is to actually build the binaries, right. Using cargo build and we use the release version of Rust. We don't want to use the latest or the edge. It's going to take a while. So it's a perfect time to answer some questions. Perfect. So let's see, what do we have?
01:13:51.740 - 01:13:57.640, Speaker B: When will the main net support kernel one by Michael?
01:13:58.700 - 01:14:05.336, Speaker A: It's live. It is supported already. You can deploy right there's not a.
01:14:05.358 - 01:14:14.460, Speaker B: Problem that keep saying with compiling. Okay. It's a particular problem. I will look at it. Okay, so we already showed the comments. Thank you very much. Crypto Nerd and Radiff.
01:14:14.460 - 01:14:38.896, Speaker B: In terms of energy consumption from Ramsey, from Carnable Ramsey, we're looking at that particular question. We don't know. Right. But Manmid already asked internally to see if we can get an answer as soon as possible. Ramsey, thank you very much for that. What are the benefits of the Caravirtual machine versus zero node TVMs? They have to be strong for DSL to win with Soldier team. And thank you very much, Paul Henry.
01:14:38.896 - 01:15:12.380, Speaker B: He answered that the Kyovm is very specifically used by STARnet. Yes, exactly. And the benefits is that, again, that Cairo is focusing only on scalability. And this is something that the Terror bitro machine is not focusing on. They focus on other stuff like decentralization, which is very relevant. But the Cairo has the only goal of scaling ethereum. So that allows to do certain kind of stuff that make us scale without having to follow all the rules of the EVM, which that are done for different purposes.
01:15:12.380 - 01:15:27.140, Speaker B: So the cargo virtual machine should be able to allow for more scalability. That will be the main benefit. I don't know if you see any other question you want to answer right now, David.
01:15:28.440 - 01:15:29.510, Speaker A: Which one?
01:15:34.840 - 01:16:08.636, Speaker B: Sorry for answering this a little bit late. We have a lot of questions. So Tal is asking most projects would probably be attracted to zero chains because they are already bunch of solidity types. How easy will it be to transpile solidity to Cairo in the future? Is it better for projects to transpile or to create native on STARnet? And if you allow me, David, let me quote here again. Eleven Sasson, founder of the Starks, inventor of the Starks, founder of Star Wars. He said that indeed we will have actually a Silver TV. Danilo is leading that development.
01:16:08.636 - 01:16:39.464, Speaker B: It is called Kakaot, which Francois already shared. Thank you very much, Francois. But Ellie said our focus here is to scale code using Cairo. So the real scale is going to be coming from Cairo, not from transpilers like the one we have. Warp will be transpiling solid code into Cairo. However, building native Cairo codes will be the real power of stone. So indeed there's a lot of developers already for solidity, but we think that developers can easily adapt.
01:16:39.464 - 01:16:54.796, Speaker B: So most of you I think you know at least two different languages. I don't know, maybe Python and JavaScript or something like so we would really believe that developers will have no problem learning. Carol, aside from solving.
01:16:54.988 - 01:17:47.330, Speaker A: Also keep in mind that standard gives you way more resources for executing transaction that's possible on the limitation of a gas fees on layer one. So that allows you to create more interesting applications. You can actually create things that are not possible at all to create on layer one. So do you actually want to just transpile your contract as is? You're going to be missing a lot of interesting features. For example, account abstraction that exists technically on L one now. But it's a little confusing because there's three different ways to have an account on layer one, on layer two and starting it, everything is smart contract, everything is using account abstraction or smart wallets. So really the idea is that when you have a different environment with different constraints or less constraints, you probably don't want to just rewrite the smart contract exactly the same way as layer one.
01:17:49.220 - 01:18:52.612, Speaker B: And it's worth mentioning that any serial knowledge project following the terrible virtual machine like the Cke EVMs will have the same constraints as the EVM that being account obstruction, for example. Okay, do you guys know any open source project that have migrated fully to Cairo so that I can work to their code? Let me share you the link to the STARnet Cairo 101, which you can already do and it's called as migrate to care one, I guess also end to end testing. I don't know if we have a project already doing end to end testing. So there are a lot of projects migrate to Kerrow One, but they are doing it maybe not open source or experimenting behind the scene. Also Argent I think will have sooner code Kerr One, so that will be very good. But in the meantime, I will share to you start Kyro 101 tutorials. Those are very good for you to understand how to structure your code.
01:18:52.612 - 01:19:04.040, Speaker B: If you want to learn Cairo code, you can learn with it. But it is also very useful to learn the syntax and the way to structure your project. So I will show it to you in the chats.
01:19:06.880 - 01:19:17.150, Speaker A: Compilation is taking a while, it's pretty intensive and also it's a virtual machine. It's not my host machine, so has limited resources, but we're getting close. Perfect.
01:19:18.800 - 01:19:28.690, Speaker B: Okay, so DV is asking why not both decentralization and scalability start disoriented more to the second one? But I don't see the trade off to live in the first one.
01:19:30.600 - 01:19:31.508, Speaker A: Yes, sure.
01:19:31.594 - 01:19:58.436, Speaker B: Well, correct me if I'm wrong here, Manmade and David, but a starter is having both the decentralization from Ethereum and the scalabic that is provided. Plus we will have decentralization. There's no layer two that is decentralized right now. Actually, we're working on that. We're working on deciding how we will have centralization so we can decentralize the use of sequencers and so on. But I don't know, david, if you want to add something to this bonus.
01:19:58.548 - 01:20:18.544, Speaker A: No, the goal is to decentralize everything right. It's a hard problem to solve. It took Ethereum a long time to do it right. It'll take us a while also to do it right. So we need to approach it first. Let's see that the technology works that we can scale and then we can decentralize. You have to tackle some big challenges once at a time to do it right.
01:20:18.544 - 01:20:27.270, Speaker A: But that's the goal to have it completely decentralized. Okay. Any other question?
01:20:31.560 - 01:20:53.900, Speaker B: Wow, we have a lot of voices today. That is great. Thank you very much for coming. Very happy to have you here. I think those are all the questions that we can answer lives we did. Oh, there's a question from Leo. What are the most interesting use cases you are seeing of on chain apps that will benefit from being able to access more compute? Banmet is answering right now.
01:20:53.900 - 01:20:57.310, Speaker B: Do you want to answer me?
01:20:58.720 - 01:20:59.180, Speaker A: Yeah.
01:20:59.250 - 01:21:30.040, Speaker C: Just like the hats that I dropped in the chat. One of the most exciting things that I've been seeing out here in San Francisco is the new push towards Zkai because AI and machine learning models are inherently very computationally intensive. So being able to prove inferences so people don't have to run them all over again is actually quite a powerful thing. That's one thing off the top of my head other than the obvious scalability to Ethereum.
01:21:32.620 - 01:21:54.290, Speaker A: Also, if you have to follow along sorry, going back to the previous question about digitalization, you can go to the standard forum that I put it on the chat link where we actually post our thoughts and ideas of how do we want to decentralize stagnet. You can follow the discussion there in the proposal and you can comment. Perfect.
01:21:59.460 - 01:22:19.930, Speaker B: Anything you want to add, David? Regarding STARnet Cairo Brown, again, if you want to share your discord in the chat so we can add you to the group. We have a discord in case you haven't been added yet. Please put your discord there. Also join the Telegram community where.
01:22:21.980 - 01:22:22.296, Speaker A: It'S.
01:22:22.318 - 01:22:29.870, Speaker B: Also useful for in order to plan meetups. If you want to do some in your cities or you want to talk with us. You have any questions, please let us know.
01:22:31.760 - 01:23:06.724, Speaker A: All right, good news, it's finished compiling. So we can move with the next step, the terminal here. So now that we have the Car One compiler compiled, we want to add these binaries to our path so we can execute these binaries from any place in our file system. So an easy way to do it is just by adding to our configuration file for our shell. In this case, I'm using CSH. Might be using Bash. So just modify this depending of your terminal.
01:23:06.724 - 01:23:45.540, Speaker A: If you're using Bash, it will be Bash RC. Just basically adding the path where we compile, where the compiled version of the Car One compiler lives to our path. So once with that, I'm going to just close terminal and open again so the changes takes place and we're able to find the binaries. So if this goes well, we should be able to call the STARnet compiler just to see the version and what is opening. Standard compile, not compiler. And there you go. So we have the Binary ready.
01:23:45.540 - 01:24:25.040, Speaker A: The Binary is added to our path so we can use it to compile or carry one smart contracts to Sierra. So let's test that the compiler actually works. So I'm going to create a folder just like a sample project. We're just going to put a very simple smart contract and try to compile that. So I'm just going to call this folder when I get into it and in here just going to create just like a test folder. And I'm going to create two folders just for usually I like to have one for where my source smart contract is and where the compiler folder. So I'm just going to call the compiler folder Sierra.
01:24:25.040 - 01:24:55.936, Speaker A: So this is how my sample project looks like and I'm going to create a file for my sample smart contract inside of source called example Cairo. Okay, so put the tree again, I should see the file. So let me open this with Vs code. David, quick question.
01:24:56.038 - 01:25:00.160, Speaker B: Is there some kind of prettier or ESLint for Kyle?
01:25:01.300 - 01:25:27.324, Speaker A: Pretier or ESLint, the closest will be this extension that we can install, but it's not exactly as prettier because prettier is a formatter. So I will say not yet. Something like ESLint. The extension will work similarly, but not like prettier that actually formats when you save or something like that. When you execute it, how do you increase the font size?
01:25:27.362 - 01:25:28.156, Speaker B: Thank you.
01:25:28.338 - 01:26:15.820, Speaker A: Okay, here you go. I'm just going to put a very simple smart contract, right, basically we use this macro contract and then we create a module. It's called simple storage. For now today, it's not the goal to learn Cara One just to make sure the tooling is working. As you can see, we don't have any syntax highlighting or tooling or anything because we haven't done yet the work of installing the extension. But we have the smart contract, so let's try to compile it. So here I can just do instagnet compile and I provide the file example cairo and then the output and it's going to be a JSON file, the output.
01:26:15.820 - 01:26:27.020, Speaker A: So it worked. Our compiler is working. This is how the sierra looks like for this very simple smart contract.
01:26:27.920 - 01:26:28.332, Speaker B: Good.
01:26:28.386 - 01:27:03.160, Speaker A: So we have confirmation that the compiler is working. Now. The compiler for caro. One next step will be to actually install the Vs code extension and the source code for that extension actually it's inside of the Cairo one repo. So let's go back to that repo that we store in Cairo. And we have here a folder called vs code Cairo that we're going to get into it, right? All right, we're in the right folder. So first of all we're going to need to have node JS installed.
01:27:03.160 - 01:27:40.320, Speaker A: So in the case of Ubuntu, a simple way to install it will be with this command. There are multiple ways to install this. I'm just going to use this to get the latest node version 19. Let me just expand this more. It's going to work. Let's see. So in theory, now I can do pseudo apt update where I trying to install it.
01:27:40.320 - 01:28:37.320, Speaker A: So now I can actually try to install node JS. Let's see. Okay, so if it works well, I should be able to do node and version and yes, we have node version 19, the latest one installed on the computer. So we're good to actually now compile the extension or just well when you use a JavaScript you don't really compile. Let's say you package it somehow. So first of all we need to have install a global package called vs code v ese. So this is what you do for compiler extensions.
01:28:37.320 - 01:28:44.830, Speaker A: So install it globally, it's under this name ese. This is provided by Vs code.
01:28:50.140 - 01:28:59.544, Speaker B: So remember everything is being recorded and will be up in YouTube. So you will be able to send you an email with the link. So you can review everything that we're doing right now.
01:28:59.662 - 01:29:48.476, Speaker A: Yeah, and the guide that I'm following also we have shared with you the link. So exactly what I'm doing is just documenting in a nice document there you can follow along. Okay, so now let's install dependencies for JavaScript with NPM install. Remember, inside of the Vs code cairo with the extension leads. Okay, let me just update my NPM just in case this is suggesting me to do copy paste. Oh, I need to do pseudo. This is just optional.
01:29:48.476 - 01:30:21.750, Speaker A: All right. So now I can actually package the extension previous to be able to be installed using this command package that we installed this binary globally on NPM. Now we can use it here. This is just a temporary measure. Eventually the extension is going to be published to the marketplace and you will get it directly from Vs code without having to do that. But remember, we're living at the edge. So this is how it needs to be done right now.
01:30:21.750 - 01:30:44.350, Speaker A: So now we have the package. We can actually install it, install it to Vs code with this command. Right. Solid extension. This is the file that we just created. Now we go ahead and in theory should be installed. So let's try.
01:30:44.350 - 01:31:18.544, Speaker A: Right, so if I open the extension here, okay, I can see that it is now installed. Cairo one is called extension. But we need to be configured because it's asking for where's the path for this particular binary. The Cairo language server. This is one of the binaries that we compiled from using Rust, from source. So we need to provide this path. And to provide that path let's go back to that's going to be the target release.
01:31:18.544 - 01:31:58.476, Speaker A: Let me just go back here to target. This is where all the binaries are placed. This is my absolute, let's say, path to it. I'm just going to copy this, going to put it here and with the name of the binary. And I think I need to probably close this and turn it on again. So it takes let me close the Vs code and Oops, I need to go back to my workflow. Or maybe just open here and it's not taking.
01:31:58.476 - 01:32:12.400, Speaker A: Okay, now it's work. Now I get syntax highlighting and it's going to complain, do some things wrong, like in this case. Right. So it's a nice helper when you write Cairo and code. So cool. So we have the Vs code extension working.
01:32:12.470 - 01:32:40.760, Speaker B: Yes, Omar, sorry, it's worth mentioning that as David said, I want to repeat that we are not learning Cairo right now, but we will do. And we'll have the chapter of the book ready for in a couple of days. So you can start learning Cairo by yourself. And then we can come here and already with more knowledge of Cairo, and we also teach you some Cairo and also we have some tutorials like Starlinks we will share in a minute. So you can start also learning Cairo.
01:32:41.180 - 01:32:58.210, Speaker A: Yeah. Today is just about the dev environment, not really about Cairo. Well, let me put a little more complex Cairo code here because we actually want to deploy it today. Oh my God. Paste. Yeah. All right.
01:32:58.210 - 01:33:22.250, Speaker A: Again, I'm not going to really explain how this works. We're going to talk more about Cairo in future sessions. I just want to make sure that we can compile this and we can deploy it to stagnate. So let me just recompile this we did before. You ever go back to oh my God. Okay. Just going to copy this.
01:33:22.250 - 01:33:58.300, Speaker A: All right, copy it. Can I paste it here? No. Anyway, stack net. Compile. Okay, so we compiling the new version of the smart contract. So this be a little more complex now as we can see here, right? Way more complex. So this is the code that we actually deployed to STARnet that we give to the sequencer, the Sierra smart contracts.
01:33:58.300 - 01:34:46.466, Speaker A: Okay, so let's keep moving on the next step. Now, because to interact with the Stargate, we used to use the stagnant CLI, the standard CLI is written in Python. So we need to have Python 3.9 in particular to be stored in our system. So to install a very particular version of Python, at least on Ubuntu, you will need a particular PPA. This one here every time. So I add this repository to my apt it's because we need Python 3.9,
01:34:46.466 - 01:35:32.178, Speaker A: we install Python three point ten. It might not work. Now, I do update references and I'm ready to install Python 3.9 using these two packages, especially for development, because we also need to have virtual environments. Thanks a little bit. If it all went well, we should have now Python 3.9 installed version.
01:35:32.178 - 01:36:00.130, Speaker A: Yeah, there it is. You do have it. So now let's actually install the Cairo CLI. So to use the Cairo CLI, to install it, we need to have one global dependency called GMP. So you can use this command to install it. This is required for the stagnant CLI, not the Stagger CLI. You need this global dependency.
01:36:00.130 - 01:37:05.980, Speaker A: Now, let's go back to our project that we were working on, call it STARnet Test. We're back to our project and I'm going to create a virtual machine here for a virtual environment for Python. So when I install packages, I don't want to install it globally, just want to install it per project. So to do that, you do this command, you define that you want a virtual environment and then you give it a name I'm just going to call Cairo. Right? Then you activate that virtual environment so you can start installing it's called Cairo, cairo Bin Activate. So, as you can see, now we're inside of the Python virtual environment, so we can install the Carolang package. Just before I do that, I'm just going to upgrade Pip to the latest version just to be safe.
01:37:05.980 - 01:37:50.360, Speaker A: And now I can actually install Carolang Pip Install, which is going to give you the starting CLI. And it's installed for this particular project. It's not installed globally. If you are on a Mac, this might fail. I put some instructions on the guide was the alternative command that you can run on a Mac, because happened to me that it failed. So I found a solution. It's a more complex command, but it works all right.
01:37:50.360 - 01:38:15.644, Speaker A: So if this is working, so we should be able to execute the binary called stagnet, which is the one used by the CLI. And there we have it. We have zero point 11.0.2. Perfect. So we'll use this. The start CLI. In every command, you will have to define to which network you want to deploy or interact.
01:38:15.644 - 01:39:07.194, Speaker A: You use that with flags. And also you need to define which type of wallet. Remember that on Stargit, every wallet is a smart contract and you have to define to the CLI how the smart contract looks like and how the smart contract is able to verify signatures. So to be a little bit easier for now and not go into much into detail until we get to those sections, I'm going to define two environmental variables on my shell that the starting CLI is going to use and going to make our comments look a little bit simpler. So let me open my profile configuration. Mckaychrc Web open right now. Go to the bottom.
01:39:07.194 - 01:39:41.094, Speaker A: And I'm going to add two environmental variables. One is to tell every time that I run a target command that always targets the testnet alpha girly instead of Mainet. Right. I don't want to spend money right now. And also to tell them, because it's a kind abstraction, which type of wallet I want to use to sign transactions. So using this one here. Okay, so this would be export as well.
01:39:41.094 - 01:40:11.790, Speaker A: It's not export export. It's using an aversion of the open sippling wallet. Okay, this looks good. So I should be able now if I close my terminal and then open it again, should be able to access these environmental variables. I do echo network. There you go. So it's installed, it's available on our shell.
01:40:11.790 - 01:41:14.002, Speaker A: So now, next step, before we can deploy anything, we need to create a user account in our computer because we need to pay for declarations and deployments. So let's go back to our project for now. Stucknet test. Let me activate again the virtual environment for Python. Activate because the stern CLI is only available in this Python virtual environment. So create the new account at least to get the address of our user account, we use this command, the Stagnate new account, and we give it a name here. So using the strong CLI to create a new account in my computer and I'm going to give it a name, the zero point 11.0.2,
01:41:14.002 - 01:41:55.878, Speaker A: so I can add different wallets once the network keeps upgrading. So by doing that, it's not going to create the user account yet. It's just going to give me the address because the address is always it can be known before you deploy because it's just an algorithm that will be always the same. So this is will be the address of my user account while I deploy it. So I'm just going to copy this one here. And the next step is just I need to send test ETH to this account. I need to fund my wallet even before the wallet exists on chain.
01:41:55.878 - 01:42:47.790, Speaker A: This is called the counterfactual deployment, I think it's called. This is a common feature when you have a kind of abstraction. So I'm going to send a small amount of ETH to this address. So let me open I think I should have a wallet here in this VM that I could use maybe I don't have yeah, I have to send it from my so let me just bring this up. Give me a second to unlock my. Wallet without sharing my key or anything. Just a second.
01:42:47.790 - 01:43:22.080, Speaker A: All right. Okay, so as you can see, I have Bravos here, another account which already has some test ETH on Gurley. So I'm just going to send some test ETH there. So I need just to copy the address. And from here just going to send some amount. Let's send 0.5 test ETH.
01:43:22.080 - 01:43:45.368, Speaker A: So I'm using bravos. It says that it doesn't exist on chain, which is fine. This is the counterfactual deployment. We're going to talk more about that when we talk about a kind of abstraction in future sessions. For now, just follow along. All right, so I've sent a transaction to STARnet Testnet using my wallet. I can follow a lot of transaction here on a block Explorer.
01:43:45.368 - 01:44:14.470, Speaker A: So we need to wait until the transaction gets at least to the pending state before we can continue. So I think right now on testnet blocks are produced every three minutes. If I'm not mistaken, that's why you see the counter. So let's wait a little bit. Let me increase the font size. You can see better. So once we get to the pending state, it means that I have the funds available on that particular wallet and I can continue with actually the on chain deployment of my user account.
01:44:14.470 - 01:44:31.710, Speaker A: Again, this is a feature of account abstraction. Hopefully we can make it easier for you in the future with tools like Scarp that we haven't talked about it yet. Questions in the meantime, Omar, or people just post questions.
01:44:33.280 - 01:45:07.510, Speaker B: We don't have a lot of questions. We have a question from Michael. Sorry, Michael for the late reply. He's having some trouble compiling. There are a couple of questions for you. Are you using a log? Log out, Michael? And the second question is, are you using what version of the compiler? Can you check version please? Or if you're using Scarp, let us know. Scarp is using the newest compiler version because I think there's a problem with that part.
01:45:07.510 - 01:45:13.640, Speaker B: Okay. Dimitri is asking it would be nice opportunity to showcase faucets.
01:45:15.180 - 01:45:38.896, Speaker A: Oh, it's a good point. Yes. In this case, I'm sending Ether from another account that I have. But you can actually use a faucet. Where is it? Tools faucet. There you go. I'm going to put it in the chat link to the faucet where you just put your address and it will give you some amount of it.
01:45:38.896 - 01:46:02.250, Speaker A: The faucet has the limitation that it has a limit of how much test if it can give you every ten minutes. So if I try to use it now, I'm going to say, oh, you have to wait ten minutes, and I don't have time to wait ten minutes. That's why I went the other way. But if you are more patient, you can use it this way. You will get some test if on your address. If. Okay, so now that we have yeah, Omar, go ahead.
01:46:02.940 - 01:46:11.630, Speaker B: Sorry, David, here gleam is okay, go ahead. Gleam is mentioning something very important in the chat, but we can go ahead and mention it later.
01:46:12.000 - 01:46:54.990, Speaker A: Okay, so now that I have test, if associated with this address, I'm actually going to deploy my user account, which is a smart contract, to this address. So let me get back to my notes. Put in my secondary. Okay, so to deploy my user account, just clear the screen here. I use this command. So again uses the standard CLI. Now you see the deploy account command, always using this particular account that I created before, the one that we know the address.
01:46:54.990 - 01:47:48.380, Speaker A: So if I do that, it's going to actually deploy my user account to testnet. And you can see, so it sends the deploy account contract transaction so we can follow along the transaction using this hash on stack scan it dark scan value testnet. Put here the transaction hash. Because we need to wait until it gets to at least the pending state. That's when we know it's ready to be used. Because what we really want to do is to deploy the Cairo One smart contracts that I showed you before that we have a Vs code. Okay, so it's on the pending state.
01:47:48.380 - 01:48:30.280, Speaker A: So now we technically have now a user account that we can use to deploy and to invoke transactions. Cool. Let me just clear here and let's go back now. So before we can deploy a smart contract on Estanga, you have to first declare. It the reasons we better explain it in the next session. But for now, we're going to execute this command, just going to try to explain what it does. So basically, it's going to upload our Sierra, the Sierra code of a smart contract using this account to pay for fees, for gas fees.
01:48:30.280 - 01:49:03.540, Speaker A: And declaring is the previous step before you can deploy, because on a standard you can deploy multiple instances of the same declared code. We're going to talk more about that when we go to a con abstraction. For now, just follow along. So when we try to execute this, send this transaction to testnet, it's going to fail because this smart contract was deployed, was declared before, actually by me. So it should tell me there's an error. Yes, the error is that says the class hash blah, blah, blah is already declared. Right.
01:49:03.540 - 01:49:50.070, Speaker A: And that's what I was expecting. That's fine. It means that I can just go directly to the deploy. I don't have to declare, but because sometimes you don't know, it's better to just try to declare and see if it fails and you can move to the deployment. So oh, wait, did I copy? What was the address that I used? The address of my account. Just a SEC. Try to find out which addresses send the account location, number, transition center address.
01:49:50.070 - 01:50:26.670, Speaker A: Sorry, just a moment. All right. Yeah, I forgot to take note of what was the address of our user account. But now I have it because we need to send the deploy transaction. Let me try again at the declare because I need to take note of the class hash, which I didn't do before.
01:50:29.120 - 01:50:43.248, Speaker B: So some people are having trouble using the faucet. So it's very understandable. We are sending you or David. Do we have a method to send it without using the faucet? Right now?
01:50:43.414 - 01:50:49.760, Speaker A: Not right now. There's something right now how to do better because we know the faucet has the limitation.
01:50:50.980 - 01:50:53.572, Speaker B: We have a lot of people right now asking for.
01:50:53.706 - 01:51:36.194, Speaker A: Yeah, that's why we kind of knew, but it's hard to get around. Hopefully that's one of the things that we need to improve for next time we do base camp. For sure. So to deploy the smart contract, we need to provide the class hash that is provided here in the previous account. I'm just going to remove this because this is a previous thing that I did comment and the class hash is here. And with this, we should be able to deploy our smart contract. Okay, so the transaction was sent for deploying our smart contract.
01:51:36.194 - 01:51:59.844, Speaker A: We can follow along here. I need to remember to not delete anything from the terminal because I need those addresses. Paste. Paste. Sure. Okay. So this is transaction to deploy the smart contract that we wrote in Cairo one.
01:51:59.844 - 01:52:24.070, Speaker A: So we need to wait until it gets to the pending state before we can actually start interacting with it. So let's wait a couple of seconds. Is there any question in the meantime, Omar? No.
01:52:24.840 - 01:53:06.070, Speaker B: Michael is asking will there be a gross based CLI? And the answer is yes, there would be. It will be soon. But don't worry, the Python one is going to be working very soon and it's going to be the same. Also, a lot of people are asking for it. Maybe, Mamit, if you have some it and you can help me send to Thomas please, that would be great. In the meantime, let you know that all the transactions that I made, I send you the date and you should be able to find it in your now you can deploy your wallet because the transactions were successful. So you can deploy your account.
01:53:06.680 - 01:53:30.140, Speaker A: Yeah. So our smart contract has been deployed, so we can actually now interact with it because we know the address. This one. And you can see first of all, there is a Cara one smart contract. And we can go to the read write section. And if we compare to our code, you can see that our smart contract had two functions. One to increase balance and one to get balance.
01:53:30.140 - 01:53:50.070, Speaker A: This is read only. This is for modify the state. And if you see in this Explorer, you see the get balance. Right now it's going to be zero because it has no value. But we can actually use the right to increase it. I'm just going to connect the wallet. Wait a second.
01:53:50.070 - 01:53:59.780, Speaker A: That's one thing that I didn't prepare for to install a wallet here. So let me just do it on my Mac copy.
01:54:02.300 - 01:54:31.324, Speaker B: While let me explain this. Rafael is asking, can we bridge girly eat to STARnet? Yes, we can. You can get some eats, for example, using a faucet. Remember, the name Paradigm has a faucet that can give you girly eats to layer one. So you can send it to your MetaMask account, for example. And then from there, you can breach it using the bridge. I will send you the link in the chat and you can breach it to the actually, Clement already shared the bridge.
01:54:31.324 - 01:54:48.630, Speaker B: Thank you very much, Clement. Stargate. STARnet IO. It is on the chat. So you can use that to bridge to connect your MetaMask account to your Parabolos or Ariana account, and then you can bridge that to your account. So it is relatively simple. Yes.
01:54:51.240 - 01:54:56.308, Speaker A: Sorry, just going to we can go back to questions after. Perfect.
01:54:56.474 - 01:55:07.000, Speaker B: Just so I think some people might be leaving right now because of the time. So is there any question? Sorry, what is the homework? Is there any homework?
01:55:07.160 - 01:55:09.720, Speaker A: We'll send it in the email. We'll send an email with the instructions.
01:55:09.800 - 01:55:12.110, Speaker B: Okay, we'll send you an email. Thank you, guys.
01:55:13.200 - 01:55:54.140, Speaker A: All right, so I'm just going to send the value ten to the increased balance just in my wallet stylish transaction, and we wait a little bit until it gets to pending state. So we should be able to do the read operation and see the value of ten coming back. So let's wait a little bit. Let me see what questions we have. When will the main net support Cara One? Okay, we answered that one. Are we sure? Omar that is deployed to Cara one.
01:55:56.350 - 01:55:57.098, Speaker B: What?
01:55:57.264 - 01:56:02.462, Speaker A: Caro one is deployed to Mainet? Because Michael is saying no, it seems.
01:56:02.516 - 01:56:12.800, Speaker B: Like it's a little bit more complex. A contract has to be tested for a while and then it can be uploaded to the main net. So we cannot do it right now.
01:56:13.250 - 01:56:25.266, Speaker A: Gotcha. I didn't know that. Transaction is about to get to the pending state, which a little bit it.
01:56:25.288 - 01:56:55.280, Speaker B: Means while we wait for that, an anonymous attendee is having an error while deploying the account. It is called storage error code uninitialized contract. It is likely because you haven't sent it to your account. And then deploy the first as David showed, you first have to send to the address of your account date and then you can deploy it.
01:56:56.450 - 01:57:12.494, Speaker A: There you have it. Sorry, I thought you were finished. I query the balance again. Now I get the value ten. So to confirm that actually our transaction went through and modified the state of the smart contract. So now we can read the new value. So that concludes the tutorial to set up the environment.
01:57:12.494 - 01:57:38.486, Speaker A: It's a long one. It's a complex one. Again, cara one is fairly new. So hopefully just to do a brief summary, we had to install Rust, Python and Node JS. We compiled the Car one binaries using Rust. Then we configured those binaries to be available anywhere adding to the path. Then we install also Kyolang and we stole Python to be able to execute Kyolang.
01:57:38.486 - 01:58:02.340, Speaker A: And we installed the Vs code extension as well. So you get this nice syntax highlighting and some easy errors to spot there when you write. Thank you very much for staying so long. This was supposed to finish a while ago, but it took longer. Hopefully it was useful. You have the guides there and you have more questions. Please use Discord and hopefully you will be able to use the Faucet eventually and get some test it.
01:58:03.110 - 01:58:32.170, Speaker B: Yes, also if some of you are not able to get some it, let us know please in the telegram. So I sent it to as much people as possible, but I run dry so I will need to recharge. But let us know in telegram please. I won't be able to store all your addresses right now, but send it to the telegram or bridge it. Thank you very much to Clement who helped us a lot in this. Also Glenn. Thank you very much.
01:58:32.170 - 01:58:44.078, Speaker B: And Glenn mentioned also something very important that you have to change your contract hash okay, don't worry, we'll see the next the next time and we like to the book. So thank you very much folks.
01:58:44.254 - 01:58:46.286, Speaker A: Thank you. Take care. See you next week. Bye.
