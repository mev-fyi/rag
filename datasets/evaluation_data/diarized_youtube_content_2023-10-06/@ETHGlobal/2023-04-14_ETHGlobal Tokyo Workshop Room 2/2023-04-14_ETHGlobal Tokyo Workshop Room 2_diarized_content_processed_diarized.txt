00:07:55.570 - 00:08:30.740, Speaker A: Time. Is this okay? I don't know. Is this better? Can you hear me if I don't speak into the microphone? That's a good point. I'm going to talk into the microphone for the audio quality. Just checking. Is everyone here for the talk about Mina protocol and Snarky JS workshop? Room two. Okay, just because I know that sometimes people get the wrong rooms also.
00:08:30.740 - 00:08:53.616, Speaker A: So we've still got a couple of minutes. Oh, I don't have a time. I'm going to do a timer on my phone. Stopwatch it's. All right. I'll just keep a general eye on it. Also, I brought this prop with me.
00:08:53.616 - 00:09:22.804, Speaker A: This is some of the swag. We have actual recursive bags. So it's a bag inside another bag if anyone wants one. I've got one here and we've got more at the booth. So I said this joke to one guy earlier and he gave me a kind of laugh out of pity. And then he said to me, the thing about recursive humor is it's very repetitive. So he actually made a much better joke than I did.
00:09:22.804 - 00:10:10.474, Speaker A: I don't even know if he meant it or not, but I enjoyed it. I suppose I'll do. A quick show of hands just now as well. How many people here know what a zero knowledge proof is? That's a good amount. Okay, cool. How many people have done some sort of zero knowledge programming before with either Snarky JS or some other tool or language? Okay, cool. That's good to see.
00:10:10.474 - 00:10:34.410, Speaker A: So we're almost ready to get started. What should I do as well? Do I need to wait for a kind of signal? Is it like, on the dot, half past, or do I wait for a signal like we're live?
00:10:37.500 - 00:10:41.370, Speaker B: They'll give you a signal. Yes, you can start. It's already live, actually.
00:10:42.620 - 00:10:43.512, Speaker A: Okay. To start?
00:10:43.566 - 00:10:43.844, Speaker C: Yes.
00:10:43.902 - 00:11:21.368, Speaker A: Okay. Thank you, Aragato. Just start my timer as well. Konnichiwa, everyone. My name is Angus and I'm going to be talking today about MENA protocol and Snarky JS. So as a quick introductory slide here, as I said before, my name is Angus Maidment and I am working doing developer relations for the MENA Foundation. I live in Edinburgh in Scotland, and my Twitter is at blockchainbeard, so you can follow me on there.
00:11:21.368 - 00:12:06.470, Speaker A: I also have a poll going for all participants of ETH Tokyo. It's about how you add people when you're kind of exchanging telegram information. So I'd be really grateful if everyone votes in that poll. I've put a prediction for what I think their outcome will be as a shah two, five six hash, and I'll reveal it when the poll closes at the end of the day on Sunday. So there's a funny picture of me as well, blending into the background of the sign in my MENA hoodie. I've actually got the trackies on today, but no hoodie because it's too hot. So, the structure of the talk today, I'll first of all introduce the MENA protocol and give you a quick intro as to what zero knowledge proofs are.
00:12:06.470 - 00:13:25.200, Speaker A: I'll talk a bit about ZK apps, the kind of applications that you can build on top of Mina protocol, a bit of a deeper dive into Snarky JS, which is the TypeScript library that you can use to build zero knowledge proof based applications. And then I'm going to tell you about a program that we have got going at the moment called ZK Ignite and also the next steps for how you can get started building stuff. So the first section, what is Mina? Mina is an L one blockchain that's built from the ground up using zero knowledge proofs. And so to give a general introduction about what zero knowledge proofs are, it allows you to verify information in a private, trustless and decentralized way. So that has a number of useful properties that allow you to do things like create ZK roll ups and ZK EVMs of which you might hear about from other people here at the conference. You can do private transactions and keep data more private or hidden in some way. It's good for doing private voting.
00:13:25.200 - 00:14:24.944, Speaker A: It's got a lot of applications when it comes to identity as well, which is obviously an important aspect of Web Three. And also you can verify large amounts of computation efficiently. So a zero knowledge proof effectively says that you can prove that a program has run in a valid way and that the output is valid. You can prove that efficiently. So it's fast to verify the proof and you can do that without seeing all of the inputs necessarily. You can do that just by using what we call the constraints. So that gives you options to give your users more privacy and security by keeping their information private and also has implications for verifying things and scalability as well.
00:14:24.944 - 00:15:21.908, Speaker A: So, just to give you an idea, these are kind of like the function prototypes or kind of declarations for some cryptographic primitives that you might be familiar with. A hash function. You put a string into the hash function, which is h there, and you get out the hash which is also a string. So you can tell that two pieces of data are the same if they have the same output from the hash function. Right there's public key signatures. So you have a sign function. So you take a private key, you can sign a message with the sign function and that will give you an output of a signature, right? And then you can verify that signature using the corresponding public key, right? And so you put that signature, the message and the public key into the verification function and you get out.
00:15:21.908 - 00:16:07.744, Speaker A: Either this has been signed by that private key or it hasn't, right? So then you can tell if a private key has signed like a message or a transaction with a zero knowledge proof, right? The way to think about it is. There's a compilation step. So you compile your program and then that gives you so you have some code, you compile it and that gives you the verification key, which is a string. The verification key or index, that's a string. Then you have a proving function. So you have the program. You run the program with some inputs, right? You use the proving function to then generate the proof.
00:16:07.744 - 00:17:04.500, Speaker A: The proof is a string as well, right? And so then when you did the compilation step, you get the verification key, you use the proving function to create the proof. Then you can verify, you take the proof, you take the public inputs, but not the private inputs, and you use the verification key that you created at compilation time. You run the verification function and that gives you the boolean. The proof is valid or it's not. So now what we're doing is you can verify computation, not just that something has been signed, but you can verify that a program is run correctly and you can keep some of the inputs private or hidden. So you only need some of these inputs, the public inputs. So that kind of gives you an idea of how it's different to these other the zero knowledge proofs are different to other cryptographic primitives.
00:17:04.500 - 00:17:49.860, Speaker A: And I'm going to talk a little bit now about Mina protocol, which is, as I said earlier, a layer, one blockchain that is built entirely using zero knowledge proofs. Now, as I said before, zero knowledge proofs you can verify efficiently. And so Mina is a succinct blockchain. It's been built using zero knowledge proofs. So that it's very efficient to verify the state of the blockchain. So that means that you can verify the state and run like a light node on a variety of different hardware, including a mobile phone. So that's what that diagram on the left is saying.
00:17:49.860 - 00:18:45.600, Speaker A: It works using recursive ZK snarks. So recursive like proofs to kind of link the states of the blockchain together and to move it on. That's what this diagram in the middle is signifying. And so that's what keeps it lightweight as well. The fact that these proofs can be recursive, you can prove the last proof, you can kind of chain them together and the proof stays the same size. It's a constant size and it's fast to verify. And also it's interoperable in the sense that because you have this lightweight proof that you can quickly verify, you can use Mina as a kind of ZK layer and then take the state of Mina and kind of verify it in other environments, including for example Ethereum, to have it function as a kind of ZK layer for other blockchains or environments.
00:18:45.600 - 00:19:34.256, Speaker A: So this isn't just stuff that we're kind of postulating on. There's actually a grant being given jointly by the MENA Foundation and the Ethereum Foundation to this other foundation called the Nil Foundation. And they're building in EVM MENA state verification. So in the future when this is ready to go, you'll be able to verify the Mina state in an EVM smart contract, which is pretty cool because then you can do whatever you want on Mina, verify an EVM and know do stuff on the EVM chain. I'll take questions at the end, but thank you, Jonathan. We also have the openmina web node. So basically you can run this node in a web browser.
00:19:34.256 - 00:20:51.480, Speaker A: So when I was referring earlier to that diagram where it says you can run a node on your phone, you can actually spin up a Mina network node in the web browser, right? So you could in theory submit transactions directly through the web browser without having to go to like a third party RPC provider. So coming on to what you can do with Mina at the hackathon, right, is you can build apps on top of Mina that use zero knowledge proofs. We call them ZK apps. And so just to introduce the concept, to think about the concept of ZK apps, ethereum uses on chain computation. So you write your code in Solidity and then you put the actual code onto the blockchain and then all the nodes in the blockchain network, when you say you want to run a function in your smart contract, they all run the code that they have on the blockchain. And so it's verified by the fact that everyone does the computation right, and gets the same result. All the nodes on the network on Mina, the ZK apps use off chain computation with on chain verification, right? So you do a bunch of compute off chain and then you generate this proof that I was talking about earlier, and then that gets verified by the network.
00:20:51.480 - 00:21:32.536, Speaker A: So this has a number of advantages. One, you can give your users more privacy by keeping inputs to the function private. There's no gas fees in Mina, so you don't pay for computation, you just pay for the block space. You do all the computation you want, you generate a proof and then you put that proof in a transaction. All you pay is the transaction fee. There's composability using Snarky JS, our TypeScript library, so you can kind of program your own ZK apps to fit your use case. And there's scalability through rolling things up with this recursion that I'm talking about.
00:21:32.536 - 00:22:52.100, Speaker A: So the fact that you can use proofs to generate further proofs means that you can kind of roll things up and collapse them all down into single proofs that kind of verify everything that you've done. And also the interoperability thing through the blockchain being lightweight and quick to verify the state of. So to explain that in slightly more depth, just the process of it, just to kind of help you get a mental model of what's going on when you do the compilation step that I was talking about. So you write some code that's going to be your ZK app and then you compile the code and that produces the verification key. And so then you'd send a transaction to the MENA network that creates a ZK app account. So an account for your ZK app and that verification key is stored in that Zkap account, right? So now you have a ZK app that is associated with this verification key that's on the network right now on the left hand side of this diagram, this is your ZK app. So you serve the ZK app to a user in a web browser, for example, right? They run the ZK app with some data inputs that they put in to the web browser when they run the app.
00:22:52.100 - 00:23:40.310, Speaker A: That's the program bit that we got out of the compilation thing that I was describing earlier. So they run the program and it generates the zero knowledge proof. So they generate the proof and they include that zero knowledge proof in a transaction. The transaction gets sent to the MENA network and the MENA network uses the verification key that you sent when you deployed the ZK app, right? And then it uses the verification key with that verification function with your proof. And that then says whether this proof that you've generated is valid or invalid. If it's invalid, then the transaction is denied, doesn't go through. So that's kind of roughly how.
00:23:42.520 - 00:23:42.836, Speaker D: The.
00:23:42.858 - 00:24:38.256, Speaker A: Verification happens when you deploy. You put the verification key on the network and then the network nodes basically check your proof against that key when you use the ZK app and create the proof. So ZK apps are composed of methods, right? And methods you can think of as like functions in other smart contracts. So there's this diagram on the right. Basically you have inputs and outputs to these methods, right? You can have arguments that go into the method. There's a very small amount of on chain state that you can manipulate and it says here are some values from the state of the world. So that's another database that you have on your website or some other thing that you can kind of control or change and then that's the input to the method the method runs.
00:24:38.256 - 00:25:42.440, Speaker A: And then as a result of the kind of logic in it, you can make updates to the state of the smart contract or you can make updates to some other thing based on something that happens in your method. And so if you want to learn how to write methods, we need to go on to Snarky JS. Snarky JS is the TypeScript library that you can use to define, create and verify zero knowledge proofs. So it's giving you as a developer the flexibility to build applications that use zero knowledge proofs without having to be a cryptographer or kind of a highly capable functional programmer who can understand DSLs in OCaml. I mean, if you are into that sort of thing, you should definitely still come and talk to us because it's all kind of under the hood. But Snarky JS is basically giving you the TypeScript interface that a lot of developers are more used to. Here's some logos that you might recognize.
00:25:42.440 - 00:26:29.944, Speaker A: So we have basically familiar tooling that you'll be used to. We've got good IntelliSense support in Visual Studio which makes it the developer journey a bit easier. And you can write all your tests in JavaScript using Jest. So this is five steps to show you how easy it is to get started. The first one is to install the Zkapp CLI tool, which is a CLI tool that kind of helps you with building, as in compiling, configuring and deploying your ZK apps. Then it's one simple command. ZK project creates you a new project directory and it actually has a demo kind of smart contract in there already.
00:26:29.944 - 00:27:14.248, Speaker A: The fourth step is to configure it with our kind of testnet information. There's also a step here where you need to go to the faucet. If the faucet's giving you any trouble, you can kind of come to the booth or message me or tweet at me and I can give you some testnet mina because I've managed to secure a supply of it especially for this weekend. And then all you do is ZK deploy Berkeley and then that's it. You've deployed your ZK app to program in Snarky JS. You also need to understand that we use field elements. So these are elements of a finite field which we use because that's how the cryptography works.
00:27:14.248 - 00:27:55.940, Speaker A: In snarky JS It can store quite a large number up to almost 256 bits. So it's a built in type in Snarky JS and it has built in methods as well. So down here you can see an example where you declare a constant called sum and then you make it out of two new fields, one of which is doing the dot add method to another new field, which is three. So that sum will end up being four. But it'll be a field element, right, which is what you need to use if you want to do things. In snarky JS there's also some other built in types, including some crypto stuff. So you've got public and private keys and signatures.
00:27:55.940 - 00:28:36.676, Speaker A: And also there's a Merkel tree implementation that you can use for things. And these all have built in methods on them as well. So if you want to find out more about that, it's all in the docs or you can use it IntelliSense if you use Visual Studio code that'll tell you what the methods are. So this is kind of an example smart contract that just to give you an idea of what it looks like. I thought I was going to have a kind of pointer that I could use. So I'll try and point and I can actually refer to the lines. So in line twelve you've got this state right, kind of variable called NUM.
00:28:36.676 - 00:29:24.832, Speaker A: So you have a very small amount of on chain kind of state storage. And then what this is doing is this method down here on line 22 is saying we set the initial state to one, which is a field, remember, because we're using field elements. And then the update method on line 26 is saying check, get the current state, check that that is actually equal to the current state. So you're kind of putting it into the proof that this is the state that you got and it's equal to the variable that you have. And then it's saying, add two to the current state. So then this is the demo smart contract that you get. So it'll just every time you call update it'll update the state variable by two.
00:29:24.832 - 00:30:06.636, Speaker A: So that's what snarky JS looks like. Also, this is the Mina colored theme that someone made for Visual Studio, like the syntax highlighting. So if you want to get hold of that, I think we can maybe link you up to it. But I'm not entirely sure. So, next steps recursion. We've been talking a lot about recursion, obviously making some bad jokes with the bag within a bag. But one of the really powerful aspects, one of the powerful features of Snarky JS is that you can do infinite recursion, right? So you can use proofs as input to other proofs.
00:30:06.636 - 00:30:44.568, Speaker A: So you can kind of roll proofs up into a single proof to verify that several things have happened with intermediary kind of proof stages. So this is a diagram here of kind of, oh, here's a Snark. And then you put that into the next Snark. And kind of the proof stays a constant size the whole time. So you can kind of infinitely roll up these proofs, right? And so an example that I'll take you through is in the case of a card game, if you're player one, you take your turn according to the rules of the game. You produce a proof that you've done a valid move. You pass that proof to player two.
00:30:44.568 - 00:31:17.316, Speaker A: Player two can verify the proof. They can verify that player one has taken a valid turn. Then they can make their turn. They can pass the proof to player three. Player three can then verify that player two has taken a valid turn as well, right? And so in that way, you can kind of go through as many hands of the game, as many rounds as you want, and then you can do it all off chain. And then when you have the end proof, that's kind of the end state of the game. You can then put that onto the blockchain to show these three players have played 20 rounds of this game.
00:31:17.316 - 00:32:16.696, Speaker A: Okay? And so this is something that's quite interesting. A lot of the time when people talk about roll ups, they're talking about batching transactions together, right? But now with Mina and Snarky JS, you can start to think about rolling proofs up together, right? And that opens up quite a lot of different kind of ideas and use cases. So that's something recursion is something that is really quite exciting about Snarky JS and will open up new, different ideas. So here is the prize pool for ETH Tokyo Hackathon first prize, 8002nd, 6003rd prize, $4,000. And there's a $2,000 pool for kind of runners up who don't get the top three, but still submit a project that's built with Snarky JS. There's also this program called ZK Ignite, which I mentioned earlier. It's a sort of cohort based grants program.
00:32:16.696 - 00:32:43.728, Speaker A: So you submit a proposal, there's some voting, and if you get funded, you get funding for your project. And also you kind of go through the process with a bunch of other projects. So it's a kind of cohort like that. And you get hands on support and kind of training and kind of community type things going on. And so there's a new cohort starting on the 24 May. You can scan this QR code to get more information. And one more QR code.
00:32:43.728 - 00:33:07.304, Speaker A: This is like the Hackathon starter kit. It's got a link to the documentation and also a couple of other things. So please come and talk to us after this workshop as well, or at the booth which is in there. I'm not going to try and describe where it is. We've got a big Mina sign behind our table, though. And so that is the end of the presentation. Thank you very much for being here.
00:33:07.304 - 00:33:15.310, Speaker A: We've got about eight minutes left for questions. I'll take this question down here first.
00:33:16.240 - 00:33:21.020, Speaker E: So there's a verification key per app? Per ZK app.
00:33:21.090 - 00:33:21.468, Speaker D: Yes.
00:33:21.554 - 00:33:23.724, Speaker E: That means there's a trusted setup per app.
00:33:23.762 - 00:33:25.680, Speaker A: Like, that's a good question.
00:33:25.750 - 00:33:26.492, Speaker E: Reference stream.
00:33:26.556 - 00:34:09.900, Speaker A: There is not a trusted setup per app. And so it's because the proof system that we use, it's called Kimchi, and it uses something that's like bulletproofs that uses the inner product argument to avoid the need for trusted setups. Don't ask me to explain it more than that because I don't know all the math. But the inner product argument way of it's kind of like something that I don't want to call it a worker either. I'm not sure the correct terminology, but basically there isn't a need for trusted setups because they use this inner product argument methodology.
00:34:11.360 - 00:34:14.220, Speaker E: This verification key, what is it?
00:34:14.370 - 00:34:16.910, Speaker A: It's a string, okay?
00:34:18.980 - 00:34:21.890, Speaker E: It's an input to each proof of the app.
00:34:23.220 - 00:35:24.310, Speaker A: So when we're talking about the network, the verification key, when you deploy your ZK app, the verification key gets stored on the network. And then the Mina network uses the verification key to verify the proofs. So that the verification key and the proof go into the verification function. And then out comes proof is valid, proof isn't. In a boolean. The docs say the proof system is plonkish, right? And also there's the Mina book, which is a load of documentation about the proof system, which has a lot of math and a lot of cryptography, which I can point you to, which will have all the answers that you're looking for. Thank you, I'm sure.
00:35:29.080 - 00:35:41.390, Speaker E: So you mentioned when you deploy a ZK app, you store the verification key on chain, and there's also some very small amount of state that is on chain that is accessible to each of these ZK apps. Is that correct?
00:35:41.920 - 00:35:42.668, Speaker A: Yes.
00:35:42.834 - 00:35:47.740, Speaker F: How is the blockchain fixed size with that state?
00:35:47.810 - 00:35:58.610, Speaker E: I'm assuming there's not an upper limit to the number of ZK apps that can be deployed on chain. So how can you store verification key on a fixed size blockchain without increasing the size?
00:35:59.620 - 00:36:54.236, Speaker A: The only limit to the amount of ZK apps that we'll have on chain is the imagination of developers like all of you. Also, the blockchain isn't a fixed size in the sense that so the state proof stays a fixed size, which you can verify the whole state of the blockchain from. But obviously there's other things which kind of make up the blockchain, right? And that goes into how the MENA network works and the kind of different roles and entities that there are. There's different kinds of nodes, right, that have different storage requirements. But the fixed size thing, so you may have seen this before as well, it's a number of kilobytes. The fixed size thing is the size it takes to verify the state of one account, and that includes the overall state proof for the latest block in the MENA blockchain.
00:36:54.348 - 00:36:56.336, Speaker E: So the state proof is what's?
00:36:56.368 - 00:36:56.932, Speaker D: Fixed size?
00:36:56.986 - 00:36:58.390, Speaker E: It's not the state.
00:36:59.160 - 00:37:00.388, Speaker A: Yes, fixed size.
00:37:00.474 - 00:37:01.110, Speaker E: Okay.
00:37:02.920 - 00:37:23.288, Speaker A: But to verify the state of a single account, it's a fixed size per account. So then I think it would be if you wanted to run a node with the whole state of every account, I think it would be N accounts times that number, but I'm not sure on that.
00:37:23.374 - 00:37:23.844, Speaker C: Got you.
00:37:23.902 - 00:37:31.932, Speaker A: I'm mainly dealing with the ZK app stuff, but I'm sure we can get someone to go in depth on the node stuff with you if you like.
00:37:31.986 - 00:37:32.590, Speaker F: Awesome.
00:37:33.620 - 00:37:36.290, Speaker A: Thank you. There's a question over here.
00:37:39.460 - 00:37:51.908, Speaker B: Thank you. It was nice presentation. Could you tell more about the vision of Zke apps ecosystem? What types of products you want to have on it? Like DeFi some games or whatever?
00:37:52.074 - 00:38:35.696, Speaker A: That is a very good question. So we've just run the first cohort of that ZK Ignite program and the kinds of ZK apps that were funded by a kind of council of electors who were kind of community members. The kind of things that are getting funded are L, two roll ups that do kind of batch things together, transactions or other kind of bits and pieces. We've seen a couple of roll up solutions. We've seen data availability solutions. So at the moment, there's still quite a lot of infrastructure and tooling being built. There is one thing was really cool, actually.
00:38:35.696 - 00:39:37.028, Speaker A: It's a kind of verification app for people who get kind of different colored belts in martial arts and you can kind of check who has given whom each belt and things like that. So that one was quite interesting, I think, when it comes to things like DeFi, because the computation model is different to EVM quite a lot of the things that we think about in DeFi. It's not really defined how to do it on Mina yet. So that presents to you an opportunity, I think, but also a challenge. So you kind of need to figure out a different way to do things on Mina, but then if you do figure it out, you'll be the first person to do it. So that's why it's both a challenge and an opportunity, I think. But we really are just getting started with ZK apps, so it's a good time to get in early.
00:39:37.194 - 00:39:38.150, Speaker B: Thank you.
00:39:40.280 - 00:39:45.050, Speaker A: One last quick question and you can ask me questions outside as well.
00:39:46.140 - 00:39:50.970, Speaker F: I was just wondering where the proving actually gets done. Is it in the user's browser or is it somewhere else?
00:39:51.440 - 00:40:14.080, Speaker A: It's in the browser. I think we have enough time to do this answer. So you run a ZK app in the browser and what that is doing is running the program and then producing the proof and that's the proving. Right? So you run the program, you produce the proof in the browser and then the verification happens in the network.
00:40:14.820 - 00:40:20.230, Speaker E: Okay, I'll ask later about timing though. Does that have substantial lag or is it pretty quick?
00:40:21.560 - 00:40:24.192, Speaker A: Yes, you're right. That is a question for come to the booth.
00:40:24.256 - 00:40:25.190, Speaker E: More death later.
00:40:25.640 - 00:40:32.340, Speaker A: There's a lot of asterisks attached to that. So thank you very much everyone, though. Bye bye to everyone on the internet.
00:40:40.800 - 00:40:41.550, Speaker F: It.
00:43:01.160 - 00:43:01.764, Speaker D: Hello.
00:43:01.882 - 00:43:10.630, Speaker F: Okay. Oh yeah.
00:43:13.960 - 00:43:14.710, Speaker D: This.
00:43:31.570 - 00:43:32.510, Speaker F: Oh, cool.
00:43:32.660 - 00:43:33.360, Speaker D: Awesome.
00:43:37.190 - 00:44:03.354, Speaker F: Okay. Hey everyone. So we are from Tyco. My name is Dave, I work on developer experience and this is Brecht, our big brain. So, yeah, welcome to our workshop. We're going to be talking about Tyco, which is ethereum equivalent ZK rollup. And we'll be giving a little bit of like a workshop on building a DAP as well.
00:44:03.354 - 00:44:47.880, Speaker F: Give an overview of the bounties that we have and then also give some insights onto some cool things that you can build. Like I said, we'll just go over the bounties, talk a little bit about Tyco ideas and then code base walkthrough. Yeah, so these are the different bounties that we have. We have over $20,000 in bounty prizes that you can win. So we have best DApps. It's just like a smart contract DAP that you can develop infrastructure improvements. Catch mev some interesting mev stuff, ZK zone where you can work on some interesting ZK stuff.
00:44:47.880 - 00:45:10.366, Speaker F: Protocol economics. This would be like kind of a no code bounty. And if you're interested in economics and kind of dynamic systems, I guess this would be. A fun one. Ethereum public goods. We find this one particularly exciting. If you can do something that's just better for the whole space, that would be really great.
00:45:10.366 - 00:46:02.270, Speaker F: And finally, just a fun bounty where you just can do whatever you want, I think is interesting. All right, so what is tyco? So basically, like I said, it's an Ethereum equivalent ZK roll up. And if you look at this graph here, you can see we have these two axes of decentralized and centralized and Ethereum equivalent and one that diverges from Ethereum equivalents a bit more. And we're at the extremes of both of these axes where we're fully decentralized in terms of proposing blocks and also proving blocks. And then also we're Ethereum equivalent in the sense that we don't make any changes to the Ethereum stack. Even more peripheral things. We essentially don't really change anything to make it easier to generate proofs.
00:46:02.270 - 00:46:39.782, Speaker F: Yeah, another word for this is a type one Zkevm, if you're familiar with it. It's also l one sequenced. If you're familiar with Justin Drake, he made like a post about something called a based roll up which is using the L one to do the sequencing. So when you propose blocks to create the Tyco chain, we just rely on Ethereum to do the sequencing. We're fully open source and MIT licensed. It's a community project. I think we have like 30 contributors on our Mono repository on GitHub and I think we have over 50,000 members on our discord.
00:46:39.782 - 00:47:15.074, Speaker F: So we really try to keep everything open and let everybody just help contribute. We really like that. And yeah, as I said, fully permissionless block proposing and proving. The only reason I said permissionless here instead of decentralized is because in regards to proving maybe the decentralization doesn't matter as much as it being permissionless. But I won't go into too much length about that now. Okay, cool. So next I'll just give a run through of what the stages look like for the chain.
00:47:15.074 - 00:48:01.400, Speaker F: Right? Like as the chain is moving on, like what are the kind of steps that happen. So, yeah, first you see here we have these users of the roll up and they submit transactions to the mempool and everyone is able to run a node, right? You can just go to our GitHub repo and you can spin up a docker image and run a node. So they're all running this node. It's a fork of Geth, which is the execution client. And basically those nodes can run as a block proposer. It's just like an environment variable. You're going to enable it and then after your proposer, you just look through the transactions in the mempool and you can propose a block to the contract that we have deployed on L One.
00:48:01.400 - 00:48:37.060, Speaker F: And yeah, basically at the time a block is proposed I think I kind of show this in the next slide. We can already build the roll up state right after we've posted that transaction data, and that's because we have really well defined validity rules that we derive from the ethereum yellow paper. And we do those validity checks to be able to compute the next state for the roll up. So you don't have to wait for approve or anything like that. At the moment a block is proposed, the chain can progress. So, yeah, that's how we kind of derive the roll up state.
00:48:38.550 - 00:48:38.914, Speaker D: Yeah.
00:48:38.952 - 00:49:16.638, Speaker F: So in terms of proving blocks, you see here, I have these three colors, like blue is like, proposed, and you can just keep proposing blocks in sequence. And then in green you can see is when you can prove a block. Right. And really what that is, is it's just proving one state to another state. It's like proving that transition. But the reason why there's also this verified state is because it's assuming that the state transition that you're proving has a valid parent or a verified parent. So the first block, the Genesis block, is already implied to be to be valid because it's the first one.
00:49:16.638 - 00:49:31.970, Speaker F: So it's only when all of the parent blocks have also been proven that we can consider a block as verified. Yeah. So you propose blocks, people go around and also this block proving it can be done in parallel.
00:49:36.570 - 00:49:37.320, Speaker D: Yeah.
00:49:40.330 - 00:49:51.674, Speaker F: Exactly. That's a good question. So the next slide is like boom, yellow. Yeah, exactly. Okay, cool. That was a great question. Okay.
00:49:51.712 - 00:49:51.914, Speaker D: Yeah.
00:49:51.952 - 00:50:07.630, Speaker F: So you can do all of this in parallel, and then at the moment that they're all proven to Genesis, they're all verified. Okay. Now I'm going to give it to Brecht and he's going to talk a little bit about some things to think about as they relate to our bounties.
00:50:10.770 - 00:50:34.598, Speaker C: Hey, everyone. So, yeah, I'm going to go over the bounties pretty quickly. There's a lot of detail that you could go into. There's quite a lot of bounties. All right, I'm a bit smaller. Yes. So, yeah, there's a lot of different bounties, and to go into detail for all of them would be quite difficult.
00:50:34.598 - 00:51:23.558, Speaker C: So I'm going to be pretty quickly describe some of the bounties, give some extra detail, but if you're interested in them, please contact team members and they will give you some more information afterwards. So, yeah, one of the first one is kind of like infrastructure improvements, where the goal is to just improve the usability of our chain. And so there's a couple of possible tasks you could work on. One is, for example, the NFT bridge. So we created an RSC 20 token bridge ourselves and an Eat bridge ourselves. So you could depend on that as like, a sample of your NFT bridge. But yeah, our Bridging is kind of like very flexible, so you can basically write your own Bridging SmartCraft just by depending on this L One block hash that we bring available to L Two.
00:51:23.558 - 00:52:03.470, Speaker C: So our RSC 20 implementation is like, one of them that you could use, but basically you can do whatever you want to make this bridge. The other one is also, like, Bridging related. So currently, we use Merkopisa tree check in our smart contracts. The positive thing about that is kind of like, yeah, we also type one equivalent. So this makes sure that we can actually reuse a lot of code that other bridges already use to do that. But the downside is that it's quite expensive because the Merco Patricia tree proof is quite big. And also the verification cost in the Smart Contract is also pretty significant.
00:52:03.470 - 00:52:53.010, Speaker C: So we can try to optimize that by instead of doing it in a Smart Contract, we just wrap the Merko Patricia Tree tree Check in a CK circuit, and then we just have to verify this circuit plus a small proof. And so we kind of balanced out the proof size, like the data size compared to the computational cost. And on L two, the computational cost is kind of less significant than the data cost. And the other two ones is kind of like more UI related. So one of them is like, yeah, we have like, an L two Block Explorer, and currently it doesn't add some of the ZK stuff to it. So, for example, it doesn't show you if a block is proven, if it's verified. And so it would be great if users can actually see that as well on the Block Explorer.
00:52:53.010 - 00:53:32.138, Speaker C: Another one is we want as many people as possible to be able to run a proposal. It's kind of, like, necessary for the decentralization of our block production. It's also necessary for some of the decentralization of our proving. So it's important that it's as easy as possible for everybody to run a node if they want to. The other one is kind of like the general protocol proposing improvements. So here the goal is mainly to improve the efficiency of proposing blocks. And so, yeah, one of the first tasks is kind of like improving the block, proposing cost estimation.
00:53:32.138 - 00:54:14.042, Speaker C: So the difference is we really try to be as much as possible to, like, Ethereum. But the difference between L two and L two, an L one and an L two is that proposing a block on L one is completely free. It doesn't matter how much data it costs, like, how big a block is in terms of data and things like that. And for an L two, this doesn't matter because we actually have to publish the data on the L one. And the costs for some of these resources that we use on Ethereum is also, like, time dependent. And so that's kind of like, one of the more challenging things. It's kind of like, okay, proposers want to put blocks on RL two, but yeah, they still want to make a profit, so they have to have a good strategy to do it.
00:54:14.042 - 00:55:18.782, Speaker C: And so, for example, transaction data needs to be included on Ethereum for us. And so that takes data on the L one blockchain that calls gas and so that needs to be taken account if they want to be profitable. The one other thing is also like what Dave mentioned is we have a based sequencer so we kind of depend on the lo one to do our sequencing. But yeah, if we have no extra mechanism on top of that, that means that many proposers would submit blocks at the same time and that would mean that many transactions would actually fail and waste gas because many proposals would submit the same block and they would include the same transactions and obviously that would be very inefficient. So the way that we can improve that is to integrate latchbots which allows us to proposers to say like, okay, include my block only when it's successful and then all other blocks will not be included. But that's great because they don't want to be included if another one another proposer is faster than it. The other task is kind of like more exotic.
00:55:18.782 - 00:56:14.500, Speaker C: So one of the things that Tyco protocol allows is kind of like these shared sequencers because our current protocol is kind of like already fault tolerant. So that means that a shared sequencer does not need to have the full state available of all the L two S because it's okay for us for a sequencer to include a transaction that is actually invalid, so the protocol will skip over. It's kind of like inefficient so you want to avoid it, but we can fully support that out of the box. And the other one is also similar to that. So for the base sequencer we kind of want to use Flashbots to include, for the proposals to include in our L two blockchain. The other one is like, yeah, if we have an L two then there's also like map to be exploited on the L two. So being able to also have this map boost availability on the L Two is very useful for proposals to make money and optimize for that.
00:56:14.500 - 00:56:55.790, Speaker C: And the last one I'm going to talk about is like the protocol and economics. So yeah, the goal here is that the economics need to be simple and robust and so two main fees that need to be paid one is if a proposal submits a block then he needs to buy block space. It's similar to the ethereum. EIP one five f nine. The other one is that if you create a block there's also like an extra zero knowledge proof generation costs associated with it. So that's the two main fees that need to be paid for the EIP one five nine on the proposed site, it's very similar to the Ethereum one. But there's a couple of differences.
00:56:55.790 - 00:57:37.902, Speaker C: For example, instead of having a fixed block time there's like no fixed block time on R two. And also the L one mechanism depends on this variable block size, which we also don't want to support because it's less efficient. And the final one is the proof fee. So the proof fee is generally paid by the proposer, but it doesn't have to. It kind of depends on the mechanism there. So there's some ideas on how the prover fee could be paid. So one of them is kind of like a race where the first that's submitted actually gets a reward for the auction based.
00:57:37.902 - 00:58:19.020, Speaker C: It's kind of like depending on how much the proofer wants to pay and how long the proof generation cost takes will now. And the final one is also like an interesting one where the proof of stake mechanism, where the sorry. Where the California depends on how much each prover gets like tyco stakes or something like that. And so then we can just use statistics to give some of them. Depending on how much is staked, we can actually assign blocks to them.
00:58:23.010 - 00:58:24.400, Speaker F: Okay, cool.
00:58:25.330 - 00:58:25.694, Speaker C: Yeah.
00:58:25.732 - 00:59:05.914, Speaker F: A lot of fun stuff there. Oh, crap. All right, we're good. All right, so yeah, the next one is just going to be like me using open source tool that I made, which is called DAP Slaps. So basically the idea is that you can just in one click, bootstrap your DAP. And I know there's a few variants of these, but I tried to make it fairly unique in the technology that's used. It uses Svelte, it's a mono repo configured with foundry and uses a lot of kind of the latest tooling to give a really frictionless developer experience.
00:59:05.914 - 00:59:43.294, Speaker F: And yeah, basically the idea is just want to help so that you don't have to waste too much time trying to build your DAP and just get moving on writing smart contracts or doing something more fun. So, yeah, you can scan this QR code if you want to check it out. But aside from that, I'm basically just going to emulate what you would be if you're using this tool and just set up adapt with it. Yeah, let's see here. Okay, so this is the repo. This is the button. Yes.
00:59:43.294 - 01:00:08.800, Speaker F: You just connect your GitHub. I'll just call this blah, blah, blah, blah, blah. So yeah, it'll deploy. It like on Versaille. And the only thing that you need is this like one environment variable, which is like a web three modal project ID. I'm going to get one online. I think it's let's see here.
01:00:08.800 - 01:00:15.760, Speaker F: I think wallet, connect, cloud. Okay.
01:00:23.570 - 01:00:24.266, Speaker D: All right. Yeah.
01:00:24.308 - 01:01:06.060, Speaker F: So you just create a new project here and then it'll give you like an API key. I'll just copy this and I'll add this and then okay, technically two clicks, I guess. All right. This might be like a little bit of an awkward silence just because it needs to build. I don't think it'll take too long though. Let's see if it cloned the repo, at least on my profile. Oh, there we go.
01:01:06.060 - 01:01:20.670, Speaker F: Okay. All right, as I'm waiting for this to build. I'll just clone the repo, and then maybe we can see it locally. So you can just follow these steps. They should be fairly clear in the README.
01:01:22.070 - 01:01:22.386, Speaker D: Yeah.
01:01:22.408 - 01:01:59.310, Speaker F: So I'll just go through this, maybe increase my font size. Okay, so just cloning this, and then what are the next steps? Yeah, it doesn't clone the sub modules, so you have to do this one forge install. See here? So CD into the directory. Do this forge install. If you need to install Foundry, there's, like, a link to it here. It's, like, fairly simple, I think. It's just like a curl command.
01:01:59.310 - 01:02:54.234, Speaker F: And then, yeah, you can just run this setup script, and this will just install the node packages and also install the forge dependencies. Okay, so next step would be, like, generating this BIP 39 mnemonic. And you don't have to do this, but I just kind of recommend this if you're hacking, because you might want multiple accounts, like, multiple addresses, and you don't want to use your main one. So you can just create a BIP 39 mnemonic and use that. And basically, you can use this as an input. If you're not familiar with Foundry, you can run, like, a local Ethereum node, and you can just send in the BIP 39 mnemonic that you generate here, and it'll just bootstrap the network with these accounts and give them all, like, a bunch of ETH. Yeah, I'll just create that, and then we'll set that in the environment file.
01:02:54.234 - 01:02:58.240, Speaker F: There's a single environment file. Just put this here.
01:02:58.690 - 01:02:59.294, Speaker D: Okay.
01:02:59.412 - 01:03:05.650, Speaker F: Source the environment file, and then I think that's it.
01:03:05.720 - 01:03:06.146, Speaker D: Yeah.
01:03:06.248 - 01:03:33.670, Speaker F: Okay, so I have three windows here. The reason for that is because we'll use one window to start the local anvil chain. We'll do another one just to, like, I don't know, do random terminal stuff. And then the last one will just be, like, running the front end of the app. Is this done yet? Okay, cool. So this is done. So like I said, you literally just need to do that, like, two clicks, I guess, and then you can go and it'll be deployed.
01:03:33.670 - 01:03:54.290, Speaker F: So you'll just have a fully functioning DAP that you can use. This doesn't use any weird. It's, like, very minimal. I didn't put any CSS or anything like that. It's like a single file. You can just rip it out and just use HTML, and it's just very minimal. So, yeah, this is the DAP, but we'll get back to working on it locally.
01:03:54.290 - 01:04:26.570, Speaker F: Okay, so I sourced the environment file. Now I'll just follow these three steps for these three windows. I'll start the local anvil change with the BIP 39 mnemonic, and you can see here that it gives you all of these accounts that you can use along with their private keys. So you can just take any of these private keys, and you can just import them into MetaMask so that you can use it in your application. I guess I'll just do that as well. Okay, cool. I don't know why it says Sepoli ETH.
01:04:26.570 - 01:04:56.994, Speaker F: All right, so I started the local anvil chain. That's good. Now we can interact with that. The second thing I'll do is I'll run this script. It's a deployment script just to deploy kind of a dummy smart contract to that local anvil chain. And also it uses, like, Wagme to generate all of the types. So it's like, fully type safe when you interact with the contracts values required for fork URL.
01:04:56.994 - 01:05:02.518, Speaker F: Okay, so it's probably because I need to go in here.
01:05:02.684 - 01:05:02.966, Speaker A: Yeah.
01:05:02.988 - 01:05:09.234, Speaker F: I didn't source my environment file, so I think that was the issue. Okay, cool.
01:05:09.292 - 01:05:09.514, Speaker D: Yeah.
01:05:09.552 - 01:05:19.562, Speaker F: So this is just compiling the dummy smart contract. I'll go through the folder structure too, so you can kind of see but this just compiled and deployed the contract. I think we should have gotten a receipt.
01:05:19.626 - 01:05:19.854, Speaker D: Yeah.
01:05:19.892 - 01:05:43.780, Speaker F: This is like a transaction receipt here. Okay, cool. So now we'll just start, like, the front end of the application. I think it's Pnpmf. All right. We can visit it on localhost. Yeah, this is the application.
01:05:43.780 - 01:06:01.926, Speaker F: And let's see. Does this work? Okay, cool. So it says I'll just show what the contract looks like. So basically, like I said, it's a mono repo. One of the folders has all of the foundry configuration. The other folder is a Svelte front end. So in the contracts folder, we can look at the contract I just deployed.
01:06:01.926 - 01:06:22.526, Speaker F: It just said, like, hello, world here. And the cool thing that this has integrated is if I update this actually yeah. If I update this and then I redeploy the contract right. It'll just update the contract address, which is used by the front end. And now you can see here's the new message. Right. So hopefully this can give you really rapid development.
01:06:22.526 - 01:06:47.226, Speaker F: You'll need to change contract addresses or anything like that. It'll just update all reactively. Okay, so what else do I want to show here? Okay. Yeah, so like I said, there's this source contract folder. There's obviously like a test folder if you want to write unit tests while you're hacking, but that would be kind of weird. This is the deployment script. You can see here.
01:06:47.226 - 01:07:03.662, Speaker F: This is where it's deriving that mnemonic. Yeah. Creates this smart contract. This broadcast folder has some metadata from doing the deployment. Okay, cool.
01:07:03.716 - 01:07:03.934, Speaker D: Yeah.
01:07:03.972 - 01:07:06.798, Speaker F: So this is just like you can just interact with a contract here.
01:07:06.964 - 01:07:07.246, Speaker D: Yeah.
01:07:07.268 - 01:07:25.602, Speaker F: So it's pretty simple. It's just a dumb smart contract. I don't have enough supply ETH. Okay. But yeah, I'll show one other thing really quick. I guess I only have four minutes here, and I want to be able to answer questions. We we have one page where we integrate the Tyco signal service.
01:07:25.602 - 01:07:54.880, Speaker F: So Bret talked about that a little. Really? Because our protocol is like, ethereum equivalent, and we just use Merkel Patricia tree for the state. We can just send arbitrary messages using merkel proofs. And the Signal Service is a contract that we expose where you can do that merkel proof verification easily. So if you want to do that thing, like build the NFT bridge or do something related to cross chain messaging, then you can just use this as an example on how to interact with the Signal Service.
01:07:56.850 - 01:07:58.078, Speaker D: Okay, cool.
01:07:58.244 - 01:08:00.190, Speaker F: So let's go back to the slides.
01:08:01.090 - 01:08:01.454, Speaker D: Yeah.
01:08:01.492 - 01:08:39.020, Speaker F: So, yeah, big thanks to everyone for coming here and listening. I think Tyco is going to be, like, a really interesting thing if you don't have too many ideas for the hackathon. We actually have, like, 20 people here in Tokyo, which is pretty crazy. And I know that we're all really willing to just talk about anything, so if you don't know what you want to build, there's a whole playground of things you can do. Whether it's economics, building a DAP, doing something that's not even really Web Three related, and writing some scripts to run a node. I think we'd all be down just, like, stop by our booth. We'd love to talk to you about anything and help you build.
01:08:40.110 - 01:08:40.474, Speaker C: Yeah.
01:08:40.512 - 01:08:52.210, Speaker F: So I guess now, does anyone have any questions? What's your RuneScape username. My RuneScape username. It's Dr. Super fresh.
01:08:54.630 - 01:08:55.380, Speaker D: Yeah.
01:08:59.670 - 01:09:01.970, Speaker F: For Block, proposers for Tyco.
01:09:06.070 - 01:09:06.834, Speaker G: Oh, I see.
01:09:06.872 - 01:09:07.460, Speaker A: Okay.
01:09:12.440 - 01:09:12.928, Speaker E: All right.
01:09:12.954 - 01:09:18.888, Speaker F: So for block proposers for Tyco, is it just, like, first come, first serve for whatever hits the smart contract first.
01:09:18.974 - 01:09:19.848, Speaker C: On the L One?
01:09:19.934 - 01:09:20.184, Speaker D: Yeah.
01:09:20.222 - 01:09:32.524, Speaker F: Anyone can propose blocks at any time, but it's up to the L One to decide how those are included or when they're included. They decide to pick up that proposed block up to the L One validator or, like, whoever's proposing the L One block.
01:09:32.572 - 01:09:33.120, Speaker D: Exactly.
01:09:33.270 - 01:09:33.824, Speaker C: It makes sense.
01:09:33.862 - 01:09:34.450, Speaker D: Yeah.
01:09:46.730 - 01:09:55.740, Speaker F: What do you view as the most important trade offs to optimize for economically in the system? Brack. Do you want to go for that one?
01:09:56.190 - 01:09:56.602, Speaker D: Maybe.
01:09:56.656 - 01:10:02.014, Speaker F: A maybe? Like, what are the most challenging things you've encountered so far?
01:10:02.212 - 01:10:39.482, Speaker C: Well, we kind of want to narrow the problem down as much as possible. So what we do is not change anything to the ethereum protocol itself, but instead, we have to really optimize our circuits and our zero knowledge proof generation as much as possible. Because if it's too long, then transaction costs would go up, which would obviously be a bad thing. So the trade off here is kind of like you trade in some of the efficiency for full compatibility, full equivalent, so it's easier for developers to develop on. But then we have to do our job to make it as efficient as possible.
01:10:39.616 - 01:10:40.586, Speaker F: Okay, great.
01:10:40.688 - 01:10:47.994, Speaker D: Thanks. Questions on the block finality? Tyco block finality, is that instant or.
01:10:48.032 - 01:11:25.602, Speaker C: We have to wait for confirmation? It's instant, as in when the block is proposed and it's included in Ethereum block, it's finalized. So that means that the transaction order is fixed. Everybody knows what the presate and the post state will be. It's just like that. The information like the post state of that block is simply not known yet by smart contracts. But anybody that's running a note and is just looking at the data as it comes in, in the roll up, smart contract can execute those transactions, know the post state, so they know exactly what the state is. And once it's in the smart contract, that means that it cannot be changed anymore.
01:11:25.602 - 01:11:43.870, Speaker C: So once it's there, it's fully finalized, cannot be changed. Everybody knows the state except smart contracts. And smart contracts. That's why we need the zero knowledge proof. So zero knowledge proof is there because we will also want to let smart contracts know what the latest post is without having the smart contract itself execute all those transactions.
01:11:44.370 - 01:11:48.142, Speaker D: So I guess in practice, we don't have to wait for any confirmation then.
01:11:48.196 - 01:12:01.490, Speaker C: No, you don't have to. It's just for Bridging, where a smart contract needs to know what the L Two state is. Otherwise everybody else knows directly when the block is proposed, what the latest state is, so they don't have to wait.
01:12:01.640 - 01:12:07.578, Speaker D: Sorry, another question. We have plans to support privacy programming.
01:12:07.614 - 01:12:15.000, Speaker C: Feature, as in Leo or Mina, not on our layer two. So if you want privacy, you'll have to run it as in L Three on our L Two.
01:12:16.270 - 01:12:17.020, Speaker B: Awesome.
01:12:18.750 - 01:12:19.274, Speaker C: Thank you.
01:12:19.312 - 01:12:19.514, Speaker D: Yeah.
01:12:19.552 - 01:12:20.380, Speaker F: Thanks, everyone.
01:15:30.200 - 01:15:31.172, Speaker G: Yes. All right.
01:15:31.226 - 01:15:31.540, Speaker D: Awesome.
01:15:31.610 - 01:16:16.076, Speaker G: Let's start. GM I'm Flywell, this is Miguel, and we're going to talk about WorldCoin today. So, in case you haven't heard about us, WorldCoin, the Shiny orph, and World ID, the identity protocol that we're building, we're going to start with a little bit of the story. So obviously, the world is changing very fast. We now have some amazing stuff coming in. AI, robotics, you name it, right? And it's becoming a little bit more of a problem of what is actually human and what are actually bots online.
01:16:16.198 - 01:16:16.868, Speaker D: Right.
01:16:17.034 - 01:17:10.870, Speaker G: We're starting to see how intelligence is really no longer a discriminator online, and these sort of problems start to come up, right? Particularly in the exciting world of AI. And with all of this advancements, it's getting really hard to know what's real out there. How do we make sure that value is fairly distributed and that we're prioritizing humans? Right. So all of this comes to Personhood. Why did personhood go away? Personhood? I'm sorry about that animation, all right? It's not a demo if something doesn't fail. Right, but personhood So this is what it's all about. World ID.
01:17:10.870 - 01:18:00.950, Speaker G: What we're going to talk about here today is about personhood and distinguishing real humans in the digital space. So, WorldCoin, this is the goal of WorldCoin Build, our largest network of real humans. And we're doing this by giving away the ownership. So we are launching the WorldCoin Token, which will be distributed to every human on the planet just for being humans. And we're doing this because we can do personhood verification and ensure that a single person can only claim their share once. And of course, you run into the issue very quickly. How do you know who is a real and unique person? Right? We've all seen this before.
01:18:00.950 - 01:18:53.190, Speaker G: Civil attacks. Quite easy to replicate yourself and make it look like you're 100 people and kind of like game the system. So this is the problem we started to solve and that we're now offering in an open protocol for anyone to be able to leverage for WorldCoin. We want to do this in a fully private, inclusive and robust way. So what does this mean is we want everyone to be able to have access to this. We want all data to be privacy preserving and kept in the ownership of users. And we want it to scale beyond a billion people.
01:18:53.190 - 01:19:34.800, Speaker G: So we explored a lot of options. All of this turned out to be invisible. I mean, email or phone, I think we can all create right now 1000 of them very quickly. IDs is a lot of people turns out don't have IDs. You'll run into a lot of issues with the different types of IDs forgeries. All of this web of trust is actually a great solution once you have a trusted seed of humans. But then how do you bootstrap this? And then that leaves biometrics.
01:19:34.800 - 01:20:25.760, Speaker G: So within the realm of Biometrics, of course, there's several options, right? And these are just some of the options that we explored. But again, we ran into different issues. Fingerprints, it's easy to spoof. Remember, here we're trying to demonstrate that you're a unique person, not that you are you. So when you're, for instance, using your fingerprint to get into your office, you are just demonstrating that your fingerprint belongs to you. Whereas here I could very easily make a little cut in my finger and now I'm a different person. Face doesn't have enough entropy to recognize beyond billions of humans.
01:20:25.760 - 01:21:23.670, Speaker G: DNA is very intrusive, very logistically complicated. Not a good option. So that leaves iris. And that is how the orb operates through the entropy of the iris. Then next problem is, all right, we know that we can use iris to recognize a billion humans. How do we get the entropy of the iris? And then again, we went through different options. And the TLDR here is phone sensors are very varied and most of them don't have the resolution that's needed to extract the entropy to distinguish a billion people.
01:21:23.670 - 01:22:40.910, Speaker G: And even then you get into issues with trusted hardware, right? Like how do we make sure that you're not using a rooted phone that's feeding false data? And that's why we ended up building custom hardware, which is the orph, yeah, this was a little bit of a long time to build, but here's the output. This little guy here, as you can see, we went through quite a few prototypes. All the. Way to this is where we are today. And a little bit of a sneak peek just for you guys of where we're going to be tomorrow. We are in test phases for this newer version. The whole idea is these orbs are produced to be in untrusted environments and very easy to operate, so that anyone can come in to the verification and walk away with their verified World ID.
01:22:40.910 - 01:23:29.660, Speaker G: The ORV does these three things. It makes sure you're a real alive person, make sure that you're not doing anything fraudulent. Like for instance, that it's not like two people standing close together prosthetics you're not wearing glasses or things like that, that would interfere with the entropy of your iris. It checks that you're unique and it verifies your World ID. And this is your world. ID. So World ID, you can think of it as a digital passport that lives in your phone, is completely self custodial.
01:23:29.660 - 01:24:42.272, Speaker G: World ID is based out of key pair that is created on your phone, only lives there. And the public key is what gets inserted on chain once your identity is verified. So, beyond personhood, because your World ID already recognizes you as a unique human, more credentials can eventually be attached and issued within your World ID protocol, right? So today we are supporting the ORF verification and we are launching a beta for phone verification. So, kind of like the two ends of the proof of personhood spectrum. But the protocol is completely decentralized and agnostic. So we envision very soon other credentials will start to show up and issued by different parties, the World ID protocol. So, these are the guiding principles for the World ID protocol.
01:24:42.272 - 01:25:18.576, Speaker G: First and foremost is privacy. First, it's not like privacy is an afterthought. If we start with privacy and we'll talk about a little bit more about privacy in a second, it's completely decentralized. The source of truth is on chain. It's a smart contract and that's it permissionless. And all of it is open source. The hardware of the orb is already open source as well.
01:25:18.576 - 01:25:59.950, Speaker G: You can already check it online and we'll continue to open source the software and everything else because that's what it's all about. So how can you use world ID? There's two ways to use world ID. You can use it as a signing mechanism. Signing with WorldCoin very easy. Or we have an advanced version that lets you do what we call anonymous actions. So signing very simple. You add a button in your app, in your website, sign in with WorldCoin and the user authenticates using their World ID.
01:25:59.950 - 01:27:16.752, Speaker G: The benefits that you get is you get this credential on how likely the person authenticating is to be a human, because they've either verified at a north or they have phone verification, right? So as more signals get added, then this can become a continuous spectrum and let you verify it at different levels. So if you're building, I just heard an idea about a dispatcher that prevents civil attacks and bots. You could do something like, well, if you're or verified, we'll give you 100 transactions an hour, but if you only have phone, we'll give you five. If you have nothing, we'll give you zero. Right? It's kind of like it can be thought more of a spectrum as more than binary. Anonymous actions is for a little bit more enhanced privacy use cases. For signing with WorldCoin, the person verifying will always give the app the same Identifier to make sure that you are the same person authenticating.
01:27:16.752 - 01:28:13.492, Speaker G: For anonymous actions, you can actually generate different Identifiers for each of the actions that the user is executing. So a good example of this is boating, right? So say you're building a boating platform. You want each proposal to be voted only once per person, but you don't want to be able to link votes of the same person across proposals. So if I vote yes to proposal A and no to proposal B, we never want to be able to link those votes together. So what we can do is each of these proposals can be separate actions and therefore, like privacy preserved across. All of this is accomplished because whenever you're using World ID, you do so with zero knowledge proofs. And the zero knowledge cryptography is what is one of the biggest privacy components of the entire protocol.
01:28:13.492 - 01:28:39.170, Speaker G: You cannot use the World ID credentials without going through the zero knowledge proofs, which make it impossible to track users across applications or to kind of, like, break the privacy there. Yeah, you're good. I'll leave you with Miguel to show you a cool demo.
01:28:39.780 - 01:28:40.144, Speaker D: Yeah.
01:28:40.182 - 01:29:17.230, Speaker E: So, first of all, I'm just going to speed through this because this is basically the fallback if the Internet breaks, but we're hoping that we'll be able to actually demo this in real time. But as Paulo was saying, the really cool thing about Wall ID is that it works on chain, and it can also work off chain if you need to. We have an API. It still goes on chain either way. But the really cool thing about this is that if you're completely new to Web Three, which I think some people here might be, or also developers that are not really that into crypto, you can still get the full privacy guarantees that Wallcoin provides without any of that. And it's also really easy to integrate. I'm going to show you that now.
01:29:17.230 - 01:29:39.808, Speaker E: So, first of all, I'm going to go really fast here because we're a little short on time. But everything that I'm saying here, if you go to Docs Wallcoin.org, we have an excellent documentation that you can look into. It will explain how to do everything. I will jump across it right now. But yeah, basically anything that you miss, it's going to be in there, and there'll be a link in the end of the presentation as well. And a QR code and everything.
01:29:39.808 - 01:30:23.888, Speaker E: So the demo that we have, the screenshots here is Chat GPT. I feel like at this point anyone knows it. This is not the official Chat GPT, it's a clone that we made just to showcase how it is to integrate Login with Wolcoin. So in this case, we are using Auth Zero, which is a platform that allows you to provide authentication services. And it's actually the same one that OpenAI chooses. And the really cool thing about all of this is that it took zero lines of code to get this to integrate with Wolcoin, because signing with Wolcoin uses the same standard that signing with Google, signing with Twitter, signing with Apple uses. Meaning that if you have any kind of package or library that supports any of those, like Passport, Superbase, Auth Zero, any kind of code that connects with those, you can probably really easily make it work with Wallcoin as well.
01:30:23.888 - 01:30:55.016, Speaker E: And so the way that this works is the user would click Continue with and then that loads up a QR code. And then on the user's phone they would go to the Wallcoin app here, and then they just click the little cure at the top and scan the QR code. Now you don't need to actually get scanned to download the app. You can use the phone signal that Paolo mentioned if you don't want to get scanned for any reason. And if you cannot get a hold of us. Also for the staging environment, kind of like the testnet, you don't need any of this at all. You can just go right ahead.
01:30:55.016 - 01:31:46.760, Speaker E: But I will get this pop up on my phone and as I click Verify, it will generate the serial knowledge proof in my phone, send it over to the computer, and then I will be logged in. And in this demo, basically we just add a little human mode as a yoke. Again, this is not the real Chat GBD, but again, signing with Wallcoin zero lines of code to implement. You can obviously do it with code, but you don't need to, which is the really cool thing. For a slightly more complex example, basically we have anonymous actions. And as Paolo mentioned, anonymous actions are more usually for unseen use case or use cases where you don't really want to persist I know who this user is, and more want to let them do well anonymous actions. So for example, let's say that you're making something like, I don't know, curious cat or any of these platforms that allow you to ask questions anonymously or vote on a proposal anonymously.
01:31:46.760 - 01:32:27.812, Speaker E: You still want to prevent spam or prevent people voting twice, but you don't want to kind of break the anonymous thing. You still want to be able to have these people ask questions or vote without revealing who they are. And so if you did signing with Wallcoin, sure, you would not know who this person is, but you would know, oh, this person who I don't know who that is. Just did these five things. And as they do more and more things, you would maybe be able to start learning some things about them, like who their friends are or what kind of proposals interest them. Anonymous actions kind of let you reduce the anonymity pool to a single action. And what that means is if I have a voting platform, I could make anonymous action for each proposal.
01:32:27.812 - 01:33:27.612, Speaker E: And so within a single proposal, when someone is submitting a vote, I can on chain or off chain figure out has this person voted here yet? Which is kind of what you want. But when you are doing something like a different proposal, if you're voting a different proposal, someone votes and you have no way of knowing these two votes from different proposals come to the same person. It's anonymous, so there's no way of knowing. As an example of how this might look like, we have this lens integration that we made a while ago that basically lets you mark your lens profile as belonging to a human. And ideally this would help reduce spam or maybe be taken into account when they do machine learning. And if we go to the repository for that and the smart contract and I'll try to keep this very simple so people that are not into solidity don't get scared. Basically the way that this works is we have a function here verify and this will get the profile ID.
01:33:27.612 - 01:34:09.416, Speaker E: This is like the arbitrary argument that I am passing. Let me make this a little bigger. The arbitrary argument that I'm passing and then these three arguments that Wallcoin just gives you. And again, this is on the documentation we have a starter kit which with everything that you need to get starter here. And so basically the first thing that we're doing is we're calling the verify proof method and saying and this will just say is this proof that the user has gave me valid? If it's not the transaction reverts, nothing has happened, your code doesn't execute, so you don't need to worry about any of that. After it works here's where you would usually say like, okay, has the user done this before? In this case we don't want to make it so that you can only do this once. What we want to make sure is you have only verified your profile once.
01:34:09.416 - 01:35:20.752, Speaker E: So if you have already verified a different profile, we will first unverify it and then verify the new one. In this case we're using this ID, this anonymous ID that you get from the anonymous action instead of just like by checking true or false, has they done it before more to store the ID that they have verified and revert it. So it's more of like an advanced use case. On the website side, we have this library called Idkit and it's a JavaScript library. We add react components but if you're using View Spelt something else you can still integrate with it and basically just gives you a component here where you can pass an app ID that you get from our developer portal. We give you a QR for that in a second and an action which is just like a text description or whatever action like voting in proposal whatever or claim NFT Tokyo and then just an unsuccess callback. And basically what this will do is we'll open a model with the QR like you saw me do before and then when the user completes that you will get your serial proof on this result part and this is the part that you need to send to your backend or your smart contract for verification, whatever you are.
01:35:20.752 - 01:35:57.468, Speaker E: And again I'm going to reiterate this because on previous hackathons some people usually just like constant unlock the proof and get it done. You actually do need to verify this. Someone could just inspect element, change some stuff and actually get you a proof that is not valid. So you do need to verify it ideally not on the front end. So again, if you have a smart contract that's the place to do it. If you don't have a server, an API somewhere, verify it there very important, otherwise it's not civil assistance. And yeah, basically as I mentioned before, have all of the things that you might need here.
01:35:57.468 - 01:36:46.920, Speaker E: If you have any questions you can go find us in the booth. We also have a little GTP four power chatbot here that you can use. So if I were like how do I verify proofs on chain it will give you the answer and the correct pages. So if you just have a short question you could do that or if you have chat GBT as everyone does these days and you have the plugins beta, you could also use that to ask the same thing and it will have access to your looks. So again, trust humans more. We have a discord channel on the global discord and that will actually answer all the questions there. We have a booth over there, it has like a nice purple shade so you can find it really easily.
01:36:46.920 - 01:37:25.880, Speaker E: You can also come find me really easily I feel like. But yeah, you get the idea before my computer dies. And so as I said before, this actually has a lot of really cool use cases. The main ones that we have highlighted are voting article systems in general, but for AirDrop which is our original idea, unquote terrified lending NFTs in general, consumer incentives. I mean this is a hackathon, you probably have a lot of ideas but you can use it for almost anything. And yeah, as I said before, the docs that have everything also have a list of suggested use cases that you may want to use for inspiration. We have 20K in prices.
01:37:25.880 - 01:38:03.940, Speaker E: I'm not going to read through that you guys know how to read and it's also on the website and on the starting kickoff that we're going to do later. But basically choose whatever suits you best. And yeah, as I mentioned before, we have a developer portal that you can use. That's the QR code. If you don't manage to get it here, come to the booth later, we'll give it to you, it's fine. But yeah, this unlocks the developer portal that you need to use in order to integrate it to have like a nice image show next to your demo in the app. All of the cool things going to wait for another second for everyone to take a photo.
01:38:03.940 - 01:38:31.020, Speaker E: Otherwise, again, come to our booth, we'll give you the QR code. And yeah, all of the resources that I mentioned and even more that I didn't mention like starter kits, more ideas. All example projects that we have code for, front end, back end are@walcoin.org ETH 23. So really easy to remember. URL go there you have an ocean page with everything that you would ever need. Again, any other questions that you may have, come to us in our booth.
01:38:31.020 - 01:38:56.772, Speaker E: Ask AI whatever you want. And also it's like a little thing. If you want to see a demo of the anonymous actions you can just come by our booth and ask us about Waldi and we'll just give you the page to claim a nice NFT using anonymous actions. So you do need to get on board with the orb in order to do this. Again, we're like demoing the thing, but if you want to get a nice NFT and try out the experience, feel free to do it. Yeah, that's about it. This is wall ID.
01:38:56.772 - 01:39:21.004, Speaker E: It solves the whole civil assistant issue that we've been worrying about for so long that is becoming more important even now with AI. Also a really nice anonymous identity solution for anything that you may want regarding privacy and yeah, it's here and feel free to use it now. I hope you have a good time hacking. Do we have time for questions?
01:39:21.122 - 01:39:21.356, Speaker B: Yeah.
01:39:21.378 - 01:39:22.910, Speaker E: So anyone have any questions?
01:39:28.180 - 01:39:32.290, Speaker G: Battery killed, that's good or bad?
01:39:32.740 - 01:39:36.144, Speaker A: Hey guys, thanks so much.
01:39:36.262 - 01:39:37.430, Speaker D: Just quick question.
01:39:38.440 - 01:39:42.196, Speaker A: Okay, now it works. What's the typical proof generation time and.
01:39:42.218 - 01:39:44.390, Speaker D: Proof verification time just out of interest.
01:39:44.840 - 01:40:29.430, Speaker E: So proof verification time on chain is whatever it takes to mine a block because that's what all transactions take on Ethereum. Well, this is polygon but well, all transactions take in polygon so I would say like few seconds. I don't know the average block time, but I don't think it's more than 2 seconds. Proof generation, it's usually not the issue at all. The issue especially in hackathons is how much does it take to send it over because WiFi, but definitely less than 5 seconds, usually less than two. It's pretty fast. It also depends slightly on the phone that you use if you have a very old Android phone specifically they can take like maybe 5 seconds or so, but we've seen that in general the blocker is more sending the data over more than generating the proof because you're just like doing math on your phone.
01:40:32.680 - 01:40:41.216, Speaker B: Hi, so I only need to verify myself once either with the orb or the mobile and then it will be with you forever.
01:40:41.408 - 01:41:18.048, Speaker E: Yeah, basically the way that it works is you verify yourself once, then you have the key forever. If you have the phone verification and then you want to get the orb, you have to go to the orb. The phone is more of like what we call weak simple assistance because it's not that hard to have multiple phone numbers. I have two, but it's harder to get like 100 or 1000 or like multiple thousands. So this is why on apps we recommend to add tiers and kind of give less access to the phone and more to the orb. Because your issue is to prevent spam. Well, I mean, spammers can get phone numbers, but they can probably not get large quantities of them.
01:41:18.048 - 01:41:59.216, Speaker E: So it's more of like this orb is not everywhere in the world yet there's one in my city, there may not be one on yours. So it's more of like a temporary thing where it still gets you integrated with wallcoin, makes it really easy to support both. And then ideally at some point as we have more signals, you have a more complete picture of how human this person is. Or how human do we know this person is. Ideally every person is human, but yeah, you get it. But yeah, basically you verify yourself once either with the orb or the phone number, you have the proof and the key forever. If you want to kind of update your verification, as in like you have phone and you want to go to an orb, you can do that, but you don't need to have an orb at home and scan yourself every day.
01:41:59.216 - 01:41:59.904, Speaker E: Basically.
01:42:00.102 - 01:42:10.500, Speaker B: Sorry, just last question. So everything of my personhood will be on chain as my work ID. What's the likelihood of, I mean, what's the worst case that someone haggett how easy it is?
01:42:10.650 - 01:42:38.172, Speaker E: Right? Your personhood is not really on chain. What is happening with the orb or the phone number is your phone generates a private key which is separate from your wallet private key. And this key will be used to kind of sign these proofs of personhood. So basically on chain there is just kind of like the equivalent of the public key of this private key that you have. So really there's nothing on chain of your personhood. In a way. Same for the phone numbers.
01:42:38.172 - 01:43:17.000, Speaker E: The phone numbers are hashed and you just store the public key. The phone numbers are not given to the apps or put on chain. And so basically the way that we've done it, the worst case that could really happen is if you somehow manage to export your private key and give it to people which is not supported in the app yet, but at some point maybe we'll let you export your wallet private keys. Then at that point that person could generate proofs. And then by that point we will have a way for you to go back to an Orb, invalidate that key and generate a new one. But basically there's no risk of like you either even doxing yourself. So it is pretty secure.
01:43:17.000 - 01:43:30.460, Speaker E: Thank you so much. Hope you have funny.
01:46:58.860 - 01:47:40.720, Speaker D: Hey guys, do you hear me? Sorry for the small delay. So today it's kind of actually it's a long workshop and I'm not sure I can handle everything in 30 minutes. But I will try, at least I will try to explain what is one inch fusion and why it's so like what what is the hype about one inch fusion and how it works under the hood. But let's make some small recap. What is one inch? Firstly, so basically One Inch started as a hackathon project at Ethereum, New York at 2019 by almost one and a half men. Right now we have about 200 people. We have a lot of metrics.
01:47:40.720 - 01:48:09.580, Speaker D: We have billions of volumes of dollars on multiple chains. We actually are one of the largest deck segregator on the market. We also have multiple other protocols, like limit order protocol. We do have one each wallet. Actually it's a list of protocols and you can take a look on some of them here. One of the most popular one right now is limit order protocol and one each fusion. Also, we do have one each pro that is product for institutionals that provides QIC and AML policies.
01:48:09.580 - 01:48:52.140, Speaker D: So let's make some intro about what is One inch aggregation protocol. Firstly, maybe you heard that Vanich is dex aggregator. And actually it's true, we do have API for aggregation information on the DEXes, how basically that works. Let's imagine that you want to make a swap on the uniswap. And in this case, let's imagine that you want to swap, for example, 100 Ethereum to some amount of die. And what will be the problem that you will have potentially that if you will use uniswap, they actually use specific pools, liquidity pools, to make the transaction, to make a swap. And of course you will have some price slippage.
01:48:52.140 - 01:50:11.668, Speaker D: What is the best idea how you can have potentially the best lowest possible slippage? In this case, you need to have multiple pools and try to split your 100 Ethereum amount to some small parts. It varies how small it is, but it must be like that small that the price slippage in each pool where you will try to make a swap will be almost zero. And you need to do all of that inside one transaction. So basically it's how Varnish works under the hood. As a varnish dex aggregator product, we basically split if you want to swap, for example, die to one inch, we split amount of die to some small subparts and split these subpars to another subparts and try to route all this and emulate all of that logic through multiple liquidity pools, through almost each decks that have existed on Ethereum chain, for example, on a Binance smart chain and trying to find the best option to get the Max return and have the lowest gas for the user. That's like pretty basic right now and most of the guys aware of it, but I just want to remind that how it works and the main feature here is that it happens atomically. So for example, if somewhere price goes wrong, we have some desired minimum amount that you will need to get.
01:50:11.668 - 01:50:58.948, Speaker D: If you are not okay with that, the whole transaction will be reverted. So basically you are protected from any edge case that can happen during this swap. But the main problem here is that if it's one atomic transaction and in some cases, for example if it's some shitcoin and sometimes everyone needs to swap some shit coins in this case if you have a lot of them you can have a really big slippage. It doesn't matter how much DEXes you use because liquidity for some shitcoins can exist for example only on sacs or on other chains. And if you are doing that atomically, that means that it's impossible to aggregate all of that liquidity in one atomic swap. You need to wait a bit to make it. In this case the limit order protocol can help you.
01:50:58.948 - 01:52:07.640, Speaker D: What is a limit order protocol? It's quite the same as basic limit orders on any tax, but it's completely decentralized. So basically you just sign a specific structure that you agree that our smart contract can withdraw the tokens from your account and fill it using specific function and get some tokens instead. Basically make a swap and anyone can use this function and they just need to provide specific instruction from your site. It's a signature and data which token they need to withdraw. Basically the limit order protocol allows to make a gasless transactions on your own site. I mean you can make a gasless swap for example in this case you can just need approve for example for the Dai to the limit order contract and make a limit order for example to sell Dai for Ethereum and anyone can actually fill this transaction on behalf of your user. And in this case basically not user is paying the gas but market actually market taker is paying the gas.
01:52:07.640 - 01:53:06.264, Speaker D: It's a cool feature but the problem here is that there is specific price condition here, it's fixed. So that basically means that if price goes wrong you can wait for like 4 hours or four weeks to get a good price to make this order executed. If you will try to say in the Sax terms it's like market sell there is no market sell here, it's only limit order and you need to wait there is no any guarantee that it will be executed even if the price will be the same as the market price. For example, what if you want to make something on the market price but we want to make it like limit order? Is it possible in the defy? And actually that's the question, what we have and right now we can say that it's possible. Actually, it's the solution, what we make with the one inch fusion we want to make something like market price, sell at the same time. It must be like atomic. It must be limit, order inspired.
01:53:06.264 - 01:53:37.320, Speaker D: It must be gasless. It must be protected from mev attacks all at once. And that's. What is fusion? Actually, it's a fusion of multiple protocols at one inch. How it works. Basically, it's auction. You try to say that I am okay to sell specific amount of dai and the rate is going down and down and all of that is actually one limit order and what it allows to anyone, for example, to the resolver, to the party who will try to fill your order.
01:53:37.320 - 01:54:12.156, Speaker D: It allows to aggregate liquidity during that moment. So basically, you killed multiple issues at the same time. Firstly, you try to actually have a market sell feature so you sell some tokens without any you don't care it will be already filled. There is a guarantee that it will be filled. There is high probability that will be filled. At the same time, the price switch will be a bit lower because you don't need to make it atomic. And for this case, we actually use price auctions.
01:54:12.156 - 01:55:01.584, Speaker D: And this is like example of the curve for the price. Auction for the rate where the rate is going down during the time basically it looks like Dutch auction. Actually the main feature is that all of that logic is quite simple for the user and there is almost no difference for the user when you try to use one each fusion it's quite the same as just make on chain transaction but it's off chain transaction it's basically signing a specific limit order on the site of the user and that's it. But there are some additional features here. The first one, of course is the gasless execution. What I mean is that as a limit orders is off chain transaction and you basically just send some data to some database. That's it.
01:55:01.584 - 01:55:37.580, Speaker D: And anyone can access to this signature to your data in this database and execute transaction on your site. The gasless execution doesn't mean that you don't pay gas fee at all. This gasless fee is just included in the rate of the fusion order and basically it's still a bit more efficient than if you will try to pay on your own. Because in the fusion protocol there is a specific gas optimizations. Basically that means that when. Somebody try to pay for your transaction to fill the transaction. The relayer can execute multiple transactions at the same time.
01:55:37.580 - 01:56:30.110, Speaker D: It will be one on chain transaction, but multiple fusion transactions in one transaction, it can save a lot of gas, a lot of ethereum on gas for example. And when the volumes are large it can be like ten times more efficient for example, than just paying on your own for that. So that's basically how actually any fusion orders are working right now. Any off chain orders are working, the orders going through the blockchain, through relayers, through some market taker who is doing that. It's quite the same for the limit order and for the fusion. Let's try to make it more complicated why we have a view protection by default here because there is no any blockchain communication on the site of the user. There is no any option how somebody can steal your data or reexecute it on your own.
01:56:30.110 - 01:57:27.344, Speaker D: But that doesn't mean that there is no me protection for the resolvers. But the risks in this case are much lower than for the user. Because when resolvers are trying to fill this order they have risks that somebody can execute it a bit more efficient and they can arbitrage the resolvers on their own. But the price difference here is not that critical and it's more a case of the resolvers how they can try to find a way how to protect from the muth. So the risks are lower for the users, a bit higher for the resolvers. And what about liquidity feature that basically actually we can aggregate all the liquidity across multiple chains during some auction time. So for example, in case of any resolver, we don't have any design how you need to aggregate or how you need to fill each user order.
01:57:27.344 - 01:58:20.892, Speaker D: You just have a time for that and you can't be forced to execute any order as a resolver. So basically it's open market and each resolver just can aggregate liquidity from any point. In case of our shitcoins, for example, how it can work, we basically need just for example any shitcoin that's existing on the ethereum and existing on the polygon and all liquidity is on the polygon. You can see that there is a pretty good interesting order on the ethereum side and there is no any liquidity to execute it right now. Any resolver can take some time and withdraw this liquidity, for example from the polygon chain to the ethereum and after that it can be executed on the ethereum side. It will be impossible to do the same logic, for example on aggregation protocol because it must be atomic and it must be instantly. And in this case that's the instant profits for all the parties.
01:58:20.892 - 01:59:15.876, Speaker D: It just makes the markets more efficient because users can get more tokens in this case and resolvers can get some profits from that case as well. There is some slippage for the user because of the price auction, the rate goes down. But this spread is not that high because it's pretty open market and it's very easy to become a Vanish resolver right now. So right now let's take a look on some PCs example about price auction I just want to say that we do have right now a more dynamic formula for each pair on one each front end. So it depends on which token you are selling and which token you are buying, the price formula can differ. And for example, on ethereum die rate. If you try to say that in the beginning when you're trying to make an order a price auction the price is going down not that fast.
01:59:15.876 - 01:59:58.240, Speaker D: We are allowing Resolvers to instantly feel this order but if you see that during some amount of time like 1 minute nobody feel it that basically means that price is really very bad and nobody will feel and we can make it a bit faster going down, making this period a bit more like a bit more extreme. If it's still okay, that means that the market is changing. Rapidly. And we need to stop walking like this and try to have the same stable formula. So basically, it's a lot of logic under price formula under the way how you can execute the auction. It's another way how? You can make the markets more efficient. It also depends on the pair and the liquidity of the pair.
01:59:58.240 - 02:00:33.516, Speaker D: We also do take care of all of that and it's another opportunity. How you can, for example, design something or propose your own price formula for specific pairs and make it more efficient. Just want to mention that the whole picture actually looks like that if you'll try to understand vanish Fusion is that market maker is basically users they just need to send an order. Send it to the network of the one inch of one inch fusion. After that one, each network gist to this order as a fusion order and share this fusion order across. Resolvers. Right.
02:00:33.516 - 02:00:58.772, Speaker D: Now, there are top ten resolvers that can execute any order instantly. And if you want to participate or become a resolver, there is a documentation on our website how you can do this. Basically, the integrity for any resolver. Is quite low. It's about 101 inch tokens, and if you want to participate, it's just like, less than $60. So basically, any resolver can feel limit. Actually, it's limit order.
02:00:58.772 - 02:04:38.494, Speaker D: So any resolver can fill this limit order through. One inch smart contract that is open source and when it's filled, limit order is executed and sent funds to the maker so basically to the user. So the logic is off chain and on chain at the same time. There are some questions. What is one execution? Is it off chain logic or is it on chain logic? It's a hybrid sometimes it's off chain in some cases, in other cases it's on chain but basically it's quite the same as a limit order protocol but more advanced with more additional rules over limit order if you want to try to understand it let's talk a bit how you can work with the Vanish fusion basically there are two options how you can integrate and work on the Vanich fusion the first one actually you can integrate vanish fusion to your app let's imagine you have a wallet or any app that needs to have a functionality to swap any token to any other token in this case it's pretty simple we do have a Vanish fusion SDK and in this case it's in JavaScript we have a rust version as well and if you want you can just use it there is a pretty easy example here I will show you 1 second how it works so basically in this case you can use for example node JS application to make a fusion order so we have one each fusion SDK it's open source and it's quite transparent it's not that hard to install it in this case you just need a node, you need a private key, you need a maker address of the user who will be creating a limit order and what you need to do is basically have a web free node and our SDK you just install our SDK, set up our SDK with our network, our URL of storage of limit order of fusion orders and web free provider and basically you just need to create an order where you specify a from token address which token you are trying to swap two token addresses you are trying to buy and amount in from token address so it's like only four parameters for the function it's quite simple and in that case I don't have enough ethereum right now to execute this function but basically it's just one function it's not a lot of issue to make it work so it's the simplest way how we can work with vanish fusion order and also it's gusless so basically I just want to add when you will try to use for example to run SDK or niche fusion SDK it can be not working because you still need to make a proof from token amount to the fusion contract if you don't make an approve you need to use permit function in this case it's more complicated if you want to combine permits and make a fusion order but it's possible of course we do support permits in the fusion protocol but in this example you need to make approve before you're trying to make a swap so that's one example how you can use one inch fusion orders and the second one actually is to become a resolver if you want to become a resolver in one inch like ecosystem there is multiple steps what you need to do basically the first one. You need to have some one inch token staked you need to apply as a resolver. And basically all of that is pretty decentralized.
02:04:38.494 - 02:05:38.600, Speaker D: But if you want to be on the front end side, on the one inch front end client, there are multiple additional steps that requires us to contact with you, to chat with you. So we have a website form where we specify all the data what you need to do to become a resolver, but basically it will end up with a chart with our team that helps you to integrate and to become a resolver. On our site we are obligatory to make some compliance checks at the same time. But if you want to become completely decentralized, potentially you can do this, you can still do this. That's the main point about one inch fusion that is right now the network is much more decentralized and we can't stop you to become a resolver because it's mostly on the smart contract side. I just want to explain a bit more how resolver works, how the logic under the resolver works and for that in this case, I need to open one inch. Let me, give me 1 second please.
02:05:38.600 - 02:06:38.854, Speaker D: So let's take a look on our delegate like delegate tab at one inch front end, 1 second. So right now we have multiple resolvers and what is it? Only top ten resolvers in this list can be allowed to fill transactions and what does it mean? Like all of them are competing for your transaction. Each one, each fusion order can be filled, not atomically but by parts. So basically when you create a swap, multiple resolvers can fill the same transaction. It's their own competition between them. Who will be the first one who will fill all of that? So they need to take care on their own how it's happening. Each one inch fusion resolver can basically share some profits with the user.
02:06:38.854 - 02:07:46.782, Speaker D: In this case, for example, if you are owner of the Vanish tokens, you can delegate Vanish tokens to any resolver and allow resolver to be on the top and fill the vanish fusion orders and get some profits. So the scheme looks like pretty the same as curve wars as a curve staking. But there is one small difference here that basically vanish fusion resolver is not obligatory sharing the profits with the user. There is no direct scheme here, but if vanish fusion resolver will try to refuse to share the profits, you can just undelegate from this part and delegate another resolver. So basically on large volumes it will works on the markets, like it will be marking repetition and any resolver is obligatory to get some profits, to share profits with the user. If it will be lower than expected from the user side, you can just try to use another one. So as you can see right now we have about eight working open sources like open resolvers and the market share right now is much more lower.
02:07:46.782 - 02:08:56.882, Speaker D: In terms of Vanish Labs resolvers, it's only about two months that we are working right now and we have pretty good results right now. I just want to add that we also support not only ethereum chain right now we do support binance smart chain and a polygon chain and we have plans to support all networks that we have on the front end side. So it's about 1110 networks so it will be Ziki sync as well the option how you can participate as a user for example, you just need to stake one inch tokens and I just want to mention when you stake one inch tokens you lock your tokens for specific amount of time. You can lock it for example for two years. In that case you can't withdraw it for two years but you have pretty good amount of delegated tokens that means that you will have higher Apr and higher profits from the resolver when you will stake it. So it's up to you how much amounts you want to stake and for how long you want to stake it. You can always unstake it before this locked period but in this case you will have some fee and for example, if you lock your tokens for two years and you want to unstake it in the next transaction you will lose like 99% of the total transaction in the fee.
02:08:56.882 - 02:09:30.500, Speaker D: In this case, all the fees going to the one each dow. So it's pretty transparent. If you have any questions, I am pretty happy to answer that. So I just want to show again our core codes how you can participate as a resolver and how you can create fusion orders using one each fusion order SDK we do have additional instructions how we can use fusion on our documentation website. So basically this link is going to our documentation website. Thank you.
02:09:32.710 - 02:09:40.550, Speaker G: So if a third party partner wants to integrate fusion to, let's say a major centralized exchange.
02:09:43.850 - 02:09:45.586, Speaker F: They also have a Dex aggregator.
02:09:45.698 - 02:09:46.786, Speaker D: Does it have to be a separate.
02:09:46.818 - 02:09:55.578, Speaker G: Button or can it be somehow fused between fusion mode? And they have sort of the legacy swap mode, right?
02:09:55.744 - 02:09:58.202, Speaker F: So how would that work out?
02:09:58.336 - 02:10:47.336, Speaker D: If it will be some another Dex aggregator it will be quite hard to aggregate it if they have only on chain functionality. I mean like in case of one inch, for example, trying to integrate another one inch in this case it's almost impossible because one inch needs to integrate only DEXes. Fusion is not a Dex and in the case of another Dex aggregator it requires to make off chain logic but they need only one atomic transaction so it's not quite possible yes, they need a different interface and they need to explain the user that this transaction can be filled not atomically but by some steps. There is like an auction here's, just this one.
02:10:47.458 - 02:10:53.552, Speaker A: How would you get historical trade data? Like the trades from historical stuff?
02:10:53.686 - 02:11:44.720, Speaker D: Basically each fusion order is in the end of all is just on chain transaction. So basically if you will try to field like if you want to get the data, you can just index that. You can use Dune analytics for the data or you can just go to the address scan and see all the Vanish resolver orders that are executed on the Vanish fusion contract. That's the one option that you can do. The second one we do have right now, like a database like API where there is a storage of all orders, you can fetch data there. But I do recommend that the best option is actually to index data from the nodes directly or actually use June analytics for example, to fetch all limit like fusion orders. We do have Dune analytics dashboard for the fusion and we do have all the requests.
02:11:44.720 - 02:12:34.272, Speaker D: It's quite transparent there how it's happening. So all the analysis about fusion is actually quite open source and transparent. Yes. The main logic here is that it works like that. Right now there is one more edge case that potentially later diffusion order can be filled, not fully, there can be some small amount that will be not filled right now. It's handled in the case that in most cases right now it's not very profitable to fill order by small steps. So usually it's obvious they just fill it atomically in one step or two steps later, with large amounts, it can be a small issue.
02:12:34.272 - 02:12:55.690, Speaker D: With some small amounts that is not executed. It's the same as for example, one inch limit orders have. This is the same issue like you can trade, you can make a limit order for 100,000 Ethereum and 0.1 Ethereum will be not executed in the end of all because it's just more expensive to spend on gas than execute this limit order.
02:12:57.900 - 02:13:02.552, Speaker B: Which actors in the overall transaction are paying for the transaction?
02:13:02.696 - 02:13:39.744, Speaker D: Basically, it's only a resolver that is paying for the transaction. And in the case of resolver, it's responsibility of the resolver to calculate how profitable the transaction will be. For the resolver, the price is going down. That basically means that, for example, let's imagine that currently Ethereum price is like $2,000. I want to make a fusion order to sell Ethereum for $2,000. Let's imagine I make a diffusion order but nobody wants to execute this transaction because the gas price is like $20. For example, let's wait like 10 seconds.
02:13:39.744 - 02:14:53.612, Speaker D: The price right now is not $2,000, it's like 1099, 99 in this case, for example, it's profitable and somebody will come and fill this order. So the price is going rapidly down and during the moment when the market price is a bit like it's a bit lower than the real price, somebody will catch and execute this order. It's quite the same I think, as front running or not front running, but as Arbitrage bots are working on the market, they're just trying to compete to find the way how they can execute or optimize the market. There is a period when there is an auction, of course it can be canceled, but if you want to cancel it, it must be on chain transaction. So that's the pain point here that if you'll try to cancel it, there's no guarantee that it will not be canceled instantly. You need to wait that the transhange transaction will be executed. So yeah, it's quite painful issue here, but of course it can be canceled by the amount of time, but for example, in some cases it's very edge cases, but sometimes it happens when the market is going not in your position against you.
02:14:53.612 - 02:15:20.970, Speaker D: All the fusion order can be not executed at all. In this case. Yeah, it's just time constraint. When this fusion order is executed, all of that is actually off chain data that you are signing for. So basically you can see all the details how this fusion order will be executed. There is no any something that is not off chain or not signed, not in the permissionless way basically.
02:15:24.940 - 02:15:26.580, Speaker F: For becoming a resolver.
02:15:26.740 - 02:16:06.176, Speaker D: Right now there are multiple like actually one incentive program to become one inch resolver. That basically means that we share some one inch tokens, one inch dow sharing one inch tokens to resolvers to help them to reduce their costs on building the infrastructure. There are some details on the one inch website for that. So yeah, there are multiple incentives from Vanish team to help to build your solver on your own. And right now it's pretty high volumes on the Vanish fusion order. So I do highly recommend to try take a look on it. Yeah.
02:16:06.176 - 02:16:08.810, Speaker D: So I think we can end up you so much.
02:18:28.060 - 02:18:49.856, Speaker B: Okay, cool. Hi, I am Emily. I am the developer advocate for Linear A ZK roll up. And here I'm going to give a crash course on L two. So it's going to be high level but also low level and we'll see where we fall in terms of how much you understand what I'm saying. So I'm just going to go ahead and get started. There's a lot of information to cover.
02:18:49.856 - 02:19:36.336, Speaker B: So first off, from the start, what are L two s if you guys aren't familiar? Basically, hopefully you've heard of these blockchain trilemma. Why is ethereum? It's a pick two situation, right? We have decentralization, we have scalability and security. We need to choose three. What has happened is we've chosen as a community to focus on decentralization and security, but we don't have that scalability access, right? So what that means is we are going to be pricing out users because of high transaction costs and slow transaction finality. What does that mean? Layer two to the rescue. So layer twos are specifically the scaling solution for Ethereum. What that means is we are decreasing congestion by pulling off the execution layer from Ethereum and then creating that data and posting it back.
02:19:36.336 - 02:20:22.908, Speaker B: When I say posting it back, I mean specifically this concept called data availability. So basically what data availability is, is the guarantee that all this data is going to be published to Ethereum. So this is what powers trustlessness, right? So one common misconception is how many of you guys are familiar with polygon proof of stake, right? How many of you guys think polygon is a layer two? Okay, actually nobody. That's great, but I think it is a common misconception, right? They have their own consensus mechanisms, they have their own security flaws. Basically, layer twos, right now, data availability is the key to defining the difference. So that's something to think about. Kind of an image of like we all love visuals.
02:20:22.908 - 02:20:56.020, Speaker B: So just to kind of show you what that looks like is Ethereum is the monolithic version is taking care of execution, settlement, consensus, data availability. It's doing a lot of stuff. Like I said, again, linear or like roll ups in general, pull off the execution layer. Ethereum is handling settlement and consensus data availability. How does it do this? Here's another really fancy visual. Basically there are various ways to do layer twos. The kind of winning solution for it is roll ups.
02:20:56.020 - 02:21:38.100, Speaker B: So when a roll up, it's pretty self explanatory. Definitely what it does is it rolls up all these transactions together and then takes that and then posts it to Ethereum once. But how does it do this? Right? So when we talk specifically about roll ups, there are two types, ZK roll ups and optimistic roll ups. How they differ is specifically on the proof verification part. So the proof verification is basically telling you, how do I know Ethereum? How am I proving that this data I'm posting is correct? Right? So now we're going to dive into oh, actually I forgot about this slide to further explain roll ups. It's composed of a few parts. So we have the on chain contract.
02:21:38.100 - 02:22:14.500, Speaker B: So you're going to have a roll up contract on Ethereum that basically does the storage, monitors, states, tracks, deposits. The second piece is the off chain VM. So this is where that execution is happening. And the third piece is you guys have might have heard of like operators, validators, aggregators, sequencers. That's a lot of words, but you can basically think of them as the people who aggregate transactions and then post that on. Specifically, when I talk about sequencer, that is a little bit of a separate concept. They are the ones who have the authority of actually posting it next.
02:22:14.500 - 02:22:43.052, Speaker B: Okay, so now I'm actually going to talk about optimistic versus ZK. So optimistic roll ups basically do prove verification by basically not proving verification. What does that mean? So they're optimistic because they assume that everything is valid. In order for it to be invalid, somebody has to send in a fraud proof. They say, hey, wait, that doesn't look exactly right. Let's run a fraud proof. If it proves that it's correct, then it'll post.
02:22:43.052 - 02:23:25.620, Speaker B: If it proves that it's incorrect, then obviously that transaction is rolled back. What that means specifically is this concept of a challenge period, right? So in order for a fraud proof to be submitted, or like that transaction data to be posted, we have to wait seven days basically to give time for fraud proofs to be submitted. There are workarounds for this. So something you might have heard of with regards to optimistic roll up specifically is something like a liquidity pool. So that's basically kind of a separate entity that says we'll actually just verify it all for you. If you want to post it and withdraw your ETH immediately from the L one, we can do that for you. The only issue here is that doesn't really address the issue of NFTs.
02:23:25.620 - 02:24:09.624, Speaker B: The other piece is that is another kind of hackable element, if you care. So liquidity pools is something you might hear as a solution for the challenge period of an optimistic roll up. I don't think it's foolproof. And that's why we're going to go into ZK rollups. So ZK roll ups essentially, basically, instead of waiting for a fraud proof to be submitted, we, I guess, proactively submit something called a validity proof. So what that looks like specifically, if you go back to this side right here, the proof verification is done via a zero knowledge proof. So if you guys have heard of zero knowledge proofs, it basically means proving the correctness of a statement without revealing the statement itself.
02:24:09.624 - 02:24:44.604, Speaker B: I want to step in here again in case you guys are a little I have heard a common misconception with ZK rollups specifically. I think when people think about ZK, they think about privacy a lot and they're like, oh, all this is but there's a difference between a privacy solution and a scaling solution. So ZK proofs are using we're using it specifically to keep the data small, make that faster. That's for scaling. That's not the same thing as a ZK proof for obscuring your information. So those are two separate things. We are a scaling solution.
02:24:44.604 - 02:25:26.284, Speaker B: So I want to point that out. The other piece about ZK proofs that makes it really cool specifically, is we think about there's a concept of recursive ZK proof. So essentially with a ZK proof, you can have this information and you can actually put a ZK proof on top of that and make it smaller. And you can put a ZK proof on top of that and make it smaller, right? So there is what you could call like infinite scaling that is enabled by a ZK roll up versus an optimistic roll up. So when we talk about ZK rollups, we want to dive in a little deeper. So there's this concept of the Zke EVM. And so basically this is executing, I guess, solidity or EVM bytecode.
02:25:26.284 - 02:25:56.052, Speaker B: And what does that mean specifically? So Vitalik put out this article of four different types of Zke EVMs. So when you think about the rollup space, you might have heard a lot of things like there's like StarkNet, what else is there in the ZK spink space? ZK sync I'm part of linear polygon Zkevm scroll. There's a lot. How do they differ from each other is specifically in the Zkevm portion. So at the highest level we have type four. So type four is language equivalent. It is not bytecode equivalent.
02:25:56.052 - 02:26:45.012, Speaker B: So basically what that means is you will be writing in solidity, but that will compile into something that is not readable by the EVM, like the theorem virtual machine. As we move further down, I guess, further down in number, further up this, I guess, table, we have type two EVM Equivalency. So that's basically it is language equivalent. So that means you can write like solidity. Everything is going to be directly portable from Ethereum to the layer two. And it is also bytecode equivalent. The difference here specifically is you can think of being farther away from the EVM, I guess, is a bet that EVM, I guess, inherently is not super compatible with ZK proofs.
02:26:45.012 - 02:27:43.896, Speaker B: So performance is not as easily achievable. Whereas type twos and then type ones, which are fully Ethereum equivalent, then you're thinking about like the easier it is to interact with the Ethereum ecosystem, the easier it is to have the network effects of all the tooling that's already been created around it. Everything, you know, that has already been built around Ethereum works out of the box. Right? And so that's the really strong point. That's the win versus, I guess, a type four, and I'm not going to read everything on this slide, but it's just kind of the graphical representation of what I was talking about versus compatibility and performance. So type four, the least amount of compatibility or it's on the side, type four, but the highest amount of performance as you go up that's, that cool. So now that we kind of have a basic overview of how evolve that works, what it means, what is linear specifically? So just fast facts.
02:27:43.896 - 02:28:22.996, Speaker B: Linea is a product of four years of research and development at consensus. It's actually pretty interesting. When we first started, we were thinking about, I guess, payment solutions, like anonymous payment solutions. The idea that ZK proofs could be applied to scale was actually just kind of no one thought it was possible. So we were doing a lot of ZK proof research and then through that research, we realized actually scaling solutions are possible with ZK proof. And so that's kind of how Linea first got started. The other piece, like I said, we are on the way to type two Zke EVM Equivalency or type two Zke EVM, which is EVM equivalent.
02:28:22.996 - 02:28:48.608, Speaker B: Right now we are at type three. You can think of that as more of a transitionary stage. When we get to mainnet, the goal is to be type two. The other piece is we are powered. By an award winning prover. So when you think about the technical, I guess, underpinnings of how linear works, we want an award that's pretty cool. And the second piece is we actually are very new as compared to the other ZK roll ups that exist in the space.
02:28:48.608 - 02:29:08.520, Speaker B: So you might think like, I think Polygon recently came out with main net. We actually just opened public testnet. March 20. Eigth. So that was like three weeks ago, I think, or less than three weeks. But in that little amount of time we have a lot of activity, right? So I pulled this this morning. We have over five and a half million transactions.
02:29:08.520 - 02:29:42.576, Speaker B: 560,000 wallet addresses, a lot of deployed contracts. I just guess for comparison, I think Polygon might have like less than a million transactions right now. There are different reasons for that I can get into later. But there's been a lot of activity, there's a lot of real big assignment excitement. Why exactly is that? Why are people so excited about Linear? So I'm going to dive into this portion of how do you choose where to build. Well, the first piece is there's a lot, right? Like I mentioned, I was naming all these EKS. There's actually more than this.
02:29:42.576 - 02:30:22.072, Speaker B: There's more optimistic roll ups. Things are developing. How do you choose? When I think about what I build and why I care about a roll up, there are a few factors that I'm considering. Right? So I think the first thing that people consider is like the reason I'm choosing a roll up is because I care about finality and gas fees, right? So speed of the roll up, how cheap it is, stuff like that. But the next piece is you want to think about liquidity, right? So how much liquidity is on that protocol. So if you're focusing on building like a DeFi DAP, for example, you want to think about how much transaction volume you can get from there, EVM compatibility equivalents. So this is where I was talking specifically on whether or not you want to leverage the network effects.
02:30:22.072 - 02:30:59.140, Speaker B: So specifically with Linear, for example, because we are EVM equivalent, nothing changed in terms of when we were bringing on partner DApps, literally all they did was just redeploy, right? Because nothing had to be changed. If their code is written in solidity, it should work on linear. The other piece is users. So when we are thinking about building a DAP, you obviously want people to use it. So how many people are actually building or I guess transacting on that l two. The other piece is security. So I think this is kind of where the reason people might focus on optimistic roll ups versus ZK roll ups.
02:30:59.140 - 02:31:26.084, Speaker B: Optimistic roll ups have been around for a while so you could say they are battle tested to an extent. ZK rollups are a very new technology. Are there going to be bugs? Probably. We've only been around for like three weeks, public test net wise, but something to think about. I think this will be a solved problem, but we'll see. And then the second piece is future proof. So I think this is kind of where I'm talking about.
02:31:26.084 - 02:32:14.612, Speaker B: Where do you think the future of this roll up will go? Is that EVM equivalency super important. Is it going to be able to be fast enough? The other piece is like is that ecosystem just going to be supported in the long term? Things to think about. So I mean, like I said, I think for the most part ZK rollups have won against optimistic roll ups. I spelled optimistic incorrectly, ignore that. But yeah, I think specifically when I talk about the differences between the ZK roll up on the linear side, the Vortex is our prover technology. So when I talked about how you might think about a type four being able to be more performant more easily, our assertion is like actually our proofer tech is going to be fast enough. You have a confused face.
02:32:14.612 - 02:32:39.804, Speaker B: Maybe that's not true, but that's our bet. No. Anyways, what does that mean exactly? So this is kind of like a high level of what it looks like. So I'm going to name these important parts. I can't explain them directly, but basically we have Arithmetization. So you can think of Arithmetization as taking all the K proof, can actually prove it. The inner proof system is kind of where that proving is happening.
02:32:39.804 - 02:33:13.124, Speaker B: Arcane and Vortex is basically our tech to recursively make that proof smaller and smaller and smaller so that when we submit it to that verification contract on Ethereum, it is as small as possible. So it is faster and cheaper. That's my understanding of this. If anything is incorrect, I will let you guys know when I talk to our researchers. But yeah, so this is also just like another slide of what that looks like. It's very complicated, but basically what you can see is the language Equivalency versus the bytecode Equivalency and how that compares to Ethereum. So that's kind of all of them.
02:33:13.124 - 02:34:01.392, Speaker B: But they're all really good and smart projects. So I'm not here to say one is better than the other, but specifically, why linear? Like I said, so I think we have the basics of a roll up right, cheaper, faster, secured by Ethereum. When we talk about ZK versus optimistics, we don't have that challenge period, zero switching costs. So that's when I was talking about being able to take advantage of the existing Ethereum tooling system. Something I want to speak to specifically, and I think this is kind of in line with how future proof you think it is. With linea, linear is a default network on MetaMask. So right now when you deploy to other networks right now you have to go through the UX of hitting add network manually finding that RPC information, adding it all there user UX is going to be smoother.
02:34:01.392 - 02:34:35.116, Speaker B: We live in the same company as MetaMask. So there is a partnership in that sense of we are very close to the most popular wallet in Ethereum or in Web three. But yeah, that's that the other piece I want to note as well. I think there is a lot of, what do you call it, people like to fight between L two S. I don't think that's necessarily true. So something we are exploring is something called the multi prover theory. So like I said before, things might have bugs, right? So at the end of the day we're sending it through a prover.
02:34:35.116 - 02:35:11.020, Speaker B: If that prover has a bug in it, that's problematic, right? So what the multiproover is saying is we're actually going to send it to multiple provers. So scroll linear polygon is like people we're talking to. If there is a consensus on this is true, we've verified it in three different ways. So that is a lot more secure than for example, if linear was the only L two that existed in the space. And so this is what I say when we're competitors, but actually it's very important that we collaborate. So yeah, that's kind of the future. The other piece to this too, I guess, a sneak peek, right? We are in L two but we are thinking about building L three S on the future.
02:35:11.020 - 02:35:38.710, Speaker B: That could be anything from more specific app chains to again doing that recursive proof so that it is faster. The definition of an L three is actually still in flux, which is pretty interesting. So keep an eye on the space. But yeah, so actually what does it look to build on linear? I think the WiFi is really bad. So I'm not going to do this live. But the first thing you need to do is actually get linear ETH. Let's see if I can access if it'll go.
02:35:38.710 - 02:36:09.080, Speaker B: Oh, okay, I guess so. Yeah, I mean, basically what happens is you're going to need to bridge ETH from girly testnet over to linea. So this is kind of I hope you guys know how to use a bridge, but you can just think of it like this and then send it over. If this is not working. I think it will work. You can come to me. I have 2000 linear ETH so I'm happy to share but definitely try out our bridge.
02:36:09.080 - 02:36:40.776, Speaker B: But yeah, so the first thing you need to do is get linear east to actually transact. The next piece is going to be choosing where you build your smart contracts. So I have an example specifically for Truffle foundry and Hard hat. But because it is EVM equivalent by code equivalent, you should be able to use like remix brownie. I don't know what other people use, but wherever you build, that's where you choose. So specifically with Truffle, actually I can probably do this. Let's try this.
02:36:40.776 - 02:37:02.104, Speaker B: So let's do a truffle init project. Oh, I'm in a project already. Whoops. Okay. Truffle init project code project. And I don't have any demo code in here actually. So pretend I opened this and then whoo.
02:37:02.104 - 02:37:12.240, Speaker B: I added all this stuff. Amazing. Wow. What does that look like? To actually deploy. So to deploy. And I'm going to show you what this looks like actually. Oh, I already opened it.
02:37:12.240 - 02:37:43.420, Speaker B: So here's Truffle dashboard running. If we go to Truffle dashboard specifically, you can choose what chain to deploy on. On MetaMask, I chose linear. If you want to deploy on Gurley mainnet, et cetera, you can do this all here. I'm choosing to use dashboard because I don't want to expose my private key to you. And then you can just do a Truffle migrate network dashboard. And if the internet works, something should show up.
02:37:43.420 - 02:38:06.384, Speaker B: I don't know if it will, so I'm just going to show you. This is what it looks like. It actually sends in the transaction. You just hit approve and then it happens with hard hat. Actually, you can also use the dashboard. You would just fit it in here and then deploy with NPX like hard hat. Deployrpc like Truffle dashboard with linear.
02:38:06.384 - 02:38:24.552, Speaker B: Specifically, this is our RPC endpoint RPC early linear build. We are permissionless public testnet right now. So that's how you would do it. Have any of you guys actually deployed a contract before? Oh, actually, most of you haven't. Damn. I'm just saying stuff as if you understand. Yeah, okay.
02:38:24.552 - 02:39:02.012, Speaker B: I will briefly touch on contract deployment. So essentially you have various tools. So like I said, Truffle Foundry hard hat that help you manage the deployment process. So that's going to be writing it and then giving you the opportunity to deploy to a network configure what those networks look like. So if you want to deploy to multiple networks, that would be part of a configuration that you add to your Truffle Hardy hat or Foundry project. The other piece is like, it offers testing functionality specifically when you choose where to deploy, that's kind of where this network configuration comes into play. If you guys have deployed a contract before, what it looks like is this URL will just be replaced with, like, early testnet.
02:39:02.012 - 02:39:17.190, Speaker B: Will we be replaced with mainnet, will be replaced with polygon in. What we're saying here is actually just needs to be RPC girly linear build. It's exactly the same. You don't have to change any of solidity code. So that's when I'm talking about stuff like StarkNet, for example, they are.
