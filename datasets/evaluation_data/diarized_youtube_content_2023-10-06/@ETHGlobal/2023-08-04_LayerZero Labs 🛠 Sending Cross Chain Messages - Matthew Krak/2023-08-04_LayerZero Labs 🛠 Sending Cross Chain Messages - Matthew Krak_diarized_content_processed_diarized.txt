00:00:18.770 - 00:00:29.640, Speaker A: Hello everyone, and welcome to the SuperHack Layer Zero Workshop, sending cross chain messages. Joining us today is Matthew Crack, who will be taking us through this session and without pass it over to Matthew to get the session started.
00:00:30.170 - 00:00:31.042, Speaker B: Here's, Jim.
00:00:31.106 - 00:00:45.674, Speaker C: Everybody. Welcome in. Thank you guys for having me. Super excited to be presenting here for ETH Global. I'm sure that many of you have seen the bounty that we've got going on for this hackathon. So excited to see all the submissions you got going on. And with that, we'll kind of jump.
00:00:45.722 - 00:00:47.790, Speaker D: Right into it real quick.
00:00:47.860 - 00:00:49.840, Speaker C: Just pulling up my screen here.
00:00:50.610 - 00:00:52.154, Speaker D: For those of you who are unaware.
00:00:52.202 - 00:01:44.762, Speaker C: I'm with Layer Zero and we're going to be talking a little bit about what Omnichan messaging is and hopefully jumping in a little bit more too with just how Layer Zero works as a protocol. So jumping straight into it, I want to give you guys a little background about who we are. Layer Zero is an open source protocol for building Omnichan interoperable applications and we provide authentic and guaranteed message delivery without sacrificing decentralization, efficiency or scalability. What does that really mean though? I want to jump in today and kind of explain what the concept of Omnichain messaging is and how we provide authentic data delivery between not just L ones, but L two S, as well as optimism base and many of the chains you'll be working on during this hackathon. So before we get into Layer Zero, I'd love to kind of walk you through the evolution of just cross chain messaging as a service and kind of understand some of the shortcomings of previous solutions.
00:01:44.906 - 00:01:46.926, Speaker D: So in the early days of just.
00:01:46.948 - 00:02:47.860, Speaker C: Blockchain messaging, you would have data existing on Chain A and you'd like to ideally get it to Chain B. The main ways that you went about doing this before were usually by having some central third party take the data that you'd like to move from Chain A and then they would write it themselves for you on Chain B. And this service worked initially, but obviously the major shortcomings we had were that you were adding a level of centralization directly into the blockchain ecosystem. It meant that you couldn't really verify that data integrity was being upheld. And it also left a lot of systematic risk for the projects that were using this service. Once we kind of realized the issue with third parties and jumped in with some of the core principles for blockchain and tried to build around that, we came up with a solution of middle chains. A middle chain was basically a chain that sat in the middle of Chain A and Chain B and tried to preserve some of that ledger technology so that there wasn't a central third party that was responsible for relaying data.
00:02:47.860 - 00:03:52.950, Speaker C: The major issue with a middle chain solution like this was that one, sometimes the validator sets were very limited so you would have potential for there to be false information broadcast across the network. And the second issue is that even though you interest a new chain, you didn't always guarantee that chain was decentralized well enough to actually be able to preserve data integrity. Some of the major risks that you really brought up in this solution were there's a lack of decentralization, you were often forced to accept whatever that middle chain security profile was. So if that meant that the chain had upgradable contracts, you were forced to use those upgradable contracts regardless of whether your app wanted to or not. And you were basically giving your app security in the hands of this third party, which in the case of many exploits, led to systematic and contagion of risk that happened across the ecosystem. You can think of the Ronan hack, for example, that happened with Axie Infinity as a clear cut example of this. So clearly this solution isn't scalable.
00:03:52.950 - 00:04:55.066, Speaker C: Ideally, the best way to improve sending message data from chain A to chain B would be to have a way for you to own your own app security, essentially being able to ensure that the data you're sending from A to B is one, valid, two, not being changed in flight and three, not able to be rolled back. And that's kind of what we want to talk about today with layer zero. If we were going to provide this solution, how do we achieve it? I think the first parameter you would need is that this would have to be a permissionless technology. You would have to allow anyone who's anyone to build on top of the protocol. The second feature would have to be immutability. You would need that this solution have, one, the inability to change over time so that apps that had previously accepted a security profile wouldn't be at risk of a new update coming along. And three, this messaging protocol would have to be censorship resistant, right? That data would have to be able to be transmitted from A to B in every possible case and not have a third party potentially come in and block the flow of data.
00:04:55.066 - 00:05:48.218, Speaker C: So how do we actually go about achieving this level of security that I talk about now? The traditional approach like we outlined is you would have an off chain entity sitting between A and B relaying that information. But the problem is that with only one off chain entity, you have susceptibility to that off chain entity lying right. There's no way to confirm that they're going to tell the truth every single situation and every single time. Ideally, if we had permissionless technology, we could have multiple actors running their own offchain security and being able to actually validate against a set of other offchain providers what the validity of that data transfer is. Additionally, you would be able to own it and run it yourself if that was something that you wanted to do. The second piece that I talked about was that we need to make sure that this data flow is not mutable. We need to make sure that data being sent from chain A to chain B is not being changed when it's sent in flight.
00:05:48.218 - 00:06:14.914, Speaker C: And this is something that comes up a lot when we talk about cross chain messaging. If, let's say that I'm confirming that I want to purchase tokens on a destination chain and I pay for them on the source, how do I make sure that that data is being sent through so that I actually receive at my chosen wallet address, for example? Right. Those tokens. We need to make sure that this can't be changed once the message is sent, making it immutable. The final thing that I talked about was making it censorship resistant.
00:06:14.962 - 00:06:15.414, Speaker D: Right.
00:06:15.532 - 00:07:03.634, Speaker C: Traditionally, if you had this third party entity in the middle, the way that they would go about messaging was potentially prone to censorship. You could cancel messages before they were delivered and actually logged on chain by your destination blockchain. Ideally, we need to use smart contract enforcement to ensure that these messages that are being sent from chain A to chain B are always going to be delivered and not blocked or removed by potential failures of the system or the protocol. So with that out of the way, I'd love to kind of jump into layer zero and how we tackle these three prongs of security. The first thing I want to outline is how layer zero actually works from a technical level. So we use smart contracts that we have named endpoints as a way for transmitting this information from A to B. All a layer zero endpoint is is a set of immutable non upgradable.
00:07:03.634 - 00:07:31.674, Speaker C: And that's the keyword smart contracts that handle transmission validation and receipt of transaction message data from a source blockchain network to a destination blockchain network. In this case, as I've outlined, you could potentially send an endpoint on optimism and it would be connected to any of our other endpoint contracts across all other networks that we support. For more information on this, we'll definitely jump in and make sure that you guys understand it. But from a high level. This is the basis for layer zero's protocol.
00:07:31.722 - 00:07:35.246, Speaker D: This endpoint to endpoint communication walking through.
00:07:35.268 - 00:07:58.274, Speaker C: A little bit more of how the user flow works. User applications are contracts that you are deploying yourselves. So for all you hacking, you are the guys who are building these user applications. What we allow through the layer zero protocol is essentially to specify in your user application using the data patterns that we've created or design patterns, I mean, is to specify what endpoint you're communicating with, whether that's on chain.
00:07:58.322 - 00:08:00.934, Speaker D: A or chain B, and then sending.
00:08:00.982 - 00:08:26.990, Speaker C: A configuration of not only your security that you want through this message library called our ULN, but also being able to determine, for example, let's say, how many block confirmations a transaction should wait while it's being routed, or what security pairing I'd like. We really want to make sure that you as a developer have the maximum level of configurability possible in order to build your application and that's something essential to layer zero's protocol.
00:08:27.150 - 00:08:30.926, Speaker D: From here we have the Oracle and the Relayer pair.
00:08:31.038 - 00:09:34.886, Speaker C: These are two independent off chain entities that we talked about earlier that are able to essentially vet and make sure that the transaction info sent on chain A is going to be delivered to chain B. Walking through a little bit of like a user flow, you would send a message from your application which would be read by the endpoint and forwarded along to your message library of choice. We would emit that message off chain and our Oracle or Relayer would be listening. You as an app developer could run your own relayer or choose what Oracle relayer pairing you want to use. And the important part here is that these are two independent entities. You would not have to rely on a single configuration of an off chain entity in order to ensure that your message was going to be passed along from there. On our destination side, that message is picked up, we confirm independently from both the Oracle and the Relayer, both a block header and a proof confirmation that basically ensures that the data has not been changed intermittently while that's being sent before finally forwarding that message to our endpoint and our user application.
00:09:34.886 - 00:10:10.942, Speaker C: So I've gone through a lot here, maybe a little too fast. But just to overlie or give a quick overview of what I've just said, the whole point of layer zero's protocol is to ensure that the messages you're sending from your source application to your destination application are preserved through immutability, censorship, resistance, and guaranteed delivery at that destination. All through a process that you, as a user, are able to configure and predict. That way you don't have to opt into any of those unnecessary updates, fall prey to updates that are outside of your control or potentially fall victim to security vulnerabilities and future patches.
00:10:11.086 - 00:10:12.420, Speaker D: That's the big group.
00:10:13.030 - 00:10:59.826, Speaker C: So moving forward to a couple of examples that we can go through, the major example that you could build out in this hackathon is an oft an Omnichan fungible token. Using that previous system that I talked about where you send messages from chain A to chain B. You could send a message from chain A to burn a token and then mint that same token on network B using a contract that you've deployed from chain A and chain B. This effectively allows you to now have unified liquidity through your smart contracts where they are controlling the existence of tokens on chain A or chain B and where you still own the contracts on both networks looking in the chat really quickly. Yeah, so actually that's a good question. So similar in the sense that we.
00:10:59.848 - 00:11:03.374, Speaker D: Have an oracle here in our setup.
00:11:03.422 - 00:12:00.834, Speaker C: But you could choose a chainlink Oracle. There are other Oracle providers that you could allow. The main idea of the Oracle and Relayer setup is that you can choose essentially any parameter for your security or run your own security if you want to as well that's listening to those messages emitted on chain A and then relay the chain B, you have more control basically over that security configuration. An example really quickly of how this might work in practice. Right, let's say we have an ERC 20 we've deployed on Ethereum already. You could deploy a second contract called Proxy of T, which is inheriting our layer zero library that we have already. This contract would communicate with our endpoint on Ethereum and enable you to use the same process I outlined before this burn and Mint functionality to then burn or store a transaction from your ERC 20 on that source chain, and then mint a new token on optimism or on base, wherever you'd like it to exist, that has unified liquidity.
00:12:00.834 - 00:12:40.254, Speaker C: Because your smart contracts are connected together, you wouldn't have to worry about the ERC 20 token potentially falling victim to a wrapper attack where someone wraps your token and then you lose control over the actual asset itself. You would basically have straight control over your asset's existence on all chains it's deployed on. This part here should say optimism or base, but you can also deploy on arbitrary monoptos if you want to, too. Really quickly. I think what might help cement this a little better is let's actually jump into the code demo really quick. So jumping over to my remix IDE. This is simply 50 lines of code if you exclude the comments.
00:12:40.254 - 00:12:56.482, Speaker C: And I'm going to have this repo posted for you guys both in the discord channel as well as I'll drop it in here as well, too. But the general idea is that you can deploy exactly that comment on my own layer two with Op Stack.
00:12:56.626 - 00:12:56.886, Speaker D: Yeah.
00:12:56.908 - 00:13:03.018, Speaker C: So I believe we have support for the Op Stack library. You might have to deploy your own endpoint or have us help you with.
00:13:03.024 - 00:13:05.610, Speaker D: The endpoint deployment there, but the general.
00:13:05.680 - 00:13:07.942, Speaker C: Idea is that you're able to essentially.
00:13:08.006 - 00:13:10.758, Speaker D: Deploy across any of the supported endpoints.
00:13:10.774 - 00:14:05.242, Speaker C: That we offer currently and have that asset move uniformly based on your own security parameters there. This contract is relatively simple. All we're going to do is store a string on our source chain and then deliver that string to our destination, all using one transaction call. So again, I'm going to put this GitHub repo out here with a full tutorial that you can read through if you want to follow along by yourself. But really, here's how we're going to deploy this contract. This is your user application. Inside this constructor argument, I've outlined the address for a layer zero endpoint, and we're calling this non blocking layer zero app that we have as just a design pattern, right? Currently I'm on Gurley ETH and what I'm going to do is take my girly ETH endpoint address, which I've mapped here, and just basically tell my user application that, hey, this is the endpoint that we're going to communicate with on our source chain.
00:14:05.386 - 00:14:07.598, Speaker D: I'm going to hit deploy, wait for.
00:14:07.604 - 00:14:10.174, Speaker C: The MetaMask prompt, hit confirm, and then.
00:14:10.212 - 00:14:15.258, Speaker D: You should have a deployed contract pop up here in a moment and we're.
00:14:15.274 - 00:14:18.318, Speaker C: Going to do the same thing again once this deploys.
00:14:18.494 - 00:14:19.826, Speaker D: Let me just pull up here and.
00:14:19.848 - 00:14:33.798, Speaker C: Make sure we're going Gurley's a little slow. There we go. We're going to deploy the same exact contract, only this time on optimism Gurley. So we switch over in this case because I'm on optimism now, I'm going.
00:14:33.804 - 00:14:38.200, Speaker D: To use our optimism Gurley endpoint address deploy here.
00:14:40.430 - 00:14:45.722, Speaker C: I'm going to cancel that and actually send it again. Sometimes we have a weird thing where.
00:14:45.776 - 00:14:48.518, Speaker D: Estimated gas pops up with that error.
00:14:48.534 - 00:14:49.900, Speaker C: But it doesn't actually matter.
00:14:50.270 - 00:14:52.826, Speaker D: So while we're waiting for this, there.
00:14:52.848 - 00:15:36.278, Speaker C: We go, way faster. We have two contracts deployed, one as our source contract and one as our destination contract. We're now going to link these contracts together in order for them to communicate. It's very simple how we do this process. We have this function here called set trusted remote. All we're going to do is specify what chain our address is on or sorry, what chain our destination contract is on and what that destination contract address is. This is just a design pattern that we've set up to make it where your apps are natively, able to communicate with each other and you don't have to worry about filtering any of the other messages that may be sent from other applications looking to communicate with your contract.
00:15:36.278 - 00:15:45.802, Speaker C: So since we're already on our optimism chain, let's actually just copy this top contract address. We're going to hop into our contract.
00:15:45.866 - 00:15:48.654, Speaker D: That'S now deployed on optimism, head over.
00:15:48.692 - 00:15:50.320, Speaker C: To Set Trusted remote address.
00:15:50.850 - 00:15:54.190, Speaker D: We're going to paste our Gurley contract.
00:15:54.530 - 00:15:56.194, Speaker C: And we're also going to take our.
00:15:56.232 - 00:15:59.838, Speaker D: Layer zero chain ID for Gurley, paste.
00:15:59.854 - 00:16:12.310, Speaker C: It into our remote chain ID. These are just chain IDs that we've specified for our layer zero endpoints because they're different than the actual blockchain IDs that we have natively for like wallets and then hit transact.
00:16:12.810 - 00:16:18.306, Speaker D: You shouldn't need to populate this with any message value, but hit confirm, we've.
00:16:18.338 - 00:16:20.330, Speaker C: Set our trusted remote on optimism.
00:16:20.670 - 00:16:21.418, Speaker D: Awesome.
00:16:21.584 - 00:16:40.074, Speaker C: We're now going to do the exact same thing again, only this time on our Gurley contract. So just switching back over to Gurley. Popping into Set trusted remote. We are going to take our now optimism contract address, paste it in here, as well as our optimism destination chain.
00:16:40.122 - 00:16:45.178, Speaker D: ID, paste in, hit transact, confirm.
00:16:45.354 - 00:16:47.906, Speaker C: And now essentially your contracts are linked together.
00:16:48.008 - 00:16:49.506, Speaker B: There are a few extra settings you.
00:16:49.528 - 00:17:11.462, Speaker C: Have to go through for oft or onFt deployments, but if you're using our default adapter parameters and some of our default configs. This is really the bulk of the work you have to do to start being able to send cross chain messages. So from here, the last thing I want to walk you through is how do we know how much gas we have to pay when we're sending Omnichain transaction.
00:17:11.606 - 00:17:14.234, Speaker D: Well, if we go down to our.
00:17:14.272 - 00:17:25.786, Speaker C: Estimate Fees function here, relatively simple function, we're again pulling this from our design pattern that we've already set up for you in our GitHub. But our Estimate Fees function basically allows.
00:17:25.818 - 00:17:27.818, Speaker D: You to take the chain ID we're.
00:17:27.834 - 00:17:30.586, Speaker C: Sending to let's just confirm that we are on Gurley.
00:17:30.618 - 00:17:34.462, Speaker D: Yep. So if we want to send from.
00:17:34.516 - 00:18:05.162, Speaker C: Gurley to Optimism Gurley, we'll paste our chain ID in here. This lets us know that we're sending to Optimism Gurley. We're going to then paste our adapter parameters. This is something that can be customized a bit by you on your user application. I'm not going to go into the details here, but in that GitHub repo, I've specified how we actually come about getting to these default adapter parameters and why it looks this way. So if you're interested, tune in there or check out some of our documentation to learn more. From there.
00:18:05.162 - 00:18:43.560, Speaker C: I'm just going to put in our test message, let's say my first Omnichan message, right? And then hit call. And you see here in Way, this is actually the native fee that's needed exactly to pay for this message to be sent to Optimism, including our Gurley fee, our Optimism fee, as well as the Oracle and relayer fee that's taken from layer zero Infrastructure Protocol. So we're going to pass that native fee into here. Before we call our send function, we're going to pass the same exact message in my first Omnichain message.
00:18:44.250 - 00:18:49.110, Speaker D: Hit transact, hit confirm.
00:18:50.010 - 00:19:12.890, Speaker C: And now you've sent your first Omnichan message from here. We're just going to confirm that it goes through on Gurley, depending again on what blockchains you're deploying to as well as congestion at that time. It may take a few minutes for it to be recorded, but the handy thing that we've built for you because we know that it can be a little painful, is a testnet layer zero Scan Explorer.
00:19:12.970 - 00:19:15.614, Speaker D: So this helps map for you where.
00:19:15.652 - 00:19:27.718, Speaker C: Messages are being transferred to and from and really gives you a good idea of whether or not things are going accordingly to how you plan them in your testnet environment. So let's just make sure here that.
00:19:27.884 - 00:19:29.894, Speaker D: This is searching good.
00:19:30.012 - 00:19:36.294, Speaker C: In the meantime, I'm going to hide the meeting controls so I can see.
00:19:36.332 - 00:19:41.258, Speaker D: This good and then hop back over to Gurley. Awesome.
00:19:41.344 - 00:19:51.530, Speaker C: We can see that our transaction was successfully confirmed on Gurley and now it is in flight to layer zero's infrastructure and ultimately to Optimism.
00:19:52.430 - 00:19:53.886, Speaker D: In the meantime, while we're waiting for.
00:19:53.908 - 00:19:59.626, Speaker C: This to go through, you can check in here. Actually, if we switch over to optimism. Gurley.
00:19:59.658 - 00:20:06.174, Speaker D: Again, you can see in our destination contract, when we call data, it says.
00:20:06.212 - 00:20:09.154, Speaker C: Nothing has been received yet. This is important to note, this shows.
00:20:09.192 - 00:20:11.710, Speaker D: You that none of this is hard coded.
00:20:11.790 - 00:20:26.326, Speaker C: All this is changing live. We're seeing that basically what's happening here is that we are overriding this layer zero receive function when we get that message sent through on our destination endpoint, instead of having it say, as we.
00:20:26.348 - 00:20:33.194, Speaker D: Say in our constructor here, about having an empty string, we'll see that once.
00:20:33.232 - 00:20:40.090, Speaker C: This message gets delivered. Give it one more second here while we're indexing, we'll see this message change.
00:20:40.240 - 00:20:43.930, Speaker D: On Gurley or sorry, on Op Gurley.
00:20:44.090 - 00:20:47.790, Speaker C: To the message that we just sent from Ethereum Gurley.
00:20:48.770 - 00:20:50.720, Speaker D: Give it a little more time here.
00:20:56.180 - 00:21:06.576, Speaker C: But yeah, in the meantime, feel free to ask any questions and I will try my best to answer them for you. Also see if I can pull up.
00:21:06.758 - 00:21:13.204, Speaker D: The message controls that I just lost. Here we go.
00:21:13.242 - 00:21:14.304, Speaker C: Show floating controls.
00:21:14.352 - 00:21:15.270, Speaker D: There we go.
00:21:18.640 - 00:21:20.190, Speaker C: This makes a lot of sense.
00:21:21.440 - 00:21:21.852, Speaker D: Yes.
00:21:21.906 - 00:21:23.900, Speaker C: The message gets stored on chains.
00:21:24.960 - 00:21:25.964, Speaker D: Awesome. Yeah.
00:21:26.002 - 00:21:30.368, Speaker C: In the meantime, I'll also drop this repo that I threw together for you guys as well.
00:21:30.534 - 00:21:31.996, Speaker D: This will give you a clear overview.
00:21:32.028 - 00:22:27.110, Speaker C: Of actually everything that's happening behind the scenes and a little bit more detail into all of the parameters that I'm filtering in. And yeah, what we're essentially trying to prove here is that outside of just being able to send a string from your source to your destination chain, we're really trying to show that you can pass any arbitrary data using layer zero's protocol. And what that means is besides storing strings right on a destination chain, you could have a function from any source chain that you'd like. For example, call an external contract or call an external function on your destination side. This can be incredibly useful for building complex interactions where you want a user to pay on one source chain to trigger an action on your destination, or if you just simply want to take advantage of the bridging functionality and move assets natively. It allows you within your own application without taking on any bridging risk, to use this functionality yourself.
00:22:29.720 - 00:22:31.456, Speaker D: How does it prevent message spoofing?
00:22:31.488 - 00:22:32.164, Speaker C: Good question.
00:22:32.282 - 00:22:34.356, Speaker D: So the two things that we look.
00:22:34.378 - 00:22:54.776, Speaker C: For going back into our example here, we submit from our source chain basically a transaction proof, right, of what the message is on source and then on destination. We're confirming that transaction proof matches with the block header that we have coming through from the Oracle.
00:22:54.888 - 00:22:56.956, Speaker D: So the idea is here is that.
00:22:56.978 - 00:23:26.420, Speaker C: We'Re trying to preserve message integrity that's being sent from source to destination to prevent that message from being switched up. If you want a little more specifics on how that works, feel free to ping me on discord and happy to connect you with the correct resources. Real quick, let's check back in here and see if we are moving through. Still a little slow. Again, message congestion happens. If it takes too long for this workshop, I will make sure to ping you in discord with the configured not configured with the delivered message.
00:23:26.570 - 00:23:29.832, Speaker D: But the idea is here that you.
00:23:29.886 - 00:23:49.260, Speaker C: Basically can now forward messages from any chain you'd like to any destination with limited impact to your application. And also with complete customizability on the configuration, you're not subscribing to a third party bridge that could upgrade at any time and introduce a vulnerability. You can basically choose your application security settings.
00:23:52.300 - 00:23:52.760, Speaker D: Good.
00:23:52.830 - 00:23:57.884, Speaker C: So, yeah, we're in here on Ether scan. And then let me just double check.
00:23:57.922 - 00:24:01.404, Speaker D: Because sometimes indexing is slower than the.
00:24:01.442 - 00:24:03.624, Speaker C: Actual arrival of the transaction.
00:24:03.752 - 00:24:06.488, Speaker D: But overall, I hope this is helpful.
00:24:06.584 - 00:24:22.580, Speaker C: In kind of explaining how layer zero works as a protocol. And feel free to follow along in that GitHub repo that I've linked. How to replicate this yourself. And you can see on your own machine or through your own example on remix, how exactly these messages are delivered.
00:24:26.300 - 00:24:26.712, Speaker D: Yeah.
00:24:26.766 - 00:24:27.908, Speaker C: In the meantime, let's see if there's.
00:24:27.924 - 00:24:29.370, Speaker D: Any other questions up here.
00:24:31.500 - 00:24:45.230, Speaker C: Oh, can I show an example if there are three or more chains? Yeah, so, good question. If I was going to do three or more chains, all I would do let's see if I have any matic in here. Actually, that would be a good way to figure this out.
00:24:45.860 - 00:24:47.612, Speaker D: Or do I have enough sepole ETH?
00:24:47.676 - 00:24:48.560, Speaker C: I don't. Okay.
00:24:48.630 - 00:24:49.440, Speaker D: Bummer.
00:24:53.060 - 00:24:54.640, Speaker C: No, I don't. Okay.
00:24:54.790 - 00:24:55.344, Speaker D: Yeah.
00:24:55.462 - 00:25:06.400, Speaker C: The way you would go about deploying to a third or fourth chain is basically following this exact same process I outlined. So you would deploy again another version of the Omni message contract.
00:25:06.560 - 00:25:09.012, Speaker D: You would input for the layer zero.
00:25:09.066 - 00:25:22.644, Speaker C: Endpoint, our endpoint addresses that live on that chain you're deploying from. So if it was, for example, I don't know, base, if you wanted to, right, you would go in and you can actually find this within our repo.
00:25:22.692 - 00:25:25.470, Speaker D: Here I've listed, I believe.
00:25:27.520 - 00:25:30.990, Speaker C: Let's see here. Yeah, so you can go in here.
00:25:31.360 - 00:25:37.132, Speaker D: Into our layer zero documentation, go down to base and you would take this.
00:25:37.186 - 00:25:42.064, Speaker C: Endpoint address, plug it into your deploy function or deploy script again.
00:25:42.102 - 00:25:42.448, Speaker D: Right.
00:25:42.534 - 00:26:32.640, Speaker C: You would hit deploy, assuming you obviously have gas on base and have the network configured in MetaMask deploy to base, you would have a third contract pop up here. You would follow the exact same process I did for Set trusted remote address. The only thing is, if you wanted to send from, let's say, Ethereum and Optimism to base, you would have to configure that remote address twice, essentially. So you would link them all together and have them listed as a remote address that you're trusting. And then if you wanted to, let's say, trigger a function call where I send from Ethereum to Optimism and then call something on base, you would have to use our send and call functionality, which you can find more of in solidity examples in our GitHub. Feel free to ping me though, if you are looking to explore that exact interaction.
00:26:33.220 - 00:26:34.272, Speaker D: Let's check here.
00:26:34.326 - 00:26:46.196, Speaker C: I think hopefully this is done. We are doing some major upgrades right now, so there is a lot of congestion on the network and I know that testnets right now can sometimes be.
00:26:46.218 - 00:26:49.588, Speaker D: A little slow, but is there a.
00:26:49.594 - 00:27:22.896, Speaker C: Permissionless way to add extra chains? Let's say if you roll out my own LPL two stack, so there are ways to go about getting deployments onto other chains that Layer Zero hasn't officially rolled out on yet. I think that I'd like to connect you with an engineer who can help with that question better. I've joined Layer Zero a little over a month ago, so I'm not entirely sure exactly on adding your own endpoint, but the whole point of Layer Zero's architecture is as permissionless. So if anything were to happen to.
00:27:22.918 - 00:27:25.984, Speaker D: Layer Zero as a parent organization, you.
00:27:26.022 - 00:27:37.750, Speaker C: Could have access to all of the contracts that we've already deployed on Chain. Roll them out yourself. It would take a lot of heavy lifting right, for you to redeploy everything, but the idea is basically to.
00:27:39.800 - 00:27:40.164, Speaker D: Go.
00:27:40.202 - 00:27:56.552, Speaker C: Through that process in the event of something happening to the protocol. Right. The idea is that the protocol will last long after Layer Zero is gone in terms of endpoints. I also believe that we are making it easier to roll out on the Op stack and other what's it the word? App chains.
00:27:56.616 - 00:27:57.324, Speaker D: Yeah.
00:27:57.522 - 00:28:01.640, Speaker C: Can you go back to the link on our slides? I was hooked on your architecture.
00:28:01.720 - 00:28:02.156, Speaker D: Sure.
00:28:02.258 - 00:28:11.264, Speaker C: Yeah, we can jump in here while we're waiting. Also, guys, feel free to stop me if I'm running over time here. I know I've been going on, but.
00:28:11.302 - 00:28:14.700, Speaker A: Yeah, I think the question for is if you could post the slides.
00:28:14.860 - 00:28:15.900, Speaker C: Oh, post slides?
00:28:15.980 - 00:28:17.712, Speaker A: Post the link to it.
00:28:17.846 - 00:28:27.270, Speaker C: I think I can do that. Yeah, that shouldn't be an issue. I can get that actually going into our Discord. Let's see if we're getting this through.
00:28:30.610 - 00:28:32.080, Speaker D: Check one more time.
00:28:36.720 - 00:28:48.080, Speaker C: If not and we run out of time here, we'll make sure that this gets sent through. We've had some weird instances where it takes a little longer than ten minutes, but on main net things are pretty instantaneous.
00:28:56.310 - 00:28:58.726, Speaker D: And yeah, while we're waiting here, we.
00:28:58.748 - 00:29:23.530, Speaker C: Can also just jump through too. If you guys ever have any questions, concerns, want to reach out to me or anyone else from the team, we're happy to help. Feel free to either message in our Discord channel that we have set up now with SuperHack. Feel free to jump into layer zero's own discord. You can follow the QR code here. Also, feel free to ping me directly. I'm happy to answer questions either from Twitter Telegram.
00:29:23.530 - 00:29:29.920, Speaker C: I'll actually throw my Twitter handle really quick into the Zoom chat here.
00:29:32.470 - 00:29:33.522, Speaker D: So yeah, feel.
00:29:33.576 - 00:29:58.070, Speaker C: Free to just reach out if you have any questions you'd like more clarification on. Hopefully we get this going through here in a second. If not though, thank you guys for tuning in. I hope this kind of gives you a better overview of how Layer Zero works. Like I said, GitHub link in the comments. Currently we'll have that posted in the Discord shortly for you. Same thing with this block confirmation once it goes through.
00:29:58.070 - 00:30:07.340, Speaker C: Testnets can be annoying sometimes and unpredictable, but I hope this kind of helps you better understand how Layer Zero works as a protocol and how you can start building on it today.
00:30:12.910 - 00:30:13.418, Speaker D: Awesome.
00:30:13.504 - 00:30:20.462, Speaker A: Cheers. Well, thanks Matt. I mean, we try and wait to see if it eventually goes through or not.
00:30:20.596 - 00:30:24.480, Speaker C: It's always when you want it to go through, right? It doesn't want to go through.
00:30:26.070 - 00:30:44.646, Speaker A: Awesome. Cheers. Well, thanks for the great workshop and presentation and thank you all for attending as well. So, yeah, this was the last workshop for the day. The opening ceremony is tomorrow and as Matt said, yeah, feel free to reach out to him on Discord or writing the partners if you have any other questions.
00:30:44.828 - 00:31:05.502, Speaker B: This within our repo here I've listed, I believe. Let's see here. Yeah, so you can go in here into our Layer Zero documentation, go down to base and you would take this endpoint address, plug it into your Deploy function or Deploy script again.
00:31:05.556 - 00:31:05.918, Speaker D: Right?
00:31:06.004 - 00:31:56.030, Speaker B: You would hit Deploy assuming you obviously have gas on base and have the network configured in MetaMask deploy to base. You would have a third contract pop up here. You would follow the exact same process I did for Sent trusted remote address. The only thing is, if you wanted to send from, let's say, Ethereum and Optimism to Base, you would have to configure that remote address twice, essentially. So you would link them all together and have them listed as a remote address that you're trusting. And then if you wanted to, let's say, trigger a function call where I send from Ethereum to Optimism and then call something on base, you would have to use our Send and Call functionality, which you can find more of in solidity examples in our GitHub. Feel free to ping me though, if you are looking to explore that exact interaction.
00:31:56.030 - 00:32:53.418, Speaker B: Let's check here. I think hopefully this is done. We are doing some major upgrades right now, so there is a lot of congestion on the network and I know that testnets right now can sometimes be a little slow, but is there a permissionless way to add extra chains? Let's say if you roll out my own LPL two stack, so there are ways to go about getting deployments onto other chains that Layer Zero hasn't officially rolled out on yet. I think that I'd like to connect you with an engineer who can help with that question better. I've joined Layer Zero a little over a month ago. So I'm not entirely sure exactly on adding your own endpoint, but the whole point of layer zero's architecture is that's permissionless. So if anything were to happen to layer zero as a parent organization, you could have access to all of the contracts that we've already deployed on Chain.
00:32:53.418 - 00:33:01.220, Speaker B: Roll them out yourself. It would take a lot of heavy lifting right. For you to redeploy everything, but the idea is basically to.
00:33:03.270 - 00:33:04.114, Speaker C: Go through that.
00:33:04.152 - 00:33:06.750, Speaker B: Process in the event of something happening to the protocol.
00:33:06.830 - 00:33:07.218, Speaker C: Right.
00:33:07.304 - 00:33:20.002, Speaker B: The idea is that the protocol will last long after layer zero is gone in terms of endpoints. I also believe that we are making it easier to roll out on the Op stack and other what's it the word? App chains.
00:33:20.066 - 00:33:20.774, Speaker D: Yeah.
00:33:20.972 - 00:33:36.550, Speaker B: Can you go back to the link on our slides? I was hooked on your architecture. Sure, yeah, we can jump in here while we're waiting. Also, guys, feel free to stop me if I'm running over time here. I know I've been going on, but yeah, I think the question for is.
00:33:36.560 - 00:33:38.122, Speaker A: If you could post the slides.
00:33:38.266 - 00:33:39.630, Speaker B: Oh, post slides?
00:33:39.970 - 00:33:41.134, Speaker A: The link to it.
00:33:41.252 - 00:34:11.570, Speaker B: I think I can do that. Yeah, that shouldn't be an issue. I can get that actually going into our discord. Let's see if we're getting this through. Check one more time. If not and we run out of time here, we'll make sure that this gets sent through. We've had some weird instances where it takes a little longer than ten minutes, but on main net, things are pretty instantaneous.
00:34:11.570 - 00:34:46.940, Speaker B: And yeah, while we're waiting here, we can also just jump through too. If you guys ever have any questions, concerns, want to reach out to me or anyone else from the team, we're happy to help. Feel free to either message in our discord channel that we have set up now with Super Act. Feel free to jump into Layer zero's own discord. You can follow the QR code here. Also, feel free to ping me directly. I'm happy to answer questions either from Twitter Telegram.
00:34:46.940 - 00:35:18.490, Speaker B: I'll actually throw my Twitter handle really quick into the Zoom chat here. So yeah, feel free to just reach out if you have any questions you'd like more clarification on. Hopefully we get this going through here in a second. If not, though, thank you guys for tuning in. I hope this kind of gives you a better overview of how layer zero works. Like I said, get a blink in the comments. Currently, we'll have that posted in the discord shortly for you.
00:35:18.490 - 00:35:30.750, Speaker B: Same thing with this block confirmation once it goes through. Testnets can be annoying sometimes and unpredictable, but I hope this kind of helps you better understand how layer zero works as a protocol and how you can start building on it today.
00:35:32.640 - 00:35:40.204, Speaker A: Awesome. Cheers. Well, thanks, Matt. I mean, we try and wait to see if it eventually goes through or not.
00:35:40.322 - 00:35:44.190, Speaker B: It's always when you want it to go through, right? It doesn't want to go through.
00:35:45.760 - 00:36:04.310, Speaker A: Awesome. Cheers. Well, thanks for the great workshop presentation. Thank you all for attending as well. So, yeah, this was the last workshop for the day. The opening ceremony is tomorrow and as Matt said, yeah, feel free to reach out to him on discord or any of the partners if you have any other questions.
00:36:05.400 - 00:36:07.430, Speaker B: Yeah, cheers, guys. Thanks so much.
00:36:07.880 - 00:36:08.610, Speaker A: Cheers. See you.
