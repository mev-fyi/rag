00:00:09.940 - 00:00:33.440, Speaker A: Okay, let's start. Thanks everybody for coming. I'm ed Felton. I'm the co founder and chief scientist at Optchain Labs. And I'm going to talk about Arbitrum, which is our product. Now the second spin of Alpha that overcomes a bunch of the limitations of state channels. Franco, I'm going to talk about state channels, just sort of a review of what they are and what the limitations of state channels are.
00:00:33.440 - 00:00:57.008, Speaker A: And then I'll talk about sort of how we overcome those and some about the design of our product. And at the end, I'll just give a few pointers on what to do if you're interested in using it. All right, so, right, start with smart contracts. Smart contracts are awesome. They have their disadvantages. Every miner emulates every execution step. So the contract complexity is limited by the global gas limit.
00:00:57.008 - 00:01:31.890, Speaker A: On Ethereum, that gas limit is uncomfortably low. It's something like a 10th of a laptop of total computation capacity that has to be shared by everyone across the world. And this gas mechanism is basically necessary because it's expensive to run contracts. And also all of the contracts and code, code and data is public. So the total throughput is really limited by what a single miner can do. Right, so there are a bunch of responses to this to try to get scalability. One of them is state channels and just a review overview of what state channels are for those who need the review.
00:01:31.890 - 00:02:18.668, Speaker A: You have a fixed set of end participants in a state channel who are defined at the beginning when the state channel is operating as a state channel, they unanimously agree off chain about updates in the state of the channel. And as long as they unanimously agree on a sequence of updates, you can stay off chain and everything is good. And you only need to go on chain if there's not agreement among the participants. So the optimistic case is great. Everything happens off chain, and you only need to sort of cash out the state channel at the very end on chain. Okay, so if you want to write this as a smart contract in Ethereum, you'd write it sort of like this. You'd write it as a smart contract that operated in two modes, state channel mode and on chain mode.
00:02:18.668 - 00:03:03.404, Speaker A: So the contract starts out in the state channel mode and the participants then sign state updates locally. And when you're in this initial state channel mode and everything is going along off chain, then all of the functions of your contract are locked except for closed channel. Closed channel is basically which is what someone's going to do. If you are no longer reaching unanimous agreement off chain, then you're going to need to move on chain. So you initially start here, everything happens off chain except for this one opportunity to close the channel. Now, if you don't get agreement among all of the parties and that's going to happen either because somebody becomes unavailable or because somebody is just uncooperative or malicious. If that happens, then some participant can decide to close the channel.
00:03:03.404 - 00:03:41.950, Speaker A: Actually, any participant can decide to close the channel just because they feel like it. But in any case, once you close the channel, the contract now enters the on chain mode. The contract is initialized with the most recent signed state whatever is the most recent version that all of those parties agreed to off chain. That's going to be the initial state of the now on chain execution of the contract. All the functions are now unlocked and the contract proceeds on chain until completion. Right? So you ride the optimistic horse as long as you can and when the optimistic mode fails, then you switch to on chain execution. That's the standard state channel model.
00:03:41.950 - 00:04:21.240, Speaker A: So why use them? Well, they're fast, they're scalable because they fast and scalable because they have very little on chain footprint in the optimistic case. And they're also private when you're operating in the off chain mode. That is, you don't need the stuff that's happening in your contract that can just be agreed upon mutually by the participants. And as long as they all sign updates, you don't have to post those updates to Chain. And you can have a long interaction between the parties and at the end you just have a simple cash out transaction that they both agree to. So that's great when you're operating off chain. But there's a set of disadvantages that state channels have a set of limitations.
00:04:21.240 - 00:05:01.536, Speaker A: So one limitation is that they're sort of fragile. If one party not only fails but even just goes offline for a while, one participant, then your fast progress halts. You switch into the slow on chain mode and you stay there. State channels don't distinguish generally between unavailability and malice. So it doesn't require that somebody be wrong or malicious, just if they have a hiccup in the availability of their computation or their network, the result will be the whole thing will go on chain and stay on chain. So that's the fragility. The second limitation is that they're computationally limited.
00:05:01.536 - 00:05:59.060, Speaker A: Although you can do huge amounts of stuff, lots of computation, have lots of storage when you're operating off chain, you need to be prepared at any time to move on chain and that means whatever it is you're doing, it has to be doable on chain. And so even if you're in the optimistic case, you have to be able to get pessimistic and so that means you can't do more than on chain resource limits would allow. So state channels improve the transactions per second, but you still face the same limitations on computation and storage as you would if you were on chain. The third limitation is you don't get guaranteed privacy. You have privacy of what's happening if you're operating off chain. But as soon as you go on chain everything is visible again and then finally, generally, state channel models require specialized development. That is, you don't write your contract in the standard programming model or paradigm.
00:05:59.060 - 00:06:56.490, Speaker A: You have to write your contract specially for a state transition paradigm in which the contract goes through sequences of states and what gets agreed upon is the state in between. And that's a different programming model than the one that you have if you're writing a normal contract in, let's say, solidity. So the fact that you have to write in a different model and a model that some people at least consider to be less friendly is a drawback. So those are the four limitations. Arbitrum, our solution from off chain labs, solves all of these make, and I'll explain how and why this happens in a minute. But we can make non unanimous fast progress, meaning that if somebody becomes unavailable, we can still make progress fairly quickly, not quite as quickly as if everyone's available. Even if somebody gets malicious or in error and there's a dispute, we can still make progress relatively quickly.
00:06:56.490 - 00:07:44.504, Speaker A: We can resolve disputes between parties without having to run the full code on chain. We have a very efficient on chain dispute resolution protocol which operates without taking more than a tiny bit of state and putting it on chain. And that means that because we never have to move your whole contract on chain, that we're not limited by the computation and storage that we could do on chain. We can do more than can be done on chain and sustain that. And privacy is guaranteed even when there's a dispute because you don't have to move the state of your contract onto the chain in case of dispute. If you want to keep the code of your contract secret or you want to keep the state of your contract secret to only the participants, you can do that. And there's no need to explicitly reprogramming the state transition model.
00:07:44.504 - 00:08:45.790, Speaker A: You can compile existing solidity contracts without modification using a compiler that we supply. So if you have and my colleague Harry Klodner did a API workshop this morning where he did a sort of live porting of a simple DAP from ethereum into Arbitraring in a few minutes. It requires changing only a few lines of code sort of in the initialization. Okay, now there are a couple of different use cases or styles of using Arbitrarim, which I sort of summarize here in this table. And I'm not going to go through all of this, but I just want to note that what I'm going to talk about here is what we call Arbitrum channels, and that is a state channel like mode of operation where there's a fixed set of participants. The system runs trustlessly for the participants, and computation, storage, and messages all happen off chain. We give instant finality in the common case and privacy is such that only the participants need to know what's going on.
00:08:45.790 - 00:09:37.260, Speaker A: We also have an Arbitrum chain mode where the participants are dynamic, participation is dynamic and open to everybody. It has slightly different performance characteristics because messages too, that the call data of your transactions has to be on chain, but computation and storage still off. So I'm going to talk here in this session about arbitrary channels. Okay? So basically the arbitrary design involves a very high level, a combination of three things. It involves some protocol design, that is, how is it that the party's participants interact with each other. It involves some incentives. We give parties incentives to come to agreement off chain and we produce strong disincentives to ever getting into a dispute.
00:09:37.260 - 00:10:10.756, Speaker A: And then there are some things we do in the virtual machine architecture that allow us to make dispute resolution very cheap. And I'll go through this in a little bit more detail. So let me sort of build out how this Arbitrum channels mode works. One of the first concepts here is a validator. That's a term we use for a participant in an Arbitrum channel when you make a VM, a virtual machine. This is our term for a contract or group of contracts that are running sort of for a running DAP on the chain. You give a list of validators for it.
00:10:10.756 - 00:10:53.760, Speaker A: Those can be any parties you want. And those validators are responsible for keeping track of the VM's computation and its data. So think of them like the participants in a state chain and we provide what we call the antitrust guarantee. And that guarantee is that as long as at least one of your validators is honest, then we guarantee that your contract will execute correctly according to its code. That means in particular, if you're a validator, then you can force correct execution all by yourself. So it's trustless with respect to you. And that's why we say that arbitrary channels are trustless because every participant is a validator and any one validator can force honest progress.
00:10:53.760 - 00:11:43.072, Speaker A: Validators advance the state of the running VM in a couple of ways. They have incentives to agree unanimously about what a contract will do and when they unanimously reach agreement, they can repeatedly update the state without going on chain. This is very much like the optimistic mode of a state channel. You could have a whole series of executions and if everyone is well behaved and follows their incentives, then you're basically one on chain transaction to start your contract and another one at the end to cash it out. If they all agree, the system accepts what they agree on as correct. And that's consistent with that any trust requirement. So the method that we use is something we call unanimous assertion.
00:11:43.072 - 00:12:29.486, Speaker A: And it looks logically like this. The validators all agree that if the virtual machine starts in a state that has a certain hash and with its inbox of incoming messages having a certain hash, then it can execute end steps of computation. The result will be that the machine state will have this hash. The inbox will have that hash, and along the way, it will make some payments and send some outgoing messages. So if all of the validators agree on this, then they can sign a series of these things. And if they chain together with this resulting state, matching the precondition of the next one, then they can just chain them together off chain. So as long as it's signed jointly by all of the validators, you're good to go.
00:12:29.486 - 00:13:22.906, Speaker A: And that's all off chain. Okay? And once it is confirmed and fully signed by everybody, there's some technical details here, but except in rare cases, it's immediately final, meaning that we guarantee that it will eventually reach the main chain and achieve finality there so that applications clients can trust that they have already have finality. All right, so, so far, this looks like just regular state channels. I want to talk now about the more interesting case, which is how to make progress non unanimously. And one of the first pieces of this is what we call a disputable assertion. So any manager, any validator, can make an assertion that is a claim that looks just like one of those unanimous assertions, but it's made by just one party. And when they make this claim, they put down a deposit, which they might lose.
00:13:22.906 - 00:13:54.102, Speaker A: If they're lying, that assertion is subject to challenge. And if somebody challenges it, claims it's wrong, then they deposit funds. And if there is a challenge, then there's a dispute and the party that's wrong is going to lose their deposit. So it works kind of like this. Somebody makes a disputable assertion, and when they do that, a timer is started in which everyone else has an opportunity to challenge it. If they don't, if time passes without a challenge, then it's confirmed that it's accepted as correct. Everyone had their chance to challenge it.
00:13:54.102 - 00:14:31.042, Speaker A: They had an incentive to challenge it. And if they didn't, then they must have believed it was right. Alternatively, you can have an assertion, disputable assertion made. Somebody can challenge that. And now you have a dispute between an assertor who made the claim and a challenger who says it's wrong. And we efficiently resolved the dispute through a two stage protocol. The first stage involves bisection, that is the idea that once the challenge is made, the assertor has to bisect their assertion into two half size assertions that fit together to yield the initial one.
00:14:31.042 - 00:14:53.100, Speaker A: And then the challenger has to pick one or the other of these two sub assertions to challenge. Here they challenge the second one. Something's wrong with it. Maybe you didn't get to this end state. Maybe it didn't spend exactly these coins. Maybe you can't even execute N over two instructions. Whatever it is he claims, this is not a thing that this machine could do.
00:14:53.100 - 00:15:56.350, Speaker A: So you continue this process, recursively dividing into four. One of those gets challenged and so on. After a logarithmic number of stages of this, what you have then is an assertion about just one step of execution like say, an ad instruction and somebody has challenged that. Now at this point we go to the second stage of dispute resolution and this is the one that uses the virtual machine architecture and that's a one step proof. And so the party who has made the one step assertion needs to provide enough information that an onchain component can verify that their claim is correct or determine that it's wrong. And so the big question here is how big is this one step proof and how costly is it to create and verify through a bunch of trickiness in the way we design the virtual machine architecture, we make these one step proofs of small, constant size, meaning a few hundred bytes. And that's, independent of the complexity of the contract, how much code or data it has in it.
00:15:56.350 - 00:16:28.780, Speaker A: And they don't require complicated cryptography, just hashes and ordinary digital signatures. So the custom VM architecture guarantees that these proofs are small and it's efficient. One step proofs are this small and they're fast to create or verify. It costs about 90,000 gas on Ethereum to verify this. So this is order of less of worth of gas to check to verify one step free. And they're also private. They don't leak contract data because they're just dealing with hashes of things.
00:16:28.780 - 00:17:18.610, Speaker A: Okay, so one of the consequences of the way this design works is that the state of a virtual machine of a running contract is revealed only to its validators. They're the only ones who need to know. The only thing that appears on chain is this stuff. salvable hashes of the state cryptographic hashes, the number and timing of steps executed when you're in non unanimous mode, the fact that the VM executed some particular number of steps at some point in time, and also the messages and money that are sent and received by the VM. If the virtual machine is going to receive or make payments of ETH or of other tokens, that's ultimately going to need to be recorded on chain. And so that's going to be on Chain. But this is all that appears on the Ethereum main chain.
00:17:18.610 - 00:17:59.574, Speaker A: So Arbitrum runs on top of Ethereum. We have an ethereum contract called the ETH Bridge. We call the ETH Bridge which manages all of this, resolves disputes and so on. Okay, so right, built on Ethereum, we offer a compiler that takes your existing solidity code or takes EVM, Ethereum virtual machine code if you want compiles it into our AVM architecture so you can use existing contracts. We offer plugins on the front end for web3 Ethers and Go Ethereum to let you use your existing JavaScript or Go based front end. You just plug in our plugin instead of whatever one you're using. So you can use your existing front end code.
00:17:59.574 - 00:18:25.310, Speaker A: These virtual machines that are running can send or receive ETH or any ERC 20 or 721 token between Ethereum Land and Arbitrum Land or two other Arbitrum virtual machines. This is all available on GitHub. It's open source. You can go and try it out. Okay, so we have a developer site which is here, developer Offchainlabs.com. The code, as I said, is here in the URL. You can probably guess GitHub.com
00:18:25.310 - 00:19:22.432, Speaker A: offchainlabs arbitrarium. There's a developer Quickstart Doc and we have an API prize of $1,500 here at this event and we have a thick a few minutes for any questions. As a scalability solution, can you give a high level overview of how Arbitrum compares to other layer two solutions maybe such as scale? Sure. So where we are now in our alpha is for scalability, we measure a couple of things. There are several things that are relevant. One is how many contracts can you run at the same time and then what performance do you get for each contract and performance for each contract we measure both in terms of transactions per second. That is sort of how fast can you spin the dial and also how much computation you can do per second within a contract.
00:19:22.432 - 00:20:08.772, Speaker A: Right. So in terms of the number of contracts per second and if you could run simultaneously when you're running on sort of testnet on a local machine, local laptop so you can run thousands of contracts at the same time and we can make that number. Frankly, we feel safe saying thousands is an honest number but we can cook the benchmark to make that as big as you want. In terms of transactions per second, we currently are a bit over 500 transactions per second in each contract. Again, thousands of contracts at the same time. The amount of computation you can do in each contract right. Now, each contract can execute instructions at a rate that's about 2.3
00:20:08.772 - 00:20:38.672, Speaker A: times the global capacity of Ethereum within each contract. That's where we are now. We expect to get substantial improvements over that continuing over time. So the other thing that we think is important for application developers is finality time. Right. You want to be able to get instant finality in the common case and you want to be able to do that with a very strong trust guarantee. There are lots of different level twos out there and there's different trade offs between them.
00:20:38.672 - 00:21:14.200, Speaker A: We think we really hit a sweet spot in terms of scalability and performance privacy, instant finality in the common case and a very strong security guarantee. Right. So unlike some other chains which say you need to have half honest or two thirds honest participants in order to guarantee a correct execution, we have this very strong antitrust guarantee. So even one honest validator gives you guarantee of correctness. So it's trustless with respect to those participants. So that's basically what the trade off is there. Thank you.
00:21:14.200 - 00:21:21.350, Speaker A: Sure. Right. Yeah.
00:21:21.500 - 00:21:38.300, Speaker B: Do you imagine that because of a particular nature of the brief you have, that this is better suited to certain types of applications than others you could imagine? Because the proof you have, these certain things that this might not work for.
00:21:39.310 - 00:23:05.702, Speaker A: It does work for everything in the sense that you can compile any solidity program and the compiler doesn't generate a slowdown compared to other dispute resolution based systems. So in other words, it is general purpose in the sense that you can run anything on it. It's especially well suited for applications that require a lot of storage or a lot of computation, because the on chain footprint and the cost of proofs and so on are independent of the amount of storage and the cost of dispute resolution depends only in a logarithmic way on the amount of computation you do. And so things that require large storage or lots of computation, and in multi user type DApps, large storage may come from having a lot of users whose records all need to be kept within the app. We also have a particular type of privacy guarantee and so if you care about that, we also might be well suited for what you have. We kind of feel like we have a combination of features that is really unique as well. So if all you care about is privacy, then maybe you want something.
00:23:05.702 - 00:23:18.010, Speaker A: If all you care about is scalability and you're willing to sacrifice some security in order to get it, then maybe something else is right. But we think we're at the sweet spot where we do well on all of these dimensions.
00:23:20.420 - 00:23:22.556, Speaker C: So is this fully open source?
00:23:22.668 - 00:23:44.260, Speaker A: Yes, the current version is open source. There will eventually be a premium model which is closed, a premium version which is closed source. But the developer version we have out now is BSD licensed and will always be open source. There will always be a fully working system at at least the current performance characteristics that's open source.
00:23:44.420 - 00:23:47.960, Speaker C: What features are you planning to add to the agreement?
00:23:48.780 - 00:24:57.480, Speaker A: It'll be higher performance and primarily higher performance and some tools for sort of management and accounting, the sort of things that we think enterprises are likely to want in addition to higher performance. So can you say more about this? Only one honest party needed. So basically you're saying that you divide the code you do like a binary search in the code for the thing that people are contesting. So yeah, let's go back and then someone has to prove let's walk through the example a little bit more carefully just to kind of put a finger on that. Right? So suppose that I make a claim like this and you know, the initial state of the VM, you run it for end steps and you find that it ends with some other hash. So you would then just put down a challenge on my claims. Right? So now it's you versus me and this ethereum contract to Eastbridge is refereeing our dispute, right? So now it's my turn.
00:24:57.480 - 00:25:47.010, Speaker A: I have to bisect my assertions. Now, it's pretty easy to prove that if my initial assertion was wrong, then at least one of these two halves has to be wrong, right? And so your job once I have made this claim, Bisection, is to figure out which half is wrong. What you're going to do in practice is you're going to try to replicate the first half. If that's wrong, you'll challenge it. If it's right, then the second half must be wrong, and you just challenge that. So we have, like, an instruction number, and at that point, we stop, check the hash, check the hash and does it match? That's what you do. That's what you did to figure out if I was right in the first place, right? And now when I bisect, essentially what I'm doing is I'm saying, what was the hash at the halfway point? I'm making a claim about that.
00:25:47.010 - 00:26:16.554, Speaker A: And you say either that you can't get from here to here in N over two steps, or you can't get from here to here in N over two steps. Right? If my initial claim was wrong, at least one of these two sides of mine has to be a lie. You just have to figure out which one it is. You put your challenge on that one, right? So now you've got your finger on something that you know is wrong. That's smaller, right? You don't know what a claim happened in here, but you know this is wrong. Right. So this happens on chain.
00:26:16.554 - 00:26:39.810, Speaker A: Right. I've made this assertion on chain. And you put the challenge on chain. And I wrote this midpoint hash on chain. And then you said, Well, I'm challenging the second half, and so on, and we continue to do this right. Now, I put down two deposits. No, I put down a deposit when I made my first claim, and then you put down a deposit when you made your challenge.
00:26:39.810 - 00:27:08.014, Speaker A: And now we're involved in this dispute, and we're playing for our deposits. The loser is going to lose their deposit. The winner gets half, the other half gets burned. Right? And so if your challenge is a valid challenge at each stage, you'll be able to identify one of the halves that's wrong. And so you're basically pinning me down step by step, assuming I'm lying. If I'm telling the truth, then I just keep telling the truth. And so get down to the end.
00:27:08.014 - 00:28:01.566, Speaker A: And if you were right in the beginning, then you're going to be right down here as well. I will not be able to show that you can get from here to here in one step of execution. If I was right in the beginning and I told the truth all the way down, then your challenge was bogus and continued to be bogus all the way down. So whoever was right at the top level is also right down at this level, assuming that the person who was right played the game well. And so then the on chain component just needs to resolve this dispute, right? And that is the point where I have to actually what my claim has here is a hash of the state. I have to open up a little bit of that hash. Can imagine the whole state is organized as a merkle tree and I have to open up a little bit of that merkle tree just enough that you can figure out what the merkel tree after one step of execution is.
00:28:01.566 - 00:29:06.910, Speaker A: Just enough you can figure out, oh, it was an add instruction and he was adding three and seven, therefore the result is ten. And the rest of the big merkel tree is just what it was before, so we don't need to open it, right? And so that's kind of the spirit of how that one step proof works. And that's checked by an on chain contract, costs about 90,000 gas to do that. And now it knows whether I was right or you were right. And whoever was wrong is going to lose their deposit, right? And so what that means is whoever is right will win. And so if I was right in asserting what I was doing, I will win the dispute. And so because this dispute gets to the truth of what a virtual machine would have done with some technical caveats that we could talk about off chain, in other words, which don't lead to incorrectness of the outcome, right? Maybe both people are idiots.
00:29:06.910 - 00:29:57.270, Speaker A: The point being, maybe both people are idiots and the protocol is designed. So if both people are idiots or lying, that it doesn't take a wrong step. So what we guarantee is that any one honest party can prevent a wrong action by challenging it. And then, although I didn't talk about it in the limited time I had here, we also guarantee antitrust progress, which means any one honest party can force progress even if everyone else is throwing up fake challenges at large expense to themselves. And that's how we get the antitrust basically, that whoever is right is able to win because they're right. That's the thing you have to do in order for one right person to be able to win over N minus one wrong people, you have to actually get to the truth of the claim.
00:29:58.010 - 00:30:05.938, Speaker C: So I guess progress in the evolution of the contract needs to be frozen during this dispute process because you don't.
00:30:05.954 - 00:30:45.254, Speaker A: Know what the correct state is, not quite. So one thing you can do is you can take those two parties and send them off to the side to resolve their dispute. So once the dispute starts, so if the original assertor wins and the assertion is accepted, the system can't necessarily believe that assertion was correct, right? Because maybe those two parties were actually colluding and trying to. Create a situation where the assertant won. And so if there's a dispute, you just take those two parties, you send them off on the side to resolve their dispute, and then the operation of the virtual machine can keep going.
00:30:45.372 - 00:30:51.606, Speaker C: So what's sort of the worst case delay in the resolution process?
00:30:51.628 - 00:31:13.306, Speaker A: So the worst case delay is assuming that there are N minus one people who are willing to lose deposits, willing to lose large deposits repeatedly, they can slow you down by basically a factor of N. That's right. But if you make the deposit, if.
00:31:13.328 - 00:31:14.506, Speaker C: You do this, push off to the.
00:31:14.528 - 00:31:52.834, Speaker A: Side, how long is the dispute, the dispute resolution? Let's see. So it partly depends on N, right? So it's log of N. We don't really bisect. We really do K way K section for a larger K. So under realistic circumstances, think about a dozen on chain transactions to do the speed resolution, so you can send them off on the side. To do that, they have put down large deposits. And those large deposits, the losers deposit, half of it will be burned.
00:31:52.834 - 00:32:03.020, Speaker A: A little bit of that actually goes to compensate the miners to pay for the gas to do all of the dispute resolution. So there's ample funds from the users deposit to basically make this.
