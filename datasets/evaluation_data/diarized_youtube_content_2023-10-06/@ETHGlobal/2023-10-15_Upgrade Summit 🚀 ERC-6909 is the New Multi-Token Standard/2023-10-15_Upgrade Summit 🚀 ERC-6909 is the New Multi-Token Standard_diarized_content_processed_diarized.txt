00:00:07.050 - 00:01:11.940, Speaker A: Today we're going to be talking about, ERC, six to nine, the minimal multitoken interface. So why, like, multitokens like, why does this thing even matter to begin with? Right, well, the big, you know, obvious one is you can manage multiple tokens and NFTs within a single contract, right? So, ERC, 20 basically de facto standard of what fungible tokens are, like single fungible tokens. It's pretty straightforward, right? It's a single token where you can track a balance allowance, total supply, decimals, et cetera, et cetera. Right? Well, 69 nine is similar, but it can actually track multiple in one, right? So you can have balances allowances, total supplies, anything like that, but you can have an arbitrary number of them, I guess, technically, two to the 256 minus one of them. And so just as, like a quick architectural comparison on this, right, ERC, 20 is our single token. It's always fungible, right? ERC, 721 comes along a bit later. This is the NFT standard.
00:01:11.940 - 00:02:27.126, Speaker A: It can be a single token or it can be multiple tokens managed in the same one. But they're always non fungible, right? So you can have token ID 123456, but there's only ever going to be one of each one of those, right? ERC, 1155 comes along and it can do basically everything, right? Single token, it can do multiple tokens. They can be fungible, they can be non fungible. And so, ERC, 69 nine is actually an iteration on what 1155 was, right? It's not backwards compatible, it's actually something new altogether. But from this chart, you can see functionally, they do the same thing. And so one of the really big use cases, and honestly, the one that's probably most exciting here, is DFI singleton architectures, right? So if we take a look at Uniswap V Three, which this is also applicable to V Two and V One, and plenty of other D Five protocols that have some sort of factory pattern, each one of these markets, each one of these AMMS are all their own contract, right? Each contract owns, in uniswap's case, a pair of tokens. Let's say you're doing arbitrage or maybe you're doing multi hop swaps, right? Things like this, you have to go between multiple markets.
00:02:27.126 - 00:03:27.166, Speaker A: That's a pretty common thing to have to do. But you have to do so through external calls, right? Like these contracts have to call out to one another and this gets really expensive. Even though all of the uniswap pools individually have Flash loan functionality, there's kind of a limit, right, to what can be done with this. The amount of tokens you can flash loan are limited to the amount of tokens in the individual pool, right? So there's a bit of liquidity fragmentation there as well. But over here in Uniswap V Four, this is still work in progress. You'll notice if you've looked into it architecturally, it's pretty similar to uniswap V Three, but everything's contained into one singleton contract, right? Like every market is managed under the same contract and they're using ERC, 1155 at the moment to handle this multi token system. And recently I actually opened a pull request for this to try out, ERC, 69, nine, just to take a comparison here.
00:03:27.166 - 00:04:17.790, Speaker A: And they are functionally the same. You don't lose any functionality by using either one, but there's some pretty big code size and gas efficiency savings, which we'll take a quick look at some of that here in a little bit. But the big thing to note here is that more and more DFI architectures are going to be trending towards this singleton pattern, both for liquidity reasons and for gas efficiency reasons in the future. So why not 1155, right? I've mentioned a couple of times that they're basically functionally identical, but why will we switch this out? Right? So the biggest one is simplicity. So if you want to make a simple transfer, if you're Alice and you want to transfer a token to Bob, you have this pretty complex flowchart. Obviously you want to check, make sure they have balance because of the way that 1155 does its transfer system. You also have to check if the sender is the caller.
00:04:17.790 - 00:05:41.530, Speaker A: If they're not the caller, we have to check if they're an operator, is the receiver a contract? If so, do they implement that? Do they revert? What do they do? I mean, it's a mess, right? ERC, 69, nine. On the other hand, pretty straightforward, right? Does the sender have balance? If so, send the tokens, right? Otherwise we throw some kind of error. So it's a pretty straightforward, simple system here. Now, the other big thing is code size, right? The reason that this even came up with uniswap is that uniswap is getting pretty close to the code size limit for their singleton contract. And so as just a quick side by side comparison, these guys come from the soulmate repo and these are just a mock, like 1155 and 69 contracts here. And you can see that the code size difference is pretty drastic for something that's more or less functionally identical. So what do we do about this? What do we do with this information? The simplest one is we can go ahead and start replacing these things, right? In terms of what actually is really divergent here, there are, I think, two or three different things that 1155 does that we're kind of found to be unnecessarily useless, just they don't get used in production by many protocols, right? The big one is batching.
00:05:41.530 - 00:06:36.940, Speaker A: So creating a batching system in the specification itself requires that everybody implement the same batching scheme. And for gas efficiency reasons, code size efficiency reasons, there are different variations you might want to take on something like this, right? Like different ways to different ways to do the batching systems. And I don't think personally that this is something that EIPS should constrain. This should be something that protocols individually can choose or protocol teams can choose to constrain themselves. So that was kind of the motivation behind removing that bit. The other one is callbacks, right? So like I mentioned earlier, in the flowchart there's like this back and forth of making sure are they a contract, are they not? Are they returning the right things? There's a lot of that there that isn't necessarily useful for many use cases. Right? And in general, when protocols want to create these kinds of systems, they tend to just build their own callback systems in.
00:06:36.940 - 00:07:15.714, Speaker A: The specified callback system is still there, but it doesn't get used. There's like a different callback system that gets used instead. Right? So the idea is just remove that from the standard and let protocol teams kind of decide on how they want to do their callback systems. So, as I mentioned earlier, Soulmate has an implementation of this vectorize, also created one in lady super super optimized implementation of it. And then I have a reference implementation. This is what's linked in the EIP, just a pretty bare bones it's not really optimizing for gas efficiency or code size. In this last one, the reference implementation, it's mostly just for readability's sake.
00:07:15.714 - 00:07:36.218, Speaker A: So it's very clear what the standard is actually doing. So TLDR on everything kind of summarizing stuff here. ERC 16 nine. It's gas and code size efficient. It's removing a lot of unnecessary things and reducing code size. Because of that, it's a drop in replacement for ERC 1155. You can manage multiple tokens in one contract.
00:07:36.218 - 00:07:59.540, Speaker A: These can be fungible, non fungible, they can be a mix of both. They can be semifungible, et cetera, et cetera. And this can be used for authentication schemes, right? You can do a token based Auth system. You can create NFT collections with this. There's a metadata extension in the EIP as well. And it can also be used for a singleton architectures for a pretty wide range of problems and.
