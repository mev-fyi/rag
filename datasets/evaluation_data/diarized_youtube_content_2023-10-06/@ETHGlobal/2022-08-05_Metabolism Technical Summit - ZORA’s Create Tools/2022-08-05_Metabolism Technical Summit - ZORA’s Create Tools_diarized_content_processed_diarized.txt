00:00:06.250 - 00:00:06.366, Speaker A: Yeah.
00:00:06.388 - 00:00:35.206, Speaker B: Up next, we've got another awesome talk by another member of the Zora team. We've got Ian here with us to chat about create tools. As Max mentioned, they're going to kind of go a little bit deeper into what can be done with all the tools that Zora has. So without further ado, I'll invite Ian to come up onto the stage here, here and share his video, share his audio, do all those good things. And I will also stop sharing my screen so that you can take over as well. So Ian, whenever you're ready.
00:00:35.228 - 00:01:22.600, Speaker A: Yeah, thanks for the introduction, Jacob. Yeah. So what I'm going to talk about today is adding on new user interfaces for creating custom addition content types and how the Zora Drops tooling works for both the additions and the drops. So the idea here is creating a Zora Drop contract with our creator factories and all the on chain infrastructure, and all you need to build is another front end so there's no solidity involved. And this really just uses what solidity we've already deployed on chain and kind of how some of it works behind the scenes. Just going to make sure I have the chat open for you guys and start sharing my screen. Give me 1 second.
00:01:22.600 - 00:02:34.458, Speaker A: So we'll start off with some of the official Zora documentation because it's a pretty great way to understand how our smart contracts work. So if you go to Smart Contracts and then create an NFT collection, this does a pretty good overview of all the different NFT contracts that are a part of our drops tooling. The way the contracts are structured is there's a Zora NFT creator and it's a factory that creates the ERC 721 Drop and it's a template NFT contract that creates a new addition. The idea with the ERC 721 Drop is that the metadata that is generated from the drop contract is generic. So an example of that is in, for instance, a addition. You want to have the metadata pretty much the same except for just the addition ID that changes. However, with a Drop, you want to go into a folder either on a server or on an IPFS or areweave instance and grab the specific token ID because each different token is a completely unique artwork.
00:02:34.458 - 00:03:10.710, Speaker A: And those are the two main distinctions. We actually have a repository open sourcing soon that provides more interesting renderer approaches. One of them allows for products and redemptions, one of them allows for creating groups of additions. So if you have 100 that want to be one another, hundred that want to be another, so there are a lot of fun things you can do with that. But it's solidity. And I wanted to keep this talk really into how the JavaScript interface works. So if we go to the Zora NFT creator here, you can see these are the arguments for creating a contract.
00:03:10.710 - 00:04:09.654, Speaker A: And here there's a function to create an addition and a function to create a drop. Now this function does the creation in one go, so a lot of things get done at once and we can break down a little bit more specifically how this works and what the JavaScript interface is in this Create addition function. So an interface you guys might be more familiar with, that I'm going to jump to is the Ether scan interface just to show how this is not really proprietary Zora but it's just general web3. We can have the create drop here that takes the name, symbol, admin, addition size, royalty, Bps, all these different arguments. We'll talk about it in a little bit. And then one for addition and then there's another one that's for generic stuff. So this is if you're doing solidity extensions, you can utilize that going here.
00:04:09.654 - 00:05:01.158, Speaker A: So the first argument is the name. It's the ERC seven and 121 NFT standard we all know and love and it's actually for additions the name of the NFT. So if we go to test to create Zora co we pick this Zorogenesis hackathon NFT and then we go to Etherscan for that address. You can see that the title here matches the title here and the metadata for the NFT is informed by the contract title. Now, one thing to think that's a little problematic with this is that typically indexers don't support changing the name and the symbol of an NFT contract. Meaning that a lot of this stuff you can edit after the fact, but neiman symbol are two that you just can't really edit, unfortunately. Next is the addition size.
00:05:01.158 - 00:05:39.250, Speaker A: Addition size is interesting. It is the maximum number that can be minted. And this is a level of creating scarcity. It's a useful way to sell NFTs. If I told somebody that they could buy 100 and then I actually could have sold 1000, those hundred would be worth less in some ways because there are more people willing to sell the same item. If you set the addition size to one, you're creating a one of one NFT. And this is actually a nice way to use these contracts if you want to just mint a bunch of specific NFTs on a front end that are yours and they're not being sold in large amounts.
00:05:39.250 - 00:06:22.180, Speaker A: The other thing is we have a concept of open additions with this tooling. And open additions is an addition that can be minted to any size, but it has the ability to be closed. So after the addition is closed, so you open addition here. The addition size is marked as the number that were minted in the sales period. So this would be 18,546 and then there could be no more minted after that point. So it takes the full set possible number of mints from the Ethereum blockchain and then shrinks it down to the number that are minted. And there's a contract function to do that.
00:06:22.180 - 00:06:50.008, Speaker A: The next is royalty bps. This is the on chain royalties and bits per share. And Bps essentially is a hundredth of a percent. So if you want 1%, you put in 100. If you want 10%, you put in 1000. If you want 10.1%, you put in 1001.
00:06:50.008 - 00:07:22.630, Speaker A: The reason this is not just a percentage is that solidity doesn't support a decimal point and it's a pretty respected financial way of setting the percentage. So you can see here I'm doing a 10% royalty. That's 1000 bps. A thing to do too is if you're unsure how this works, you can just do Bps from percent into Google and you get a nice little calculator here and a chart. And this calculator is quite nice. So I can type in 10%. It will give me the basis points.
00:07:22.630 - 00:08:00.300, Speaker A: Continuing onward, you have a default admin. So the admin address is the address that manages the entire contract. Can do anything that the contract has ability to do. Funds recipient is the address that gets the funds. Now, the reason these are split between two different addresses is if you wanted the funds recipient to be a split. Another way is if you wanted to fund Juicebox or you wanted to fund a Dow from your NFT sales, or you wanted to put the funds in a multi SIG, but your personal wallet would manage the drop, so it allows for some flexibility. The next is sales config.
00:08:00.300 - 00:08:30.564, Speaker A: Sales config is complex. We'll talk about that in a little bit. This determines when the NFT is for sale, who is it allowed to be sold to, how much it costs and all those sorts of things. It's the arguments for the Lazy Minting description. It's a string that you can see in here. It's just a string. Now, one thing to note about descriptions for additions is that they're stored on chain.
00:08:30.564 - 00:09:25.926, Speaker A: And we can actually see that by going to this contract here. And then this is a factory. Each NFT is its own independent, wholly owned contract. And then I get to the metrenderer and then I can ask for the information associated with that token and then boom, we have this whole description stored on chain. Now it's stored on chain, which means that the cost goes up with the more content that you put in the description. The reason we didn't use off chain media for the description on additions is that it would require a server. And Zora is really trying to be decentralized and wholly owned by the individuals that are creating the media.
00:09:25.926 - 00:09:56.580, Speaker A: And a great way of doing that is to put as much data as possible in the contract that the NFT ownership is held by. And most people don't really mind the increased cost because this one description is used for tons of different NFTs. So it's pretty efficient in the end. For instance, this NFT was minted 165,000 times. So copying this description once for this many NFTs totally makes sense. If you're minting 1000 individual unique NFTs with 1000 different descriptions. That doesn't make any sense.
00:09:56.580 - 00:10:28.186, Speaker A: And then we have the animation Uri and the image Uri. These are a part of the ERC 721 or the image Uri is a part of the ERC 721 spec. It defines the image shown for the NFT. In this case just this image. And you can go down here in the Zora interface and you can see that image URL. This loads the full size image. Animation is an extension that's pretty well accepted, made by Openc and it's used for any non image content.
00:10:28.186 - 00:11:04.982, Speaker A: Animation being web page, audio, video, even 3D objects are supported in animation Uri. And this is kind of what we're going to be getting into with our little demo after this. The demonstration project will create a web page using this animation Uri field. If we go down here's, how you might call this in JavaScript, we'll talk about the sales config in a minute. But my essay, so this is going to be my name symbol essay ten. It's an addition of ten. So after Ten Mints there can be no more made.
00:11:04.982 - 00:11:34.830, Speaker A: It shuts down sales, even me as an admin, I can't increase that number ten. The only time you can change the addition size is when you do an Open addition and then you close it. So there's no way to increase the addition size, there's only a way to decrease it really. In a very specific case here, we next have the royalty Bps default admin funds recipient for small projects. It's worth just setting to the address of the Minter. So it's set to the address of the Minter here. Sales config.
00:11:34.830 - 00:12:20.800, Speaker A: You can pass in a default sales config and that'll just disable sales. And then you can go ahead and use the Zora, create tools to set your sale settings, or you can go and set a sale to start right when somebody Mints. It's really up to your use case. Here we have the IPFS URLs. Now if you're familiar with typical HTP, what is IPFS? It's just a way to specify that the asset lives in the IPFS system rather than on the web, http HTPs. You can totally replace these URLs with http and https but it's not recommended because it's not a decentralized thing. If your server goes away, the NFT image becomes broken, but it's really up to you.
00:12:20.800 - 00:13:03.200, Speaker A: Okay, now we're going to talk a little bit about the sales configuration. The sales configuration is one thing to notice is this is a solidity extension that takes in a different size compared to a full number. A full number in solidity is typically defined as 256 bits. This clamps down those numbers quite a bit into 100 and 432 64 bits in order to save space. And this saves deployment costs, which saves you ether. First is the public sales price. It's in the number of ether and you are going to specify that to ten to the 18th.
00:13:03.200 - 00:13:43.804, Speaker A: Easy way to get that is Ethconverter.com. So if I pass in one E, it'll be one to the ten to the 18th way, and this is a way field. So you would put the way into your public sales price. Max Sale purchase per Address this is how many you can purchase per each address. And if you set it to zero, that means you get unlimited mints per address. But let's say you only wanted one address to mint four or five, so they couldn't buy up all of the NFTs in one go, or even just one. You could set that to that number.
00:13:43.804 - 00:14:38.696, Speaker A: Now, the thing to be cautioned about, or to be cautionary about with this per address field, is that somebody could always just spin up more addresses, but it's a little bit annoying, and it does slow people down, so it can hopefully encourage people to have more unique buyers. But it's very easy to get around if somebody wants to. The public sales start is in UN 64 and it's stored as a block timestamp. So that is a Unix time. It's the number of seconds since 1970. If you want to get the current Unix time, you can just type Unix time in DuckDuck go and it'll tell you the current time. I can do 2022 T actually for drops.
00:14:38.696 - 00:15:19.804, Speaker A: What I typically use for Unix time is Wolfram Alpha. So if I go to Wolfram alpha and I say Unix time yesterday 12:00 p.m. CET central European time, it will say convert yesterday at twelve EDT. Okay, this is not working. Unix time 12:00 p.m$. August 2 cet So convert 12:00 p.m. C est.
00:15:19.804 - 00:15:49.684, Speaker A: August 2 to Unix time. Boom. We get the timestamp right there and then we can just take that and put that into the contract. It's a nice trick, especially when you're dealing with drops across many different time zones, to just quickly get that number for your sales start and sales end. If you're building a UI, you probably will use some sort of calendar, so it's not a big deal. If you don't want to start with a public sale or a private sale, that's a pre sale. You can just set the value of all of these timestamps to zero.
00:15:49.684 - 00:16:26.092, Speaker A: If a sale starts at the beginning of time and ends at the beginning of time, it never happened. Pre sale Start so pre sale is determined by this merkel route. The merkel route is a predefined way of determining all of these different users if they exist within the set. And if a mint matches the merkel route, then it can be minted under pre sale. And the merkel route includes the variables for sale price and max purchase per address and address. So there's no settings for that in the contract. It's taken directly from the merkel route.
00:16:26.092 - 00:17:00.430, Speaker A: If you're not using a merkel route, it's safe to set a merkel route of zeros and the reason you choose zeros as opposed to anything else is that zeros are cheaper to store on the blockchain. So when you're making an empty merkel route, just set it to be a bunch of zeros. Don't choose something like EEEE or like it's. It's all the same thing as zero. The chances that there's a valid merkel route resolving to that is basically zero. So you wouldn't have that concern. But the concern you would have is just saving storage space.
00:17:00.430 - 00:18:07.960, Speaker A: And this is how you would import a type and TypeScript from the Zoralabs NFT Drops contracts package. So you don't have to manually check every field. You can have TypeScript check it for you as well. And we'll get to what that looks like in the example. The docs links are here, and then I can share the slides in the chat. Okay, let's go through some code. So I made a little demo project for this that allows you to mint markdown essays with the Zora Edition tool.
00:18:07.960 - 00:20:03.440, Speaker A: And we can actually take a little look at the current version at this link here. It's hackathon quality code, so don't judge me too much. Jacob. Are people able to see the chat? And I believe there's one environment variable this Minter needs to set up. So I'm going to go and set that really quickly and show you how it works. Okay, I don't really have great ideas for this essay, but I can give you a quick demo on my local host. So let's do that.
00:20:03.440 - 00:22:07.040, Speaker A: And then I'm actually going to take some of my presentation code and put it in the markdown editor markdown. You can do this to create a code block, and then we can add a header, and then we can add another section for sales configuration. And I've already connected my wallet to the website, so you can see I'm on the Rinkib test network and I'm connected to this website. And we can add in the sales configuration slide. And then I'm also going to add in a GitHub repo and let's make the link pretty. So here I can just take this GitHub repo, and I want to make it a link. And if we look at the preview this is wrong.
00:22:07.040 - 00:23:05.050, Speaker A: Get every code. I think it goes the other way. Got a love markdown? Yes. And then we just delete this line here and then I can go ahead and publish. So here it's posting to my local server to the publish route. And then the publish route is returning a response here with the Sacid and the image CID. And if we take a look and see what these are, this should be an HTML web page of the essay I just wrote.
00:23:05.050 - 00:23:42.250, Speaker A: So looks good to me. Create an addition. There's some code, and you can take a look here. And this is a rendered HTML from that markdown editor, and it says Publishing. So if I go over here, there's a contract interaction, and I can go ahead and take a look at the hex data for it. And if I turn this into we can just see if this works. I've never gotten the metamass data parser to work.
00:23:42.250 - 00:24:40.118, Speaker A: All right, it doesn't work. We will confirm the transaction it went through. And then the easiest way to determine where the new Drop address is is to look at the events on Etherscan. And you're going to do the same thing in JavaScript. We can actually add that in if there's a little bit of time, because right now it does nothing. It should redirect to a page where you can view your essay when you're done making your essay and create Drop, the second address would be the addition contract address. This is our new contract we just made.
00:24:40.118 - 00:25:40.498, Speaker A: And if we look at the contract, we can do read. I think I need to set it as a proxy. And we can take a look at our name of the token and the description. That would be in name metabolism. And then there's no description, but we can then go over to our metadata tool to pull out the description. The metadata contract is generic across each of these additions, which means that you pass in as an argument your contract address, and it'll give you your information. So we have our description.
00:25:40.498 - 00:26:02.910, Speaker A: Creating a Drop presentation looks great. We have an image Uri. So if we go to Zora IPFS and we look at that image boom, it's exactly what we just saw. And then our animation. See if this works. Yep. Okay, so what does this look like on OpenSea? Well, we can take a look after we mint something.
00:26:02.910 - 00:27:03.970, Speaker A: So since I'm currently the admin of the Drop, I am going to mint myself. Two, we can pull this addition up on our testnet, view the right address. This did come through. Maybe it takes a few minutes, maybe. Let's see. And then the mints went through. Perfect.
00:27:03.970 - 00:27:31.596, Speaker A: Then right here we have our essay metabolism. The image is used as the preview. That's why we have to create an SVG. You could also upgrade this to allow somebody to upload a preview image. And then I open up the essay and boom, I have the essay here. Something to note is in the sandbox. View GitHub will not allow blah, blah, blah.
00:27:31.596 - 00:28:02.050, Speaker A: So I need to go and open the site in a new window. But yeah, you can render markdown, you can add some styling. You could even add themes in the editor. So if you were to go to this here, you could choose a theme, and then it would update this preview over here. And then that same theme would apply to this site right here. And you can actually fork this and do whatever you wish with it. And there's a nice little GUI editor here for those that like that.
00:28:02.050 - 00:28:33.620, Speaker A: Something to note is if you link in an image. It should work, but it would be best to link in an image from something like IPFS. And you might have to go and work with your favorite markdown editor to add that option in. Now that I've created this addition, though, and I can see on OpenSea, which is awesome, and I can actually probably see it soon on the Create tool. I think it's just cached. Let's see. Nope.
00:28:33.620 - 00:29:39.554, Speaker A: How would we view this information locally and actually let's back up a bit and go through. How does this upload flow work and how is this app working behind the scenes? The main page here is the Create page. And the sale starts off at zero and ends in one week. And the reason is seven. Let's start 60. So it's seconds, seconds minute, then 60 minutes in an hour and then 24 hours in a day, and then 7 hours in seven days in a week. So this sets the sale to last a week.
00:29:39.554 - 00:30:17.730, Speaker A: Disables presale sets 100 purchases per address and a 0.1 E sales price. Can go ahead and see that works by going to our Drop and calling purchase. Where is it? Purchase 0.1. I want one of them. No, that'll fail. One that's successful.
00:30:17.730 - 00:31:12.950, Speaker A: And then this is all pretty standard react. So this here is used to disable the button when publishing. Here is content for essay, title and description. And then this is stuff with Wagme, which is a Hooks library for interacting with Ethereum. And then this allows us to connect the Zora contracts with Wagme. Here we have a fairly simple form. It takes in a title, description and essay.
00:31:12.950 - 00:31:50.242, Speaker A: I'm using a third party markdown editor. It acts in react just as a standard text input and then a button for publishing. I decided to use the ggen toolkit, but you can use any type of front end or your own component library to build out the components. When you push the upload button, the first thing that happens is it sets the publishing to True and then it gets the Sahtml from the editor preview. It's a bit hacky, but it works. I didn't really want to rerender myself. And then it calls API.
00:31:50.242 - 00:32:15.460, Speaker A: Publish. Now, a lot of times you might think, why doesn't it just call Pinata right here? Well, two reasons. One is mainly for security. I don't want to expose my Pinata Uri. And then two, it's just a little bit easier to get those API calls done on the server. You can batch it into one request and add in better error handling on the client. And you can also render things on the server side.
00:32:15.460 - 00:32:46.810, Speaker A: The response then comes back as JSON. We grab the IPFS hash from both the image and the essay. This is just for debugging. And then it calls contract createdition. The Abi is pulled in from the node package of the Zora contracts. All the Zora contracts have node packages with typechain and Abis published and you can take a look and see what that syntax is in the Node Modules package. It's a pretty easy way.
00:32:46.810 - 00:33:42.120, Speaker A: You're not going to find it directly in the repo since it's compiled automatically down. But you have deployments folder and you can choose the specific version of the deployment you want to use in your application disk folder, which includes the artifacts. Now these are the JSON files with the Abis in them and also Typechain. And these are TypeScript definitions and JavaScript files interact directly. There was a conflict between the markdown editor and our Typechain builds, so I was not able to use Typechain with this project and I just instead used the direct abi files. Can take a little bit of a look into how the API works. I've found Pinata publishing from a string to be quite annoying, but this seems to be working pretty well.
00:33:42.120 - 00:34:07.914, Speaker A: This is a very simple HTML web page. Given the essay content and the title it just spits out a web page. Could probably improve on this quite a bit. Then I'm doing a request to Pinata directly. I'm not using any of Pinata's tooling, I'm just doing a standard Http request. So I set the CID version. I added the Type essay from Pinata metadata.
00:34:07.914 - 00:34:43.914, Speaker A: Not necessary, but nice. When you're in the Dashboard, it'll show all the essay types in one section. And then I'm just using the Isomorphic fetch library, which I believe is included as a part of the next. JS framework, to then send the response to Pinata with the form data. Now, the reason you would use form data is to allow for adding on a file. JSON can't really encapsulate files very well. So solution here is to just append a file onto the request and then it splits it up into multiple chunks for you and you don't have to do anything for that.
00:34:43.914 - 00:35:27.706, Speaker A: It's all automatic passing in the authorization header. So this is coming in from NextJS as the Pinata key, and then it calls the HTP response and then returns. JSON probably needs to have better error handling, but this is the rupaulload to Pinata function, short and sweet. Then this is the handler. This is the next JS function that gets executed when this API route is called. First it checks if the request is a post, it's going to ignore Get request and then it parses the JSON body to grab the title, description and essay fields. And you can see that we pass those in right here.
00:35:27.706 - 00:36:07.762, Speaker A: JSON stringify imagecid. So this just uploads to pinata a function make SVG card with the title and description, the content type shtml make HTML page same as making SVG card. It's just here the Make SVG card is used both the same on the server and the client. So it's in another file. And I exported an SVG from Illustrator and threw in the text. That's why the scaling is a bit weird. It's probably better to manually write your SVG.
00:36:07.762 - 00:36:40.266, Speaker A: But time, the next step is to upload the pinata, the essay. And then I just returned the image and the SA CID. And the CID is the content ID field. It describes the file on IPFS. So when your URL looks like slash, this is where the CID is put. If you're addressing a folder, you just add the folder after that and a bunch of files can fit in a CID. But these are just simple CIDs that include only one file directly.
00:36:40.266 - 00:37:03.698, Speaker A: There's no folders involved here. This is a bit of a hack to create our symbol field. You can take a look at that here. So the symbol of the NFT fresh here. Now it knows. So three tabolism. I don't know why Meta got removed.
00:37:03.698 - 00:37:33.760, Speaker A: Oh, substring one through ten, it should be substring zero through ten, maybe eight. So it just takes the first eight uppercase letters that are A through Z, zero through nine, and makes that the symbol. And you can see our purchase went through here. And let's see if it shows up on the Zoro creator testnet. Should at this point. Yes, it's doing something. There we go.
00:37:33.760 - 00:38:06.006, Speaker A: Metabolism 22. Hackathon, creating a drop presentation. And right here is the Mint button. And then here's the treasury. So I can run a withdraw here. Now I want a better preview page than this. So now that we've covered how the upload works and how the CID is then added to how the CID is added, we can then now look at how we retrieve this published contract.
00:38:06.006 - 00:38:43.334, Speaker A: So if I go to additions ID, I wrote a web page that does a call using use contract reads and has an index page. So if we go to addition, the addition I want, let's see what happens. Loading, loading right there. Metabolism 22, creating a drop presentation. And then we got our IPFS, another IPFS. So let's do this data. It would be data zero one and 2012.
00:38:43.334 - 00:39:41.552, Speaker A: So data under Info or nothing. And then our data field. And we know data's got to exist. So now we can do title image essay equals data. And then we can return header heading, title one. Make it real big. We can embed the web page.
00:39:41.552 - 00:41:36.370, Speaker A: Since this is a full web page, I'll just pass in iframe source, replace this with an Http gateway. This is all react D stuff. Maybe we swap the image and the essay. There we go. Create an NFT edition. And then it looks like there was an issue loading the essay. Not sure what's happening there, but I think that's time.
00:41:36.370 - 00:42:20.144, Speaker A: So to play with this repo and to continue on, you can take a look at how all this works in the code in my GitHub. Just mark this down and I will publish the latest changes to GitHub. Ian Nash zorasa Editionmintor. Thank you so much. And I hope somebody makes some cool weird P. Five JS HTML interactive SVG generated. I don't know.
00:42:20.144 - 00:42:24.144, Speaker A: There's some really cool things you can do with this. So have a good rest of your day.
00:42:24.262 - 00:42:41.272, Speaker B: Amazing. Thank you so much. That was sick. I think just being able to go through all of that in one fell swoop and wow, that's awesome. Yeah, I think that's going to be an amazing resource for people as they build over the next weekend. Thank you so much for taking the time to roll over that with us.
00:42:41.326 - 00:42:41.990, Speaker A: Really appreciate it.
