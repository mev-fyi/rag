00:00:02.810 - 00:00:31.666, Speaker A: Let's give it another 30 seconds here. Awesome. Looks like we're rolling here. Okay, cool. Well, thanks everybody, for attending here on Zoom here on YouTube. The building on Balancer v two session being headed by Jeff Bennett over at Balancer. Really thankful to have Balancer as one of our key presenter sponsors for the events and as many events over the years with Balancers.
00:00:31.666 - 00:00:39.160, Speaker A: So excited to see about the V Two. Have to learn a little bit more about how to build on top of it. And I'll get out of the way so that, Jeff, you can just take it away.
00:00:39.530 - 00:01:16.994, Speaker B: Okay, thanks. Happy to be here. So I know people at Hackathons are at all different levels. You have aspiring student developers and experienced devs who might be new to blockchain blockchain engineers who might be unfamiliar with Balancer. So I'll start with kind of an overview of what Bouncer is, the architecture, high level interfaces, and then show you where to get started building. So, okay. We launched V Two a while ago now, and it's it's mature now.
00:01:16.994 - 00:02:00.370, Speaker B: It's past its emergency period, where it's now immutable there's hovering around up to $2 billion on it in TBL. So I'm really pleased at how smoothly it's all gone. Of course, we launched V One year before, and this is the natural continuation. V One was more of a product. Things were more fixed. Balancer V Two is a platform, so it's an AMM platform. So you can actually build not only new pools, but new types of pools.
00:02:00.370 - 00:02:59.922, Speaker B: So the design goals here were, as I said, like flexibility, extensibility, and gas efficiency, because these were the issues we had with V One. It was a little expensive to use and it was a little hard to extend or integrate with. And especially our interface that was redesigned with a UX team from the ground up. And the V Two version is much better from a user perspective, simpler and a lot cheaper to use. And we've gotten a lot of traction with Integrators and other users. So as a platform, what does this do for you? So how does it make it easy to build on it? The central concept is the vault, and that is where all the tokens are stored. And it handles not only the token storage, but all the accounting and the main security features.
00:02:59.922 - 00:04:00.098, Speaker B: And it has all the infrastructure for pool contracts, but it doesn't constrain you. There's just a very simple interface that you have to implement, and then you can write basically arbitrary code, arbitrary AML logic, arbitrary tokenization. We also have other features like asset managers, where you can pull tokens out of the vault, where the vault behaves as if they're still in there, and arbitrary flash loan. And I've updated this slide from the last time that we've made a lot of progress. So we're fully deployed and fully supported on not only COVID and main net, but also Polygon. And recently arbitrary. So all the main EVM compatible L two S and we are continuously developing and so far we have these kinds of pools.
00:04:00.098 - 00:04:59.786, Speaker B: So on V One, we pretty much had one kind of pool, the weighted pool. And the V Two weighted pool is quite similar. It's two to eight tokens, fixed weights, dynamic swap fees. We also have a two token pool which is an Oracle and has dynamic actually all the pools have dynamic swap fees and we even have the ability to use what's called a delegate owner. And if you have pools, can have owners and if you assign it to the delegate owner, then governance can do some permission operations such as set the swap fees. We also have a stable pool which was two to five tokens, has an Oracle in it, and it's for hard pegged tokens. So it has one to one tokens that are supposed to be one to one.
00:04:59.786 - 00:05:32.040, Speaker B: And then metastables are special ones that have two token and they can be for soft pegged tokens. So with every provider and then we have recently so V One, a big success story of V One was liquidity boost wrapping pools. We have those now on V two. In fact, there's one running at the moment. The UI is being provided by partners at the moment. We have Copper and Prime Dow and Copper is up at the moment. And there is an Aclima token LVP going on at the moment.
00:05:32.040 - 00:06:10.450, Speaker B: Those have dynamic weights and swap fees. So they're basically similar, except only the owner is the only LP permitted. And then coming soon, we have other things under development, mainly pools that are designed for investments. So they have things like management fee along with dynamic fees and swap fees. And we have other kinds of pools that do capital efficiency similar to asset managers in a more flexible manner. And I'm going to start going through this a little faster than given the time here. This is one of the original graphics we use.
00:06:10.450 - 00:06:27.906, Speaker B: It's still valid. So it just shows you that the vault has all the token balances. You can do a swap, you can join and exit and do flash loans. So everything goes through the vault. And this is a major efficiency of V two. Over. V One? In V One, the pools are all separated.
00:06:27.906 - 00:07:02.210, Speaker B: You had to go through them and you had to have proxies. And if you want to join or exit a pool, it would take three or four token transfers. And now it doesn't. Everything goes right from your wallet right to the vault. So, yeah, this is that example. And you have things like we have internal balances, so you can actually avoid token transfers altogether with a wallet basically inside the vault. You can have your own personal wallet inside the vault and that allows you to do swaps and joins and exits and things all inside the vault with no token transfers.
00:07:02.210 - 00:07:43.706, Speaker B: All right. And then so the interface for transitioning a little bit to how to build on this, part of what makes this simple is pretty much everything goes through the vault. So swaps, really you can do swaps and joins and exits. Those are the fundamental operations. So we have liquidity pools and you can do a single swap with one pool. And there's two kinds. So either you know how much A you want and you're asking how much token B can you get for it, or you know how much you want and you're asking how much does this cost? Those are the two fundamental kinds of swaps.
00:07:43.706 - 00:08:12.250, Speaker B: And you can do either a single swap with one pool or you can chain these together in batches. And then we also have query swaps. So what that is, is it's kind of a simulator and this is very powerful for UIs and aggregators. It does the exact same code as a real swap. So you know it's doing the same processing. It can't get out of sync, it just reverts at the end with encoded data. So that's a powerful feature that I think is underused.
00:08:12.250 - 00:08:50.758, Speaker B: And all swaps are two token. One balance goes up, one balance goes down. And we've also added things like native ETH swaps and joins. So previously you had to wrap ETH separately and then join a pool that had wet in it. Now you can do that all in one interface and then joining and exiting is what is the way you add and remove liquidity. And another innovation here is you can do any combination of pool tokens. So in V one you either had one token or all tokens proportionally and a lot of AMMS work like that.
00:08:50.758 - 00:09:32.334, Speaker B: For instance, uniswap is other alter tokens and you have to have exact proportions, the exact amounts. So on balancer, if you have a five token pool, you can join with two of them and exit with three of them. So that's maximum flexibility. And these are the kind of things we have in development, there's a lot of them. So not only the investment pools I talked about earlier and the capital efficient pools. We have other third parties that are building, that have already built custom pool types on balancer. So that one being the yield curve pool of convergent.
00:09:32.334 - 00:10:21.140, Speaker B: We also have the element finance pools and if you go on our balancer phi main page, the app you'll see at the bottom, you can actually link to the element finance pools. And that's a general model. If you're a protocol and you make a special pool type, that's how it will generally work. You'll be included in the main list of pools. But when people click on the pool, it'll go to a custom interface which can have the branding and explanation of everything and a custom interface for that vendor. So that's an easy way or how building on this might look like. All right, and then this is part of the architecture discussion here.
00:10:21.140 - 00:11:06.478, Speaker B: This is how the current pool types and how they're organized. So we've tried to make it as modular as possible and so that you could we factor out different functionalities in different areas of the tree. Here, for instance, the pool participation is the token contract that's handled by the balance pool token. At the very top, the base pool has the token storage and scaling interface, but not the actual implementation. And then the weights are implemented at the base weighted pool level. So everything that has weights is part of that. And stable pools don't have weights, they have an amp factor.
00:11:06.478 - 00:11:35.110, Speaker B: So that way at the bottom you can sort of pick and choose what you want to implement. So a regular weighted pool has immutable weights and tokens. It's just like NV One liquidity bootstrapping pool has mutable weights but immutable tokens. And then over here, this weighted pool, two tokens. That's an example of how you can sort of pick and choose things. In this case, we had a two token. It's a weighted pool, but it has an oracle because normal weighted pools don't have oracles.
00:11:35.110 - 00:12:15.030, Speaker B: So we needed the price oracle, the weighted math, the Oracle weighted math. And then we also needed the pull on the governance and the token contract and the swapping logic. So that's how we constructed that. So you may find if you want to do something nontrivial, make a new pool type that's nontrivial. You may have to copy some code because it won't be completely transparent, especially if you want to change something high up like the pool participation. All right, so concretely, we have the mono repo. That's where all the code is we've transitioned to.
00:12:15.030 - 00:13:04.386, Speaker B: We went back and forth with a few different ways of organizing the code. We were trying to have a core and some sub repos. We ended up doing a monitorepo that's just a lot simpler to manage and things don't get out of sync that way. But that is very complex. We're using workspaces, there's a lot of them and it's under active development, so it's not really what you want to start with. We have published NPM packages and you can use those, especially integrators and aggregators, people that aren't doing the new smart contract development, you can use those directly. And we have a stable branch in addition to the regular master branch.
00:13:04.386 - 00:14:03.958, Speaker B: We now have a stable branch and that corresponds to those published NPMS. So if you want to look at the source code, when you import something, you look at that stable branch and not master for people to build on. Rather than copy the mono repo, we have a much simpler balancer example repo. So this links to the NPMS as dependencies and it will run out of the box. We just literally just did this this week. So it's a work in progress, but it does show how to and I'll go through it in more detail, but it does show how to deploy the vault authorize or deploy a pool and run some simple operations. So you can do a swap, you do a join, do an exit and it check balances and it has some simple helpers and TypeScript models.
00:14:03.958 - 00:14:47.000, Speaker B: So it's in TypeScript. So the idea is it's also a template repo. So it's designed to be forked in an especially friendly way. So this is what you would do. You would fork instead of forking the mono repo, you might fork this balancer example repo and work off of that. And as I explained, if you want to do a completely new nontrivial pool type, it probably won't be enough to just import the NPMS. You will likely have to do something, you'll likely have to copy some code over from the monorepo and we're going to make that easier over time.
00:14:47.000 - 00:15:39.906, Speaker B: But I can show that, let me show the well, all right, I guess I can go this I'll show the repo at the end then. So for ideas, a lot of them survived from the last one. We've just launched an Arbitrum. So really anything in Arbitrum would be interesting. There's lots of opportunity there. It's new something like even one of the standard pools if you had some kind of logic on it because you can do a lot of change weights, you can stop with some of them. You can change the swap fees, change the weights so that you could have something even off chain that rebalances in a unique way with swapping to reduce impermanent losses.
00:15:39.906 - 00:16:26.134, Speaker B: A lot of things you could do. Of course, in Arbitrage bot we have flash swaps. We just saw some actual flash swaps with using internal balance in the wild. So it is possible to do that or some sort of relayer, really just surprises, can do whatever you yeah, we're just excited about what people can build. And I also have a list of resources here which I guess will be published at some point. Let me show you the Mona repo example repo. So here it is.
00:16:26.134 - 00:17:03.220, Speaker B: We just published it today. It's under GitHub balancer. Labs balancer. Examples. So this is built off an example we saw from Arbitrum and this is just the beginning of it. We're going to add a lot more to it, but this is just kind of the first minimal thing that has all the configuration because that's really the hard part, pulling in all the dependencies. So we have Balancer JS, which has a lot of the helpers to do it.
00:17:03.220 - 00:18:24.350, Speaker B: So here's an example of liquidity provision. So we have a couple of scripts that you can run and I can actually do it here too. When you're at the top of the here's you do a yarn, yarn build at the top level and then inside the examples here, and then you can run the script and I'll go through the script just to show you that it works. And this is similar QR. And of course we have the monorepo with all of its exhaustive tests, but we didn't want to publish all those TypeScript things because they're very specific to our applications and we didn't want to have to maintain that it works out of the box. So you should be able to just fork or clone this and run these right out of the box with instructions in the README. But I can just go over this very simply.
00:18:24.350 - 00:19:16.698, Speaker B: You set up the environment. This deploys, I don't have to go through details here, but this deploys the vault and authorizer it mints some tokens, 100 tokens actually, and it approves them to the vault and it sends them to the trader so that you have some funds. And then you're deploying a way to pool factory. All of the pools are deployed from factories pointing at the vault. So now you set the parameters, which is very simple. And then here you create a pool from the factory, you give it name, symbol, tokens, weights, delegate, owner, and then it deploys the pool. And now you have a pool.
00:19:16.698 - 00:20:17.490, Speaker B: So given this pool, you can now join and you're joining on the vault because join, swaps and exits all happen on the vault given the pool ID. When you create a new pool, you get an ID and then you call the vault with that ID. And a lot of the complicated parts of building on Bouncer, especially for UIs, is the encoding, the arguments, because it's so generic, that means we need to support any arbitrary logic. That means that logic might require some data from the users. So for a join, it needs to know what are the token balances that you're joining with, for instance. And we don't know what a new pool type might need, it could need anything. So we have a generic user data bytes 32 that we pass in or byte a generic bytes user data argument that we pass in and that can have anything in it.
00:20:17.490 - 00:20:56.362, Speaker B: And it's up to the pool to decode that. So that's a lot of the complexity and it's hard to do it on ether scan, for instance, because of that. So for that reason we have these encoders and this does it all for you, weighted pool encoder. So you're saying we're going to do an initial join. When you create a pool, the first time you join it, you have to do a special initialization join. And then after that anyone can join. In the case of Liquidity Bootstrapping pool, you have to be the owner.
00:20:56.362 - 00:21:54.110, Speaker B: In the case of a regular weighted pool, anybody can do that initial join, but it just has to be done that way first. And then we have these simple helper functions like get pool tokens. So the vault is an object in TypeScript, so it's very easy to follow here, get pool tokens, print them out get pool balance of how much BPP does the trader have? Very simple straightforward code. If you look at our tests, this is enormously simpler than our tests and that's by design. So here I've done a join and then here do an exit and this is all the encoding. You make this structure and you call exit pool on the vault. And then you look at the results and you do the it has some expect, I guess this one doesn't.
00:21:54.110 - 00:23:00.600, Speaker B: So this is joining and exiting. There's another one I just put in that shows how to do a swap. So it has the same kind of beginning and then again the call is just swap on the vault but it needs all these arguments that are structures. So this shows you how to construct these in JavaScript or TypeScript. And then this is more like an actual test. So it expects that you do a swap in, the balance is going to be increased by the amount you swapped in and the amount you swapped out is going to be going to be less than it was and it does a regular swap and then also a batch swap. So here a batch swap is a chained set of swaps and you do the first step and the second step and then again, it's just a simple batch swap call right on here.
00:23:00.600 - 00:24:04.490, Speaker B: So this is the skeleton and we're going to add to this a lot, but that's how to interact, how to deploy the vault, deploy a pool and interact with that pool. We also have an example of how to say you're doing contract development. So say you want to do a new kind of pool and you can read the detailed docs in here. But this is a very simple example of how you might make your own pool type. In this case it is trivial enough. It's basically a regular weighted pool that has a maximum of three tokens and we haven't really done much else to actually it's not even a weighted pool, it's just a pool that has three tokens and it shows you the implementation here. And part of that also is and some of the things you have to override and part of it this also shows you how to do things from inside a contract.
00:24:04.490 - 00:25:13.150, Speaker B: Let me do just a second here. In liquidity provision, there's also this contract here, liquidity provider. So this simulates if you have this is if you're like an aggregator and you're not making a new pool type, but you're interacting with pools from a contract. So the scripts show you how to interact with it using JavaScript and this shows you how to interact with it from within a contract. So here we're saying initialize a pool from a pool ID and this is calling things on the vault and showing you how to construct these arguments. It's very similar, parallel really to the script code, but it shows you how to do it inside a contract programmatically vault join pool. It's very similar and this just has a join and an exit.
00:25:13.150 - 00:25:52.720, Speaker B: And we're going to add to this as we go along. So I think we're near the end of the time, I guess I have to open up for questions. We'll also share the resources. There are SDKs also we have SDKs for the sor we have a great Python SDK that lets you access everything through Python and create pools and do swaps and all sorts of things. So we have all those resources available and I guess we'll publish them somehow here.
00:25:54.690 - 00:26:09.102, Speaker A: Awesome. Looks like we have some questions coming in the chat here. Jeff, we had first question we had from Kevin, I think just wanted to go a little bit deeper into what the query batch swap is and how that can be helpful.
00:26:09.246 - 00:26:50.080, Speaker B: Right, it's a little bit of solidity magic. It literally runs the same code as the real swap would do. So you can see in the code there's the query join, query exit and these functions are just they parallel the actual functions. If you do a real batch swap, it'll actually do the swap. If you do a query batch swap runs the same code, it will actually do all the transfers. It does everything all the way up to the very end. It changes the balances in the vault and everything at the very end.
00:26:50.080 - 00:27:38.640, Speaker B: But instead of actually completing the transaction, it reverts the transaction at the very end and it encodes the data in such a way that you can figure out what it did. If you just look at the code in the monitor repo, it'll show you. It's basically all inline assembly that does this magic and there's links in there to where that was derived from. But it's a wonderful thing for it's an on chain way and also we have an Sor that simulates it in JavaScript. But this is an on chain way. In case your program needed to know what it would do. You could use that method and you would get the exact values that you need.
00:27:38.640 - 00:28:43.326, Speaker B: So for stablecoins oh yes, well, part of that's in development. So we do have stable pools and we also have metastable pools. Stable pools have a get rate and actually all of our pools have this get rate function and that lets them be used as rate providers in our metastable pools. So one way to do a stable coin is have your own stablecoin in a meta stable pool with like our three pool or different stable, different stable coin. So there's just a lot here it's hard to answer. The regular stable pool is one to one and then we have a meta stable pool which has a rate provider which tells you the relationship. So it's made, for instance, like Dai and CDI.
00:28:43.326 - 00:29:37.218, Speaker B: So they're not one to one but they're related and they're changing slowly like one is gradually increasing or one is gradually approaching the other. And that relationship is queryable on chain through some mechanism, maybe. And we also have adapters for that. Actually, there's a repo, I think, that has these examples, let me find it. Of relayers that have metastable rate providers. So we have, for instance, an adapter for chainlink and an adapter for compound tokens. So, yeah, I'm not sure if that answers the the question.
00:29:37.218 - 00:30:09.066, Speaker B: There's a lot going on there. We have different kinds of stable pools and we have even more advanced ones that we're developing where we're concentrating liquidity of stable coins and using them to generate yield. So eventually you'll be able to use another one. Let's see. Okay, yeah, right. Maybe we can make some videos on stablecoins. I'm also not the stablecoin expert.
00:30:09.066 - 00:30:46.170, Speaker B: There's people that worked on that more directly that it can probably explain that better, but okay, different vaults. I mean, the point is that there is only one vault. So the question is how difficult to extend vaults? You can't extend the vault if you mean literally the vault. I mean the vault is I suppose you could have another yeah, you could always deploy another vault. But there's not really a reason to do that. What you're extending is the pools and the pool types. You can make a new type of pool that uses the same vault.
00:30:46.170 - 00:31:23.800, Speaker B: That way you have access to all the liquidity and the security and governance control and everything that you have with the vault. That's the advantage. Okay, pool type. So you're saying how difficult to make a new pool type? And I address that a bit. It's not trivial. It depends what you're trying to do. If you need new math, for instance, so that would take a lot, you probably would end up having to copy a lot of the code from the repo into it.
00:31:23.800 - 00:32:29.078, Speaker B: If you're just using a pool type, like launching a pool from within something, then you can just pull down the NPMS and use it, no problem. And maybe some very simple modifications, really simple modifications might be able to be done by just extending one of the existing classes. But if you want to do anything really different, you probably have to make a whole new math if you're using a different AMM function, so a different pricing algorithm, different math, you will definitely have to make another parallel structure, sort of like we did with the way to pool. You might have to make a new pool type. I guess you could look at the weighted pool, two tokens with an example, because that's not as tied in to the inheritance tree as most other things. You'd put something on the side, maybe you can borrow from some things. You're going to end up having to copy a lot of code over from the mona repo.
00:32:29.078 - 00:33:01.350, Speaker B: So it's not trivial, but certainly it can be done. We've had people do it element Finance did it. And you can look at their pools. A lot of those are and I think there's two or three other ones that are out or in development. So we've already had several examples of people doing this. It's certainly easier than developing your own AMM from scratch. Grants.
00:33:01.350 - 00:33:39.490, Speaker B: We do have grants UI level. I mean, you can also make all of our code is open source. You can just make pull requests, too. If it's a small thing for a bug fix, you can just make a pull request. We also have a Grants program. It should all be on Discord or the website, the URLs for that. I think it's just Grants, Balancer, PY, something like that, where you can do a proposal and apply for grants.
00:33:39.490 - 00:34:35.970, Speaker B: And yeah, we have several in progress, several awarded, and that's an area we're trying to grow along with. So we're making major pushes here, not only on the development end, but also on specifically for developer docs like these sort of things to make it easier to build on Balance because you recognize that it's a complex thing, it's kind of a trade off because it's very flexible and that leads to some irreducible complexity. And so we're trying to make that as easy as possible, and certainly it's already been done. And we're also trying to get more community involvement in decentralized generally, and have more community involvement and have things like the Grants programs. And we have the ballers and that's all expanding rapidly as well. Got all on our plate and we're hiring.
00:34:40.410 - 00:35:10.826, Speaker A: Awesome. I think that was all the questions I saw there. Well, yeah. Well, Jeff, I mean, first of all, thank you so much for yourself, giving us the time and walking us through the new V Two. And also, again, big thank you to Balancer for being a returning sponsor, supporting ETH online, and being with us. If anybody has any more questions after this or you're watching this afterwards on YouTube, you can of course grab the Balancer team on their Discord chat. It's just the Balancer channel there for Ethan online if you're attending.
00:35:10.826 - 00:35:17.390, Speaker A: So if you have any more questions, feel free to grab the team there and otherwise. Yeah, thank you again and thanks, everybody for attending.
00:35:18.210 - 00:35:19.900, Speaker B: Thank you. Good luck with everyone.
