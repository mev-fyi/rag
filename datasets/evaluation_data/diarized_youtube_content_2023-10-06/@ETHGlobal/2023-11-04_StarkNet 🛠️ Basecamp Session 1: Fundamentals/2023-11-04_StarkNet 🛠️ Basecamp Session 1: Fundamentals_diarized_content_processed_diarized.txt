00:00:07.290 - 00:00:22.202, Speaker A: So welcome to Basecam cohort four. This is session one. One of seven. Okay. My name is David Barretto. I'm one of the developers advocates from stagware. Focus on stagnet.
00:00:22.202 - 00:00:58.606, Speaker A: Of course, you can see here my socials, my Twitter, my blog as well. And I'm here with also Manmeet and Omar. We're also developer advocates from Stackware. So in this cohort of basecam cohort four, we're going to have seven sessions in seven weeks. Each session lasts for 2 hours. What we expect, roughly, is that out of those 2 hours, 90 minutes is going to be the presentation or some light coding. We have 20 minutes for questions, which you don't have to wait for the end or just whatever question you have.
00:00:58.606 - 00:01:25.730, Speaker A: Use the Q and A and Manmit and Omar will do their best to try to answer them. If any of you don't know the answer, you want to discuss it, please. Omar, Mamit, interrupt me. We have a discussion live as well. We will share in the Q and A for you guys after the session in an email, so you have that as a reference. We will have ten minutes break as well. And just so you know, the last session of basecam core four is going to happen May 24.
00:01:25.730 - 00:01:45.774, Speaker A: So it's going to be kind of like two months in the future. We have some homework, but it's optional if you want to do it or not. Just take base cam as a way to learn everything aboutnet and Cairo. It's up to you how much you want to get out of that. So we don't have any formal aggravation. We're going to be reviewing the code. We're just here to support you.
00:01:45.774 - 00:01:56.180, Speaker A: That's why the discord is important. If you get stuck with homework, go to discord, try to get support from your peers. We will also get to hang out there to help you guys as well.
00:01:58.310 - 00:02:02.514, Speaker B: David, there's a question regarding the slides. Can we share the link?
00:02:02.552 - 00:02:17.720, Speaker A: Oh yeah, that's a good point. Yeah. Okay, let me share. Publish. Is there in a Q and A? Yeah. Type an answer.
00:02:22.990 - 00:02:24.586, Speaker B: So it stays there.
00:02:24.768 - 00:02:26.380, Speaker A: In the chat as well. Okay.
00:02:26.750 - 00:02:27.740, Speaker B: Yes, please.
00:02:35.390 - 00:03:08.230, Speaker A: I should be working. Is it working for you, Omar? Can you open it or anyone in the chat can come in? Let me know if you can open the slides. Okay, cool. People are able to look at the slides. So as I mentioned, we're going to have seven sessions for a basecam. So today is about fundamentals, just the getting started about everything, about starnet, Cairo, hopefully to have a basic dev environment set up in our machines and to deploy an example of smart contract to stagnate. So you get to interact with the network as well.
00:03:08.230 - 00:03:35.210, Speaker A: Session two next week is going to be a deep dive. So basically it's like a part two of this same talk today. Session three is actually about Caro one going through the syntax. And if any of you have been at stock there for a while, you will know that Caro zero is a very different language from Caro one. So we want to take some time to go through all the details about the syntax. Session four is about testing. And how do you test Cara one smart contract.
00:03:35.210 - 00:04:15.174, Speaker A: Then session five is about the starnet architecture. We will see some architecture today at a foundational level. But then session five, we're going to go deeper into it. Session six, we're going to look at Cairo's architecture because Cairo has a very specific cpu architecture that we're going to discuss there. And the final session is going to be about starks, the ZK proof that underpins stagnet. Okay, so some things that you should know is that after each session you will receive an email that's going to have a link to the recording. It's going to be a link to a YouTube video, a video that's going to be unlisted.
00:04:15.174 - 00:04:46.754, Speaker A: So you will need the link to see it. We're going to also share the Q A from the session. That's why we're trying to push people to have any question. Use the Q A because that way we can share with you after so you have it as a reference. We're also going to send a feedback form because we want to hear from you guys. How do we improve basecam session only base cam as general, how do we improve from next session for next week? So please give us your feedback. We're going to tell you what's going to be the homework in the email and also a form so you can submit your homework.
00:04:46.754 - 00:05:30.354, Speaker A: In this case any GitHub repo or your stagnant address where you actually deploy it. Use the Q a system to ask questions instead of the chat. And use discord to get help from peers. So if you provide your discord username when you register to Basecam, you should already been added to a private channel on Discord in the stagnant channel, the stagnant Discord server. If you didn't, it's because there are some issues. Either you were not part of the Discord server. So try to first of all get into the discord for stockware and then we will add you some people, we were unable to actually add you because there's some rules about security, about the bots that we cannot bypass.
00:05:30.354 - 00:06:05.626, Speaker A: So I'm sorry, that's one of you. If that's your case, please use this session to ask all the questions that you have. So for today's agenda, we are going to cover why Cairo, why stagnate? So Cairo, the programming language, stagnate. The L2 with Cairo is used. We're going to also see a basic view of the stagnet architecture. We're going to do also basic view of Cairo. One, we're going to discuss some of the tooling that you have available as a developer.
00:06:05.626 - 00:06:36.266, Speaker A: We're going to have a little break and then we're going to do some live session setting up a basic dev environment from scratch. So I'll be using in this case a VM with Ubuntu. So you can see the whole process from start to finish. And we also have that documented. I'll share the links to where that has been documented. Any interesting questions? Omar Manmit to discuss now live. You can vote on your favorite question in the Q A as well.
00:06:36.266 - 00:07:00.720, Speaker A: So that gives us more visibility. All right, we lost some admit. So this is some question here. Which disco server channels is dedicated to the bootstrap? The bootcamp. Thank you. It's called bootcamp. Sorry, base camp Cobalt four.
00:07:00.720 - 00:07:44.966, Speaker A: Yeah, that's inside of the Stagnet Discord server. All right, let's get started. So why Cairo? So I like to start this with actually a story. So imagine you are the head of a space exploration agency in a small country, and your task is to send a spacecraft, a small one, like a robot, to a planet, let's say Mars. So of course you have to do a bunch of calculations. The most important one is when is the right launch window and the best trajectory. So you use the least amount of fuel.
00:07:44.966 - 00:08:21.506, Speaker A: So the rocket is the smallest as possible and it takes the least amount of time. So those competitions are very complex. To perform requires a lot of computing power. So probably you will go to your engineer and say, hey, could you ride in the algorithm in some very high performance language, like rust for example, so we can get those results. We can just know those two variables, the best launch window and the best trajectory. So sure enough, they create the algorithm. But it's very complex because so complex actually requires a supercomputer to be executed in any reasonable amount of time.
00:08:21.506 - 00:09:28.060, Speaker A: But you have the issue that you don't have a supercomputer because you are in a small country, you don't have access to a lot of resources, but there is a rival country that has been willing to help you out. They have one, and they have offered to execute your code and give you the answer. But then you have the issue that, sure, you can provide the code to them, to the rival country, they execute it in their supercomputer, and they will give you back the answer, right? So they give you those two variables, the launch window and the trajectory. But then you have a problem. How do you know that that is the right answer? That is actually the result of executing your programming exactly the way you write it. How do you know that the supercomputer didn't malfunction? Like one bit flop doing the calculation? Or maybe there was some kind of sabotage, maybe even a small change in how the computation is performed could be a disaster for your space exploration. So you don't have a way to meaningfully to be convinced that that result is actually what the algorithm that you wrote or your team wrote actually was supposed to find.
00:09:28.060 - 00:10:35.726, Speaker A: So not even with any traditional language, you cannot have that certain thing, not even rust, not c, not any language. But with Cairo, you actually can, because Cairo is a provable language that when you executed the repeated scenario, this time you write the algorithm in Cairo instead of rust, you provide that code to the supercomputer of the rival country. But now then, because it's been used with Cairo, not only do we give you the result back, they also will give you a cryptographic proof that verifies, or will let you verify the validity of the computation or the integrity of the computation. So now you can take that proof and you can use any regular computer and just verify the proof. And that verification will let you know in non certain terms, or in a mathematical certainty way, that the result that you're getting is actually what was supposed to came out of the execution of your program. This is called computational integrity. So now if the execution is intentionally or unintentionally modified, the proof will be invalid and you will know it right away.
00:10:35.726 - 00:11:11.420, Speaker A: So there's no chance someone's going to sabotage your program or that there was some malfunction and you didn't know. You will know right away. So with this, with Cairo and the fact that you get cryptographic proofs out of execution, a regular computer, in this case a laptop, is able to keep a supercomputer honest. And that is a superpower that only languages specialized like Cairo, specialized for validity proofs, can provide. Okay, just a sec. Trying to make the Q a visible for me as well.
00:11:12.430 - 00:11:18.620, Speaker B: David, just one question here we have channel in discord for these.
00:11:19.950 - 00:11:23.870, Speaker A: Do we do someone actually provided basecamp cohort port? That's the name.
00:11:23.940 - 00:11:29.120, Speaker B: Excellent. Thank you very much. Shipping. I saw that. Okay, perfect.
00:11:29.970 - 00:11:49.240, Speaker A: Yeah. If you provided your discord username when you register, you should be in the channel already. Unless you were not part of the discord server. So if you were not, try to join the discord server for stagnate. And then we will review the list again and add the new people that enter the Server later.
00:11:49.930 - 00:11:57.610, Speaker C: David, if it takes just a second, could you please add me so I can also take a look at the questions. And be able to answer them on Zoom.
00:11:59.390 - 00:12:01.766, Speaker A: To add you to discord.
00:12:01.958 - 00:12:04.650, Speaker C: Just the Q and A. I have to discord.
00:12:08.930 - 00:12:10.510, Speaker A: You can just open the window?
00:12:11.170 - 00:12:29.074, Speaker B: Yeah, it's opening. Yeah, no problem. Go ahead David. Okay, so we have a lot of questions here, but we're going to answer them and let you know what can we answer like let me just try.
00:12:29.112 - 00:12:44.022, Speaker A: To answer a couple of them. Maybe you can type the answer as well so they have it as a reference. But let me just see interact with the audience. Let me see some of the questions. At least the one have been voted that have not been answered already. Sir. Skip the intro.
00:12:44.022 - 00:13:05.694, Speaker A: So what do I have to do to graduate? Can attend all the sessions 100% do the work. We don't have a formal graduation. This time we're going to give you homework. It's up to you if you want to do it or not. Just take spacecam as a way to learn as much as you want from Cairo and Stagnet. This is because we don't have capacity to assess. Hundreds of people submitting homeworks every week.
00:13:05.694 - 00:13:11.940, Speaker A: A reliable way. And we realize that the goal here is just for you guys to learn more or anything.
00:13:14.070 - 00:13:23.060, Speaker B: We can do cool stuff. You will see that it goes to something. It will be worth it.
00:13:24.150 - 00:13:42.250, Speaker A: Box says we really need have to focus on Cairo one. No reason to do carrot zero anymore. Yes, in this base camp we're not going to do any Cairo zero. It's just all about Cairo one this time. Just be mindful. Car one is super new, was just released to main end very recently. So it's going to be a little bit rough around the edges.
00:13:42.250 - 00:14:24.980, Speaker A: But it will improve over time. How can we sure that the proof is not tampered. So the probability of you being able to create a cryptographic proof that is going to fold the verifier is one over 1 billion times 1 billion times 1 billion times 1 million. So it's very small that you can actually do that. To understand exactly the reason why you have to wait until session seven when we discuss. Actually, Stark, the math behind these validity proofs, please turn on caption. It will be super helpful.
00:14:24.980 - 00:14:43.790, Speaker A: You know what I try last time, I don't know where it is. Can you. Omar, you're the host. Can you take a look to see if there's a way to enable captions? I know the last time or some previous time we were able to, I just don't remember where. Sure, I'm looking for this.
00:14:44.640 - 00:14:45.900, Speaker B: I don't promise.
00:14:48.080 - 00:14:55.330, Speaker A: All right, let me continue. Omar, if you see any interesting question, please interrupt me and we can have a.
00:15:00.660 - 00:15:03.510, Speaker B: We going to? I don't know, go ahead.
00:15:04.760 - 00:15:45.200, Speaker A: Okay, so to summarize, why Cairo? So first of all, it allows you to create what's called a provable program. You can create a cryptographic proof that attests to the integrity of the computation. So as I mentioned, the cryptographic proof is generated alongside the result. Proof verification can detect cheating or malfunctioning without reexecution. That last word is the key to why we use proof for scaling ethereum. We're going to look more into that in the next section. So you can summarize this by saying that a regular computer is able to keep a supercomputer honest when you use a language like Cairo.
00:15:45.200 - 00:16:38.984, Speaker A: Okay, so we talked about Cairo, so why do we need darknet? So let's think about the issue of scaling on layer one. Sorry, just a second. It disabled disco because I hear so many notifications that are distracting me. Okay, so in layer one, in case of ethereum, we have what's called a block producer, which is going to give you, okay, it's going to tell the network, hey, here's the new state of the network. Let's say the state is 42, but of course all the other validators in the network, they just don't going to take the word for it and say, oh yeah, sure, it's 42. They will actually execute independently the same block, and verify that they all get to the same result independently. So that's part of the consensus that the actual result they all get to a consensus is actually 42.
00:16:38.984 - 00:17:18.852, Speaker A: So as you can see, even a small or a simple computation takes tens of thousands of computer to actually execute. Right, because they all need to execute that independently and get to a consensus. So you can see that is fairly inefficient in that regard. So this is how Ethereum achieves computational integrity. But by re executing the same transaction over and over. In the case of a stagnant, we execute only once, but then we verify everywhere. So on a stagnant you will do something similar, you process transactions, and then you propose a new state.
00:17:18.852 - 00:18:10.580, Speaker A: Let's say the new state is 42. But not only you provide the new state, you also provide the cryptographic proof. And now the validators were just Ethereum nodes, ethereum validators, they don't have to re execute the same block to see if it's 42. They only have to verify the cryptographic proof that was provided, and that will give them mathematical certainty that the actual answer of the new state is 42, without having to re execute all the transactions in the block. And as you can see, the verification takes only a fraction of the actual underlying computation. So you can see visually here why a L2, like a stagnant, is so much more performant, because now you don't require every single node of the network on layer one to reexecute all the transactions. They only need to verify the cryptographic proof, and that takes much less effort.
00:18:10.580 - 00:19:12.488, Speaker A: What's the connection? How less of an effort? Well, if the execution takes n steps, the execution done by the sequencer on a stagnet, then the validation of the cryptographic proof associated with it actually takes lock square of n. So this polylogarithmic relationship, and it's easier to see in this graph. So this blue line going vertical, sorry, going in the diagonal, is actually the amount of steps of certain computation. And you can see the red line is the amount of steps or the verification of the associated cryptographic proof. So the bigger the gap between these two curves, the more you achieve in saving computing power from the whole network to achieve the same result of creating new states. So you can think of validity proofs. At this analogy, a validity proof is to Computation what zip is to a file size.
00:19:12.488 - 00:19:32.450, Speaker A: It's all about compression. Just in the case of validity proof, it's a compression of computation, while Zip is a compression of file size. Let's see, any interesting questions? Any question here? Omar and me?
00:19:32.980 - 00:19:40.640, Speaker B: Yes, if I inquire, is asking what is honest supercomputer?
00:19:42.420 - 00:20:13.260, Speaker A: You don't need the supercomputer to be honest. As long as they use the Cairo VM and you have access, we're going to have to see, you'll need to have access to the underlying Cairo program. So we all have an agreement which program is being executed. But as long as the supercomputer uses Cairo VM, it will able to generate this cryptographic proof that the computer will not be able to tamper. Or if they do you with a verifier independently, you will be able to spot when they are trying to cheat.
00:20:18.000 - 00:20:24.000, Speaker B: Sorry, when you say cheating and being honest, what do you mean? What is cheating? In this context?
00:20:24.900 - 00:20:54.904, Speaker A: Cheating will be trying to create a validity proof that try to attest to a computation that didn't happen, or to attest that some computation that apparently happened provide a completely different result that it should have done. Okay. And you've been trying to fool the verifier that you have on your side. So it's the combination of both I give the security of a system. Great.
00:20:54.942 - 00:20:56.520, Speaker B: Thank you. Secure workstation.
00:20:58.800 - 00:21:04.670, Speaker A: Please, people in the chat, please use the Q A. Don't use the chat for questions so we can keep track.
00:21:06.800 - 00:21:22.850, Speaker B: Yes, we're focusing on the Q A. And also, David, here's a question. How can aslio join the discord? I guess they're simply going to the discord of Starknet. Join and whatever.
00:21:24.180 - 00:21:29.860, Speaker A: If you can share the invite link to the discord server, put it there in the Q A will be helpful.
00:21:30.200 - 00:21:47.240, Speaker B: Also, let me invite you to the telegram. I will send you a link in the chat so you can join the telegram here of english speakers. It's only for builders. So if you want to go there and we can just talk a little bit more and contribute, you can ask questions and so on. So I will send you the link also for the discord.
00:21:49.200 - 00:22:18.756, Speaker A: Cool. Thank you, Omar. All right, let's talk a little bit more about validity proofs. So validity proofs are an implementation, what's called the zero knowledge proofs or CK proofs. And it uses CK proof to guarantee computational integrity. That's basically to guarantee that certain output is a result of computation with input. So you can think about that as like doing the right thing even when no one is looking.
00:22:18.756 - 00:22:47.736, Speaker A: That's one way to think about computational integrity. So we use validity proofs and CK proofs not for privacy, which is a common misconception about starnet. We use it for scaling Ethereum. As I showed you before, the comparison of the layer one and the L2 validators. So starnet right now is not about privacy. It might be in the future, but right now it's not. That's why we think that ZK rollup is a misnomer, because it kind of implies some privacy.
00:22:47.736 - 00:23:31.264, Speaker A: We prefer the term validity rollup for starnet. And to be fair, pretty much any other ZK rollup out there uses validity roll ups. None of them, to my knowledge, actually are focused on privacy after I think Aztec shut down their own L2. And very importantly, the type of ZK proof that starnet uses is starks. We don't use snarks, probably have heard both pin cK proofs, but we use starks. And there's an important reason why we chose to go with starks and snarks that I want to review here. So if you compare these two type of ZK proofs, the verification time for a stark proof is polylogarithmic.
00:23:31.264 - 00:24:04.372, Speaker A: If you recall the chart that I showed you, in the case of a stark, it's actually constant. So it doesn't matter how complex the underlying computation is, the amount of work to verify the computation is always the same. Now the proof size that we send to layer one for verification in the case of stark is pretty big. It's about 400 kb. In the case of a snark, it's pretty small. It's only close to 300 bytes. So it begs the question, if the snarks are so much better than stack, why did we actually chose a stack and snark for stagnet? There are very two important reasons for that.
00:24:04.372 - 00:24:34.576, Speaker A: First of all, when you use snarks, you have to go through the trusted setup, the trusted ceremony where you have to fit the system with a secret and you have to make sure that the secret is properly disposed. Because if that secret is being leaked, the whole system is compromised. In the case of stack, we don't need a trusted setup. It works even without that. So it's one less trust assumption for the security of the system. It's also very important. The Starks are quantum secure, which snarks are not.
00:24:34.576 - 00:24:53.910, Speaker A: So whenever quantum computers come alive with sufficient power, they will actually break a stark, but they will not break a stark. So we are making a bet on the future to the maximum level of security that we can think of. Of course that has a price in the proof size, but it's better to be safe than sorry in the future. That's all. At least we'll be thinking.
00:24:57.150 - 00:25:11.600, Speaker B: David, good question here. So there are some people that join the discord of Starnet mode. They have not been added yet to the channel. So how can we proceed in that case?
00:25:12.210 - 00:25:43.080, Speaker A: If you joined just recently? Allow me some time to get in touch with the Discord mod who is in charge of the channel, so they can add you. Just make sure that you actually provided that your discord username when you register and we will try again to add you to the server. Some people might try to join theware server and might not be able to. And that's because some security bots, that's something that we cannot do anything about that. But if you actually were able to join, we will add you to the Discord server. Just maybe tomorrow morning.
00:25:44.090 - 00:25:49.394, Speaker B: Maybe they can send their discord name in the chat.
00:25:49.442 - 00:25:49.654, Speaker A: Right?
00:25:49.692 - 00:25:50.600, Speaker B: And we can.
00:25:51.290 - 00:26:05.662, Speaker A: Yeah, Omar, if you can take a note of that, it will be super perfect. Okay, so maybe start A-Q-A. And people add their discord username. So we have one place to track all the people who were added to the.
00:26:05.796 - 00:26:20.034, Speaker B: Oh, I think it's okay. In the chat, we can download it. And then please add to the chat your discord name. In case you haven't been added to the Discord channel. And we will add.
00:26:20.232 - 00:26:53.900, Speaker A: Thank you. Let me see more questions. I wonder if this is a way to hide the one that's been answered. Okay, is there a possibility to keep the algorithm private. So the supercomputer cannot steal algorithm and they use it later? Not now, no. Because as I mentioned, the stagnet is not about privacy, it's about scaling. And so you have to share the algorithm.
00:26:53.900 - 00:27:01.050, Speaker A: So basically, when you use Starnet, you have to publish your smart contract. So it becomes visible to anyone to use it.
00:27:03.930 - 00:27:29.674, Speaker B: If you answer it. David, please click on answer like so. We know you already answered. Okay, there's some questions from Fox, from XFP. So man, you know that there are. Okay, what do you think about the snarks using a trusted. Without trusted setup? They are using some kind of prfs.
00:27:29.674 - 00:27:31.200, Speaker B: What do you think about them?
00:27:32.450 - 00:28:02.650, Speaker A: That I'm not sure. I haven't digs so deeper into the tech sector. Know what's the implication? But I know that for Ethereum, there's a push right now for KCG commitments. I think that's part of the secret, right? We're all collectively creating a secret to fit into the system. To provide security to the stocks. So that's why it can be done. But you have to make sure that you do the KC commitment ceremony correctly.
00:28:04.270 - 00:28:30.850, Speaker C: Yes, Jim, second, real quick. So when you have a circuit and the verifier has to read. It's basically you have two parties, prover and verifier. All of this trusted set of yada, yada yada is basically done. So the verifier can read something shorter than the actual circuit. And verify that the circuit is correct. So we have to, as David has been saying, go through some sort of a compression process.
00:28:30.850 - 00:29:31.400, Speaker C: From circuit to compressed information. And then that compressed information is what the verifier reads this compression requires, in the case of snarps, which is the first protocol to have been introduced in this space, it requires some randomness. Now whether you use verifiable randomness or I guess unverifiable randomness, that doesn't change. The security vulnerability that we are talking about is that even if you do have verifiable randomness and someone is able to get access to that or leak that information after the trusted setup, then the proverb can basically cheat and create false proofs and the verifier will not be able to figure out what's going on. That's kind of like what we're doing here. Starks require no randomness to generate, they only use a collision resistant hash function, which is also why they're quantum secure. So that's kind of like just fundamentally superior tech stack, I guess.
00:29:33.370 - 00:30:45.354, Speaker A: There's a very interesting question from Zebrin Islary that says, aside from blockchain, where can Cairo be to? I see some very good answers already from your peers, so let me just provide my own answer as well. One example that I like to think about is in the future, you should be able to generate proofs directly on your computer, right? And then submit that proofs to some server, and the server is the one who runs the verifier. And I like to think gaming is a good example of this. It's a common issue in gaming that people actually modify their client to cheat, right? And that's an issue when you have a multiplayer game with language like Cairo, you can technically request your client to every so often create a validity proof out of the execution of your client and send that validity proof to a server which runs the verifier. Just to check that you are not cheating, that you are actually securing the client the way that it was supposed to be. So if you try to cheat, if you try to modify your client, the server will know because the validity proof that you send regularly will fail. So that's one use case and there are people actually doing research in the topic to actually run, even on a smartphone.
00:30:45.354 - 00:31:00.210, Speaker A: The main issue right now is that creating proof is a very resource intensive process. So there's a lot of research that needs to be done to get to that point. But it's an interesting thought as well, how to use Cairo in a different setting that is not stagnant.
00:31:04.840 - 00:31:07.190, Speaker B: We're also doing something with bitcoin, right?
00:31:08.120 - 00:31:11.530, Speaker A: Oh, that's great. Yeah. Can you explain? Can you elaborate, any of you?
00:31:12.300 - 00:31:37.996, Speaker B: To be honest, I am not very aware of what is happening, but I know that there is something being built. I will send you the report to the chats. Something is being built. I don't know exactly what, but it is in order to scale bitcoin you should start. And it has been very successful within the bitcoin community. So that's something we can say about it. Also, maybe there's a question about the program will be open source.
00:31:38.188 - 00:32:19.976, Speaker A: Let me first answer the question about bitcoin. Actually that's something that the bitcoin community is very well aware of. I think the Ethereum community is not as much, but on the Ethereum community they're actually using our technology to create a very light bitcoin client. I think the basic idea is that a cryptographic proof or validity proof is generated out of a regular bitcoin client. And then when you want to sync a new bitcoin client yourself, you don't have to download the whole blockchain to calculate the utxo yourself. You can just verify the cryptographic proof of all the calculation that other server actually perform for you. And then you can sync to the latest UtxO.
00:32:19.976 - 00:32:34.850, Speaker A: Just download the database and verify the cryptographic proof associated with the execution to get to the current UTxO. So now you can zinc a bitcoin client in a matter of probably minutes instead of days. I forgot the name of the project. Was it.
00:32:37.540 - 00:32:55.432, Speaker B: Clement Kofitz here added the link to the rip with the chat. Thank you very much clement. You can go and see it. To be honest, there's a lot of very cool stuff that is being built right now at the edge of the technology. The star community is amazing. To be honest, it's amazing. They are building some really cool stuff and.
00:32:55.432 - 00:33:01.624, Speaker B: Yeah. David, do you want to do the.
00:33:01.662 - 00:33:34.084, Speaker A: Proverb open source question the proverb open source? Yes. So right now it's not open source, but we made a commitment to actually we will make it open source. We're just trying to tackle other areas of the blockchain first, especially the sequencer is our first target. It's just already we're doing a full rewrite in rust. Open source want to decentralize also the sequencers before we can tackle the prover. But it is the goal to decentralize the whole stack. It's just not yet.
00:33:34.084 - 00:33:50.940, Speaker A: We're not at that level yet. So right now the sequencer and the prover are actually centralized, which is the same for every other CK problem. Right now that is centralized. That's all. They're not actually open source. Yeah, go ahead, Omar.
00:33:52.400 - 00:34:29.400, Speaker B: There's also a question from Paul asking, can you explain why stark is secure? Not stark. So real quick, the part of the cryptography that is being vulnerable right now to quantum attacks are those using elliptic corp cryptography, such as Starks and Ethereum and bitcoin and so on. And the starks are not relying on this kind of primitives. They are not using elliptic corpse. They are using hashic functions as symmetric key encryption. So it is believed that this particular primitive will be quantum resistant. So that's the main reason the elliptic corp cryptography.
00:34:29.740 - 00:34:49.390, Speaker A: Yeah, at least right now we don't know any algorithm able to break hash function using quantum computers, but we do know an algorithm to break elliptic curves and other cryptography primitives using elliptic curves using quantum computers. The algorithm exists. It's just waiting for a quantum computer to be sufficiently powerful to run it.
00:34:49.840 - 00:35:14.340, Speaker B: And they will talk when we have that. A lot of development has been done in the quantum computing side, and one of the goals they have is actually trying to use this algorithm to break the elliptical. Cryptography is actually a metric for how good these computers are. So it will come a day, and when that day comes, the first thing they will do is break this lip. Cortography.
00:35:15.320 - 00:35:50.160, Speaker A: All right, thank you for the question. Meet Omar. Feel free to keep answering them on the Q A. I'm just going to keep moving forward because of time constraints. All right, so you probably have heard, like in stagnate, we use the Caro VM, we don't use the EVM. So why is that? So on one side you have ZKE evms, which some famous one are like the Polygon Hermes Scroll CK sync. They try to be as compatible as possible to the Ethereum virtual machine, while Starnet is actually using its own virtual machine called the CarobM.
00:35:50.160 - 00:36:41.330, Speaker A: So these two approaches, they're trying to optimize for very different things. So seeking EDM is trying to optimize for having max compatibility with current smart contracts deployed on layer one. But they sacrifice performance because the EVM was created for a particular cpu architecture or a traditional cpu architecture that is not really friendly to CK circuits. That's why Cairo VM or Stargrape, we decided to create our own virtual machine so we can create our model, a computer that is exactly or fine tuned for validity proofs. So we're thinking about how do we track the most performance of the network long term. Amit, do you have any more comments? You're more an expert of this area than I am, probably.
00:36:44.260 - 00:37:01.416, Speaker C: I would leave it at that today. But we can. But yeah, the main difference is of course you can compile your code directly into EBM by code on zkebms with us. You have to go through Sierra and maybe I'll let you speak more about.
00:37:01.518 - 00:37:38.336, Speaker A: We have a session six. It's going to be about the Cairo architecture. So probably a lot of these questions are going to get answered. How the architecture of Cairo actually looks like the Cairo VM actually looks like. Just a quick comparison. If you have read Vitalik's article about the CkeVM classification, he classifies CkeVM in four categories, type one to four. So type one is basically no changes to theorem virtual machine full compatibility, but the performance will be very slow to create a cryptographic proof out of those execution.
00:37:38.336 - 00:38:18.172, Speaker A: So pretty much no one is attempting this right now. Type two is that you use most of the EBM, but you change at least the data structure for storage. You achieve high compatibility. At least you're going to have some smart contracts that you will need to be modified, but the performance is still very slow. Then you have type three where you have compatibility, but you have to modify something like storage hashes pre compiles to make it a little more friendly to the new architecture so you have partial compatibility. It's not like you can deploy every single smart contract as is to a L2. With these characteristics.
00:38:18.172 - 00:38:52.600, Speaker A: The performance is going to be slow, at least in theory, technically. And we have projects doing that like Scroll, Polygon, Hermit, ZK sync. Even Katarot, which is a layer three on top of Starnet, are actually tended to be type three Cke evms. But then you have the type four where they implement a completely different virtual machine. They're not compatible with the smart contracts deployed on Ethereum using solidity. But the upside is that it's very fast to create the validity proofs. So you have two main projects competing in the space.
00:38:52.600 - 00:39:11.440, Speaker A: Obviously stagnate is one of them. And you can consider to be a CkeVM because you can use stagnet with a compiler called warp to compile solid smart contract into Cairo VM. And the other one is polygon smiting. So we are really focused on performance and long term view of scaling Ethereum.
00:39:14.060 - 00:39:57.668, Speaker B: Okay, to summarize, maybe quoting here, eleven, Sasson he said, we really believe in Star wars that the future of scalarity will be built using Cairo or astronaut GVM. Because David said the only focus of Cairo, the only focus of Cairo is to scale Ethereum. That is not the goal of the EVM. The EVM goals is to maximize centralization, which is great, and it's very relevant. We're already thinking as a given the part of the security and decentralization that Ethereum gives. So now we're focusing only on scaling. And that's why we really believe that Kyo is the way to scale Ethereum.
00:39:57.668 - 00:40:33.008, Speaker B: The problem here is, of course, image from David's show. There's already an Ethereum building tooling, tooling boundary. We have profile and so on, and those we don't have in Cairo or starnet. We need to build a new tooling. However, the tooling is being built by the day. So we have total star, which is kind of similar to foundry. We have actually, which we have several APIs and sdks that we can use to interact with the starter than Kyo.
00:40:33.008 - 00:40:45.000, Speaker B: So the tooling is getting much better. So we are able to write Kyo and scale both the social part and the scalability as lower fees and fastest transactions.
00:40:45.820 - 00:41:10.364, Speaker A: Cool. Thank you, Omar. All right, to summarize why Stagnet, first of all, it guarantees computational integrity without re execution. Proof verification is cheaper than the underlying computation. So remember the polylogarithmic relationship with the underlying computation. We can think about that as computation compression. So we use ZK proof for scaling, not for privacy.
00:41:10.364 - 00:41:48.648, Speaker A: That's very important to keep in mind, at least not yet. And we use ZK proofs, we use starks, CK proofs and not snarks, because starks are quantum secure. That's really the main reason we're thinking long term. And this is why we have the trade off. Cool. Let's talk about at a high level, the architecture of Starnet. So in my previous example, the story about the head of space exploration, the person actually got convinced that the result is 42, whatever that is, right, because he was able to verify independently the cryptographic proof in his laptop.
00:41:48.648 - 00:42:25.130, Speaker A: But then how is other people going to trust that that is actually the result, right? Because so far, only this guy was able to verify the validity proof, but not Alice. So that's why for Alice to trust, a couple of things are needed. First, you need to make the chiropromon publicly accessible for anyone. She should be able to independently verify the proof. Basically run her own L2 node. So she needs a starnet. So starnet is a L2, right? So that's why I present here ethereum at the bottom as layer one.
00:42:25.130 - 00:43:46.752, Speaker A: So on a starnet, when you send a transaction, you send the transaction to what's called the sequencer, right? And the sequencer is like the block producer of Starnet and that's where the Cairo VM lives and also where the starnet OS lives. And the sequences is just going to take all the transactions, it's going to validate them just to make sure that the signature is correct, that the person is able to do these things or been able to use this user account. It's going to bundle them into blocks and it's going to calculate what's the new state of the network based on the execution of this block, right? Similar to a block producer on layer one in this case. The interesting thing here is that out of the execution of all the transactions in a block, the sequencer sends what's called an execution trace to the prover that we call it sharp. In the case of a stagnant sharp is because shared prover is used by stagnate used by Stackx as well. So with this execution trace the prover is able to compute the validity proof to attest to the integrity of the computation done by the sequencer. And this validity proof is eventually sent to layer one as cold data to a verifier smart contract that is written in solidity, right? Since open source anyone can see it.
00:43:46.752 - 00:44:51.936, Speaker A: So the verifier is going to take the validity proof and it's actually going to perform the verification on layer one. This case, the ten thousands of Ethereum computers are going to perform this computation independently and if the verification is actually successful then the sequencer is going to change the state difference. But changing the state before and after the block was executed again to the layer one as call data to a different smart contract that we call a stagnant core and we use that as our data availability. That year we want to publish this data on layer one. So now we can have full nodes or stagnant full nodes. Who gets what is the state of the latest block or the state of the network? It gets that from the signature correctly because as of now these are two centralized entities. But the fact that we send this state diff to layer one, it means that if for some reason the sequencer or the connection between the full node and sequencer fails, you are able to recreate the L2 current state by reading or indexing data from the stagnant core smart contract.
00:44:51.936 - 00:45:28.220, Speaker A: So you can recreate the data from layer one independently if there is a situation that the sequencer stopped responding to L2 full nodes. So at a very high level, this is how Starnet works. So I went through some of the modules. So as I mentioned, the sequencer validates, executes and bundle transactions into blocks. The prover creates stack proofs for a stagnant and a stack x. That's what's called sharp or shared prover. The verifier is a layer one smart contract, verifies stack proof sent from sharp.
00:45:28.220 - 00:45:50.020, Speaker A: Stack core is another layer one smart contract that just stores storage is a big word because actually we only send it as cold data. It's not get stored at the contract level, storage or cost reasons. And we use that as the data availability layer. Finally, the full node provides data to L2 taps.
00:45:52.870 - 00:45:53.810, Speaker B: David.
00:45:57.030 - 00:45:57.490, Speaker A: Perfect.
00:45:57.560 - 00:46:12.280, Speaker B: So, regarding the start of your presentation, there was a question from eliel. Sorry for coming. There are a lot of questions, we're answering each of them. So Eliel asked, do we send algorithm or the data to rival country when you were talking about this part.
00:46:14.730 - 00:46:17.450, Speaker A: Oh, you mean in the example at the very beginning?
00:46:17.790 - 00:46:21.500, Speaker B: Yes, at the very beginning. So what are we sending, the algorithm or the data?
00:46:22.590 - 00:46:48.910, Speaker A: The algorithm, like the program, you can send the program, it's just in reality you don't send the program as is, you send the bytecode of the program, the low level chira assembly program, to the supercomputer. Okay. Yes. Thank you very much. David. Questions from Amit.
00:46:49.070 - 00:46:50.340, Speaker C: Go ahead, go ahead.
00:46:52.490 - 00:46:54.726, Speaker A: Is asking, can you use different data.
00:46:54.748 - 00:46:57.238, Speaker B: Availability layer, like Celestia for example?
00:46:57.324 - 00:46:58.790, Speaker A: The answer is yes.
00:46:58.940 - 00:47:33.118, Speaker B: We are working on the value views, which is going to be. I'm working where we would be able to do the data availability part using different kind of services. For example Celestia, Pycore, USB if you want. It's going to be very interesting. You will be able to write Cairo code where you can declare variables that are going to be stored on chain and some variables that will be not stored on chain. It will be stored off chain or maybe it's an STL or somebody else. So that would be very cool with valid.
00:47:33.294 - 00:48:05.174, Speaker A: Yeah, just a comment. It's called volition, because validium is what volition uses. So we have three different data availability modes right now. Only two really roll up is the one used by Stagnet will be published to layer one. Validium, which is used by Starkx that we are not covering here, but it's another technology developed by Stackware. And then we have volition that we want to implement on stagnet. I don't know, this year at some point which is going to allow you to choose where to store your data so you have different costs for your transaction.
00:48:05.174 - 00:48:23.650, Speaker A: Are you going to store it on layer one or have a maximum security or do you want to store it in some other place that could be celestia or a consortium of people storing data that's going to be cheaper. So we don't have a lot of details about that, but we know that is a path forward for stagnant to enable volition.
00:48:25.670 - 00:48:33.720, Speaker B: David, do you have curious is asking for the link to the repo of the verifier smart contract layer one. Do we have those?
00:48:34.170 - 00:48:44.310, Speaker A: Yeah, if you go to Caroline Repo.
00:48:51.530 - 00:48:52.702, Speaker B: Nice putting it.
00:48:52.756 - 00:49:15.730, Speaker A: Also you go to the Caroline repo. Useful info, important addresses the verifier can. Is there a question here? I don't know where the question is. I put it on the chat, but Omar, can you please put it on the Q A? Yes.
00:49:15.880 - 00:49:20.558, Speaker B: The question is, can we get the link to the repo, the verify smart contract? So I will show.
00:49:20.664 - 00:49:53.754, Speaker A: All right, so this is the link to the deploy smart contract. To see the actual source code you have to go to the Caroline on GitHub and in here. I think it's here. I know I saw it somewhere here, but I don't remember. Yeah, no problem. I can search for it, I've seen it. It's there somewhere.
00:49:53.754 - 00:50:22.552, Speaker A: I need to find. Perfect. Cool. Section four. So let's talk about Carawan. We just recently released this new version of the language which is very different from Cairo Zero, but is much better than Cairo zero. So Cairo one is a high level language, right, which makes it easier to learn compared to Cairo zero, which was more of a low level language.
00:50:22.552 - 00:51:08.252, Speaker A: The syntax of Cairo one is heavily inspired by rust, which also makes it like a strongly typed language. So if you know rust, you will feel comfortable with Cairo one. When you compile a Cairo smart contract, it doesn't directly compile to the Cairo VM bycode, which we call it the Cairo assembly. It compiles to the intermediate language called Sierra. Sierra stands for safe intermediate representation, because this is what allows to create validity proofs even when a transaction fails, which was not possible before, and now because of Sierra. Basically sicknesses are always compensated for their work even if a transaction fails. And in the near future we allow for transactions to be reverted, much in the way that happens on layer one.
00:51:08.252 - 00:51:44.520, Speaker A: So you can see on the right side, you start with a car one smart contract. You compile it to Sierra, and then you send this to the sequencer, the sequencer that compiles to Cara assembly that we also call it chasm. And from the Cara assembly, the execution of this car assembly bytecode by the sequencer. That's where we derive the validity proof on the proof and we send to layer one. So take a look. This is how it looks like an example of smart contract on cara one you can see at a glimpse. It looks a lot like rust where you can do some metaprogramming with macros.
00:51:44.520 - 00:52:09.600, Speaker A: This is how you bring functions into scope. This is how you define storage variables. You have to name a stroke, storage has to be the name. And then you define the properties of all the storage variables. Felt is still the data net type, but then we have more data types that we can use. That before in carousel zero was not possible. One very commonly used is U 256 which is commonly used in solidity.
00:52:09.600 - 00:52:36.410, Speaker A: This is how you write to storage. This is the syntax, this is how you read from storage. For now, just take a look. Today is not the day to focus on carol one a lot, just for you to have a taste of how it looks like. And now this is how you define variables with the keyword length, which if you use Cairo Zero, you know that before there was like a four different ways to define a variable. Now we have only one. So it's a much nicer language to play with.
00:52:36.410 - 00:53:26.040, Speaker A: So there's a thing called regenesis that is all about closing the gap. So as I mentioned briefly that in Cairo zero transactions, failed transactions cannot be proven. And because they cannot be proven, that opens the door for what's called a denial of service attack on the sequencer. Because the sequencer gets to execute a transaction to the point where it fails and then it cannot add it to the block because a validity proof cannot be created out of a failed transaction. In caro zero, caro one actually fixes this problem, but it means that eventually Caro zero smart contracts needs to be disabled from the network for security reasons. So we have two important events that happen over time. The one that happened recently is the deployment of standard zero point eleven to mainet.
00:53:26.040 - 00:54:26.220, Speaker A: Because before zero point eleven, mainnet only supported Carol zero point ten smart contract right after the deployment, the standard zero point eleven. Now both languages are supported. Carol zero point ten and Carol one. At some point in time we're going to go through Regenesis maybe four or six months where we actually going to disable all the Cairo zero smart contract and only Cairo one is going to be supported from that point forward. But in the meantime we have a migration window where we provide mechanism for you to be able to upgrade your already deployed smart contract from Cairo zero to Cairo one while preserving your same storage layout, the same storage values, the same address. So in a way that is completely transparent to your end users using your smart contracts. But you will have this migration window to go through it, because after Regenesis we got to disable all the Cairo Zero smart contract and from that point forward it's only going to be Caro one from that point on.
00:54:26.220 - 00:55:06.410, Speaker A: And this is where we are right now, just at the very beginning of the migration window. So let me go to the summary and I stopped for some questions. Probably there's some so Carawan Carawan is a high level language inspired by rust. Sierra allows for reverted transactions before were not possible. We don't have reverted transactions just yet. We need a little bit more work on the staggered to allow that, but it's now technically feasible to do it. Smart contracts can be upgraded from Caro zero to Caro one while preserving the state and their current address where it is being deployed.
00:55:06.410 - 00:55:25.826, Speaker A: Staggered already supports Cairo one in the tested and on Mainet as well, and regenesis will disable Cairo zero code and that's going to happen before six months in the future. So let me stop here for questions by better some there's a question from.
00:55:25.848 - 00:55:33.140, Speaker B: Anonymous attendee is it possible to build circuits like circle or Noir with Cairo one?
00:55:36.500 - 00:55:45.910, Speaker A: I don't think so, because this is a high level language, but I'm not that much of an expert to get deeper into the reason why. But intuitively I don't think so.
00:55:47.000 - 00:56:13.052, Speaker B: But from what I've seen, you've seen layer three. We can be able to use noir and then that compile it so you can get into Kyro. So it will be interesting. And actually Francis mentioned something before. You can be able to prove snarks into starnet. It's something that's been working Garaga I think, yeah.
00:56:13.186 - 00:56:37.172, Speaker A: You can create your own verifier with Cairo. Right. It's a smart contract. It actually exists. There are stacks verifier, there are different stack verifiers as well. So really you can implement your own layer three right now and not wait for a stackware or stagnate to evolve to the point that we make all these things the official verifier available on L2. Perfect.
00:56:37.306 - 00:56:45.690, Speaker B: Also, Sephirne is asking can we expand more on Sierra? Sierra will be looking at sessions six. Right. David, more about.
00:56:48.140 - 00:57:14.800, Speaker A: I haven't, we haven't discussed exactly what's going to be covering the chapter, but probably yes. For now, just keep in mind that it's going to be an intermediate language. When you compile in your computer before you deploy, you no longer compile directly to Kyra assembly, you compile to Sierra and that's what you deploy to stagnet. And then on a stagnet, the signature compiles your Sierra bytecode to Kyra assembly code. Yeah.
00:57:14.870 - 00:57:28.550, Speaker B: This is a great invention. For those of you who want to, for example, do audits, security audits, learning Sierra will be key for you. It's very important. It's like learning jewel for layer one.
00:57:32.600 - 00:57:40.520, Speaker A: Yeah. More question. Go. Can you order by most of. Because I see some questions being unanswered. With four votes. Three votes.
00:57:41.340 - 00:58:06.396, Speaker B: Yeah, we're working on that. We have a lot of votes. So there's a question by Gleem. He's asking gleem, by the way, he's French, living in Mexico. Hey Glenn. So if the centralized started, the sequencer will be a full node and there will also be a full node that are not a sequence line, which means only sequences will participate to consensus. And all other full nodes are only relaying data to DAP or other nodes.
00:58:06.396 - 00:58:07.330, Speaker B: Is that correct?
00:58:13.830 - 00:58:49.454, Speaker A: Consensus. So how decentralized stagger is going to look like is a moving target? I don't have a clear answer. Of course, the first sequencer will be the first one to be decentralized. And it means that they need to reach consensus as any decentralized system do they need to be full node. I mean, sequencer will they need to store the current state of the network, right, as well as a full node. But a full node can exist independently from a sequencer. They don't have to be the same thing.
00:58:49.454 - 00:59:12.150, Speaker A: They can be independently. And I think that's the future. But they will probably share some modules, like right now. For example, if you use papyrus as a full node, it uses a module called glockifier that we are going to introduce also into the new sequencer that has been rewritten in rust. So they're going to share some of the same primitives for storing the state. But they are two different systems in the network.
00:59:13.230 - 00:59:17.674, Speaker B: Also we have like clients, right? Like bureaus being built also by the community.
00:59:17.872 - 00:59:38.240, Speaker A: We also have beerus, which is inspired by. I forgot the name of the other, not Horus. Forgot that there's a like line developed by a 16 z for Ethereum that we're using to build Horus on top of that, which I forgot the name.
00:59:40.210 - 00:59:51.940, Speaker B: Also worth mentioning that Francois, thank you very much. He has been answering a lot of questions. So thank you very much, Francois. What else can we do? Start with caution to reduce the proof size like the Mina protocol with.
00:59:54.710 - 01:00:03.386, Speaker A: A. Ok, can we, do we do, do the sharp. Manmad, go ahead please, you can answer that. Yeah, so I was just going to.
01:00:03.408 - 01:00:33.700, Speaker C: Say, initially we generate one proof object per computation, but then basically whilst we're still in the off chain environment, we batch those proofs together and keep on generating smaller proofs for a certain period of time. And only at the end of that period of time do we send the one really sort of like root proof down to Ethereum layer one. So in that way we're actually getting hundreds of thousands of transactions through one proof object.
01:00:35.190 - 01:00:46.006, Speaker A: Yeah. On session four, when we go deeper into standard architecture, we're going to look at how the proverb achieves recursion. All right, sorry, let me move on.
01:00:46.028 - 01:00:47.560, Speaker B: Because the time is.
01:00:50.170 - 01:01:40.040, Speaker A: If we have time at the end, we will go back to see some of this question, but please try to answer some of them directly on the Q A. So some of the tools that you should have if you want to get into Starnet, first of all it's a wallet and there are two main ones. You have Argentx and you have Bravos. Argentx they have a browser extension, as you can see, for Google Chrome, for brave, for Firefox, Bravos the same also a browser extension, but Bravos also has a mobile wallet, which is very interesting, how they implement that and how they use account abstraction. So pick the one you like the most and make sure that you have installed in your browser so you can follow along some of the exercises. We have two different block explorers, welcome Voyager and the other one called Stark scan. Both are great options, so pick the one you like the most.
01:01:40.040 - 01:02:35.590, Speaker A: And we have some tools for developers. One of them is Protostar, which right now I actually was thinking about removing Protostar for now because it's definitely a full rewrite of how protostar works with Cara, one using a thing called Scarb. So maybe put that on ice in the meantime. But just know that there's a tool similar to foundry on Ethereum so you can test your smart contract using the same language that used to program the smart contract, in this case Cairo. And also we have collaboration with open sepling that they actually develop smart contracts for Cairo, always on the best practices for ESC 27, 21 and so forth. Other tools that we have available, we have a plugin for hardhut if you want to test using javascript. We have a definite similar to Ganache as well if you want to run it locally.
01:02:35.590 - 01:03:12.978, Speaker A: We have a library for react, for your decentralized app, we have different SDKs for different languages, for typescript or JavaScript, for Python, for Java kodu and scala and for iOS. So whatever you're building, we have an SDK for that. Many of them right now are going through the process of upgrading to support Cairo one, so just be mindful of that. All right, so let's take a break. Ten minutes. We have ten minutes. What do we have? Let's have, sorry, five minutes, because we're going to jump into the live coding session.
01:03:12.978 - 01:04:02.894, Speaker A: So just have washroom breaks and get some coffee and we'll get back in five minutes. Sorry, I'm just going to mute myself and turn on the camera and I'll be back in a moment. All right, so let's go and set up a dev environment for Kyra one. So first of all, just a warning, we are going to be using a lot of tools, we're very new, so we're going to be living on the edge, which means that some of these toolings are still rough around the edges. So we have two main repositories that we're going to use. One's called Cairo Lang, which is written in Python is where we have the starnet Cli and where we have the Cairo zero to Cairo assembly compiler. It's just like the old compiler but it still has the starnet CLi.
01:04:02.894 - 01:04:45.598, Speaker A: And then we have the Cairo repo without the Lang, which that's where we have the Cairo one compiler, the compiler to Sierra. And then also we have a compiler from Sierra to chasm. And I'm going to go into detail why we have two different compilers. I'm going to explain that in section four, I think, but this one is written in rust, not in Python, and it also has a vs code extension that we can use, but we're going to have to build it from source so you can have some syntax completion and validation as well. So we're going to need three main languages for setting up this dev environment. As I mentioned, this is going to simplify as time goes by, but for now we're going with three. We're going to need rust to compile the Cara one compilers.
01:04:45.598 - 01:05:33.170, Speaker A: And I know it's a mouthful, but that's what we need to do. And also to compile the vs code extension, because right now it's not yet published to a marketplace. We're going to need Python, especially, particularly 3.9, to create an account so we can deploy and declare all these things and invoke to use the start CLI because the Cairo line where the CLI lives is written in Python and we also needed to, sorry to declare to deploy and to invoke transactions on a starnet. Finally, we need node js for packaging the vs code extension before we can actually install it on our IDE. So this is the plan for the coding part. Hopefully you can follow along, but we have the instructions shared for you here at the bottom.
01:05:33.170 - 01:05:55.702, Speaker A: So first we're going to compile caro one from source. Then we're going to test that the compiler is actually working by compiling a simple smart contract. Car one smart contract. Then we're going to install the Vs code extension for car one. Then we're going to install the starnet CLI. We're going to create a user account locally your computer. So then you can declare an example of smart contract.
01:05:55.702 - 01:07:06.130, Speaker A: You can deploy it to starnet Testnet and then interact with it using block Explorer and a regular wallet. So you have two links here at the bottom. I'm using the guide today, but in the starting book we also have steps for performing this as well. Okay, I'm going to start a virtual machine so we can follow the steps from the beginning, basically. So let me see, give me a sec to start this untu, do this cleanstall and start. Just a moment while the VM starts and I log in. Share the screen in a moment.
01:07:06.130 - 01:07:36.090, Speaker A: Okay, I'm in and I'm going to follow my guidelines here. Sorry guys, I just tried to set up my computer here with all the things that I need or I can start doing live coding. Perfect.
01:07:40.220 - 01:07:41.980, Speaker B: Wait. In the meantime.
01:07:42.320 - 01:08:06.960, Speaker A: Cool, I'll be ready. So as I mentioned, I have a clean installation of an Ubuntu machine. The instructions for macOS are very similar. In the guide I put whenever there's a small difference, I put there comment, like an if else kind of blog. So the first step is to install rust. So to install rust, you basically you follow the official instructions of how to install it. We want the release version of Rust.
01:08:06.960 - 01:08:46.544, Speaker A: Why it came like that. We need to use curl to get it. Let's see, how can I increase the font size of this? I'm just going to proceed with the installation. How is the font size? Not that good. If you can zoom in. Yeah. Join email size, columns, rows, custom fonts here.
01:08:46.544 - 01:09:04.440, Speaker A: Already change it. Custom fonts can increase it to a thing. Better now? Yes, looking better.
01:09:05.050 - 01:09:09.800, Speaker B: What do you think, guys? They say it's okay. Perfect. Thank you very much.
01:09:11.610 - 01:09:47.540, Speaker A: Make a little smaller. Okay. All right, cool. So I have rosk installed. It asks you to activate some things on your shell. So you can just run this source or you can just close the terminal which you're going to do, and open a new one so the configuration takes place. And just to verify that rust is installed, at least rust up, do this rust up version and yes, so we have version 1.25.2
01:09:47.540 - 01:10:34.510, Speaker A: so rust installed. As I mentioned, we need rust to compile the car one compiler from source. So the next step is to actually download or clone the repo where the compiler for car one lives. So I have this command here what I copy. All right, so this is the repo where the Cairo one compiler lives. I'm going to clone it to a specific folder on my home directory just called Cairo. I just want to have a particular location that I can always go back to because we're going to have to do some mapping of the binaries.
01:10:34.510 - 01:11:12.590, Speaker A: That's why I put it here. So after toilet we should have it in the Cairo folder. So if I come here, so we have here in the repository for Cairo one. So we need to activate a very particular tag, the latest tag available in the repo because that's the compiler that was used or supported right now by stagnet. So we need to make sure that we use the same. So this is why we enable or activate this particular tag, which is the latest tag on this repository tag version one point alpha six. Right.
01:11:12.590 - 01:11:28.900, Speaker A: So we are in detached mode in this particular commit of the car one repo. So now we can actually build all the binaries using cargo using this command. I'm sorry, I went a little too fast just because.
01:11:32.310 - 01:11:34.318, Speaker B: Rajiv and also former.
01:11:34.334 - 01:11:51.020, Speaker A: Memory are asking if we can share the commands. Yeah, in the slides which I share with you. At the bottom of the last slide where I have the live coding plan. You see the reference, let me just put it here.
01:11:53.630 - 01:11:56.780, Speaker B: You can share again the link to the slides wp code.
01:11:58.770 - 01:12:11.650, Speaker A: Okay. Link to the slides, publish the web. These are the links. Where do I put it? In the chat?
01:12:15.310 - 01:12:16.790, Speaker B: Yes please, in the chat.
01:12:16.950 - 01:12:49.620, Speaker A: Okay, so I put in the chat, the link to the slides. And if you go to this last slide before let's start the setup, you see a link to the guide. I share this link to you. This is the steps that I'm following basically that you don't see on the screen, just using a secondary screen, but you also have this target book as a guide. This is exactly what I'm following in this session. You shouldn't see it. Cool, thank you Eddie.
01:12:49.620 - 01:13:05.530, Speaker A: All right, so going back here. Just a sec. I'm setting up again my environment.
01:13:12.160 - 01:13:14.092, Speaker B: I should do chat.
01:13:14.156 - 01:13:15.776, Speaker A: The link to the starnet book where.
01:13:15.798 - 01:13:24.016, Speaker B: You can also see the commands. Please bear in mind that the starnet book is very, we're working on that, but that part is finished.
01:13:24.208 - 01:13:26.100, Speaker A: Could you share that link, Omar?
01:13:27.720 - 01:13:29.092, Speaker B: I will share the link right now.
01:13:29.146 - 01:13:29.364, Speaker A: Okay.
01:13:29.402 - 01:13:30.870, Speaker B: Link to the starnet book.
01:13:31.240 - 01:13:52.856, Speaker A: All right, so next step is to actually build the binaries, right, using cargo build, and we use the release version of Rust. We don't want to use the latest or the edge. It's going to take a while, so it's a perfect time to answer some questions. Perfect. So let's see, when will the mainnet.
01:13:52.888 - 01:13:59.596, Speaker B: Support kernel one by Michael, it's live.
01:13:59.698 - 01:14:04.270, Speaker A: It is supported already. You can deploy. Right.
01:14:04.640 - 01:14:13.456, Speaker B: There's that problem that keeps getting with. Okay. It's a particular problem. I will look at it. Okay, so we're really sure that man, thank you very much, crypto nerd and.
01:14:13.478 - 01:14:14.320, Speaker A: Radif.
01:14:16.280 - 01:14:43.784, Speaker B: In terms of energy consumption from Ramsey, from carbonal Ramsey, we're looking at that particular question. We don't know. Right. But Manmit already asked internally to see if we can get an answer as soon as possible. Ramsey, thank you very much for that. What are the benefits of the caravirtual machine versus serial node tvms? They have to be strong for DSL to win with solidity team. And thank you very much, Paul Henry, he answered that the UM is very specifically used by Starnet.
01:14:43.784 - 01:15:36.936, Speaker B: Yes, exactly. And the benefits is that again, that Cairo is focusing only on scalability and this is something that the terror petrol machine is not focusing on. They focus on other stuff like decentralization, which is very relevant. But the Cairo has the only goal of scaling Ethereum, so that allows to do certain kind of stuff that make us scale without having to follow all the rules of the EVM which that are done for different purposes. So the cargo virtual machine should be able to allow for more scalability. That will be the main benefit. I don't know if you see any questions you want to answer right now, David, which one? Sorry for answering this a little bit late.
01:15:36.936 - 01:16:12.840, Speaker B: We have a lot of questions, so tal is asking. Most products will probably be attracted to zero chains because they are already a bunch of solidity types. How easy will it be to transpile solidity to Cairo in the future? Is it better for projects to transpile or to create native on Starnet? And if you allow me, David, let me quote here again. Eleven. Sasson, founder of the Starks, inventor of the Starks, founder of Star wars, he said that indeed we will have actually a serial GBM. Danilo is leading that development it is called Kakaot, which Francois already shared. Thank you very much Francois.
01:16:12.840 - 01:16:54.836, Speaker B: But Ellie said our focus here is to scale code using Cairo. So the real scale is going to be coming from Cairo, not from transpilers like the one we have. Warp will be transpiling solid code into Cairo. However, building native Cairo code will be the real power of stone. So indeed there's a lot of developers already for solidity, but we think that developers can easily adapt. So most of you, I think, you know at least two different languages, I don't know, maybe Python and JavaScript or something like. So we would really believe that developers will have no problem learning Carol, aside from solving.
01:16:55.028 - 01:17:31.216, Speaker A: Also keep in mind that standard gives you way more resources for executing transaction. That's possible on the limitation of a gas fees on layer one. So that allows you to create more interesting applications. You can actually create things that are not possible at all to create on layer one. So do you actually want to just transpile your contract as is? You're going to be missing a lot of interesting features. For example, account abstraction that exists technically on l one now. But it's a little confusing because there's three different ways to have an account on layer one, on L2, and starting it.
01:17:31.216 - 01:17:47.370, Speaker A: Everything is smart contract, everything is using account abstraction or smart wallets. So really the idea is that when you have a different environment with different constraints or less constraints, you probably don't want to just rewrite the smart contract exactly the same way as in layer one.
01:17:49.260 - 01:18:42.392, Speaker B: And it's worth mentioning that any serial knowledge project following the terrible virtual machine like the CKE evms will have the same constraints as the EVM, that being a construction, for example. Okay, do you guys know any open source project that have migrated fully to Cairo so that I can work to their code? Let me share you the link to the starnet Cairo 101 which you can already do. It's called as migrate to Kyle once I guess also end to end testing. I don't know if we have a project already doing end to end testing. So there are a lot of projects migrate to kerr one, but they are doing it maybe not open source or experiment behind the scene. Also argent I think will have soon their code kerr one. So that will be very good.
01:18:42.392 - 01:19:04.080, Speaker B: But in the meantime I will share to you start Kero 101 tutorials. Those are very good for you to understand how to structure your code. If you want to learn Cairo code, you can learn with it, but it is also very useful to learn the syntax and the way to structure your project. So I will show it to you in the chats.
01:19:06.900 - 01:19:17.510, Speaker A: Compilation is taking a while. It's pretty intensive. And also it's a virtual machine. It's not my host machine, so has limited resources. But we're getting perfect. Perfect.
01:19:18.840 - 01:19:28.730, Speaker B: Okay, so DV is asking why not both decentralization and scalability start disoriented more to the second one, but I don't see the trade off to live in the first one.
01:19:30.700 - 01:19:31.528, Speaker A: Yes, sure.
01:19:31.614 - 01:19:58.640, Speaker B: Well, correct me if I'm wrong here, manmade and David, but start that is having both the decentralization from ethereum and the scalabic that is provided. Plus we will have decentralization. There's no L2 that is decentralized right now. Actually, we're working on that. We're working on deciding how we have centralization so we can decentralize the use of sequencers and so on. But I don't know, David, if you want to add something to this bonnet.
01:19:58.980 - 01:20:21.160, Speaker A: The goal is to decentralize everything right? It's a hard problem to solve. It took Ethereum a long time to do it right. It will take us a while also to do it right. So we need to approach it first. Let's see that the technology works, that we can scale, and then we can decentralize. You have to tackle some big challenges once at a time to do it right. But that's the goal, to have it completely decentralized.
01:20:21.160 - 01:20:27.290, Speaker A: Okay, any other question?
01:20:31.580 - 01:20:45.180, Speaker B: Wow, we have a lot of wins in today. That is great. Thank you very much for coming. Very happy to have you here. I think those are all the questions that we can answer. Lives we did. Oh, there's a question from Leo.
01:20:45.180 - 01:20:55.860, Speaker B: What are the most interesting use cases you are seeing of on chain apps that will benefit from being able to access more compute? Banmet is answering right now. Do you want to answer live manmit?
01:20:58.760 - 01:21:28.396, Speaker C: Yeah, just like the hats are dropped in the chat. One of the most exciting things that I've been seeing out here in San Francisco is the new push towards zkai. Because AI and machine learning models are inherently very computationally intensive. So being able to prove inferences so people don't have to run them all over again is actually quite a powerful thing. That's one thing off the top of my head, other than the obvious scalability.
01:21:28.588 - 01:21:54.330, Speaker A: To also, if you have to follow along, going back to the previous question about digitalization, you can go to the stagnet forum that I put it on the chat link where we actually post our thoughts and ideas of how do we want to decentralize starnet you can follow the discussion there in the proposal and you can comment perfect.
01:21:59.500 - 01:22:30.210, Speaker B: Anything you want to add. David, regarding star again, if you want to share your discord in the chat so we can add you to the group, we have a discord in case you haven't been added yet, please put your discord there. Also join the telegram community where it's also useful for in order to plan meetups. If you want to do some in your cities or you want to talk with us, you have any questions, please let us know there.
01:22:31.860 - 01:23:20.324, Speaker A: All right, good news, it's finished compiling so we can move to the next step. Just clear the terminal here. So now that we have the car one compiler compiled, we want to add these binaries to our path so we can execute this binary from any place in our file system. So an easy way to do it is just by adding to our configuration file for our shell. In this case I'm using CSH, might be using bash, so just modify this depending of your terminal. If you're using bash it will be bash Rc just basically adding the path where we compile where the compiled version of the car one compiler lives to our path. So once we're done I'm going to just close terminal and open again.
01:23:20.324 - 01:24:01.792, Speaker A: So the changes takes place and we're able to find the binaries. So if this goes well we should be able to call the starnet compiler just to see the version and what is opening. Standard compile not compiler and there you go. So we have the binary ready. The binary is added to our path so we can use it to compile or car one smart contracts to Sierra. So let's test that the compiler actually works. So I'm going to create a folder just like a sample project.
01:24:01.792 - 01:24:46.750, Speaker A: We're just going to put a very simple smart contract and try to compile that. So I'm just going to call this folder when I get into it and in here just going to create just like a test folder and I'm going to create two folders just for usually I like to have one for where my source smart contract is and where the compiler folder. So I'm just going to call the compiler folder Sierra. So this is how my sample project looks like and I'm going to create a file for my sample smart contract inside of source. Call it example Cairo. Okay, so I put the tree again, I should see the file. So let me open this with vs code.
01:24:46.750 - 01:24:55.976, Speaker A: David, a quick question.
01:24:56.078 - 01:25:00.200, Speaker B: Is there some kind of prettier or eslint for Kyo?
01:25:01.340 - 01:25:27.392, Speaker A: Prettier or Eslint. The closest will be this extension that we can install, but it's not exactly as prettier because prettier is a formatter. So I will say not yet. Something that linked the extension will work similarly, but not like prettier that actually formats when you save or something like that when you execute it, how do you increase the font size?
01:25:27.446 - 01:25:28.224, Speaker B: Thank you.
01:25:28.422 - 01:26:02.670, Speaker A: Okay, here you go. I'm just going to put a very simple smart contract, right. Basically we use this macro contract and then we create a module. It's called simple storage for now. Today is not the goal to learn cara one just to make sure the tooling is working. As you can see we don't have any syntax highlighting or tooling or anything because we haven't done yet the work of installed extension. But we have the smart contract so let's try to compile it.
01:26:02.670 - 01:26:27.060, Speaker A: So here I can just do Instagnet compile and I provide the file example Cairo and then the output and it's going to be a JSON file the output. So it worked. Our compiler is working. This is how the Sierra looks like with this very simple smart contract.
01:26:27.960 - 01:26:28.372, Speaker B: Good.
01:26:28.426 - 01:27:10.916, Speaker A: So we have confirmation that the compiler is working. Now the compiler for Cairo one next step will be to actually install the vs code extension and the source code for that extension. Actually it's inside of the Cairo one repo. So let's go back to that repo that we store in Cairo and we have here a folder called vs code Cairo that we're going to get into it, right? All right, we're in the right folder. So first of all we're going to need to have node JS installed. So in the case of Ubuntu, a simple way to install it will be with this command. There are multiple ways to install this.
01:27:10.916 - 01:27:51.350, Speaker A: I'm just going to use this to get the latest node version 19. Let me just expand this more. It's going to work. Let's see. So in theory now I can do pseudo apt update where I trying to install it. So now I can actually try to install node js. Let's see.
01:27:51.350 - 01:28:39.988, Speaker A: Okay, so if it works well I should be able to do node and version. And yes we have node version 19, the latest one installed on the computer. So we're good to actually now compile the extension or just, well when you use a Javascript you don't really compile. Let's say you package it somehow. So first of all we need to have install a global package called vs code ESE. So this is what you do for compiler extensions. So install it globally.
01:28:39.988 - 01:28:44.890, Speaker A: It's under this name ESE. This is provided by vs code.
01:28:50.200 - 01:28:59.624, Speaker B: So remember everything is being recorded and will be up in YouTube. So you will be able to send you an email with the link so you can review everything that we're doing right now.
01:28:59.742 - 01:29:48.370, Speaker A: Yeah, and the guy that I'm following also we have shared with you the link. So exactly what I'm doing is just documenting in a nice document there you can follow along. Okay, so now let's install dependencies for Javascript with NPm install. Remember inside of the vs code Cairo with the extension leads. Okay, let me just update my npm just in case this is suggesting me to do copy paste. Oh, I need to do pseudo. This is just optional.
01:29:48.370 - 01:30:33.716, Speaker A: All right, so now I can actually package the extension previous to be able to be installed using this command package that we install this binary globally from NPM. Now we can use it here. This is just a temporary measure. Eventually the extension is going to be published to the marketplace and you will get it directly from vs code without having to do that. But remember we're living at the edge. So this is how it needs to be done right now. So now we have the package, we can actually install it, install it to vs code with this command, right? Solid extension.
01:30:33.716 - 01:31:18.596, Speaker A: This is the file that we just created. Now we go ahead and in theory should be installed. So let's try, right, so if I open the extension here, okay, I can see that it is now installed. Car one is called extension, but we need to be configured because it's asking for where's the path for this particular binary, the Cairo language server. This is one of the binaries that we compiled from using rust from source. So we need to provide this path. And to provide that path, let's go back to, that's going to be the target release.
01:31:18.596 - 01:32:09.522, Speaker A: Let me just go back here to target. This is where all the binaries are placed. This is my absolute, let's say path to it. Just going to copy this, going to put it here and with the name of the binary and I think you need to probably close this and turn it on again. So it takes, let me close the Vs code and oops, I need to go back to my workflow or maybe just open here and it's not taking, okay, now it's work. Now I get syntax highlighting and it's going to complain, do some things wrong, like in this case, right. So it's a nice Helper when you write carawan code.
01:32:09.522 - 01:32:15.842, Speaker A: So cool. So we have the Vs code extension working? Yes, Omar, sorry.
01:32:15.896 - 01:32:40.810, Speaker B: It's worth mentioning that as David said, I want to repeat that we are not learning Cairo right now, but we will do, and we will have the chapter of the book ready for in a couple of days. So you can start learning Cairo by yourself and then we can come here and already with more knowledge of Cairo and we'll also teach you some Cairo and also we have some tutorials like starlinks. We will share in a minute. So you can start also learning Cairo.
01:32:41.150 - 01:33:04.270, Speaker A: Yeah, today is just about the dev environment, not really about Cairo, but let me put a little more complex Cairo code here because we actually want to deploy it today. Oh my God. Paste. Yeah. All right. Again, I'm not going to really explain how this works. We're going to talk more about Cairo in future sessions.
01:33:04.270 - 01:33:32.170, Speaker A: I just want to make sure that we can compile this and we can deploy it to stagnate. So let me just recompile this we did before you ever go back to. Oh my God. Okay, so we're going to copy this. All right, copy it. Can I paste it here? No. Anyway, stack net compile.
01:33:32.170 - 01:34:11.152, Speaker A: Okay, so we compiling the new version of the smart contract. So this will be a little more complex now as we can see here. Right, way more complex. So this is the code that we actually deployed to starnet that we give to the sequencer, the Sierra smart contracts. Okay, so let's keep moving on the next step now, because to interact with the Stargate, we used to use the stagnant ClI. The stagnate Cli is written in Python. So we need to have Python 3.9
01:34:11.152 - 01:35:00.740, Speaker A: in particular to be installed in our system. So to install a very particular version of Python, at least on Ubuntu, you will need a particular PPA, this one here every time. So I add this repository to my apt. It's because we need Python 3.9, we stall Python three point ten. It might not work. Now I do update references and I'm ready to install Python 3.9
01:35:00.740 - 01:35:40.220, Speaker A: using these two packages, especially for development because we also need to have virtual environments. Thanks a little bit. If it all went well, we should have now Python 3.9 installed version. Yeah, there it is. You do have it. So now let's actually install the Cairo Cli.
01:35:40.220 - 01:36:25.380, Speaker A: So to use the Cairo ClI to install it, we need to have one global dependency called GMP, so you can use this command to install it. This is required for the stagnant ClI, not the stagnat Cli. You need this global dependency. Now let's go back to our project that we were working on. Call it Stagnet test. We're back to our project and I'm going to create a virtual machine here for a virtual environment for Python. So when I sold packages, I don't want to install it globally, just want to solve it per project.
01:36:25.380 - 01:37:05.950, Speaker A: So to do that, you do this command, you define that you want a virtual environment and then you give it a name. I'm just going to call Cairo. Right? Then you activate that virtual environment so you can start installing. It's called Cairo. Cairo bin activate. So as you can see now we're inside of the Python virtual environment, so we can stall the Caroline package. Just before I do that, I'm just going to upgrade Pip to the latest version just to be safe.
01:37:05.950 - 01:37:50.412, Speaker A: And now I can actually install Carolang pip install, which is going to give you the starting it. And it's installed for this particular project. It's not installed globally. If you are on a Mac, this might fail. I put some instructions on the guide, was the alternative command that you can run on a Mac, because happened to me that it failed. So I found a solution. It's a more complex command, but it works all right.
01:37:50.412 - 01:38:22.880, Speaker A: So if this is working, so we should be able to execute the binary called Stagnet, which is the one used by the CLI. And there we have it. We have zero point 11.0.2. Perfect. So what uses the start CLi? In every command you will have to define to which network you want to deploy or interact. You use that with flags, and also you need to define which type of wallet. Remember that on starnet, every wallet is a smart contract.
01:38:22.880 - 01:39:19.244, Speaker A: And you have to define to the CLI how the smart contract looks like and how the smart contract is able to verify signatures. So to be a little bit easier for now and not go too much into detail until we get to those sections, I'm going to define two environmental variables on my shell that the standard CLI is going to use and going to make our comments look a little bit simpler. So let me open my profile configuration. McKaychrc. What open right now, go to the bottom and I'm going to add two environmental variables. One is to tell every time that I run a starting command that always targets the testnet alpha girly instead of mainet. Right.
01:39:19.244 - 01:40:02.164, Speaker A: I don't want to spend money right now and also to tell them because it's a kind abstraction, which type of wallet I want to use to sign transactions. So using this one here. So this would be export as well. It's not export, export, blah, blah, blah. It's using an average of the open sippling wallet. Okay, this looks good. So I should be able now if I close my terminal and then open it again, should be able to access these environmental variables.
01:40:02.164 - 01:40:35.220, Speaker A: I do echo network. There you go. So it's installed, it's available on our shell. So now next step, before we can deploy anything, we need to create a user account in our computer because we need to pay for declarations and deployments. So let's go back to our project for now. Stucknet test. Let me activate again the virtual environment for Python.
01:40:35.220 - 01:41:41.448, Speaker A: Activate because the starting CLI is only available in this python virtual environment. So create the new account, at least to get the address of our user account. We use this command, the stagnate new account, and we give it a name here. So using the staggering CLI to create a new account in my computer, and I'm going to give it a name, the zero point 11.0.2, so I can add different wallets once the network keeps upgrading. So by doing that, it's not going to create the user account yet, it's just going to give me the address because the address is always, it can be known before you deploy because it's just an algorithm that will be always the same. So this is going to be the address of my user account while I deploy it.
01:41:41.448 - 01:42:18.630, Speaker A: So I'm just going to copy this one here. And the next step is just, I need to send test eth to this account. I need to fund my wallet even before the wallet exists on chain. This is called the counterfactual deployment, I think it's called. This is a common feature when you have a kind of abstraction. So I'm going to send a small amount of eth to this address. So let me open, I think I should have a wallet here in this vm that I could use.
01:42:18.630 - 01:43:06.284, Speaker A: Maybe I don't. Yeah, I have to send it from my. So let me just bring this up, give me a second to unlock my wallet without sharing my key or anything. Just a second. All right. Okay, so as you can see I have bravos here another account which already has some test if on Gurley. So I'm just going to send some test if there.
01:43:06.284 - 01:43:33.672, Speaker A: So I need just to copy the address and from here just going to send some amount. Let's send 0.5 test eth. So I'm using bravos. It says that it doesn't exist on chain, which is fine. This is the counterfactual deployment. We're going to talk more about that when we talk about account abstraction in future sessions.
01:43:33.672 - 01:44:03.670, Speaker A: For now, just follow along. All right, so I've sent a transaction to starnet testnet using my wallet. I can follow a lot of transaction here on a block explorer, so we need to wait until the transaction gets at least to the pending state before we can continue. So I think right now on testnet blocks are produced every three minutes if I'm not mistaken. That's why you see the counter. So let's wait a little bit. Let me increase the font size so you can see better.
01:44:03.670 - 01:44:31.790, Speaker A: So once we get to the pending state, it means that I have the funds available on that particular wallet and I can continue with actually the on chain deployment of my user account. Again, this is a feature of account abstraction. Hopefully we can make it easier for you in the future with tools like scarp that we haven't talked about it yet. Questions in the meantime, Omar, or people just post questions?
01:44:33.280 - 01:44:43.570, Speaker B: We don't have a lot of questions. We have a question from Michael. Sorry Michael for the late reply, he's having some trouble compiling. There are a couple of questions for you.
01:44:45.540 - 01:44:46.770, Speaker A: Are you using.
01:44:48.580 - 01:45:13.660, Speaker B: A log local Michael? And the second question is are you using what version of the compiler, can you check version please? Or if you're using Scarp let us know. Scarp is using the newest compiler version because I think there's a problem with that part. Okay. Dimitri is asking, it would be nice opportunity to showcase faucets.
01:45:15.200 - 01:45:45.430, Speaker A: Oh, it's a good point, yes. In this case I'm sending ether from another account that I have. But you can actually use a faucet. Where is it? Tools faucet. There you go. I'm going to put it in the chat link to the faucet where you just put your address and it will give you some amount of it. The faucet has the limitation that it has a limit of how much test if it can give you every ten minutes.
01:45:45.430 - 01:46:06.460, Speaker A: So if I try to use it now, I'm going to say oh, you have to wait ten minutes and I don't have time to wait ten minutes, that's why I went the other way. But if you are more patient you can use it this way you will get some test if on your address. Okay, so now that we have. Yeah, Omar, go ahead, sorry David here gleam is.
01:46:06.610 - 01:46:11.710, Speaker B: Okay, go ahead. Gleam is mentioning something very important in the chat, but we can go ahead and mention it later.
01:46:12.080 - 01:47:35.802, Speaker A: Okay, so now that I have test, if associated with this address, I'm actually going to deploy my user account, which is a smart contract to this address. So let me get back to my notes, putting my secondary, okay, so to deploy my user account, just clear the screen here, I use this command. So again you see the standard CLI, now you see the deploy account command always using this particular account that I created before the one that we know the address. So if I do that, it's going to actually deploy my user account to testnet. And you can see, so it says the deploy account contract transaction. So we can follow along the transaction using this hash on stock scan, stock scan value testnet. Put here the transaction hash because we need to wait until it gets to at least the pending state.
01:47:35.802 - 01:48:10.094, Speaker A: That's when we know that it's ready to be used. Because what we really want to do is to deploy the Cairo one smart contracts that I showed you before that we have in vs code. Okay, so it's on the pending state. So now we technically have now a user account that we can use to deploy and to invoke transactions. Cool. Let me just clear here and let's go back now. So before we can deploy a smart contract on a standard, you have to first declare it.
01:48:10.094 - 01:48:57.070, Speaker A: The reasons we're going to explain it in the next session, but for now we're going to execute this command, just going to try to explain what it does. So basically it's going to upload our Sierra, the Sierra code of a smart contract using this account to pay for fees, for gas fees. And declaring is the previous step before you can deploy because on a stack you can deploy multiple instances of the same declared code. We're going to talk more about that when we go to a con abstraction. For now, just follow along. So when we try to execute this, send this transaction to testnet, it's going to fail because this smart contract was deployed, was declared before actually by me. So it should tell me there's an error.
01:48:57.070 - 01:49:20.460, Speaker A: Yes, the error is that says the class hash, blah blah blah blah is already declared. Right. And that's what I was expecting. That's fine. It means that I can just go directly to the deploy. I don't have to declare, but because sometimes you don't know, it's better to just try to declare and see if it fails and you can move to the deployment. So.
01:49:20.460 - 01:50:26.700, Speaker A: Oh wait, did I copy? What was the address that I used the address of my account. Just a sec. Try to find out which addresses, send the account location, number, transition center address. Sorry, just a moment. All right. Yeah, I forgot to take note of what was the address of our user account, but now I have it because we need to send the deploy transaction. Let me try again at the declare, because I need to take note of the class hash, which I didn't do before.
01:50:29.150 - 01:50:43.250, Speaker B: So some people are having trouble using the post set. So it's very understandable we are sending you or David. Do we have a method to send it without using the faucet? Right now?
01:50:43.400 - 01:50:49.730, Speaker A: Not right now. There's something right now how to do better, because we know the faucet has the limitation.
01:50:51.030 - 01:50:53.602, Speaker B: We have a lot of people right now asking for.
01:50:53.736 - 01:51:39.368, Speaker A: Yeah, that's why we kind of knew, but it's hard to get around. Hopefully that's one of the things that we need to improve for next time we do base camp for sure. So to deploy the smart contract, we need to provide the class hash that is provided here in the previous account. I'm just going to remove this because this is a previous thing that I did comment, and the class hash is here. And with this we should be able to deploy our smart contract. Okay, so the transaction was sent for deploying our smart contract. We can follow along here.
01:51:39.368 - 01:52:21.030, Speaker A: I need to remember to not delete anything from the terminal because I need those addresses. Paste, paste, sure. Okay, so this is transactions to deploy the smart contract that we wrote in Cairo, one. So we need to wait until it gets to the pending state before we can actually start interacting with it. So let's wait a couple of seconds. There any question in the meantime, Omar?
01:52:23.370 - 01:52:51.410, Speaker B: No. Michael is asking, will there be a roast based Cli? And the answer is yes, there would be. It will be soon. But don't worry, depend on what is going to be working and it's going to be the same. Also a lot of people are asking for it. Maybe Mahmit if you have some it and you can help me send to Thomas, please. That would be great.
01:52:51.410 - 01:53:06.538, Speaker B: In the meantime, let you know that all the transactions that I made, I send you the date and you should be able to find it. Now you can deploy your wallet because the transactions were successful. So you can deploy your accounts.
01:53:06.734 - 01:53:42.834, Speaker A: Yeah. So our smart contract has been deployed, so we can actually now interact with it, because we know the address, this one. And you can see first of all there is a Carawan smart contract. And we can go to the read write section. And if we compare to our code, you can see that our smart contract had two functions, one to increase balance and one to get balance. This is read only, this is for modify the state. And if you see, in this explorer, you see the get balance right now it's going to be zero because it has no value.
01:53:42.834 - 01:53:59.750, Speaker A: But we can actually use the right to increase it. I'm just going to connect the wallet. Wait a second. That's one thing that I didn't prepare for to install a wallet here. So let me just do it on my Mac copy.
01:54:02.330 - 01:54:29.246, Speaker B: While let me explain this. Rafael is asking, can we bridge barely eat to Starnet? Yes, we can. You can get some eats, for example, using a faucet. Remember the name paradigm has a faucet that can give you girly eats to layer one. So you can send it to your metamask account, for example. And then from there, you can breach it using the bridge. I will send you the link in the chat and you can breach it to the.
01:54:29.246 - 01:54:47.990, Speaker B: Actually, Clement already shared the bridge. Thank you very much. Clement. Stargate, starnet IO. It is on the chat. So you can use that to bridge to connect your metamask account to your parabolos or Arian account, and then you can bridge that to your account. So it is relatively simple.
01:54:47.990 - 01:54:48.680, Speaker B: Yes.
01:54:51.290 - 01:54:56.310, Speaker A: Sorry, just going to. We can go back to questions after. Perfect.
01:54:56.460 - 01:55:07.030, Speaker B: Just something real quick. So I think some people might be leaving right now because of the time. So is there any question? Sorry, what is the homework? Is there any homework?
01:55:07.190 - 01:55:09.738, Speaker A: We'll send it in the email. We'll send an email with the instructions.
01:55:09.834 - 01:55:12.000, Speaker B: Okay, we'll send you an email. Thank you.
01:55:13.250 - 01:56:02.030, Speaker A: All right, so I'm just going to send the value ten to the increased balance used in my wallet when I sign this transaction. And we wait a little bit until it gets to pending state. So we should be able to do the read operation and see the value of ten coming back. So let's wait a little bit. Let me see what questions we have. When will the main net support Cara one? Okay, we answered that one. Are we sure, Omar, that is deployed to caro one, what's already Cairo one deployed to mainet because Michael is saying no.
01:56:02.100 - 01:56:12.820, Speaker B: It seems like it's a little bit more complex. A contract has to be tested for a while and then it can be uploaded to the main net. So we cannot do it right now.
01:56:13.290 - 01:56:26.470, Speaker A: Got you. I didn't know that transaction is about to get to the pending state, which a little bit, it means block.
01:56:27.230 - 01:56:55.300, Speaker B: While we wait for that, an anonymous attendee says king is having an error while deploying the account. It is called error code, uninitialized contract. It is likely because you haven't sent it to your account and then deploy the account. As David showed you first have to send to the address of your account date and then you can deploy it.
01:56:56.550 - 01:57:23.238, Speaker A: There you have it. Sorry, I thought you were finished. I query the balance again, now I get the value ten. So to confirm that actually our transaction went through and modified the state of the smart contract so now we can read the new value. So that concludes the tutorial to set up device. It's a long one, it's a complex one. Again, car one is fairly new, so hopefully just to do a brief summary, we had to install rust, Python and node js.
01:57:23.238 - 01:57:52.242, Speaker A: We compiled the car one binaries using rust. Then we configured those binaries to be available anywhere added to the path. Then we installed also Kyolang and we stole Python to be able to execute Kyolang. And we stole the VS code extension as well. So you get this nice syntax highlighting and some easy errors to spot there when you write. Thank you very much for staying so long. It was supposed to finish a while ago, but it took longer.
01:57:52.242 - 01:58:03.638, Speaker A: Hopefully it was useful. You have the guides there and you have more questions. Please use discord and hopefully you will be able to use the faucet eventually and get some test it. Yes.
01:58:03.724 - 01:58:38.270, Speaker B: Also, if some of you are not able to get some it, let us know please in the telegram. So I sent it to as much people as possible, but I run dry so I will need to recharge. But let us know in telegram please. I won't be able to store all your addresses right now, but send it to the telegram or bridge it. Thank you very much to Clement who helped us a lot in this. Also Glenn, thank you very much. And Glenn mentioned also something very important that you have to change your contract hash.
01:58:38.270 - 01:58:44.130, Speaker B: Okay, don't worry, we'll see the next time and we'll add it to the book. So thank you very much folks.
01:58:44.290 - 01:58:46.338, Speaker A: Thank you. Take care. See you next week. Bye.
