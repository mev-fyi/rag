00:00:07.450 - 00:00:46.778, Speaker A: Hello. Hello everybody. So, am I audible? Audible. All right, so we're going to talk the least and do the most number of code developments we can. So if you have a laptop, just open it because it's going to be a lot of fun. Hopefully, by the end of this particular workshop, you should be able to deploy a subgraph and understand what the graph does, which is basically indexing blockchain data. So what is basically indexing? Indexing means getting information which is already existing in the database in a more skewed format, so that you can get it for your own needs.
00:00:46.778 - 00:01:28.202, Speaker A: For example, there is so much data that exists in the world, right? But you just need data that is required for your particular application. For example, when you see an ethereum block, you should be able to see there is so much data that exists. In one particular ethereum block, there is MakerDAO transaction. In one particular ethereum block, there is uniswap transaction, in one particular ethereum block there is Aave transaction. And let's say you are a uniswap developer and you just need information about uniswap. How do you get that? That's what is indexing. So basically indexing information is that all the blockchain has all the data, but you just need information for your own needs.
00:01:28.202 - 00:02:12.790, Speaker A: And for that you need to create a middleware such as subgraphs, so that the smart contract which has all the data can get the information that is required to your UI using a middleware. And that middleware is called a subgraph. So in TLDR, a subgraph is basically a middleware which gets the information that exists on the blockchain for your own needs. And that's about it. So basically, this ethereum blockchain is converted to such simple databases which can be queried via GraphQL APIs. That's what is the graph. In one word, we can also say the graph is actually Google of web3.
00:02:12.790 - 00:02:48.194, Speaker A: In Google we have web two data. There is so much web two data that exists. But Google, if we just search ETH Tokyo, E Tokyo, it will only give me things that are related to ETH Tokyo. And the reason behind that is there is so much web data, but we just need information for our own needs. And that's where Google indexes all the web two data to give you what you need in the graph as well, there is so much web3 data. The blockchain data is basically open source. You can do whatever you want with it.
00:02:48.194 - 00:03:32.494, Speaker A: You can actually get in whatever information you need. But there is so much data, you just need information, let's say of all the arbitrage position that is between pancake swap and uniswap. For that, you just need to have your concentrated information on. For that, you will be creating your own subgraphs. So there are two ways to do it. The first way is you create your own indexer, burn the whole DAP, and that's how you create it that's normally the web3 way, but not the correct way. All right? There are better ways to actually get the information to your UI and that is by using this middleware known as a graph, by creating a subgraph so that you can get that information for your own needs.
00:03:32.494 - 00:04:01.414, Speaker A: So that's about it. I'll stop talking and let's code together. All right, I'll start from the very basics. We'll first of all deploy a smart contract and then we will create a subgraph out of that smart contract. Then I will do a transaction on that particular smart contract so that at the end you can see that that subgraph has indexed that particular smart contract and you can get the information you need for your smart contract. All right, let's do it. Let's go to remix.com.
00:04:01.414 - 00:04:43.138, Speaker A: If you have a laptop right now, just open it up and at the end, if you're able to create a subgraph with me, we have some exciting rewards which are different from Bounties. So first of all, I just create a subgraph, let's say an ERC 721, which is mintable. Okay? We create this remix subgraph, this smart contract. All right, we have the smart contract. Everybody has seen this ERC 721 NFT basic mintable smart contract. I've not created it. I've just gone to remix and just taken the code template.
00:04:43.138 - 00:05:22.638, Speaker A: So the smart contract is with us. Now what we do is just deploy it. Let me check that I am not on Ethereum main net, otherwise the workshop is very expensive for me. Okay, I'm on Gordy and I deploy this smart contract inject web3. Deploy the smart contract. Send transaction. Can somebody send me some Gorli eight? Send transaction.
00:05:22.638 - 00:05:47.932, Speaker A: Come on. Network is busy. Oh my God. Okay, let's do it on Sipolia, which is the new testnet. It's a live demo. Anything can happen. By the way, I wanted to make announcement right after the end that Sipolia is now on the graph.
00:05:47.932 - 00:06:17.870, Speaker A: But now, you know, I'll be deploying a smart contract on Sepolia and then doing a subgraph on that. So the big news is that the graph is now integrated with Sepolia chain and you can deploy your smart contracts on Sepolia. And we are going to do it right now. So let's just do it. This is Sepolia testnet. Hopefully this works. If this does not, then I am texting Ethereum Foundation that we need to talk.
00:06:17.870 - 00:07:16.344, Speaker A: Okay, so the smart contract is being deployed by then. What we do is we go on the graph studio. We go on the graph studio and basically just log in with our MetaMask. Once we have done that, I'll create a new subgraph and I'll name it Iris who's sitting right there, my colleague from the graph. And use Sipolia testnet, create a subgraph. So Iris subgraph which is Iris NFT, is having this kind of a UI which is a studio UI, right? And if you are new to the graph. The first thing you have to do is have the libraries installed globally so NPM install Graph CLI.
00:07:16.344 - 00:08:04.590, Speaker A: This is this particular thing that you have to deploy. Once you have that you will be on terminal and if you do just graphs, you should be able to see all this. If you have this, that means you have all the global libraries that are required. Okay, I hope the transaction is done and we have our smart contract and we need to actually verify this particular smart contract. Okay, so I flatten the file. First of all, this is the smart contract. I flatten the file a little bit, not little bit, totally flatten the file and verify single file 0.18.
00:08:04.590 - 00:08:43.984, Speaker A: I hope I'm not very speeding up. If you are coding with me, just be able to code along and then I just deploy. I'm not a robot. Verify. Okay, so my smart contract is verified now I can just go here and be able to check. I'm also going to tell you specifically why I verified my particular smart contract. So basically with the graph we created tools so that you don't have to write a subgraph from scratch.
00:08:43.984 - 00:09:29.124, Speaker A: Most of the things, most of the events are already catered upon and you just have to make changes so that your UI needs are fulfilled. All right, so we have just a small TLDR. We had an NFT called as Iris that we deployed, right? And then we deployed it on the Sepolia network and we actually verified that particular smart contract and it's verified now. And we also logged into the subgraph studio so that now we can do the next things right. We go on the terminal now and I create an Mkdir known as Iris NFT. You're getting very famous today, Iris. Hey, I need some money after this.
00:09:29.124 - 00:10:38.120, Speaker A: Okay. Iris NFT. So we are inside now. I'll do graph in it index events so that all the events that exist in an ERC 721 721 open Zeppelin smart contract, which is all the events that exist, which is transfer, approve and approve for all. All these events are actually indexed by the subgraph. So basically subgraphs index events and in all the smart contracts we have events so that we can show that to the front end, but there is no way to actually show that. So you create a subgraph so that the events can be indexed, right? So in an ERC 721 we have three events transfer, approve, approve for all and all these events will be indexed by the subgraph by just this magical command from index, from contract.
00:10:38.120 - 00:11:33.518, Speaker A: And then I paste the contract address which is this one that should be okay, wait, graph in it. Okay, this is it. This should be able to so this is an EVM chain. Sepolia is an EVM chain. By the way, the graph is also on Cosmos, near and other places. But this is Sepolia as an EVM chain. So we'll just deploy it there.
00:11:33.518 - 00:12:01.218, Speaker A: This is Subgraph Studio and the slug name is Iris. Again, Iris. This is sipolia. So we'll choose Sipolia and this is the smart contract. So you see. Fetching. Abi So basically I verified my particular smart contract so that the graph command could fetch all the events from the Abi.
00:12:01.218 - 00:12:52.182, Speaker A: Because I verified it, right, it could not fetch the start block. So I'll just take the start block from here. This is the start block. Contract name is Contract and this should be able to just generate a subgraph for us. So an ERC 721 has three events, right? And those three events will have one subgraph so that we can index all the activities happening on the Iris NFT. How many of you have been able to reach till here? Okay, nobody? Wow, I like it. No problem.
00:12:52.182 - 00:13:30.558, Speaker A: You have a lot of time. We can always talk after this workshop as well. But this can be a great introduction to this amazing piece of infrastructure, which is going to be the Google of web3. We go inside. Okay. So you see the subgraph is already created and I'll go in a little depth to explain you. What are the parts of a subgraph? Right? There is first of all a YAML file which actually defines what's inside the graph.
00:13:30.558 - 00:13:56.778, Speaker A: What is inside the subgraph? What that means is that a subgraph has three things. The first is you need to define the network where you are deploying it, right, which is Sipolia. If it is on Gorli, this would be Gorli. If it was on Polygon, it would be Matic. If it was on Gnosis chain, it would be Gnosis chain, so on and so forth. So first of all, you need to define the network. The second thing is you need to define the address.
00:13:56.778 - 00:14:30.406, Speaker A: You are actually the smart contract address that you're actually indexing. Then the start block. And then there is this mapping file, right, which will always come up in that there are these entities. This is the most interesting part of the subgraph. What are these entities are the schemas. Basically, you see here, they're already created by the subgraph, by that graph in it index event file. So basically, when you have a smart contract, it has events approve, approve for all transfer.
00:14:30.406 - 00:15:35.226, Speaker A: I showed you that. And according to that, it created schemas for us so that we can basically query these. So when I actually go on this particular smart contract and hit transfer, that means I have done an event, right? And that needs to be indexed so that at the end the dashboard of your UI can show that this Iris NFT ID one was transferred from my address to some other address in your NFT marketplace, for example. Right? So basically you create these schemas so that you can tell that, okay, an approved function was done, a transfer function was done that will be required for your UI. So the first thing is you always define the schema, right? Here are the schemas with all the things that you want. And the second thing is the events, right? You are actually indexing events and then converting them to schemas. So basically, what happens in Ethereum is that you get events, right? And those events give you data.
00:15:35.226 - 00:16:21.338, Speaker A: That data needs to be put in such a way that it can be queried. So basically, these events have raw data and the mapping file converts those raw data to schemas, right? And that's about a subgraph. You define a subgraph in YML file. Then you have these mapping files so that these events which have the raw data can convert the data into schemas, which are such good looking. So in the mapping TS file, you actually define in TypeScript that how do you want to convert the data from the event, which is raw data, to these schemas? That's it. So mapping TS file is the major file where you define logic. That's it.
00:16:21.338 - 00:16:55.766, Speaker A: So this is all about it. We have everything that's required and now we will the schema is defined by like it's by default, but if you want, let's say, just a uniswap position. So I'll just delete everything and just have an LP position with ID transaction from transaction to and stuff like that. So whatever you want to query, you just define schema. And according to that, you set the mapping TS file, which is the logic for the event, so that the schema can be created. That's it. Great question, by the way.
00:16:55.766 - 00:17:27.274, Speaker A: So this is about it. Now we will deploy this subgraph and see the magic of how do you index information in such good formats? We do the graph. Auth this is my key. Don't use it, guys. If you do, then you are really bad people. So I do the Auth, then I do code gen and graph build. Okay, everything works.
00:17:27.274 - 00:18:14.730, Speaker A: And at the end, I just deploy this subgraph in the Studio 0.0.1. So you see, it took 20 minutes for a person to have a smart contract, have information via GraphQL APIs. So the subgraph is deployed and I can just go on the playground, which I cannot see right now. Okay, it's deployed and just refresh maybe. Yeah, you can see that the subgraph is deployed. I can go on the playground and check. It's empty, right? This is cool.
00:18:14.730 - 00:18:54.360, Speaker A: I can just go to transfers and I can still see, let's say from ID and two, and it's still empty. Wow, so much work and nothing done. Why? Because we have not done any transactions. Guys, come on, you're not paying attention. Let's do a transaction and then I'll show you that indexing happens in a second. If you don't use a subgraph, you'll have to create a whole indexer, have an event being tracked every time and pay one hundred k to AWS. By the way, AWS office just around that corner, so don't tell them.
00:18:54.360 - 00:20:10.410, Speaker A: So this is it. I'll just safe mint an Iris NFT for myself, is that okay? Iris? Okay, so I just go here and do and do one and just do a safe mint. So I've transferred one NFT into my particular account, and now the transaction, once it is successful, you'll be able to see that the subgraph is able to catch that event, get all the information from to ID and whatever you need and be able to serve you. Is the transaction successful? Not yet. We need a layer two to test nets too, I guess. Who's building one? Okay, the transaction is successful, and it took 31 seconds. And now you just go here.
00:20:10.410 - 00:21:08.830, Speaker A: Boom. You see the information, right? So as soon as the transaction is successful, you see the indexing happening. And now you have this amazing GraphQL API over here, and you want to query anything around, let's say Iris NFT, or let's say you have board API club NFT, right? And you want to know that who is the top most folder, right? You want to know who owns this particular ID NFT, and at what point in time he bought it, at what point in time scamp he bought it. You can get everything just by indexing that particular smart contract. So this is the power of creating a subgraph. At the end, you need a subgraph as a middleware between your smart contract and your UI so that you can put in all the information from the smart contract to your UI. So that's the missing piece in creating a full stack, decentralized application.
00:21:08.830 - 00:21:43.640, Speaker A: This is about it, guys. This is about it. Why do you need the graph? Because there are 15 million blocks in Ethereum, and if you want to create your own indexer, you'll have to scan every particular block and get the information. Who uses the graph? Everybody who has good brains and good devs. So that means Uniswap has an info Uniswap page, right? You all might have seen that. All of you who are billionaires because of crypto have seen it. So who has seen it? Okay.
00:21:43.640 - 00:22:21.734, Speaker A: Just marcus, maybe. So you see this particular info uniswap page, right? And all the information here is just smart contracts interacting. So you are a user, you go to Uniswap, you interact, you SDC swap. And that swap is a smart contract event that's tracked by us uniswap subgraph. And you get the information here. See, this is a Uniswap subgraph. I'll just expand it a little bit if I can, but yeah, this is an API, the graph Uniswap.
00:22:21.734 - 00:23:18.406, Speaker A: So basically, Uniswap has created a subgraph so that they can get in all the information from their Uniswap smart contract into this UI page. So basically, as I was telling you, the TLDR is if you have a smart contract and you want to create an application which is used by humans, not junkie developers, you need to create a UI. And for that there is a middleware known as subgraphs so that you can use it, right? So this is about it. We also have substreams coming by next month, right? But you can still use it basically indexing events for really fast chains like Polygon and ZK Sync. Right? Now coming, it's like a 1 second block and you need to index everything. And if you have, let's say, 10,000 transactions in every block, then it becomes a little tough to scale it. And with the current subgraph infrastructure, that's why we have substreams.
00:23:18.406 - 00:23:49.622, Speaker A: With subgraphs you can only index events with substreams, you can also index every granular data. For example, you can index addresses. So basically you can give your Djen score to a particular address by all the interactions it has done on the blockchain, all the transfers it has done on blockchain, everything. There is something known as on chain reputation, which is becoming very big right now. And you need to compute and addresses on chain reputation based on what it has done. And for that you can use substreams. It is already coming along.
00:23:49.622 - 00:24:27.326, Speaker A: It is a different stack. But I just wanted to introduce this because we have Bounties, right? Good Bounties. This one $800 can get you some good meals in Shibuya Crossing, right? I went there yesterday. Good place. So if you create a new subgraph, you can get one $800.01, $400 or $1,000 based on your capacity and how you developed it. Or what you can do is be a little more intelligent like me, and use the existing subgraph for dashboards.
00:24:27.326 - 00:25:29.924, Speaker A: For example. I'll give you an introduction to that as well. For example, so I have a repo in which I have named all the top subgraphs, right? This is the repo, missari, ERC 721 lens protocol subgraph. So if you are using Lens and you want to just use something for your dashboard, for a simple hack, let's say you want to find out which Lens address is the biggest scammer or something like that, you can just use the Lens Protocol subgraph and use it for creating good dashboards. One good example would be in ETH, India, somebody created an Arbitrage bot for all the Uniswap subgraphs. So basically what he did is Uniswap is deployed on three chains and let's say USDC ETH price on Polygon is more than it is on Ethereum. So he just queries the subgraph and it shows it on the dashboard that there is an Arbitrage opportunity.
00:25:29.924 - 00:26:03.890, Speaker A: There is an Arbitrage opportunity, right? These kind of innovating things you can do just by using a subgraph already created by Uniswap Team or Missari Team and do your own thing. So this is about it. This is how you create a subgraph and index information for your UI. That's about it. And this is about me. If you have any questions, I'll be here for three days if I'm not going out and drinking Saka. So you can find me here.
00:26:03.890 - 00:26:21.220, Speaker A: And by the way, this was the last thing that I introduced, the first news. That the graph now indexes sipolia testnet. Because graph testnet costs girly, testnet costs a lot of money. This is about it. Thank you. Bye.
