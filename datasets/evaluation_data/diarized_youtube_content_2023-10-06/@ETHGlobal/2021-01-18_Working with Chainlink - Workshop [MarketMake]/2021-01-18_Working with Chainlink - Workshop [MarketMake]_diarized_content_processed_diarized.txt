00:00:26.530 - 00:00:26.934, Speaker A: Awesome.
00:00:27.052 - 00:00:51.600, Speaker B: Looks like we're all set. So, further ado, thanks everybody for attending the chainlink workshop. Last workshop of the day. Today the first day of market make. We've got Patrick from the chainlink team. He's going to come at you live with a bunch of info on how to use chain link, get data into your contracts, into your DApps, and of course, many other things. So Patrick, I'll turn it over to you.
00:00:53.410 - 00:01:15.062, Speaker A: Awesome, thanks so much. Yeah, I'm just going to go ahead and share my screen. I just had to retweet Market Make tweet. Can everyone see? This looks awesome. All right, great. All right, awesome. So what's going on, everybody? My name is Patrick, I work on the chainlink project.
00:01:15.062 - 00:01:52.978, Speaker A: I'm really excited to be here, really excited to be helping out with the global teams hackathon. They always put on a stellar event. I'm really glad that I've been invited back. So, yeah, I'm here to talk to you about chainlink, about decentralized Oracles, about data, and about building the next generation of smart contracts at this exact point in time. We really have an extraordinary opportunity in front of us. The world of smart contracts is right here. We're seeing more and more adoption and more and more people understanding why smart contracts and why blockchain is so important and how it can really change the whole world for the better.
00:01:52.978 - 00:02:34.160, Speaker A: So we have this opportunity, we have this obligation almost to do something fantastic and build really cool things. And these hackathons are really the stomping grounds that enable this creativity, that enable everything that we're doing here. So I will be monitoring chat from time to time. So if you have any questions, feel free to pop them in there and I'll get to them when I can. So let's continue on. So a brief kind of layout of what we're doing here. We're going to talk about the Oracle problem, some definitive truth for financial data, verifiable, randomness functions, accessing any APIs use cases, and then we'll get into some demos at the end.
00:02:34.160 - 00:03:54.620, Speaker A: So in order to really understand chainlink, we first need to understand that smart contracts are not able to connect to external data or really any off chain data resource on their own. And this is a huge limiting factor for smart contract adoption because it means the only thing that we can really do is token transfers with each other. And that doesn't sound very smart contracty, right? Because a smart contract is just a traditional contract that can do more things and it is decentralized and it auto executes and it's not corruptible, which doing token transfers is great, but we obviously want to do more than that. So one of the questions that I often get asked is, okay, well, why can't I just make an API call in my smart contract? And this is actually a really important question. And the simple answer is that blockchain is a deterministic system and it needs to be able to be validated from the inception, the genesis block all the way to where it is right now. And if making API calls is part of that validation, part of that consensus protocol, then each node is going to get wildly different results when trying to sync up, right? Because if one node calls an API a minute later, that API could be changed, could be depreciated. And if you try to go back and 20 years later try to revalidate every single node, every single transaction, it's going to be all whack and it doesn't work.
00:03:54.620 - 00:04:39.506, Speaker A: So how do we deal with this problem? So, to interact with the outside world, we need what's called an Me. An Oracle is any device that interacts with the off chain world to provide data to smart contracts. And they report the result of this data in a transaction on chain so that the blockchain can stay deterministic. So these are really important obviously, because they take these smart contracts from kind of being these tokenized transactions to being able to take real data and build real contracts that have real meaning. Now here's where it gets a little bit spicier. The oracle problem. A centralized Oracle becomes a single point of failure for the entire smart contract.
00:04:39.506 - 00:05:18.430, Speaker A: If you have a centralized data source, but a decentralized logic, your smart contract isn't decentralized. One of the main reasons that we build on blockchains at all is because of the decentrality. So if we have our logic that's totally decentralized, that's fantastic. If we get our data component of our smart contracts from centralized points, it kind of defeats the purpose. So in order to make our applications that truly never need to rely on one entity, be it a company, a landlord, government, or anything like that, you need a network of chainlink nodes. You need a network of chainlink Oracles. And we use those terms a little bit interchangeably.
00:05:18.430 - 00:06:03.826, Speaker A: So to answer all this, chainlink is a decentralized Oracle network. It's a modular decentralized Oracle network. Meaning you can build your networks to be as decentralized as you want and add as many nodes getting data from as many different data sources as you can, so that your data can be truly decentralized and tamper proof with these auto executing smart contracts. And this is where Chainlink really shines. So Chainlink allows users to build anything that they want and take smart contracts. From doing just these token transfers to being what we really want smart contracts to be, and replace and relandscape entire industries right now, to doing these superior digital agreements. Because that's what smart contracts are.
00:06:03.826 - 00:06:56.100, Speaker A: The added trust, reliability and security of smart contracts is a necessary, is something that we need in today's day and age. And Chainlink allows you to do that. Chainlink is completely customizable and can work with any API. And it's even more customizable with what's called external adapters and external initiators. These are what allow people to connect to any blockchain or any data source and have the nodes do hypothetically whatever you want. And to get you started with DeFi, the Chainlink project has actually gone ahead and found many of the best blockchain node operators on the planet and combined their prowess to build what's called price feeds. These are decentralized on chain reference points that can be considered the source of truth for various currency pairs, like the price of ETH and USD, for example.
00:06:56.100 - 00:07:37.806, Speaker A: And as you can see, this image is a little bit outdated, but everything is the same. Each node, because ETH is not $200 anymore. Each node in the network independently retrieves data from some of the highest quality data APIs and reports their answers. On Chain, you can see the answers that each provider reports so that everything is completely transparent. Many of the most popular cryptocurrencies or fiat pairs are currently supported. And the best part is, if you don't like it, you can build something else yourself. Now, so here's just a little bit more of the approach of how these price feeds work or the thought and the care that goes into making sure that these are so powerful.
00:07:37.806 - 00:08:15.094, Speaker A: They're centralized, provably, secure. They're all using high quality data, they use crypto, economic security, there's defense adept, huge open source community that's contributing. If you want to learn more about it, definitely check out the documentation and you can kind of read into the actual Oracles and the actual nodes that are running these price feeds. And why I'm stressing this point so much is we've already seen dozens of attacks. And just in November alone, when I was counting, I counted six attacks. Six attacks in DeFi that were over a million dollars each. And they were due to the fact that they were using centralized Oracle.
00:08:15.094 - 00:08:59.420, Speaker A: So we absolutely need to braise us as a community to a higher standard and use safer, decentralized Oracle so that we can build these awesome protocols and these awesome projects. And DeFi is constantly one of the major areas pushing for projects and pushing for innovation and really drawing out the creativity of engineers and has a ton of momentum and knowledgeable people working in the field. Chainlink supports some of the top DFI projects. Already at the moment, there's over something like $20 billion in DFI. And you may think, oh, we're doing really well. That's a lot. It's not even close to what traditional finance is, so there's so much ground to be built.
00:08:59.420 - 00:10:00.654, Speaker A: And so some of the projects that are using Chainlink right now, chainlink price feeds are synthetics with over a billion dollars in assets under management, loop ring set, protocol ave with, what is it, like 3 billion right now or something like that. So these synthetic price feeds are battle tested, tried and true to really give you these definitive sources of truth on financial data like price feeds, there's more data than just the prices of F and different cryptocurrencies. You can definitely check it out in the documentation, or you can go to Feeds Chain Link to see the visualizations, learn a little bit more about exactly what's going on under the hood and everything else going on there. So with that as well, chainlink is more than just price. Feeds chainlink is, like I said, it's an oracle that allows really any input and any output and you can really do whatever you want. You can take your smart contract from being an agreement to just send tokens, to doing anything that any contract on the planet does today. This is the future that we want.
00:10:00.654 - 00:10:37.174, Speaker A: This is the potential of smart contracts to really do everything regular contracts do today. And obviously, contracts play a huge role in our lives. Pretty much everything you're looking at is a result of a contract. The computer that you're watching this on, or maybe you're streaming it from your phone, is a result of many contracts to get the materials, to build the materials to build the software. These are all due to contracts. So going from regular contracts to these smart contracts to these superior digital agreements is a huge advantage for humans and the world in general. So Chainlink allows you to do any input and any output.
00:10:37.174 - 00:11:20.998, Speaker A: And a huge use case here is getting provably random numbers. Right now what a lot of people use to get random numbers is they depend on the block hash and they hash the block hash. But right now that's not a really safe way to get a truly random number. If a miner is incentivized to get a different random number, they cannot publish a block, which actually screws with the fairness of your supposedly provably fair random application. So we can't trust the miners, we can't have the system where we're working on the block hash to get a random number. So we need a better solution. And this is where Chainlink of VRF comes into play.
00:11:20.998 - 00:11:52.094, Speaker A: Chainlink VRF is a provably random function generator. So it provably creates random numbers that are verified on Chain that they're provably random. It was developed by some very intelligent people saying provably random. Sounds insane to me, but yeah, all the code is open source. You can go check it out and learn how this actually works. There are a number of projects that are working with this Chainlink VRF and are using Chainlink VRF, one of them being pulled together. Everything is in the documentation.
00:11:52.094 - 00:12:35.306, Speaker A: You can start getting random numbers right now to power your gaming, your random sampling, or whatever you want to do with random numbers. And again, Chainlink is capable of being used to work with any API and can be extended to integrate with any blockchain with external adapters and external initiators. So this is really the power of Chainlink. Everything that you know and love about the internet right now, it runs off of APIs. You can take those exact same APIs that makes the internet run. Customize them however you want and put them into your smart contracts and you can do it in a decentralized fashion. And then here's a snapshot of the docs page of the chainlink API calls, which we'll get to in just a minute.
00:12:35.306 - 00:13:08.934, Speaker A: But really quickly, before we do that, I wanted to just run through a few sample use cases of what you can do with chainlink enabled smart contracts. There's a blog out there called 77 Smart Contract Use Cases Enabled by Chainlink. I highly recommend checking out if you're kind of looking for ideas or looking for something to do. This industry is still, I know it's been what, five, six years? Six years since Ethereum launched. There's still so much innovation to be done and so many protocols to be built into decentralized fashion. Let's just rip through a couple of them. Decentralized finance.
00:13:08.934 - 00:14:07.690, Speaker A: Again, I know this is a big topic, but there's still so much to be built in this area and so much to do and so much to be learned here. Fantasy sports or any sports game in general, any type of poker game or any type of RNG game or literally any game at all, any type of tokenized assets, split up your car plots of land. Chainlink makes it really easy to keep track of who owns what and you don't have to deal with any of that paperwork. And since your data is coming from a decentralized source, no one can mess anything up. And then obviously insurance is a huge one that I'm really excited for more products to get into this space. Let's say your crops are messed up due to the weather and your insurance doesn't want to pay out due to some preexisting condition or something. Well, with a decentralized smart contract and a decentralized insurance platform, you don't have to trust that the insurance company is going to do the right thing because doing the right thing is infrastructural with chainlink.
00:14:07.690 - 00:14:29.154, Speaker A: So with that it looks like we have plenty of time to go through a couple of demos and let me answer a couple of questions before I go on to that. Looks like there are no questions. Hello. Hello. Stream up. All right, cool. Yeah.
00:14:29.154 - 00:14:54.246, Speaker A: Feel free to ask any questions during this. I'd like this to be kind of a more interactive session, so if anything is confusing, feel free to let me know. Here, let me switch gears to this. Okay, so we're going to start on the documentation page. So this is the chainlink docs. This is where most of you engineers are going to come to just start learning about your projects. We are going to go and start with the price feeds.
00:14:54.246 - 00:15:32.130, Speaker A: So each section is kind of separated like this. Let's go to price feeds. You can learn more about what each of the price feeds does here. And all the code is here. Everything that you want to do, we can actually just go ahead and click this big Remix button and we can get a demo spun up right in Remix. And this is going to be getting the latest price of an asset. So again, if we head over to Feeds Chain Link, we can see kind of what these feeds look like once my computer decides to load, or I have to make it wider.
00:15:32.130 - 00:16:08.100, Speaker A: We can see what these feeds look like and we can see the different nodes reporting their different individual prices. That all gets aggregated to this number right here and we can even click on it. We go check it on Etherscan. Everything that we want to know is here. We're going to look at these internal transactions and we can see it gets updated pretty frequently, which is really exciting. So on Remix here, I've done this a few times, so I have a couple different couple different contracts here. We hit that button and the code's automatically populated right here.
00:16:08.100 - 00:16:46.240, Speaker A: And this is everything that we need to know. So first we're going to import the code from the chainlink GitHub. And this is going to be how we define connecting to the price feed that has this decentralized price. Something else, actually, that I didn't put in this demo that I probably should is for those of you who want to try using ENS. ENS is now enabled, which is really exciting. You can actually just use ENS instead of these address strings, which is really exciting. So we're on the COVID test network right now, or we should be.
00:16:46.240 - 00:17:04.050, Speaker A: I'm on the Mumbai test network, actually. Got to reload the site test password and can you guys see MetaMask or can we not see MetaMask?
00:17:04.130 - 00:17:05.062, Speaker B: Yep, it shows up.
00:17:05.116 - 00:17:32.318, Speaker A: It shows up. Okay, great. All right, cool. So we're on the COVID test network here. I have already gotten my test ETH and my test link and a whole bunch of other stuff in here. If you need to get a Faucet to get test Ethereum or test chain link, you can find that in documentation, too. You can also go through these tutorials if you're brand new and you're still learning.
00:17:32.318 - 00:18:27.498, Speaker A: This will also go through giving you some testnet ETH and some testnet link so that you can get spun up and learn how to deploy a smart contract right now. And on a testnet which resembles very closely to the Ethereum main net, I got a question, so I'm going to take it. How would it work to get IoT data into a smart contract? Even Chainlink couldn't help to get data, for example, data from temperature sensors, right? If there were for good examples, in one of supply chain and cooled goods, you could just put one sensor in a cooling box inside a truck and put the other goods outside the box. Maybe I didn't read this right, but yeah, so that's a good question. So getting IoT data into a smart contract? That's a really good question, actually. Basically what you would do is you would take your sensor and you would have it you'd connect it via an API to your chainlink node. Your sensor could just send the chainlink node API calls.
00:18:27.498 - 00:19:10.986, Speaker A: Or, excuse me, the chainlink node could just make API calls to your sensor. And depending on the output of those API calls, you can make a smart contract do something or the other way around, depending on the output of a smart contract, you could turn on a sensor or do something with a sensor, so everything just flows through APIs. So with a sensor, for example, if you wanted to make it decentralized, you would have many different sensors. Like, weather is a great one. If you wanted to get the average temperature of Boston, you just have many weather sensors giving that temperature update to this chainlink oracles. That's a really good question. And we've seen a couple of projects who start working with IoT data for similar use cases.
00:19:10.986 - 00:19:49.158, Speaker A: So that's actually really exciting. Are there samples to connect to NYC Miami Date open data APIs to retrieve city data? Probably. I mean, honestly, if the API exists, you can work with it. So if you find an API that actually gives you that data, you can work with it. I don't know of any examples. Miami Date open data APIs to retrieve city data? I guess it depends on what kind of city data. Something that is really interesting is we released a video on using Google's BigQuery.
00:19:49.158 - 00:20:32.950, Speaker A: Google's BigQuery has a ton of free data, a ton of really cool data that you can use to combine with smart contracts to look up nearly anything or whatever is in their data library. But that's a really good question. So the question here is kind of more on sourcing data and where can I find data? If you can find the data, you can put it into the smart contract. Question from YouTube I have an ERC 20 token and want to use the best tools to make it an incredible asset. What aspects of link could I use to add to this already deployed asset? So this isn't really related to link so much, but I will say that the Link token does have a really cool feature called transfer and Call. I recommend you checking that out. Yeah, that's a pretty general question.
00:20:32.950 - 00:21:22.806, Speaker A: What aspects of link? How do you use yeah, I would say look into Transfer and Call or the ERC 677 standard, actually. Question from YouTube could you please tell the main difference between connecting two blockchains private and public using chain link and polka dot or cosmos? Main difference between using chain link and polka dot or cosmos between connecting two blockchains private and like, it sounds like you're confusing polkadot and cosmos for oracles. Yeah, cosmos and polkadot aren't oracles, so I guess that would be the main difference. So that's not what they do. That's not what Polkadot and Cosmos does. So chainlink is an oracle. That's what chainlink's primary function is, is to get data from the real world, bring it onto blockchains.
00:21:22.806 - 00:22:02.242, Speaker A: Unless you're asking what's the difference between connecting private and public blockchains in which case I would say there isn't really a difference. Actually we did a demo with a project and we showed deploying a chain link node to a private blockchain. So if that's the question, you can absolutely 100% deploy chain link to a private and a public blockchain. I suppose you could use chain link to attest to states of different chains. You could and that would be a really interesting use case. And if somebody builds that I think that that would be really cool. At the moment that's not what chainlink is primarily used for but that would be really cool.
00:22:02.242 - 00:22:38.720, Speaker A: And if you can build it, I would love to see that. That would be really cool. But yeah, sorry, I'm going to go back to the demo here and I'll answer some more questions soon. We're on the COVID Network. Here is the address of what do I have 40 minutes left? I think we're doing good. So we're going to head over to Coven's network and we can see again, we can see this being updated. It's not as frequent because it's a testnet but we can see things being updated here.
00:22:38.720 - 00:23:35.890, Speaker A: So what we do is we take this address and we add it to our aggregator V three interface as a parameter in our constructor here. And then we can call this get latest price function, which these are the variables that get returned. And we're just going to do price feed, get latest round data and just return the price. A common question is why is an int, why not a uint? And the answer there is as more and more interesting types of data are onboarded, you're going to want negative numbers and remix. We're just going to compile injected web three. So we're going to use MetaMask here, let's deploy it and we'll get the link there and this is our contract and we get the latest price and we can see this is the latest price of Ethereum and boom, it's that easy. And then you can use this price to do whatever you want.
00:23:35.890 - 00:24:16.958, Speaker A: Maybe you want to make a Dex, maybe you want to update some value on your smart contract. You can do whatever you want with this price because now you have this definitive truth, this decentralized reference point on what the price of Ether is. So that's the price feed. Let's look at the random number again. We're going to do remix first and then we'll switch over to doing like Vs code with a smart contract development framework just to show you kind of if you want to see start rate from remix. So same thing. We get this populated, we're going to import the VRF code which is different.
00:24:16.958 - 00:24:48.666, Speaker A: We're going to inherit everything from the VRF consumer base and VRF is a little bit different. There's a little bit more to it than just the view function on the price feed. What we're actually doing is we actually make a request to an off chain Oracle that Oracle is going to generate a random number, post it back on chain. On chain. There's a smart contract that's going to verify if it's actually random based off on the node's key hash. Each node has their own key hash. And then if it's good, if it's a random number, it's going to output it to us.
00:24:48.666 - 00:25:26.242, Speaker A: So before the price was a number that was already generated on chain and we were just reading from it. So here we're actually making a request to the node, the node is generating our request and then it is making a second transaction back on chain for us. So it's a little bit more involved. But again, we have a couple of different addresses in here. We have the VRF coordinator address, which is going to be the one that's going to be doing the verification and making sure the number is truly random link token address. And then we have our key hash of this Oracle. So when we're choosing an Oracle, we actually choose the Oracle and we say this is that Oracle's key hash.
00:25:26.242 - 00:26:06.050, Speaker A: That way they can't lie about if the number is random or not. And so here's our constructor. And since we're inheriting the VRF consumer to the two parameters that it takes is the coordinator address and the link token address as well. And we're going to give it these two global variables, key hash and fee. Again, the key hash is the key hash of the Oracle and fee is actually the link that we're paying to the Oracle to execute this request. So similar to how whenever you use logic on the ethereum chain that computation costs ETH and gas. Whenever you get data with chainlink, that costs link in what I like to call the Oracle gas.
00:26:06.050 - 00:26:53.858, Speaker A: So once we deploy it, we're actually going to call this get random number function and we give it a user provided seed. So this is going to be a number that we come up with to kind of bounce off of again to check to make sure the number is random. And we're going to call this request randomness function, which because we've inherited from the VRF consumer base, it kicks off that random number request to the chainlink Oracle. And again, like I said, we're making two transactions. The chainlink node is actually going to respond on this fulfill randomness function. And you can see it's an internal override function, which means there's a fulfill randomness function that we're overriding to add these into it. Only the chainlink Oracle can actually call this and fulfill the random number.
00:26:53.858 - 00:27:13.634, Speaker A: And we're just going to store the random number into this random result. Variable that we're going to read in and see what the random number is. So let's go ahead and compile this inject a web three. Let's deploy. MetaMask pops up. Can you guys see it when MetaMask pops up? Or no, maybe not. I know you could before, but I know this is like a different window.
00:27:13.634 - 00:27:15.434, Speaker A: In any case, MetaMask popped up.
00:27:15.632 - 00:27:16.410, Speaker B: Different screen.
00:27:16.480 - 00:27:32.570, Speaker A: Yeah, it was a different screen. Yeah. So this is the same screen, but the other one's a different screen. So MetaMask popped up. I hit confirm, and now we can see. This is our deployed contract here. Now I'm going to hit this request random number and it's going to fail.
00:27:32.570 - 00:28:01.320, Speaker A: And I just want to show you this because the first couple of times you might run into this, you're going to get this gas estimation failed again. Remember, you don't have any Oracle gas yet. So we actually need to fund the contract with our Oracle gas, which is our link. So we're going to copy the address like this, go into our tokens. We're going to send it. We'll send it to link just to be safe, even though the fee is 0.1, just in case we want to get a bunch of random numbers, send it to link.
00:28:01.320 - 00:28:28.798, Speaker A: Here's our transaction. It looks like it's pretty much already gone through. Yes, it's gone through. So once it's gone through, now we can make the request because we have the Oracle gas to pay the chainlink node. So we're just going to use one, two, three as a random number seed. In the documentation, there's a note about choosing a random number seed to keep it really secure. So you're going to want to check that out too.
00:28:28.798 - 00:28:47.714, Speaker A: Don't always have it be one, two, three. So let's do get random number. MetaMask pops up in a different window. We're going to confirm and right now before the node responds, our random result is zero. So we actually, again, we have to wait for two transactions. We have to wait for it to send. The Oracle has got to get it and then respond.
00:28:47.714 - 00:29:37.110, Speaker A: It might be done already, but it also might not be. So once the random number comes back, you'll see, we'll get a random number within the range of zero to the max size of a UN 256. So this most likely it's going to be a huge number. Another question that I get asked a lot is how do I take this random number and kind of divide it into other random numbers? You can use a module function and basically split it up by the digits and just have multiple random numbers to kind of do less requests there. And yeah, we'll see it here. It's this massive, massive random number. But this is actually wild because this is a provably random number, which is something that is so cryptographically wild.
00:29:37.110 - 00:30:02.480, Speaker A: I think it's insane that we actually have the ability to do this. So. This is how the chainlink VRF works. Are there any questions about that? All right, cool, let's move on. And now we'll move on to our last one, making a get request. So this is just calling any API. This is where you can really customize your smart contract to do whatever you want.
00:30:02.480 - 00:30:43.722, Speaker A: We are going to be calling from this API right here. And actually if we call it right now, we can see what it responds, it responds with kind of this massive JSON object. And we're actually just looking for we're going to try to get volume 24 hours. We're looking for this number right here. If you enter one, two, three again, I presume it will provide a separate random number. Did I delete that? Yes, different random number. This is where you can really customize however you want.
00:30:43.722 - 00:31:22.540, Speaker A: I do want to point out really quickly, we won't have time to go over it here. External adapter chain link blog. But this is where you can really customize it and really make it your own. We have a blog on building custom external adapters. And what you would do is you'd build this external adapter and kind of make the API do whatever you wanted and then you just swap this out with the URL from your external adapter which is really powerful. I know I mentioned external initiators as well. There's some documentation on external initiators those are a little bit more involved, but you can do some really cool stuff with them as well.
00:31:22.540 - 00:31:55.522, Speaker A: Here we have our code for making an API call. We're going to import from GitHub as well. And same thing as the VRF. We choose our Oracle and we choose the job ID. So choosing the job is actually really important. This is going to define what is the return type of the job and what else the job does. So if you're looking for some custom jobs or some really interesting jobs, you can head over to Market Link, select the network that you want.
00:31:55.522 - 00:32:44.834, Speaker A: There's Matic, there's Binance here too, which is awesome. And we can know if maybe we wanted to find like an Http get job that returned a Uwint. We can see some nodes that actually have that data or maybe a get job that returns a Boolean. We'd see some other jobs that some other nodes that have that job and you'd click it, get the Oracle address and then you can go to their jobs and find for example, their job ID. So that Oracle address plus this job ID here are going to what you need to populate the Oracle and the job ID and that chooses the specific node and the specific job. And again, same thing as the VRF. We're choosing a link token fee to give these guys out as a thank you for returning our data safely to us.
00:32:44.834 - 00:33:33.010, Speaker A: So this is the constructor in here. We're actually going to call this request volume data and there's a couple functions in here. So we build the chainlink request by inputting the job, the return or the callback address, which is going to be this smart contract that we deployed. And then the callback function which we're saying is defined as this fulfill function. So if we scroll below, we do see this fulfill function which takes the request ID and the return data as its parameters. And again, this is why choosing the job ID is so important because you need the job ID to return the same data type that your fulfill function has. It also has this record chain link fulfillment modifier, which means that only the Oracle that you specified can actually call this function.
00:33:33.010 - 00:34:07.302, Speaker A: And then we're just going to set it to this volume parameter. So in this build chain link request, we're going to add some what's called adapters. We're going to add a get adapter. We're going to say we want the job to get this URL. And again, we actually only want this volume 24 hours. So we're going to use this path adapter or this copy path adapter to walk the JSON to get to this volume 24 hours. So when we saw this response here, we see the first key is Raw, the second key is E, third key is USD.
00:34:07.302 - 00:34:47.826, Speaker A: And that's how we're going to walk to this volume 24 hours. So that's what we want. Then we want to multiply it because solidity doesn't work with decimals, so we need to multiply it by a number high enough to get rid of all those decimals. And yeah, we add this times adapter and then we send the chainlink request. So we send the chainlink request to the Oracle with the request that request object that we built here, right, and we added the adapters to and we add the fee and then when it gets done, it's going to call via this fulfill function. So same thing. Let's compile injected web three, let's deploy.
00:34:47.826 - 00:35:29.782, Speaker A: Metamass popped up, I hit confirm and and we have deployed this again. Remember, since we're making a request, we have to send it link. So I'm going to send to link. Just to be safe, I should just max out the gas for these, right? Because it's a testnet and I don't really care how fast it but yeah, once it gets some link, then we can actually call this request volume data function, right? And this is what's going to make this API call. If we hit volume right now, it's a big zero. So let's hit this request volume. MetaMask popped up, it's on a different screen.
00:35:29.782 - 00:36:01.794, Speaker A: Sorry, I'm going to go ahead and hit confirm and it's going to give me the transaction here for Etherscan. So again, this is making two transactions on ETH. So it's going to make the transaction. The chain Mcmuid is going to read the event that's emitted. It's going to go get the data and go do whatever you tell to do. I mean, at the end of the day, all these adapters are just saying, hey, do this, do this, do that. So it's going to go get that data, it's going to do whatever you tell to do, and then it's going to return the data in a second transaction, which will actually update this number here.
00:36:01.794 - 00:36:41.246, Speaker A: And it looks like it is already updated. And this is the volume for 24 hours there. So that's how you can get any API and get any data into your smart contract. Again, this example uses a single node and a single data source. So it's great for testing and it's great for developing, but in a production environment, obviously you want to use decentralized data because that's the whole purpose of developing with smart contracts. But I got a question from Max Million, but for external adapters, you wouldn't have an average or median of the data anymore or not. I'm not sure I understand the question.
00:36:41.246 - 00:37:21.914, Speaker A: So with an external adapter, you wouldn't have a definitive or proven average or medium, right? You're trusting that that API and that single Oracle is giving you this average, this median. And that's not what we want in smart contracts. We want to have trustless smart contracts. I mean, that's one of the whole reasons that we do anything with blockchain. What is the definition of an external adapter? An external adapter is anything outside of chainlink's core functionality. So any adapter or task outside of chainlink's core functionality. So if we go to the chainlink docs, let me just go to adapters actually.
00:37:21.914 - 00:38:08.874, Speaker A: So this is external adapters, which will tell you a little bit more about it. But if we go to adapters, these are some of the core adapters that the chainlink node comes prepackaged with. So example we can have compare, which compares values. We have Copy, which is that kind of copy path thing that we saw. We have ETH Bool, which turns a Boolean true or false into an ETH understandable boolean f Bytes, which does the same thing for bytes. Int is the same thing for int ETH TX, which makes a transaction on chain adapters, which are also known as tasks, are just something that you tell the chainlink node to do. So an external adapter is something that you tell the chainlink node to do that's outside of this core functionality, outside of the core of these adapters here.
00:38:08.874 - 00:38:46.662, Speaker A: So an external adapter is where you build something yourself, connect, hook it up to your chainlink node and make it do something really cool. Good question. Can Oracle nodes whitelist consumers out of the box or do they just respond to anyone using the Oracle address and the right job ID? They can actually whitelist consumers if they want, but out of the box they just respond to anybody with the Oracle address and job ID. But again, if they set that fee, then they'll charge the smart contracts for it, but you can whitelist if you want. I mean, because you use an API that might be a centralized source for the external adapter. Yes, okay, got it. Good question.
00:38:46.662 - 00:39:34.598, Speaker A: So you can make it do whatever you want, but if you're getting data via an external adapter in the same exact parameters apply, right? You're going to want to get that data from multiple external adapters from multiple different sources. Good question. Can you get notified by chainlink when a price hits a certain amount without your contract initiating the request? Yes, actually, you can. There are a couple of different really interesting ways to do that. You could do what's called a Cron initiator, which kicks off a job just whenever you set the schedule. And you could kick off a job that says, like, check for transaction. Or you could do an external initiator where you build your own initiator looking for a specific thing.
00:39:34.598 - 00:40:07.690, Speaker A: Yeah, maybe this cron job kicks off a quick script that you wrote that checks for prices. But yeah, this is the beauty of chainlink. You can really make it do whatever you want to do. So, yes, absolutely. All right, cool. I'm going to move on to my next demo because I only have a couple of minutes left here, share this one. So in a lot of my demos, I do NPM, I do Truffle, I do hard hat.
00:40:07.690 - 00:40:36.954, Speaker A: I did want to show you guys a Python implementation, actually, of developing and deploying smart contracts that I really like because I'm a Python nerd. I love Python, which is brownie. Could somebody please mute whoever joined? Thank you. Yeah, because I love Python. I love working with Python. So we have a blog coming out on this. You can definitely check out the Brownie docs on this as well.
00:40:36.954 - 00:40:57.070, Speaker A: First. You'll need Python. You'll need Ganache as well. If you just have Python, you can just do Pip install. I think it's F brownie. I'm not going to do it because I already have it. Next, what you'll need to do is actually install Ganache.
00:40:57.070 - 00:41:23.810, Speaker A: I think this is the command. Everything for this is actually in the chain link docs as well. Hold on, I'm flipping to the docs. I know that you guys can't see the page 1 second share. So here's the chain link docs. It does go over truffle. It goes over adding.
00:41:23.810 - 00:41:45.520, Speaker A: With NPM, you just add NPM install contracts, chain link contracts. You can do it with yarn, too. This will open up a Truffle project. And then here's how you do with Brownie, you do need Ganache, so you have to do NPM install Ganache. So let's actually flip back now. And let me share my screen here. If we have time, we'll also do the Truffle demo.
00:41:45.520 - 00:42:42.226, Speaker A: So once we have Ganache and Brownie installed, we can do which Brownie. We see that we actually have it installed or Brownie version or maybe version is wrong. Right now we have a blank folder and Brownie has this cool thing called brownie mix, brownie bakelink mix. And this will actually open up smart contract project that already has some sample boilerplate code in it. It looks like I need to do this right here. It already has some boilerplate code for our chain link smart contracts. So you can go kind of most of the smart contract development frameworks have a similar set up to this.
00:42:42.226 - 00:43:20.542, Speaker A: There's like a build or an artifacts. This is where it stores all your already deployed smart contracts. There's a contracts tab which right now this one comes pre installed with kind of the three main ones API, consumer price feeds, VRF, some images. This is a fun little chainlink brownie logo interfaces which are really good for working with already deployed deployed projects. And then we have scripts, which is what we're going to use to actually deploy stuff. And we'll get there in a second, your tests and then the brownie config which will define a lot of stuff. Kind of going quickly because we're running out of time.
00:43:20.542 - 00:43:53.522, Speaker A: And the README, if you ever get confused, just go back to the README, hop into the discord, leave an issue. We're very friendly and the chain the community is really excited to help each other and have people be really successful here. So we can actually just go through the README too. You can actually just go through the README too. To get started, let's actually just scroll down to here. So we do need two environment variables. We do need to export web three infuria.
00:43:53.522 - 00:44:15.534, Speaker A: I'm not going to do the whole thing. Inferior project ID. Actually I could just copy I already have it, already have it exported. And this is going to be your inferior project ID. You can go to infura, get a free key and this is how we're going to connect to the coven testnet. You also need your private key. You also need your private key.
00:44:15.534 - 00:44:55.406, Speaker A: So same thing you're going to need to do, export private key equals whatever your private key is, cat, dog, mouse, whatever you can get it from MetaMask or whatever wallet you're using. Just do export private key. Quick note for MetaMask is sometimes it doesn't export with like the first ox. So sometimes you'll have to add that on and there's a link here if you want to learn more about environment variables and how to set them. And it's really useful for just kind of because a lot of projects use them. We're actually going to deploy a price feed contract here. So we're just going to do brownie run.
00:44:55.406 - 00:45:29.762, Speaker A: And if you do nothing, brownie should give you oh, wait, never mind. It gives you nothing if you just do brownie. Excuse me. It'll give you kind of like a list of commands and you can do brownie help and see everything again. This is all in the documentation and you can learn more there. But we're going to do brownie run and we're going to run our scripts. We're going to run this deploy script, which you can see is a pretty simple Python script, which is going to just deploy that's our API scripts, actually, which is going to deploy our price feed deploy.
00:45:29.762 - 00:46:20.230, Speaker A: And we're going to use Coven. So it's going to deploy the coventh USD. It's going to deploy a price feed using this coventh USD address. So we're going to do COVID. So the same way we did with Remix, we can do it with here. Obviously, the huge benefit of using a smart contract development platform is you can do the tests, you can kind of script out everything that you want to do. Tests are obviously really important for keeping your project robust.
00:46:20.230 - 00:46:52.050, Speaker A: And it allows you to kind of have this fully coded back end and then you can put whatever front end you want on it as well. So it looks like we were able to deploy so price feed deploy that here. If we want. We can also do Brownie console, but I'm just going to keep staying with the scripts because I really like them. So we also have this read price feed script, which we're going to run right now. And it's going to take the most recently deployed price feed. So from Brownie import price feed, this price feed object is a list.
00:46:52.050 - 00:47:21.722, Speaker A: We're saying grab the most recently deployed price feed and we're just going to read from that. So, same thing. We're going to do brownie run scripts, price feed scripts, read price feed network Coven. And then this will say, hey, we're reading data from here and here's what we get. And again, this is the price of S in USD. And remember, sleeve doesn't work with decimals. So great.
00:47:21.722 - 00:47:47.250, Speaker A: So this is the actual price. So we have a little more than 1200. So this is kind of a real quick way to work with Brownie to deploy your smart contracts. Again, it is pulling from my test MetaMask account, which is how it actually deployed this on the COVID testnet. So that's that. And it looks like I do have some time left. Oh, you can go forever, Patrick.
00:47:47.250 - 00:48:22.350, Speaker A: Awesome. Got a couple of questions. I'm flipping back to these questions now. How scalable is the chainlink network? Really good question. That question can actually go a lot of different ways, more and more. I mean, the chainlink team and the chainlink core is working super hard on building brand new features to reduce gas costs, add more nodes, and do all these really cool things. And again, open source project.
00:48:22.350 - 00:49:20.430, Speaker A: So contributions are highly welcome. And you can see everything in the repo chainlink is right now, it's working mostly on Ethereum and it's working mostly with popular cryptocurrency prices. But really, any data that's needed or wanted for smart contracts, chainlink can add. And so right now we've seen Fiat cryptocurrency, but I'd love to see more diverse types of data get on. So that's one of the easiest ways and most exciting ways for me that Chainlink is going to scale is add more data types, add maybe weather data, add political data like anything you find in Google. BigQuery on a smart contract so we can build these insane smart contracts that can literally replace current contracts so we can have this more trusted environment using these trustless smart contracts. So that's one major way that I can scale.
00:49:20.430 - 00:49:51.034, Speaker A: Another way is that Chainlink is blockchain agnostic. So you saw actually Chainlink is on Matic, who I believe is also sponsoring this hackathon. So if they are and you saw that, maybe that's a little double whammy for you there. Chainlink and matic. So that's another way. Chainlink scales too is being on multiple chains. Asking how chainlink scales isn't the same as asking how ethereum scales, right? Because chainlink itself isn't a layer one.
00:49:51.034 - 00:50:20.142, Speaker A: Chainlink is a layer two. Right? It's an off chain resource that's getting data and bringing it on. Chain the layer. One aspect of it obviously is the link token that really secures the network and has some awesome improvements to actually make the whole thing work, like the transfer and call functionality. So that's a good question. That's a really interesting question because of kind of the different directions we can kind of go in with that. But again, everybody who's here, feel free to hop into the discord.
00:50:20.142 - 00:51:02.946, Speaker A: The community is super active, always asking really good questions and usually I'm around and usually a lot of the people who work on the core is around and you usually get it answered pretty quickly and it's really friendly community. So feel free to hop into the discord. And that's where the majority of the community is. Next question. Ultimately, chainlink solves the trustworthy messenger issue, but what about the data source authenticity issue? Is there any work on creating a marketplace for getting real world data such as temperatures, real world data such as weather in a trustworthy way? Sorry if this was already covered, just joined in late. No worries. No, that's a really good question.
00:51:02.946 - 00:51:56.926, Speaker A: So right now the closest thing to that is market link, which you can choose the different Oracles that you want and kind of literally build your own kind of price feed based off these different Oracles, which is awesome. More and more projects are constantly adding different types of different types of data and adding themselves to market that link. Like I said, the more nodes get spun up and the more people start contributing to the network, the more we'll see more and more of this. This is something we expect to come at some point. Kind of have this marketplace for data where you kind of show up and you just get this decentralized data. Right now that marketplace is these price feeds because these are pre configured, decentralized network that you can kind of just skim through and say, hey, I want ETH USD, I don't want to have to build the network myself. And then you see all the transparency of that decentralized network.
00:51:56.926 - 00:52:29.200, Speaker A: You can see it all right on Chain over at fees chain link. So that's a really good question. Like I said, more and more data is being added. Temperature, weather, those are things that are being worked on. It's interesting too, because Arble is an insurance provider that's working with Chainlink to get kind of weather data to provide insurance for farmers. So I can only imagine that this is going to come a lot sooner. A lot sooner, but maybe not as soon as we wish, but not as long as we might think.
00:52:29.200 - 00:53:06.090, Speaker A: Yes, I also didn't understand that because the data from sensors is easily manipulated. Great question. So this is why you want a decentralized network of sensors. So in the same way that you're getting decentralized data for your price feeds, you're going to need decentralized data from the sensors. And so it's going to be for some of those trickier data sources. I'm really curious to see the solutions there on how people decentralize those. Like, for example, what's the temperature of a heart in an ice box, like you were saying, or like an organ that's being transferred.
00:53:06.090 - 00:53:45.094, Speaker A: I'm really excited to see the solutions that people come up with here. One kind of the easy one is just you add a whole bunch of different sensors that have totally different infrastructures into this box. In any case, it's going to be really interesting to see some of the solutions that people come up with here. The easier ones is like weather data. If you have a city and you want the average temperature of the city, you can create thousands of these sensors, all relaying this data to this Oracle node. That's just going to take the median of all these sensors. So for IoT, stuff like that, it's actually really easy.
00:53:45.094 - 00:54:45.450, Speaker A: The hardware part is the harder part, the chain link part. And the Oracle part is actually the easier part. The harder part there would be like coordinating, adding all these sensors. How many nodes secure the link network at the moment? Good question. So right now, if you head over to Market Link, and I'll even switch views here back to my Internet browser, we can see some of the different nodes, some of the different nodes on the different test nets. Again, this is COVID, but we go to mainnet too, some of the different nodes and their activities. But if you want to see so securing the Link network might be a little bit misleading because there's obviously many different networks because each one of these price feeds is potentially a different set of Oracles.
00:54:45.450 - 00:55:03.470, Speaker A: You can see XAU USD. I believe this is gold or silver. I forget it's one of those. I should really it's gold. Okay, cool. Thank you. Each one of these different oracles is bringing that data in for it.
00:55:03.470 - 00:55:45.994, Speaker A: And so, like, this network, for example, has nine, so it depends on the feed. This one has 21, which is really exciting. And more, like I said, more and more advancements are being made. Like, for example, when OCR comes out, there will be even more nodes because OCR reduces the gas costs by such an insane amount. So these are the ones that are securing the feeds networks right now, but there are more than that, kind of just in the overall chain link community. What's the partition tolerance redundancy for data served? Good question. Well, for the price feed, unable to show a price feed.
00:55:45.994 - 00:56:16.630, Speaker A: Okay. Oh, it's probably updating or something. Maybe it's updating. That's pretty cool. Maybe I broke the front end. But yeah, you can actually see on the different price feeds, you can set your own deviations, you can set your own thresholds. It looks like this one updates every 86,400 seconds or whenever there's a deviation threshold of 0.5%
00:56:16.630 - 00:56:47.342, Speaker A: or more. So these nodes are actually monitoring the off chain APIs that they're consuming, or most of them are actually monitoring many APIs to get a decentralized aggregate themselves, which is then again, decentralized on chain. They're monitoring it off chain. And then if they see, hey, there's a 0.5% update, we need to update the smart contract to reflect this change. So it really depends on the network. It really depends on the price feeds.
00:56:47.342 - 00:57:41.934, Speaker A: But yeah, you can set it to be really whatever you want. Is the data delayed by any amount of time? Is that just for price feeds? Yeah. So that's a good question. So the data is saying it's delayed I don't think is accurate, but saying it's up to the second real time is also not accurate. So each one of these has their own heartbeat, right? And whenever that heartbeat hits, it makes an update, or whenever there's a deviation threshold. So if I said it's delayed, that's not accurate because anytime there's a significant movement, everything gets updated. So it's kind of this mix of being the price with basically two heartbeats, and the primary one, obviously, is the threshold, the deviation threshold.
00:57:41.934 - 00:58:27.650, Speaker A: If there's a big spike or a big drop in price, it triggers a change. Sorry, this question might be too futuristic, but is there an adapter which can link quantum randomness sources to chainlink? If it's got an API, you can do it. Long story short, so yeah. Do nodes get slashed for producing voting on bad data? Yeah, this is a really good question, actually. So right now, nodes are basically monitored based off their reputation. If they behave poorly, they get kicked off these networks. If they are responding outside the range, outside the threshold, if they're not responding.
00:58:27.650 - 00:59:24.850, Speaker A: And since the networks are pretty small, the groups are really swift to basically kick them off and bring somebody better in. As the network grows more and more nodes is going to be added to these networks, but due to kind of how small they are at the moment, they get kicked off really quickly to keep them incredibly high quality, because that's kind of the main. There's so much money riding on these price feeds. I think it's something like $7 billion $10 billion of DFI is riding on these price feeds, being accurate, which is fantastic. So they've reached this level of decentrality that's really efficient for these protocols, like synthetics, like Aave. But yeah, since everything's on chain, every oracle's reputation goes right on chain. So if somebody screws up or somebody doesn't respond, everybody sees.
00:59:24.850 - 00:59:59.920, Speaker A: So when you're running a chain link node, you really want to have a really high caliber. You really want to have 24/7 monitoring. There's a lot that goes into it because if you're down for even a little bit, you're probably going to get kicked off. Very cool. Excited for some graph protocol, chain link integrations? Yeah, I've actually seen a couple of those, which are really cool. I actually built a project that pulls from one of them, which is pretty cool. So I know we're at time, but Jacob said I can go as long as I want.
00:59:59.920 - 01:00:17.022, Speaker A: Jacob, you have made a mistake. No, I'm kidding. Let me switch views again. So I know I showed you guys, showed everybody here brownie. This one is this one's python. We could do a couple different things here. Please hit us with more stuff.
01:00:17.022 - 01:00:54.160, Speaker A: Okay, great. Let me ask, what would you guys prefer? Do you want to see Truffle? Do you want to see brownie? Do other stuff? Do you want to see hard hat? I don't have a hard hat prepped, but I could get all the hard hat stuff really quickly. Is there something in particular you want to see? Truffle hard hat? We're getting a battle. I'll show Truffle because Truffle and Hard hat are pretty similar. Let me go to this. I've also written a blog and a couple of tools. If you Google actually, let me flip back real quick.
01:00:54.160 - 01:01:45.934, Speaker A: Q, who said hard hat? If you look up Hard hat chain link, I believe you'll get my repo here, which shows how to use Hard hat and chain link, which is hard hat is actually really cool because it's got this kind of like this forking thing built in. I definitely recommend checking out Hard hat if you haven't before, but let's switch back. Yeah, I wrote a blog recently on kind of the best smart contract developer frameworks, and I found that it's definitely going to be Truffle Brownie and Hard hat. Hardhead has some really cool improvements. This is my Truffle file. This is similar to that brownie mix. Yeah, if you haven't heard of Hard hat, yeah, definitely.
01:01:45.934 - 01:02:03.358, Speaker A: Take a look. It's really powerful. So this is my Truffle file. I already built it again, truffle is from MPM. So you do truffle MPM install g truffle and. This is how you get it. It's built into scaffold.
01:02:03.358 - 01:02:20.698, Speaker A: E, take a look at that. Oh, is it? Oh, I didn't know that. That's really cool. Yeah. Actually, the forking feature is really powerful with hard hat. Truffle actually does have a hard hat, or excuse me, a forking feature. But I do like hard hats a little bit better.
01:02:20.698 - 01:02:34.986, Speaker A: It's a little bit easier. I didn't know Scaffold ETH had a yeah, here, I'll send you the link for the chain link. Hard hat one. I didn't know Scaffold ETH had a hard hat build in. That's really cool. Yeah. Builder is now hard hat.
01:02:34.986 - 01:03:07.706, Speaker A: Yeah, they recently Biddler, or however you pronounce it. That's why they rebranded, because it was like, Biddler. What? Yeah, I feel like now we have to do hard hat, but yeah. So here's truffle this is made with Truffle on boxainlinkbox. Not going to do it again because I've already done it here. You can see everything in the README. Oh, actually, this is the outdated one.
01:03:07.706 - 01:03:49.174, Speaker A: There's an updated one with price feeds and VRF, which is really exciting. So, again, NPM install, and everything's going to be in this config. So, again, we're pulling from Mnemonic and Rpcrl. So Mnemonic is going to be that cat, dog, mouse, cheese, whatever, from our wallet. So we export it, export it from our Ethereum wallet, and then we export it as an environment variable in our project here. And then RPC URL, this is going to be like your web three URL. Like, if you add infuria, it's going to be the whole URL string for that.
01:03:49.174 - 01:04:29.800, Speaker A: So we export those the same way as with Python export RPC URL equals www dot infura COVID or whatever it is. Again, if you're unfamiliar with environment variables, definitely check out that Twilio, the Twilio link in the Python chain link library. Now that we're bouncing around platforms and languages, we might get confusing. Yeah. And then I believe once you've unpacked everything, you can just run your basic Truffle commands. I've already compiled here. The README says to do the NPM, but I believe you can just do the Truffle ones.
01:04:29.800 - 01:05:03.550, Speaker A: So this is going to deploy this, my contract, which is our API call thing. Again, the newer version of this has price feeds, I believe. So we'll do Truffle Exec, truffle migrate, network. I think I said fly on this one, right? Network live. Yes. And then we're also going to do reset, just in case. So reset, hard resets, even if you've deployed.
01:05:03.550 - 01:05:36.218, Speaker A: So great. We're deploying to Truffle or excuse me, we're deploying to the COVID network right now because I have this Rpcrl defined as coven. And we're going to see the oh so familiar Truffle deployments here. Going to deploy my contract, which my contract is just a little bit more advanced version of that API call bit that we saw. I should have updated this for the demo. Apologies. There.
01:05:36.218 - 01:06:12.926, Speaker A: Then we can do Truffle Exec scripts fund contract network Live. We have a little fund contract script. This sends the link that that contract needs to make the request to the chain Oracle. So we're actually going to fund it via script, which again, is one of the huge benefits of doing everything in a smart contract development framework. We can just script everything that we want. Jason, I know you said I go as long as I want. I will try to wrap Jacob apologies.
01:06:12.926 - 01:06:31.740, Speaker A: I don't know why I came out as Jason. Jacob. I will try to not go too long, be conscientious of people's time here, but so we funded it right there. We can actually go and see oh, wait, can you guys see my Vs code?
01:06:32.750 - 01:06:33.722, Speaker B: Yeah, it's coming through.
01:06:33.776 - 01:06:50.020, Speaker A: Yeah, it's coming through. Okay, cool. Yeah, we could see this if we copy paste it to Ether scan. I'm not going to do that because then I got to flip back and forth. But then same thing. We're going to do truffle exec scripts. Request data.
01:06:50.020 - 01:07:23.414, Speaker A: Network live. And so this is exactly what we did in Remix just now. It's all scripted out. You can see all the scripts in here. And this package is actually this Truffle box is actually really nice because the tests are phenomenal. And so if you want to see a really good way to write really strong tests in web three with any smart contract in general, definitely check out this my contract test. It was made by Thomas Hodges, who's just a phenomenal smart contract engineer.
01:07:23.414 - 01:07:57.570, Speaker A: So we've funded it with Link. We've made the request. We can see the request was successful. That means the link went through, which is great. And now we're going to do this read contract, which after we've made the request, the chainlink node is going to fulfill the request, post the data back on chain, and we're just going to read from it again. Truffle Exec Scripts read Network Coven and this should give us I believe this is the price of Ethereum as well. And I ran into an issue unknown network coven.
01:07:57.570 - 01:08:20.190, Speaker A: That's because we said it's live, not COVID. And we got zero. And that probably just means it hasn't responded yet. We could probably check back in a minute. But that's kind of the basics of what you kind of look like here. Or you could do truffle console live. And this will bring you to the Truffle console.
01:08:20.190 - 01:08:46.770, Speaker A: And you can do all the same commands in your script here. So, like, I could do let MC equals my contract. Deployed. Deployed. I need to do await. Excuse me. Because this is JavaScript, MC has already been defined.
01:08:46.770 - 01:09:19.860, Speaker A: Let's do MC so I can do MCC data call. And this should give us the right because JavaScript does this weird stuff. Let's leave or exit. I forget how to exit. It actually control C. Yeah, that's how you get into there. And is it just being really slow for some reason, all right? It's just being really slow for some reason and it doesn't want to read.
01:09:19.860 - 01:10:30.034, Speaker A: But that's how you'd interact with Truffle there going through the questions. Are there DApps actually using the VRF feed? Would you vouch for the VRF feed on record XD? How is getting a random number not a standard contract on Zeppelin already? This is a really good question and the answer is yes, 100%. Absolutely. And I've written a couple of blogs about this. So there are basic ways to get a random number that are not secure, right? If you want to hash the block height and use that as your random number, absolutely. But as I said, if any of the miners have anything riding on it and they create the block that would give a different winner than what they wanted, well, then they just wouldn't publish the block, right? And so if you have a big mining group kind of doing this now, you've basically taken your Fair lottery and it's completely ruined now, right? It's not fair anymore. So the reason getting random numbers in computer science is hard, right? Because in computer science, systems are deterministic.
01:10:30.034 - 01:11:19.830, Speaker A: Even when in your Python or your JavaScript, when you say get random number, normally what it does is it just looks at a location and it just reads off of read some numbers because it says, okay, this is random enough, right. These deterministic systems can't create random numbers. Now blockchain where the entire thing is deterministic and everything is on chain, it's even harder, right, because everybody can see everything. So saying, oh, I want a random number, in a deterministic environment, it's not possible, right? So in order to get a random number, we actually have to look outside the chain to get a random number. Because I see what your kind of question is here, right? So if you want to create a pseudo random number, absolutely, go for it. Use the block height, use the block hash. But if you want to get a truly random number where your protocol is not going to get hacked and it's not going to get attacked.
01:11:19.830 - 01:12:05.738, Speaker A: And again, this is something that we have seen where people use pseudo random numbers and their protocols are injured. That's the wrong word, are injured because of it. Yeah, if that's what you want to use, great. If you're building a random system or you're building a project that doesn't need a truly random number, go for it. But if you need a truly random number, if you're doing a lottery, maybe some random sampling or maybe some high value gaming or even low value gaming where you really want to have a truly random game, then you're going to need to use chainlink VRF. And yeah, that's why it's not an Open Zeppelin, because Open Zeppelin does on chain contracts. So openzeppelin's.
01:12:05.738 - 01:12:31.562, Speaker A: Awesome. By the way, if any of you guys are building any projects, definitely use Open zeppelin for reference. They build amazing stuff. That's a really good question. That is really good question. The answer is because blockchains are deterministic, you actually can't get a random number, a truly random number from inside the blockchain itself. I guess zeppelin deals with smart contract based libraries.
01:12:31.562 - 01:12:49.830, Speaker A: RNG is something that requires either VRF. Yep, it looks like oh, I didn't even see that. You guys answered this. That's why we invented lava lamps. Yeah, definitely interested in security properties of UF. Yeah, definitely. Go check it out.
01:12:49.830 - 01:13:18.310, Speaker A: There are some really brilliant people that worked on it. Jacob I know that we've super gone over. If people are interested and if we have time, I will gladly show you guys hard hat. If not, we can jump off. Are there people who really want to see Hard hat? Give it a second for the delay. All right. No.
01:13:18.310 - 01:13:34.714, Speaker A: Yeah, because Hard hat is really similar to Truffle, actually. Yeah, if you fork Jacob, we have time to do hard hat. Or should I just point them in the direction of the README there, we got two. Yeahs. Now is it okay if I do the fork?
01:13:34.842 - 01:13:36.814, Speaker B: Yeah, if it's like maybe five minutes, that's probably fine.
01:13:36.852 - 01:13:59.038, Speaker A: All right, cool. Yeah, I'll do the fork. You guys can all see my thing still. Cool. I'm going to change screens real quick. Oh no. Welcome demos.
01:13:59.038 - 01:14:24.830, Speaker A: Oh, I messed up. 1 second CD share screen. There's got to be a simpler way to do this. Chain the card ham. Cool. Everybody can see chin the card. HAP.
01:14:24.830 - 01:14:32.640, Speaker A: So same thing. What's up? Yeah vs. Code. You can see me typing around and stuff.
01:14:33.410 - 01:14:34.350, Speaker B: Yeah, you're good?
01:14:34.420 - 01:14:56.946, Speaker A: All right, great. So same thing. Everything is in the README. For a quick start, if you guys want, you can clone this repo again. I can even drop it in the chat here. You can clone this repo everything's in the README. So we're actually going to be using this Alchemy mainnet Rpcrl.
01:14:56.946 - 01:15:55.494, Speaker A: So we're actually going to fork mainnet so we can deploy our contracts as if we're deploying it to a main net, which is wildly fantastic because we can work with mainnet price feed addresses, which is really cool. So, same thing. We're going to export our Alchemy mainnet Rpcrl and our Mnemonic exact same as before. You see the example right here and this is with yarn. So we already cloned this and in the Hardhead config we have this networks bit down here and this is where we define the networks that we're going to be working with. And why I think the hard hat forking is so simple is because in your networks we call one network hardhat and this is going to be our default network. So whenever we run a script, we just don't say a network, it's going to default to this, we're going to say it's default hardhat.
01:15:55.494 - 01:16:31.094, Speaker A: And the forking URL that we're going to use is this mainnet URL. So this is all you have to do to add forking in Hard Hat, which is why it's so fantastic. So you just do forking URL. You can also do a couple other things to get it, but this is the simplest way. And then you can add the other networks as well. So we have price feed here and we have deployed I didn't build a read command here, but what we can do is we can run test. I forget what's in test.
01:16:31.094 - 01:17:01.374, Speaker A: Actually, not too much. Actually, we're working on updating this so we can do MPX Hard Hat run, don't set a network. And then we'll do scripts deploy JS. It's what this is actually going to do, which is really cool. It's going to deploy this. Oh, no, I added a read to deploy to the deploy thing, which is really fun. I forgot about that.
01:17:01.374 - 01:17:14.242, Speaker A: Yeah, f price. Wait, get latest price. Oh, cool. So we deployed it and we read. So this actually deploys. So hard hat has what's called a hard hat virtual environment, I believe. Or hard hat runtime environment.
01:17:14.242 - 01:17:43.930, Speaker A: You saw how fast that went. So it actually forked mainnet. And we used a mainnet address to deploy. This is our deployment script price consumer Ether contracts we're deploying in the contract itself. We're using a main net FUSD address. So it actually forked the main net, deployed the smart contract and then read off of it back to us. So tests run really fast on Hard Hat because it uses this runtime environment instead of Ganache.
01:17:43.930 - 01:18:02.046, Speaker A: And you can do this forking. So those are some huge pros that Hard Hat has, which is really cool. Hard Hat. Hard Hat. Hard Hat. Algorand and Cardano use VRFs for the entire block production selection of staking pools. So you can bet it's very secure.
01:18:02.046 - 01:18:22.918, Speaker A: However, it all depends on the original C data. Okay, interesting use of forks. Yeah, this is probably my favorite use of forks because then you can test with mainnet. So that's kind of the simple overview of Hardhat. Like I said, the setup is really similar. It has this hardhat config, really similar to the Truffle config. The difference is that you have these tasks.
01:18:22.918 - 01:18:46.382, Speaker A: So I believe we can do Hardhat accounts and it'll print out the accounts. Yes. So Hardhat is kind of the shortcut for it. And anything you add as a task, you can just add that task there. You can code whatever tasks you want and really make it do whatever you want to do. So I probably didn't even need to do the scripts deploy. I could have just set it as a task.
01:18:46.382 - 01:19:01.430, Speaker A: But yeah, artifacts are up here. This is where a lot of the stuff is going to compile. You have your cache known modules, obviously. And yeah, pretty lightweight. Also, Ethersjs. That is a yes. Yes.
01:19:01.430 - 01:19:36.000, Speaker A: Thank you, Jacob. Ethersjs is super clean, but yeah, I know everyone's super over. And if there are any questions speak now or forever hold your Piece until you get onto Discord and ask it there. All right, cool. Well, that seems like it's it well, thank you all so much for coming and asking these really insightful questions. I'm super excited to see what everybody builds. This is going to be a fantastic know the ETH global team always puts on a stellar event.
01:19:36.000 - 01:19:42.500, Speaker A: We're really excited to be here and be participating. And thanks so much, Jacob and the whole team for having us here.
01:19:43.350 - 01:19:58.470, Speaker B: Awesome. Nice to have you. Patrick. Thanks for going over all of that. And yeah, again, also, thanks for Chainlink being a sponsor of those events. And you guys have been on so many of our events and it's been amazing to work with you guys for so long. So thanks for coming back and looking forward to see what people build on Chainlink.
01:19:58.470 - 01:19:59.800, Speaker B: Thanks, everybody. Awesome.
