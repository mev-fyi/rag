00:00:12.410 - 00:00:49.926, Speaker A: Everyone. Today we're going to be creating a chat app using PolyBase. So this is going to be a fairly long video, so we might split it into two parts. But today I want to cover creating a schema, logging in with the adding the libraries and kind of getting an initial read write request going in PolyBase. And we're actually going to build an NFT gated chat app just to kind of see the full options available in PolyBase. So the first thing I'm going to do is just jump into the docs and the Getting Started guide. And as you can see here, we have some instructions on how to install the client.
00:00:49.926 - 00:01:20.758, Speaker A: But I'm actually going to skip down to the creating a collection. So in PolyBase, everything, all data lives inside collections. A collection is similar to a database table and you can have fields and you can define kind of a schema for that database table. You can do it in code as it's shown here. But I would highly recommend using our Explorer. It will just give you a much easier experience in terms of creating that first collection for yourself. So I'm going to log in and you want to log in for the Explorer using this.
00:01:20.758 - 00:01:58.046, Speaker A: You need to have a MetaMask extension to log in and then I'm going to select this test account here to log in. It's going to ask me to log in with the Explorer and I can sign that request and then it's going to ask me to sign another one because I'm a new user. You enter your email address if you want updates. I'm going to skip that for now and then we'll go and create our chat app. So create the chat app. Again, it's going to ask me to sign messages if you're interested. This is an ETH personal sign message, so nothing to do with your ETH balance can be done with this type of signature.
00:01:58.046 - 00:02:36.318, Speaker A: Unfortunately, MetaMask doesn't really do a good job of explaining that this is kind of a weaker level signature or weaker in terms of risk level that you're putting up. So we obviously need to sign requests in PolyBase to make sure that we know who is sending requests to the database. So that's what this is doing and this is creating some demo code for us, which you can see here. So as I mentioned before, we've got a collection, we've got a bunch of fields. Highly recommend reading the comments on this first collection because it kind of gives you a bit of an overview of the different set functionality. But you're watching this video, so maybe you'll pick it up from that. I'm going to just remove this for now and just jump into creating some schema with you.
00:02:36.318 - 00:03:19.094, Speaker A: So the first thing I'm going to want is obviously a user or collection and I'm going to give it an ID field string. Now all collections have to have an ID field as string and that field has to be mandatory. So I'm going to put that one in and then I'm also going to add public key here or type public key and you'll see why we need this in a minute. But this is to do with and then I'm going to create a constructor. So you can see the syntax looks very similar to a TypeScript class and that's intentional. The syntax is very similar to JavaScript TypeScript. The main difference being instead of class here you see collection.
00:03:19.094 - 00:04:04.486, Speaker A: So when you want to create a new user, it makes sense to call the constructor function, which you would do if you were instantiating a new class. Now in this case, what I want to do is actually I want to use context public key. So when we run this code, context will be automatically populated with us, for us with a property called public key. Now public key is the public key used to sign this request. So when creating the record, the user, as you saw that MetaMask pop up previously, that's the same thing. It's basically getting us this public key. This will only be populated if the public key of the user is sent or the message is signed.
00:04:04.486 - 00:04:33.186, Speaker A: Otherwise you won't get it. So we might actually want to check here to say, okay, we definitely want to have public keys. So if public key is not there, we're going to throw an error. One thing to note is double quotes are also not accepted at the moment. That's a bug. We're going to fix that for you. So just make sure it's single quotes and then you can say you must sign the transaction just to let the user know that.
00:04:33.186 - 00:05:05.390, Speaker A: And then I'm also going to start. So as I mentioned before, this ID field needs to be a string. Context public key is of type public key. So we actually need to convert it to a string. And to convert it to a string we can turn it into a hexadecimal, which is kind of a string that starts with zero X and we can assign that then to the ID. And then we're going to also store the public key in its root form. So as a public key type as well because that enables us to use it with our permissioning logic.
00:05:05.390 - 00:05:50.890, Speaker A: Okay, so we have our user collection but we're creating an NFT data. So we're going to need some more collections here. So I'm going to create an NFT and I'm just going to give that an ID and then I'm also going to give it an owner and I'm going to give the owner as a user. So this is one of the really cool things you can do with PolyBase is you can pass in another collection or record from another collection into another record. So it's kind of like a foreign key or kind of a relationship between these two things. And again, I'm going to write the constructor for. So in this case we're saying we've got an ID string and we're actually going to pass in the ID this time for our NFT.
00:05:50.890 - 00:06:21.720, Speaker A: Very simple NFT which just has an ID that's defined by the user. Once you claim your NFT, no one else can take that off you or mint it. I can do this. ID equals ID, this owner equals owner. Great. So you can see just there's going to be a lot of this kind of assigning values from the parameters in the constructor, this boilerplate. We'll look to make this easier in the future but for now that's what you got to do.
00:06:21.720 - 00:07:09.080, Speaker A: So then the next one I want to probably next question I want is probably something to do with a particular chat room or chat group that you've been invited to or that you're able to access as an owner of this NFT. So we're going to obviously again, we have to have an ID stream that's mandatory. If you want to have an optional property, you can just use the optional property same as in TypeScript. But I'm going to leave that out for now. We're going to actually make this mandatory. Again, I have my constructor here. One of the things to bear in mind is that the semicolons here are mandatory, which is unlike JavaScript where they're not mandatory, they're mandatory employee base, at least for the time being.
00:07:09.080 - 00:08:11.618, Speaker A: So in terms of the chat, we actually probably want a members as well because we know who is a member of the chat, but we're actually going to gate it by an NFT. So actually we're not looking at who is a user of the chat. We don't care who the user is, we just care whether you have an NFT or not. So in this case I'm going to do again, I'm going to map over the ID which is a string, the name just a string again. And then members, I'm just going to set to an empty array for the time being and we'll add some logic around in a minute about how sorry, empty array. I like to just do all of the fields and the constructors first because I think it just gets me understanding the structure that I want to create and then finally we probably want some sort of message. So that would be again, we definitely need a string.
00:08:11.618 - 00:08:39.410, Speaker A: We want obviously the message is a string. We want the timestamp that the message was sent. So that's going to be a number, unix timestamp. So number of seconds since 1970 or epoch if you want to call it that. And then in the constructor we're going to pass in. Oh, the other thing we need here is obviously what chat does this message belong to? Otherwise it's going to get very confusing. Few messages from every single chat.
00:08:39.410 - 00:09:29.262, Speaker A: And so we have ID string here, message string timestamp, a number and a chat we're going to pass in as well. Okay, cool. Again I just need to assign these apologize for all this border plate. We'll make this better timestamp timestamp this chat equals chat. Okay, so we got some great boilerplate going on here in terms of our collections but one of the things we're missing first that I can recognize is that there's no way to actually add a member. So there's no way to add someone to the chat or even the original member can't be added to this chat. So we're going to add a function called add member.
00:09:29.262 - 00:10:34.860, Speaker A: Now all writes in PolyBase have to happen via these functions. Either the constructor to create or you can add your own custom functions if you want to update the record. This is similar to Solidity where you have to write a function and you can write any code in here. So you could write if this members length is bigger than five, then again we can error choose seam and we'll say too many people in the room. All right, so you can imagine there's like some really exclusive rooms, right? You can only have five people in a room. Whatever logic you want to implement here and then you've got some kind of thing to say okay, I'm going to members push and I'm going to add in this NFT. Right? Don't forget the semicolon at the end.
00:10:34.860 - 00:11:24.522, Speaker A: It's the most common mistake I make when I'm coding. Okay, so now we've got a way to add a member. But with all of these things at the moment it's very open in that I haven't defined who is allowed to read these messages and who is allowed to do writes and create records. So that's what we're going to do next. So I'm actually going to start off with Message because Message is kind of the lowest level primitive because to read a message you probably want to be part of the chat group. And to be part of the chat group, we kind of specify that you need to be a member, which you need to have this NFT. And this NFT has an owner and that owner belongs to some kind of so thinking through that, we obviously want to start with a message and say, okay, you can read a message if you are part of a chat and there's no semicolons after these.
00:11:24.522 - 00:12:59.210, Speaker A: These are called annotations or directives and there's no semicolon after these because you can actually write this. But I think it's been nice on a separate line. So we're saying okay, anyone who is part of this chat can read from this chat and then what we want to say is okay, so we've now given responsibility to this chat but we want to specify kind of more specifically what does it mean to give responsibility of this read to this chat group. Well actually what we want to say is if you're a member of this chat so what we can do is we can delegate our authority from here, from this into the chat and then from the chat into being having a particular NFT. And so this is quite powerful because we can basically say we don't care how chat does its permissioning from a message perspective, we just care that this is the chat and the chat is responsible for determining how the permission should be delegated. And again, in the members we delegate to the NFT. And then if we go back, we look at the NFT and we see, oh, actually, the NFT needs to be delegated as well to the user because the responsibility of the NFT or the control and ownership of the permissioning of the NFT is actually ultimately going to go to the user who actually owns that NFT.
00:12:59.210 - 00:13:30.450, Speaker A: And so we delegate to that user and then finally we need to delegate to this public key. And this enables us to basically end the chain of events. Everything needs to end at a public key eventually because that's what people use to sign requests. So you should always have kind of a delegate on a private key. Now the other thing we need to do is we haven't actually specified who can read chat. We've delegated the responsibility. So any control and permission that's been given to chat obviously goes to the NFT members.
00:13:30.450 - 00:14:12.690, Speaker A: But we haven't said who can actually read chat. So again, we're going to add a rule here to say you can read chat and you'll see this a lot with your collections is that you probably need to where you have a delegate, you probably want to have a read as well to allow people to there are some exceptions to that. And again, if you are the user, then you get to read your own public record, the NFTs. You might actually want to read public. It could be more interesting in that case. So maybe we'll add an app read at the top here. If you add an app read at the top then that means that the collection is anyone's able to read that collection, which is super useful in some cases.
00:14:12.690 - 00:15:12.510, Speaker A: The other thing we want to do, so we've now added read permissions and how we want them and we probably want to be able to control who can actually add a member here. And what we can use is that call directive and then in the parameters we want to specify what field is responsible for controlling this permission of being able to call this member. Now we can obviously, as we've done here, we can write in specific rules in addition to this. But this is quite good for the daisy chaining of permissioning from message to chat to NFT which would be quite complex and verbose to do as code. So this just kind of makes it a lot easier to do and we can say okay at call if you are a member. And so that's delegated to the NFT. So you can both read the chat group or you can add a member if you are already a member of that chat.
00:15:12.510 - 00:15:54.322, Speaker A: One thing to know about constructors is that anyone can call a constructor, generally speaking. So you'll need to add your own rules if you want to specify something a bit more specific around that. And the other thing to note is if we're passing in user, you have to have at least read permissions of this user in order to pass that in. So you wouldn't be able to have someone creating an NFT for some other user. You can only create an NFT in this particular setup if you have read access, which we do if we own the public key. So that's something else to keep in mind. So I think we're roughly done in terms of this code.
00:15:54.322 - 00:16:19.100, Speaker A: We might want to have some way to set name. For example, we're going to add that here. And again, we want to add this call to specify who can do that, but I think that's probably it. So I'm going to save this and hopefully there's no errors. If there is, it's probably two with semicolons. Okay, no errors. Great.
00:16:19.100 - 00:16:59.736, Speaker A: So I'm going to sign and request we can ask you to sign it four times because internally each collection is being saved separately to the database. And now that's saved, I can actually go into my collections and I can see I have all of the four collections here. So if I want to create a new collection, there's no button here to create a collection because the collections are derived from your schema. So you just add a new collection at the bottom of your schema and you'll be good to go. The other thing to note here is that this is what we're going to use for later. It's definitely worth copying your initiating your client code from here because we populate your namespace and this is required to access your collections. But we'll jump back into that in a minute.
00:16:59.736 - 00:17:21.600, Speaker A: Okay, so let's actually look at wiring this up. Now we've built out our collections. So I've got a Create react app here. As you can see, it's a very simple app. I just go to the root here. We use Chakra, which is a UI library for doing some of the basic UI elements. But essentially we've just got some roots here.
00:17:21.600 - 00:17:58.350, Speaker A: We use React router Dom for that and we've only got two pages. We've got a home and we've got Chat, and you can see these two pages here. So I've tried to keep the app very simple because what we're really interested in here is how we use Base and how we kind of wire up PolyBase to an existing UI. So I'm going to start this code so we can see exactly what we're looking at here. So we've just got a very simple thing and asking us to log in. Now if I click log in with a wallet it's not going to do anything because we haven't wired it up yet. So let's go ahead and do that.
00:17:58.350 - 00:18:58.690, Speaker A: So you've got the sign in button which is what we're going to use and you can see that this is the page that we were just on. We've got some logic to determine if we're logged in but we're not actually setting that at the moment. So first thing we want to do is actually install the Ur, the different libraries we need. So we want Client, we want React and we want Auth to client is basically anytime you want to interact, whether you're using React or View or any kind of vanilla JavaScript, this will interact with your database. React has some helpers to help working with React and Auth is used for kind of wallets and sign in and makes that process easier. Install those. So once those are installed you should be able to grab the dependency here and we want to grab our Auth and then we can just instantiate it here.
00:18:58.690 - 00:19:28.410, Speaker A: So Auth should be instantiated outside of your function and you should only instantiate it once for your app. I'm just going to do it here for now but we'd probably want to move it up at the scope a little bit if we were doing this for a bigger application. And then it's really simple. All I have to do is call. So this sign in is being called by this button here. Sign in login with wallet. So we're going to call this sign in function and let's see what happens.
00:19:28.410 - 00:19:51.788, Speaker A: Okay great. So this is actually what the user would see. They get an option for sign in with MetaMask or sign in with email. If they sign in with email there will be a custodial wallet. So we would have the private key for that. So less decentralized. But obviously if you're not already onboarded into web three, you might not have a MetaMask wallet.
00:19:51.788 - 00:20:27.950, Speaker A: And then you've got MetaMask which obviously just delegates to the MetaMask extension. Now, the great thing as a developer is regardless of which one the user chooses the experience for you should be the same or very similar. And that makes it really easy. And we'll be adding more authentication methods in the future. Different wallets. But from your perspective, you can use exactly the same API, regardless of what the user decides to use as auth. So let's go through and actually let's log out what this responds with.
00:20:27.950 - 00:21:06.034, Speaker A: Always interesting to see what's happening. So I'm going to just refresh this. Log in with wallet, login with MetaMask. I've already connected on a different website so it's going to just ask me to continue and then we're in. Now if we look in here we can see there's an object and we've got type MetaMask and a user ID that's all MetaMask gives us. So that's what we've got to work with if the user logs in with MetaMask. So obviously nothing happened because we didn't actually update any of the UI components.
00:21:06.034 - 00:22:00.146, Speaker A: So probably what we'd want to do is say, okay, if there's some response object from here then we'll set the logged in state. And so again, if I refresh and do it again, maybe start again with the process. You can see now I've got the logged in state which is just a quick UI update based on the logged in state. Now probably what I want to do is I mentioned before MetaMask only gives us those two properties but we really want the public key. So we're going to write a function to get public key if it's not provided to us. Sometimes if they use email, public key will be provided in this result. But if not we're going to find a way to get the public key.
00:22:00.146 - 00:23:17.540, Speaker A: So equals all public key. But if it's not available then we're going to say we're going to find a way to get it and I'm going to define a function up here, get public key and there's basically a way to recover a public key from a signed message and that's the way we have to do it. We're not given a public key straight away so the message is just going to be login with tap because it's a simple message, because we just need to sign any message. We're going to grab the signature and we can actually use the or fiber to grab the signature which would be east personal sign, assign that message that will respond with a signature and then we need to recover the public key. We need a separate library for this. So I'm going to just go and grab that from here, a library called PolyBase ETH. So this has some utilities in that just making working with ethereum based signing a bit easier because it's a bit of a minefield out there and these all work without any browser polyfills as well, which is nice.
00:23:17.540 - 00:24:05.390, Speaker A: So we want to be able to recover the public key from a signature. So we will get the public key back. Actually we'll just return that public key once we get that back. So we're passing the signature and we have to pass in the message again. So you don't really have to understand how this works but essentially if you have a signature you can get a public key from it that was used to sign that signature and that's exactly what we want in this case. So we'll say in this case get the public key of the user and then we've now got that public key which is great. The reason we want that public key is we're going to actually create a user based on that public key.
00:24:05.390 - 00:24:44.650, Speaker A: So next thing we want to do is actually create that user from our collection, this unit here in our database. And we're also going to want to load in the PolyBase library to do that. So as I said before, you want to grab this to instantiate the client. And we've got our DB now and we're going to say, okay, we want to create user if not exists already. So DB get user. We're actually going to try in here. So we're going to say DB collection.
00:24:44.650 - 00:25:16.644, Speaker A: So everything starts with a collection. So we would say user here and then we would say create. And then we have an empty array object here because if you look back at our code, we don't actually have any parameters. So if you had parameters, this, for example, would have an array of two items. But because there's no parameters here, we just put in an empty array. Actually, what I want to do first is check if the user already exists. So that's the first thing I want to do.
00:25:16.644 - 00:26:24.688, Speaker A: I'm actually going to do DB collection user, and I'm going to look up a record by ID. So look at the record pass in the ID and that ID would be our public key. And then what we want to do is say earth get. Okay, so if this fails because there isn't a use, we will create the user, but otherwise we'll check that the user exists first to ensure that we have the user. One thing to note about this public key, if I log this out, let's create the user first just so we can see what's happening there. Now the other thing we need to do here is we need to obviously tell when we're creating records or getting records from the database. We need to give PolyBase a way to actually call records.
00:26:24.688 - 00:27:05.244, Speaker A: So we need to actually do DB signer and pass in a function which will sign requests because the client doesn't know how to there's many different ways to sign a request. It just knows that it needs to sign a request so that it can create a record or get a record. So if you just click into here, we can actually see the signature type, which is this signer response, which is here. So we can just maybe grab that. We get the data in, which will be a string. That's the data we want to sign. This is always a static value.
00:27:05.244 - 00:27:39.724, Speaker A: We don't need the public key, but the signature. Well, we actually already got the signature using this ETH personal sign up here. And so let me just copy that in. So that's going to request a signature and we want to sign the data that the client library is asking us to sign because that's what the client library needs to sign. Okay, so now when we log in, we should create a new user. So let's go and give that a go. Okay, log out again.
00:27:39.724 - 00:28:16.372, Speaker A: Log back in. Continue it's now going to ask me to sign. Now this is to get the public key like we wanted to get and then it's going to ask me to sign another message and that's because we implemented the DB signer to read records and then finally the final record to create that new user. Okay, so now we're logged in and the user should be created. So let's go back to the Explorer and have a look. Now we can see here that there isn't a user and we might think, oh, that's a mistake, but actually it's because of the read rules on this collection. As an admin, you don't necessarily get the right to read anyone else's records.
00:28:16.372 - 00:29:02.184, Speaker A: It's one of the privacy preserving things of web three. But when in development it can be really useful to be able to see these things. So we can actually add the public parameter during testing so that we can kind of see everything that's happening and make sure everything's happening correctly. And then we could remove that parameter once we're ready. So now you can see that this now appears because I've made this collection public. The downside of this obviously is that everyone can see these records now, which is not what we wanted, but for testing it can be useful. Now, one thing to note about the public key that is created from your two hex function is that there are 64 byte public key.
00:29:02.184 - 00:29:57.610, Speaker A: Now there are two types of kind of public key and some of them basically have a prefix on, so there'd be 65 bytes. Some of them are 64 bytes, like this one is 64 bytes. So the only difference is you'll see zero x four if the prefix is there and you will see no zero four if the prefix is not there. This is something to keep an eye out for because different libraries use different keys and actually this is going to be returning a 65 byte key. So I'm just going to log this out here. You will be able to see that this key matches, almost matches what we need. So if I go back to the app, I will refresh and we'll log in, log out, log in again.
00:29:57.610 - 00:30:42.890, Speaker A: So we have to sign the messages again. So you can see this one here has zero x four and then the rest of the key is the same. If I copy this bit, you can see that this bit is the same key. So we do have the zero four prefix here, but we don't have the zero four prefix here. So we're going to need to just edit our code slightly to handle this zero four prefix. So all I'm going to do is I'm going to say, okay, return public key slice and we're just going to take off the four first four values and then add on the zero x at the beginning again. And that's just to make sure that everything is now the same in terms of the public key.
00:30:42.890 - 00:31:20.300, Speaker A: So when I log in again, it shouldn't try and create. A new user because it should now be able to look up. Let's just log this out. Okay, so let's try again and let's sign. Okay. And we got the user data back. So we know the user exists and we're logged in correctly, which is great.
00:31:20.300 - 00:31:57.370, Speaker A: So that's now working. But what we want to do is we want to now allow the user to mint their own NFT using the rules that we have in our next collection, which is the NFT collection. And so we need to pass in this time an ID and an owner of that public key. So of type user. So I'll show you how you do that right now. But before we do that, actually just one quick thing. One of the useful things to be able to do is to be able to every time now when we refresh the page we have to log in again.
00:31:57.370 - 00:32:57.424, Speaker A: But actually the auth is saved for you. So you can actually use DB, sorry, auth on Auth. And then we can actually grab the Auth from here, auth state and we can kind of log them in straight away if they are. So this will basically now when I refresh the page, it will automatically log the user in because we've already logged in from a previous session, which is obviously a nice feature. One thing you need to remember to do is add the signer because we're not calling this function anymore necessarily every time, but we still need to tell the PolyBase client how to sign requests so we can still do that using that method. And then we want to down here, we want to create an NFT. So our collection was called NFT.
00:32:57.424 - 00:33:27.904, Speaker A: So we want to do something like giving me some code here. So DB collection, NFT create oh, it was almost correct in here. In this create you need an array like I mentioned before. So the array would have two properties, the ID and the owner. So the ID is going to be the ID passed by the text box here. So whatever this value is will be passed in. So we're going to grab that NFT ID from here that's already been wired up.
00:33:27.904 - 00:34:25.802, Speaker A: You can see here the input set NFT ID so we can create a NFT like this. And then we also want to pass in the user. And the way you do that, because it's another collection is you say user record and then you can pass in the public key. Now we probably store this public key somewhere once we've done it once, but because we haven't done that, I'm just going to grab the code from up here and make sure we grab that public key again. Okay, so we've now got this NFT should be being created with whatever I put in there. And the other thing we need to do is obviously we need to get a list of records. So I'm going to write this query and we can do that by calling Collection again.
00:34:25.802 - 00:35:06.200, Speaker A: So everything starts with kind of Collection. We want to get the NFT and then one of the things we want to do is we want to import our React library which we're using React because it has some helpers in us to help us with read queries. And we've got something in here called Use Collection that will allow us to do automatic updates whenever. So it's kind of like the Firebase Listener where you get automatic updates of things that are changing. So we're going to have three properties here, data Error and Loading. The one we're really interested in is Data here and that's going to be our list of NFTs and then we can pass in our query. So as simple as that.
00:35:06.200 - 00:35:42.798, Speaker A: And then we need to pass in the data because the array of records is under the data property. So that should give us our list of NFTs. And if this is all wired up correctly, then it should work. When I now try to create an NFT, sorry, create one mint my NFT called Hello World. It's going to ask me to sign and then it's going to ask me to sign this message to say that that's correct. And you can see the NFT has appeared and it automatically rerenders itself because that's what the Use Collection does. It automatically updates whenever there's a change in the database.
00:35:42.798 - 00:36:15.720, Speaker A: There's a change in the database. So this is my NFT and so I think that's everything for this video we'll cover some more of the chat app and kind of going in and building out the rest of the chat app in the next video. But I think this gives a good overview of creating the Auth, creating your initial record and also reading a record from your collection and creating the UI. Hope that helps. If you've got any questions then make sure to join our Discord channel where we'd be happy to help.
