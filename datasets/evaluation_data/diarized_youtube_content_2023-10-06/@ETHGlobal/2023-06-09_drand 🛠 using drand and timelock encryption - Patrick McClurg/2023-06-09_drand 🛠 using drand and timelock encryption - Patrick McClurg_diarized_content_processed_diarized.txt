00:00:07.850 - 00:00:18.640, Speaker A: Hello, everyone, and welcome to the Hack FS workshop using Drand and timelock encryption. Joining us today is Patrick mcclerk, who will be taking us through the session. And with that, I'll pass it over to Patrick to get the session started.
00:00:20.050 - 00:00:42.780, Speaker B: Thank very much, Rory. Yes. Welcome, Everybody, to The Drand. Hack Best Workshop. First we'll go over a little bit about the challenges and then we'll dive into what Drant is and how it works. Then we'll finish up on what time lock encryption is and how you can use it. And then I'll field some Q A at the end for any questions you might have along the way.
00:00:42.780 - 00:01:53.200, Speaker B: So firstly, the challenges are twofold. First is for the best app built with timelock encryption that might not make any sense to people who have not come across time lock encryption yet, but we will get to that very soon. Secondly, there's a prize for the best use of Dran that solves an everyday problem and improves the security profile of a blockchain use case, a game, or improves the DRAM ecosystem. And there's $2,000 redo's up for grabs for people who make the best apps, essentially. Okay, so what is drand? Drand is a decentralized Threshold network from providing publicly verifiable, unbiaseable random numbers. It's based on Threshold cryptography, as I said, and supports pairing operations, which we'll come to a little bit later. Essentially, when the network is created, a verifiable secret chain process happens and a shared private key amongst all the permitted participants of the network is created which no single party has access to.
00:01:53.200 - 00:02:47.890, Speaker B: And then they emit randomness at epochs using the signatures from Threshold cryptography scheme. It's built on BLS twelve 381 has been tested, audited by Kudelski Security and deployed at scale. The biggest user right now is FalcoIn network who use the randomness from Drand for leader election and some other proof of space time related things. And currently Dran randomness is available on the FVM in the Cosmos ecosystem and kind of on Ethereum. In fact, in one of the previous ethereum hackathons, a team built ethereum integration for Drand called Oranges, which I've linked in the bottom of the slide here in case and if you want to try for yourself. So a bit of a primer on how DRAM works. The notation is not super important.
00:02:47.890 - 00:03:27.920, Speaker B: That's for the math nerds who like all the extras. But in essence, DRAM emits randomness epochs. Each of these epochs map to some time in the clock. So for our default network, that's every 30 seconds. Every 30 seconds, the nodes in the network gossip a partially signed message over the number of that epoch. And then when any node gains a threshold number of those signatures, they can aggregate them into one group signature. That's valid for everybody in the network because as I said before, no single node in the network ever has access to the private key.
00:03:27.920 - 00:04:14.800, Speaker B: That signature is indistinguishable from randomness as they can pre image it. Then we pass that signature through a hash function to remove some mathematical properties from it and that becomes our random number. And this happens at every single epoch. Everyone in the network gossips all their partial signatures to one another and create the randomness. You might be familiar with some existing types of randomness and I'll just give a brief breakdown of how Dran differs from those. So the one most people are familiar with is dev U random built into all Unix machines and Linux machines and Mac machines. And there's kind of an analog in the Windows world.
00:04:14.800 - 00:04:59.414, Speaker B: It's probably what you use to generate your bitcoin private keys and do lots of other day to day randomness operations. The biggest difference, obviously, is that dev U random is private randomness and DRAM's public randomness. So naturally you wouldn't want to give your bitcoin private key to anybody else unless you want them to take all your cash Drand. However, all the random numbers are public, everybody can read them, everybody gets the same random numbers. Additionally, you random on your own device. But Drand is a decentralized network, so there are lots of different participants working together to create this randomness. And finally, Drand is verifiable.
00:04:59.414 - 00:06:07.326, Speaker B: So if you were to get a number from a random generator, you've sort of got to trust in the fact that it's implemented correctly, that you're using the right generator, that the number that comes out is actually random. But because Drand is based on a signature scheme, you can verify the fact that that has been generated correctly. And because of the property we mentioned before of not being able to pre image the signatures, it's both random and verifiable, which seems counterintuitive at first. So dipping into some more of the public randomness world for people who built on Ethereum before, they may be familiar with Randao. Randao is a dao and a smart contract on the Ethereum network where users commit to providing some bit of entropy to smart contract and at a later point reveal that entropy. And those bits of randomness are aggregated together into a final random number. Dran differentiates from this is firstly, it's unbiaseable.
00:06:07.326 - 00:07:04.370, Speaker B: So you can imagine someone who has a lot of power in Ethereum network, like, let's say a coinbase, can actually take up many slots in this Randout contract and they can choose to reveal or not reveal their little bit of that randomness based on the prior output. So if you manage to get some number of slots at the end of any Randout epoch, you can influence the final result. Also, a cool thing about Dran being based on the signature scheme is that it's not just web three only. There's not a DRAM blockchain per se that's not just on one blockchain. In fact, you can get Dran beacons from any CDN, you can even get them from an adversary. And because they're verifiable, you can know that the Dran network has generated that random number. A final project which is very commonly used at the moment in blockchain ecosystems is Chainlink VRF.
00:07:04.370 - 00:07:57.910, Speaker B: Chainlink VRF allows you to request random numbers and they create some proofs and write them somewhere before you use them to show that the randomness has been generated fairly. Firstly, like Randao, like the difference with Randao chainlink is primarily for on chain applications, but also the trust model is very different. You're contacting one party chainlink to run that function to output this random number. Whereas Drand we have a network of participants and you must trust that there's never a threshold number of malicious parties in the network. So the model is just a little bit different. So a little bit about the networking. We currently run two networks in production, the default network and the fastnet network.
00:07:57.910 - 00:08:48.338, Speaker B: The core differences between them are that the default network emits randomness every 30 seconds, whereas the fastnet network releases randomness every 3 seconds. They have different URLs for interacting with them naturally and also they run in slightly different modes. So in the default network running in chained mode, each beacon contains a reference to the randomness from the beacon before it. This means that they form a bit of a merkel dag. And one drawback of that is that we can't do time lock encryption, which I'll come to later using this chained mode, the Fastener Network. By contrast, each beacon stands alone. It's not linked to the previous beacon through this chain of signatures.
00:08:48.338 - 00:09:34.580, Speaker B: And that means that we can predict all the future messages. Although not the signatures for beacons that are going to come out in a fastnet. That's a secret sauce for tambo encryption which we'll come back to in a bit. Also math nerd extra for any math nerds in fastnet we swap the G one G two groups in BLS in order to have smaller signatures and bigger public keys. Because at foundation of the network we create one public key and at every epoch we create a signature, which obviously is the randomness. So it means you can save gas costs if you're using it in the blockchain. So if you were to go into your terminal now and request some randomness from the Dran API, you would come up with something a bit like this.
00:09:34.580 - 00:10:25.566, Speaker B: The top entry here is the round number. So that is an epoch, that's a monotonically increasing number every time the network omits a piece of randomness is at a new round. It also maps the specific time on the clock so you can predictably know when a specific round is going to become available. The next key in it is the randomness itself, which is a Shah two five six digest the signature. Third field, the signature is predictably the signature. It's a group signature for the entire network. So again, it's the key pair that was done created during the distributed key generation process and it's BLS twelve for chain networks.
00:10:25.566 - 00:10:59.950, Speaker B: There's also previous signature, which, like I said, links to all those previous beacons. So the easiest ways to get to your rant are to use the client libraries. We provided one in Go and one in TypeScript. Those are the official ones. Of course. You can get it through any CDN, through any HTP client you wish, but these also bundle in verification of the signatures as well, just so you don't have to do it yourself. Also, everyone in our community seems to be a rustician, so there are a whole bunch of different Rust clients for those of you who like writing things in Rust.
00:10:59.950 - 00:11:41.310, Speaker B: And also actually this one top one, D, is also a CLI that can do time lock encryption and lots of other cool operations. So you should check it out because it's awesome. I've got a slide that says demo time now, which is slightly a lie. It's more a bit of a code walkthrough than a demo. Let me heal my presentation momentarily. I'm just going to go into the integration tests of the drank client for JavaScript. I think it's an easiest way to understand exactly what's going on and at least you can find it later in case you don't really remember what happened in that presentation.
00:11:41.310 - 00:12:21.980, Speaker B: So we've got an integration test here. Essentially you create some plumbing. We're fetching the public key of the network, which you can also do out of band. There are some other objects that allow you to not have to make requests for that. We provide three main functions. Firstly, you can fetch a beacon by the time you can just pass in a classic JavaScript date and the mapping between wall time and Drand epoch will be figured out magically for you. If you happen to know the epoch that you want to use, you can also pass that in and fetch a beacon just by its round number.
00:12:21.980 - 00:13:11.702, Speaker B: Finally, we provide a watch function. So if you're, for instance, building a game that needs to consume Dran randomness in a timely fashion at every single epoch, you can get an Async generator here that will call some callback whenever you receive the randomness. These are also more or less available in the same format in the Go library. So I shan't go into the Go library, but any questions on that obviously hit me up. Okay, so that was how to use Drand and a little primer and how it works. Let's now look into time lock encryption. It kind of does exactly what it says in the tin.
00:13:11.702 - 00:14:07.674, Speaker B: It's encrypting something nigh that can't be decrypted until some future time has passed. The crux is that the Dran network is a bit like a reference clock. It ticks for every epoch and emits that piece of randomness so we can rely on it to map clock time. Also side note, my colleague has presented the ten lock encryption scheme at Real World Crypto. So if you want to get a longer form explanation of how it works and all the gory details, you should definitely go watch the talk in advanced Encryption in real World crypto. So, diving a little bit deeper, how does time lock encryption work? Well, it's simple. Fancy math, I guess, is a short term for those of you whose eyes have just glazed over after going through school and seeing discussing things like this.
00:14:07.674 - 00:14:52.140, Speaker B: We're not going to dive into this, don't worry. I've simplified it just a little bit further. So I said in one of the first slides that BLS twelve three to one supports pairing operation. This is essentially exploding some mathematical properties of the equation, as it were, in such that you can move different things around without changing it. So inoc encryption, works a little bit like traditional asymmetric encryption. In traditional asymmetric encryption, you've got some public key that you use to encrypt a plain text, and the output is some ciphertext. And if you take the ciphertext and some secret key that has a relationship to the public key, you can combine them and decrypt the ciphertext and come out with the plain text.
00:14:52.140 - 00:15:59.850, Speaker B: What time lock encryption does is basically turns the round number into a public key, and the signature that gets emitted from that round number into a secret key. So, like I said before, in unchained mode, because each beacon is not linked to the beacon before it, we can predict the exact message and the exact bytes that will be signed over by the network at some point in the future. That means we know that message now, we can use it as a public key to encrypt something, and we won't be able to decrypt it until the Dran network emits that piece of randomness in the form of a signature at a later point in time. We've built some libraries around it, but also a cool web demo, which you're welcome to try now. It's called timevault. It is a web application for encrypting vulnerability reports, so that when you find all those Adobe flaws, even if they take you out with an assassin, the world can still know what you find. It's built using tlock JS.
00:15:59.850 - 00:16:23.782, Speaker B: Obviously, it's backed by the Dran network. I'm not going to demo it now, but you can obviously open in your browser and give it a fiddle for yourself. All the code's open source, it's all in GitHub. And there's also a paper and eprint if you want to know how it works. Before we do the Q-A-I will give the same. Not quite a demo of TJS. Again.
00:16:23.782 - 00:16:55.090, Speaker B: We've got some integration tests in there. I think those kind of give the clearest picture of how to use this in practice. But essentially we bundle some main net and testnet clients in here. There's a function called timelock encrypt. You pass a round number that you wish to encrypt to in there. There's some tooling as well around mapping that round number to a wall clock and back and forth. And then there's a time mock decrypt function which takes also a client and takes your ciphertext.
00:16:55.090 - 00:17:47.938, Speaker B: It supports an Asymmetric encryption under the hook called Agay, actually good encryption which works and looks a little bit like PGP. If you've already filled up a timeBolt, you'll see that the output of cyprtext here is this cool IG encrypted file, which again looks a bit like a PGP ciphertext. So yeah, I implore you to get involved, check it out and try out all the libraries. Luckily, I've left plenty of time for Q A. So if anyone has any questions about Drand or time lock encryption, I'm all ears. There are some in the chat. Here is links to the generator random numbers set.
00:17:47.938 - 00:18:35.310, Speaker B: Yes, indeed it is a shall two five six digest, so it's got Affixed lengths. Hypothetically, you could do your own hash key derivation function on top of the signature as well. There is in fact somebody raised a PR, somebody from the community raised a PR to do that on the DRAM repo. So there's some prior art there if you want to go and check out how they've done it or come up with your own derivation function. Tony, is it going to be available on chain? That depends which chain you're using. It is available in the Cosmos ecosystem already through the noise network that's nois. Also, Dran randomness is included in every block header of the FalcoIn network, so you can currently access it through the pre randow opcode.
00:18:35.310 - 00:19:35.670, Speaker B: If you're building an FVM actor, for instance, it's not currently available out of the box on Ethereum, although, as I said before, there's a project called Rngsis with a G and not a J that have built all the relevant bindings to deal on Ethereum if you'd like to do so yourself. Unfortunately, BLS operations are a little bit expensive as currently there aren't pre compiles on EVM for that, but there is an EIP up for them. So you should go and if you want them, go and hassle Ethereum people to get it merged. Max Ken asks, do you have a link to the PR for the transformation function to decrease the length? I can find one for you very quickly. Yes, you can find it somewhere here in the pull request and pull it out for you. Yes. Here it is from Mr.
00:19:35.670 - 00:20:20.418, Speaker B: Gorman. Although there also is some prior art in terms of if you for instance wanted to pick from one of ten items. There's a cool project called Derandomizer with an S, the glorious British spelling and not the American Spelling, which provides some tooling around doing that in the correct way to avoid modular bias and stuff. So worth checking that out. I haven't linked it here, but again, you can find all manner of projects under the Drand organization on GitHub. Surab asks where can we find some use cases? I joined it late so not sure what's being discussed. Well, that's up to you.
00:20:20.418 - 00:21:19.330, Speaker B: In the hackathon, of course. Some existing use cases we have seen, we've got some people building games on top of Dran. So for instance, for either randomizing item drops or defining the variables of certain NFTs for certain items and games, that's been one example. We're also working with a not for profit called Social Income who are providing universal basic income in Sierra Leone and they're working to use Dran to randomly select the people who should receive that universal basic income. We also developed a sample fem map called Deraffle, which is basically a bit of a raffle lottery type app for drawing winners from the smart contract. Some other possible use cases time lock encryption, a very cool one, which might be hard work in a hackathon, but mev prevention, minor extractable value. You could for instance, time lock encrypt the mem pool of a blockchain.
00:21:19.330 - 00:22:04.994, Speaker B: You could stop miners from either reordering or not mining transactions based on gains they think they might get from them. Other use cases generally drawing anything, anything needs to be fair lottery wise or in the time lock world, things like wallet recovery, automated dead man switches, auction applications. I'm sure there are plenty more that you guys can think of that I haven't thought of and I hope that's the case. I'm excited to see what people build. How can we get your slides? That is a great question. I will make them available through the hackfs people. I'm not sure if there's a centralized channel for that.
00:22:04.994 - 00:22:31.340, Speaker B: I can also stick them on IPFS after this and post the Sid somewhere for people to retrieve them. Yes, obviously if you have any further questions, you can ping us on Twitter. We're also on Bluesguides, we're hipping with it and there's a link to our Slack workspace here as well. Lots of people talking about different use cases and cool things that they're building in there. So feel free to get stuck in.
00:22:32.670 - 00:22:38.526, Speaker A: Hey Patrick. Yeah. For the slides, if you want to post them in the Discord channel that might be another option as well.
00:22:38.708 - 00:23:07.130, Speaker B: That's the best idea actually. Yeah, I will do that immediately after this talk. Awesome. Have we any final questions from the chat? Well, if that's the case, thank you very much everyone. Thank you for listening. I hope to see lots of cool applications built on Drand and any questions, find me, ping me, tag me and hopefully I'll be able to answer them.
00:23:10.300 - 00:23:11.790, Speaker A: There was last question.
00:23:12.480 - 00:23:44.100, Speaker B: Can you iterate on future file encryption? Well, one cool iteration on time off encryption that we would love to have is some kind of proof system on top of it. Right now there's no way to link if I say I'm encrypting something now to prove that what's in there is actually what's been encrypted. That's quite a research project and would be a lot of work for a hackathon, but if somebody does it, that could well be worth a prize. But anyway, thank you very much and happy hacking.
00:23:44.840 - 00:23:54.712, Speaker A: Cheers. Thank you Patrick, and thanks for everybody for attending. Good luck with rest of the week hacking and we'll see you for next workshop in a little while. Cheers. Bye.
00:23:54.856 - 00:23:55.528, Speaker B: Cheers. Bye.
