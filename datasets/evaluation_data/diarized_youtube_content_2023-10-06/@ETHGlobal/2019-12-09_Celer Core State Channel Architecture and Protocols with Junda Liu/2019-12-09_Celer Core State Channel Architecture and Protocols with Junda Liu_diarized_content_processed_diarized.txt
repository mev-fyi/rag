00:00:00.170 - 00:00:52.346, Speaker A: So let's get started. The talk is State Channel architecture and protocols. This is just upfront, this is not a state channel 101. This is really more in the advanced level to reason about why Seller network decides on this kind of architecture and what on the more like a lower level, the protocols, how does the protocol work? And you know, Seller Network starts with a simple mission we want to scale all blockchains. Yes, apparently Ethereum is one of the most active ones, but we do support different kind of public blockchains. The idea here is we try to adopt a layered architecture. So when we want to say work with another blockchain, the only thing that's different is you can think about the adapter layer that runs a smart contract on a different blockchain.
00:00:52.346 - 00:02:08.182, Speaker A: And the technology path we have chosen is L2 state Channel. The benefit is pretty obvious, right? With State Channel compared to sidechain or all the other different scaling solutions. It has many benefits like instant finality and also the throughput can be linearly scale out instead of you have to beef up the network or you are limited by how many block proposers you can get because in say channel there is no block. The speed can be as fast as the internet and we have been in production for a few months and with actually pretty I would say in terms of within the blockchain community pretty amazing numbers like for the monthly active user, for the transactions we have carried through with real money, real ETH or Die or the other tokens on the main net. And on the other side, our users, coming from 89 countries. I think that's kind of something really hit me as oh, this is the power of the blockchain. Aside from the users, we are also very actively working on to onboard the non blockchain developers onto the blockchain world, especially on the seller platform.
00:02:08.182 - 00:02:58.866, Speaker A: So we actually have more than 250 developers already signed up on our developer portal. More than 100 games submitted. The idea is we want to kind of hide or encapsulate all of this complexity be it interacting with on chain beats off chain beats, all this complexity within our SDK and we expose very simple, easy to use APIs to developers. So our tagline is basically say two lines of code and you're good, you're good to go. You can run your caro games already on Seller platform. Aside from the gaming vertical, we also provide a more generic seller web SDK. Just I think many of the current blockchain developers are more familiar with web based front end development.
00:02:58.866 - 00:03:53.362, Speaker A: So using the web SDK it enables yes, you have to deal with a little bit more detail, like a little bit more lower level operations, but then you get the flexibility to say you are not restricted to only having a game. Right? You can do many of the many people talk about the DFI, whatever the derivative prediction market. All these kind of fancy all the hot topics that people are talking about in the community. You can benefit from the L2 solution. In short, it's instant finality, meaning you don't have to wait the moment there is a message co signed by all the participants, it's finalized. And the other part is there is literally no transaction fee. There is nothing about that in past hackathons like in East San Francisco and Boston there are projects actually building very interesting streaming payments.
00:03:53.362 - 00:05:15.666, Speaker A: Basically say because the payment today is so low cost, so instant, you can use that in some new way that prior that no one thinks it's even possible, right? Basically, literally I'm doing the payment every second and a very tiny amount you can even pay just single way, right? No one will ever do that on blockchain because the gas fee will be already so expensive. At the same time we open source our code smart contract everything and the full protocol specification including the motivation and the kind of the trade offs we have to make to make the protocol work efficiently. So, just a quick summarize. So Seller Network already has the larger scale production network running for a few months with the real user numbers and real money playing as one of our seller X vertical for Esports mobile games. And in the past one year and a half since Seller Network the project started, we have been driven by real use cases, basically real user feedback, be it experience, be it onboarding, it's too slow to interact with onchain all these ten points. We have internal rapid iteration to solve, basically to identify the problem and find a good solution for that. At the same time, because there are different other projects very interested in the state channel space as well.
00:05:15.666 - 00:06:17.698, Speaker A: We are leading the cross project standardization process. Basically we say instead of everyone reinvent the wheels, let's sit together, we share what we have learned from the process and get different ideas and see how we can make it more like a common agreed upon spec. Then all the projects can benefit from the last part. As I mentioned earlier, our developer portal already has more than 250 non blockchain developers sign up and then submit their games. Yeah, that's kind of the high level overview of what Seller Network, the project, the technology underneath and also the first vertical we pick for mobile esports. Now, what's coming next will be a little bit as I mentioned earlier, it will be a little bit advanced but then there's nothing like rocket science. You need like complicated formula but then the design and the thinking behind that I'm hoping even you are not really interested in a lower level system design.
00:06:17.698 - 00:06:58.814, Speaker A: You might get some kind of inspiration and say oh, this kind of design philosophy could help. First of all, it's pretty simple. We adopt what we call a layered architecture. Many people know, like the Internet has been so successful today in terms of academia of the industry, many contribute the successful or the super high scalability to their layered architecture design. Because you have the lower layer physical or IP layer, then you have application layer. Each layer promise a common agree upon interface to upper layers and they don't even worry about what's the new application you want to run. Imagine the Internet.
00:06:58.814 - 00:07:47.780, Speaker A: The core of the IP protocol was defined 40 years ago and then at that time people might say, oh, it could be some other fancy application that use up to like one kilobytes per second. Now today if you look at the Internet today we have Netflix, YouTube, streaming, real time, even 5G enabled like remote medical operations. All this doesn't even change the IP layer. So that's the power of layered architecture. And I think Cellar Network kind of being the founder's background also coming from the computer networking research, it comes as pretty natural. Say hey, we want to separate the concern we identify oh, the bottom is what we call the anchor to the main net or to the blockchain. And then on top of that we have what we call a payment channel.
00:07:47.780 - 00:08:41.006, Speaker A: It will be a payment network only takes care of what token you want to exchange within this layer. Two network. Then on top of that we say if you want to write your own, say financial Prediction market or you just want to write your own goal or chess game, that's our application. So this simplifies three layers, right? The bottom is the Minnet, the smart contract and the middle is our payment network and on top is the applications. This give us kind of the benefit. Just like the internet, it's simpler in each layer and at the same time you can really optimize within each layer. Say hey, I can make it even more efficient by not worrying about too many different use case imagine when they were designing the IP, they have to consider how the YouTube works there, right? They didn't.
00:08:41.006 - 00:09:37.362, Speaker A: So that's why it's so successful because they focus on how can I make IP protocol only solve? The single problem is like routing or reach any other node on the internet. That's it. And even for reliable transportation, it's the transport layer's job. After that it's Http or Google has done all the other stuff like Quick or anything. But at the same time, remember, just like Internet, the flexibility is much greater because we define this layer, we say that's it any application as long as you comply to our interface, which is actually pretty minimal, you can run on top of seller. Now let's kind of zoom in. Say what defines a payment channel, right? So what really is the minimal information you need? Just like for IP, you need the source IP address, destination IP address, some hider, some sequence number, some checksum, right? For payment channel we also have to define kind of a data structure.
00:09:37.362 - 00:10:13.934, Speaker A: So this is like the core of a cellular network data model here. Again, this is like, after several iterations, this, we believe, is pretty optimized and between two peers. Instead of try to maintain a shared single number, we actually define two one direction, what we call simplex. And in each simplex, the owner of the simplex, basically the sender of the simplex, is free to update its own sequence number and say, hey, this is the new state. This is a new payment. I agree with you. Here you go.
00:10:13.934 - 00:11:18.550, Speaker A: And what the receiving end need to do is simply cosign send it back. This avoids many of the common issues caused by the other project say hey, you need to have two nodes try to maintain agreement on updating a single number and oftentimes that doesn't work because your client may get disconnected. Especially if you think about the mobile environment say the guy walk out of the hotel and he disconnect from WiFi reconnect on 4G or Lt network then your previous cosign negotiation will just break. So that's like optimized for really production use case anytime the other peer is reconnected they can resume the communication and no one need to really wait or even blocked by the disconnection and also what we show here is literally literally our actual data definition written in protocol buff. It's something from Google, it's also open source, well supported. The only actual we add. You can see this soul type.
00:11:18.550 - 00:13:32.590, Speaker A: This is something we contribute to the community as an open source project and also recognized by the official Google protobuff project on their Wiki page to say, oh, by default, protocol buff support, like common languages, JavaScript, C plus plus Java, Python, Go, blah, blah, blah, and all that. But of course, no solidity. But we do need the capability in our smart contract to decode protobuff encoded binary data and we look around there were some kind of hobby project it doesn't up to the quality we expect so we kind of invest our engineering resources. Let's make one and this is a hint to tell the open source solidity generator that reads this kind of data structure and automatically generate a decoder in solidity, right? So I think that's actually on GitHub seller network it's called PV three two soul that's the PV three Genso that's the solidity code automatically generator we have done by reading this data schema definition and the reason we have to add all these types this is the solidity native type. Again, we could just use like bytes but it will incur much higher gas cost so that's the optimization to the minimal to the maximum solidity has native uint 64 but the reason we put uint here is to save literally literally four gas in unit in gas unit four. The reason we have to do this because imagine this data structure will be used really frequently between all these communications even a saving of four is worth it. There's a flow machine where's like two you don't need the two address the channel ID is the hierarchical data is one channel ID define the two participants and one simplex only need to define their owner as peer from yes, that's a good question.
00:13:32.590 - 00:14:02.460, Speaker A: Thanks. Yeah. And now we move on again, right? As I mentioned earlier, this is more like a deep dive into the Seller core technology. This is how we define a conditional payment. The reason is the whole purpose of L2 is to enable frictionless. Low latency, zero latency, the same latency as internet latency, right? There is no block, there is nothing, there's no agreement or consensus needed. The only consensus we need is the cosine of the message.
00:14:02.460 - 00:15:01.658, Speaker A: But then at the same time remember this layer, just like IP, need to be flexible enough to support upper layer applications and we cannot predefined say oh, you can only write the games on top of seller. So we make it very generic. If you say this is just defined a payment for payment it doesn't have because the payment could be multi hop. We define source and destination. Basically. In other term, source is the payer, the destination is the payee, right? And then it can say the pay only happens when the conditions are satisfied and of course the condition has different types. And for the pay we also defined how do you let's say you have a pay, has a condition on tomorrow's temperature and how the moon is aligned with the earth and then you say those two numbers combined together is how much I pay you, right? So that's the complexity we can support and the flexibility.
00:15:01.658 - 00:15:37.550, Speaker A: We kind of say we define the common basic abstraction but at the same time it can enable all kinds of wild application the developer can think about. Yeah, I think before that up until now we have been very clear about between two peers. That's what we call the hop by hop conditional payment. Primitive. It's just like on the internet, you know, there is a hop by hop very similar in seller network design. Then we say borrowing again from the internet philosophy. Design philosophy.
00:15:37.550 - 00:16:42.362, Speaker A: It's an end to end argument. We design the multi hop payment network. Basically, instead of only support between two directly connect peers, you can send your payment through all these relay nodes to reach your actual final destination. And I think this actually gives you the flexibility. We are using the same seller network to support arbitrary D apps, right? So basically you can have a chess you don't want every time the two players want to play one round of the chess game, they need to set up a state channel upfront. You don't need to do that with Seller as long as they both join the seller network, the routing algorithm automatically finds the optimal path and make sure that the two players just like they have will feel the same as if they have a direct connected channel, but in reality they are actually multi hop underneath. So basically today when you say I'm connecting to Google server, you know, it could even be like dozens of routers between you and the first Google server that respond.
00:16:42.362 - 00:17:52.302, Speaker A: But you don't see that, you don't even care about that. That's the same idea here. So the reason again to really make it easily scalable because now we are pushing more of the complexity onto both ends, the source and destination and all the nodes as a relay node in the middle, just like an internet router does very simple relay of the kind of they receive a conditional payment, say oh, I'm not a destination. Where is the destination? Using the routing algorithm, find the next cop and send it out. I think that significantly minimize and reduce the relay nodes complexity. And that's kind of another reason we can learn from why internet can scale out so easily because you can easily deploy more routers and then the clients can join and interconnect the whole network with multiple hop. Now basically we have per hop primitive, then we have a multi hop network, then we say what else we can do? Right? We have deal with the Boolean condition that's a little bit more like I mentioned earlier, like say B and C are the relay nodes.
00:17:52.302 - 00:19:00.262, Speaker A: They just need to do the counter pay request and response between the next hop and the final resolve of the pay happens between you can see the dashed line happened between the actual source and destination A and D. Yeah, again, all of these materials is also on our website with more like detailed documentation. Say hey, the design is in such a way because we consider all the others. Like for example security guarantee for example, oh, you do not want to assume the client can always be online watching something, right? So I think that's all the design choices we have made to lead us to this kind of final engineering solution. Yeah, after we have done with Boolean. Basically the idea here is that cellular network has been designed with very optimized for common case bullying condition. Meaning you either pay or not pay, which already cover I would say more than 90% of the cases people can think about, right? Especially in real life, you think about a payment, especially a partial payment is actually not very common.
00:19:00.262 - 00:19:42.002, Speaker A: If you go to a merchant, they will not say hey, you pay me. Depends on how many push ups you can make, right? Basically it's more like a fixed price. It's either happened or not happen. So in our term it's called bullying condition. And because of the flexibility of this multi hop primitive, we can support numeric. Go back to the example earlier. In ads like Google, Facebook, when they try to make money from the advertisers, they actually use something called second price auction, which is a common game theory conclusion that hey, even you are the highest bidder.
00:19:42.002 - 00:20:37.302, Speaker A: Let's say you are bidding for showing your ads. Just to keep it simple, let's say you want to bid for the painting in the entrance, right? You say I want to go bid say ten e but if you later you learned the second bidder only bid one ETH you will feel oh, I paid too much, right? So the common reaction would be it will be great if my actual pay is only a little bit higher than the second bidder or even the same right that actually will encourage every bidder to beat their true price from their heart. So basically that's the game theory trick. You can do a know of course there are tons of literature research about that and it's actually really that's the money printing mechanism for Google, Facebook and all the ads company. The advertisers are free to bid much higher. Price. But in the end, they don't pay that price.
00:20:37.302 - 00:21:29.302, Speaker A: They only pay who paid the second highest bid price. And that's where the numeric comes in. So basically you say I'm willing to pay say ten if but in the end, you know, if the second highest bidder is only one, you only pay one. So that's a numeric case. And on Seller Network we also support that, which is kind of yes, it will be more complicated than a simple Boolean, but we still try to make sure the interface just like on top of IP, you can have TCP that provides reliable transmission and also UDP that say I just do whatever I can. Yeah, this kind of is right now in production on top of the Ethereum Mainnet. What we have has been running for a few months and we kind of have been to different hackathons and have developers try.
00:21:29.302 - 00:22:46.954, Speaker A: Some developers say, oh, I really like the idea of a mobile esports game. I'll just do the gaming on selects. And some say, hey, I'm really into this whole DeFi prediction market or like derivative thing. They can do something using the web SDK. Right. And the power of this modular architecture will actually show we are not limited to what we can provide today the same interface can actually support if you are into the blockchain space you might heard about some other idea like Nitro which on the surface looks completely different but it's one other choice. It's a kind of proposal for state channel but then when we take a closer look at hey our underlying primitive actually can make that happen I think another notice from the original Nitro proposal I think they are still having some issue with the multi hop and remember we already solved the multi hop problem on top of seller we actually using the underlying hop by hop primitive we can actually make Nitro working multi hops than the original independent Nitro protocol.
00:22:46.954 - 00:23:08.120, Speaker A: So I think that really showed the power of modular layered architecture and design. Yeah, I think that's the last slide I have for any question. We have all this communication channel you can think about and also our documents and what I actually mentioned in this whole talk is public on our website. Yeah, that's it. Thank you.
