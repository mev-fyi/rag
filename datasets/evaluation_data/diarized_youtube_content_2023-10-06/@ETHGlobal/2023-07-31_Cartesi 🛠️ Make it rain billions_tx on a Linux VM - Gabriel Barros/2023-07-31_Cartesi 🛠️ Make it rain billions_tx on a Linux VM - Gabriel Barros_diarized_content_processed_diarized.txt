00:00:07.370 - 00:00:40.566, Speaker A: Today I'm here to introduce you Cortesi rollups. I'm going to give you a quick overview of Cortesi, how it came to be and a little bit of how the rollups itself works. What is the basic infrastructure that makes it possible. And I'm going to show you a few projects that's been built using Cortez and other hackathons such as this one. So as Nick peek. This is a python code. It's kind of like a script at this point, but it's basically a Cortesi DAP already.
00:00:40.566 - 00:02:05.070, Speaker A: This DAP is Echo smart contract. So it will be the equivalent of having a solidity contract that whatever it receives, it replies it back as an Ethereum event. But here you can see that we're importing Python libraries, we are using Http requests and how the fuck is that possible? Right? So Cartesi here, I feel like this kind of public, we don't need to explain the trilemma again and what AVM brought to us. Basically, Ethereum brought some very interesting properties, but it came at a cost of scalability and EVM itself. It's a really good machine to embody the necessities of the constraints of a blockchain, but at the same time it limits our content capability. So meaning that even if you by some magical reason manage to get much more output from the EVM, you're still constrained by the format of the machine itself. So the idea is what if we can have complex computations and blockchain security guarantees and still add great tooling to it? So basically, what if we can have Web two ecosystem going back towards the blockchain? So the basis for that is two pieces.
00:02:05.070 - 00:02:40.960, Speaker A: First, Cartes is application specific, meaning that you can deploy this on top of any other network or on top of any other roll up. It can be a zero knowledge roll up, optimisec roll up. As long as EVM compatible, this could be deployed on top. So it technically is a layer end solution. And the second one is the Ris Five deterministic machine. Because of this platform processor, which is an open source competitor to some extent to Intel Med, you can have an OS. So meaning you can have Linux back.
00:02:40.960 - 00:03:42.686, Speaker A: And in this way basically you're enabling the ability of having JavaScript, Python, SQLite databases, any of the other framework and tooling that we used to to support our applications. Because the Cartesian machine itself is deterministic, meaning you can do interactive fraud proofs back on the base layer that you chose to deploy. So to be more visual, this is what it looks like to be coding for the EVM ecosystem. Right now you have a very good Plier and sets of Pliers, but that's it, right? If you need to nail, you cannot really do it that properly. And Cortez is trying to bring back all the tooling that we used to have and that really looks like this. Your Cartesia DAP at the end of day is a docker build. You basically do your recipe, your docker file, you build a docker image, bundle that to the Cartesian node.
00:03:42.686 - 00:04:23.454, Speaker A: Now you've created a node that is specific to your DAP, meaning you now have your application specific rollout and that's what it feels. You can have your favorite language, you can use complex libraries to do things that we just take for granted. Like for instance, logarithm. You can have all these other frameworks, even that one star repo that some size just coming so handy. You cannot really use that with solidity, really. Right. And here is like an attempt to compare what it means to code in such platform when compared to EVM.
00:04:23.454 - 00:05:16.590, Speaker A: So being very generous to the Ethereum network right now you can have a maximum of 30 million gas per block. And the less expensive useful upcode would be add a subtraction which costs free gas. So we're looking at 10 million instructions per block. That's being very genius, right? And to boot Linux, and we know this because we have all the inspections here, it's kind of small to read, it's about 36 million instruction cycles. So that's just Linux booting and being ready to do whatever you program it to. And just to be fair, then we limited the Cartesian machine to 13 seconds execution, which mean the average block time, right? And in 13 seconds on a laptop such as this one, you can have 3.7 billion instructions being executed.
00:05:16.590 - 00:06:01.182, Speaker A: So the power that it brings back is very huge and it's even difficult to grasp. So here's an image that helps you with that. That little black box over there is the 10 million instructions of EVM compared to the 3.7 billion ones of a 13 2nd execution on Cortesi. So how is the roll ups itself, right, an overall architecture here for people who are not familiarized, things don't change too much. I realize now that the white contracts didn't work too much, but basically you're going to have let me see if my pointer here works. Yeah, you still have your connection with the JSON RPC here because it's still a roll up.
00:06:01.182 - 00:06:59.794, Speaker A: So to start that sent you're committing your information, you're committing your information to the chain for the roll up. So you don't have the impasse of the data availability. And then the node that you build here represented as criticizer roll ups framework. You'll be digesting this information and that might be you as a validator, that might be the user as well, trying to verify whether or not you're doing something wrong. And as it digestes, it can create new outputs that go back to the theorem chain. So it might be, for instance, just the merker root for the state of the machine or might be like new transactions that will do like withdrawals, for instance. And inside I chose to make a little bit of a highlight of this Http rollout server here.
00:06:59.794 - 00:07:36.218, Speaker A: So this is still a machine. Linux doesn't know what the fuck it is doing inside there, right? So to deal with the drives, to deal with the low level communication of halting the machine, getting a new drive, inputting the information that came in this new digest from the chain, then holding the machine again, getting this binary information of the output drive, interpreting it and putting as an output to the ethereum chain, for instance, will be too much. So we created an abstraction. We created this. API rest API. It's four endpoints. The documentation can read in 30 seconds.
00:07:36.218 - 00:08:07.160, Speaker A: And just by hitting these endpoints, you can have an abstraction of how to input information and output information into the chain. So then all you need to do as a developer is really choose your language, communicate through this API, and there you go. You can have a smart contract in the shape that you like. It can even be like a microservice. I don't know what for, but if you choose to do so, it could. So talk is cheap. Let's go back to that code.
00:08:07.160 - 00:08:36.850, Speaker A: Not trying to explain every little bitty nitty gritty detail here, but to this side, to the left side, we created this little helper tool. It's similar to what forge have been trying to do. So you can sign transactions easily and call contracts. For now, we just create this custom one. And with this, you can send payloads as input or as Ethereum calls to certain extent. And you can read all the outputs here. Notices.
00:08:36.850 - 00:09:25.622, Speaker A: We call them notices because yes, just one singular difference from the Ethereum events. Ethereum events are not provable. If I give you a payload for ethereum event, it doesn't mean anything without the hash addression. And really, it only means something if you go through the chain and verify that it actually creates the output, right? And notice have Merco proof attached to it. So as long as you have the state, the root tree of the mercurialization of the machine being committed to the chain, from that merkel root, you can create the Merko proof for anything the machine creates, such as the notice. So you can prove notices on chain. And here is just listing the new notices created at this epoch.
00:09:25.622 - 00:09:50.994, Speaker A: And here's the thing. So this program here should do the echo thing I was talking about, right? So from there, like I was saying before, you import requests because you're going to be doing Rest requests. You get it from the environment variables. We already put it there. Easy for you. And we have two top level handlers here. You can create as many endpoints as you wish.
00:09:50.994 - 00:10:34.722, Speaker A: But these two top levels here are obligatory. Why? Because just like Ethereum EVM, there is two states of how to run the machine. There's one that will change the state of the blockchain, and there's one where you're just trying to digest information from it. So it's ephemeral. So if you got inspect state here as your request, type it means that no matter how much change you do to the machine, all of it is going to be throw away. Just like on a hypervisor and VMs. And if you got a best state, you really should be careful with whatever you're doing because however you stop the machine there, it's going to be the state that the machine will be for the next transaction.
00:10:34.722 - 00:11:36.134, Speaker A: So this is still code, right? If you throw and you lose your process, there is no way for you to restart this. It's kind of like self destruction, a contract or putting in a bad state. Just like the Parity wallet hack. And the only last thing I think it's worth mentioning more specifically is that every time you get these new requests, you should reply back what was the final stage of the whole processing. So you should go back and say status accept. If you say status reject or you don't reply for a long time, the hypervisor, quote unquote hypervisor will understand that something went wrong and it will tag that transaction as a reverse, so to speak, and it will revert back the machine. So here in this case, we would get the information here, we would unroll the JSON request, we get to the advanced state top handler.
00:11:36.134 - 00:12:13.890, Speaker A: We didn't register any other handler, just this global one here. You see like I'm getting the payload, I'm just creating a new notice with the same payload because supposed to just be an echo. And finally I just go to slash notice with that payload. I'm creating it, you can call it as many times as you wish, return the accept thing I was talking about before and you close your loop. It's an infinite loop program in this case. So you're always waiting here at Finish. So Finish is a special endpoint that will halt the machine.
00:12:13.890 - 00:13:10.406, Speaker A: You don't need to do anything else, especially because this machine is deterministic and single threaded. You don't need to be managing these scenarios, these edge case scenarios. So the idea here is really like you can further decentralize your DApps because sometimes the DApps are not so decentralized because they lack CPU power or they lack the expression capability of putting there all the rule sets, all the necessary quarter cases, handlings and everything. You can of course then express more complex logic. And this extra processing power lets you leverage the traditional stacks that we had before. And it also as a new project, you should be thinking sometimes that the talent pool for web three people is really short. So maybe you can get started with two, three people.
00:13:10.406 - 00:14:32.350, Speaker A: But as your project grows, you need to hire more people and it's way easier to tap into the web two talent pool so it's easier for them to be onboarded with such technology. So let's see the impochs. So I collected two examples here from previous hackathons and attempts of building things with Cartesi and one of them was just at East Global Lisbon just before and she was actually a track winner, track finalist. And what she did was to put an LLM inside a cartesian machine so she could have verifiability on the outputs produced by the LLM. Her concern was kids very soon will be using PT and likewise tools to be learning about things just like Google. And at some point they might be questioning something like, okay, I'm going to run a marathon, what should I be drinking to maintain myself hydrated, right? And then she wants to avoid this scenario where it goes like, oh, you should drink Coca Cola or you shouldn't drink beer. And not having the proof that this is happening and not having where to start to backtrack and see where in this case, Coca Cola influenced the LLM model to be producing such a propaganda instead of its responses.
00:14:32.350 - 00:15:32.374, Speaker A: So she created this, how to say, sandboxed on chain version of LLMs that can have diversified. The second one is a curious one. So this guy, he wanted to intervene in the situation of clocking and clocking out into government offices. So it happens in many places, but especially in Brazil. These guys, they find ways around the system to not be there, take longer vacations or be late every day and still show on the system that they are there by using silicone fingers or by bribing the guy that's supposed to ensure that nothing's going on wrong with the machine. So what he did is twofolded. And here what I like about this example, is just what he could use, not exactly the example he used OpenCV to do the biometrics so he can identify the fingerprint of people.
00:15:32.374 - 00:16:10.866, Speaker A: And he used a machine learning model to avoid the spoofing of the information so he can detect whether or not there was silicon fingers used or reuse of images and things like that. And that was all running on chain, actually off chain, but being proved on chain. Here we have this community website of Rolluplab IO. There's several examples using Cortesi there, it might trigger your curiosity. There's things from Dows to games. It's really cool, resource. And at East Global here we are tracked as well.
00:16:10.866 - 00:16:52.538, Speaker A: So we have up to $10,000 of prize pool and I hope I can see you there. I'm going to be at the booth me of my friends. I'm going to give you all the support that you need. One final announcement is that we are launching on main ads next month, probably with a Honeypot DAP. So the foundation is supporting this initiative where they are going to be putting money inside this DAP just as a target for hackers and other developers to try to steal it as a showcase of the security and the verifiability of the rollout framework. I thank you for being here. This has been nice.
00:16:52.538 - 00:17:31.274, Speaker A: It's always really good to be at East Global talking to interesting people. But before I go, I have one more thing. So a few months ago, this guy went to Twitter to say, if Ethereum is the world computer, why haven't we seen Doom running on? Like how so? Right. And one of our collaborators, core developer Eduardo, he, actually took it on and he put Doom to run on the cartesian machine. If you want to check it out. We are running actually a leaderboard downstairs at a booth. You can play there.
00:17:31.274 - 00:18:04.408, Speaker A: There's FOAPS and stuff. Thank you again, guys. Thanks. Does anybody have questions? Aloe briston? First of all, my first question will be how do you handle upgradability? Upgradability? Yeah. In a cartesi roll up. Once you deploy the first smart contract. The DAP.
00:18:04.408 - 00:18:18.360, Speaker A: Yes. How do you upgrade? What do you need to upgrade? For sure, I feel like we are kind of like in 2016. 2017 a serious situation. How we deal with upgradability.
