00:00:06.330 - 00:00:53.354, Speaker A: You. So I guess what I wanted to talk about a little bit is I think some of the trends, the big trend that I think I see happening in layer two space right now and like, most simply put, I would say that trend is diversification. So what we're seeing, especially over the past year, year and a half, two years, is that the number of scaling solutions out, and particularly layer two scaling solutions, are exploding. We're getting huge, huge numbers. And I want to talk about sort of like, first of all, the history, like, what gave rise to that? How has that progressed, how has that changed over time? And maybe also what we should be doing about it. Sound cool? Excellent. Okay, so I see a lot of familiar faces in the room.
00:00:53.354 - 00:01:28.518, Speaker A: So hopefully you guys have an understanding of what l two does. I like to think of it as like literally a layer cake where we add things like trust, assumptions, incentives, and particularly these two guys extra computation and networking to build something more than the blockchain itself allows you to do. Right? And we sort of stuff that all on top of the main chain somehow. And this gives us some nice properties, a different system than the blockchain did. And particularly the thing that I think is most important that has been very, very helpful in our understanding of what the heck these layer two things are. Is it's all about disputes. Like this analogy, you don't go to court to cash a check.
00:01:28.518 - 00:01:52.720, Speaker A: You go to court when a check bounces. This is the analogy that usually allows is like the intuition for why l two scales. Right. We don't scale by allowing ourselves to process more transactions. We scale by processing disputes about transactions instead of the transactions themselves. And this seems to fit our intuitive models for what on earth, how the world works today. And it seems to be a very good paradigm for us to be doing in layer two.
00:01:52.720 - 00:02:29.766, Speaker A: Right? And then the goal is usually to go fast, so we'll throw the speedometer up there. Okay. So what kind of things can you add on top of your blockchain to make it more than a blockchain? Well, the simplest one is another blockchain, right? So, like, very early on, layer two research went towards side chains. And side chains are simply we lock some money up from one chain and we sort of open it up on another chain. And now the second chain is where we're processing transactions. And because of this, we have two blockchains and maybe we have double the scale. Or maybe this second side chain is less secure and has even more scale than the first blockchain.
00:02:29.766 - 00:02:59.122, Speaker A: So we've more than doubled it. Right. So this is like some of the early explorations of layer two, I would say, where it gets really interesting. Right. State channels. I would say that state channels were like the big AHA moment of layer two development where we finally realized, hey, we have this thing that's not a blockchain, but does transactions that we know sort of are going to happen on a blockchain or related to the blockchain. And the idea is we exchange IOUs, right? So we have these great tools of cryptography that allow us to sign things in an unforgivable way.
00:02:59.122 - 00:03:50.580, Speaker A: And so if we sign a bunch of things between each other, these IOUs, and we give a period to go onto the blockchain and say, hey, this guy signed an Iru and he's not coughing up the box, then we built a state channel. So state channels are really cool. I don't think the Lightning Network was the first channel construction, but it's obviously like the big one that we hear about today in public. And it was, I think, two way and blah, blah, blah, lots of great things about the Lightning Network. And then I think this is more contentious, but I think another big moment in layer two scalability was understanding plasma. At the time that this paper was put out, that was a very ill defined concept, but it is what I spent a lot of time working on, and it opened the doors for a very large design space because Plasma sits somewhere really in the middle of state channels and side chains in that. Plasma does have this notion of another chain, another sort of chain of even blocks, you could say.
00:03:50.580 - 00:04:23.310, Speaker A: However, it does not just act independently like a side chain does. It's sort of tied in to the root chain, which is the layer one blockchain, the main chain. And because of this tie in, you can use disputes that have to do with these ties to get some very nice security properties, maybe even to dive into that a little bit. The plasma landscape itself is massive. So this is where I spend a lot of my time researching. So I know firsthand that the rest of you can't even track all the things that are going on in plasma. We started with minimal viable plasma.
00:04:23.310 - 00:04:47.462, Speaker A: Mr. Buterin came in and saved the day with a plasma that actually worked. But then immediately we got another plasma, which was a lot of other people coming together and saying, hey, there's this thing called plasma cash that's a lot better. But very, very quickly the number of these things start to increase. And what we have today, I think this is actually almost a year old now, at least six months. Okay, we have a massive number of plasma constructions, right? Just a huge number. So this is really cool.
00:04:47.462 - 00:05:11.598, Speaker A: It's really exciting to me as a plasma researcher because each one of these has a cool little nugget of information that I can break down and explore. But realistically, it's crazy. These things are blowing up. And to step back to layer two, I mean, we have dozens and dozens and dozens of these scouting solutions. We have TrueBit arbitram. Nocust, Rwand. Both, right? This list is massive, right? This is just a random selection of things that I pulled off the top of my head.
00:05:11.598 - 00:05:43.334, Speaker A: There's a lot more of that came from. So that's a bit of history on layer two. And I think it's relevant to see that what has clearly happened is we have a trend where way more layer two solutions are being created than maybe we would have anticipated three years ago. And they each are making different trade offs and doing different things and many of them are very interesting. Okay, so that's the first part questions so far I said I want this to be interactive. I've got no questions yet, so I'm going to have to make you guys feel awkward and stand here for a minute while you contemplate. Yes.
00:05:43.372 - 00:05:47.260, Speaker B: Just a quick question about the shadow chains. Would you include that there?
00:05:47.630 - 00:06:43.050, Speaker A: So I would absolutely include this. So shadow chains, also being called more recently optimistic roll up, gone by a few different names over the years is a sort of plasma e, sort of. So maybe I'll make an aside here, which would be to say that one of the things that's happened as this design space has exploded is that the line between layer one and layer two is being increasingly blurred. So there are lots and lots of sort of hybrid or combinatory protocols which take some elements from some parts of layer two, some even some elements from parts of layer one. And so one very thing, that simple thing that you can do that we've realized is you can use only one blockchain. Don't have two blockchains, but have a sort of shadow chain, a side chain, a roll up chain in which a bunch of transaction data is posted. And we pay for it to go on the blockchain, but we don't pay to execute the transaction.
00:06:43.050 - 00:07:40.670, Speaker A: So we have this optimistic notion of someone says, hey, here's a transaction, I claim that the result will be this. And instead of checking on the blockchain in this court system that the output will be that, we simply allow someone to say that is actually something else, this person lied. And so even in doing that, we can get a very large and nice scalability increase that makes pretty few sacrifices. But it's kind of weird because it's all happening on layer one, right? So you can run that system almost entirely through layer one that has very low sort of architectural overhead in terms of complex networks and payment channel routing and plasma confirmations and all these things and very, very simple construction and it really sits somewhere in between. Right? So again, I think that's a great example of yes, I would fit that in here. And I would say that really what we're seeing is not only an explosion of layer twos, but an explosion of layer twos, like towards layer one, right? This is like a two dimensional sort of explosion of designs. Yeah, great question.
00:07:40.670 - 00:08:33.760, Speaker A: Other questions. All right, well, that's fine by me, because we got one in so far. So the next thing I want to talk about is sort of like, with that framing of the history of L2 and these recent developments in L2, what's going on? What should people do? And I think there's, like, two real framings to ask this question. One is, as a developer, as someone trying to make blockchain applications, what should I be doing about this explosion of L2 protocols? And the other one is, as an L2 protocol developer, what should I be doing about this? I think those are two pretty important lenses under which we should be addressing this explosion. So as a dev, I'll start there. I think the big one is you got to understand the trade offs, right? So not all of these layer two applications are built the same. And we have to understand that.
00:08:33.760 - 00:09:32.480, Speaker A: One really big caveat here is scalability metrics can be extremely misleading. I don't think there's ever been a word other than maybe like ICO or Coin in the crypto space that is as overused and under specified as transactions per second. Like, TPS is this magical thing which everyone claims to have a very high number of, but there's a lot more that goes into a transaction than the number of them you could do per second, right? A very, very large number. So, for example, one of the things is transactions per second is usually specified on an average basis, but there are many schemes in which you can get a million transactions per second. But really, that's because a billion transactions get finalized every week, right? And so if you do that, then that has, like, as a protocol sorry, excuse me, as an app developer that has very different properties than something that is instant transactions, right? This is a very important thing to understand. Transactions per second is not the one metric. There are lots of metrics there.
00:09:32.480 - 00:10:22.254, Speaker A: This is a really fun quiz that I thought off the bitcoin cash subreddit, I will admit. But it's a very good example of trade offs that layer two designs make. So here we have a payment channel network, and the question is, how many coins can ALS send to Frank? Now, there are six coins, I believe, locked up per average user of this payment channel in these six people. But in fact, Alice can only send two coins to Frank, and actually, in one lightning transaction, she can only send one. She would have sent two. But regardless of that detail, it shows that these tradeoffs are very real. Because one of the things that we would observe about this is six coins locked up per person in the world of layer two is going to mean higher fees because there's an interest rate that Carol and Ella and Bob and David could be seeking elsewhere in return for the money that they have locked up.
00:10:22.254 - 00:10:56.214, Speaker A: And so for them to be willing to facilitate a transaction between Alice and Frank, they're going to want to take a fee. And so these fees may be non trivial in payment channels. And as the payment channel space becomes more robust and explodes, we'll see what that trade off actually looks like. So, because there are so many of these guys, I can't really go into the specifics of all the trade offs. But there's like three general heuristics that I think are pretty good as an application builder that I think are relevant. So the first one is we can scale Sacrificing security. I think this is a land dominated by side chains.
00:10:56.214 - 00:11:36.822, Speaker A: So because you can make a side chain process very large number of transactions in return for a hit in things like block propagation time and verification costs, we can get a large number of transactions through a side chain, but it sacrifices some security. Another option is we can sacrifice the cost. So we might be able to get a lot of transactions per second, but they're not as cheap as in other scaling solutions. This is what Channels did, will probably do, and this is what we just talked about on the last slide. Another example is in plasma, which is where I started working in the layer two space, we sacrifice functionality. So we have a notion of generalized plasma and the ability to build more complex contracts on top of plasma. But the truth is that's very hard to do.
00:11:36.822 - 00:12:31.980, Speaker A: It is not like an ethereum contract. Writing a generalized plasma contract to do something new is a nontrust undertaking. It requires that you reason about the incentives and the ownership and details of that particular contract you're trying to build. It's not like writing a solidity contract. So these are some nice heuristics that I think are relevant if you're building on a layer two application questions, comments, concerns? It's our next question, boss. Interesting to highlight the plasma versus Channels to be also fundamentally kind of open contracts versus fixed set of ah, yes, that's another big one. So in this graph, notably, not only can Alice only send two coins to Frank, but she can only in this graph, assuming this is the full graph, send coins to Alice, Bob, Carol, David, Ella or Frank, there are no other people who can safely receive a coin in a payment channel based on this.
00:12:31.980 - 00:12:49.342, Speaker A: So you're absolutely right. This is in contrast to plasma in which someone who does not have any sort of channel on the main chain, that might not even have an address on the main chain yet can receive some money. So that's a very notable difference. Another great example of trade offs. Yeah, absolutely. Other questions, comments and I mean another.
00:12:49.396 - 00:12:55.410, Speaker B: Way to look at these trade offs is like you need to pick the best use case for each of these kinds of technologies.
00:12:56.550 - 00:13:30.622, Speaker A: Absolutely. Yeah. So my intent with framing this as someone building an application is to say exactly that, depending on what the application is, you need to change how you want to apply layer two to your application and some of them don't make sense. Okay, other questions, comments, concerns? How are we doing on time? Let me make sure we're being perspective of Mo as he gets up next. I think we're okay on time. Okay, so the next perspective I want to talk about is sort of the perspective that I have as a protocol engineer developing layer two applications. And there are some other wonderful folks that fit that category in the room.
00:13:30.622 - 00:14:17.274, Speaker A: So that's exciting to be able to speak to some like minds on. That one of the big things that I think well, okay, let me back up and explain why I have this icon right here. I think that the name of the game must be Unification. So I do not think that we are going to be able to get by in a world where 1000 different scaling solutions have a thousand different APIs and a thousand different sets of terminology to describe the disputes that are used and so on and so forth. There's a lot of thousands that you can name there. Right, but the name of the game is that for people to even be able to understand the trade offs and to choose which trade offs they want to participate in, there has to be a unified way for them to understand layer two protocols. Because protocol developers are always going to understand layer two protocols better than application developers are.
00:14:17.274 - 00:14:39.362, Speaker A: That's how it should work. That's the point of the distinction in the first place. So I think that's very important. So I think the name of the game is Unification. So one great way in which we have our unification recently shout out to the state channels folks in the room is that state channels are coming together and unifying this concept. And this is a very, very big deal. We've got a bunch of wonderful people on this list that are participating in that.
00:14:39.362 - 00:15:08.490, Speaker A: I think this is really, really good. It's crazy to think that multiple state channels, especially because they serve a very similar purpose across different state channel implementations, the API should be the same. It would be crazy to have two different state channel applications in which the APIs in which they communicate and attempt to send money are different. This seems very, very unhealthy for the ecosystem and for a developer trying to build a DAP on top. So unification in state channels is coming along. It's very exciting. I'm super jazzed to be reading more on this.
00:15:08.490 - 00:15:28.782, Speaker A: It's going to be great. And now it's time for me to show my own stuff, obviously. Why else would I be here? I want to talk about the OVM. So what we've seen is that beyond state channels. What we showed before is that there's a very large design space going on. And this is especially true in Plasma, what we were working on. And this led us to something that we call the OVM, or the Optimistic Virtual Machine.
00:15:28.782 - 00:16:26.018, Speaker A: So basically the idea is that even though there is a large number of these layer two protocols and they're all making slightly different trade offs and design decisions and they all function a little bit differently at the core, they do really all work very, very similarly. And the way that they work is you dispute things on the main chain. And the way that you guarantee that you have some money or that some state is in a certain state is that, you know, you could dispute it to be as such on the main chain if required, but optimistically, you might not have to. Right? And this is how we get the scale of blockchain. So the OVM is an attempt to break all of the layer two scaling solutions down and understand them as individual components and based on those components, use just one wallet and just one contract. So this is the sort of far reaching appeal of the OVM. There's definitely a lot of research that needs to be done to really make that universally true for the broadest number of possible layer two applications.
00:16:26.018 - 00:16:56.186, Speaker A: But for things like plasma and channels, we have a pretty good start at doing it. So if you're interested, let's talk about how that works a little bit. You can kind of think of the OBM as a set of dispute Legos, and they're actually based on this fun thing, which I pulled a great Wikipedia screenshot from, of dialogic logic. So which is very great. Dialogic logic? I can't think of a better name. My goodness. Dialogical logic is the idea of framing truths about the world as arguments between two people, maybe a player and an opponent.
00:16:56.186 - 00:17:48.382, Speaker A: They're often called and they participate in a challenge response protocol. And it turns out that for like 100 plus years, philosophers have been talking about, well, what if we thought of logic as dialogues between people? Well, this turns out to be a great analogy to blockchain dispute games because effectively, blockchain dispute games are dialogues between two people in a state channel. For Alex and Bob to be in a state channel when they have a dispute, they say, Well, I have this IOUs. And he says, well, no, Alice, I actually have a more recent IOU from you. And then Alice says, Well, Bob, I took the IOU back, and so on and so forth, right? So this ends up being a very good framing. So for example and these actually fit very closely logical concepts such as and. So, believe it or not, there's an and game, okay? And so you express an and game as game one and game two with an and around it and being able to win an and game corresponds to being able to win both game one and game two.
00:17:48.382 - 00:18:21.980, Speaker A: Another example of this is a not game. So to win the not G one game, you have to be able to beat someone else at the G one game. Right? And then maybe another example which is a little more complex example is the For All game, the universal quantification game, which says for all g one of x, anyone else can choose some particular x. We'll call that t and you have to be able to win G one of t for any such x. Any such t rather. Yes, absolutely. Any such x substituted in for the free variable of x, if we'd like to be more specific.
00:18:21.980 - 00:18:59.682, Speaker A: So it turns out that we can actually build channels and plasma using these constructions. So these are crazy large pieces of code JSON, but I won't go into too much detail right now. But we can see we've got a knot here, we've got an and here we've got it. There exists, which is the dual of universal quantification, existential quantification, not for all, not exists and not exists, not is for all. We also have things like A for all such. So we have a universal quantification here, so we can express channels and we can express plasma under this framework. So there's much to be done with the OVM.
00:18:59.682 - 00:19:21.502, Speaker A: But we think that it's an important effort to be able to do this because in the future, just like we've seen in the past, the number of L two solutions out there are going to get much larger. And we want to be able to explore the design space in an Iterative manner and be able to incorporate the design into applications without having to reinvent the wheel of APIs and networking and all that as we go. So that is what I'm working on.
00:19:21.636 - 00:19:23.742, Speaker B: Just a quick question back slide there.
00:19:23.796 - 00:19:24.400, Speaker A: Absolutely.
00:19:25.170 - 00:19:29.760, Speaker B: The format still looks quite a lot different, like the left one looks like.
00:19:30.770 - 00:20:08.794, Speaker A: Yes, absolutely. I pulled this wonderful plasma example from Crypto Economics Lab shout out to Cel who are working on OVM plasma stuff. So this is because they write in rust, because they're crazy and we write TypeScript. There's some small differences there because of that. And in general, what we have seen is that there are several ways to express most layer two applications. So, for example, G one and G two is the same game as G two and G One. So one of the open questions and interesting questions that we've seen is that there are several logical interpretations of layer two systems that look different, but in fact they're the same.
00:20:08.794 - 00:20:25.060, Speaker A: And so that's absolutely right. That would be an example of that that you could be seeing here. In any case, that is the end. So if you want to follow Positive group or me, these are some Twitter handles. But thank you all for being here. And listening and ask more questions, please. Let's do it.
00:20:25.060 - 00:21:11.120, Speaker A: Yeah. So what level of splitting contract do you think can be represented on plasma chain today? That's a great question. So that is something that we alluded to before, and I in fact tried to emphasize it on this slide here. Sacrifice functionality EVM on plasma has been a long standing meme, just like plasma has been a long standing meme. And truthfully, we are only coming to understand what that really means and whether or not it's even possible as we explore this design space. So right now there are no secure plasma implementations that allow you to write a solidity contract. And it may be the case that this is a fundamental result that without some further restrictions, it's not possible.
00:21:11.120 - 00:21:48.798, Speaker A: However, with the OVM, we found that there's a larger design space. So there's something called optimistic roll up. We talked about this shadow chains before, which does allow you to add some layer two scalability to fully smart contract systems. The intuition for why this is the case is that almost always layer two solutions handle disputes based on intent. So Alice and Bob are the relevant ones to dispute a State Channel because they are the ones who want some money. But a general solidity contract is unclear who, if anyone, wants to dispute this state. And so that ends up making it very tricky to build a very scalable off chain application.
00:21:48.798 - 00:22:35.306, Speaker A: So it may not be possible, as a matter of fact. Great question. Yeah. So from a research perspective, I definitely see the deal of having kind of a very abstract kind of description of how these protocols work, but kind of from a practical perspective. So like the State Channel example, there's a very practical need of we have some standards and we need to make a new standard to add our data. So essentially, what do you see as kind of the practical outcomes of kind of applying this sort of model? Great question. So I am definitely a researcher and so you're right that I could totally be going down a research rabbit hole of unnecessary stuff.
00:22:35.306 - 00:23:20.714, Speaker A: However, in this case, I think that it's very much not the case. And I'll give you maybe two reasons why. One is because I think that this explosion of layer two solutions, many of these designs are going to be valid and we really don't want to rewrite the API. So the beauty of these OBM designs, right, is that you have just one wallet and just one smart contract that handles all the disputes for these different applications. So in general, this is very useful because it means that this code right here, these sort of JSON objects, are interpreted by a generic smart contract and a generic client that automatically understands that it has safety on some off chain property based on these constructions. And so that means that you effectively cut the work in half for L two development. You no longer have to write a client and write a contract and make them talk to each other.
00:23:20.714 - 00:23:57.190, Speaker A: You have one client and one contract that speak OVM and you write things in OVM that they understand. As a more concrete example of why this is valuable, all of the hard problems of channels are solved by plasma. So you can put channels on top of plasma and this makes both of them much, much more powerful. However, it is very, very tricky to integrate a state channel client and a plasma client if they're not talking the same language. We tried to do it and it was very, very challenging. So that's I think the most concrete example is that I believe that the future of plasma and channels are that channels are always on top of plasma, plasma is always under channels. I think that's very valuable.
00:23:57.190 - 00:24:33.246, Speaker A: Yes. One more question. Yeah, go ahead. Is this kind of like on chain dispute mechanism work separately from, let's say, a plasma operators OOH? An interesting question. So it's hard to understand what you mean by a plasma operator's dispute mechanism. So the thing that a plasma operator is meant to be doing is providing an optimistic state transition scheme in which disputes don't have to happen. So the role of the plasma operator really is not always to dispute things, it's to follow the rules so that users don't have to dispute the plasma operator.
00:24:33.246 - 00:24:47.960, Speaker A: So it's a little tricky to understand what you mean by that, but maybe that's a helpful answer. Yeah. Other questions I want to make sure we give Mo time to talk as well. But Mo is asking the question, so I bring it on.
00:24:48.970 - 00:24:55.574, Speaker B: I don't use that. I think generalized solutions.
00:24:55.622 - 00:24:56.220, Speaker A: Also.
00:24:58.590 - 00:25:48.658, Speaker B: Let'S say we use this logic circuit constructor to do challenge field. My intuition is that it might not be as efficient as just kind of the right, very specialized logic, very high optimized kind of a process to do. And sometimes many of these things comes down to cost and cost related to user experiences and all the other kind of product aspect of it. So I'm very curious about kind of how, how can we combine the OBM idea with some deep optimization of either the circuit or have some kind of a way to optimize it so that the trade off of the generic doesn't affect it?
00:25:48.844 - 00:26:25.086, Speaker A: That's a great point. So certainly generality versus specificity often comes at performance costs. Definitely the case. So the long tail answer that I would give would be that eventually both of these objects should be compiled. So we see these structures, these OVM structures as in fact not things to be interpreted by one smart contract, but in fact to be compiled to a smart contract. But you can't boil the ocean and starting with a compiler from this dispute language to the dispute contract is very, very difficult. In the long term.
00:26:25.086 - 00:26:53.982, Speaker A: I think that. That's? Absolutely. The right approach is to be able to compile these things into contracts and you remove this generality sort of extra hop that is definitely going to give you a performance. But hopefully also because we don't want disputes to happen anyway, we're like optimistic that they won't happen. Hopefully the downside and the slower dispute resolution process doesn't matter. People don't dispute things because why would you dispute things if you're going to lose all the time? That's the point. Yeah.
00:26:53.982 - 00:27:15.720, Speaker A: Can you build that kind of decks on top of this OVM? Absolutely. So it's important to understand what that means. So you can build a decks on plasma, you can build the decks on a state channel and you can build both plasma and a state channel on the OVM. So you absolutely can. There's a larger question to ask there, which is what kind of decks do you want to build? But you most definitely can. Absolutely.
