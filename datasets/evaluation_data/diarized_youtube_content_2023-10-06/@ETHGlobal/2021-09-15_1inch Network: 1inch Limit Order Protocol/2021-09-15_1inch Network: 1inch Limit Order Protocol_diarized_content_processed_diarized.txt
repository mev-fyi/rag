00:00:00.090 - 00:00:14.080, Speaker A: Workshop. I'm Sean On. I'm from ETH Global. And here I am joined by the wonderful Carol from One Inch. So Carol, I'll let you take it away, and for any questions, please put them in the chat or wait until the end.
00:00:15.410 - 00:00:18.430, Speaker B: Okay, I will answer questions in the chat.
00:00:21.760 - 00:00:23.980, Speaker A: Feel free to just start the presentation.
00:00:25.200 - 00:00:35.802, Speaker B: Could you repeat? Oh, Carol, you can begin. Carol, when you're ready. Okay? Yes, I'm ready.
00:00:35.856 - 00:00:36.460, Speaker A: Exactly.
00:00:37.150 - 00:01:36.990, Speaker B: So, first of all, I want to give you a quick introduction into One Inch network. This is the big ecosystem of different D five products. By initially, the first product of One Inch network was a One Inch aggregation protocol. It was built on Ethereum New York hackathon in 2019. And this protocol incorporates Pathfinder algorithm that searches deals across different markets on Ethereum binance, smart chain, polygon network, and also optimism. You can find the best price. This price will be better on big amounts in terms of gas and return amount than any individual exchange.
00:01:36.990 - 00:02:36.290, Speaker B: And also we released our own limit order protocol that allows to place the order like on centralized exchange. And you will pay nothing for this order. You just need to enter your preferable price and sign the transaction. And this transaction will send to the back end site or mesh network. And then any user of One Inch or any Arbitrage bot can use this orders as a taker. So if I am maker, I can place the limit order, sign it. I will not send this order to the chain, but I send it to the back end.
00:02:36.290 - 00:03:48.470, Speaker B: And then our Pathfinder algorithm will take into account this order in the wall path if it's profitable for the taker, and anyone can fill this order. So if you are maker, you will not pay the gas fees, and if you are taker, then you will pay for the submitting transaction to the network. So, let's look at the limit order protocol. This protocol I think is the best solution not only in terms of gas usage. So this protocol charge about 100K or maybe 150K for the order filling. And also One Inch limit protocol has three interesting feature that I haven't seen before. The first one, it's a conditional execution.
00:03:48.470 - 00:04:46.890, Speaker B: During the order filling process, you can check is your order valid or invalid. Moreover, you can set any condition that you want. You can set expiration time chain links, oracle, price checking, or maybe some whitelist of the takers. Also, you can use One Inch limit order protocol not only with the ERC 20 tokens, but also with NFTs and other tokens. So the conditional execution, it's really flexible feature that allows to validate some details on chain during the execution. The second interesting feature is arbitrary price discovery. You can use any formula for exchange.
00:04:46.890 - 00:06:27.500, Speaker B: You can build your own custom curve, or maybe integrate some other dex formula, or maybe you want to get your price from the chain link oracle or any other price source. So you can build any formula that you want for this limit order. This formula can include some fees that you want to charge during the execution and other stuff that you can imagine. And the last interesting thing, this is the custom callback. During the execution you can call any other function, something like callback before funds will charge from your account. So for example, you can get the flash loan and pay to the taker using your maker token and after that you can return this flash loan. So you can add any logic maybe with debt borrowing and collateral like CDI CDC on compound you can use lending protocols in this callback so you can add any functionality that you want to be executed before the debting funds from your account.
00:06:27.500 - 00:07:25.440, Speaker B: And let's look deeper on how it works. So the order has the following structure the first property it's salt, this is the random generated number that protects against double spending. The second two properties it's maker asset and taker asset. This is the address of the tokens that you want to receive and pay. So maker asset, this is your asset that you have and take your asset. This is the coin that you want to receive after the order filling the next two properties. This is the makers data and takers data.
00:07:25.440 - 00:09:32.070, Speaker B: This is the abi encoded transfer from function that contains signer address amounts and also if you want to make this order private, you can specify a receiver address to the makers data and if you want to make this order public, you can place to the destination address the zero address. So the next two properties, this is the get maker amount and get taker amount. Those functions allows to call any function that will calculate your maker or taker amount. This is the arbitrary price discovery feature and this is also the abi encoded bytes that should include swap taker amount and swap maker amount. As a last argument and as a result of this function we will get in case of getmaker amount, the swap maker amount and for the get taker amount swap taker amount. The next property, it's a predicate. This is abi encoded function that should return boolean and this is your condition or maybe a combination of different conditions like using or and maybe not and other built in functions that allow to combine different conditions.
00:09:32.070 - 00:10:58.370, Speaker B: So the permit, this is call data bytes for tokens that supports permit you can place the order without an approval from your site without making the transaction that will allow to spend your token from one inch limit order protocol and the last bytes it's the interaction. This is also your abi encoded callback function on your strategy contract. If you pass more than zero bytes here then the callback will be executed and you'll perform some action before the transfer from funds from your account. So to fill the order you need to call fill order function. The first parameter, this is the described before order structure. The second parameter it's a signature. So we are using sign type data version four signature and you should sign the order using this EIP.
00:10:58.370 - 00:12:10.222, Speaker B: Seven one two standard using your wallet that has enough funds and approval to one inch limit order protocol. And second two parameters. This is the making amount and taking command in case if you know how much you want to spend on this order, then you need to place Taking Command. And if you want to specify what amount you want to receive, then you need to set Making amount. And one of those parameters should be zero. And the last parameter this is something like minimal return. This is also acceptable for the function with arbitrary price discovery to protect yourself from price slippage, let's look at the predicate.
00:12:10.222 - 00:13:57.098, Speaker B: This is the condition that will be checked on chain and you can combine any conditions that you can imagine. And for example on the one inch user interface we use the combination of two conditions. This is the nons equals and timestamp below the first one allows to check the nons of the maker address to be sure that maker didn't cancel the order. And the second timestamp below this is the check of the expiration time and we can combine those two functions using and predicate. So we need to encode those two functions and pass it to the bytes array as a data and also you need to specify targets addresses where these two functions is placed. These functions is on our one inch limit order protocol contract and if you want to build your custom functions you can also execute it but I will say how to do that in the next slides. What about arbitrary price discovery? We have these two functions get maker amount and get taker amount.
00:13:57.098 - 00:16:45.780, Speaker B: These two functions are using basic proportion and you can calculate maker or taker amount using these formulas and the abi encoded version of this function should be placed in the order structure and also how we call these functions in the limit order protocol. We are using unchecked function static call that should call inside this contract and we attach the for example taker amount in the end of this call data to execute the real taker amount that taker has passed and also how to use predicate and get maker amount and get taker amount with your contract. You need to encode these functions inside the arbitrary static call function because it exists on the limit order protocol contract and you need to execute all outside actions using this function. This is the security proof something like this yeah, you can just encode your function, place it to the data parameter and as a target you can specify your smart contract address and these functions will be performed on your contracts. If the maker address is the smart contract address then you don't need to sign orders using the default signature. If the signature is invalid, for example as a taker you can pass some random structure or maybe just random bytes to the signature field. And if your signature will not valid, then we will try to call is valid signature on the maker address.
00:16:45.780 - 00:18:15.850, Speaker B: So this thing allows us to use Smart contracts as an order maker and we need to validate some data inside this function on your Smart contract. For example, here we're just validating the order structure and also checking the price drop for the order. And if all is good, then we just return the selector of the Is valid signature. That means that your contract has validated the signature signature. This is just the name of the parameter, it can be order or any other data that you need to validate during the order execution. And the last thing, this is the interaction as I said before, if this property in the order structure more than zero bytes, then we will call notify fill order function on your contract. So you need to implement this function on your contract.
00:18:15.850 - 00:19:25.700, Speaker B: And this function accepts maker, asset taker, assets making and taker taking amount and the call bytes that you pass to the order structure. Thank you. Using these core codes you can find limit order protocol, smart contracts, some JavaScript seals to interact with the limit order protocol and build custom predicates. And also we have documentation for those fields, you can find it just visit docs One inch IO limit order protocol at seals. And here you can find all needed information, how to validate limit order, how to fill it, how to cancel, how to build predicates and all other needed information. Thank you. I'm happy to answer your questions.
00:19:29.350 - 00:19:57.926, Speaker A: Thanks for the presentation Carol. Does anyone in the chat have questions? And if not, everyone can feel free to drop your questions if you have them later in the sponsor One Inch channel there's going to be some folks from One Inch that are going to be really happy to answer your questions. And thanks everyone for coming and thanks KIRO for the amazing presentation.
00:19:58.118 - 00:19:58.600, Speaker B: Thank you.
