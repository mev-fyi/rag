00:00:07.370 - 00:00:48.730, Speaker A: Hi there. My name is David Snyder. I'm one of the co founders at Lit Protocol. And over the course of the next hour you will hear from me, Chris, Cassano and Debbie as we talk about what is Lit Protocol, how does it work and how to get started. And so the big question to think about here at the start of this is it's all about keys? Today we're going to talk about keys, key management and the use cases for distributed keys. So some of you may know who this is if you have seen the Matrix trilogy. This is known as the key maker in that film, in that film series.
00:00:48.730 - 00:01:52.320, Speaker A: But from the perspective of keys, if you're familiar with that story, what this individual is, is a centralized trusted custodian, a holder of keys. And so if you've seen that film, spoiler alert, it is the centralized holder of keys that gets compromised and in the story lets neo into the machine backend, so to speak. And so I use this example, just as a fun example from fiction to illustrate the idea that a centralized holder of keys in our networked era that we are all living in really doesn't make sense. And we've been addressing this problem quite specifically over the past few years. And so it really comes down to a big question of where are keys stored? And so another way to say this is can the internet keep a secret? And what we're going to see today is that the answer is yes. And we'll talk about the methods for doing that. I'll give a brief overview and then Chris will dive into some more detail.
00:01:52.320 - 00:02:48.722, Speaker A: But in short, lit is a key management network that uses something called multiparty computation and threshold secret schemes to hold a key in distributed custody. Then developers can use that distributed custody key for the same thing that you use keys for in general, which is encryption and signing. And we'll take a look at a number of examples in a moment. And some of the core processes at the heart of this are things like distributed key generation, proactive, secret sharing and secure encrypted virtualization. And this is the methods for distributing the key and protecting the private key material to ensure even the node operators don't have access to it. And really kind of the key insight here, no pun intended, is that nobody ever has the whole key. The whole notion of a distributed key generation is you can have a bunch of parties holding something called a key share.
00:02:48.722 - 00:03:28.654, Speaker A: And this is a threshold crypto system where you need a threshold of the network. In the case of lit, that's two thirds in order to authorize any decryption or signing with that underlying key. So let's talk about the two use cases here. The first one that we'll talk about is decryption. So these hexagons here in the middle represent the nodes which are custodying. This distributed key again, none of them is a centralized custodian, none of them have the whole key. And these nodes can read data from public state like blockchains and then determine if a rule is correct and provision access to another person.
00:03:28.654 - 00:04:19.834, Speaker A: So, an example of how this might be used is Alice. Let's say Alice is a content creator. Alice can write a book and can encrypt it client side and then say anybody who buys my NFT, they should be able to decrypt my book. And Alice can take that encrypted Blob and store it on a blockchain or store it on a distributed storage network like Filecoin or Rweave or IPFS based system like Ceramic. And when Bob shows up later on, he can sign a message and broadcast that to the nodes that says hi, I'm Bob, I own Alice's NFT, please give me the key to decrypt the book. And the nodes can validate in this case against the chain data. Does Bob hold Alice's NFT? And if yes, each of these nodes creates an authorization known as a decryption share and sends it down to Bob.
00:04:19.834 - 00:05:13.146, Speaker A: And Bob collects those on his machine client side in order to perform that decryption. And so what we've got here is really quite cool because there's client side encryption, client side decryption, but the two parties never had to meet because lit is this network, this distributed network that is validating the rules and provisioning the keys. And so another way that this is conceptualized is something called identity based encryption, which definitionally, at least before this offering, did require a central authority. Here you can see the definition from Wikipedia. But again, lit is the distributed network alternative to doing a central authority, identity based or rules based or conditional based encryption. And so let's look at a couple specific use cases. If you're familiar with Lens Protocol, it is a social media protocol where everything is an NFT.
00:05:13.146 - 00:06:11.806, Speaker A: What I mean by that is like liking, following, et cetera are all on chain NFTs. The Lens Protocol team has integrated lit inside of their SDK in order to create gated posts. So when you go and post on Lens Protocol, you can say only collectors can view this, which is like the equivalent of liking the post, you collect it, or only people who follow me can view this post. And the encrypted Blob is stored on IPFS and only the parties that meet these rules can perform the decryption. So all of a sudden this creates like a patreon like benefit to these creators that are using Lens. This is also live in Orbis Club for token gated messaging, which is another kind of cool use case, quite similar, but in this case it's more about chat content rather than social content. And we can also look at this in the context of verifiable credentials.
00:06:11.806 - 00:07:13.730, Speaker A: So what we're looking at here in this video is on an application called Credit, where a user is using a third party service to do KYC or know your customer validation. When that proof that in this case, that somebody is over 18 is sent back to the user, it's the same process again where the user is going to encrypt that proof. Client side is going to encrypt that proof. Client side and is going to encrypt that proof client side and then can set a rule, a selective disclosure around who is able to see that proof. Looks like there's a little bit of video trouble here, but just to repeat, again, get some data. Encrypted client side can be KYC data in this example, and this is quite interesting because it's also a verifiable credential. So it's some signed JSON linked data that in this case is encrypted and stored on ceramic.
00:07:13.730 - 00:08:27.374, Speaker A: And then the user, in this case, the individual who's over 18 can have the selective disclosure in the form of provisioning decryption rights via lit to that data. Let us proceed here. And the other ways that this encryption mechanism is being used is for things like data marketplaces. So this is the logo of a project called Streamer Network that uses lit to let data producers create data, encrypt it, store it on the open web, and then set a rule like you must buy this NFT in order to decrypt that data set. Again, having it be rules based or condition based is kind of the main insight around conditional encryption. And as mentioned earlier, it's not just chain data that you can use for the rules for who can decrypt this, but really, any data on the web, whether you can get it from an API, an HTP request, whatever it might be, any statement that can be made, true or false, can be used as an input for this encryption data. And it's also worth noting that things like cross chain support, Boolean, logic, all that.
00:08:27.374 - 00:09:04.614, Speaker A: Sophistication if you wanted to implement that in your conditional decryptions, you could. And those are all in the lit docs. Now let's talk about the other part of keys. So as you know, public key cryptography in general basically has two core features, which is encryption. We just talked about conditional encryption and signing. Signing is really interesting because you have to sign a transaction in order to make an on chain interaction, in order to log something to the distributed ledger that we call blockchain to that state machine. And so what we're looking at here is a very similar kind of diagram.
00:09:04.614 - 00:09:50.054, Speaker A: As you can see, it's the same underlying architecture. But in this case, there is some code, some JavaScript code, and Chris will talk more about this that dictates when this distributed key should sign. And then the nodes can process that JavaScript and output in this case, rather than an authorization to decrypt, an authorization to sign. And so there's a distributed key that is being managed by this network that is signing based on rules. And again, it's not just one node that is authorizing a signature, but a threshold of the nodes. So 20 out of the 30 nodes in the network. And so let's take a look at some examples here, like one pretty excellent use case for leveraging.
00:09:50.054 - 00:11:06.350, Speaker A: This is for user Onboarding where you can do things like set up Discord or Google or Web authent as the authentication method where the private key is held and lit in this distributed network. But the user's Credential in this case OAuth from Google or Discord can basically the network can validate that in that 20 out of 30 model that we discussed before and functionally create an authorized transaction from that distributed key. So that is pretty exciting as it relates to Onboarding if you're building a product that is maybe for non web three natives. This is also really interesting around decentralized finance automation. So what we're looking at in this video is a project called Yacht Labs. And underneath the hood here there are two parties which are represented by these two windows and there is one of these PKPS, these programmable key pairs which is this programmable key that's managed by lit that we just discussed. And so what is happening here is this team has programmed that PKP or programmable key pair to act as an automated escrow agent for cross chain swaps.
00:11:06.350 - 00:12:10.810, Speaker A: So Alice is on Arbitrum and Bob is on ethereum. They can both send tokens to this wallet and when they both approve a swap happens to the other person's address. And so as we kind of look along here, we can see Alice has set everything up. Go back to that, we see Alice has set up the swap and now Bob is sending in from his side and the swap is ready on Alice's side and now the swap is ready on Bob's side and then they can receive the tokens once they've sent them to that escrow agent. This is really interesting. Certainly it can apply to swaps, but it may be also interesting to explore using this capacity to program keys for structured financial products such as liquidity loss prevention on DEXes, dollar cost averaging, stop loss orders on stake tokens. Definitely a lot of room for creativity here.
00:12:10.810 - 00:13:08.136, Speaker A: And then one more example from Krebit. What we're looking at here is a video where the Lit PKP which has the capacity to sign programmatically is being used to issue a Verifiable Credential. So Verifiable Credential is some signed data, some signed JSON LD typically, and in this case the user is signing into Discord. Then a lit is validating that that user has generated that JWT, that OAuth token if you will, from Discord. And lit is essentially signing that and says yes, this address in this case is in fact this user. But what's nice about the way that this team has implemented it is that Verifiable Credential is encrypted and stored on ceramic in this case. So once again it uses that private data, it uses that encryption aspect that we talked about before.
00:13:08.136 - 00:13:52.804, Speaker A: And if you want to look at these demos more in depth, you can find them all at the Lipprotocol.com blog. And so that about wraps it up for my section. I'll include a request for startups if you need some ideas in terms of thinking about what you can build with lit. But really the thing before I kind of pass it off to the next person that I'd like to stress here is that this is really a new primitive that you can think very creatively with if you're familiar with how lambda functions work, or serverless functions. Essentially what lit is, is like a lambda service function and a key management solution, but network based. That's distributed and fault tolerant.
00:13:52.804 - 00:14:03.470, Speaker A: I know I'm really looking forward to seeing what gets built in this event and interacting with a number of you. And with that I will pass it off to Chris. Thanks so much.
00:14:06.960 - 00:15:12.428, Speaker B: Hello, my name is Chris Cassano and I am here to talk to you about how Lit Protocol works. Lit Protocol is a decentralized and programmable key management network. What does that actually mean? What that actually means is that Lit Protocol is a network of node operators similar to like bitcoin nodes or ethereum nodes or something like that. But what the nodes actually do instead of running a blockchain is they provide key management services. And that means things like giving you keys, providing access to keys when certain conditions are met, signing for you, all kinds of things like that. And it is a generalized programmable network. Basically the goal of Lit Protocol is to take this amazing new technology of threshold cryptography and put it into your hands as a developer.
00:15:12.428 - 00:16:31.530, Speaker B: And we really want to make it as easy as possible to use this technology and fully programmable. So you could do whatever you want with it. And the thinking is that you could set up your own threshold cryptography network of nodes, but it's a huge pain, right? Who wants to manage nodes? So instead you can use our nodes and write programs that run on them and do whatever you would like with that. So if you're not familiar with threshold cryptography, the general idea is that you perform a process called distributed key generation. And for this example, let's say that we have a network of 30 nodes and we're going to set a threshold of two thirds, which means that you need 20 out of the 30 nodes to participate in order to use keys within this network. And so you have 30 nodes and they come together, they perform this process called distributed key generation. And what this does is create a public and private key pair just like the one in your ethereum wallet, but nobody knows the private key.
00:16:31.530 - 00:17:34.460, Speaker B: Instead, each node operator only has a private key share and they're able to do the same things with that private key share that you are with a regular private key like sign and decrypt things. But the difference is that somebody has to combine the resulting signature shares or decryption shares above the threshold to get out a decryption key or a signature. And so in our case of a 30 node network with a two thirds threshold, you have to get a signature share from 20 out of 30 nodes. You can combine those signature shares into a final signature. And there's kind of like two broad areas of use of lit protocol. One is decentralized access control. And in this case, the threshold to cryptography is generally used for encryption and decryption.
00:17:34.460 - 00:18:33.810, Speaker B: And so some really cool use cases of things like this are let's say you are in a Dao and you want to encrypt some content, upload it to IPFS or Rweave or some kind of public storage, but you only want your Dao members to be able to read it. You don't want everybody else in the world to be able to read it. If you think about this, it's actually kind of a hard problem if you just use some encryption key that you made up, then you have to share that encryption key with every member of the Dow, right? Maybe you go on discord, you share it with them on there. But then what happens when somebody leaves the Dow? Right now, all of your content is encrypted using this key. You have to rotate the key, give everyone a new key. It's like a huge headache. You can imagine, right? Every time someone joins or leaves, you have to do like a whole operation, basically.
00:18:33.810 - 00:19:39.450, Speaker B: And instead, what you can do is encrypt your content using lit. You can set an access control condition that says user has to be a member of a Dow. And what that means is that somebody on the right here, this is like a user in a web browser or something can make a request to the lit nodes. The lit nodes are these hexagons in the middle, and they can say, hi, I'm in this Dow, I would like to decrypt this content. And they present a wallet signature from their wallet, just a signed message. And the lit nodes check that signed message and say, okay, this user does actually own this wallet. And then the lit nodes each individually check with the blockchain to see, okay, does this wallet actually meet the condition Aka? Is it actually in the Dow still? Right? And if it is, then each lit node will use its private key share to create a decryption share.
00:19:39.450 - 00:20:38.330, Speaker B: The user will collect all of these decryption shares above the threshold, and then they are able to decrypt the content. And lit supports tons of access control conditions. It's not just like if you're a member of a Dao, that's just an example. You could also do things like does the user hold an NFT? You can basically anything that lives on chain you can use as an access control condition and you can use any smart contract function if you want. You could make a smart contract that says that checks a ZK proof and says only let a user in, or only let a user decrypt content if they present a ZK proof that's valid, that meets some condition, right? Anything that you can imagine, you can basically use as an access control condition. And we also support essentially using JavaScript as an access control condition where you can say only let the user decrypt if a JavaScript function returns. True.
00:20:38.330 - 00:21:25.576, Speaker B: And we'll talk a little bit more about those JavaScript functions later, which we call Lit Actions. So what is this useful for? It's really cool for permissioned and private data on the public web. So you could imagine if you're using a cool, fancy, new, decentralized social network and it stores its data on IPFS. Awesome, right? Anybody can get the data. It's a disputable open system. But wait, that also means that anybody can read all of your posts, right? There's no privacy. What you can do is encrypt your posts with Lit Protocol and you can set your access control conditions such that all of your friends are allowed to decrypt it.
00:21:25.576 - 00:22:22.620, Speaker B: And that's great, because now you don't have to self host the data, right? It's hosted on IPFS, on the public web, but it's permissioned in private, in that you can still control who is able to access it and when. Another use case for Lit Protocol is essentially signing. So the first case we talked about was reading from blockchains in order to decrypt something. This use case is talking about writing to blockchains. And the way that you write to a blockchain is with a signature. The lit nodes hold private key shares and they're able to create threshold signatures that can be used to write to a blockchain. And the way that the lit nodes actually do this is that you are able to upload some content, some JavaScript code to IPFS.
00:22:22.620 - 00:23:12.508, Speaker B: And this is called the lit action. And once it's on IPFS, it's immutable because IPFS is content addressable. So you can kind of think of these like LIT's version of smart contracts, but they're in JavaScript, so they're really easy to use. And these Lit Actions are allowed to also read from the web. They can make HTP requests, so you can pull in data, you can do all kinds of things that would be really hard to do on traditional blockchain. And so basically, kind of how this actually works is a user shows up and says to the lit nodes like, hi, I would like you to run this program on IPFS. And each lit node pulls this program down and runs it.
00:23:12.508 - 00:24:22.050, Speaker B: And if the program asks for a signature, each node creates a signature share. The signature shares are collected by the user. The user combines them and is then able to broadcast them to or broadcast the resulting signature to a blockchain. And so that's how you can use lit to write to a blockchain in addition to read. And we think that this is like a really powerful new primitive that you can use for all kinds of things in cryptography. And one thing that I haven't really talked about yet is when you're writing to this blockchain, when these nodes are signing using a private key share, whose private key is this? Right? Like, is this the network's private key? Which private key shares is it using? And that's where the concept of a programmable key pair comes in. A programmable key pair is an ECDSA key pair, which is the algorithm that Bitcoin, Ethereum and Cosmos use.
00:24:22.050 - 00:25:13.872, Speaker B: And the lit nodes hold the private key shares that correspond to this key pair. You can create a programmable key pair, aka a PKP, by minting an NFT that represents ownership over that PKP. And then whoever owns that NFT can ask the lit nodes to sign anything on their behalf using the private key shares that correspond to that PKP, including Ethereum or Bitcoin transactions. And I'll show you how this works right now. So this is a lit action, very basic lit action. And what it does is it defines something to be signed. This is just a simple array that contains the string hello world.
00:25:13.872 - 00:26:07.780, Speaker B: But this could be a transaction that you want to sign. This could be a write to ceramic. Anything that requires a signature, you can sign. It's very, very flexible. And what you see here is that we are requesting that the lit nodes sign this data using this key and store it in the result of named SIG one. And basically what's happening is the lit nodes hold the private key shares that correspond to this public key. And so when you ask each lit node to do this, it's able to create a signature share, and the signature shares all get returned to the user, who's able to combine them into a final signature.
00:26:07.780 - 00:26:46.830, Speaker B: So here's sort of a basic overview of how that works. The user creates some kind of authentication that could be a Wallet signature. It could be an OAuth token. We support Google and Discord, and we're working on adding phone and email authentication as well. And they make a request to the lit nodes. They talk to every single lit node in parallel, and they present their authentication. And they also present an IPFS ID.
00:26:46.830 - 00:27:44.960, Speaker B: And they say, hi, lit node, please run this code for me. The lit nodes pull down the code from IPFS, right, and load it into a JavaScript runtime. The JavaScript runtime executes the code, and it actually checks that the user is authenticated and allowed to actually use the PKP. And the lit action is also allowed to pull down any data from anywhere on the web using an HTP request. So you can use it like an oracle. You can pull in data from anywhere in the world and use it in your computation. And then if your lit action wants to sign, it can request that the lit nodes use their threshold private key share to create a signature share, which is then returned to the JavaScript runtime.
00:27:44.960 - 00:28:58.440, Speaker B: And what happens is the user down here is running this request across all the nodes and collects signature shares from all the nodes. The user is able to combine those signature shares into one signature and then can then broadcast the signed transaction or use that signature for whatever they want to use it for. And we have a TypeScript SDK that you can use that basically does all of this for you and abstracts it all away, where you just kind of create a request pass in what you need and you get back a signature at the end. Another cool pattern that you can use is the mint grant burn pattern. This is really interesting because a PKP, because it's created as an NFT on a blockchain, you can basically create the NFT and mint it. You can grant the access for it to use like some lit action and then you can burn it. And what that essentially does is lock the PKP such that it can only be used by this lit action forever.
00:28:58.440 - 00:30:01.470, Speaker B: Now, interesting kind of toy use case of this, right, is suppose you have a lit action, so you have some JavaScript code that given a number as input, will check if that number is prime. You can mint grant burn a PKP on that lit action and then you can pass numbers in. And if the number is prime, then each lit node is running this independently. It will sign using its private key share. The user collects all the signature shares, combines them into a signature. That signature essentially proves that any given number is prime because the corresponding programmable key pair can only ever be used to run that program. And so what you kind of end up with is something that functions similarly to a ZK proof in the sense that you have a signature that proves that all of the nodes in the network got the same result.
00:30:01.470 - 00:31:07.984, Speaker B: And now you don't have to check if a number is prime if it's signed. Instead, you can trust the signature because you know that the only way that the signature could have been produced from the corresponding PKP is if the lit nodes ran the program correctly and that you got the result that it expected, right, which is the number is actually prime. And you can use this for anything, right? You could use this to certify or to prove that suppose you have to prove that you're in a city, but you don't want to prove where in that radius that you actually are. You just want to prove that you're in a radius without giving away your real latitude. And longitude. You do something like that, you could prove that the weather was a certain temperature on a certain day in a certain place and time. Because you can pull in data from the web using HTP requests, you can essentially create proofs of anything on the web very very easily and very very quickly.
00:31:07.984 - 00:32:00.020, Speaker B: And the proofs are ECDSA signatures, so you can pass them right into a smart contract which is able to check those and verify them. A couple other cool use cases, you can use a PKP as a vault. What this means is that a PKP is a public private key pair. It's a wallet. You could send 100 NFTs to it, right? And then you can trade all 100 NFTs at once because you can actually sell the PKP NFT itself, which is the NFT that controls the PKP to another user. And you effectively have just sold the underlying private key that owns all of those NFTs. And remember, the private key never exists.
00:32:00.020 - 00:32:55.350, Speaker B: It never gets created anywhere. Instead the lit nodes only have private key shares. And so you can effectively trustlessly trade a private key in a way that you never could before. This basically breaks things like soulbound tokens. A lot of anti civil mechanisms like for example Gitcoin passport or polygon ID can be broken by this because now you can actually sell the wallet that owns the sole bond NFTs, right? That something that you could never do before because in order to do that with a regular private key that you are just like looking at, you would have to prove that you've forgotten the private key, right? And you can't prove that. It's impossible to prove that. But with lit, since the private key never exists, you are able to actually trade that.
00:32:55.350 - 00:33:26.672, Speaker B: You can also use a PKP as a cloud wallet. Lit supports a ton of different auth methods. So I talked a little bit about like if you hold the PKP NFT, you can ask the lit nodes to sign using that PKP. That's just one of a ton of different auth methods that we support. We also support OAuth with Google and Discord. We support web authent. We're working on email and phone soon.
00:33:26.672 - 00:34:11.288, Speaker B: We don't have that yet, but we will soon. And that basically means that you can use any of those things as auth. And there's a smart contract on chain that you can use to set up your auth for a PKP. So you could say I'm going to onboard new users and all they have to do is log in with Google using Google OAuth and I'm just going to pass that Google OAuth access token to the lit nodes as proof. The lit nodes can verify that access token and let the user sign using that PKP, assuming that you've set up that user to auth using that Google account. So it's great for onboarding. Like you don't need to do seed phrases, you don't.
00:34:11.288 - 00:34:42.584, Speaker B: Need to worry about anything like that. You can get people a wallet very quickly, like with one click. You can also use PKPS for automation and signing. So this is a super cool use case. It's like, imagine you're in some cool 10,000% APY farm and you're like, this is great, I'm making tons of money. But if the token price tanks, then I'm going to lose all my money. Sure would like it if there was some kind of way to set up a stop loss order.
00:34:42.584 - 00:35:29.604, Speaker B: But your tokens are staked. You can't sell staked tokens with lit. You could set up a lit action that checks the price of the token. If the price of the token drops below a certain level, then it creates a transaction to unstake the tokens, and then it creates another transaction to sell them on uniswap. And you could basically be polling this, have this Lid action run every 10 minutes or something, right? And if the token price starts to tank, then this will unstake and sell your tokens. And this is really cool because it's just using Raw ECDSA signing. You can do anything you could do with a regular wallet with this.
00:35:29.604 - 00:36:10.564, Speaker B: So you could do things that are cross chain. You could use bridges, literally, like whatever you can imagine, you can build. And in order to do this in a sort of traditional way, you would have to set up a hot wallet on a server, kind of like a trading bot type setup. It's very prone to error. Having a private key on a server as a hot wallet is really scary. Like, it's a huge target for attacks. And so this kind of like using lit for this instead gives you the protection of the decentralization, right? Like somebody doesn't need to hack one computer to steal your money.
00:36:10.564 - 00:36:54.400, Speaker B: They need to hack two thirds of the lit nodes. And the lit nodes run inside of a trusted execution environment powered by AMD Sev SNP. It's actually a secure encrypted virtualization environment, so node operators can't see what their nodes are actually doing. It's fully opaque, and so it's very hard to hack into, and that's part of why we've built it that way. So anyway, here's some really cool ideas of what you can build with lit. And check out the docs at getlit dev. If you have any questions, hop into Discord.
00:36:54.400 - 00:36:59.636, Speaker B: We're always around and we are so excited to see what you build.
00:36:59.818 - 00:37:00.790, Speaker A: Thank you.
00:37:01.720 - 00:37:49.380, Speaker C: Debbie. And I lead developer relations at Lip Protocol, and I'm going to do a quick overview around Chronicle, as well as how to start minting PKPS and getting test tokens. So previously a bit of what Chris covered, chris, our CTO covered was around before we moved to our roll up. And so with this roll up, we have a lit test token to serve as gas for transactions. And so that'll be built on Chronicle, which is our EVM roll up. Built on optimism. So first is we're going to go to actually the Faucet to get the lit test tokens.
00:37:49.380 - 00:38:24.990, Speaker C: So here we're going to put in our Watt address. We're going to tell them we're not a robot, we're an actual person. We're going to claim these tokens. And you'll notice in this wallet, I already have some lit test tokens. So I already have two lit test tokens. And from there, going back to the Docs. The Docs are the home of everything you'll need to build with us.
00:38:24.990 - 00:39:27.902, Speaker C: You can go down to the programmable key pair section, go to the Introduction, and go to Minting a PKP so you can mint via contract through our Lit Explorer page. And then we have all these different other ways of minting as well. So right now, we're going to do Mint via Contract. So clicking here and we're going to go to our Lit Explorer and from here we're going to go mint a parallel key pair. So great, we've minted our PKP. And then from there we have this PKP public key, which Chris has gone over some different ways of using lit actions. And you'll need to use that PKP public key to sign any conditions as a result of lit action or to authorize additional methods.
00:39:27.902 - 00:39:38.800, Speaker C: So it's very quick, but hope you had fun learning this. And we are excited to see what you built for ETH Global Waterloo. And we'll see you there.
