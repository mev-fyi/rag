00:00:00.090 - 00:00:02.990, Speaker A: Building on Hermes with JavaScript SDK.
00:00:05.090 - 00:01:12.370, Speaker B: Hi, everyone. Thank you. I'm going to share my screen in order to perform this workshop, okay? This workshop will be about interacting with ermath network. As you may know, ermath network is a L2 solution, basically secure lab. So in order to interact with this Hermeth network, we built an SDK in JavaScript. And what we're going to do in this workshop is to learn how to set the environment of the SDK, how to create a wallet, how to make a deposit in nervous network, and at the very end, how to do a L2 transfer, standard transfer in L2. Okay, so I assume here that you have a very basic knowledge about node JS, about NPM, which is the package management package manager of node.
00:01:12.370 - 00:02:15.480, Speaker B: So the first thing to note, the first thing to note is that we're going to import some standard libraries of node, which is Path and Ethers. Ethers is a very well known library user in order to interact with Ethereum. And at the very last, we're going to import our package. You can find our package in NPM. You just have to install it with NPM install robot network. Okay? So first of all, what do we need in order to start this workshop or in order to interact with the Ernest network? Okay? So here what I'm going to show is the variables that I'm going to use in my workshop, okay? And probably it will be the variables that in case that you perform some script or you perform some interaction with the standard mode, you will need to set up. So here, this is just an example.
00:02:15.480 - 00:03:21.338, Speaker B: Obviously, I have my own hidden environment file. And here what I'm going to set up is theorem node URL. I will use an impura one here in this workshop, you need to set up your Ethereum private key. Which token do you want to deposit and transfer afterwards in Edmonton's network? Regarding the token, you will find there are several tokens available that you can deposit and transfer in L2. We will see later all the tokens available when we perform the deposit action. Then here we're going to set up the deposit that we want to insert into the L2. And afterwards, how much are we going to transfer in L2? Also, you can perform in this workshop, I will perform four different actions.
00:03:21.338 - 00:04:06.822, Speaker B: But of course, there are so many much actions to perform. I will share a link to a repository in GitHub with several more actions besides the ones that I'm going to present here. And one of them is to perform an exit. And afterward the exit, you can perform the withdrawal it's in order to get out of L2 and recover your funds in layer one. Also, when performing a transfer, of course, you need a receiver. And here we are just setting the theorem address of the receiver that we want to transfer our funds in L2. So let's start with setting the environment.
00:04:06.822 - 00:05:28.754, Speaker B: Okay? So when you just download the repository, the network emergency SDK, there is one set up, which is by default, which is the default environment. Okay? And the default environment is set to localhost. So now what we're going to see here is which is the default environment that is set up. I want to run the script. And you can see here that the default environment points to airmeth hardcore smart contract withdrawal delayed smart contract, which I'm not going into details here, but this is regarding when you perform the withdrawal function and also the base API URL, which is the coordinator, the patch Explorer, which is like the ether scan. The Base API URL is the URL of the coordinator, and the coordinator is the forger of batches on L2. Okay? Just to do similarity, the coordinator is for L2 as the Miner is for layer one.
00:05:28.754 - 00:06:32.810, Speaker B: Okay. The Batch Explorer will be our own Ether scan in order to find transactions, in order to find your account. So here I want to show you the file that is inside Ermine, which is called Environment JS. So here you can find that all the data are already available. So what do you need in order to set the environment? What you need is just only the chain ID. And if you set up the provider, in our case, I will be interacting with infura in Rinkev with just that variable, I will set up the whole Hermet SDK. Okay? So here we can find all the correct URLs regarding main drinkv and local of the coordinator Ether scan.
00:06:32.810 - 00:07:21.050, Speaker B: All the contracts are already here because they are already deployed on drinkav and Mainet and so on. Okay? So it's important to notice that just with a single parameter, which is the chain ID, we're going to set up the binary. So here what I'm going to do is to get the ID from my provider. Okay? Here I'm just loading my provider with the library of interest. Here I'm getting the network information. From the network information, I'm getting the chain ID. So MSDS provides you a single function in order to set up the environment.
00:07:21.050 - 00:08:15.296, Speaker B: That's all that I need. In order to set up the environment. What I'm going to see now is how this so let's run it. You can see, you can notice the difference from the previous one. It was localhost and local deployment. And here you already have the smart contracts that are deployed on Rinkav and all the URLs regarding the coordinator, the batch exploit and the Ether scan are pointing to Rinkav as well. Okay? Another important thing, this is just in order to save time for further script, is to set the provider.
00:08:15.296 - 00:09:07.520, Speaker B: Like the library of Ethers does. You can connect smart contracts. You can connect some signers, but in order to use them, you need to connect a provider in order to sign the transactions and perform interactions with the blockchain. So in this case, we perform the same in Hermit. So we are able to set the provider globally. Okay, you can set the provider in each function if you want, but it's more comfortable for the developer experience in order to set the provider globally in the whole SDK and every time that you will use a contract interaction, this provider will be already set up. Okay? So here we are just basically setting up the environment with just a single parameter, which is the chain ID and setting up the provider global in SDB.
00:09:07.520 - 00:10:04.000, Speaker B: Okay? So let's move forward to the next one which is the create wallet. Okay? What we're going to do here, what we're going to do is to create the private keys of the baby Japjap private keys. The baby Japja private keys will be used in L2 because are the keys necessary in order to sign L two transactions. And this private key will be generated from your Ethereum private key. And this generation is deterministic. Okay? So you will be always available to create if you have your Ethereum private key, you will generate your baby Jap Jap private keys deterministically. So here I will just copy paste the previous example which is load environment files and set up environment and provider.
00:10:04.000 - 00:10:53.684, Speaker B: But this time it's more packet in the code with just the four lines of code I just adopted by domain of the provider. And here also I load the private key of the city. So what I'm going to do now is to create the wallet and that it. How do we create the wallet? Well, what we implement here, there's several ways in order to load your private key. One of them is through directly your private key. We use this kind of loading to wallet because it's very similar to the one that is used in Ethers. So developers are used to work with this kind of code.
00:10:53.684 - 00:12:34.448, Speaker B: And also it's very important that you can load your wallet in such a way with a private key, but also you can load a wallet with your JSON RPC provider, okay? In that way, the SDK that we provide not just only work in order to do some scripting, but it also works with browsers, okay? In fact, with MetaMask. In fact, this SDK that I'm presenting in this workshop is used in our web app application exactly the same. But instead of loading a private key, you are loading the provider of the MetaMask, for example, okay? So we are loading here the signer and we use a method from hermet in hermet wallet section create Wallet hermet from Ether account, okay? And we're just passing the provider and the sign. And inside that method there is a way to generate the baby Jab Jab private key and public key. Okay? I'm not going into the details. You can ask me in discord about the details, about the specific details or methods how to generate these Baby Japan private keys. But just a simple point is that we are just signing a message and then hash it in order to get the Babyjabjab private key, which is basically this lines of code here.
00:12:34.448 - 00:13:25.748, Speaker B: Okay? So I'm just going to show which are the values of this account. Okay, I will run the script wallet. Perfect. So here you can see that I created a wallet, okay? And I repeat, when I create a wallet, I took the Ethereum private key, I generate the Baby Jap private key. And of course, I also have the public Ethereum key and the Baby Jap public key. So here I just want to show you which are the different types of Baby Jab jack. Okay, this is the public key, baby Jab jab point in the elliptic cure x point y point.
00:13:25.748 - 00:13:58.076, Speaker B: This is the XY point in compressed way. This is the Baby Jab jack is present in Xyzmal string. This is the Pipjap Jab expressed it in base 64 encoding. Okay? And this finally is the Ermet. If you just play around with our web app and you just play around with the budget builder, you will notice that we use for user interface, we use the Baby Jab Jab encoded in base 64. This is very helpful for the user because it helps to differentiate and shape Ethereum addresses. And baby jap addresses.
00:13:58.076 - 00:14:38.056, Speaker B: One is expressed in Excel string and the other one is expressed in base 64 code. Let's move forward and perform a deposit. Okay, you will notice that I will just again copy and paste all the code that I shared previously. And I also load two more variables. And I'm here, I'm just in six lines of code. I'm just setting up the environment on the provider and creating a wall. Okay, so what I'm going to do now, I want to perform a deposit.
00:14:38.056 - 00:15:38.780, Speaker B: So the first question is, which token do we want to use? Okay, in order to do that, first I'm going to show you which tokens are available in hermeth network in Rinkav. Okay, so you just call there is an API, public API that you can call and get all the public tokens that you can deposit. And for that purpose, I will show you which tokens are available. So for example, we have the first place, we have Ether. The second place we have Hermes, USDT, USDT Dai, Uni and Link. Okay, just for clarity, in order to not show some information again, I'm here in these two lines of code. I'm just grabbing the token that we set up in the environment variables.
00:15:38.780 - 00:16:47.744, Speaker B: Okay? So I'm just filtering the array. We can say that. So here we have all the token information that we need in order to perform a deposit afterwards of the token that we want to deposit. Okay? So which is the next thing to do when you want to perform a deposit. So of course you will need how much are we going to deposit? So you probably may notice that this how much we already took it from the vitamin variables. And there is an important thing to mention here that this is not straightforward because we are not using 256 bits in order to represent a big integral, we are using a custom floating point code encoding which we call float 40. And this has been done in order to save space when we publish all the data availability in the smart contract.
00:16:47.744 - 00:18:14.870, Speaker B: As you may know, ZK Robs, we must publish all the data in order to rebuild the state tree from zero, from scratch on chain, okay? So in order to do that, we need to publish all the data of all the transfers that the user made on chain and in order to save space, we are using a custom encoding decoding beacon table. Okay? In that case, in the SDK we wrap all this coding encoding and we call it hermet compressed amount. So at the very end, you just need to insert the big integral into this hermet compressed amount. Compressed amount. And the amount that you will receive is the amount that you will send to the smart contract in order to perform a deposit. Okay? So we have now the token, we have now the amount, so nothing left. So what we're going to do is to perform finally the deposit, okay? What this action? What it will do, this action, what will do is to send a transaction to the smart contract and the smart contract will handle these transactions and after a few times your account will be created in L2.
00:18:14.870 - 00:19:56.256, Speaker B: Okay? That's it. In order to see that your account is already created in L2, we need to wait some time for the purpose of being faster. I already made this action yesterday and I also create an account. So the account is already created, but as you can see, it's just only a very smooth interaction with blockchain because this function here sends a transaction to Ethereum, to the smart contract of Mermet and creates for you an account. So once your account is created, we are going to perform a transfer, a layer to transfer. So in order to do that, I will just copy paste again the code that I used before, but this time setting the environmental provider, setting the wallet and I'm going to initialize the transaction pool, okay? I'm not going into the details here, but you can imagine that this transaction pool works as the transaction pool of MetaMask, okay? So if you perform two transfers in a row, the nons will be handled automatically by this transaction pool. You will send nons one and nons two, okay? Like it happens with MetaMask, when you perform some transaction, the transaction is in the theorem pool, it's pending.
00:19:56.256 - 00:21:03.444, Speaker B: But if you perform a second transaction, the second transaction will have a non plus one, so the nonsense not repeated. So in order to perform the transactions reL2, we need to initialize the transaction pool, which is basically to handle nons properly. The following lines you will see that are very straightforward because are the same that we use in the deposit section, which is basically set up the token information and set up the amount to transfer. Okay? And here what I'm going to see. We're going to look at the account that we have just created in the previous step. Okay? In order to do that, I'm going to run script. And here we can see our information regarding the account that we have created in the deposit script.
00:21:03.444 - 00:21:34.468, Speaker B: Okay, so my account has been created well. I have this account index. I have this balance. My Baby Jap address, public address is this one. My Ethereum address inside L2 is this one. I already performed a transaction yesterday, for example. And this is the token that my account has.
00:21:34.468 - 00:22:23.488, Speaker B: This, for example, is ether. Okay, so what do we need in order to perform a L2 transaction? As in probably all blockchain, the most common fields in order to perform a transaction are just from, to I mean sender receiver amount and fee and that's it. That's the only things that we need in order to perform a transaction. Okay, so what we have already, we have the from, which is me, which is this account. And here, I'm just grabbing the fee as it happens with Ethereum. I will ask to the coordinator like you will ask to Ethereum network, which is the current fee. You will ask the coordinator on L2, which is the current fee.
00:22:23.488 - 00:23:13.916, Speaker B: So the coordinator will answer you, which is the expected fee in order that your transaction will be inserted in L2. And we are just computing here, which is the fee that I need in order to perform this L2 transaction. I'm going to run the script and then you will see which is the fee. For example, this is the fee in Ether that I'm going to pay that I need to pay in order for my transaction to be inserted. Okay? And there is one more step. Well, there is one thing important to mention. That protocol that we use in L2, the fees are paid in the same amount that you perform the transaction.
00:23:13.916 - 00:23:49.044, Speaker B: So if you perform a transaction with Ether, you will pay your fees in Ether. If you perform your transaction in Dai, you will pay the fees in Dai. Okay? That's a different approach. Rather than Ethereum for example, but I think it's better because it allowed you to pay in whatever currency that you want, whatever token that you want. Because you can link transactions and pay transactions in the token that you want. Okay, as I said before, what do we need in order to perform a transfer? Who is going to perform a transfer. Who is going to receive a transfer? The amount and the fee.
00:23:49.044 - 00:24:53.940, Speaker B: So here, this is my account. This is a sender the receiver, I set it up in the bidomain variables. The amount I have just compute the amount in float 40, remember? And the very last variable is how much I'm going to pay. Okay? So here when you send a transaction Ethereum, you send a transaction to the Ethereum pool and here in L2, it happens exactly the same. So we are going to send the transaction into the coordinator pool and then the Coordinator pool, which gives us a result if this transaction has been correctly inserted into the L2 pool of the coordinator. So I'm going to run the script and this will be the last step. This script will send to the coordinator the L2 transaction.
00:24:53.940 - 00:26:11.400, Speaker B: Perfect. So what happened here happens that we send the transaction to the coordinator and the coordinator verifies of course, if the signature is okay, if you have enough balance and so on, in order to accept this transaction, if the nons is correctly signed if the nons is the nons that your account needs in order to perform this transaction. And this transaction has been inserted into the pool, and it will be processed in a few minutes. Okay, but it's important that the coordinator has response us that the status is okay. And this is the transaction ID. So with this transaction ID, you can go to the batch Explorer or just directly to the API of the Coordinator and see which is the status of the transaction, if it's pending, if it's forging, if it's already forged, it's like the status of an Ethereum transaction when it's pending or mining. Okay, that would be all.
00:26:11.400 - 00:26:18.350, Speaker B: These are three minutes left if you want to ask anything.
00:26:22.820 - 00:26:37.780, Speaker A: Thanks so much Carlos, that was great. And you packed in a lot there in just under 30 minutes. There is one question that came in, which is how is the fee calculated? It seems like it's predefined.
00:26:39.480 - 00:27:33.860, Speaker B: How is the fee calculated? Basically we are asking to the coordinator, which is the fee that the coordinator needs. Okay? It's like when you're asking to the Ethereum network, which is the fee in order that your transaction will be processed. In this case the coordinator. As you can see here, we just ask to the coordinator global state and inside the global estate there is this recommended fee in order to perform a transaction. And basically I'm just grabbing this recommended fee. I'm dividing the recommended fee by the token price of Ethereum in order to know how much Ethereum I need to pay in order to send the layer to transaction.
00:27:37.900 - 00:27:57.880, Speaker A: Great. Thanks so much, Carlos. We on time here. That was a great session. And any questions for Carlos, you are more than welcome to drop them in the sponsor Hermes channel and discord. And with that we'll close out the session. Thanks so much, Carlos.
00:27:58.620 - 00:28:06.560, Speaker B: Thank you very much. And thank you very much for everyone. I will be in discord in order to answer all your possible questions. Thank you.
00:28:06.710 - 00:28:09.596, Speaker A: Great. Cheers, everyone. Bye.
