00:00:03.770 - 00:00:38.370, Speaker A: Hello, everyone. Just give us a couple of seconds to set up the live stream. All right, let's get started. Hey, everyone, thanks for joining us for our last workshop of the day. For Hack money, we have Shravan joining us who's going to be hosting a workshop on Scaffold ETH. Hooks and TypeScript. Questions will go into the zoom chat.
00:00:38.370 - 00:00:49.690, Speaker A: Shravan will look at them at the end of his workshop, but also give you the opportunity to come off mute if you want to ask your question live as well. And with that being said, I'll pass the mic off to Shravan.
00:00:50.750 - 00:01:33.180, Speaker B: Thank you so much. All right, really excited to be here, guys, and share more about Scaffold TypeScript and its companion library, Etox. So I hope it's going to be a great learning experience and you'll really get to figure out how to prototype quickly with the template and really try out new things in Web Three. And additionally, I hope you learn how Ethox works and how it really helps you with react apps. A couple of housekeeping things like as assumptions. I'm going to assume that you guys know how Yarn NPM and Node work and you also know what react and react context are, and you've seen Ethers before and you know what hard hat is. Okay, so we're going to get started with that.
00:01:33.180 - 00:02:26.538, Speaker B: So what is scaffold TypeScript? It's basically a template that makes it super easy to build Web Three apps. The links will be posted later, but there is a Scaffold TypeScript repo. You can just clone that but use this template. And I'll give you this batteries included kind of template that makes it super easy to build Web Three apps. Why do we need this? It's really a challenge to get the new project going, especially Web Three, because there's so many things and things are changing so quickly and you kind of want to have a good place to start with all the libraries included and has the tools to get you started. I think there's a need for a solution with the great DX and it's kind of challenging to have that. Iterative loop from solidity code to your front end and that's what Scaffold Deep will give you.
00:02:26.538 - 00:03:10.882, Speaker B: And of course, I'm a really big fan of TypeScript, and I think it really makes it a lot easier to not make mistakes. You catch it in build time, customers don't see it, or your project presentation doesn't see it, so think it's a huge difference. So as I mentioned before, like, why Scaffold eat rapid prototyping, I can't keep mentioning this. It's going to make your life a lot easier to just check out your solidity code. And really, we spend a lot of time building that good developer experience. It makes a big difference to be able to see your solidity changes right away and see how they work. And lastly, the most important thing is that it's effortless front end with Ethox library.
00:03:10.882 - 00:03:48.582, Speaker B: So we have a context for the Ethereum provider so you can get access to it anywhere in the app. There's a context for contracts, so you can use the contracts that you build anywhere in your app. You don't have to pass things around. It just makes things easier. And then there are TypeScript definitions for everything, including the contracts, which are automatically generated by the build script. So that makes it a lot less error prone when you're developing things. And so the three things I hope you get away from this is how Scaffold and Ethhooks work and how to quickly prototype these things.
00:03:48.582 - 00:04:14.942, Speaker B: And additionally, I wanted to showcase how web three front end, how you can develop web three front ends in a very type safe way. Okay, so we're going to get started with just the code. I'm going to quickly go over the commands that we have. We have a bunch of commands that make life a lot easier. The first one is yarn. Contract build. It builds the contracts, creates that API and generates the types for us that we can use in the front end.
00:04:14.942 - 00:04:51.270, Speaker B: And Automate easily loops that into the front end. The next is Yarn Deploy, which is same as hardat deploy, and it deploys to your target environment. And we control that with an environment variable. And then Yarn Chain, which is basically starting the hard hat ethereum node. So we're going to start with that. I'm going to go in, I have Scaffold pulled, and the main folders that you care about is the wide app TS, which is the application, and then the hard Hat TS which is your hard hat contracts and hard Hat application. So I have on my right side a bunch of terminals.
00:04:51.270 - 00:05:14.260, Speaker B: The first thing I'm going to do is do Yarn Chain, which starts that hard at Node so we can develop locally. Then I'm going to start do Yarn Start to get that react app started. And you notice that it's really fast. It's running on bytes. So it's like about 100 times faster than webpacks. It's one of the big advantages for rapid prototyping. So now we have that running.
00:05:14.260 - 00:05:35.590, Speaker B: It's actually running here. I'm going to reload this and then I'm going to make sure that I build all my contracts. So I'm going to go yarn. Contracts build. So this is going to go through and build my contracts. Right now I only have one contract in my contract folder right here. It's called your contract.
00:05:35.590 - 00:05:56.702, Speaker B: There's another contract, but it's not set up to build right now. And I have no external contracts I want to talk to. And it uses hardware deploy in the background. So basically it's just telling it to deploy that contract and that's the code for it. So now it's deployed. I'm going to go and you notice that I'm going to reload this. Sorry.
00:05:56.702 - 00:06:10.898, Speaker B: Now it's built, now I have to deploy it. So I'm going to do Yarn deploy to actually deploy it to my local hardhat node. That's why it wasn't showing up there. So I built the contracts. Now I'm going to deploy it. And once it deploys, you see the contract. It makes it super easy.
00:06:10.898 - 00:06:39.370, Speaker B: And some of the features, for example, is like if you just set a purpose and it fails for whatever reason, which is one of the functions in the contract, you see why I don't have enough funds to send this. So that's why it's failing. There's a little helper function here. You grab the funds from the faucet and now we can do it. So I'm going to click on that because this is a local running on local hard drive. I can actually create a burner wallet and give myself money. It automatically does that in the template just to show you guys.
00:06:39.370 - 00:06:59.090, Speaker B: There's a Web three modal and you can connect to any app using MetaMask wallet, connect, whatever. Right now we're using the burner wallet. I'll show you some the MetaMask in a bit. So I've connected to my burner wallet. Now I have this. I can actually set a new purpose. So I'm going to do that so I can really interact with the contract right away.
00:06:59.090 - 00:07:40.126, Speaker B: And it's super easy to test it out, especially when you just want to prototype things. So that's one part of it. And now we're going to show how that rapid prototyping works. Some of the new commands that I want to go through is there are some Web three helpers like Yarn generate, that creates a local Web three wallet for you so that you can deploy things to other networks, but we don't need that for the local hardat and yarn accounts. That will show you all the status of your accounts on different networks. But I'm going to go into that a little bit more later. Right now what I'm going to do is augment my contract to show you that quick dev loop that I was talking about.
00:07:40.126 - 00:08:04.518, Speaker B: So I'm not happy with this purpose right in here. You see, this contract is basically a purpose and set purpose function and a set purpose event. And that's not enough for me. So what I'm going to do is I'm going to get another purpose, a higher purpose. I feel like I need to do something better with my life. So I have a higher purpose here and that's a new data field. And I'm going to set up a function.
00:08:04.518 - 00:08:23.834, Speaker B: I'm just copy pasting this from a local file. That's why it's appearing suddenly, if you guys were wondering. So this is a function for higher purpose. And basically all this is that because there's a higher purpose, you need to provide some ETH to have a higher purpose. It's just the way things are. So I have this higher purpose. You have to put an extra ETH in there.
00:08:23.834 - 00:09:00.314, Speaker B: And it's just a public contract now, but I'm going to make it a payable contract so you can actually give extra ETH to it. And that's my contract right now. So I'm going to do that same loop again where I'm going to build my contracts. So it'll go through compile all my contracts and build them automatically. Updates the front end with the latest types and whatever is required for this contract then because it's a Hard Hat node, I can easily deploy. So I'm just going to do year and deploy after it's done. You notice that this is in TX on the side.
00:09:00.314 - 00:09:22.798, Speaker B: That's part of hard hat. And then that's done. So now it's immediately updated. Like it just shows up. So we have the higher purpose, the purpose set, higher purpose set purpose. If I make a mistake, for example, I want to set my higher purpose. So higher purpose number two and I send it gives you the full error message.
00:09:22.798 - 00:09:46.034, Speaker B: Some error messages are parsed better, but basically this one says you're not giving it enough eat to send it. So what I'm going to do is because the require statement right here says, oh, you need to send eat with this purpose. I'm going to do that. I'm going to send one eat. You're supposed to send it in GUI. So there's a little helper thing back here. You click on it, it converts it to GUI.
00:09:46.034 - 00:10:01.980, Speaker B: Super easy to do. And we wanted to make your life as easy as possible. And then you send that the transaction was successful and you have a higher purpose now and a higher purpose number two. It's running on a local node. That's right. So fast, if you're running against testnet, it's going to be a lot slower. Just keep that in mind.
00:10:01.980 - 00:10:28.766, Speaker B: So that's basically like a quick thing. Other thing I wanted to mention is that you notice like, there's a console log. Hard Hat allows you to have a console log. It actually would dump that in the yarn chain out here. So you'll have the console logs show up and you can set whatever you want. And it's super useful to debug contracts, so just keep that in mind as a tidbit. So now we're going to do something different.
00:10:28.766 - 00:10:53.274, Speaker B: I want to deploy this to Mumbai. So we're going to go in and check out those two commands that I mentioned right here. Yarn generate and yarn account. So I want to create an account as a deployer that I want to deploy to Mumbai. So I'm going to create a new wallet. So I'm going to do Yarn Generate if I can spell that properly. And then it's going to go in and create a new account.
00:10:53.274 - 00:11:29.662, Speaker B: And this is my account and you're going to need polygon, I forgot what it's called, matic for that or teammatic, whatever. So I'm going to send that to this account for my MetaMask. So zero one and oh, I've got to send it. Here we go. So it's going to be sending that. While it's doing that, I'm going to go to Yarn account and it's going to give me a list of all the accounts and how much eat they have and what the status are. And also like this handy QR code if you need to access it in another device.
00:11:29.662 - 00:12:06.434, Speaker B: But basically I'm looking for Mumbai and the balance is 0.1. The money I sent for MetaMask has shown up in my new account that I've created through Harihap. So what I want to do is deploy this to Mumbai, and it's super easy. With scaffold lead. All I have to do is go to Environment Variables, which is in the white app folder environment. There's a lot more things here that you wouldn't normally put in and check into GitHub, but because this is a template that helps people learn, we wanted to have everything included in there. But when you're going in and developing your own app, make sure to replace all of this with your own API keys and stuff.
00:12:06.434 - 00:12:49.010, Speaker B: You don't want to bankrupt Austin, so please do that. So we're going to go in and I'm going to change this to Mumbai. So it automatically updated the front end and it's going to load. And it reopened that Web Three wallet because the previous login wasn't valid anymore. There's no local host or burner wallets in Mumbai. So what we're going to do is deploy this again so that it can update properly and we get those contracts showing up. And while it's doing that, I'm going to connect with my MetaMask.
00:12:49.010 - 00:13:20.054, Speaker B: That login that you saw there is part of Et hooks, and it uses Web Three modal in the back end. It automatically sets it up so that you can access this user's login anywhere in your application in React app. It makes it super easy, and I'm going to go through that etherist context later. So let me refresh that. I logged in. There is a higher purpose. I can send Matic and change my purpose.
00:13:20.054 - 00:13:58.120, Speaker B: So I'm going to name purpose number two and then send that. It's going to pop up my MetaMask and make me pay some Mumbai matic or whatever it's called, I don't know. And then it'll take longer because it's a testnet. So while that's happening, just wanted to showcase that how easy it is just to change that. All of this is done through the environment variable. If you notice the hard hat I didn't mean to do that. Let me go.
00:13:58.120 - 00:14:22.190, Speaker B: So the Hard hat config automatically uses the environment variable to target the right network. All the tasks that you normally have in Hardhat is not in the same file. It's under this folder, Tasks, and it automatically loads it. There's a bunch of helper ones that we provide as well with Scaffold. So I think it's done now. And then there's purpose number two. So that's good.
00:14:22.190 - 00:14:42.214, Speaker B: So that's a basic overview of that tight iterative loop that I wanted to show you guys. So now we're going to go into how the front end really works. So we're going to talk about the React app. Now the React app is running white. I already showed you how I started. I used Yarn Start and it uses white. It's really fast.
00:14:42.214 - 00:15:09.678, Speaker B: It takes two to 6 seconds. The other version of Scaffold uses Webpack and it takes like 30 seconds to almost two minutes. It's really a huge difference in boost of speed. And now what I'm going to focus on is Eathooks which is library that Scaffold. Et uses both scaffold and scaffold TypeScript. And there are two main things that really help you build those apps. Ethers app provider, which is this react context that lets you access the Ethereum network anywhere in your app.
00:15:09.678 - 00:15:49.002, Speaker B: And all the hooks use this under the hood. And Contracts app context which lets you access the contract, your contracts that you want to use in your app, anywhere in your app. And just to go over this and I'll show you more code about this, the Contracts app context has three main files in Scaffold. It's the app Contracts Config which lets you sets up the contract connectors so you can actually connect to your contract. And I'll show you how that works. External contracts which say example, you want to, I don't know, load up USDC contract or whatever. It'll help you do that without actually pulling the APIs yourself.
00:15:49.002 - 00:16:07.198, Speaker B: It'll automatically get the APIs for verified contracts and load them into the app. You don't have to do any work and I'll show you how that works as well. And Web three modal is basically configuring. This modal and you can set up. Right now I only have MetaMask and wallet connect. Maybe you have some other things you want to add. You can easily do that with that.
00:16:07.198 - 00:16:43.774, Speaker B: So it's very little config and the configurations are all in one place. So right now I'm going to focus on how the contracts are loaded. So there's three types of contracts as far as Ethos is concerned. Hard hat local contracts as you're actively developing external verified contracts like Dai or ETH. Unverified contracts like stuff from Abi, like you load from Abi, it gives you a lot of flexibility. For example, I was working on a hackathon for Lens Protocol and I just had to load the APIs from their local APIs to integrate with that contract. And that was super easy to do.
00:16:43.774 - 00:17:24.090, Speaker B: So going into that a little bit more, the contract context is basically the contexts are already part of Scaffold. But if you have your own app and you're using oh my God, it's slow. If you have your own app and you're using it, all you have to do this is my app. There's a bunch of other things that you don't have to worry about. But the main app is here, there's some error handling stuff here and there's a contract tab Context and Ethers Tap Context and you just have to wrap your app in that and that's all you need to do. This is already done in Scaffold, but that's all you need to do if you want to add this to your own application. Etherhooks to your own application.
00:17:24.090 - 00:17:58.062, Speaker B: So this contract app context is going to set this up. So what it does is the first thing it does is configures your app contract. So when you run Yarn Build Contracts Build, it runs hard at deploy. It creates a type through type chain and then the types are generated for the contract and automatically pushes them into the front end and using the app contracts config. So this is how you configure the contract. So I'm going to show you that now. App contracts config.
00:17:58.062 - 00:18:24.606, Speaker B: So right now this is the appcontracts config. There's a lot of comments in there to make your life easier to help you understand how this works. In addition, just to show you guys, Etox has a huge documentation page. We're improving it as a go and there's guides and different things that you can use to really get into that. So I'll paste those links in a bit. So right now I have one contract. So your contract, you've seen to me deploy it before.
00:18:24.606 - 00:19:04.918, Speaker B: There's a function that creates that contract connector based on the name of the contract and the factory that's generated by typeship automatically. When you run Yarn Contracts Build, it automatically generates this factory and puts it in your front end code under the generated folder. And that's how your contract is used. So I want to add two more contracts. I'm going to use add your NFT, which is another local hard hat contract. So to show you guys, I'm going to go to the Deploy folder in my hard hat, go to contracts, re enable this. It's just a simple contract that loads.
00:19:04.918 - 00:19:27.422, Speaker B: It's just an ERC 721 contract. So that's ready. And I'm going to have to run yarn contracts, building yarn deploy again to set that up. Another thing I wanted to show you is how to load those external contracts. So I'm going to enable this as well. So this is going to be enabled and right now it's not loading properly. So I will set this up.
00:19:27.422 - 00:19:52.314, Speaker B: All the external contracts are loaded into this folder, but it hasn't done that yet. I'm going to have to build that again. And this other example is how to load things from Adi. I just put that there as an example. I'm not going to go into that right now. So now I have all of this enabled. One more thing that I need to do is I need to go to my external contracts and enable this.
00:19:52.314 - 00:20:19.040, Speaker B: So basically there is external contract config file where I'm saying, hey, I want to load Dai in Mainnet. The Dai contract is located in this address. This uses ETH SDK library under the hood. It automatically configures everything. It's an amazing library. It's the same guys who did type chain. So give them a lot of kudos for this.
00:20:19.040 - 00:20:35.350, Speaker B: So this is going to load the Dai contract. You don't have to worry about loading APIs. It automatically does that to you. This is really valuable for anyone who wants to interact with any contract out there. It makes life a lot easier. So that's it. I'm pretty much going to run yarn.
00:20:35.350 - 00:21:28.834, Speaker B: What was it? Contracts, build again. And it's going to oh, it doesn't need to compile anything, but it's loaded the Dai contract right here and then all that stuff. So basically, it's loading this app contracts. And the second part is that as part of ethics, there is a contracts context factory that you need to call in your app. It's already done in Scaffold, but if you want to deploy it, use Ethhooks and another in your own project, for example. And it generates, based on your contract config a bunch of hooks. The hooks, basically one hook to load the contracts, one hook to connect the contracts, and one hook to actually use the contracts.
00:21:28.834 - 00:22:06.850, Speaker B: I'm going to show you that. Now, the actual code on where I'm using the contract is here. It's a bit like advanced TypeScript stuff. So little TypeScript magic going on. But basically what it's doing is you just have to call the contracts context and then call it with that function that I just showed you, which is this thing right here, app contracts config from that other file that I was just showing you, which is this function right here. Go away, zoom. And the rest you don't have to worry about.
00:22:06.850 - 00:22:49.726, Speaker B: I won't go into the details of how it works, but it's basically generating the context and a bunch of hooks for you that you can use in your app. It's basically like a factory helper factory, and you're telling it what the types are. And that's where the TypeScript magic happens. So with that TypeScript magic, what you get is I am going to put it so I have this main net die contract, right? I just disabled this. Before I go into that, I have to use those hooks to load the contract. So I'm doing that here, use load contracts, which is this one right here. And I'm also telling it, hey, I've loaded the contract.
00:22:49.726 - 00:23:21.420, Speaker B: Can you connect my contracts to the mainnet? Can you connect my contracts to the network? My user is currently logged in right now. I'm logged into Mumbai, I think, so it does that for you. And what's happening here is that I'm going to get an instance of the contract. So use app contracts is what does that. So right now, I'm saying I want the Dai contract that I mentioned in the contracts config, which is right here. See, it says load the die contract. So, yeah, go away.
00:23:21.420 - 00:23:50.990, Speaker B: So you have access to the die contract. Now, this is entirely typed main net Die, and you have access to the entirety of that contract. So you get to see everything about the contract. So Die has some special functions. It's not a normal ERC, 20 token. Like there's some other stuff like I think burn and a few other functions that are specific to Die. And you get to see those things so you can't make those mistakes.
00:23:50.990 - 00:24:23.978, Speaker B: This thing is strongly typed. So if you put some random gibberish in here or call the wrong contract, it's not going to allow you to do that. So that's one of the good things about this TypeScript stuff. And to give you a further example, there is a file called Use Scaffold hooks examples just to show you more. And in here I have a place where I'm loading using that Dai contract. So I'm going to uncomment this. So basically what's going on here is I'm loading that dye contract on the main net chain.
00:24:23.978 - 00:25:09.530, Speaker B: I have access to that contract and then I'm basically getting my main net Dai balance for the address that I've logged into with that. So you notice that I'm using the Use balance hook as one of the hooks and I'm passing in my current account from the Ethers app context. I'll go into that a little bit more in detail a bit later, but it's basically my current address of the person who's logged in. And I'm basically saying, hey, don't use the context provider, use this mainnet provider because I'm logged into Mumbai. But I want to see my mainnet Die balance. And that's what's happening here. There is some console logs that shows my mainnet Die balance.
00:25:09.530 - 00:25:32.882, Speaker B: I'm going to disable this one. Okay. So if I go back to my app, you'll see in the console log, I'm going to log in first. Zoom thing is annoying me. So I'm going to log in first. I use my MetaMask, I logged in. So if you notice in the console, I have my main net, my local balance and my current chain.
00:25:32.882 - 00:26:12.546, Speaker B: And I think my main net balance is here too. It's talking about the Dai contract and and then it's probably oh, didn't show up. Oh yeah. Because I did not enable. So the other thing I was going to do okay, let's see, what else do I cover? Oh yeah, that's a good quick overview. So one thing that I wanted to do is enable the other pages that shows the Die contract. So I've had it commented out.
00:26:12.546 - 00:27:12.920, Speaker B: So basically there's a helper function in here and all I have to do is uncomment these two. So it's loading my NFT contract and my Dai contract as well. There's a function called you just have to provide it a list of pages and it'll automatically render those pages for you. So you notice now you have your NFD contract that you can interact with and the main net Die contract that I can interact with and get the balance off and use it for whatever purpose that I need it. Oh, and then you have your Dai contracts show up here as well. Dai balance show up here in the console log as well. So that's a quick overview of how the contract context works.
00:27:12.920 - 00:27:49.966, Speaker B: And then the last piece is the Ethers app context. So Ethers app context is a way for you to interact with your hooks. Sorry, interact with the Ethereum provider anywhere in your app. It uses the context that I showed you earlier. And so for example, you can also have alternate contracts like I showed you with the Die contract use Scaffold. Sorry. So for example, here I want to get the DAC contract from Mainnet.
00:27:49.966 - 00:28:24.474, Speaker B: So I'm passing in explicitly main and Adapter. Normally it'll just use the provider for the currently logged in app user. So if they're logged into Mobile, I'll just show you that. So it allows you to access the context anywhere you want. So for example, I have this Nested page example that I'm going to show you guys. So I'm going to enable that as well. It's just an extra page that's going to show up and that page is nested somewhere in my react three.
00:28:24.474 - 00:28:58.758, Speaker B: So you don't have to pass down your provider through all three of react three, right? That's the ease of using the contract. So I have the Ethersapp contact context here. All you have to do is do this to use it and then I can use my Use Balance hook and get that balance for that particular user. Or I can use the Use Balance hook to get it for my currently logged in user. So I'm going to get the account of the currently logged in user. Let's see my balance. I'll just use that.
00:28:58.758 - 00:29:31.112, Speaker B: So going to enable these. Basically, I'm going to show this balance on the screen and that's what it does. And then I'm going to show my my balance here. So this is showing me some TypeScript errors. Oh, I have to import the hook. Okay. So I've imported the hook.
00:29:31.112 - 00:30:08.130, Speaker B: It's going to load. And this is the Nested three. You notice that it's a bunch of nested components, but it's still super easy to access the context right here. And one of the advantages of using the ETH hooks is that you actually get the status of the hook. So you notice that it's switching from loading to success. It actually allows you to provide a better UI by knowing the status of a call to the Ethereum network so you can show loading screens and show errors in a much more sophisticated way. It's a lot easier than just calling the provider and getting the data for that contract or for something else.
00:30:08.130 - 00:30:43.372, Speaker B: And that's basically a quick overview of how the provider works that I wanted to show you. I've already talked about how you can pass in alternate providers into It. So for example, you're logged into Mumbai but you want to use the ENS provider. You can easily do that by passing it in. One of the other things I want to show is a lot of problems that we have is that updating Ethereum data. So if you set your apps to update every block and then the user logs into polygon, they're going to be updating every second. It's going to spam your Alchemy provider network, for example.
00:30:43.372 - 00:31:29.444, Speaker B: So one of the things that Ethoks has built in is rate limiting and basically you set it normally updates on every block. So for example, this local balance is updating every block. But I'm going to tell it hey, update every ten blocks and that's definitely possible with this use balance. I can also tell it hey, update every ten milliseconds or 100 milliseconds or something like that. That's also thing it uses React query under the hood and it allows you to do this super easily. All I'm doing here is use block number interval and passing it ten or use refresh interval which is a polling mechanism and I'm telling it to update every 100,000 seconds. I think the other one, there's some fancier things in React query.
00:31:29.444 - 00:31:58.288, Speaker B: Like for example, this one is telling it to update whenever the user brings that window into focus. So they do something else and they come back to the browser and click on it. It try to update everything immediately. So that's a huge advantage. You're not going to be spamming your Ethereum providers or Alchemy provider or anything like that. So that's a big advantage to it. And it also stops things from constantly refreshing if you have a bad hook or you didn't do the dependencies of your hook properly.
00:31:58.288 - 00:32:46.800, Speaker B: The other thing is that it also provides a manual update so you can actually have a function call an update and that's possible too that's this updater. I can call that and say side effect if I wanted to. And the last part I wanted to cover is Caching. So everything that uses ETH hooks, all the hooks cache their context so you're not overloading your provider. Say you have a huge spike in volume. This will automatically cache everything based on your parameters and you can call the same hook in multiple places in your app. Say I'm calling use balance in my main page and then I'm calling it here as well and I'm calling it somewhere else for the same account or the same address.
00:32:46.800 - 00:33:15.070, Speaker B: It's going to collate all that and only make that one call automatically. And you get this for free using ethics. So that way you don't have to pass on variables, you don't have to worry about repeated calls. You can also make sure that when the user logs out, it automatically invalidates all the cache. When you use the logged in, it validates the cache. So it's very powerful and it saves you a lot of time and effort to do this. Just double checking on how much time I have.
00:33:15.070 - 00:33:44.630, Speaker B: So that's basically what's capable in ethics. There is a lot of hooks out there. If you go to the docs, you'll see there's use Balance, use Block Number, use Contract Loader Reader. You can get the current noms, whatever you need. I'm going to quickly show you how use Contract Loader works. Use contract reader works. That's probably an important one.
00:33:44.630 - 00:34:25.090, Speaker B: So right now I'm getting the purpose and using that purpose somewhere. So what I'm doing is I have the contract here and I'm going to call use contract loader. Sorry? Use contract reader. Sorry, I said the wrong name. I'm going to pass in my contract that I wanted to use and I'm going to say, hey, I want you to call Purpose in my Use Contract. I want you to call Purpose and that's it. And you get access to that purpose anywhere in your app.
00:34:25.090 - 00:35:20.080, Speaker B: It's that easy to use Contract Reader if you want to do it for something more complicated, say in the main I have main and then I have the main net die I want to interact with. I can use use Contract Reader and pass in mainnet die and say Mainet. I want to, I don't know, get call something that has parameters. It actually types the parameters so when you pass it in, sorry, my computer is slow because streaming. So if you pass in the wrong parameter, say I try to pass in a string into this that's going to throw an error. So this really helps you make things more type safe so that you don't make mistakes. Calling contracts or even writing to contracts.
00:35:20.080 - 00:36:02.796, Speaker B: This is a huge difference. It's the same with Use contract writer as well. So that's basically a quick overview on Scaffold TypeScript and React ETH and how to use that in your React app. And there is documentation that I will paste in the channel. It'll definitely be uploaded into YouTube and then I'll answer questions. So that's pretty much it. Please go on to the links I provided and you can also go through the docs to find out more and you can go to Scaffold repo.
00:36:02.796 - 00:36:38.796, Speaker B: And there's also a couple of things I wanted to show you. There's this wonderful site called Speedrun Ethereum that has also a TypeScript section. Basically Austin and the team have worked really hard on getting this work. This is an easy way to get onboarded into Ethereum to learn how it works. You go through a bunch of challenges and there's a TypeScript version of a lot of the challenges as well and it teaches you how to create NFD and different things in the Web three world. Yeah, I rushed through that. There's a lot to cover so I'm going to go on and paste this into the channel.
00:36:38.796 - 00:37:14.020, Speaker B: If you guys have any questions, I'm more than open to answering them now and let me know if there's anything in particular you guys want me to cover. Oh, yes. So, yes, it is possible to use Tailwind. It's already part of the app in faculty TypeScript. If you notice in Nested page, I am using Tailwind here. It's already part of the template, so you don't have to worry about it. You can just use it, it just works.
00:37:14.020 - 00:37:40.360, Speaker B: The components that we're using are part of this library called EAP Components and that uses Ant. We're in the works to update that component library into using Tailwind and make it headless as well. That's a work in progress. We'll keep you guys updated about that. Okay? Doesn't look like there's any major questions I can check on the Discord.
00:37:55.300 - 00:38:17.370, Speaker A: It doesn't look like there are any questions on Discord right now either, but I'm sure more questions will come in. And for the rest of you, if you do have any more questions, definitely feel free to ping Shravan on Discord as well. Yeah, I guess with that being said, we can just end things here then.
00:38:18.780 - 00:38:20.090, Speaker B: Thank you so much.
00:38:21.020 - 00:39:09.780, Speaker A: Yeah, thank you, Shavin, for taking the time to do this workshop for the hack money hackers, super informative, and I think that Scaffold ETH is always like, something super interesting to learn. So, yeah, thank you so much. And for the rest of you, thank you for tuning in to Shravan's workshop. And that is our last workshop of the day. There's going to be more tomorrow and for the rest of the week, so definitely tune into those as well. Otherwise, this workshop is recorded and on YouTube, so if you want to reference it after at any point after, feel free to go on YouTube and you can find it there. I know we had a question in the chat about that, so yeah, with that being said, hope everyone has a great rest of your week and thank you for joining.
