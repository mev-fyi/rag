00:00:01.050 - 00:00:21.920, Speaker A: Cool. All right, welcome, guys. This is the Aztec developer workshop. So today we're basically going to do a couple of things. We're going to take you through an overview of what Aztec is and how it works. And then secondly, we're going to do like a demonstration of some code to talk through how you can use Aztec and integrate with it. But first of all, join our discord channel.
00:00:21.920 - 00:00:58.250, Speaker A: So just whip out your smartphone, scan the barcode, and just take you straight through to our discord channel. We can ask any questions you want. You'll ping me and Joe straight away and we'll be on there to help out. So I think first of all, if we just introduce the Aztec bounties, that's what everyone's interested in. So we've got $1,000 for the best use of Aztec in any DAP. So that's any sort of implementation of DAP of Aztec, which is pretty interesting and does some interesting stuff. And then secondly, we have $500 for the best use case of Aztec in the private identity solution.
00:00:58.250 - 00:01:36.282, Speaker A: So if you've got any questions about that, feel free to ping us later on. And then today you've got me and Joe both from Aztec. I'm going to talk you through an overview, what it does, what the ecosystem looks like, and then Joe's going to take you through some example flows. So if we start off, why is privacy important? So traditional financial services offer privacy by default. When you have a bank account, you have privacy built in by default. If you're going to rebuild these services and markets on chain, then this is a prerequisite. It has to be built into whatever product you use.
00:01:36.282 - 00:02:11.138, Speaker A: It's essential across the industry, and it will also allow users to control third party access to their financial and personal data. So privacy is essential and really important if you're ever going to take some of these markets that already exist in the traditional world and rebuild them on chain. So where does Aztec come into this? Well, Aztec is a toolbox of plug and play cryptography. It has a few different quite interesting properties. So it's interoperable between different DApps. We have a single trusted setup and a single common reference string. It's extremely gas efficient.
00:02:11.138 - 00:02:48.260, Speaker A: So gas, everybody knows you have to pay for computational work on ethereum, and this is expressed in gas. And so you want your gas cost to be as low as possible. And Aztec is currently about 800,000 to about 900,000 gas for a standard transfer. But with EIP 1108, which is on its way, that will hopefully reduce some of these elliptic curve operations down. So that a single transaction costs between about 200,000 300,000 gas. So gas efficiency is important. And Aztec has fast proof construction, which makes it possible to use in a browser, for example, on a mobile phone.
00:02:48.260 - 00:03:12.860, Speaker A: And the alpha is ready today. If you look on our GitHub page on some of our blogs, you'll see that the Alpha is out there. And we're going to go through what some of this looks like. So if we move on, then to what the Aztec ecosystem is. So there's three core components. And we'll start first with the central box in the middle, the Aztec Cryptography engine, otherwise known as the Ace. So this is an ERC at the moment.
00:03:12.860 - 00:03:54.338, Speaker A: And basically this is like the central nervous system of the whole Aztec ecosystem. It coordinates things. The Ace has a set of validator contracts that you can see on the right hand side, join, split, bilateral swap, mint. There's about seven at the moment. Basically what the Ace does is it takes proofs that have been served to it, that have been constructed by these ZK assets, and it will verify them using these validator contracts. It will check whether the zero knowledge proof is a valid zero knowledge proof and whether whatever type of financial transaction that you are trying to perform is legitimate. The Aztec Cryptography engine checks the mathematical legitimacy of these transactions.
00:03:54.338 - 00:04:20.586, Speaker A: So total inputs equal total outputs. And then the ZK assets, which you can think of almost as like a confidential equivalent kind of to an ERC 20, they have that same sort of standard interface. They deal with permissioning and all the sort of flows. And this is how it all kind of links together with a user DAP, the Cryptography engine, the validator contracts, and the ZK assets. So that's a bit abstract. That's a high level view of what the Aztec ecosystem looks like. And if we just move on to the proofs.
00:04:20.586 - 00:04:36.834, Speaker A: So currently we've got a few proofs. I think there's seven in total. We're representing a few here. So the basic one is send. So this is how person A pays. Person B, you send what we call Aztec notes. Otherwise, this transaction is also called a joint split.
00:04:36.834 - 00:05:06.186, Speaker A: You can also swap confidential digital assets using Aztec, a bilateral swap. You can pay interest using Aztec. There is a zero knowledge proof called a dividend proof, which lets you calculate one note as a ratio of another. And so you can pay interest. You can mint directly Aztec notes, which is useful for stablecoin applications. And similarly, you can burn Aztec notes and destroy these representations of value. An Aztec note is an encrypted representation of value in our ecosystem.
00:05:06.186 - 00:05:32.150, Speaker A: And lastly, there are proofs called private range and public range proof, which allow you to check that these encrypted representations of value are greater than or less than another value. So that's a light speed overview of our ecosystem, of our different proofs that we've got. And now to bring this all to life, joe is going to demo some of the things that you can build with Das Tech and some of the things that you guys might be working on today. So with that, it's over to Joe.
00:05:50.130 - 00:06:31.960, Speaker B: Give me 2 seconds just to get this so everyone can see it's cool. So what we've got here is one of our starter kits. It implements a confidential loan. And we're going to do yeah, let me zoom in on both of them. So, yeah, what we've got here is it's one of our starter kits. If you look on the Discord channel, there's a link to the GitHub repo under the hood here. We're actually integrated with the Graph Protocol to make this a real time UI.
00:06:31.960 - 00:07:13.940, Speaker B: We don't use MetaMask because of some of the signing flows. They require access to public keys and private keys, which you can't currently do with MetaMask. So we use a hot wallet. So, first of all, let me just go to the docs and grab my very secure mnemonic here. So I'm just going to yes, the Graph Protocol, one of the main sponsors. So this under the hood, it's got a set of mappings to kind of just make the UI real time. It's a react app with GraphQL to kind of just make this usable.
00:07:13.940 - 00:07:39.810, Speaker B: So in this app, we're going to create notes, Aztec notes, which are confidential. And then we're going to settle a loan confidentially with an ERC, 20 token. And then we're going to stream interest out of that loan in real time. And all of that's kind of facilitated by the Graph. It's actually just our own private one. We'll be launching our own yeah, local ganache. Yes, just running right here.
00:07:39.810 - 00:08:17.132, Speaker B: We'll be launching a public Aztec subgraph in about three or four weeks, but it's not ready for this hackathon. So I'm just going to add the wallet. It's a lovely secure password of test. And we'll restore the wallet here. So we're going to treat the left hand side as the borrower and the right hand side as the lender. So the first step is to go in and create a loan. What we're trying to do here is create a loan where the notional is obscured from public view.
00:08:17.132 - 00:09:10.220, Speaker B: So when this is broadcast to the smart contract in the contracts, in the inputs, you can't deduce kind of what the actual notional value is. We're going to use a local representation of Die as the EFC 20 to settle the loan in. We'll set a 10% interest rate and we'll do a very short loan because we don't have much time. Um, so when I create this loan, we're actually using the mint proof to under the hood, create an Aztec note registry. Mint notes inside that or mint one note worth 150,000, which represents the loan's notional. If we go to the left hand side, at the right hand side, sorry, we can see the lenders view and there's a loan that's been created there's. The public terms of the loan here, but the notional is obscured in private.
00:09:10.220 - 00:10:01.980, Speaker B: So the next step is if a lender wants to come along and is potentially interested in fulfilling this loan, they have to kind of request access to the loan's notional. And what this is doing under the hood is every Aztec Note has a viewing key which allows user to decrypt it. And we're going to share that viewing key with the lender through the graph. So if we go here, we can see we've now got a new viewing request which comes from this Ethereum address. So we're now going to use some Ies encryption just to share the viewing key across the graph. And as we do that, the loan will move from pending loans to approved loans and we'll now be able to see the notional balance. So the next step is the lender still happy to proceed, is to settle the loan.
00:10:01.980 - 00:10:55.468, Speaker B: So what we're going to do here is perform a bilateral swap. We're going to swap 150,000 die for the loan note, which is worth 150,000. And what Ace and Aztec, the Aztec Cryptography engine, is going to do is validate that the 150,150 thousand are equal and if they are, it will perform the swap and the assets will change hands. So in order to do that, we have a mintable die contract that lets us mint 150,000 die, which would be nice in real life. But so the first step here is just to give us 150,000 die and then we're going to perform the swap. It's worth noting here that the 150,000 die don't instantly get sent to the borrower. They're actually owned by in note form, they're owned by the Smart contract, which allows some pretty complex flows, such as interest streaming, which we'll see in a second.
00:10:55.468 - 00:12:12.072, Speaker B: So when I press this under the hood, we're constructing bilateral swap proof which is going to settle the loan. We're going to send that up down to the local Ganache instance and the loans now have settled and we can see that interest is now accruing on the loan in real time. And under the hood here, using Aztec, we can withdraw interest to the nearest block time and we can have the blockchain validate that the correct amount of interest is being withdrawn in a non interactive way. So on the left hand side, the borrower can withdraw the balance if they want to, minus any accrued interest. So say they've got a working capital requirement, they need to withdraw 50,000 die, they'll withdraw that and we'll see in the top right hand corner, using the graph as that note is created, we're able to decrypt that and add it to the user's account balance. And on the left hand side, we're actually going to use, as Tom was explaining earlier, the dividend proof to compute the currently accrued interest as a function of the elapsed duration of the loan. And we're going to have the Smart contract validate that the proof the lender sends is correct.
00:12:12.072 - 00:13:15.512, Speaker B: And if it is correct, because it owns the underlying balance note, it can perform a joint split to split the currently accrued interest and the balance into two notes, one owned by the smart contract and one owned by the lender. So here, if I try and withdraw a portion of that, we'll see that there's some quirks of integer arithmetic and solidity, so we have to find an amount that corresponds to an actual second. So once we've done that, we'll then be able to withdraw 11,388 die, which we'll see in our account here some other interesting use cases of this. If the lender decides sorry, if the borrower is irresponsible and they decide they want to withdraw the entire balance of the loan, the loan will start. This one is actually already sorry, let me just create one more loan. This one's actually already matured. So I was going to show you the default functionality.
00:13:15.512 - 00:14:06.296, Speaker B: We have a proof that uses our private range proof, which allows a smart contract to validate that the collateral stored in the collateral account is currently less than the accrued interest, which allows kind of programmatic default to occur. So in this case, if this loan was backed by any security, such as on chain real estate, such as a house, you could transfer the title of that security on result of a default to a new owner. Or if it was a kind of crypto backed loan, you could transfer any collateral to a new owner. But unfortunately, this loan is matured, so let me just create a new one very quickly. Actually, we can show you this tomorrow, actually, because we haven't got that much time and we want to get people coding. So all of this is possible kind of with Aztec. This is available as a starter kit on GitHub.
00:14:06.296 - 00:15:01.260, Speaker B: It's using the graph and it's got a load of kind of helper functions just to make integrating Aztec on the front end easier. So feel free to grab me tomorrow if you want to talk through any of how we set up this interface and how we set up the graph. For now though, we're going to switch back to the presentation and we're going to run through a small what's happened here, a small set of what you can build for Aztec. So, Aztec was originally made in our previous life. We were a company called Creditmint, and we were trying to put large scale syndicated loans on the blockchain. But Ethereum kept promising that privacy was coming, and a year and a half later it never materialized. So we ended up building it and pivoting to a kind of privacy protocol.
00:15:01.260 - 00:15:58.588, Speaker B: So it's obviously very useful for large scale financial markets. Some of the other use cases which we're excited about people building in the hackathon are services like a private venmo. So being able to send money confidentially using Ethereum and also private identity solutions. So using the range proof, which is the latest addition to our toolkits, you can prove very interesting things about your identity. So you can prove that you're say above 21 and you live in a US state that supports gambling without revealing which state or how old you are. Or you could prove that you have a salary of above $70,000 to get a mortgage, but not say how high above it is to make sure that your rent's not increased too much. Or you could do interesting things with your credit score, proving your credit score is in a certain range without revealing what it is, which is very interesting for some DFI applications.
00:15:58.588 - 00:16:18.390, Speaker B: So we're very excited to see what you will build. I think the main takeaway now is just to get everyone coding. And before we do that, I'll just do quick one or two questions if there's anything I've missed. But then we'll get everyone coding and we'll clone down a quick repo to kind of get Aztec deployed to a local blockchain and run through basically how it works.
00:16:22.440 - 00:16:31.080, Speaker C: I'm guessing it's a hot wallet, so they would have to own whatever token or ether.
00:16:33.680 - 00:17:01.750, Speaker B: So just for now, we used a hot wallet just for ease of signing flows. There's an EIP, I think it's one of the MetaMask EIPS, basically, which allows delegated signing flows, which once integrated, we'll be able to use MetaMask. But for kind of large scale loans, we'd probably suggest that they integrate with a custody provider that provides access to the private key to allow the signing probably on a server. So the hot wallet is just an example right now to kind of get up and running.
00:17:02.440 - 00:17:23.470, Speaker C: How do you keep what the original loaner, how do you keep that private? Because they're obviously sending it to the contract to convert it. How does the loan stay private from the loaner side?
00:17:24.320 - 00:18:09.290, Speaker B: Talking about from the settlement, like ERC 20, the dai. So for a public token, there's one kind of place where the confidentiality falls down. When you transfer tokens into the Aztec ecosystem, that's obviously public, but once the tokens are in note form, it's confidential. So for a real use case, we'd recommend kind of not using an ERC 20 and have a fiat provider or stablecoin provider that mints directly into Aztec. So on receipt of a bank transfer, they'll mint a note worth $100,000 or something to be able to settle the loan. And in that case, it's completely impossible to tell what that note is worth. Only you and the bank kind of know.
00:18:09.290 - 00:18:51.792, Speaker B: Hopefully that helps. All right, so let's get coding. So if you head to our discord channel, I'm going to end this PowerPoint 1 second. So just quickly, but actually before I end this, we're going to run through an example of how to build private venmo using Aztec in 100 lines of code. So the flow we're going to kind of go through is Bob is going to deposit $100. In this case, we're assuming that there's a bank account API that will tell us that on receipt that $100. And we can issue a note worth $100 to Bob.
00:18:51.792 - 00:19:37.108, Speaker B: He's then going to take a taxi to East New York. It was raining today, if you didn't realize, then he's going to pay Sally $25 for the taxi, but he wishes to pay confidentiality. So in order to do that, we're going to do a join split, which splits his original $100 note into $75 and $25. He'll retain the $75 note, the $100 note will be destroyed, and the $25 note will be owned by Sally. And yet, obviously in this, the values of the Mint and send transactions are confidential. It's worth noting that Aztec follows a UTXO model similar to Bitcoin. So you have to keep track of a lot of notes, which is where the graph comes in.
00:19:37.108 - 00:20:15.836, Speaker B: And it's quite useful because it allows you to every time a note is created or destroyed, we use it to kind of tally up those notes and associate them with a particular user. So if I head over to GitHub, it's also 06:00 A.m. For us. So if this doesn't make sense, please explain. Ask me to stop and I'll go over this again. So if everyone can go to GitHub, let me zoom in on this. We have an Aztec Ganache starter kit and we are going to just run through kind of I'm going to do it with you all, just kind of cloning this and following the README.
00:20:15.836 - 00:21:08.810, Speaker B: And then I'll walk through the code. And hopefully by the end of this, we'll have everyone set up with a development environment where you can start writing smart contracts and integrate with a local version of Aztec. And I'll talk through some of the proof construction and we'll talk through all of those flows in the private venmo example. So has everyone got to this point of cloning the repo? Let me just quit. This is really small. Cool. So first step, let's clone the repo.
00:21:08.810 - 00:22:32.646, Speaker B: Now we're just going to CD into that directory, and using this means you need to have node installed and yarn. So assuming that's the case, we can just run yarn install and we'll install kind of all of the packages we need. Let me figure out if I can hang on. I'm just going to try and zoom in on the display because it's not going to be visible on the live stream. Okay, so the next step included in this, we've got a M file, which has just some deterministic ethereum accounts, which we've given a thousand efer to just to make it easier to develop. And the startup command will start a Ganesh instance with those accounts. It just makes local development a bit easier.
00:22:32.646 - 00:23:15.580, Speaker B: So the next step is just to rename the M file to something that Ganesh can talk to. Has everyone got laptop? If you just type this command, paste this command, the file is called renameme m, and this command will just rename. If you just paste this command, it will rename it. If you just paste that whole command, it will do it for you. It will take this file and it will rename it to this file. So then you'll be good to go. And then the next step, we're just going to run Yarn Start, which will start up our Ganache instance.
00:23:15.580 - 00:24:24.784, Speaker B: And I'm now just going to open up another tab. And just quickly before I do this, I'm going to compile the contracts. You have to add the compile flag just because there's quite a few Aztec contracts that we need to compile. Here. You can see we've compiled all the validators and the reference implementations of our ERC 1724, which is a standard for confidential assets. We've compiled all of those because we'll be using them in the private venmo example. So after we've done that, I won't run the test script now, actually I'll just and we'll run through what's happening under the hood.
00:24:24.784 - 00:25:11.144, Speaker B: So I think the first thing to talk through is the migrations that are required to deploy Ace, which is that central kind of coordinator that the system requires to a local blockchain. We have deployed versions already on Rinkby and our main net release will go live in Q Three. But for local development it's much easier to obviously just have one on Ganache so you can test it out without having to deploy every time. So first of all, we're going to require all of the artifacts we just compiled with Truffle. Ace is obviously the cryptography engine. And then as Tom was saying, we have our toolkit validators. Each of these corresponds to a different zero knowledge proof.
00:25:11.144 - 00:25:48.450, Speaker B: The adjust supply is for minting and burning. The bilateral swap is our swapping proof, which can be used for trades. Dividend computation is the interest. One private range allows you to prove that one Aztec note is greater than another Aztec note. And the joint split is obviously the sending so you can split a note into multiple. We also have a dev utils package which allows us to kind of require some constants which are used inside Ace. So the first thing we do is we deploy Ace and all of the validators we need.
00:25:48.450 - 00:26:42.640, Speaker B: So once we've done that, we need to set our common reference string. So Aztec uses a very efficient range proof to enable it to be around 800,000 gas. And this common reference string basically tells Aztec which set of trusted setup database points to use. We've run an internal trusted setup right now and this just points to our own kind of test trusted setup which goes up to a million points. The production version will go up to two to the 32 sorry, two to the 30, I think, which is just over 100 million. So this just tells Aztec which set of points each of the notes will use and is used for the underlying cryptography. We then have to tell the cryptography engine which validator contracts it should use for each of the proofs.
00:26:42.640 - 00:27:48.170, Speaker B: These are upgradable over time. So if we add new proofs we can overwrite these validators or we can add new ones as kind of the range of functionality grows. So once we've done that, when we run truffle migrates, we'll have a working implementation of Ace on chain and we can start writing our own contracts. So I head over to an example ZK asset. I think it would be important just to bring up one of these contracts quickly, actually just to talk through what the ZK asset actually does. So the ZK asset contract is our let me do the interface. The ZK asset contract is meant to be very similar to an ERC 20 even though it follows a UTXO model.
00:27:48.170 - 00:28:38.776, Speaker B: We implement a confidential approve function which allows the owners of notes to approve smart contracts or other users to spend notes confidential transfer which is the default transfer functionality under the hood. This takes a join split proof and will actually process the transfer. And then the confidential transfer from is used for some of the more involved signing flows. In order to call this, you have to have first approved every note for spending inside Ace. So if we go back to our migrations for a basic zero knowledge asset, we're just going to look at the bottom one here. We're initializing a new zero knowledge asset that's mintable. This means that the total supply of the asset can be adjusted so it will start at zero.
00:28:38.776 - 00:29:29.444, Speaker B: And on receipt of any bank transfer we can issue new notes, increasing the supply to that value. So to initialize the asset we have to set the Ace address that it should listen to, to validate all the proofs. Usually the second parameter of the constructor function for a new ZK asset is the linked token. In this case we don't have a linked token because it's a fully private asset. But if you wanted to link this to Dai, like in the loan example, you would pass in a linked token. There's then a scaling factor, which is if there is a linked token and you want to express larger numbers than the range of the trusted setup, you can multiply by an integer here to help achieve different token values if you need more granularity. And then the last two parameters, sorry, are if the supply can be adjusted.
00:29:29.444 - 00:30:51.688, Speaker B: So in this case it's mintable, so the supply can be adjusted. And the last point is can you convert back to an ERC 20 token? So you'll notice in this one it's false, but in our standards AK asset that's linked to a test ERC 20, the last parameter is true, meaning it's convertible back to ERC 20 form and it's not adjustable because every single Aztec note has to be one to one backed with an ERC 20 that's owned by Ace. So after we've done that in the migrations, that's all you need to put a very basic ZK asset on chain and we can then use that ZK Asset to mint notes and use the Aztec toolkit proofs to interact in various confidential fashions. So if I switch over to actually implementing private Venmo, all of this code would actually run on the client side. But for ease of use, we just have a set of tests that implement this. So just before I going, I'm just going to show you what these do. So the first thing we do is we just create two accounts.
00:30:51.688 - 00:31:43.390, Speaker B: This is similar to our hot wallet setup on the client, but this is running in a test. So we just create an account for Bob and an account for Sally. The SEPK two five six K one package is just a helper package we've published to NPM that just makes it easier to interact with Ethereum wallets in a node environment. And then we then have to get instances of both the ZK Asset mintable, which we're going to call our private Venmo contract, and the joint split contract, which is going to validate the actual transfers. So if we look at our test, the first thing we want to do is we want to deposit a note worth $100. Has everyone got to this stage in their demo so far? Just out of just okay, sorry. We'll go very quick.
00:31:43.390 - 00:32:27.196, Speaker B: So the first thing we're going to do is we're going to use Aztec JS to create a note that Bob owns. We do this by using Bob's public key, and we create a note worth 100. This would usually happen on the client, so only Bob would know this value. When we mint a note, when we use the mint proof, we use the proof part of the Aztec JS library and we use the Encode mint transaction. We pass in a new total, an old total, and the note that Bob's going to be basically granted out of this. Once this transaction is sent to the ZK Asset contract, it will automatically mint this note, and Bob will have a note in the note registry worth 100. So that's the minting step done for you.
00:32:27.196 - 00:33:14.990, Speaker B: And it's as simple as just using one of these off the shelf toolkits. So when we call confidential mint here, we're actually going to validate that proof and in one go mint the proof. So then the next step is to do a join split transaction, which is the basic send functionality of Aztec. So we're going to make a note for Sally worth 25, and a new note for Bob worth 75. And in the join split transaction, the only requirement that Ace is validating is that the sum of the inputs equal the sum of the outputs. If that's correct, it will allow the transfer to proceed. So here we're going to use Bob's first note, which we can see was worth 100, as an input note, and we're going to split that into Sally's taxi note worth 25, and Bob's new remainder note worth 75.
00:33:14.990 - 00:34:13.890, Speaker B: There's some. Signing that goes on under the hood that the input notes have to be signed by Bob. But once we've constructed this proof using Aztec JS, we can then send this to the ZK asset contract using confidential transfer and the transfer will happen. So if we run Truffle test, you should see and that's how you kind of do private confidential transactions with Aztec. Me and Tom are going to be around all weekend to help you in the discord channel. We've got a series of articles which kind of walk you through getting set up with Aztec and hopefully everyone gets to build some really cool stuff. We can't wait to see what everyone builds.
00:34:13.890 - 00:34:17.110, Speaker B: I'll have any questions if we've got time. Good luck.
00:34:25.930 - 00:34:32.120, Speaker C: Leverages the graph. Yeah, I'm not sure what that is, but can you kind of go like, what does.
00:34:33.970 - 00:35:29.370, Speaker B: Makes if we go back to the loan example building? I don't know if many people have built UIs on Ethereum, but it's not very fun having to kind of query contracts and in react. There's a very good library called Apollo which allows you to have a GraphQL server and the graph just puts a GraphQL endpoint on top of ethereum. So you can write mappings for all your smart contract events and you can just query normalized data in a much more readable format. Yeah, it's just like a nicer interface for connecting to a node. It's currently centralized, but they're playing a decentralized solution for it. It's just easier for kind of like infuria but a GraphQL server, they'll explain it better, go and talk to them. So we just use that in this to make building interfaces easier and it's useful for keeping track of notes.
00:35:29.370 - 00:35:55.234, Speaker B: So if you have a note registry that's outputting create events and destroy sorry, create Note events and destroy Note events. You can listen to that and you can assign them to a particular user. And it's much easier for kind of figuring out the total balance of a particular user's notes. In the future, we'll be launching Aztec subgraph, which will be kind of maintained by us to make that easier. But we need to do a few upgrades to the protocol before we can do it properly.
00:35:55.362 - 00:35:57.750, Speaker C: Is that why it doesn't work with MetaMask?
00:35:58.170 - 00:36:20.990, Speaker B: No, the reason it doesn't work with MetaMask right now is you just need for some of the flows, you need raw access to the private key to sign. So to approve a note for spending, you need to sign the note in a particular type data format with your private key. And that flow is not currently possible with all of MetaMask. It will be soon, but when it is, we'll be able to use MetaMask.
00:36:24.290 - 00:36:31.582, Speaker C: Since you're using the graph, would web3 JS still be valid?
00:36:31.726 - 00:37:05.626, Speaker B: So all of the sends for the blockchain are through web3. Like the graph is kind of pulling bit data back down, so it's kind of a cycle. You don't need to use the graph. We just found it out of personal preference for building an actual UI. You can prototype very fast because for web developers, you don't need to even know there's a blockchain. Basically, it's just GraphQL. Anyone else? What information about transaction draft is available to the public? That's a great question.
00:37:05.626 - 00:37:52.430, Speaker B: So currently on the standard implementation, we just do confidentiality, so just the balances are obscured. But the protocols fall compatible with stealth addresses. So you can make the owner of any note a stealth address. Implementing stealth addresses on ethereum is kind of someone else's job, but it is compatible with it. So if someone builds a good stealth address wallet that can do that, aztec is compatible with it. There's a small issue with the gas cost and who pays the gas, and we have some solutions for that, which we'll be talking about in Q three. We have like a mixing service that abstracts that, but if you have a kind of centralized transaction relayer, you can have fully anonymous transactions as well, using staff addresses.
00:37:54.770 - 00:37:57.902, Speaker C: Given that the mint amounts are unknown.
00:37:57.966 - 00:37:59.682, Speaker B: Is it possible to prove the total.
00:37:59.736 - 00:38:01.630, Speaker C: Supply of a note?
00:38:01.710 - 00:38:41.820, Speaker B: Yeah. So for any mintable asset, there's one note that keeps track of the total minted and the total burned. So the owner of the ZK asset who creates that particular asset, their private key, can always decrypt the value of that note and prove the total minted or the total burned. So it can be proven to everyone with a proof? Yes, but it's not public, it's in note form. And if you want to prove it, you could prove it to someone. So you could use the range proof to prove that was above a certain value or below a certain value if you wanted to, and the owner of the note registry. So in your case, the DAP owner could do that.
00:38:41.820 - 00:39:05.860, Speaker B: Anyone else? It cool. Look forward to seeing what everyone builds and yeah, we'll be around all weekend. Just ping us on discord or come and grab us. And we'll happy to help you build and ask any questions about architecting or seeing what you build. Thank you.
