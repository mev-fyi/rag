00:00:02.810 - 00:00:20.960, Speaker A: Hello and welcome everyone to the Starquare Peeking into Cairo workshop. Joining us today, Shaha and Ellie who will be taking the session. Yeah. And with that I will hand it over to them to give a quick introduction to themselves and kick the session off.
00:00:25.450 - 00:00:38.922, Speaker B: Okay, terrific. So I am Ellie Benson, co founder and president at Starquare. Shahad, do you want to yeah.
00:00:38.976 - 00:00:46.620, Speaker C: I'm an engineer at Starcore and I'm the co creator of Cairo. Okay.
00:00:49.230 - 00:01:56.930, Speaker B: Starker is one of the sponsors of ETH Global and we would like to invite you to build on Cairo. And what we'll do for the next 50 minutes or so is first of all give you a little bit of explanation of how Cairo relates to L2 s Starks ZKPs. And that's the part I'll do first. I'll take roughly 15 minutes and the rest of the time Shahel is going to walk you through hands on tutorial to see the full cycle of how one can write code in Cairo and actually get a Stark proof and have it automatically verified on know a full cycle later on during the session. Sorry, during the ETH Global we hope that many teams are going to build we have some tutorials on AMMS voting and a bunch of other things and we hope people will build on it. And I'll now give a little introduction and after that I'll take some questions and hand it over to Shahab. Okay, so the purpose now is going to be a little bit of just state alignment.
00:01:56.930 - 00:02:02.740, Speaker B: I'm going to share a screen. So do you see my screen?
00:02:05.270 - 00:02:06.066, Speaker C: Yeah.
00:02:06.248 - 00:03:23.354, Speaker B: Okay, so the question I want to answer first is why are we learning Cairo? Cairo is a programming language and I guess most of the listeners already know quite a few programming languages, so why learn another one? And the short answer to that is that this is a language that is best suited to build DApps on L2 that have the exact same security that is offered by L One but has at the same time exponentially greater throughput or exponentially lower gas cost. And this can be achieved directly today using Cairo. This is the way we are building our systems and those of you who will build systems can deploy them today on Mainet or you can do that also through StarkNet by summer. So this is a system that is up and running. We have a few of our systems in production. We'd love to see more teams build and use this infrastructure that allows you to get the power of ZKPs and the exponential scale they offer at your hands. So how do we get that scale? So everyone would like to take throughput of Ethereum and Ten exit or 1000 exit, which is what we do actually achieve with Cairo and starts.
00:03:23.354 - 00:04:29.266, Speaker B: But what has Cairo got to do with it? Why can't we just press some button and just have it automatically scale or in other words, how do we, with Cairo get this exponential speed up or exponential reduction in gas cost? What's the magic here? So the answer is that what happens behind the scenes is that the computational integrity of Cairo runs of executions of programs written in Cairo can be and is automatically and efficiently proved using the start ZKP and placed and verified on a blockchain. So all you have to do is write code in Cairo and execute it, and then these executions can be asserted and proved to be correct, verified on chain. This whole system is already spinning and working. And then you can consume the outputs of your computation that were done off chain. You can consume them on chain. And we have a full system that works this way. We have three systems in production that are using this framework, and we'll have more up and running.
00:04:29.266 - 00:05:47.594, Speaker B: Okay, so let's now answer four questions. What do we mean by computational integrity? What are cryptographic proofs, which are the method that we use within the field of cryptographic proofs? What are Starks and what are heirs? And some of these terms are going to look magical, but we're going to answer each of these four questions in the remainder of my part, and then we'll see the whole Cairo system working. Okay, so integrity roughly says doing the right thing even when no one is watching. And in the context of computation, it means you would like other parties to run programs and report the exact output that program gives them. But the problem is that often people have incentives to misreport the outputs. For instance, if I'm processing many transactions on some L two version of Uniswap, maybe I'd like to put my transaction first, or maybe I'd like all transactions to just pay me money. How can you trust the output of my computation? How can you trust my computational integrity? So how do we get it? Well, if you look at the conventional system, for instance, banks, basically we trust them.
00:05:47.594 - 00:06:46.570, Speaker B: And there are a bunch of accountants and regulators that look into their computations to assert computational integrity. But it's kind of opaque to the public. If we go to blockchains like Bitcoin or Ethereum, the way they achieve computational integrity is by naive replay of computation, which means that everyone, every node in the network, is repeating and replaying the same computations and processing the same information. This is precisely what limits the scale of blockchains. This is what makes you have in Ethereum a TPS of ten or 15 or something like that, because you want everyone to naively replay the computations that everyone else is doing. Now, Starks achieve computational integrity through math and cryptography, and in particular through cryptographic proofs. So now we're going to answer the second question, which is what are cryptographic proofs? So they are systems that have two main components.
00:06:46.570 - 00:07:51.774, Speaker B: There's a prover and a verifier. The prover is the one doing the computation it is the one executing the transactions. In our case, it's going to run Cairo code, but it could be some other computation, some circuit or some solidity code or some C plus plus code. So there's a prover running the computation, and in addition to running the computation, the prover takes upon herself the extra burden of generating a proof of computational integrity, which is a computationally complicated task. And the nature of cryptographic proofs, and this is backed by many years of research. Is that true statements, statements of the true evolution of a program and its state do have good proofs that can be efficiently generated by computers, whereas false statements don't have proofs and you cannot generate for them, even if you are a very strong and powerful party running the computation. The math and cryptography prevent you from producing these proofs.
00:07:51.902 - 00:07:52.290, Speaker C: Okay?
00:07:52.360 - 00:07:55.870, Speaker B: That's the prover. Now the Verifier checks the proof.
00:07:55.950 - 00:07:56.434, Speaker C: Okay?
00:07:56.552 - 00:08:56.114, Speaker B: It doesn't need to trust the prover at all. It's a piece of software. And the math in crypto that has been researched for like four decades proves that the Verifier with its work can check whether a statement is correct or incorrect. Now, what are we proving? We are proving statements of computational integrity that have the general form that is specified by a quadruple. Quadruple is a specification of the computation, a program, an initial state of the system before you started the computation, a final state of the system after you ended, and a time bound. And if you have this quadruple, the statement that is captured by it is the following. There exists a bunch of auxiliary inputs such that if I run the program, that's the first parameter starting from the initial state, that's the second parameter with the inputs that you are not shown, you will end up in the final state, third parameter within less than T steps.
00:08:56.114 - 00:09:45.318, Speaker B: So this is a statement of computational integrity and it pretty much covers what you would think as the formalization of computational integrity. It is that a system has evolved correctly according to a computation. The four parameters just specify what it means exactly to advance the system. There is a program, it starts from an initial state, it ends at a final state, and there is a time, the number of steps it took to reach that thing. For those of you with a bit of a mathematics and computer science background, you cannot eliminate the T parameter because this would violate the undecidability of the halting problem. Because you need to know for general computer programs, you need someone to tell you what is the time and when they finish because otherwise they could run forever and you cannot really decide it anyways. But that's beside the point.
00:09:45.318 - 00:10:49.450, Speaker B: Back to our topic. Cryptographic proofs are systems that have a prover and Verifier and allow you to reach computational integrity by asking the prover to prove statements of computational integrity in a very general format that programs have evolved correctly and the verifier can now verify the correctness of these. So what are Starks? There's a very large family of different cryptographic proof systems and those interested we can share more information. I wrote a blog post on Cambrian explosion of ZKPs describing a little bit the different parameters that sort of break the set of ZKPs up a little bit more. But ZK starts, which is the technology that we use and which Cairo is tied into, have the following properties. First of all, ZK means they have privacy, which means a ZK start proof is one that does not reveal any information about the auxiliary inputs that went into the computation. In the context of Cairo, this is not something we're supporting today.
00:10:49.450 - 00:11:44.722, Speaker B: It is easy to add it and we will add it to the future. But the core technology of our computational integrity proofs does have this property, but we're not deploying it today. The essence, Stark means scalability, which is exactly relevant to the issue of gas cost. It means that in our proof systems, right, which have a prover and a verifier, you get two things simultaneously. The time required to prove a statement scales pretty much linearly, actually quasilinearly with the amount of computation actually done. Scales like T times polylogarithmic in T, which is very close to T, it's called quasilinear. And at the same time verification is exponentially small in T, meaning verification of a batch of T transactions does not take T steps as in a replay, it takes only log of T steps, which is exactly how you reach scalability.
00:11:44.722 - 00:12:23.914, Speaker B: You need two things. You need the prover to be efficient, which is given by its quasilinear running time, and you need the verifier to run in time that is exponentially small in the amount of computation being done, which is what we achieve. And that's why we have a verifier on chain that runs in time that is exponentially small in the amount of computation that is being asserted. T stands for transparency, the T of Stark, which means that there's no trusted setup. It's a very important property for trust and for scaling. And another aspect which ties directly into Cairo is universality. Any computation can be proven, any program.
00:12:23.914 - 00:13:02.678, Speaker B: Its computational integrity can be proved by the same framework of ZK Stark. So now how do we get a Stark to be written for a computation that you have in mind? And there's a lot of math going into it. There's something called an algebraic intermediate representation, which is a bunch of polynomial constraints. Those of you who know a little bit about Snarks may be familiar with the term R one CS constraints. So errors are the succinct analog of that in the world of Starks. And that's how you describe the computation. You basically write a bunch of polynomials that capture it.
00:13:02.678 - 00:14:11.200, Speaker B: Now, if this sounds complicated, then indeed it is. And initially for each computation we had to write by hand a bunch of constraints that capture it. And this is very scary to do and very hard and doesn't scale very well. So Shahar and his co creators of Cairo came up with a brilliant suggestion of defining one single small set of constraints that actually defines a specific computation that is the analog of a CPU, like a chip that can run any program, and came up with a programming language in which you express things for the CPU. And that programming language is Cairo. So now the way we at Starkware build our systems is not by handcrafting a bunch of constraints, as is done in other projects for scaling and as we used to do in our earlier iterations, we now write programs in a very nice developer friendly programming language that is Cairo. And all of these programs get compiled into one air and all the algebra is abstracted away and everyone's happy.
00:14:11.200 - 00:15:09.930, Speaker B: So Summarizing Cairo is a programming language in which it is very efficient to express general computations, much like other programming languages. But Cairo is specially designed so that proving computational integrity can be done efficiently and incorporated in a blockchain. We have a full tooling that brings you from a computation run into a proof on blockchain and into consuming the facts that are proven there. Cairo, in our view, is the just right programming language for proving stuff. It is general enough, it's Turing complete, you can express any computation, but it's also efficient enough to generate proofs for it. It is production grade. We have by now three production deployments for Dy, DX, immutable with NFTs and Diversify, all of them, their code is written into Cairo, is written in Cairo, and this is the language in which StarkNet, which will be our L two roll up, is going to be written.
00:15:09.930 - 00:15:57.460, Speaker B: So my speech is done, I'll maybe answer a few questions and hand it over to Shah to actually show us the internals of how to work with Cairo. Okay, so if there are some questions I can take, like, let's say two questions. Oh, I see, there's a question from Mark B in the chat. Okay, I'll answer the two questions that are here. Now, are there any examples on how to invite Voke, a Cairo program from within the context of an existing DAP written in react JS? What is the high level flow of how it all works together end to end? Shah, maybe you can answer this.
00:16:00.230 - 00:16:48.500, Speaker C: Well, if the app is using Ethereum, then it's quite easy to use the Cairo today. Our Sharp service lets you prove any Cairo program you want and it puts some fact on Ethereum. So in your D app you can query this Global Fact Registry or Cairo, just say, oh, there is a fact, which means this Cairo program ran with this input or output and you can use it in your DApp. You specifically said via JS, I'm not sure if you're using theorem or not, if you are even it's easy.
00:16:49.590 - 00:17:34.610, Speaker B: Okay, so I'll answer the second question and that will be the last one I'll answer now and hand it over to Shaha. What is StarkNet? This is a terrific question. So, till now, Starkware, which is the company that both Shah and I work in, we had these Bespoke systems that serve customers. So we partnered with Diversify to build a scalable spot trading system for them using Cairo. We partnered with dYdX to build perpetual contracts and margin trading for them using Cairo. We partnered with Immutable X for NFTs Minting and trading at massive scale. And all of these systems are written in Cairo, integrated through the service called Sharp that Shah is going to describe in a minute.
00:17:34.610 - 00:18:52.234, Speaker B: But you have to talk to us, you have to work with us. That's the way the system is right now. But by summer we are opening an L2 Stark roll up, which will be very much Ethereum like, meaning permissionless, deployment of smart contracts, permissionless, deployment of transactions, decentralization nodes, running provers and operators and sequencers, just like so think of Ethereum, but at much higher scale. And it gets its security from L1 of Ethereum by being a roll up. But at the same time it has massively greater scale because of the scalability offered by Starks. And it also has, just like Ethereum, complete universality because smart contracts are going to be written in Cairo. So a very good reason for developers to start learning Cairo today is to start writing smart contracts that will be deployed on StarkNet, because we will port over all existing Cairo programs, in particular the Stark systems that we have deployed for our customers and any other contracts that will be written by them.
00:18:52.234 - 00:19:02.030, Speaker B: And they will be the first things populating StarkNet, which will happen by the summer. So now is the time to start learning. And with this, I will hand it over to Shahar.
00:19:03.090 - 00:19:54.240, Speaker C: Hi, there. Let me just share my screen. Okay, so I'm Shahar Hi. I'm going to show you some hands on example how to work with Cairo, from the level of the code to putting proof on Sharp and using it in the app in Ethereum. Some of the things I'll show you, if you have no previous experience with Cairo or didn't see it, then you might just have to take it for granted. I do suggest you look at these links. If this is interesting to you and you want to know more how to do it.
00:19:54.240 - 00:20:32.278, Speaker C: All these links basically will teach you how to do the entire AMM example by yourself. I will just show a small part of it and all the resources you need to know about Caro are in our website. Carol.org, a few words about the Caro language. First of all, it is designed for efficiency on top of stocks. Unlike regular CPUs where we use bits, here we use field elements. So the basic data type.
00:20:32.278 - 00:21:10.114, Speaker C: Cairo is a field element. This might mean that sometimes if you're not careful, you have weird results in your computations. I will show you how to do it safely. And also the memory is immutable, which means once you write to some variable or some memory, you cannot change it to always be this way. Cairo is young, it's developing. We are adding new features all the time, quality of life all the time. So at the beginning it was very clunky.
00:21:10.114 - 00:21:55.460, Speaker C: It's a lot better now to get a lot better, hopefully soon. Another thing in Cairo is the built ins. To make Cairo even more efficient, we use some hardware components which do some specific tasks very efficiently. This includes, for example, doing hashes and verifying signatures. We are not writing these explicitly in cargo. We're just communicating with this hardware, this built in using the memory. So we'll usually have some pointing to the memory where we can communicate with this built in.
00:21:55.460 - 00:22:39.662, Speaker C: Another built in we will use is the range of PDR. This helps us do safe math. It makes sure some field element is in the range of zero to some number is in bounded range and the output built in outputs things to the public output. Another very important building block is the dictionary. Sometimes it's easier to write things with a mutable memory, with a read write memory. So this is some construct built inside Cairo using immutable memory. That gives you some interface you can use like it was mutable memory, like a dictionary.
00:22:39.662 - 00:23:24.786, Speaker C: You can read and write things and get the new instance every time. And the last bit I want to discuss first is we have some implicit arguments. Those are things in curly braces maybe I'll touch later. But curly braces means implicit arguments. Okay, let's go to the code. So this is Cairo, specifically our example, the automatic market maker and I took the liberty of deleting the body of this function. This is the swap function.
00:23:24.786 - 00:24:17.170, Speaker C: Where the user wants to swap this amount of a token, they get exchange B tokens and this is what we will implement right now. I'll just give you a quick introduction to this code so we can start working. These are some imports we have from the standard library we have this structure represents the state, entire state of the AMM. You can see there are the balances of token A and token B. This example only has two tokens, token type A and token of type B. And these are basically the liquidity we have inside the AMM. How many free token A's and how many free token B's there are.
00:24:17.170 - 00:24:54.954, Speaker C: And the AMM will always want to keep the product of these two constant. In addition, we have this account DICT. Like I said before, we have a dictionary. This is how we use a dictionary. This is going to be sort of a mapping from the account ID to these structures accounts. Each account will hold the public key of the owner, how many A tokens he has and how many B tokens he has. Also we have this max balance which is a cap on the balances.
00:24:54.954 - 00:26:30.246, Speaker C: This is important for safe math so we don't have overflows the last bit is this function which don't have to understand but we will use it basically modifies an account. This thing clearly braces like I said is an implicit argument every past event check built in things like let's see this function which assert that some number is in range actually implicitly use this built in don't really see it because it's an implicit argument. This function takes an AMM state counter ID difference in a difference in B and it returns the new state after doing this difference. Let's make it bigger and bit bigger. Okay, so this returns the new state after applying the difference and returns the public key so we can be easier to verify that the user indeed signed on whatever we wanted to do. So now we want to implement the swap function like before it gets the range pointer as an list argument. It gets a previous state on which you want to act and it gets a swap transaction.
00:26:30.246 - 00:27:38.130, Speaker C: She's the little guy here it has the account ID that wants to swap and how many of token A does he want to swap and we need to return the use state. So let's start first things first, we want to verify that the transaction is valid. In this case you can see we have token amount the type is field element but we want to verify it is in a bounded range so we won't get overflows. We do it by the assertion this is the assert non negative and low equal. This needs to be non negative and lower equal then mass delt is enough. We don't have to explicitly verify the count ID. It will be verified when we call modify account because modify account will need a valid account ID or it will fail.
00:27:38.130 - 00:29:08.350, Speaker C: Okay, next thing is like the core of the swap function AMM want to compute how many tokens will the user get back. You want to swap this amount of tokens type in and we compute how many he gets of token B. So compute token b amount. Okay so as I mentioned before, we want to keep the product the same. So if a zero and B zero are the initial amounts in the AMM you want this to be equal user gives away a so the AMM gets plus DA tokens and it gives back this delta b tokens. We want to compute delta B. This case delta b equals I'm just doing the math really quickly don't have to follow it is equals d zero times BA over a zero plus DA.
00:29:08.350 - 00:30:18.290, Speaker C: So using the formula this starter's AMM formula this is the amount we want to give him back. So let's compute this. If we use the division operator, we actually get division in the field. So this is not what we want to do. Instead want to use this function unsigned div and remainder, which does integer division. Want to give it this expression. The initial b amount is b balance times delta a is the token amount to swap and we divided by easier plus the initial a balance plus DA.
00:30:18.290 - 00:31:01.060, Speaker C: And let's assign this to let's call it token b amount. Okay, so this was just computing this formula. Next thing we want to make sure that the token b amount is within range because we have this multiplication here, the amount can grow above max balance. We want to make sure it doesn't. Make sure token b amount is also here. I bug up any transaction. This is local, so just use token b amount.
00:31:01.060 - 00:31:59.170, Speaker C: All right? Okay, so he computed the amount he needs to get back and it's valid. So we just need to apply it. Let's start by modifying the account and let's copy the signature modify account. This is in the police document state. Start by, let's say the main document here we give it the current state. The count ID comes right from transaction. And like I said before, this function will also verify that the count ID is valid and it will also provide us back the key of the user so we can see that he indeed signed on this transaction defect.
00:31:59.170 - 00:32:39.220, Speaker C: The user wants to give his a token. He wants to get back b token. Okay? And this function turns the misstate. We bind it and the key. Now I want you to notice here that this is called in the same name as this argument we got. It's not mutable. This area in the memory still has the previous state.
00:32:39.220 - 00:33:16.510, Speaker C: But state will now point to a new area in the memory. It's just a rebind. It's equivalent to saying state zero, new state, something like this and not having the other arguments. But the memory is still immutable. If we were to try to use it in other place to the previous state, we still could. Okay, so now we modified the user account. Something we need to do here, for example, is to verify signature.
00:33:16.510 - 00:34:38.860, Speaker C: Basically we'll use an ECDSA built in using this public key and some hash on the transaction. I won't do this now, stay out of scope, but let's do it here. Okay, now we want to modify the account of the user. And I want to modify the liquidity of the AMM. The user gave his tokens and the AMM got them. So let's compute the new state, new state AMM state type and start filling it up. Just copy from the previous state dictionary of the account was modified here, but we haven't modified it since it okay.
00:34:38.860 - 00:35:34.940, Speaker C: And now want to modify the balances. So token a balance is since we deduced from the user, we want to add the AMM token A balance and the token B balance we added to the user. So we want to deduce the AMM. We are not done yet because we need to verify that these balances are in range. For example, that they are not negative negative. So the AMM still has the right amount, not too great. So do the same thing we do every time.
00:35:34.940 - 00:36:18.150, Speaker C: Verify this is within balance, within max balance, both of these. Now we will return the new state. Okay, this is basically the function. Now let's find all my syntax error. We will use the Cairo compile command. Cairo compile give it the AMM cairo file and output to AMM. Compile JS.
00:36:18.150 - 00:37:00.174, Speaker C: Let's see. Oh yeah, one error I did is here. So you get extended argument the remainder. But I don't need the remainder here's. The valid syntax equals is only for a simple command, not compound. I need to use search. This is the right command search.
00:37:00.174 - 00:37:38.130, Speaker C: This equals this. Okay, and twelve compiled. Now we want to run it. Let's see. I will run and it runs. Just want to explain what happened in the run. A lot of parts of the program that I have not shown you.
00:37:38.130 - 00:38:38.640, Speaker C: Basically, the program outputs at the end some structure that says something about what was the previous state and what is the new state. You can see we have token A before, token B before and the account root before. This root is the root of a miracle tree with all the accounts in the leaves and the develops after before and this is after. So this is the output we get here. These were balanced before, this is balanced after. Basically, this thing is a sort of effect that is true regardless of any state in any word. Just says if the previous state was this, then going to this state is valid.
00:38:38.640 - 00:39:20.460, Speaker C: This is like a timeless fact. And this is basically what we do with Shark. Let's look at Shark. I can use the COVID Sharp command to submit this program, this run actually to Sharp. What it will do to run it. Sharp will use sharp is a service. We provide software and we prove it in our provers and we publish this proof on chain on Ethereum.
00:39:20.460 - 00:40:15.372, Speaker C: Right now it's Rapstan and then every contract trapsten can query our contract and see how this fact is correct. Which is just this effect is just some catch up on the Mm output and the program hash. So if you want to communicate, let's just see an example how I can communicate with this. This is an example for how I can write an Ethereum contract to communicate with factoring in Sharp and Chiropractor. So our contract will have state to have the current account route and the current amounts. This represents everything we need to know about the AMA. It also has the program hash, the current program hash.
00:40:15.372 - 00:41:24.112, Speaker C: And this is basically the address of Sharp. Verifier stockware is verifier. So the function here looks very simple. We give it the program hash that we claim it's a valid output of our program. The function will compute this fact hash based on the current program hash and the hash of the entire program output after it calculates the hash, if you ask Sharp, Is this fact valid? And if it does, it knows that this is a valid output, which means it represents a valid state transition. Since it's valid state transition, we first verify that what program output for the previous values. Like the previous token, a amount is the current amount, the previous B amount is the previous month and the previous counterweight is the current count root.
00:41:24.112 - 00:42:20.570, Speaker C: And now we know I can safely move to this new state that the program outputted. This is exactly what it does. It's that simple. Maybe it's not simple, doesn't look like very simple right now, but it's a very small contract and the Cairo is not that big. Okay, first of all, if you have some questions, I'd like to answer them now, before we move on to the next, I want to show you how to use the AMM demo. So if you have some questions now, I'll be happy to answer. Let's see let's start from the last question.
00:42:20.570 - 00:43:36.350, Speaker C: Can you paste the Ether scan link to the transaction that resulted? Okay, this is the fact. We can look at it. This is the job key. I don't think we provide the transaction hash itself when we run the demo soon we will have but we're going to use the carousel Sharp status to see what's up with our well, it's processed means it's currently in our approvers. I can fetch it later and send you the transaction itself, but in the Mm demo we'll see it better, I think. What else? Is there a waiting period for finality similar to optimism? No. As you saw in the solidity contract, once we have this straight transition, we know we can move to the Tweet.
00:43:36.350 - 00:44:14.830, Speaker C: There's no finality because there is no way this proof is wrong. It's cryptographically correct and we can do this move to the new state. Will current Web Three wallets be able to independently verify these proofs that they need? First, no verification is done on Ethereum. Everybody can do a verification. The verify is open source. Everyone can verify this proof. We are putting it as a fact on Robson just because it's very easy to onboard this thing, very easy to use, but you can verify proof anywhere.
00:44:14.830 - 00:45:16.606, Speaker C: Where is the Car program running? Well, first of all, as you can see, I ran it locally before the Car program runs here and when we send it, we already send the result of the run of the Car program. If you are asking about proving, then yes, we are proving it on our machines software machine on AWS. Also, we have a playground if you go into our site. And there's the car playground. Just play with things, right? Run compile, send to sharp. It's all very easy UI. What else can we verify? Signatures? Yes, we can verify ECDSA signatures for our curve.
00:45:16.606 - 00:46:10.260, Speaker C: This is the ECDSA built in that they mentioned before. You can again look at the tutorials site to see how it's done. It's not complicated. If you want to verify ECDSA on some other curves, then it's going to cost you. Jamaica events from L One to L2 and Two from L One. Well, basically the interaction with L One is like I've shown here. If you, for example, want to output things from L2 to l One, then you can add here some list of, let's say, events or something like this event, which will be some list of numbers.
00:46:10.260 - 00:46:23.000, Speaker C: And then after it's outputted, you can do some for loop on these events and process them here. You can also do it in the other direction by.
00:46:25.130 - 00:46:26.360, Speaker B: Share your screen.
00:46:28.570 - 00:47:27.910, Speaker C: Share your screen, yeah, should have shared my screen. Yeah. Thanks. Yeah, like I said before, I can add in the output some list of events and then read them here, do some follow up in the contract in the program output and read them. I can also do it in reverse, which is a bit less intuitive, but I can select another member here, which is incoming events. I actually need to guess it here is not kind of get it as program input. We guess what we will get from the l One and we put it in the output.
00:47:27.910 - 00:47:56.360, Speaker C: And here we verify that these guesses were correct. Program output. We read this incoming events array and we verify that it's indeed what we sent. We can only see your terminal. We can't see your code right now, Billy. Oh, God damn it. Now we can see.
00:47:56.360 - 00:48:29.742, Speaker C: Yes, now I can see. Okay, sorry. Going badly? Yeah. These are the things I've added to the output. This is how we basically communicate between the Cairo and l One ethereum. We output things. We can output outgoing events and output the incoming events that we guessed here.
00:48:29.742 - 00:49:30.638, Speaker C: We can process the outgoing events and do something based on them. And we can verify that the incoming events are correct. There may be something that we saved in the storage in the state and to be up to the guy that uses the carrot run to give in the out input what he currently sees on ethereum. So if, for example, I want to send something, I might add a function in my contract function send to l Two. What it basically does is push something to the state, to a list in the state. Then third party will do the Carol run and say, hey, listen, in program input I'm giving you, there are incoming messages, incoming events you need to take care of. I see it because I see you can see what's going on I send it to Sharp.
00:49:30.638 - 00:50:13.458, Speaker C: Sharp puts a fact, and then I call update state with program output. I give the incoming events, then I can verify. Oh, yeah, this is indeed what I sent you. I have my storage, so I popped into the storage and this is a good fact. Okay, third party is you. Okay? It's not a third party, it's a first party or something. The guy runs the caro run, basically needs to look at Ethereum and what he needs to read from there and do the car run.
00:50:13.458 - 00:51:07.170, Speaker C: How do we know I don't answer one more question? Because I don't have time. How do we know that the input is correct? Correct in what sense? I can give any input I want and get an output in return. This is just a stateless thing. I prove, just a fact that says, hey, if I take this program and give it some input, then I can get this output. This is a valid output. The person that needs to validate this output is the contract. Like in these lines, I verify that the output indeed corresponds to something in the current state in my storage, in the contract.
00:51:07.170 - 00:51:49.598, Speaker C: I can verify other stuff. I can verify here the incoming events. I can verify here everything. When you call Kyra Money to provide the correct things from Ethereum but the verification happens on the contract after the fact is written, after everything is submitted, the Sharp finishes, then you call update state with the program output that you claim is correct and this verifies that the previous state corresponds with the l one state. Okay, I'm done. If you have more questions, you are welcome to join our discord. You can see it in our site, can email me.
00:51:49.598 - 00:51:53.380, Speaker C: I'll be happy to answer questions. Thank you very much.
00:51:54.630 - 00:52:19.640, Speaker A: Thanks so much, Shaha and Ellie, for the really great session. And, yeah, I've kept a note of answered and I will post them in the Sponsor Starquare Channel discord. And, yeah, the Starquare team will get on answering those, but, yeah, thanks everybody. Ready for joining the session and have a great day.
