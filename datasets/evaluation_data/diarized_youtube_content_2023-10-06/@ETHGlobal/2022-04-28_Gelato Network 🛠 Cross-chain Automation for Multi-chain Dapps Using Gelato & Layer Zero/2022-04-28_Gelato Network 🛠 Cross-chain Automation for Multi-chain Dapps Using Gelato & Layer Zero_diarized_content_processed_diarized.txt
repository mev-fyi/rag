00:00:25.570 - 00:03:36.880, Speaker A: The way. Yeah, right. They're all gone. Once the tool, it maybe let's wait a minute or so. Sorry, do you have a hard stop in half an hour or do we have a hard stop or is it okay, cool. All right, let's wait maybe a second or so. Maybe just to understand.
00:03:36.880 - 00:04:14.886, Speaker A: Maybe just to understand sort of like the understanding in the room. Do you guys know about gelato already? Okay, semi. Do you know about cross chain messaging? All right, if you have questions in between, just like maybe raise the hand and then I will try to answer them on the fly. If something is unclear and if I go too fast or too slow on something, just maybe let me know. Because we're a small group, we can just make it a bit more interactive. Cool. Yeah.
00:04:14.886 - 00:04:38.094, Speaker A: I think I probably can just get started and then maybe we have some other people joining in later. Yeah. Thanks everyone for coming. Who's here some familiar faces. Yeah. Today we will talk about automation, about specifically cross chain automation. And the title is like a mouthful.
00:04:38.094 - 00:05:05.034, Speaker A: But we will unpack this a bit now so you know what we will be discussing. And let me actually just put my timer here so I know if I speed too slow or too fast. Awesome. Yeah. So cross chain automation for MultiChain debts, that's a mouthful. And this is what we will be discussing. Yeah.
00:05:05.034 - 00:05:53.962, Speaker A: And I think if you are building an application over the weekend, if you especially want to build an application that requires certain processes to be automated and then if you might build this application on multiple networks, not only on one, I think this talk will be quite interesting to you. And yeah, if you have a question, just raise your hand and we'll get them answered. All right, so this is sort of like the agenda. We'll go through some definitions first, then we will go into smart contract automation. Why this is necessary, why you need that how it works. And then we actually go into code and just start seeing how we can build it maybe. Are you all developers or developers? Raise your hand please.
00:05:53.962 - 00:06:23.240, Speaker A: Just to know. Okay. All right, so we got some code here, so if you have questions regarding that, just let me know and we'll try to answer them. It shouldn't be too complex. All right, so first of all, the title is a bit of a mouthful, as I said. Right? Cross chain automation, MultiChain, whatever. And we are now sort of like unpacking it slowly and then going into certain details so you guys understand what's going on.
00:06:23.240 - 00:07:47.630, Speaker A: Yeah, so first of all, the cross chain part of this whole title, like what is it about? Right, so here you have, let's say, two different layer, one networks. You got polygon on one side and then you got ethereum on the other side. And let's say you are building an application, right? And that application has it stores a balance of your users, for example, on Polygon and a balance of your users on Ethereum. And they should sort of know about each other's balances, right? Then this is normally in the normal world not really possible because Polygon and Ethereum can't really communicate with each other directly as these sort of two different networks, right? And that's why cross chain messaging protocols exist. Cross chain messaging protocols are sort of this layer in between that allow you as an application developer, to actually let these two different applications, these two different smart contracts that are on Polygon, on Ethereum, they can be on any other EVM based compatible network as well. To communicate with each other and say, hey, here, I just received some money from a user and you should know about this. On ethereum, for example, right? And there are a bunch of different cross chain messaging protocols out there that you can use.
00:07:47.630 - 00:08:54.226, Speaker A: Some examples include nomad, for example. Then there's layer zero. I think multi chain just released theirs a couple of days ago. So there are a couple of different protocols you can use to let applications from different networks communicate with each other. That's the cross chain part. Now to the multi chain part is applications sort of like existed on each network in the past, right? So you had an application on Ethereum and then your user base in your front end was usually just configured to serve your users on this particular application on Ethereum, right? But with all these other networks coming up in the past one and a half years, we have seen that a lot of applications, for example, Uniswap or Curve or Avil as well, they deployed their applications on all these different networks, right? So because they said, hey, we've seen that there are a lot of users on, for example, Polygon or on Phantom or on Binance smart chain and we also want to serve these guys. So we basically took our application and we put them on all these different networks.
00:08:54.226 - 00:09:39.826, Speaker A: And now you have sort of like five like you have the same application five times on five different networks, right? And this is sort of like what we call MultiChain DApps. And there are generation one MultiChain DApps which are DApps that are completely isolated from each other. They're like isolated instances on Ethereum and it has nothing to do with the one in Polygon, nothing to do with the one on Phantom, right? And if you combine these multi chain with cross chain, you can actually create sort of like a system where these applications, even though they live on different networks, can all communicate with each other. So it feels more like one application rather than five different ones. Five different isolated ones that live on different networks. Yeah. And then the automation part.
00:09:39.826 - 00:10:26.740, Speaker A: So what's automation? And I will go into this in a bit more detail in this talk because this is what we at Gelato do. We enable you to automate your smart contracts on all these different networks. And yeah, there's some reasons why smart contracts, even though sometimes it is sort of like portrayed that they are these autonomous agents and they do everything themselves, are actually not that automated. And we go into that in a bit more detail. But this is sort of like the last piece of the puzzle. In order to create truly MultiChain DApps that communicate with each other, you need sort of automated processes to happen to redirect the information that enables them to communicate with each other, like every day or every couple of hours. Cool.
00:10:26.740 - 00:11:02.590, Speaker A: So now we are jumping into the topic of why smart contract automation, why you need that. And then we'll later go into some demos and some code and some examples. All right? So first of all, what is important to understand is that smart contracts are not smart. They are very dumb, actually. They are quite lazy. The only thing they do is they have certain functions, right? And these functions, they contain a certain logic. And this logic in these functions enable you to change the state of, let's say, Ethereum or this particular smart contract.
00:11:02.590 - 00:11:42.362, Speaker A: But these functions that exist there, they are not self executable. They don't just magically transfer 1000 USDC to your account. They need to be called, they need to be triggered by someone in order to actually facilitate that logic. And that's usually an EOA, which stands for externally owned account. So an account external to the system has to send a transaction, has to pay for some gas which is the unit of computation on Ethereum. And once this is done, then the logic of a certain smart contract function is actually executed. If no one sends that transaction, nothing will happen.
00:11:42.362 - 00:12:24.214, Speaker A: Even if you encode certain rules in your smart contracts, nothing will basically happen by itself. So smart contracts do not self execute. And this means that the EVM sort of the virtual machine underneath Ethereum, it does not support conditional and recurring transactions. And if you think about automation, what is automation is just stuff happening all the time in an infinite loop type of way. And this is not natively supported on EVM based networks like Ethereum. So why is that? Right? Why isn't that supported vitalik? Why didn't you do it? Good question. And there are like two ways of thinking about this.
00:12:24.214 - 00:13:45.058, Speaker A: The first one I call an endogenous EVM automation, which is basically why don't these functions just sort of like run in these for loops and just always run and then certain logic is executed whenever these conditions are met. It's because basically you have in a blockchain, you have a block and in the block only a certain number of transactions actually fit in, right? In order to counteract spam and people preventing others from actually sending transactions to these networks and getting in mind. There's a concept called a gas limit. And a block can only fit so much units of gas in it in order to make sure that still sufficient nodes in the network can actually get it and process all the transactions. And yet you don't run into a scenario where you have a very centralized network. And so if someone would be able to create these infinite loops on Ethereum and a smart contract, then no other transaction will ever get mined after it, right? So if you think about it sort of from that point of view, it makes sense that, okay, these sort of infinite loops within smart contracts, if you have these atomic transaction concepts that we have on Ethereum, then this doesn't really make sense. So another approach of trying to kind of hack automation or these infinite loops into Ethereum would be to actually build it on the client side.
00:13:45.058 - 00:14:33.390, Speaker A: So not in the core protocol, but let's say on full nodes they will have this extra module which then allows them to constantly sort of check whether certain transactions can be executed. And they check certain conditions all the time. And once they're met, then these transactions will actually get executed. However, this is very, very computational intensive if you think about it. Let's say you have like 10,000 different sort of automated tasks or jobs running which you have to check every block whether they can be executed or not, right? This is just a huge computational load on your system. And especially this is also subject to spam attacks. So someone could create like another 100,000 tasks and then these full nodes needed to check all of them at the same time and whether they get mined.
00:14:33.390 - 00:15:26.338, Speaker A: And this is just like practically infeasible because this would mean full nodes have to beef up their servers significantly, which is basically what we always try to avoid in Ethereum because this would mean only a very small number of people could actually run these full nodes. This means centralization. And then you end up with just like one giga computer running all the computation for everyone else and no one can really verify anything. So that's why having this sort of automation layer on the client itself doesn't really make sense. So you need to have it. What's the result? Here what's the learning is. You need to have an external network, an off chain external network that actually helps you automate these smart contracts by enabling you to submit these jobs to them and they check them for you away from the sort of like core protocol and then help you get these transactions mined at the right time.
00:15:26.338 - 00:16:12.370, Speaker A: Yeah, and this is basically what we do at Gelato. And there are sort of like two different parts to it that you can think of. One is sort of like the on chain part and one is the off chain part. And the onchain part is sort of like what we call our Gelato ops system. Or you can think about it as like a job scheduler and there's the smart contract and in the smart contract you can basically submit it's a standard interface and in the smart contract you can submit two types of data points. One is basically a resolver and one is a target. And what the resolver basically says is hey, these are the conditions I would like you to track to make sure that my transactions are executed at the right time.
00:16:12.370 - 00:17:16.760, Speaker A: For example, check that 24 hours have passed on Ethereum. Or check that the price on Uniswap for ETH UCC just dropped below $2,000, for example. Right, any condition you can think of you can basically define into these resolvers and then you can define a target smart contract. And this target is basically when this condition is met, then please execute the transaction at this target or on this target smart contract. And this target might be swapping on uniswap or transferring tokens or whatever action you would like to do. And you submit these two data points via this job scheduler and then an event is submitted on chain and then the gelato nodes, which are called the gelato executors which is this sort of like secondary middleware network that lies underneath ethereum, polygon, Phantom, BSc matic, so all EVM based compatible networks and we are still expanding to a lot more and then at some point also non EVM networks. We're for example working on like a StarkNet integration right now.
00:17:16.760 - 00:18:04.114, Speaker A: Then these nodes, they listen to the event of this decentral job scheduler smart contract and then they basically process information and then they will for you check every block whether your transactions can be executed or not. And if so, they will get them executed fast, cheap and reliable. Basically, this is the whole concept here. And yeah, in the middle you got sort of like a layer of redundancy which we call the JSON RPC aggregator because it's actually communicating to the network, especially on these low latency networks. These very fast blockchains like polygon or something is actually not that trivial in a pragmatic way, but I will get into that in a bit. And the benefits for developers like yourself or colleagues of yours is pretty straightforward. First of all, you don't need to host servers.
00:18:04.114 - 00:19:09.978, Speaker A: It's completely serverless, right? So you have your smart contract on Ethereum, you got your UI or your front end on IPFS. You automate your smart contracts with Gelato and then you fetch the events to display data on your front end with the graph, right? And you combine all this together and you don't as a team or as a developer have to run any sort of server and your application is completely serverless, which is always. So what Gelato offers you is we aggregate multiple RPCs which means that we run our own full nodes we work with infura Alchemy and all these sort of RPC providers to make sure you always get the right information at the right time. And when you want to actually execute certain transactions, these transactions go through even if there's a huge spike in demand for block space at that time. Right, and this often happens especially on these cheaper networks. Then gas prices suddenly go crazy and then getting transactions mined is actually very difficult. Yeah, and this basically goes into reliable transaction relaying is a very key component here.
00:19:09.978 - 00:19:54.718, Speaker A: And then there are a lot of edge cases that we sought out for you. For example, reorgs, I think we have seen crazy deep reorgs on like polygon and the likes where you think your transaction got mined but then 150 blocks afterwards you actually realize it didn't get mined because there was like a massive reorg in the network. And yeah, you have to catch these sort of edge cases and this is like what the system is optimized for. The beauty of it is that it's MultiChain. So let's say you want to deploy your application to five different networks. Now, this would mean if you build up this whole server infrastructure and automation infrastructure yourself, you would have to host it and run it on five different networks with five different RPC providers and all of that, which is a pain. And then one of the biggest reasons is that there's no single point of failure when you use something like Gelato.
00:19:54.718 - 00:20:42.502, Speaker A: Because if you build up your own system, you run your own centralized service server, then obviously, if your server goes down, then no one will call this function anymore and your DAP will start stop working. And it's not really that decentralized anymore. And then there are a whole bunch of other reasons like private key management which you don't have to do anymore in the cloud, which is another rabbit hole to go into. And that Gelato basically coordinates multiple nodes to always make sure at least one is up to get your transaction relayed, which is so this is like our ecosystem right now of projects that use us. And there are a bunch of really cool ones. One that we will go into today is Abracadabra so we will make a small case study about how they are using us. But there are also other projects that are similar, like MakerDAO, for example.
00:20:42.502 - 00:21:28.134, Speaker A: They use us to automate the depth ceiling updates on their protocol and then algorithmic stable coins for example, users to periodically rebase their token every ten minutes. And then there are funny use cases like NFTs or Avogadchis or something and you can pad them every 8 hours and you can automate this padding of your Avogadchi. With Gelato there are a bunch of funny use cases and people do really random it's completely permissionless, so you can do whatever. And people do wash trading on uniswap with Gelato and stuff like that. So some shady stuff as well. But yeah, they can use whatever they want, right, we can't really control. Yeah.
00:21:28.134 - 00:22:13.154, Speaker A: So now we go into the demo and how you actually do that. And first what I will do, I will start out with a very simple use case how you can automate a specific function. Then we go into how Abracadabra uses this to actually make a fully multi chain application that does cross chain message passing, which is quite interesting. So the first use case which we will be talking about is basically licking ice cream. And it's imagine you have an ice cream NFT, it has three scoops and you can lick it. There's a function on this NFT smart contract which is called Lick. And when you lick it, one of the ice cream scoops will disappear and it will actually disappear on chain.
00:22:13.154 - 00:22:53.406, Speaker A: So this is an NFT which has all the SVG information stored within it and so it dynamically changes the images on chain when you lick it. But there's a caveat to it, you can only lick it every five minutes because otherwise you will get brain freeze because you lick it too often, right? So you don't want to sit there for 20 minutes and press Lick. We want to automate that, right? And so this is a very simple use case that I can quickly show you. And this is sort of the smart contract right here. This is on Polygon, by the way. This is the ice cream NFT. And I think you should be able actually to plug it also in OpenSea.
00:22:53.406 - 00:23:30.266, Speaker A: And then you see it on OpenSea. We'll skip that for now and yeah, so these are like if you go to the Block Explorer, then there's this code section here, right. And you actually see the code of the smart contract you're interacting with. And let's check out the function that we want to automate here. This is the function, this is called Lick. You can pass a token ID. This is your NFT and then it will basically check whether the Lick threshold has been met or not, right? And if not, if you have licked like you licked now and then you licked a minute later, then it will actually not work because you have brain freeze.
00:23:30.266 - 00:23:59.480, Speaker A: So you can't lick it anymore. All right, so how would we actually automate it? With Gelato. So there's this application which you can just find under App Gelato network. Let me just increase the stuff here and yeah, I'm connected to the Polygon network right now. So what you can do is there's actually this tutorial thing which is a bit helpful here. So this is the address of my ice cream NFT smart contract that I showed you earlier. What I can do is I can just copy the address here, I can dump it in here.
00:23:59.480 - 00:24:42.818, Speaker A: Now it will fetch all of the Abi and all the information about the smart contract automatically from the Block Explorer. And then you can select from all the functions that are possible to automate. For example in this case the lick function and yeah so in this case our NFT is actually NFT number seven, two, three. So we will dump the token ID in here and now we can just define hey, I want to lick this smart contract every five minutes. You can define like a start date when you want to lick it but we just want to lick right now. And then you can because transaction costs money right on blockchains unfortunately. So you have to define how you want to pay with it.
00:24:42.818 - 00:25:28.660, Speaker A: And there are two options. One is just a very simple prepaid model. So we have a balance here in Gelato where you can just deposit some in this case matic on Ethereum ETH and then basically this balance gets deducted for every transaction you execute. Or there's also another option where you can have the transaction pay itself. For example, let's say the NFT would already send Ether to whoever calls that function. Then you can just select that and you don't need to pre deposit anything. So let me just here actually gives you some let me just say lick my ice cream in Amsterdam sounds a bit wrong but I'll just create cranked it up.
00:25:28.660 - 00:26:37.850, Speaker A: Yeah and then basically what will happen is the transaction will be broadcasted and then hopefully it will get mined and then once it mines the events get submitted the Gelato network will pick up all the information about the task and then it will basically start licking that ice cream. And this is now done basically now as long as there is some balance in this account this ice cream will get licked for eternity. And now you got sort of like an automated smart contract here. But this is just like for you to understand how you actually create these tasks. And now I think to the interesting part is how do you take this sort of like, very simple notion and primitive of, okay, I can automate certain functions. And how can you actually do something significantly more complex with that? Because licking ice cream is cool. But how can you actually build these cross chain automated multi chain DApps that I was talking about at the beginning? Right? And yeah, the case study is about Abercadabra Abracadabra is like a lending and borrowing protocol.
00:26:37.850 - 00:27:39.462, Speaker A: It's live on a lot of different networks and sort of like their USP at the beginning was that hey, we provide you with features that are sort of similar to MakerDAO and other lending protocols but we are very multi chain by default. So we're available on Polygon, on Avalanche, phantom and all these different networks and our protocol lives is not isolated but it lives on various systems. What they have is and I actually found out that they are using Gelato for this by accident because I was talking to the developer and then he actually showed it to me on like a video call, which was dope. And so what they do is they have a native governance token called Spell. And spell is their governance token. And what you can do is you can take that spell, you can stake it on Phantom, you can stake it on Ethereum, you can stake it on Avalanche, for example. And if you stake it, then you're eligible to receive daily MIM rewards.
00:27:39.462 - 00:28:04.680, Speaker A: And MIM is their stablecoin. MIM is like $1, like USDC, for example. And so you're a user. You're on Phantom, you're on Arbitrage, on Avalanche or whatever. And you want to stake your and your spell is basically there, okay? It's got a lot of notifications going on. Can I do not disturb. Exactly.
00:28:04.680 - 00:29:17.898, Speaker A: You stake your spell on some of these networks, and now there are, let's say, 1 million MIM rewards that are distributed every day, right? But these memory, whether you have 1 million in MIM that will be distributed on a daily basis. However, you sort of need to find out which network has how much spell staked, right? Because they think about the application as like, one application. And then it doesn't matter where you stake. You will receive your pro rada share of the total $1 million worth of worth of memory wallets that you will receive, right? So, basically, each of the Abracadabra implementations on Phantom, Avalanche, or whatever, they need to understand, okay, not only how much spell was staked on their network, but how much spell was staked in total everywhere, right? And obviously Polygon doesn't know how much spell was staked on Avalanche and vice versa. And so you need to aggregate that information somehow. And basically what they do is they have sort of like a hub and spoke model. So they have Ethereum as the sort of hub for their system.
00:29:17.898 - 00:30:08.880, Speaker A: So they have one contract on Ethereum. And then they treat all these other layer ones or L2s as spokes, sort of like as these children chains. And what they do is they want to relay the information about how much spell was staked on Avalanche or Polygon once a day back to Ethereum. So all of the different spoke chains, they sent the amount of spell that was staked on them to Ethereum once a day. And then this gets aggregated in Ethereum. And then sometime later, they need to trigger a function that basically then sends the mem rewards from Ethereum via some bridges back to all these networks. And so you every day pay out the rewards that you want to pay out in the sort of like cup and spoke model.
00:30:08.880 - 00:31:12.850, Speaker A: And to achieve that, they require two different types of gelato tasks to actually make that possible. The first one is on bespokes like Polygon or Avalanche, for example. And this is snapshot how much spell was staked and then pass this information to Ethereum. And then the second task is on Ethereum, once all the information has been aggregated trigger a function that then distributes the mem rewards back to all these spoke chains and we'll actually go into how this is done. So the first task, right, so we are now on, let's say polygon or avalanche and we need to check how much spell was staked and we need to get that information over to Ethereum. Right? How this will work on like an architectural point of view is that you have your smart contract that stores that information and contains the function that will broadcast this message on, let's say, Polygon, right? It's this Mspellreporter solve smart contract here. It has a function called Send amount.
00:31:12.850 - 00:32:03.586, Speaker A: And what this send amount does, it snapshots the amount of spell that you have on this particular smart contract and then it relays that information via a cross chain messaging protocol. In this case it's layer zero to Ethereum. And this is triggered every day at the same time, basically. And at the same time all these networks on Polygon, Avalanche, Phantom, get called by a gelato on this particular smart contract function and then relay the transaction. Let's maybe have a quick look of how this actually works or how this looks like in the the they call it and they have their repo open source, by the way, so you can check it out. Abracadabra's repository. They have this function called send amount here and there's a lot of weird like time calculation stuff in here, but this is really not the interesting point.
00:32:03.586 - 00:32:41.082, Speaker A: The interesting point is that they check the balance. They check okay, what is the spell balance of the M spell smart contract? The M spell smart contract is basically just like a staking contract. Sure. Like this bigger. Okay, sorry. So what they do is they check, okay, how much spell is staked or how much spell is in the M spell contract. The Mspell contract is literally just a contract which stores where people can stake their spell.
00:32:41.082 - 00:33:45.954, Speaker A: And then once this is sort of clear, they will encode that information in a payload which is okay, just they want to know what's the time where this snapshot was taken and then what this demand. And then what you do is you have this endpoint here and the endpoint is an Immutable variable which is sort of the address of the layer zero endpoint, which is this cross chain messaging protocol that you use. And what you do is you say, hey, I want to broadcast this payload that I just encoded here, right? I want to broadcast it to the destination chain, which in this case is chain number, chain ID one and one stands for Ethereum. I want to send that information to the spell sender, which is the contract on Ethereum that should receive that information and I want to send that payload and you have to pay this crosschain messaging protocol. So they forward a bit of, in this case matic to them and then pay for. The transaction. So basically what this smart contract lives on polygon, right? It has the send amount function.
00:33:45.954 - 00:34:49.654, Speaker A: Gelato calls the send amount function. Now the send amount function via layer zero calls this smart contract right here, which is this Mspell sender contract on mainnet, right? And there is this sort of like fallback function that they have which is the standard function that layer zero calls, which is the LZ receive function. And here what they do is hey, they first of all check, okay, is it actually layer zero's endpoint that is calling my function? If yes, okay, then we are Gucci. And then what they do is they decode this payload here that we just encoded on the other side on the other chain and then they update the state variables in here. So they update okay, this chain has 100 spell staked right now. All right, so this is the first task that is running and you can actually see that we, for example go here. The cool thing about this Gelato application is you can actually see all the tasks that have been created in real time.
00:34:49.654 - 00:35:55.766, Speaker A: So we got this leaderboard and this is like the real task created by the Dev of Abracadabra. And you see like when this executes, for example and you see he created a task and this is this actual contract that is live in production right now from Abracadabra and it's being called and this is the address and this is the function, right? And then you can actually go to each transaction and check out how it works. Yeah, so this is like the first task and then the second task is and I speeding a bit up because we already have 30 minutes. The second task is, okay, how do I then take that information about how much spell was staked on all the different networks on Ethereum and then distribute rewards. And this is actually pretty simple, basically is another Gelato task running which calls the bridge MIM function on Ethereum in the M spell sender contract. And what this does, it uses multi chain. Multi chain is a bridge that you can use to transfer tokens from network to network.
00:35:55.766 - 00:36:51.838, Speaker A: And it takes this multi chain contract and it bridges the MIM tokens on their behalf. And how this looks like for the ones who are interested is here's this Mspell sender contract, they have a router interface here from any swap or multi chain, how they call it now. And then there is this bridge MIM function. And what this bridge MIM function does, it just like some calculations how much MIM it has and then it's actually quite crazy in a for loop, it actually calls the router and just sends MIM to all the different chains that have some state stored within it. And so what happens now is you distribute all these rewards over to the network and now this process has been completed and now Gelato will just wait for 24 hours again, and then this whole process gets initiated again. And so it runs completely autonomously. They don't have to do anything.
00:36:51.838 - 00:37:23.382, Speaker A: And if Abracadabra developers will stop tomorrow, this will just continue forever as long as they have balance in this account, right? And this, of course, you can also automatically top up. So you can take a bit of your spell or MIM that you transferred and you just sell it to ETH or something. And you top it up on Gelato. And you have this sort of infinite loop running. And this is actually how, for example, Beefy does their harvesting. Quick shout out to Zerox Merlin, who's a developer of Abracadabra who I stole this concept from. Right? So he actually did it.
00:37:23.382 - 00:38:06.194, Speaker A: And yeah, I found it cool. That's why I wanted to present it, because it's like the first I think the first one I've seen that have completely automated processes across multiple networks. So pretty dope stuff, and unfortunately, we run out of time. But one quick thing, what I want to mention is with Judado, you don't necessarily only have to create tasks which are triggered based on time, like every day. You can trigger them by any sort of condition you want. It could be like, price changes, it could be interest rate changes, it could be your balance changing or whatever. And this would require you to create a resolver which is like a smart contract which returns true at a certain time that tells Gelato when to execute.
00:38:06.194 - 00:38:39.010, Speaker A: But we don't really have time to go into that. But, yeah, I think this is sort of like a good point to stop this talk. And if you have any other questions regarding specifics of what we went through or some high level stuff, feel free to ask. Thanks. Any questions, or should we just go outside and then do them privately or something? All good. Okay, cool. Then we can wrap it up.
