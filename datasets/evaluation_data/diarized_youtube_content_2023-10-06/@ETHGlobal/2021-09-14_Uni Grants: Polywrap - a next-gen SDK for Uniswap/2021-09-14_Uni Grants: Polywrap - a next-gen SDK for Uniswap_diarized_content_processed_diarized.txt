00:00:13.100 - 00:00:13.440, Speaker A: All right.
00:00:13.510 - 00:00:37.050, Speaker B: Hey, everyone. Welcome to the unigrants polywrap workshop. I'm sean on. I am from East Global. You might see me on the server as peep. So I'd really like to warmly welcome Jordan and Kevin from Unigrants. Such a pleasure to have them here, and I'll hand it to you both to take it away.
00:00:39.870 - 00:00:45.722, Speaker A: Hey, everybody, how's it going? This is Jordan, and then also Kevin's here as well.
00:00:45.856 - 00:00:46.780, Speaker C: Hey, everyone.
00:00:48.530 - 00:01:11.140, Speaker A: And yeah, we're excited to talk to you about the Uniswap polywrapper that we built for the Unigrant style. And so we'll give a quick presentation to describe what is polywrap and what is this new thing that we created. And then we'll show a quick demo and a little coding workshop where we walk through how we actually do this.
00:01:12.230 - 00:01:38.234, Speaker C: Awesome. Hey, everyone, I'm Kevin. I'm the developer relations engineer at polywrap, and Jordan is one of the original developers. We're here to show you our project polywrap. It's the next generation SDK for web three. And just a note, it's formerly known as Web Three API. So in our code, you'll notice that some of the code still uses the old terminology, it'll be changed soon, which will be changed soon.
00:01:38.272 - 00:01:38.860, Speaker A: Yeah.
00:01:40.290 - 00:02:16.570, Speaker C: So what's the bottleneck with Web Three development? Today? Most Web Three protocols maintain software development kits, or SDKs, in JavaScript, and it allows for integration. But the issue with JavaScript SDKs are that, one, they're not secure and they're not very composable. So say you want to integrate Uniswap and OpenSea and other protocol SDKs. They're all built in their different ways and it's hard to compose them. And lastly, they're not very compatible with enterprise gaming, metaverse and IoT use cases.
00:02:16.990 - 00:02:32.240, Speaker A: Yeah, and the main reason why they're incompatible with those use cases is because they're language specific. So good luck using your JavaScript in, like, a native game or a game written in a game engine, like Unity or something like that.
00:02:34.920 - 00:03:40.670, Speaker C: And so we think Web Three deserves a better integration solution. And that solution is polywrap. polywrap is a containerized protocol that brings Web Three anywhere and everywhere. So what we describe as a next generation SDK polywrap has advantages over traditional SDKs because it's more secure. We use WebAssembly inside polywrappers, which are allocated their own virtual memory. Polywrappers are hyper composable, so there will be standards for different polywrappers that you can easily use to compose them together. And since it's WebAssembly, it'll be able to run in any WebAssembly environment.
00:03:43.650 - 00:03:58.130, Speaker A: That includes back end services for enterprise or native mobile applications, or IoT devices or games. And so being able to write one SDK that is able to run everywhere.
00:04:01.030 - 00:04:42.590, Speaker C: And just a very high level overview of the polywrap experience. First, you'd wrap your protocol, meaning you'd write all your protocol business logic, like a Uniswap swap function in a language that compiles down to WebAssembly, like assembly script. Next, after you write all your protocol business logic, you would deploy your polywrapper into a decentralized hosting service like IPFS. And then third, other DApp developers can integrate your polywrapper by installing the polywrap client, which will be able to fetch all the business logic all at Runtime.
00:04:45.570 - 00:04:59.990, Speaker A: And so currently, the polywrap client that we have developed first is the JavaScript client and we'll be developing more in the future. Next up, we'll be making a native client with Rust that can work in all native platforms.
00:05:02.970 - 00:05:35.730, Speaker C: And next we're showing you our polywrap Hub, which is a UI for all the polywrappers that are deployed. It's like a marketplace where you can explore different business logic that is deployed and test them out in our playground. And here's a screenshot of the playground. You can test, query and mutation code. Here they're written in GraphQL and you can connect your wallet, write the code, click Run, and it'll give you back your results.
00:05:36.790 - 00:05:42.290, Speaker A: Yeah. And just to stress, this is reading and writing to and from protocols.
00:05:45.690 - 00:06:18.660, Speaker C: And a couple months ago, we were funded by Uni grants to do a case study for the Uni Polywrapper. And what we did in this case was we forked the Uniswap interface and we swapped out all the Uniswap JavaScript SDK and replaced it with the Polywrappers. So on the right here, you can see the advantages, but imagine being able to use Uniswap one day in Enterprise DApps like PayPal or Robinhood with polywrap. These use cases are possible.
00:06:22.070 - 00:06:29.640, Speaker A: Yeah. And right at the bottom right here, there's a URL, which I'll go ahead and show you in a little bit, but you can actually test out the demo for yourself.
00:06:31.210 - 00:06:58.750, Speaker C: And just an overview of our Dao. We have some of the top dev shops working on this project. Dior ChainSafe, consider done and more. And we also have launch partners supporting our project. So these launch partners help us review our documentation. They also get early access to products like the polywrap Hub and so on. And also at the bottom you can see our different funders.
00:07:04.500 - 00:07:41.720, Speaker A: Awesome. Thank you so much, kevin and I'd love to take you all through a quick demo. And so first, let's just start with the demo application for Uniswap. And so, like we were stating, it's at this URL demo, uniswap Polywapp IO. You can go ahead and just use it just as you would normally with the regular Uniswap interface. And so here we'll go ahead and connect our wallet. We'll say we want to swap one, let's say E for, let's say some Uni tokens.
00:07:41.720 - 00:08:44.780, Speaker A: And so what's actually happening in the background here, it happened pretty quickly, but what happened is the Polywrep client was taking these queries for instance, these queries shown over here, for example, best trade exactin, and it's executing it on this ENS Uri. And so if you want to actually see the ENS domain that the polywrapper lives at, it's right over here. It's v two, uniswap web threeAPI ETH. And on the content hash you can see that there's an IPFS hash which points to the polywrap package. And so this is the actual package that your app is downloading and running at runtime. And you can see these query and mutation WebAssembly modules. They're relatively small and that's why it was able to fetch them so quickly and execute the best trade exact in function call on the WebAssembly.
00:08:44.780 - 00:09:36.544, Speaker A: And again, just to stress, the reason why we're using WebAssembly is because it's more secure and it's also multiplatform. And so you can actually use the same code on any device and not just inside the browser. And so this is all cool and dandy, but let's actually jump into a workshop where we can show you how to use this. And so here we've created a repository. Let me just pull up this link here. It's at polywrap workshop or uniworkshop. This is the URL here and we can go ahead and just step through these readmes and they will basically walk you through creating a custom uniswap DAP and then also creating your own polywrapper which uses uniswap inside of it.
00:09:36.544 - 00:10:23.630, Speaker A: And so let's go ahead and do that. First off, if we look at this guy, it links to the presentation you just saw and then additionally it links to our website. And since this is like a little bit of a strange concept to wrap your head around, we really wanted to make the website as easy to digest as possible. So if you're still having a hard time understanding what Polywrep is and what its benefits are, really recommend just taking a look at the website and starting to read through what our different benefits are and how it all works. And so, yeah, without further ado, let's get going. So we're going to start with creating the custom uniswap DAP. And so we're going to go ahead and start here.
00:10:23.630 - 00:10:58.410, Speaker A: So here we are in this README. Then first off we have some prerequisites. I'm going to skip over just some of the more boring parts and just skip the fun parts. We're going to first go ahead and change to adapt Directory. We're going to do NVM use to use the right version of Node. We're going to install some packages and then once we do that, we're going to actually start up the application. So let's do Yarn Start and check out what this app looks like.
00:10:58.410 - 00:11:48.920, Speaker A: And so this is the app before anything has been done to it. So none of the uniswap functionality exists there. And so what we'll see is we'll just see a very simple interface here where we can insert like a text amount, we can connect our wallet and then we can select, let's say, ETH. We can maybe select Aave, let's say, but it's not showing the correct output for us and the swap button also doesn't work. And so if we go through the steps in this README, it'll actually have us hook all this up so let's go ahead and do that. And so first here we're going to be fetching the token output amounts. And so here it tells you about in uniswap there's this concept of a token pair.
00:11:48.920 - 00:13:02.930, Speaker A: We're going to be taking a token pair of two tokens and figuring out what the exchange rate is between those and then calculating what the output amount is given the input amount. And so all this sounds complex, but when it's all wrapped into a nice SDK and it's made as easy to query as polywrap makes it, it just becomes this little short code snippet here, where we simply just say, here, let's actually copy this code into our file first so we can look at it with some better syntax highlighting. Here what we do is we have this function fetch swap output amount and we have the polyrep client. And as Kevin was saying before, it's currently named Web Three API, since that was our old name. And so just kind of don't mind that. And so here we're saying client query the ENS domain, which there's a little handy tooltip here. ENS goes to, IPFS goes to WASM downloaded and run right inside your application.
00:13:02.930 - 00:13:32.520, Speaker A: And then we have a query. So this is where we actually call the function that's going to be doing our work. So this is pair output amount. We give it our token pair and our input amount and we're good to go. And so now if we go back to our application, we can see that it's already updated and it's already fetched what the output amount is. Pretty cool. And so let's go ahead and expand upon this functionality.
00:13:32.520 - 00:14:08.870, Speaker A: And so next up we're going to allow uniswap to swap our ERC twenty S. And so we need to give it an ERC 20 token approval to be able to move our tokens around for us. And so here, as you guessed it, it just comes down to another query. We have a query to the Ethereum polywrapper and we're saying call Contract View allowance. So we're basically figuring out if we need to grant approval. So this is approval needed. And so let's go ahead and copy this in.
00:14:08.870 - 00:15:00.920, Speaker A: And first off, before we do that, let's check out Dai, because I know for a fact I haven't given Dai approval, so it's still saying swap, so that's not correct. So let's go ahead and go into this approval needed file. Paste in the code again, just to walk through what's happening here. We call this view function allowance. So we get the allowance, we then get the result down here, which is our allowance. We use this decimal library to parse the large numbers and then we just do allowance greater than spending. So it's saying that if the allowance in the contract is greater than what the user wants to spend, then we already gave it approval.
00:15:00.920 - 00:15:37.648, Speaker A: And so here if we look now at our application, it says approve. And so if we go to something that's already approved, let's say, let's say uniswap, it just says swap. And then again if we go back to Dai, it says Approve. And if we click this button, nothing is happening yet. And so that's the next part. We'll actually implement the approval logic. And so now that we've figured out if approval is needed, we can actually approve the token.
00:15:37.648 - 00:16:19.570, Speaker A: So here we're sending now a query to the ENS Uri of our uniswap wrapper and we're calling the Approve function. And so if we go here, go ahead and paste this in, inside of this Approve function, it's going to actually send out an Ethereum transaction. And so let's actually see that in the works. So here, go ahead and click Approve. Sometimes my wallet integration is spotty. So if you want to fix up the wallet integration, please feel free. But if you just basically disconnect and reconnect, it should fix it.
00:16:19.570 - 00:16:47.610, Speaker A: And then here it's going to ask us for an approval. Cool. So that's working. We're going to reject that because we don't want to wait for that right now. All right, so then next up, now that we've finished up the approval process, let's actually implement the swap. And so here, as you can see, it's a little bit more code, but let's check it out. Let's see what it's doing.
00:16:47.610 - 00:17:24.000, Speaker A: May look a little scary, but let's see what it's actually doing here. Inside of the swap token pair function, right here we have our inputs and then we pass them along to the polyrep client and we say client query. And we call this swap function. And so the swap function, it's pretty straightforward. It just takes in token in, token out, and amount and how you want that amount to be treated. So we want this to be an input amount. So we say exact input.
00:17:24.000 - 00:18:05.392, Speaker A: You could also say exact output if you wanted this amount to be the amount you get back from the trade. And so here we go ahead and we call the swap function. And inside of the uniswap polywrapper, it's going to be calling Ethereum and executing that transaction. So let's check that out. Let's switch over to ETH. Let's say let's do like let's actually purchase some uniswap and we're going to do this on main net and let's see what happens. Let's go ahead and oh wow, okay, that's all right.
00:18:05.392 - 00:18:34.780, Speaker A: You know what, it's for the cost. And so now we've submitted our transaction. There's no notification set up or anything like that in the official fork. There is, it's all clean and nice, but this was just like a really scrappy lightweight demo. And so here, if we check out the transaction that just got sent out, we should be able to find an Ether scan. And there it is. Oh, sweet, good timing.
00:18:34.780 - 00:19:04.390, Speaker A: So we got some uni. That's cool. So we now have a fully functioning uniswap app. It just kind of took a little bit of copy and pasting because it was all kind of set up for us. But all of the actual integration with Uniswap was pretty straightforward. It was just a few calls using the polywrap client. And so to recap, as we just seen, integrating Web Three protocols into your applications has never been so easy.
00:19:04.390 - 00:19:27.992, Speaker A: The idea here is that we're trying to make it as easy as Web Two. So in the same way as Web Two, where you can send, let's say, a query to Twitter's API or to Stripe's API. We want to make that same experience in Web Three, and we want to support right operations as well, but without sacrificing decentralization because we don't want to trust a central server.
00:19:28.136 - 00:19:29.724, Speaker D: And we also don't want to pay.
00:19:29.762 - 00:20:17.180, Speaker A: For an expensive network to do the work for us. So how do we solve this? Well, we download WebAssembly and we run it inside of our application. That's the idea. Yeah. So there's a few links here and without spending too much more time, the one last thing I wanted to say is that this link here actually brings you to the code of the Uniswap demo. And so if you wanted to see like a fully working fork of the Uniswap interface using polywrap, you can check this repo out here. So what's up next? What's up next? So we did the application and so now let's go ahead and do the polywrapper.
00:20:17.180 - 00:21:05.820, Speaker A: So here we will create our own polywrap that is using Uniswap inside of it. So again, we just have some prerequisites skip over the boring stuff. Yada, yada. Let's go ahead and let's change into the wrapper folder NVM use install dependencies. And then what we're going to do first is we're going to write our schemas. So over on the left hand side here, if you look at the folder structure, polywrappers all have a pretty similar folder structure. They have a manifest file which just defines the structure of the package.
00:21:05.820 - 00:21:36.788, Speaker A: And then they have their actual source files, which here we have it separated into mutation and query. And so query, we're going to start with this. These are our reading operations. If we look inside of the schema, so the schema is empty and we're going to fill this out. And this schema acts as our public interface to our polywrapper. And so let's quickly look at what's happening here.
00:21:36.954 - 00:21:45.384, Speaker D: In this first line we have some magic happening. We're actually importing types and queries from.
00:21:45.582 - 00:21:50.600, Speaker A: The Uniswap polywrapper that's living on ENS and IPFS.
00:21:51.260 - 00:21:54.380, Speaker D: And this little into here is a namespace.
00:21:54.800 - 00:22:07.330, Speaker A: And so this query type, for instance, so this query type here will be showing up in your schema like this uni underscore query, that's what it'll be showing up as.
00:22:09.220 - 00:22:41.176, Speaker D: And now that we have these imported, we want to wrap them in some meaningful way. And so what we want to do is we want to make a helper function called fetch Token Total Supply. And this is just a wrapper function where you can give it a chain ID and an address. These are the only two required properties because as you see, they have an exclamation point. And in GraphQL this means that they are required. Then if you have these two, then.
00:22:41.198 - 00:23:04.320, Speaker A: We can go ahead and fetch the token and fetch its total supply. And so let's look at what the implementation looks like. And so down here for the query implementation, let's go ahead and copy this over and check this out. It's a pretty simple function. This is actually assembly script. So this looks like TypeScript, but it's assembly script and it's going to compile into WebAssembly.
00:23:04.660 - 00:23:10.164, Speaker D: And here, as you see, we are importing the uni underscore query type and.
00:23:10.202 - 00:23:14.390, Speaker A: We'Re calling functions on it. And so these are.
00:23:16.440 - 00:23:18.036, Speaker D: GraphQL functions on.
00:23:18.058 - 00:23:52.960, Speaker A: The uniswap interface and we're just calling them as if they were functions, but behind the scenes. So behind the scenes it's actually going to do a client query just like we were doing in our app. And it's going to give it the ENSV two uniswap web, three API e. It's going to give it the ENS domain and it's going to also give it the query. Yeah. So that's kind of like the first little bit of magic. Your polywrapper is querying another polywrapper.
00:23:52.960 - 00:24:33.790, Speaker A: And then lastly, we'll go ahead and we will do the mutation really quickly here because we're running out of some time. And so let's check out this schema file here. For the mutation schema, we're creating another kind of helpful wrapper, which is simple, a swap. And then we have an output type which is swap output. And so this is kind of showing that you can define custom types. And then inside of our assembly script, we're going to go ahead and implement that simple swap function. And so here we'll go ahead and paste this in.
00:24:33.790 - 00:25:06.760, Speaker A: And first thing we do is we fetch the token data. We fetch the token data of the output token and the input token and then we perform a swap on both of those. Yeah. And so now that we've done all this, we have our code implemented. Let's actually build it and test it. And so we're going to skip this part because we're building it in this step here. So in order to test our polywrappers, we actually made something that makes it very easy.
00:25:06.760 - 00:25:26.130, Speaker A: We made these things called query recipes. And so a query recipe is let me just get our test environment set up. We are in test environment up. Our query recipe is it's just a JSON file. It's just very simple.
00:25:26.820 - 00:25:58.680, Speaker D: And what this does is you give this query recipe to the polyrep CLI and you tell the CLI, hey, execute this recipe script. And so the first step in the script is to connect to the API, connect to the wrapper at this domain. And so it's testnet because we deployed this wrapper to our testnet that's running that we stood up in this step using Docker.
00:25:59.100 - 00:26:00.328, Speaker A: You can actually see it in the.
00:26:00.334 - 00:26:10.664, Speaker D: Background here, client test environment. And then we connect to our testnet polywrapper and we're going to send this query. So fetch.
00:26:10.712 - 00:26:11.064, Speaker A: Token.
00:26:11.112 - 00:26:23.600, Speaker D: Total supply. And so here we have a query fetch token, Total Supply. And this is the function that we developed just a few seconds ago in our query module.
00:26:25.140 - 00:26:26.748, Speaker A: And so, as you can see, we're.
00:26:26.764 - 00:26:29.012, Speaker D: Filling it out with these variables with this address.
00:26:29.146 - 00:26:39.190, Speaker A: And I'm not going to spoil the surprise of what this token actually is. Let's actually see what this function returns if we run yarn test.
00:26:39.880 - 00:27:07.280, Speaker D: As you can see it's doing W three query recipe end to end. JSON let me make this a little bigger. And then the first step is it sends this query. So query fetch token, Total Supply, gives it an address and then down here with the result, it gives you the full token with its total supply. And so here you can see that it is the uniswap token.
00:27:09.540 - 00:27:12.544, Speaker A: And the cool thing about this is.
00:27:12.582 - 00:28:10.630, Speaker D: That our command line tool did not know anything about uniswap, it did not know anything about our polywrapper that we developed when it was created. But on demand, it's able to load up our SDK, it's able to run it and then it's able to be able to perform these sub queries. This composable nature of bringing in more and more different polywrappers just kind of showing you how on demand and composable this can really make web three development. And so, yeah, that is the end of that short demo. The last thing I want to just quickly show is that if you look inside of your build folder, you can see the same files that were uploaded to IPFS. And so, yeah, there's nothing special. You just stick these files on decentralized storage and your polyurep client can query them.
00:28:10.630 - 00:28:24.010, Speaker D: And so I think I'm going to stop screen sharing now, or stop talking. At least that's my timer. And if there's any questions, we would love to answer them.
00:28:26.380 - 00:28:26.792, Speaker A: Awesome.
00:28:26.846 - 00:28:53.400, Speaker B: Thank you so much for that demo. We would of course love if everyone were to just type their questions in the chat. And I strongly, highly recommend everyone to just check out that GitHub repo link is right now in the chat. So, yeah, definitely check this out. Build with it, play around with it, learn about it, all that jazz. Any questions?
00:28:58.930 - 00:29:18.120, Speaker A: And then also, just to recap, I'll pull up just like the list of benefits of why using a polyp SDK as opposed to, let's say, a JavaScript SDK is better. And so if any of these don't make sense or you'd like more information on them, just feel free to speak up.
00:29:19.610 - 00:29:28.700, Speaker B: Sounds great. And for all of you Rust fans out there, or those of you who want to develop more using Rust. Do you have Rust support coming in very soon?
00:29:33.150 - 00:29:36.362, Speaker A: Yeah, definitely. And two types of Rust support.
00:29:36.496 - 00:29:47.674, Speaker D: The first type will be being able to develop your polywrappers in Rust and then additionally being able to have a Rust polywrap client.
00:29:47.802 - 00:30:01.682, Speaker A: So being able to actually execute polywrappers inside of native applications. And so this will give way to any sort of language that supports native binding. So think of not just Rust, but.
00:30:01.736 - 00:30:05.720, Speaker D: Go and C Sharp and all the other languages out there.
00:30:08.250 - 00:30:44.590, Speaker B: Sounds great. And once again, if anyone has any additional questions after this workshop, you can always hop into the ETH Global channel right underneath the Uni Grants sponsored channel. You can definitely feel free to ask any questions and there are definitely a lot of people who will be willing to help. All right. And at that, I just want to thank everyone for coming. Feel free, once again, ask any questions if you'd like. And thanks as well to Jordan and Kevin for the amazing presentation.
00:30:46.530 - 00:30:48.590, Speaker C: Yeah, thanks so much for having us.
00:30:48.740 - 00:30:49.740, Speaker A: Yeah, thank you. Thank you.
