00:00:00.170 - 00:00:20.750, Speaker A: Next up, we have Kelvin from the Optimism team and he's going to be talking about how optimism is going to help scale Ethereum. We've seen a handful of talks on scaling today and this is going to be another fantastic one in the series. So Kelvin is here with us on this chat, so I'll let him introduce himself and kick off with his presentation. So welcome, Kelvin.
00:00:23.330 - 00:00:44.586, Speaker B: All right. Hello. Hello. Super excited to be doing this. My name is Kelvin. I work for Optimism and I do a lot of random stuff, working on this extremely cool project. So I'm very excited to be able to talk to you about this.
00:00:44.586 - 00:01:14.482, Speaker B: And it's kind of going to be a fun presentation. It's not going to be too heavy, not going to be too light. So I hope that everyone gets something out of this and let's talk about the very cool things that are happening in the scaling space right now. All right, so I need to share my screen. Let's get that going. All right. And there we go.
00:01:14.482 - 00:01:37.260, Speaker B: I believe we're good to go. Good to go. All right, Optimism? Keeping ethereum half full. All right, here we go. All right. So kind of the first thing that we need to understand is why exactly we are even talking about this right now. So, in a nutshell, this is how Ethereum works.
00:01:37.260 - 00:02:30.022, Speaker B: You kind of tell Ethereum what you want to do, whatever these people are saying, and Ethereum is like this little family business. Ethereum, here's your little transaction, and then it processes your transaction and gives you a result, right? This is the basic flow of Ethereum. And this is kind of a way to look at how this execution really works. Sort of a very simplified version of this execution. And the important thing here, you don't really have to understand much about this diagram right now, but the key things are what Ethereum really does is it's storing your transaction data and results and it's also doing the actual transaction execution. And that means running smart contract code. And the thing is that data storage is pretty cheap.
00:02:30.022 - 00:03:16.822, Speaker B: Like, hard drives are pretty cheap, but execution on Ethereum is quite expensive. And a majority of the cost on Ethereum right now comes from the fact that we have all of these new smart contracts that are quite complicated and transactions burn gas like crazy. So this is sort of an updated picture of Ethereum today. And we kind of just shout loudly and hope for the best. We've got this person with very long legs and one arm saying we uniswap. We've got a large baby screaming for more yams. We have this gold medalist with gold legs and lambos for feet asking us if we've ever heard of bitcoin.
00:03:16.822 - 00:04:02.826, Speaker B: And this is sort of what happens to Ethereum in the face of that. So you see, Ethereum is completely swamped and everyone's really sad because there's so many transactions to process. So how do we solve this dilemma? Well, there is sort of a clear idea, which is child labor, child chain labor. In this case specifically, we don't consume child labor. But you can see we go to the next generation, we offload some of our work to the other people that we have sitting around. In this case, offloading that work means doing the computation somewhere else on optimus. So here is the optimistic execution model.
00:04:02.826 - 00:05:17.198, Speaker B: And again, all you really have to understand in this slide is the transaction data still gets stored on Ethereum, but we stick the transaction on Ethereum and then we read it and we say, okay, what does this transaction want to do? And then we kind of run it in sort of another version of Ethereum, this layer two version of Ethereum. And that's where the execution happens. And then we publish the result back onto Ethereum. And because this execution is not happening on Ethereum anymore, and we don't have to have all of the Ethereum nodes doing this execution, right, so we do the computation outside, then the fee for this transaction is just going to go way, way down because we don't have thousands and thousands of nodes executing these contracts. And instead we just do it on layer two. You've got all the kids doing all the work, the child chain doing all the work here. And the fundamental problem that arises here, sort of this looks very simple in theory, but the fundamental problem is this advent of fraud.
00:05:17.198 - 00:06:05.442, Speaker B: Right? So what exactly is fraud? Well, we have these contracts that are storing the transaction data and then layer two gets the transaction and executes the transaction. Executes the transaction and then we get this result that gets published on Ethereum. But Ethereum didn't actually run this transaction. So how does Ethereum know about what happened? Ethereum doesn't know whether the result that was published is actually valid. And so on layer two, the people who are publishing these results can pretty much claim anything, any possible result. And layer one has no clue. They kind of just have to accept it.
00:06:05.442 - 00:06:52.960, Speaker B: Ethereum kind of just has to accept this result because it hasn't done this work for itself. So in this case, everything is now candy. So what are the solutions to this general problem? Well, you basically have two options here. You either have Moon Math or not Moon Math, which is just making Ethereum do the transaction again. So fundamentally, what you are trying to achieve in one of these two solutions is make Ethereum know what the correct result was. And so Moon Math is essentially proving to Ethereum that your result is correct. And the not Moon Math way of doing it is making Ethereum just run the transaction again.
00:06:52.960 - 00:07:36.462, Speaker B: And these each have their various trade offs. But I'm going to take a look at Moon Math route first, and then we'll talk about sort of the path that we've taken in tackling this problem. So option number one, moon Mass, right? You get this kid to do it and I didn't need to even Photoshop the glasses on this kid. So you just know that they know what they're doing. And essentially what you're trying to say is this result cannot possibly be invalid. So you provide a transaction result to Ethereum and you give some proof that it can't possibly be invalid. And obviously you want Ethereum says prove it.
00:07:36.462 - 00:08:42.978, Speaker B: And you provide this sort of complex mathematical structure that convinces you on layer one that this result was correct. The trade off space with this sort of approach is that it's quite confusing to a lot of people. It's quite difficult to understand, it's not necessarily developer friendly and it also limits you in sort of the design space of how you can build your applications. You typically cannot just build a solidity smart contract and deploy it to a system like this because these proof models sort of need to be sorry. You need to build your applications in a way that you can then go and prove that the result of executing your application was X or Y, whatever. And oftentimes you have to adapt your application to the proof system rather than the proof system just working for any arbitrary application. And especially today, I think that this space will definitely grow in the future.
00:08:42.978 - 00:09:38.538, Speaker B: But right now it's sort of quite early and quite difficult to use. So what is option two? Well, let's just briefly bring back up our old diagram here. We have this stuff on Ethereum that I called the roll up contracts and that's what we want to take a look at. So what actually are these roll up contracts? Because I kind of lied, it's not this simple. Essentially there are three contracts or three sort of main areas of these contracts. And the first two of these, the sort of canonical transaction chain and the state commitment chain are pretty straightforward. So the canonical transaction chain is just where the transactions go when people put them on Ethereum, right? So kind of think of like your mem pool or something like that, where this is an append only lock.
00:09:38.538 - 00:10:31.282, Speaker B: You put transactions in there, they stay there forever, they can't be deleted or anything. And this is what the layer two nodes then read from in order to know the ordering to execute transactions on layer two. Then the state commitment chain, also pretty straightforward, is also an append only log. Except that so this is where the transaction results go. After you've executed after the layer two nodes have executed the transaction, the transaction results get posted to this state commitment chain. And this is sort of read only or sorry, read only a pen only log. But there is a case in which this log can be this state commitment chain can be deleted and that is as a result of something in this fraud verification contract.
00:10:31.282 - 00:11:11.218, Speaker B: And that's exactly what we want. We want a system where somehow we can say you cheated and therefore the result that was published is not invalid or sorry, it's not valid anymore, and we need to delete it and somebody else can publish a different correct result instead. So this is the general flow. I think you cheated, right? And then I say to the fraud verification, I messed these slides up. This should say they didn't cheat. Whoops. My animations are quite rushed today.
00:11:11.218 - 00:12:02.670, Speaker B: But point being, if the fraud verification contracts recognize that you did not cheat, it won't do anything. It won't touch the state commitment chain. But if the fraud verification contracts say, okay, wait a minute. The result that we found when we executed this transaction again on layer one was different than the result that was posted or supposedly executed on layer two. So that result was fraudulent. We need to go in and we need to remove that result from the sort of list not canonical, because we can delete it, but this list of results. And then we have a timeout window that says you must prove that something is fraudulent within a certain amount of time from when the result was published.
00:12:02.670 - 00:12:55.140, Speaker B: And we assume that if you don't try to go through this fraud process after that amount of time, then you just figured it was valid and not fraudulent. And after that, it can no longer be deleted. So this is great because this is why we kind of call it an optimistic system. In the ideal case that people are just sort of motivated by profit or whatever, they won't try to cheat. And if they do try to cheat, then we can challenge them. But if they don't try to cheat, we don't have to bother challenging them, right? Because it's only necessary in the case that there is actually fraud. So when people are submitting valid transaction results, it's much, much cheaper because none of these transactions actually have to be executed on Ethereum itself.
00:12:55.140 - 00:14:02.026, Speaker B: So now the really fundamental question is how do you make this work? This is all sort of straightforward in theory, getting Ethereum to just do it for you. But how do we actually do that? And the meme answer is this or this, which is basically that we go over the whole transaction together on layer one through sorry, whoops messed up that slide? Whatever. Okay? Yes. The fundamental problem with any of these sort of systems essentially can be described like this. There's a smart contract and it makes decisions based on something like the current Ethereum time. And Ethereum says the current timestamp of the current block is this. And timestamps are just one example.
00:14:02.026 - 00:14:53.462, Speaker B: But there are a lot of things where the result of these sorts of opcodes stuff like timestamp is going to be fundamentally different between layer one and layer two. So the current time on layer one or the current time on Ethereum is going to be different from the current time on layer two. And if we execute this transaction in a different block on layer one, the current time will be different. So all of a sudden, this transaction is no longer deterministic. And if we run this transaction on layer one, odds are it will come up with a different result than what we got on layer two. But not because we did anything wrong, just because it uses an opcode, a stateful opcode, because it uses a stateful opcode. And this adds a sense of nondeterminism.
00:14:53.462 - 00:15:43.560, Speaker B: And so we need to fix this, right? Essentially, we need to figure out what are the things that contracts can access that are dangerous to us? And the answer is storage. Contract storage, other contracts and information about Ethereum, like the block number. And if they are able to arbitrarily access this information, then they could interact with a contract that doesn't exist on layer one when we're doing the verification step or so, it doesn't exist on layer two when we're doing the verification step on layer one. And that would cause this nondeterministic behavior. So what are the opcodes that we don't really care about? The safe opcodes that we don't have to worry about? Basically the pure opcodes. So add, subtract, push, pop the stack opcodes, M Load, S store. These things don't have anything to do with modifying the state.
00:15:43.560 - 00:16:48.346, Speaker B: But what are the tricky opcodes? So we have sort of the Ethereum state opcodes like timestamp the number, S Load and S store for accessing, contract, storage, call, create, and all of their various different forms. So all of these opcodes give us issues. And if we just allowed contracts to arbitrarily use these opcodes, we could essentially never guarantee a deterministic execution of the L2 transaction on L One when we're verifying it. So how do we block them? Well, we need to block them because we can't allow people to use them. So we have this thing called the Safety Checker. And the Safety Checker is literally a smart contract that statically analyzes contract bytecode and it says, oh, I see that you include an S load, I'm not going to allow you to deploy this contract. This contract is not allowed to exist on layer two because you use one of these banned opcodes.
00:16:48.346 - 00:17:37.866, Speaker B: But if you're a good contract and you decide not to use any of these banned opcodes, then you're totally fine. You can deploy on layer two, because that means that when we go back and execute it on layer one, there's no chance that you will use one of these sort of opcodes. That give us a headache. But obviously, these opcodes, especially things like S load, S store and call are extremely useful and we can't live without them. So how do we actually get around this problem? How do we make sure that people still have access to these opcodes? Even if we need to ban them. And the answer is that we get around it by taking all these opcodes and we replace them. We replace them with our own sort of custom opcodes.
00:17:37.866 - 00:18:46.498, Speaker B: And these are implemented as calls to a special contract called the Execution Manager that sort of handles all of the logic for these opcodes. And it ensures that these opcodes will always behave deterministically based on sort of some setup phase. When you create the initial, when you want to run this fraud verification step. And in order to sort of translate from Solidity code to these special opcodes, these calls to this special contract that handle these opcodes for you, we have a custom compiler, a custom version of the Solidity compiler that will, instead of allowing you to use these opcodes, just immediately translate them into calls. So this is the general flow of the Execution Manager here. If we just had the Execution Manager with no context and a contract wanted to know what the current time is, well, if the Execution Manager hasn't been set up properly, then it doesn't know what time it is. And then all of a sudden it doesn't have any clue of what to do.
00:18:46.498 - 00:19:47.830, Speaker B: So really what we need is the two step thing where we have these two contracts called the Execution Manager and the State Manager. And the way this works is that users populate the State Manager with what the state was on layer two before this transaction that they wanted, that they want to sort of verify on layer one. And they say this is exactly what the state was. These are what the contracts are. It's not all of the state, it's only the state that's relevant to this particular transaction. And you load that into this thing called the State Manager. And then when you actually execute this transaction, during this fraud verification process, when these contracts, for instance, ask for what the current timestamp is, the Execution Manager will then go into the State Manager and say, okay, hey, what time is it right now? And it will access that state and return it back to the other contract.
00:19:47.830 - 00:21:17.126, Speaker B: So that's sort of the nice ideal case of a very simple interaction. But let's say that a contract we're trying to interact with a contract that has not been set up on layer one. So a contract that the user who is trying to prove fraud has not sort of initialized set up, made it ready to be used during this fraud verification process, then what would happen is that in order to actually, let's say, do a call to this other contract, the contract would request this call from the execution manager. The Execution manager would ask the State Manager, do I know about this account? Has this account been set up? Does this contract have the ability to access this other account? And in this case, if the answer is no, then all of a sudden everything has to immediately stop. And this is really important because everything has to immediately stop so that the contract cannot make decisions about the presence or absence of information during this fraud verification process. Because on layer two, all of this state is always available. So if it can somehow recognize that, oh, hold up, some of this state is not available to me.
00:21:17.126 - 00:22:17.110, Speaker B: It can make decisions based on whether it's running on layer two or layer one. So we have a lot of very interesting, very interesting problems to sort of face here, where the Execution manager has to figure out how to immediately halt the entire execution. But it can't just revert because that opcode is a call. And if it reverts, then that revert can be caught by the contract that called it. So what we end up having to do is make sure that the contract that called it also reverts if the Execution manager reverts in this way. So there's this really fascinating aspect of having to sort of hijack reverts and figure out how do we carry all these things up, because we can't allow execution to continue. And this is all sort of reflected in our contracts right now.
00:22:17.110 - 00:23:03.190, Speaker B: But it's an extremely interesting problem. It's somewhat non trivial and all these sort of things that you would think are quite easy. Running EVM code on Ethereum are actually quite difficult when you're trying to prevent access to state that contracts should not have access to. Of course, everything errors out. All right, last little technical bit. Because we'll do this, one important thing that we all would need is being able to send information between layer one and layer two so that we can, for instance, transfer ERC 20s from Ethereum onto this optimistic roll up system. So doing that from a layer one to a layer two is quite easy.
00:23:03.190 - 00:23:53.718, Speaker B: You kind of just tell Ethereum what you want to say. Ethereum puts it in the layer two chain as a transaction and it's just there and you can access it on layer two. That direction is quite simple. It's basically just sending a layer two transaction. The other direction is a little more difficult. The other direction, you say something, you have a message that you want to say on layer two, like transfer some number of USC 20s or just hi whatever it is, and you sort of acknowledge that you put that in the chain on layer two. But what gets posted to layer one is not the full state of layer two because then what's the point? You post the state root of layer two on layer one.
00:23:53.718 - 00:24:50.102, Speaker B: So someone actually needs to come in and say, okay, there is a message on layer two, and I can prove to you that this message exists on layer two, so please relay it to a contract on layer one. So you say, okay, I believe that there's this message. Ethereum tells you to prove it. You give a merkel tree proof that this message was actually included on the layer two chain. It says, okay, have we waited long enough that we're sure that it's not fraudulent? And then as long as that proof checks out, we send that message off to a contract on layer one and everyone's happy. And to finish this off, other really cool stuff, we can do custom op. Did we have a native account abstraction? So the EOA account or externally owned accounts don't exist anymore.
00:24:50.102 - 00:25:28.674, Speaker B: We can do any EIPS that we want, whenever we want and we have lots of plans to do that. We have geo hot commits and it is extremely cool. Just trust me, look at the repo and you will be very excited. So what is the status? Well, the contracts are being audited right now. You can see the latest contracts in the contracts between your repo. We have a testnet up and running and we're doing a lot of testing. We are hitting those integrations because we got to make sure that everything works beautifully and we're hiring.
00:25:28.674 - 00:25:48.060, Speaker B: So if you are a compassionate person who loves public goods and you know how to use Ms Paint for presentations, then please come talk to us because we are absolutely hiring and absolutely looking to do more cool stuff with cool people.
00:25:53.170 - 00:26:54.682, Speaker A: Great. Well, Kevin, thank you so much for that amazing talk and the lovely visuals. There's a lot of people for the hackathon that are working on integrating layer two solutions. So we'll be sure to recommend them to try out optimism and give you feedback directly. We are at time, but what I will do is I'll just kind of ask a couple of smaller questions that maybe you can just clarify for the audience and if more questions come up on our chat and if you have time, you can just join the live Eigth online page to answer them and chat directly. So you kind of talked about how the Execution Manager works and the opcodes that are at least detected and prevented in some capacity two branches to that scenario. The first one being what actually isn't possible if you are trying to deploy to OVM in terms of what you can do on main net but you can't do on OVM.
00:26:54.682 - 00:27:11.430, Speaker A: And then the second one being just kind of as developers think more about supporting layer twos and optimism, what's kind of like a blocker for them or what should they think about differently or what do they have to do very differently than what they're used to that they should keep in mind as they consider optimism?
00:27:13.290 - 00:27:43.614, Speaker B: Yeah. Cool. Good questions. Well, pretty much anything you can do on layer one, you can do on optimism as well. I can't off the top of my head think of anything you can't do. You can write your contracts in Solidity. You can basically take the contracts you have right now and just use our custom compiler and deploy it as is and you can actually do more because we have these sort of custom opcodes and things like that that we can always add quite easily, much more easily than we could on layer one.
00:27:43.614 - 00:28:45.070, Speaker B: So we're going to do a lot of experimentation with potential EIPS that we want to try to implement potential new opcodes. So in a lot of ways it's sort of an expansion on what's possible on layer one and the sort of biggest shift from an application design standpoint since you can just run the same solidity code, that doesn't really change. The biggest shift sort of comes in the message passing, where if you want to have applications where part of it runs on Ethereum and part of it runs on this optimistic roll up system, they need to talk to one another. And we have contracts that sort of abstract that for you and let you really easily do that. But you kind of need to understand what's happening to some extent that there's a delay here between it doesn't immediately go to the contracts on layer one or layer two and you have to wait a little bit before those transactions go through. But really, other than that you can kind of treat it just like you would treat your contracts on Ethereum.
00:28:46.170 - 00:29:04.100, Speaker A: Awesome. That sounds like a pretty good sell because you can just directly support scalability in your project. So excited for the testnet to get a lot more usage and bugs cleared out so that it can become a reality. And want to thank you again, Calvin, for doing this awesome talk and we'll see.
