00:00:09.180 - 00:01:11.504, Speaker A: All right, can we start? Yeah. Okay. Hi, so my name is Joavais. I'm from the Ethereum Foundation and I wanted to talk today about account obstruction and ERC four three, seven. So first, what is account obstruction? Account obstruction means that instead of using an externally owned account, which means an account that's directly associated with a private key, you're using a contract wallet. And this contract wallet can be controlled by a key or multiple keys, but it could also be controlled by an arbitrarily complex mechanism that is encoded in the contract. So this enables use cases such as social recovery, which means that if you lose your keys, you lose access to your wallet.
00:01:11.504 - 00:02:07.732, Speaker A: Your friends can sign a special message with their keys to help you recover it. Or you could use complex access controls such as multisig in the context of your wallet. It also allows you to switch even to different signature schemes such as moving to BLS or the quantum resistant signatures in the future, which is quite useful for Ethereum. And it allows you to do things such as batching multiple operations. So, for example, let's say you want to trade an ERC 20 on uniswap. When trading, you don't need to approve and then to do a transfer from you can bundle both of them together in one core. Account obstruction can be quite useful.
00:02:07.732 - 00:03:09.660, Speaker A: It can also do things like gas abstraction. So gas abstraction means that a decentralized application can pay for its user's gas it can sponsor so that the user can be onboarded without buying ETH. This can be useful in various scenarios, and it also makes it possible for the user to, for example, pay for the gas with some tokens instead of having ETH. And behind the scene, the contract will change the token to ETH in order to pay for the transaction. So the user doesn't need to know anything about ETH if he has tokens. And let's say you have a gaming application, you have a blockchain game, something non financial, and the user doesn't own any crypto you want to onboard the users that are not crypto people. So they can pay a service provider by credit card just for sponsoring their gas.
00:03:09.660 - 00:04:19.904, Speaker A: But this centralized service doesn't control the transactions. It can't say anything about what the content of the transactions should be, it can censor it, it can only pay for the gas. And it enables some more complex use cases, such as private withdrawals from ZK roll ups and from zero knowledge mixer such as Tornado Cash. Currently, if you want to withdraw money from something like Tornado Cash, you need to have ETH in the withdrawal address in order to send a withdrawal call. And this could de anonymize you because it associates an address that already has ETH with the address that's performing the withdrawal. And right now, there are centralized solutions like a centralized relay that helps you perform the withdrawal, but then the relay knows about you. So with account obstruction, this becomes decentralized and doesn't de anonymize you, because the withdrawal operation can pay for itself.
00:04:19.904 - 00:05:28.484, Speaker A: You can have a paymaster that looks at the withdrawal, that looks at the withdrawal, it sees that it's going to be successful, so it will perform it it will perform the withdrawal for you, take the cost of the deduct, the cost of the withdrawal, and give you the rest. Which means that you end up withdrawing to an address without associating it with anything else. It makes some interesting use cases that are very popular these days, such as cross chain operations, because it means that you could do things like cross chain trades without having to hold the native currency of both chains. So now that we see what account obstruction can give us, why now? Why again? Ethereum already had its fair share of account abstraction attempts. There were many attempts to figure this problem out. And the problem is that it's very complex. It's very complex and it's hard to agree because all of these attempts require changing the consensus, changing the protocol.
00:05:28.484 - 00:06:21.076, Speaker A: So what's different about this is that it's an ERC, there's no protocol change, which means that it can be immediately used on any EVM chain, no need to wait for a hard fork. And this allows us to start experimenting with account obstruction without committing to a protocol change. So we can start experimenting and iterating and until we see that we have something that everybody likes that satisfies all the requirements and there are no problems. So the end goal is to reach a situation where we can drop EOA altogether. We no longer need externally owned accounts and everything is account obstruction. But in order to take the first steps in that direction, we need a way to experiment. And, ERC, four, three, seven is the way to start this experiment.
00:06:21.076 - 00:07:12.900, Speaker A: So this is our first step. So how does it work? Instead of using normal transactions, we created a new abstraction level above that which we call user operations. And these user operations live in a separate mempool. They live in a separate mempool. And there are bundlers that mine this mempool. They take user operations, they check that these operations are going to be paid for and then they send the bundlers, put it on chain through a global contract called Entry Point, which delivers it to the contract wallet and the bundler gets paid for it. Now, this is permissionless.
00:07:12.900 - 00:08:18.684, Speaker A: Anyone can be a bundler, including the I mean, the user can be its own bundler or anyone else can be, but the natural fit is that it will be miners or post merge. It's going to be block proposers or validators. So the miners will probably participate in this additional mem pool and will mine user operations. As we can see here, users just sign and assign user operations and put them in this user operation mempool, where bundlers take it from there and put it on chain as long as they see that they're going to get paid for it. So I'm going to go through the flow of such bundle from the moment it's sent by a bundler until the operations actually happen. I'm starting with the simpler flow where there's no gas abstraction. So the bundler built a bundle of one or more op.
00:08:18.684 - 00:08:52.644, Speaker A: So let's say it put some user operations inside the bundle transaction. It ran a simulation locally, it saw that the bundle is going to be successful. So it puts it on chain, sending it to the entry point. Now, the entry point contract, this is a singletone. There is one on the entire chain. And this entry point starts by calling the validation function of each wallet. So each wallet needs to implement a validation function and this function performs several actions.
00:08:52.644 - 00:09:32.660, Speaker A: First of all, it does the access control, which normally means checking a signature. So it will verify the signature of the operation, seeing that it is really signed by the user. Then it also checks for replay protection, which in the current model means checking a non and incrementing it. And finally, it pays the maximum cost of the operation. Just like it works for current transactions. You first pay for the entire, you pay the maximum cost and then you get refunded for the unused part. So the validate function verifies everything.
00:09:32.660 - 00:10:18.710, Speaker A: Then it pays for the operation. And then Entry Point calls the wallets to actually perform the operations. So the wallets now get to perform the user operations to act upon the user's request. And after that and after each operation, the entry point also refunds the unused. The unused gas payment, the part that wasn't consumed by the operation gets refunded to the wallet, just like with the current transactions. Now let's switch gear and look at what happens if there's a paymaster involved, which means there is gas abstraction. So now the wallet doesn't pay.
00:10:18.710 - 00:11:02.704, Speaker A: It starts the same way. Entry Point calls the validation function and the validation function checks the signature. It increments the nons, but it doesn't pay. It is not asked to pay because there's a paymaster. Instead, the Entry point now checks if the paymaster is valid and staked. And I'm going to elaborate on that in a bit, but let's assume it sees that the paymaster is valid and staked. So now it also calls a validation function in the paymaster contract and the paymaster gets to look at the operation and decide whether it wants to pay for it.
00:11:02.704 - 00:12:06.470, Speaker A: If it wants to pay for it, it approves it. And now Entry Point performs the actual operation, tells the wallet, it gives the wallet an opportunity to perform the operation and the paymaster is charged for the amount. And now there's another optional step here because the paymaster might want to do something after it knows how much it paid on behalf of that user. For example, if it's a token paymaster where the user is paying with tokens. So now the Paymaster wants to charge the user to transfer tokens from the user to charge for the operation. So the Paymaster could ask for a post op and in that case after the operation the Paymaster's post op function is called. So now the Paymaster gets to do its internal bookkeeping or to charge the user or anything else that it wants to do with this information.
00:12:06.470 - 00:13:06.484, Speaker A: So in order to perform all of these duties, the entry point contract needs to have a few interfaces, it needs to have interfaces to serve the three different entities in the system. It serves the bundlers, so the bundler creates the bundle and it needs to locally call a simulate validation function which is how it checks that the operations are valid. And then it calls on chain, the handle ops operation which performs the flow that we just seen. And the Paymaster paymasters have a stake as I mentioned. So they need to manage the stake, they need a way to lock the stake, to unlock it and to withdraw it. So there's this interface and finally there's a deposit that is used to pay for gas. The deposit is owned by wallets or by Paymasters.
00:13:06.484 - 00:13:51.988, Speaker A: So they also need a way to check their deposit and to check the deposit to deposit more into it or to withdraw it. So these are the interfaces that Enterpoint provides and if you want to build a wallet or a Paymaster, you need to implement certain interfaces as well. So the wallet implements a very simple interface. It has just one function, it's the validate user op function. This is the function that gets called during validation. It performed this signature check or whatever access control it has. It performs the non increment or any method of replay protection and it optionally pays for the transaction.
00:13:51.988 - 00:15:12.480, Speaker A: Now the Paymaster has a similar interface with a validate function as I explained earlier and it could optionally have another function called postop where it charges the user or perform bookkeeping. So the entry point is a highly trusted component because it's actually trusted by all the wallets to perform. It actually tells the wallet what the user wants it to do. So the wallets must be really sure that they will only get something that really came from the user and it's trusted by the Paymasters to only charge them, to only charge them for operations that they really agreed to pay for and by the bundlers to compensate them properly for the bundle. So there are a lot of security requirements. I'm not going to go through all of them right now, but we just finished a security audit with OpenZeppelin, so the contract has been audited and I'm happy to talk about its security later if anyone wants. Another important security consideration that also affects the way you use the system is denial of service is the risk of denial of service against bundlers.
00:15:12.480 - 00:16:05.940, Speaker A: So user operation relies. The validity of user operation depends on EVM state and that makes a pretty big attack surface against bundlers. For example, if someone can submit a large number of ops and then invalidate all of them at once, it means that there's going to be a lot of unpaid work performed by the bundlers. They need to simulate all of these ops. Each of these ops is going to fail simulation and get dropped off chain, but nobody is paying for all of this extra work. So we need to protect against this. And it can be even worse if there's a bad paymaster because a single paymaster can affect a large number of different ops from different wallets.
00:16:05.940 - 00:17:05.044, Speaker A: So we put many mitigations in place. The first one is a limit on validation gas. So validation gas represents the risk of unpaid work for bundlers and for nodes because this is the work that's being done for the validation before knowing that the operation is going to be paid. So each user operation has to specify how much validation gas it's going to need. And if this number is set too high, then bundlers are likely not to accept this yobu's user operation and not even try to simulate it because it has too much risk. Another thing we needed to take care of is to make sure that the environment is consistent because otherwise user operations could be invalidated in large numbers without any action. For example, let's say we allowed during validation to check the block number.
00:17:05.044 - 00:17:46.470, Speaker A: So someone could send a very large number of ops that depend on the current block number and they're all going to be successful when added to the mempool. But then the block number changes and by the time a bundler tries to bundle them, the block number is no longer the expected one. So now all of these operations need to be dropped and that's going to be a lot of work. So we needed to ban any environment operations. So all of the ones listed here are not allowed. So an operation is not going to be accepted if it uses them during validation. Of course it can use them during the operation itself, just not in the validate function.
00:17:46.470 - 00:18:43.680, Speaker A: And we also needed to restrict a couple of opcodes. So for example, the gas left call, it can only be used in the context of a call. When setting the gas for a call, you cannot use gas left to read the number and act upon it and make decisions on the gas. In practice, this shouldn't really be a limitation. There isn't a lot that you need to do with it other than making calls. And one last thing that we do to ensure consistency is we make a list of the code of any account that is accessed during this during validation. And if the code changed between getting into the mempool and creating the bundle, then the operation is dropped without simulation.
00:18:43.680 - 00:19:22.716, Speaker A: Normally, this shouldn't happen. It means that someone either created or self destructed one of the contracts related to the operation. So this is how we make sure that everything stays consistent, which leaves us with just storage access. So we also need to make sure that a single storage change cannot invalidate a large number of ops, because then someone could set a flag that kills all of the ops in the mempool. So we limited the wallet. The wallet can only access its own storage. It cannot access the storage of other contracts.
00:19:22.716 - 00:20:13.884, Speaker A: And this is complemented by another requirement that each wallet can have only one user operation in mempool at a time. It can replace it by fee, it could even replace it with a batched operation that perform multiple actions, but it can only have one. So these two rules together mean that a wallet that a state change can only invalidate one op. It cannot invalidate a large number of ops. So we have a similar rule for paymasters, but for paymasters, this is not enough because you actually could have multiple paymasters. You could have multiple ops that use the same paymaster. So we also needed a reputation system where each bundler maintains a reputation for each paymaster it sees, and it needs a way to know if this paymaster is causing a lot of unpaid work.
00:20:13.884 - 00:21:37.470, Speaker A: So what it does is it checks how many operations with this paymaster failed simulation in a sliding window. And if it sees that the paymaster is causing too much unpaid work, then it's going to throttle and eventually ban it for a while. And this is where the stake comes in, because we needed a civil resistance mechanism so that it's not cost effective for an attacker to spin up a large number of paymasters that misbehave. So each paymaster has to lock a stake and if it wants to unstake, it needs to wait for a while, which means that if someone wants to perform such attack, they need to spend a lot of ETH on deploying these paymasters. And each of the paymasters is going to cause a very small amount of extra work before it gets itself banned. So when can you use this? We started building this eight months ago. It was co authored with Vitalik and since then the Nethermind team and the Opengsn team have been working on building it and we kept iterating with Vitalik on the design until we're satisfied with it.
00:21:37.470 - 00:22:35.344, Speaker A: And now, last week, Open Zeppelin completed the security audit for it, which allows us to put it on Mainet. So today it's available on Ethereum, Mainet, and on testnet. It's also available on Gnosis chain, formerly XDI, and soon it should be available on more layer one and layer two networks. And now is your part. Now we would like you to start building and experimenting. We want the community to start building, ERC, four, three, seven wallets and also experiment with different gas abstraction models by implementing Paymasters. So if anyone wants to start experimenting with it, this hackathon is a great opportunity because the Opengsn team is sitting right here and could help you get started.
00:22:35.344 - 00:23:31.330, Speaker A: Or you could join our discord where we can also help with such integrations. And finally, if you are building a cool project that uses ERC four three seven, you should consider applying for a grant from the Ethereum Foundation because we would love to see the community start experimenting with this. Right. So I'm going to post a couple of links for the EIP itself and everything associated with it. And now I would like to invite Draw from Opengsn to walk through the code of the so I'd like to invite Draw to walk through the code and show what a wallet looks like, what a Paymaster looks like.
00:23:32.100 - 00:23:32.850, Speaker B: Right.
00:23:46.820 - 00:24:15.048, Speaker A: GSM still affiliated with Open Zeppelin is what? I'm sorry. No, not with open zeppelin. It's maintained by Opengsn, but it's active and actually a new version is coming out now. Sorry, you were asking? Yeah, because Open Zeppelin was working on GSN right before in the first version. We worked on it together, but we've.
00:24:15.064 - 00:25:05.176, Speaker B: Been maintaining it sincera. I'm from the Opengsn team, I worked on this project. Now, after the overview of Joav, I'll try to dive into the two contracts in the system that interest you as developers. I can overview the entry point, but we don't have time for that. It's the contract that we all trust and love and Openzeppen Verified. I'd love to go in person if you like, but the two components that applications will want to customize and create are a wallet and a Paymaster. So, first of all, what is a wallet? This is the interface that you have talked about.
00:25:05.176 - 00:25:55.556, Speaker B: A wallet is an account, it holds your account, it has an execute function, but we don't mandate its format, so the interface doesn't require it at all. And in order for you to easily create a wallet, we created the base wallet implementation. It exposes nons. Of course, it has to have the entry point it supports at any given point. There is exactly one and it implements a validate user op. So we provide you with the default implementation, which verifies it calls only from an entry point. We have to provide a validate signature.
00:25:55.556 - 00:26:43.380, Speaker B: Now, this base doesn't implement it. We'll see in a moment how it is and it perform a prefund, which means it sends back to the entry point. That called it the value, the cost of this transaction if we go down into a specific the sample wallet we created. Now, sorry, it's simple. This is a very simple wallet and for one thing, I want to zoom in. Great. This is a simple wallet contract.
00:26:43.380 - 00:27:24.110, Speaker B: It's a base, it provides anons it has an owner and it accepts signature only by its owner. It implemented the verified signature by using the verified signature. It validates the signature using the standard EC recover. If you like, we can have any different signature scheme we're not enforcing we don't require any signature scheme, not even a length. This one uses EC recover. It uses the very, very simplistic nonce mechanism which is increment by one. Again, it's very good for a start.
00:27:24.110 - 00:28:18.680, Speaker B: And it provides an exec from entry point, which is of course how it receive requests from the entry point. It requires that it is called from the entry point to execute on behalf of this wallet, which to create the request. One thing it doesn't do, and of course a wallet probably will do it is not a proxy. It works very well, except that the deployment will cost you quite a lot because it's the entire contract is deployed each time you use it. A better implementation, of course, will only deploy a simple proxy so that this contract can exist once on chain. It also exemplifies how it uses a batch. As you have said, we can have only a single transaction per wallet in the Mempool.
00:28:18.680 - 00:28:47.140, Speaker B: But if you want more, you probably would use a batch. So we added a sample batch into this simple wallet. And another example of something it can do is it can transfer. It can transfer ETH from its own balance to other contracts and of course, to execute code in any other contract. Let me see. Okay. And it provides the basic help function for elac.
00:28:47.140 - 00:29:53.160, Speaker B: It has an admin to modify its entry point. This is the edge case where an entry point has to be upgraded, so of course the owner can perform the switch. This sample contract is also act as a standalone proxy account and it accepts requests directly from its owner. That is, you can either call it just like you would call any other contract object from your owner account or through an account obstruction where the entry point executed as long as the entry point pays, and as long you are using ethereum. As it is today, there is no real difference. As we said, the difference comes when you use features like the paymaster. So again, if you look what it takes to be a paymaster this is the interface you have described earlier.
00:29:53.160 - 00:30:42.030, Speaker B: There is the verify paymaster. A paymaster receives a request just before it gets accepted, and if it appears in the request, it has to accept it and then has a chance to run a post operation code to do it. Again, we create a base paymaster to implement this interface. It provides a convenient way to initialize the entry point. And to support this entry point, validate paymaster itself is exposed as it is, because it's a view function. There is no added value we can do in the base class, but the post operation is required to be called from the entry points. We enforced it in this base paymaster.
00:30:42.030 - 00:31:11.320, Speaker B: Now, let's look at an example which is very interesting but a bit more complex of a paymaster. This is a token paymaster. It is a token and it is a paymaster. And if you have tokens, you will pay. For the request using it. So the main function is the validation. Let's see what it does.
00:31:11.320 - 00:31:53.494, Speaker B: This is the validate userboard. It's a view function that a Paymaster expose and it should revert if it doesn't agree to Pay. And should accept if it agrees to pay for this request. So this is an abstract method, a conversion from it knows how much this operation will cost, so it knows how many token it needs to request from the account. It okay. It performs some validation that the verification guards in the request is big enough. This security issue, I'll not dive into it right now.
00:31:53.494 - 00:32:31.220, Speaker B: Now it need to check if the wallet will agree to pay for the request. What it does, it checks that there is a balance. That the token balance. Again, this paymaster is a token. It verifies that the balance of this wallet is high enough in this token paymaster. And if this balance is enough and it reverts. If it doesn't emit, this balance is enough.
00:32:31.220 - 00:32:58.570, Speaker B: What you see here, it's return value. The return value of the verification is what we call a context. It's something we pass after the request. Is complete to the post operation. This is a signal from the paymaster to the system that it has some post operation to be done. Don't forget me after the execution. I need to complete the balancing of the user.
00:32:58.570 - 00:33:43.174, Speaker B: If you go into this post operation, it extracts this context, which is the it saves the address of the user and the post operation, it gets the actual cost. So now it knows how much tokens it needs to get from the user. So what it does, it forms a low level transfer. Again, this is a token. So it can do it by itself from the user's account to itself. So this way, the user paid in token. We made sure that in advance that the user has enough tokens for the maximum possible price in token and post operation.
00:33:43.174 - 00:34:11.730, Speaker B: After the user completed the operation, we perform the actual charge. Now, if you are thinking maliciously as a user. Okay? I will start a transaction, and then the operation I will create is empty my token balance. Because if I empty my token balance after the operation, I don't have any tokens and I will not have to pay anything. The paymaster will not be able to charge me. So we need to mitigate that. Now.
00:34:11.730 - 00:34:55.274, Speaker B: It's a bit difficult to see from this paymaster code how it is done. So it is written somewhat in comments. And you have skipped it in the first part when a paymaster runs its post op post operation. If this method reverts the entry point performs a very neat trick in that it reverts the user operation completely. Along with the postop, of course, and then calls again the postop of the paymaster. Now, if you think about it, the code that the user create executed was completely reverted. It's not on chain.
00:34:55.274 - 00:35:52.580, Speaker B: So if you look at the state of the chain, the pre operation, the verification, the user has a balance, was executed, we did some operation and reverted it and now we call the post operation which means the user has a balance. So if the user will perform this trick and try to empty its own balance, the post op will revert, the entry point will call this post operation again by the way, with updated actual cost, which is higher, it has to cover for this revert. Okay. And the transfer will succeed. So this code, it's not that complicated, but this is a paymaster that works with a token. There are several other paymasters we have in the sample code. I don't have much time, but I don't have any I don't think we have okay.
00:35:52.580 - 00:36:21.306, Speaker B: If you like you can talk with us. There is one paymaster we added is the ability to kind of an oracle, to trust an external address so that this paymaster can trust a signature created outside of the system, outside of the network, off chain and the paymaster will validate it and will pay based on this signature. So we also think it's a cool paymaster to use and to integrate. Okay, thank you.
00:36:21.408 - 00:36:31.840, Speaker A: If you have any questions any questions? Yeah, if anyone has questions, we can throw outside because there's already.
00:36:34.610 - 00:36:35.406, Speaker B: Available.
00:36:35.588 - 00:36:41.220, Speaker A: Oh yeah. I will publish it around this code and I'll make it available.
00:36:41.990 - 00:36:42.880, Speaker B: Okay, thank you.
