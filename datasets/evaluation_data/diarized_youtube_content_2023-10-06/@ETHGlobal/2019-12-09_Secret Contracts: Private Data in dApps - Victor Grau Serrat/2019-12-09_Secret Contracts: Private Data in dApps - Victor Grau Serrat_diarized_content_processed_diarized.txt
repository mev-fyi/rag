00:00:03.450 - 00:00:43.418, Speaker A: I have this slide with some of the workshop materials. I'll keep putting this slide a few more times and probably at the end. But basically all the information that you want to hack with us is on this link, enigma codaloo. Okay, having said this, I'm going to start my talk. And I guess I want to start by saying that research shows that in talks like this, people will get at the most three ideas out of any talk. So I'm just going to try to make the job easy and just outline those three ideas, key ideas that I want you to get out of this talk and of this talk. And I'll keep hammering those in.
00:00:43.418 - 00:01:30.810, Speaker A: So first is come on in. First one is that if you think about privacy in the Ethereum ecosystem, we want you to think about Enigma. Second one is that analogous to the smart contracts in Ethereum? We have secret contracts on Enigma and those secret contracts are written in Rust. I'll talk more about this. And number three is that we provide a Truffle like environment for developers. So if you are familiar with truffle for your Ethereum development of DApps, then we are trying to make it as like you should feel very familiar, look very familiar to you in the environment that we provide. So privacy equals enigma.
00:01:30.810 - 00:02:10.434, Speaker A: Secret contracts are written in Rust and Truffle like development environment. So let's start talking about the problem of privacy. We all know that data on blockchains are public by default. And we believe that this greatly limits the potential applications. Think about healthcare, think about finance, think about identity. And think about any games that rely on not knowing your position of your opponents, et cetera, et cetera. All these things are things that right now you cannot do on Ethereum.
00:02:10.434 - 00:03:32.800, Speaker A: And we want to change that because we think that if we have to grow the Ethereum ecosystem, we have to provide tools that allow for private data. And so we solve specifically this issue of computing over sensitive data without compromising on decentralization. So we have a network of nodes that have what is called trusted execution environments, or Tes for short. That's a technology that comes almost by default in new intel machines and basically provides sort of a black box inside your computer where not even the person that controls the host or that machine can see what happens inside that black box. That's the Enigma network where the computation happens and the verification or consensus for that we rely on Ethereum. And that's good news because that makes our network 100% compatible with Ethereum. And that's why we come to the Ethereum hackathons for people to use this technology.
00:03:32.800 - 00:04:55.622, Speaker A: So we are several weeks or maybe a month or two away from releasing our public testnet, which we codenamed Discovery. And that's the first network that publicly enables this notion of secret contracts, which is Permissionless network. It's economically incentivized like or very similar to a proof of stake network and again, it's compatible with Ethereum. It helps to understand how our network works from the point of view of the different stakeholders. And much like Ethereum, we have developers who deploy DApps, we have users who interact with those DApps and we have a set of nodes like Ethereum but we'll call them workers to distinguish them which are the ones who execute the task or compute over that encrypted data. And so for the next two or three slides I'm going to look at the flow of information in our network. So we start on the left hand side with developers that write secret contracts, compile them to bytecode and deploy them on the Enigma network.
00:04:55.622 - 00:06:14.546, Speaker A: In that deployment also they are registered on the Ethereum blockchain which again is our source of truth that's our consensus layer is on Ethereum. So then users interact with DAPs by submitting encrypted data. We provide the JavaScript library, much like Ethereum's web three, that makes all this process sort of seamless to the user. And the user again encrypts their data, sends it to the network. There's some keeping track of those tasks on Ethereum so that they are in order and if they will be executed in the order that they were sent to the network and then the task is sent off to the network. So then workers receive those tasks based on a stake or a weighted lottery. The selected worker executes the tasks, the selected worker can decrypt that information and only that worker can decrypt that information.
00:06:14.546 - 00:07:20.618, Speaker A: And again, think about those black boxes where no one can pick inside those boxes, not even us, not even the people who run the network, no one like that's. Sort of the beauty of this technology that we get from intel. And then the worker executes those tasks and disseminates the results across the network. And the worker returns the results back to the user so that the user can see the results and also to the Ethereum network so that they can be committed on chain or hashes of those tasks. So if all this sounds very complicated to me, this is the slide that simplifies it. So there's something that goes in that goes encrypted. The worker does its magic in the black box and then you can get encrypted outputs and we maintain an encrypted state.
00:07:20.618 - 00:08:38.100, Speaker A: So this is a state that I guess like the Ethereum state is kept throughout the different computations or the different functions and it remains encrypted at all times in the network. And then there's the option of having an Ethereum callback where you can interact with Ethereum with say, nonsensitive data. Let's say we have a secret voting that say we want to decide how to allocate $100,000 and each of us votes. And we don't know what each of us voted, but we know that at the end there's an Ethereum callback that says transfer 100,000 to this address and that's what the Ethereum callback does. And it's separated from say, the secret voting flow that is inside the worker and we will never be able to know who voted for what. Again, this is the materials here. You will have all you need to hack with us.
00:08:38.100 - 00:09:46.502, Speaker A: So let's think about what can you build with Enigma. Think about games that require you to hide actions like rock paper, scissors or Battleships quiz or word competitions like Geoparty or hangman scavenger hand with secret locations, secret messaging. And here I want to highlight where's Ainsley and John they are in the back. They are two of our people in our team who basically spend their job is to think about applications. Right? So what I like to say is that anything that you can come up with, they probably have thought it before and they are well or in some form or another or they can relate to something that you might be thinking. So use them, use them as resources and say, well, I'm thinking about this. Is this feasible? Is this not? And they will relate to any ideas that you might have and brainstorm with you.
00:09:46.502 - 00:10:42.380, Speaker A: So we know that in a hackathon there's limited time. Use those resources that you have at your disposal to get the most out of your time here. Okay, so I'm moving to not yet. We provide docker network because we don't have, as I said at the beginning of the presentation, we'll go public in about a month or month and a half. So we don't yet have a public testnet or mainnet. So we provide a docker environment where you can launch a self contained instance of the network and interact with it. You just launch it and see all the nodes in the network interacting with one another.
00:10:42.380 - 00:11:34.380, Speaker A: But what I want to get to today is develop a secret contract. So idea number two, secret contracts are written in Rust. And if I were a participant in a hackathon, I said, jeez, yet another language I have to learn. Sorry, but obviously we don't choose the language that will run our infrastructure on how easy it is to hack. I hope you appreciate that decision. But rather because it's memory safe, it's highly performant well and it has the plus that has a wonderful community. But basically it's like actually I want to ask a question.
00:11:34.380 - 00:13:12.650, Speaker A: Who has experience coding in Rust? Yeah. So that's what we are expecting because, well, Rust is not that pervasive in the Ethereum ecosystem yet, but we're going to provide you with and actually the rest of my talk is mostly demystifying Rust and making it easy for you to get started on Rust. So I like learning by doing. So I'm going to just walk you through what would writing a secret contract for the Millionaires Problem look like. And if you are familiar with Yao's millionaires problem, this is about two people, Alice and Bob, who are millionaires, and they are always obsessed to know who's richer, but they do not want to disclose their wealth to one another. So they are obsessed with privacy as we are. So what happens here is that we create this Millionaire's Problem secret contract where both Alice and Bob submit in encrypted form their wealth, and the contract basically returns either Alice or Bob as the richest without disclosing the individual amounts.
00:13:12.650 - 00:13:57.382, Speaker A: So my tip for okay, you come here, you have some ideas for a really cool DAP. You realize that you need privacy. You choose to code with Enigma, and then you are confronted with the challenge of coding your secret contract in Rust. This is the first place where I would start. This is when our main repo has 123-45-6789 secret contracts already written that you basically can cut and paste. It's like, okay, I need to store a variable in the state. There's a function here I need to write from the state.
00:13:57.382 - 00:14:25.220, Speaker A: Okay, this contract does this. I need to make an Ethereum callback. Okay, this one does. And you just look through the code and look for the bits and pieces and essentially copy paste. All those contracts are thoroughly documented and in line and so on. So it should be easier. So that's what one secret contract looks like, but I'm going to break it down almost line by line.
00:14:25.220 - 00:14:53.306, Speaker A: And the Millionaire's Problem Secret contract is about 80 lines long, including comments. You can see that in this 1st 23, more than half are common. So we are looking at 40 lines long. I claim that those 40, almost 15 or 20 are always the same. So you just copy paste. So in the end, you have to write like 20 lines of code. I think you can do it.
00:14:53.306 - 00:15:54.362, Speaker A: So again, these 1st 25 lines is everything. It always is the same. The first one is that because we're going to run our code inside the enclaves, the enclaves cannot support all of the standard functionality of Rust. So we take it out. We bring two crates into scope which provide the runtime, which allow for reading from the state, writing from the state, and printing for debugging purposes. We bring this other crate that allows us to call Ethereum functions at the very end of the execution, and then this other crate that allows for serialization and deserialization of data in and out of the contract. Crates are the equivalent of packages or libraries in JavaScript or other languages.
00:15:54.362 - 00:16:40.414, Speaker A: So all this is just like copy paste. And then in order to write and read from the state, we basically have a hash map. The hash map is indexed by this string. So I'm just going to write whatever Identifier I want to use to access the State. This is how we declare data that we will write and read from the state. And it's like a struct where you basically define with key value pairs. And here you go.
00:16:40.414 - 00:17:36.330, Speaker A: Into what types are supported. These are rust types. But in the appendix there's also the equivalence between Rust types and solidity types. And then here we declare the functions that will be publicly available from our secret contract and the ones that the users will be able to call. There's a constructor but because it's empty we can go with the default. And this is essentially this is where the code actually starts where I want to get a millionaire from the state. So I read from the state with the string that I defined before and I know I'll get some vector.
00:17:36.330 - 00:18:28.206, Speaker A: Otherwise if the state is empty, just give me an empty vector and then I want to add a millionaire. That's when Alice and Bob send their wealth to the contract. They'll send their address first parameter and an integral for their net worth. And so I'll read from the state to get if there are others, I'll push the data that it's been passed onto the contract and I write all that to the state. If you think at a high level, this is fairly simple. I read from the state, I get whatever the state is, I add my data and I push that into the state. And then the network handles or keeps the privacy and the encryption there.
00:18:28.206 - 00:20:05.600, Speaker A: So four or five lines here and then at the end I want to compute reaches. So this is a rust at its best, where you get a lot of stuff done in a line, basically where I want to read from the state, get the millionaires, iterate over the array that I will get and then find the maximum by key, where I'm using the net worth as the key and I will get something in return or nothing. And the known is so that we can handle if again the error if nothing is returned. So that's that. So then I've written this secret contract in Rust. I use the environment that we provide much like Truffle compile, I use discovery compile and then this generates the compiled bytecode which in the Enigma network happens to be WebAssembly and that's the WASM files. And so then like Truffle you do discovery migrate and this will deploy this contract onto the Enigma network and have it ready for the users to start interacting with.
00:20:05.600 - 00:21:15.780, Speaker A: I want to skip this and then basically mention that we have a client side library for interacting with secret contracts which is responsible for encrypting the user inputs, submitting the task to Enigma and getting the computation results or status from Enigma. And it looks like something like compute task where the first parameter is the function that I want to compute, say add millionaire. The arguments are the arguments to that function. Say the address and the net worth and then the gas limit and gas price like ethereum. The sender that would be the user and the address of the secret contract where? I'm sending this computation task and then I can get the task results and check the status of the task when it's pending computation, and then eventually it's done, and then I can interact with it. I'm going to skip this in the interest of time go here and I know I'm going to finish early. Oh, I want to say two other things.
00:21:15.780 - 00:22:02.066, Speaker A: I'm going to insist on use the resources that we bring to the hackathon. There are six of us in addition to John and Ainsley that I introduced before from the business development there's, fred and I. Hi Fred. We are both developers. We have developed this protocol alongside with a larger team and we are happy. We are here only to answer or mostly to answer your questions to support in your installation to help you write those secret contracts. We're just standing by for you to come and talk to us and help you out and if you decide, well, this is all complicated, it's all over my head, I'm not going to make it.
00:22:02.066 - 00:22:55.074, Speaker A: But I think that privacy is needed. Enigma School I want to make sure you talk to Aaron and Tor there who are leading our community marketing communication efforts. They manage a wonderful community of Enigma ambassadors or whether you want to start blockchain club at the university. Aaron is your guy. Utilize us. We are here just so that you talk to us in person because we know how much of a difference talking to people rather than being on a forum or slack or whatnot make. So with that, I have a couple of minutes left to spare if you want to do Q and A, ask questions or we can just empty the room and let the next ones come in.
00:22:55.074 - 00:22:55.814, Speaker A: Yes. Question.
00:22:55.932 - 00:23:00.262, Speaker B: Yeah, so when you're passing in a function and you want to grab the.
00:23:00.316 - 00:23:08.038, Speaker A: Actual address that the person sends in, I see you guys are doing something called sender. When I'm doing SRML, I have to.
00:23:08.044 - 00:23:15.740, Speaker B: Say like origin and I have to specify and grab it from origin. Is sender like a reserved word in Enigma contract that allow me to actually get the person?
00:23:16.190 - 00:23:25.134, Speaker A: No, this is a parameter that you pass. So you would pass in this case you would pass an Ethereum address as the message sender type of thing.
00:23:25.252 - 00:23:33.940, Speaker B: But it has to be signed by them or how do I figure out that the message was signed by the actual person? I want to sign by.
00:23:36.950 - 00:23:51.222, Speaker A: I guess let's take this conversation offline, but I like your thing already. We're getting in deep into the stuff. Quick question. Yes.
00:23:51.276 - 00:23:53.698, Speaker B: There is a constructor just like Ethereum.
00:23:53.794 - 00:24:17.486, Speaker A: Yes. When you construct the okay, yeah. I didn't show it because if you don't specify it, it uses a default constructor. But then you can override it and say I need to make this constructor and pass these variables into the constructor. Then you specify it. I guess we are trying to make it simpler and simpler in that if you don't need it, you don't have to worry about it. If you need it, then it's available to you.
00:24:17.486 - 00:25:13.278, Speaker A: Okay? Yes. So all the computations are paid for in eng, the Enigma token, and then the Ethereum callbacks are paid in Ethereum. But there's an automatic conversion that happens. You send more eng and the eng is converted at the rate at the running rate to pay for that Ethereum callback. So again, we try to make it as seamless as possible. So you make one transaction where you pay gas in eng and then the network takes care of it. How do I do computation over encrypted data? So at the beginning of the talk, I said that the network relies on these trusted execution environments.
00:25:13.278 - 00:26:10.080, Speaker A: So the answer is that I decrypt the data, I do the computation and encrypt again, because there's a key exchange that happens through using diffie hellman where I know what is the worker or the node that will do my computations and I communicate direct. I send my public key to that node. The node generates the counterpart, and then I have that one to one with that worker. Eventually we want to use what's called multiparty computation, but we are not there yet. And we thought that this was a faster way to get to prove that. I don't think that no one is implementing MPC for real, like in a viable way. We believe that it will be possible in the future.
00:26:10.080 - 00:26:35.540, Speaker A: The CEO that founded the company, his research was on PC at the master's level, so that's why it triggered the whole thing. And the original paper was Enigma running on MPC, but for viability purposes in the short to medium term, we had to implement with the stressor execution environments. Great questions. I think my time is up. Thank you very much for your time. We'll be outside.
