00:00:00.410 - 00:00:35.426, Speaker A: Thank you. Hey, everyone. I'm Hirsch, founder and project lead of EPNS or Ethereum. Push notification service. This is a 30 minutes workshop. Hopefully we'll get everything done in 30 minutes. But yeah, we'll go very quickly about the buy, about the water, the why of VPNs, then how to build the notifications, including your channels and everything else, so that you can deliver notifications to web Three wallet addresses.
00:00:35.426 - 00:01:17.400, Speaker A: Then it's about price and brands. And of course after that it's question and answers. So let's get started. Of course, we always start with some good Vibe video. So I have that right over here. Awesome. Hope you guys like it.
00:01:17.400 - 00:01:50.990, Speaker A: Back to the deck. So, yeah, first of all, nostalgia time. So the reason Eat Global Hack money is our favorite is because we started from Hackman 2020. Just like you guys, we just had an idea and we built it out. And because of the love we got from Ethereum Community and of course from ETHGlobal family, here we are. So yeah, cycle of life for us. But yeah, diving in.
00:01:50.990 - 00:02:42.818, Speaker A: So exactly what are we solving over here? Well, basically we are solving the missing piece of web3. So just think about it. In web Two, whenever we are waking up, we usually have a look at our mobile phones and we have notifications from everything or every app which we use in web two. Right? So it can be about notifications of your important emails, it can be notifications about any transaction you do, any PayPal or Venmo payments, it can be about any social networks which you go into or even when you're doing WhatsApp. It's just like notifications which come in and that's how we talk. So yeah, that's basically web two. But now when you come to web Three, what we realized was everyone went for speed, scalability and security, and that was really important.
00:02:42.818 - 00:03:31.890, Speaker A: But with the invention or innovations on DAP, a lot of things started to break up because no one really paid attention to the communication there. And because of that, a lot of problems occurred. For example, if you are into DeFi, your loans were liquidated and you were not able to get to know about it. If you are into ENS, your domains will expire. You don't get to know about it. If you are into governance proposals, they come and go, you don't get to know about it. And the reason for that is there was no communication layer for web Three, which means that there was no way for a DAP or a protocol or a service to reach out to a wallet address and say, hey, something of importance might have occurred to you and what do you want to do? Which is exactly what APNS was meant to do.
00:03:31.890 - 00:04:14.130, Speaker A: But yeah, before that, let's quickly elaborate all the problems or where communication is needed. So let's look at DeFi first because of course it's happening. So DeFi again, as I said, loan liquidations, they occur and there's a broken interface where actually for loan liquidations, there's no interface. Like there's no way you can know about that. Your wallet address loan will be liquidated right now. And that is not the norm in web two. Whenever a bank liquidates or when you go on a holiday, you don't return back from the holiday and the bank says oh no, you were gone, the house is now ours.
00:04:14.130 - 00:04:58.810, Speaker A: But yeah, in DeFi that's a scary possibility. Same thing with farming. Like farming epochs, the more we farm, the less we are aware like what epochs have occurred and whether our rewards are available to claim or not. And you can extend it so much more. It can be interest change and it can even be a new stable coin attachment that has been made or a new world strategy that has been made. Again, you as a web3 wallet address are not able to know about these things because there's no way to communicate that to you or there was no way to communicate that to you. Same with the Dow.
00:04:58.810 - 00:05:36.550, Speaker A: Again, there are a lot of governance that comes and go and people usually put it on Twitter. But again, that interface is broken because just think about it, when you are on Twitter, you're talking to each other through Twitter usernames. When you are on WhatsApp, you're talking to each other on WhatsApp usernames, which are phone numbers. When you are on web3, your wallet address is actually your username and that's shared. But yeah, no one is talking to them. So that's what the problem is again for the same thing with the NFT. So yeah, what is the solution? Well, of course the solution is UPNS.
00:05:36.550 - 00:06:38.126, Speaker A: The way we solved it was by creating a decentralized communication protocol that enables any DAP, any front end, any protocol or any backend to send communications that are tied to a user wallet address. This is done in an open gasless and MultiChain way and also platform agnostic way. The idea is that this is an open communication there and any crypto front end can then tap into this network and can ask all the communications about a certain wallet address and based on that show it to you regardless of any crypto content where you are logging in from for web3. So yeah, that's the solution. Very quickly, how does it work? So yeah, what we have over here, EPNS has three ecosystem cogs. The first is EPNS code that resides on ethereum's. Basically any service that wants to send notifications, they have to come and register themselves.
00:06:38.126 - 00:07:14.666, Speaker A: Over here, this EPNS code is essentially responsible for governing everything. Then on the right side we have something that we call as Epns.com layers. They are made of two different parts. One is the gasless EPNS SDK. So the idea is if you're a back end or a DAP, you don't really need to pay gas. What you need to do is send these notifications which you will be forming using EIP seven one two to our push notes and that will be picked up, validated and everything will go on.
00:07:14.666 - 00:08:10.540, Speaker A: The second layer on this is something which we call as Epnscom Middleware Smart contracts and these are deployed to all the chains that we support. We of course support EVM as well as non EVM chains. But the idea is if you're a smart contract then you can basically interact with this smart contract and send those communications out. I already mentioned push nodes but yeah, push notes basically form the heart of the ecosystem. Basically what they're doing is push nodes are listening to all the communication that is coming from Epnscom. Once a communication comes, it quickly validates it through EPNS core and if everything looks good, it basically admits it into the network and right after that any crypto wallet and crypto frontend can just tap into the network and can display these notifications out. So yeah, that's the what and the how.
00:08:10.540 - 00:08:59.226, Speaker A: Let's now quickly dive in on how to get the workshop done. And just for fun, I am going to start the timer because I want this to be done in less than ten minutes. I know that will not be possible but let's have a go at it. So yeah, the first thing which we need to do is of course go to stagingapp or stagingapp EPNS IO and we need to create our own channel. How do we do that? The very first thing we need to do is get some ether because of course Kovan ether will be required to create a channel. I want to do it completely from the scratch. So, yeah, this is ETH build.
00:08:59.226 - 00:09:58.126, Speaker A: I am just creating a private key which I will just import in my MetaMask account. Once I've done that I can just go to any faucet and I can get that ethereum. But in case you want, we have EPNS channel discord channel on ETH Global. So you can just come and ask us about providing some common ETH to you, which is what I'm going to do. I already have some common eat over here. So what I'm going to do is I'm going to transfer 0.1 E to this newly created account and while that's happening, we'll very quickly go back and we'll see exactly what we need to do.
00:09:58.126 - 00:10:38.218, Speaker A: So yeah, the first thing, like EPNS Code governance and any service that wants to send notification, they have to create a channel which is exactly what we are going to do over here as well. So let me just log into the newly created account, connect, reload the DAP just to make sure everything is proper. Go to create channel. Now we have the ETH. We also need to mint some die. We basically stake 50 die or so to create a channel that basically is a form of civil resistance. And of course it enables some cool things.
00:10:38.218 - 00:11:07.534, Speaker A: We can skip that for now. Right now I'm just minting free die. Right after Free Die, I do need four things to create a channel. The first thing is, of course, EPNS logo or your channel logo, which is 128 PX by 128 PX. Hopefully the transactions will not take that long. I think they're already done. So yeah, I already had a logo for E Global.
00:11:07.534 - 00:11:52.660, Speaker A: So I'm going to use that amount state 50 dime. I minted that as well so I can continue. Then I do need to put in few key things about my channel. So let's say we want to name this Global 2022 channel. We are multi chain, so Polygon is something that we are already getting deployed on in this case because we are probably going to interact with the Ethereum main net. So I can just copy paste this address and just use Polygon as an alias. But yeah, in essence, if you are creating something at Polygon, then the Polygon address is what you are going to enter over here.
00:11:52.660 - 00:12:24.626, Speaker A: Then after that, I'm just going to name this. This is my local channel and I will have a call to Action Link, which is a URL. And that's it. All I have to do after that is basically in the background, what is happening is your JSON file is generated off the channel. It's getting uploaded to IPFS. After that, there are two transactions that we have to do. The first is approving the Dai so that it can be deposited in the smart contract.
00:12:24.626 - 00:13:11.450, Speaker A: And right after that it's about contract interaction. So, yeah, I'll confirm that and hopefully everything will go super smoothly and the channel will be created very shortly. So the one thing that you have to remember is once you create the channel, it might take 30 to 60 seconds before the channel is actually shown on the front end. And that's because the IPFS payload which is getting uploaded, it also needs to be cached and penned by the push node. So that's why it takes a little bit of time. But yeah, while this is getting loaded, what we can do is it's already loaded. Awesome.
00:13:11.450 - 00:13:43.400, Speaker A: So, yeah, this is your channel. Now we are going to look at some notifications. So of course, notifications, like sending is one thing and receiving is the other thing. Right? So to receive it, I am going to basically go to Docs EPNS IO. I'm going to go to Developer Docs. Developer Docs, sending notifications and testing sent notifications. So we have all the ways by which you can test your notifications out.
00:13:43.400 - 00:14:14.586, Speaker A: In this case, we are just going to download this extension, the Chrome extension. We are just going to add this to Chrome should be added. All right. And then I'm going to pin this just for making sure that it's available. After that, I do need to sign into the Chrome extension using my wallet address. So I just pasted that and yeah, that's it. Now I'm all set to receive notifications.
00:14:14.586 - 00:15:05.178, Speaker A: Let's see how notifications can be sent across. So let's see the manual method first. Over here, because now I have a channel, I can basically go in the channel and send a notification out. One thing to remember is whenever you're sending a notification, the wallet address needs to be opted into that channel. Because I've created this channel, I'm automatically opted in and that's why I am able to receive notifications. But in case you want to receive notification from any other channel, you need to opt in, which is a gasless intent. Again on EIP seven one two that is getting sent to push notes and once that intent is recorded, only after that point of time a channel can send notifications which will land in your inbox.
00:15:05.178 - 00:15:55.166, Speaker A: So yeah, going over here, let's send a notification. A broadcast is a notification that gets sent to all the people or all the subscribers of that channel who have opted in. A subset is just for a mini set of all the people that you want to get the notifications to and targeted is basically just one person. So over here I'm going to do targeted. We are content independent as well. This means that the notifications define how the front end will show them up. So in this case, what I want to do is I want to basically send image with my notification as well because that's cool.
00:15:55.166 - 00:16:53.762, Speaker A: You can also do call to action subject YouTube videos or whatever you want. So over here I'm sending a notification. Again in the background everything is getting uploaded to IPFS. Adjacent payload is generated which is then recorded or which is then sent to the push notes and after that the notifications are sent, I think because I'm recording. So the notification will probably not be shown like the push notification will probably not be shown because it's a screen recording. But yeah, if I go over here you can see that the notification is already and they have already made its way. Not only that, we are platform agnostic so any crypto front end can show this out, which also means that wherever you want you can see these notifications out.
00:16:53.762 - 00:17:27.920, Speaker A: So yeah, that's basically creating a channel and sending a manual notification. But when you are building some awesome projects, most of the time you will be doing this via automated route. So let's see how to get that done. So again we'll go to Docs EPNS IO, we'll go to developer Docs. Over here there are various ways by which you can send notifications. You can send it via back end SDK, you can send it via Showrunners, you can even send it via smart contract. There's an example for that as well.
00:17:27.920 - 00:18:25.440, Speaker A: And yeah, it basically is like whatever way you want to define to send a notification out, there's a way for that. Let's use Showrunners scaffold just to see how quickly we can set up everything and can send everything. Because the demo will probably include the Showrunner Scaffold and Uniswap Interface because you can even embed these notifications on your DAP and front end. So because of that, what I'm going to do first is I'm going to very quickly clone everything that is needed. So, for example, for uniswap, I'm cloning the uniswap interface. We'll see how the front end looks in a while. For the showrunners, I will quickly go to Showrunners Framework, set up Showrunners and clone the Showrunners framework as well.
00:18:25.440 - 00:19:26.798, Speaker A: And I think there was one more cloning which I'm missing right now. But yeah, for now this will do. So very quickly, I'll also do one thing, I'll just go to the shortenrs framework and of course I'll do a Yarn install while it's installing. I will also go to Uniswap Interface and I'll do a Yarn install just to make sure that everything is good to go. We can give it some time for the installation to proceed smoothly. But what we can also do in the meanwhile is in the Showrunners, we basically have few things. So Showrunners is basically a scaffold, which basically means it has all the tools to automate your notifications or notifications logic.
00:19:26.798 - 00:20:37.914, Speaker A: But because it's a scaffold, we do need to essentially configure some of the things out. So of course, once I have thrown the show notes, the next step is to create an env file from env sample, then basically define the log level. Because this is a hackathon, let's go with Pbok and after that I do need to go to Infuria or Scan or Alchemy and get the API key about it. Not all three are required, but one of them is a requirement for this demo. Let's do Sscan and Alchemy API as null and let's get this docs infura Project ID and Secret as a part that will run the showrunners out. Hopefully by this point of time, it's still taking some time. So, yeah, the reason why we need Infuria or Etiscan or Alchemy API is of course to listen to the blockchain data because that's what we are going to do over here.
00:20:37.914 - 00:21:11.974, Speaker A: So let's see if Yarn is actually slower than us doing the coding. So yeah, while Yarn is doing its things, let me just show you what Showrunner basically does. So once we have set up Showrunners, right, it basically gives us a framework on which we can build a jam logic. So that's what we are going to do. Let's just hope. Awesome. So this is done.
00:21:11.974 - 00:21:59.010, Speaker A: The next thing is no, it's Docker compose up because we do rely on some demons to go up before the showrunners, before we start the showrunners out, hopefully. Okay, something is wrong. Let's see what is wrong. Okay, let's remove this. Let's stop this docker part. Actually, it's okay, so let's stop the docker and let's rerun it. Hopefully this will work faster this time.
00:21:59.010 - 00:22:49.250, Speaker A: Awesome started running. Then on the next terminal what I'm going to do is I'm going to do yarn start. So because we have configured in env file, if everything works well you will have this error which is basically that student doesn't have any channel folder or basically it doesn't have any channel logic on which it can basically rely upon for code execution. So how to get that corrected? Well, just go to code, go to SRC and in this you have something called Chapel underscore Showrunners which are basically some sample channels which we have created for you guys. Do check it out. For this demo let's just take Hello Word. This is basically a plug and play.
00:22:49.250 - 00:23:44.502, Speaker A: So what you need to do is just drag Hello Word down to the showrunner. Once you do that, once you do that you will have a different error which is Hello Word has no wallets attached to them and that's where they are supported. That is because a channel or a delegate of the channel can only send notifications on their behalf which basically means that you do need to enter your private key over here. So of course, because we just created the channel we have the private key, we'll just go and paste that in and that's about it. Your showrunners is running. Not only that, it is basically sending notifications from hello folder. This folder basically has every logic which you need to have in your channel.
00:23:44.502 - 00:24:27.394, Speaker A: So basically what happens is there's a channel TS file which has all the logic which you want to do. Over here it is just sending a dummy notification. The Jobs is basically a scheduler so you can basically call a particular function if you want via Jobs, Roots basically form your postman routes and what they do is they enable you to manually trigger some of the notifications. So right now we already have a route configured. I already have a postman over here. So my show run is running on port 5432. So I just go to that particular route and I just hit on Send.
00:24:27.394 - 00:25:14.594, Speaker A: Once I do that you can see in the debug that the notification has been sent and again, because we are screen sharing so you will not be able to see the notification but they are coming. But yeah, if you reload the DAP or if you go to the Chrome extension you can see it out. If it was not screen sharing it will be pushed out to your screen as well. So yeah, it's as easy as that to create a notification from a back end or a DAP. Again, we do support Smart contracts and you can go to Docs EPMs. IO to see that. So this is basically how you can send a notification out.
00:25:14.594 - 00:26:42.750, Speaker A: There's one more thing which I wanted to talk to you about which is basically how to include the notification on your interface. So over here we basically fold uniswap interface and we are going to use that to basically bootstrap everything from our front end SDK. One more thing which I wanted to point out was that in case you don't want to show the nurse then you do have back end SDK which again is the thing you can use to trigger the notification out the back end SDK in your JS logic. All you need to do is import the back end SDK, call SDK, send notification again you can find the entire thing like how to do it right over here you can go to backend SDK and you can set up the back end SDK and even understand what is happening. So yeah, moving on to the front end SDK so let's go for installation first. So while uniswap is loading, I do want to add our front end SDK into the uniswap interface. I can do that by the same uniswap and front end SDK.
00:26:42.750 - 00:27:42.210, Speaker A: So yeah, this is basically a port uniswap. Now I'm adding the front end SDK. Front end SDK basically allows you to do two things. First thing is it allows you to embed these notifications for your user. For exam that massively, massively improves the UX for the web3 user because webtree users are shared so when they come to your dab and they see all the notifications which they have opted and write inside your dab you basically make sure that their entire experience is massively improved. And the other thing front end SDK allows you to do is basically eliminate users going to app EPNS IO and opting into your channel. Instead of that, what you can do is just place that logic code right in your front end so the user can just go ahead and opt in to your channel and start receiving the notification.
00:27:42.210 - 00:28:52.738, Speaker A: I think the front end SDK is almost ready to be installed. I can open code as well just to get started. So a couple of things which we'll do because uniswap interface is a little finicky. So yeah, the first thing we'll do is we'll turn prettier off just because we don't want to be slowed down by missing a tab or missing entry key. The next thing we'll do is we will turn off the strict null checks. This is something which we are doing because this is something which we are doing because again we don't want strict null checks to stop or come in our way. And then one more added thing we'll do is because the EPNS front end SDK, it doesn't have a strict type right now.
00:28:52.738 - 00:30:06.350, Speaker A: So we are going to basically go and turn that off in the add liquidity section because that's where we are going to give our opt in and opt out button. So I'm just going to declare the module as a star just to make sure that it works well awesome. Hopefully everything is done right now so enslaper still works. All right, the next thing we need to do is we need to add our opt in button. By the way we do have a channel for Uniswap and that channel notifies every LP pool holder like when they're not earning the fees and that's why we chose to put the opt in on the ad liquidity. So over here I do have a hacky way which basically means that I do have a EPNS opt in file already created which I'm going to go and put it over here. It is nothing but ways to call the opt in on our protocol.
00:30:06.350 - 00:31:12.950, Speaker A: You can look into it in detail. We do also have this Uniswap depot front end hosted and also available as an example so you can go ahead and try it out. I think the example is not reflecting it right now. There it is apnsx Uniswap four three, four but yeah, coming back. So what are we doing over here is basically creating an opt in button and this opt in button is just calling channels opt in which is basically the same thing EIP seven one two sign thing sent to the push notes over here. Let me also come to index TSX. We basically need to import few things over here.
00:31:12.950 - 00:32:52.790, Speaker A: The first thing we need to import is Ebns opt in and I want to import it after Dots because Uniswap again has a lot of strict checking which also means know things needs to be in alphabetical order so that's why I've written it over here. So yeah, once we have imported EPN is often I also need to go to which line number am I going to think it's 538 because we already know where to put everything out. So I can go to line number 538, put this in in that row. So let me just put this EPNS opt in, it's react by the way in case anyone is wondering and then just do a row and of course we need to close it under tanks. Hopefully it will not give a lot of error. Okay, yeah. And yeah, if everything is working fine then now when we go to a new position you have an opt out or opt in button.
00:32:52.790 - 00:34:12.400, Speaker A: So an opt in and opt out button which will basically opt you in and out. The reason it was opt out was because we basically hard coded the channel address. This is not your channel address or the channel address that we just created. So basically if I change that then the opt in and opt out will work in a better way. Let's see. Okay, so the channel sometimes takes, I mean it takes sometimes to reflect on the front end but as long as you are pulling the channel out by typing it in you are able to do it. My channel, this is not channel I created, I've forgotten the name of the channel but yeah, in essence let's just put this channel only and yeah, okay.
00:34:12.400 - 00:35:34.246, Speaker A: All right, I think the speed run which I'm doing, I goofed up something or I forgot to include something out. So what I'll do is instead of the speedrun, I also have a repo or a test repo that is also public the EPNS unit swap front end SDK. So let's go over here and let's do a yarn start over here instead. So hopefully everything is installed so it will be very fast. So the last thing I wanted to show in this demo, like after the opt in button which basically improves your channel visibility. After that the bell icon which can basically pull all the notifications that a channel has. So to do that, what we simply did was we went to uniswap header which is under Components in header.
00:35:34.246 - 00:36:30.630, Speaker A: We created a bell icon because we wanted to create our EPNS bell. And after that we went to index TSX. We imported the bell icon and right after that first we first attached a divid. The dev ID is very important with the bell icon so that when the front end SDK is loaded, it can attach itself to this trigger ID. Right after that we basically created a use effect in which we imported account. Uniswap is based on web3 react, so we had access to the account. So we basically loaded that and then we just called embed SDK initialize along with the SDK trigger.
00:36:30.630 - 00:37:11.910, Speaker A: And what it does is after that whenever notifications are happening, you will be able to see it in the DAP as well, just like how you can see it right now. So yeah, that is basically everything about EPNS. Again, we do have the docs to get everything done. As I said, integrating on front end. We do have the Uniswap depot which you can basically go and check it out. It's actually in front end example and yeah, happy coding.
00:37:21.720 - 00:38:16.630, Speaker B: Hey there. In this video we are going to see how one can integrate EPNS to a subgraph and send notifications. If you're not familiar with subgraph, let me give a quick explanation. The graph is a decentralized protocol for indexing and querying data from blockchains. So if we want the graph to index and store some data from a blockchain, then we must define something called a subgraph and it is to this subgraph that we'll be integrating EPNS notifications. In this video I'll be doing each and every step of EPNS graph integration and the same example is also added to our documentation hub, which you can access by going to docs EPNS IO. Click on the Developer docs and under the examples section you can see notification via subgraph example.
00:38:16.630 - 00:38:56.916, Speaker B: All right, let's get started with the implementation. So the very first step is to create a notification channel. So in the prerequisites, the next step is to install the graph CLI. So let me copy this and install. All right, while that is getting installed, let's see what the next. Step is link your GitHub to the graph website. All right, this is because we are going to deploy the subgraph to the hosted service.
00:38:56.916 - 00:39:20.608, Speaker B: And for that we need to link your subgraph, link your GitHub ID to the graph platform. So let me sign in. All right, I have signed in and there is my dashboard. Here you can see all the subgraphs that you have created. And let's see what the next step is. Add a subgraph from your hosted service dashboard. And this is the dashboard.
00:39:20.608 - 00:40:25.660, Speaker B: And here there's an option to add subgraph. We can put subgraph name as to name cat graph, demo that's subtitle and let's create a subgraph. All right, now I think we are all done with the prerequisites. And the next step is to deploy the contract. Now, in this link there is a sample ERC 20 contract. We can just copy the contract code and deploy using remix create file. The contract name is Pushtoken pushtoken solve.
00:40:25.660 - 00:41:40.810, Speaker B: Let's paste the code and let's compile the contract. Let it's compile push token sol compilation is successful and let's deploy the contract. All right, let's select injector step three, COVID network. All right, select this wallet. All right, select the contract bush token and deploy and make sure you have the COVID to deploy the contract. All right, let's wait. Okay, let's view this on Ether scan.
00:41:40.810 - 00:41:59.370, Speaker B: All right, while this is getting deployed, we can look at the next step that's the contract deployment step is done. Next step is the subgraph deployment. So in this repo, there is an ERC 20 token subgraph. So you can basically clone this repo.
00:41:59.990 - 00:42:00.740, Speaker A: It.
00:42:11.430 - 00:42:45.322, Speaker B: Subgraph. I've already cloned this repo. I have this here ERC 22 concept graph. And let's see, we have subgraph YAML, and we have this address that basically is telling that the subgraph should index this contract. Now we should update it with the contract pushed, update it with the contract that we have deployed just now. Let's see whether it got confirmed. Yes, it is confirmed.
00:42:45.322 - 00:43:19.730, Speaker B: Then let's get the contract address. This is the contract that we need to index. So let's update it here. And here we have a schema GraphQL which basically says the structure in which the data is to be saved in the graph and inside the SRC folder we have mapping TS. Here is where all the handler functions are defined. Now, this is a subgraph without any integration. And let's see what the next step is.
00:43:19.730 - 00:44:02.564, Speaker B: So clone theoreppo and in subgraph for YAML, update the contract address which we did just now. And the next step is to do yarn install. Let's do that here. So here I'm already inside this folder. Let's do yarn install, which I've already done. And let's do graph code gen which generates the types. All right, graph code gen is done and let's authenticate.
00:44:02.564 - 00:45:36.994, Speaker B: Now, for this step, you need to get the access token from the dashboard. So copy this code graph product hosted service and copy the access token from here from your dashboard. All right, authentication is done, and the next step is to deploy the subgraph. Now here we need the GitHub username and subgraph name. So let me copy this graph deploy product hosted service and subgraph name is the Slug graph demo. And so this last two part will be what I need to copy ashwajwalta graph demo all right, compiling. Deploy moment is done.
00:45:36.994 - 00:46:31.906, Speaker B: And let's check here whether it started syncing with the chain. So we can see that the graph demo subgraph is deployed and it's syncing 100%. Now we can start with the integration. So for the integration, the first step is in the Schema GraphQL include the following EPNS schema so we have two EPNS schema types EPNS notification count and push PNS push notification. Let's copy this code and add to the schema GraphQL file. All right, once that is done, in mapping TS, export the subgraph ID. So copy it and inside SRC mapping TS export subgraph ID.
00:46:31.906 - 00:48:08.430, Speaker B: So subgraph ID is basically GitHub username subgraph name. And for this subgraph that we just deployed, the subgraph name is graph demo graph demo all right, inside as you folder, create a file EPNS notification TS. All right, now this basically will act as the EPNS helper file. So let me create Epnsmenification TS, all right? And copy and paste the help of file code from here. All right, let's copy this helper file code. Paste it here's in mapping TS, import the helper file steps by six and seven within the respective handler functions from which the notification needs to be sent. Now here in mapping TS, we have this handler function which is handle transfer.
00:48:08.430 - 00:48:54.680, Speaker B: Now, we basically want to send notification whenever a wallet receives push token. So it is in this handler function that we need to send the notification. So here we can define these payload items such as recipient type, title body, subject message, image, secret, CTA. So this has already been defined the way that I want it. So let me copy the same things here towards at the end of the function. All right, so here the type represents the type of notification that we are sending. So it says three.
00:48:54.680 - 00:49:56.890, Speaker B: That means it's a targeted notification, which means that this notification is to be sent to this particular recipient. And there are a few other types of notification that EPNS supports, such as broadcast notification, which is to send out to all the subscribers of a channel and subset notification, which is to a specific set of wallet addresses. So, yeah, you can refer those in the documentation and we have title, body, all these things. You can customize it the way you want. And once you have defined the payload items, you can define the notification in this format notification. And once all of these things are defined, we can call the helper function. And helper function takes in two arguments one is recipient and the other one is notification.
00:49:56.890 - 00:51:31.940, Speaker B: All right. And these are all the code changes that is required for EPNS integration. Now that we are done with the code changes, let's deploy the subgraph again. So we do graph quadrant. We can do authenticate it's deploying it's loading to APSS deploying. All right, let's look at the hosted service yes, deployed few seconds ago. And let's see if we can see the EPNS notification types.
00:51:31.940 - 00:52:49.820, Speaker B: See earlier, these two types were not there. Since they have added those two types EPNS Notification founder EPNS push Notification we can basically check it from the playground first notification whether the contract is the same. So even with the contract creation itself, it basically send all the tokens to the address. So that's why this notification is there. Let's see what the next step is. So now, once we're done with this subgraph deployment, there's one more step that is left that is linking subgraph to the EPNS notification channel. Now, let's go back to the channel that we created earlier and see if we can see it.
00:52:49.820 - 00:54:43.618, Speaker B: All right, it is created graph demo. That means we'll be able to see it in the channel list. Yes. Graph demo is here. And this is the channel owner and we want to test it. So let's add this contract, this token MetaMask send it it's wallet transaction. All right, we sent tokens to another wallet.
00:54:43.618 - 00:55:11.280, Speaker B: Now let's go back to the remaining step that we wanted to do. All right, so this is the channel owner. This is the channel dashboard. Yeah. And here in settings you can see add subgraph details. Now, it is in this form that we need to fill the subgraph details. Now, the subgraph ID is your GitHub name.
00:55:11.280 - 00:55:40.860, Speaker B: Subgraph name which you can see from here. Shaywalta slash graph demo. All right. And pull time. Pull time in seconds. So if you enter like 60 seconds as poll time, that means in every 60 seconds, the push nodes will ping the subgraph and see if there is any pending notifications that need to be sent out. Now, that's how the poll time works.
00:55:40.860 - 00:56:47.570, Speaker B: All right. Once you add it, it is an on chain transaction. So make sure you have the ETH confirm the transaction. All right. All right, let's reload and see. So this is the subgraph owner and the contract owner. And this wallet basically received the tokens and it should basically get the tokens or else we can write now do a transaction.
00:56:47.570 - 00:58:11.510, Speaker B: Let me send hundred push notification. All right, that is done. Let's switch to that wallet and wait for 50 seconds. Yeah, this is the notification from before. That is when I transferred 500 push. Now I've transferred 100 more push. So let's wait for the notification.
00:58:11.510 - 00:58:46.396, Speaker B: And here it shows delivered by Articraft. So right now these notifications are shown in the spam folder. Because this wallet has not opted into their channel to receive notifications yet. So that is why there is an opt in option. So if I opt in, then I'll basically get the notifications in the inbox. All right, so here we have two notifications. One from the transfer before 500 push.
00:58:46.396 - 00:58:57.872, Speaker B: And here, right now, we did 100 push transfer. That's why we have the notification. That's all. That's all I wanted to do for this demo. Happy learning. Bye.
00:58:57.936 - 00:59:21.380, Speaker A: We do have push dance program with a 1 million USD. So, idea is, once you build cool things over here, that's not the end. You can start or you can carry on with the push scan program. We also have some build ideas in the Medium blog. You can scan this and it will take you directly to the Medium blog. Also, you can go to docs. EPNS.
00:59:21.380 - 00:59:30.430, Speaker A: IO to start your developer journey. And yeah, one last thing. This is our disc QR code in case you guys want to go over here.
