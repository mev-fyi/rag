00:00:05.330 - 00:00:19.094, Speaker A: You. Okay guys, I believe it's nice to see you again and I believe introduction earlier. However, I miss the most important part.
00:00:19.132 - 00:00:19.960, Speaker B: Which is.
00:00:22.330 - 00:02:12.854, Speaker A: Now I'll make a more detailed introduction about how Texan network design and how can you build application on Texas Network basically in this hackathon. Okay, so as you know, Texa Network is a middleware infrastructure and although there are many L2 projects and we are not aiming specifically aiming on scalability, but we more focus on the vertical performance and privacy of individual smart contracts. And there are different kind of L2 and some are focused on scaling solutions which are actually solving the problem, helping layer one to solve their problem. And however, some L2 they focus on achieving something that layer one really very difficult to achieve such as privacy or like a story aiming to provide high performance and also privacy delivery and business audits. And if you imagine DF like a traditional centralized service, the role of Texas Network is more like the back end. Just like the back end, you will not always generate a database transaction after after each variable change on the back end. Likewise, you don't need to always generate more introduction about the applications on hexa network.
00:02:12.854 - 00:03:20.622, Speaker A: So the application running on Hexa network, we call it a T service which is in short for trustless service. It's similar for smart contracts. T service is Trustless which means the integrity of the code and the data are guaranteed. And what's different is we also guarantee the confidentiality and we use a very different technology from their one blockchain. There are three aspects of security availability, integrity and confidentiality. So basically their one blockchain sacrifice confidentiality to achieve availability and integrity by letting every single node running the same thing higher, sacrifice performance and also confidentiality. And when you are viewing off blockchain you want to also guarantee integrity, you need some very different technology than blockchain which is trusted computing and specifically we are using the hardware based trusted executing environment engineering wise.
00:03:20.622 - 00:04:30.486, Speaker A: We're currently using Etijx and I believe many of you already heard of it. And the feature of Q zero is first Tesla network is not a layer one blockchain. So we are stateless and that means we don't permanently store the state equally money connection and whenever you need it, you will need to generate a layer one connection. And also we are based on request response protocol and also we support Restful interface and also different from and we also provide very good privacy which is guaranteed by hardware PE and the privacy is opt out, which means all the data are private by default, which is invisible even to the node operator. And unless the developer intentionally discloses and some more details. First is the UIL. I'll introduce some important concepts.
00:04:30.486 - 00:05:18.434, Speaker A: First is UIL. UIL is the entrance of the service which includes two parts. First part is a unique identity, we call it App ID which is you can see the link and the part is beginning with QS. This one is multi hash and IPFS compatible and we exactly use shell 256 so it looks very similar. And the later part is function. So each T service will contain multiple functions and all those functions could act as the entrance of request. The user will be able to submit a request to a URL and the URL will give them response.
00:05:18.434 - 00:06:32.430, Speaker A: And the request as you can see, is in a JSON format which will provide more detail in our documents. And also you can carry privacy data which is encrypted with AES. And the only one who can depurpose your request is hardware te inside the node. And what about our developer requirement? And we support a full Python development stack from the low level interpreter to the runtime and the runtime libraries and up to the application level framework which you can see if you write a blast. And you'll be able to pipe a rock to mapping a URL request to a certain Python function. And the user will be able to use the request to send their private data and we will use response to return the result. So, this is a very basic mainliner problem, which is two step protocol.
00:06:32.430 - 00:07:20.910, Speaker A: Two people don't trust each other and they want to each submit a confidential member and we will tell them whose member is larger. And so basically, two parties will submit value. And most importantly, there's a feature called Session. That means Session is temporary storage with support inside e. It's not permanent and the developer are not supposed to store permanent data using that. For now, it will be per developer building and developer should not assume that it will always exist and backup just like a mechanism. First submit, then reveal.
00:07:20.910 - 00:08:15.286, Speaker A: And as a kit framework we provided Python which is first for Python. It's a Python runtime and we're currently web based on Python 2.7 and we know Python Two is going to very soon. And we'll also be adding the Python parties also in our pipeline. And one advantage of using Python is we value feature even more than performance. A big advantage of Python is it supports a lot of third party libraries including crypto, mathematics, modeling, and also we support a series of channels to communicate with their one. And this is one example of communicating with AirWatch.
00:08:15.286 - 00:09:21.320, Speaker A: Let me give you example. So suppose two people are playing a game, maybe black guy. So first each user could generate a pair of keys, could be hash or the public and private key or hash and the plain text and the PE the hardware, you can actually put your secret information inside it. So you can give the private key, send the private key inside a request. And so the hardware anthology is the only party in the world other than the user who has the private key. And you put your public key to a smart contract on public blockchain it's a commit and reveal protocol. That means, for example, I'm playing a game with another guy and we first both submit a transaction on a wallet contract, which indicates that, for example, I'm willing to lose one user if I lose the game.
00:09:21.320 - 00:11:11.114, Speaker A: And then I put my public key into inside a certain function ethernet contract and whoever gives the correct signature or give the correct hash plaintext will be able to unlock a transaction. And then in your T service, whoever wins, you can let the T service to sign using the counterparties private key sign magic or just disclose the plain text of a hack and then whoever has the hack will be able to unlock the password practice money. So this is basically reveal procedure, basically what you need is the public encryption or the head function we support it in the hardware applet and also you need to write unlock smart contract and if you have any questions on building this part just let us know and we'll give you some technical support and about the features. So, technical network running on L2 has this unique advantage and also has some differences. So first, because there's no constraint on consensus mechanism, and also we have te technology, that means you can build some high performance business logic with very abundant time and space resources. So eventually our minet will enlarge, we will allow 32 megabytes of the request data per call. And also the developer has set a timeout and also there's very low response latency because there's no confirmation needed.
00:11:11.114 - 00:12:19.022, Speaker A: And also he will guarantee the configuration. And we'll keep expanding our contract engine, adding more library support inside our Python runtime. And also we are blockchain agnostic, as long as you can deploy the contract on a certain blockchain, we'll support many different blockchain infrastructures and the application some interesting possibilities. So, for example, the game some games are very difficult to build on. Layer one, for example, card game, maybe you can even build chat games with information transparency. Like if you want to build some multiplayer game with information. Asynchronous you can take members of the choice and also, like I gave another example is two people exchange their private contact list.
00:12:19.022 - 00:13:20.846, Speaker A: For example, I want to see what are the mutual connections between me and the other guy. But we don't want to reveal our detailed contact list. That is another possibility. And also, beyond blocking, we also have some business use case such as collaborative computation. Okay. And now we will briefly demo you the whole procedure of using the TV and test your T services. First because you will need a hardware T environment to develop your code in the hackathon we configured six nodes with full T support so we can only allow six teams to develop their project on Texa network.
00:13:20.846 - 00:14:48.378, Speaker A: And so we are having application link and please submit your idea and retain information and we'll later send you the developer document and also our support channel. I'll briefly introduce how the Te works and how to communicate with the Tesla developer. Okay, actually I like whiteboard more. So the key concept of Te is you can run some code and computation, you can let someone you don't trust to process your private data and you can guarantee your data won't leak and you can also guarantee the computation is cracked. So if I use one word to express the solution which is isolation. So G is achieved by isolation and basically E is achieved by establishing hardware isolated environment inside a node. Go to the node and all the computations are processed in a hardware isolating environment.
00:14:48.378 - 00:16:07.670, Speaker A: Even the nodes don't have access to it's. Just like if we compare the node to a room and the T the hardware environment is a locker inside that room and even the owner of the room don't have any access to anything happening inside the environment. So isolation is how we guarantee the integrity of our how the user put his secret data inside without liking the node receive it. So there's a protocol very similar to PLSL, it's a handshake and a key change. So both the user and PE will have public and credit key pair and they will do a DG helmet key change and yeah, you basically only need to know the concept because they have zero material library to achieve it. And you may also want to ask how does the user know he's communicating with the te not the emulator or fake environment? Well it's just like how do you know you are communicating to Google? There's a CA so that's the only fault assumption. If you are using te there's a service called IAS Intel as they can survey intel will tell you whether the chip is legit.
00:16:07.670 - 00:16:48.326, Speaker A: This is the only trust assumptions. The protocol is like, the user ask is, hey, I want to attach one on the chip. And the service will say, okay, random number. And so it's very similar to and then the user sends the signature to Is. And is will say, okay, so they can change the temperature. And then the most important part is the Google key change. And both parties will have know, just like in SSL or TLS, you first use your public key.
00:16:48.326 - 00:17:32.450, Speaker A: And private key to do a key change and afterwards you change the symmetric key which is the user will negotiate. And there are only two copies existing the world. One belongs to the user, another belongs to the de environment. Afterwards they can communicate anything just critical with ASP that's a basic attendation and communication protocol and other things you can forward the request using anyway using any method you like. You can even just deploy a node JS and lap the process and forward I just want to clarify that the.
00:17:32.600 - 00:17:39.080, Speaker B: Key is isolated to the actual key instance itself and not anyone else outside of that, right?
00:17:40.890 - 00:21:16.550, Speaker A: Yes so basically when I do a key change and the last step is you want to avoid just using public and the user will decide AFP and using the channel to send it to the key so they both have AIP and nobody else in the world has it. Yeah here are four steps first you will have data and second you will generate your request after test agent the user will have an EIP and you encrypt your request using the EIP and then it's just like a web service you send your JSON to the server response and then you decrypt that response it's like encrypted. Here's a simple demo so first left window and right window are client and server and we are running this on a debugging node which is required when you are debugging and the client will generate identity and then we start the test data. So the server will launch the process using binary which is the server is ready for a test data and then the user, the client will connect to the server and handship it and we already package this feature inside our service application so testing and beginning so the testing result shows the testing result shows intel says 200 that means user conversation and there's another important part the Mr unplay this is a hash indicating what kind of code is being executed inside the PE. So basically it's a signature or it's actually a hash to the memory pages of the hardware isolated memory because the memory side of the computer has very strong consistency. So suppose there are two computers, their memory are similar to every byte and their execution result will be also totally the same. So that means if the MRN plate hash is similar you can guarantee it's running how you desire and after a testation you can start to send it first this is a piece of code you can see we will test out a row and in here we test the second feature basically we change some seconds and also we do some basic before decoding some random encoding and we also display user request parameter and afterwards we already provided a certain script and the user can encrypt that request.
00:21:16.550 - 00:23:13.620, Speaker A: Let me show the encrypted looks like okay. And you can see this part is a encrypted request and the request compile the the request consists of certain parts such as a function name and also the impressive data and the code is often known because hexa nodes are stateless. So on protocol wise the user is to post the entire code they would like to the node and the node will also verify whether it matches the hack in the URL because if the hack of the code are the same, the code must be the same. But engineer wise you don't have to carry the code every time because engineer wise, our node will catch up our existing code, especially those frequent activity ones. And after the user encrypted the request and the response you can see on the right side it also contains base 64 and AF is encrypted response which is first encrypted by the AFP side and then base 64. And we also have a very lightweight HTP service on the node allows red for API call by changing the encrypted response and request value mainly on the debugging node. Or you can implement any architecture you like and the user can just decrypt the request using his as key.
00:23:13.620 - 00:24:37.090, Speaker A: We also have a script for that and here you can see the results. So basically the user has modified session for the yeah this is like a Howard level demo about how to debug our development and so basically you know what Pser is to do that piece of it is dataless. It cannot permanently store the state so you must communicate with their ones if you need to permanently store something. And Pseudo has very good performance, especially on the vertical performance data processing capability and although we have very rich budgets and very developer friendly framework and yeah. And for every team who demoed completed, ready to go as allocation will reward 3000 to up to 16 and for the most competitive one we have additional yes. So please submit right here. Or if you would like to discuss with us, we are very welcome.
00:24:37.090 - 00:24:52.668, Speaker A: We are actually at the corner of the hacking place. Yeah so you are always welcome to come and discuss your idea with us and any questions please.
00:24:52.854 - 00:25:06.250, Speaker B: So I think in most cases a Te might be overkill for a wallet, a standard wallet. So would Coinbase be like storing our private keys in a Te or is it?
00:25:07.100 - 00:26:28.660, Speaker A: That's a good question. Personally I don't know whether what technology Coinbase uses but what I can tell you is that Te is very widely used. Very widely used and it's definitely not specifically designed for blocking. For example, each of you have some key. For example the part that Verifies fingerprints it isolated the whole story verifying product inside the hardware hyper it only tells developer yes or no but developer has no access to hardware. But Intel SGX is actually more focused on developability and computation general public computation which provides a lot of possibilities actually Intel SGX is more specifically designed for cloud computing for land of vendors keep the users privacy. Yeah so I don't know how some may explore their Tea, but what I can tell you is Tea is very widely used to handle private data and definitely doable to handle to process private key and also other kind of mobile device devices usually do this kind of key management.
00:26:30.120 - 00:26:41.204, Speaker B: I mean in theory whenever someone asks you to put that twelve word passcode you don't have the secret, you store it on your computer. That's dangerous.
00:26:41.252 - 00:26:41.416, Speaker A: Right?
00:26:41.438 - 00:26:43.784, Speaker B: So in theory, you should probably use.
00:26:43.982 - 00:26:46.308, Speaker A: Actually the hardware wallet.
00:26:46.404 - 00:26:47.050, Speaker B: Yeah.
00:26:48.940 - 00:26:52.490, Speaker A: Just for different purposes. They are more focused on isolating itself.
00:27:00.000 - 00:27:02.704, Speaker B: If two people want to schedule an appointment, but they don't want to share.
00:27:02.742 - 00:27:04.352, Speaker A: The calendars with each other, they both.
00:27:04.406 - 00:27:09.920, Speaker B: Individually send out their calendars to figure out the best place they should meet.
00:27:10.070 - 00:28:08.412, Speaker A: Yeah, exactly. The case you talked about is a very architect of PFR private setting, which means that two parties don't trust each other and they want to find and I believe those also cause there's an old problem why they're satellite but they don't want to be they definitely cannot solve the exact work of their satellite. Yeah, so basically that's and a very elegant solution. Definitely doable in many cases because you don't have any access control. Suppose later I got another contact, I can immediately verify whether in your contact you are using. Example contact? Private contact. Yes.
00:28:08.412 - 00:29:51.330, Speaker A: If you're using head, you don't have access control. However, in our case, you can just let the key to generate we do have the mathematics leverage to generate and using that key is encrypted all your both parties privately and if your plaintext are the same, your cyber tax will also be the same. You just compare the cyber tax and then send the cyber tax back to decrease. I'm not sure if I explained the clear enough. So basically what you can do is you generate say you generate key that normally and the key will the key will using K one to encrypt the both of their input. And then they just compare the and then the two users. The two users will compare their encrypted and find the going back and then send the encrypted data back to so that guarantees nobody's more, much more secure than using hash because we got very good any other questions? Okay.
00:29:51.330 - 00:30:03.700, Speaker A: If you have any questions, feel free to go to our books and just record this. Submit your idea.
00:30:07.910 - 00:30:12.558, Speaker B: I'm getting a permission error on the Google doc.
00:30:12.734 - 00:30:13.170, Speaker A: What?
00:30:13.240 - 00:30:16.490, Speaker B: I'm getting a permission error on that one. Mama.
00:30:34.430 - 00:30:35.530, Speaker A: Give a chocolate.
00:30:40.110 - 00:30:41.810, Speaker B: Pepper by so.
00:30:41.960 - 00:31:05.470, Speaker A: Ten kicking around ten will be retired. You always will have those are boosted to yeah, representative.
