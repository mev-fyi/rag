00:00:09.830 - 00:01:08.620, Speaker A: Yeah. So I'm going to talk about the Arbitrum SDK. So Arbitrum is a layer two scaling platform that my company, Offchain Labs, is building to enhance the scalability of Ethereum. And kind of the fundamental goal is just to unlock the power of DApps to make it that Ethereum has a lot of limited limitations in place in terms of kind of what's feasible to actually do on the blockchain in terms of expense, in terms of capacity, from a lot of perspectives. And the goal is basically to get around those limitations and unlock a lot of cool potential. So why does Ethereum itself not work? Well, kind of fundamentally, it's a network where every single miner has to execute every single contract and so there's no way to really scale it up. Adding more nodes doesn't help because they all have to do the same work.
00:01:08.620 - 00:02:33.880, Speaker A: You have to have kind of a limited capacity because everybody has to be able to verify everything. And that leads to a need to have gas costs and gas limits and so imposing kind of significant transaction fees on users which are kind of a significant adoption barrier and kind of rule out a lot of applications where users wouldn't want to pay kind of a significant fee when the network gets more usage and reaches capacity, which kind? Of happens when some random company is doing a token giveaway and suddenly gas fees go through the roof. Which is not good if you have a legitimate application. And additionally all contact code and data is public. And so fundamentally, kind of if your application you don't like the idea of everybody in the world being able to see everything that you're doing, then you have a tough time using a totally public smart contract platform. And so Arbitrum, I think, gets around a lot of these limitations and it does it without sacrificing security at all, which is really great because we can kind of keep the same major advantages that Ethereum has while just removing disadvantages. And so Arbitrum provides a way, rather than having all of your contract execution on chain you can instead have the scripts run off chain while still having security.
00:02:33.880 - 00:03:24.070, Speaker A: And I'll talk a little bit about how we do that and later this afternoon my co founder Ed Felton is going to be giving a technical talk about Arbitrum that will go into a lot more detail of how we accomplish that. But kind of fundamentally what it comes down to is rather than executing all your code on the blockchain directly on Ethereum, what you want to do is you want to execute most of the time off chain because most of the time people are happy and people will agree. But when there's a dispute you want to be able to settle it on chain and you want to be able to do so efficiently. And that's essentially what Arbitrum accomplishes. And we do it in a way that you can just use your existing solidity contracts. There's nothing really new to learn. There are a few tools that you have to use but fundamentally kind of one of our goals is to essentially have as low a learning curve as possible.
00:03:24.070 - 00:04:14.274, Speaker A: There are a lot of layer two solutions out there and fundamentally a lot of them are pretty hard to figure out how to use. And so making adoption easy is really valuable. And so Arbitrum does this through kind of a combination of pretty reasonable tools. So we have a sophisticated protocol that essentially makes sure that you can run your contract off chain securely. We have incentive mechanisms in place to make sure that the parties to your contract actually operate the way they should. And we have a custom virtual machine architecture that is optimized for this off chain context since essentially running a contract off chain is pretty different than running it on chain and the things you care about are different and we've optimized a lot for that. So kind of the fundamental concept that Arbitrum uses to make things fast is this idea of validators.
00:04:14.274 - 00:05:10.054, Speaker A: And so when you spawn a contract for Arbitrum you specify a list of validators for it and they're the only ones who have to run this contract. And the really cool thing that Arbitrum provides is if any single one of these people are honest then it'll run correctly, which is kind of nuts. I mean, essentially kind of normal systems. You require kind of two thirds of people to be honest or at best half of people to be honest in terms of kind of for Ethereum or for Bitcoin. If more than 50% of the hash power is malicious, your system's totally broken. Whereas with Arbitrum you only need kind of a single one of these validators to operate correctly along with having the Ethereum blockchain itself operating correctly of course, but providing a lot of scaling on top of that. And so essentially what the validators do is most of the time they just unanimously agree as to what the next step is and they run the execution locally and they're the only ones who have to.
00:05:10.054 - 00:06:06.102, Speaker A: And 99.99% of the time they're all friends and nobody's going to cheat and everybody's going to be friendly and you're going to be able to execute instantly off chain and your transactions are going to be final immediately. So you don't need to wait for the two or three minutes or whatever it is where your transaction is pending waiting confirmations on Ethereum which is kind of a horrible user experience and instead you get kind of that security instantly. So where we are today so there's a public alpha of Arbitrum that's usable today. It's a system of kind of smart contracts along with node software that runs alongside Ethereum and on top of Ethereum. In order to enhance it. We support running existing solidity contracts on Arbitrum which means that kind of the learning curve is very low and those contracts can send to receive ETH or any other or any token.
00:06:06.102 - 00:06:52.410, Speaker A: Which means that this off chain solution is still interoperable with all of the great on chain things. So a little bit about kind of what Arbitrum looks like from a technical perspective. So essentially kind of the process of using Arbitrum is reasonably straightforward. So you start with a solidity smart contract and you compile it down into a virtual machine just by kind of running the compiler. And the main way we support this right now is just as a plugin to Truffle. You then distribute this machine to all of the validators. They make a call to an on chain smart contract in order to create this virtual machine or this contract.
00:06:52.410 - 00:07:24.100, Speaker A: And then they just function offline passing messages between each other. And so the blockchain is involved in that. It's kind of tracking the metadata for this contract, but everything else happens efficiently and securely off chain. So that's essentially what the deployment side of things look like. And the other side of things then is the front end. So how do you actually write applications that talk to an Arbitrum contract? It's off chain, it's not a regular contract on the blockchain. How weird is the experience of building on it? Well, it turns out it's actually really easy.
00:07:24.100 - 00:08:37.100, Speaker A: That kind of fundamentally an awesome thing about how Ethereum Tech has developed is that all of our front end interfaces, so Web Three and Ethers being the main JavaScript ones, and then there being kind of others in other languages, are super pluggable. And so essentially what we give you is we give you an Arbitrum provider package that just plugs into your existing front end and kind of instantly ports it to instead working with an off chain Arbitrum contract. So just to give you an idea, just to give you an idea of how easy this is, I'm going to walk through just kind of a quick example of how this porting process looks. So I'm just going to start out on our developer Quickstart which provides instructions for getting all this stuff set up. And I'm going to start with just an existing solidity DAP with an existing front end that's just kind of totally standard, unmodified and I'm going to walk through the process of modifying it. And so let's do that. I'm going to make sure everything is nice and big so it will show up.
00:08:37.100 - 00:09:30.810, Speaker A: And the goal of this is basically just to demonstrate that this stuff is totally easy to use. The bar to taking advantage of these advances is very low. So I've already gone through the setup. I'm not going to walk through that here because installation and dependencies and stuff is boring, but it's all laid out there. But I'm going to start with our porting guide. So we support any Truffle based project, any front end using Web Three or Ethers and kind of as long as you're, as long as your DAP has kind of some sort of reasonable build system, which kind of basically everybody does if you're doing anything that has any complexity whatsoever. And so I'm going to demonstrate this out on just like a fun little Connect Four application.
00:09:30.810 - 00:09:57.990, Speaker A: So betting on and playing Connect Four on the blockchain, it's a horrible idea. Don't actually do this because other people will just use bots and you'll always lose. But it makes a really fun example and it works well if you're playing with friends who you trust not to cheat. And it looks cool. So it's a fun little demo. So to start out, the first thing we need to do is we need to work on that back end component. We need to make sure it actually compiles.
00:09:57.990 - 00:10:54.980, Speaker A: And so the thing to do there, I'm going to open up here is the code for our Connect Four DAP. And the first thing to do is actually get it hooked into Truffle. So normally with Truffle you deploy on Hsnet, or you deploy on main net or you deploy on Ganache. And so what we're adding in is to deploy on Arbitrum. And so I am just going to copy and paste this somewhat ugly blob of code from our developer Quickstart, which I can just immediately post into my Truffle config and slot that in. And then all I need to do and then the next thing I need to do is I actually this, sorry, I'm jumping around a little. This depends on this ARB provider package that we provide.
00:10:54.980 - 00:11:19.340, Speaker A: And so I am going to add that as an import and I am going to add that dependency, which is currently not working. Let's see.
00:11:21.390 - 00:11:22.900, Speaker B: Let it.
00:11:24.710 - 00:12:12.678, Speaker A: Say that again. Yeah, it should be picking it up locally. I'm just going to skip that step because I don't actually need to use it because I already pre compiled this stuff. But just interesting. Yeah. So essentially the first step, and I'm going to go through these instructions, it will work, but essentially the first step is to plug into and compile with Truffle. And so the fundamental idea there is we provide this kind of Arbitrum network backend and then all you need to do is run Truffle migrate.
00:12:12.678 - 00:13:14.618, Speaker A: And instead of specifying kind of production or testnet, you instead specify that it should deploy on Arbitrum. And essentially what that does is it pops out this lovely file which is navigating to the project contract AO. And so essentially what that is, is kind of rather than the Truffle migrate actually deploying on a network, it just pops out this little file which is like, this is your contract. And so this is the thing that needs to be distributed to all of the validators. And so essentially, kind of once you have created that, the back end is all set and now you just need to deploy. So for the purposes of our alpha, we've made the deployment super automated because when you're in alpha and you're testing, it's nice to have everything automated in one click. And so we provide this tool, ARB deploy.
00:13:14.618 - 00:13:57.578, Speaker A: And essentially what that does is it launches in docker a local Ganache instance to run a blockchain. It launches however many validators you specify. So here I say to specify to launch three validators for your application and we specify the contract file that we're using. And so you've kind of fed it kind of the only two parameters that matter are how many validators and what the code they're going to be running. And you run ARB deploy and that launches everything. And so that one should work well. And a lot of flashing text goes by.
00:13:57.578 - 00:14:58.240, Speaker A: This essentially goes through the process of deploying Arbitrum, which involves kind of compiling all of the components, launching them locally. It does essentially everything that you would otherwise kind of do amongst multiple computers. And it also does kind of the deployment of the kind of on chain Arbitrum contracts which once we're live on testnet, will just already be there for you. But this essentially provides you a totally self contained environment to work within, which is great for testing, where you just want kind of a one click setup that will launch your DAP without you needing to do any work. So that is the back end component and that is kind of from my slide. What we've done just to recap is that and I didn't do this live, but I've compiled it with Truffle to output an AVM program. I've launched the validators and the ETH Bridge, which is our on chain contract, which manages your off chain Arbitrum contract and tracks metadata for it.
00:14:58.240 - 00:16:01.740, Speaker A: And all of these parties are now in communication and are running our contract. So the next step, and I think just for ease, I am going to actually just grab my modified version. And so the next thing to do is we want to modify the front end to get it working. And so that's very easy. So essentially, kind of if you have an existing DAP, and in this case we're going to use Web Three, it will have code which will set up the Web Three provider. And so it'll set up essentially whatever your connection is to the blockchain. And so a lot of the times if you're setting it up to work with MetaMask, then it'll grab the provider object from MetaMask.
00:16:01.740 - 00:17:00.400, Speaker A: And kind of the big thing that we change with Arbitrum is that we add this ARP provider. And so instead of directly creating a Web Three provider, you instead pass essentially your connection to the ethereum blockchain into this second layer provider. So much like Arbitrum is kind of a layer two solution on top of ethereum. The way we communicate with the blockchain is essentially by wrapping what you would normally do with the blockchain inside of kind of our higher level provider, which has the ability to do a lot of kind of what you want to do off chain. And that is it. And so essentially, kind of the only changes we've had to make are we modified the Truffle network that we're deploying to in order to produce our compiled contract. We modified the Web Three provider on the front end in order to talk to our Validator rather than to talk to the Ethereum blockchain.
00:17:00.400 - 00:17:54.252, Speaker A: And I used ARB deploy in order to spawn Validators for this contract. And that's essentially the entirety of the modifications necessary. So then we will see if this works or not. This should be fun. So I just essentially launched the web server for my DAP and this is just running kind of the code modified in these very simple ways if we go to it. So we're going to start out I'm running it locally but I'm just running with kind of a normal MetaMask instance that's connected to Ganache running on my machine and the code's been modified to use the correct provider. And so the goal here is essentially that it will not look any different than if you were using a normal contract.
00:17:54.252 - 00:18:30.844, Speaker A: And that's really the dream of layer two is to kind of have the experience be kind of exactly the same as if you were kind of using standard Ethereum. And so I can make transactions when they're transactions that are involving payment they're made on chain. And so those look fairly standard. But the trick is once I start actually playing the game, I'm no longer going to be making any on chain transactions. These are going to be completely off chain. And so if you see here, I'm not actually going to pay at all. I'm just signing something.
00:18:30.844 - 00:19:02.932, Speaker A: And so there are no fees whatsoever. And so I sign this message and it accomplishes essentially what would be accomplished in kind of a normal Ethereum contract on chain without touching the blockchain at all. And it does it without any decrease in security and with next to no modifications to your DAP. And that's kind of the magic of Arbitrum. And this is kind of the entirety of the changes that I made. And I was just playing around with this last night. So this is the entire diff.
00:19:02.932 - 00:19:50.230, Speaker A: It might be a little hard to read but essentially so we have the modification to Truffle. We add a couple of dependencies and we add that provider and that's it. And then you're up and running and you have an infinitely better experience than using Ethereum directly in terms of latency, in terms of cost and in terms of kind of capacity and complexity of what you can do in your contracts. Yeah, so that's I think about what I have prepared, this is all live and totally usable. We kind of have our Alpha two out. We should be on testnet in a couple of months and then live on main net, hopefully some point early next year. It works pretty well.
00:19:50.230 - 00:20:28.210, Speaker A: And yeah, there's an API prize also. So if you're interested you should definitely try it out. There's a lot of cool stuff you can build on it. So yeah, thanks for listening. I think I have a couple of minutes if there are any questions. Right, so, I mean, essentially the idea is that and kind of what it comes down to is transactions that involve sending or receiving money still need to be on chain. But any transaction that kind of just mutates the state of your contract internally, which like in the example of a game would be kind of all of the moves in the game.
00:20:28.210 - 00:20:45.080, Speaker A: Or if there's a contract with trading, if people deposit their money in first and then they can do kind of arbitrary trading kind of within the contract. And all of that can be completely gasless. All of that can just be kind of sent off chain but with the same security of an on chain transaction.
00:20:50.360 - 00:20:53.380, Speaker B: Is the virtual machine?
00:20:57.400 - 00:21:38.420, Speaker A: Yes, somewhat. So the big and on our developer website we have like a section which is kind of solidity things we don't support, the main thing of which is kind of direct synchronous calls. So this is kind of an interesting thing. If you're operating in an off chain context, you can't directly call into an on chain contract and have it execute immediately. So that's essentially the main restriction. So if you have kind of a DAP that is made up of a bundle of contracts, they can be launched together and communicate synchronously, no problem. So the issue essentially comes up with integrations with other DApps.
00:21:38.420 - 00:21:55.450, Speaker A: We're working on a number of solutions. Fundamentally it comes down to you can make calls to them and receive calls, but you can't actually have the result immediately. So it's doable. But it's definitely kind of on the research side of things.
00:21:57.660 - 00:22:25.148, Speaker B: So I apologize for showing up. So one of the traditionally hard problems associated with players is like what do you do if, say, I come online and then party two comes online and I make my move but party two just drops? What do you do in that case? Is it like the developers problem around that or do you guys have some solution?
00:22:25.324 - 00:23:07.116, Speaker A: Right, yeah, no, it's a good question. I'll give a short answer and then my co founder Ed Fountain is giving a talk at I want to say two, but you should check your calendar if you're interested and he'll dig much more into the details. The fundamental problem so there is no fully general solution. So essentially the biggest thing that we can provide is that as long as a single validator is still running, people can make calls to your contract. And so you don't need kind of everybody to participate. Fundamentally, if your contract is coded that it can't make progress. If you're waiting for a move, then you need to have a timeout or something.
00:23:07.116 - 00:23:23.590, Speaker A: But kind of the best we can do, and it really is a big thing, is make it so that even if all the other validators disappear, you can still make calls to the contract. You could still execute whatever function you want and it'll execute correctly. So that's kind of where we fall on that.
00:23:25.320 - 00:23:37.508, Speaker B: If Validators are assumed, validators hold a private key which binds your address, and then you kind of encoded in contract.
00:23:37.604 - 00:23:38.250, Speaker A: Yeah.
00:23:39.740 - 00:23:47.820, Speaker B: If one of the private keys is compromised, what happens when there are multiple validators?
00:23:48.160 - 00:24:19.268, Speaker A: Oh, totally. Yeah. The beauty of Arbitrum is this kind of what we call the any trust assumption that only a single validator needs to be operating correctly for the protocol to remain secure. And so as long as kind of there is someone who's not compromised, the protocol continues to work. It slows down a little, but your entire contract still remains off chain. The costs still stay low. It can't execute quite as fast, but everything keeps working.
00:24:19.268 - 00:24:56.796, Speaker A: Even in that case, as long as you don't have 100% of the validators of your contract compromised. And essentially kind of the way that's accomplished is that there are two ways to make progress. And I didn't go into this too much, but I mean, I have a little extra time. So there's a unanimous way and there's a non unanimous way. So the unanimous way is very akin to state channels for anybody familiar with those where essentially everybody agrees they can just sign an update and say, hey, this happened. If any single validator is honest, then that won't be malicious. That will just execute correctly.
00:24:56.796 - 00:25:48.236, Speaker A: So the interesting question is, if you don't want to assume and you don't want to rely on just having kind of on having everybody be available, then you need some other way to make progress. And essentially the way that that works in Arbitrum is a single one of the validators essentially proposes an update, and any other validator can challenge it. And so kind of there's a definition of what's correct and arbitrary, provides a really efficient mechanism for resolving disputes, essentially over whether that proposed update is correct or not. And that's how we get this kind of like magic of you don't actually need to trust that kind of many people are honest. Yeah, I'm happy to talk about it offline. I will convince you it makes sense. Awesome.
00:25:48.236 - 00:25:53.060, Speaker A: Cool. So, yeah, I will give it up for the next talk. Thanks for listening.
