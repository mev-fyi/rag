00:00:06.890 - 00:00:28.182, Speaker A: Great. Welcome everyone. Thanks for joining us and taking your time. We have rahat here from Polygon. He is going to give a workshop on Token gating static data with Web Three storage and polygon. Rahat, I'll let you take the stage and if you guys have any questions in the meantime, feel free to pop them in the chat and we can take them towards the end.
00:00:28.316 - 00:00:29.000, Speaker B: Thanks.
00:00:30.810 - 00:00:31.318, Speaker C: Awesome.
00:00:31.404 - 00:01:08.734, Speaker B: Thank you. Let me share my screen. All right, thank you everyone for joining another's workshop. So today we're going to be talking about Token gating static data using Polygon as well as Web Three storage. And specifically what we're going to be doing is building out like a little Token gated blog backed up by Web Three storage as well as an NFT on the Polygon network. First off, a little bit about me. My name is Rahat, a developer advocate over at Polygon.
00:01:08.734 - 00:01:44.910, Speaker B: Previously I've been a front end engineer as well as a freelance solidity engineer overall, just like an indie hacker, Web Three enthusiast. And yeah, these are some places you can find me specifically for everything we go over in this workshop. You can find everything at this link. I'm also going to drop it in chat, but it's Rahat Dev posthackfs 2022. So if you ever want to go over the slides, if you want to go over the code again that we go over during this workshop, feel free to do that. That's all available right there. Cool.
00:01:44.910 - 00:02:16.242, Speaker B: A little bit about polygon. Polygon is the leading platform for Ethereum scaling and infrastructure development. So we provide a bunch of different solutions. Things like ZK rollups, optimistic rollups, I chains, hybrid solutions, different things for different needs. Specifically, what we're going to be talking about today and what folks might be more familiar with is our main offering, which is the proof of stake blockchain. It's an EVM compatible blockchain. Our native Token there is Matic, super accessible and sustainable.
00:02:16.242 - 00:03:18.678, Speaker B: Accessible being because transaction fees are much lower than doing something unlike mainnet and sustainable because we've been committed to being carbon neutral, which we've done so far and trying to go for being completely carbon negative. So why should you build with the proof of stake chain? Speed is one of the first reasons. 65,000 transactions per second, pretty fast. You still leverage like Ethereum at the end of the day so you can conduct transactions on the previous day chain and then bridge assets back and forth back to Ethereum. And like I mentioned before, you're saving on cloud on costs, approximately 10,000 times lower costs per transaction than Ethereum. So I wanted to give you kind of like an overview of how this works at a very high level. So this is sort of like at the bottom you'll see like the Matic side chain, which is kind of like where you would do most of your interactions with if you're using the Polygon network.
00:03:18.678 - 00:04:26.526, Speaker B: If you deploy some smart contracts, et cetera, onto either our testnet, which is the Mumbai testnet, or our main net. On Polygon, you would interact with that chain specifically, but if you look at the overall architecture, you'll see at the top, the root chain is actually the Ethereum mainnet. What happens in between these two chains is that we have this layer called a public plasma checkpoint node. And what these nodes do is that they'll occasionally take a look at the current state of the Matic chain and they'll save a hashed value of that state to the Ethereum Main net. We have a contract on there that essentially keeps track of all the hashed values of it. So what this means is this transforms the Matic side chain into what's called a commit chain and inherits some of the security and backing of the Ethereum Main net onto Polygon itself. So building robust, decentralized applications requires a combination of tools in the ecosystem.
00:04:26.526 - 00:05:15.470, Speaker B: I just gave you a little bit about Polygon and the proof of stake blockchain, but at the end of the day, if you're going to be building a decentralized application, polygon is just one part of the equation. You need a few other things to actually flesh out and build a full, usable, decentralized app. One of those things can be stuff that helps you with storage. So what are we building today? Like I mentioned before, a token gated block. We're going to be looking at how we can take an existing NFT smart contract that I have already deployed on the Polygon mainnet, which I actually built on a previous eGlobal workshop. And what we're going to be doing is just like verifying the ownership that somebody owns one of those NFTs. And if they do, they can access a blog.
00:05:15.470 - 00:06:05.918, Speaker B: The data for that blog is going to be actually hosted on IPFS and filecoin using web3 storage. So our blog is built with, like I said, Polygon web3 storage. We're going to look at some react code as well as the Ether JS library. And then we're going to, at the end, talk about some more tools that we can use to help improve this sort of basic implementation a little bit further. For now, let's look at some code. So I've got this code repository pulled down, but this code is also available on that link I sent earlier. And I've got this JSON file in here, nothing fancy.
00:06:05.918 - 00:06:48.240, Speaker B: It's like a mini little blog post called GM World. It's got a description, a body and an image. Nothing fancy. We'll take a look at this a little bit more later. But a quick run through of the application itself is I've got most of the things here inside of the app JS. I've just got like a handle connect wallet function here, which is just going to request permission to connect to the user's wallet, save their address into state, as well as connect to an existing NFT smart contract that I've specified up here. Let me go ahead and actually open that for you.
00:06:48.240 - 00:07:26.008, Speaker B: So this is the NFT Smart contract I was talking about before, which I created during another ETH Global workshop. But just a quick overview. If you head to Contract, you can actually read the contract itself and see what's going on in here. So Polygon scan is very similar to Etherscan. If you've used Etherscan before to take a look at some of your existing contracts. But here you'll see that I verified the Contract code. Shout out to past me for doing that because that made this so much easier.
00:07:26.008 - 00:08:43.940, Speaker B: But essentially it's a very basic kind of implementation of an NFT Smart contract. I'm importing open Zeppelin ERC 721 Uri storage as well as counters to help with giving token IDs for everything. This ERC 721 NFT collection is called metadata NFT and nothing really going on. I just have a single Mint function that takes a token Uri, which could be anything just hosted on IPS, fast File, Coin, whatever that has, just like some JSON data that we can use to essentially set up the token Uri for this NFT and add all the data for it. Not a lot going on. But the main function in here that is going to be useful for us if we had to read Contract is this balance of function. So if I were to go and take my address, paste this in here, hit the query button, you'll see that the balance of method returns three, meaning I have three NFTs that are a part of this collection.
00:08:43.940 - 00:09:47.288, Speaker B: So what we're going to be doing inside of here is checking to make sure that any person who connects their wallet has a balance greater than zero. They just have to have one single NFT as part of this collection and that will set the state of the app to be authorized. Currently the state of the authorized by default is false. This will set that authorization to be true. How are we using that authorization down here? I have this component called Content which will show once someone's address is connected as well as taking in that authorization. So let's take a look at the Content component itself. Not a lot going on in here, but essentially it is making a fetch request to a JSON endpoint and then displaying the results of that data, saving it to state and displaying it down here as long as the person is actually authorized to view it.
00:09:47.288 - 00:10:46.684, Speaker B: So that JSON data again is coming from this post JSON. So how do we actually get this onto a queryable endpoint? This is where Web three storage comes in. So I'm going to head over to web3 storage. I've already got an account, but you can make one here. So for the sake of this specific workshop, I'm just going to be using their uploader to actually just upload the JSON file straight into web3 storage. But they've actually got a whole entire JavaScript client that you can actually put into your apps to upload files, get them straight onto IPFS file clone, et cetera, and display that data in a more programmatic way. In our case, we're taking a shortcut and just uploading files, so you can just drag and drop files here.
00:10:46.684 - 00:11:21.492, Speaker B: So this is that link to that JS client library that I mentioned before. Actually, I think I already uploaded it before. Yeah, post JSON. So we can just click this. You'll see that it goes to an IPFS link. And you'll see that my post JSON over here lives on this endpoint. So inside of my application, if we go to the env file, you'll see that I already put in this endpoint as the react app JSON endpoint.
00:11:21.492 - 00:12:27.470, Speaker B: Now, this is a very naive, rudimentary way of hiding this endpoint so that someone with the NFT can only access it. We'll discuss how you can actually make this a little bit more secure at the end of the demo. But what we've got here basically is we are connecting to somebody's wallet. Just a quick walkthrough again, connecting to somebody's wallet and then immediately connecting to this contract address, which also includes the abi from the contract. So this Abi code I just copy and pasted from the contract itself. So if you ever wanted to look at a verified contract and actually build a front end around it, as long as they've got this little green check mark, if you head to code and scroll down, you'll see that there's the contract abi here. You can hit this button to export or copy the abi to clipboard whatever you need.
00:12:27.470 - 00:13:27.730, Speaker B: And so I basically just copy and pasted that into this JSON file here. API code. All it does is just kind of I like to refer to it as like a map. It is what the different functions that are available to you to call on this contract. This is how any JavaScript SDK that you use will understand how to actually query this specific contract. So if we head back to app JS, we will see that I'm importing the Abi up top and I'm creating an instance of this NFT contract by supplying the contract address, the API, as well as the signer which I got up here. And then I'm just immediately calling this balance of function, which I showed you all on polygon scan and supplying it my address that I got from up here.
00:13:27.730 - 00:14:03.528, Speaker B: And that's how I'm checking if this person actually has a balance of any of the NFTs associated to this specific collection. So let's take a look and make sure that actually works. Let me run that here. It cool. So we have our Connect wallet button.
00:14:03.614 - 00:14:04.008, Speaker C: Cool.
00:14:04.094 - 00:14:43.930, Speaker B: Hit connect wallet. So I connected before, but if you connect for the first time to Localhost 3000, then it'll ask you to authorize it and everything. But yeah, this looks like it works. I have the GM world a little description body as well as the image that I saved. Cool. So as long as I have an address with that specific NFT, this is all good. Let me actually switch this to a different address and let's verify that this should not work.
00:14:43.930 - 00:15:06.760, Speaker B: I'm just switching it off camera. 1 second. Okay, so this is a new one. Hit connect wallet. Okay, my MetaMask is still detecting the other one. I have to disconnect everything. 1 second.
00:15:06.760 - 00:16:15.970, Speaker B: It this is always the issue with doing live demos and having multiple accounts linked to stuff. DA DA DA. In the meantime, I do see some questions while I'm setting this up. I'll just quickly answer some if the Auth check is done client side, what's to stop someone from just setting their own authorization and fetching displaying the data? So in this implementation, there is nothing to stop that. But we are going to talk about some tools that will help you to improve this implementation further at the end of this demo, once I disconnect all of my wallets. One moment. Okay, cool.
00:16:15.970 - 00:17:08.770, Speaker B: So I'm now on a different wallet. Hit Connect Wallet says, sorry, you do not own the NFT required. That is because this specific wallet does not own any of the NFTs or have minted any NFTs from that specific contract. So that is a very just like a starting point for you all just to kind of take of how you could potentially save some JSON data onto a service provider like filecoin using Web Three storage and actually token gating that using something on polygon. This implementation is not perfect. There's never going to be anything perfect in a 30 minutes implementation. But let's take a look at how we can improve this.
00:17:08.770 - 00:18:38.120, Speaker B: Let me reshare my screen. Cool. So ideas for building this out even further. So one of the things I was asked is how do we actually better secure this data and make sure that only somebody who has the actual access to this data access it so you can actually encrypt this data. On the JSON endpoint, there's this really awesome protocol called Lit Protocol which will help you to encrypt data on you can encrypt any type of data and then essentially have the ability to unencrypt it based on ownership of a specific NFT ownership or whatever kind of set sort of details that you want. Maybe you want specific addresses to have access to it, et cetera. So aside from using something like your own server to do some of that validation, let protocol is a good sort of like Web Three way of making this a little bit more secure and encrypting this information specifically for those NFT holders or any addresses of your choice.
00:18:38.120 - 00:19:49.890, Speaker B: Other things you can do. Consider using subgraphs if you're wanting to integrate multiple NFT communities because trying to essentially if you have some type of newsletter or a blog or something that you want to token gate in this way you're going to be better off using something like a Subgraph, especially when you have different types of NFT communities that you want to make sure you're servicing. One thing that I mentioned earlier was using the Web Three storage JavaScript client to allow users to upload their protected data themselves. So rather than you having to go in, go to Web Three storage, upload the actual data they do have that JavaScript client for you to integrate that directly into your DAP. Last thing would be to use solutions like Rainbow Kit as well as Wallet Connect for more wallet compatibility. The way that this specific implementation is done is that it's only really compatible with MetaMask or like a browser injected wallet. So definitely want to make sure that you are targeting and opening up your DAP up to as many people as possible.
00:19:49.890 - 00:21:19.044, Speaker B: So the main takeaway that I hope that you all sort of the main point that I hope you all sort of take away from this is that Web Three protocols are your building blocks. You have to use them kind of together to build out that robust DAP. So again, something like polygon as the base layer to have your assets to have your transactions on and then you have Web Three storage thanks to the folks at Filecoin to have some of that storage. Maybe it's like JSON data for static blog posts, maybe it's images, et cetera, whatever you kind of want need to store that's there for you. And then the other thing that I mentioned of making this a little bit more secure is using tools like lit protocol to further make this into something that's more production ready by adding some sort of encryption for protection against people who want to do some nefarious things and access data that they should not access. So, want to open this up to questions? I know there's a bunch in the chat so I'm going to stop sharing and let's take a look at the chat itself. Is it possible to build a forumma style service using this? Yeah, I mean essentially the JSON endpoint itself could probably have whatever kind of data you want.
00:21:19.044 - 00:21:57.920, Speaker B: So this is forums with things like the ability to add comments and things like that. This might not be 100% the best solution for that. I would say maybe for real static data like a blog. Like a blog is not going to change a lot. So if you want to have a blog post or like a newsletter or something that is specifically Token Gated, that is probably like anything really static is probably the best way to do that. Cool, thank dyson.
00:21:59.880 - 00:22:05.828, Speaker C: Hey, thank you for presenting. This was really cool. I was actually thinking about something like this as well.
00:22:05.914 - 00:22:06.550, Speaker B: Awesome.
00:22:07.160 - 00:22:34.700, Speaker C: Yeah, just one thing I've heard about unlock protocol, and then the other thing I don't know how they do it, but I'd be curious. And also, if, you know, maybe you can explain a little bit more also around the lit protocol, do you have any resources like GitHub code or things like that that you can say how we could potentially take this farther? Because this is super interesting to me.
00:22:34.850 - 00:23:08.120, Speaker B: Yeah, let me grab the Lit Protocol docs. Thanks. Yeah, the folks like at Lit Protocol are super awesome, so if you drop in their Discord and have questions, they can answer right away. But Lit Protocol can help you with doing things like adding authentication, JWT based tokens, things like that, so you don't have to actually build out your own server and stuff. You can actually use a Web Three protocol to help you encrypt and access data.
00:23:08.890 - 00:23:22.986, Speaker C: Do you think from what do you know, with using their Stack or Lego block, we'd be able to essentially restrict the content specifically to the NFT owners so people can't yeah, okay.
00:23:23.088 - 00:23:23.740, Speaker B: Absolutely.
00:23:24.190 - 00:23:25.500, Speaker C: Okay, thank you.
00:23:25.950 - 00:23:31.020, Speaker B: Yeah, my specific implementation, again, was really just like to go through no, that was perfect.
00:23:31.870 - 00:23:38.042, Speaker C: We were actually stuck on our project, and we were trying to solve this problem and cool. Yeah, this is great.
00:23:38.096 - 00:23:40.700, Speaker B: Thank you. Awesome. Glad I could help.
00:23:45.710 - 00:23:59.240, Speaker A: Great. Thanks, Rohat, for this workshop. It was great to have you. And if anybody else has any more questions, feel free to pop over to the Discord sponsor Polygon, and we'll be there to help.
