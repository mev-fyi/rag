00:00:00.890 - 00:00:13.600, Speaker A: All right, so our next speaker is Zach from Aztec, and we'll be going on with his talk achieving practical programmable Privacy with Noir. So without further ado, Zach, please take it away.
00:00:15.650 - 00:00:27.734, Speaker B: Yeah, happy to do so. Cool. Just to check, can people hear me? Just want to make sure my mic isn't muted. Awesome. Great, thanks. Cool, yeah. So, hi, everyone.
00:00:27.734 - 00:01:12.562, Speaker B: I'm Zach. I'm the CEO of Aztec and we are a privacy provider on Ethereum. And our mission as we see it, is to both scale Ethereum, but also mainly to deliver strong privacy guarantees to public blockchains. So I'll just share my screen now because to share a few slides that I have presented to present. Cool. So our thesis at ASIC is that the more that blockchains reach into the economic lives of individuals, the more that privacy is going to move from being just nice to have to utterly essential to the functioning and purpose of a blockchain. Blockchains can be used.
00:01:12.562 - 00:02:06.910, Speaker B: I mean, the great promise of blockchain is to be used as the world's Global Settlements layer for payments, microtransactions, and far more than that. But if we live in a world where your salary is streamed on chain, or we live in a world where the majority of your purchases and payments are being settled on a blockchain, people aren't going to be happy. With their entire payment history being built up and assembled by some analytics firm so that their details can be sold to Advertisers without their consent. People aren't going to be happy with everybody being able to view how much they're getting paid at a glance on chain. And so, really, I think that privacy is going to become a major issue in the future. And the way we see is we want to basically solve this problem. And we're going to solve this problem using highly advanced, state of the art ZK snark tech plugged into a very advanced programming language that abstracts away all the cryptographic nonsense and presents a very easy to use private smart contract programming interface to developers.
00:02:06.910 - 00:02:32.198, Speaker B: So before we dive into that, what might be useful is to provide a little bit of context. What are private transactions and how do they work? Because they're not particularly simple, that's for sure. If you want a transaction to be truly private, then you need three things. What we call the trip ticket privacy. And I've completely stolen this from Anna Rose from the ZDK Podcast. You need data privacy. Obviously, values that are being transferred are hidden.
00:02:32.198 - 00:03:06.626, Speaker B: Any sensitive data is encrypted. You need user privacy. You need the identities of senders and recipients and counterparties to be completely anonymous and encrypted. And you also ideally need code privacy so that the actual contract you're calling is not known to observers. And you can even go one step further and actually have encrypted code itself so that only a privileged number of people can actually see the smart contract code to begin with for kind of specialized use cases where you're using proprietary algorithms. But this presents a lot of problems if you're doing a cryptocurrency transfer. Your transfer now can't produce linkable database updates.
00:03:06.626 - 00:03:44.910, Speaker B: And by that I mean if you take the Ethereum use case, you have an account balance on the Ethereum blockchain. It's in a database somewhere. Your address has got a value link to it. And that value changes when you send a transaction. Even if you encrypt that value field, the fact that it changes reveals information about the transaction graph and exposes a little bit of what's happening. And so the way that we solve this and the way that it's commonly solved, for example, I think Zcash really pioneered this for privacy, is you represent value in the more Bitcoin style world where you have unspent transaction objects, except this time they're encrypted. So you have some notes that represents the value, and it has an owner, but the value and the owner are encrypted, and your balance is a sum of those owned notes.
00:03:44.910 - 00:04:47.990, Speaker B: That way you can describe a private transfer of value using this joint Spit ZK snark circuit. The idea is you have some input notes that have owners and values, and you have some output notes that have owners and values very much like Bitcoin, except everything's encrypted. And the way that this transaction works is you use a ZK snark to validate that some of the input notes equal to some of the output notes to validate that the note owners have consented suspending these notes by providing a digital signature and basically validating all of the logic that requires sensitive information inside a ZK Snark circuit so that it's all hidden from the world and from observers. And nobody other than the sender really knows what's going on. And only the recipient can decrypt the app notes along with the sender because they're creating them. So that's how you do private transaction. But how do you do it at scale? Because that's important, right? It's not sustainable for the Ethereum blockchain to verify every private transaction in a smart contract because ZK smart verification is crazy expensive.
00:04:47.990 - 00:05:28.470, Speaker B: Costs you up to hundreds of dollars at the high gas prices we've been experiencing. And this is where our ZK ZK roll up architecture comes in. Effectively, deposits and withdrawals into this architecture are public because you're depositing a withdrawal cryptocurrency, but the identities are unlinkable. So the identity of the depositor is not necessarily the same as the identity of the withdrawal. And you can also mix together values to provide even more obfuscation and any internal transactions that you send within the roll up architecture. So any purely private sends are completely obscured. So senders and recipients identities are hidden, values are hidden.
00:05:28.470 - 00:06:03.610, Speaker B: The strongest privacy guarantees you can get. So the way this works at scale is through the concept of recursive ZK snarks. So you have a ZK snark circuit which defines an individual private transaction. And then you have another larger ZK Snark circuit which aggregates together hundreds if not thousands of these private transactions and verifies their correctness by. Basically what you have is you have a ZK Snark circuit that verifies proofs made of other Ziki Snark circuits. That's why it's called precursive Snarks. And doing this on Ethereum has been something of a difficult problem to solve because the cryptographic primitives available on theorem are extremely limited.
00:06:03.610 - 00:06:52.430, Speaker B: You can only do basic arithmetic over one elliptic curve, soon to be two. And so what we've done using our turboplot proving system is we provided the first viable algorithm that can be used to perform recursive Snux on Ethereum. That's how we've achieved this private roll up architecture. And one of the valuable things about this is that this roll up that you need to make the proverb is completely untrusted. It can be delegated to a third party. They don't need any sensitive information because everything's hidden within the inner Snarks. And it has more advantages over other similar roles in L2s, because the rollout provider can't mount censorship attacks because from their perspective, all of these transactions, they just look like random numbers because everything's encrypted, so they don't know what to censor.
00:06:52.430 - 00:07:37.848, Speaker B: So from that point of perspective, it's a relatively neat architecture. And then to go one further, to get a little bit inception about it, you can make roll ups of roll ups, of roll ups, of roll ups, of roll ups, if you want to paralyze your roll up construction to aggregate extremely large numbers of transactions. So let's say you have a roll up that aggregates 32 private transaction proofs. Well, then you can create another roll up circuit that verifies 32 of the roll ups that verify 32 transaction proofs. And then you got 32 squared transactions compressed down into a single roll up. And you can scale this arbitrarily to produce massive roll ups, which is again another value of this recursive ZK snap construction. So that's how private transports can work.
00:07:37.848 - 00:07:54.684, Speaker B: They provide strong privacy guarantees. But the title of this talk is Programmable Privacy. And that's not programmable, that's just basic value transfer. So let's go one step up and say ask ourselves, okay, sends and receives. That's cool. You've got private bitcoin, you've got a Zcash type architecture. Nice.
00:07:54.684 - 00:09:12.532, Speaker B: But how do you do something more? For example, how do you tap into DeFi, but in a private privacy preserving way? Now, this might seem on the surface of it not too hard, right? We have Snarks, they're programmable, program DeFi, job done. But it's a little bit more complicated than that because when you want privacy protections, then everything changes. Basically, you live in a bit of a more constrained world because state variables, storage variables, the kind that exist in a solution to smart contract in a world of privacy, they're all owned by individuals because they're all encrypted. For example, if you have some AMM that you're creating. Well, you probably need some kind of total liquidity supply variable in your AMM, but you can't keep a global variable like that and update it because that releases information about what individual transactions are doing. And so this makes DeFi protocols in particular extraordinarily hard to do in a privacy preserving manner to actually make the DeFi protocol itself private. Another problem is that if you have a programmable private smart contract system so that that join split transaction I just described, you basically make that programmable by anybody.
00:09:12.532 - 00:10:33.932, Speaker B: So anybody can fiddle with the rules of that joint split circuit. Well, now you're adding untrusted code execution into a ZK roll up that's privacy preserving. And so from a cryptoposk perspective, that's quite dangerous because you need to somehow validate that you have strong security guarantees that somebody can't create a malicious smart contract that manipulates or affects or corrupts other smart contracts. So how do we do this? How do we protect users from being defrauded with malicious circuits? And how do we achieve the kind of code privacy so that you don't even know which smart contract you're calling when you're interacting with this crypto system? This architecture that we're putting together, a lot of it is inherited from the Zexi protocol that was published in 2015 with a few modifications. So the way you do it is you have a concept of a kernel snark circuit. A kernel snark circuit, effectively it's a Ziki snark circuit whose job it is, is to verify the correctness of a single private smart contract transaction. So you have a private smart contract which is defined by Aziki SNOX circuit that's coded up by some developer, could be anybody using this noir programming language.
00:10:33.932 - 00:11:35.616, Speaker B: And then this kernel SNOX circuit is designed to ensure validate the correctness of it, that the user is interacting with a smart contract that's been kind of deployed to the chain, that the inputs and the outputs of the contract are correct. That any state variables that need to be modified are following the rules of the chain, basically performing a similar function to the EVM on Ethereum, but with the difference that this isn't actually an actual virtual machine, it's much higher level than that. So the story so far is we have a way now of doing programmable private smart contracts. You have this recursive extraction where you have a privacy proof that is user defined and then you have a kernel smart circuit which verifies the correctness of a single private transaction. And then you have a roll up circuit which aggregates kernelsmark circuits. So it's turtles all the way down here. So how do we get from that to DeFi or something a little bit more ambitious than private transaction, just a private value transfer? I mentioned earlier that one of the problems is state has to be private.
00:11:35.616 - 00:12:44.324, Speaker B: Everything is encrypted. It has to be owned by one or more people. Therefore you can't do things like track total supply you can't trigger out transactions algorithmically and by that I mean consider something like Private MakerDAO in makeadao if you create a CDP, if it comes under collateralized it automatically gets liquidated. Well, if your CDP is encrypted, the value is encrypted and how do you determine it even if the thing is under collateralized and even if you can do that, how do you liquidate it? The only person who knows how to do that is the owner of the CDP and they aren't going to help you because you're hurting them by performing this action. So I guess the TLDR of this is that whilst you can do private DeFi in a completely private way where you actually make the DeFi algorithm private, it's quite hard and it requires very advanced multiparty computation protocols to achieve. And you might need to add in additional trust assumptions and that this is not something which is particularly easy to deploy or even build if you're not a relatively sophisticated cryptographer. So this might sound a little bit weird know at AZEC our goal is programmable privacy.
00:12:44.324 - 00:14:10.128, Speaker B: This whole talk is about how do you do programmer privacy and here I'm saying it's kind of hard, you probably can't do it, that's not actually true but we're at the halfway mark where it looks quite hard to do. You can do more meaningful privacy preserving DeFi type interactions without having to have advanced NPC premises and kind of completely getting around the fact that the actual DeFi protocol itself is very hard to encode in a privative preserving manner. And the way you do that is you interface private transactions with public DeFi protocols. And by that I mean you go to the source of value, you go to the tokens themselves, and you ensure that they're private so that the owners of tokens are encrypted their positions of any one token holder that's also unknown. Then you can make your DeFi protocol completely public, and you can have very strong privacy guarantees, because if you have people interacting with, say, for example, uniswap, but you don't know the identities of people interacting, you don't know who is depositing into the liquidity pools, you don't know who is performing trades, then that's privacy preserving. It gives you very strong protections against some of the existing problems in DeFi. For example, right now if you have a very large position in DeFi it's very easy to get pretty much inevitable that you'll get front run, right if you start to because you can use services like chain analytics to completely dissect and understand everybody's relative holdings and DeFi protocol.
00:14:10.128 - 00:14:41.824, Speaker B: If somebody has a portfolio with large positions, you can know about it. And so if somebody starts to unwind that position, they start to make a large trade, everyone knows about it. And hey, hey, you can frontline those. Trades you can do Mev Shenanigans but if the actual assets themselves are private, then you can undo this. Because if you have a large position, you can unwind it slowly you can slowly drip it like 1000 die out or 1 million die. Trade time. And nobody knows that those 1000 by trades are connected with one another.
00:14:41.824 - 00:15:54.596, Speaker B: So if nobody knows that somebody's doing a large trade because from the perspective of the blockchain, they're not, this is kind of what we're doing at Aztec. This is kind of our focus right now. It's to basically provide a way of interfacing with public DeFi protocols in a privacy preserving manner to provide the kind of programmability which makes this possible without having to basically reinvent the wheel and require these DeFi protocols to reinvent themselves in a completely private way, which requires very advanced multibody computations and advanced cryptography, which most d five teams have the ability to do because it's quite niche and also probably the inclination, because it's extremely difficult to pull off. So the summary this is basically if you want to do private D Five, you create a privacy preserving bridge to a layer on DeFi protocol from a L2 private wallet like Aztec. The idea is you can aggregate together fixed nomination notes that don't need to be fixed, but it helps with the anonymity guarantees. So for example, if you want to trade five ETH and the dominant nomination is one ETH, then you just split it up into five trades because this is a scaling solution that is relatively cheap to do. And then you have an aggregation circuit.
00:15:54.596 - 00:16:35.488, Speaker B: And what an aggregation circuit will do is it collects together trades of the same type from different users and bundles together into one megatrade that then gets sent off to the layer one DeFi protocol. And that way the expensive layer one transaction gets amortized across a large number of users. No, hang on, this is somehow skipped together, skipped about a dozen slides. So we were here, weren't we? Yes. So this is just a little flowshot of how this system will work. So on the left we have the L2 robot architecture that's privacy preserving users have a bunch of ethereum they want to trade it for die. You have an aggregation ZK snux circuit.
00:16:35.488 - 00:17:17.440, Speaker B: This will be programmed by somebody using Noir. And these ETH notes get aggregated together into a giant pool of ETH that then gets sent out to the public layer one to a bridging contract which basically acts as the interface between the L2 roll up and the DFI protocol. Anyone can write this. This is completely non interactive. The D five protocol itself doesn't have to write this bridge. We don't have to like as long as somebody writes it and it conforms to a standard interface that we're going to be publishing fairly soon, then this just works. And so the idea is then the bridge contract would perform a swap with some DeFi protocol, then the proceeds would get sent back to the aggregation circuit inside the roll up.
00:17:17.440 - 00:18:16.788, Speaker B: And then from that, the circuit using, because it's programmable, we've programmed to disseminate the dye that was exchanged. In this example, disseminated it back to the original depositors in the correct ratios. And this is both how you can interact with existing DeFi protocols in a privacy preserving manner without having to rewrite the DeFi protocol and to do it at scale at a price which is cheaper than just a basic layer, one transaction itself. So how do you program this all up? Because this is what we're building at Aztec. But there's one thing between having the Aztec team, which has got some very good cryptographers in it, building. This is a very different thing to getting the community to build these things, which is the end goal. Privacy can't achieve its full potential unless the users themselves, they're the ones deciding how best privacy can be utilized for their purposes and programming it up themselves.
00:18:16.788 - 00:18:59.120, Speaker B: And so part of this is the proving system, the cryptography, because when you have a private roller, one of the big constraints, one of the problems is that the privacy proofs that are constructed so these joint split transactions, these, these, these kind of these aggregation proofs, they need to be constructed client side. They need to be constructed by the user because they're privacy proofs. If you delegate that proof construction to a third party, then you're leaking information. You have to give them secrets. You don't want to do that. But if you're constructing these proofs client side, then you're constructing them with very wimpy constrained hardware, old laptops, old phones, and worse than that, probably running a DAP in a web browser. So you can't even have tightly compiled optimized code.
00:18:59.120 - 00:19:47.556, Speaker B: You got to run it in a web browser, probably using WebAssembly. So you have a lot of slowdowns involved. And snark proof construction is notoriously expensive. Typically, the difference between running a computer program and constructing a ZK snark proof of that computer program, it can scale up to a factor of a million. And that's using this state of the art tech, which improves by one or two orders of magnitude on what came before it. But we're very confident with this ultra plump proving system that we've developed in house at Aztec that it's fast enough to get the job done. So one of the reasons why is because it's a completely state of the art universal ZK snark that's built on top of the original Plonk protocol, which Aztec published in 2019.
00:19:47.556 - 00:20:31.260, Speaker B: And it's far more efficient than Plonk. It can do recursion in less than 350,000 constraints. We're going to get the number down to much lower than that in the future. And it can do very snark unfriendly things very efficiently. So if you're familiar with ZK snarks, you might know that Snark circuit has if you have to represent a program as a Snark circuit, you need to decompose your program into addition and multiplication gates, which is very hard and annoying to do because that's quite primitive. What we can do instead is we've developed a way for very efficiently accessing lookup tables within a CK Snark circuit. So you can do things like, let's say you want to do a shard of x six hash, well, that's made up of a bunch of exclusive operations.
00:20:31.260 - 00:21:22.604, Speaker B: You can create a lookup table of eight bit exclusive operations and just index get values out of pull values out of the lookup table instead of computing these exclusive horse, which is quite hard to do in a Snark. And similar things like that means that you can absolutely crush down the constraint cost of common cryptographic algorithms that you need for these kinds of advanced ZK Snarks, as this table shows. And the way that we're going to give the community the ability to actually work with this technology is through Noir. Noir is our private smart contract DSL being developed. The lead developer is Kev Vedabar and he's developing this as a fully open source project. So the goal of this, we're going to be using this to enable users to build state of the art private smart contracts as Plonk circuits. But the language itself can be used in theory, plugged into any cryptographic backend, not just Plonk.
00:21:22.604 - 00:22:02.104, Speaker B: So this is very much a community driven effort. And the difference of this Noir with other Snap programming languages is this one is very much optimized for client side proof construction. It's optimized for the goal is for it to compile down to very, very highly tightly optimized circuits where proofs can be structured on maybe Wimpy hardware, which is quite critical for our use case. Some of the target features are things like efficient dynamic arrays. Now, if you're a software engineer or programmer, you might think big whoop, dynamic arrays, wow. They've been around in traditional programming languages since what, the 60s, maybe the 50s. But doing this kind of thing as far as AK Snark is truly revolutionary.
00:22:02.104 - 00:23:11.828, Speaker B: To do it efficiently, like to do it with one or two constraints per array access is not really been done before. You can have efficient recursive proof composition, which is essential for a private smart contract system because you need this kernel Snark, you need this roll ups, there's lots of recursion going on here. And also the end goal is this to have very efficient, very nice, pleasant private state semantics. So it's very easy to create storage variables, to have them be owned by users and manipulate them without having to deal with the underlying encryption algorithms and the typical cryptographic algorithms that you need to manipulate state inside CK. snunk, which is like merkel tree membership proofs and nullify sets and a lot of horrible messiness that we want to completely abstract away from the user. And also importantly, pleasant cool semantics so that private smart contracts can call other private smart contracts and that privacy smart contracts can even make calls out to layer one smart contracts and get return results back, which is needed for, for example, that aggregation example earlier in the talk. So the workflow for Noir is that you have some application that you want.
00:23:11.828 - 00:23:39.436, Speaker B: So here I've got some examples like Ziki Money, Tornado Cash, and then you program up your circuit in Noir. And then basically Noir will spit out two things. It spits out a proof of your circuits that you can create on demand. So you can put that in a web based SDK and have users make those proofs. And it also spits out for you a verification smart contract that you can deploy to Ethereum. So these follow a fairly standard template. The only thing that really changes per circuit is the verification key.
00:23:39.436 - 00:24:23.160, Speaker B: But the actual algorithm remains unchanged because it's a universal snob. And the abstraction layer that we're using here to enable Noir to plug into different cryptographic backends is something that we're calling a Sea, which stands for Abstract Circuit Intermediate Representation. It's a little bit like Llbm for computers. The idea is it breaks down a program into primitive operations that are efficient to do performance like a Zigzag circuit. So to give an example of currently how SA is structured, as much as possible, we try and devolve the basic operations into linear combinations. So a little bit like rank one constraint systems, if you're familiar with that. So this is basically just additions and multiplications.
00:24:23.160 - 00:25:21.416, Speaker B: But then we have black box algorithms for the complicated stuff. So what we've done at Aztec is we've built very, very tightly optimized gadgets, I guess you could say, common cryptographic algorithms like Shardy by six. So we've got this down to like 3600 constraints, and it can be optimized further. So that kind of stuff, we really want users to be able to tap into that without having to write it themselves, because our version is extremely efficient, because we spent a lot of time working on these. Similarly, you can do range trees very efficiently, other cryptographic primitives. And so the way it works is you have these black box algorithms that you can tap into, and then everything else that can't be covered by the black boxes gets turned into linear combinations, which is a little bit more expensive to turn into plump gates. But the idea is that for the linear combinations, that's kind of glue logic between the complicated black box algorithms that are kind of effectively can be considered.
00:25:21.416 - 00:25:54.890, Speaker B: They're a little bit like Ethereum pre compiles. So I want to give this a roadmap of this all, because this has kind of been a very high level what are private transaction center. How do we achieve them? How do we make this programmable? How do you get it done with Noir? But how do you use Noir? Well, Noir has been released. It's in an alpha. So you can download it now, tinker with it. We've got a lot of work to do on it before it's completely featured, complete, and ready to be used inside, like a roll up architecture to create private smart contracts. But the basics are all there.
00:25:54.890 - 00:26:51.160, Speaker B: Our roadmap for Aztec is that, well, we've currently small. We've released the first fully private roll up on Ethereum, so it's what we call ZK money, which is a way of shielding Ethereum and shielding ERC 20 tokens and then sending them around privately to other people. And right now, sorry, I pinch an OD slide, one of my old talks. So that number is actually 128 transactions per block, not eight, nine, six. And it's powered by a slightly older version of our cryptography because we wanted to get this released fairly quickly, so we haven't yet migrated it to the latest state of the art. But even with this, our privacy proofs can be constructed on a client, like in a web browser in 10 seconds. So this is why we're very confident that we can get the full private smart contract architecture done in such a way that you can still make these proofs efficiently in the web browser.
00:26:51.160 - 00:27:56.924, Speaker B: Phase two, which we're planning on releasing in the summer this year, is this DFI interaction stuff that I was talking about. So because we want to get this into the house of the community as quickly as possible, we're going to be programming these circuits ourselves so that users can interact using our L2 privately with DFI protocols, and that users and developers can build these bridge contracts themselves. So that if you have a D five protocol that you particularly want to talk to, or pretty much any layer one smart contract that could be modeled as a token swap. So this includes things like Dow voting, you can write a bridge contract, wire it into our L2, and then send asset transactions directly to that smart contract, and that'll be powered by our state of the art Ultraplot proving system. And finally, the apotheosis of what we're working towards is this final programmable, Private Smart Contract World. We're planning on launching either late this year or early next year, where we'll be releasing the 1.0 version of Noir and our rearchitected asset rollout protocol, which will enable users to program up private smart contracts directly in our L2 and then use them for whatever they want.
00:27:56.924 - 00:28:50.930, Speaker B: But the idea is to create a very rich ecosystem of private cryptocurrencies, private entities, private financial instruments that interact with both with DeFi protocols in a privacy preserving manner, but also more traditional financial products and services of the type that can't even be deployed on blockchain today because they require strong privacy guarantees to begin with to work. So the status of Noir at the moment is an alpha release. That's the link to the source code if you want to check it out and start tinkering around with writing Noir circuits. The current supporter backend is Ponk, but we're planning on. Supporting other cryptographic backends. Eventually, things like Marlon and the Smart contract verify generation is all working. So you can not only construct your circuits bullproofs, but you can spit out smart contracts to verify them.
00:28:50.930 - 00:29:52.660, Speaker B: What's on our roadmap is lots of work on developer tools to make this pleasant experience, to have things like a linter debugger, that kind of thing, as well as a developer SDK, basically the Aztec equivalent of web3 JS. So you get something to wire to act as the interface between making a proof and then turning the output of that proof into an ethereum transaction and getting it sent to a verified smart contract as well as support. For multiple cryptographic back ends and the semantics for smart contract transactions and storage state storage that doesn't require the developer to mess around with merkle trees. So just one final slide to give an example of the kind of DApps that we want to incentivize the community to build. This is one we built ourselves with our current technology. It's ZK Money, and it's a privacy preserving web wallet for Ethereum, where private cryptocurrency transfers are less than a layer one Ethereum transaction. Because of our scalable roll up tech and because of our technology, it's all completely privacy preserving.
00:29:52.660 - 00:30:02.970, Speaker B: So, yeah, that's a lightning tour of noa how to achieve practical programmable privacy. And yeah, be super happy to if there's time to answer anyone's questions.
00:30:05.580 - 00:30:25.870, Speaker A: Thank you so much for this super interesting talk, Zach. We do have one question that came in mainly, so the question privacy preserving bridge looks like mixednet for DeFi. If there aren't enough users traffic anonymity is not your entry. Is that the case here?
00:30:27.620 - 00:31:22.540, Speaker B: So actually it's complicated, but you're on the nose where the few people using the L2, the worse your privacy guarantees are. One of the valuable things about the L2 architecture, though, is that basically your anonymity set is pretty much everybody who's deposited into the roll up architecture. So even if you have a not very commonly used DeFi protocol, let's say, for example, you are the only person who's interacted with the DeFi protocol in the last six months. Nobody knows it's you. It could be you, it could be any of the other people that have deposited in the Aztec. So as long as the actual high level protocol has a reasonable amount of traffic, then you have a very strong anonymity guarantees. But you'll create that if the protocol is dead and it's like one transaction a day, then you're going to get very poor privacy guarantees.
00:31:22.540 - 00:31:48.740, Speaker B: However, we're pretty confident that's not going to be the case. To give an example, like we launched about six weeks ago, we have a one ethereum deposit cap on Aztec. Because it's experimental technology, we want to make sure that people don't throw all their Ethereum in it in one go. But despite the deposit cap, we have about one point. We've had $1.7 million of deposits in six weeks. So even just post launch, it's got a very vibrant community of users, despite the limitations.
00:31:48.740 - 00:31:58.360, Speaker B: So I'm very confident that when we deploy our DeFi bridges, our users will enjoy relatively strong anonymity.
00:32:00.540 - 00:32:16.830, Speaker A: That's amazing. Thank you. I hope that answers the questions of where we're asked this. We're running a bit over time, so unfortunately I won't be able to take much more question, but thank you so much for your time. Zach, that was great. I hope everybody learned a lot. I did.
