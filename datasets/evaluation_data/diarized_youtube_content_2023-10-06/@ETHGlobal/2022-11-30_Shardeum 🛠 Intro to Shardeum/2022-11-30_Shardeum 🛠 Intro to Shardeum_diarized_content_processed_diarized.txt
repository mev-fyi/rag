00:00:06.010 - 00:00:33.574, Speaker A: Hey, everyone. Welcome to Shardium's workshop for ETH, India. My name is Greg Hemmer. I'm the head of ecosystem at Shardium, an EVM based layer, one that scales linearly using dynamic state Sharding. At Shardium, we've noticed a challenge that existing blockchains don't scale. You have this upside down J curve where at first blockchains have a great user experience. They have low transaction fees that get processed quickly.
00:00:33.574 - 00:02:03.854, Speaker A: But as these blockchains grow in popularity, they reach their scalability bottlenecks, where they have more transactions being submitted to the network per second than the network can process, resulting in a queue of transactions that build up, where users bid on gas fees to prioritize their transaction first, resulting in rising transaction fees. And our co founder, Nishal Shetty founded Shardium as a result of experiencing this challenge firsthand while operating his exchange with Xerx, where he noticed that users weren't withdrawing crypto like bitcoin and ethereum to the blockchain because transaction fees are too high. And so, if we want to live in a world where decentralized applications go mainstream, we need to have blockchains that can scale linearly to keep transaction fees low while remaining decentralized, no matter how many transactions there are. That's exactly what Shardium is building an EVM based layer, one that scales linearly using dynamic state Sharding. Dynamic state Sharding is an architecture that shards the compute network and state where each validator is assigned to a unique range of address space while retaining atomic composability. This enables TPS per validator, where Shardium is the first blockchain in the world to increase its TPS relative to the number of validators in the network. Just like mainstream web two applications, when you need more scale, you add more servers.
00:02:03.854 - 00:02:45.406, Speaker A: The same goes for Shardium. When you need more TPS, you add more validators. Shardium retains decentralization using lightweight consensus mechanisms. We use proof of stake in proof of quorum, which translates to low hardware requirements to operate a validator node. It'll only ever cost $50 to $100 a month to rent a dedicated server to operate a Shardium validator. And so, because of these low costs, there's a high number of people in the world that can afford to operate a validator on Shardium, enabling true decentralization. Shardium is also a fully permissionless network where no permission is needed to run a validator.
00:02:45.406 - 00:04:00.710, Speaker A: Anyone who wants to run a validator and has the required stake and the hardware needed can operate a validator on Shardium. Shardium is highly secure in part due to a feature called node rotation, where every 60 seconds, some of the validator nodes waiting on standby in the Shardium network join the network and replace a portion of validator nodes that are active in the Shardium network. And so every 60 seconds, you get this swapping process that happens where some of the validators go to standby and some of the standby replace those validators. But no standby node can choose when it is added to the network or which Shard it's added to this allows for true decentralization and high security in contrast of a dynamic state Sharded network. Like Shardium, when we look at an unsharted blockchain, every validator in the network does the same work. Each validator is responsible for processing all of the addresses transactions in the network and storing all of the transaction history data. And so when you add more validators to an uncharted blockchain, we recognize that you only get more decentralization and redundancy.
00:04:00.710 - 00:05:12.470, Speaker A: But it's our belief that eventually you have too much redundancy and what you really want is parallel processing. So you can continue to scale and increase TPS, preventing congestion. And so if you look at the most popular way blockchains that are unsharted scale today, they scale vertically, where when they get congested, they use more powerful nodes to increase their throughput capacity. By using more powerful nodes, you're increasing the cost of the hardware needed to run a validator node, resulting in centralization because less and less people over time can afford this hardware to operate a node. Also, scaling vertically isn't really true. Scaling it just makes the blockchain faster because it just incrementally delays the time it takes to run into your scalability bottlenecks that you were hitting previously. For example, when executing transactions, this happens at the CPU of a node and if the blockchain is getting congested and reaching nodes are hitting their CPU capacity, you can scale vertically and use more powerful computers with a more powerful CPU to execute these transactions faster.
00:05:12.470 - 00:06:11.410, Speaker A: But as the demand of the network continues to grow, you're going to hit that CPU capacity bottleneck again. And so vertical scaling doesn't really mitigate the scalability bottlenecks that blockchains face. To mitigate these bottlenecks, we need to shard the blockchain and scale horizontally. This is the way that all web two distributed systems scale. And this is how web three distributed systems or blockchains, will scale as well using Sharding. And so with Shardium, we've built the most advanced Sharded architecture that's been built in web three to date, where as I've mentioned, each validator covers a unique range of addresses and only needs to execute the transactions for the addresses it's assigned to and store the state for those addresses. And so here in this oversimplified diagram, you can see rather than every validator doing all of the work, you can complete work in parallel.
00:06:11.410 - 00:07:18.570, Speaker A: And you may also notice that some of the validators, while they each have a unique range of addresses that they're assigned to, some validators also cover the same address. And so with Shardium, each validator covers a unique range of address space while having a lot of overlap. And this overlap results in every address having the required redundancy of 128 validators. In addition to the benefit of linear scaling, shardium is also the first blockchain in the world to build auto scaling, where here we have a simplified diagram of a Shardium blockchain. Each black circle represents an active validator and the white circles represent a standby validator node. This Shardium blockchain is currently processing 750 TPS and using the autoscaling feature. Every 60 seconds, Shardium measures its load and comes to consensus on the required number of validators needed to process the current load.
00:07:18.570 - 00:08:39.326, Speaker A: So as this Shardium blockchain grows in popularity and applications acquire more users who are submitting more transactions, it's realizing that its load is approaching network capacity and it comes to consensus on the fact that it needs to add more validators to process the current load. So it autonomously adds nodes from standby and activates them into an active validator state, resulting in an increase in throughput capacity to 1000 TPS. This is a simplified diagram of how Shardium works and why Shardium developers in our community are so excited about what we're building. Because for the first time you have a blockchain that can increase or decrease its TPS autonomously relative to the load of the network. You might be thinking why would any blockchain ever want to remove validators and decrease its TPS? Well, shardium prioritizes efficiency. It never wants to pay more node rewards than necessary to process the current load. So if a black swan event happens, or issues like some of the recent issues in web three occur and we go into a bear market and load on the Shardium network reduces, it doesn't want to pay, say, 100,000 nodes, for example, if it only needs to process 20 TPS.
00:08:39.326 - 00:09:52.758, Speaker A: And so it'll remove validators to the minimum number of validators needed to process the current demand. So it only needs to pay minimum node rewards at all time. One thing we're really excited about that we wanted to ensure could occur is that you have the same developer experience as building on an unsharted blockchain where you have atomic composability with all contracts on the network while also getting the benefit of linear scaling. So I'm really excited to say Shardium has atomic composability. In a Sharded network, this means you can have things like DeFi where you have an AMM with a router contract and different token pair contracts that are Sharded, where these contracts live on different shards and nodes across the network. But those nodes can still retain atomic composability and execute the transaction in one transaction where the contracts can have composability with each other and all other contracts on the network. As a developer, you no longer need to worry about which Shard you deploy to and worry about only having composability with the other applications on your Shard.
00:09:52.758 - 00:11:32.090, Speaker A: With Shardium, you just need to deploy your contract and you immediately have composability with all contracts on the network. So an example of journey of a transaction in Shardium is a user submits a transaction through a front end with their wallet. The front end injects EIP 29 30, which is an access list of all the addresses involved in a transaction. That transaction hits the Shardium RPC, which forwards the transaction to the network. And no matter which validator that transaction hits in Shardium, every validator in Shardium knows the addresses that all other validators in the network are assigned to, and it also knows the addresses involved in the transaction thanks to the access list under EIP 29 30. Therefore, the validator can route that transaction immediately to the validators assigned to the addresses in that transaction and those validators come together and form a consensus group where only the validators covering the addresses in that transaction vote on whether the transaction is accepted or rejected and come to a majority agreement or proof of quorum where they form a receipt showing there's more than 50% of agreement on accepting or rejecting that transaction. This allows Shardium to retain atomic composability in one transaction, where you can call numerous contracts on different charts simultaneously and come to consensus on the output of these contracts in one transaction.
00:11:32.090 - 00:12:42.474, Speaker A: Some other reasons why developers are gravitating to Shardium is because Shardium has a focus on delivering users to applications. Shardium foundation would like the Shardium network to be the first blockchain in the world where applications go mainstream and acquire billions of users. Thanks to our linear scaling and dynamic state Sharding architecture, today we have over 300,000 users on our testnet, and applications building on our testnet have been acquiring around ten to 20,000 users on average within one to two weeks, which is really exciting. Shardium is also the first EVM based layer one that's native to India, being built by the community in India. From the testnet phase, every other layer one has been built outside of India and then tries to enter India. At Shardium, we believe that India is the most important market in web three and is going to build more unicorns in web three than any other country. And so everyone in India is really excited to play a role in building Shardium, and we're here to support you, our cofounder, Nishal.
00:12:42.474 - 00:13:53.910, Speaker A: Shetty is the founder of WazirX, India's largest exchange, and Nishal is also one of the top influencers in the web three ecosystem. As you likely know, Nishal has fought for positive regulation in India. For example, India went through a banking ban, and Nishal tweeted out hashtag India Wants Crypto for a thousand days in a row, which helped motivate the government to end the banking ban. Nishal frequently has helped to educate and grow the web three community in India, and he's here today to support those of you who continue to build on Shardium following this hackathon. Our cofounder, Omar Sayed has 30 years of experience building scalable distributed systems and is one of the most talented distributed systems engineers in the US. His second job in his career was at NASA, where in 1996, NASA took the first pictures of Mars, posted them on their website, became the most popular website in the world for a period of time, and Omar was one of the webmasters that had to scale NASA's website and their servers to handle that traffic. And so, from the earliest days of the Internet, omar has been focused on scalability.
00:13:53.910 - 00:14:53.690, Speaker A: This led to him being hired by Yahoo as their principal architect to rearchitect the application they bought from Mark Cuban. It was a video streaming application that started crashing in 2006 when the US upgraded to broadband Internet. Omar rearchitected that application and Yahoo is granted four patents on the system Omar designed for them. He's been working on the architecture for Shardis and Shardium since 2016 and is here to support you today if you have any questions about scalability in Web Three distributed systems, or just generally want to talk about what you're building and get his guidance on the technology side of things. Shardium is one of the fastest growing layer One communities in India and is the most active Web Three Meetup organizer in India. Today. We host eight to ten meetups per month in India, across all major cities, and some of the less populated cities as well.
00:14:53.690 - 00:15:50.806, Speaker A: We've had over 1600 attendees visit our meetups in the past two and a half months, and over 3000 people register for them. We're really excited that these are continuing to grow every month, and we're focused on scaling to 50 to 100 meetups per month across the world. We would love for you to continue building on Shardium and help you create awareness for what you're building in our community. We'll invite you to attend all of our meetups, which you can see pictures of here. You can present what you're building to the community there, get feedback on what you're building, build partnerships, and become a leading application in the Shardium ecosystem. Here you can see pictures of 16 meetups we've hosted over the past few months, and we're really, really excited to watch this community continue to scale so far this year, in just a few months, Shardium has made great progress. We've raised an $18 million seed round.
00:15:50.806 - 00:16:27.110, Speaker A: We're building really fast. We have two testnets live today. Our third testnet will go live in December. This quarter, we have 96,000 followers on Twitter who we can help ensure is aware of the products you're building on Shardium. We have over 109,000 followers or members of our Discord channel. We can work with you on things like AMAs and promotions on Discord to help create awareness for what you're building and help you acquire thousands of users. Speaking of users, we have over 304,000 users on our testnet today, and we're just getting started.
00:16:27.110 - 00:17:00.434, Speaker A: We're only in the testnet phase. This community growth has been all organic. We have around 9600 contracts deployed at the time of this presentation on Shardium, and we're excited to continue to scale. This is just the beginning. Thank you so much for listening to our presentation during the hackathon today. To get started building on Shardium, please visit our developer Docs at docs shardium.org. And with that, I'd like to introduce Marcus wentz, who will take you through the shardium demo.
00:17:00.552 - 00:17:10.680, Speaker B: Hi, everyone. My name is Marcus Wentz. I'll be showing you how to connect to shardium. So there's a few different ways to connect shardium using MetaMask, which I have installed. Over here.
00:17:14.720 - 00:17:16.540, Speaker C: We have MetaMask installed.
00:17:16.880 - 00:17:20.610, Speaker B: Here are the RPC endpoint details that we would need to add.
00:17:21.060 - 00:17:22.688, Speaker C: This is one way to do it.
00:17:22.854 - 00:17:24.544, Speaker B: To get here, you'd have to go.
00:17:24.582 - 00:17:30.140, Speaker C: To the browser extension, hit Add Network.
00:17:30.220 - 00:17:44.980, Speaker B: This window will pop up, and then you can add a network manually to add custom networks. All the information that you need is here. So you would just fill all this information here and then hit save. And then it would be recorded into MetaMask.
00:17:45.720 - 00:17:47.356, Speaker C: So this is useful for devnets.
00:17:47.408 - 00:17:59.176, Speaker B: And we recommend you use Liberty 2.0 because it's shorted. Let's try out Liberty 2.0. We have 1.6 and 2.0 on chainlist.org. 1.6
00:17:59.176 - 00:18:10.380, Speaker B: is not shorted, 2.0 is shorted. But you'll need an access list. But we'll get to that later. Let's just double check that we have Liberty 2.0 installed.
00:18:11.540 - 00:18:12.000, Speaker C: Awesome.
00:18:12.070 - 00:18:18.764, Speaker B: We have Liberty 2.0 installed, as we could see here. So now that we're connected to shardium.
00:18:18.812 - 00:18:21.840, Speaker C: Now we need SHM tokens to pay for gas.
00:18:22.820 - 00:18:56.220, Speaker B: So there's two ways to do this. We could either use a faucet website that we have here, or we could use a discord faucet. For this workshop, we're going to be using the faucet website. So to use this, we'd have to make a tweet. I've copied the tweet to my clipboard, and now all I need to do is paste in that tweet. It'll have a null address by default. I just copy and paste my address in so that the faucet can know where to send the tokens.
00:18:56.220 - 00:19:37.630, Speaker B: I make the tweet. Going to refresh the page. Now I'm going to grab the tweet and then just copy and paste the URL of this tweet here. Just going to close this out and close this other window that will open up. And then I would just paste in the tweet here. I already have SHM, so I'll get an error here. But if you didn't have any SHM, after a few seconds or like a minute or two, you should get SHM deposited to the address that you tweet with that URL here.
00:19:37.630 - 00:19:56.952, Speaker B: Okay, so now we have tokens. So now let's do a swap. Let's swap our SHM for wrapped SHM. So on this front end, it'll show wrapped ether, but in reality, it's wrapped SHM on the shardium blockchain.
00:19:57.116 - 00:19:59.956, Speaker C: We're going to swap one for one. This should go to a six, and.
00:19:59.978 - 00:20:03.876, Speaker B: This should go to a seven. Down here, it's seven wrapped ETH at.
00:20:03.898 - 00:20:06.250, Speaker C: The end because we're getting one.
00:20:08.860 - 00:20:30.448, Speaker B: The cool thing about Liberty 2.0 is, as mentioned earlier, it's sharded and it uses crosshard composability. And the way this works is you need to use an axis list to communicate between the different shards for sending a transaction. But we'll get to that in a minute or two. So it looks like the transaction went through. It might take a few seconds for.
00:20:30.454 - 00:20:32.480, Speaker C: The balances to update.
00:20:33.460 - 00:20:49.776, Speaker B: Awesome. The balance is updated expected. We have a seven and we have a six of the balances here. Okay, now that we interacted with a contract on shortium, now let's actually deploy some new contracts to shortium.
00:20:49.968 - 00:20:50.324, Speaker C: Here.
00:20:50.362 - 00:20:59.608, Speaker B: We have a Hello World type contract where we're just going to store a value, a uint here. And it's public, so we'll be able.
00:20:59.614 - 00:21:06.744, Speaker C: To easily view that function once it's recorded or at any point it was set.
00:21:06.782 - 00:21:08.410, Speaker B: We're actually changing the state.
00:21:09.420 - 00:21:17.096, Speaker C: We set a uint that would be the new value. I'm hitting CTRL s to compile the contract by default.
00:21:17.128 - 00:21:27.820, Speaker B: I'm in the virtual machine for remix IDE. So to access any type of chain with MetaMask, you have to go to injected provider. MetaMask.
00:21:27.980 - 00:21:29.164, Speaker C: Looks like it's connected.
00:21:29.212 - 00:21:50.810, Speaker B: Now I'm going to hit deploy. And now MetaMask is going to ask me to sign this transaction to confirm, I want to deploy this contract to Shardium. So it'll set this value and then record it to the storage slot. This is storage slot zero, and then it'll send out an event as well. Okay, awesome. The transaction went through.
00:21:53.420 - 00:21:54.776, Speaker C: Since we didn't put a value, the.
00:21:54.798 - 00:22:35.244, Speaker B: Default value will be zero as expected. Let's change the value to, let's say, the number one and hit confirm. So when the transaction is finalized and accepted, this will go from a zero to a one in the storage slot in the contract. Awesome. We have a one here. Now I'm going to show an example of an Oracle. Here we have an Oracle contract where we're able to get price feeds on chain.
00:22:35.244 - 00:22:54.460, Speaker B: Let's just deploy this contract first. This is from Super Oracles. They offer price feeds for different cryptocurrencies on chain.
00:22:55.440 - 00:22:57.656, Speaker C: Let's check out these functions with Bitcoin.
00:22:57.688 - 00:23:34.140, Speaker B: When I click on this, I'll get the Bitcoin price relative to dollars or USDT. And then when I click on this ETH USDT, I'll get the price of ETH and USDT because we're calling to this address. And then we're saying, hey, if we want ETH and then we want Bitcoin, and then we could call these other functions somewhere else since we're returning the price. Right. So here I'm just taking the value of Bitcoin over ETH. As you can see, it could do the math for it. This is just the contract being recorded here for this contract instance.
00:23:36.640 - 00:23:42.808, Speaker C: Awesome. Now let's jump to a more advanced contract.
00:23:42.904 - 00:24:27.884, Speaker B: Here we have this is very similar to this contract to the original contract, where we're just changing the state and being able to see the state in the contract. However, this contract is actually able to call this contract this contract here called multicall because it's able to grab the contract here. Oh, hey, I know this contract. And I'm saying, hey, here's the contract on this blockchain, and we're going to be able to interact with it and read and write to it. So here we're able to read slot zero because this acts as like a view function. When you have it as public, it'll just return the value, which is very convenient. However, this will be a little trickier but I'll get to this first.
00:24:27.884 - 00:24:30.636, Speaker B: I'm going to just I already have.
00:24:30.658 - 00:24:33.404, Speaker C: This contract deployed on Liberty 2.0.
00:24:33.602 - 00:25:09.700, Speaker B: I will just load it into remix IDE based off of its address. Just double check this is the right contract. The right data looks correct. Notice here the prefix is different for the address. This is a B and this is a zero on shardium. This means that they'll be on a different shard because their prefixes don't match. If we read as we can see here, it's simple, right? This is the last Unix time that the state was changed is what this is representing.
00:25:09.700 - 00:25:28.716, Speaker B: However, if I try to change the value without adding an access list, the transaction will fail because the transaction won't know what shards to go to. Since this is a multi shard transaction, we should get a failed transaction in.
00:25:28.738 - 00:25:33.832, Speaker C: The next second or two. Failed transaction as expected.
00:25:33.896 - 00:25:37.950, Speaker B: Let's pay attention to this value here. It ends in 50 two.
00:25:38.480 - 00:25:43.728, Speaker C: We have a script here where we have an access list. The way this is structured is we.
00:25:43.734 - 00:25:51.490, Speaker B: Have the other contract we're going to interact with and then we have its storage slot and then a code hash here for that address.
00:25:55.350 - 00:25:57.634, Speaker C: Now what I'm going to do is.
00:25:57.672 - 00:25:59.010, Speaker B: I'm going to run the script.
00:26:01.590 - 00:26:01.906, Speaker C: And.
00:26:01.928 - 00:26:03.380, Speaker B: This is the previous value.
00:26:09.210 - 00:26:18.366, Speaker C: This is the current time. Let's see the value updated as expected.
00:26:18.418 - 00:26:26.300, Speaker B: The value updated because we sent this transaction with the access list. So awesome, it's working.
00:26:29.070 - 00:26:30.538, Speaker C: To give another example of when you.
00:26:30.544 - 00:26:32.058, Speaker B: Would need the access list, let's think.
00:26:32.064 - 00:26:33.494, Speaker C: Of it in terms of tokens.
00:26:33.622 - 00:26:43.610, Speaker B: Let's say we have an ERC 20 token with total supply. It's just a view function. We're just trying to see how many tokens exist. So we're not changing the state of that contract.
00:26:43.770 - 00:26:45.374, Speaker C: We don't need to pay gas or.
00:26:45.412 - 00:27:04.758, Speaker B: Change storage slots, we're just reading. However, if we want to transfer tokens, say like we have tokens and we want to give them to someone else, this will change the state of that contract and we'll need to pay gas and interact with store slots. This will actually require the access list.
00:27:04.844 - 00:27:07.878, Speaker C: Because it'll need that access list to.
00:27:08.044 - 00:27:10.794, Speaker B: Render which ours to interact with.
00:27:10.832 - 00:27:14.010, Speaker C: But we preload this information in with the reading.
00:27:16.750 - 00:28:00.114, Speaker B: The good thing about this is we're actually able to automate the access list with an RPC. The way this is structured is we have an address and an API. So this is how we define our contract. It's the contract instance and then we have the method that we're going to call from that contract. What you could also do for this method as well is you can put in an input argument if that function needs it, but this function doesn't have any input argument, so it's just blank. And with that we have an unsigned transaction. And with that unsigned transaction we could call this RPC, which will generate the access list for us automatically.
00:28:00.162 - 00:28:04.006, Speaker C: We don't have to compute it, all.
00:28:04.028 - 00:28:14.826, Speaker B: We need to do is just send the transaction and say hey, we have a type one transaction that will include the access list and we just grab the access list from here and put it in the transaction and that's all we need to do.
00:28:14.848 - 00:28:33.968, Speaker C: It's very simple. You would use Ethers JS to access this. This is the simplest way to access the RPC. So here we have an interface.
00:28:34.064 - 00:28:42.196, Speaker B: Interfaces are very useful for interacting with old contracts. Wrapped ether wrapped SHM their solidity 0.4.
00:28:42.298 - 00:28:50.892, Speaker C: And they don't support safemath by default. When you build a new contract without safe math, you can have underflows and.
00:28:50.946 - 00:29:00.750, Speaker B: Overflows, which can be security risks for a contract. Typically why most developers develop with 0.8 now.
00:29:02.480 - 00:29:04.728, Speaker C: And to interact with this contract, we'll.
00:29:04.904 - 00:29:25.110, Speaker B: Abstractly define all these other functions or the functions that we just need. We just need a few functions for this example so we could abstractly call them in this interface and we say hey, these are the functions we want to call based off of their names and their input arguments and what they're returning, and then point at the address where that contract is deployed. And it's as simple as that.
00:29:26.200 - 00:29:28.100, Speaker C: You will need the access list for.
00:29:28.170 - 00:29:46.254, Speaker B: Contracts like this because it's at a different contract, therefore it'll be at a different Shard, unless you get lucky with the same prefix. There's a brief intro, went to Shardium, hope you all enjoyed. Love to see everyone check out the.
00:29:46.292 - 00:29:48.860, Speaker C: Shardium discord as well. Thank you for watching.
