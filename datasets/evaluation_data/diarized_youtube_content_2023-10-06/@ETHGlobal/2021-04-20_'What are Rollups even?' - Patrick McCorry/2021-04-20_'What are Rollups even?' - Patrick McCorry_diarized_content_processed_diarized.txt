00:00:00.090 - 00:00:15.418, Speaker A: Without further ado, I'd like to welcome our first talk of the day. Patrick McCourry is going to be talking about what are roll ups? And he'll be doing a really amazing talk on how everything works in this world. So, Patrick, welcome and I'll let you kick off with your presentation.
00:00:15.594 - 00:00:37.714, Speaker B: Awesome. Thanks for the introduction, Kartik. I'll just share my screen now. Hi, everyone. So I'm just going to quickly present for the next 15 minutes what even is a roll up. And what I want to highlight before I begin is that I'm not affiliated with any roll up project. So I'm going to try my best to give you an on pass view of the problems that they're trying to solve.
00:00:37.714 - 00:01:36.490, Speaker B: I currently work for Infuria and I also advise Lambda Cap. So, without further ado, as everyone's aware, this wonderful event is going to be about blockchain scalability for the next month. And over the past year, a bunch of new projects have emerged, like arbitrary Aztec Sellers, ek Sync, Optimism, polygon, Starkware, ZK Swap and Loop Ring. And these are projects that are called roll ups, that are promising low fees, smart contract deployment, transfers, and a much better user experience than developing on Ethereum. So what I really want to highlight is, why does this matter? What are the problems they're trying to solve? And hopefully set you up for the next three weeks, you can get a really good understanding what's going on. But before I get into that, I always like to ask people this question. Have you ever deposited coins into an Exchange or an online service like Coinbase Finance or Bitstum? Nobody asks people to raise their hand, but there's no hands here to be raised.
00:01:36.490 - 00:02:22.918, Speaker B: But pretty much, if you've ever used an Exchange before, then you've actually used a layer two system. You've had to deposit coins under the service. You get a balance that becomes positive on the website. You can then trade, execute transactions, whatever. And the idea there is that these intermediary services, Coinbase, Bitstop, Finance, et cetera, they're technically layer two sequencers. They take all of their users transactions, they order them, they execute them, then they update their layer two database, which basically determines how much funds you have on the service. Now, the problem with these layer two services is one, they're fully custodial, they can freeze confiscate, or they could even just lose your funds.
00:02:22.918 - 00:02:57.038, Speaker B: Two, they're not auditable that layer two database that they have. Can anyone here access the Coinbase database? Well, obviously not, because it's opaque and it's not publicly auditable. So the question then is, are these layer two services, are they running a fractional reserve? And we don't know. Who knows? We can't actually look at the database. And as I mentioned, they also control the ordering of transactions. So given a list of transactions, they can order them and determine how they're executed. So layer two is used every day, but it is custodial and is high risk.
00:02:57.038 - 00:03:53.634, Speaker B: Back in 2016, Goon had this wonderful tweet that 33% of bitcoin exchanges have been hacked. And then as they get hacked, they tend to be large scales. The amount Gox has lost 850,000 bitcoin, Bitfinix lost 120,000 bitcoin. And it's not because they're not being malicious or adversarial, it's just very difficult to keep custody of a large big honey pot of funds that a hacker can just get in, steal the private key and then run away about your funds. So the question is, all of these roll ups and all these cool layer two protocols, can we transact on a layer two system while still allowing users to maintain full self custody of their own funds? So, let's find out. What I'm going to explore today is I want people to get a better understanding of rollops and more generically, as Polygon said, commit chains. Because rollops are just a single instance within this entire design space, we're going to look at this from first principles.
00:03:53.634 - 00:04:51.070, Speaker B: So what is a commit chain and how does it work? What is the wider environment they live in? And what are the protocol assumptions? Who is the adversary? What is their power? And how are they trying to break the system and steal your funds? And finally, what are the security goals that need to be satisfied before a roll up is secure? And hopefully this will set you up for the rest of the hackathon. So the big difference with these commit chains is that you still have this sequencer that can be one sequencer or multiple sequencers. They're still collecting layer two transactions, they're still ordering the transactions. But the big difference is that they have to post little checkpoints to Ethereum periodically. These checkpoints will define the order of transactions and also the execution of all those transactions. So what is the current state of the layer two database? And there's like this little checkpoint that send to Ethereum. And so this big difference allows for layer one enforcement.
00:04:51.070 - 00:05:26.590, Speaker B: So it's up to the layer one to enforce that all these transactions are valid and correct. Then Alice comes along and Alice wants to use the layer two system. So Alice will still have to deposit one coin into this layer two system. But the big difference here is that this coin is deposited into a layer one smart contract and it's never given to the sequencer. So the sequencer never has custody of your funds. And typically you still have to do a signature in order to transfer funds in the layer two system. So this layer one contract that enforces the roll up rules also has custody of your funds.
00:05:26.590 - 00:05:55.706, Speaker B: Then Bob comes along. Hi, Bob. And Alice wants to sign a coin to Bob. So Alice will sign a transaction, give it to the sequencer, then the sequencer can ping Bob and say, bob, you've now got one transaction, one coin. But this isn't final yet, this is still pending. Until the sequencer posts a checkpoint to Ethereum. So we wait around, there's no new transactions, checkpoint gets posted, then everyone can see that Alice's transfer is confirmed and Bob has received the one coin.
00:05:55.706 - 00:06:47.758, Speaker B: And over time, checkpoints get posted and that finalizes the transactions. Now, the final difference, which really makes rollaps and commit chains beautiful, is that Alice should be able to use Ethereum, this layer one blockchain to get the ground truth data about the layer two system. It should also be able to fetch the entire transaction history for the layer two system and recompute the entire layer two database herself. And then she can verify that everything is valid and everything is correct. But what does it mean to be secure for a commit chain? Well, Georgia has this wonderful Twitter thread that says what makes layer two special is that layer two security equal equal layer one security. But I'm going to argue that's too ambiguous. Layer two protocols really cannot have the same security as layer one.
00:06:47.758 - 00:07:29.354, Speaker B: But they can get pretty damn close and it's really this pretty damn close is where the detail and the really cool innovation that's happening. So what does it mean to be secure? So now I'm going to cover the protocol assumptions and the threat model. What do we assume to be true? Who is our adversary and what special powers do they have? Then I'm going to talk about the security goals and what we're trying to actually keep secure. So, adversarial model, I'm going to break it down to two parts. First, the advertory has control over the message control flow. So any message is sent on the layer two system, the adversary can view, order and drop. So they can censor all the transactions in layer two if they want and they can reorder them.
00:07:29.354 - 00:08:13.782, Speaker B: The only thing they can't do, and this is a protocol assumption, is Alice can always reliably send a transaction to the layer one blockchain, which is Ethereum, and as long as he pays an appropriate fee, it will always get mined. And this also assumes Alice can always see the layer one, Ethereum, can always see the contents of that, and the layer two system can't stop her from looking at it. The second part of the adviceira model is that there's only two trusted parties. There's Alice, who's honest, the single user and the smart contract, Ethereum. We assume both of those parties are honest. Otherwise the adversary can corrupt everyone. They can corrupt every sequencer and they can corrupt all users.
00:08:13.782 - 00:09:11.382, Speaker B: So really, if I'm using this layer two system, I have to assume everyone can be corrupted and I still have to be safe and secure within that environment. So really, we've described the most powerful adversary possible. And really, not every rule app has the tools to fully constrain or outright defeat this beast. But another way to look at it is that it's a tag team battle between the honest user this layer one smart contract and they're fighting the sequence during the adversary to constrain it and make it bend to their will. And if you don't have this epic fight in your hands for a layer two protocol, then it's not really a layer two protocol and unfortunately, I'm not too interested in that. So what are the security goals? What are the security properties? What are we trying to keep secure? How are we trying to constrain this adversary? The first one is the data availability problem. So what do I mean by this? So, as I mentioned, the sequencer has to post little checkpoints to Ethereum.
00:09:11.382 - 00:09:50.406, Speaker B: It's typically a 32 byte hash. This will include the layer two state and the list of transactions that are being executed. So how do we guarantee that the entire transaction history for the layer two ledger is publicly available? So this is important for several reasons. One, audibility Alice wants to recompute the layer two database herself. She needs the transactions that recomputed herself two interaction if she's going to send a swap on uniswap on this layer two system. She wants to verify that the exchange rate she's being quoted is correct according to the layer two database. And finally, withdrawal.
00:09:50.406 - 00:10:27.418, Speaker B: If Alice wants to withdraw her coins from the system, she may have to inform the layer one blockchain what her final balance is that she's going to withdraw. And bingo. This is where we get roll ups. This is the only thing that roll ups solve in terms of all these problems. A roll up literally means all transaction data is rolled up and posted to the layer one blockchain. This is actually a slightly stronger assumption. We now assume the layer one blockchain has plenty of storage, it can store all the transaction data, bandwidth is not an issue, and everything can be stored on Ethereum.
00:10:27.418 - 00:11:07.614, Speaker B: But this is one of four ways to solve that problem. But that is what a roll up is, the state transition integrity problem. Now, so the issue here is, how do we guarantee that the final execution of a layer two transaction is correct? Because a sequencer could post a checkpoint which has the state and an invalid transaction that steals everyone's coins. And if the sequencer can get away with this, then obviously they can steal all the funds in the layer two system and it's not secure. So there's another bingo card. This is optimistic versus zero knowledge, fraud proof versus validity proofs. I'm not going to go into it now, but you'll hear plenty of debates over the next few weeks about the pros and cons of either approach.
00:11:07.614 - 00:11:27.970, Speaker B: But again, that's the only problem. Fraud proofs and validity proofs are solving state transition integrity. And the final problem is withdrawal integrity. So let's just say Alice wants to withdraw her coins from the system. So he says, Sequencer, here's my withdrawal transaction. Give me my ten die. And the sequencer says, no, you're stuck forever.
00:11:27.970 - 00:12:04.722, Speaker B: You're never getting your coins out. They're confiscated. The system should be set up so Alice can always withdraw her coins even if this sequencer is offline or does not cooperate. So now we have our three problems. Data availability, state transition integrity, and withdrawal integrity. If we can satisfy the above problems, then hopefully we can slay the beast, deploy a secure layer two system and everyone can have all their unicorns. But even if we can satisfy all three properties, do we still need the trusted sequencer? So the answer is yes, no, yes, no, yes, no one.
00:12:04.722 - 00:12:34.234, Speaker B: It depends how well people can satisfy those three problems and there's no perfect solution out there. But there's also other problems that pop up that relate to security. The first is minor extractable value. And you're going to hear a lot about this over the next three weeks. But the idea is that the sequencer can control the order of all transactions. So if I send in a trade on uniswap and I allow for $1,000 worth of slip each, the sequencer can sandwich me. They front run me, they back run me.
00:12:34.234 - 00:13:17.334, Speaker B: The victim transaction goes in the middle and they interfere with your computation and they extract $1,000 from your trade. They haven't tampered with your transaction, they've just played with the state so they could take the slippage. Is this an outright attack on an outright attack on the system? Or is it a potential business model? Is it the Robin Hood of rule ups? There's still a debate out there. But what we do know is mev is very profitable. You can go look the Flashbots project and they're making way more money than honest miners who just take the transaction fee. I think over 60% of miners now are now using Flashbots. But most importantly, we need to trust Sequencers because this is the difference between the fast path and the slow path.
00:13:17.334 - 00:13:40.846, Speaker B: And I mean the very slow path. If Sequencers are honest, I give my transaction to the sequencer. They'll acknowledge me right away to say patty, your transaction will be mine. This is the final execution and it will be finalized within the next two 3 hours. I walk away. I'm happy it gets finalized and the sequencer did what they promised. If the Sequencer cannot be trusted, maybe I give them my transaction.
00:13:40.846 - 00:14:35.006, Speaker B: They want to do some mev or whatever and I have no guarantee what the final execution is going to be. Then actually I may end up on the very slow path because one, I'm waiting for 4 hours or 2 hours to know what the final execution really was. But also I may just have to send the transaction to Ethereum directly. If I want it to be truly executed the way I want it to be definitely 100% included in the blockchain, then that's actually the very slow path and that's even worse than Ethereum today. So we still have to care who these sequencers are going to be and what keeps them honest. So what we need to consider is first, how are sequencers selected? Is it centralized? Are they appointed? Are they elected? Do they have stake on the system? And also the consensus protocol? How do these sequencers reach agreement on the next set of transactions to be executed? Do they take an intern to Alice? Bob carlin. Alice.
00:14:35.006 - 00:15:15.230, Speaker B: Bob carlin. Or do they have some BPFT protocol there? So, this is my final slide. I obviously haven't given many solutions in these slides, but what I hope that I've given you is a much better understanding about the problems that surround roll ups and throughout the hackathon. You can now poke your favorite project and say, how do you solve the data availability problem? How are you solving the data integrity problem? Do you deal with mev? Do you have order, fairness, et cetera, et cetera? So I'm going to finish with this slide. This is what a layer two protocol is about. And if you don't have this battle on your hands, then it's not a layer two protocol. So thank you for listening.
00:15:18.530 - 00:15:24.940, Speaker A: Thank you so much, Patty. This was super helpful as a context. And we also have a few questions. Come.
