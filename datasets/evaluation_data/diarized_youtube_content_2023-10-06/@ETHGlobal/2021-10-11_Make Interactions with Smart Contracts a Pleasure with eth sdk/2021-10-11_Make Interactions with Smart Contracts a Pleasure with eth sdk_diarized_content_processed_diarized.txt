00:00:05.370 - 00:00:17.600, Speaker A: Move on to our next talk. And next up we have Chris, and Chris is going to talk about SDK and how to make development a lot more pleasurable. So without further ado, welcome.
00:00:19.250 - 00:00:55.994, Speaker B: Hello. Let me share my screen. Okay, I think it works now. So, hello. Yes, my name is Chris Kachog and during the day I work as a software engineer for MakerDAO, working particularly on layer two stuff. And during the night I'm part of Dev Organization, where we're trying to make Ethereum developer experience better. Today I want to talk about if SDK a new this is actually award premiere.
00:00:55.994 - 00:01:35.558, Speaker B: So guys, free Alpha Incoming, a new tool that is a generator of lightweight and typesafe SDKs for Ethereum Smart contracts. And I'm going to unpack this in a bit. Now let's talk a little bit about the Ethereum dev landscape and how it evolved. So if you were using Ethereum few years ago, everyone was using web free JS and it was pretty raw. It didn't even support premises back then. These days Ethersjs is a king. Similar thing happened to Truffle and Hardhat.
00:01:35.558 - 00:02:27.258, Speaker B: And I'd like to point out a more profound change, which is a change in language that we use. A couple of years ago, everyone was using JavaScript. Now more and more people use TypeScript, and not only in blockchain community like you can see this rise of TypeScript everywhere. And some time ago you could think about TypeScript as some kind of add on to JavaScript. These days, TypeScript is more popular than full fledged programming languages like Know. Now these days a lot of libraries were rewritten in TypeScript. So for example, Ethersjs, it's written in TypeScript already.
00:02:27.258 - 00:03:37.742, Speaker B: As Richard mentioned, it's going to be even better supporting TypeScript soon. But still in some sense, web free JS with TypeScript is broken and it breaks exactly in the moment when you start interacting with smart contracts deployed on Ethereum. The problem is that to interact with a smart contract you need an API. And this is a piece of dynamic piece of JSON JavaScript that you basically inject into your blockchain access library and then you get some sort of object created during runtime that can talk with the smart contract. And the problem is that you cannot prepare typings to this in a usual way. And I recognized all of these issues some time ago, like the rising popularity of TypeScript and the problems related to web free interface word and created a tool called Typechain. So Typechain takes your JSON APIs files and takes information about your target.
00:03:37.742 - 00:04:21.530, Speaker B: So do you use traffic? Do you use Ethers maybe web3 JS and it generates TypeScript typings as a separate build step. So this way you have excellent ID support. You can just browse through the methods that are available on the Smart contract we support as well. Nutspec. That was already mentioned during this dev summit. As I mentioned, it supports officially many different targets. Ethers JS v four v five WebView JS truffle.
00:04:21.530 - 00:05:17.730, Speaker B: But recently we also added support for Hard hat which is kind of great. Like if you use hard hat you should totally give it a try. It's typing things like get contract add and so on. And I feel like typechain does accomplished a lot like a lot of well known companies like Uniswap Maker. Obviously optimism uses it, but it makes interaction with smart contracts a breeze. But it doesn't solve all of the problems that web free developer can encounter, especially during setting up the scene for smart contract development, for smart contract interaction rather. So you can imagine that the typical day in the web free developer life looks more or less like this.
00:05:17.730 - 00:06:13.780, Speaker B: Imagine that you get a new assignment to write some kind of script that gathers data or reads some events from multiple smart contracts. Or maybe you're developing a front end or backend, it doesn't matter. First of all, what you probably do is you gather smart contract addresses and maybe use it, scan for that. Maybe you browse and you just type in Etherscan Search to find the addresses, maybe use GitHub or docs of a given project to find all the addresses. But then you need to find APIs. Maybe if you're lucky you can find the APIs somewhere on the GitHub. But then you need to wire APIs with the addresses in code like create Ethersjs Contract Wrappers or something similar.
00:06:13.780 - 00:07:21.290, Speaker B: Then you need to generate typings if you want to have good developer experience and type competition. And only then you can start actual work. So if SDK tries to make this ceremony much more easier and enable rapid smart contract to enable rapid interaction with smart contracts. So I like to think about it as a love child of Ethersjs typechain and Etherscan and talk is cheap. So let's go and try to use it in a Hard hat demo. So here's a boilerplate code for Hard hat example. And this is a very simple code that it's configured to fork Mainet from a particular block and we can start writing code.
00:07:21.290 - 00:08:49.910, Speaker B: Note that there are no useful contracts here. We're going to interact with mainnet contracts and the only reason we use hardcut is for fork features and what we want to do here. Imagine that it's I guess one week ago and compound hack just happened and you're a white hat or just person curious and you want to realize what happened. You don't know too much about compound smart contracts but you still have addresses of the contracts and you want to dive right into it and try to play with it, try to reproduce the original claim that caused like minting a lot of comp tokens and try to play with the whole setup. So usually now you would start dumping APIs in your code and so on and so on and it would take you some time. But now we can use if SDK and to do that we can go right to the GitHub and grab a command to install it. It's to the dependencies and once it's installed we can use it right now.
00:08:49.910 - 00:09:26.718, Speaker B: So first of all we need to create a config file. So If SDK will read all contract information from contracts JSON config file. So in this file we define all of the contracts that we want to interact with and I already have this piece of code ready to copy so let me just dump it. Yeah. So first we need to specify a network that we want to interact with. Here. It's Mainet.
00:09:26.718 - 00:10:40.730, Speaker B: And then we can start writing arbitrary nested list of smart contracts. So we can have this namespaces like tokens but at the end of the day is name of a smart contract and address that it lives on the particular network and we do the same for other compound smart contracts like Comptroller which is responsible for dealing out the rewards. It's a proxy so it has Comptroller implementation and the treasury. So there's another interesting bit about this attack and that's why we need treasury now. It's the moment when we can actually run If SDK and see what happens. So now it read config file and it's getting APIs automatically and it's generating client and notice that client was generated directly to node modules and now we're good to go to start interacting with the smart contracts that we defined. So let me import the SDK.
00:10:40.730 - 00:12:02.066, Speaker B: So this is the If SDK client package and we have get Mainet SDK and this function is tailored based on the config that we just created. So here we're going to call it and we're going to pass signer and you can see that it matches the shape of this object matches exactly the shape of a config file. And if we go inside we see that there are a bunch of typings and in the runtime these are ether JS contracts that are already configured to be used. So the interesting bit about the compound attack was that there was a treasury contract that could be used to drip even more compound tokens into treasury. So just to test that, let's actually test first the Drip function. So we're going to add some logging here, let's say before Drip and we're going to call some methods. So we're going to check the balance of Comp token on the Comptroller address.
00:12:02.066 - 00:13:12.700, Speaker B: So if Drip function works correctly, we should see that the balance was increased, need some formatting and we need to import this function. Okay, now we can call Drip function and notice that I'm not an expert in compound contracts but thanks to type competition I can write my code pretty quickly. And here again I forgot to handle promise. But since everything is typed correctly, I got immediately an error in my idea about this. So now we're calling Drip function and after Drip this balance should increase if Drip works correctly. So here I have a script to execute the code that we just developed. And yes, we can see that Drip is causing a lot of new comp tokens available.
00:13:12.700 - 00:14:32.046, Speaker B: Now we can try to replay what original, maybe not attacker, but the original claimer did. So we want to claim tokens and receive much more rewards than we should receive, right? So again we're going to print out balance, but this time before claim and we're going to print out balance of the EOA that we're interested in. Now we can call. So there's another thing that we need to actually initialize controller because it's just a proxy. So we need to take the implementation and attach it to the comptroller address. Okay, with this we can do claim and notice that there are a bunch of overloads but this is the one that we're interested in. The holder is again, our EOA and C tokens is the list of citokens that the rogue claimer claimed.
00:14:32.046 - 00:15:23.548, Speaker B: And finally we can print out the balance again of the EOA. So if things go well, we should see like this claim causing a lot of rewards to be sent to the EOA. Let me run it again. It's a little bit slow because it's fork mode. But yes, we can see that there was a bunch of comp reward sent to the user. I don't know, we can play with this code. But what I wanted to present here is that we were able to start interacting with a system that we know almost nothing about and write a script that does something meaningful very quickly and writing.
00:15:23.548 - 00:16:06.240, Speaker B: So it's funny, because if SDK wasn't ready, really one week ago, as I told you, it's a word premiere. And I was writing similar code and I made a typo while copying one of the addresses, and I was interacting using the wrong API to the wrong address. And I spent like, half of an hour trying to debug it. So with If SDK, it's all very simple to code. Now, continuing my presentation. So as you could see, If SDK generates this lightweight typesafe ready to use SDKs. It works for different networks.
00:16:06.240 - 00:17:15.684, Speaker B: We care about the network config because you need to have a way to connect to Etherscan and get verified contracts for this particular network. So that's why we support Xpcd list networks, but it's pretty long, including things like optimism mainnet. We generate SDKs directly to node modules. So if you're familiar with Prisma, this is exactly the same approach. I think it's quite nice because the import paths are always the same and they are short. And as I said, it's perfect for writing any scripts, one time scripts or front ends or backends diving a little bit more into details. APIs that we gathered are stored in the if SDK APIs directory and this directory should be actually committed to the git repository to avoid querying contracts.
00:17:15.684 - 00:18:29.676, Speaker B: Again when you execute if SDK again. Another trick is that you could add executing if SDK as a post install script. So it's much easier to use because you always need to generate the client code. Client generation is a little bit complicated because first we generate TypeScript code, we generate typings, and only then we run TypeScript compiler to get JavaScript code that you can easily place in the Node Modules directory and Node Modules insertion I already mentioned. So what are the future plans? So, we would like to have a first class support for Hardcut. So right now you saw it's quite an opinionated tool. If it comes to what you're using, you could use it with whatever you want, but we can improve the integration for some of the frameworks.
00:18:29.676 - 00:19:26.472, Speaker B: So, for example, for Hardhat we could register the APIs so Hard hat knows more about them and can print meaningful error messages and so on. We would love to integrate if SDK with used app that Mark mentioned today and the bit that I didn't like during demo. You could notice that users are forced right now to reconnect proxy with implementation. So we could also automatically query proxies to get always the valid implementation. So if we recognize that a given contract is a proxy, we can always query implementation and then query API for this implementation and then merge this API. So this would be, I think, a pretty nice feature for end users. Finally, we are planning on supporting alternative API sources.
00:19:26.472 - 00:20:23.030, Speaker B: So Sourceify was mentioned here today already and I think it's an excellent tool that we should integrate with because Ether scan is pretty great. But it's a closed source for profit company, so it's always nice to have a decentralized alternative. And then we're thinking about supporting dynamic addresses, for example, for local network, when you can provide them by hand and just enjoy the typed shell. And that's it more or less you should join our discord. So at Dev, we're focused on improving Ethereum developer experience. There's a couple of people involved in the organization here are social media, and I'm open to any questions right now. Thank you.
00:20:25.880 - 00:20:38.010, Speaker A: Thanks so much, Chris. No, this is really great. I think kind of a couple of questions. The first one is, just as a confirmation, are you getting the Abis from Etherscan or somewhere else? And how does that work?
00:20:39.020 - 00:21:12.310, Speaker B: Yeah, so I think I answered it at the end, but yeah, right now we use Etherscan API. There's actually a key Hard coded somewhere deep in If SDK. So I hope you guys don't do and but yeah, the better idea would be to use Sourceify or at least have some multiple backends. But for now, Etherscan was a way to go.
00:21:12.680 - 00:21:37.950, Speaker A: No, that makes a lot of sense. And I think one super cool part of this is that so many talks today, they're all interconnected and they're just helping basically modularize each other. So it's just great that I saw you step with Sourceify and everything here. I know you already touched on this thing, but what are some of the feature things that you're trying to integrate or add features for? And how do you think this will evolve over the next six to twelve months?
00:21:38.560 - 00:22:38.050, Speaker B: Yeah, so I think a single biggest feature that we're looking at is integration with other libraries tools in the ecosystem, particularly the ones that you would use on front end. So Maglek was showing today, Used up and Used Up is great, but if you were paying attention, you would notice that Smart Contracts interactions right now at Usedap is totally untyped. Right. I bet that the whole thing is written in TypeScript. But again, as I mentioned at the beginning, interacting with Smart Contracts, it's a little bit more difficult. So we would like to integrate with tools to provide this first class support for typed Smart Contracts. And it's not something that you do.
00:22:38.050 - 00:23:10.964, Speaker B: The reason why we're doing is that because it saves you time in the longer term. Right. Like now, these days, if I write some code without having type information and basically guessing, I need to go again to check the documentation or check the source code of the Smart Contract, to double check the arguments or whatever. Having all of this in the ID is just a game changer, and it makes writing code so much faster and debugging.
00:23:11.012 - 00:23:13.676, Speaker A: And that's just a bad yeah.
00:23:13.698 - 00:23:32.796, Speaker B: And this bit, like last thing, this bit that you could see that I forgot about await in one place and literally spot it right there and just say, hey, you forgot Await. This is exactly the thing that we are missing when coding. Just in JavaScript.
00:23:32.988 - 00:23:45.140, Speaker A: Absolutely. And then just kind of lastly, to close, are there some immediate things that people can help with in terms of contributing to the project directly? Or how is that structured and how can people get involved?
00:23:45.720 - 00:24:29.410, Speaker B: Yeah, so I would encourage all of you to just jump on a discord channel. And it's a very fresh channel, so not so much going on there now, but this would be a perfect place to try to coordinate. And if SDK is in quite experimental stage right now, where we're just trying to figure out what's the best way, for example, to define the config or to define some other things, like, I don't know, the CLI interface. So I would encourage anyone to just drop us some feedback and so on.
00:24:29.780 - 00:24:44.730, Speaker A: Awesome. Well, hopefully that was helpful for everybody, too, and it's a good reminder for everybody to join the discord and make it more lively. Chris, thank you so much for that amazing demo and present invitation, and can't wait to myself use the testdk and have others try it out too.
00:24:45.180 - 00:24:46.072, Speaker B: Thank you.
00:24:46.206 - 00:24:46.950, Speaker A: Amazing. All right.
