00:00:00.490 - 00:00:27.794, Speaker A: The topic is like, on the more technical side, but will be based just off of what I've learned as a developer in the space over the last kind of couple of years trying to develop Composable Smart contracts. And so if at any point you guys have any questions, feel free to ask. There's not a lot of people in the room, so I'm happy to pause and answer. Cool. So, yeah. Who am I? I've been a DAP developer since 2016. I'm the co founder of a project called the Bounties Network.
00:00:27.794 - 00:01:12.482, Speaker A: We build the standard Bounties protocol which is, if you're familiar with Gitcoin, the project who presented earlier, we power the Bounties on their platform. And so the goal since the beginning of 2017 has been for us to build this standard for Bounties on Ethereum. So that if you guys are familiar with a bounty, like a request for someone to do work or something, that it would be very easy to integrate that with any other DAP which wanted to request particular types of work or for different marketplaces to share different work orders. So, for instance, I could create a bounty on Gitcoin, let's say, and automatically have it end up on the Bounties Network as well and any other marketplace that wanted it. So we've been doing that for a long time. And generally, I love composable smart contracts. I think they're really cool.
00:01:12.482 - 00:02:15.734, Speaker A: I think Composability is one of the most interesting parts about Ethereum. To give you some more background into what is Composability, this was kind of what you asked. Composability is this concept in computer science and in general with regards to architecting code. And it's the ability to combine a series of independent pieces of code into much larger, more useful pieces. Code that is very composable is that which is I have a couple of things here which is like self contained code which doesn't rely on a large other web of other pieces of code is much more easily reused as a component of a larger system. And also when code is stateless, this makes code very composable again, because it's very easy to sort of combine functionality of different kind of calls into much larger, much more meaningful calls. And so Ethereum is this network of Composable code, right? You have these smart contracts which can all talk to each other.
00:02:15.734 - 00:03:18.138, Speaker A: And so Composability is something that was possible on a very local scale on people's machines before Ethereum, but it's now possible on a more global scale because you can have interactions between people's code that they didn't write necessarily in a very easy way. And so just going on a little bit on why that's so cool on Ethereum. So this is like one of the most interesting things about Ethereum and the EVM in particular, in my opinion, is that code, each smart contract gets its own address and so can be treated as the same as an individual, which means that any actor can also be a piece of code. Which means your code can very easily interact with other pieces of code by being an actor, so to speak, within that contract. And so the fact that this is natively available makes it very easy for us to, in theory, have our code talking to each other in a really nice way. We don't see that as much in practice, but it's very possible, which is interesting. Another reason composability here is cool is that the smart contracts can't change.
00:03:18.138 - 00:04:06.540, Speaker A: If you have something you're building and you want to depend on another piece of code, you don't have to worry about that piece of code ever changing. You can reference it at a particular address and you can kind of trust that it'll always be there. And so that's pretty valuable and pretty important. Although it becomes a double edged sword, as you'll see later. You can automate complex and valuable transactions by stringing together simpler transactions. So this is sort of like what Ethereum offers to spaces like DeFi and stuff, where you can have a string of very individually expensive market transactions or value transfer transactions and you can batch them together. And this means, of course, you can do that within one contract, but you can integrate many, many different contracts that other people are writing rather than having to do it all yourself, which is pretty interesting.
00:04:06.540 - 00:04:56.860, Speaker A: And finally, the thing that kind of got me excited about Ethereum in the beginning when I was first getting into the space was this idea of a network effect of applications. So network effects for you guys is like when you use a social network, there's a network effect because the value to you as a user goes up with each number of additional users who are there. And so Ethereum has that as well, right? Like the more people who are on Ethereum, the more people you can transact with, which is valuable. Right, but it's also valuable for the applications. The more applications there are on Ethereum, in theory, the more valuable each of those applications is because it has more other applications it could talk to. And so an example of this I'll get to right now is like DAOs and Bounties. So dows, I'm sure you guys are familiar with, they take in money and they disperse that money doing different things.
00:04:56.860 - 00:05:52.266, Speaker A: Token holders from a dow can automatically create bounties which spend their tokens, which is kind of like a core part of their mission is allocating capital bounties automatically get surfaced on one or more different marketplaces. Kind of like I mentioned with Gitcoin. So for instance, if an Aragon dow creates a bounty, it can automatically do that directly in the contract and without even notifying gitcoin. That bounty can automatically end up on Gitcoin because it's like a code bounty and they automatically screen for those. It similarly might end up on bounty's network as well. And then finally the Dow can vote to accept submissions and disperse them, which is very interesting. And we see that for us as an application, the more Dows there are on the network, the more that we have users of the contracts, right? The more sources there might be for people to create bounties.
00:05:52.266 - 00:06:44.894, Speaker A: And similarly for Dows, the more applications there are like bounties maybe like grants or listings or all these other different transaction primitives. The more of those that there are, the more valuable it is to have a Dow on Ethereum because you can now do more with it. So that's sort of the network effects idea. So getting into the problems, problem number one of why we see this composability is not working and for background, composability is something that we talk about a lot in theory, right? And this idea of combining projects as something we can do on Ethereum, but studying how frequently it actually occurs, the answer is that it's fairly rare. The first reason is that the code just isn't very modular. People don't write code and reuse their code. People are constantly rewriting the same code.
00:06:44.894 - 00:07:33.550, Speaker A: For instance, the Safe Math library isn't rereferenced in every contract. We don't just have the same functionality there, we're reusing it. We're redeploying these libraries every single time we deploy a new contract. Same thing with ERC, 20 tokens and stuff. And so in general, it's very expensive to write modular code because you're breaking up your code into a much larger subs group of contracts. Basically that's more sprawling and it's almost always more modular code is more generalized. And so it's usually much cheaper to write very specific code and smart contracts for a given use case, for a given set of users, for one particular interaction, rather than having to write code that works for all types of interactions.
00:07:33.550 - 00:07:35.120, Speaker A: Welcome.
00:07:37.090 - 00:08:00.226, Speaker B: This is not done by design properly. One would think, abstracting from the actual implementation, that writing modular code should be the same. It's hard to think that doing things the right way or like doing things that you can reuse it's more expensive.
00:08:00.418 - 00:09:11.040, Speaker A: Yeah, so in theory it should be less expensive, right? Like in theory reusing code that's already on chain and not having to redeploy it in theory is less expensive from a gas perspective. It's not necessarily less expensive from a time perspective because again, we don't have tooling for people to test contracts against live deployed contracts. And so for testing code, this is expensive not just in terms of gas and maybe this is probably the bad framing, it's actually also time expensive, but it is also actually just more gas expensive. Practically speaking, when you see Aragon's DAOs for instance, are very modular, their code is very clean. But it's much more expensive to deploy the same Malik Dao structure on Aragon than it would be in the Molokdao contract. Because the Molokdao contract is very specific. It's like one use case versus when you write modular code it's like self contained, it's usually more generalized which means you're passing in more parameters which means you might be storing more state potentially and there might just be more code.
00:09:11.040 - 00:09:51.850, Speaker A: So yeah, this is kind of expanding on that. Users most DApps aren't modular and their contracts aren't modular because they're not this sort of like maximally generalized version of whatever they're doing. They're usually more specific. And again, we talk like that makes sense why they might be more specific. It's easier, it takes less time, it's usually less gas. But what it means is that if they're more specific it makes it much harder for them to actually interoperate with each other for different contracts to talk to each other because they're too opinionated for them to be able to do that. And then finally what we see is people modularizing their code too early.
00:09:51.850 - 00:11:23.430, Speaker A: People who believe that there are certain functional lines with which they should divide their code bases and this is not based off what actually should live in different contracts based on what is changing maybe or different types of plugin type systems that people might want to have for a different component. People just kind of come up with their own little modularization and little componentization of their contract and assume that's right and often it's not and it ends up being a waste of time and money. Next we go into the issues that people run into when actually combining functionality. The first problem is that most of the code on Ethereum is very stateful. People don't write a lot of functional code and so what it means is that it's like reusing this code is very difficult because all of the code that you're running is constantly referencing particular memory within the EVM state. And so what that means is that combining it is very tricky and requires just a much more directed view making sure that a particular thing like, let's say a bounty is like we're interacting with just that bounty and doing a series of things with just that bounty versus if we had very functional code we could reuse code and combine it in this way that we just kind of know it works because the output of one function is the input for the next function and that's how really good functional code bases work. The other thing that's really interesting is that you can't really combine functionality very easily.
00:11:23.430 - 00:12:14.002, Speaker A: You can batch transactions on web3 kind of they still get sent as disparate transactions but really the only way to combine these stateful calls is to do it within a third party proxy contract. And so what you see is a lot of functionality requires multiple ethereum calls where you're constantly signing transactions. And some people say that's a wallet problem, some people say it's an EVM problem, but it nonetheless makes it more difficult to combine things. And it seems like there's a missed opportunity there. And then finally, the interfaces between contracts are really opinionated. They're not standardized. My favorite example of this is like some contracts use bytes for string information, some people use strings.
00:12:14.002 - 00:13:06.040, Speaker A: And different teams will tell you there are different reasons why. Some people use anything that's not like a UN 256. They'll use like a UN eight or UN 16, whereas most of the time it's more gas expensive to do that depending on the functionality. So there's just like all of these weird ways in which these interfaces are not usually configured to talk to each other in really nice ways. And so it requires a ton of casting and just very directed view on each of the ways that you're combining for it to work, which means it just takes more time to combine, which means it's just like harder for people to do. Next you can't update the code. Again, this is kind of something we talked about earlier is like one of the good things about the composability of Ethereum is that people can't update the code and so you can depend on it and it's always going to be the same.
00:13:06.040 - 00:13:57.746, Speaker A: The hard part is that code still needs to be updated, that we're still not finished. A lot of what we're working on is still very beta and so we require the ability to update a code base. Most of the time it doesn't suffice to be able to update a proxy contract or update the contract it points to. You see some teams getting kind of shouted at online these days for having the ability to do that because it's a pretty big attack vector to be able to change the functionality of a particular contract for some third party to be able to do that. And so, yeah, what we're seeing is like software dev cycles are turning into hardware dev cycles where basically software development cycles are supposed to be very short. You're supposed to be able to write code, test it immediately and deploy it immediately. And so those dev cycles are supposed to be very tight feedback loops.
00:13:57.746 - 00:14:27.422, Speaker A: Hardware dev cycles are the opposite. Hardware takes much more time to build, to test, to implement. And so what we see with smart contracts is that our dev cycles resemble hardware dev cycles far more than software. Or we don't ship smart contracts on a regular basis. We kind of do the opposite, which makes it much more difficult. And most software devs don't know how to work under those dev cycles. And then finally, you can't notify contract authors if you do have an update.
00:14:27.422 - 00:15:13.074, Speaker A: So for instance, for us, when we have a new version of the standard Bounties protocol, we deploy a new registry. We don't update the registry, we just have a new one that we add to it. And if we're talking about a company like Aragon, for instance, that has a native integration with our contracts, it needs to know where to point and we could update like an ENS name and the address there to notify it there. But there's no automatic way for us to get in contact with them. And that works for us because we know the error. God team, we can contact them, we have their emails. But if somebody wanted to sort of permissionlessly work on our code, there's certainly no way we could notify them or get in touch with them about the fact that we're changing the code or that something's wrong or anything like that.
00:15:13.074 - 00:15:55.198, Speaker A: So that makes it very difficult for two teams and two contracts to collaborate and interoperate with each other. And then finally there's like people problems. Users rarely kind of compose on their own. The users of smart contracts usually are devs and so the onus usually falls on the components to have the desire to collaborate with other teams and to build those integrations natively, which means it had better be in their best interest because otherwise they probably won't do it. It's also just generally difficult to collaborate across teams. It takes time, it takes effort. Different teams have different norms and different cultures, which doesn't always make it easy.
00:15:55.198 - 00:16:45.360, Speaker A: And then also, of course, it's expensive just to spend the time figuring out how to do these interoperations. Composability makes markets more efficient. But also that means usually that there are lower barriers against competitors which isn't always in the best interest of these projects. Again, when you have an open marketplace, for instance, or this open ability for any Dow to be able to do something, whether it's an Aragon Dow or a Dowstack Dow, that lowers their competitive advantage that they have against each other because the markets are sort of more efficient, they're more free. And so that's like a problem for those competitors. And that's one of the reasons why people don't like collaborating in the space. So now what? Well, the good thing is that people are beginning to modularize their code better based on the way that they've been used.
00:16:45.360 - 00:17:39.210, Speaker A: A lot of things like Dows, even Bounties have been around for a year or two and people have just seen what needs to be changed, what works, what doesn't. And so now it's sort of a more appropriate time to start breaking up code into smaller pieces that people can reuse. Teams are gaining motivation to collaborate. We see things like the Libra project coming up, where we see that Facebook is very much moving into the crypto space and I think we see an increasing number of teams seeing that they can't build everything on their own. They need to collaborate with other teams and so they're motivated to do that and to spend the resources and the time to do that. The ecosystem is evolving the way that we do code upgrades, which is great, and the ability to test different things is good. I think we're still very early in that sense, but nonetheless it's getting better and then finally people are writing more contracts.
00:17:39.210 - 00:18:32.110, Speaker A: This is kind of the most exciting part about Ethereum is that our state continues to grow, which kind of sucks sometimes, but also so does the design space of Ethereum contracts and interesting Ethereum contracts. And so kind of back to thesis that I started with, we believe that there's this application network effect that with every application that people build at events like this one, it makes all the other applications more valuable and more useful. And so just by virtue of us, like waiting and having more of this happen, the network itself already gets better. So that's all for me today. If you guys want to do some bounties, I have to give a shameless plug. We have a bounty network, lou Bounties network. We have a ton of interesting bounties there if you want to some of them just for your hack projects, some of them that are not related to your actual hack, you can write a poem and stuff like that.
00:18:32.110 - 00:18:40.160, Speaker A: And of course, if you want to get in touch with me, here are some great links. But yeah, if you guys have any questions, I love to answer them. Thank you.
