00:08:15.410 - 00:08:17.670, Speaker A: Oh, yeah, that's perfect. Thank you so much.
00:08:17.820 - 00:08:18.502, Speaker B: Oh, great.
00:08:18.556 - 00:08:19.254, Speaker A: That's a great help.
00:08:19.292 - 00:08:19.654, Speaker C: Okay, cool.
00:08:19.692 - 00:08:21.126, Speaker A: We can actually start now.
00:08:21.308 - 00:08:22.040, Speaker B: Sorry.
00:08:26.840 - 00:08:32.660, Speaker A: Okay, this microphone, is it on? Okay, cool. So make sure we use the mic.
00:08:32.730 - 00:08:33.350, Speaker B: Okay.
00:08:40.440 - 00:08:41.510, Speaker D: Turn it up.
00:08:42.280 - 00:08:42.596, Speaker E: Yeah.
00:08:42.618 - 00:08:43.380, Speaker D: Mika.
00:08:48.660 - 00:09:01.476, Speaker A: Okay. I think we can kick this off now. Once our slides come on, we'll start presentation. But I'm Natter Dabbot, and we're going.
00:09:01.498 - 00:09:20.184, Speaker B: To go through a presentation and then a live workshop. Oh, yeah. Thank you. Part one will be kind of just following along, looking at the presentation. Then we'll break out our laptops, and you can follow along the workshop in real time. We also just published the repo and the slides and the code on Natter's Twitter. So you can go grab that now.
00:09:20.184 - 00:09:23.610, Speaker B: So you can follow along while Natter is working on it, or you can follow along later.
00:09:24.460 - 00:09:25.210, Speaker C: Okay.
00:09:35.300 - 00:09:38.560, Speaker B: And the slides and the code on Natter's Twitter.
00:09:52.840 - 00:09:54.144, Speaker A: It seems disconnected.
00:09:54.192 - 00:09:54.644, Speaker E: Good.
00:09:54.762 - 00:10:25.512, Speaker B: Yeah, most of the slides are caribo. Okay, perfecto. Great. Okay. Boyamani hard spanglish for casamas in Colombia. Just like Colombiana. I said I'm going to kind of maybe speak in Spanish in some parts.
00:10:25.512 - 00:11:01.236, Speaker B: One of my kind of core key mission statements as a developer advocate is to make sure that computer science education in general is widely accessible to people from all over the world. And that means that when you're in a different country with a different language, making sure that those people can access the education in the same way. I did a check here, and everyone here speaks English, so I'll lean more towards English on that for sure. And all of the stuff that's published is in English, but it would actually be great for us to potentially translate it. So cool. We're going to do a Foundry workshop, a complete introduction to smart contract development with Foundry. So Nader is being my emotional support right now, but then we're going to switch.
00:11:01.236 - 00:11:32.100, Speaker B: Then he's going to get on, and I'll be his emotional support. Cool. So Foundry is a portable, fast, and modular toolkit for ethereum application development. So you might have heard of it, but you might have heard of others that fall into the same category in that part of the stack. So maybe hard hat, maybe truffle. So it falls into the same place it does the same thing, where it's tooling around development. And we'll talk about exactly what are some of the unique values and the unique propositions that Foundry has and how you can leverage it in your smart contract development.
00:11:32.100 - 00:11:38.532, Speaker B: So why foundry? Like I said, there's other competitors if you look oh, is it ugly for you guys, too? Yeah.
00:11:38.586 - 00:11:38.804, Speaker E: Okay.
00:11:38.842 - 00:12:13.360, Speaker B: So it's in the middle. So there's hard hat, there's truffle, there's brownie, there's anchor. But kind of like, what is the unique proposition of Foundry, and why are we here talking about Foundry specifically? So a few different reasons. One is that it lets you write your tests in solidity instead of JavaScript. And we say instead of JavaScript because I think at least for both of us, before Foundry, we were using Hard Hat. And when you're writing your tests there, you're writing your tests in JavaScript even though your smart contracts are in Solidity. So with Foundry, it allows you to kind of have just less context switching and less mental overhead of writing in one language and then testing in a different the next one is that it's really, really fast.
00:12:13.360 - 00:12:54.520, Speaker B: If you've used Hard Hat or anything else, and then you use Foundry, you'll be able to feel the difference and tell the difference. And it's partially because it's written in Rust, so it's able to leverage a lot of the key properties that come with Rust and why Rust is gaining so much popularity right now. Another really cool thing that we're going to go over today in the workshop is an improved developer experience with Fuzzing. So Fuzzing is an automated testing strategy that basically lets you, as a developer, make sure that you're testing for all possible cases. So when you write unit tests or maybe functional tests, you're checking that an output for a very specific input matches what you expect. So you're like, check that the output equals one, check that the output equals two. But there's no way that you can manually write tests to handle every possible outcome.
00:12:54.520 - 00:13:45.880, Speaker B: So that's exactly what Fuzzing does, is it makes sure that you as a developer are seeing all of the edge cases, all of the kind of failed cases that are out there so you can make sure that you're handling. So, okay, one of these are out of pocket, out of order. So talking about the tools that come with Foundry and what we're going to talk about exactly today are Anvil, Forge, and Cast. So starting with Anvil, anvil is a local ethereum node similar to what you've already seen in Hard Hat or Ganache, where you can spin up your local ethereum node and use it for testing your contracts and interacting over RPC. Cast is another CLI tool that allows you to interact with the smart contracts. This is where you actually send transactions, read data from the network. And we're not going to talk too deeply about this next part, but I would encourage you guys to check it out in the Foundry book, which is linked at the end.
00:13:45.880 - 00:13:56.350, Speaker B: CAS also has some really cool subcommands that you can use for decoding call data and sending arbitrary messages and a bunch of other things. And then this is the one that was in the wrong place.
00:13:58.560 - 00:13:59.420, Speaker A: CAS.
00:14:01.700 - 00:14:12.624, Speaker B: Oh, forge. Okay, well, I didn't put one in the slides, but the other one is Forge, and that's like what you use to call it.
00:14:12.662 - 00:14:17.492, Speaker A: It's kind of one of the main commands that you're going to be using on the CLI to generate a project and run tests and stuff.
00:14:17.546 - 00:14:37.340, Speaker B: Yeah, like when you do hard hat in it. It's the equivalent to that. So when you're doing forge so now we're going to actually walk through. If you want to pull out your laptop, you can follow along. If you want to do this later on your own and just watch, you can do that. If you want to follow along, go to Natter's Twitter. He just tweeted out the link to it so you can see it up close, so you don't have to squint.
00:14:38.000 - 00:14:39.740, Speaker A: Thank you for that introduction.
00:14:40.720 - 00:14:44.056, Speaker E: So I'm going to get off stage.
00:14:44.088 - 00:14:47.230, Speaker B: And help people if they run into stuff while we're doing it. Yeah.
00:14:48.340 - 00:15:40.280, Speaker A: So what we're going to be going over today is an open source GitHub repo that you can obviously follow along with today. Or if you are watching at home or watching this at any other time and you don't have time to follow along, you can do this obviously at another time. But I've kind of tried to make this the most concise introductory level workshop to kind of get all of, to me, the most important, exciting things about Foundry covered in a short amount of time. And along with this workshop, I've linked to a couple of really great resources. One of them is the Foundry Book, and it's a great resource, obviously. The other two, though, are one of them is something that I actually reference almost on a daily basis when I'm writing smart contracts with Foundry. And this is something I created called the Foundry cheat sheet.
00:15:40.280 - 00:16:22.504, Speaker A: And this basically just has all of the copy and paste commands for the 90% of the work that I do with Foundry. So you might want to know, oh, how do you send a contract call to an address that's local? How do you send a contract call to a live contract? How do you do this or that? There's a lot of good copy and paste code that you can use here. And I believe that we are going to actually merge this into the Foundry Book. There's already kind of a GitHub issue open there. So for right now, the Foundry Cheat Sheet is separate, but it might be part of the book later. And then the other is a video tutorial that I've done on getting started with Foundry. It's very similar to this workshop, but maybe a little bit more in depth.
00:16:22.504 - 00:16:55.556, Speaker A: So with that being said, the only prerequisite for this workshop is that you have rust installed. And if you want to see where this actual GitHub repo is, it's actually GitHub.com Dabbit Three. I think the URL was actually the slides there. So GitHub.com Dabbit Three, the very top workshop should be there. And the things that we're going to be covering today are testing and assertions, fuzzing, logging, running a local node and deploying to that node.
00:16:55.556 - 00:17:38.388, Speaker A: We're going to be looking at calling contract calls directly from your command line to that local node, installing and using libraries. So in hard hat. We can use NPM to install like open Zeppelin contracts and stuff like that. And with Forge, you can actually do the same. We're going to look at how to configure the remapping so that your text editor understands where these libraries are, but also the development environment knows where those are as well. And we're going to also look at some of the more interesting things that you're going to probably doing on a day to day basis, like mocking users. So let's say you want to kind of like run a contract call from one user and then test it out by transferring a token to another user and all that stuff.
00:17:38.388 - 00:18:08.988, Speaker A: How do you do that? Well, we're going to cover that today. And that should be, I think, a really great overview. Once you go through this, then I think at least for me, this was everything I needed to get started building. So with that being said, Cammy kind of gave an introduction around a lot of this overview stuff that I'm going to skip now. And we're going to actually go directly to getting the installation done. Now, if you don't have Rust installed, it might take a little time for you to actually do that. So you might not be able to follow along.
00:18:08.988 - 00:18:41.252, Speaker A: But once you have Rust installed, you're going to be installing Foundry up. And once you have Foundry Up installed, you can just run this command Foundry Up. And this will either install Foundry or it will install the latest version of Foundry. So before this workshop, I ran Foundry up and broke everything in the workshop because things changed. So I had to go back and make some updates. But the only thing that really changed with the new update was the actual original contract that was scaffolded by Foundry. They used to just scaffold out an empty contract.
00:18:41.252 - 00:19:16.576, Speaker A: Now they scaffold out a counterexample, which is actually much nicer. And honestly, it's also a good contract to play around with if you're learning. So with that being said, what we want to do is install Foundry by running this command and running Foundry up, like I mentioned. And what that's actually going to do? It's going to install a couple of different libraries or a couple of different tools, I would say. And Kami already kind of covered those. But once you do the installation, you're going to have three different CLI commands available to you. One is forge, one is CAS and one is Amble.
00:19:16.576 - 00:19:47.388, Speaker A: Forge we're going to use to create a new project. We're going to use it to do testing and stuff like that. Cast is actually what you're going to use to then make contract calls against any live contract. And it doesn't have to be a contract created by Foundry. Actually, you can literally just use this cast to interact with any live EVM network, which is cool. And then Amble is what you'll use to spin up a local node. So with that being said, we're going to run Forge Init, and this will scaffold out a new project.
00:19:47.388 - 00:20:20.740, Speaker A: So I'm going to go ahead and open my command line. And is that readable for everyone? Okay, cool. Try to make it big enough. So we're going to run Forge init. Well, first of all, let me just show you that we're in an empty directory now. So Forge Init will scaffold out a new project. And while that's scaffolding out, I'm going to open that up in my text editor and we're going to look at the folder structure and we're going to see that we have the SRC directory, which holds our main contracts.
00:20:20.740 - 00:20:51.970, Speaker A: We have our test, which holds what our tests obviously. And then we have our script, which is actually what you're going to use to deploy your contracts. And scripting is actually really cool. And I think it's something that wasn't there when Foundry first came out. And then Lib is like the node modules, but it's for this environment. So if you install open Zeppelin contracts, it'll go in the Lib folder and you can immediately start doing things. So if you wanted to run a build, you could say Forge build.
00:20:51.970 - 00:21:30.190, Speaker A: And this is going to compile your contracts and it's going to give you the abis. So if you ever use Hardhat, you compile, you get your abis. And you can use those to make client side calls, or you can use them to deploy and verify your contract on something like Ether scan. Once you run Forge build, you're going to have this out directory, and this out directory holds your abis. You can also run Forge test. And we're going to be actually running back through these commands again with a new code base because we don't really know what that's testing because we haven't even looked at the contract. So what I'm going to do is go back to my code base.
00:21:30.190 - 00:22:16.680, Speaker A: And what I want to do is instead of using this counter example, we're going to do a Hello World, which is going to just give us a little bit more room to work with to show some of the functionality that you might not be able to do with just a counter example. So in order to do that, I'm going to rename this to Hello World Soul. And everything that I'm doing is actually covered in the workshop materials, copy and paste directly from here. So don't worry if you're not keeping up, you can literally just go here and copy and paste. So what I've done is I've renamed counter to Hello World, and this is a very basic Hello World contract that I'm going to go ahead and paste here. The only functionality that we have is that we have two variables. We have a greeting and we have a version.
00:22:16.680 - 00:22:47.156, Speaker A: When we make a new greeting, we're going to increment the version and we're going to have a function that just returns the greeting. So it's about as simple as you can get. But it also, I think, is a good basic starting point. So the contract is there. This isn't on solidity development, it's on Foundry development. So we're going to actually go now to the test, and we're going to spend more time on testing. And what we want to do is we're going to go to Test Foldercounter T Soul.
00:22:47.156 - 00:23:23.060, Speaker A: We're going to rename that to hello world. T soul. And you're going to notice that in this example contract here, that we have a couple of functions, and they start with the word test. Now, with Foundry, any function that starts with the word test will automatically be tested when you run Forge test. It doesn't even have to be in this directory. So keep that in mind when you're writing your test. If you create a test in the test that doesn't start with tests, it won't actually get tested, at least by default.
00:23:23.060 - 00:24:18.388, Speaker A: So what we're going to do is just go ahead and copy this test, and we're going to walk through the assertions that are being had there. All right, so the first thing that you might notice that's different is that we have this setup function. And this just allows you to create some type of initial variable or whatever that you want to reuse across all of your other tests. So it often makes sense to just create a new instance of the contract, and then you can just reuse that instance of the contract. So that's kind of what we're doing here. We're creating this variable called hello that initializes a new Hello, World contract. And then we can just now say hello, whatever the method of that contract is that we want to call.
00:24:18.388 - 00:24:50.700, Speaker A: So the first test that we're going to run is we want to get the value that's returned from the greeting and make sure that what we expect what we expect it to be. Is this because the constructor takes in that initial argument, and we're doing that now. That's interesting. But I think the most interesting thing to be keeping an eye out for is this assertion assert equals. So you have about a dozen different assertions that you can work with. And I have a link in the workshop to all those assertions. So you can assert equality.
00:24:50.700 - 00:25:35.216, Speaker A: You can assert things like greater than, less than, equal to. You can assert truthiness, pretty much anything that you would probably need for assertion. So it's a really basic test here, right? We're just kind of like making sure the greeting isn't equal to the string that we expect it to be. And then we're going to also do an update, and we're going to say the initial version of the version is zero. I guess you could say we're going to then create a new greeting, which should increment that version number to one. And then we're going to assert that that is equal to one and also assert that the greeting is equal to hello world. So with that being said, we can now run forge test.
00:25:35.216 - 00:25:58.480, Speaker A: That should work. That's cool and all, but that's not all that interesting. Let's kind of look at more interesting stuff. So now that we have our basic project set up, let's dive into more stuff. So I mentioned some of these other assertions. We're not going to really be using any of those other ones but here are some of them and here's the link to view more. But what we want to look at now is Fuzzing.
00:25:58.480 - 00:26:56.730, Speaker A: So Fuzzing is cool because we don't actually have to pass in the argument that is expected here. Fuzzing can actually take care of that for us. And therefore you have also more, I would say variation in the types of tests that are run because it will basically automatically inject just different variables there. So instead of passing in the variable ourselves, we're going to use fuzzing here and we're just going to define that there is a variable that should be passed in there and then foundry will automatically inject that and it'll make it available for us. Everything else kind of I would say stays the same. So now if we run forge test again it should still work. But if I go to maybe change this greeting to something else obviously like hello world, then that should maybe break.
00:26:56.730 - 00:27:35.248, Speaker A: Okay, so the greeting that's coming in is some value that we don't know. So what if we want to know that value we can start logging it out. And if you want to log, you have about a dozen different logging methods that you can use. You can just use a straight up basic log which is just log which is really simple and you can also log integers if you know for sure that it's going to be an integer log string. You can do log name string which would be something like console log passing in the first argument as the string. The second argument is the value. So let's do some logging.
00:27:35.248 - 00:28:15.252, Speaker A: So I'm going to go back to test two and what I want to log out is the value that is returned from the greet method which should just be hello world. But you're going to notice when I run this test that nothing is logged out because by default logging isn't enabled. You have to actually ask for more verbose logging. So what we're going to do is just pass the VV and then now we see that we have the logs there. So hello world. So that's how logging works. You just want to pass in the verbosity and I think there's up to four V's and I don't know what that would do but let's see.
00:28:15.252 - 00:28:41.768, Speaker A: There we go. So I've never really needed that much, honestly. Okay, so we have some basic stuff going on. We're going to dive even deeper to more interesting stuff. We only have five minutes but I think we have enough time. Next we want to go ahead and run a local ethereum node. So in Hard Hat we would run NPX Hard Hat node and in foundry you just type in the word anvil and this spins up a node.
00:28:41.768 - 00:29:49.516, Speaker A: And here you see that we have ten different accounts and ten different private keys. So what I want to do now is go ahead and set an environment variable to one of these private keys and then that way we can start interacting with the network and referencing that private key as an environment variable. So to deploy the actual contract to the network we need to run a script. And we already have a basic script in our project here under Scripts we want to just rename this to Hello World s Soul and we have this run function and then we have this broadcast method on the VM that actually does the deployment and that's kind of where we're going to be doing our work. So I'm going to copy this and not a whole lot has changed. We still have this empty setup method because we're not really using it. We're doing the VM broadcast and then after that whatever is called will be actually deployed.
00:29:49.516 - 00:30:34.240, Speaker A: And all we're saying is like we want a new Hello World contract deployed and then we're passing in the constructor argument of the string and then from there we should be ready to go. So how do you actually run this? Well, we are going to use the forge CLI and we're going to say forge script. We're going to define the location of the script. We're going to define where the RPC is that it's going to be deployed to. So if this was like Infuria, you would set an RPC endpoint. But since we're running locally, we're going to set the localhost 85 45 and then we're going to set the private key as the private key that we stored in our environment variable. And then we're going to say broadcast because if you don't say broadcast, it doesn't actually deploy that.
00:30:34.240 - 00:31:26.076, Speaker A: So let's do this without broadcast. And I'm going to go ahead and open my terminal and this will basically just give you a simulation of the deployment. So this will just tell you whatever information about the deployment like how much gas would be used and stuff like that. And then when you're ready to deploy, you just run that again and then you just say broadcast. And then what you should be given is the contract address and we're going to also be using that. So now we've deployed and we see some logging that's happened there in our anvil and you also see the transaction ID and the contract ID. So now that we've deployed our contract, what we want to do is store that in an environment variable.
00:31:26.076 - 00:32:13.136, Speaker A: So I'm going to go ahead and do that, well, let me just do this. So we have two environment variables. Now we have our contract address and our private key. And now we want to call that contract because we want to start reading information from our contract locally. So what we can do is say cast call and we're going to pass in the contract address and the method so we have that stored in our environment variable so we can just reference it. And then what we want to do is call, greet and we know that it's going to return a string and we get hello from Foundry. That's what we expected.
00:32:13.136 - 00:32:39.628, Speaker A: Pretty basic stuff, but it's pretty cool to be calling that from the command line. We want to now send an update to update the greeting. So we're going to say cast send. We're going to say update greeting. We're going to pass in the new greeting and then everything else is the same. So if I copy that and then I go back and read the greeting again, this should now have my new greeting. And there we go.
00:32:39.628 - 00:33:27.926, Speaker A: We've read the contract, we've updated and we've then read the new value. So now that we've kind of gone over some of the basics, let's look at how to install a new package. So one of the most popular packages is Open Zeppelin contracts. So let's create an ERC 721. And what we want to do is just say forge install openzeppelinzeppelin contracts very similar to like NPM install. And what I need to do first is make a commit because they don't like that if you have uncommitted code. Okay, so we're installing opens up on contracts and after that's installed, it should just show up in our Lib folder right there.
00:33:27.926 - 00:34:14.990, Speaker A: And we now need to configure our remappings because we need to tell our local environment where to find that code once we try to import it and use it. So you can actually run forge remappings and see already whatever remappings are configured. And here you kind of already see them trying to kind of make some assumptions about your environment. But we want to set a custom remapping. So if you would like to do that, you can actually just create a new file called remappings text. And we will set our remapping for OpenZeppelin here. And now we can actually just import that directly from OpenZeppelin without having to reference the entire path.
00:34:14.990 - 00:34:57.998, Speaker A: And it looks something like going to we have maybe three more minutes and we're already over a little bit. But we still have just one more thing to cover. We want to look at mocking another user, which is I think, one of the more useful things that you could probably learn here. So to do that, we're going to be going to make a new ERC 721 soul. This is a really basic contract, but you see, now we're actually importing from Open Zeppelin contracts, which is pretty cool. We're creating an ERC 721 called DevCon Panda. And we will just have a mint function.
00:34:57.998 - 00:35:32.216, Speaker A: Pretty basic stuff. And we are going to also have a test for this because this is going to be the part where we're actually learning something in the test. Okay, so the test that we have set up for right now is really basic. We haven't added any of the mocking features yet, but what we want to do is simulate another user. So we have two users. We have Noah and we have Sofia. And what we want to do is create a token, transfer it to another person.
00:35:32.216 - 00:36:05.204, Speaker A: We want to make sure that only the owner of that token can actually transfer the token. So to do that, we are going to use the prank method. And you can either say prank and prank will be using the next call only to prank that user, or you can say Start prank. And it will do all of the users or all of the calls that come after that until you call stop prank. So this will wrap up the workshop. I know we're a little bit over. I'm going to go ahead and create the function that we're going to be doing here.
00:36:05.204 - 00:36:39.880, Speaker A: And we have this method where we're going to test a transfer. So we want to mint a new token to Noah. We want to start pranking and simulating. US being Noah, we want to then transfer to Sophia. And then we want to check the owner of that token and then assert that Sophia is indeed the owner. And if we run Ford's tests, that should work. We want to actually only test this contract.
00:36:39.880 - 00:37:10.888, Speaker A: And if you would like to do that, you can pass in the match contract. So now we're only testing that one. And to make sure that everything is working good, we're going to assert that Bob is the owner when he's not the owner and everything fails, which is what we want. Okay, so that's basically it. We're not covering everything. You can run forge coverage, which is a pretty cool command to give you test coverage, and you can go even it's not working because the test has failed. But anyways, forge covers is really nice.
00:37:10.888 - 00:37:21.390, Speaker A: So that wraps up the workshop. Sorry we started a couple minutes late. I'm sorry we went a couple of minutes late. Over. Check out the GitHub repo. Walk through all that stuff a little bit slower if you'd like to learn more. Thank you.
00:37:39.320 - 00:37:40.272, Speaker D: Gas reporter.
00:37:40.336 - 00:37:40.950, Speaker F: Or.
00:37:43.960 - 00:37:45.270, Speaker A: I'm not sure, actually.
00:37:47.940 - 00:37:48.416, Speaker F: When I.
00:37:48.438 - 00:37:51.936, Speaker B: Run higher, sometimes when I run the.
00:37:51.958 - 00:37:53.570, Speaker C: Text, I get like.
00:37:56.680 - 00:37:57.748, Speaker G: Is this your phone?
00:37:57.834 - 00:37:58.470, Speaker B: Yeah.
00:38:03.000 - 00:38:09.700, Speaker A: Oh, the gas reporter. Okay. Yeah, there's gas reports and all kinds.
00:38:18.810 - 00:38:20.520, Speaker G: All right, Miranda, can you hear me?
00:38:22.090 - 00:38:22.454, Speaker E: Test.
00:38:22.492 - 00:38:22.694, Speaker C: Test.
00:38:22.732 - 00:38:24.120, Speaker D: Can you hear anybody hear me?
00:38:29.820 - 00:38:32.490, Speaker G: Let's see if I go into presentation mode, how this goes.
00:38:33.180 - 00:38:34.968, Speaker C: The resolution should have changed right away.
00:38:35.054 - 00:38:37.256, Speaker G: Yeah. Do I want to go into presenter mode?
00:38:37.288 - 00:38:38.332, Speaker E: Is that what I want to do?
00:38:38.466 - 00:38:39.692, Speaker D: Do you need the notes at the bottom?
00:38:39.746 - 00:38:42.110, Speaker G: I mean, if I can look at them, yeah.
00:38:50.880 - 00:38:51.340, Speaker C: Okay.
00:38:51.410 - 00:38:52.748, Speaker H: Yeah, that should be good, right?
00:38:52.834 - 00:38:54.030, Speaker G: Yeah, I think so.
00:38:54.400 - 00:38:55.868, Speaker C: We'll see in a second once it turns on.
00:38:55.874 - 00:38:58.044, Speaker G: If not, and then do I need the audio jack?
00:38:58.172 - 00:39:00.736, Speaker C: If you have audio playing, is there.
00:39:00.758 - 00:39:01.516, Speaker G: Going to be any audio?
00:39:01.628 - 00:39:02.128, Speaker C: Oh, it's her.
00:39:02.134 - 00:39:16.310, Speaker G: Yeah, it's her. Yes. He said he had it a second ago. It's a good time. Audio or HDMI Audio?
00:39:17.370 - 00:39:22.710, Speaker E: Because we can also just do kitchen.
00:39:25.930 - 00:39:26.710, Speaker C: Table.
00:39:42.050 - 00:39:43.646, Speaker D: Can we just test out YouTube to.
00:39:43.668 - 00:39:44.590, Speaker C: See if it works?
00:39:44.740 - 00:39:47.520, Speaker G: Sure. Brandy, you want to say something?
00:39:52.730 - 00:39:54.834, Speaker D: Maybe they need to turn up the audio on their end.
00:39:54.972 - 00:39:56.074, Speaker F: We already have it.
00:39:56.112 - 00:39:59.386, Speaker E: Maybe you need to set oh, wait.
00:39:59.408 - 00:40:01.180, Speaker D: Let me change sound device then.
00:40:08.340 - 00:40:08.704, Speaker E: Okay.
00:40:08.742 - 00:40:09.692, Speaker D: You can hear the ping?
00:40:09.756 - 00:40:10.176, Speaker G: Yes.
00:40:10.278 - 00:40:11.204, Speaker E: Okay, so that's really good.
00:40:11.242 - 00:40:12.230, Speaker G: We can hear you.
00:40:12.920 - 00:40:13.670, Speaker H: Okay.
00:40:14.760 - 00:40:16.310, Speaker G: We didn't hear them when they talked.
00:40:19.000 - 00:40:19.984, Speaker E: Can we try?
00:40:20.122 - 00:40:21.610, Speaker G: Miranda, say something again.
00:40:23.260 - 00:40:24.056, Speaker B: Hello?
00:40:24.238 - 00:40:24.632, Speaker C: Yeah.
00:40:24.686 - 00:40:25.224, Speaker G: Okay, perfect.
00:40:25.262 - 00:40:25.960, Speaker B: Did you hear that?
00:40:26.030 - 00:40:28.250, Speaker E: Yeah, perfect.
00:40:44.730 - 00:40:45.880, Speaker B: Did you hear that?
00:41:07.130 - 00:41:07.880, Speaker C: Okay.
00:41:09.930 - 00:41:15.150, Speaker G: Do the slides down there. Can you see my slides?
00:41:16.610 - 00:41:17.662, Speaker H: Yeah. Good.
00:41:17.716 - 00:41:18.638, Speaker G: All right, cool.
00:41:18.804 - 00:41:19.774, Speaker H: All right.
00:41:19.972 - 00:41:42.034, Speaker G: Hi, everyone. Andrew Foreman. I'm with Ernst and young EY blockchain here talking about Starlight. I work at EY. I work with a lot of our clients that are building smart contract applications. Any kind of web, three app, new governance features, things like that. What I'm not is I'm not a cryptographer.
00:41:42.034 - 00:42:25.554, Speaker G: I've never taken a cryptography class. I don't really understand the math behind zero knowledge proof circuits. I know there's a couple out there. So what Starlight is is really just a huge leap forward in allowing any average silly developer, myself included, to start to bring and use privacy features in the construction of their DAP and their smart contract. So this is very much like, if I can do it, you can do it, too kind of talk. We do have some of the cryptographers that worked on building the application on the phone, and they'll talk through some of the technical parts of it, but definitely want to give you a feel for what this is, what we're building here. Maybe just another important note, too, is that this is something that we're actively working on at EY.
00:42:25.554 - 00:43:13.922, Speaker G: It's pre alpha release, very much an experimental technology. So we're hoping to launch it soon. The reason we're talking about it this weekend is so that you guys can see it, you can start to use it, give us feedback, and then we can have a more robust launch very shortly. Okay, so what is starlight? So, like I said, the big headline here is that any solidity developer can now use the power of zero knowledge proofs in building private features for their DAP on chain. You don't need to understand kind of all the sophisticated circuits, the elliptical, curves, anything like that to go then build private features for your DAP. So that's what Starlight was built to do. It's really two things.
00:43:13.922 - 00:44:04.340, Speaker G: It's one, it's a zero knowledge proof library for writing your solidity code. And two, a transpiler, we call it compiler. But really it's a transpiler to then read that library file and the decorators that are involved there. So what you can do is then you take any of your, these decorators do is they take any of your variables mappings arrays that you have in your contract and it allows you to put them into a private state. And so then some of the names you see up here are the kind of, the names that we've been using. I mean, these are kind of like right now just internal names that we're trying to experiment with. But when you take your adapt and you run it through this kind of construction that we have around decorators, we're calling that a Zap or a zero knowledge proof app.
00:44:04.340 - 00:44:57.498, Speaker G: The Zalidity is the file type that we use in this zero knowledge proof library in the Starlight library, which I'll get to in a bit. And then Zapify is really just a command to run the compiler. So once you understand kind of some basics around those decorators, it's really just three steps. Write your solidity, add these decorators, run the compiler. And as you can see, we've taken all of that trusted setup, circuit construction, trust assumptions, logic off of you as a developer. So all you have to do is add this to your solidity code and kind of understand what the logic is going to look like for your users and how these state changes get updated. Okay, so first one, we said two things, right? First is the compiler.
00:44:57.498 - 00:45:42.170, Speaker G: So I think I want to say, why did you even build a compiler? It's kind of like a weird thing to even go and tackle. You don't see it that often where someone wants to go build a compiler. And so for us this was really just about scale and getting more developers access to this technology. It was something that I ran into personally on a project. So we worked with a client, they wanted to build this private donation platform and what it allowed you to do was take a bunch of different charities, make private donations to them. So now like, a large donor who may not want their donation to be public could do so privately on chain. So there's a big step forward in more sophisticated, more real world smart contract applications.
00:45:42.170 - 00:46:44.900, Speaker G: But I worked with a team of advanced cryptographers. We had to go through weeks of circuit construction. They had to explain it to me so that our team could then write it into solidity code. All of that stuff is not scalable when you talk about hundreds and thousands of zero knowledge proof based and privacy enabled applications. So to make that all work, we started kind of at the compiler level so that you can keep writing your Solidity code, add these decorators and run it through this construction. So the three steps again will say, take your contract in solidity sol, add decorators, you mark what you want to be, secret variables, arrays, mappings, anything that can have a private state, then send it through Zapify into what we're calling this compiler transpiler. So then how does that look at runtime? Because this is maybe just like also as like a developer education point, understanding what's happening to your code as you go in through and deploy it.
00:46:44.900 - 00:47:48.646, Speaker G: So what we have here is the compiler takes that solidity code and we have now this Zol file, the solidity file type. And what we're going to do is we're going to first kind of make sure that the syntax and the way your Solidity code is written looks right, that there's no solidity errors. First we're going to run it through the Solidity compiler, just like as your code always would be executed. Then we're going to add back into this AST tree, which we've broken out the decorators that you put into that file, and then we're going to run it through our transpiler. And so now we've gone through this compiler loop a second time and what you have is a validity or a Zap that's been compiled. And so that's when we would then set up and create the circuits and the state changes that you would need for that application. So, yeah, that's kind of what it looks like.
00:47:48.646 - 00:48:45.820, Speaker G: At the back end, you're going to have one tree that has these three different parts, which is the shield contract, this orchestration code, and then also just your solidity file structure. And I only call that out now because when we get into the more technical parts of the talk, you're going to see that breakout again of the orchestration, the shield contract and the solidity file. Okay, so like I said, all that you need to know as developer is how to use these decorators and how to run it through this transpiler. And you've got your Solidity app ready to go. So I want to now jump into the decorators because this is really kind of like the key thing for anybody that wants to go and use Starlight to understand are these three decorators. Miranda, can you hear me or do you want me to take these ones? You want to try and test talking and see if we can hear you?
00:48:54.030 - 00:48:54.780, Speaker C: Hello?
00:48:58.830 - 00:49:45.702, Speaker G: All right, well, I'll get started. So the first one is the secret decorator. So what secret is, is think about any kind of variable, whether you declare it at the global level or a function parameter that you want to remain in a secret or private state. So like your basic example here we can jump to the code as well is I've got variable A. I don't want anybody else to be able to call and see what I have stored at variable A. So I can put it secret in front of that argument and now it can remain private on chain known and unknown. So this is getting a little bit more advanced.
00:49:45.702 - 00:51:03.060, Speaker G: So then think about this as like a bank account, right? So a known would be where I know what's in my bank account, I can now update the state of my bank account. I would use known for that if I want to add or decrease if I don't know the state of my bank account. So let's say I want to change his bank account, I don't know what's in his bank account, I would use unknown and now I can add to his bank account without knowing the state of it. So that's how you would use known and unknown. A lot of this comes down to kind of the language of ZKP and privacy and cryptography is just like who's creating the commitment, who knows the secret word at any point and who can update the state of whether it's a variable mapping or an array. And so to me, this is just like a very nice distillation of a lot of a zero knowledge proof work happening in the background, where for me, all I have to understand is how to use these decorators, what they're going to look like once my code is represented on chain. And now I can start to kind of bring these features of zero knowledge proof and privacy into my application.
00:51:03.060 - 00:51:16.840, Speaker G: Who can change states? Who knows things when and who can update them? So let's look into an example of that. Miranda, if you can hear us you can jump in on this one as well. You start talking.
00:51:18.250 - 00:51:19.560, Speaker E: Can you hear me?
00:51:20.970 - 00:51:22.860, Speaker G: Maybe it's a little loud, you want to try that again?
00:51:23.790 - 00:51:25.066, Speaker B: Hello, can you hear me?
00:51:25.088 - 00:51:26.298, Speaker G: Yes, we hear you fine.
00:51:26.464 - 00:51:27.178, Speaker C: Perfect.
00:51:27.344 - 00:51:31.290, Speaker B: Yes we do. Okay, perfect. So we're going from the example, is that right?
00:51:31.360 - 00:51:31.980, Speaker G: Correct.
00:51:32.670 - 00:52:05.958, Speaker B: I can't see the slide, sorry. Okay, great. So you have an example here. So if we want to Zapify something and turn it into a zero knowledge application, we start with a smart contract as Andrew talked through. So let's do this super simple idea which hopefully some kind of use case. We have a mapping of invoices from an address a person to the amount in the invoice. We have the owner of the contract, this is the one who's going to be paying the invoices and we have a function to add invoice and function to pay them.
00:52:05.958 - 00:52:36.160, Speaker B: So you see in red these are where the decorators are. So we don't actually need to worry about known and unknown here because we're overwriting state and we're decrementing state. So we know that essentially the only people who are going to call these functions are the people who know and own the state. And the compiler is clever enough to work that out for you. So we don't need known or unknown here. But yes, this is an example of a kind of input you would be able to put into Starlight and Zapify. At the bottom is just a very high overview of the actual application.
00:52:36.160 - 00:53:25.280, Speaker B: By compiling this we would get a shield contract which would verify the information you put on chain. In this example we are not revealing any owners or amounts of these invoices. So very little information will go on chain apart from the proofs proving you've done these computations correctly and the amounts based on whether you're adding a new amount or whether you're decrementing some amount. The orchestration is just the node code and a bunch of other types of sort of deployment type things. So like docker NPM files that help you deploy and use and bring together the zero knowledge and the on chain parts and the Zocrates file. So Zocrates is the code that we use for our zero knowledge circuits. All right, so on the next slide there should be sort of example flow of this.
00:53:25.280 - 00:54:00.662, Speaker B: So lovely. So ideally here, so the user wants to add an invoice using their zero edge application that they've made with Starlight. So number one is the only step that the user has to do. All the rest is done in the background and the user is just waiting for the receipt back from the transaction. So they want to privately add an invoice to this contract. They still need to input an amount. So if you remember in the previous slide we still need the user to input an amount but then the rest is done in the background.
00:54:00.662 - 00:54:57.486, Speaker B: So they call, instead of calling the contract, they will call a JavaScript node file. And what that would do, if you have an old invoice for this exact owner for you, then it would grab that old commitment. If not it would use a dummy commitment which is a bit of an advanced feature, but we'll just continue it would get all these inputs together and create all the things that we need to keep the state private. So in this case, in number three, we want to wrap the amount into a commitment. So what we do is we hash it with lots of other information as well to make sure that it's hidden but it's provably correct. And we go through exactly the same computations that we did in the original input contract, but instead we do it in the zero knowledge circuit and we prove that we've done it correctly rather than revealing the inputs that we've used. And then once we've done all this, in number four we send this proof the new commitments we have.
00:54:57.486 - 00:55:38.140, Speaker B: So the new commitment representing the new value and the nullifier of an old commitment, if it exists, we send that on chain. If the contract that we made, if that verifies the proof, it adds a new commitment to a tree so you can prove that it exists later. It basically tells the world for mostly our Merkel tree application that a new commitment has been added and it adds a nullifier so that you can't double spend any commitments. So all the user had to do was step one and the starlight generated application has done all the rest. So the user has added a completely secret invoice to this application? Yeah, that goes through the example.
00:55:38.830 - 00:55:39.610, Speaker E: Yeah, great.
00:55:39.680 - 00:56:20.126, Speaker G: I'm just trying to see if I can switch over to the actual repo itself. I don't know if we can do mean, here's another example just to bring it up. Mean I think that was a good example that Miranda walked through. And I think maybe just like some other examples to throw at you, just to get you thinking about how you would use these decorators, might be something like if I wanted to have a voting contract and I wanted to restrict the number of people that could vote on that contract, and I wanted to keep those ten people private, I could create a mapping that says, here are my ten voters. They're private. You can go and check on chain. You wouldn't be able to see who's allowed to vote on my contract.
00:56:20.126 - 00:57:01.190, Speaker G: And then maybe only I or some admin has special privileges to change the voters in my application. We've thought about some other ones like issuing IOUs or different kinds of advanced commitments. So I think this one's like an invoice example. I think that these are powerful tools and now we can start to think about what are the privacy features of our users, when do they want their information to be private or some other part of the application to be private. And then this becomes a way that we actually instantiate that feature.
00:57:05.610 - 00:57:06.226, Speaker D: I'll flip.
00:57:06.258 - 00:57:43.060, Speaker G: Over to in a second, but we have a GitHub repo that is public and anybody can go and access it. I'll put up a slide after this and there'll be a link there to get to it. There's a lot of good examples, there a lot of good test files for you to go through. So we definitely want people to go and try out the repos, take a look at it, see if it makes sense. If you have questions, we're available to talk through any parts of it that you want. And then maybe just to hit on two kind of learnings that we've had over the last few months working on this repo. One, building the compiler is really hard.
00:57:43.060 - 00:58:33.490, Speaker G: It's hard to find compiler developers to work on this. There's a lot of different test cases that you need to be working for. I wouldn't advise it for your health to go work on compiler code. It's a mess. So if anybody's a compiler dev, come find me recruiting dinner. And then I think too, for me, the big opportunity and the big thing that's changing in our space and as ethereum developers, EVM developers is building privacy, indoor applications. And I think as these applications become more sophisticated, as they start to have more real world applicability and use cases, as our governance systems get more sophisticated, that we're going to want to have privacy in the things that we put on chain for our users.
00:58:33.490 - 00:59:29.436, Speaker G: And it's not feasible right now at this point, or just assume that everybody's going to go out and understand how a snark works at a very detailed level to go build those applications. So I really think we need tools like this to be able to make the privacy features that we want and that'll make the space better work. And so I think something that'll be a big focus for myself and our team going forward, too, is just like helping designers, developers, product managers think through what are the feature designs they want to build in and how do they start to think about privacy in a more robust way. That's pretty much all on the talk. Can I switch over to the GitHub? I'll just show you guys where it's at. Here's a link if you want to scan here. And yeah, you just heard from Miranda.
00:59:29.436 - 00:59:51.910, Speaker G: She was one of the lead developers. Michael Connor down there in the stands also worked on it. Swati rayal is part of our r d and cryptography team in London, and Megan and I are kind of helping us develop a relation, so to speak. All right, I don't think we're going to get to GitHub, but yeah, come find me after the talk and we can walk through the repo. Okay, thanks everyone.
00:59:57.760 - 00:59:58.510, Speaker H: It.
01:04:13.410 - 01:04:50.886, Speaker F: Hi there, guys. So I saw some of you at the booth already today. I'm going to talk about how cartesi is bringing Linux to the blockchain, and I'm going to explain how that's possible. And I'm going to show you a python example of how that works. So this is a quick overview of what we are going to do over here. So I'm going to talk a little bit about cortesi, what it is, how long we've been around, and I'm going to do a live comparison between web3, web two, and cortesi development. And then I'm going to actually talk about cartesi roll ups.
01:04:50.886 - 01:05:26.994, Speaker F: I'm going to introduce you to roll ups for those who are not familiar with it, and then I'm going to go dive into the code. However, I want to keep you hooked. This is the code we are going to investigate together. So this 25 207 line python code that's actually importing libraries from normal python. It's actually running on a virtual machine that can act as a roll up for Ethereum, for instance. This is actual smart contract. This one here is doing an echo python.
01:05:26.994 - 01:06:17.554, Speaker F: So whatever you send it, you send it back on the blockchain for you. So Cartesi cartesi is a company that was founded in 2018. These guys have been working a long time trying to bring a risk five. I'm going to talk about risk five, but a processor, a true processor, to the blockchain, how to make it deterministic so you can do like normal computations. And that's why they're calling it the Blockchain OS because we actually brought the Linux for it. So the overall idea, I guess you're all familiar with it, so I'm just going to run through it, is that Ethereum is awesome. It's secure, it's somewhat censorship resistant, decentralized.
01:06:17.554 - 01:07:07.702, Speaker F: There's all these good features about Ethereum. However, it becomes slow, it is expensive. So DApps are actually fighting for space resource inside of the blocks to actually be processed. And it comes with a lot of friction for developers that are just coming to blockchain. So you have 30 years of experience, doesn't matter, you're going to start over all over again. So the idea is, what if we can do complex computations and maintain the main layer's security guarantees? So here's the Kurtesi response to that. First, we use a transparent VM so you are able to actually see the whole code.
01:07:07.702 - 01:07:48.920, Speaker F: It's not somewhat complicated, but it's open source. Like the last guy was saying, compiler stuff is hard, but in any case, it's open to everybody to investigate it. And it is using the RISC Five, like I said. So RISC Five is an open hardware platform, just like open source, but for hardware. And it comes with a lot of security guarantees already because it's being audited by several companies and people, it keeps getting updated throughout the time. So that's nice. Any person is allowed to build on top of it.
01:07:48.920 - 01:08:49.480, Speaker F: And it is a platform processor, which means you can actually have any kind of OS on it. It's a very robust machine and the only thing that we need to actually adapt is to build a deterministic emulator. So we made RISC Five deterministic and because of that we could actually make the emulator for EVM as well. So whenever you run the computation off chain, it is possible to actually run the same computation on Ethereum. Right now, in fact, one of our acceptance tests is to actually do the whole RISC V acceptance test on Chain. So of course it's a testnet or a local testnet, but we do it on the EVM just to prove that the version that we have on chain is the same exact version that we've developed in C plus plus. So that allows you to have massive computation as a layer two.
01:08:49.480 - 01:09:35.190, Speaker F: And with that, the whole way this works, the idea of to actually have the massive competition now become yet another limiter again is to have local consensus. I guess people here are more familiar with app centric roll ups. So because of that, instead of having a lot of computation, doing the same work over and over again, effectively only having a single machine, which is the way the Ethereum works, you can actually have computational resources dedicated to each application so every application, it is its own roll up. If you use the Cartesi framework.
01:09:37.290 - 01:09:38.038, Speaker E: Finally.
01:09:38.204 - 01:10:38.726, Speaker F: The most important thing, it's actually make it work with the blockchain, right? So that's where the dispute protocol comes in. It's not any novelty, it's actually been discussed for a long time. So here we are using the verification game. The overall idea is you get the whole computation you did off chain. Let's say it took like 3000 cycles, CPU cycles, you find exactly where the validators diverge and you only have to execute a single CPU instruction cycle on Ethereum, which makes validating the whole process really cheap. So how to say the end result is Ethereum becomes a judge. So it means that if you have, I don't know, like four people playing a poker game and one of them win and the other three start to collude against the one that won, that single honest validator.
01:10:38.726 - 01:11:26.700, Speaker F: That's all that you need. A single honest validator to come to Ethereum and complain about the end result. And then Ethereum is going to judge who's telling the truth. So you guarantee the correct settlement of computation. So for those who are not familiar with rollups, the overall idea is you have the main chain, it has its own blocks. At some point you initiate the process, you tell Ethereum here's the initial state of my rollup and you go on with your life for a little while off chain doing computations. And once you're done, or once you want to do a checkpoint, because that's the idea of roll up, you're always checkpointing your process.
01:11:26.700 - 01:12:46.574, Speaker F: You go back to the blockchain and with optimistic roll ups you actually have like a seven day window for now, that's the agreed good time span for disputes. So you have a seven day window to actually complain about anything that went wrong on that block of computation, so to speak. So how everything gets together, right? So before in web two, you used to have some kind of a front end, a few APIs defined by you to be run in a centralized server or a set of centralized servers talking to a set of centralized databases, right? That's the main web two idea. So Ethereum comes up and say, you know, what the business logic, whatever is most important, you can actually decentralize that. So you figure out a way to deploy your front end, you can use IPFS, which is really nice, and you communicate with the blockchain. Cartesi doesn't change that too much. The overall idea is still you have the same feel as the Ethereum.
01:12:46.574 - 01:13:35.218, Speaker F: You are supposed to have a set of nodes that you communicate with. Just like what happens with Ethereum to have your back end be the base of your app. The main difference is instead of burden the developer with all the little things needed to actually communicate back to Ethereum, we are calling here http dispatcher it's just an API that encapsulates all the complexities of communicating with the blockchain back. So basically what you need is just to communicate with a rest API. So there is a definition of that. There's three endpoints. You get to learn how the endpoints work.
01:13:35.218 - 01:13:59.914, Speaker F: And now you can develop your Solidity I'm sorry, your smart contract in any language. That's the overall idea. And I'm going to show that in Python. So how it actually looks like. We have the three main pieces of APIs. The first one is the JSON RPC. It's just there.
01:13:59.914 - 01:14:52.914, Speaker F: So that one is too like Ethereum. So you have a data availability issue, right? You are settling on process like on computational disputes, but it's too Agony Chicken situation if you don't have an agreement. What was the input that you had for that process? So the idea yes, let's keep using Ethereum or any other layer one networks to just communicate what were, I don't know, our chess moves for instance. So you have the JSON RPC. There still to do inputs to the roll ups. However, you have the GraphQL API that we developed. And the GraphQL API is mostly so you can check on three things that we have on the Cartesian machine.
01:14:52.914 - 01:15:21.830, Speaker F: So over here we have Report and Notice. They are similar but different enough. So Report is any kind of log that you log within the Cortez machine. Think of it as a developer debug log. So it's not provable, it's ephemeral. You cannot do much with that. It's just to help you out while you're checking the health of a process or you're developing your DAP.
01:15:21.830 - 01:16:09.070, Speaker F: However, the notice is our version of Ethereum events with a twist. So right now, if ERC 20 token says there was a transfer between an A and B party of some amount, it's trustworthy enough. If you're running the theorem node, however, you have no proof that the event actually exists. You have to be running the node to trust the event. The notice, however, comes with its own proof. So the notice is part of the machine state. So if you go back to Ethereum and you have to create other DApps and interact with other DApps inside Ethereum, or even on other optimistic rollups, you can build upon the idea of having notices.
01:16:09.070 - 01:16:46.162, Speaker F: So let's say you have a transfer happening inside an Ethereum machine. It doesn't need to be a direct call. You just need to say, hey, I actually won the game, let's say an NFT generating situation. So in order to win this badge like the winner, you have to prove that you won ten times the game. You just collect the ten notice and you can put it to be proven on Ethereum for instance. So that's how it is different from an event. And Voucher, the final one is basically Ethereum transaction that is yet to be.
01:16:46.162 - 01:17:31.834, Speaker F: So whenever your roll up DAP wants to communicate back to a smart contract in Solidity, for instance, it creates a Voucher. And if the optimistic roll up settles and there is no disputes on that, after the seven day window, the Voucher becomes executable. So it becomes actually an Ethereum transaction. So you as a user could just call it and claim the Voucher or you could let the validators on the network do it for you. There is like fees and other stuff going on on that. So that's why you have the GraphQL API. Because if you want to populate your front end with that kind of information, you can access it directly calling the node.
01:17:31.834 - 01:18:15.230, Speaker F: Finally, we have an ATP Rest API that works like ETH call for those who are familiar with Ethereum. Basically it's any call that you do to the machine that is not state transitioning. So we ensure that this call, we always roll back to the initial state of the machine. That's the main difference. And that call only can generate reports because that's what I said before, right? It's something that it's not provable. So the idea is to have quick depth communication. You can use it to grab data for your UI and you can use it as a debugging solution as well.
01:18:15.230 - 01:19:01.418, Speaker F: It's easier to check up on the state of your machine, of your program. So now I go back to the Python example. So, to this yellow side over here, we have a tool on our roll up examples repository. But basically they're encapsulating JavaScript code like to how to actually call stuff through the Jzon RPC, right? It's a helper tool. And over the blue side I have the actual Python DAP. So we're going to start sending like a payload with just hello there it is. Just a transaction call data, nothing special about it.
01:19:01.418 - 01:19:47.850, Speaker F: And we are going to start checking what happens on the code. So from the beginning you can see that I can use all the support that Python offers me. And I'm going to start using requests because I want to talk to the API that I just talked about, right? I want to be able to do HTP requests I grab from the environment. Where is the actual URL for the HTP API within the machine. So we provide you with that environment variable for you. So you can actually just grab it without hard coding it on your code. And here we have the two types of handlers I was just talking about.
01:19:47.850 - 01:20:19.122, Speaker F: But from the API's perspective within the machine, here are the two types. If you receive an inspect state kind of a request, it means that the whole machine, the whole Emulator will revert back. Oh, something happened. Okay, now we're back. So it will revert back to the previous state before the request. However, if it is advanced state, it's basically telling you this is going to change the state. So you should do it properly.
01:20:19.122 - 01:20:42.138, Speaker F: Basically with that, it's just the high level. You can subscribe and create as many endpoints as you wish. It's just like solidity in a sense. At the solidity code, you basically have the entry point and you do all the switch for the functions. Right here, you have the main loop. So the idea is that this machine houts. It doesn't stop.
01:20:42.138 - 01:21:10.250, Speaker F: It just howts. So every time you finish a request, processing the request, it just houts at the end and wakes up at the next input. So this finish over here is actually kind of like a next. So it's actually saying, hey, I'm ready. Wake me up whenever you have something. So you stop over here. So as we begin for the first time at a code, you're going to see that I have like finished Status Accept.
01:21:10.250 - 01:21:43.006, Speaker F: And that's what I'm sending to the Emulator beneath it. And it's going to halt. And then when I say hello there, it's going to wake up the code exactly at this line. And from here on out, we are just going to process this request. So I send an input. So it should be an advanced state kind of request. So we are going to just pick up the JSON data from there, actually go to the handler that is responsible for that, so that's the advanced state and add a function.
01:21:43.006 - 01:22:11.846, Speaker F: At this time, I'm just going to create a notice, just the notice with the same data I just received. So I grab the data payload and put it in the notice payload back. It's just a simple program in this case. And I'm going to call the API. Creating a notice, that's what that's doing. It's not going to how the machine. It's just saying, hey, here's something that it is an output from this process and I can call it as many times as I wish.
01:22:12.038 - 01:22:12.682, Speaker C: Okay?
01:22:12.816 - 01:22:49.206, Speaker F: And the result is Accept again, it's all fine. So I'm just going to jump over the inspect for a second. So I would just add to the status Accept. And because I am in a loop, I'm going to end up here at the finish again, sending the Accept status halting the whole machine. However, if I had the handler of the type inspect, meaning instead of sending an input over there, I would actually try to inspect the machine saying, hello there. You would go to this different handler. You would create just a report.
01:22:49.206 - 01:23:29.862, Speaker F: Just like the notice is not that different when you see the code and it's the same. I just finish and whenever I ask for the helper to list all the new notices that there is there, you're going to see that the machine would return you with the hello there as a payload. And that's the overall idea. Do you guys have questions? I guess it's too much. Yes. It's still a blockchain environment. So in a sense, you're not connected to the Internet.
01:23:29.862 - 01:23:57.330, Speaker F: You can have Internet at the Cartesian machine when you're first building it. So remember the roll ups example thing I was doing like initial state. So let's say you're building your machine, building all the DAP, and you need data. So I don't know, docker images and NPM installs and things you can have that for sure. But once you're in the roll up environment, you don't have that access anymore. Makes sense. Go ahead.
01:23:57.400 - 01:23:59.350, Speaker A: What's the cost of deployment?
01:24:00.170 - 01:24:53.030, Speaker F: So there is the cost of deployment of the roll ups itself, like the set of smart contracts and stuff. It's not that high. I don't actually have a right figure for you right now, but it should be something around like $50 or something for Ethereum right now. But just so we have all the insertion points, so to speak, on Ethereum. Because this DAP actually has a mirror address on Ethereum, so other DApps can communicate through it back to the cartesi roll ups. But in terms of actual cost of running, this thing is up to the depth developer. You say, do you want to charge people for using it? Do you want just you and other developers run the nodes? Do you want to incentivize your users to run the nodes? It's up to you in the sense cortez is more like a framework really, because it's really app specific.
01:24:53.030 - 01:25:04.410, Speaker F: You tell the parameters. You don't like the seven days because you're doing a simple game like if really simple, low stakes, maybe it's just 5 hours for your roll up settlement window.
01:25:05.470 - 01:25:06.460, Speaker C: Makes sense.
01:25:07.950 - 01:25:09.130, Speaker F: You had a question?
01:25:09.280 - 01:25:09.980, Speaker C: Yeah.
01:25:11.870 - 01:25:13.818, Speaker E: The expectation that everyone is going to.
01:25:13.824 - 01:25:15.566, Speaker C: Be running their own infrastructure, like they.
01:25:15.588 - 01:25:17.454, Speaker E: Are setting up the machine that is.
01:25:17.492 - 01:25:45.080, Speaker F: Going to be running with VM. I mean, it's up to the DAP developer if it is something that makes sense, I guess, sure. But right now we're in the middle, right? We understand that mostly we're still going to have the service providers running the nodes and people kind of like trusting them. Yeah. Any more questions? Okay, thank you.
01:30:06.820 - 01:33:11.584, Speaker H: Should I wait until 70 30? I think we can start. Can everybody hear me? Yeah. In this workshop we will take a look at how the graph provides critical infrastructure to web3. And you will then learn how you can create your own API that is tailored to your data requirements. My name is Ariane Arista. You can find me on Twitter. Web three slimchance.
01:33:11.584 - 01:33:54.980, Speaker H: You can find me in Discord Slimchance 1699. I'm in the eat global discord. If you need any help with any technical questions and you can also find me upstairs. We are right by the elevator, so drop by our boot if you need any help with your subgraphs. So let me first start with the question that everybody asks me. Why do we need index data? The blockchain is public, right? But most blockchains are optimized for writing data and not for reading it. And you can imagine the blockchain as a big public library where every day there comes a new truckload of books.
01:33:54.980 - 01:34:43.000, Speaker H: And these are not sorted in any way. They're just added to the end of the shelves. And imagine that you go into this library and you want a list of the books with the highest word count. If you were to do that using a traditional, like RPC, or just connecting to a blockchain RPC, you would need to check every single book, note down the word count, and then create your list. And this is where the Graph comes in, as it allows you to index this data beforehand. Let's take a more practical example, a DeFi dashboard. Most of you are familiar with Uniswap, a decentralized protocol for swapping tokens.
01:34:43.000 - 01:35:21.830, Speaker H: Some of you might also know that there's a dashboard called Info Uniswap.org where you can get valuable charts and data about the protocol. Now, if you were to retrieve this data directly from an RPC, you would need to do a call. For every single time there's a trade, the price would change. So you would need to check the price. And to get a chart like this, you would need to do millions of calls, which would be very resource heavy, read, expensive. So that's why we need to preprocess this data.
01:35:21.830 - 01:36:08.390, Speaker H: It would also take you an enormous amount of time because you would need to process this in the front end. So again, index data allows you to have this data in real time. In your application. All of the data that you see on Info Uniswap.org is provided by the Graph. So you might think, who needs the index data? And we found out that that is everyone we are currently seeing. Over 64,000 subgraphs have been created on the hosted service, and over 640,000,000,000 queries have been served by the Graph.
01:36:08.390 - 01:36:26.912, Speaker H: So why are people using the Graph? Well, you can create a customized API that is tailored to your data requirements. This includes rich, sorted, filtered and aggregated.
01:36:26.976 - 01:36:27.590, Speaker D: Data.
01:36:29.960 - 01:37:35.890, Speaker H: And it allows for fully decentralized and serverless applications. If your DAP relies on a single centralized server, it's just an app. The Graph currently have two services the hosted service, which is a centralized service run by Edge Node, one of the core developer teams at Graph. It supports 38 different networks near polygon B and B and 35 more. We are currently moving to the Decentralized network where we currently support Ethereum Mainet. But we believe every DAP deserves decentralized, open APIs to retrieve their data from the blockchain. And we are delivering on that with the current ongoing MIPS program where we are incentivizing indexers to start indexing other blockchains as well.
01:37:35.890 - 01:38:46.440, Speaker H: And that is a historic step forward, not just for the Graph, but for the entire webtree ecosystem that relies on us and wants us to provide them truly decentralized, open APIs. And to dive deeper into why do we need decentralization in the infrastructure layer? Well, there's no central point of failure. You never have to call your back end engineer at Sunday morning saying that your server went down. It is naturally load balanced, the graph is infinitely scalable and it does so seamlessly. It is geodistributed service. We currently have indexers on every continent with over 200 indexes that are currently on the graph network. You will never wake up to an email from your service provider saying that your server went down because your service provider have taken no crypto stance.
01:38:46.440 - 01:39:41.478, Speaker H: And most of all, well, this number is a little bit outdated now, we now have 220 indexes all competing to deliver the highest quality of service to the lowest possible price. And this is why I am excited about the graph and I hope also you guys will be excited to use the graph this weekend and going forward. So I'm going to stop there and I'm going to ask if you have any questions about the protocol. If not, we can move on to the next part. I'll dive into the subgoth. Yeah. What does it take to be an index? So an indexer would be running RC nodes to get all that blockchain data.
01:39:41.478 - 01:39:51.660, Speaker H: And you will soon learn about sublocks, which is a blueprint for what data you want from unchained and how you want it presented in a.
01:39:53.550 - 01:39:54.234, Speaker D: They take.
01:39:54.272 - 01:41:35.750, Speaker H: These blueprints and they use that to transform the water from the node that they run. And then we are providing these endpoints on an open, decentralized network or market where end consumers can query those endpoints. Yeah. Did that answer your question? So every index needs access to wall blockchain AR and currently most of them are running their own servers, running their own software. Somebody creates like so we will come to this pretty soon but consumer creates a block that they deploy to the network and that is a blueprint or index. All indexes to them have access to this blueprint. They will index that data using all blockchain data either from using a service provider but the vast majority spending their own and they take that data, transform it according to the subgroup and then provide that on the decentralized network and they want to do so to receive credit fees from the consumers.
01:41:35.830 - 01:41:36.460, Speaker F: So.
01:41:48.980 - 01:41:50.640, Speaker G: That was one of the investors.
01:41:53.850 - 01:42:05.974, Speaker H: Yes. Do not type too deep into economics algorithm that is used to route these.
01:42:06.012 - 01:42:07.240, Speaker C: Queries to the.
01:42:10.280 - 01:43:27.100, Speaker H: Business. Not an exemptive for indexes to run multiple nodes unless they are also doing it in different areas of the sorry and thank you. So it's not incentivized for indexers to split their stake over multiple nodes unless they're also running the service in multiple geodistributed locations, which at that point well let them because they are just also providing better service to the network. Yeah, let's dive into I've touched a little bit on what the subgraph is. It has three major parts. The subgraph manifest here you define your network, the network you want to index, the contracts on that network, the start block, because when you get that blueprint to the indexer they will start indexing the data from a certain sub block. It can be from the Genesis block or from any other block that you specify and what events, calls or other triggers to listen for on these contracts.
01:43:27.100 - 01:44:31.112, Speaker H: The subgraph schema is where you define the data structure that you want to query and this is where you want to think ahead and make it as close as possible to the data requirements of your application. You would have the data structure, the entities, relations between the entities and so on. Then where you will spend the most time as a subgraph developer is in the mapping code. Here you map data from the events that you have specified and to the data structure that you also have specified here. And you would also do any kind of transformation. Aggregation of data will happen in the manifest or in the mappings that is written in assembly script, which is very similar to TypeScript if you work with that. So let's dive into it.
01:44:31.112 - 01:45:24.430, Speaker H: Let's look at how we can create a subgraph in a very short amount of time. So this is the graph. In the graph you have access to what's called a subgraph studio, where you can log in with your MetaMask. I'm already logged in and created a few subgraphs on other workshops. If I wanted to create a new one, I click create a subgraph. I want to create one for mainnet. In our case, we want to index.
01:45:24.430 - 01:45:51.670, Speaker H: In this workshop shop, I will show you how to index the Basi contract. So the board. Ape Yacht club. Let's call it basi. Bogota, for example. Now you have created this in the subgraph studio. In the subgraph studio you can see some important information like it is currently undeployed.
01:45:51.670 - 01:46:36.960, Speaker H: It is having a subgraph slug, which is the Identifier you will use in some of the CLI commands. And you also have a deployment key that you use to identify yourself. So only you can deploy changes and upgrades to this subgraph. What you would do is you would first install the graph CLI. I've already done it on my machine. Then you will initialize your subgraph. Let me duplicate my screen so it's easier.
01:46:36.960 - 01:48:15.450, Speaker H: Now, a cheat code that I like to use is the index events flag. This will create a scaffold code where it's indexing all the events that it finds in a certain contract. It asks us which network or which protocol type that the contract is on. It's an ethereum contract. The subgraph slug, the directory and then which network sit on and it's on Mainet. Now the contract address, save that maybe I'm not connected to the Internet. Let me try again.
01:48:15.450 - 01:49:32.406, Speaker H: There you go. Now it's creating a subgraph scaffold for us with scaffold code. Just give it a second. It's a tough time to download things from the internet here. I believe it maybe if everybody turns off their phones and their laptops. So there we go no, we can add more contracts. I just wrote no here.
01:49:32.406 - 01:50:43.960, Speaker H: So now we have a subgraph in CDBC Bogota. So here we can see the three files that I talked about earlier. You have the subgraph YAML which defines what to index and in our case we are looking at the basey contract on Mainet. At this address. I will add a start block as well because we don't want to wait around for it to index all the way from the Genesis block. So I'm adding that. Here we have the schema.
01:50:43.960 - 01:51:24.580, Speaker H: It is currently pretty sparse. It's a simple indexing of all the four events on this contract. Approval, approval for all ownership, transfer and transfer. And then in the source file you have the mapping file where you see all of these entities are being stored. And this has already been created just by using the index event flag. And I recommend using that as a way to populate your code with some boilerplate events and and entities. Now we are ready to deploy.
01:51:24.580 - 01:53:06.360, Speaker H: We can do graph code gen this. Now if you go back to the studio, you can see that you would also authenticate your laptop first or your computer first. I've already done that. So I can go all the way ahead and do graph deploy. Give it a now it's uploading all the subgraph files to IPFS so that indexers can fetch that data and start using the subgraph as a blueprint to then transform raw blockchain data into the open API. That is a subgraph. But in our case we are just deploying to the studio, which is a centralized service and it's a place to stage and test your subgraphs before deploying it to the decentralized network.
01:53:06.360 - 01:54:12.548, Speaker H: So it's deployed, let's check it out, let's refresh the page. And the subgraph is already fully synced, already fully populated with data about every single event that has happened on the basic contract. So this is pretty cool. But what really we can do with subgraphs is then go back in and add aggregated data. Say you want to find out, okay, how many board apes have been traded every month? Or what is the total value of what other aggregated data you want to have in your subgraph. You can add that then to the mapping code and then redeploy. So, for example, we can go into the schema and say that we want to simply like now we have all the transfer events but we don't know when they happen.
01:54:12.548 - 01:55:51.550, Speaker H: So we could, for example, have a timestamp and then to create the timestamp so you can access it from the mapping code, you would run graph code gen again. Now it's created the type spores so we can access them in the mapping code. So now I can go in on the handle transfer and save this in entity dot. You see, now it's appearing here. Timestamp, event timestamp. So now if I were to redeploy that's all that is needed to add that to your subgraph code and thus you can reiterate and add more functionality to your subgraph. Is there any questions so far about writing your subgraph? Yeah.
01:56:00.630 - 01:56:05.126, Speaker G: And you to read change something in the upgradable contract, you'd have to go.
01:56:05.148 - 01:56:09.638, Speaker C: And change, I guess, where the graph is pointing to, which contract is pointing.
01:56:09.654 - 01:56:10.698, Speaker E: To, is that correct?
01:56:10.864 - 01:57:03.820, Speaker H: Yeah. So the question here is if you are using upgradable contracts and in this case you can use something that is called dynamic data sources, which is a way to then change or add more data sources while the subgraph is in production. And that is used for, for example, Upgradable contracts. Another use case is factory contracts, like say for example, uniswap, every time a new pair is created, you want to create a new data source, which is the new pool. And in that case you would also use dynamic data sources. It's also called templates somewhere in the documentation, but it would be templates in the manifest, for example. But yeah, I can give you some documentation after this talk if you want to dive deeper into it.
01:57:03.820 - 01:57:20.580, Speaker H: Questions about subgofs or creating a subgof. Yeah.
01:57:27.920 - 01:57:30.620, Speaker F: So the graph QR Studio generates.
01:57:34.020 - 01:58:29.534, Speaker H: That is correct. And I will show you now how to query subgraphs and I won't show you the front end code, but I will show you how you can create a GraphQL query and then you can use it depending on what language you're using in the front end application, you can then use that query. If we go back to the graph.com, as I mentioned earlier, we have a Graph Explorer. Or if you have a decentralized network, you can find subgraphs that is on the decentralized network. We had a graph explorer. We also have the hosted service which has 30,000 Open APIs that you can query.
01:58:29.534 - 01:59:19.356, Speaker H: I will show you how to query one of them. So let's for example, say we want to query the synthetics subgraph. For example, here you can create a GraphQL query to test your query. It's not a valid query. You can save your queries and use them. Let me instead open the endpoint. This takes us to a GraphQL Explorer that allows you to create your own GraphQL queries using a simple checkbox type of interface.
01:59:19.356 - 02:00:35.184, Speaker H: So you can, for example, find the Synth holders order by synth and you say you want to have the first ten and now if the Internet is with us, we can get a query response. So there you have the first ten cent holders ordered by Send. And with our prices here on the hackathon, we have two tracks. One is creating a new subgraph, so a new Open APIs, as I showed you ten minutes ago. And the other track is using an existing subgraph in your application. And here you see it is very easy to create a query. And the power of using GraphQL is that you can get exactly what you need.
02:00:35.184 - 02:01:27.224, Speaker H: So no more than that and no less than that as well. You don't need to have this reiteration that you often have to do with SQL where you have to first maybe find the ID of something and then you need to go back in and find the fields that you are looking for. But you can get everything in one query. Yeah. So what determines the speed that a subgraph is indexed? That's a good question. It depends a lot on how you write your mapping code. So there are some patterns that you want to avoid when you're writing a subgraph.
02:01:27.224 - 02:02:22.590, Speaker H: For example, you want to avoid doing an excessive amount of eat calls. So in a subgraph you can do eat calls at a block and get the state of the chain at that block and you want to avoid having an excessive amount. So you don't want to, for example, create a loop where you are looping through a lot of entities and for each of them doing a query to an RPC endpoint. So you can do that in a subgroup, but you want to limit that. So each query takes around 100 to 200 milliseconds at a ruler tom, so a few of them doesn't matter. But if you are doing 1000 of these and you're doing that every block or every event or every transaction, it's going to be costly when you are indexing a subgroup. Yeah.
02:02:22.590 - 02:03:12.080, Speaker H: Specific block or path. Yeah. So the question was querying a pass block or pass range and unless you have deleted an entity in the subgraph, you can just find it directly here like synth holders. This will also hold all the synth holders since this started indexing. But there's also a feature called time travel queries that queries the state of a subgraph at any block that you specify. So say that I want all centholders at a given block. I can get that using time travel queries.
02:03:12.080 - 02:04:05.710, Speaker H: So here you would have block number and then you would write, for example, a block number here. So at this state, this subgarp started indexing at block 5 million and change. So I cannot query block 2333, but any number that I put in that is over this 5 million. Does everybody see my screen, by the way? Cool.
02:04:08.420 - 02:04:09.964, Speaker E: What did you mean by cheap?
02:04:10.012 - 02:05:04.210, Speaker H: I mean every query, when do you pay that? Yes, so again we need to differentiate between the decentralized network where you're paying for queries and the hosted service which is completely free. You will pay for query costs. First of all, with the subgraph that we just created, it's currently on the subgraph studio, which is the staging area and that is also free to use once you deploy your subgraph to the mainnet. So let me see the basic Bogota here. This is the one I just created. This has a development and query URL that you can find here that is completely free to use. You can also use the playground to play around with it.
02:05:04.210 - 02:05:39.430, Speaker H: But once you want to go into production and use this subgraph or use this API, you would go to publish and you would publish it on mainnet. And at that point, you will also need a API key to query that subgraph. And you will pay query fees in GRT. Yeah, I'm done. So, yeah, we can take that afterwards.
02:09:06.370 - 02:09:08.570, Speaker E: All right, guys, thank you for joining.
02:09:08.650 - 02:09:10.320, Speaker C: I'll get started in just a second.
02:09:11.730 - 02:09:12.720, Speaker E: All good.
02:09:17.960 - 02:09:22.410, Speaker C: Just give me 1 minute here. If you're looking for Superfluid, you're in the right place.
02:09:41.500 - 02:09:51.480, Speaker E: All right, so we will get going then. Thanks to everybody who is here. It's fun to be in Bogota. I think all the LATM events that I've been to have been great so far.
02:09:51.550 - 02:09:56.236, Speaker C: The communities here are excellent. But, yeah, I'm excited to get started.
02:09:56.258 - 02:09:59.388, Speaker E: And talk you guys through Superfluid and also show you some examples of how.
02:09:59.394 - 02:10:02.108, Speaker C: To actually get started with Superfluid with code.
02:10:02.194 - 02:10:02.492, Speaker E: Right?
02:10:02.546 - 02:10:06.300, Speaker C: So let's go through building on superfluid at ETH Bogota.
02:10:06.460 - 02:10:11.436, Speaker E: So what is Superfluid for those of you that don't know? Well, it is a protocol that enables.
02:10:11.468 - 02:10:13.756, Speaker C: Something we like to call real time finance.
02:10:13.948 - 02:10:16.196, Speaker E: So the one big way that this.
02:10:16.218 - 02:10:19.168, Speaker C: Manifests itself is through something called money streaming.
02:10:19.344 - 02:10:22.196, Speaker E: So Superfluid enables these money streams, which.
02:10:22.218 - 02:10:28.392, Speaker C: Are digital native programmable cash flows that let you stream money with no capital lockups in a way that is 100%.
02:10:28.446 - 02:10:30.600, Speaker E: Programmable and on chain.
02:10:31.500 - 02:10:33.496, Speaker C: So at Superflu, we like to say.
02:10:33.518 - 02:10:39.884, Speaker E: That the Internet is to information what blockchain is to value, right? We believe that we're in the very.
02:10:39.922 - 02:10:48.760, Speaker C: Early innings here of new forms of finance that will bring this old world of finance into the age of the internet.
02:10:48.920 - 02:10:51.436, Speaker E: And one way this manifests itself is.
02:10:51.458 - 02:10:58.892, Speaker C: Through the way that payments work for things that have to do with time. Right? So services, right? So if you think about services businesses.
02:10:59.036 - 02:11:05.376, Speaker E: If you're an employee, you're kind of in the services businesses business as well. With services, the way these work is.
02:11:05.398 - 02:11:08.420, Speaker C: That they flow in real time from a provider to a client, right?
02:11:08.490 - 02:11:11.316, Speaker E: Netflix is something you watch in real time.
02:11:11.498 - 02:11:17.168, Speaker C: Your work is something you provide in real time. However, the issue is that the payments.
02:11:17.344 - 02:11:23.960, Speaker E: For that value are disconnected from the way they're actually being provided. Right? So you work through an entire month.
02:11:24.030 - 02:11:40.940, Speaker C: And you get paid at the end of the month. Why shouldn't you be getting paid every second? So let's dive into money streaming a little bit more, right? This thing you're seeing there in the bottom right hand corner of the screen is a live money stream. That's ETH being streamed on a testnet.
02:11:41.280 - 02:11:44.536, Speaker E: And you can think of these as continuous payments.
02:11:44.728 - 02:11:46.636, Speaker C: We are used to a world of discrete payments.
02:11:46.668 - 02:11:51.664, Speaker E: What if we could make them continuous, right? What if we could create this direct link between the.
02:11:51.782 - 02:11:56.676, Speaker C: Service provision and the value transfer in return for that service. And the other thing that's cool about.
02:11:56.698 - 02:11:59.108, Speaker E: This, because it's all on chain, it.
02:11:59.274 - 02:12:06.580, Speaker C: Completely gets rid of any delays, unpayment risk, or any intermediaries because it's all mediated through blockchains and smart contracts.
02:12:07.720 - 02:12:12.468, Speaker E: So how is money streaming possible? Well, we built an EVM compatible smart.
02:12:12.484 - 02:12:26.492, Speaker C: Contract framework to make this happen, right? And it's made up of three pieces. So we'll get into how the heck this thing here is happening in the bottom right hand corner, but it takes some building up to it.
02:12:26.626 - 02:12:29.400, Speaker E: So these three pieces are superfluid agreements.
02:12:29.560 - 02:12:34.080, Speaker C: Super tokens, and the superfluid host contract, which brings everything together.
02:12:34.230 - 02:12:46.740, Speaker E: So what are agreements? Well, these agreements are peer to peer financial relationships that are open ended and perpetual between two accounts, or potentially more than two accounts.
02:12:47.240 - 02:13:02.324, Speaker C: When I create an agreement to stream you money, what's happening is I send a transaction on chain which agrees to stream you a certain number of tokens per second. And that amount of tokens that I'm streaming you per second is actually built directly into the token balance.
02:13:02.452 - 02:13:04.036, Speaker E: So we'll get into how the token.
02:13:04.068 - 02:13:08.344, Speaker C: Balances work in just a moment. But what's happening here is, within the.
02:13:08.382 - 02:13:15.612, Speaker E: Constant flow agreement, which is the main agreement that facilitates all this money streaming, you define that flow rate and money.
02:13:15.666 - 02:13:23.392, Speaker C: Begins flowing immediately in real time from you to the receiver. Right. The sender or receiver can be smart contracts. It doesn't matter.
02:13:23.526 - 02:13:32.844, Speaker E: You're just executing a transaction and money begins flowing in real time. So literally, this right here, these simple lines of code, CFAV one, create flow.
02:13:32.892 - 02:13:35.744, Speaker C: Receiver, token, flow rate will open this money stream, right.
02:13:35.782 - 02:13:43.028, Speaker E: It will create this in the end. As a developer, it's quite simple, but to understand how it works, we got.
02:13:43.034 - 02:13:43.824, Speaker C: To go a little deeper.
02:13:43.872 - 02:13:44.084, Speaker E: Right.
02:13:44.122 - 02:13:48.116, Speaker C: So this is all great. You might understand this concept of an agreement.
02:13:48.148 - 02:13:54.676, Speaker E: Yeah, I kind of get that, but how are you doing this without calling transfer? Like every millisecond?
02:13:54.788 - 02:14:12.508, Speaker C: How is that not how this is working? And the way we get around this is by building an extension under the ERC 20 standard, right? So we built an extension out of the ERC 20 that comes with all the stuff you're used to approve transfer from symbol all this stuff.
02:14:12.594 - 02:14:14.864, Speaker E: But the way balances are calculated will.
02:14:14.902 - 02:14:17.276, Speaker C: Take into consideration all of the agreements.
02:14:17.388 - 02:14:19.404, Speaker E: You have outstanding for any given token.
02:14:19.532 - 02:14:19.872, Speaker C: Right.
02:14:19.926 - 02:14:22.688, Speaker E: So within that balance of function on.
02:14:22.694 - 02:14:29.044, Speaker C: A super token contract, there's another call that's made to something called to a function titled Real Time Balance, of which.
02:14:29.082 - 02:14:32.596, Speaker E: Takes into consideration your real time balance. Right.
02:14:32.618 - 02:14:34.468, Speaker C: And your real time balance is really.
02:14:34.634 - 02:14:39.440, Speaker E: Just an aggregation of all of the money being streamed to you and all.
02:14:39.450 - 02:14:41.176, Speaker C: The money you're streaming out to give.
02:14:41.198 - 02:14:43.530, Speaker E: You a kind of single net flow rate.
02:14:44.300 - 02:14:48.980, Speaker C: So let's dive into these a little bit more. Right? Again, ERC 20 compatible plugged into the protocol.
02:14:49.060 - 02:14:50.408, Speaker E: And what's cool about it is they're.
02:14:50.424 - 02:14:55.404, Speaker C: Usable anywhere in web3, right? So we know that interoperability is super.
02:14:55.442 - 02:14:59.436, Speaker E: Important within this industry. So for existing ERC 20s or even.
02:14:59.458 - 02:15:02.784, Speaker C: Native assets like ETH, AVAX, Matic, or.
02:15:02.822 - 02:15:15.148, Speaker E: Other native assets and other chains, we've built Wrappers, right? So you can go wrap USDC. Like actually, right now, my salary is paid using a wrapped version of USDC called Usdcx.
02:15:15.244 - 02:15:16.768, Speaker C: If you see the X appended to.
02:15:16.774 - 02:15:18.196, Speaker E: The end of a symbol, it just.
02:15:18.218 - 02:15:19.792, Speaker C: Means that it's a super token.
02:15:19.936 - 02:15:21.776, Speaker E: It's a wrap version of that existing.
02:15:21.808 - 02:15:24.720, Speaker C: Asset that enables all of the streaming functionality.
02:15:24.800 - 02:15:25.044, Speaker E: Right?
02:15:25.082 - 02:15:25.664, Speaker C: It's a wrapper.
02:15:25.712 - 02:15:26.688, Speaker E: Super token.
02:15:26.864 - 02:15:31.668, Speaker C: There's also native super tokens whose supply is 100% streamable. So if you know about superfluid, you.
02:15:31.674 - 02:15:33.556, Speaker E: Learn about superfluid today and you decide.
02:15:33.588 - 02:15:34.904, Speaker C: To launch a token, you might opt.
02:15:34.942 - 02:15:35.896, Speaker E: To just deploy it out of the.
02:15:35.918 - 02:15:37.608, Speaker C: Box with all these features so you.
02:15:37.614 - 02:15:41.220, Speaker E: Don'T have to wrap anything. That's an option, too. There are several of those out in.
02:15:41.230 - 02:15:44.860, Speaker C: The wild that have a lot of usage, so that's another option.
02:15:44.930 - 02:15:48.796, Speaker E: But the key thing to keep in mind is this real time balance, right?
02:15:48.898 - 02:15:52.936, Speaker C: It's an aggregation of all the incoming flows and outgoing flows.
02:15:53.128 - 02:15:57.456, Speaker E: To create this kind of single number, the protocol needs to keep track of.
02:15:57.558 - 02:15:59.056, Speaker C: To figure out how many tokens you.
02:15:59.078 - 02:16:01.410, Speaker E: Should be sending or receiving every second.
02:16:01.940 - 02:16:07.024, Speaker C: If anybody else has any questions on that, I will stand out there right outside the door and answer as many.
02:16:07.062 - 02:16:09.136, Speaker E: Questions as you guys have just to.
02:16:09.158 - 02:16:10.496, Speaker C: Make sure we really drill that into your heads.
02:16:10.528 - 02:16:11.268, Speaker E: Because I know it can be kind.
02:16:11.274 - 02:16:12.964, Speaker C: Of weird at first, but it is.
02:16:13.002 - 02:16:15.940, Speaker E: Critical to understand if you're going to interact with superfluid.
02:16:16.680 - 02:16:18.660, Speaker C: Okay, the final thing here that's important.
02:16:18.730 - 02:16:23.944, Speaker E: For understanding how the protocol works is this thing called the superfluid host. The superfluid host brings this all together.
02:16:24.062 - 02:16:25.832, Speaker C: It's like the brain of the protocol, right?
02:16:25.886 - 02:16:29.476, Speaker E: So it's made up of some whitelisted agreements. Again, the main one is that constant.
02:16:29.508 - 02:16:31.356, Speaker C: Flow agreement, which defines how balances can.
02:16:31.378 - 02:16:34.940, Speaker E: Be changed during using that constant flow formula.
02:16:35.360 - 02:16:36.908, Speaker C: It also is something you call when.
02:16:36.914 - 02:16:38.184, Speaker E: You deploy a super token.
02:16:38.312 - 02:16:40.364, Speaker C: It supports something called batch calls, which.
02:16:40.402 - 02:16:43.800, Speaker E: Lets you just batch a bunch of superfluid related operations into a single transaction.
02:16:43.880 - 02:16:44.756, Speaker C: Which is kind of helpful.
02:16:44.808 - 02:16:49.616, Speaker E: You can do things like open 150 streams in one transaction, other crazy stuff.
02:16:49.638 - 02:16:51.596, Speaker C: Like that, and then it also serves.
02:16:51.628 - 02:16:57.076, Speaker E: As a registry for something called a super app. Right. So what is a super app and.
02:16:57.098 - 02:17:05.152, Speaker C: Why is that interesting? Well, the other interesting component of Superflu is that it is programmable. You can build contracts that are aware.
02:17:05.296 - 02:17:14.276, Speaker E: Of these streams coming in that have callbacks, which can automatically run whenever a contract starts receiving tokens, whenever those streams.
02:17:14.308 - 02:17:16.724, Speaker C: Are updated, or whenever those streams are deleted.
02:17:16.852 - 02:17:23.948, Speaker E: Right. So this opens up all kinds of really interesting connections between smart contracts that forms a really interesting network that I'll.
02:17:23.954 - 02:17:34.252, Speaker C: Show you a visualization of in just a second. But to understand these, you have to keep in mind that all of these callbacks here, this after agreement created thing you see in the bottom, right?
02:17:34.386 - 02:17:38.752, Speaker E: These are called by the Superfluid host contract, because when you deploy a super.
02:17:38.806 - 02:17:42.864, Speaker C: App, you just register it with that host contract, which is the brand of the protocol, right?
02:17:42.902 - 02:17:45.040, Speaker E: So that the host contract will know.
02:17:45.190 - 02:17:47.044, Speaker C: Hey, this contract that is a super.
02:17:47.082 - 02:17:49.492, Speaker E: App is receiving tokens call this function.
02:17:49.546 - 02:17:52.692, Speaker C: With your arbitrary logic in it to do something else cool, right?
02:17:52.826 - 02:18:07.512, Speaker E: So again, there's lots of super apps deployed right now and they all kind of do different things. One big one is called Ricochet Exchange, which allows people to stream funds into a contract and effectively dollar cost average into different, right?
02:18:07.566 - 02:18:09.700, Speaker C: So right now I can go DCA.
02:18:09.780 - 02:18:13.404, Speaker E: From USDC to ETH on polygon and.
02:18:13.442 - 02:18:14.876, Speaker C: All that's happening in real time, right?
02:18:14.898 - 02:18:19.288, Speaker E: So it's just like this loop where you have a contract that's receiving funds.
02:18:19.304 - 02:18:20.590, Speaker C: And sending funds out.
02:18:21.040 - 02:18:22.236, Speaker E: And what this looks like when you.
02:18:22.258 - 02:18:24.016, Speaker C: Start stitching things like Ricochet and these.
02:18:24.038 - 02:18:29.244, Speaker E: Other contracts together is this you get this really crazy network of cash flows.
02:18:29.292 - 02:18:34.780, Speaker C: Where every single green ball there is an account, whether it's a smart contract or an EOA.
02:18:34.860 - 02:18:38.708, Speaker E: And all the connections between them are cash flows, right?
02:18:38.874 - 02:18:41.056, Speaker C: So for you here that are considering.
02:18:41.088 - 02:18:47.840, Speaker E: Building applications on Superfluid, you have a gigantic network of cash flows to make use of, point them into new places.
02:18:48.000 - 02:18:49.770, Speaker C: Build new things for them to do.
02:18:50.140 - 02:18:57.656, Speaker E: And we'll try to reward you for it. So a quick little aside on the prizes. We have ten K in prizes this.
02:18:57.678 - 02:19:01.496, Speaker C: Weekend, three K for the best over our project built on Superfluid, a few.
02:19:01.518 - 02:19:06.744, Speaker E: $2,000 prizes for various purposes like DeFi and best use of Superfluid and NFTs.
02:19:06.872 - 02:19:24.304, Speaker C: And then we have this thing we call the Pool of Honor, which is just a pool prize where if you implement Superfluid in some capacity, we'll throw you some money. Just don't do things that I've seen where some of you guys just throw a little git commit there at the end and just add the couple of lines. I'll actually look all right, but just.
02:19:24.342 - 02:19:27.764, Speaker E: Wanted to plug those, but all right, let's get into the actual building.
02:19:27.882 - 02:19:30.964, Speaker C: Okay, what do you need to know.
02:19:31.002 - 02:19:33.616, Speaker E: About before you start actually building on Superfluid?
02:19:33.648 - 02:19:41.456, Speaker C: Well, you should be made aware of a couple of DevTools, right? The first is the Superfluid developer console. This makes it really easy to see all these streams.
02:19:41.568 - 02:19:43.416, Speaker E: Ether scan is not quite optimized for.
02:19:43.438 - 02:19:45.588, Speaker C: This sort of thing yet, as you can imagine.
02:19:45.764 - 02:19:54.780, Speaker E: So we built our own console. It makes it easy to manage all this stuff. We have a dashboard that lets you create streams and update streams and all this stuff in a no code way.
02:19:54.850 - 02:20:03.676, Speaker C: If that's your thing. And we have an SDK. So if you like JavaScript, you like TypeScript you don't know solidity. The SDK core is your friend and.
02:20:03.698 - 02:20:04.544, Speaker E: I'll show you how to use that.
02:20:04.582 - 02:20:05.520, Speaker C: In just a second.
02:20:05.670 - 02:20:08.016, Speaker E: So let's build.
02:20:08.198 - 02:20:15.056, Speaker C: Okay, and I guess, you know what, before we click away, I'll go over what we're going to build. The first thing we're going to do.
02:20:15.078 - 02:20:18.416, Speaker E: Is we're just going to interact with some really dead simple front end examples.
02:20:18.448 - 02:20:20.704, Speaker C: So this is for you react fans.
02:20:20.752 - 02:20:25.636, Speaker E: Out there, you TypeScript, JavaScript fans out there. We'll go to our docs. I'll show you where to find these.
02:20:25.738 - 02:20:28.672, Speaker C: We'll create flows, update them using JavaScript.
02:20:28.736 - 02:20:32.216, Speaker E: All right? From there, we'll actually go through the process of building a super app in.
02:20:32.238 - 02:20:34.936, Speaker C: A couple of minutes. I got a pre deployed contract here.
02:20:34.958 - 02:20:44.044, Speaker E: That will receive incoming streams and send all those incoming streams to the owner of the contract. And plot twist, the contract is also an NFT, right?
02:20:44.082 - 02:20:46.716, Speaker C: So if you trade this contract, the.
02:20:46.738 - 02:20:47.868, Speaker E: Cash flow follows it.
02:20:47.954 - 02:20:54.112, Speaker C: So it's a really interesting primitive to let you tokenize cash flows, which can open up a lot of really interesting.
02:20:54.166 - 02:20:55.600, Speaker E: Applications, in my opinion.
02:20:56.340 - 02:21:04.036, Speaker C: So first thing I'm going to do is go into our docs where we.
02:21:04.058 - 02:21:15.956, Speaker E: Have a lot of front end examples. All right? So let me expand this a little bit here, all right? So in our docs, if you have.
02:21:15.978 - 02:21:17.828, Speaker C: Computers out, you can literally go to this right now.
02:21:17.914 - 02:21:26.264, Speaker E: Docs superfluid finance and in developers, if you go to constant flow agreement, it just says CFA frontend examples, super easy.
02:21:26.302 - 02:21:29.160, Speaker C: To find to create a flow.
02:21:29.500 - 02:21:30.968, Speaker E: What we do is we import the.
02:21:30.974 - 02:21:33.672, Speaker C: Superfluid SDK over here.
02:21:33.726 - 02:21:36.296, Speaker E: You can kind of drag this over and see it sometimes. I'm bad at Internet.
02:21:36.328 - 02:21:40.636, Speaker C: These don't load great. We might find an alternative to code sandbox. This is what we got for now.
02:21:40.738 - 02:21:46.076, Speaker E: But we just set up a simple react app and we have a really dead simple function here where we initialize.
02:21:46.108 - 02:21:49.056, Speaker C: The SDK using this line, where we.
02:21:49.078 - 02:21:50.208, Speaker E: Create this framework object.
02:21:50.294 - 02:21:52.000, Speaker C: We specify the chain ID.
02:21:52.070 - 02:21:53.248, Speaker E: You can get this dynamically, but I.
02:21:53.254 - 02:21:54.800, Speaker C: Just hard coded to Gurley.
02:21:54.960 - 02:21:56.420, Speaker E: We create a signer.
02:21:56.920 - 02:21:59.332, Speaker C: We load the super token contract using.
02:21:59.386 - 02:22:08.256, Speaker E: This dix load or not dix. This awaitsf load super token line that'll.
02:22:08.288 - 02:22:12.324, Speaker C: Load a super token contract object for us and then we'll create a flow.
02:22:12.452 - 02:22:13.368, Speaker E: So what we do is we just.
02:22:13.374 - 02:22:20.364, Speaker C: Create a really simple operation object using SF CFAV one create flow pass in a few parameters like the flow rate.
02:22:20.402 - 02:22:26.232, Speaker E: Receiver and super token. And then we execute that from our signer.
02:22:26.296 - 02:22:28.892, Speaker C: Okay, this is hooked up here.
02:22:28.946 - 02:22:31.324, Speaker E: It's hooked up to an exposed private key, right?
02:22:31.442 - 02:22:33.288, Speaker C: You don't have to have an unlocked.
02:22:33.304 - 02:22:34.524, Speaker E: Private key to do this.
02:22:34.642 - 02:22:36.752, Speaker C: Obviously, that's not the preferred way for you to do it.
02:22:36.806 - 02:22:38.448, Speaker E: It's just really easy because we have.
02:22:38.454 - 02:22:39.916, Speaker C: An address with a ton of fake.
02:22:39.948 - 02:22:41.328, Speaker E: Tokens in it and we let you.
02:22:41.334 - 02:22:45.904, Speaker C: Just basically demo this in real time. So here I have an address I've pasted in.
02:22:46.022 - 02:22:48.390, Speaker E: I've got an amount here which is our flow rate.
02:22:48.840 - 02:22:50.996, Speaker C: This thing down here will calculate what.
02:22:51.018 - 02:22:57.268, Speaker E: That flow rate actually is. When you put this number in. This is actually in way per second. So it's helpful to have a kind.
02:22:57.274 - 02:22:59.636, Speaker C: Of formula for UX purposes to calculate.
02:22:59.668 - 02:23:08.250, Speaker E: What this actually is on a per month basis. So what I'll do is I'll just click this to create the stream. This should work in just a second.
02:23:10.140 - 02:23:14.428, Speaker C: All right, so we just created a money stream. So what I'm going to do is.
02:23:14.434 - 02:23:17.660, Speaker E: I'm going to plug this address into the console. This is the console.
02:23:18.560 - 02:23:19.628, Speaker C: Check it out.
02:23:19.794 - 02:23:21.788, Speaker E: Useful tool. If you click Home, you can see.
02:23:21.794 - 02:23:26.320, Speaker C: A bunch of streams, right, on different networks. If I want to click on Guerreli.
02:23:26.980 - 02:23:28.720, Speaker E: I can just paste in the address.
02:23:28.790 - 02:23:31.856, Speaker C: That I just used to create to.
02:23:31.878 - 02:23:33.010, Speaker E: Send the stream to.
02:23:34.740 - 02:23:42.150, Speaker C: And we can see that we are receiving some money, right? So I just created a stream to this address.
02:23:42.520 - 02:23:44.660, Speaker E: Pretty cool, right? Not very much has come in yet.
02:23:44.730 - 02:23:48.660, Speaker C: That's because it's a pretty small amount, right? So we created a stream.
02:23:50.680 - 02:23:54.472, Speaker E: In this page. We have a few other ways you can do this, right? So we have at the very bottom.
02:23:54.606 - 02:23:58.292, Speaker C: A MetaMask and Web three provider example where you can just use MetaMask.
02:23:58.436 - 02:23:59.530, Speaker E: Yes. Question.
02:24:01.900 - 02:24:07.210, Speaker H: Address, application, whatever amount.
02:24:10.820 - 02:24:13.856, Speaker E: So no, one thing I'll walk through.
02:24:13.878 - 02:24:22.688, Speaker C: What I think you mean if you're starting with dai and you want to stream money with that dai, you have to wrap that dai to super token dai, right?
02:24:22.774 - 02:24:25.956, Speaker E: So again, if you want simple examples of that, again, we got more fun.
02:24:25.978 - 02:24:39.976, Speaker C: And examples here around let's go to Tokens super tokens. We'll walk you through how this works. And then we have an example here that's just like the other interactive ones.
02:24:40.078 - 02:24:41.796, Speaker E: Where you can just call the upgrade.
02:24:41.828 - 02:24:44.536, Speaker C: Function to wrap those tokens, right?
02:24:44.558 - 02:24:45.736, Speaker E: That's the only thing you have to do.
02:24:45.838 - 02:24:48.132, Speaker C: But if you already have those wrapped.
02:24:48.196 - 02:24:52.670, Speaker E: Die in your account no, you just call that function and boom, you're good.
02:24:53.840 - 02:24:55.788, Speaker C: Makes sense. Cool.
02:24:55.954 - 02:24:58.316, Speaker E: All right, so I won't belabor the point, right?
02:24:58.338 - 02:25:00.168, Speaker C: You can imagine that updating and deleting.
02:25:00.264 - 02:25:02.204, Speaker E: Is very, very similar, right?
02:25:02.322 - 02:25:05.680, Speaker C: I won't go into those, but that is dead simple.
02:25:05.750 - 02:25:09.264, Speaker E: Creating updating and deleting streams in JavaScript, right?
02:25:09.462 - 02:25:17.924, Speaker C: Pretty straightforward, really easy to integrate with any other project you're probably working on. For a more complex example, let's get into this tradable cash flow thing, right?
02:25:17.962 - 02:25:19.252, Speaker E: This super app thing.
02:25:19.386 - 02:25:22.404, Speaker C: And I have a project up here. I'll show you where to find this.
02:25:22.442 - 02:25:26.340, Speaker E: After I'm done. We have this in our main repo.
02:25:27.000 - 02:25:30.536, Speaker C: I'll zoom way in. Hopefully you guys can see that.
02:25:30.558 - 02:25:31.290, Speaker E: All right?
02:25:32.140 - 02:25:35.940, Speaker C: But inside of our examples, this is inside of our super examples repo.
02:25:36.100 - 02:25:37.992, Speaker E: We have this tradable cash flow example here.
02:25:38.046 - 02:25:43.116, Speaker C: Okay? So this is going to look exactly the same as it does here. As it will in that repo, we.
02:25:43.138 - 02:25:46.716, Speaker E: Have two contracts, and the first one.
02:25:46.738 - 02:25:53.904, Speaker C: Is called this Redirect All contract. So what the redirect all contract is? It's a super app, which means that.
02:25:53.942 - 02:25:56.656, Speaker E: It allows us to send money into it.
02:25:56.758 - 02:26:00.096, Speaker C: And then when we send money into it, we can execute arbitrary logic in.
02:26:00.118 - 02:26:05.248, Speaker E: These callbacks to do something. That something could be anything you want.
02:26:05.414 - 02:26:06.448, Speaker C: But in our case, what we're going.
02:26:06.454 - 02:26:07.088, Speaker E: To do is we're just going to.
02:26:07.094 - 02:26:16.708, Speaker C: Send 100% of the value coming into the contract to the owner. All right, so we have a bunch of stuff set up in the constructor. We initialize this CFA library to make.
02:26:16.714 - 02:26:18.752, Speaker E: It really easy to create streams in Solidity.
02:26:18.896 - 02:26:27.400, Speaker C: I won't go too deeply into that right now, but the Cliff Notes is it makes it so that creating a stream in Solidity looks a lot like how it did in JavaScript.
02:26:27.820 - 02:26:30.584, Speaker E: We register the app, so remember that.
02:26:30.702 - 02:26:33.532, Speaker C: That host contract has a registry of super apps on it.
02:26:33.586 - 02:26:35.196, Speaker E: So we need to register it and.
02:26:35.218 - 02:26:39.132, Speaker C: We need to define the callbacks we do and don't want to use.
02:26:39.186 - 02:26:39.356, Speaker E: Right?
02:26:39.378 - 02:26:40.604, Speaker C: We have docs on this that explain.
02:26:40.642 - 02:26:41.724, Speaker E: This in much more detail.
02:26:41.842 - 02:26:47.312, Speaker C: But in essence, there are six callbacks that can run. There's a before agreement created, an after.
02:26:47.366 - 02:26:51.692, Speaker E: Agreement created, before agreement updated, after agreement updated, and the same for deleted.
02:26:51.836 - 02:26:54.976, Speaker C: The before will run before the actual logic takes place.
02:26:55.078 - 02:27:01.648, Speaker E: The after will run after the event takes place. Okay, so we're basically just turning all of the before agreement options into no ops.
02:27:01.664 - 02:27:04.676, Speaker C: We're not going to use them. So the only callbacks we're going to.
02:27:04.698 - 02:27:07.632, Speaker E: Use are these after agreement callbacks.
02:27:07.696 - 02:27:08.020, Speaker C: Okay?
02:27:08.090 - 02:27:10.936, Speaker E: So inside of these, we get a bunch of parameters that the host will.
02:27:10.958 - 02:27:21.964, Speaker C: Call it with and we're going to run a single operation here. And that's this update flow operation. What's happening in update flow? Well, all we're doing is we're just.
02:27:22.002 - 02:27:28.344, Speaker E: Checking whether or not a stream already exists into the contract and we're handling that situation accordingly.
02:27:28.392 - 02:27:30.796, Speaker C: Right, so if there already is a.
02:27:30.818 - 02:27:32.908, Speaker E: Stream coming into the contract and the.
02:27:32.994 - 02:27:38.784, Speaker C: Operation is a delete operation, that means we need to not only delete the stream coming into the contract, but also.
02:27:38.822 - 02:27:45.084, Speaker E: Delete all the fundings coming out of the contract, right. 100% of the inflow should equal 100% of the outflow.
02:27:45.132 - 02:27:46.036, Speaker C: So we're just basically going to make.
02:27:46.058 - 02:27:47.876, Speaker E: Sure those match in this function.
02:27:47.978 - 02:27:53.460, Speaker C: Right? But again, the limits here are your creativity. You could put whatever you want here, right?
02:27:53.530 - 02:27:55.270, Speaker E: This is just one example.
02:27:55.960 - 02:27:57.828, Speaker C: The other function here that's useful is.
02:27:57.834 - 02:27:59.252, Speaker E: This change receiver function.
02:27:59.386 - 02:28:02.904, Speaker C: This will run every time the token is transferred. So if I want to sell this.
02:28:02.942 - 02:28:08.084, Speaker E: NFT, this change receiver function will run, which will just change who is receiving the flow.
02:28:08.212 - 02:28:08.504, Speaker C: Right?
02:28:08.542 - 02:28:10.536, Speaker E: So if I sell it, we'll take.
02:28:10.638 - 02:28:12.372, Speaker C: As a parameter here the new receiver.
02:28:12.436 - 02:28:15.596, Speaker E: Which is going to be the person I sold it to, that person is.
02:28:15.618 - 02:28:19.484, Speaker C: Now going to receive 100% of the outflow. Simple enough.
02:28:19.602 - 02:28:21.004, Speaker E: And then inside of this Tradable cash.
02:28:21.042 - 02:28:23.704, Speaker C: Flow contract, it's an NFT. It's an ERC.
02:28:23.752 - 02:28:25.708, Speaker E: 721. It inherits from the redirect.
02:28:25.724 - 02:28:33.340, Speaker C: All contract. And then we use this nice little helpful before token transfer hook that you guys can find in the open Zeppelin API docs.
02:28:33.500 - 02:28:41.590, Speaker E: And we just call that change receiver function in there. So I have a pre deployed version of this. Let me go to it in just a second.
02:28:41.960 - 02:28:43.136, Speaker C: And I got a bunch of scripts.
02:28:43.168 - 02:28:46.276, Speaker E: So we're going to interact with it really fast before we wrap up.
02:28:46.458 - 02:28:48.196, Speaker C: So I have some scripts.
02:28:48.388 - 02:28:50.568, Speaker E: Let me grab this contract address so.
02:28:50.574 - 02:28:56.276, Speaker C: We can go look at it. This right here will be our Tradable.
02:28:56.308 - 02:28:57.544, Speaker E: Cash flow NFT address.
02:28:57.662 - 02:29:04.796, Speaker C: We can see I've been playing with it, I've been sending streams to it and stuff. But if I want to create a stream to this NFT contract using a.
02:29:04.818 - 02:29:10.956, Speaker E: Script, what I can do is I can just call this create flow script. And what this is doing is it's basically using the same logic we had.
02:29:10.978 - 02:29:11.820, Speaker C: In our react app.
02:29:11.890 - 02:29:13.484, Speaker E: We're creating a flow with the script.
02:29:13.612 - 02:29:21.344, Speaker C: So we're just doing this in node instead of the react version we just saw a bit ago.
02:29:21.382 - 02:29:24.164, Speaker E: So if I run this using hard.
02:29:24.202 - 02:29:24.900, Speaker B: Hat.
02:29:27.400 - 02:29:34.688, Speaker E: Createflow JS, we're going to create a flow from our signer into the contract on Guerreli.
02:29:34.864 - 02:29:36.852, Speaker C: This should work. Please.
02:29:36.906 - 02:29:38.100, Speaker E: Internet gods.
02:29:39.420 - 02:29:42.648, Speaker C: All right. Yep. I think that just worked.
02:29:42.814 - 02:29:43.976, Speaker E: In a couple of seconds, as soon.
02:29:43.998 - 02:29:47.560, Speaker C: As the transaction propagates and stuff, we'll go back and see what just happened.
02:29:47.710 - 02:29:49.624, Speaker E: Inside that NFT contract.
02:29:49.752 - 02:29:52.748, Speaker C: But again, if you want, we can.
02:29:52.754 - 02:29:55.020, Speaker E: Go through the update examples, right?
02:29:55.090 - 02:29:57.740, Speaker C: Instead of it being create, we're just calling update.
02:29:58.400 - 02:30:03.004, Speaker E: And instead of same thing. Instead of create or Update, we're calling delete here, right.
02:30:03.122 - 02:30:04.448, Speaker C: The only difference in these functions is.
02:30:04.454 - 02:30:13.344, Speaker E: That the delete function doesn't need a flow rate because there is no flow rate, we're just deleting. Okay, so let's refresh this again.
02:30:13.542 - 02:30:14.988, Speaker C: Prayers up to the Internet Gods.
02:30:15.004 - 02:30:15.890, Speaker E: See if it works.
02:30:17.780 - 02:30:18.608, Speaker C: There we go.
02:30:18.694 - 02:30:24.516, Speaker E: All right, so what we can see let me zoom way in. What we can see is my account just created a stream of about 33.
02:30:24.538 - 02:30:27.556, Speaker C: Tokens per day into the contract. We can see how much has been.
02:30:27.578 - 02:30:29.416, Speaker E: Streamed in, and we can see that.
02:30:29.438 - 02:30:37.160, Speaker C: Because, again, 100% of the flow into the contract is going to go to the owner. So there's no net flow rate for this thing.
02:30:37.230 - 02:30:44.140, Speaker E: It's just basically coming in and passing it all through to the owner. We also have an outflow rate that was automatically created.
02:30:44.480 - 02:30:45.548, Speaker C: We didn't create that.
02:30:45.634 - 02:30:47.084, Speaker E: Those callback functions created that.
02:30:47.122 - 02:31:03.776, Speaker C: So it reacted to that operation for the exact same amount, right, so that they match. And that's the idea. So that's end to end, a super app contract and all of those JavaScript SDK examples, right.
02:31:03.958 - 02:31:05.408, Speaker E: It should get you started, hopefully give.
02:31:05.414 - 02:31:11.556, Speaker C: You some ideas to wrap things up here I want to walk through, like.
02:31:11.578 - 02:31:12.868, Speaker E: What else you could build. Right?
02:31:12.954 - 02:31:14.192, Speaker C: I have a lot of ideas.
02:31:14.336 - 02:31:23.592, Speaker E: A lot of people here that are sponsoring will tell you they have lots of ideas that you can take and build on. But I'll just give you a few right now.
02:31:23.646 - 02:31:24.056, Speaker C: Right?
02:31:24.158 - 02:31:26.244, Speaker E: One interesting one is a platform for Token vesting.
02:31:26.292 - 02:31:28.552, Speaker C: Our community would like to see this, right?
02:31:28.686 - 02:31:30.852, Speaker E: Streaming money is good for vesting tokens.
02:31:30.916 - 02:31:37.340, Speaker C: Right. You do have to lock the funds up in a contract at first, but money is being sent per second, right.
02:31:37.410 - 02:31:39.644, Speaker E: So it's pretty useful to be as.
02:31:39.682 - 02:31:42.616, Speaker C: You'Re vesting, be able to vest on a per second basis and actually receive.
02:31:42.648 - 02:31:52.000, Speaker E: The money second by second. The other one is Web Three native subscriptions. So these are all recurring payments, right. They're money streams. There is no canonical yet.
02:31:52.070 - 02:31:54.516, Speaker C: There are some great teams, we love working on it, but there is no.
02:31:54.538 - 02:31:58.628, Speaker E: Canonical web Three native subscriptions platform that uses money streams yet.
02:31:58.714 - 02:31:59.684, Speaker C: You could build that.
02:31:59.802 - 02:32:05.664, Speaker E: Another one is a decentralized advertising protocol where you could effectively turn that NFT.
02:32:05.712 - 02:32:12.888, Speaker C: Contract I just showed you into like a billboard space for banner ads and have all the money streamed into it.
02:32:12.974 - 02:32:16.136, Speaker E: Be sent to the owner of the billboard. You can do interesting things in those.
02:32:16.158 - 02:32:27.032, Speaker C: Callbacks like split the funds too, if you want. Two other ones are around like lending, borrowing and lending. One of them is a lending protocol that would use streams to amortize loans.
02:32:27.096 - 02:32:32.568, Speaker E: So what if I could pay off a loan with a stream instead of discrete amounts?
02:32:32.744 - 02:32:35.376, Speaker C: Our hypothesis is that doing that would.
02:32:35.398 - 02:32:37.616, Speaker E: Justify a lower interest rate because the.
02:32:37.638 - 02:32:40.156, Speaker C: Lender is getting their money back faster. It's more granular.
02:32:40.268 - 02:32:42.288, Speaker E: And the final one that's really interesting.
02:32:42.374 - 02:32:44.076, Speaker C: Based on that huge network I showed.
02:32:44.108 - 02:32:46.592, Speaker E: You, is being able to borrow against.
02:32:46.646 - 02:32:51.280, Speaker C: An incoming money stream, right? So there's a lot of people receiving salary streams right now.
02:32:51.430 - 02:32:52.400, Speaker E: I'm one of them.
02:32:52.470 - 02:32:54.450, Speaker C: There's many, many others.
02:32:54.820 - 02:32:56.788, Speaker E: What if I could because that's a cash flow.
02:32:56.804 - 02:32:57.796, Speaker C: It's an on chain cash flow.
02:32:57.828 - 02:32:58.712, Speaker E: It's proof of payment.
02:32:58.846 - 02:33:07.080, Speaker C: What if I could borrow against that and not have to put up any other collateral? That'd be really interesting and it'd be the kind of thing that I personally would try out. So there are markets here.
02:33:07.150 - 02:33:08.440, Speaker E: These are things we've thought through a lot.
02:33:08.510 - 02:33:09.384, Speaker F: If you guys want to build them.
02:33:09.422 - 02:33:11.450, Speaker E: Come up and say outer booth and I'm happy to help.
02:33:12.940 - 02:33:16.652, Speaker C: Finally, what I want to leave you with is where to start.
02:33:16.706 - 02:33:16.972, Speaker E: Okay?
02:33:17.026 - 02:33:17.948, Speaker C: Like if you leave here and you're.
02:33:17.954 - 02:33:19.900, Speaker E: Curious about superfluid, where do I go next?
02:33:19.970 - 02:33:23.548, Speaker C: All right, well, the first place is those SDK examples inside of our docs.
02:33:23.644 - 02:33:28.876, Speaker E: Go to our Docs constant Flow Agreement front end examples. The second place is our solidity examples.
02:33:28.908 - 02:33:36.288, Speaker C: Repo look up Superfluid Finance on GitHub and look for super examples. And I'd also recommend YouTube for a.
02:33:36.294 - 02:33:38.100, Speaker E: Lot of tutorials, more in depth stuff.
02:33:38.250 - 02:33:40.944, Speaker C: And the last thing is a podcast.
02:33:40.992 - 02:33:42.788, Speaker E: We just launched, right? So this really doesn't have anything to.
02:33:42.794 - 02:33:44.980, Speaker C: Do directly with Superfluid, but it is.
02:33:45.050 - 02:33:50.068, Speaker E: A great resource for technical people like yourself. We've interviewed a lot of top devs.
02:33:50.084 - 02:33:52.248, Speaker C: From Maker Balancer, uma, devrel leaders like.
02:33:52.254 - 02:34:01.432, Speaker E: Austin Griffith about very technical topics, right? Like their favorite gas optimizations, how they ship new features, how they manage their engineering teams, all this stuff.
02:34:01.486 - 02:34:03.212, Speaker C: We try to pull it out and.
02:34:03.266 - 02:34:04.296, Speaker E: Give you guys the insights.
02:34:04.328 - 02:34:07.964, Speaker C: So I'd recommend checking it out. Devs, do something on your favorite podcast platform.
02:34:08.162 - 02:34:10.548, Speaker E: But yeah, that's the last thing I'll plug.
02:34:10.664 - 02:34:11.824, Speaker C: I'll leave you with that.
02:34:11.942 - 02:34:13.244, Speaker E: Come say what's up at the booth.
02:34:13.292 - 02:34:29.970, Speaker C: And thank you for being here. Appreciate it. All right, thank you.
02:34:34.340 - 02:34:35.330, Speaker A: Grab this.
02:36:54.550 - 02:36:56.258, Speaker C: All right, I think we're good to go.
02:36:56.344 - 02:36:58.166, Speaker E: Hello, everyone. Thank you for coming.
02:36:58.348 - 02:37:00.038, Speaker C: I'm Eulis from APWINE, one of the.
02:37:00.044 - 02:37:01.826, Speaker E: Co founders of Apyine Finance.
02:37:01.938 - 02:37:03.346, Speaker C: And today I'm going to be presenting.
02:37:03.378 - 02:37:14.730, Speaker E: This workshop in mainly three different know what Apyine is, how it works, and how you can integrate it into your own hackathon project in order to win some prizes.
02:37:16.350 - 02:37:19.914, Speaker C: So we're going to begin with what is AP Wine and why did we.
02:37:19.952 - 02:37:23.258, Speaker E: Build it in the first place? It all started during the DFI summer.
02:37:23.274 - 02:37:27.802, Speaker C: Of 2020, where APYs were just crazy three digits.
02:37:27.946 - 02:37:30.782, Speaker E: And we just saw the opportunity here.
02:37:30.836 - 02:37:37.970, Speaker C: Because there was no way to bet on the loss on the rise of yield. So essentially reduce your risk.
02:37:39.750 - 02:37:41.218, Speaker E: This is why we came up with.
02:37:41.304 - 02:37:49.334, Speaker C: A new primitive in DeFi called yield tokenization. And now yield tokenization is mainly the core of APY Finance, and this is.
02:37:49.372 - 02:37:53.350, Speaker E: What allows you to get your yield in advance or trade yield.
02:37:54.410 - 02:37:57.634, Speaker C: So yield tokenization allows you to buy.
02:37:57.692 - 02:38:00.650, Speaker E: Sell, and hedge your risk in DeFi on your yield.
02:38:00.990 - 02:38:05.034, Speaker C: Now, how does it work? It all begins with if you use.
02:38:05.072 - 02:38:07.594, Speaker E: Some funds on Ave or Compound or.
02:38:07.632 - 02:38:25.358, Speaker C: Any yield generating platform, you have some interest bearing assets. Interest bearing assets is you just hold your tokens and it increases in value or just increases yield in your wallet. So as an example, I've taken Adai, a pretty common asset to hold in your wallet.
02:38:25.454 - 02:38:30.590, Speaker E: It just increases in value. And this is an interest bearing token. Now, if you deposit that on APY.
02:38:30.670 - 02:38:32.594, Speaker C: This is the yield tokenization part.
02:38:32.712 - 02:38:36.198, Speaker E: We're going to split it into two tokens. So one of them is going to.
02:38:36.204 - 02:38:42.770, Speaker C: Be the principal token. And this represents the value of your deposit at the time when you deposit.
02:38:42.850 - 02:38:50.966, Speaker E: So essentially, imagine you deposit 100 Adai on APY, you're going to get 100 PT principal tokens.
02:38:51.078 - 02:38:53.338, Speaker C: And these principal tokens are always going.
02:38:53.344 - 02:39:00.466, Speaker E: To represent 100 Adai, right? It's always the same value. And now what's interesting is the future yield token.
02:39:00.518 - 02:39:02.014, Speaker C: The second token that you get.
02:39:02.132 - 02:39:05.006, Speaker E: And this is going to constantly when.
02:39:05.028 - 02:39:09.966, Speaker C: The Adai is generating yield from Ave, it's going to put this yield not.
02:39:09.988 - 02:39:13.342, Speaker E: Into the principal token, but into the future yield token.
02:39:13.486 - 02:39:21.586, Speaker C: So essentially, we're splitting the capital and the future yield. And this is what allows us to.
02:39:21.608 - 02:39:24.500, Speaker E: Get this entire marketplace of future yield going on.
02:39:25.830 - 02:39:33.446, Speaker C: So you can mint PT and FYT with your interest bearing tokens and you're never locked in the platform. You can always withdraw if you still.
02:39:33.468 - 02:39:37.734, Speaker E: Have the PT and the FYT. And then we have the AP One.
02:39:37.772 - 02:39:39.702, Speaker C: AMM, which is a core part of the protocol.
02:39:39.766 - 02:39:41.466, Speaker E: And the AP One AMM allows you.
02:39:41.488 - 02:39:51.102, Speaker C: To sell this FYT or buy PT or just trade between any of the three assets of Adai, PT, FYT in order to build your own strategies or.
02:39:51.156 - 02:39:55.360, Speaker E: Get your yield in advance or fix your rate or so on.
02:39:57.090 - 02:39:58.910, Speaker C: Our AP One AMM is the result.
02:39:58.980 - 02:40:09.554, Speaker E: Of many months of research. This is the APY and AMM v one. We have Impermanent loss protection mechanism for LPs. So if you want to become a liquidity provider on APY, it's also very.
02:40:09.592 - 02:40:10.658, Speaker C: Easy to do so.
02:40:10.744 - 02:40:15.826, Speaker E: And maybe we can chat about it after the workshop. But in order to get straight into.
02:40:15.848 - 02:40:20.760, Speaker C: The workshop, I'm just going to mention a few strategies here, and then we're going to get into what we're going to build today.
02:40:21.850 - 02:40:23.414, Speaker E: Some of the strategies you can build.
02:40:23.452 - 02:40:25.794, Speaker C: With APY include PT trading.
02:40:25.842 - 02:40:31.750, Speaker E: So this is like equivalent to a fixed rate, essentially buying PT at a discount.
02:40:31.830 - 02:40:34.826, Speaker C: Imagine if you're buying PT at 0.9%.
02:40:34.848 - 02:40:41.370, Speaker E: So 90% of what it's really worth. It means that if you wait till the end of the period, for example.
02:40:41.440 - 02:40:44.622, Speaker C: Three months, this is what we work with, you're going to make a 10%.
02:40:44.676 - 02:40:46.794, Speaker E: Profit because you know for sure you're.
02:40:46.842 - 02:40:48.526, Speaker C: Buying something that is going to be.
02:40:48.548 - 02:40:49.710, Speaker E: Worth more in the future.
02:40:49.780 - 02:40:56.242, Speaker C: And this is how you fix your rate. Now, without going into too many strategies, this is what we're going to be doing today.
02:40:56.376 - 02:41:01.810, Speaker E: Today's workshop is about going back to the future to fix your rate on your yield.
02:41:02.950 - 02:41:05.298, Speaker C: So we're going to be leveraging the.
02:41:05.304 - 02:41:10.466, Speaker E: Yield tokenization part of APY plus the Apyine AMM in order to build this strategy.
02:41:10.658 - 02:41:12.886, Speaker C: So some of the prerequisites and if.
02:41:12.908 - 02:41:15.682, Speaker E: You have your computer, it's great. If you don't, you can just follow along.
02:41:15.756 - 02:41:37.280, Speaker C: But it's also very easy to follow with the GitHub repo. So you need Yarn node JS. And we're going to be starting now with the repository setup. All right, it's fine. I'll just keep like this.
02:41:37.890 - 02:41:39.406, Speaker E: All right. This is going to be a one.
02:41:39.428 - 02:41:41.300, Speaker C: Handed workshop, which is going to be interesting.
02:41:41.910 - 02:41:56.646, Speaker E: Let's go with the repository setup. I'm just going to get this a little bit higher. And we're going to gitclone GitHub.com uladevineworkshop. And if we clone this repo and.
02:41:56.668 - 02:42:01.542, Speaker C: We navigate to it, let's open it in code to better.
02:42:01.596 - 02:42:05.046, Speaker E: See it and you're going to be.
02:42:05.068 - 02:42:08.298, Speaker C: Able to see everything that it contains. The first step you're going to want.
02:42:08.304 - 02:42:16.566, Speaker E: To do is copy the environment file from the example file to your environment local file.
02:42:16.598 - 02:42:20.346, Speaker C: So F, example two M. I've set.
02:42:20.368 - 02:42:29.482, Speaker E: Up an API key for you to try. Please don't use it for anything else. It's not going to work. All right. And then we just want to install all the dependencies.
02:42:29.546 - 02:42:31.322, Speaker C: So you just want to go with yarn.
02:42:31.386 - 02:42:32.626, Speaker E: This is going to install all the.
02:42:32.648 - 02:42:40.978, Speaker C: Packages just like NPM. And while we do this, let's take a look at how we are going to follow along.
02:42:41.144 - 02:42:48.114, Speaker E: So, first step we're going to do is yarn start node. This is going to start a node, a fork on mainnet.
02:42:48.242 - 02:42:59.100, Speaker C: So essentially, we're going to be simulating our strategy without actually using money, which is very useful because if your strategy doesn't work, you likely just want to simulate it before.
02:42:59.870 - 02:43:08.022, Speaker E: So if we do yarn start node, this is going to do a local blockchain fork. And then we want to open a new tab.
02:43:08.166 - 02:43:09.930, Speaker C: And every time we want to follow.
02:43:10.000 - 02:43:13.486, Speaker E: Along a step, you can just do yarn step one, yarn step two, all.
02:43:13.508 - 02:43:14.270, Speaker C: The way to five.
02:43:14.340 - 02:43:15.866, Speaker E: So just done as an example, let's.
02:43:15.898 - 02:43:36.114, Speaker C: Do yarn step one. And then we can go look into the code to see what it does. So here we can see that it initializes the SDK. And this is the first step that we're going to take a look at it. So, first step is the SDK creation. Very simple, just one liner. This is going to be a JavaScript workshop, not a solidity workshop.
02:43:36.162 - 02:43:42.726, Speaker E: But if you're interested in integrating within solidity our contracts, we can chat about it. It's also very easy to do.
02:43:42.748 - 02:43:45.814, Speaker C: So, first step, SDK is equal to.
02:43:45.852 - 02:43:48.438, Speaker E: New APY and SDK, you want to.
02:43:48.444 - 02:43:56.314, Speaker C: Put your provider, your signer, everything that you need, the network which is going to be mainnet. And that's it. A new world opens to you, the.
02:43:56.352 - 02:44:17.054, Speaker E: World of future yield. So this is the first step that we just did. The SDK is now initialized and ready to work. Second step. So just to explain how this is going to work, what we're going to do is first see how we can do the very basic PT trading strategy. So buying PT for cheap and waiting.
02:44:17.102 - 02:44:19.122, Speaker C: Till the end and seeing how much.
02:44:19.176 - 02:44:23.794, Speaker E: Apr do we get. And the second step, which is the.
02:44:23.832 - 02:44:31.382, Speaker C: Real workshop that we're going to do, is go through future yield. So essentially tokenizing into Ptfyt and then.
02:44:31.436 - 02:44:35.686, Speaker E: Swapping our future yield for fixed rates. And we're going to see that this.
02:44:35.708 - 02:44:39.580, Speaker C: Is much more capital efficient. So hang on.
02:44:41.550 - 02:44:42.602, Speaker E: This is the first step.
02:44:42.656 - 02:44:48.620, Speaker C: How do we retrieve all the futures? APY supports all the assets that we support, all the platforms and so on.
02:44:49.070 - 02:44:55.066, Speaker E: What we can do is this. Futures is equal to SDK, fetch all future aggregates.
02:44:55.178 - 02:44:57.742, Speaker C: Very simple, you get all the information that you need.
02:44:57.876 - 02:44:59.040, Speaker E: Let's try out.
02:45:01.730 - 02:45:07.390, Speaker C: And while we do this step so this is going to actually run on the main network.
02:45:07.550 - 02:45:10.162, Speaker E: We can take a look at what it does here.
02:45:10.216 - 02:45:14.646, Speaker C: So if we go to script and then step two, get all futures, we.
02:45:14.668 - 02:45:16.134, Speaker E: Can see exactly what it does.
02:45:16.252 - 02:45:22.840, Speaker C: So here fetch future aggregate from address and we just pat whatever future vault address we want.
02:45:23.610 - 02:45:27.046, Speaker E: And if we go back here, we.
02:45:27.068 - 02:45:33.254, Speaker C: Can see here the results of all the assets that we support at this time of the fork.
02:45:33.302 - 02:45:37.754, Speaker E: This was a fork from a few months ago. We now support many, many assets around.
02:45:37.792 - 02:45:42.366, Speaker C: Two chains and many different platforms. But here we have for example and.
02:45:42.388 - 02:45:50.110, Speaker E: This is going to be the one we are going to look at, we have Staked ETH from Lido Finance. Anybody ever used a staked ETH before?
02:45:50.260 - 02:45:53.042, Speaker C: Yeah. So you can generate Apr at 5%.
02:45:53.096 - 02:45:59.470, Speaker E: 6%, depends on what you're getting. Right? And this is a period that expires.
02:45:59.550 - 02:46:06.802, Speaker C: Expired rather on the 23 of March of 2022. So this is an older fork but.
02:46:06.856 - 02:46:09.426, Speaker E: The principle stays the same. You can try with a newer block.
02:46:09.458 - 02:46:11.720, Speaker C: Number and it's going to work just as well.
02:46:13.690 - 02:46:14.918, Speaker E: And then the next step we want.
02:46:14.924 - 02:46:16.934, Speaker C: To do is compute the Apr that.
02:46:16.972 - 02:46:18.386, Speaker E: We would get if we were to.
02:46:18.428 - 02:46:22.300, Speaker C: Buy the PT for this specific Staked ETH future.
02:46:22.670 - 02:46:24.202, Speaker E: So how do we do this?
02:46:24.336 - 02:46:29.834, Speaker C: We're going to use the AMM this time because we want a special price, right? If you want to buy or sell.
02:46:29.872 - 02:46:31.134, Speaker E: Anything, you're going to have to go.
02:46:31.172 - 02:46:32.910, Speaker C: Through the APY and AMM.
02:46:33.330 - 02:46:44.110, Speaker E: So price is equal to SDK. Fetch spot price, you pass the vault. So this is going to be our Stake ETH vault. And then from and to these are two different strings.
02:46:44.190 - 02:46:47.086, Speaker C: So you can put underlying PT or FYT.
02:46:47.118 - 02:46:47.940, Speaker E: Very simple.
02:46:49.830 - 02:46:52.980, Speaker C: And this is what we're going to do right now and see the result.
02:46:53.930 - 02:47:00.918, Speaker E: So yarn step three and we can take a look at what it does here.
02:47:01.004 - 02:47:06.534, Speaker C: Compute PTA apr. So here the result is that we get an Apr of 35%.
02:47:06.652 - 02:47:12.522, Speaker E: Remember this was before. How is that possible? The magic of DFI this was very.
02:47:12.576 - 02:47:14.470, Speaker C: Close to the launch of AP Wine.
02:47:14.550 - 02:47:25.360, Speaker E: So there were still many opportunities available for Arbitrage. There are still many opportunities available, but just keep in mind that this was an older date.
02:47:27.010 - 02:47:38.930, Speaker C: So essentially at this time you could get 35% by just buying PT and this is a fixed rate. So you're guaranteed hacks aside that you're going to get your Apr. So how do we do this?
02:47:39.000 - 02:47:50.326, Speaker E: We just do compute apr. So this is a helper utility method that just according to a price and an expiration date, you can compute how.
02:47:50.348 - 02:47:57.282, Speaker C: Much percentage this is going to give you. So for example, if you're getting 1% on one month, it means you're getting 12% per year.
02:47:57.356 - 02:47:59.260, Speaker E: Very simple. This is what it does.
02:48:00.830 - 02:48:04.458, Speaker C: So we are getting a 35% Apr. This is very, very good.
02:48:04.624 - 02:48:06.026, Speaker E: But there's one detail.
02:48:06.128 - 02:48:08.746, Speaker C: The spot price is never equal to.
02:48:08.768 - 02:48:09.722, Speaker E: What you're really getting.
02:48:09.776 - 02:48:17.354, Speaker C: So if you were to buy $1 million worth of PT, you would have a lot of slippage because the liquidity.
02:48:17.402 - 02:48:21.294, Speaker E: At this time was much lower. So what we need to do is.
02:48:21.332 - 02:48:23.186, Speaker C: Go through the other strategy, which is.
02:48:23.208 - 02:48:27.266, Speaker E: Much more capital efficient. By capital efficient, I mean that you.
02:48:27.288 - 02:48:29.506, Speaker C: Can have much bigger volume for the.
02:48:29.528 - 02:48:36.446, Speaker E: Same exact Apr or very similar. So the efficiency that we get is.
02:48:36.488 - 02:48:39.314, Speaker C: Good, but it can be better with lower resources.
02:48:39.362 - 02:48:41.446, Speaker E: So lower liquidity, we can get a.
02:48:41.468 - 02:48:42.920, Speaker C: Same or beta result.
02:48:44.010 - 02:48:45.158, Speaker E: And this is what we're going to.
02:48:45.164 - 02:49:04.110, Speaker C: Do in this new step. We're going to go through not only buying PT with our ETH, but directly staking on Lido finance. So ETH staked ETH and then deposit that on APY. So it's going to go like this. ETH staked ETH and then Tokenize into PT and FYT.
02:49:04.450 - 02:49:06.174, Speaker E: So this is the step we're going to do right now.
02:49:06.212 - 02:49:07.200, Speaker C: Let's do it.
02:49:09.250 - 02:49:14.514, Speaker E: Yarn step four and we can take a look at what it does.
02:49:14.632 - 02:49:17.618, Speaker C: So essentially, we're depositing I made another.
02:49:17.704 - 02:49:20.530, Speaker E: Utility function here very simple, to deposit.
02:49:20.870 - 02:49:22.206, Speaker C: ETH on Lido Finance.
02:49:22.238 - 02:49:25.030, Speaker E: So this is going to convert your ETH into staked ETH.
02:49:26.490 - 02:49:28.246, Speaker C: And then we're going to deposit on.
02:49:28.268 - 02:49:30.200, Speaker E: Our future vault here.
02:49:33.290 - 02:49:34.806, Speaker C: And what you get at the end.
02:49:34.908 - 02:49:44.138, Speaker E: Is if you deposit ten ETH online defines you are getting 9.93 PT and 9.93 FYT. Why is that?
02:49:44.304 - 02:49:48.938, Speaker C: Why don't I get exactly ten PT and ten FYT? The reason for this is that the.
02:49:48.944 - 02:49:51.662, Speaker E: Future already started a few days ago.
02:49:51.796 - 02:50:01.134, Speaker C: So it already generated yield, right? So you need to account for this. But if you were to withdraw everything, you would get your exact ten staked ETH back.
02:50:01.332 - 02:50:05.858, Speaker E: This is because one FYT in this case already has some value.
02:50:05.944 - 02:50:16.294, Speaker C: So if you add the value of your PT and the value of your future yield, it's going to be exactly ten staked ETH. Nice. Now we're ready for the last step.
02:50:16.412 - 02:50:18.726, Speaker E: We have our PT, our FYT, and.
02:50:18.748 - 02:50:26.326, Speaker C: What we want to do is go from FYT to PT, so maximize our fixed rate. There are also other strategies you can do.
02:50:26.348 - 02:50:28.474, Speaker E: For example, you could do the other way around.
02:50:28.512 - 02:50:36.506, Speaker C: You could just swap your PT for FYT, which means that swap your FYT for ETH, which means that you would.
02:50:36.528 - 02:50:38.410, Speaker E: Get your yield in advance.
02:50:38.850 - 02:50:42.218, Speaker C: Remember, FYT is the future yield token.
02:50:42.314 - 02:50:50.240, Speaker E: If you swap it for ETH, it means essentially that you're selling your future yield for yield today, right?
02:50:50.930 - 02:50:52.194, Speaker C: And this is where it gets super.
02:50:52.232 - 02:50:56.446, Speaker E: Interesting because you can do so many strategies with it. So swapping FYT.
02:50:56.478 - 02:50:57.090, Speaker C: Let's do it.
02:50:57.160 - 02:51:01.870, Speaker E: SDK swap in, provide the AMM entity.
02:51:01.950 - 02:51:04.978, Speaker C: And then from FYT to PT provide the amount.
02:51:05.064 - 02:51:05.602, Speaker E: Very simple.
02:51:05.656 - 02:51:09.586, Speaker C: It's going to do the routing automatically from FYT to PT and then ETH.
02:51:09.618 - 02:51:11.366, Speaker E: So you don't need to care about it.
02:51:11.548 - 02:51:15.334, Speaker C: Now let's look at the result yarn step five.
02:51:15.372 - 02:51:20.458, Speaker E: This is the last step and then we can go with some questions. So if we do this, it's going.
02:51:20.464 - 02:51:22.394, Speaker C: To do a lot of computations and.
02:51:22.432 - 02:51:37.214, Speaker E: Simulate everything on the blockchain. And final guaranteed Apr with this strategy is 34%. Again, this was during the time. You can try again with a different block number, for example today's block number to see what you would get and.
02:51:37.252 - 02:51:41.486, Speaker C: It could be interesting to do so and simulate by your own or you.
02:51:41.508 - 02:51:47.746, Speaker E: Can just try with real money. So this is what we get. The difference with this is that this.
02:51:47.768 - 02:51:52.626, Speaker C: Is much more capital efficient. So lower slippage, bigger trades up to.
02:51:52.648 - 02:51:55.158, Speaker E: Ten times depending on the Apr and.
02:51:55.244 - 02:51:58.034, Speaker C: The APY and the pool that you've.
02:51:58.082 - 02:52:01.526, Speaker E: Selected and the composability because you can.
02:52:01.548 - 02:52:04.274, Speaker C: Swap from any of PT FYT ETH.
02:52:04.322 - 02:52:09.794, Speaker E: So it's very interesting to use the AMM in that matter. Right?
02:52:09.852 - 02:52:11.754, Speaker C: So we just basically with a few.
02:52:11.792 - 02:52:14.714, Speaker E: Lines of code, just five very simple step.
02:52:14.912 - 02:52:20.818, Speaker C: If you put it all in one file, it's going to be even simpler but I've kind of split it to make it easier.
02:52:20.934 - 02:52:22.334, Speaker E: But all of this to say that.
02:52:22.372 - 02:52:31.026, Speaker C: In a few lines you can have your fixed rate Apr with a very simple strategy on AP Wine. So if your project, if you're still.
02:52:31.048 - 02:52:41.406, Speaker E: Looking for ideas, we could brainstorm together. But if there is anything from Arbitrage trading bots, leveraging of yield or there's.
02:52:41.438 - 02:52:52.710, Speaker C: Even some people there who are working on lands like social graphs and they have some capital in the project which means that it uses DeFi in some way.
02:52:52.860 - 02:52:55.734, Speaker E: You could use APY to not have.
02:52:55.772 - 02:53:00.540, Speaker C: The capital sit around and do nothing. So you could actually put it to work.
02:53:01.710 - 02:53:11.520, Speaker E: So this is just one of the ideas that you could leverage AP Wine for and creative strategies are going to get rewarded for this hackathon we are.
02:53:12.930 - 02:53:15.600, Speaker C: Sponsoring with a few prizes. Let me show you here.
02:53:16.850 - 02:53:23.474, Speaker E: All right, so we have three prizes for AP wine. First is the wine connoisseur. This is the first prize, five K.
02:53:23.512 - 02:53:30.260, Speaker C: In APW and the two other ones, the runner up prizes are 2.5K in APW each.
02:53:31.510 - 02:53:42.130, Speaker E: So again, if you are still brainstorming, we would be super happy to help. Some of you have probably already seen our stand, our booth at East Bogota.
02:53:42.210 - 02:53:45.654, Speaker C: So please, anytime during the weekend, please.
02:53:45.772 - 02:53:48.006, Speaker E: Feel free to come along, chat with.
02:53:48.028 - 02:53:50.860, Speaker C: Us and we can brainstorm together to make an amazing project.
02:53:52.270 - 02:53:53.834, Speaker E: I feel like there are so many.
02:53:53.872 - 02:53:56.134, Speaker C: Ideas possible with different projects.
02:53:56.182 - 02:53:57.674, Speaker E: So it's up to you to really.
02:53:57.792 - 02:54:05.966, Speaker C: Leverage as many kind of prices as you can to get the best out of it. All right, thank you so much for.
02:54:05.988 - 02:54:07.226, Speaker E: Listening to this workshop.
02:54:07.338 - 02:54:16.098, Speaker C: Really appreciate seeing you here. Also a note that we are hiring front end developers, solidity developers as well. So if you're interested even at the.
02:54:16.104 - 02:54:18.242, Speaker E: End of the hackathon, to talk more.
02:54:18.296 - 02:54:20.114, Speaker C: With us, please reach out.
02:54:20.152 - 02:54:22.014, Speaker E: We'd be super happy to chat.
02:54:22.142 - 02:54:25.670, Speaker C: Thank you so much for listening today and good hacking.
02:54:28.970 - 02:54:30.440, Speaker E: Any questions so far?
02:54:33.000 - 02:54:41.770, Speaker C: We have a few minutes for questions, but again, there's going to be time during the weekend to answer any of your yes, please.
02:54:43.260 - 02:54:49.272, Speaker F: What is the difference between PYT and PT? PT is the one you use to unstake your deal.
02:54:49.406 - 02:54:50.570, Speaker C: Yeah, good point.
02:54:54.300 - 02:54:56.764, Speaker F: You can have your deal on event.
02:54:56.882 - 02:54:57.116, Speaker C: Yeah.
02:54:57.138 - 02:55:08.248, Speaker E: So how AP One works is you start with your adai, for example, like, very simple interest bearing asset. Interest bearing asset means that it generates yield over time. You deposit that on AP one.
02:55:08.434 - 02:55:19.316, Speaker C: And the primitive that we came up with is the future yield tokenization. So it splits this interest bearing token into two tokens. If you deposit $100, your PT is.
02:55:19.338 - 02:55:21.524, Speaker E: Going to be worth exactly $100, not.
02:55:21.562 - 02:55:29.504, Speaker C: More, not less, all the time. And because this generates yield, all the yield over $100 is going to go.
02:55:29.562 - 02:55:34.616, Speaker E: Not in the PT but into the FYT. So from the time zero to the.
02:55:34.638 - 02:55:39.812, Speaker C: Time one month after all the yield is going to go inside of the FYT.
02:55:39.956 - 02:55:41.604, Speaker B: For example, I can use the principal.
02:55:41.652 - 02:55:44.164, Speaker F: Token compound so I can get a loan.
02:55:44.292 - 02:55:50.428, Speaker E: Exactly. No, please. What I meant to say is you can use compound to generate yield and.
02:55:50.434 - 02:55:59.760, Speaker C: Then go on APY and to tokenize that yield. It's very interesting, though, that you mentioned borrowing with Pts collateral. Yeah.
02:55:59.830 - 02:56:06.550, Speaker E: Well, you could definitely try doing this during the hackathon. This is very good first idea. Definitely something know we're looking into, but.
02:56:07.320 - 02:56:10.532, Speaker C: Please feel free to try. Awesome.
02:56:10.586 - 02:56:12.084, Speaker E: Thank you so much for the question.
02:56:12.282 - 02:56:15.190, Speaker C: Any other questions so far?
02:56:17.100 - 02:56:18.330, Speaker D: Yes, please.
02:56:20.060 - 02:56:20.970, Speaker C: You mentioned.
02:56:25.250 - 02:56:26.480, Speaker A: PT two.
02:56:28.430 - 02:56:29.450, Speaker E: Percentage.
02:56:35.080 - 02:56:36.468, Speaker C: Yeah, that's a very good point.
02:56:36.554 - 02:56:38.180, Speaker E: Maybe I can show the interface.
02:56:43.240 - 02:56:45.750, Speaker C: So basically all right, let me.
02:56:48.600 - 02:56:50.088, Speaker E: If you go on APY and you're going.
02:56:50.094 - 02:56:53.992, Speaker C: To see all the features that we support, and what you mean is here.
02:56:54.126 - 02:56:55.384, Speaker E: The LP, APY, right.
02:56:55.422 - 02:56:58.504, Speaker C: So PT, for example, underlying and then Ptfyt, right?
02:56:58.542 - 02:57:11.912, Speaker E: Correct. Oh, this one the TVL, the market Apr. Okay, that's a very good point.
02:57:11.966 - 02:57:15.920, Speaker C: Maybe we can take the few minutes to explain this. So the market Apr is what you're.
02:57:15.940 - 02:57:17.660, Speaker E: Going to get on AP wine.
02:57:18.240 - 02:57:20.264, Speaker C: If you go into either the PT.
02:57:20.312 - 02:57:23.544, Speaker E: Strategy, so buying PT or into the FYT strategy.
02:57:23.592 - 02:57:25.208, Speaker C: So selling your future yield.
02:57:25.304 - 02:57:30.576, Speaker E: So let's look at an example. Staked ave. For example, if you go.
02:57:30.598 - 02:57:32.716, Speaker C: On APY and you get a fixed.
02:57:32.748 - 02:57:37.104, Speaker E: Rate, you're going to get 8.1%. Okay.
02:57:37.302 - 02:57:38.064, Speaker C: This is right.
02:57:38.102 - 02:57:40.944, Speaker E: Now, if you sell your future yield.
02:57:40.992 - 02:58:01.892, Speaker C: And you get it in advance, you're going to get 7.82%. So essentially it's fixed rate on top, PT versus fixed rate plus yield in advance. So it's lower, right, because it's had some discount. And then here the LP APY. This is going to be the APY.
02:58:01.956 - 02:58:05.432, Speaker E: That you can get by providing liquidity.
02:58:05.496 - 02:58:10.140, Speaker C: On either of those pools. So there are two pools on APY for each AMM.
02:58:11.520 - 02:58:13.980, Speaker E: On Uniswap, you have two tokens, right?
02:58:14.130 - 02:58:18.092, Speaker C: On balancer, you have three tokens, and on APY we also have three tokens.
02:58:18.236 - 02:58:27.948, Speaker E: So the PT, the underlying and then the FYT. So, for example, PT Dai or ETH or whatever, and FYT, there's two pools.
02:58:27.964 - 02:58:28.800, Speaker C: You can provide to.
02:58:28.870 - 02:58:30.324, Speaker E: So if you provide to the first.
02:58:30.362 - 02:58:35.652, Speaker C: One, which is PT underlying, this is the most stable and riskless pool because.
02:58:35.786 - 02:58:39.220, Speaker E: You only get exposed to minimal and permanent loss.
02:58:39.720 - 02:58:50.888, Speaker C: This is going to give you 0.6% plus 95% in rewards of APW. If you provide to the Ptfyt pool, which is a little bit more risky, but it's also another strategy because you.
02:58:50.894 - 02:58:52.616, Speaker E: Get exposed to the volatility of the.
02:58:52.638 - 02:58:59.950, Speaker C: Yield, you get 6.1% plus this amount in APW. I hope that answers your question.
02:59:00.480 - 02:59:13.830, Speaker E: Awesome. Yes, that's an arbitrage opportunity right now. It either means that the liquidity.
02:59:15.610 - 02:59:15.974, Speaker D: Is.
02:59:16.012 - 02:59:20.502, Speaker E: Low enough that there might be arbitrage opportunities right now to take because higher.
02:59:20.556 - 02:59:23.386, Speaker C: Volumes can't keep up, or it can.
02:59:23.408 - 02:59:32.170, Speaker E: Mean that we're very close to the period being expired. So because there's only a few days left, there's like this arbitrage opportunity also.
02:59:32.320 - 02:59:34.238, Speaker C: So if you see anything negative, it.
02:59:34.244 - 02:59:37.646, Speaker E: Can also be a hackathon project, you know, a bot that takes advantage of.
02:59:37.668 - 02:59:40.106, Speaker C: Any arbitrage opportunities on AP wine.
02:59:40.218 - 02:59:44.270, Speaker E: So that's a very good point. So essentially.
02:59:46.070 - 02:59:47.426, Speaker C: You would just tokenize and.
02:59:47.448 - 02:59:48.862, Speaker E: Then sell your PT.
02:59:49.006 - 02:59:53.940, Speaker C: It means the PT is above one, so there's arbitrage to be made.
02:59:59.510 - 03:00:04.822, Speaker E: And I can use my PT, right, and get my APH back earlier. Yes.
03:00:04.876 - 03:00:11.470, Speaker C: You need to go on the AP one AMM, though. Yeah, but same concept as Sushi Swap.
03:00:11.490 - 03:00:15.340, Speaker E: Or Uniswap or anything you're comfortable with already using.
03:00:16.670 - 03:00:23.866, Speaker C: Awesome. Thanks for the question. Anyone else? All right, again, I just want to.
03:00:23.888 - 03:00:28.494, Speaker E: Mention thank you guys so much for coming. We have the booth all week, all.
03:00:28.532 - 03:00:32.958, Speaker C: Weekend, and so please feel free. Even if you're still brainstorming ideas or.
03:00:32.964 - 03:00:35.666, Speaker E: If you're building on top of AP wine, want to get some feedback and.
03:00:35.688 - 03:00:37.954, Speaker C: Input, feel free to reach out to.
03:00:37.992 - 03:00:39.762, Speaker E: Us and we would be super happy.
03:00:39.816 - 03:00:44.980, Speaker C: To help you guys. Awesome. Thank you so much. Happy hacking again.
03:04:59.500 - 03:05:37.940, Speaker D: Does it work? Awesome. Yeah, that's perfect. Hi, everyone. I'm Kevin from Boba. Not sure if you have heard about Boba network yet. It's an optimistic wall up that allows you to make off chain calls within one single atomic transaction, and that's called Hybrid Compute, formerly Turing. That's what I'm super grateful today that I'm allowed to present you today to give a little bit of backstory of why we started with Hybrid Compute.
03:05:37.940 - 03:06:38.250, Speaker D: Basically, we have all seen the Grace last year. We have the Play to Earn games, right? Axio Infinity and all those copycats and comparable Play to Earn games which unfortunately weren't that sustainable and we don't have a solution for that unfortunately too. But we at Boba believe that it's time for great games. And great games what have all of them in common? Great UX, they have an amazing gameplay, it's not like you need to wait for some things. It's easy, it makes fun. And you don't play games just to earn money, but because it's fun and to maybe even have some additional benefits like gathering, collecting some NFTs or whatever. And that's what hybrid compute for.
03:06:38.250 - 03:08:57.620, Speaker D: And before I get too deep into the technicalities, I want to give you a little bit of backstory. What's the differentiation between hybrid compute where you can make these off chain calls and regular Oracles? Because that might be the first thing that you think about when I say you can directly call from your smart contract external API point and do some cool stuff with it. Not sure if everyone here ever used chainlink. Uma, the optimistic Oracle that's also here today, all of them have amazing solutions, don't get me wrong, they have their use case, they do incredible work with requesting data in a decentralized secure manner, right? But when looking at GameFi, do we always need that async fully decentralized way of collecting data into our smart contract? I'm a smart contract developer myself, I love decentralization. So why are we talking about centralization now? In the whole blockchain space? We always have that trade off between scalability, security, decentralization, and when we go back one step and think about GameFi, UX is still a great gameplay, still the most important aspect in the whole GameFi space and almost all web3 games incredibly, unfortunately fail at this and we need to change that. So in comparison to all these Oracles that we have now, I said different use case where we need to wait several transactions, minutes, hours or even longer, depending on the sensitivity of the data. There might be the need at some point that you can actually request data on time within the same transaction.
03:08:57.620 - 03:10:15.980, Speaker D: Just think about when you play a game, you earn a nice little skin like a cold jacket or anything like that. And you would like to personalize that in some kind of way, right? You want some personal data that you have on your centralized backend, want to have that within your NFT in an autonomous and trustless manner as much as possible. So what you can do now you can have within your smart contract, you can call your API endpoint in a synchronous way, get the data and directly work with it. And that actually gives you a whole new possibility or opportunities to build some great new applications. As said, different use case than Oracle's and that's what we are going to do today. So basically to give you some understanding how that in channel works, right, boba is, as said, a layer two solution. So what we basically did we modified layer two, Gaff.
03:10:15.980 - 03:11:37.288, Speaker D: And when you basically call that smart contract function that triggers that API call, then we intercept that RPC call and replace the original call data with the result of the API call and save both of them to layer one, which is, in our case, ethereum. And that enables us to do that in the same transaction. So, to give you some understanding let me get that to the other screen to give you some understanding before you get shocked away by code the whole touring landscape, which is, I said, the old name for hybrid compute. You will see that now and then on some places because everyone who has ever won a company knows that replacing a name is, unfortunately a really difficult task in general world. We have three core components. Actually, it's four. We have your own smart contract that triggers the API call.
03:11:37.288 - 03:12:29.290, Speaker D: Makes sense. Then we have your backhand itself that understands or needs to understand some way that needs to understand, what kind of information you're sending from your smart contract to the backend. Because it will be or needs to be API encoded. It just can't be plain text or something like that. And the same way other way around, if you return data from your backend to the smart contract, it also needs to be in an understandable format. And now we are coming to two other smart contracts that we might need to know or think about. And that's on one hand, the so called Turing Helper, or Hybrid compute helper, as you wish, and the Turing credit.
03:12:29.290 - 03:13:15.172, Speaker D: And both of them have a really close interplay. One of them, the Turing helper, is a smart contract that every project needs to deploy themselves. That contract, basically, is nothing else than your personal, let's say, key to your backend, let's put it that way. And the Turing credit contract basically keeps track of your Turing helper, your smart contract. But why am I saying this? As with every oracle, you need to pay for each transaction. For each API call, you need to make a small deposit. In our case, it's a prepay.
03:13:15.172 - 03:14:19.148, Speaker D: So you need to prepay your if you basically deploy a project, you need to prepay the amount of Boba tokens that you want to fund in advance so that your users can actually trigger those smart contract functions. So every time you call your smart contract, there will be 0.1 Boba token, which is around a few cents currently deducted from your prepaid balance. And the Turing credit contract is deployed by us, the Boba team, which keeps track of your balance, basically. And the Turing helper contract is some kind of authorization, right? So that only your users or the contracts that you want, your custom smart contract, can actually call that endpoint. Otherwise, I could just use your endpoint for free. And you would pay for it.
03:14:19.148 - 03:15:03.550, Speaker D: That's why we have two smart contracts here. But enough theory sorry for that. I want to show you a little bit. What you see here is really a quite minimalistic example that I want to implement with you today and what it basically does, it calculates the time delation based on the Special Relativity Theory by Albert Einstein. Sounds complicated. Right now it's just a basic math formula which would be quite hard to calculate in a smart contract, as you can imagine. Right? And that's why I chose that for today.
03:15:03.550 - 03:15:23.680, Speaker D: If you want to do that with me, I have prepared a starter repository that I would ask you to clone. Then we could actually do that. Basically it's on our official organization.
03:15:25.460 - 03:15:25.824, Speaker E: And.
03:15:25.862 - 03:16:40.168, Speaker D: It'S called Hybrid Compute underscore Tutorial. That default branch is already the one that you can use to implement that with me today. And yeah, basically everything is already set up and we will go through every step that it's actually needed to perform your Turing call. To give you first insights on what we are talking about at all, I want to show you how does such an API call actually look like the most let me look here. That's a more beautiful example. You can see it here. Basically it's really just a one liner, right? You can actually call your smart contract by calling a method on the so called Turing Helper that Asset your project needs to deploy it themselves.
03:16:40.168 - 03:17:53.200, Speaker D: But you don't need to change a single line there. It's really just fully prepared, already ready to deploy smart contract that you can use. You just needed to actually keep track of your balance to get back to the repository. To give you Asset a little bit of overview, we have said we have a couple of components here, right? We have our own custom smart contract that we will implement today. We have our so called Touring helper ready to deploy, nothing to change, basically copy paste that actually tracks if your smart contract is allowed to call that endpoint to actually be charged for that. So it's a whitelisting and some other error handling stuff and whatever. But as said, you basically just need to know two core functions that will be useful for you.
03:17:53.200 - 03:18:55.204, Speaker D: On one hand you have the so called Turing random function which gives you a super strong soil random number directly from layer two GAF. And we have the so called Turing TX function where you can call any endpoint with any call data you want. That's where you can actually do your off chain calculations or call further API, APIs such as Twitter or whatsoever. And yeah, basically, that's the Turing helper. That's our custom contract that we will deploy today. And then you will need your own custom backend that understands the data you're sending to and data that you're returning from. In our case, we just used AWS lambda function that's already prepared for us.
03:18:55.204 - 03:19:57.400, Speaker D: I still uploaded it here so that you can actually have a look at it and understand it. But basically everything that it does is decode the API encoded data and encodes the result as well. So nothing super complicated or magic here. But as said, that's already deployed. So if you have cloned that for yourself, what you can do now is, as always, if we deploy on testnet, we will need some kind of testnet tokens, right? Otherwise it's going to be hard to actually deploy anything. We have a nice little faucet for that on our gateway. You can find it if you type on the search bar gatewaywinkerby boba network.
03:19:57.400 - 03:21:25.400, Speaker D: And as you can imagine right now, that's the faucet. Basically this faucet itself actually uses hybrid compute itself. What it does is it asks you to copy your so called boba tag, which is nothing else than the Boba prefix with MD five hash of your public key, and post that on Twitter, just like I did here. If you have that, just need to copy the link and can put it in. Here what this does now, if you click on authenticated faucet, it actually requests from the smart contract the Twitter API and checks if you have posted that and then sends you the Boba and Eve. So that's what you would need to follow the workshop today. So if we go back to our own project now, what I did is to actually give everyone here a little bit of a safe haven.
03:21:25.400 - 03:22:27.428, Speaker D: If you code that today, then I want you to be sure that it actually works right. For that very same reason, I wrote a simple test that actually checks if you did it right. So nothing to be done here. But basically what this test does is it checks the event that I'm emitting in the smart contract, which we need to do right. Right now, it's undefined, undeclared variable. And yeah, then basically it just checks if the value within the event is the one that we are expecting to. And yeah, small hint, not to confuse you too much, but basically, as you might know, solidity smart contracts don't support floating numbers.
03:22:27.428 - 03:23:13.344, Speaker D: And this formula returns actually really small number. That's why I multiply it on the back end, the floating number with 1 trillion. And here I'm just dividing it back to a value that makes sense. So basically what this would do now, it calculates how many minutes basically your time is stretched if you almost move at the speed of light. We're very close to the speed of light here. That's the velocity parameter. And then we have the proper time, which is the original time that we as a person actually feel like it is.
03:23:13.344 - 03:23:40.796, Speaker D: I think everyone here, or most people have seen the movie Interstellar. Not all of it is science fiction. The part of it where gravity and basically the speed of your aircraft stretches to time is true. So let's get hands on. I have prepared some setters on top here which. You don't necessarily need. Right.
03:23:40.796 - 03:24:30.430, Speaker D: As you know, you can provide everything yourself. But basically every time when we want to use hybrid compute, we need our own custom Turing helper. That's the contract that we need to deploy ourselves. That's the one that we had a look at before run with the error codes and with the Turingtx function, with the Turing random function and so on. So that's basically just deployed by us. I'm just assuming that for now. And basically what you need to do is provide that address to the contract so that your custom smart contract knows where to redirect your call data to.
03:24:30.430 - 03:25:05.990, Speaker D: The second would be what's your actual backend? What's your actual backend? API URL. And that can be anything, as you might guess. In our case, it will be AWS lambda instance, which you can use yourself. I already pasted it in the tests. If you look here, it's on top. It's here that's already live. So basically that's our Python file that we see here.
03:25:05.990 - 03:26:16.910, Speaker D: So to actually make that work now we now have or assume that we have our hybrid compute helper. We assume that we know where the information should actually flow to. And now we actually need to do three basic steps, which could be, in theory, a one liner. But I want to make it simple. So the first thing we would need to do is encode our parameters that we want to send to our backend in a way that the Smart contract is able to handle. So basically what we need to do is we need to create a bytes value I'm just calling it right now params. And we basically just encode our two parameters that we get from this function proper time.
03:26:16.910 - 03:27:06.616, Speaker D: Those are the 15 minutes that we saw before and the speed that we are moving at. So that's the first thing. Basically, we encode the data in an understandable format. So the next thing that we need to do is to actually do our synchronous API request. So that works in a quite similar way with the Turingtx method that we saw before. What we get from the API itself is, again, a bytes. It's really it needs to be in a format, again, that the smart contract understands.
03:27:06.616 - 03:27:38.216, Speaker D: So basically we get here our bytes memory. Again, I'm calling it OSB for now. I know that's not best practice. And now our so called hybrid compute helper comes into play. And we see now that we have our Turing TX and Turing random function that we can use the Turing TX function, basically. Let me see if we see that even here. Yeah.
03:27:38.216 - 03:28:16.640, Speaker D: Requests that we send the URL that's our HC endpoint in this case, which is just a regular string and our already encoded parameters, the ones above that's. It basically that simple. Line sensor API request to your backend. No callback, nothing else. Super simple. And the next thing, what should I do with bytes. Now, no usage for that.
03:28:16.640 - 03:29:14.910, Speaker D: I want to have some kind of proper value, right? Want to have a number. I want to have a string, whatever. Now it would be great if you know what your back end returns, right? Otherwise, you get some random value out of it. In our case, I know that it's an integer value. So what I'm doing now is I'm defining that the first value of my Tuple is just a number and I decode the rest B value that we just got into uint. It's always great to develop one to displays. So that should be it.
03:29:14.910 - 03:29:46.840, Speaker D: That result that we get now we just emit the event so that our test can actually read it and check for the accuracy. That would be the whole magic. This Asset I hope I didn't confuse you too much. It's always a little bit difficult to go from zero to 100. But basically, this enables you to do a lot of crazy new things. Things that you couldn't do that easily before. But everything is possible right now.
03:29:46.840 - 03:30:14.300, Speaker D: We have oracles. We can do everything. But we all went through Callback Hell in Web Two and it also can exist in Web Three, right? Asset, chain link. Uma, all oracles are great. They have the use case. This is a different one. So now I'm going to do the most risky part of my presentation.
03:30:14.300 - 03:31:21.280, Speaker D: I'm trying to run the tests. Let me see if everything works. So what these tests now do they basically deploy our Turing helper? Let me show you. They deploy Turing helper here. I said that's just our prepared contract from before. Our own smart contract where we actually provide the Turing Helper address and our backend URL, this case Asset AWS Lambda instance. And what we need to do now is we need to know, or basically the Turing helper needs to know which smart contract is actually allowed to call my Turing helper my endpoint for which smart contract I'm willing to pay for.
03:31:21.280 - 03:32:07.982, Speaker D: Otherwise, I said I could deploy a smart contract and one of you needs to pay for it. Wouldn't be so cool that's this line basically a whitelisting to protect your funds. When we are talking about funds. We also need to basically fund a Turing credit contract which keeps track over your funds by actually knowing your Turing Helper contract address. Because your Turing helper triggers that API call finally. And that's why The Turing credit knows from where the call comes from. That's what we do here.
03:32:07.982 - 03:32:41.698, Speaker D: We basically just add some boba tokens to the touring credit contract. And the rest is just some basic checking if we get the correct address back and so on. So that's basically it. I am super happy that this works. And I hope you learned something. Maybe you got even some kind of crazy ideas for the next few days. I don't know.
03:32:41.698 - 03:32:46.120, Speaker D: I would love to know them. And yeah, if there are any questions, I'm happy to answer.
