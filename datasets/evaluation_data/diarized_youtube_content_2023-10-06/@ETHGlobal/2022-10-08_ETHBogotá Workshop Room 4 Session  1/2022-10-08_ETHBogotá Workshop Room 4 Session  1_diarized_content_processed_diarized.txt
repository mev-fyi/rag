00:05:52.260 - 00:06:44.996, Speaker A: Hello, can you hear me? Well, just a second. Hello, my name is Dorothy Roche, I'm from the Opengsn team. We've done lot of gazless and lately we're working on account abstraction with the EF from the EF. And I'm here to describe account abstraction with a specific stress on how to build a wallet. On this framework, I will go with a brief overview of what account abstraction is, what we abstract, security, the architecture of our implementation of EIP. Four, three, seven, some cool features we think can be built and should be built above it. And then I will go into the SDK we have how to use it, how to use this API.
00:06:44.996 - 00:07:29.056, Speaker A: To create a wallet, we do need knowledge both in solidity and ether's API in JavaScript. I hope everybody here has it. Okay, first of all, before we do account abstraction, as I said, it's doing for security, what is the basic account security? Account security does three things authentication, replay protection and Dos protection. Those gas payments we are paying, they are the mechanism that's used by the system for Dos protection. They're not just fines. And when we say account abstraction, what we basically abstract is all of these. So we have a wallet.
00:07:29.056 - 00:07:58.816, Speaker A: A wallet is a contract. And the contract can abstract the authentication. It can do whatever. It like replace the signature, whether it can use ECDSA, it can use BLS for aggregation or other things. It can do quantum resistance. We as account transaction don't care what signature scheme is used, except of using different scheme it can use to change the signer. You are not bound to this signer address.
00:07:58.816 - 00:08:26.712, Speaker A: The signer is separate from the account itself. You can use multiple signer and access roles, whatever. And you can do recovery. A lot of features you can do with authentication. For representation, you still need to use somehow nonce. You can use normal, sequential nonces like our sample. But if you like, you want to use parallel, that is, transactions that can be sent on chain regardless of the order.
00:08:26.712 - 00:09:01.872, Speaker A: You can do it also. And for payment, yes, you can do the normal payment. The account pays for itself. But we also provide an API to let an external contract to perform the payment opening cool features like onboarding, where some external contract application pays for the deployment, or using token paymaster to pay with token for transactions. Briefly, the components we have for account abstraction. First, foremost is the user operation. This is our transaction.
00:09:01.872 - 00:09:39.040, Speaker A: The replacement for a transaction structure is user operation. We'll see it later. Then there's a wallet, the account, which is built, of course, from a contract. There's a second contract we call the deployer. This is the contract that deploys new contract again through the system and the wallet software, the UX. We see either browser extension or other software that shows the UX, the transaction to the end user and let it sign the transaction. It has to know the contract signature, of course, to sign using the right signature.
00:09:39.040 - 00:10:34.060, Speaker A: The next component system are the paymaster, the contracts that can pay for transaction if they want. That is, they verify transaction and decide whether this transaction is valid for their own payment system. Bundlers are the nodes that support account abstraction and put these user operations on chain and the entry point. This is the one contract we deliver that executes on chain. The transaction perform all the validation, orchestrates all the system. If we look briefly about how we add it to the system, we have an application that uses the wallet software and send the RPC. But you can see here that account abstraction doesn't come to replace in one shot a normal transaction.
00:10:34.060 - 00:11:16.876, Speaker A: Some nodes of the system continue to work with transactions. Some nodes no normal transaction, but also user operation. User operations come from a separate mempool. So when a wallet sends a user operation into some nodes and bundler, it will get into the network. Yes, we would like all the nodes in the system to support user operations and account abstraction. But the system will work fine even if only part of the nodes support it. If you look at the flow on chain, once a node sends a user operation, there's a single method in enterpoint called handle ops to send a transaction.
00:11:16.876 - 00:11:49.764, Speaker A: Transaction goes through four steps. First step, if needed, optional is to create this wallet. If it has an init code, it will deploy this wallet contract if needed. Once it is deployed, the validate user op method is called. This is the main method. We'll see it later that a wallet has that validate the signature, nons and everything and pays if needed. If there is a paymaster, the paymaster is consulted whether it wants to pay for this transaction.
00:11:49.764 - 00:12:29.996, Speaker A: Otherwise the transaction will be rejected and finally the transaction will be executed on chain. And as I said, it's called handle ops. It can be a bundle. That's why we call it a bundler with multiple ops in a single request. But I will not stress on this because this is something that a wallet doesn't care about, something that the system does for its own optimizations. If we look at a transaction, the way we see it is that an application, how we add account abstraction, how applications start to interact with it. So an application is probably stay unmodified.
00:12:29.996 - 00:13:19.624, Speaker A: It uses a wallet, it will continue to use a wallet. The wallet will be modified, of course. Instead of creating a transaction, it will create a user operation and display to the user with the added fields, ask user to sign it and eventually send it to the node through a different RPC call the send user operation. The node bundler will accept it. It verifies it unlike normal node that knows the signature scheme and everything to check it. It makes the view call to this validate user op not directly, but it makes a view call to the entry point to validate this user operation. And it added to the mempool later on a bundler what used to be called in the past.
00:13:19.624 - 00:14:04.736, Speaker A: A miner will collect all these user permissions from the mempool and we'll create a handle ops transaction and put it on chain. Okay, let's see what we have in a user operation. User operation first, it has all the fields that you see from a normal transaction. The call data itself, gas limit, gas values, signature and nons. Except that the definition of nonsense signature are completely open to the wallet implementation. Then there are some extra fields we add. We put the sender.
00:14:04.736 - 00:15:00.640, Speaker A: Since we can't assume this signature is ECDSA, which you can recover the address of the sender from the signature, we have to specify the sender addresses specifically if the wallet is not yet deployed, we have the init code, which is the code that is used to create this wallet. And we have several extra gas fields that we have to add. We have a verification step, so we have a limit on the gas verification step can take. And there is some gas value that has to account for all the things that you can't check on chain, like call data, cost, et cetera. And finally there is the paymaster information. If there is a paymaster, it will be specified on the paymaster. What a wallet has to define the API.
00:15:00.640 - 00:15:40.196, Speaker A: We provide specified function validate user operation in the iwallet interface. This is the only function we mandate by its name, by the wallet it received, the entire user operation and the request ID, which is basically a hash of this user operation. This is what gets signed and it needs to validate the signature. An aggregator not relevant for this talk. For a separate talk about signature aggregation, highly relevant for L, two S, not relevant at the moment. And missing wallet funds. This is the top up value the wallet has to pay.
00:15:40.196 - 00:16:14.716, Speaker A: If no one else pays and there is no balance that it already has. It has to pay this to the entry point for this transaction to succeed. If this valid user op reverts, the transaction will fail. It will not pay anything. If it succeeds, then later on the entry point will call the call data. There are two wallet specific functions. We don't mandate their name, but the wallet has to provide them.
00:16:14.716 - 00:16:48.758, Speaker A: One of them is nons. To return the current nons value when we create transaction, we need to know the current nouns and the other is the method that will be executed from the entry point. So in our sample wallet we call it Exec from entry point, which I think is a good name. It has to have implementations for these two methods. Okay, now I'm going to the client side. I want to create a transaction. I need to have a wallet.
00:16:48.758 - 00:17:50.950, Speaker A: But today we don't have a wallet that support account obstruction. So we created a method where we can use an existing injected wallet like MetaMask and still use the account abstraction with it provider. The current provider you have, we have an API to wrap it with an account abstraction specific provider. When you send a transaction through this provider, it will go through the logic of create a user operation for it and to send it on chain. So if you add this code to your client application, it will go through an account abstraction. One thing that is missing here is that you see we have the wallet address. This wallet address exists even before the wallet itself is deployed on chain.
00:17:50.950 - 00:18:24.290, Speaker A: The wallet is able to pay for itself, for its own creation. So we need to fund it to send some ETH into this address. Or if you use the paymaster, the paymaster can handle this payment. But this address, the signer address of our provider, this is the address of the wallet itself. And then I create ether's contract and call some method. And the method will get called. And the first time the wallet is called, this method will also create the contract.
00:18:24.290 - 00:18:52.970, Speaker A: The difference from a normal wallet. Yes, it will take a little more gas because you need to deploy this contract just before making the call. This is the high level API. Underneath this API we provide, we'd call a base wallet API. This is the API that lets you create user operation. You pass the parameter to it, it will create the user operation. But creating user paration is highly dependent on the contract.
00:18:52.970 - 00:19:56.670, Speaker A: So this base wallet API, which is an abstract class, provides four abstract methods. How to create an init code for this specific wallet, a method to sign the get nons. This is the method that reads from a vehicle from the on chain value of the current nons and a method to create the execution function to make this call. And in our sample contract, we have a contract we call a simple wallet. So we created Simple Wallet API. It uses this base wallet API and implemented for our contract above four methods. So you create a Simple Wallet API and then you can call it to create a transaction sign or unsigned transaction and then send it on chain.
00:19:56.670 - 00:20:26.890, Speaker A: The owner we see here also on the base class is a signer. This is the owner of the wallet, which is the class will get called to sign this user operation. Okay, if you have any question, I can go back. Yes.
00:20:52.080 - 00:20:53.950, Speaker B: I see there I haven't seen.
00:20:58.580 - 00:21:33.328, Speaker A: Okay, when you create a Simple Wallet API, a specific Wallet API, it is for a specific instance, you can pass it here. The address. I didn't specify if it is pre configured. You can pass here also the address of the wallet contract itself. The APIs I call it here is it is not yet created. So I create this object, I specify the owner, the signer and I have get wallet address. I have a method here to get the address of my wallet which will probably the one I will use on the next call.
00:21:33.328 - 00:22:51.554, Speaker A: Yes, the sample here shows only the first creation for an already created wallet. Yes, you will specify the address of the wallet obviously also you can have it is possible to add account abstraction support for an existing wallet. Like we have an example how to take ignosisafe and to add it interface to be called through account abstraction. So obviously if you didn't create it this way you have the address of the wallet. It is not created through the system but once it is created you can use it as your address. Yes, both here and the high level API you can specify the address of the wallet sender it is called sender because sender is the contract that will call the call data. Call data is the encoded call and I will call it on the sender.
00:22:51.554 - 00:23:14.830, Speaker A: So I'd like to call it a wallet. Okay, it's the same the wallet is the sender naming is problematic. Yes, if I want to change the parameters of my smart contract wallet what do you mean change the parameters? For example I see that.
00:23:18.600 - 00:23:19.140, Speaker C: You can.
00:23:19.210 - 00:24:08.550, Speaker A: Specify for example yes, you can have whatever you like. I think the best way to do it is make a transaction that you as the owner of this smart contract make to make some changes. You can have an API that will be used only through entry point but if you want to call it directly, for example you don't want to use for one transaction, you want that the owner can also call directly this contract. Then you will want that to change owner, change entry point. All this function will be callable the same way. So this is the way we suggest to do it. You are so owner allowed to make execute from this smart contract and also make changes on itself.
00:24:08.550 - 00:25:08.090, Speaker A: I think the normal flow for reconfiguring, whatever type of reconfiguration you want to do, whether it's to set a new entry point or even let's say it's a multi SIG and you want to add a signer, then the correct way to do it will be through a user operation where in the call data you can specify. It's actually a self call. The wallet is calling itself so it will still go through the same validation flow. Your validate user op implementation gets called and then after the wallet says yeah, I accept this sign or I accept this operation and then it will be executed on the wallet. So we don't mandate which there's no interface for what other functions the wallet needs to implement. You can have an exit function, you can also have configuration functions but that they can only be called by the wallet itself or by entry point. Depending on the model you use, not by anything else.
00:25:08.090 - 00:26:34.500, Speaker A: Any more questions? How can you use smartphone? For what? Yes, you would have to deploy if you wanted to have the same address. Then you would have to send the first transaction on each of the chains which would deploy the wallet. If you use the provider, then this is transparent to the user, it just gets deployed. But the caveat is that both of the chains need to have the deployer in the same address in order for the created wallet to also have the same address. Yeah, it's all counterfactual. You can assume that you own the address. You can assume that you own the address.
00:26:34.500 - 00:27:42.460, Speaker A: You can even send assets to it without having the contracts and then the contract gets created the first time you transact with it. So it's created lazily or optimistically when you need to start using it, it's actually the way you're supposed to do it because the wallet is supposed to pay unless there is a paymaster involved. So putting the paymaster use case aside, the wallet needs to pay for its own creation. So you need to have some ETH inside the wallet, inside the wallet address before the wallet even exists. You send ETH to the address before after getting the wallet address and then when it gets deployed, the first thing it's going to do is during its validation, it will pay for its own creation and if it doesn't, then the creation gets reverted. Yes. And if you want to use it cross chain as a wallet creator, you have to make sure that the deployer contract is the same on all chains and this way it will create the counterfactual address for this signer will be the same on all networks.
00:27:42.460 - 00:28:52.190, Speaker A: Yes, we don't mandate how to use it, but yes, it has to be deterministic. As you have said, the wallet can't pay for its own creation unless you as a wallet creator can counterfactually know the address and put funds into it. So if you look at the high level API, you see I use normal ETH as a code. I created our provider, the signer in our provider. It's not a real signer, it's the component that sends it. It's a user operation but it has a method get address in normal account it is the account address which is really the sign in our case, it will return the counterfactual address that you can use to send funds to but again, it depends on the deployer that will work. Yes, we provide a sample deployer that is counterfactual that creates the address exactly based on the basically it means that the deployer has to create the address based on the current signer.
00:28:52.190 - 00:30:15.392, Speaker A: The first signer you are using, you have the signer, the component that will sign this create and the next request of this wallet and based on the deployer itself and this address, we create the address of the wallet. If you later change the address, it doesn't matter because then you will already have the address and you will keep the same address. You don't care the counterfactual address is only needed for the initial creation? No, sorry. Go on, create two. Yes. So this is not a hard fork, it's an ERC, meaning that we need some bundler to support it and ideally it would be great if all nodes support it, if all block builders support it, but we can start without it. So we are starting a network of bundlers and we hope it will expand over time because it's going to be profitable for block builders.
00:30:15.392 - 00:31:10.778, Speaker A: So when a block builder includes such a bundle in the transaction, the block builder gets paid for it. So block builders are incentivized to participate in this mem pool and include these operations. It won't happen in one day, but it's okay, it can happen over time. I'm sorry, I couldn't hear you. Right now there's an implementation of Nethermind that is a full fledged node. It runs currently on the girly network we have our own bundler. It's somewhat limited from a wallet's perspective, it's fully functional, it receives user paration RPC and it puts them on chain.
00:31:10.778 - 00:32:11.178, Speaker A: From the bundler's perspective it can be docile, it can be attacked, large part of the ERC are made. How to make this network of bundlers resilient our specific bundler? It's simple, but it's not as resilient as it should. We are working on it with Nethermind and others. Yeah, ideally to have this functionality into a node yeah, ideally it should be part of nodes. Any node that is used for block building has the information in order to also build these bundles. And as So nevermind implemented it in their own client and they also implemented it into mev geth. So there's actually a geth fork that also supports this and we hope to see a lot more of those.
00:32:11.178 - 00:32:37.154, Speaker A: And another way you can currently run a bundle safely is by having it is by connecting it to Flashbots or to Mev Boost. So you know that you cannot be attacked in certain ways because you can use the protection granted by Flashbots to submit the bundle. Do you offer any censorship resistance guarantee.
00:32:37.282 - 00:32:38.870, Speaker C: Other than a wide?
00:32:46.210 - 00:33:39.162, Speaker A: I think we provide the sensory resistance that normal ethereum nodes gets. It's a mempool and nodes take entries from the mempool that are profitable and put them on chain. Anyone? You have actually another layer that if you have a specific application you can easily run your own bundler. You know you will not attack itself because in order to be protected a bundler has to make view call to make sure it will succeed and they make the transaction. So general purpose bundler cannot trust components not to front run itself, but if it is your bundler, you can always trust it. So you have a way to make always your transactions. But for general use, I believe it is as censorship resistance, as nodes, as Ethereum network.
00:33:39.162 - 00:34:36.624, Speaker A: Yeah, but you actually have a fallback. But as a last line of defense, let's say all the bundlers decide to censor you and you're not running a bundler and everything. You can always just put a bundle since the bundle itself is just an Ethereum transaction. So if you have an EOA with gas, you can use it to act as a one time bundler and put your bundle on chain. So it is always as censorship resistant as Ethereum itself. Is it cheap enough for me to do that on the browser? Is it cheap? It has some overhead. Yes, the overhead of the system is 20 or 30K or 20K on top of the normal 21K.
00:34:36.624 - 00:35:14.628, Speaker A: It's not a big deal. You will lose because it's not a bundle. You will send a bundle of one so you can't split it with others. Or if you do have, you can it's less than a single uniswap operation over it. Yes, this is the simplest way to do it. It is possible to manage multiple addresses, but it's going to be very difficult to manage. Yes.
00:35:14.628 - 00:35:59.710, Speaker A: In order to be questioned, you want to have the same address. Okay. First, it's not a problem with account abstraction itself. It's a use case that you want to support it. We do see ways that you can use the same address on multiple chains. All it requires that you put the same deployer on all chains and then you have it. This deployer can be deployed using create two using some counterfactual deployers that are out there or using your account.
00:35:59.710 - 00:36:35.850, Speaker A: Like the deployer of Gnosisafe is deployed by their own private key on all chains, so they will always be able to support new chains. So you can use that method. Once you use it, you have a mechanism to have the same address on all chains. But technically, if you are on chains where you can't have the same address, I can see a use case, for example, for having a registrar, suppose you have a singletone contract where on the chain where you initially create the wallet, you could have a mapping that says you can send it from a certain wallet. Okay.
00:36:36.000 - 00:36:36.410, Speaker D: Yeah.
00:36:36.480 - 00:36:39.020, Speaker A: So you could build solutions around it.
00:36:42.590 - 00:36:44.394, Speaker B: Can you expand just a little bit.
00:36:44.432 - 00:36:46.080, Speaker C: On the latest changes?
00:36:53.000 - 00:37:38.130, Speaker A: Yes. We added support for a signature aggregation, mostly for BLS, and we have a reference implementation of BLS using it. The idea is that you send a bundle of multiple user operation but with empty signature in all of them. As long as they use the same aggregator, you have a single aggregated signature. And there is yet another contract that you have to use, which is called a signature aggregator you interact with if you want to go deeply, we can talk about it later. Right now it is not deployed anywhere. There's a sample that works with it, but we didn't make any further progress with it yet.
00:37:38.130 - 00:38:30.910, Speaker A: Yeah, but it is only valid for L two S because there is a requirement that the cost of Aggregating a single signature is less. And on Ethereum, the cost of pairing Aggregating a single signature of BLS is more expensive than EC recover. So there's no point of using it on any chain with the L one gas limits on L two S where there is a huge gap between call data cost, which is very expensive, and CPU gas cost, which is very low. There it makes sense very much to be used. Yeah, I think we are a bit over time, so we can continue to take questions if you want to keep discussing it. Okay.
00:41:36.870 - 00:42:12.650, Speaker E: Thank you for coming out today. My name is Vanessa and I'm a developer advocate with Wallet Connect. Thank you for today's workshop. It's going to be pretty quick and easy. We're going to go ahead and show off our new Web three modal, version two, and we'll get connected and we'll be using some React hooks. So let's go ahead and get started. So for those who don't know, Wallet Connect is a communications protocol and we connect apps to Wallets.
00:42:12.650 - 00:43:07.290, Speaker E: We have end to end encryption, frictionless, UX easy integration, and multi chain support. We support any wallet, any app, any chain. So to get started, we're going to go ahead and get a project ID. And we can do that by creating an account with Developer cloud. So if you don't already have an account, you should be able to scan this QR code and this will be kind of like you can go ahead and start coding too. So we want to make sure that everyone's running locally at the end of this with a full on integration with the modal. So I'll give you all a couple of moments to get that, if you don't already have it.
00:43:07.290 - 00:43:59.694, Speaker E: And you can also create an account using your Ethereum address, so you don't actually need to create it using an email and password. Okay, so most people use React. So we're going to go ahead and make this example using React. So to get started, we're going to go ahead and create the React app. You can do that by using your terminal and importing or typing in NPX. Create, React app, name your app, whatever you'd like. We were calling it Wallet Connect Demo.
00:43:59.694 - 00:44:13.090, Speaker E: And then the imports that you'll want to use will be web3 act and Web Three modal, Ethereum. Since we will be making the example on the Ethereum chain. And then we'll also import Ethers.
00:44:15.110 - 00:44:15.426, Speaker A: The.
00:44:15.448 - 00:44:57.102, Speaker E: QR code over here is our GitHub to our modal three, version two. So if you want to take a picture of that, you can actually also follow along with the docs along with this presentation. So to get started, we're going to first import Web three modal. So we have an example here in your index JS. We're going to first start with importing web3 modal. From web3 modal react and then we're going to configure project that project ID will be that same ID you just created from the developer cloud. We have different theme options, we have different accent color options as well.
00:44:57.102 - 00:45:59.676, Speaker E: And this is the Ethereum object where you can go ahead and name your app. And to actually use this web3 modal you'll actually import it and use it right below your consuming app so it won't actually wrap like in the past with our old modal. So that is something important to note. For the next step you can go into your app JS file and you can add in that line import Connect button from web3 modal react. And if you just return the connect button modal you should be able to see a view very similar to this. You should see your connect button and when you click on it you'll see this new modal pop up and that's our new modal that we will be using. So we want to be able to actually be able to pull in some information from the user when they authorize using that connect button.
00:45:59.676 - 00:46:37.076, Speaker E: So we're going to do that by using the Use account hook. And a couple of things that we can pull out from that is is connected which is just a boolean which will return true or false and then the address. And so for the following example we're just going to create a ternary option so if the user is connected, then we'll be able to see their address. If they're not connected, we'll be able to render that connect button. And so this is kind of an example of what that should look like. So we get logged in and then you can see your account address. Pretty simple but we kind of want to go a little bit further.
00:46:37.076 - 00:47:16.330, Speaker E: We've got ENS names these days. We've got avatars that we want to show off. So we also have some hooks for that and one of those hooks is called Use ENS name. And so very similar to what we did with Use account, we're going to do the same thing with Use ENS name and so we're going to destructure the object, take pull out data and then pass in the address, which is the user's address. And we just kind of updated the return statement here. So we should be able to see their name, their ENS name as well as their address. So that's kind of what it should look like.
00:47:16.330 - 00:48:12.520, Speaker E: But if you're doing this live you might notice that there's a moment where it takes a while to load the ENS name and you probably don't want to have that because that's not really the best user experience. So we're going to add and make a couple of adjustments here. We're going to create a new file under a new folder called the Data. JS and we're basically going to kind of move everything that we had in our index or in our app, put it into data and then we're going to also now add this new property called Is loading and we're taking that from Use ENS name hook. And so what that will do is if it's loading, then we're not going to render anything. We're going to just render loading so then the user doesn't actually see their address first and then they have to wait at that moment until the loading is complete. And then this is the updated app JS.
00:48:12.520 - 00:48:29.786, Speaker E: So instead of having most of our return statement, now we're just passing in that data component. And so this is kind of what it should look like upon connecting and.
00:48:29.928 - 00:48:30.620, Speaker A: It.
00:48:33.150 - 00:49:12.440, Speaker E: So you have that loading state and then once it's actually complete and lastly, we can't really have the full user experience unless we can also give them the option to sign out. So this is where we use the Use Disconnect hook. So we'll go ahead and import that in the data component and very similar to the other hooks as well, we'll just create a new const and call that disconnect. And then we'll add our button. So right underneath address, we add the new button. We give it the on click handler which is going to be disconnect. And this is what that should look like.
00:49:12.440 - 00:49:55.140, Speaker E: You get your button once the user clicks it'll, take them back to the Is Not connected state which will render that Connect Wallet button. And lastly, if you have any more questions, you can take a look at our GitHub which will also have other react examples if you want to go ahead and play around with those. So that kind of concludes our workshop. I know we went kind of quickly but I really wanted everyone to have a chance to really play around with the code and have this modal working. So are there any questions or are there any places where anyone's stuck?
00:49:59.320 - 00:50:05.610, Speaker B: We've got a project and we're trying to implement structured signed data using Wallet Connect.
00:50:09.100 - 00:50:13.540, Speaker A: You said structured, structured signed data like instead of string.
00:50:13.620 - 00:50:21.020, Speaker B: You know how like Aave does for a permit? I'm not too sure.
00:50:21.090 - 00:50:28.130, Speaker E: We do have our engineering team here, so I'm going to kind of look at them for support here and see is that something that we are able to do at the moment?
00:50:34.170 - 00:50:34.920, Speaker A: Maybe.
00:50:52.760 - 00:50:53.908, Speaker D: Right up here.
00:50:54.074 - 00:50:56.008, Speaker A: What if it takes on board and.
00:50:56.094 - 00:51:20.210, Speaker E: Another blockchain, new blockchain? Well, a couple of things. So we're going to need wallets that also play with those blockchains. So we need to have the Wallet support first and then we can have the DAP integration as well. Are there any other questions?
00:51:37.680 - 00:51:50.830, Speaker A: We also can mix this authentication with other authentications. For example, I wrote about World Coin that is compatible with Wallet Connect.
00:51:51.780 - 00:52:22.840, Speaker E: Is WorldCoin compatible with Wallet Connect with the version one protocol or the version two protocol? The two. That's something that we can look into. I haven't heard that we are or not compatible with WorldCoin, but if you want to follow up with us at our booth after this, sure. We can answer that question for you. Yeah, thank you. All right, well, thank you very much for joining us today and have a great hacker weekend.
01:02:03.100 - 01:02:18.990, Speaker C: Mic testing. Hello. Yeah. Ola Bogota. Como ESTAS? So that's all the Spanish I know. My name is Chai. I'm the head of engineering at Web Three Auth.
01:02:18.990 - 01:03:25.904, Speaker C: So today's session will be about how we simplify blockchain and Web Three access for everyone. And how do you enable these smooth, seamless experiences for your users using Web Three auth? Okay, so for people who don't know about Web Three Auth, what we do is we simplify Web Three for everyone, and it's where passwordless auth meets MPC enabled noncustodial key management for wallets and apps. So that's like a mouthful. But the idea there is we allow you to do key management, but we allow you to do in a noncustodial way, and we enable familiar web to login experiences for Web Three users. So it's like you can use your social logins, like Google login, Facebook login, and so on, and get access to a blockchain wallet, and we do it in a fully noncustodial way. Okay, so let me just go through about what a typical Web Three user experience is like and what are the typical problems associated with that. So if you look at a typical web to login flow, how does it look like? Okay, user enters an app, they log in via SSO, and then they simply use the app.
01:03:25.904 - 01:04:10.092, Speaker C: Okay, so this is what happens with the millions of applications out there in the wild. And this is the typical flow, which everyone is familiar with, like more mainstream audiences, like my dad and everyone. But if you look at Web Three wallet login flow, it's a bit different, right? So it's dramatically a bit more complex. So whereas user needs to enter an app and needs to install like, a mobile app, wallet, or an extension, I need to set up the seed phrase, and we need to educate the users about securing those seed phrases, need to connect the confirmation with wallet and app, and need to talk about the extensions and all. And also after that, the user will start using the app. So this leads to multiple problems, obviously, the first of which is bad. UX.
01:04:10.092 - 01:04:47.528, Speaker C: Okay, so let's say if you're developing a small game, right, you want the users to focus actually on your game rather than installing and setting up Chrome extension. A couple of other problems are, like, there are some unfamiliar flows. So these are all unfamiliar flows for mainstream users, and there is no easy recoverability. So if the user basically forgets the seed phrase or doesn't secure it for whatever reason. So a lot of keys are lost. So nearly 3.6 million bitcoins are lost from misplaced private keys.
01:04:47.528 - 01:05:38.728, Speaker C: And seed phrases are like the single point of failure in this case. And for many applications which are built on Web Three, there is a very high drop off rate. Okay, so nearly 70,000 daily DApps users are lost from the Web Three ecosystem due to the long onboarding time. So typical setup takes around like ten minutes, right? So this is time better. And in the day and age of like TikTok, where people's attention span is very low, getting them to spend ten minutes just to use your blockchain game is like super hard. Okay, so how do some of the enterprises solve this key management problem? Okay, so they use this concept called as multiparty computation. So these are some of the enterprise companies like Fireblocks, BitCo, Anchorage and Paxos who use MPC solutions or some custodial solutions in order to manage the keys.
01:05:38.728 - 01:06:21.768, Speaker C: But what we do at Web Three authors, we are trying to democratize this enterprise grade security for everyone. So we bring these personal multi factor keys for any application and any wallet. So let's say if you want to build a wallet, you can use our authentication service to build the multifactor authentication for your users. So let me just talk about the way Web Three smoothens the user's journey into Web Three. Okay, so what we offer is the familiar white labeled login flow. So users can use the social logins, which they are very familiar with in the Web Two apps. It helps reduce the onboarding time, it improves the conversion rate up to 74%.
01:06:21.768 - 01:07:03.204, Speaker C: And we also provide like the passwordless and other social logins as well. So we have a very good UX team which has done a lot of research on this space. And we have actually seen several applications move from traditional Chrome extension flows to using Web Three auth and they have seen dramatic improvements in terms of user retention. This is especially true in terms of the native apps and other mobile applications as well, like the mobile web browsers, where the extension flows are much more complex to use. Next we can connect to any blockchain with any wallet. So we provide interoperability across the chains, platforms, frameworks, wallets and logins. So we are blockchain agnostic.
01:07:03.204 - 01:07:39.040, Speaker C: We are platform agnostic as well. So whatever platform you're building on, whatever chain you want to target, you can use our SDK to basically get keys for that platform. Next, what we offer is the non custodial MPC enabled enterprise grade security. So it allows applications to legally operate without KYC AML because the key management is non custodial. So you are not subject to the same KYC AML regulations which other companies are subject to. And it future proves the company's liability to safekeep user funds. Because of the non custodial nature, the user is actually responsible for his own funds.
01:07:39.040 - 01:08:08.968, Speaker C: And we have some really amazing UX flows which make sure that the user never loses their account. And usual has actually very good access, the secure access to all his different types of shares. So you can experience this yourself. As you can see now on the screen, the video is playing. So you just log in with your Google and then boom, you're actually in. Okay? That's literally all you have to do. So the rest of the magic is done in the browser.
01:08:08.968 - 01:08:35.824, Speaker C: I'll just go through on how this magic is done later on. But as you can see, there is no difference between a traditional Web Two login flow and the Web Three login flow using Web Three Auth. Okay? So users feel very comfortable, they feel at home, and then that's it. And they're able to connect to their wallet using this. Okay, so some of the top integrations look like Laddercasters, Skyviewer and Chess.com. So all of these companies have integrated us. We'll share this PPT.
01:08:35.824 - 01:09:25.376, Speaker C: Later on you can actually go to the sites of all of these companies and then experience the login flow for yourself. Web Three Auth is actually trusted by the best and over 3000 applications. So we are currently integrated into all of these applications. As you can see, there are several wallets and exchanges, there are several games, social applications, enterprises, marketplaces, NFTs, finance and everything. So Web Three companies in every space basically integrate us and they try to offer the seamless experience to their users. Okay, so at this point, I would like to just pause the presentation and then go through our documentation. Yeah, so we have really good documentation in terms of how to integrate our SDK.
01:09:25.376 - 01:10:01.424, Speaker C: So our team has actually spent months curating this and we have received rave reviews regarding the ease of use for our documentation. So if you guys go through and integrate our application using our documentation, we would love the feedback which you guys can offer. Okay, so we have a booth in the upstairs and our team will always be there, so please feel free to reach out to us. We also have Discord and Telegram channels as well. Feel free to reach out to us and then you can comment about anything. Okay? So if you feel some concept is harder to understand, we'll be glad to improve documentation regarding that. Yes.
01:10:01.424 - 01:10:35.408, Speaker C: So coming back, let me just go through what a quick start on how it looks like. So you can basically start by integrating a basic Web Three model into your application and then you can customize it according to your needs. We also have a really good integration builder like this. So you can choose your language framework and then you can choose the blockchain you're targeting. You can also talk about whether you want to use custom authentication or you want to white label our model. I'll just show a demo of how this looks like as well. But custom authentication basically is one of the key features which Web Three author offers.
01:10:35.408 - 01:11:07.076, Speaker C: So let's say your application already has a login mechanism, okay? So you have an email password, login or whatever in your application. You can bring that and you can bring those users over to Web Three. So which basically means that we create noncustodial wallets for your existing users as well. So that is something which is possible with custom authentication and the typical Web Three Auth react quick start guide, which because many people use react. So yeah, that's the default here. And the blockchain is ethereum. So you can just use NPX create react app and then NPM Start.
01:11:07.076 - 01:11:43.170, Speaker C: So webpack phi basically said we are not going to support the node module, so we need to add this, fix the webpack issues. Then you can install web Three or Ethers and then you install a couple of dependencies of web Three Auth. After that you import our dependencies and then at this point we would like that you guys register for a new client ID on our developer dashboard. So our developer dashboard looks like this. It internally uses the web Three authentic, as you can see. So we believe in our products that much. So the typical login flow looks like this.
01:11:43.170 - 01:12:16.670, Speaker C: I just clicked on Login with Google and then oh, I have biometrics enabled, so I just clicked Biometrics. So that's also something we offer, by the way. And it goes through the typical login flows where the shares are reconstructed from the social login nodes. And also I have one backup share on my device. So all of that is being reconstructed at this point and then any minute now it'll be done. I mean, the network is a bit slow here, so it's taking a bit of time, but normally it's much faster. Yeah, and I just select an account.
01:12:16.670 - 01:12:46.692, Speaker C: I think I'll just get into my admin portal. So whenever you're ready. There you go. Okay, so I'll just turn off my admin portal. So this is how the typical dashboard looks like and you go to the plug and play section and you can just create a new project. So this can be any project. You can select the environment which you want, typically prefer the sign mainnet for building over here because the sign main net is present in the US.
01:12:46.692 - 01:13:19.744, Speaker C: And then it's closer to this geographical region. And yeah, you can also select the chains you're building on top of. And you can also select whether you want this web Three ODS key to be shown in the Taurus wallet. So Taurus is the previous name of the company. We have a couple of wallet services as well. So if you are building an app using Web Three Auth, the key can be shown in the Taurus wallet so that it can be used within different marketplaces, basically like OpenSea or something like that. Okay, now once you create a project, you can actually whitelist the URLs here.
01:13:19.744 - 01:13:50.292, Speaker C: It's a typical OAuth flow, right? You create a project, get a client ID, you whitelist your URLs, basically, and so on and so forth. So we also show you the typical usage of how it looks like on the dashboard itself. And then you can also read the docs and go to the integration guide. So let me just go back to the integration builder. So once you get your client ID, you can create the Web Three instance like this. So here I'm targeting the Ethereum mainnet so that's the chain ID and the RPC target. And you can initialize the modal.
01:13:50.292 - 01:14:15.744, Speaker C: So at this point, it actually shows you the modal. You can log the user in using web3. Connect. And after the user is done, the connect resolves and gives you back a provider. You can also get the user info using Web Three. Get user info. You can interact with any EVM compatible blockchain because I selected Ethereum at the top.
01:14:15.744 - 01:14:39.252, Speaker C: So the way it works is like the Web Three connect returns you a provider. So you can use that to initiate Web Three or Ethers. And you can do all the methods which you are familiar with using Web Three. Right? So you can just get your accounts, web Three, get accounts and so on and so forth. Again, sign transactions, send transactions and everything. Okay, yeah. You can also log the user out when he's done using Avaidwebtl logout.
01:14:39.252 - 01:15:15.716, Speaker C: And that will basically require the user to log again in when they come back to the app. Okay, so how does a typical integration look like? Okay, so I'll just go through that first. So this is a demo app which we built for some. It basically demonstrates all the different types of mechanisms which are possible. Yeah, there you go. I'll just select Mainnet for now and I'll click on Submit and then yeah, that's fine. So I'll just click on connect.
01:15:15.716 - 01:15:43.784, Speaker C: So it shows me the modal. So at this point, when you see the modal, it basically means that Webtow Connect was called and I just click on Login with Google. I go through the same flow which I showed you on the developer dashboard. I select an account. My shares from the Taurus network, the Auth network, are being brought into the front end. It's combined with the device share, which I have on the device, and then that forms my private key. And you get an app scope key for your application from that private key.
01:15:43.784 - 01:16:03.700, Speaker C: And any second now, that will be done. Yeah, there you go. Okay, so your application, this is the demo application. So this gets back the Appscope private key, and you can do everything with it. Okay, so I can get the user info. That's my user info. I can sign some transactions.
01:16:03.700 - 01:16:21.544, Speaker C: Okay, so this is a typical transaction signature, how it looks like I can sign messages. So we support all the EIP 1193, EIP seven to 191193, as well so you can also get accounts, get chain ID, get balance. Do I have balance on this?
01:16:21.582 - 01:16:22.248, Speaker A: No. Okay.
01:16:22.334 - 01:16:52.276, Speaker C: Yeah, and we support all the other ethereum provider stuff as well. Okay, this is how the typical integration looks like. Now, you can also refer to our examples web3 examples, GitHub repo. So we have examples for all kinds of different combinations which you're looking for. So we have some important links here, as you can see. And if you want a react EVM example or NextView angular common JS. So depending on the SDK you choose, we have an example for it.
01:16:52.276 - 01:17:18.700, Speaker C: And if you really want an example for a different platform, please reach out to our team. We'll definitely be adding that example here as well. So you can target different blockchains, different types of authentications, and the mobile SDKs as well, even the gaming SDKs. So we have gaming SDKs for unity and unreal as well. So we have documentations guides and everything for that. So once you have the integration builder, we also have the SDK API reference. So as you can see.
01:17:18.700 - 01:18:03.484, Speaker C: So we have the API reference for all the platforms, as you can see there. And yeah, you can integrate our SDK using the integration builder, the SDK API reference, and we also have some guides. So if you have some custom authentication like Firebase, OD, Zero, or any other type of authentication provider authentication mechanism, we have some really nice guides for that. So, yeah, you can easily use all of that to provide the seamless experience for your users in the apps. Okay, so now, coming back to the presentation, so we have something new, which you're going to announce today. So this is our early access alpha MPC SDK. So in the previous flows, as you can see, we reconstruct the private key on the front end.
01:18:03.484 - 01:18:36.224, Speaker C: Okay? So with the alpha MPC SDK, we never reconstruct the private key. Okay? So it's all done via threshold signatures. So this is basically like Fireblocks, but for consumers. So you can just scan this QR code to access our alpha MPC SDK and I'll just talk more about it. This is a very new SDK which we are launching just today. This is a typical demo of how it looks like. Okay, so as you saw that this is a typical same Web Three login.
01:18:36.224 - 01:19:11.292, Speaker C: I'll just still log in with my Google account. It just takes a SEC. Yeah, so the difference here is that the private key is never reconstructed anymore. I'll show you how that works. And also the way we sign transactions is quite different because the transaction is sent to all of the different MPC nodes, and all of the nodes basically partial sign. And as I said, I also have a share on my device, so I partial sign with that share on the device as well. And once all the partial signatures are combined, it forms your actual signed transaction, which you can then submit to the blockchain.
01:19:11.292 - 01:19:42.824, Speaker C: Okay, so the MPC has two phases like pre computation and signing. So the pre compute phase already happens when you just simply load the page, as you can see, and it's very fast by the way, as you can see, even with this internet. So I can just sign a typical message like hello Bokota. And as you can see, that signing was done. Okay. It's less than a SEC for MPC signing and this I would say is like the best in the industry. Okay? And yeah, you can also verify that the signature is valid by going to scan and then verifying this.
01:19:42.824 - 01:20:23.492, Speaker C: Okay, so this website is live. You guys can play around with it and then if you face any issues, you can feel free to reach out to us. So there is some small comparison I would like to do, comparing the web3 Auth MPC versus the typical competitors. So I'll just use a cluster in South America for whatever reason. And see, GG 20 is the current standard which the rest of the enterprises are using and you will basically see the speed comparison between the two scenarios. Okay, maybe I can open the developer console. Yeah, so this is all the things which are happening.
01:20:23.492 - 01:20:50.384, Speaker C: Okay, so the green is the DKLS which is web3 Auth. It was done, the pre compute was done in 10 seconds. The signing time is like 1 second, whereas the GG 20 is still not done. Okay, so I can basically change North America, run one more, maybe then the GG 20 will be done. Let's see. Okay, so this basically shows that our solution is like miles faster than the competition. And yeah, this is all the console logs which are happening.
01:20:50.384 - 01:21:02.644, Speaker C: Okay. This is all the things which are happening in the background. Yeah. As you can see, the competitors solution takes around 27 seconds for the pre compute and the signing takes 2.7 seconds. So we are like much, much faster. Okay? Yeah.
01:21:02.644 - 01:21:35.260, Speaker C: And this is the documentation for our alpha SDK. So if you guys want to use the MPC, which I was just showcasing here and here the threshold signatures, we have a new SDK for that. So the only difference between the new SDK and the old SDK is the way you initialize it. Okay? So the older ones basically use at the rate web3 web3 Auth. And this uses edrate web3 MPC. Web three auth. And the way you use it is exactly the same as the typical web Three Auth integration, except the open login adapter the way you write it.
01:21:35.260 - 01:22:33.568, Speaker C: So you just use the iframe URL as mpcbeta openloging.com. This is our alpha site where we have the TSS signing and you use the TSS settings like this. And then you can just copy paste all of this logic and it'll just work. Okay, so as you can see, the typical login logout flows the quick starts, all of them are exactly the same and you can use it with any blockchain and the flow is also exactly the same, so there is no difference or extra complexity which you need to do in order to integrate the MPC flows. Okay, so we also have a very nice code for the demo. So I was showing you this demo, right? This is a different demo which basically shows you how to integrate the Mpcsdk. And yeah, this is a simple repo which showcases that integration and I can just show you the run through the code very quickly.
01:22:33.568 - 01:23:16.088, Speaker C: So it's a typical react app as we talked about, you just install at the rate Web Three Mpcbase and at rate Web Three MPC. Web Three out. These are the new SDKs for the MPC as I was talking about. And the rest of it is like the typical react app, you just need to do the config overrides the same with any Web Three application nowadays. And when you go to app TSX, which is where everything is, you can initialize Web Three Auth. You can initialize the open login adapter, pass these TSS settings to enable the MPC for you. And you init the modal, basically initialize the modal in the back end, configures the different adapters which we have, and so on and so forth.
01:23:16.088 - 01:24:01.528, Speaker C: And then when the user wants to log in, the user basically can click a button and then we call Web Three connect. So once the user is connected, we get back a provider and then that's it. You can use that provider to do all the transactions. Okay, so I'll just do NPM install here or no, it's Yarn actually. I'll just do yarn and yeah, I don't think the internet speed is that great, but no worries. So you can do the typical things which I was talking about before getting the user info, logging the user out, getting the chain ID, getting the accounts balance, signing and sending transactions and everything. Okay, so the flow remains exactly the same, it's just you need to use a different package.
01:24:01.528 - 01:24:38.900, Speaker C: Okay, that is all. And our team will be always here so you can reach out to us if you face any issues while integrating the new MPC or the old Web Three typical SDK. Okay, let me just get back to the PPT now. So thinking about what to build. Okay, so you guys might be having different ideas already and you guys might be already forming a team regarding if you have an idea you want to build. That right, but we also have some suggestions for some of the ideas which you can build on top of Web Three Auth. So we offer around 20,000 total in the bounty tracks.
01:24:38.900 - 01:25:24.504, Speaker C: The best overall app gets 7000, the security track has two items, the best in track gets 4000 and the run up gets 1000. And we have other tracks like Identity and Data and then use case and UX as well. So we think UX is a very serious problem to solve in case of blockchain and then we prioritize that by actually giving a very good bounty for the use cases and UX as well. So here are some of the ideas regarding what to build. So the top idea basically is like the building the security policies on the MPC engine. So I was just talking about the MPC engine, right? So where we have the threshold signatures and all. So in that case, a DAP can basically choose to have a policy engine in the sense that let's say all the users of its DAP should not spend more than 0.1
01:25:24.504 - 01:25:51.810, Speaker C: E a day or even user can configure this. Users can configure like I do not want to spend more than 0.1 E a day or any kind of limits. Okay? So you can also have some sort of scam detection or transaction uniqueness or something like that. So all kinds of security policies can be built on top of the MPC engine. So we have some really good code for this in the demo which I was showing you earlier. So we would love to see more security policies built on the top of this MPC engine.
01:25:51.810 - 01:26:50.470, Speaker C: And yeah, the best price usually goes to the best security policy to be honest. And we also have combining the MPC with smart contract or multisig capabilities. So if you're building on top of other multisig or some smart contract wallets, you can use the MPC solution to integrate this as the default key for those smart contract wallets or the multisig cases. So how do you introduce the time based security on MPC? Or what are some of the IAM systems that people would appreciate? Like you can integrate no Safe plus MPC or something of that sort? Next, there are some ideas around encryption and decryption as well. So could we build a messaging layer between the wallets and apps based on the user public private key pairs? And what are some of the UX friendly permission systems for users when talking about their data? So these are some of the ideas which we are thinking about in terms of the encryption decryption side and some of the ideas regarding the Web Two and Web Three identities are like.
01:26:52.280 - 01:26:52.596, Speaker A: How.
01:26:52.618 - 01:27:55.876, Speaker C: Can we help apps identify what users would be into ahead of time? So Web Three Auth has this concept of derived addresses where you can know what the address of a user will be before they actually log into your application. Okay, so in that case as well, you can use Web Three to actually identify the identity and we can also manage the back end systems for Web Two and Web Three for server resources. And can we share the reCAPTCHA or KYC for multiple users using this next because we link Web Two and Web Three identities, right? So it makes real sense to have some. Of that. Next for payments, how can we make crypto payments more friendly? What stack or markets would appreciate crypto payment adoption? And the most important one, the silky smooth UX. So UX that we just can't trust if you are building some application with a very slick UX that basically qualifies for a really good price. And what are some of the gasless abstractions you can do on top of the E Two? So these are some of the ideas which we have and yeah, that brings us to the end of the ideas.
01:27:55.876 - 01:28:30.996, Speaker C: So this is our Mpcsdk, so you can scan this QR code and then you can keep in touch with us on the Twitter at redwebtreeauth. Discord DG web3 auth. This is our Telegram and you can also mail us anytime. So please feel free to reach out to us and we'll be available on all these platforms throughout the hackathon. Our team will also have a couple of mentors at our booth, so please feel free to reach out on either the telegram or by coming over to our booth. So we'll be happy to help you in any sort of way. We can also brainstorm a couple of ideas which you would want to discuss as well.
01:28:30.996 - 01:29:42.296, Speaker C: Okay, so yeah, that's the end of presentation. Okay, does it, does anyone have any questions? Hello. So the question was that if you sign using Web Three Auth into different applications using the same social login, would you get the same wallet address or a different one? So the answer for that is you can configure it. Okay, so let's say if you own both the DApps, if you use the same client ID, you get the same address. If you use a different client ID, you get a different address. So the way it works is even though the social account creates only one private key, if you use it in an app, you get an app scope key derived from that root private key. Okay, so the keys which apps receive are basically app scoped keys.
01:29:42.296 - 01:29:44.764, Speaker C: Yeah, they are scoped to your app.
01:29:44.802 - 01:29:45.390, Speaker A: Yeah.
01:29:53.950 - 01:29:55.100, Speaker C: No other questions?
01:29:55.710 - 01:30:04.240, Speaker A: Will you export studies?
01:30:05.240 - 01:30:39.776, Speaker C: You can always export the private key. So users can export the root private key by visiting App Openlogin.com or the DAP. Appscope private key is also available for the DAP and DApps can create the UI to export it, or users can also download all their Appscope keys on App Openloggin.com as well. Okay, so we have configured the entire UX around this to be very seamless both for the users and the DApps as well. So the DApps can basically automate all of this programmatically in order to help users understand and export their accounts as well.
01:30:39.798 - 01:30:40.370, Speaker D: Yeah.
01:30:46.280 - 01:31:26.290, Speaker C: Not really. So as I said, the private key consists of multiple parts. Okay? The private key consists of multiple parts. So the social login basically share is split into multiple subshares across the auth network. And you also have a second share on your device. You can also have one more share on your backup trace and so on. You require two out of these N shares to actually create your private key, which basically means that it's noncustodial kind of, or self custodial, I would say, for the end user, because let's say even if the Auth network gets hacked for whatever reason, right? The attacker cannot get access to the user's private key unless they have their device or the backup, whatever.
01:31:26.290 - 01:32:03.180, Speaker C: So in that way, it's self custodial login or noncustodial login. The way you see it, that's kind of our USP in terms of comparing to our competitors. Yes. So while the user sets up the MFA, we also offer different types of setups. Okay? So like user can start with two out of two, two out of three, two out of four, and so on. You can add multiple devices, you can add a password, you can add security questions, backup phrase. You can also do N number of things.
01:32:03.180 - 01:32:35.060, Speaker C: So we have generated our own user flows after multiple years of UX research to make sure that users never actually lose their account, even if they lose a device, or even if they forget their password or lost their backup phrase as well. Okay. And we also have this solution called as Web Three self host, which basically means that you can build all of the UX flows, which I'm showcasing. So in that scenario, our team can work with you in order to provide the best UX flow for your application as well. Okay, that's available as a separate feature.
01:32:36.840 - 01:32:37.590, Speaker A: Yes.
01:32:38.300 - 01:33:03.150, Speaker C: Pricing. Yeah. You can go to web3 IO. Pricing. To be honest, we are cheaper than Cognito or Okta. The pricing is basically based on mau monthly active users. So depending on how your application gets, how many monthly active users your application has, the price scales, okay.
01:33:03.150 - 01:33:27.688, Speaker C: It's free up to the first thousand monthly active users. And we have different tiers based on the number of mau you have. The typical would be like, I'm not sharing screen, but for 1000 logins, it's like 70 something, I guess. Yeah. So it's like 0.6 cents per user for a million logins per month. Okay.
01:33:27.688 - 01:33:46.876, Speaker C: It's Maui Mau per month. Yeah. It's like rock bottom. So you can actually check the slider. Oh my God, my mouse is not working. Okay, so that's the slider we have. And if you cross more than 1 million, you can upgrade to Enterprise and then you can have a custom rate for your application.
01:33:46.876 - 01:33:48.990, Speaker C: Yeah. Yes.
01:33:59.520 - 01:34:03.790, Speaker A: Yes. You.
01:34:06.700 - 01:34:30.076, Speaker C: Yes. So one good example I would showcase is basically like Cache IO. Yeah. There you go. So, Cache IO is a typical example of a multi chain application. So they are present on both Tezos chain and Ethereum mainnet. So how it works is you can simply log in with your Google account.
01:34:30.076 - 01:34:34.576, Speaker C: I keep using Google for no reason. You can use other social logins as well.
01:34:34.598 - 01:34:34.784, Speaker A: Okay.
01:34:34.822 - 01:34:56.112, Speaker C: You can also use the passwords, by the way. Yeah. So on and so on and so forth. Basically, the app gets an Appscope private key, and then they derive the tezos key from the same private key. Okay. So that way the keys are compatible with both SCCP and Ed 2519 chains. So you can typically literally use it with any blockchain.
01:34:56.112 - 01:35:00.232, Speaker C: Okay, so all blockchains basically use SCCP or Ed 2519 keys, right?
01:35:00.286 - 01:35:00.890, Speaker A: Yeah.
01:35:01.740 - 01:35:18.476, Speaker C: So, as you can see, I have an account on Terra. I have an account on Ethereum as well. Okay. Using the same login mechanism. Yeah. My time is up almost. So if anyone has any extra questions, we'll be right outside.
01:35:18.476 - 01:35:19.884, Speaker C: Okay, last question, maybe?
01:35:19.922 - 01:35:20.510, Speaker A: Yeah.
01:35:26.700 - 01:35:31.196, Speaker C: Not really. So it depends on the DAP to actually configure it because the DAP gets the Appscope private key.
01:35:31.218 - 01:35:31.452, Speaker A: Right?
01:35:31.506 - 01:35:59.140, Speaker C: Okay. So they can sign transactions on your behalf. So the DAP can show the models depending on their use case. But let's say if you're building some kind of application which does not want the private key, we offer another integration called as Taurus Wallet. So, Taurus Wallet is also our product, and in this case, the DAP never gets the private key. It lives in an iframe. It's basically a web based wallet, and it's the one which is integrated into OpenSea and other marketplaces.
01:35:59.140 - 01:36:12.856, Speaker C: Okay, so that's it, guys. We're out of time. So our team will be right outside. You can reach out to us. And we also have a booth on the third floor. Please feel free to drop by. And then if you have any questions, please ask us.
01:36:12.856 - 01:36:14.030, Speaker C: Thank you very much.
01:39:10.490 - 01:40:05.546, Speaker F: I'm very excited to be here and present it for you today. I work at a company called Blocks, which is the core developer of a very cool project called SSV Network. SSV stands for Secret Shared Validators, and it's a decentralized infrastructure for Ethereum staking. Now, before we start with a quick raise of hands, how many of you here has been engaging in ethereum staking, either through solo staking or any other staking service? Very nice. Hopefully there will be even more after DevCon. So I think in order to better understand what we do, it's important to take a step back and talk a little bit about the current state of ethereum and how it works. So, the transition of ethereum to proof of stake started almost two years ago on December 2020.
01:40:05.546 - 01:40:56.550, Speaker F: And since then, we have about 440,000 validators active on the beacon chain, which amounts to 14 million ether at stake, or $18 billion. This represents about 12% of Ethereum circulating supply. And those validators are earning approximately between four and four and a half Apr. Even more if you factor in mev, which is now available. Now, I personally think this is pretty amazing. Even more compared to the fact that most of our ETA was just collecting dust in our wallet, right? So every new technology has challenges and Ethereum staking is no exception to that. The main challenge, and the most familiar one is slashing.
01:40:56.550 - 01:41:42.230, Speaker F: Slashing is what happens if you part of the validation process. Do something that goes against the protocol. It's a big penalty into your principal stake, which is pretty bad because it can result in negative ROI. Definitely something you want to avoid at all costs. Moving on there's centralization. If you are not new to crypto Twitter, you've probably heard a lot of concerns regarding centralization or a subset of that problem, which is client diversity. Basically, it's the idea there's no single point of failure in the form of one entity, whether it's a client or a service that has enough market share that it can shut down or censor ethereum.
01:41:42.230 - 01:42:21.758, Speaker F: Your keys have to be online 24/7. This really goes against everything we know about keys management, right? We need to keep our keys offline, preferably in cold storage. So it's hard. It's also something we take for granted, right? Because we all have our device in our pocket, we bring it up, we have internet. But as in life, the internet shuts off, the kids plug it off the wall, we go on vacations and sometimes we come to load up a song and it's buffering. Right? There's latency issues. Now, we personally can wait out those 20 seconds for it to load.
01:42:21.758 - 01:43:26.920, Speaker F: But if we were to run a validator and we were to miss a duty because of that, we would miss out on the associated reward with that duty, which is pretty bad. And last but not least, ethereum staking has a very significant cost of development and maintenance. And almost all staking providers out there has to build their own infrastructure, which makes it very, very not reusable. Now, the bottom line of what I'm trying to say is that Ethereum staking is very, very hard and a lot of it has to do with the design itself of the staking. So let's see how it looks like. This is the most basic infrastructure scheme of almost all staking providers out there, ranging from the Coinbases and the Krakens of the world all the way down to startups and solo stakers managing a single validator. This is the most basic way people set up the infrastructure and as I said, the reason is it's pretty much derived from the Ethereum spec itself.
01:43:26.920 - 01:44:07.030, Speaker F: Now, in this middle part here we have a thing called validator client. This is a software containing of different and a bunch of validator keys. Each validator box we see here represents a 32 E validator on Ethereum. And this piece of software is responsible of coordinating those validators into the duties they have to perform periodically, every six minutes or so. Now, for the keen eyes here, you can see that this infrastructure has a very big flow in it. This big thing in the middle is literally a single point of failure. And this causes a lot of challenges and a lot of risks.
01:44:07.030 - 01:45:12.564, Speaker F: Validator clients can only run a unique set of keys. If you try to run multiple validator clients with nonunic set of keys, then you are risking being slashed, almost for sure. So robustness through stuff like redundancy or backup is something that is really hard to develop into the infrastructure of Ethereum. You also have to keep your past signatures of all of the things you signed with your validator key into something called a Slashing database. And if you lose access to that database because you fail to restore it or back it up correctly, then you're also risking being slashed as well. The keys has to be online 24/7, which is hard. We just discussed this and because the infrastructure is not reusable, it's going to cost you a lot of money, a lot of resources, and a lot of knowledge and expertise in order to actually do this.
01:45:12.564 - 01:46:04.752, Speaker F: And this pretty much goes against everything we learned in the past decades. Regarding software development, especially in crypto, one of the amazing things we have in our ecosystem is that we manage to build these components that everyone can use, right? Usually it's the blockchain itself, but it can also be an application. If we take DeFi building blocks, for example, that are stacking up and building on top of each other, this really reduced the cost of development for everyone and accelerated growth and innovation. And because the current infrastructure of Ethereum is not reusable, it really hinders innovation. Because if the cost of innovation is high, then it's very high to innovate. So with that in mind, let's circle back to SSV. SSV is a protocol.
01:46:04.752 - 01:46:51.884, Speaker F: It's a decentralized infrastructure for Ethereum staking and it tries to solve a lot of the issues that we just covered. So how does it do that? Well, first, it doesn't use a single validator node or any specific staking service or provider to run its validators. It uses multiple of them. No single operators hold the full key, so there's no single point of failure. We use Threshold signatures and BFT Consensus protocol to coordinate duties between non trusting parties in a way that builds fault torrents within the protocol. And the best part is that it's a reusable infrastructure. Anyone can use it in a permissionless way.
01:46:51.884 - 01:47:43.728, Speaker F: And this really enables you to focus on the application, focus on your business, and not on the infrastructure beneath, but still in a way that lets you enjoy a solid, first class, decentralized infrastructure. And it looks something like this. And you can see in the middle part there's no single point of failure anymore. There's a bunch of them and they work together to run your validator. And if one of those nodes or clients, in our case it falls shuts down, gets hacked or compromised, nothing happens to your validator because the rest of them will continue to work. And this is really the heart of it. Instead of having a single point of failure that runs everything.
01:47:43.728 - 01:48:32.364, Speaker F: You now have a bunch of them. And this really removes centralization not only by the fact that you have a redundancy of more than one, but also because it's highly customizable and you can cherry pick your validator operators according to their set clients, their jurisdiction, their client provider, et cetera according to your needs. Now we are all devs here, so let's see how it looks pretty much internally. So as I said, each validator has to perform periodically every six minutes or so. A duty. Whether it's an Attestation or a block proposal, it doesn't matter. And then those four or seven or whatever the amount of operators you chose for your validators.
01:48:32.364 - 01:49:05.320, Speaker F: Once a duty comes in, then they together select a leader in a very deterministic way. That leader proposes what they need to do. For example, sign an attestation. And then if they reach consensus regarding what to sign and this is where really the fault tolerance kicks in. This is where the power of SSV kicks in. Then they each produce locally a partial signature. They then reconstruct it to a full signature and execute it to the beacon chain as a full and valid duty.
01:49:05.320 - 01:49:38.752, Speaker F: And this all means that no operator has the full key. Okay? They only have a share of it. So they need each other to work together. But they are pretty independent, right? They don't need to know the other operators. They don't need to trust the other operators only to communicate over a consensus protocol. So with that in mind, the benefits of SSV are pretty significant, right? First of all, you don't have to keep your key online anymore. Put it in cold storage.
01:49:38.752 - 01:50:21.970, Speaker F: Follow the best practices of key management because they don't need the key, the threshold signatures that we use, they grant security. And if a share is compromised, it cannot be compromised in a way that will compromise the full validator. There's no single point of failure anymore. It's decentralized, it's fault tolerant and it's ready to use infrastructure, right? It's reusable. Now you can use the same operators, the same network, the same setups over and over again. And the cost of integrating SSV is practically nothing. It's literally a smart contract call which is pretty amazing.
01:50:21.970 - 01:50:55.896, Speaker F: Now, the best part about everything I just said is that it's not some moonshot idea. This is no science fiction. This it actually works. It's running on testnet. People are using it, people are experimenting with it. It works and you can try it out today. So I want to talk a little bit about where we came from and where are we now? Well, it all started when we received a grant from Ethereum Foundation to build an SSV node.
01:50:55.896 - 01:52:13.540, Speaker F: SSV was later termed as DVT Distributed Validator Technology. Since then, for the last year and a half we've been running testnets during which we got engagement from over 3000 operators. 100 of them and more are verified operators and by that I mean to real and reputable staking services. Some of them the biggest in the industry that are running a test nest node, experimenting with this, with the intention to adopt it when it goes live. We also managed to accumulate over 20,000 validators so we can really test it that it works out in scale and right now we are the final stages of getting it ready to launch hopefully early next year, early 2023. Now I want to kind of showcase to you how it looks like through a very simplistic flow or use case of a solo staker that has a validator that he wants to run on the SSV network instead of running his own infrastructure or instead of choosing a centralized staking service. So we built a very cool and easy web app which you can try, which you basically come with your validator and you can import it to run on the SSV network.
01:52:13.540 - 01:53:09.000, Speaker F: All you have to do is bring your validator key, bring your keystore file, enter your password if you have one so we can extract the key and then you'll be asked to choose the operators for your validator. You will see a big list of operators, a marketplace of operators. Some of them you know and recognize, some of them you don't. But you can evaluate every one of them through some metrics, like how many they are managing currently, what is their performance metrics according to specific time frames, what rate they are charging for their services, because this is a free market. And once you picked your group, all you have to do is review and sign this transaction with your web3 wallet. And once it's broadcasted to the network, your operators will pick it up and start managing your validator for you. And that's pretty much it.
01:53:09.000 - 01:54:12.990, Speaker F: You're welcome to the distributed infrastructure of the SSV network. I really encourage every one of you to go to SSV network, check out this web app it's very simple, very easy to use and it really showcases how to onboard a distributed validator and how to manage it. So I discussed one use case but there's a lot of different use case which you can use to build on it, right, because It's infrastructure and infrastructure was meant to be used somehow. So these are the most typical use cases that we come up with. Obviously there are more because now when we open up infrastructure as a reusable way, a lot of innovation can happen so the most obvious one are staking pools, staking pools that will use SSV as their back end. And starting this presentation I said there's currently 14 million ITER at stake. This number is projected to go to 40 million in the upcoming years.
01:54:12.990 - 01:55:31.190, Speaker F: And that new ITER that will come in will not only go to Lido, will not only go to Rocket Pool, but in our eyes, there will be a long tail of new staking pools that will compete for this market share. Because at this amount, it's becoming a huge market. And for those staking pools, for those new staking pools, now that they have the infrastructure available as a service, the next rocket pool will not take three or four years to build, it will take three months. And we know this because we currently have teams doing exactly that in those timeframes. Moving on, there's a lot of Dow treasuries on ethereum, a lot of DeFi protocols, even bridges that has a lot of ether. They're also accustomed to holding ether, they're accustomed to the price fluctuations of ETL and we see that that ital will eventually find its way to staking because it's becoming the de facto reference interest rate for ethereum. And also staking services and institutional staking will want to use SSV as their backend to have higher performance, more security, to decentralize their operation and mitigate the risk they have now because they're running it in a central way.
01:55:31.190 - 01:56:33.880, Speaker F: And I want to use this opportunity to really call out all devs to check out our new and big grants program where we give out grants to build exactly those use cases and help the teams bootstrap their operations. So if you fall along one of these categories, come and reach out, make an application and also use this opportunity to extend this offer to the teams who choose to build on us today on this weekend. If you choose to continue working on your project and make it from this weekend to a production grade venture, feel free to reach out and apply for even a bigger grant. We would love to support you and partner with you in the future. Go to Grants SSV network, check it out. So, with that, I would like to pass the torch to Lyor, our CTO, who will present to you how to onboard a Distributed Validator through our Smart contract.
01:56:37.660 - 01:56:57.760, Speaker A: Thanks Ariel. So, I hope you're getting excited after hearing what Ariel described. So I want to do a quick guide because I don't have a lot of time on how to run a Distributed Validator and how easy it is for developers.
01:56:58.500 - 01:56:59.250, Speaker C: We.
01:57:01.140 - 01:57:33.020, Speaker A: Offering grants for this hackathon to run SSV staking pool or Staking service based on SSV. So to run a Distributed Validator there is a simple prerequirement is to have a validator. If you don't have you can use ethereum launchpad to generate one and deposit. You'll need to go early and you'll need a testnet SSV. You can get both of them for us. You'll need a little bit go early to just to make the transaction to our contract. You can get SSV as well from our Faucet.
01:57:33.020 - 01:58:24.460, Speaker A: Okay? The process is you select a few operators. Right now we support four, in the future we'll support more. You can use sorry, then you need to distribute your validator key to shares and then register the validator to the network. And that's basically it to have your validator run on the SSV network. Okay, so the operator selection, you can use our Explorer, where you can browse all the operators and their performance, as Ariel mentioned, and choose which one do you want to use for your validator. Once you chose them, you need to just pick just to copy their ID and public key, as mentioned here on the image. And we will need it for generating the key shares.
01:58:24.460 - 01:58:52.260, Speaker A: Okay, so, key distribution, we created SSV key distributor SDK and wrapped it with a CLI. So you can either integrate it in some code that you're running or just use the CLI for your convenience. The output of this thing is the key shares. It has a public key and encrypted shares corresponding to the operators you chose. You will need that for registering that to the network.
01:58:53.400 - 01:58:54.164, Speaker B: All right.
01:58:54.282 - 01:59:43.184, Speaker A: And then the main function register validator on our contract, it expects the public key, the validator public key, which you have the operator SDS that you chose from the Explorer, the share public keys and encrypted keys. That's the output from the CLI or SDK, whatever you choose to use, and the amount of the SSV that you want to fund your validator right. To pay the operators that you chose. By the way, the CLI also outputs this whole payload for the transaction. So you can use that for your convenience instead of building it by yourself. And it's not just providing the public keys and encrypted keys for the validator. We really encourage you to go to our documentation.
01:59:43.184 - 02:00:19.890, Speaker A: You have this whole guide and with a lot more resources to see how you run a validator. But as well, we have integration guides for this hackathon, how to build a Staking pool in SSV. It has a lot of information or a Staking service, and you should go there before you start. We really encourage you to go there. It has a lot of information, will make things much more easier to kick start. So just go to Docs SSV network and yeah, that's basically it. So if anybody have questions, feel free to ask.
02:00:24.980 - 02:00:25.536, Speaker C: You.
02:00:25.638 - 02:00:26.690, Speaker A: This one works.
02:00:29.160 - 02:00:30.950, Speaker F: Can you just shout it out?
02:00:31.720 - 02:00:41.160, Speaker A: Is it possible if I run to start running, the operator use my executing?
02:00:47.500 - 02:01:28.186, Speaker F: You basically mean I'm repeating, you want to run your own operators and then choose your your validators to run on that operator, right? Correct. Yeah. So each operator, you can see the clients that he uses. Right. So if you want to have different clients, you can choose operators that operate with different clients. And then you have some diversification. It's up to you.
02:01:28.186 - 02:01:32.860, Speaker F: Totally open. Anyone else?
02:01:33.630 - 02:02:27.550, Speaker A: I'll just add I think it's even encouraged to do that. Right. For client diversity, you can choose one operator runs on AWS, and we show that those operators, when they register verified operators, provide their data. One can run on AWS and run Prism client and one can run on Azure or whatever, Google Cloud and run something else. And not just that, you can run even one operator locally if you want to have more diversity, right? Like, let's say if Google cloud right now shutdowns or have some outage, we're probably going to see a lot of Validators not working right or et cetera. AWS or so that creates not just for you, for your security, but also for the Ethereum network to be more secure via those that are going to run on SSV network are much more resistant and make the network itself to be secure. Yeah.
02:02:27.700 - 02:02:29.054, Speaker C: So I missed the beginning of the.
02:02:29.092 - 02:04:02.416, Speaker A: Talk, but what is the single point of failure with lido and optical that you guys are mentioning? So lido, you want to answer that again? All right, lido have a few operators, right? But they manage the ETH, they have the ethereum and then they distribute it between their operators. So each operator have and running by itself x amount of validators. It means it holds the private keys somewhere, right, in a one custodial or central way. With SSV, the difference is that the validators running on operators, but each operator hold a share of the private key, right? So if, let's say one of the lido operators will be hacked for some reason, this way or another, the attacker will have the private keys right here. If one of the operators is hacked, you'll have just a fraction of the keys and you can't do anything with that? Yes. Do you have any incentive to manage the operators that are sorry, if we have what? Yes. So SSV is a dao that's first of all, and operators, anybody can be an operator, but we have a verification process that runs through the Dow and operators that are showing that they have a good infrastructure, a good reputation can get to be verified.
02:04:02.416 - 02:04:44.240, Speaker A: But hey, even if one operator from those four operators, as we mentioned, would be hacked or would be like something wrong with it, then the Dow will probably vote for it to be unverified. That's a and for you that's not going to do anything because if you're running a validator on that, again, one operator can't do anything for your validator. Actually, the threshold is three F plus one. That's why we said four. But in general, it depends on how many single points of failure you want, how many failures you want to support. So if you want to support one failure, that's four operators, right? Today, when you run a Vitro client as a solo staker, for example, that's zero. So three multiplied by zero, it's one, right? I mean, if you want to have two failures, then it's seven and et cetera.
02:04:44.240 - 02:05:02.230, Speaker A: And then as a validator, you can always change the operators, right? If you not happy with some operator because you think he's malicious or because his performance is not great. Then you can anytime change the operators. All right? Any further questions?
02:05:05.960 - 02:05:11.710, Speaker F: If something comes up, you can reach out to us outside or in booth. And thank you all for coming.
02:10:28.530 - 02:10:51.766, Speaker D: All right, hi, everyone. So today I'm going to be giving you a lovely talk about why you should definitely move your project to optimism. So just because everyone looks a little bit dead and sad right now, I know it's raining outside, but we can be alive. So I just want to figure out how many of you are hacking this weekend. That's a good number of you. How many of you work full time in crypto? Even more of you. Okay.
02:10:51.766 - 02:11:28.686, Speaker D: And then how many of you have struggled to get support on chains that you've deployed on? Wow. All right, lots of top notch support. All right, so there are so many opportunities on optimism to get what you need to make sure that your project does the absolute best. So today we're going to be going over just some of the amazing things we can do for you on optimism and help you get actually deployed. There is a QR code at the end with all the information, so I got you right. So first things first is the vibes. Optimism's.
02:11:28.686 - 02:11:56.700, Speaker D: Vibes are unmatched. Anyone who's been in our discord or like, at any of our events, you know, the vibes are just immaculate. We have retropgf, so we retroactively fund public goods, which is just think about that for a second. So we've funded the Solidity team, the Viper team. Web three. JS Ethers JS We've given away a million dollars so far in retro PDF and we have another round coming out a little bit later this year, maybe next year, depending. Timelines are a bit sticky on these things.
02:11:56.700 - 02:12:29.174, Speaker D: So, yeah, we fund public goods and you should definitely be supporting that. So if you deploy your app on optimism, a portion of the fees that your users pay when using the app actually goes towards funding public goods. So your DAP doesn't even need to be a public good to help the ecosystem generally grow. We also strongly believe in collaboration. I know a lot of chains will make you fight to the death with other projects on the chain for resources and know you want to get an NFT quest like fight with the other chains. We're not like that at all. We will help you, we will support you.
02:12:29.174 - 02:13:04.500, Speaker D: You will not have to fight anyone to get help. And yeah, collaboration beats competition every single time. We also are on our path to decentralizing. We've actually started this. So we've launched our Token House Governance and our two House Governance system, which is actually one of the largest experiments in governments in a hot minute. Yeah, so the Token House is fantastic and a completely open process that anyone can go join. And it is obviously a token based governance system, but we'll get more into that a little bit later.
02:13:04.500 - 02:13:43.646, Speaker D: So as a crypto project, it can be really hard to get your project in front of users, right? So we have some amazing opportunities for your DAP to get discovered. So we run Twitter spaces quite regularly. We have the Op Radio, which is a Twitter space that happens weekly. We have demo days which happen biweekly where you can come and demo your DAP to users. It also helps if you want to go through the governance process to demo it so that the delegates have a space to ask you questions. And the delegates love to ask you questions, so just be warned, they will ask you questions. And that happens once every two weeks.
02:13:43.646 - 02:14:10.934, Speaker D: And it's in our discord and it's open for any project that has deployed to participate in, whereas the Twitter spaces we do do a little bit more digging before we'll join you on Twitter. We also have some incredible discovery things. So we have Quests, which are the most adorable little NFTs you've ever seen in your life. If you haven't checked out our Quest program, definitely go look at it. They are very cute. And you can actually, as a project, apply to join our Quest program. We haven't started accepting new projects yet, but we will start.
02:14:10.934 - 02:14:40.866, Speaker D: So definitely go and apply for that so you can get on that. Waitlist. And they're really, really cute. Like, I cannot emphasize how cute they are. I wish I put a photo up. We also have a token list, obviously, for our gateway and our Bridging that you can go get your token listed on, as well as our website listing for all of the apps in our ecosystem, which is a really nice way to get discovered. So how many of you have a full time QA tester or do QA testing at yeah, yeah, I see you.
02:14:40.866 - 02:15:31.602, Speaker D: So we have the most fantastic ambassador program group who just have such an insane energy. So if you wanted to get your project to have a real QA testing process, you can come and offer some small incentives to our ambassadors and they will do a full bug hunt, like clicking every button of your DAP. And they've done this before for other projects and it's been amazing. So they give you a full list of bugs that they found as well as the steps to reproduce those bugs. So it's like proper QA, as well as just general features that they think you're missing because obviously they interact with lots of DApps, so they'll be like, oh, well, you're a wallet, why don't you have this feature? Which can be really, really helpful, especially if you're in the earlier stages of being a project, to just have someone go through your DAP and click on everything. And it's not just someone, there's like 500 of them. So it's a proper QA test and a little bit of a stress test.
02:15:31.602 - 02:16:19.050, Speaker D: If you haven't actually launched to a lot of people yet. We also have grassroots community content. So if you want some memes made about your project, you want a little bit of hype, you want some articles, maybe some tutorials on how to do it, you can definitely come to our community and have that done. For example, with the quests, which I was talking about earlier, a whole bunch of our community members just started making tutorials about how to use these apps because you kind of needed to know how to use them to do the quest. So you can get like, genuine grassroots content made about your project, which you can't underestimate the power of a little bit of a Twitter barrage of your project. And then of course, we support you. We will support you with developer questions if you're struggling to deploy or you have some unrelated question about what to do with my solidity bug.
02:16:19.050 - 02:16:55.286, Speaker D: We have a very active community of developers as well as general users who will just help you, which is really, really nice. We also have user support, so if your users are struggling to use your app, our community loves to just dig into that shit and help out. We also, of course, have project support. So this is everything from figuring out how to deploy infrastructure connections, like getting connected to other projects that you would work well with. synergetically. I can't believe I just used that word, but yeah, we have project support and you will be supported. We also have incredible infrastructure.
02:16:55.286 - 02:17:22.694, Speaker D: We are the most forked L2 with, I think, three forks right now might be four. And tons of audits from the top auditing companies in the crypto space. So we've done our shit. It's secure. We also have bedrock coming out soon, which is the next version of the optimistic infrastructure, which is amazing. I'm not going to talk too much about that because we actually have a bunch of talks happening at DevCon about it. So if you're not there, they will be online so you can watch them live.
02:17:22.694 - 02:17:58.874, Speaker D: We also have been championing the EIP 4844 process, which is going to push L2 fees down to their theoretical lower limits, which is super exciting because obviously fees are expensive and you don't need them to be as expensive as they are. We also have the prettiest docs you've ever seen. I'm definitely biased because they're my baby, but they are the prettiest docs. Like, go click around, you'll see what I mean? And they're great for developers. They're also great for users. They also have, like, if you want to deploy, if you want to get a proposal through our governance process, all the information you'll need is there. How to write a proposal, where to post your proposal, how to get feedback.
02:17:58.874 - 02:18:20.182, Speaker D: All that kind of stuff is in the docs. It's really, really good. We also have a lot of content for absolute beginners. If you've never written a smart contract before. We also have tutorials for you if you've written lots of smart contracts and need very sophisticated how to integrate with the bridge smart contracts directly, there's also tutorials for you. So we really cover everyone. And just because I really do love them.
02:18:20.182 - 02:18:26.300, Speaker D: These are our docs. Look how beautiful they are, guys. Look at that. Look at that. They cover everything there's. Quick start. How it works.
02:18:26.300 - 02:18:42.442, Speaker D: Dark security. We're very honest and open with our security settings. Like how our security models, governance contributing. It's amazing. It's all there. Go check it out. Then finally, of course well, it's not finally, but of course everyone wants a little Op in their bag.
02:18:42.442 - 02:19:12.790, Speaker D: So you can get Op through two methods. One is through our governance grants, which I've been speaking about, which is a completely open and transparent process. So you can go and apply it's completely like open. And again, you can go on our Docs for the process of how to apply templates, all that kind of stuff. It's good for small to medium sized grants. You can get a larger grant, but none of you really going to have to justify it very good if you've got like milestone based grants and you want to iterate on your grant. Again, in the Docs is the whole process that you can go check out.
02:19:12.790 - 02:19:40.542, Speaker D: We also have a partnership grant where you can get Op, but that's a private process so you can apply, but it's not going to be like publicly listed. You're not going to be able to look at previous proposals for inspiration or anything like that. Yeah, and this is how you submit. Again, the Docs guys, I really do love them. So this is how you submit a proposal. Like all the steps are there, the templates, the links, everything you need to actually do the thing. So actually last but not least is getting connected.
02:19:40.542 - 02:20:47.238, Speaker D: So as I said earlier, we really believe that collaboration beats competition every single time. And as such, if you want to get connected to a centralized exchange or an infrastructure provider or a wallet or an onramp or an audit firm very much, if we have a connection with them and they want to talk to you, we will definitely try and facilitate that relationship because we think it's really important. Crypto and blockchain is built on collaboration and that's where the real innovation happens, when you're actually able to innovate with people without weird competition vibes going on. So we really, really try and encourage that and we've done a lot to make it easy for you. And then of course, what is a talk without a little bit of alpha? So we have actually a very exclusive partnership server that will be coming out in the coming months, TMC supply that you definitely want to get on the waitlist to get into, where we will make connecting between projects even easier and much more like automatic and facilitated. So you should definitely go check that out because that is going to be amazing. I have also left a lot of time for questions because I know I covered a lot very quickly.
02:20:47.238 - 02:21:11.038, Speaker D: This is the QR code you're going to want to scan to get all this information. So definitely hit that up. But yeah. So what's up, guys? Who's building? Who wants help? Love you. Thank you. No one wants to apply for free money. Wow, impressive.
02:21:11.038 - 02:21:13.220, Speaker D: You all must be doing really well in this bear market.
02:21:16.630 - 02:21:29.520, Speaker A: Well, the last economy, we didn't.
02:21:35.160 - 02:22:07.552, Speaker D: Yeah, you totally can apply for a grant. So you don't need to have like you can apply for a grant, a governance grant, before your project's even finished. So you can apply for a grant. You can use the grant for developer costs, obviously, because you guys need to eat. And also for things like user grants. And if you want to do an AirDrop to your users or like a retroactive reward to your users for having used your application, you can totally do that. You just obviously need to lay it out in your grant application about what you're going to use it for and make it very clear so that delegates understand what you're doing.
02:22:07.552 - 02:22:42.398, Speaker D: But you can totally do that 100%. Also shout out, thanks for building such cool tools. Yeah, that is a great question. So the question was, how do we determine who gets the retroactive public goods funding? Right? So the way this works right now is anyone in the community can nominate a project, right? So you could nominate a for profit project that's not necessarily a public good, or they would nominate themselves. That's normally what happens. And then everyone else is nominating public goods. Then what we do is we select a subgroup of the community.
02:22:42.398 - 02:23:18.730, Speaker D: So it's a smaller group, normally less than like, 50 people. Last round, I think we used like, 30 people, and then what they do is they sit and they go through all of those applications. We use a quadratic formula for voting, so they will quadratically vote on those projects and then list it out, obviously from the highest to the lowest. And then we distribute the funds proportionally to how many points you got in the voting from the subcommunity. So in the next round, we'll probably do something quite similar where it's actually like, the community that is voting on the project. And we do that because obviously we're not necessarily impartial to what isn't isn't a public good. So we want to leave it in the hands of the community and make sure it's, like, very values aligned people.
02:23:18.730 - 02:23:25.080, Speaker D: Yeah, just community members. They don't have to be token holders at all.
02:23:25.150 - 02:23:25.770, Speaker G: Yeah.
02:23:44.930 - 02:23:54.720, Speaker D: We do. Yeah. No shout out. Vitalik. He wrote a great article about our first retro PGF round. We also wrote an article, but obviously it wasn't as popular as his. So you'll find his first.
02:23:54.720 - 02:25:06.778, Speaker D: Yeah. Thank you. Yeah, no, optimism really is like it's a very wholesome community, especially for first time founders or first time projects. There's a lot of support, especially for the earlier stage stuff. And the community is very supportive. If they find a bug, they'll tell you about it, they're not going to scream at you, which is really nice. And then also because it's an L two, the fees are quite cheap compared to deploying on Ethereum.
02:25:06.778 - 02:25:27.320, Speaker D: So it's much cheaper then for your users to claim the NFT, use it, that kind of stuff. Yeah. We also have a decent amount of Dow tooling. So if you did want to launch like a Dao with your NFTs, it's quite easy to do that. Yeah. I got you, girl. Anyone else? I don't bite, I promise.
02:25:27.320 - 02:25:48.828, Speaker D: At least I won't bite you. Yeah. Make sure you've scanned the QR code if you want to get all this information later. Otherwise go check out our docs. Literally all of the information I've talked about is on our docs. Yeah. Deploy on optimism.
02:25:48.828 - 02:26:51.962, Speaker D: It's good vibes. And your project is then funding public goods, which is like, what a better flex, right? Yeah, you don't have to jump. You did the jumping earlier. You're done with the jumping now. You got socks though, so you won really yeah, yeah. Okay, hold on, let me just go back a few slides. Okay, so if you see at the top there, we have a security page on our docs.
02:26:51.962 - 02:27:46.430, Speaker D: We're actually very open and honest about our security setup. So right now we have a multi SIG that can fast upgrade the entire network. So it's like completely centralized, really, but yeah. So the kind of the timeline of things that are coming is first we're rolling out bedrock, which is the next major upgrade to the optimism network, which is going to reduce fees a little bit and really just make the infrastructure much more robust and hardened and much more like. We're not going to need to upgrade it for a while because it's going to be very stable. So once that's out, it's in alpha right now, once that's out and on Mainet and actually running and we've got good data that it's very stable, then the next step is going to be rolling out Canon, which is our fraud proof mechanism sorry, fault proof mechanism. And we're obviously going to start that on a very whitelist no slashing mechanism as we're testing it and figuring it out.
02:27:46.430 - 02:29:04.650, Speaker D: Once we're sure that the fold proof itself is secure and it's not like accidentally saying things are wrong or right when they're not, then we will roll it out publicly. So then anyone can say, I think there's fraud, let me prove it. But that will first roll that out with no slashing so they can call it without any repercussions for the sequencer. Then once that's stable and we know that's working right, then we'll introduce slashing and then we'll start decentralizing the sequencer. So maybe doing, like, we haven't 100% chosen how we're going to decentralize the sequencer necessarily, but I think the way we're thinking about this right now is that we're going to do some kind of sequencer auction where the rights to be the sequencer can be auctioned off. And then obviously, in order to do that, we have to have 100% functional fault proofs with slashing enabled. So in order for it to be, like, decentralized yeah, you kind of do need the sequencer to be decentralized, because, for example, if the entire optimism team died tomorrow, the sequencer would go offline and that would not be great.
02:29:04.650 - 02:29:42.496, Speaker D: I mean, it would run for a while, but yeah, so definitely that's a part of being fully decentralized. We definitely need the sequencer to be decentralized, but there's this concept that we've been toying with which is, like, minimum viable decentralization. So the minimum viable decentralization for optimism would just be fault proofs, because once you can prove fault and have a slashing, then you don't really need the sequencer. Being decentralized is like, the final step rather than a necessary step. Yeah. Great question, though. Sorry, I'm Veronica.
02:29:42.496 - 02:29:49.080, Speaker D: Yes. Yes. I'm Veronica. Or V if you see me on Twitter.
02:30:00.290 - 02:30:01.360, Speaker A: We good?
02:30:03.970 - 02:30:16.694, Speaker D: Yeah. Let's build it. Let's go. All right, well, I wish luck to all the hackers. Obviously, optimism has lots of cool prizes if you're hacking on optimism, so definitely check that out. Yeah. Thanks all for coming.
02:30:16.694 - 02:30:18.040, Speaker D: Love to see you.
02:32:30.140 - 02:33:33.376, Speaker G: Hi, everyone. Great. Is it okay if I put it in the holder? No? Okay, no worries. Hi, everyone. Welcome to my workshop. It's called? The future of identity is self sovereign. Build a DAP with polygon ID.
02:33:33.376 - 02:34:11.560, Speaker G: First of all, I want to say a big shout out to the Polygon ID team. A bunch of the ID team is here. Can you guys stand up? We've got people back there, they've built a really, really cool product and I'm excited that you're all going to get to start developing DApps this weekend. I think these are going to be some of the first DApps on Polygon ID ever. So you're really early, which is exciting. But first of all, GM, I'm steph. I'm a developer relations engineer at Polygon, along with my lovely coworker Rahat in the front row.
02:34:11.560 - 02:35:03.970, Speaker G: Another round of applause for Rahat, because why not? Vibes are good today. I'm also Oceans 404 on Twitter. But right here in this slide, I gave you 12345 pieces of my identity. So my name, my job title, my company, and also my Twitter and my profile picture. So you know five things about me from this, but how do we know that those things are true? We don't, really. Right? You can kind of trust me, but when I think about identity, I think about things that I recognize immediately, like SpongeBob, and I know this is SpongeBob, and maybe these police come up to him and ask him, who are you? And he says I'm SpongeBob. And maybe they look at him like, are you really? How do we know that? We've never seen the show.
02:35:03.970 - 02:36:11.060, Speaker G: But if you have done Kernel or read a lot of things on Bitcoin, there's this proverb that says, don't trust verify. So you can see in this image, SpongeBob is wearing a name tag, and you can see that it's written maybe in handwriting. So we think that he is self identified as SpongeBob, but we still don't know for sure if that's his real name or if that's really who he is, or if he's just saying that's true. So if SpongeBob had a driver's license, that would be better proof that he is actually who he says he is. This driver's license is issued by the city of Bikini Bottom. It has his address, it has his sex, his hair color, his eye color, his date of birth. But if the police came up to SpongeBob in Bikini Bottom and said, what's your name? Why should he have to show his full driver's license if they only need to know one part of it? Why do we need to show all of this other data if we only need to prove one piece at a time? So kind of ruminate on that as we get into the rest of the presentation.
02:36:11.060 - 02:36:55.340, Speaker G: This isn't just a problem for SpongeBob, right? We all have digital authentication that we have to do to have access to all kinds of different apps, including big tech apps, social media apps like Facebook. You have to sign up and give your first name, your last name, a lot of personal data. So like your mobile telephone number, your email, you set, your birthday, your sex, just a lot of information. And no one really knows why they need that. They say it's to improve the algorithm and things like that. But what are you really getting back for all of that that you're giving? So, getting into identity solutions, there's three different types of identity solutions today. The first one is centralized identity.
02:36:55.340 - 02:37:41.180, Speaker G: Like I said, if you're logging into Facebook, you use your email or phone number and a password. A centralized identity system is a single purpose identity, so you would need to create a new account every time you use a new app. So you're kind of siloed, right? Because that identity isn't portable. As you go from app to app, you can't use this Facebook login to log into, let's say, TikTok. At least I don't think you can. I really doubt those systems talk or that there's synergy there because of competitiveness, but every app is storing this information for you separately, which could lead to a lot more security risk, right? Like if one of these gets hacked, they have your data, if another one is hacked, they have your data. But it's also a huge headache for managing all of your passwords and accounts across apps.
02:37:41.180 - 02:38:24.604, Speaker G: I know I have a password manager. And even that is a pain because there's always like one password that isn't in there, and then I don't know what my password is because it's a centralized identity system. The next step up is Federated identity. Who has a Federated Identity login for work stuff? I know I do. Everyone at Polygon probably uses I think it's Okta or Okta, I'm not sure, but it's a way to sign into a bunch of different apps that are all within the same federation. So at least then you can use one single account and reuse your login across all of those different apps. That makes this type of identity a little bit more portable, but unfortunately, it doesn't work for every single app out there.
02:38:24.604 - 02:39:12.280, Speaker G: And another drawback is, if you log in with, let's say, Google, one big tech company has access to all of your data across all the different apps you're logging into. So it knows what you're looking at, it knows what you're accessing. And I remember I used to use Facebook Login a lot, and one time I decided to delete my Facebook, and then I realized I was locked out of Spotify, which I didn't even realize was connected. So I immediately got my Facebook back, but I was just like, oh, no. So enter decentralized, self sovereign identity. This is a multipurpose and portable type of identity where you can prove pieces of your identity to use on any app. This is really powerful because you as a user retain the control over your personal data and also your digital identity.
02:39:12.280 - 02:40:13.580, Speaker G: And you also eliminate the middleman that's holding on to your identity in all of these different systems. So you don't have to give up your data to prove access rights to the things you need to log into. So these concepts come from this really incredible book that the Polygon ID team recommended to me. It's called self sovereign identity. And the two main takeaways I had from this book were that SSI or Self Sovereign Identity empowers us to receive digitally signed credentials, store them in private wallets, and securely prove our online identities. And we as individuals or even organizations like maybe Dows or Workplaces have that sole ownership over our digital identities, and we can decide how our personal data is shared and stored or if we don't want it stored or shared at all. So going back to my SpongeBob references, a big idea in SSI is this trust triangle.
02:40:13.580 - 02:40:42.252, Speaker G: So we have an issuer, a Holder and a Verifier. So in the SpongeBob situation, the issuer is Mrs. Puff, who has a boating school and gives out a driver's license. The holder is SpongeBob, who is getting that license, and the Verifier is a police officer. And so this kind of explains the issuance of a Verified Credential and also its usage. So the Verified Credential in this case is the driver's license, and Mrs. Puff issues.
02:40:42.252 - 02:41:29.508, Speaker G: It to SpongeBob. And in this new self sovereign identity system. Instead of the police officer having to see the verified credentials, they can just accept a proof. And they can do that because they trust the issuer and they trust that the issuer has given the Holder a proof that is authentic. So the issuer has to be trustworthy and doing the right things to make sure that whatever the verified credentials that they're giving out to a Holder are actually legit. So we already see that happening with governments and also in cases with COVID passports or vaccine passports. So someone is issuing you a verified Credential, maybe it's a nurse giving you a shot and they're saying, I gave Rahat this second COVID vaccine.
02:41:29.508 - 02:42:02.064, Speaker G: And so if there was a way to have a proof instead of having to show that actual COVID vaccine card, that would be awesome. And we're getting into that. Enter polygon ID. So Polygon ID is a scalable blockchain ID with ZK based privacy. We have a really nice architecture diagram on the right, and then the left has different tenants and things about it. So it offers universal identity. You get to prove your access rights rather than giving up your data or identity.
02:42:02.064 - 02:42:41.404, Speaker G: And it also enables advanced on chain verification through ZK snarks. So these are four of the guiding principles, and I think these come from that self sovereign identity book and just other extremely smart people on the team. But polygon ID is decentralized. It's private by default. It uses ZK for trust and reputation, and it's also open and permissionless. So going back to the SpongeBob thing, we're going to switch that to what this looks like in Polygon ID. So instead of Mrs.
02:42:41.404 - 02:43:35.596, Speaker G: Puff or like someone from the government creating claims, you use an issuer to create a claim. And that issuer can give the claim as a verified Credential to a Holder me within my Polygon ID wallet app. And then I can generate a cryptographic proof that is verified on chain with a smart contract to check against my signature to make sure that that is actually my proof. So if we go back to kind of some of the problems that we've seen in social media apps and other different things on the left, I logged into Instagram a few weeks ago and it said, Add your birthday. It said, to continue using Instagram, you have to add your birthday. And I was wondering, why is that? So I looked at the why, and it's because you need to be 13 years old. So they need to know my birthday to make sure that I'm 13 years old.
02:43:35.596 - 02:44:12.344, Speaker G: But I'm going to show you how we can use Polygon ID to prove that I'm over the age of 13 and I can use Instagram without actually having to swipe around and put in my real birthday. So this all starts with Issuer. So I'm going to click into issuer So this is the UI that is. Used to create these claims that you can give out to holders. I'm going to sign up. It's actually more of a sign in. And I have the polygon ID wallet app on my phone.
02:44:12.344 - 02:44:49.924, Speaker G: I'll show you more about that in just a second. But I'm just going to log in with this QR code and I see something that just says, connect my wallet. So I'm connecting my wallet authenticating, and now I'm logged in and I can create a claim. So I'm going to create a claim. And there's some different default schemas that are drop downs. I'm going to do a KYC Age credential because remember, I want to prove that I'm older than 13 so I can use the app. I'm not going to tell you all my real birthday, but I'll say 19 98 24.
02:44:49.924 - 02:45:16.428, Speaker G: So August 24, 1990. That would make me way older than 13. And I'll submit that. So this has created a claim that I can give myself. So since you can't really see it on my phone, I'm going to open up a notion page that shows this. Or actually, I'll start with the slides. So I'm interacting with this issuer within my Polygon ID wallet app.
02:45:16.428 - 02:45:48.680, Speaker G: So these are just some screenshots from the app. Again, you can prove your access rights without revealing your identity. And what I just did in that issuer UI was I created a claim. So now I have to give this claim to myself so that I know that that was my fake birthday. It's not my real birthday, but you get it. So to do that, I'll show you a video of how that looks. Okay, so we just created a claim, which is this screenshot.
02:45:48.680 - 02:46:32.980, Speaker G: Next up, we have to generate the claim. So when you accept the claim by scanning that thing, the QR code, it goes through this flow where it adds the claim to your Polygon ID wallet. So once that claim is added, you can see it in your data. So you can see now I have this KYC Age credential within my Polygon wallet. So when I screen recorded this earlier, I said my birthday was January 1, 1990. But now this exists in my wallet and I can check anything against this. So the demo app that we worked on was a Zke ERC 20 AirDrop.
02:46:32.980 - 02:47:39.020, Speaker G: So what we want to do is AirDrop tokens to anyone who's over the age of I can't remember what the age was, but let's just say it's 13. I think it was a specific birthday. But in order to do that, we need to check against that claim that we just created that said that my birthday was the first in 1990. So what you would do is you would scan that proof request, or you would scan that QR code. It would generate a proof against the information you already had stored. So it's generating the proof, a cryptographic proof would appear, and then you would click Generate Proof. It uses Biometric ID or a password, and it pops open your MetaMask and allows you to claim that ERC 20 token claim based on the fact that you were over the right age.
02:47:39.020 - 02:48:24.100, Speaker G: So it's generating the proof. And then if this is successful, we'll see that the AirDrop gets added to my wallet. So you can see that in the screenshot, it confirmed that contract interaction. And now I have five ERC ZKP, which is just the token drop that we created inside of that wallet. So that's kind of a high level overview of how this works. But I'm also going to show you some of the code for the Verifier. And all of this is in different links that you'll be able to check out so you can look at how the smart contract works and also how the front end works.
02:48:24.100 - 02:49:22.530, Speaker G: Okay, so this is the tutorial example. Implement a ZK ERC, 20 AirDrop in 20 minutes. So it really does only take 20 minutes if you follow these instructions and just deploy your own Smart contract and update like three different variables. But what you would do is download that polygon ID wallet setup either from the Apple Store or the Google Play Store, and then you would get it right into the code. So if you were just cloning this repo, all you would have to do is install the dependencies and then compile the code that already exists there and then run the deploy script. This would result in one Smart contract. And what you would have to do after that, where all of the magic with the proofs and everything happens, is that you have to run something called Scripts Set request.
02:49:22.530 - 02:50:04.414, Speaker G: And this is where we're actually submitting all of the things that make the proof work. So let me get into that. So within this set request, we have a validator address. This is the already deployed Smart contract that is doing the validation. And this is something you can reuse for any of your Polygon ID examples. All of the specific stuff happens below. So there's an age query and the part where we're actually checking against the age is on line 14 with the value.
02:50:04.414 - 02:51:03.950, Speaker G: So we're checking that your date of birth happened before January 1, 2001. And so I already proved that with my claim that I was issued, so this should work for me. The other thing is that we also have an ERC Verifier address. So this is the address of the ERC 20 token that you can deploy using those instructions above. And so the ZK proof request checks against that validator and also the age query to make sure that you're actually over the age that you said you were. So, back in the README, we have two different contracts within contracts. So this is the ERC 20 Verifier that I was just talking about.
02:51:03.950 - 02:51:49.844, Speaker G: And this extends an ERC 20 contract as well as a ZKP Verifier contract that exists in this repo. And there's a couple of interesting things going on. There's a before proof submit and after proof submit hook, as well as a before token transfer hook. So this is where all of the custom logic is happening to make the actual AirDrop happen. So before you submit that ZK proof, it's checking that the challenge input of the proof is equal to the sender. So you need to make sure that the user who's saying, I'm over the age of 13 is actually the person who is submitting the transaction. And then after the proof submit, there's one more require statement.
02:51:49.844 - 02:52:29.712, Speaker G: And this is just making sure that you don't claim the AirDrop multiple times. So that's just a little extra logic. And then this is where the AirDrop is executed. So this is kind of just like classic Airdropping, a token stuff. But before these tokens are actually transferred, there's one more check. And it's just making sure that you, as the person who provided the proof, are allowed to receive the tokens. And so once you have all of these smart contracts deployed, all of these, meaning just two, the last thing that you need to do is design a proof request.
02:52:29.712 - 02:52:56.662, Speaker G: So there's a query based request, language or not language, but structure, so you can read about that. More on the polygon ID documentation and in the GitHub. But I'll show you the one that I created. So mine is in QR proof. So this is just a big JSON blob. And I'm going to pass this to the QR code. It's going to live in the QR code.
02:52:56.662 - 02:53:26.626, Speaker G: So when someone scans the link, it understands that this is the contract and this is what we're querying. So on line 21 and 22, you can see what we're querying. We're querying the birthday. And on line 22 we have Lt, which is less than and then 2001 one. So we're checking that the birthday that the proof is submitting is less than January 1. I can't say. January january 1, 2001.
02:53:26.626 - 02:54:15.988, Speaker G: And mine definitely is. So this should be successful. And like I said, this needs to live in a QR code. So on our front end, we have to have some type of QR code that you can scan that has this data so that it kicks off the whole smart contract process. I created a little code sandbox for you all so that when you deploy these on your own, all you have to do in the code sandbox once your contracts are deployed is update this deployed contract address. And then you should be able to test with this front end to look at the QR code and see if you can actually claim the ZK AirDrop. But that big Blob of JSON that we saw before lives in the QR code request.
02:54:15.988 - 02:55:19.480, Speaker G: So it's the same exact thing. It has the deployed contract address and that little check down here, birthday less than January 20 or 2001 and that just lives in a little QR code component. So it's just passing the value of that to here. So when we scan this code from the Polygon ID app, since I already have a claim, it should kick off an AirDrop to me. So I see something come up that says Proof request in my app. So I've scanned and I'm just going to submit continue for the proof request. It's generating the proof on my phone and then once it's done generating the proof, I'll click one more button and then it'll kick off the transfer of that AirDrop to my account.
02:55:19.480 - 02:55:55.320, Speaker G: And you can see where that happened before. If you look at this PolyScan link, I think I'm the only person who's claimed on this contract. Yeah, but five of that Zke ERC 20 token were Airdropped to me about 6 hours ago. So I should get another AirDrop pretty soon. But yeah, that's how you would do this with an AirDrop. That was the code. Okay.
02:55:55.320 - 02:56:30.158, Speaker G: Did I lose everybody? I know that's a lot. You can look at the code on my GitHub. I'll give you the links towards the end. But I just wanted to talk about some of the prizes that Polygon is doing for the hackathon. So we have $20,000 in prizes and 4000 of that is for the best use of Polygon ID. So you could create an app like the one I just showed you or something totally different to help people prove parts of their identity without actually giving up their data. We have three other prizes.
02:56:30.158 - 02:57:10.734, Speaker G: We have 4000 for the best public goods and refi projects. Hopefully they're going to be like local projects that help the LATM ecosystem. We also have $4,000 for the best social DApps on Lens Protocol and 4000 for the best user experience and user onboarding to whatever DAP you built. And last but not least, we have a $4,000 prize pool for everyone who deploys any type of contract on Polygon. We ask that you have two transactions to that smart contract so that we can see you've actually used it. And then these are just some of the benefits of developing on Polygon. I'm sure a lot of, you know, speed, cost, scalability, flexibility, all great.
02:57:10.734 - 02:57:58.430, Speaker G: It's a great developer experience. And we're also asking that if you do submit for our pool prize by deploying something on Polygon that you tweet your smart contract at us and tell us what you're building and why you're excited about it. We love hearing developer stories. It really fuels our entire team to keep going just because we want to see what you're building and we want to amplify that work and maybe give you a grant or put you through our accelerator eventually. Okay, so these are all of the different resources that I covered in this talk. You can take a picture of this or I'll have a screenshot at the very end or a QR code at the very end so that you can get all of these when you're developing during the hackathon. But we'll also be at the booth and we have lots of different members of the Polygon ID core team here that can also help you develop.
02:57:58.430 - 02:58:27.180, Speaker G: They're awesome, super friendly and some of the most talented engineers I've gotten to work with. So I highly recommend stopping by. But thank you so much for listening to all of the things that I just said. All of the slides and the GitHub repo and everything is on this QR code, so feel free to scan it and you'll have all of the links to get started building. Really excited to see what you build this weekend and wag me. We're all going to make it. Thank you.
03:04:05.860 - 03:05:25.976, Speaker B: I am Miguel and this is Flywheel and we are here to talk to you about wallcoin and wallad and basically how to make any app fully civil assistant within a few minutes and without keeping everyone's privacy. So before that, I want to talk a little bit about why we're doing this. And the reason why we believe that this is a really big deal is because I feel like everyone here can agree crypto is really, really awesome, but at the same time, it has a bunch of problems, which is mostly with its value being hoarded a little bit. We all know about being early. And the thing is, especially for things like Ladam that are now joining more and more in crypto and where it's clear that it can solve really big problems, most of the value for things like ethereum or Bitcoin has already been captured by the people that were there at first, and that is not great. And that can hinder a little bit on the innovation that we can all achieve with this. And so at Walt Quinn, we had this question like, what if Bitcoin had started instead of by? However, it got started by just giving one Bitcoin to every human in the world and then seeing how the network effects played out, how having a currency that was fully globally available was still being modern and online and cryptocurrency played out.
03:05:25.976 - 03:06:18.328, Speaker B: And so we wanted to find this out. Obviously, we cannot buy a Bitcoin for every human, I wish. But instead we said, okay, let's make an ERC 20 token and let's do the same experiment with it. Let's make a token that every person gets for free and then we'll see how that affects the supply, let's see how that enables new people to interact with all of these ecosystems that we're building. And the big question there obviously was if we're going to be giving this token that is worth something and we're going to be giving out for free, a lot of people are going to be trying to get it for free multiple times and just like, steal from everyone, really. And so this question we went back and forth. We learned about this thing called civil attacks, which is pretty modern concept nowadays because all of these NFT means and Airdrops are suffering from it.
03:06:18.328 - 03:06:58.644, Speaker B: It basically means that some of your users are not really unique users, they're just like someone running a bunch of accounts. And this is really what we want to avoid. We want to make our protocol and every other protocol out there while we're at it, civil assistance. And so we went back and forth into different solutions that we could use for this. Maybe we could ask for an email or a phone, which is better than nothing, but kind of similar to what Gitcoin is doing but still not enough. KYC can work, but there's some areas of the world that don't have ID documents or don't have a database to check them against. And also from a privacy standpoint, it's really bad because we would have to get everyone's IDs and we really don't want that.
03:06:58.644 - 03:07:55.240, Speaker B: There's other approaches like web of trust where you are saying I trust these people around me and then that propagates that has the issue of you need an initial set of people to trust and then over time, if you know a lot of people, it's easier and easier to fake another human. We looked into biometrics like using your fingerprint and using your DNA, which both work, except for the fingerprint doesn't really have enough information for 8 billion humans. There are going to be some people that have similar enough fingerprints so that we cannot tell them apart. And DNA has the opposite problem. It is really, really unique, but it's super expensive and super slow to measure and also very invasive. And so we wanted a solution that was both private, inclusive, meaning that we could onboard every human in the world, all 8 billion humans, into the system. And that again was scalable and didn't leave anyone behind.
03:07:55.240 - 03:08:37.572, Speaker B: And so we ended up setting with irises which are like the perfect middle point between fingerprints and DNA. They're still unique, they are pretty hard to change and even then you can most of the times detect it and at the same time they are really quick to scan, measure and use. And so this is great using the system. We had a system where we were taking no images. We do take an image of the iris but then we delete it and just extract information from there. No name, no contact info, no KYC, no phone number really. There's no link between this hash of an iris really and anything in the real world.
03:08:37.572 - 03:09:21.432, Speaker B: But for us it felt like it wasn't enough. We wanted something more. We wanted something that would allow us to really not just be private, but be fully anonymous. And so we started looking into serial edge proofs and how aside from saying this is a human that owns a public key that has been certified by an orb as human. We could also say this is just like one of those humans and we have no idea, there's no way to even link them to the hash of their scan. And we ended up with this system which allowed us to prove cryptographically on Chain I am a real person and I have never done something. At the start that something was mostly claimed Wallcoin.
03:09:21.432 - 03:10:21.144, Speaker B: But as more developers came to us and said we want to reuse this technology that you guys have made on our own apps, we started thinking maybe we can expand this so that this can be added to everyone, to governance, NFTs, Airdrops, even Web. Two actions like joining a discord channel, which would help a lot with spam. And so we created this thing called Wallid, which is a protocol that lets you fully anonymously verify that someone is a real human being and that has never done an action before, like claiming Wallcoin. And so it's a privacy first decentralized identity solution. It's not even identity in the sense that it is fully anonymous per app. So if I use my Wallet ID on two different apps, these two different apps will get completely different ideas of who I am, which doesn't makes it so that you cannot even track people along us. It enables anonymous proof of personhood, which can pretty much search for every use case that civil assistance would use.
03:10:21.144 - 03:10:44.176, Speaker B: And it's also an open protocol that runs on the blockchain on publicly verified smart contracts and where you get to keep your own keys. And so, for example, if you were just making an AirTop to integrate this, you just need to add a widget which we'll talk a little bit more about and that's it. You're set it's really that easy. So now Flywheel is going to talk.
03:10:44.198 - 03:10:45.570, Speaker C: A little bit about how it works.
03:10:50.020 - 03:11:58.276, Speaker A: Thank you. I'll switch computers over there. All right, so here's roughly how the World ID protocol works. So you go to an orph physically one of these guys, and the ORV will verify you're a unique person and you get your World ID. So in the background, what actually is happening is your WorldCoin app is going to generate a unique random identity commitment that's going to live in your phone and it's going to show the public part to the ORV. The ORV is going to do the verification that you're a unique person and then add that identity to the public list on chain of verified identities. The cool thing about these zero knowledge proofs is that there's literally no link between your identity and your wallet or your identity.
03:11:58.276 - 03:12:50.810, Speaker A: And anytime that you use it, every time that you use it, the WorldCoin App will generate a zero knowledge proof that you're someone in that set of verified persons, but without revealing who you are. And the protocol is very complex to support for this anonymous proof of personhood. But we've abstracted all of this complexity. So you can integrate quite easily. So the way it will work is you install the widget in your app. The widget will connect to the WorldCoin app, receive that zero knowledge proof, and then you can verify it on our smart contract or on our API. After you verify it, you know for a fact that that person has been verified by an ORV and it's an actual person.
03:12:50.810 - 03:13:39.224, Speaker A: And then I'm going to show you how to integrate it using the API, which is the fastest route to integrate. However, if you want to do something on chain, we definitely recommend doing on the smart contract side. We'll also show that in a little bit. So let's say I have this example of I want to issue POAP, but I want to make sure that the POAP can only be claimed once by a single person. So I have this very simple form where I can click claim POAP and I receive the POAP in my wallet. This, of course, is very easy to farm and spam and steal all the POAP. So we can simply add World ID to prevent that.
03:13:39.224 - 03:14:24.910, Speaker A: And let me get my app here. So to do this, we simply need to add the WorldCoin widget. So you can easily install it by just running Yarn WorldCoin ID. This will install the widget on your project. You can now just simply load the widget. If you're using Next JS, this is an important part. You need to do this dynamic import as I'm doing, because the widget relies on window being set.
03:14:24.910 - 03:14:57.376, Speaker A: So if you don't do this, you'll get an error. And then just remember to do the dynamic import. Thank you. Copilot all right, there we go. So I have the widget imported. We can then mount the widget. You're going to need to provide a couple of things to the widget.
03:14:57.376 - 03:15:34.512, Speaker A: So one is the Action ID. The Action ID basically defines the scope of the uniqueness for your own application. So you can just go to Developer Worldcoin.org and you can create any number of action IDs there. It'll ask you if you want to create something on production or staging, and it'll ask you if you want to run it on chain or just with the API. And then you'll also need something called a signal. So the signal is an additional security measure that you can add, and it depends on what your application is, what makes sense to do.
03:15:34.512 - 03:16:24.350, Speaker A: So, for instance, if you're doing an AirDrop and you don't set a signal, what I can do is man in the middle attack that claiming process where I get the serial knowledge proof from the user, and then I change to my wallet address to receive the AirDrop that would have belonged to the other person. If you add the signal, the signal becomes part of the proof. So if I tamper with it, then the proof will become invalid. So depending on your use case, it might make sense to use different types of signals. But then something like this. In this case, the signal can be the wallet address or it can be something else. And then we're also going to need the action ID.
03:16:25.200 - 03:16:25.950, Speaker C: So.
03:16:27.840 - 03:17:10.640, Speaker A: Let'S just do all right, then we're going to need to receive the proof here. Just console log for now. All right, let's see if this works. Need to run the server. All right, so now we have the Widget mounted. Super easy to do. Just make sure to set the right params.
03:17:10.640 - 03:17:52.790, Speaker A: Once the verification process happens, then I'll receive the proof in this method. And then here comes probably the most important part. What you need to do is verify that proof. The fact that you got the proof from the Widget is no safety measure at all. It's obviously on the front end, very easy to spoof, very easy to change. So what you want to do is grab that proof and verify it either on chain or with our API. But don't just assume that because you got the success method that this is going to work.
03:17:52.790 - 03:18:39.052, Speaker A: And then to verify the proof is quite easy. So if you're doing the API, you're going to want to do this from your back end. Again, if you do it from the front end, it's quite easy to spoof. So make sure to call it from the back end. And you're simply going to want to do something like this where I call the API. You don't have to remember the endpoint, of course, it's very well documented, so don't worry about it. And then either the API or the smart contract is going to take five params to verify the proof.
03:18:39.052 - 03:19:14.700, Speaker A: So first is going to be the action ID. The second thing, let's just send the action ID. Of course, if you don't send the exact same params, this is not going to work. So be sure to send the exact same params. Second of all, the signal, both of those params are set by you and sent to the Widget. So make sure to use the same ones. Let's see, what signal do we use here? Flywheel ETH.
03:19:14.700 - 03:19:50.596, Speaker A: And then the other three params are what comes from the response on the Widget. So if you see this verification response object, it actually has these three parameters merkel root, nullifier, hash, and proof. And those are the additional three params that you need to send out. I'm just going to do it like this. And then if the response is successful, 200 code. You know, the proof is valid. If the same person tries to verify again, then you'll get an error.
03:19:50.596 - 03:20:18.784, Speaker A: Or of course, if the proof is invalid. And just to add a little bit more to that. So the three params that we're sending, they have different purposes. The merkel root is used just to prove that you're part of the merkel tree where the identities are stored. The proof is just the zero knowledge proof. The interesting one to take a look at is the nullifier hash. The nullifier hash is basically the user ID.
03:20:18.784 - 03:20:57.070, Speaker A: It's going to be unique for every person and every application. So this is what ensures uniqueness. If the same person tries to verify for the same action ID, again you'll receive the same nullifier hash and you know that's the same person. Well, what's cool is this will always be different for every application. So if I use my world ID with this POAP app, then my nullifier hash will be different than if I use it to verify my lens profile. And now Miguel is going to show you how to integrate on the smart contract side.
03:21:07.400 - 03:21:08.004, Speaker C: There we go.
03:21:08.042 - 03:21:44.368, Speaker B: It never goes in the right direction the first time. Okay, so first of all, all of the stuff that we're saying here right now, it's probably way better explained in the documentation. So any questions or any doubts or even like the endpoint ID or all of that is going to be there. But yeah, let's look at some code. Start easy. Let's say that we are like we've seen how to verify it on the API and the API behind the scenes. What it's doing is calling on chain anyways.
03:21:44.368 - 03:22:12.556, Speaker B: It's always verified on chain. The API is just a convenience measure for people that are not super familiar with web3 or people that are making applications like the pop one where really adding an onchain component doesn't really make sense. But for most of the implementations of this, you'd probably want to use a smart contract. And so let me make the font size a little higher. Hopefully that's big enough. This is an example contract. That what it's going to do is it's just going to AirDrop some tokens and don't get scared.
03:22:12.556 - 03:22:44.516, Speaker B: By measure all of the text here. Most of this is just comment. This is one of our example starkits. And so the part that you need to look into is this claim function which receives four parameters. First is the address that is going to receive the proof. We do it this way instead of just defaulting to MSG sender in order to make it so that anyone can submit a transaction and so you can pay for gas for your users, which is really nice. And then the other three arguments are the ones that you got from the Widget like Paolo demoed.
03:22:44.516 - 03:23:21.728, Speaker B: And so in here we're going to want to do three things to verify it and then you can do whatever you want to finish your logic. First of all, we're going to check if the nullifier has that we are getting here is already on our list of people that have claimed this. So you'll see up here I have a mapping of the UN which is nullifier has to a boolean. And this is going to be false by default. So we'll just get right through it like. Paolo mentioned, this is a unique ID for this action and this person, meaning that if they do it again, you'll see later down here, we're just going to mark it as true. And this is like the dumbest solution for making sure that they cannot reuse.
03:23:21.728 - 03:24:05.060, Speaker B: You can also do some interesting things with this, but the most common use case is just checking if it is included and after verifying, making it included. And so afterwards, what we're going to do is call the wall ID contract and just say in verify proof and we're passing the root that we received, group ID, which is always one, then the signal of the proof. And for the API, the signal doesn't really matter. Usually it's on the Smart Contract side where it really, really does matter. An example of where this would matter is let's say that I submit this proof. I'm not using the signal. Someone can just front run my transaction in the mempool, change the receiver and get all the tokens by themselves.
03:24:05.060 - 03:24:42.684, Speaker B: And then I cannot verify again because I already went through by adding any number of parameters here on the signal. What I can ensure is if this parameter doesn't match the one that the user specified when they generated the proof, then the verification is going to fail. And then if someone were to tamper with our transaction, it's not going to get verified. And so, yeah, you can add any number of parameters in here. It's kind of like a way of checking that the parameters that the contract received are the ones that the user intended. And you usually just want to add any parameters that your function is going to receive in here. In this case, we only have one, which is the address, and then every other thing that we received.
03:24:42.684 - 03:25:18.852, Speaker B: The action ID is important. We are getting that in the constructor here and you're just going to get the Action ID. Like the string that Paulo showed is like wid underscore a bunch of letters and numbers. What we're doing here is encoding it and hashing it. This is required by the Smart Contract solution. And if you're using one of our storage kits, it will be handled automatically for you. And then finally this call, if the proof doesn't get verified for any reason, be it the user is not registered as a human or the signal has been changed or they haven't done this again, then this is going to fail.
03:25:18.852 - 03:26:09.724, Speaker B: If that doesn't happen, then we're just going to mark it as true so that the next time that the same user calls this function, this is going to revert right here and then we will proceed to do whatever we actually want to do. In this case, send them some tokens. A more advanced version of this would be we have this integration with Lens Protocol where users can mark their accounts as humans. And the implementation of that follows kind of the same pattern with one difference. As you can see, the first thing that we're doing is we're getting the profile ID which instead of the address is the parameter that we care about. Here which profile we are verifying and then the three parameters we're going to verify the proof, passing the profile ID because that's the signal, because that's the parameter that we care about. And then since this is really a unique Identifier, it just only format app.
03:26:09.724 - 03:27:15.650, Speaker B: What I can say is if this user has already verified a profile, we can use that to unverify that profile before verifying a new one. To make sure that if I fuck up and verify the wrong profile or at any point want to change the profile that I have verified, I still have that option without allowing me to verify multiple ones. So this is an example use case of how you can use the nullifier hash as some sort of anonymous action ID. So in this case instead of setting the nullifier hash to true, what I'm doing is I'm sending it to the profile ID and if that is different from zero that is the default. What I'm going to do before is just unverify the other profile ID which in this case is just emitting an event because Lens takes care of accounting for this in this part and finally let's look at how we would hook all of this up on the front end. So I have the front end for this here. It has a bunch of models and stuff, but the one that you care about is the verify model, which is where we have the profile that we want to verify already.
03:27:15.650 - 03:27:23.136, Speaker B: And the only thing that we're going to do is run the wall. ID widget our signal is going to be the profile.
03:27:23.168 - 03:27:23.412, Speaker C: ID.
03:27:23.466 - 03:28:13.540, Speaker B: And we're doing some sanitizing here to encode it as a uint, which you sometimes have to do when you're not working with strings. And then the action. ID and everything is going to be just fine. Once this is successful we are just going to call set proof and then send it to another component. In this case we're going to use the Wagmereact library to write it to a contract so we're calling the verify function on the contract that I just showed. We're only doing this though if we have a profile and we have a proof so until we actually go through with the verification this is not going to trigger and then once it does we are sending all of the same arguments that we saw here before and then calling the method that should call the contract. If it doesn't revert it will go through, everyone is happy and we are verified.
03:28:13.540 - 03:28:47.332, Speaker B: So yeah, just to recap a little bit, the system is quite complex but we've made it super, super easy to use. You can just drop in a few lines of JavaScript, integrate a wallet connect style JavaScript widget that acts in a similar way of a captcha and just allows the user to scan a QR code, get a zero knowledge. Proof that you can verify even either through an API or most commonly on chain. And get to know that that user has never done whatever action your app cares about.
03:28:47.386 - 03:28:47.990, Speaker A: Once.
03:28:49.880 - 03:29:30.796, Speaker B: On the upside, I didn't have time to hook it up to show my phone screen here. I thought enough shiftling with the computers was enough. This is what it pops up on the wallcoin app where it will just show the name of the app and say the app wants to verify that you haven't done this specific thing before and it will tell you what that specific thing is. And then when you click verify it's where it sends the proof to the website. Again, the code is really really simple. Verifying the proof with the API takes probably a minute, doing it on the smart contract takes a little bit more. But we've been working really hard to provide lots of examples and starter kits and pretty much anything that you would need to have fully commented.
03:29:30.796 - 03:30:17.440, Speaker B: Code that you can just take the example that I showed at the start with the AirDrop change, the thing that is in the end and in most of the cases, you're going to be fine. And yeah, the really really cool thing is we have sibling systems now and it is super, super flexible. It's not just protecting airdrops. There's a lot of things that you can do, especially with governance and voting quadrant funding, things like Wallcoin. There's been a lot of talk about solvent NFTs which are solvent to your wallet, which isn't ideal because then you lose your wallet and you're fucked. Something like the thing that I showed for the lens profiles could be used to bound NFTs to a wall ID profile instead making it so that if you lose your wallet or if at any point you want to transfer them, you can still transfer them as long as you can generate proofs with your wallet. And there's a lot of other really cool use cases.
03:30:17.440 - 03:31:12.272, Speaker B: All of the links that we have mentioned are in the documentation, including the explanation of how this works, links to probably not this talk because it will not be out there, but all the similar talks that we've done in the past. Documentation, guides, testnet simulator so that you don't have to go to the Orb to try your app, you can just use a faucet that will give you unlimited entities to test with on testnet examples and much much more. So yeah, you can just go to ID walcoin.org and we'll also be doing the entire hackathon both on the Wallcoin discord which you can access at discord Ggwalcoin and at the Ifgobal discord on the channel. Yeah, we wanted to give a little shout out at these three projects SEMA for Hubble and Wallet Connect. Which are kind of like the projects that are allowing us to do all the things that we're doing here. Most, if not all of these projects.
03:31:12.272 - 03:31:45.832, Speaker B: Actually, all of these projects are open source. I'm sure everyone is familiar with walletconnect Hubble is an old project by the Ethereum Foundation, and Semaphore is also an open source project by some really cool people. And those are the things that really enable all of the stuff that we're doing here. And, yeah, we got started with this around ETH, Amsterdam, so pre of this year. And we've been working into making more apps like the Lens integration. We're working with Gitcoin Passport to get integrated there as well, and many others. And we are hoping to release this MultiChain.
03:31:45.832 - 03:32:25.780, Speaker B: Right now, it's mostly on polygon, but will be MultiChain hopefully by early 2023. And yeah, I personally think it's a really exciting solution. I've made a bunch of things that sound super hard, but really just take a few lines of code, like a contract that will receive any tokens and split it through every human on Earth, or at least every human that has registered, and things that, like, before, you could just not think of how to do. And yeah, I'm really, really looking forward to see what everyone else makes. Yeah. If you have any questions, our booth is upstairs on the left. First one that you see, and we'll be here all weekend.
03:32:25.780 - 03:32:29.332, Speaker B: You have discord? I have papa hair. Pretty easy to spot.
03:32:29.476 - 03:32:30.072, Speaker A: Yeah.
03:32:30.206 - 03:32:46.270, Speaker B: Thank you for listening. Hope you have fun. It's.
