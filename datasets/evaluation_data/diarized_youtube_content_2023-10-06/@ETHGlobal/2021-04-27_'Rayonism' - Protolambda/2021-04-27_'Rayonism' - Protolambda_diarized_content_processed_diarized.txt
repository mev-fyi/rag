00:00:00.330 - 00:00:23.146, Speaker A: For the next talk. I really want to I'm super excited to welcome Protolanda, who's going to talk about Rainism. We've been hearing about this thing a lot, and you've seen blog posts and tweets and everything else about it, but we want to make this really special and do a special talk around what's happening with the E Two testnet. And without further ado, please welcome Proto to tell us about the testnet.
00:00:23.338 - 00:00:36.920, Speaker B: Hello, everyone. Right, I'll share my screen. One moment check.
00:00:37.390 - 00:00:38.780, Speaker A: You're all good to go.
00:00:39.310 - 00:01:05.054, Speaker B: Thank you. I'll make this full screen for you. There we go. So, thank you so much to Eve Global for hosting this day. We'll have a lot of talks about merge, and I'm going to present about Rayonism. So, Rayonism is this kind of project over the whole Hecton. It's not going to be kind of submission.
00:01:05.054 - 00:01:52.650, Speaker B: It's rather like this kind of thing where we with developers, client teams, write this hackathon pipe and we are building this merge testnet. We're prototyping Sharding. So let me introduce myself. I'm Protolampta Or Dieteric, researcher at the Ethereum Foundation, and I research things about Ethereum Two with Phase Zero, various kind of testnet deployments tooling, this kind of stuff. And then more recently, Rainism. So, if you're just joining in, we have had just two talks, one from Xiave and one from Luxeman. If you missed them, you can watch them back on YouTube.
00:01:52.650 - 00:02:37.518, Speaker B: Highly recommend. The first talk went through the history, the second talk went through the status quo of the merge. And what I will be talking about is the next month or so with Prototyping development of this merge effort. And just to recap, in case you missed these talks. So what do we have? We have the ethereum one side and the ethereum two. Site. And you can think of them as the execution engine and the consensus layer or consensus engine, and they have their similarities, but the differences here are key.
00:02:37.518 - 00:03:17.546, Speaker B: And the main thing why we keep them separated for now is that we can improve the transition. If we refactor everything into one node, the merge hard fork is not going to be pretty. And at the same time, there are a lot of components that are just doing exactly what we want them to do. And breaking them during the merge is really not what we'd like to do. So instead, what we are doing is we keep a slim down version of Dev P to P. This is the networking layer of Ethereum One. Then we have the execution state.
00:03:17.546 - 00:03:44.180, Speaker B: The storage you're familiar with will keep all the state around. No changes, no application worries. Then we have the EVM. Of course, the transaction pool will stay on this kind of execution engine. This one is more up for debate. We have this new gossip sub in EPM Two that serves a lot of consensus messages already. So there is definitely opportunity to improve this.
00:03:44.180 - 00:04:30.850, Speaker B: And then the application RPC will stay the same. And on the Ethereum Two side, we introduced this new networking stack. So this was a lot of work. But within the Ethereum Two ecosystem, we have the peer to peer layer in many different languages. Also, thanks to collaboration with Protocol Labs and other projects that use Lip ETP, we have this beacon state which you could kind of compare to the execution state, but it's focused at consensus and it's this new structured binary form. So a binary tree to simplify all the light client work, which I'll talk about more later. We have new fork choice, of course, and we have the Federator API.
00:04:30.850 - 00:05:17.918, Speaker B: So Fedators are this new kind of thing, this separate kind of node that sign all the messages, all the consensus messages, and make the fork choice of this. So let's recap the roadmap for a little bit. So what I'm not going to talk about is the full history or full feature. What I am going to touch on, though, is that there was this one tweet last year, I think around April, and then there was this revisit of the same roadmap in December when we launched. And I think it's like time to just revisit it again and see where we are. This is this full roadmap. There's a lot of research projects.
00:05:17.918 - 00:06:02.800, Speaker B: There is Ethereum One, there are these separate Ethereum Three, or basically these kind of ideas where we could improve ethereum in a lot of different new ways, experimental ways. But what I'm going to do is to zoom in on the Ethereum Two part. So let's have a look. So this is where we were at last December, right? We had just launched and then we were looking at merge at Sharding specification. We were thinking of implementing light client support in the next hard work. And so this is kind of where we are. If you take the day today, we have a complete merge spec.
00:06:02.800 - 00:06:42.874, Speaker B: We have light client spec for the altar hard fork. Of course, these specs, they're not quite final, but are there you can work with them. And there's this new Sharding spec which we'll build a prototype for in Rainism. And then this kind of ethereum bond, ethereum Two merge implementation work starts with Rainism where we try and prototype the post merge world. I'll talk about testnets later in this talk. And so the hard floors will look like Altair merge and then Sharding. So, quick summary of altar.
00:06:42.874 - 00:07:39.130, Speaker B: For those that don't follow the spec as closely, it's this idea of a little stargazer or a light client that follows the state of consensus. And then they can take this state. The state is represented with a binary tree. And so when the root of the binary tree is signed off by a signed committee, the light client can trust it and can follow down the path to just the data they are interested in without downloading all of it. So we had this pre release a little while ago called Stargazer. There are a few more pre releases and if you're interested in light clients, definitely have a look at Lodestar and maybe reach out in the discord. I'll share some links after the call, after the talk, then we have the hard work two the merge.
00:07:39.130 - 00:08:34.290, Speaker B: This is what it's all about. So what you kind of think about is this execution engine, this rocket ship that we call Ethereum One that we try and give this space habitat where it can scale, where we can enjoy proof of stake. And in this kind of picture, really nice illustration from the Ethereum side is you can see these new building blocks being added to the habitat we're working on. Sharding and I'll talk about this later in the presentation. So what is this merge problem about? So there are eight plus client teams working on the merge. It's like this huge coordination effort. I think there are more like the thing is, with client teams, you have researchers, you have experimental clients, more and more implementations.
00:08:34.290 - 00:09:29.662, Speaker B: I think you should be interested too if you are looking to get involved. There are various new clients that are up and running and that can use more developer help. Then we have a whole lot of new protocol specifications that carefully navigate this balance between the current Ethereum One chain and the new prophostake system chain or the beacon chain as we call it. And then we have, as we merge the two with a few new challenges to support syncing the chain. Um, so maybe some of you remember this. This is way back last year, one of the few last hackathons, it was in Eve Denver. Yes, we all missed them, but we kind of want to recreate.
00:09:29.662 - 00:10:35.670, Speaker B: And especially hope to get from this month long hackathon with Eve Global is that we kind of get this vibe, this motivation to work between a lot of teams. This is really just a multi client project. It's communication interrupt. First, we do want to see all these clients interoperate and this hackathon is really just to get and start moving. Like without this idea of an Ethereum Two beacon node chatting to an Ethereum monot, there wouldn't be a merge. We need this kind of prototype where we can see that we can steer consensus and where we can move forward with the beacon chain and basically pass through execution to Ethereum One and have this kind of model where we have both the best of both worlds, right? We have the EVM, which you are so familiar with, all the existing state. And then proof of stake.
00:10:35.670 - 00:11:15.374, Speaker B: And then later on in the Hecton, we'll kind of split this off. I'll talk about this later in the presentation. We have merge transition research and then we have also Sharding research. So this is more to get into later. We have these kind of two specifications, luxeman kind of covered the first one, we have Demerge, but then we also have this Rayonism merge spec. So what do you think of the merge spec? You say? How do you reason about the differences here? The first one is specific to Etherm Two. This is to the beacon chain.
00:11:15.374 - 00:12:02.878, Speaker B: These are like type changes in the consensus state. These kind of things state transition on the consensus level. But what we are looking at with Realnessm is this additional specification, which covers an initial RPC. So this is this API between the Ethereum One node and the Ethereum Two node and all the little details involved in making it a coherent thing and getting this testnet to run. And special thanks to other researchers here, michael, Danny, Guillaume, everyone. Really a huge effort to get to this point where you can simplify and where you can say like, this is the minimal thing we really need. It's not this huge, complicated effort.
00:12:02.878 - 00:12:40.190, Speaker B: It's going to be a smooth sailing process to upgrade. So Rayners seek to break the barriers between the artist and the public. What does this mean? Well, for us as hackers during the hackathon, we want to build testnets. We want to build this kind of merge, this post merge world where we can see that the chain is stable, where you can test transactions on proof of stack. So this is what we are going to do. Let me try and put this into context. We have the Ethereum One chains of today.
00:12:40.190 - 00:13:11.590, Speaker B: We have the Ethereum Two chains of today. And they're kind of separate, right? They're the same currency, but there are different chains with Rayonism. Right now, what we are looking at is the post merge. This is where they are already merged. They start from Genesis, from the start of the testnet. They start in a combined manner. So what you have is the Ethereum One payload embedded in the Ethereum Two block.
00:13:11.590 - 00:13:53.234, Speaker B: So we have ethm and proof of stake. Right away, we can focus on sync, we can focus on validation, work on transactions and all the new infrastructure to make this usable. And then post Rayonism after the hackathon, what we are looking at is these new testnet upgrades. We kind of can combine any firm one testnet and any Ethereum Two testnet and merge them. And we can do the same with mainnet. When you combine Mainet with Mainet, you get Mainet squared. Anyway, so what we have right now is this tutorial to set up a local test network.
00:13:53.234 - 00:14:52.070, Speaker B: So you everyone here on the presentation on the Hecton can already run this for themselves. And clients have been actively contributing instructions on how to run their clients in the merge setting both Ethereum One and Ethereum Two. And what we're looking at next week is to spawn this one day developer network where we test interrupt, where we work through the initial issues, and then we move forward. We iterate. We say we'll try one week DevNet and what you kind of see here is the Prism Node, the locks where you see both attestation work of validators as well as transaction and application level data. And so it's really just combining the two and making it work. And then moving forward, we have the first, like after the developer networks, we'll move to a test network.
00:14:52.070 - 00:15:56.750, Speaker B: This is more public thing and you can think of testing sync. When we run a longer chain, we can try and ensure that it's not just the Beacon node providing blocks to the Ethereum monode, but we also have the Ethereum monode ability to sync the application state. So we refactor the existing sync and also we have these transactions. And this is completely new to the beacon chain. And this kind of latches onto the question from the previous call with Luxeman what are these OPEC transactions? So the beacon block contains an execution payload and this contains the block data that we know today from Ethereum. And this contains a list of transactions. The thing is, Consensus does not know or have to know anything about the transaction itself.
00:15:56.750 - 00:16:50.110, Speaker B: It just needs to know if it's valid or not. So what happens is that it passes through the transaction list to the Execution engine. The Execution engine updates the state, the application state or the execution state. And then it returns this check and says, well, if it's valid or not. And the idea of making them OPEC, but not making the payload as a whole OPEC is to be able to evolve in the future, to be able to merkel proof individual parts of the block in an elegant manner where we can separate all these little header fields. But within the transaction, that's very much up to the transaction format. And we just have this new EIP to define new transaction types.
00:16:50.110 - 00:17:49.474, Speaker B: This will stay part of the application layer, or I should say the Execution engine and application layer makes use of these types of different transactions. Okay, so let me give you a quick example. Like one thing that breaks with the merge if you just try and naively combine the two clients. So previously we had proof of work, now proof of stack. And the fork choice differs in one fundamental way is that we move from total difficulty, which is this block by block thing, to weight of attestations. And the thing about Attestations is that there are separate messages and that the weight can change. So if you add a block with a lot of attestations but then suddenly validators change their mind, there are these other Validators that have not voted yet.
00:17:49.474 - 00:18:38.738, Speaker B: They can vote for a different block. And so without adding a new block to the chain, you can move to a different fork and with difficulty you didn't have the same problem. So if your mon clients will have to implement support for this new type of RPC message where it's the Beacon Node that says what the new hat is. And then if your mon node forces a reorg manages their database to point to the head of the chain the current state of all the data in Ethereum. So what comes after? So after that we don't have a plan. What we do need to do is to iterate. So once the post merge is stable, we just want to break it again.
00:18:38.738 - 00:19:20.954, Speaker B: Basically sync, stake, break, repeat. It's that simple. What we have Ethereum is like a huge amount, basically one of the biggest decentralized exchanges, all the DApps. There's a whole like a super large ecosystem and we should protect it and we should test it before we move ahead towards the merge. And so with these testnets and then after the hackathon as well, it's not going to be a hackathon forever. We move towards production with iteration and you can help. We have a lot of different testnets and each of the testnets we need to deploy tooling.
00:19:20.954 - 00:20:11.386, Speaker B: Think of block explorers, fork monitors, statistics, faucets, RPC. And then on the Ethereum Two side we have slashers and validators. People need to be able to deposit. There's lots of tooling and you can help build this out. So what do we have? We have the merge transition afterwards and then the Sharding prototype. With the merge transition you have to think about how do we get into this new type of chain where we have proof of stake and we have the execution layer. And then with the Sharding prototype is like how do we scale it, how do we make it better? And I think right now we are all focused and working together on making the post merge stable.
00:20:11.386 - 00:20:50.010, Speaker B: And then going forward we'll have some Ethereum Two researchers focus on the transition and a lot of the Ethereum One teams. And then separately this is more of an Ethereum Two thing. We'll have people looking into Sharding prototypes. So independent of the merge transition, work will work in parallel to tray a first Sharding test nut. We have a specification, we are building prototypes. And then the next step is to build dev nuts to write Shard nodes, these kind of user focused nodes that provide all the data. And then we can think about roll up testing.
00:20:50.010 - 00:21:33.286, Speaker B: So what is the Sharding prototype about? I'm not going to get into the merge transition. This is something for after the hexon. It should be taken very seriously. But if the Sharding prototype will focus on getting to learn about this additional scaling, like how do we add a huge data availability layer to provide this L2? Provide the L2s with the data they need. So what is this data? So you can think of it like a data availability boost. It's not just data. We're not FalcoIn, we're not IPFS.
00:21:33.286 - 00:22:34.430, Speaker B: What we care about is that the data is the same domain of trust as the rest of the chain. So what we have here is proof of custody to ensure validators hold onto the data and data availability sampling so that ineffatable data does not get into the chain. And then L2 execution. We're not quite at a point yet where we have layer one execution on charts. We had a lot of research into this, but if you think long about this, it makes a lot more sense to do this with roll ups and cost chart communication kind of moves to L2 and L2 cannot be a lot more creative and doesn't have the same constraints. It's really just the data that's the data availability, that is the bottleneck and that we can solve. So how about the sharding spec? We have the Ethereum two specs repository, there's this base functionality, there is the custody game and there is data availability sampling.
00:22:34.430 - 00:23:33.826, Speaker B: These are three separate parts and we kind of can just build the first debase, the essential part. And this is enough to get to a point of testing the other parts. These are additions. I'll look into these after Rayonism. So what are these essentials? Well, we recently had this nice post from Vitalik on Eve research about staggering of shared data. But what you should really focus on is that if you have a chain with these blue execution payloads and these little green headers of shard blobs, then we can register shared data, ensure that it's available in the future with the new upgrades. And we include shard plops that move into the chain every slot and 64 at a time.
00:23:33.826 - 00:24:29.380, Speaker B: I'm only drawing three to keep it minimal and simplified, but we're looking at 64 shards. So let's give you a walkthrough to the simplified sharding specification. I won't get into any code on this presentation. There's a whole specs repository and if you're eager to learn more about this stuff, just reach out and then you can help build the new sharding prototype. So what is this shard block about? Well, it's really just a blob of data. The data can be extended, it's a list of bos points. And with this extension you can do fancy things like data availability sampling with the data itself extended data doesn't have to be included in the block, it's just repetition essentially a little bit more sophisticated with the repetition of the data.
00:24:29.380 - 00:25:28.358, Speaker B: We can summarize this data in a summary and then the header just includes the summary of the body. This header is what is registered into the chain, which can also summarize it even more into our reference. And then, so whenever there's a double proposal on a chart, we can efficiently slash them without repeating any of the data. And so what I'm kind of omitting here is the signature scheme. So all the signatures for these kind of things are the same, thanks to the way the mercuryization works. That you should just really think about is how data moves along the network, how it's registered on chain and then with enough votes, it's confirmed by committees, the committees that we have in place today with phase Zero. And so it's really just introducing these new types and few network changes.
00:25:28.358 - 00:25:49.654, Speaker B: And we have the essential Sharding functionality in a prototype. So that's exciting. Okay, maybe I liked maybe a little bit of code. So these are the kind of definitions we have in the specification. I won't get into any processing, though. If you think this is readable, it really is. It's just python.
00:25:49.654 - 00:26:18.840, Speaker B: You can get started with this. If you'd like to contribute to Sharding, try it. Read the specification. It's minimal. And then we can discuss building prototypes during Acton. So what's the prototype about? We do proposals, we do Attestations and we do header inclusion. But what we leave for the future is this kind of X data extension, data sampling and custody over all this data.
00:26:18.840 - 00:27:03.822, Speaker B: The base layer of the Sharding prototype is enough to provide this API where roll ups and other L2s can test against. They can get started building something before we even have a running test network. We could try this API because the Share data is really just low level. Low level. It's just a key value store with a lot of security. And then we have this new KCG proof to register the Share Data to commit to it. And if we can add this into the EVM one EVM, then we can efficiently prove any type of Shard data during an EVM transaction.
00:27:03.822 - 00:27:36.302, Speaker B: And then things like optimistic roll ups and whatnot can utilize the Shard data much better. So that's about my talk. If you have any questions, there is this panel as well. Just after this talk, you don't have to do time zone off. Right after we'll have the Q A, we kind of get into the evolution of the consensus. You can ask anything. Technical things we have Daniel Ryan or community things.
00:27:36.302 - 00:28:11.100, Speaker B: We have aftab. And then we have this break and a lot more talks. And then at the end of the merge summit, we close with this talk from Vitalik, where we look into the future after the merge and how we introduce these kind of new things to improve solidify the merged beacon chain and things like Sharding get a lot further than this base prototype. Thank you. Any questions?
00:28:12.190 - 00:28:43.250, Speaker A: Awesome. Thank you so much, Pearl. That was a really helpful intro and just a super detailed talk that covers a lot of things that all of us had questions about. We did see a lot of questions coming in and I'll start reeling them in order. And also, it's just awesome to see this being built during the hackathon. Just really good to see this all happening in real time. So the first question, which might be a quick one, is just does the Radianism testnet have a transition total difficulty like the main net will, or is it designed separately?
00:28:43.990 - 00:28:57.782, Speaker B: Right, so let me go back. I covered this maybe too quickly, but it's there. So this ID about post merge, the.
00:28:57.836 - 00:29:01.740, Speaker A: Screen is not being shared right now. So you may want to one more time.
00:29:02.350 - 00:29:50.802, Speaker B: Okay, never mind. I'll try and explain anyway without the slide. So the post merge is about embedding the execution payloads into the beacon chain. And we can do this from starting from Genesis. So we don't have the complexity of the transition just yet. We just make sure that what we fork into is a lot more stable before we focus on that one moment of the transition. And then once we have a stable start, the current phase zero chain and the current mainnet and a stable destination which is the post merge chain which we develop a realism and then improve, we can really get into this transition from one to the other which should just take one block.
00:29:50.802 - 00:30:14.240, Speaker B: And then there is this proposal with total difficulty and a few others to make the transition happen. I'm not going to get into that with Raynessm. It's outside of scope. It's a lot more work. It's an active research. There are proposals, we can make it happen. But I think that is not something you'd want to do in the hackathon just yet.
00:30:14.610 - 00:30:24.660, Speaker A: Got you. Awesome. The next one is just kind of from where you're at right now. What is the status of all the different clients? Which ones are ready to kind of follow the spec?
00:30:27.850 - 00:31:26.758, Speaker B: So we have this tutorial repository where we merge the instructions to run any client that participants right now. We always had Deku which is one of the first clients doing merge research along with Catalyst which is this new upgrade of Go Ethereum to facilitate merge. So that's two clients. But then more recently we had a lot more input from both Ethereum Two and Ethereum One teams with the Rainism project. So we have Lighthouse, we have Prism and more recently we'll also get Nimbus on board on the Ethereum Two side. And then with Ethereum One we have Nethermind ready for the first testnet. We have Basu looking at joining one of the early testnets as well and then maybe open Ethereum in the future.
00:31:26.758 - 00:31:35.340, Speaker B: I think we shouldn't push too much at the same time. This is a huge coordination effort but there are definitely a lot of clients on board already.
00:31:36.910 - 00:32:11.362, Speaker A: Awesome. Yeah, there was another one around just where can we follow the mergenet spec and tutorial and I think somebody already pasted the link on the chat. So I'll just kind of say that out of just completeness. There are a handful of questions that are happening but I feel like there's a pretty active conversation going on the chat. So instead of directly asking and taking a snippet out of it, I feel like it'll be better if you were able to join the live chat and just kind of continue with the conversation. But this has been extremely awesome. And thank you so much telling us about everything that's happening with Rainism.
00:32:11.362 - 00:32:19.810, Speaker A: And with that, we are ready to move on to our next talk. So the next talk is actually a panel, and I'm super excited to be welcoming.
