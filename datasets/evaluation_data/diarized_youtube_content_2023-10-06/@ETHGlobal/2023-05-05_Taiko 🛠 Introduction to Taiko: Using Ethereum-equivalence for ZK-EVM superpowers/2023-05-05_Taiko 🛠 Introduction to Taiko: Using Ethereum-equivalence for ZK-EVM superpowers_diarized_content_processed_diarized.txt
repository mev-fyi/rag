00:00:07.690 - 00:00:33.734, Speaker A: Okay. Hey everyone. So we are from Tyco. My name is Dave, I work on developer experience and this is Brecht, our big brain. So, yeah, welcome to our workshop. We're going to be talking about Tyco, which is Ethereum equivalent ZK roll up. And we'll be giving a little bit of like a workshop on building a DAP as well.
00:00:33.734 - 00:01:18.280, Speaker A: Give an overview of the bounties that we have and then also give some insights onto some cool things that you can build. Like I said, we'll just go over the bounties, talk a little bit about Tyco ideas and then code base walkthrough. Yeah, so these are the different bounties that we have. We have over $20,000 in bounty prizes that you can win. So we have best DApps. It's just like a smart contract DAP that you can develop infrastructure improvements. Catch mev some interesting mev stuff ZK zone where you can work on some interesting ZK stuff.
00:01:18.280 - 00:01:57.266, Speaker A: Protocol economics. This would be like kind of a no code bounty and if you're interested in economics and kind of dynamic systems, I guess this would be a fun one. Ethereum public goods. We find this one particularly exciting. If you can do something that's just better for the whole space, that would be really great. And finally, just a fun bounty where you just can do whatever you want and I think is interesting. All right, so what is Tyco? So basically, like I said, it's an Ethereum equivalent ZK roll up.
00:01:57.266 - 00:02:41.098, Speaker A: And if you look at this graph here, you can see we have these two axes of decentralized and centralized and Ethereum equivalent and one that diverges from Ethereum equivalents a bit more. And we're at the extremes of both of these axes where we're fully decentralized in terms of proposing blocks and also proving blocks. And then also we're Ethereum equivalent in the sense that we don't make any changes to the Ethereum stack. Even more peripheral things. We essentially don't really change anything to make it easier to generate proofs. Yeah, another word for this is a type one Zkevm. If you're familiar with it, it's also L One sequenced.
00:02:41.098 - 00:03:17.900, Speaker A: If you're familiar with Justin Drake, he made like a post about something called a based roll up which is using the L1 to do the sequencing. So when you propose blocks to create the Tyco chain, we just rely on Ethereum to do the sequencing. We're fully open source and MIT licensed. It's a community project. I think we have like 30 contributors on our Mono repository on GitHub and I think we have over like 50,000 members on our Discord. So we really try to keep everything open and let everybody just help contribute. We really like that.
00:03:17.900 - 00:04:08.534, Speaker A: And yeah, as I said, fully permissionless block proposing improving. The only reason I said permissionless here instead of decentralized is because in regards to proving maybe the decentralization doesn't matter as much as it being permissionless, but I won't go into too much length about that now. Okay, cool. So next I'll just give a run through of what the stages look like for the chain. Right. As the chain is moving on, what are the kind of steps that happen? So, yeah, first you see here we have these users of the roll up and they submit transactions to the mempool and everyone is able to run a node, right? You can just go to our GitHub repo and you can spin up a docker image and run a node. So they're all running this node.
00:04:08.534 - 00:04:45.318, Speaker A: It's a fork of Geth, which is the execution client. And basically those nodes can run as a block. Proposer. It's just like an environment variable. You're going to enable it and then after your proposer, you just look through the transactions in the mempool and you can propose a block to the contract that we have deployed on L One. And yeah, basically at the time a block is proposed, I think I kind of show this in the next slide. We can already build the roll up state right after we've posted that transaction data.
00:04:45.318 - 00:05:17.646, Speaker A: And that's because we have really well defined validity rules that we derive from the ethereum yellow paper. And we do those validity checks to be able to compute the next state for the roll up. So you don't have to wait for approve or anything like that. At the moment a block is proposed, the chain can progress. So, yeah, that's how we kind of derive the roll up state. Yeah. So in terms of proving blocks, you see here I have these three colors, like blue is like proposed, and you can just keep proposing blocks in sequence.
00:05:17.646 - 00:05:53.710, Speaker A: And then in green you can see is when you can prove a block. Right. And really what that is, is it's just proving one state to another state. It's like proving that transition. But the reason why there's also this verified state is because it's assuming that the state transition that you're proving has a valid parent or a verified parent. So the first block, the Genesis block, is already implied to be to be valid because it's the first one. So it's only when all of the parent blocks have also been proven that we can consider a block as verified.
00:05:53.710 - 00:06:19.200, Speaker A: Yeah. So you propose blocks, people go around and also this block proving it can be done in parallel. Yeah, exactly. That's a good question. So the next slide is like boom, yellow. Yeah, exactly. Okay, cool.
00:06:19.200 - 00:06:38.970, Speaker A: That was a great question. Okay. Yeah. So you can do all of this in parallel and then at the moment that they're all proven to Genesis, they're all verified. Okay. Now I'm going to give it to Brecht and he's going to talk a little bit about some things to think about as they relate to our bounties. So yeah.
00:06:41.100 - 00:07:04.960, Speaker B: Hey, Ron. So yeah, I'm going to go over the Bounties pretty quickly. There's a lot of detail that you could go into. There's quite a lot of bounties. All right, I'm a bit smaller. Yes. So, yeah, there's a lot of different bounties, and to go into detail for all of them would be quite difficult.
00:07:04.960 - 00:07:53.968, Speaker B: So I'm going to be pretty quickly describe some of the bounties, give some extra detail, but if you're interested in them, please contact team members and they will give you some more information afterwards. So, yeah, one of the first one is kind of like infrastructure improvements, where the goal is to just improve the usability of our chain. And so there's a couple of possible tasks you could work on. One is, for example, the NFT bridge. So we created an RSC 20 token bridge ourselves and an ETH bridge ourselves. So you could depend on that as like, a sample of your NFT bridge. But yeah, our Bridging is kind of like very flexible, so you can basically write your own Bridging Smart just by depending on this L One block hash that we bring available to L2.
00:07:53.968 - 00:08:33.800, Speaker B: So our RSC 20 implementation is like, one of them that you could use, but basically you can do whatever you want to make this bridge. The other one is also like, Bridging related. So currently we use Merkopisa tree check in our Smart contracts. The positive thing about that is kind of like, yeah, we also like type One equivalents. So this makes sure that we can actually reuse a lot of code that other bridges already use to do that. But the downside is that it's quite expensive because the Merco Patricia tree proof is quite big. And also the verification cost in the Smart contract is also pretty significant.
00:08:33.800 - 00:09:17.496, Speaker B: So we can try to optimize that by instead of doing it in a Smart contract. We just wrap the Merco Patricia Tree tree check in a CK circuit, and then we just have to verify this circuit plus a small proof. And so we kind of balanced out the proof size, like the data size compared to the computational cost. And on L2, the computational cost is kind of less significant than the data cost. And the other two ones is kind of like more UI related. So one of them is like, yeah, we have like, an L2 block Explorer, and currently it doesn't add some of the Z key stuff to it. So, for example, it doesn't show you if a block is proven, if it's verified.
00:09:17.496 - 00:09:56.628, Speaker B: And so it would be great if users can actually see that as well on the block expo. Another one is we want as many people as possible to be able to run a proposal. It's kind of like, necessary for the decentralization of our block production. It's also necessary for some of the centralization of our proving. So it's important that it's as easy as possible for everybody to run a node if they want to. The other one is kind of like the general protocol proposing improvements. So here the goal is mainly to improve the efficiency of proposing blocks.
00:09:56.628 - 00:10:44.424, Speaker B: And so, yeah, one of the first tasks is kind of like improving the block, proposing cost estimation. So the difference is we really try to be as much as possible to like Ethereum. But the difference between L two and L two, an L1 and an L two is that proposing a block on L1 is completely free. It doesn't matter how much data it costs, like how big a block is in terms of data and things like that. And for an L two, this does matter because we actually have to publish the data on the L1. And the costs for some of these resources that we use on Ethereum is also like time dependent and so that's kind of like one of the more challenging things. It's kind of like, okay, proposers want to put blocks on RL two, but yeah, they still want to make a profit so they have to have a good strategy to do it.
00:10:44.424 - 00:11:58.616, Speaker B: And so, for example, transaction data needs to be included on Ethereum for us and so that takes data on the l one blockchain that calls gas and so that needs to be taking account if they want to be profitable. And the one other thing is also like what Dave mentioned is we have a based sequencer so we kind of depend on the lo one to do our sequencing. But yeah, if we have no extra mechanism on top of that, that means that money proposers would submit block at the same time and that would mean that many transactions would actually fail and waste gas because many proposals would submit the same block and they would include the same transactions and obviously that would be very inefficient. So the way that we can improve that is to integrate latchbots which allows us to proposers to say like, okay, include my block only when it's successful and then all other blocks will not be included. But that's great because they don't want to be included if another proposer is faster than it. The other is kind of like more exotic. So one of the things that Tyco protocol allows is kind of like these shared sequencers because our current protocol is kind of like already fault tolerant.
00:11:58.616 - 00:12:44.830, Speaker B: So that means that a shared sequencer does not need to have the full state available of all the L two s because it's okay for us for a sequencer to include a transaction that is actually invalid so the protocol will skip over it. It's kind of like inefficient so you want to avoid it, but we can fully support that out of the box. And the other one is also similar to that. For the base sequencer, we kind of want to use Flashpots to include, for the proposals to include in our l two blockchain. The other one is like, yeah, if we have an L two. Then there's also like math to be exploited on the L two. So being able to also have this MEF boost availability on the L two is very useful for proposals to make money and optimize for that.
00:12:44.830 - 00:13:22.728, Speaker B: And the last one I'm going to talk about is like the protocol and economics. So yeah, the goal here is that the economics need to be simple and robust. And so there's two main fees that need to be paid. One is if a proposal submits a block, then he needs to buy block fees. It's similar to the ethereum EIP one five nine. The other one is that if you create a block, there's also like an extra zero knowledge proof generation costs associated with it. So that's the two main fees that need to be paid for the EIP one five nine on the proposed site.
00:13:22.728 - 00:13:58.996, Speaker B: It's very similar to the ethereum one. But there's a couple of differences. For example, instead of having a fixed block time, there's like no fixed block time on our L two. And also the L1 mechanism depends on this variable block size, which we also don't want to support because it's less efficient. And the final one is the proof fee. So the proof fee is generally paid by the proposer, but it doesn't have to, it kind of depends on the mechanism there. So there's some ideas on how the proof of fee could be paid.
00:13:58.996 - 00:14:49.350, Speaker B: So one of them is kind of like a race where the first that's submitted actually gets reward for the auction based scale of like depending on how much the proof wants to pay and how long the proof generation costs takes will know. And the final one is also like an interesting one where the proof of stake mechanism, where the sorry. Where the counterfeit depends on how much each prover gets like tyco stakes or something like that. And so then we can just use statistics to give some of them. Depending on how much is staked, we can actually assign blocks to them.
00:14:53.420 - 00:15:26.880, Speaker A: Okay, cool. Yeah, a lot of fun stuff there. Oh, crap. All right, we're good. All right, so yeah, the next one is just going to be like me using open source tool that I made, which is called DAP Slaps. So basically the idea is that you can just in one click bootstrap your DAP. And I know there's a few variants of these, but I tried to make it fairly unique in the technology that's used.
00:15:26.880 - 00:16:07.440, Speaker A: It uses Svelte, it's a monorepo configured with foundry and uses a lot of kind of the latest tooling to give a really frictionless developer experience. And yeah, basically the idea is just want to help so that you don't have to waste too much time trying to build your DAP and just get moving on writing smart contracts or doing something more fun. So yeah, you can scan this QR code if you want to check it out. But aside from that, I'm basically just going to emulate what you would be if you're using this tool and just set up adapt with it. Yeah. Let's see here. Okay, so this is the repo.
00:16:07.440 - 00:16:30.560, Speaker A: This is the button. Yeah. So you just connect your GitHub. I'll just call this blah, blah, blah, blah, blah. So, yeah, it'll deploy. It like on Versaille. And the only thing that you need is this one environment variable, which is like a Web three modal project ID.
00:16:30.560 - 00:16:46.120, Speaker A: I'm going to get one online. I think it's let's see here. I think wallet, connect cloud. Okay.
00:16:53.940 - 00:16:54.416, Speaker B: All right.
00:16:54.438 - 00:17:18.210, Speaker A: Yeah. So you just create a new project here, and then it'll give you, like, an API key. I'll just copy this and I'll add this and then okay. Technically. Two clicks, I guess. All right. This might be, like, a little bit of an awkward silence just because it needs to build.
00:17:18.210 - 00:17:48.436, Speaker A: I don't think it'll take too long, though. Let's see if it cloned the repo, at least on my profile. Oh, there we go. Okay. All right. As I'm waiting for this to build, I'll just clone the repo, and then maybe we can see it locally. So you can just follow these steps.
00:17:48.436 - 00:18:23.550, Speaker A: They should be fairly clear in the README. Yeah. So I'll just go through this, maybe increase my font size. Okay, so just cloning this. And then what are the next steps? Yeah, it doesn't clone the sub module, so you have to do this one forge install. See here? So CD into the directory. Do this forge install.
00:18:23.550 - 00:19:01.960, Speaker A: If you need to install Foundry, there's, like, a link to it here. It's, like, fairly simple, I think. It's just like a curl command. And then yeah, you can just run this setup script, and this will just install the node packages and also install the forge dependencies. Okay, so next step would be, like, generating this BIP 39 mnemonic. And you don't have to do this, but I just kind of recommend this if you're hacking, because you might want multiple accounts, like multiple addresses, and you don't want to use your main one. So you can just create a BIP 39 mnemonic and use that.
00:19:01.960 - 00:19:29.684, Speaker A: And basically you can use this as an input. If you're not familiar with Foundry, you can run, like, a local ethereum node, and you can just send in the BIP 39 mnemonic that you generate here. And it'll just bootstrap the network with these accounts and give them all, like, a bunch of ETH. Yeah, I'll just create that, and then we'll set that in the environment file. There's a single environment file. We'll just put this here. Okay.
00:19:29.684 - 00:19:52.970, Speaker A: Source the environment file. And then I think that's it. Yeah. Okay. So I have three windows here. The reason for that is because we'll use one window to start the local anvil chain. We'll do another one just to, I don't know, do random terminal stuff and then the last one will just be, like, running the front end of the app.
00:19:52.970 - 00:20:13.376, Speaker A: Is this done yet? Okay, cool. So this is done. So like I said, you literally just need to do that, like two clicks, I guess, and then you can go and it'll be deployed. So you'll just have a fully functioning DAP that you can use. This doesn't use any weird. It's like, very minimal. I didn't put any CSS or anything like that.
00:20:13.376 - 00:20:39.540, Speaker A: It's like a single file. You can just rip it out and just use HTML, and it's just very minimal. So, yeah, this is the DAP, but we'll get back to working on it locally. Okay, so I sourced the environment file. Now I'll just follow these three steps for these three windows. I'll start the local anvil change with the BIP 39 mnemonic. And you can see here that it gives you all of these accounts that you can use along with their private keys.
00:20:39.540 - 00:21:05.508, Speaker A: So you can just take any of these private keys, and you can just import them in the MetaMask so that you can use it in your application. I guess I'll just do that as well. Okay, cool. I don't know why it says Supply ETH, but all right, so I started the local anvil chain. That's good. Now we can interact with that. The second thing I'll do is I'll run this script.
00:21:05.508 - 00:21:39.620, Speaker A: It's a deployment script just to deploy kind of a dummy smart contract to that local anvil chain. And also it uses Wagme to generate all of the types. So it's like, fully type safe when you interact with the contracts values required for fork URL. Okay, so it's probably because I need to go in here. Yeah. I didn't source my environment file, so I think that was the issue. Okay, cool.
00:21:39.620 - 00:21:58.010, Speaker A: Yeah. So this is just compiling the dummy smart contract. I'll go through the folder structure, too, so you can kind of see but this just compiled and deployed the contract. I think we should have gotten a receipt. Yeah, this is like a transaction receipt here. Okay, cool. So now we'll just start, like, the front end of the application.
00:22:03.430 - 00:22:04.370, Speaker B: PMP.
00:22:07.460 - 00:22:22.640, Speaker A: All right. We can visit it on localhost. Yeah, this is the application. And let's see. Does this work? Okay, cool. So it says I'll just show what the contract looks like. So basically, like I said, it's a mono repo.
00:22:22.640 - 00:22:48.364, Speaker A: One of the folders has all the foundry configuration. The other folder is a svelte front end. So in the contracts folder, we can look at the contract that I just deployed. It just said, like, hello world here. And the cool thing that this has integrated is if I update this, actually yeah. If I update this and then I redeploy the contract right. It'll just update the contract address, which is used by the front end.
00:22:48.364 - 00:23:06.224, Speaker A: And now you can see here's the new message. Right. So hopefully this can give you really rapid development. You'll need to change contract addresses or anything like that. It'll just update all reactively. Okay, so what else do I want to show here? Okay. Yeah, so like I said, there's this source contract folder.
00:23:06.224 - 00:23:16.988, Speaker A: There's obviously, like, a test folder if you want to write unit tests while you're hacking, but that would be kind of weird. This is the deployment script.
00:23:17.104 - 00:23:17.576, Speaker B: You can see here.
00:23:17.598 - 00:23:37.644, Speaker A: This is where it's deriving that mnemonic yeah. Creates this smart contract. This broadcast folder has some metadata from doing the deployment. Okay, cool. Yeah. So this is just like you can just interact with a contract here. Yeah.
00:23:37.644 - 00:23:55.984, Speaker A: So it's pretty simple. It's just a dumb smart contract. We don't have enough supply ETH. Okay. But, yeah, I'll show one other thing really quick. I guess I only have four minutes here, and I want to be able to answer questions. So we have one page where we integrate the Tyco signal service.
00:23:55.984 - 00:24:31.804, Speaker A: So Breck talked about that a little bit because our protocol is like, ethereum equivalent, and we just use Merkel Patricia Tree for the state. We can just send arbitrary messages using Merkel proofs. And the signal service is a contract that we expose where you can do that merkel proof verification easily. So if you want to do that thing, like build the NFT bridge or do something related to cross chain messaging, then you can just use this as an example on how to interact with the signal service. Okay, cool. So let's go back to the slides. Yeah.
00:24:31.804 - 00:25:10.844, Speaker A: So, yeah, big thanks to everyone for coming here and listening. I think Tyco is going to be, like, a really interesting thing if you don't have too many ideas for the hackathon. We actually have, like, 20 people here in Tokyo, which is pretty crazy, and I know that we're all really willing to just talk about anything. So if you don't know what you want to build, there's a whole playground of things you can do, whether it's economics, building a DAP, doing something that's not even really Web three related, and writing some scripts to run a node. I think we'd all be down just, like, stop by our booth. We'd love to talk to you about anything and help you build. Yeah.
00:25:10.844 - 00:25:49.228, Speaker A: So I guess now, does anyone have any questions? My RuneScape username. It's a dr soupa. Fresh. Yeah. So for block, proposers for Tyco, is it just like first come, first serve for whatever hit the smart contract first.
00:25:49.314 - 00:25:50.188, Speaker B: On the L One?
00:25:50.274 - 00:26:03.532, Speaker A: Yeah. Anyone can propose blocks at any time, but it's up to the L One to decide how those are included or when they're included. They decide to pick up that proposed block up to the L One validator or whoever's proposing the L One block. Exactly.
00:26:03.686 - 00:26:04.436, Speaker B: Makes sense. Yeah.
00:26:04.458 - 00:26:32.348, Speaker A: All right. What do you view as the most important trade offs to optimize for economically in the system? Bret, do you want to go for that one? Maybe. A maybe? Like, what are the most challenging things you've encountered so far?
00:26:32.534 - 00:27:09.840, Speaker B: Well, we kind of want to narrow the problem down as much as possible. So what we do is not change anything to the Ethereum protocol itself, but instead we have to really optimize our circuits and our zero knowledge proof generation as much as possible. Because if it's too long, then transaction costs would go up, which would obviously be a bad thing. So the trade off here is going to affect you trade in some of the efficiency for full compatibility, full equivalents, so it's easier for developers to develop on. But then we have to do our job to make it as efficient as possible.
00:27:09.990 - 00:27:10.976, Speaker A: Okay, great.
00:27:11.078 - 00:27:52.124, Speaker B: Thanks. Questions on the block finality tyco block finality, is that instant or we have to wait for confirmation? It's instant, as in when the block is proposed and it's included in Ethereum block, it's finalized. So that means that the transitional order is fixed. Everybody knows what the prestate and the post state will be. It's just like that. The information like the post state of that block is simply not known yet by smart contracts. But anybody that's running a note and is just looking at the data as it comes in in the roll up smart contract can execute those transactions, know the post state, so they know exactly what the state is.
00:27:52.124 - 00:28:18.336, Speaker B: And once it's in the smart contract, that means that it cannot be changed anymore. So once it's there, it's fully finalized, can only be changed. Everybody knows the state except smart contracts. And smart contracts. That's why we need the zero knowledge proof. So the zero knowledge proof is there, because we will also want to let smart contracts know what the latest post is without having the smart contract itself execute all those transactions. So I guess in practice, we don't have to wait for any confirmation.
00:28:18.336 - 00:28:33.270, Speaker B: No, you don't have to. It's just for Bridging, where a smart contract needs to know what the L two state is. Otherwise everybody else knows directly when the block is proposed, what the latest state is, so they don't have to wait. Sorry, another question.
00:28:34.680 - 00:28:37.368, Speaker A: We have plans to support the privacy.
00:28:37.464 - 00:28:49.116, Speaker B: Programming feature, as in Leo Mina, not on our L2. So if you want privacy, you'll have to run it, as in L3s on our L2. Awesome. Sorry. About time. Cool.
00:28:49.218 - 00:28:50.750, Speaker A: Thank you. Yeah, thanks everyone.
