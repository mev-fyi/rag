00:00:25.570 - 00:09:57.970, Speaker A: Sam sam. It's dam ram nam. There's money SA.
00:11:43.570 - 00:11:44.320, Speaker B: Okay.
00:11:46.050 - 00:12:05.090, Speaker C: It'S working, guys. Hello. Good afternoon to you guys. My name is Carlo. I'm with CartaSi. And today I'm going to try to convince you to use our cool tech to do some interesting stuff. The name of this is Billions of Reasons to use Cartesi and I hope it becomes clear during the presentation.
00:12:05.090 - 00:12:42.126, Speaker C: So today we'll be covering basically this. A quick overview of what Cartesi is and then an intro into our tech, which is Cortez RoPS its interfaces, really simple application of how you can build Cortesi application, in this case in Python. And then I'll go through a couple of things that are being built with Cortesi and are nice things to inspire others. So this is just a preview. I'll come back to this later. But this is a really simple program in Cartesi. In this case, it's an aqua application.
00:12:42.126 - 00:13:09.720, Speaker C: Wherever you froed it, it throws back at you. And if you check the code on the right side, which is the whole application code for the ones that are familiar with Python, this is just traditional Web Two Python code. There is nothing in there screaming web free. You don't have to learn anything new. You're just using requests, which is a well known HTP client. So it's really easy for anyone used Web Two to get started with Cortisol. But as I said, I'll go back to this later.
00:13:09.720 - 00:13:45.150, Speaker C: So let's get started. So what's the idea behind Cortesi? So, Cortez started in 2017. Ethereum was blooming at that time, and Ethereum is really nice. So we have all these decentralization properties, censorship, resistance. No one can tamper with anything because if they try to, it's really hard. You have to lie with thousands of nodes in order to get it right, and it's awesome, but it comes with its disadvantages as well. So on Ethereum, everything is low, it's expensive and it's cumbersome.
00:13:45.150 - 00:14:39.410, Speaker C: Why slow? Because, well, you're sharing a single VM, all the resources with all the applications that are running on, it expensive because you're always bidding for the resources that are scarce available in there. So you have to purchase that resources and overbid others trying to use it and cumbersome. Because Ethereum was designed around the VM, which is really good for sandboxing. Make sure that no one's messing with someone else's computation, but it's not similar to anything that came before. So all the tooling has to be built from the ground up. So what's the idea behind Cartesi? What if we could have much more complex computations, still having these really cool guarantees that Blockchain gives us, but with great ceiling, and that's what we achieve. So what's our solution? So we have this really cool application specific roll up solution.
00:14:39.410 - 00:15:24.450, Speaker C: We basically do this roll up for each application. That the plasma cortez. Each one of them has their own VM. And this VM is based on this Risk Five architecture, which is an open hardware processor and since everyone's got their own processor, the applications are not competing for resources and it's based on this traditional computation platform. Well, we can boot Linux and by booting Linux we bring all the web two goodies for Web three development. You don't have to learn Solidity to have all this really steep curve for doing your decentralized application. You can just use what you're used to on Web Two and in order to make it easier for people to onboard, we wrapped all the complexity of the framework on an HTP interface.
00:15:24.450 - 00:16:18.130, Speaker C: So how do we achieve this? This is achieved by using a very cool dispute resolution protocol that secures this computation. It's based on something called verification game. I'm not going to get really down on the details of how it works, anyone interested on that can talk later to me. But basically what happens is that all these computations that happen in the Cortez machine, the Cortez machine is deterministic. So if someone disagrees about the computation they engage on this verification game protocol we settle what's the first point of the computation you don't agree and that single instruction is arbitrated by the underlying chain on a copy of the Cartes machine implemented in Solidity. So when you have a dispute it's the entire blockchain you're using underlying that's actually arbitrating if you're right or wrong. So it's very safe.
00:16:18.130 - 00:17:11.538, Speaker C: Our security guarantee is that a single party willing to enforce the correct result is enough to guarantee it. Okay, just being a bit graphical here. So Ethereum Tooling is really scars because as I said, EVM is not compatible with anything that came before. So everything is being built from ground up. And when you come to Cortesi, well, you have everything you're used on Web Two so you can use all the libraries, all the services, all the languages that you're used to. This is just a quick overview of how you can make your Cartesi machine drive in which contains your application, everything you're going to use. So when you're building your Cartesi machine you can take advantage of a docker container which uses Camo to emulate risk Five and all the Linux distros that are already built for it and you just use whatever you want to install your environment.
00:17:11.538 - 00:18:03.830, Speaker C: So in this case here, I'm just starting from this risk Five build of Sling jammy for Python, which is Ubuntu distro you can use whatever you want. Alpine is your cup of tea, go for it. You want to use Vanilla Linux, go for it as well. Whatever you want, you can start in there. Since I'm Ubuntu and I want to use a SQLite database, well I just apt install it and it's available inside the machine for my usage. Then I just copy that directory in there to this optic Ortiz DAP because on my directory I will have the actual Python files for this application which actually has my logic and I can just pip install the dependencies like I would do on any Linux machine. So for a Web two developer, this is all very simple if you're used to docker.
00:18:03.830 - 00:18:54.022, Speaker C: Now let's talk a bit about the computational scalability. So if you take a look at VFR scanner or whatever your source, you can take a look that Ethereum blocks. They generally have like 30 million gas on all the transactions within it. So considering you have the entire block just for yourself and you're doing the cheapest possible useful computation. So if you take a look at Ethereum codes, the cheapest one is adding and that costs free gas. So that gives you a boundary of about 10 million instructions for the most you can do on an Ethereum block, considering you have the entire block for yourself, which is something really hard to get. Okay, just as a comparison, this is hard to read, I guess, but in here I have a terminal, and in this terminal I'm just booting the Cartes machine and holding it, doing nothing, just booting Linux and just shutting down.
00:18:54.022 - 00:19:47.030, Speaker C: And this is using alone about 37 million risk, five CPU cycles, which are much more complex than just adding. So if you do equivalent operations on the EVM, it's not going to cost three guests, it's going to cost way more. But that's just to give you an idea of the scale of the computation we can do. And booting Linux and shutting down, which takes about 37 million risk, five CPU instructions happens in a laptop in 0.2 seconds, so it's pretty fast. Now, just another comparison, I've done some dumb computation here using a shell script and that took 3.7 billion CPU instructions, okay? And on a regular laptop, that took about 13 seconds, which is the average block time of Ethereum.
00:19:47.030 - 00:20:18.578, Speaker C: So just to have a perspective of how that is compared to those 30 million instructions, you can have an Ethereum block. It's this read. So the left top corner is a yellow square and that would be 30 million instructions. And then 3.7 billion instructions will be all this blue grid. And that's not the limit of Cartes machine computation, I just limit it to 13 seconds. But you can actually have as large computations as you want, remembering that this machine is just for application.
00:20:18.578 - 00:20:48.842, Speaker C: It's not shared among everyone, just like in Ethereum. So let's get started on Cartesia rollups. This is the overview of Cartesia rollups application. So on the client side, traditionally you're going to do a web application. So you'll probably be using HTML, CSS, JavaScript, some framework you used to like angular react, view, JS or whatever your capacity is. And then you need a couple of libraries to connect to the Cortez framework. The Cortez framework has three interfaces you're going to use.
00:20:48.842 - 00:21:38.726, Speaker C: The first one is a JSON RPC one. Why is that? Because our framework is deployed on top of an EVM blockchain and in order to provide inputs to the Cortez machine, there's a data availability problem. So we enforce this to go through the blockchain for a special smart contract cloud framework. And, well, to talk to Ethereum or any other blockchain, you generally do this using a GZone RPC interface into an Ethereum or Polygon or Gnosis or whatever you're doing node. Then we have an Http request API that's used for something like Ethereum calls. So it's Ethereal calls you do to check some machine state that doesn't really do anything. It's a read only operation, right? And finally, we have a third interface which is a graphical one in which you can create a Cartesian node for events and things that you emitted on your logic.
00:21:38.726 - 00:22:09.406, Speaker C: Now, your decentralized logic actually resides inside the Cartes machine. And in order to make it easy for you to program, we have this HTP dispatcher component that wraps up the entire framework complexity on this simple HTP interface. What does it look like? Well, let's go back to that first slide. Now. Let's go in details. So if you take a look at this code, we just start like our traditional Python program. We're importing requests, which is our HTP library.
00:22:09.406 - 00:22:40.830, Speaker C: We're importing the environment module from OS because we want to read the environment variable. In this case, it's being used online. Four, because we're looking at this roll up HTP server URL, which is an environment variable. We set with the address of this Http dispatcher. Okay, well, once we know it, we ask for it. What do we have to process? So, the basic structure of a Cartesi program is an iterator in which you call this finish endpoint. And when you call it, you're doing two things.
00:22:40.830 - 00:23:20.170, Speaker C: The first thing is you are putting a payload saying what happened with the previous thing you processed? Is it okay? Is it invalid? If it's okay, you return a status accept saying it's fine. The cartoonized machine should eventually state it's fine if it's invalid. If it's something that will corrupt your application or anything like that, you can just reject it by returning a payload with status reject. Once that happens, the cartridge machine halts and it's waiting for the next input. The next input comes, this call returns and you get a response with the data of the next thing you should process. The payload itself is in a field called Data. And then you have some useful metadata.
00:23:20.170 - 00:24:00.070, Speaker C: One of them is message address, which is the sender address. You have the timestamp of the block in which you received it and a couple of interesting things on line 26. Specifically, we're looking for this request type. This is a pretty simple usage. It's just a metadata that can come with advanced state or inspect state or lines 19 and 20. And that's for you to differentiate when you have an input that came through the blockchain that should advance your application state or if that's if call, if female call in which you just want to generate some state of the application, maybe for a front end to consume or something like this. So just an example, let's say you have a chess application.
00:24:00.070 - 00:24:46.562, Speaker C: You move a piece that changes your application state, that's going to come on an advanced state. Now you just open your application. You want to know if a game is going on or something like that. Traditionally you would have to go through the blockchain, check all the transactions that you have to rebuild the application state, or use something like GraphQL to index the state and query it with Cartez. You can use this inspect state, you just provide your address and it's going to return JSON maybe with your chessboard configuration and the player server, right? So this is the difference. In this really simple example, we handle either advanced and mispac states the same way. We just pick up the payload of the input, we put it on adjacent and we emit an event with it in case it's a handle advance.
00:24:46.562 - 00:25:36.466, Speaker C: We use our interface called Notice which is equivalent to an Eferion event. And in case of handle inspect, we use the report which is the wrapper for responses for this Ephemeral call which is the Inspect API. Now on the left side we're using a really simple frontend application. We built in TypeScript that implements those three interfaces of the other slide. So if you call this command yarn Start, input, send payload, whatever you put in there. And in this case, hello there, it's the binary payload that's going to go on this add input framework and it's going to be piped into the cartels machine so that hello there, it's arriving in here on this response. And after we process this response in line eight, that JSON with a notice, it's going to be posted with exactly that payload.
00:25:36.466 - 00:26:06.240, Speaker C: So now if you call this front end application with Yarn Start Notice list, it will go to that GraphQL interface of the node and it's going to say, hey, give me the notices and you have a nice notes in there with the hello there. Because this echo application just pipes the input back to the output. So this is a really simple crash course on how to use Cartesi. It's 27 line python code. You can make it even less if you want. And it's just using HTP interfaces, nothing fancy, nothing different.
00:26:07.970 - 00:26:08.670, Speaker D: Cool.
00:26:08.820 - 00:27:02.414, Speaker C: Now that you have a crash course on how to make a Cartesi application and the interface and stuff, let's take a look at some usages and some nice things people are doing with it. So generally people use cortez either to further decentralize DAP logic because most DApps you do when you go to high computation or something complex, you generally put a part of the DAP in smart contracts and then you put most of the logic centralized. That works for games, for DAOs, for a lot of stuff. So with Cartez. Since you have a Linux machine with Ray tooling and a lot of computational power, you can actually decentralize this logic, express more complex logic, because you got all the tooling, all the libraries. So you can have really complex mathematical functions that you just import and use. You can use NumPy, you can use data analytics, you can use machine learning, all the stuff that's already been developed leveraging traditional stacks.
00:27:02.414 - 00:27:48.650, Speaker C: And it's also way easier to onboard web two developers into web3 because after all, they're using the tooling they're used to. So a first cool use case I want to show is this game is developed by a Taiwanese studio called Aphros, and the game name is Dazzle. It's basically a Pokemon and can crush mashup. So you have your team, you attack the other one. Whenever you want to attack the Aria player, you do a combo on this shared puzzle and then there's no problem about anyone needing to trust the server, about anyone tampering with the random number that's going to fuel the puzzle. So you're in a competitive match, you know that no one tampered with your board to get a better combo next turn or anything like that. The client itself is done in unity.
00:27:48.650 - 00:28:09.240, Speaker C: It's pretty beautiful. It's got some pretty nice effects. 3d characters that they use as NFCs. And the game logic, they built in rust and runs inside the cartoon machine. So each match you can just run your own node. Check it, it checks out. Nothing was tempered with if someone tries to temper with it, you can just prove they're wrong and enforce the correct result.
00:28:09.240 - 00:28:48.098, Speaker C: This is a nice DeFi application that was done inspired by the Mango hack on Salana. So there's this DeFi protocol lending in Solana that's really simple. And it was hacked by a guy that checked that they accepted a certain asset as collateral. And this asset had really poor liquidity. So this guy got something like $5 million purchased, the asset pumped, the price goes to Mango, says, hey, I want 100 million USDT or another stablecoin gets it because it just goes to a price. Oracle checks out, but then if they try to liquidate it, it won't hold. It's not worth 100 million, it's worth those 5 million he paid.
00:28:48.098 - 00:29:29.418, Speaker C: So, inspired by this, these guys, they made this really nice risk analysis protocol called Nucleus. And well, they feed the Cortez machine with prices and volumes of assets and then they use NumPy to do some sophisticated analysis and come up with some robust metrics about liquidity and volatility. And then they give recommendations like, yeah, this asset is not good. You cannot liquidate over ten K on it, it's going to going to hold. Or no, this is a great asset, great liquidity, low volatility, you can liquidate a million bucks and no issues here. This one is more machine learning, image processing. So these guys has this problem of people tempering with fingerprints in many places in the world.
00:29:29.418 - 00:30:12.000, Speaker C: It's used either for access, for clocking in and clocking out of work, this kind of stuff. And people mess with it. So they make fake silicone fingers to go in and go out, or to get an access or photocopy and this kind of stuff. What this guy did is he made this dapping cartesi, which is specialized on defining if a fingerprint was poofed or not. How does it work? He gets inputs as a fingerprint image, then has a first C program using OpenCV. It processes this image and describes it in an array of features that is fed into a Python program with a really cool machine learning model he trained. And this model was trained to differentiate a real fingerprint from something spoofed from silicone or paper or anything like that.
00:30:12.000 - 00:30:32.174, Speaker C: This one is more on games, AI. This is from a guy that came from our community, and it's called Ultrachast. So chess has this plague that people don't really play chess online. They open up a game, but you're not playing versus a human. They just open a computer game. Whatever you throw at them, they throw the computer. Whatever clever move the computer does, they throw back at you.
00:30:32.174 - 00:31:04.666, Speaker C: So this guy said, okay, so let's make it part of the game. You can play as a human, sure. But the main focus on Ultra chest is actually you're a trainer of the bot that's going to play. So you do your AI, you train it, you change its parameters, you put it in there, and then inside the cortez machine, automated matches happen and you're a king of the hill. You turn your bot, you defeat someone that previously defeated you. So it becomes a bot automated game, and the focus is on you training and improving your bot. Since it's happening inside the cartel's machine.
00:31:04.666 - 00:31:37.510, Speaker C: If you win or you lose a match, it's not because someone tempered with the match. There's nothing to temper with. Anyone can reproduce all the matches and check that everything's fine. In this case, you build it in Python and a web user interface. The bots themselves, they use a protocol that's established and they can be developed in any language you want. So you can do a binary in C or Rust, or you can do a Python script or JavaScript, whatever you want. This one is a really cool application that came from India.
00:31:37.510 - 00:32:11.198, Speaker C: So Indians, they have a problem with car insurances. Basically, there you have an accident, you activate your insurance and they deny you the payment. And why is that? They claim you're a bad driver. How do you dispute it? You go to justice the decisions behind closed doors, and you cannot really dispute it. So what this guy's doing is a decentralized car insurance protocol. So most cars today, they have this old BDB two port in which you can export all the data from the car computer. They feed it into the Cartes machine.
00:32:11.198 - 00:32:42.720, Speaker C: Then inside the Cartes machine, they have this model that analyzes this data and come up with a risk metric saying you're a good driver, you're a bad driver, you're an average driver. And based on that data, they deny you or approve your insurance, and they make it cheaper or more expensive. So if your insurance is expensive or is denied or anything like that, you don't have to go behind a trip port or something. Well, you just check the data is in there, the model is in there. Yeah, I'm a better driver. No, I'm a good driver. They make a false claim, you dispute it and you enforce a correct result.
00:32:42.720 - 00:33:16.342, Speaker C: This one was also built in Python. This is a really nice application that was done in Harvard hackathon. So these guys, they got this retro style emulator called Ikimengo that does games like Street Fighter. They put it inside a cortez machine, they make a Python program wrapping it. And they created all these crazy NFTs for Pikachu, Pokemon, Kung Fu guy, pizza delivery guy, you name it. And then this application called Coliseum. You have a batting phase.
00:33:16.342 - 00:33:36.590, Speaker C: Everyone says, I think this guy's going to win. This guy's going to win. They output their money, it ends. Then you have the automated match happening inside the cortez machine, and then you have the result and you pay the winners. Once you have the result, they also render the whole match into old school style video. So it's interesting. You bet.
00:33:36.590 - 00:34:16.110, Speaker C: Then you watch the match like you're watching MMA or something like that. And then you get your money in case you want, once again, nothing to tamper with. If someone tempers with a fight, you just enforce the correct result by disputing competition. And this is a really cool guy. These guys, they made this for a hackathon in Bogota. So NFTs have this problem in which NFT itself, it's not the asset you want, it's actually a certificate pointing to the asset. So there are a couple of cases in which you purchase this really expensive NFT and then the person changes that beautiful art for a blank canvas on a server or something like that.
00:34:16.110 - 00:34:48.040, Speaker C: So these guys, they actually wanted to generate an NFT collection with provable art. How did they do it? Well, they generated the art within carte's machine, and in this case they use a competition intensive algorithm that generates fractals called Brat. They implemented it in rust. So if you have an NFT from their collection and someone tries to temper with the art or anything, you just go to the cartex machine and say, hey, this is not the real art. The real art is this one. This is the composition that generated. Anyone can just verify this is the right art.
00:34:48.040 - 00:35:18.866, Speaker C: This is a more traditional application, but still it's an interesting use case. So this is from a team of Poland and what they did is they did a decentralized parking app. I'm not sure about your personal experience, but sometimes you get a fine for not paying your parking, but you were on time. All this stuff, you have to go through the common justice to dispute it. It's a hassle, especially if you're not from the place. Sometimes you don't know how to pay for the parking meter, all this stuff. So they make this really nice application.
00:35:18.866 - 00:35:57.278, Speaker C: The front end is web in view and they use Rust and post SQLite on the back end. And they build this nice application which you have the parking zones, you have the piece, you can just go in there and fill up your meter. Anyone can go in there and check that you're still on your time and do your thing. So it's a more traditional web two application made very easily inside the Cartez machine. All these and many others. We have things with carbon credits, we have other things really interesting with machine learning. So sentiment analysis, all this stuff, they're available on this showcase page.
00:35:57.278 - 00:36:25.320, Speaker C: We have our games, we have some really nice projects in there. They're available in there. And just to inspire you guys a bit more, what you can do on Cartesian. So we have this track with a total price of ten k. The first winner is going to get a nice price of seven k. And then we also have share pool for the runner ups. So three teams share $1,000 each.
00:36:25.320 - 00:37:12.322, Speaker C: Okay, so we had this tweeter on February of this guy asking, well, if Ethereum is really the world computer, can someone explain how no one has managed to get Doom working in it? And we had a very clever engineer in our Emulator team which said, challenge accepted. So, yeah, he put Doom real time running inside the Cortez machine and yeah, it's really cool. So if you look at his suite, I can give you the link later. There's a render of him playing and there's also a GitHub repo for the courageous to use because he hacked this really fast. So it's not really easy to reproduce it, but it's in there. Okay, and that's all. Thank you very much for attention.
00:37:12.322 - 00:37:43.440, Speaker C: I hope you learned something maybe. And whatever doubt you have, you can shoot at me. We're going to be on our stand during the whole hackathon. So if you want to exchange an idea, if you have something you want to build, if you want to brainstorm, if you're trying to build with us and you have some problem, you need debugging or anything like that, we're there available for you. Thank you guys. So I think we have some time for questions if anyone wants to ask something. Sure.
00:37:43.440 - 00:38:41.294, Speaker C: How what works? Randomness? Okay, so the question is how randomness work? And that's a great question. So the way it works is when you generate a random number on a computer, it's not really random, it's persona random, right? And the source of entropy in the cartes machine is controlled, otherwise it's not deterministic. So when you generate a random number in the cartes machine, it's always going to be the same because other people will produce it and it's the same. That doesn't mean you cannot have random numbers within it. How do you do it? There are multiple techniques and that depends on your application. So let's get Dazzle for example, which is a multiplayer game, right? You need to generate a random number to refuel the ward. The way you do it is you use a seed that's a joint number from both players in order for you to have both players contributing without one mining advantage.
00:38:41.294 - 00:39:03.882, Speaker C: Random number. We use a scheme that's well known called committing review. So basically one player commits to a number, maybe the hash of the number. The other player submits the actual number and then the first player has to review the first number and then it's a hash. So you hash the number he provided. If it checks out, that's a number. If it doesn't, he tried to temper with it, everything is fine.
00:39:03.882 - 00:39:34.894, Speaker C: Combine both, you have a seed for a random number situation. That's a strategy. You can use our approaches, it depends on your application. Let's say you have a SWAT machine application, for instance. You can use something that's hard to control, like the block hash of the input that's coming requesting number. You want to be maybe a little more safe. You can use Oracle from Chainlink.
00:39:34.894 - 00:40:14.346, Speaker C: You can use Ivrf. Yeah, there are many options. Yeah, because you can always reset the seed on the Linux system. So, yeah, you just set the seed on the system and that's going to be used universally. Cool. Anyone has got further questions? Okay, I guess that's it. As I said, great hackathon for everyone.
00:40:14.346 - 00:40:21.690, Speaker C: If you need this, you want to trade a word or something, we'll be on our booth and happy to talk to you guys. Have a great evening.
00:40:36.770 - 00:47:54.370, Speaker A: Sam military sam SA keep. I won't. I won't. I won't. I won't die. It Sam dam.
00:51:27.430 - 00:51:28.500, Speaker E: Hi everyone.
00:51:37.390 - 00:52:37.230, Speaker F: That cheer is definitely for the Ravi tickets rather than this, but hi everyone. Thank you all for coming. I'm Jess Glover, I am the developer relations engineer at the Aave companies. I've been here for just under a year and I work primarily on Aave and Go. So I guess who here actually has Minted girly Go and who is here for a rave ticket? Okay, so today we're going to be looking at what Go is, how it works and looking at looking through some code snippets and then go through the prizes for the hackathon. So if you haven't heard of Go, it is an Ave native decentralized over collateralized stablecoin, and it was initially proposed to the Aave Dao in July last year and it's launched on the Ethereum Girly testnet and is also on the. Sepolia testnet.
00:52:37.230 - 00:53:57.366, Speaker F: Firstly, to fully understand why Go was built, we should touch on stablecoins briefly, just because they play such an important role in the DeFi ecosystem, they offer a fast, efficient and borderless way to transfer stable value on blockchain. So probably wondering why build Go when there are so many stablecoins out there? So there's been demand from the ecosystem for a decentralized ave native over collateralized stablecoin, just because of the reasons I said before, it's a great way to transfer stable value across the blockchain. So Go contributes to the RA Dow treasury as well, with repaid interest directed to the Dao rather than asset suppliers as it normally would be on the RA protocol. With the RA community's support, go has the potential to become a leading decentralized stablecoin. So what is Go? So, as I said before, the kind of lengthy definition we have RV protocol native. So Go fits natively into the existing RV protocol as a new asset. So when the team was building Go, it was clear that there was a lot of functionality already in the existing protocol.
00:53:57.366 - 00:54:39.366, Speaker F: So this is things such depositing, collateral and liquidations. Go is decentralized, so it does not have one single point of control. It will be fully governed by the Rvdao. This means that they will make all decisions relating to Go. So for example, Go is not an algorithmic stablecoin and the Aavedao will set the interest rates. So again, on this point relating back to how Go fits natively into the Aave protocol, it means that Go can actually leverage the existing RV governance framework and the access controls. So this doesn't only provide transparency, but it provides verifiability.
00:54:39.366 - 00:55:31.110, Speaker F: So you can see the governing rules and policies that will be approved and executed on chain. So Go is overclateralized. So this just means that users must supply assets more than the value of Go to be minted. So in this case, as Go will be pegged to one to one with the US dollar one, go will be backed by more than $1 of collateral. And this model has already been proven within the ecosystem and this will work as a stability mechanism. So basically, when you're supplying more Go, more collateral than the Go that you're minting, this excess collateral acts as sort of a buffer, like a cushion in the event that the price of a stable coin will fall below the target value. Go is also multicolateralized.
00:55:31.110 - 00:56:51.662, Speaker F: So in terms of the assets that a user might supply as collateral sorry, as opposed to with other stablecoins that you might mint a stablecoin using one specific collateral type in a vault, users can actually mint Go based on their entire set of digital assets across the Arvo protocol. So as we now have this diverse range of assets, this mitigates the sort of concentrating on one type of digital asset, just backing Go. So how does Go work? Go is an ERC 20 token designed to maintain a stable rate pegged to the US dollar despite market volatility. So it follows the same process when you're interacting with the RB protocol, you supply collateral, then you can borrow Go and then repay the Go debt. As Go is over collateralized users must, as I said, must supply assets more than the value of Go to be minted. And Go is also designed to accrue interest when it is borrowed. So as I mentioned the Ave Dao before, they make all the decisions relating to Go.
00:56:51.662 - 00:57:49.670, Speaker F: So this can include the interest rate, this is the collateral that you can supply and any changes to it as well. So a new concept that has been introduced when building Go is the concept of Facilitators. So a Facilitator is essentially they have permission from the Rvdao to mint and burn Go and each facilitator is assigned a maximum bucket capacity. So how much Go they can mint from. And so in the latest RV governance development update from the RV companies, it's been recommended that the RV Ethereum V Three pool will be the first to facilitate to launch Go. So you'll be able to mint and burn Go via the RV V Three pool. And this is due to the already extensive risk mitigation features that are already through the RV V Three pool.
00:57:49.670 - 00:58:39.334, Speaker F: And so if you are actually hacking and you're not just here for the tickets, how do you integrate with Go? So if you're looking into the smart contracts, you can get started with the Go contracts. There's loads of links online, so I'll link them later on Discord and on Twitter. And you can make use of the NPM packages available. So there are two or three packages for the Aave protocol and then there's one for Go. You can install it into your repository and it doesn't matter if you're using Hard Hat or foundry, you'll have access to all the contracts there. If you're building a front end, you can use the Aave utilities JavaScript SDK. So this is a really great way to fetch data and transform it.
00:58:39.334 - 00:59:20.710, Speaker F: It's really simple to use and you can use it for your front end. And then also if you're looking at the data analytics, you can use the subgraph for Aave and Go. Now to look at some JavaScript examples of how you could use the JavaScript test UK. So as I mentioned before, you have to supply collateral before you can borrow mint Go. So here, this code uses the Bsdk. So in this case we're making use of the deposit function in the Re protocol. We need to pass all the parameters.
00:59:20.710 - 01:00:07.874, Speaker F: So for example, here we have the user address, the user address, the address of the reserve that we're going to deposit into the protocol, the amount you want to and how much and on behalf of which is sort of a unique variable where it's just who you're actually supplying for. And then after you've supplied the collateral, you can then borrow Go. So as you can see, some of the parameters are the same or very similar. And it's important to note here that the interest rate mode is a variable. So at launch, the RV companies is proposing that there'll be a fixed rate. But just given the implementation of the Go reserve, it's a variable debt. Sign here.
01:00:07.874 - 01:01:07.156, Speaker F: So just to note that there if you are integrating, okay, and then if you need to repay some of the Go debt. So if you've been using the RV protocol before, you'll know about health factors and that if you repay your Go debt, you will be able to increase your health factor. And this helps to mitigate any liquidation risk that you might incur. So again, very similar. You just input the correct parameters and should be good to go. So if you aren't wanting to use the SDK and you're looking more into the smart contracts, we're going to just do a really quick live demo of so here we have a repository which again, I'll link online and in the discord channel as well. So a lot of it is already we're just going to set this up really quickly.
01:01:07.156 - 01:01:34.480, Speaker F: I've already set this up quickly. And if you want to, you can just follow the get started. Yeah. So you can follow this get started bit here. So it just helps to get this sped up. So we're just going to test, we're going to create a test file and just test Minting Go. So here we've initialized the contract already.
01:01:34.480 - 01:01:52.440, Speaker F: So we're going to use dive collateral. This is the pool contract from the RV protocol, which is kind of the main contract that you would interact with. And then the Go token contract. Again, there's like a setup here. So you're running the girly fork testnet.
01:01:57.530 - 01:01:58.280, Speaker G: Sorry.
01:02:03.690 - 01:02:49.816, Speaker F: Can everyone see that or do you want it bigger? So, sorry. So here we're going to test Minting Go. So as I said before, you have to supply collateral. So we're going to supply die using the Ave contract. So as you can see here, we need the asset and amount who we're supplying on behalf of, and then the referral code, which will just be zero. So we can say that we are supplying to the pool. We need the address of what we're going to supply.
01:02:49.816 - 01:03:44.610, Speaker F: So that is going to be dai. And then sorry, you can see all my favorite ones. We're going to say that we are the user. Sorry, I should have said before, we've already initialized our address, so we're going to be the user here. Okay. So to use the RV pool, we will need to approve the dye funds that will go in. So dye approve and then approve the pool.
01:03:44.610 - 01:04:51.320, Speaker F: Okay. And then we're going to mint Tango. And as I said before about the variable, the variable mode. So this is going to be set to two because of the way that it's implemented in the contract. So we want to borrow Go. So we're just using the same tokens that we initialize above. So we want ten variable mode two, and then because we are mincing it as the user, and so we want to send ten to our friend Ronnie so we can initialize the Ronnie address and we will just random address, and then we're going to transfer the ten go to Ronnie.
01:04:51.320 - 01:05:06.370, Speaker F: I assume you all know for Rabbi that it's Ronnie. Okay, so let's save that and then just test. Okay. Yay, it worked.
01:05:08.180 - 01:05:09.170, Speaker G: Thank you.
01:05:11.140 - 01:05:34.040, Speaker F: I didn't think you would actually clap like it's fine. Okay, so as we have sent ten Go to Ronnie, ronnie says thank you. Buy Ravi tickets, QR code, everyone. You're all flakes just to say.
01:05:41.540 - 01:05:42.290, Speaker E: Yes.
01:05:44.100 - 01:06:29.456, Speaker F: Put in do I have time to test it? Type Script JavaScript SDK anyway oh, sorry. Okay, 54321. Okay. This also doesn't guarantee tickets, just to tell you, so you might not get.
01:06:29.478 - 01:06:30.050, Speaker C: One.
01:06:32.500 - 01:07:21.456, Speaker F: For the actual hackathon. We have $10,000 for the best projects on RV and Go with first 3502nd, 2503rd, 1500, and then the five best Go integrations will receive $500 each. And then also for the best projects that build on RV and Go, you may also get Ravi tickets. So if you've not been successful now, build on RV and Go and then we can hopefully get you set up. So we have some ideas here. These are all linked in the ETH Global Prizes page, so it's just some ideas of what you can get started on. We really want people to build look into payments, so like create an app or a plugin to buy and pay with.
01:07:21.456 - 01:07:50.744, Speaker F: Go anywhere. We're really interested in what you can come up with. I know a few of you have come over and said about account abstraction, so that's really great. We're really interested in that. And there's so many different things that routes you can go down on the Aave side. Again, there's so much here health Factor Simulator would be really good to see because if you use Aave regularly, you'll definitely know how important this Health Factor is. Governance visualizations.
01:07:50.744 - 01:08:29.930, Speaker F: It would be great to see what aspects that you can look at from Ave governance and ZK Proof. Definitely looking to utilize ZK proof. Sorry, that was not accurate. And so, yeah, this is not a Ravi ticket. This is a link to all the resources on the East Global Prizes page. So we've got all the links for the prizes, the ideas that we have tons of resources for, all the docs and I will link everything in Discord as well. So thank you all very much for coming.
01:08:29.930 - 01:08:46.350, Speaker F: We have a big RV N team here, so if you want to come to the booth, come and grab some swag and we're here to answer any questions. We'll also be here tonight as well, later on, if you want to talk through any projects. Thank you very much.
01:10:15.200 - 01:13:35.470, Speaker A: Sam. It it.
01:15:54.020 - 01:15:58.770, Speaker B: Are we good? Not yet. Okay.
01:16:00.420 - 01:16:01.600, Speaker E: Hello, Jeff.
01:16:09.250 - 01:16:32.740, Speaker B: How is everyone feeling today? Excited? The hike? Yeah. Nice. We're good. Okay, cool. Okay, so today I'm going to be talking about Lens Protocol and I want to introduce myself. I'm natter Dabbit. I'm the Director of Developer Relations at Ave and Lens Protocol.
01:16:32.740 - 01:17:13.184, Speaker B: I've been a developer for about eleven years. I've been in the traditional space for about nine years, like non blockchain, and I've been in Web Three or blockchain for a little over two years. And today I'm really excited to just make a quick announcement. We launched the Lens SDK, which is a really, really big deal for us. So the, the workshop that I'm going to be giving at the very end is a very short workshop, mainly because the Lens SDK lets me do this in just a couple of lines of code. If you want to try it out, you can check out some of the links that I'm going to share. Later you can go to our Twitter and see the blog post that kind of goes over this huge team effort from everybody at Lens and Ave, from design to engineering.
01:17:13.184 - 01:18:03.236, Speaker B: So we're really proud of what has come out of this. And hopefully you'll really kind of like how it allows you to really quickly build and get started without a lot of code or without blockchain knowledge, which is the big deal. And at the end, I'm going to be doing a quick workshop that is a code along from scratch, building a full stack application with NextJS server side rendering, routing, everything. And it's a really great way to get started with Lens, along with some of the tutorials that we have in our documentation. This is all the code that you'll need to build what I'm going to build. So example code base is there along with a step by step guide. So with that being said, I want to talk about Lens and I want to answer the question of what is Lens? And I think the most succinct way to put this for the just general average person is it's the social layer of Web Three.
01:18:03.236 - 01:19:05.032, Speaker B: But here I'm speaking to developers, so I want to describe it more from the terms of how you might build with this and with it being a social protocol. We offer not only the actual underlying infrastructure at the blockchain level that you might assume would be there with a Web Three product, but also a suite of tools and APIs that allow you to really easily and quickly build social applications or integrate social features into your applications without a lot of code and without needing to manage the back end infrastructure. And this is a big deal because we talk about mass adoption in Web Three, but a lot of the use cases that come out are actually really targeted back at us. Like we're big blockchain maxis often and we like dealing with tokens and we like doing all this stuff. But when we get outside of our bubble, we realize people just want to use highly polished applications that bring a big value proposition to them and therefore we need to kind of build for those people. And with social there are 4.9 billion people that are using social applications today.
01:19:05.032 - 01:19:48.344, Speaker B: So when you think of building for the masses, you need to think of a use case that will appeal to the masses. And this use case obviously resonates, but it's one thing to kind of have an idea and another thing to actually build and execute and have a product that allows people to actually use it and for developers to build on it. And that's really what Lens is. And when we think about social applications, we're not only talking about Twitter, TikTok and all these other things that we consider social apps. When you start diving into the average application that you use on a daily basis, you start realizing that there are social features built into so many of the apps that we use every day. GitHub has a way for you to follow your friends and see the feed of the apps that they're building. Things like stack overflow again.
01:19:48.344 - 01:20:44.660, Speaker B: I'm speaking to developers, have social features and social components kind of built in. And instead of having to kind of build out all of those things from scratch, you can easily start integrating these things using a managed infrastructure like Lens, similar to how you might use Auth Zero to implement authentication in your traditional web. Two applications. Or you might use serverless functions to implement some type of custom executable code without running your own servers. You can use Lens to implement social features without building or maintaining or dealing with any of the backend infrastructure. And that's what I want to talk about now, is like, how does this actually work? And really to kind of make this succinct, you could think of the base layer of Lens being a set of smart contracts deployed to polygon, but the value proposition really comes from all the things that have been built on top of that as well. Things like a really simple to use API that gives you a lot of flexibility on querying the data and getting different selection sets for the data that you want to present to your users.
01:20:44.660 - 01:21:32.756, Speaker B: GraphQL is what we use and this allows you to choose and filter and do sorting and pagination all these things that you need for a polished UX like Twitter. When you think of a smart contract, you're typically limited in what you can do there. You have a couple of API calls, but you can't say give me the last hundred users that have signed up that live in this city. That first name starts with P that have all these different characteristics similar to how you might query a database. You can't really do that with traditional blockchain applications, but with our GraphQL API, you can. We also have implemented gasless and signless transactions for users to use your application without having to pay gas and without having to sign transactions. And those are like, the two, in my opinion, biggest barriers along with wallet.
01:21:32.756 - 01:22:16.788, Speaker B: UX for the average person to actually start using these applications, when you tell a user, hey, I launched an app, go use it, you could excite them about it. But once they open the app and you're like, oh, by the way, you have to go and buy tokens, and then you have to transfer them to this network, and they have to be on the right network, and they have to be the right token on the right network, and then you have to create a wallet. This is a massive, massive barrier to entry for most people. What if instead we were like, you can just go use the app. I mean, that's kind of like, where we want to go. And in the past, this wasn't really possible, because transactions cost a dollar or $5 or even ten cents per transaction, and at scale, that just doesn't make sense. But with our infrastructure, we recently even rolled out a more scalable infrastructure called Momoka.
01:22:16.788 - 01:23:01.060, Speaker B: The last 65,000 transactions have cost $26 combined, which is less than a single Ethereum transaction on a bad day. So at that scale, you can start thinking of subsidizing transactions. The same way that AWS and Google are being used to subsidize transactions on Twitter and Instagram. There is an infrastructure cost, but they're not offsetting it by asking the user to pay for it. They're dealing with that themselves, and the user gets to use the app for free, and everyone wins. Signless transactions are also a big deal every time you make an interaction, you don't want to have to sign a transaction. With Lens, all these actions are covered and handled by a dispatcher, which you can enable and disable for non financial transactions, which are things that you shouldn't have to worry about.
01:23:01.060 - 01:23:50.144, Speaker B: If you post something, it's not a big deal if it's just a comment or something, but it's not something that will ever enable a financial transaction on your behalf. And then the developer experience. As a developer that's focused on devrel for a long time, this is the thing that I get the most excited about, because we focused a lot around developer experience, and we continue shipping new products and updates just like today with a Lens SDK. And I want to go over some of those things I mentioned. The Lens API, which is just a really great way to query for your data at the very base level, gives you a ton of flexibility. Pretty much anything you want to do, any selection set you want, for the most part, is available there. And then to make that even easier, we've recently, as of today, officially launched the Lens SDK and this is kind of how the Lens SDK fits into the stack.
01:23:50.144 - 01:24:16.376, Speaker B: I mentioned the set of Smart contracts, which is the Lens protocol base layer. And then we built the GraphQL API on top of that. But to use GraphQL there is a learning curve for certain developers because you have to actually understand how to query for the data. You have to deal with setting up a client, things like that. And also the queries can sometimes get kind of verbose. They can be tens of lines of code or even hundreds of lines of code. So the lens SDK sits on top of the GraphQL API.
01:24:16.376 - 01:25:00.190, Speaker B: So you don't need to know anything about GraphQL and you can actually query the data from the Lens API with this many lines of code import call a query, you have the data coming back. And this is what we're going to be using in the tutorial that we do in just a moment. We also have the react native Lens UI kit. Some of the most successful apps on Lens are mobile apps and we want to make it really simple for people to build mobile apps. So also with as few as two lines of code, you can start building mobile apps. A couple of the apps that have been winning hackathons have started bootstrapping their app using the react native Lens SDK and have moved on to kind of continue building and iterating and even getting funding and stuff like that. So this is a really simple way to kind of bootstrap a mobile app with only a handful of lines of code.
01:25:00.190 - 01:25:48.284, Speaker B: We also have a way to do integrations. So the Lens SDK and the react native Lens UI kit and the API are mainly done to actually build social applications, though they can be used for integrations, but the widgets are focused at mainly integrations. So if you want to say, I want to add a sign in with Lens button to kind of have this digital identity layer without having to build it myself, or I want to allow a share to Lens button. So I can get a large number of people their eyeballs on the thing that I'm building without having to kind of build my own distribution channel. You can do this also with about two lines of code. So we have Share to Lens sign up with Lens follow on Lens. We have publications that you can kind of drop in, similar to how the Twitter have twitter embeds all types of stuff there.
01:25:48.284 - 01:26:33.416, Speaker B: You can embed profiles and a lot of things. And the UI for this looks really nice. These are actual pictures of what it actually looks like when you render that. So there's a lot of pre built design in, but you can actually configure it by passing in props and things like that. And then finally, what we've been really excited about lately is the Lens BigQuery API and data set which was released a few months ago, that has all of the data from all the transactions and interactions that have happened on Lens available in a BigQuery data set with over 50 different tables that you can query from. So people are building AI and machine learning and all types of recommendation algorithms on top of Lens now using this. And the great thing about this is you don't have to really be an expert at anything to get started with this.
01:26:33.416 - 01:27:18.244, Speaker B: All you have to do is actually go to Chat GBT and say, hey, how can I create this query on BigQuery? It'll literally give you the code and you can paste it in and people are starting to build some really cool stuff. And another thing that we're seeing adopted a lot is direct messages that are encrypted using Xmtp. This is a really great protocol, you don't need a lot of code. And the cool thing about this is all of the messages are interoperable between all of the Lens apps using a special namespace that we have, that has been adopted by most apps in the ecosystem. And people are even building like a unified inbox. So you could think of what if Twitter, Instagram and TikTok and all of these different apps all shared the same messaging protocol so you didn't forget where the message left off. Every day I meet someone and they're like, oh we talked.
01:27:18.244 - 01:27:58.944, Speaker B: And I'm like, where do we talk? Telegram, slack. I forgot and one of us forgot. But what if it was all in one place? And this is kind of what's happening with Xmtp and Lens ecosystem. I would say beyond that I'm going to just talk about composability and extensibility a little bit. Because these are like a couple of core things that are not really Lens specific, they're more like Web three or blockchain specific, but they shine really well with Lens. So with Lens you can actually build in custom functionality into the protocol itself. Almost like if you wanted to send a pull request to Twitter and you knew that you could actually get a feature added, or if you wanted to add a feature to Instagram, that's kind of what's enabled through custom modules.
01:27:58.944 - 01:28:50.708, Speaker B: So a custom module really is wide open for anything on chain. So you can program things like you have to be following my friend to follow me or you have to have collected one of my NFTs. There's a lot of stuff that you could think of that can go here. So an example of what this might look like is this is an app that has implemented a few of these custom modules and you can program and specify all these different functionalities optionally for someone wanting to publish any type of publication to a Lens app. So in this example, you can optionally open this window and say, hey, the person that is collecting this has to be following me. And it's going to cost one dollars and I'm going to limit this to 50 of them. Or with something like Waves, you can say I'm going to put $10 into a campaign and everyone that mirrors this gets one dollars.
01:28:50.708 - 01:29:31.388, Speaker B: But they have to have at least 1000 followers. There's a lot of things that are happening there that are becoming really interesting. Another example is split revenue. So let's say you see someone has built something or you want to do a fundraise for someone and you both have split the work or whatever scenario you could think of, you could put all these different addresses into a publication and you can say I'm going to split the revenue from every collect here. And all of that revenue gets split immediately when a collect happens because it's on chain, it's just all permissionless and there's no middleman and it's really simple. So beyond that composability. I'm going to speak about composability from the developer's perspective, but also the user's perspective.
01:29:31.388 - 01:30:05.820, Speaker B: From the developer perspective, I've mentioned this idea of managed infrastructure. I just want to underscore this. This is kind of huge because when you're building a startup, it's very expensive to hire devs today. And it's also very kind of hard to find high quality devs. And most dev teams need a front end and a back end team at the least. And a back end team often includes infrastructure engineers, DevOps, back end APIs, like all of these are often separate skill sets. But instead with a managed infrastructure like Lens, you don't need anything on the back end, you only need front end.
01:30:05.820 - 01:30:46.216, Speaker B: And therefore you're eliminating a large number of devs that you need on your team. Or if you take that same number of devs, you can focus more on building a higher quality polished front end. So we have developer teams of one shipping amazing apps like Butterfly on Lens that are just really great and you would be blown away that there's only a single developer on some of these teams. So that's a big thing I wanted to kind of point out there. And also you inherit the existing user base and ecosystem of Lens. So if you are trying to bootstrap an audience, it's often kind of hard. But with Lens, when you launch, you have that built in 100 x thousand number of users today.
01:30:46.216 - 01:31:33.464, Speaker B: And then in the future, as we onboard a lot more and scale that up, you're starting off with a big number of users instead of having to kind of start from scratch, which is a big deal for a lot of developers. And then on the user side, there's a couple of different things that are a big value prop not being able to lose your account because some random person decides that you said something wrong or your government shutting it down or whatever reasons. But the really cool part is that every single app that comes online, you're now bootstrapping that. Audience across that app. A good example of this is if you built a big audience on Twitter or YouTube and then TikTok came out, you're starting from zero. But every time a new app on Lens launches, you're starting from X number of followers and you're building upon that. And the outcome of this is that every time a new experience comes online, you can choose to buy into it or not buy into it.
01:31:33.464 - 01:32:19.912, Speaker B: And you have a new way to be creative without losing your audience. You could just try some of these apps out, see how you like them. There are around 100 or so apps that are live today that I would consider like somewhat high quality that you can try out next. I'm going to touch on the technology stack and then we're going to jump into a demo and then we've done. So when I talk about the technology stack, I've already talked about that from the protocol level, I want to talk about more from the user. Like if you're a developer, what's your tech stack going to look like? It's going to look very similar to what you've probably done in the traditional blockchain space in some aspects, but you can also, again, abstract some of that away with like the React Hooks SDK or the react native Lens UI kit. There is one area that you will need to deal with that isn't built in just yet, that I know of.
01:32:19.912 - 01:32:58.580, Speaker B: It's uploading metadata to store it in a permanent way, or to store it however you would like it. So if you're posting a publication, almost like if you're creating an NFT, you have to publish the metadata that is for that publication somewhere. Most of the time we recommend using Bundler with Rwev because it's very fast and it's permanent. You could also consider using something like IPFS. We have a lot of apps building live video streaming or just video applications using Live here, and that's being adopted more and more. And that's something I would also recommend if you're looking to build a video application. The traditional libraries for making actual contract calls are often used.
01:32:58.580 - 01:33:24.780, Speaker B: So if you want to use Ethersjs, Wagme, Rainbow Kit, all that stuff works great. On the front end, we're seeing Flutter apps, we're seeing native iOS apps. React native is a big deal. There's a lot of people building react native apps. So anything that you want to build on the front end, that's pretty much supported. I don't think we really have a lot of Flutter support on our end, but we have a lot of high quality Flutter apps that are out there. They're just using existing libraries that facilitate API calls.
01:33:24.780 - 01:34:07.188, Speaker B: So I want to touch over a couple of the major concepts and then this will be it before we do the demo. So who here has used Lens, by the way? Okay, cool. And if you're a developer, by the way, and you want a Lens profile. Come down to the booth, we'll get you set up. So the main cornerstone, I would say, of Lens is kind of this idea of a profile, because the profile is what everything you end up doing is attached to, and therefore you can kind of take this and move it around and have somewhat ownership over it. So the profile is like your username and then the comments, posts and stuff are essentially attached to this profile. And then under a profile, you will create a publication.
01:34:07.188 - 01:34:46.052, Speaker B: And a publication is either a post, a comment, or a mirror. This is just data that you're publishing to the network. And this is essentially a content Uri that's attached to the publication that has all the content that's associated with that. Again, I recommend something like Bundler with Rweave because it's permanent and immutable. But you can also use something like IPFS and you can do a lot with publications. One of those things is Gated access built directly into Lens SDKs, or this ability to build out a gated publication. So you can say all of my posts are public by default, but for this one, I might say, if you're part of developer Dow, you can read this, but everyone can't.
01:34:46.052 - 01:35:26.608, Speaker B: Or maybe you've collected my NFT and this is for my NFT holders. All that stuff is optional with the gated access. And then collects are kind of how you take a publication and turn it into an on chain artifact. So every publication isn't actually like an NFT, but if someone collects that, then it kind of turns into an NFT and therefore you can add a lot of rules around collecting. You can say, I want someone to pay me a dollar to collect this, or I want you to be following this person, or whatever. A couple of examples of really cool things that have happened recently on Lens. An artist that is a musician had an old MP3 or something that he created five years ago.
01:35:26.608 - 01:35:56.456, Speaker B: He was like, hey, I just want to put this out there if you want to support me, this is one of the songs that I made early on. It's a dollar to collect. He had like 3500 people collect that it took him five minutes to post. He made $3,500. A really great way to connect to his audience and a really great way for the audience to kind of support the creator. And for the 3500 users at scale, you would think, oh, a dollar collect. Like, that's not a big deal because people are used to like $5,000 NFTs.
01:35:56.456 - 01:36:28.100, Speaker B: But at scale you can say something could be ten cents or fifty cents, and you can actually have a reasonable amount of collects that would make up a value proposition for an individual. So with that being said, I want to jump into the demo. The GitHub repo for. This is@github.com David three lensprotocolworkshop. It looks like this, and I'm going to just start off with this empty NextJS application. And what we want to do is we want to use the Lens SDK to build out a social feed.
01:36:28.100 - 01:37:08.070, Speaker B: Oh, it looks like my thing is off. Sorry about that. Okay, I see. Okay, got you. It looks like I need to just change the display mirroring. All right. Actually, I need to do something else.
01:37:08.070 - 01:37:37.680, Speaker B: All right, there we go. Okay, so this is yes, GitHub repo, GitHub.com Davit three. At the very top should be the Lens Protocol workshop. And this has everything you need to build out a Next JS app from scratch with server side rendering and routing and everything like that. And we're basically starting off from this empty Next JS application. This is kind of what you might expect.
01:37:37.680 - 01:37:56.402, Speaker B: And we want to just open this code base. And it is what you would expect from a TypeScript project with Next JS. Nothing really going on yet. I want to start just by importing the react native. I'm sorry? The react lens. SDK. One of the different APIs from there is called Use Explorer Profiles.
01:37:56.402 - 01:38:31.780, Speaker B: This will just return a recommendation algorithm type of preset for you to get a bunch of profiles. And by default, it will give you a selection set. But you can also pass in props to identify and define what you want to come back. But at the most basic level, it's very simple to use. You could say Const data, and then you also have this loading variable that you can use. And you could set that as Use Explore profiles. And then we might just log out this data just to kind of get a view of what this data looks like.
01:38:31.780 - 01:39:22.010, Speaker B: And then one other minor modification I need to make is because Next JS recently moved to version 13, you have to define a client side application by saying Use Client. All right, so our app is loaded. Obviously nothing's changed because we haven't updated our user interface. But already with two lines of code, we have this data that's coming back. We have ten profiles that have come back from the recommendation algorithm, and we can even say, okay, I want to actually limit this to 25. And now when the app reloads, we should have 25 come back. Let's see if that works.
01:39:22.010 - 01:39:51.970, Speaker B: Maybe. There it goes. Okay, so we have 25 profiles coming back. Now I want to actually render these profiles to the screen and show the metadata associated with each profile. So I'm actually going to go back here and delete a lot of this code. And we kind of want to start from scratch. So I'm starting over, essentially from this empty component here.
01:39:51.970 - 01:40:24.420, Speaker B: I'm going to go ahead and import a couple of things. We're importing that same use Explorer profiles API. We're importing a link which allows us to link to pages from Next JS and then this format picture utility, which allows us to format an IPFS hash or an Rweeve hash into a gateway. And actually, I think it would be nice for us to build this into the SDK at some point. But for now, we're doing it manually. But essentially it'll just say IPFS hash. Okay, we want to say Ipfsgateway IPFS hash.
01:40:24.420 - 01:41:10.216, Speaker B: It's just a very simple function. And then once we have all those things, we're going to create the body for this. And if you look at this entire component, it's 38 lines of code, including a couple of white spaces. But to start off, we're just taking the data that we're getting back from the Use Explore profiles, and we're limiting that to 25. And then we're just rendering those in our app by mapping over the data, returning the profile image, and that's about it. So if I save that and I go back to my app and I reload, we now have a social app, and the data fetching part of this was only three lines of code, including the imports would be four lines. But we already have a very nice selection set of data coming back, and there's a lot more data that's with this.
01:41:10.216 - 01:41:49.904, Speaker B: So you have like, the COVID image of the user, a lot of other metadata about that person. So that's the simple intro, because I don't have a ton of time. If you continue with this workshop, you can actually drill down and click on a profile and view the metadata in all those publications for that user. And I think I'm running out of time, so I'm not going to go into that. If you want to learn more about Lens, definitely check out the Lens documentation at docs lens XYZ. If you want inspiration for other apps that are out there, you can go to Lens Xyzapps. If you want even more inspiration about what we want to see built, you can go to Lens XYZ apps and click on Lensverse.
01:41:49.904 - 01:42:10.270, Speaker B: There's a hackathon entire section there. There's a lot of ideas that we'd like to see there, and there's even links to things like our grants program and stuff like that. If you want to see some of the most recent updates like we made, including the Lens SDK announcement, you can go to Mirror XYZ, Lensprotocol ETH. And that's it. Thank you so much for checking out my talk.
01:42:28.440 - 01:45:23.540, Speaker A: Sam. Sam. Nam. Sam. Sam.
01:46:28.180 - 01:46:55.720, Speaker E: Hi everyone. Okay, today I will be talking about subgraphs that are fed by substreams, which is a new technology by the Graph built by one of the core teams of the Graph streaming fast first. About me. My name is Sahra. I am a med student at Wilkins University, Turkey. I'm from Turkey. I also work as a developer at Graphops, which is another core team at the Graph.
01:46:55.720 - 01:47:46.840, Speaker E: Today we'll be talking about what the Graph is and then bounties quickly about subgraphs. And then we're going to compare the subgraphs with substreams and then talk about substreams and subgraphs back by substreams, which is the main point of this workshop about the graph. Graph is the data layer of web3. It allows you to index and query blockchain data and we'll see how it does that in detail in a moment about the prices. So if you build a subgraph or use an existing subgraph, you might be eligible for Bounties. And also if you use substreams or deploy your subgraph to the subgraph studio, you get bonus points to use substreams you should pay attention because I'll show you how. So the subgraphs very quickly, they are in ETL process extraction, transformation and load of blockchain data.
01:47:46.840 - 01:48:07.420, Speaker E: And the way they do it is, I mean they consist of three components. The first is subgraph. YAML, it's the manifest file, which is the configuration file. Here we see that we are listening to Ethereum, you can see it here. And subgraphs listen to the contract events. So we have to specify which contracts we are listening. We have one contract here, which is the GRT contract.
01:48:07.420 - 01:48:41.288, Speaker E: In my example, GRT is the token of the graph. And then for each event we have a handler which transforms the event data to the entities we want in the schema in the store of the subgraph. Here we are seeing a simple handler. It takes the event data and then populates the fields of entity. In the schema we define the shape of the data we want in the store. As I said, okay, substream is a new technology and if you know about subgraph, it might be a bit confusing. So we're going to compare them.
01:48:41.288 - 01:49:09.888, Speaker E: As I said, subgraph is an ETL process, the whole thing extraction, transformation and load. But when it comes to substreams, I write their Et. But actually it's the transformation layer. But extraction also comes built in if you are developing substreams. The extraction happens by firehose and other technology developed by streaming fast and transformation is done by substreams. But there is not necessarily a load layer. So you have to define where you store your data at the end.
01:49:09.888 - 01:49:47.464, Speaker E: And we call them syncs in substreams, that's the term that we use. And in my case, my sync will be a subgraph. That's why a subgraph head by substreams, that's the name. And another difference is that subgraph handlers, the functions that transform the data, they are written in SM script, but in substreams we write them in run. Also, substreams are composable. So substreams consist of modules, many modules that transform and filter data. And if you have a module or even the whole substream developed and then processed, you can reuse it and other developers can use it as well.
01:49:47.464 - 01:50:24.820, Speaker E: And substreams are parallelizable, which means that let's say you're processing, I don't know, 2 million of blocks. You can process the first million in parallel, the second million, which makes things a lot faster. That's why they are faster. I mean, one of the reasons why they are faster than subgraph. Also in Subgraph case, you can only listen to the events and maybe occasionally make contract calls. But in substreams you have the whole block data, which is my favorite about substreams, you have the calls, transfers, logs, even the stored changes. So everything that happens to block you can see in your substreams.
01:50:24.820 - 01:51:08.120, Speaker E: Also since you get the whole block and the block comes with ordinals, so everything that happens has an ordinal has an order in the block. So you know what happened before, what you know, the rank in the block of everything, that's another thing. Now when it comes to substreams back subgraph, we get rid of the mappings where the transformation happens, we replace it with substreams and we keep the subgraph YAML and the schema. But subgraph YAML will look a bit different. I will show you in a moment because our subgraph no longer listens to the block, but it listens to a module from the substreams. substreams, as I said, they consist of many small modules. Here I will show an example.
01:51:08.120 - 01:51:44.736, Speaker E: And this is the module graph of a substreams. We have the block, the block is the input of the map, map transfers. This is a module and this map just filters data and feeds the data to downward modules. And then the other modules do their own transformation and filtering and then feed it to the downward modules at the end. In our example, since it's a subgraph head, by substreams, we have a special module which is called Graph Out, which will feed the data to subgraph store. And I have two more maps, map account and Map Block, total supply chain. That's just for demoing, just showing you how to use stores.
01:51:44.736 - 01:52:15.036, Speaker E: There are functions of stores, but we're not going to use it for our subgraph. So substreams, we have two types of modules, as you can see, maps and stores. The maps, they take bytes as input and then output bytes. And in the meantime they transfer and filter data. And these bytes are encoded as protobuff messages. Here you can see protobuff definitions that you should do if you're a substream developer. You should define what type of outputs your handler will have.
01:52:15.036 - 01:52:50.952, Speaker E: I defined the transfer just to keep it simple. And here you can see the input of my module is the block and the output is the transfer. protobuff I defined when it comes to stores, okay, stores are stateful, but they're not the final store. This shouldn't be confused because in subgrass when we say store, we mean the permanent store, the database. But here we have the stateful temporary stores where your modules will use. So whatever you put in the store will not be queryable or anything. You're just going to use it in your other modules while your substream is running.
01:52:50.952 - 01:53:23.600, Speaker E: Here we see this guy has the value type and update policy. So the reason is that for the value type, every store has a value type because stores consist of key value pairs. So you set it in the beginning and you cannot change it. Every store will have a specific value type. Update policy comes from the fact that as I said, modules can be run like the run time, they can be parallelizable. So if you don't have an update policy, you cannot really merge them. So let's say you process the first million block and then the second million block.
01:53:23.600 - 01:53:44.264, Speaker E: Now they have to be merged. So this is where the update policy comes in. If I have an ad here, this store is going to be storing balances of GRT for users. So the first million block will have a balance for a user, the second million will have a balance. And then we're going to edit because that's how you calculate the balance. So we have different value types. You can check this.
01:53:44.264 - 01:54:09.680, Speaker E: This is from the docs of Streaming Fast. And we also have different update policies. Set if not exist in the Set case, the last key wins and in Set, if not exist, the first key wins. We have the Admin Max and Append. Okay, now let's see how a substream looks like. So we start with the substreams YAML. This is the configuration for the substreams.
01:54:09.680 - 01:54:40.520, Speaker E: And here we defined, I don't know the file for proto imports, et cetera, but the important part is the modules. This is what I showed you before. I have the Transfer Modules store modules, other store and transfer modules. Sorry, map and stores. And here, as I said, you define the valve tag, update policy, input output, everything. And in the prototype file I also showed you this. You define the input output shape of your data in deliveris.
01:54:40.520 - 01:55:08.416, Speaker E: This is where you actually write your modules, the handlers. The first example of a module is the map transfers that we have seen here. The first guy here. So what this does is that we have the GRT token contract. Again, GRT is the graphs token and we just look through all the logs coming from the block. As you can see, the input of this map is the block, the whole block. But I stick to the events because it's more beginner friendly.
01:55:08.416 - 01:55:43.968, Speaker E: But if you want to see more advanced stuff about the block information, I like store changes. If you want to learn about them, I can also show that to you if you come to our booth. So we look through logs here and we just skip everything that's not from GRT token contract. And whenever we see a transfer event, we create a protobuff transfer that we've defined and we output this. Now where does this go? We have seen that here we define input output. So this is where the substreams graph is defined. Here.
01:55:43.968 - 01:56:29.788, Speaker E: This map transfer output is the input of Store balances. Store Balances is where we keep track of the balances of each user on each transfer we just increase the balance of a user if it's to that user and decrease it if it's from that user. That's very simple. But the reason why I have it here is because I want to show how to use the stores in delta mode. So the logic of delta mode comes from the fact that let's say again, you're calculating the balance of a user, but a user might be making ten transfers in one block. Maybe they did a multiple, maybe they have a bot, something like that. And then the value of their key, the account address will be the key, the value will be the balance.
01:56:29.788 - 01:56:59.000, Speaker E: It will be changing ten times in one block. So these are called deltas, the changes in one block. So the whole substreams graph is executed on each block. So that happens on each block. So we have the deltas of the block. If one store changes multiple times, even if it's one, we're going to have one delta. So in a store, when we get the store as an input from another map, this map account gets the store balances as an input.
01:56:59.000 - 01:57:33.264, Speaker E: You can look through deltas. And here, just to show you how we do that, we get for each delta we create an account protobuff. This is just for an example. You wouldn't really do this, but we can run this map account to see what it does. I have map transfers. Let's make Map account and also we can run it or we can use the GUI, which looks a bit cuter. So here this is the output of Map accounts module.
01:57:33.264 - 01:58:06.032, Speaker E: As you can see, there is apparently only one transfer so far. This is right now streaming from the block, by the way. So there's only one GRT transfer. So we see that protobuff here. So if there is any other, I can switch, but there is none and also I can switch from module to module. We can also see map transfers here. It's because map transfers was an input to store balances and store balances was an input to map account.
01:58:06.032 - 01:58:35.144, Speaker E: So all the map is running at the moment, as we can see. There is another we can just jump here, another activity, another transfer, another transfer, another transfer and so on. So it's really fun to use the glee. So let's stop it and continue. We have another mode that we can use. Stores in that mode is the get mode. So with the deltas you can see all the changes.
01:58:35.144 - 01:59:21.600, Speaker E: With the get mode you can have access, do you remember the ordinals you can have access to a specific ordinal, the value of a key at a specific ordinal. So in this example we are calculating the total supply in the first store, that's very straightforward. In the other map, in the other module, which takes that store as an input, we are using the get functions. So here I just created, let's say, let's calculate on each block how much the total supply of GRT has changed. The way we do it is by we have a special function which is Get first, which gives you the value at the beginning of the block, the keys value at the beginning of the block. And this is the key we get at the beginning of the block here. And we have the Get lost.
01:59:21.600 - 01:59:44.504, Speaker E: We also have get. If you know the Ordinal, let's say you want to know the balance of a user at a specific transfer. You would get the Ordinal from the transfer and then ask for the value here using Get. That's another one. Let's not run that. Okay, from here, this is just substream so far. We want to actually build a subgraph fed by substream.
01:59:44.504 - 02:00:17.476, Speaker E: So we did all these transformations and I think you can use this project, it's in GitHub and I'm going to share the link with you. You can use this as a template because there are many files that you have to create and many things that you have to do. I would just clone this and change stuff. So from here we actually want this data to be stored in subgraphs. How do we do it? In a subgraph we have the schema. Again, very simple schema. For today's example, we have the GRT entity which holds the total supply transfers.
02:00:17.476 - 02:00:54.160, Speaker E: Maybe I want to list all the GRT transfers in my front end and the account just balances of each account. Now the subgraph YAML will look simpler and will take Graph Out as the input. As I said, no longer it's not interested in the block anymore, no handlers, nothing. And the way we do it is, as I said, there is this special graph out module. We use entity changes. So entity changes are again protobuff definitions which just go and change the store on each entity changes protobuff coming from the graph out. So let's say your transfer entity, this is the name of the entity.
02:00:54.160 - 02:01:19.164, Speaker E: From the subgraph store, there comes the transfer entity. You give the ID, specify the ID and the ordinal. And then there's the operation here. It can be update, delete, create, but if the entity doesn't exist, it will be created when you use the update operation. So I always use the update operation. And this change function will just update the field of your entity with the new value. This does it.
02:01:19.164 - 02:01:55.880, Speaker E: And the other entity change is using the deltas. It's just updating the balances of accounts on each delta. And this guy is updating the total supply on each delta and the output will go to the subgraph as I said. And eventually we're going to have the subgraph fed by substreams. Now let's run Graph out just to see what it outputs. Again, I'm using GUI. We can also run like use the normal run command.
02:01:55.880 - 02:02:08.796, Speaker E: Let's see. Okay, the graph out, we are seeing entity changes. What happens in this specific block. This is the current number. Current block number. There was a transfer. So we are seeing a transfer entity change.
02:02:08.796 - 02:02:54.060, Speaker E: Of course, if there is a transfer entity change, there will be an account balance entity change and a GRT total supply entity change. So since this is running a bit slow because of the Internet, I don't have any other activity happening until this block. So can stop this. And finally, we will be deploying our subgraph to the studio to be eligible for not only bounces but also get bonus points the way we do it. Let me open Subgraph Studio. Okay, come here. We connect with our wallet.
02:02:54.060 - 02:03:17.360, Speaker E: And here, I already deployed this. But when you create an account, connect with your wallet and let me show you. Just create a subgraph. You're going to enter the name and select the network. This is not really important because you're not going to publish it. You're just going to deploy it. Those are two different things.
02:03:17.360 - 02:03:40.420, Speaker E: You come here. If you already built the subgraph and it's running, you already have the graph CLI. And you don't do this because this is for initializing a usual subgraph. You just skip this. In it, you authoritate the studio and then code gen graph build and deploy. Then your subgraph. This is a subgraph head by substreams.
02:03:40.420 - 02:04:18.086, Speaker E: This is the example I showed you I deployed. It can be created just like a normal subgraph. So to finish, we have where is it? Okay, it was here. We have a QR code where you can see the prices. There are job openings and hickory sources and link to the repo and to this slide as well. Thank you. No, not just on ethereum.
02:04:18.086 - 02:04:38.098, Speaker E: There are also other chains, but they're coming like they are being added. There's solana, I think. And cosmos. Some of the cosmos chains. But the best one so far right now is Ethereum. Okay, I forgot. The question was that is the substreams available only on Ethereum? I forgot to repeat any more questions.
02:04:38.098 - 02:04:39.940, Speaker E: Okay, thank you.
02:06:28.800 - 02:08:10.060, Speaker A: Dam jam. Dam sam don't.
02:08:39.580 - 02:08:40.040, Speaker E: Cool.
02:08:40.110 - 02:08:50.968, Speaker G: I'm just going to go ahead and get started. Does the music still play in the background? Is it like groovy? Okay, cool. Oh, this is very loud. Okay. Hi guys.
02:08:51.054 - 02:08:52.170, Speaker E: I am Em.
02:08:52.880 - 02:08:53.704, Speaker G: Is that too loud?
02:08:53.752 - 02:08:54.012, Speaker E: Okay.
02:08:54.066 - 02:09:24.790, Speaker G: Hi guys. I am Emily. I am the developer advocate for linear. So Linear is a ZK roll up. I'll be going literally from ground zero all the way to let's talk about Arithmetization. What does that mean? So let's break down the segment, right? Linear will be a type two ZK roll up. What does that mean? So starting from the literal base level, right? So blockchain trilemma is essentially a pick two situation, right? So you have scalability, decentralization, and security.
02:09:24.790 - 02:09:43.368, Speaker G: Essentially, you have to pick two of the three, right? So in the case of Ethereum, what they've done is they've chosen decentralization and security. What does this mean then? If we're sacrificing scalability, that is what causes high transaction fees as well as like, what do you call it, slow speed.
02:09:43.464 - 02:09:43.676, Speaker F: Right?
02:09:43.698 - 02:10:12.192, Speaker G: So how do we fix this moving forward? This is the layer two solution. So we've started from the ground. We are going one layer up. Well, actually, I guess one layer up from blockchain trilemma. But now we're talking about layer one. So layer one is the underlying foundation and base blockchain, right? So layer ones take care of your node operators, the producers, the transaction data and the consensus mechanism. So examples, you might have heard of bitcoin ethereum.
02:10:12.192 - 02:10:15.008, Speaker G: I hope you've heard of these avalanche, et cetera.
02:10:15.104 - 02:10:15.700, Speaker F: Right?
02:10:15.850 - 02:10:51.890, Speaker G: And so when we go into layer two, so linear is a layer two. This is a completely separate blockchain, right? So this is the part where we're solving scalability. One thing to note specifically is this piece of data availability, right? So the way roll ups work is they're going to roll up a bunch of transactions and the thing that makes them different is they actually post that transaction data back to Ethereum. So something people often get confused by is like if you've heard of polygon. Polygon is a side chain. So polygon has its own consensus mechanisms. That data is not posted back to Ethereum, so you're not deriving its security.
02:10:51.890 - 02:11:15.976, Speaker G: Obviously this has changed now with polygon Zke EVM, that is a layer two. But polygon proof of stake is not a layer two. So that is basically the layer two solution. There are multiple different implementations of layer twos, but right now roll ups are the most popular. So now that we know what layer twos are, let's actually get into the roll up space.
02:11:16.078 - 02:11:16.344, Speaker F: Right?
02:11:16.382 - 02:11:39.100, Speaker G: So what exactly is a roll up? What is it made out of? So, roll up has a few different components. The first piece is they have an on chain contract. So this is a roll up contract that exists on Ethereum. This stores the roll up box, monitors the state, tracks the deposits. I'll get into deposits and withdrawals. Later you have the off chain VM. So like I mentioned before, roll ups, layer twos help with scalability.
02:11:39.100 - 02:12:07.732, Speaker G: The way they do this is they take the execution layer off of Ethereum. So they do all of this through the off chain virtual machine. And the last piece is like it's a bunch of things operators, validators, aggregators, sequencers. But essentially you can think of them as the people who take all the transactions and then publish that block. So this is the anatomy of a roll up. Like I said, I was going to touch on deposits and withdrawals. So this becomes extremely relevant when we start talking about optimistic versus ZK proofs.
02:12:07.796 - 02:12:08.168, Speaker F: Right?
02:12:08.254 - 02:12:39.428, Speaker G: So asset transfer process. The way roll ups essentially work is you basically lock up ETH on this roll up contract and then equivalent amount of ETH is minted on the L two so then that's when you start using linear ETH or I guess like scroll ETH or whatever, ETH on that L two. The other piece is when you go backwards. So now it's like I've done all this stuff on linear. I actually want to withdraw it back on ethereum. What is that called? It's called withdrawal. The way that works is it's brought onto the ETH on the L two is burned and then released to your account.
02:12:39.428 - 02:13:16.444, Speaker G: This is super key when we start to talk about optimistic versus DK roll ups. So now let's talk about optimistic roll ups, right? So with roll ups, we're posting that data back to ethereum. What does that mean is before we do that, ethereum needs to know whether or not this is true or false, right? So there's different ways of doing it. Optimistic roll ups use something called fraud proofs. So here, specifically, they're called optimistic roll ups because they just assume it's valid. That is a less secure, trust assumption. The way they get around this is they say, hey, there's a seven day challenge period, right? And so in seven days, someone can post a fraud proof to say, hey, this doesn't look right.
02:13:16.444 - 02:13:47.080, Speaker G: Let's prove it true or false. And if it turns out to be false, that will be rolled back. If it turns out to be true, it will be pushed down. So again, this is really problematic for immediate liquidity, right? Because of that challenge period, there are existing solutions like trusted bridges that will do that immediately for you. The problem again is this is a bridge. The other piece is they haven't solved the use case for how do I immediately withdraw, like an NFT, for example. So things you have heard of are like optimism arbitram base, which is built on top of optimism's super stack.
02:13:47.080 - 02:14:25.140, Speaker G: So now we're talking about zero knowledge roll ups. So this becomes relevant for linear, right? So instead of using a fraud proof, you're using something called a validity proof. Specifically, when we're talking about zero knowledge roll ups, that validity proof is a zero knowledge proof. They don't require a challenge period. That information is essentially sent into that proof, generated and then submitted down. I want to note when I talk to a lot of people who kind of aren't familiar with the space, they hear zero knowledge and they immediately think privacy, that's not the case. Zero knowledge proofs in this case for roll ups are just helping for compression of the data, whereas zero knowledge in other cases, that's going to be a privacy thing.
02:14:25.140 - 02:15:17.700, Speaker G: So don't get the two confused. I can talk about that a little bit like offline, or you can ask a question later. But examples include, like, obviously linear, but ZkSync, polygon, zke, EVM, scroll and StarkNet. So now we've covered layer twos roll up, zero knowledge. What do I mean when I say a type two ZK roll up? So first off, we need to talk about what is a Zke EVM? So Zke EVM is that virtual machine that will take that smart contract transaction, utilize the Ethereum infrastructure, and also translate that into a way ZK proofs can understand. So this is actually when I talk about Arithmetization, this is also why ZK rollups came out after optimistic rollups, right? Because ultimately, what is ZK proof is a math proof. How do you translate, what do you call it, computer programs into polynomials that math can prove.
02:15:17.700 - 02:15:18.760, Speaker G: That's really hard.
02:15:18.830 - 02:15:19.304, Speaker F: Right.
02:15:19.422 - 02:15:43.820, Speaker G: And then alongside that, Ethereum itself is not very compatible to being able to translate into these math parts. So this is where the Zkevm comes from. This is where we also start to have the different types. So I'm going to touch on the different types. So at the highest type, that's a type four. This is high level language equivalent. So for those of you who are Ethereum devs, that's going to be writing in Solidity, that's writing in Viper.
02:15:43.820 - 02:16:19.876, Speaker G: This is actually going to be written, compiled down into kind of a different VM, right? So it's not bytecode compatible. What this means for you as a developer is your tools will change a little bit. So how many of you have deployed a smart contract before? Okay, so most of you, right? So you might be familiar with like Hard Hat, Foundry, stuff like that. They are not natively able to handle type four Zke EVM. The workaround there is these people actually have plugins. So you might have seen like a ZK sync Hard Hat plugin, right? That is because they are not bytecode equivalent. Their thesis is like, hey, actually Ethereum is not great for ZK proofs.
02:16:19.876 - 02:16:43.532, Speaker G: We're going to be faster because we're changing it. Right. The next piece is type three is kind of a transitionary stage. This is where most of the type two roll ups are right now. And so by that I mean stark or not StarkNet, Polygon, Zkebm, linear scroll are all going for type two. So what that means is we are language level equivalent. We are also bytecode equivalent.
02:16:43.596 - 02:16:43.776, Speaker F: Right.
02:16:43.798 - 02:17:17.420, Speaker G: So we are the closest to Ethereum, which is a type one. Then I guess if you say as you go farther away. So in terms of, I think the thesis of people or the projects that are chasing type two Zke EVMs is you are taking advantage of the existing developer tooling space. You can change the fastest as Ethereum changes because it is constantly changing. Right. And yeah, that's kind of the different types. So kind of in the sphere of is it still not? Okay, cool.
02:17:17.420 - 02:17:36.408, Speaker G: You can pretend that you saw this. Oh yeah, okay, whatever. It's there. No, well, hopefully you have good memory. So you saw what that meant. But it's basically a graph of, I guess compatibility versus performance, right. So the assertion is essentially the less compatible it is, the easier it is to make it performant, the more compatible.
02:17:36.408 - 02:18:01.940, Speaker G: It is it is harder to make it performant. That is true. I'm going to say I think within the ZK space, the tech is changing. I don't think the assertion that being farther away will make you faster if you just take social proof of people didn't even think ZK roll ups could exist. We are at a place where people are building type two S. There are projects that are also building type ones. That's not the case.
02:18:01.940 - 02:18:41.060, Speaker G: Anyways, I'm going to move to the next slide and you're not going to see it, which is really sad because I have another really cute Kermit GIF. But essentially the slide says the same thing from the beginning. Linear will be a type two ZK roll up. Hopefully all of you know what that means now, right? And so now I'm going to talk about exactly what linear is specifically. Right? So linear is the product of four years of research and development at consensus. We actually started out just doing ZK for kind of like, what do you call payment privacy. And then kind of as we were working on that ZK research, we realized, hey, actually the tech we're building is really compatible with roll ups.
02:18:41.060 - 02:19:07.676, Speaker G: And that's kind of how we moved into that space. Like I said, we are on the way to Zke. EDM it's really interesting because our approver is powered by an award winning ZK circuit library called Ganark. It is open source. It's used by other projects as well. We went public testnet in end of March. At this point, we have over 11 million transactions, 1 million wallet addresses, 196,000 deployed contracts.
02:19:07.676 - 02:19:46.648, Speaker G: So the engagement is huge, right. Cool. So kind of like that's the overview of Linear kind of where you build. So I think something I get a lot is like, there's so many roll ups, how do I choose? So there's a few factors to consider, right? So the piece I said finality, how is that transaction? When can you withdraw it? That's the optimistic versus ZK kind of question, right? So challenge periods, optimistic roll ups have that. That's not the best thing for immediate liquidity. When I talk about liquidity, it's like how much people have already bridged onto the roll up. So my users who are on the roll up already, how easy is it for them to get stuff and interact, et cetera.
02:19:46.648 - 02:20:19.184, Speaker G: The other piece I said is network effects. So this is a lot more so in the sense of as a builder, how easy it is for you to basically develop, adapt. There is a really robust ecosystem around Ethereum already. If you've heard of projects like StarkNet, for example, that start off in Cairo, that creates a whole new world where someone needs to learn Cairo to do smart contract security auditing. So what we're saying right here is like EVM equivalents compatibility. I think that's the winner of something to think about. The last piece is users oh, I have two last users.
02:20:19.232 - 02:20:19.628, Speaker A: Users.
02:20:19.664 - 02:21:09.512, Speaker G: So how large is my addressable audience? So as an entrepreneur, I obviously want to go where the most people are, right? So that's kind of the thing to consider. And the last piece is security. I think, again, leaning back on trust assumptions, optimistic roll ups aren't as trustworthy. I'm not going to say that I feel like that's really spicy. But the next piece is when we start to talk about centralized sequencers versus decentralized sequencers. Where does that fit into the security narrative? I'm not going to dive into that because we're talking about how to build, but essentially kind of how does linear fit into that system? Those images aren't sitting up exactly, but essentially, like I said, Zkebm type two, I've covered why that's cool. I think the last piece that is really interesting about linear specifically, so when we tie into that part about liquidity and user base, right.
02:21:09.512 - 02:22:00.810, Speaker G: Linea is a consensus product. We sit within the same ecosystem as MetaMask infura like diligence our own ETH clients. I think that piece with MetaMask is incredibly interesting as like an L two proposition is we are there already being able to take advantage of the benefits of the most popular web3 wallet, right? So when you think kind of to the future in that sense, I think that's the highest value prop in what we offer. Please tell me if you guys actually care more about how the prover works than how big the audience is, because that would be a really interesting conversation. But anyways, last piece I guess is I kind of wanted to go over what that looks like specifically when we talk about language equivalents, bytecode equivalents, and then VM. So as you can see, the farther you get away, the little bit is different. Ultimately this is kind of where the type two S are living.
02:22:00.810 - 02:22:40.020, Speaker G: And the last piece then is, like I said, on the linear side, we actually don't think type fours will be the fastest. So circling back, right, type fours, their thesis is we have to depart in order to be fast. I think linear, what do you call it, our tech. Right now we're really focusing on the Arithmetization part. So the cool thing about ZK proofs, especially in comparison to optimistic proofs, is you can put a ZK proof on top of a proof on top of a proof on top of a proof and make things smaller and smaller. Smaller, right. So you get infinite scale with ZK rollups recursive ZK rollups as compared to like a fraud proof, for example.
02:22:40.020 - 02:23:04.584, Speaker G: So there's really interesting use cases there. So our thesis is not necessarily that you have to make that decision between type four and type two. So we're going to get into the section of actually how to build on linear. My WiFi has been kind of funky, so I'm not going to do this necessarily live, but I'll just show you kind of the different ways to do it. The slide didn't immediately change. Oh, here we go. So the first thing you need to do is get Linear east.
02:23:04.584 - 02:23:31.444, Speaker G: So there's a few ways to do it. You can bridge it over to Linear girly, east to Linear. The other two second method hasn't come out yet, but we are building an inferior faucet to drip test ETH directly onto Linea. The third method specifically for you ETH lisbon builders out there is I am a Linear ETH whale, so please feel free to leverage me as your faucet. You can find us on Discord. Reach out to me afterwards. I will literally send it to you right now.
02:23:31.444 - 02:24:05.730, Speaker G: Emma's over here, he's BD at linea. He also has a lot, so take advantage of both of yeah, yeah, but only at Lisbon if you talk to me afterwards. I'm just kidding. I'll always be nice to you. But essentially when I talk about the ease of use with a type two ZK AVM, it's literally just swapping out your RPC, right? So when we talk about Truffle, that's a smart contract tool. If you are starting with Truffle, I recommend using their next JIS box. It's basically a full system of smart contracts connected to a front end with tests and everything.
02:24:05.730 - 02:24:45.504, Speaker G: The only thing you need to do actually, maybe I can demo this. I'll show you. Yeah. Okay. Is this big enough? Okay, so this is Truffle dashboard. You can use this with hard hat as well. Let me open up code dev linear demos.
02:24:45.504 - 02:25:04.120, Speaker G: Is this where it is? I don't remember. I'm just going to say it was here. Okay. No, I don't know where I'm at right now, so I'm just going to exit out here. Do this first because I know where that is. Okay, here's the terminal. So I'm going to do a Truffle dashboard.
02:25:04.120 - 02:25:42.976, Speaker G: Here's the thing. So this does deployment through your MetaMask wallet. If you wanted to deploy on Gurley, you would just use Gurley. In this case, you can just switch the network over to Linea. I need to click to connect, and the difference here then would just be CD, Truffle, and then Truffle migrate network dashboard. So this is cool because I didn't have to show you my private key at all to deploy, which is really nice. This is also usable with hard hat, but as you can see, the difference between Gurley and Linear was literally just switching your MetaMask wallet.
02:25:43.088 - 02:25:43.364, Speaker F: Right?
02:25:43.402 - 02:26:01.550, Speaker G: So when we go back to kind of the different tools, the same thing, I don't know how many of you guys use Scaffold ETH. It's pretty common, I think, for hackathon devs, literally just change the default network. Oh, all the screenshots aren't showing up. Okay. I can try and open up the code. We'll see if it's working.
02:26:05.680 - 02:26:06.044, Speaker F: Yeah.
02:26:06.082 - 02:26:25.280, Speaker G: Okay. So basically this is a Scaffold repo. You just change your default network, like Gurley versus Linear or something. You just swap out the RPC URL. So if you look at the girly one, this is what it is. That's a fake infuria API. All I did was say, hey, no, let me rename this.
02:26:25.280 - 02:26:36.840, Speaker G: And that was deploy on hard hat. So kind of the same thing. You can do dashboard with hard hat if you want. And the last piece is Foundry. Download it again.
02:26:36.990 - 02:26:37.448, Speaker A: Wow.
02:26:37.534 - 02:26:50.172, Speaker G: So easy. You just swap it out. Damn. No one clapped with me. That's really awkward. Cool. Okay, so anyways, feel free to get in touch.
02:26:50.172 - 02:27:12.844, Speaker G: There was a QR code with my information, but that's fine. Let me know if you have any questions. I don't know if I have time right now. Okay. I have, like, ten minutes for questions, or we can talk privately, but yeah, that's my information. Feel free to message me for linear ETH. If you are hacking, we have a bounty specifically that says just deploy on linear.
02:27:12.844 - 02:27:45.022, Speaker G: If you're deploying a smart contract, swap out the RPC, ask me or Emma for some linea ETH, and you should be eligible. So, yeah, that is it. Thank you so much for listening. I hope you learned something today. Are there any questions? What's going on? No questions. Okay. We are good.
02:27:45.022 - 02:27:54.900, Speaker G: Thank you so much for listening. I wish you the best of ETH. Lisbon. I hope I recognize your face during judging. Okay.
02:28:07.690 - 02:28:08.418, Speaker E: Emily?
02:28:08.514 - 02:28:09.062, Speaker G: Yes.
02:28:09.196 - 02:28:09.734, Speaker D: Hello.
02:28:09.852 - 02:28:10.520, Speaker G: Hi.
02:30:47.910 - 02:38:33.000, Speaker A: Sam SA sky. You ram. Sam. Sam. It's Sam. Sam Lam. Yeah.
02:39:32.330 - 02:41:43.868, Speaker D: I think we'll get started or maybe give it a couple of minutes, see if so okay, you this mic is a bit hard to use, but all right. Okay, so hello, everyone. My name is Amin. I'm a software engineer, part of Protocol Labs. I work on a project called Filecoin Saturn, and recently we've been using the newly launched Fevm. And I'm here to present a quick intro to Filecoin and Fevm and give a quick demo of some of the cool things we've been building with it. So here is a quick agenda of the kind of workshop presentation today.
02:41:43.868 - 02:42:44.208, Speaker D: I'm going to start with a recap or intro on Filecoin, and then going to give an introduction to the feem and what it's about. Going to give an example, use case of how we use it at Filecoin Saturn and explain what Filecoin Saturn is, and then give a short demo. Okay, so before we dive into the intricacies of Fevm, let's have a quick recap on what Filecoin is. And the de facto term that we say is FalcoIn is a decentralized storage system that is meant to onboard humanity's most important data. And you can think of Filecoin as an AWS without a central entity or company that owns anything. And how does this work? Essentially, it's a peer to peer network that stores files, and it has a built in economic incentive system to incentivize nodes on the network to behave well. And the consensus system is essentially proving that you store things reliably for a given period of time.
02:42:44.208 - 02:43:32.636, Speaker D: And there's some really marvelous cryptography that goes on to make sure that all of this is provable and reliable and basically in filecoin users pay to store their files on what we call storage providers. And storage providers are essentially the nodes or computers responsible for storing these files and proving that they're keeping these files on the network. So, essentially, anyone who wants to store their files or get paid for storing other people's files can join the filecoin network. So let's supplement this with an example. Let's say you have a lovely cat named dolores and you love dolores so much. You think that dolores should remain with the world forever. And you want to upload Dolores's picture to the farcoin network to store it forever.
02:43:32.636 - 02:44:02.696, Speaker D: Now, you choose a nice compression type. PNG is nice because PNG is lossless. And we want to keep every feature of dolores there for people to see. And what you can do is essentially come to the falcon network and kindly ask to store the lorse's picture on there. And what will happen is that you'll be contacted by a storage provider. You can make a deal with that storage provider, there will be a fee for storing it, and you can determine how long you want to store Dolores's picture for, and you pay the fee. And essentially it's on there.
02:44:02.696 - 02:44:46.068, Speaker D: And from there, you can get reliable provable methods that prove to you that dolores'picture will be replicated. And you can retrieve it whenever you want as long as your deal is valid. And it's as simple as that. And hopefully this gives you a better idea of what filecoin is as a network and how it works. This is kind of a more detailed slide of what happens as part of a storage deal. So, if you're a client, you attempt to make like a time limited deal on the FalcoIn network, you will make a deal with a storage provider. Initially, the storage provider will give you an initial proof of replication, and that essentially proves that your data has been replicated on the falcon network.
02:44:46.068 - 02:45:34.072, Speaker D: It's available. And then over time, these providers will essentially give you what's called a proof of spacetime, essentially just proving that they have stored your file and they're storing your file as time moves on. And this is all done by some of the marvelous cryptography that's part of the filecoin network. And towards when the deal is going to expire, you can choose to renew it, or if the deal expires, you can just let it expire and dolores'picture will disappear. So I want to motivate how naturally to come across something like the FVM, like, why do we need it? How does it help? Filecoin so farcoin is great. We can store things. We can retrieve them.
02:45:34.072 - 02:46:10.690, Speaker D: We can make sure that this storage is reliable. But let's think of some use cases. Now, let's say that you're a user that wants excellent user experience. You want to store Dolores'picture, but you don't want to keep renewing that deal. Wouldn't it be ideal if you can automate the renewal of your storage deals that way that whenever a deal expires, you can have just like a subscription, like a paid subscription, and just says, as long as I have funds, let me keep renewing my storage deal. Another example is that you can think of a developer, let's say a developer, you're trying to build an application on top of Filecoin. That's a photo album application.
02:46:10.690 - 02:47:01.904, Speaker D: A natural feature as part of a photo album application will be to add permissions who can access certain album, who can edit images on the album, who can upload images to an album. So if you have a storage network like Filecoin, and you want to build something on top of that, how is that possible with such feature? Another example is, let's say you're a researcher. You're a researcher in machine learning. You want to build a nice model that detects meerkats in your backyard and you have a nice data set for that, that's stored on fogoin. And now you want to train that data set. So you want to outsource that computation and pay for whoever does that computation for you. How can you do so with these examples? What I described, the Falcon network would be really difficult to implement.
02:47:01.904 - 02:47:50.236, Speaker D: And the common theme between these examples is that they need what they call programmability over storage. And that is exactly what the Fev gives us. It enables us to add a programmability layer on top of the things that we store. So it enables us to develop applications that have features like this. And this makes total sense if you think of major cloud providers like AWS. They have storage solutions like RDS, S Three and all that, but they also have solutions that complement and supplement these storage solutions like Lambda Compute, Cloud Front, which is a CDN, et cetera. Companies have realized that there's a lot of value to allowing people to add programmability to their storage and the same applies for the filecoin network.
02:47:50.236 - 02:48:20.520, Speaker D: And that's why the FVM exists. And a good question you might have is not why not use the EVM, the Ethereum virtual machine. And the reason is that the EVM doesn't have access to filecoin storage deals, filecoin storage deals. And that aspect of storage is unique and native to the filecoin network. So that's why you need the FVM and you cannot just not use the EVM. So yeah, EVM is the answer. EVM brings programmability to Filecoin decentralized storage.
02:48:20.520 - 02:49:02.084, Speaker D: And this is a nice diagram to kind of display like how it's layered. You can think of the L zero as the filecoin network. That's all your storage, that's your data. And then on top of that is the FVM, which brings Compute to the state of that data. And that enables to build other L, two solutions on top of the fogcoin network which do computation over data, and that happens off chain. All right? So now hopefully it's clear what problem the Fem is solving and how it naturally comes in into the FalcoIn ecosystem. So let's explore more about what the FVM is.
02:49:02.084 - 02:49:54.070, Speaker D: So what is the function of a blockchain VM? Essentially it should act as a runtime to execute smart contracts and it should allow various smart contracts to interact with each other. And additionally, an ideal feature of a VM is that it allows you to reuse smart contracts that you've written for other blockchains on that existing VM without you having to rewrite that or modify it. And these are the core features of the FVM. Basically, FVM is like a multi VM runtime for the FalcoIn network and it's built on WebAssembly. And what does that mean? It means that it's built to support multiple runtimes. So you can actually build multiple VMs on top of the FVM and the Fevm is one of them. I'm just going to describe that in a moment and you can bring your own VMs and build on top of that.
02:49:54.070 - 02:50:34.544, Speaker D: So as I mentioned, basically this diagram shows kind of how multiple runtimes can be built on top of the FalcoIn network. And as long as your VM compiles to Ozum, you can run it on top of FalcoIn. And the EVM was the first one that was launching. And essentially it's an ethereum virtual machine that runs on top of the filecoin virtual machine. It's ethereum compatible. It means that you can reuse all the features of the EVM for filecoin, like the addressing the account types, et cetera. And this is just hopefully one of many.
02:50:34.544 - 02:51:26.012, Speaker D: And you can build any type of VM as long as it compiles down to WASM. So I don't know if you really like your cat Dolores so much and you want to build the Dolores VMs where the account types are just unique pictures of Dolores. You can do that as long as it compiles to WASM. All right, so hopefully it gives you better idea of the Flocko network FVM, what Fevm is and all that. So I'll go into a use case. So I mentioned earlier is I work on a project called flockoin Saturn and I wanted to present a production use case for the FVM because we just deployed one of the very big production use cases for it earlier this year. And what falcon Saturn is, it's basically a decentralized CDN that's meant to accelerate retrievals on the FalcoIn network.
02:51:26.012 - 02:52:09.472, Speaker D: And what that means basically is right now FalcoIn is really good at storing things and can store things reliably, but we want to complete that storage loop by having really fast retrievals because that's what we expect. We expect to deliver the same experience as web two and for web3, which means we need to have really fast retrievals. And that's. Why falcon Saturn exists, and Saturn is an absolute monster. We currently have 2000 nodes that's eight times more than cloudflare, and we serve around 150,000,000 requests every day. And what's really cool about Saturn is that actually there are real people running these nodes. And what's even cooler is that these people get paid for the retrievals that they make.
02:52:09.472 - 02:53:02.960, Speaker D: And how do we orchestrate payments for the Saturn network? The answer is the FVM. So we want to run Saturn as a protocol, which means that when you're a node operator in Saturn and you want to serve retrievals, you interact with a protocol and you get paid through a protocol because that's trustless and that's decentralized and that's what web3 is about. And the Fem common of filecoin enabled us to do that. And the FVM allowed us to deploy smart contracts that maps the contributions of our Saturn nodes to payouts. And eventually these nodes can claim these payouts and the smart contract will distribute the payouts. And this is kind of like the level that the FVM can play at all the way from tiny applications to doing the accounting for a whole CDN. So I'll give you a quick demo for our payouts.
02:53:02.960 - 02:53:42.670, Speaker D: Actually, I'll start with the UI here's the UI for our payouts. And this is built with existing this is all built and this is also open source. I'll give the links for the repos later on. But this is built with existing infrastructure that works for the Ethereum virtual machine and it's running on the focal network. So as a Saturn operator, you can go claim your funds from a FVM deployed smart contract and you can still use things like Ethereum addressing and all the account types and one SEC.
02:53:50.790 - 02:53:51.166, Speaker C: Sorry.
02:53:51.208 - 02:54:47.522, Speaker D: The Internet is a bit slow here. All right, yeah. So this all runs on regular web3 tooling that we'd use, and this runs on the Fem. And as a Saturn node operator, you can see kind of like what your earnings are, what transactions you can claim, et cetera. And on Saturn, we've been working on some really cool tools that makes deploying on the FVM really easy and also very flexible if you wanted our payments contracts. Repo is open source and it's a really nice resource if you want to really dive deep into how FVM can work and all that, just to demo. So we actually built a CLI for Saturn to deploy things on FVM and I was obviously testing it before the workshop just to make sure I'm clear with the demo gods.
02:54:47.522 - 02:55:29.430, Speaker D: And if it doesn't work, I have a demo to show. But yeah, running it is essentially just as easy as a very simple CLI command that just gives you the RPC URL. And here I'm copying a local secret, which you should never do, but for the sake of the demo I am doing because I don't have my hardware wallet and you just deploy and as you can see, you're seeing all my Rust linting errors. And this is live stream. So no shame. Yeah, the block times on the Flock Coin network is like 30 seconds. So it does take a while to deploy.
02:55:29.430 - 02:56:18.944, Speaker D: But yeah, the RCLI gives you releaseful tools like what the gas price is. It can convert Ethereum style addressing to Falcon style addressing. And you can edit, for example, the gas multiplier. So you can make it really flexible or you can just use it. It is out of the box. And since the block times are really long, I'll just show you what the deploy contract oh, my God, I have so many linting errors. All right, so if so, Phil Fox is a Falcon Blockchain Explorer that you can use to check out your contracts and all that.
02:56:18.944 - 02:56:53.290, Speaker D: And this is the contract that I deployed before the demo. And it's essentially exactly the same experience as you would use with an EVM Smart contract on filecoin. It has a filecoin address, has an Ethereum address. You can see the message ID. This is like one of the payouts we deployed. And here it is live. And hopefully the other one would have deployed right now.
02:56:53.290 - 02:57:12.352, Speaker D: There we go. So this is the one I just deployed. Just want to show it's working. The demo gods are with me today and I'm very proud about that. All right, back to the presentation. To wrap things up, I've lost my mouse. There it is.
02:57:12.352 - 02:57:27.536, Speaker D: All right, so here's some useful resources. The Fevm team has a bunch of starter kits for working with the Fevm. We at Saturn really like rust, so we use the foundry.
02:57:27.568 - 02:57:27.808, Speaker G: Kit.
02:57:27.824 - 02:57:51.304, Speaker D: But there is hard hat. There is remix. There is a ton of other tutorials also that are available there to show you how to deploy and work with the Fem. And it's really useful. The Testnet Hyperspace is a repo dedicated to the hyperspace testnet. It shows you how to get test fill, how to add that hyperspace to your MetaMask wallet. And it's very similar to what you would do on Ethereum.
02:57:51.304 - 02:58:35.976, Speaker D: Basically, if you're familiar with Ethereum development, saturn contracts is our contracts repo. So basically everything like the way we do accounting for Saturn is in that repo. It's public as open source. And it's a great demonstration with how to use the Fevm with Rust. And we developed a Rust Fevm utility library and has very useful things like sending transactions. The Fevm has its own gas calculation model, so sometimes when using it with some of the Ethereum tooling, you run into some annoying bugs in Rust. We completely removed that experience for you with the Utils library.
02:58:35.976 - 02:59:09.210, Speaker D: Other things like converting filecoin to Ethereum addresses, you can find it all there. The library is very new. We're developing it and there are some issues. So if you feel the web3 hard in you to come in and contribute, feel free to do so. And lastly, this is the contracts UI. So the UI I just shown is also open source and in case anyone wants to look at how to build front end applications on Fevm, it's very similar to Ethereum, in fact, like the same exact tooling. And we have it out there.
02:59:09.210 - 02:59:46.004, Speaker D: So just a reminder. So we have some prizes at this hackathon. We have an Fevm sheet sheet if you want to scan the barcode. So we have a grand prize and another pool prize if anyone's interested to hack on the Fevm. That'll be really nice. And just a reminder to qualify for the prize. If you want to deploy things on the FalcoIn network, NFT Storage and Web Three Storage are really nice APIs, abstract away a lot of you having to do a storage deal and all that, it does that all for you.
02:59:46.004 - 03:00:24.126, Speaker D: So if you don't want to get too deep in the weeds, these are really nice services that offer you APIs to store things directly on the filecoin network. And that is it. If anyone has any questions, happy to take them. Sorry, I can't hear you. How will you make sure that the.
03:00:24.148 - 03:00:24.720, Speaker B: Data.
03:00:32.300 - 03:00:59.600, Speaker D: Yeah, so you can do it a few ways. You can encrypt the data before you send it and then decrypt it. And some like, I'm guessing like NFT Storage or F Three Storage do some encryption for you or you can go through like a smart contract route. So that is what it means, like ring programmability is that you can do things. Also, just to repeat, the question is how do you ensure that the data is encrypted or not visible to someone or not accessible.
03:01:15.200 - 03:01:17.100, Speaker C: Data on IPFS?
03:01:19.780 - 03:01:57.898, Speaker D: So IPFS, so, okay, just so you can access storage deals from the EVM itself, you can access them from the Fevm and then IPFS is content addressed so you can access yeah. Okay, so the question is, is it possible to use smart contracts on FVM to store data? And yes, you can make yeah, you make a storage deal with the smart contract.
03:01:57.994 - 03:01:58.640, Speaker B: Yeah.
03:01:59.010 - 03:02:51.210, Speaker D: So you can make storage deals with the smart contract for sure. Correct. Okay. So the question is, does Spotcoin store the relationships between different files? Not really. I don't know if you're familiar with how Ipfest store things and it's a merkel Dag, basically. So if something is another merkel Dag, there is no connection essentially, unless it's part of the file. You can reference another file in some file and that's fine.
03:02:51.210 - 03:04:20.996, Speaker D: But unless it's actually part of the directory, you can't just link it natively. You mean like having versioning? Yeah, you can have that. But a nice feature that comes baked into merkel DEGs is that for example, if you have files that are really similar or have the same content, we don't need to create a new merkel dag for it. They will share that from an existing merkle deck and just like extend it so does that make sense? You can traverse it and query, like, certain parts. You're welcome. Thank you. Yep.
03:04:20.996 - 03:04:58.762, Speaker D: So the question is, is there some infrastructure ready for off chain compute? So, yeah, there's a project that spun out of PL called Baccal, and Bacchayo is all about computation basically compute over data. It's called cod. That's why the name Bacayo came out. But, yeah, it's all about that. If you want, I can share with you after, but it's basically dedicated project for that, and it's an L two skill and later for computation over data on the Falcon network. Does that answer your question? Okay, perfect. All right, I think we have no more questions.
03:04:58.816 - 03:05:33.160, Speaker A: Thank you very much for listening. In the way. Something in the way. Something in the way. Something.
