00:00:00.090 - 00:00:59.550, Speaker A: Where the metadata is changing due to a contract interaction on the NFT contract itself. But if your NFT contract is pointing to another contract that renders your metadata, events on that contract will not tell Openc to change to update their cache. And so four nine six is useful if all of your metadata is being rendered inside of your contract, and if it only changes when someone executes a transaction. In this case, that's not how it works because of the time is always ticking down in the time left in the current cycle, for example. So to solve this in TypeScript, I wrote a process that runs in PM Two on a VPs that goes and fetches all the token IDs what is the number of IDs in the NFT contract and tells OpenSea to update each one one after another. Ideally, this is made obsolete in the future by OpenSea supporting an API endpoint where you can know, just tell them one time, update the whole collection. So far, that's not the case.
00:00:59.550 - 00:01:43.886, Speaker A: So if you have this problem, you can also go and steal this repo, and maybe it'll be useful for you. Once the metadata rendering was complete for the Juicebox protocol, I decided it would be fun as a stretch goal to make these things collectible. Because as I mentioned, these NFTs, the Juicebox NFTs, represent ownership of a juice box. And so not everyone can have them, and you can't sell them because that NFT is the ownership of the project. And so you probably want that in a multi SIG or in an on chain governance contract. So how are people actually going to see this metadata that you've spent so much time creating? My solution was to create something called juicebox cards. This is an 1155 Open Edition contract with a very low mint price.
00:01:43.886 - 00:02:25.382, Speaker A: When someone mints one of these cards, they receive an 1155 in their wallet. The proceeds go to the project in question. And the metadata for this 1155 Open Edition is simply a reference to the Juicebox project's own metadata. So as a consequence, essentially, these Open Editions are like little billboards that can be in your followers wallets, in their rainbow wallet. They can check the status of the project by having an Open Edition that has the exact same metadata as the project itself. So you can make your own metadata too. And I thought it would be nice if I provided something to get you started so that you don't just have my project.
00:02:25.382 - 00:03:01.682, Speaker A: As an example, here are a few links. The first one I think is the most interesting one. It's essentially a Forge Solidity repo, where if you download it, install the dependencies by calling Forge Install and Yarn Install. The instructions are in the README and then hit Forge Test FFI. You'll immediately have an SVG rendered from Solidity in your browser. So I think we have a few minutes, so maybe I can actually demonstrate that. Actually, before I do, I'll just explain the other links.
00:03:01.682 - 00:03:26.660, Speaker A: So the first one is this SVG demo repo that I'll show you. The second one is a boilerplate. If you wanted to write your own metadata contract that's compatible with the Juicebox contracts that I wrote, you can fork this project. It has all of the imports already in there. It's going to work right out the gate. So it's sort of a little bit of stuff on top of that SVG rendering boilerplate in the first link. And the third link is to the docs for everything that I've talked about today.
00:03:26.660 - 00:03:54.652, Speaker A: Actually, here, I'll quit out of this for a second. So this is that repo I mentioned in the first link. Oh, you can't see that, can you? There we go. So this is that repo. No, sorry, this is the wrong one. Oh, I see. I have to look on this screen.
00:03:54.652 - 00:04:22.004, Speaker A: Okay. So you can see here, these are the properties that will be like the properties of the NFT. Not visual properties, but properties that you can sort by in OpenSea, for example. And here we're generating the actual SVG. So if you download this and you simply install the dependencies and there's instructions for that in the README and then you call for test FFI, it's going to open it on my screen.
00:04:22.042 - 00:04:25.750, Speaker B: So I got to move this over.
00:04:28.280 - 00:04:37.048, Speaker A: So this is rendered from solidity. So if we go here, it's a little difficult for me to see. But if we change this to, I.
00:04:37.054 - 00:04:39.000, Speaker B: Don'T know, blue.
00:04:40.940 - 00:04:53.698, Speaker A: Obviously better to use actual hex colors. Sorry, it's on my screen. There we go. So you can start playing with an SVG, like right away. It's very, very fast and I encourage.
00:04:53.714 - 00:04:54.680, Speaker C: You to do that.
00:04:59.510 - 00:05:54.914, Speaker A: So what are the next steps? So, in this project, what I've shown you is some tips and some lessons learned from creating an onchain SBG rendering contract that just visualizes what's happening on chain in a dynamic image. The next step is to create an NFT that is interactive. And to do that, you would need to bundle in something like Ethers or web3 JS into the NFT, potentially drawing it from an onchain source, or potentially grabbing it from a regular Http route, like from a CDN, et cetera. So the promise of this is that we can have NFTs that not only visualize what's happening on chain, but allow you to write to the chain. Also by constructing a transaction request that MetaMask or whatever wallet you're using can understand and then propagate it to an RPC. The problem here with a missing piece is that, as we mentioned earlier, OpenSea, sandboxes and cash is NFTs. And so you can't have interactive.
00:05:54.914 - 00:06:26.660, Speaker A: You can only have limited interaction inside of the OpenSea frame. And so the second piece that I think is interesting that people might want to work on is an NFT app browser. That is to say, a website most likely that allows you to browse NFTs and interact with them to do things like construct transactions that you can propagate on chain. So that's my talk. Thank you very much for attending, and if anybody has any questions, I'd be happy to answer. Thank you. Any questions?
00:06:28.150 - 00:06:28.900, Speaker C: Yeah.
00:06:30.470 - 00:06:34.350, Speaker D: Did you have any suggestions on how to use it for this hackathon?
00:06:34.510 - 00:06:35.634, Speaker E: Oh, good question.
00:06:35.752 - 00:07:21.140, Speaker A: I'm not super deep on what all the prizes are that are available. I don't know if there's anything where this will be particularly beneficial, but one that comes to mind is I know 6551, the token bound, like, NFT owned wallets. Could be interesting to have those wallets rendering something on chain representing what's inside of them with no off chain dependencies. So, for instance, yeah, you could have an NFT where you send it an asset and then it shows it, and it's not relying on IPFS or Http. I think also some of this on chain stuff could be very interesting on Gnosis chain or polygon or other L two S or side chains where gas fees are lower. You could do even more aggressive things, not just with the rendering, but with having more interactivity to write to them to change what's being shown. Any other questions?
00:07:21.990 - 00:07:22.740, Speaker C: Yeah.
00:07:24.870 - 00:07:27.620, Speaker E: Because I'm new to this area. Okay.
00:07:29.370 - 00:07:33.974, Speaker F: Just if I change something, like a.
00:07:34.012 - 00:07:35.480, Speaker E: Core function of.
00:07:38.730 - 00:07:43.362, Speaker G: Dialogue box, it shows meta mask.
00:07:43.506 - 00:07:44.200, Speaker C: Yeah.
00:07:47.130 - 00:07:48.760, Speaker E: Every step you.
00:07:50.910 - 00:08:06.640, Speaker A: If you're yeah, there's you most likely have to sign a transaction if you're logging into an app that wants you to verify that you own a certain wallet or if you want to send a transaction. So those are cases when.
00:08:09.250 - 00:08:10.240, Speaker F: You play.
00:08:14.210 - 00:08:51.180, Speaker A: Yeah. The question is, if you're making a game, do you have to pop up a transaction request every time you want to do some in game interaction? And if the game state needs to be modified on chain and you want to restrict actions to the owner of a certain wallet, then, yes, you probably do. One alternative is to write your own app, let's say a mobile app where you keep the keys, and it's more of a custodial system. So instead of asking the user for permission to their key, you make every button just work. And you don't ask them for permission to sign with their private key. You just do it on their behalf. That's a way around that.
00:08:54.910 - 00:08:55.900, Speaker E: Other than.
00:08:57.810 - 00:09:02.080, Speaker A: Yeah, I would suggest you probably want to make your own wallet built into your game.
00:09:02.770 - 00:09:03.520, Speaker C: Yeah.
00:09:04.210 - 00:09:07.440, Speaker A: Any other questions? Okay, thank you very much.
00:09:14.510 - 00:09:15.370, Speaker D: Whoa.
00:11:37.780 - 00:11:53.364, Speaker F: They have yeah. One, two, three. Yeah, sounds like it works. I can see it there.
00:11:53.402 - 00:11:53.990, Speaker E: Perfect.
00:12:00.670 - 00:13:13.700, Speaker F: So I assume I can start it's already the time. Welcome, everyone. My name is Nick, and today we will be mastering our development skills around building DApps, specifically on the XTC network. So I have been working as a software engineer for the last 14 years, approximately, and my first kind of interaction with the blockchain space overall was in around 2011 twelve through one of my mentors Dionysus Andros. And today I am the CEO of Anosis We're, a research and software development firm based all over the world pretty much. Today's presentation will cover those four pretty much aspects. So I'll give a brief introduction to XDC, I will share with you my observations and then we will all together start building a quick web application.
00:13:13.700 - 00:14:24.620, Speaker F: For that you will need your laptop node JS installed and quite some patience so quickly about XDC. The XDC network was founded and established in 2017 by a group of individuals which believed strongly in the blockchain technology. It's a proof of stake network. It is quite fast, pretty robust and very cheap. And there is an amazing foundation and community behind the network who are making sure that all the developers and community members are very happy within the environment. And now I will share with you some of my observations based on the companies established, our companies established the last three years. So we have seen quite some DApps on XDC network, on Flare network where we are also building and so on.
00:14:24.620 - 00:15:32.990, Speaker F: And seemingly there have been quite some problems with those DApps. Most of the times we have noticed that because everybody I believe in this room will agree that the onboarding of a user and the user experience in the web Three is not the most easily understandable thing. If I'll show a flow to my mom, she'll probably freak out and not speak to me for a couple of days. So the one thing that I have personally noticed, especially in comparison to more traditional markets is that there is no user flow. We do not structure as developers our thoughts. We usually go all in and we're like oh, this product should have those hundred features altogether at the same time and I should just throw them on the interface. The user will figure it out because he's smart and that's usually not the way to go because the quite opposite happens.
00:15:32.990 - 00:16:26.014, Speaker F: The user doesn't know where to click, doesn't know what to do, she's not even sure what the thing is doing and then he leaves. So based on that, we're often giving either too much information or too little information. Most probably my mom, as I mentioned in example previously, doesn't know what is a throughput, doesn't care what it is, doesn't know what's a gas cost, doesn't care what is guay. All those little things should not even be of her concern. And usually there's tones of dead ends in user experiences around web3. What does that mean? You do one thing, the information never refreshed. You now do not understand what you're supposed to do.
00:16:26.014 - 00:17:31.220, Speaker F: Was the interaction you initially did ever completed, what did exactly happen? And for all those reasons users just leave your platform and most probably never come back. So a very very important tool is the user journey. It's very important to understand our users and that is probably something that we need to do better. One of the greatest tools of Web Three is that we have a direct point of communication to our community. And for the developers of the previous, let's say, decade, that would be just a tool like a golden, I don't know, shovel or something because you can do a B testing without doing any assumptions anymore. You have a direct feedback of the user to tell you exactly how they felt. And what is this about to.
00:17:33.370 - 00:17:33.734, Speaker D: You.
00:17:33.772 - 00:18:25.474, Speaker F: Know, Bruce Lee famously said be like water, right? Which means listen to people in this case and be ready to make the change. Not to be opinionated, you might be totally wrong about what you're assuming. And for that reason it's very important to create your flow. So in today's workshop, we will be building a very simple DAP which is going to allow you wrap and unwrap a native currency. A native currency is the main currency of the blockchain. For example, on ethereum is the ether or ETH token as most might know. And you can use deposit of withdrawal functions.
00:18:25.474 - 00:20:06.040, Speaker F: So some functions on the blockchain which allow you to create or take back your ethereum with this wrap native asset or in short, nat. So today we'll see that the user enters a web page and in this case I will in short show you how you can have your application interact with multiple networks instead of just one. And then the user needs to select a network on which they are connected to or they want to use the application, select a function which they want to perform in this app. So they need to choose will they wrap or unwrap and then they can see the balance that they have available to perform that action and they can add an amount that they want to interact with and submit the transaction. That action would let them into two possible scenarios the transaction failed or the transaction was successful. If the transaction failed, we need to show the user an error message and in that case take them back to the step where they add an amount and submit the transaction. And if the transaction was successful, we need to show now to the user the updated balance and to end the flow pretty much to tell them, hey, your transaction was successful, good job, you have nothing more to do.
00:20:06.040 - 00:20:30.080, Speaker F: Yeah, there's many steps in the flow, as you will see from the code. I hope we will be able to finalize that in the next 20 minutes fully. If we will not be I will be right outside. The code will be public on GitHub. Feel free to ask me any questions and to go through that right there.
00:20:33.730 - 00:20:34.590, Speaker D: Yep.
00:20:36.530 - 00:21:34.050, Speaker F: So that was our user journey. It is very important when you're building something now that you're in this hackathon to sit down and go through the exact journey you want to deliver at the end of the hackathon, because many times that's how teams kind of fail to focus and lose the deadline and never deliver something actually functionable. The template that I show is a default template by a tool called Figma. You can find it online and you can use the Figma tool for free as an individual. For the next steps, you will need, as I said, node JS, any source code editor. We do not discriminate the choice of that a browser and a lot of patience because that's pretty much the main thing that you need to have as a Web Three developer. So be prepared.
00:21:34.050 - 00:21:58.486, Speaker F: And now let's go to the fun part, right, so I will show you some code, but first of all, I will ask you some questions. So how many of you have actually built a front end decentralized application before? So two, three, four.
00:21:58.588 - 00:21:59.082, Speaker C: Not that bad.
00:21:59.136 - 00:22:59.360, Speaker F: Awesome. And how many of you have interacted with at least one before this date? Okay, approximately the same amount of people. So awesome. Today we will use technologies as Next JS, tailwind CSS Wagme, which is a helper for Web Three related actions, and Rainbow Kit, which allows you to utilize the Wallet Connect. So let me open my editor. At this point of time, I will simply assume that you have your Node JS set up and that you have your Vs code open. I will actually give you a couple of minutes to achieve that.
00:22:59.360 - 00:23:46.090, Speaker F: Now, as I said, I will make sure that I will put all this content online. So don't worry if you miss something and go on your own pace. So make sure that you are not trying to run after me. And one very important aspect, feel free at any point of time to interrupt me and ask a question that's very important for everybody to know that we're all following and there is no reason to be shy. We all did something for the first time and that's how we all learn. So to start with, we will create a new Next app. The command to do that is NPX create Next app at latest.
00:23:46.090 - 00:24:13.158, Speaker F: And I will name this application ETHGlobal Hackathon. And now it will ask me several questions. Would I like to use TypeScript with this project? I definitely would. ESLint. Yes, definitely. Tailwind CSS. Now this is something that I personally usually choose no to.
00:24:13.158 - 00:25:16.454, Speaker F: I personally write most of my CSS myself, but that's something that is up to you. Would you like this project to use SRC directory? Yes. Now, for the upper router, because there is more documentation online on this solution, I will choose no right now. So anybody who is watching online or yourselves would be able to find more material online. And would you like to customize the default alliance for the imports? No. And this will now given that we're connected to the internet and yes, we are install all the needed tools and dependencies for our application to be able to run. Okay, and that was indeed successful.
00:25:16.454 - 00:25:52.950, Speaker F: And now I can run my application by running NPM run dev. Oh, that is not true. I'm sorry. I will need to open actually so right now I am in my computer's repository and now I will need to open the project that I created. Wherever I created it should be yes, right here. So I'll open this folder with the Vs code. Yes, I trust the authors.
00:25:52.950 - 00:27:29.134, Speaker F: And now I can run NPM run dev by running this, I can check in my browser that I can see the screen right here. So our next JS application has been successfully installed and now we need to install all the other tools that we potentially will need to interact with web3, right? So the tools that we will need, as we said previously, are rainbow kits, Wagme. And one thing that we will barely use, but it is needed under the hood is VM. So those modules help again front end developers to interact much easier with the blockchain. Most of times the biggest problem that both myself and most people that I worked with had is the ability to refresh pretty much the data without initiating extra functions in our code. So this is something that Wagme solves great time. And wallet connect or Rainbow kit in this case is something that allows us to let the user connect with any wallet they have.
00:27:29.134 - 00:28:14.314, Speaker F: They might have a ledger, they might have a MetaMask, they might have a rainbow wallet. So they wouldn't need to care about the exacts of which wallets they need to use. So now that we have everything installed, you will be able to see all the code base here. And our main folder that we will care about is the SRC folder. Most of our changes will be done here. And to start with, I will open the app underscore app TSX file, which is the main file where everything starts. So everything that I have on my application, it is going through this file.
00:28:14.314 - 00:29:14.500, Speaker F: In order to be rendered, I will add import pretty much the styles from Rainbowkit so it's at rainbowkitmerainbookitles CSS. And then what I need to do is I need to set up the Wagme configurations, I need to set up the rainbowkit provider and I need to make sure that I will tell my app, which are the networks that I want it to be connected to. So let's start one by one. So first of all, we need to get the Rainbow kids to import the rainbow kits into the application. So that is done by import rainbowkit provider. So the get default wallet is not really necessary here. And then we will also need config chains and Wagmin config chains functionalities added here.
00:29:14.500 - 00:30:09.730, Speaker F: So you can see that I imported those three functions here. If you are wondering where did I find those, I found those by Googling Rainbow Kit. And on the website of Rainbow Kit there is a view instruction website. If you want to easier copy paste those additions, it's the easiest way. So now I have most of the needed functionalities or modules imported. Now, as I said, I will need to import the network which we will be connecting to. And a provider, a provider is almost like an API handler I would say, which is allowing us to connect to the blockchain as an API.
00:30:09.730 - 00:30:51.482, Speaker F: So there are several types of providers. In this case, I will show you the public provider functionality, but there is also the Alchemy provider. If you're connecting to the Ethereum network, you most probably want to use the Alchemy provider because it's much, much more reliable. So I have imported all the functionalities that I need at this moment. And now I will start writing my components. So now we know that the application the only thing that it does, it's returning any component that is passed to it through its pages. And in this case, I want to configure my chains.
00:30:51.482 - 00:32:05.494, Speaker F: So the way to do that is the function from Wagmi Configure chains and that returns to us an object with an object of array of the chains and the public client. Now, from there on, we will need to create the connectors, which is something that the Wallet Connect uses in order to understand which provider and which chains we're connected to. And for this one, you would need to find an application ID, a Project ID. To be more fair, the Project ID can be found on the Wallet Connect cloud website where you need to create an account with an email and a password. You do not need to connect any wallet and so on. And last but not least, we need to create the Wagme config, in this case to auto connect, to use the connectors from the above, and to use the public client as the client for the blockchain. So now all of our setup is done.
00:32:05.494 - 00:32:32.282, Speaker F: We can see that there is no errors right now as the linter worked. And once I will add here the two last bits, which is the Wagmi config and to the Wagmi config that's.
00:32:32.346 - 00:32:33.070, Speaker D: Owned.
00:32:36.920 - 00:33:22.980, Speaker F: Config equals Wagmi config from right above. And this closing statement right here is wrong. So this is perfect. And now I need to add the Rainbow Kit provider to our application. And I can do that by adding this function. And this needs to know now which chains we're using. And you can identify that by the variable which we defined here, named chains.
00:33:22.980 - 00:34:33.576, Speaker F: Now, this looks very straightforward and this is what you would got to a point if you would have followed the Rainbow Kid configuration setup. Now, there is a tiny problem here that if you will actually run this code, it will not work. And I can actually show that to you although there are no errors whatsoever on the code base, if I will try to run this, this is what I will get. Which is not what the Rainbow Kit website is telling me, unfortunately. Sorry, Rainbowkit, no offense, but what I'm trying to say is that this is happening all the time in the blockchain space and you need to be ready for that. That's why the patients in our case, I have found this morning what was wrong. And what happens pretty much is that NextJS is running it's a server side rendering type of framework.
00:34:33.576 - 00:35:32.016, Speaker F: What it does, it's rendering what it has to pretty much create the UI based off on the server. And then it only is serving what it rendered already to the user at the time that it's rendering. It doesn't have the FS module, which is the file system module for JavaScript. And that is why this thing breaks. So now I need to give to the config some kind of fallback for what is happening if the file system is not available at the time that I was actually loading my code. And now that I added that fallback, you will be able to see that once I refresh this page, it will work. Right now that is a job for all of us to do in the space.
00:35:32.016 - 00:36:40.180, Speaker F: When we find an issue like that, most times we need to open a GitHub issue, we need to talk to a bunch of developers. Until like several weeks later, we will be able to solve our problem. So now that we have the Wallet Connect application set up, because I have quite a small amount of time, I will rest this quite a bit. So right now what I need to do is I need to add a button which will allow me to connect my wallet. And then I need to create a form which will wrap and unwrap my native currency. So I have pasted from the repository which is live this piece of code, which is tiny, really. It is changing the title on the top left and on the top right it is adding a button which says Connect Wallet.
00:36:40.180 - 00:37:43.624, Speaker F: Right? And now if we'll go to this website, we'll see how easy it was to add the Connect Wallet button. If I click the button, it allows me to choose from a selection of wallets. Very simple for any user. It even tells the user how to get a wallet if they don't have one. And then since I do not have installed on this particular window of my browser MetaMask, I can choose Wallet Connect and I can scan this QR code and I can connect with my phone, for example, and use it through there. But for now, I will actually open it on a wallet which I have in my MetaMask, which is the wallet right here. And as you can see, I'm already connected, but I'm not connected to the Ethereum network so I can disconnect and I can connect again.
00:37:43.624 - 00:38:27.880, Speaker F: Once I connect again, it will automatically prompt me to switch to the Ethereum network. And once I'm on the Ethereum network, I have my UI updated with all the information needed. Now that is pretty cool. And I am also able to show the chain status. So if the user switches to the wrong network, they can see exactly that they're on the wrong network, which is pretty cool. But now let's actually dive deeper into some actual functions. So in this case I will create a new folder which will be called Components in order to have our code base a bit cleaner.
00:38:27.880 - 00:39:53.400, Speaker F: And I will create a new component which is called form into this folder. This component oops. This component will be a quite complex component in this case and it will do quite some things. So, starting from the top, we're importing quite some functions from Wagme, an Abi usate, some functions from VM, some spinners and a notifications pretty much library. So what do we do? One thing that we do is we're asking for the developer to provide the type of transaction. Will it be a wrap or an unwrap transaction into props? And then the user can set the action also from outside of this component. Now I will really quick install the remaining two dependencies and I will show you exactly how it looks.
00:39:59.100 - 00:39:59.656, Speaker G: Or I.
00:39:59.678 - 00:41:10.998, Speaker F: Will not really depends. So I installed react spinners which will allow us to identify our loading state. And I am also installing this little notifications library. So the idea is simple that when a user clicks the button, there is a spinner coming up. If the transaction is successful, the user should see a notification coming to his screen, right? Some very simple things use contract, prepare rights, very important function. This helps you to prepare the transaction before the user clicks any button. And that will allow you to make sure that there is no issues with either some maths that you're doing on the front end or some other kind of malicious behavior that your user can do.
00:41:10.998 - 00:41:32.140, Speaker F: You can disable it to him by saying when is this function enabled or not? And you can also provide a watch. So there is a watch function which you can set as true.
00:41:35.250 - 00:41:36.286, Speaker C: Which I.
00:41:36.308 - 00:42:04.680, Speaker F: Will set in a second. What does it do? It allows the user to see in real time what is exactly happening with his balances and anything around his screen. So I will add the form component here and as you can understand here, it will tell me to import it and I will also add the state.
00:42:05.290 - 00:42:06.040, Speaker C: Which.
00:42:08.970 - 00:42:57.090, Speaker F: Is the action. Awesome. And now there is something missing here which is the Abi. So the Abi is something very important and it's something that you and your fellow backend developers, or smart contract developers, however you would like to call them, you will have to find a common. Language on this one. The Abi is almost something like a API document, if you wish. The Abi tells exactly to the programmer which functions are available for him to access through the blockchain.
00:42:57.090 - 00:44:06.290, Speaker F: And it's definitely not a Abi file, it's a JSON file. And now that I have added that here you can see constantabi awesome. And now we have this piece of code which in our case should work, but it doesn't. Let's see what's going on wrong here. And if somebody needs to yeah, I know what's happening here. So the application tells us that it doesn't know what exactly is the use notification. Why is this happening? Is because we added a module which we haven't defined in the specifications of the application.
00:44:06.290 - 00:45:10.070, Speaker F: Once I do add this property right here, which is notifications provider, it will allow me to render my application. And now I can see this exact UI, right? It is a pretty simple UI, shows me the balance that I have on ETH. And I can wrap or unwrap based on what I want to do. But obviously those functions are right now based on my code, pretty hard coded. So the next step of what I need to do is to add the chain on which actually those functions are available. And this is something very important as not quite documented, I would say. So you can add custom definitions of custom chains.
00:45:10.070 - 00:46:20.190, Speaker F: In this case, I have added several networks and you can see that I have to provide quite some information. What does this mean is that if Wagme or Wallet Connect or anybody is not providing me that specific network or it's providing me that specific network, but the RPC sucks and I want to use our own internal RPC. I can go ahead and override every single definition that there is, even for Ethereum, right? And I can use my custom definitions with my custom networks. To do that, I need to create this little object here and then obviously to export it from this file. And now in place of mainnet right here, I can go and I can see XDC mainnet, right? And it will bring it from the file that I just created. And now you can see that I'm connected to the wrong network, although it is bringing me the data from that network. If I would go and switch from here, you can see that I just connected to the XDC network.
00:46:20.190 - 00:47:00.410, Speaker F: I can wrap one XDC. You can see here the white dot spinning, which is our spinner. If I reject it, it goes back to the default state. I can confirm it. You can see that the wheel is spinning because the transaction has not been confirmed to the blockchain, has not gone to the blockchain. Now that it went there, our balances should update and our input went blank. I have been informed that we are out of time.
00:47:00.410 - 00:48:28.600, Speaker F: So this is the last thing that I'm going to unfortunately show you and that is the fact that as you can see my balances were not updated and that is something extremely important for our users. So in Wagme, which this is by the way for the website for Wagme, one of the functions that I used is use Contract Reads. What use Contract Reads or use Contract Tree does, it allows the user to read a specific point in a smart contract. This allows you to listen to updates on every single block. So what you should really do is to either use Listener or use the watch function which allows you to literally watch for any changes on the blockchain. That way you don't need to refresh and you do not need to pretty much do anything from there on. I am very sorry that I wasn't able to show you everything that I wanted.
00:48:28.600 - 00:48:42.920, Speaker F: Again I will be right outside. We can go through in depth specific functionalities and functions. Would be very happy to help you during the hackathon and good luck everyone for whatever you want to build.
00:48:48.930 - 00:48:49.680, Speaker D: It.
00:48:56.210 - 00:48:56.960, Speaker F: Sorry.
00:49:02.690 - 00:50:48.520, Speaker D: Can you prep that's? Thank you.
00:50:54.890 - 00:52:02.416, Speaker C: Yes. Hello, I think it's pretty good. Hello, do you hear me okay? Yeah, just sitting. Hello, I'm Leo, I'm the CTO of CISMO and today we are going to do a workshop and it's I think a pretty exciting one because we are going to code live code and deploy a CB resistance AirDrop from privately aggregated data. And so this might seems a bit easy, but in fact it's not that easy because we are going to use to give on this AirDrop some amount of token. That depends on the data you are able to share. And this data can be on different accounts.
00:52:02.416 - 00:52:56.000, Speaker C: And using zero knowledge proof, we are able to only disclose the data we want without revealing the accounts. So in its core it will have civil resistance, privacy preserving data aggregation, so aggregation from data from your very private wallet, your public ENS from GitHub account, Twitter account and stuff like that without linking this account. And at the end you will have a double spending protection also to avoid to be able to mint this token a lot of different times. So I propose to enter directly in the demo so you understand what happens directly. And so let's go. So all of this has it's called ROP. All is open source.
00:52:56.000 - 00:53:51.748, Speaker C: You have a case study with it which is very detailed. So you can later I will send the QR code and the link at the end of the workshop but you can dig into it and more understand the concept so we will see different important ones. So when we launch the app we see that we have a claim token page. This claim token depends on action you made, for instance here inside the CISMO community. So to have your token you need at least to be part of the CISMO community member group I will explain you what are groups later. You need also to have the Gitcon passport holder with more than 15 for CB resistance and then you have also optional data you can share that will increase your amount of token. For instance, you can show that you were early committee members on CISMO, that you used a factory which is a product of CISMO.
00:53:51.748 - 00:54:49.656, Speaker C: I will show you later. And then you put just address where you want to receive this token and you are going to prove that you have this different data using sign in with CISMO and Sysmo connect that again, I will explain you later how it works. Just here we need the WiFi. Okay, so here I arrive on my CISMO data vault. I am redirected it's like a password manager where I have all my accounts that I imported once when I created my Sysmo data vault. I can import other accounts whenever I want like a password manager. And then here Sismo connect show me that safedrop wants me to share some information and this different data, different information will be taken from what we call data gems.
00:54:49.656 - 00:55:56.488, Speaker C: These data gems are just data you are going to share and with anonymization around the owner of this data. Typically here this data I have it from one account but the other one the factory users it's from another account and by sharing all of that I won't make any link using zero list proof so I can aggregate data from my very private wallet and some other from public wallets. So I do generate ZK proof. So here it belongs because it download all the groups of data of all the holders of the different data gem in the browser. And what happened here is that you generate ZK proof where you prove who you are inside this group without revealing this account. So if the WiFi is bit slow, it takes a long time to download all the groups basically and these groups are maker tree. I will explain you later.
00:55:56.488 - 00:55:57.908, Speaker C: But this is how the zero edge.
00:55:57.924 - 00:56:11.460, Speaker B: Proof workshop.
00:56:17.350 - 00:56:26.390, Speaker C: Here I share all the information. So we see that we have so I'm connecting my token.
00:56:29.290 - 00:56:30.406, Speaker D: Sorry, I need.
00:56:30.428 - 00:57:26.910, Speaker C: To change my network but here we see that I'm available for 400 R token. I will redo the flow and hide some information and you will see that it decrease. For instance, here I won't show that I am a Cismori user and that I am a factory user and I can do again ZK proof. Hope it will be faster this time. So now I have less token to claim. Let's claim it. The contract was deployed on polygon and so what we're going to do during the workshop is to code the Seismo community group and the Bitcoin passport groups and live deploy these contracts and test it at the end.
00:57:26.910 - 00:58:21.780, Speaker C: Okay, so just a bit of theory to explain what happened. So in CISMO you have this CISMO data vault where you can import all your accounts. Here we can see that I imported my LeonIt 21 east address where I have my ENS, my gig on passport because my Gigon passport, all the different very public account I have my Twitter, my GitHub, I have also proof of humanity which is inside. So all of that are already docs. But on Sysmo I'm doing stuff with my very private wallet. So I don't want anyone to know it. When I import this, what we call data sources into the systemo data vault, I can then share this granular piece of data.
00:58:21.780 - 00:59:14.130, Speaker C: So this is called the datagen. The datagen is just a granular server in data here it will be okay on the Gitcoin passports groups of all the holders of a Gitcoin passport I have 42 as a score inside it on my Leo 21 is and using CISMO connect which we call a crypto native SSO it's like a communication protocol. Between my very personal data and application I am able to granularly reveal this data. So here we see again the flow. I sign in with Sysmo from an app I'm redirected to my Sysmo data vault. I agree to share different data and then I'm redirected to the application that can verify it. So what I can do exactly from this CISMO data vault, it's having a request of an authentication.
00:59:14.130 - 01:00:32.270, Speaker C: For instance, here I can prove that I own the Leo 21 east address, but I can prove also that I own a GitHub account, a Twitter account and something else that is called a vault vault ID. I will explain you later how it works and you can share some data gems. So just disclose that I am part of the Gitcon passport groups with a score that is more than 15, but the application won't know that I have 42 in fact, and that I am also CISMO community members, but the application won't know from which accounts I am a CISMO committee member. And finally I have the message signature which is at the end and it serves to embed user intents. For instance, you can say for example for voting you could say I agree or I disagree. So it's really to embed user sentence. Here I will put my Leo 21 east address because I'm claiming my token on this address and it's used for avoiding front running of my proof because otherwise my proof could be front run by other address and claim for myself the token.
01:00:32.270 - 01:01:32.020, Speaker C: Okay, so in Sysmo connect what you are doing is just selectively disclose some data. It works using zero knowledge proof. So you have approver in the CISMO data vault and the application have the verifier and verifies this proof. So here if I take back my data gem, I show you later, sorry, my data gem I showed you before I had a Gitcoin passport on my Leo 21 with a value of 42 using zero knowledge proof I can granularly selectively disclose that I have a score that is more than 15 and it's anonymous. We don't know which account. Basically all of this works using snapshoted oncorg groups. So in CISMO you need to generate the groups, the CISMO data groups with all the holder of a gitcoin passport and with the different value that it has, the different score that it has.
01:01:32.020 - 01:02:14.094, Speaker C: In the same way in the system contributor you have different level to have different amount of token in the saved drops I show you before and you can disclose which value you have. All these groups has a group ID. I will show you later when we will code how to retrieve a group ID and how to create these groups using our factory or directly using our repository which is an open source repository. So finally this sysmo connect the flow I already showed you. It's very simple. You have a button in your front end. You do a sysmo connect request where you request the data.
01:02:14.094 - 01:02:50.458, Speaker C: You want the user generated in his sysmo data vault to generate this decay proof. This response which is in fact the ZK proof is sent back to the application that can verify it. It works on chain, we are deployed on eleven chains. So Mainet Polygon uses Arbitrum et cetera and it also works off chain. So you have a TypeScript package that you can install into your application to verify the knowledge proof. So sysmo connect response. So now we are going to do these live.
01:02:50.458 - 01:03:46.616, Speaker C: And to start this project we are following a tutorial that we have made which is in our documentation. I'm going to show you. So in build with CISMO connect here we have all our tutorial. The unchained one which is build a civil resistant AirDrop from privately aggregated data is basically what we are going to do. So I already set up I already set up some the repository so we don't have to do it with the time we have. So when you launch it, you are redirected to this page. It's the main page.
01:03:46.616 - 01:04:24.964, Speaker C: So it's a bit different from this one. It's a bit different from the save dot. It's a very easy template to start with. You have only the CISMO connect button inside it which is here and we are going to create this request that allows us to have the data we want for the save drop. So here we first want to generate this type of request. So we want to have the proof of a vault ID. I will explain you later.
01:04:24.964 - 01:04:58.240, Speaker C: What is it? Share data that you are a CISMO community member and that you have a Gigon passport more than 15. So let's come back to our repository. So when we do claim with CISMO so here I've just launched it. I'm redirected to this page so I can see that I have only connect to saved job. So it's not the good application. I need to create an application using the factory. We are going to do it just right now.
01:04:58.240 - 01:05:38.892, Speaker C: And here I'm only sharing the user ID. But we are going to add also the different proofs that you want to send back. So here let's go to start by giving the right application. So for that we need to go to the factory. The factory is UI tool for developers to use CISMO and to have access to different tools. So the first one is to create the Sysmo connect apps or to retrieve your existing one. And then we have the CISMO data groups I showed you before and we are going to dig more into this after.
01:05:38.892 - 01:05:57.500, Speaker C: So let's start from the application. Here you can see I've already created it. So I have an application ID I will be able to embed into my project. You can update it. It's very easy to do. You just have to enter the name, description, a logo and you create it. It's done right away.
01:05:57.500 - 01:06:30.350, Speaker C: So here I'm taking the app ID in the Sysmo connect on chain tutorial. I'm going to the main page here. So inside it you have this directory structure. It's basically a react app, a next JS react app with Foundry. So here you have CRC AirDrop. The contract I will show you later. And here you have the front end with the main page.
01:06:30.350 - 01:06:57.430, Speaker C: So at the beginning so all of this is explained in the tutorial. If you want to do it after, you will have all the steps that is very detailed. To begin with, we need to so let's try to find the system connect button which is here. And we have the config to define. We start by defining the app ID. So this app ID here is the one with for the tutorial. We are going to replace it with our new app ID.
01:06:57.430 - 01:07:52.482, Speaker C: Okay, let's come back again to our repository. Our page doing claim with CISMO and now we see that we have connect to saved up is Global Waterloo. So let's go back here for what we want. So we want to prove ownership of a Vault ID, share data from CISMO community and Gig and passport more than 15. So what is exactly this vault ID? So this vault ID, so I have defined it here. Basically, inside your Sysmo data vault, you all have a vault secret that was generated when you created your CISMO data vault. Then we just show you that you have an app ID.
01:07:52.482 - 01:08:49.666, Speaker C: For each app that consume that do a Sysmo Connect exchange. When you do this and you request a vault, we are hashing in zero knowledge proof. Inside the proof, the vault secrets and this app ID and also a derivation key. It's not very important for here it's zero by default. But by hashing vault secrets and this app ID, I will have a unique vault ID that is a bit like a user ID that is available for the application and that you can use as a user. So it's really like a unique number deterministic unique number that I generated using my Sysmo data vault. So in the case of the saved drop, we are going to use this vault ID as a newly fired for the AirDrop.
01:08:49.666 - 01:09:43.110, Speaker C: What it means is that thanks to this, you will be able each time you do the Sysmo connect flow, you will have always the same vault ID. So by saving this vault ID, we know that you are already claimed your AirDrop and we are even going to so instead of creating a mapping for that, we are even going to use it as the token ID inside the ERC 20 AirDrop token. So my token ID will be sorry, it will be just nullified in a mapping. We will show you, we will get it later. So here, that means we already have the beginning, that means we already have our vault ID. Now we need to add the claims. So let's add our claims and our claims are group membership.
01:09:43.110 - 01:10:29.430, Speaker C: So here, what it means is that I need to find my groups. For that, I'm going to the factory and going here you have the CISMO data groups inside CISMO. So you can look here. So here are all the groups that was created and we can search for the CISMO community and we find it here. So we have the group ID here. So these groups, you can take a look at what is inside. So inside you have all the data gems of all the users of the CISMO community that did some things.
01:10:29.430 - 01:11:23.558, Speaker C: I will show you later what is it and the value you can see when it was generated, when will be the next generation and how it has been generated. So for this, you can click on the data group generator. It's a bit like an infra as a service where you can just code the way you are going to generate these groups and that will run at a specific frequency. For instance, here, this group generator will run at a daily frequency and execute this code and send back the groups. All of this is open source, you can take a look at all the groups. So some groups has been generated using the factory, others has been directly coded and did a pull request into the Sysmo hub. So I will show you how you can create a new data group.
01:11:23.558 - 01:12:05.140, Speaker C: So, to create a new data group, you need to add its name. For instance, here I can say leo, France. And you can add how you are going to have these group members. So you can add eligible accounts. To add eligible accounts, it can be very easy, like putting a list of the different accounts. These groups can be also hybrid. So, for instance, I could put my GitHub account, I could put some Twitter account and you have also a telegram account.
01:12:05.140 - 01:12:48.902, Speaker C: You can also add a value, a level for each account. So for instance, I will say one for this one, three for this one, et cetera. So this is a way to add data. So here it's just static data, so it can be really interesting. But you have data providers inside these data groups that will help you to fetch data from the outside world. So here you have a full list of data providers. For instance we can say, okay, we are going to use a GitHub data provider to get all the contributors of a repository.
01:12:48.902 - 01:13:47.658, Speaker C: So for instance, we can take CSMO Core, Sysmo Hub, it will find 66 eligible accounts and put them inside the group. And here you have some description, it's a bit like metadata around the groups and then you can just deploy it. When you do this, it will automatically generate a pull request on this repository which is open source. And this pull request contains all the Sysmo data group and how the data are generated. So let me show you here we can see that this group was generated with the factory. It used null groups and sends this as a data. So we can dig into all of this after.
01:13:47.658 - 01:15:00.152, Speaker C: So, okay, let's now go to add our Seismo community members and gitcoin holders. So we take the group ID here, put it just here and now we want our gitcoin passport holders. Let's search for gitcoin passport holders. Here we can show how it is generated the same. So we see that we are querying a git passport API to generate the group and we put it here. Okay, let's go again. Now we are pretty happy because we have so our vault ID, user ID, our system community and the gitcon passport here we are only sharing that we have more than one.
01:15:00.152 - 01:15:30.100, Speaker C: So we want to request only more than 15 for CB resistance. So we can just in our request add claim type. Okay, so GitHub copy will do it for me. It's nice. Greater than or equal 15. Okay, I get back, do it again. And now we are good.
01:15:30.100 - 01:16:30.980, Speaker C: If you are not inside the groups and you want to test and develop the full flow, we have a feature in the configuration that allow you to impersonate some accounts. So I will show you here you can put the list of addresses you want to impersonate and the Sysmo data vault will contain all of these accounts. So let's do it again. And I do claim with Sysmo, I am now in an impersonation mode, so it's a very specific mode. And in my Sysmo data vault I see all these accounts. So if you want to, I don't know, do for instance noun CDAO holders as information we want to share, you can go to the group, search for a user inside that is eligible and impersonate this account. You could for instance take this one and impersonate it.
01:16:30.980 - 01:17:40.474, Speaker C: So I will remove this. So now that we have done our request, let's go here we want to verify inside our contract this request and to give the mint. So we go to our AirDrop contract and what we need to do is to have exactly the same request that is coding into the contract. So why that if someone gives you a proof, this proof in itself doesn't mean anything. This proof means something in the regard of a request. So inside the sysmoconnect library that we implement for the construct, we will verify that this Sysmo connect proof is valid, verifying the ZK proof, but also that it's zero knowledge proof that was made for these groups, same for the App ID. So here I need to take the same App ID that I put in the front end.
01:17:40.474 - 01:18:35.274, Speaker C: So this is very important, otherwise it won't work because it won't correspond both front end and back end. The contract need to be equal. Here you see our adrop that is ERC 20 and you implement the CISMO connect library here and by implementing the system connect library you have also the constructor where you use the App ID. This is how the App ID is passed to the library. Okay, so now we need to do the request so the same thing that we have done but here. So we are going to add the claim request. Okay, so we have claims zero, that is a group ID.
01:18:35.274 - 01:19:11.652, Speaker C: We will put our group ID here. So we have public constant. Okay, he's doing for me nice sysmo community members group. So he knows that I did it a lot of time. Let's verify it's exactly the same. So CISMO community members groups here it's okay. And the Gitcoin passport here is a good one.
01:19:11.652 - 01:20:01.770, Speaker C: So I'm pretty happy, I will change like that. Okay, so here I will put directly the CISMO community members and for the claims one. Okay, nice. So we have the group ID bitcoin passport holders value 15 and greater than or equal. Here we will verify the response. This is Moconnect response which is passed here as an argument to be sure that it's valid. So we need to add also the claims which we have just declared before and so if the result is valid, we continue here we extract the vault ID.
01:20:01.770 - 01:20:51.290, Speaker C: We nullify the vault ID as already claimed. So it's made here and we've verified that the vault ID was not used before and we mint to the sender the amount here we can see also the signature which contain inside my address. It's used to avoid the font running I told you about. So here I just need also so as I have multiple claims, I also need to put an array here. So the OD request. Okay, so now we are pretty good for the contract. I'm just checking that this is good.
01:20:51.290 - 01:21:21.200, Speaker C: So we have the App ID and we have the same OD and claim. So I think we are pretty good. Okay, now let's deploy. So in the tutorial we have all the steps for you to deploy. I have already set up a mnemonic here to gain some time. We are using Foundry, so we just have to do a first script, deploy, adopt. We have our RPC already set up.
01:21:21.200 - 01:22:02.394, Speaker C: We are going to send it and to verify it. So let's go once during the time it's deploying, I will change here the address. So here we were using a Mumbai fork in local. So I will put the ID of the chain. So this is a Wagme configuration you may already know and I need to change to use polygon. So all of this is explained in the tutorial. So it seems to have been deployed and now it's verifying the contract.
01:22:02.394 - 01:23:10.150, Speaker C: So let's go checking. So, 18 seconds ago it's here, now it's deployed and we can see that we have our app ID, community Group ID and we have all our code. So let's go back now to our front end, switch to Polygon and claim with CISMO. So here we are not in impersonation mode. So you can see here my account generate ZK proof and claim the AirDrop. So it's working. Let's send this going again to the transactions and we can see it here.
01:23:10.150 - 01:24:02.060, Speaker C: So polygons can claim with this more and we see our I think I need to go here. It's not well indexed for now, but yeah, we can see that. We had our adult token of 100 here. So the full case study is available here as I show you at the beginning, you can deep dive more on when we add different level, when we add different groups, ID, and how we compute the final amount of token. Here, it was only 100. And, yeah, thank you for your time. Enjoy your hack.
01:24:02.060 - 01:24:38.860, Speaker C: And maybe we have any questions available or I don't know if we have the time. No, we don't have the time. Okay. Yeah, we have the time for a question. No. Okay, there if you have any questions. Thank you.
01:24:38.860 - 01:25:55.340, Speaker C: Yeah.
01:25:56.990 - 01:25:58.700, Speaker E: Okay, 1 second here.
01:26:00.590 - 01:26:01.450, Speaker B: 30 minutes.
01:26:01.520 - 01:26:04.490, Speaker C: So I will signal you.
01:26:04.560 - 01:26:07.298, Speaker F: Yeah, it okay.
01:26:07.384 - 01:27:22.980, Speaker E: Is that that's not 1 second. Okay.
01:27:23.130 - 01:27:23.924, Speaker D: Hello.
01:27:24.122 - 01:28:06.420, Speaker E: My name's Matt Hamilton. I'm a developer advocate with Protocol Labs working on Filecoin and specifically the Filecoin virtual machine Fem. So what I'm going to talk about today is storage and retrieval using Fem and a little bit about Filecoin set the scene for people that maybe are not quite aware about Filecoin and about IPFS for example, and the differences between them. So let's just talk a little bit about what Filecoin's Grand Vision is, the Filecoin master plan. So step one is build the world's largest decentralized storage network. Well, we've done that and we're continuing to build. The current storage network is about 14 exabytes of data.
01:28:06.420 - 01:29:06.384, Speaker E: So that's 14 million terabytes. Of data. So it's about 1% of the total data center storage capacity worldwide at the moment, and continuing to grow step two onboard and safeguard humanities data. So we're taking data on currently from a number of different data sources. So things like scientific data, anything from scientific data to NFTs, everything in between that people want to store on a decentralized storage network to keep long term. And then step three is bringing compute to the data and enable web scale apps. And that's where really it gets interesting at places like ETH Global and talking about Fem, the Filecoin virtual machine, because Fem is the element that allows you to do programmable storage on Filecoin, so you can kind of think about it as various sort of layers.
01:29:06.384 - 01:29:39.184, Speaker E: So right at the very bottom we have a peer to peer network based on Lib P to P, which is also another technology from FalcoIn. And you've got things like IPFS. IPFS is another decentralized network by Protocol Labs. You might be familiar with it, especially if you've done anything recently with NFTs. It's used very much a lot for that. But IPFS is kind of a non blockchain solution. It's just a decentralized storage network, but it doesn't have the crypto economic model that Filecoin has.
01:29:39.184 - 01:30:19.816, Speaker E: So with IPFS, when you store data well, I'll go into this in a little bit more about the kind of the approaches you have with regards to storing data and why we now have things like Filecoin. But you can think of layer zero, Filecoin as being the storage layer. You think of layer one as being Fem, the compute over state that we now have that Fem enables. And then layer two will be things like what, hopefully people within this room and here at this event might be building on top of Filecoin. So decentralized applications and solutions built on top of this. You might notice a little corgi there called Biscuit. Biscuit is Filecoin's mascot.
01:30:19.816 - 01:31:03.736, Speaker E: And you'll see a little bit more about Biscuit as we go along in this talk. So this is kind of the evolution of storage, kind of starting from things like IPFS, which was now, I think about eight, nine years old now, through up. Filecoin is now about three years old. The FBM was launched earlier this year in March. And so these are kind of like the evolution of decentralized storage. So I talked about the different kind of approaches and if we look at, for example, IPFS, so IPFS gives you various ways in which you can store your data. So the first one is that the client can have their own node or nodes.
01:31:03.736 - 01:31:52.008, Speaker E: They can run their own nodes and store their own data. So you can spin up your own IPFS node, run it locally on your laptop or whatever, and pin data to that, and it can be then replicated on the network. The problem being is that if you turn your laptop off or whatever, then that data is no longer available. Another approach is you can run nodes with a community, so you can get a whole bunch of people within your community that are all running nodes as well. So collectively between you, you are storing that data and there is no one single point of failure. But again, this relies upon your community to all be storing that data. And then another one is just the client storing it on their own in which they use something like a pinning service.
01:31:52.008 - 01:32:46.812, Speaker E: So that's to prevent the situation, like I said, where you turn your laptop off or whatever and suddenly your data is now inaccessible. So services like infura Pinata you might have heard of, offer IPFS pinning services. So you pay them a fee and they will pin your data on the network. Pinning is the process by which a node says I want to keep this data on the network. It might be stored on multiple other nodes, effectively cached, but pinning is keeping it live on that node so it won't ever expire from that node. Now one of the issues with this being is that if you're using something like one of these centralized services like Pinata and suddenly your credit card expires or they go offline or whatever it might be, then suddenly there's nobody pinning your data potentially, and your data may cease to exist. Filecoin is an attempt to solve that problem.
01:32:46.812 - 01:33:19.560, Speaker E: So Filecoin is actually a separate network to IPFS. It uses a lot of the same technology as IPFS. So you might have seen with IPFS what are called content IDs. Content Identifiers, if you see an IPFS address, it normally starts slash and then a long string of what might seem like random letters in that address. Now that address is actually a content Identifier. It is a hash of the data that you are storing. And actually my colleague dawn has a really good analogy for this.
01:33:19.560 - 01:34:26.872, Speaker E: Now imagine you are going the difference between content addressing and location addressing with location addressing, which is what Http uses would be the equivalent of say, saying to somebody, look, I need you to go and get some my favorite cereal from the grocery store. They say, okay, well, what is it? You say, well, it's on the third shelf on the left, second up, and it's the fourth box along. You go along to the supermarket and maybe that box has moved, they've done a restock or they've moved stuff around or some kid has been messing around with stuff, then suddenly it's not in the right place and you don't necessarily get back what you expected. Whereas with content addressing you're actually describing the content itself. So you might say, okay, my favorite cereal has got a picture of a red bowl on the front of it. Its UPC number is this, it's 750 grams. And you could describe the contents of it and it doesn't matter where it is, somebody can find it within the shop, right? They can go in there and find the box of cereal that matches that description.
01:34:26.872 - 01:34:52.932, Speaker E: And the great thing being is it might not be in just one place. They might have say, a special offer on or a sale or something, and it might be up near the cash register as you walk in. And you don't have to necessarily traverse the whole shop looking for it might be right there in front of you. They might have it in multiple locations. And a Content Identifier is a bit like that. A Content Identifier is a hash of the data. It describes the data itself, not where it is, but what it is.
01:34:52.932 - 01:35:23.096, Speaker E: And one of the advantages with that is when you get that data down, you can check the address against the content you have received. So you can be sure, without needing to trust any other service, that the data you have been served is the data that you are expecting. That's used on IPFS. It's also used on filecoin as well for storing data on filecoin. They both use these content. Identifiers CIDs. So with Filecoin, the data is stored off chain.
01:35:23.096 - 01:36:10.940, Speaker E: You negotiate a storage deal with what's called a storage provider to store some data for a certain amount of time at a certain rate, right? So I want to store 4GB of data for two years and I'm willing to pay this amount for it. Now that data is transferred effectively, well, it can be transferred off chain. It's transferred off chain through various mechanisms. It can be downloaded by Http, could be using one of the IPFS protocols like bitswap that IPFS uses. It could literally be a station wagon full of hard drives turning up with the data on. Remember, the data network FalcoIn is designed to store petabyte ranges of data. So it's very flexible in how you actually get that data to a storage provider.
01:36:10.940 - 01:37:32.088, Speaker E: Once the storage provider has that data, they then seal the data, which is a process, cryptographic process, in which the data is transformed into a form in which they can run proof of spacetime validations over that data. So what happens is the blockchain, every 24 hours queries the or sends a challenge to the storage provider to say, have you still got the data? Right? And there's two proofs, proof of replication and proof of spacetime that are used by the client, by the storage provider to prove that they still have the client's data and they haven't lost it. Now, the storage provider and the client both put up some funds for this storage. So the storage provider has to put up some collateral and the storage client puts up their fee. So if you were to store the data for, say, two years, then the fee which you put up gets put in an escrow and then paid out to the storage provider over the space of that two years, again, the storage provider also puts up some collateral. And if, for whatever reason, they lose the data, then that collateral is slashed. So there's a financial incentive for the storage provider to keep the data online.
01:37:32.088 - 01:38:21.748, Speaker E: This is the bit that gives you the decentralized equivalent of pinning on IPFS, right? So the Filecoin blockchain contains a whole series of proofs that the data is stored and information about the storage deals, which storage providers are storing the data and for how long. Now based on top of that, we now have the Filecoin Virtual machine. So the filecoin virtual machine is a polyglot virtual machine. It uses WebAssembly. It has a WebAssembly runtime in which you can build additional runtimes on top. So the first runtime we built, which is why we are here, is the Filecoin Ethereum runtime, the Fevm. The Fevm allows you to run Ethereum bytecode directly on the filecoin layer one network.
01:38:21.748 - 01:39:25.868, Speaker E: So anything that you write in solidity that you can compile down and run on ethereum or Polygon or whatever, you can run on Filecoin as well. That allows you to then build on top of that decentralized apps, DApps, Data, Dowels, tooling like Bridges, all that kind of stuff because you're using the same technology that is being used on other EVM blockchains. So it makes that a lot easier and that enables things like decentralized compute as well. So either compute over the state that we have on the Filecoin network or off chain compute over the data itself. So Filecoin the Fem doesn't allow you to run to access the actual data. And if you think about it, the reason why is if you're storing gigabytes of data, you don't want to be trying to load gigabytes of data into a smart contract, especially not when you've got a blockchain that's ticking along 30 seconds per block. By the time you've loaded all that data in, you'll be out of execution time.
01:39:25.868 - 01:40:28.690, Speaker E: So any heavy lifting and compute you would do off chain. You could then record the result on chain, for example through something like an Oracle. You can also build some interesting DFI use cases. So I mentioned before about how the storage provider has to put up some collateral and the client puts up a fee that is paid out over time. So you can build things like loans that are collateralized on that future revenue that the storage provider will be receiving. So this is equivalent of invoice factoring in the traditional business world, right? A storage provider can prove on the blockchain that they have this future revenue due to them from the storage deals that they have and they can potentially lend or borrow against that revenue. So you get some very interesting DeFi use cases in which you actually have bare metal ultimately at the bottom of this DeFi system and you actually have storage providers collateral there.
01:40:28.690 - 01:41:45.476, Speaker E: So I mentioned the Fevm is fully EVM compatible and so it's built like I said as a polyglot kind of WASM runtime that you can create additional runtimes on top of. So the one that we're interested in is the one in the top right here, the EVM runtime that we have, right, so that allows you to use Hard, HAP, Remix, MetaMask, all the tools that you'd usually use for ethereum development. You can just put in the filecoin RPC endpoint and deploy and execute directly against filecoin in the same way that you would do something like Ethereum. So in terms of runtime, we're also working on a thing called Interplanetary Consensus IPC. So this is the next layer of scalability for filecoin and you can think of as like a layer two execution layer for filecoin but also gives subnets. So it's like sharding the network into horizontal scalability with subnets that you can use as well. We're also working on allowing what we call native user defined WASM actors.
01:41:45.476 - 01:42:34.356, Speaker E: So in the filecoin world we refer to smart contracts as actors within the network. And soon you'll be able to actually compile directly down to WASM and run WASM actors. So you might be able to write your smart contracts, for example in Rust or TinyGo or Assembly Script and compile down to WASM rather than in Solidity and things like new foreign blockchain runtimes. So we can run additional runtimes on top. So we might have say, a Solana runtime, for example, on top of there, for example. So what can the Fem solve? Here's an example of things like data dows. So, this is effectively a two layer.
01:42:34.356 - 01:43:26.132, Speaker E: It's meant to look like a cake there, but on the bottom layer we've got some primitives that Fem enables, things like repair workers. So I mentioned about how a storage provider has to prove that they have the data still. You could have a smart contract that actually checks that. And if one of the storage providers is not able to provide your data, that the smart contract could negotiate a new storage deal to replace that failed one from a known good one and automatically effectively heal the data. You could have renew workers. So you could have perpetual storage when the data comes to the end of its storage deal or when the storage deal comes to an end rather that a smart contract could renew that storage deal and continue on further, you could create new storage deals as well. So you could have something like a data dow.
01:43:26.132 - 01:44:25.870, Speaker E: So building on the next layer now this green layer on top, you have things like governance tokenomics, things like endowment management. So you could create things like data dows in which you have a decentralized autonomous organization in which the participants are voting on the funding of storage. Imagine something like commons good data. For example. Somebody had the example of a film festival in which a film festival the participants within the film festival could effectively vote on the films that were showed in the film festival, but also on effectively what would become the long term storage of that data as well do things like endowment management. So a smart contract could actually actively invest funds that it has been supplied with and use those funds in something like a DeFi lending pool and use the interest earned from that to fund the long term storage of the data. So you can have some perpetual storage in that way.
01:44:25.870 - 01:45:15.500, Speaker E: So I mentioned Biscuit, our little corgi mascot from FalcoIn. So I'm going to give you an example of a datadao called the Biscuit Data Dow. This is an example datadao we've come up with mainly my colleague Sarah, who has a very active imagination and loves corgis. And so we're going with this, the Biscuit datadow. So Biscuit datadao is a community of corgi dog owners that want to better understand their corgis. So as an example, you might have a bunch of corgi owners that submit data to a data Dow about their dogs. It might be behavioral data, it might be video data, I don't know, biometrics of corgis, maybe corgi fitbits.
01:45:15.500 - 01:46:01.332, Speaker E: That's not a crazy idea as it sounds. I actually worked for a startup that was going to pivot into dog fitbit type tracking. It was a crazy idea. But anyway, the idea being is that you could take this data from these individual participants of this Dao, store the data within the Dow, and then the Smart contract could do things like wait until the data reaches a certain level. Maybe they have to upload data in some periodic time fashion. Like maybe they have to upload the data every Monday to Friday and get like a streak, for example. Maybe they have to get a five day streak and if they do that, then they get some kind of reward.
01:46:01.332 - 01:46:38.444, Speaker E: So Smart contract could mint some sort of token. It might be something like an NFT. It might be a fungible token that could be used to reward the corgi owner for supplying their data to the network. And what could that data be used for? That data might be used for things like training AI. Right? So imagine you've got all this corgi data. Now you could actually use that to train an AI model. Maybe that AI model is used to create almost like a Robo vet, for example, that allows you to ask questions about your corgi's behavior.
01:46:38.444 - 01:48:18.620, Speaker E: Maybe this AI could then refer to that data and the training of that data is paid for by the Dao and the corgi owners. Maybe they get a governance token. They can vote on the actions that happen, whether that's some training data that happens. They might get some rewards that could be used for services within the Dow. So again, things like veterinary services, for example, you could get some discount or reward for supplying the data that could then be used against real world services as well. So the Dow Treasury, once the Dow takes these funds in the Dow treasury could then potentially actively invest those funds through things like liquidity pools, DEXes lending pools for example, that then support the Dow going onwards. So it could be effectively self sustaining by generating revenue that way that then funds the persistent storage of that data the renew, the repair, the replicate that I mentioned before to keep this data active and the end result healthier, happier, corgis achieved, right? So that's an example might seem a bit of a trivial example but it hopefully gives a bit of a flavor of the kind of thing that you can build up using Fem using filecoin, using things like data Dows on top of the network and you can access things like off chain compute.
01:48:18.620 - 01:49:20.390, Speaker E: So protocol labs have a project called Bacayao that is a decentralized compute platform. And there's a bridge called Lilypad that allows you to from a smart contract pass. For example, like a prompt to stable diffusion running off chain. That could then generate an image that could then be stored in IPFS, that could then be returned back to Fem to mint an NFT that points to that image that was generated and that is stored on IPFS. So you can kind of go full circle there between on chain and off chain with data there's a bunch more Fem compatible tools. So there's things like there's a filecoin localnet docker image that you can run, you can spin up on your laptop a local effectively filecoin network and run locally. You can then play both sides of the equation by being a storage provider yourself, right? So you can actually not only create storage deals but accept those storage deals, reject them, whatever.
01:49:20.390 - 01:50:40.956, Speaker E: There's cross chain bridges, sealer and Axler for example, both on the token side and on the general message passing side oracle things like Teller Access Control, Lit Lighthouse which is a storage aggregator, a number of DeFi protocols as well that are being created. So there's a project called Glyph that's that top icon there you might not be familiar with in the top right glyph has created a big lending pool that allows you to do staking of filecoin token and that can be lent out to storage a number of network analytics APIs. So Zondax have a network explorer called Barracks that allows you to interrogate the network. There's one by Protocol Labs called Starboard as well decentralized Compute Bacchiao I've mentioned that allows you to run decentralized compute jobs. So there's a whole bunch of stuff within Fem and more stuff kind of coming as we go along. And if you want to find out more, there's a QR code there. If you want to scan that QR code or go to that link tree address at the bottom there, that will take you to a list of resources, including if you're doing a hackathon, you'll see a link there to the hackathon, what we call a hackathon cheat sheet.
01:50:40.956 - 01:51:02.984, Speaker E: That is a document we have on GitHub that gives you a sort of full list of various different resources around Fem as well. So there we go. I think that's the end. Yes. So thanks very much. Here's a bunch of the Fem team. There's actually a lot more than that.
01:51:02.984 - 01:51:38.048, Speaker E: This is actually a bit of an old photo now, but yes, it's a big project that's been built by filecoin over a number of years now, but finally live and allows you to run smart contracts directly on the Filecoin network. So thanks very much. If anyone has any questions or if you want to grab us, actually, probably even easier, we're just in the booth, just literally on the left as you go out the door. If you want to come and have a chat to us at the filecoin booth, we can chat there.
01:51:38.214 - 01:51:38.930, Speaker G: Thanks.
01:51:52.780 - 01:51:53.690, Speaker B: Thank you.
01:56:11.950 - 01:56:44.934, Speaker D: Am I live. All right, everyone, thanks for your patience here. My name is Julian Junistu, and I'm going to tell you about unlock protocol. Unlock is a project that has been built about four and a half years ago already. We were here at the last ETH Waterloo, which was in November 2019. What is unlock? Unlock is a protocol from memberships. We'll talk about this for about half hour, through which we'll go first through a bit of theory, and then we'll move to a more practical live coding example.
01:56:44.934 - 01:57:22.618, Speaker D: So first start with a quick overview of unlock, the protocol. Then overview of the ecosystem, the tools, including subgraphs and existing integration. Then we'll go into live coding example, as I said, to see how you can add unlock to your front end applications. Then we'll give a little bit of an intro about how you can also integrate this into smart contracts via the use of hooks. And finally, we'll have a bunch of pointers to docs, guides, repos and tutorials that we have and that you're more than welcome to use as a basis for your own work. First, quick note about myself. So my name is Julian Junistu.
01:57:22.618 - 01:58:04.480, Speaker D: I'm the CEO and founder at unlock. Before that, I was actually a founder at a company called superfeeder, which was sold to medium and we were building RSS feed API APIs. I'm a big, big fan of the open web, the idea that this kind of gigantic brain of ours shouldn't be controlled by anyone and that we should all be able to play in the way we want. I worked with WTC worldwide web consortium for a little bit, and I'm also a big open source advocate, and I'm currently on the graph council. The graph is also a sponsor here. You should definitely check them out. You can find me online at julian 51 everywhere or on my own blog at uvra boat, which literally means open box in English and invite you to check it out.
01:58:04.480 - 01:58:35.174, Speaker D: What is unlock protocol? Unlock protocol is a protocol for memberships. One of my core beliefs is that the web should have a primitive for memberships because we have memberships everywhere. When you think about your Netflix account, it is a membership substack. Subscription is a also, you know, the fact that you follow someone on Twitter, even though it might be free, it's a membership. You're a member of that very exclusive club of people that follow that person. Again, memberships are everywhere. They're also everywhere in the physical world.
01:58:35.174 - 01:59:02.638, Speaker D: Your gym membership is obviously a membership. Your driver license. If you're in the US, and I think it's the same in Canada, expires, it's kind of a membership to the local DMV. You're a member of the people that can drive on the road. So Unlock is a protocol to do all kinds of membership subscription, the one that are recurring ticketing. So if you go to a conference, the ticket to the conference is a membership. For that specific conference you can do stuff like token gating and that's actually what we're going to showcase.
01:59:02.638 - 01:59:45.994, Speaker D: You can also do certifications. Certifications is also a membership. You're certified driver as I just said. Or when you get a diploma from a school, you're also a member of the class of year 2021 or something like this, as I said, founded about five years ago. And we have a team of people that have worked at Google, Facebook, Goodaddy, and multiple other names and companies that you think talk about memberships. If you've been around for the last two years, you've seen all of these NFTs emerge and so well, you can say, well, would any membership, any NFT could be a membership? The answer is no. And the reason for this is like most NFTs are collectibles.
01:59:45.994 - 02:00:11.330, Speaker D: They are not supposed to represent the fact that you're a member of a group. And one of the key missing attributes is the idea that they're perpetual. Once you have a board ape, you have a board ape forever unless you sell it. And that is not a good membership model for the people that are selling these apes to you because they need to provide you services. Imagine that you bought your gym membership by paying once and then you should be able to go your whole life. The gym would probably close and go out of business. Same for Netflix.
02:00:11.330 - 02:01:02.854, Speaker D: So really you need to think of memberships as kind of NFTs that would have some kind of expiration mechanism. Obviously the fact that they have an expiration means that they can be renewed and you can move from something that is one time to something that is recurring, something that happens every month, every week, every year, depending on what is the base duration. Here it goes from the idea that communities and creators will make money through royalties, which is kind of a very strange model, to something that is continuous. Netflix makes money continuously as people keep paying for the service because they keep streaming good shows. Hopefully at Unlock, we also build the protocol around the membership. That's assuming that not all membership will be paid and not all memberships will be paid with crypto. So we have natively in the Smart contract support for mechanism that would allow to pay with credit cards or for example ERC 20s as well.
02:01:02.854 - 02:01:37.806, Speaker D: Like most NFDS are priced in the base currency of the chain. So ETH if it's on main net or Maddox if it's on polygon. We assume that many membership would be priced in stable coins like USDC or Dai, et cetera, et cetera. You can also easily verify off chain the validity of a membership, maybe even verify its validity in a form of a QR code. And we'll come back to this in a couple of minutes. But you can also do on chain access control by verifying from other Smart contracts that a given membership is still valid. Obviously, if you thought about NFTs, you probably think transferable, not all NFTs should be transferable.
02:01:37.806 - 02:02:13.446, Speaker D: There's a concept of sole bound tokens with unlock. You can definitely create a contract for which the NFTs are transferable, non transferable or anything in between. You can say they're only transferable if short term requirements are met. And also we move away from the idea that NFTs should be immutable to something that is more practical, which is NFTs should be able to evolve based on the membership, based on what kind of services are being offered. So the Smart contracts that you deploy when you deploy your membership through Unlock are upgradable by you. Obviously we cannot upgrade them, but you can decide to upgrade and add more features as time goes and change how they behave. Unlock protocol is 1 second.
02:02:13.488 - 02:02:13.934, Speaker E: Oh, sure.
02:02:13.972 - 02:02:14.766, Speaker B: Connect this one more time.
02:02:14.788 - 02:02:17.806, Speaker G: I'll cut this out of the for.
02:02:17.828 - 02:02:20.000, Speaker C: Some reason it's squishing your video.
02:02:21.890 - 02:02:26.400, Speaker D: I'll just get the slides from you after. Do you want me to start back?
02:02:27.570 - 02:02:29.042, Speaker G: I'll just cut out this part right?
02:02:29.096 - 02:02:30.718, Speaker B: I'm here, so it's fine, but I'll.
02:02:30.734 - 02:02:31.618, Speaker C: Just get the slides from you and.
02:02:31.624 - 02:02:32.290, Speaker E: Then put them after.
02:02:32.360 - 02:02:33.860, Speaker D: Okay, cool. Not a big deal.
02:02:35.590 - 02:02:36.340, Speaker C: No.
02:02:40.490 - 02:02:43.058, Speaker D: Maybe it's when we change it, then we change the resolution.
02:02:43.154 - 02:02:43.800, Speaker C: Yeah.
02:02:46.570 - 02:02:47.560, Speaker E: Hold on.
02:02:52.670 - 02:02:53.660, Speaker C: Same thing.
02:02:56.350 - 02:03:00.180, Speaker B: Yeah, well, we were just on this.
02:03:03.270 - 02:03:05.106, Speaker E: Do you have an HDMI Direct here?
02:03:05.208 - 02:03:09.890, Speaker D: I don't have an HDMI dongle myself. Oh, it'd be like in the port. Yes, doing she right here.
02:03:09.960 - 02:03:10.478, Speaker F: Silicon.
02:03:10.574 - 02:03:14.226, Speaker G: That's what I'll just bring it directly.
02:03:14.258 - 02:03:15.000, Speaker D: To the.
02:03:26.450 - 02:03:27.470, Speaker G: That'S better.
02:03:27.620 - 02:03:31.520, Speaker C: Good, perfect. And then.
02:03:35.330 - 02:03:36.382, Speaker E: It was fine on screen.
02:03:36.436 - 02:03:37.722, Speaker A: I'll cut this out after.
02:03:37.876 - 02:04:02.486, Speaker D: Perfect. All right, sorry for the interruption here. So Unlock protocol is made around contract that are updatable. You can change the terms of membership, you can change the price, change the supply, change the duration of each membership, you can change cancellation, term transferability, all of that. As I said, they're also upgradable. Not by us, obviously, but by you. You can choose to change once the protocol support new features, you can.
02:04:02.486 - 02:04:49.362, Speaker D: Choose to opt in for these new features and that's perfectly up to you and fine, but they're also programmable and we'll very quickly allude to this and you're more than welcome to stop by our booth to get more details on this. The Smart contractor has a lot of hooks built in so mechanism to alter how it behaves based on your own logic here, which I think is pretty interesting. And you can build things like discount codes or airdrops when people buy memberships, change how something works on the Smart contract, change the price on every single purchase, et cetera, et cetera. So, key use cases, we grouped here eight. We'll go through three that are the most common ones, but you're more than welcome to do anything that involves the other one. And if you find more use cases, we're happy to hear about them. First one, I talked about it earlier, it's event ticketing.
02:04:49.362 - 02:05:19.582, Speaker D: If you have a ticket to a conference, to a concert, you're a member of that conference, of that concert for the duration of the conference or the concert. Second one, recurring subscription. I mentioned your Netflix account. If you have a substac account that is also kind of a recurring subscription, you pay every month, every week, depending on what the duration is, to keep accessing the content. That is obviously possible to imagine a world in which you have a video streaming platform. You can create a social network where people pay to access more content on a recurring basis.
02:05:19.646 - 02:05:20.078, Speaker F: Podcasts.
02:05:20.094 - 02:05:49.766, Speaker D: We've already whole listen to podcasts that have time components and premium feeds in there, so you should definitely check that out. The next one is the idea of time based memberships. So think seasonal or maybe community dows and things like this. So you can think of a dow that has every year a new class and you need to pay to be part of that class or of that group. And that's a good example of this. It doesn't have to be automatically recurring. We also talk about certification.
02:05:49.766 - 02:06:26.406, Speaker D: Gaming obviously is a big one that you can play with as well. If you play a game, maybe the fact that you I mean, first the subscription would be a thing in the game, but maybe you're going to earn items that are going to expire after some time, and so these items should be NFTs you're a member of the people that have the sword of some kind, et cetera, et cetera. Another use case that we're hearing a lot of in the crypto space right now is their finger on loyalty. So you think you're a brand. You might want to create perks for your most loyal customers. Unlock is a great contract to actually do this attendance. NFTs you probably have all heard of Poaps at this point.
02:06:26.406 - 02:07:06.930, Speaker D: That's another way of building these kind of things. And then obviously digital collectibles, they're still possible to do. And what's interesting about the time component here is that you can have digital collectibles that are dynamic, that evolve over time. So imagine a board egg that actually gets old, that'd be funny as you keep it in your wallet, getting a bit more into detail. So, event Ticketing what's interesting here is like as an organizer, you get all of the proceeds of the ticket that you've sold. It's fully end to end control by the organizer of the conference across multiple mechanisms. You can enable secondary markets or not if you want to by making the NFTs tickets non transferable.
02:07:06.930 - 02:07:58.466, Speaker D: What's interesting that you can create interoperable experiences that apply to both the offline the in person events but also online. So imagine a scenario where only attendees of a conference can join a discord or a telegram server before or maybe have discounts at local hotels and restaurants because they can prove that they have a ticket rather than say hey, I'm at the conference XYZ, can you give me a discount? Well here you can actually prove it because you can prove that you have the NFT, which are pretty cool actually. Example of this dapcon you probably know of this conference, it's one that happens in Germany every year. They use unlock every year at this point and we're pretty happy to have them in here. Subscription. So token enabled access to experience services and features it creates it's really important and critical, a sustainable revenue for the business. So rather than have the crypto space we love like numbers go high.
02:07:58.466 - 02:08:23.574, Speaker D: Well, here you don't actually have to bet on numbers going high, you can just sell your service to the people that are excited about using it. And we pay for this. I'm sure we'll have cell phones and we pay for some apps in here because they provide good services. Well, you can build the crypto version of this. Obviously we support, as I said, crypto and credit card on ramps. We also support Apple Pay, Google Pay and a bunch of other similar system. What's interesting here is like the relationship between the app creator and the consumer.
02:08:23.574 - 02:08:52.742, Speaker D: The app user is direct. There is no Apple approval in the middle. If you follow a little bit, you know, that uniswap for example, took them a month for Apple to approve this. Well, if you have a membership system that is between you and your customers, you can just offer that. You don't have to wait somebody else's approval. That works for content, blogs and stuff, software features inside of application, music, video, podcast, everything you can think of. Here an example of this.
02:08:52.742 - 02:09:31.214, Speaker D: One of our most popular users these days, and you probably don't see it here, but it's because they charge about $300 per membership is something called Alphabet DFI robot. They provide DFI insights and they have a monthly subscription that people pay for. They're at this point generate about $150,000 a year in revenue from that little app and bot that they have on Telegram. So it's actually a pretty cool use case here. Time membership sorry, time based membership. Told you a little bit earlier, no, necessarily need to go much further in here. But a cool example of this is something called Cabin.
02:09:31.214 - 02:10:08.266, Speaker D: You probably know of them, it's an offline group of people that are building cabins or purchasing cabins all around the world and using them as co living spaces. And they use unlock for their yearly membership. Really cool project if you want to check it out at Cabin City. All right, summarizing again the Use cases, events, event ticketing, recurring subscription, time based membership, certification, DMV like Things, gaming loyalty, attendance, NFTs and Digital Collectibles. Let's move into tooling. So, unlock set of smart contract. That's the core.
02:10:08.266 - 02:10:49.546, Speaker D: There's a ton of tools that are built on top of it that are completely optional that you can use. Start with use as scaffolding and then remove once you're done with this. First we have a dashboard which is really the way for creators to deploy the contract without actually necessarily having to do that with code, no code tool, connect your wallet, set a bunch of terms, deploy the contract and you can manage the contract as well. Change the terms, change the visual aspect of the NFTs, AirDrop NFTs to people that you might want to have an NFT in their wallet. We also have a similar flow which we call the Checkout, which is a way for people to buy these NFTs. So as I said, the NFTs can be fairly or it's very dynamic. So there's a ton of stuff that you can do.
02:10:49.546 - 02:11:26.754, Speaker D: For example, charge as I said, with ERC 20s while rather than actually implement the approval mechanism, all of that, you can use our Checkout UI to easily do that and support your users without having to necessarily build all of the system where they would be able to check out. You can also do build that yourself, but again, use the tool that we provide at Scaffolding. More tools subgraphs I mentioned earlier. So aggregating a ton of data listing members. Very useful. Here we have a JavaScript library called Unlock JS that supports deploying the contract, updating them, listing things, purchasing. That's actually the library that we use in our own dashboard.
02:11:26.754 - 02:12:01.938, Speaker D: We have the paywall and we'll go through that in a couple of seconds, which is this Checkout UI that can be embedded on any website. And we have hooks, hooks at the smart contract level so you can change the behavior of the contract. So for example, if you say every time one of the membership is sold, we double the price for the next one. That is something that can be easily done with these hooks. Existing Integration so unlock contracts are ERC 721. I should clarify this, they're 721 plus we add a ton of feature on the base one, so any existing integration that works with 721 will work. There so if you use Ethers JS, well, that should work.
02:12:01.938 - 02:12:35.694, Speaker D: We're actually in the third web directory, so you can use that as well. Web three JS Wagme The example that I'm going to show the demo, I'm going to use Wagme here or any other kind of wallet that works with ESCM 21 that works. Custom integrations are available in some application. We have, for example, a WordPress plugin that's actually pretty cool. We have integration with Magic, so the wallet provider here with Stripe for the credit card, with Superfluid, with Uniswap and a bunch of other things. We'll go through there. And if you build something cool, let us know.
02:12:35.694 - 02:12:58.366, Speaker D: We'd love to feature these integration on our end. Pretty large. I mean, the typical ecosystem play, you might have seen a lot of these names already. There is ways to work with unlock in all of these projects, et cetera, et cetera. Maybe the interesting part about the networks, we're actually on nine different chains. You can only see eight here. The 9th one is called Palm.
02:12:58.366 - 02:13:34.842, Speaker D: It's not a very popular one, but we have a customer that wants to use this. So we are on mainnet polygon optimism, arbitrary celo binance gnosis, and I'm sure I forgot one, but you get the logos here. Cool. Let's jump into a quick front end live coding demo. Hopefully the demo gods are with me today. I'm going to just start by showing you what I built, which is the starting point for this exercise. I built kind of a very dummy blog using actually the one that Next features on their site as a template.
02:13:34.842 - 02:13:56.086, Speaker D: So it's a blog in which I write a bunch of stories. And my goal here is to token gate some of these stories. So here it's not token gating. Obviously you can see all of the content and we're going to go through the steps that are required to token gate the content on that blog. So kind of build your own decentralized substac if you want. The first step that we're going to have to do is obviously authenticate the user. We need to know who the user is.
02:13:56.086 - 02:14:20.030, Speaker D: So for this we're going to add a mechanism for users to connect their wallet and you can use any of the existing tools in the ecosystem. Somebody talked about Connect Kit earlier. Rainbow Kit actually provides this. We have a version of this. We're going to just use that. But again, you can use the one that you want for this. Let me switch to my code editor here and get started with that coding session.
02:14:20.030 - 02:14:49.162, Speaker D: I also have very handy README here and this code is live on GitHub. So I'm going to first maybe share that link with you guys. So if you want to look at this, come on Wi Fi work, please. It's going to be helpful. Yes. Cool. And I'm pulling it because in the README I have the step by step and I'm definitely going to use this here.
02:14:49.162 - 02:15:10.102, Speaker D: So the first step is to introduce to install a couple of dependencies which I should be able to do. Yes. Cool. First step is to install a couple dependencies. I'm using Yarn in that project. You can obviously use any of the tools of your choice here. And I'm installing four or five dependencies.
02:15:10.102 - 02:15:25.938, Speaker D: First one is unlock protocol contracts. That's the abi the description of the contracts here. Second one is the paywall. That's the little embed UI that we'll add for people to purchase. We have a networks package that has all of the configuration for unlocking the networks. All of these packages are completely optional. I'm using them here for convenience.
02:15:25.938 - 02:15:54.900, Speaker D: You're more than welcome to rebuild whatever they provide. Ethers, a JavaScript framework that allows you to interact with smart contract Wagme. Kind of a front end tooling for react with hooks and VM, which is similar to Wagme. I suspect the Wi Fi is not going to allow me to run all of this. It shouldn't take that much time. So maybe let's give it another second or two. Otherwise I'll go through the I've got a recording of that demo, but I'd rather try to show it the live.
02:15:54.900 - 02:16:07.090, Speaker D: Let's actually go and copy that into the next step. So you'll see that inside of the app TSX file.
02:16:09.670 - 02:16:10.146, Speaker F: Right now.
02:16:10.168 - 02:16:46.238, Speaker D: It's the default version. You are familiar of this if you've used Next in the past. I'm just going to add the basic configuration for Wagme, which is basically creating a client. This is nothing about unlock, right? This is not specific to unlock adding Wagme here. This is specific to unlock instantiating a Paywall object. That is an iframe, to be clear, that will allow you to easily connect the user's wallet as connected and rainbowkit do, but also provide the checkout UI that will come into and then I'm just wrapping my component inside the Wagme config so that it's available inside of the rest of the app. At this point, I haven't done much coding.
02:16:46.238 - 02:17:26.926, Speaker D: The next step is to add a connect button and I'll just again copy that and we'll describe what that is precisely. But if I go to my components, I'm just going to create a new file called Connect TSX. And then I'll paste this. This Connect component is fairly basic. It is using the Paywall object and looks like it's not included here. So I'm just going to include it here to create a provider, which is the object that is being used by Wagme to connect to the wallet here. So we're also using the use Connect from Wagme to again link the provider to the application.
02:17:26.926 - 02:17:42.514, Speaker D: And then we have a pretty basic logic, like if the user is connected sorry, if the user is not connected, we show a Connect button that will call that Connect function. And if the user is connected, we will show the address of the user. Let's see if my dependencies have been installed? Yes, they have. Cool.
02:17:42.552 - 02:17:42.754, Speaker C: Okay.
02:17:42.792 - 02:18:14.586, Speaker D: So I'm going to just restart the app for the sake of making sure that everything is up to date. And now if I go to the blog, we'll see that I've not added the button yet. So nothing has changed. But I'm going to add the button, obviously, to my UI. I'm probably going to add that into, say, the where should I say the intro? Let's do that here. So we have this blog and I'm just going to add the connect component here and just save. And at that point, you'll see that a little connect button appears here.
02:18:14.586 - 02:18:32.242, Speaker D: If I click on that one and again, the WiFi is going to kill me here, but we're going to load an iframe. Oh, it's not too bad. We say hey, I actually previously connected. So it shows this message that I'm already connected. But it I'm just going to sign in with Ethereum, the typical authentication method here. Click sign in and at that point we see. Welcome back.
02:18:32.242 - 02:18:44.470, Speaker D: This is my address here. And now I'm authenticated inside of the app. That is kind of the first step. If I click through to see a post, it's still not token gated. We haven't done this, but at least the app knows who I am.
02:18:44.540 - 02:18:46.134, Speaker G: Can you increase the code size a bit?
02:18:46.172 - 02:18:56.010, Speaker D: The code size? Yes. All right. I will increase the code size a bit. Hope better. Cool. Awesome. So user is connected now.
02:18:56.010 - 02:19:22.866, Speaker D: Next step. Let's make sure that we can and I think it's next step, but it's kind of also actually no. We have one quick step to do. We're going to deploy a membership contract. Now I'm going to go ahead and say, okay, this is how much I want to charge for accessing the content on my blog. I created another account for this demo on here. So I'm just going to go to the unlock dashboard again, a tool that you can use to deploy your contract and manage them.
02:19:22.866 - 02:19:46.314, Speaker D: I would definitely recommend that you do so eventually if you want to create your own experience for this, you should go ahead. Cool. Loading. All right, I'm going to go ahead and click on Create Lock. I'm going to deploy it on Gertie. And so I'm going to do my blog membership. Let's make it last.
02:19:46.314 - 02:20:13.310, Speaker D: One day I'm going to sell an unlimited amount of these memberships. So it's not like substack where I'm going to charge every month. I'm going to start per day, but I'm going to make it really cheap. Actually, maybe something like that still may be expensive for one day. But click on looks good. And hopefully, yes, MetaMask is going to pop up and I'm going to just from here deploy the contract. As you can see the function here, MetaMask does a decent job at translating it, but it says create upgradable lock, add version.
02:20:13.310 - 02:20:33.910, Speaker D: We're deploying a membership contract here on the Gurdy network and confirm here. And now we're going to wait for Gurdy to mine this. Hopefully it won't take too much time. I did one earlier today. It was like 30 seconds. Fingers crossed. Once this is done, this is my contract.
02:20:33.910 - 02:20:55.854, Speaker D: It's been deployed from a factory unlock. I mean, me as unlock would have zero control over this. Chris as unlock would have zero control over this. It's my contract. It's exactly as if I went to open Zeppelin, compiled it and pushed it myself, except that it's deployed from a template. So I actually didn't have to do this. Template is audited verified by multiple firms, so I actually don't have to do any complicated things.
02:20:55.854 - 02:21:18.694, Speaker D: It has been mined, but looks like we're taking a couple more seconds to refresh. Yay, done. And I can start managing it. Obviously, there is not much to do right now because it's kind of empty, but the one thing that I will be doing is copy its address into my app. We show a default image for the membership. It's obviously changeable. And here, once this is loaded, I mean, it's going to be an empty list, but that would be where you would see all of the members.
02:21:18.694 - 02:22:10.762, Speaker D: So I'm just going to take the address of the contract here and I'm going to bring it back to the code. Actually, I'll do that afterwards. One of the next thing we want to do, and that's what we change here, is change the blog posts so that when somebody displays the blog well, if they're connected, we will see whether they actually have a valid membership. For this, I'm going to use I'm just going to copy that. But I'm going to use especially this function from Wagme called Use Contract Read that allows you to query through Rugmi a smart contract and check whether something in the contract, I mean, check the data of the contract. And so we'll just copy that into the blog post itself. No, and I'm going to do this.
02:22:10.762 - 02:22:33.470, Speaker D: And so let's actually go through the code quickly. That KoneC component. Oh, overwrite. Cool. Did I change this? I don't think I did, but let's see afterwards. So I'm going to paste the address of the contract that we just deployed here as the lock address here, and we'll go through that. So basically the top part isn't changed, it's the default that we got from Next.
02:22:33.470 - 02:23:13.358, Speaker D: Then we're actually going to see use the user account hook from Wagme to check the user's address and check if the user is connected. More importantly, once the user is connected, we will check using this Use Contract Read, the balance of the user. So basically, using the argument address, we're going to check whether the user has a valid membership. And since this is the ESC 721, we can use the function. Balance off that function will return zero. If I don't have a membership, or if that membership is expired or one or more if I have one valid or non expired membership. Does that make sense? Yes, we're passing the smart contract address, we're passing the API, we're passing the chain ID, it's on Gertie here.
02:23:13.358 - 02:23:45.554, Speaker D: And we're also, for simplicity's sake, just returning a boolean rather than the number of membership. Yes, the user should have access or no the user shouldn't have access. We'll come back to this in a second. But we're adding a function here that's called on purchase that will let the user purchase a membership unless they have one. And then we just move into the display logic here. If the user is not connected, we'll just show the you're not connected connect with the button that we created earlier. If the user is connected but doesn't have access, we'll just show, hey, you don't have access but you can purchase a membership.
02:23:45.554 - 02:24:07.294, Speaker D: And that's when we'll call that unpurchase method that we just discussed. And if the user is connected and it has access, well, we'll just show the content of the body. Makes sense. Nothing too fancy here. Hopefully just going to save that and move back to the live code. Actually the post is already there, it's self updated. It turns out that I'm connected, we connected earlier, but I don't have access.
02:24:07.294 - 02:24:25.294, Speaker D: So I'm just going to click on that purchase membership button. At that point we load the checkout UI from unlock. Loading the UI is fine. Querying the RPC endpoint. Shouldn't take too much time. Yay, we're showing this option. What's interesting here is you only see that my blog membership, but I could have had like two or three different types of membership for different prices, different tiers.
02:24:25.294 - 02:24:54.422, Speaker D: Like I could have the gold plan or the silver plan. Here I just have one. We show the price, we show it's unlimited, we show it's for one day. Click on next. I'm already identified because I connected myself earlier, I'm going to be able to change the recipient. It's actually an interesting here where I can buy the membership either for me, you see this is my wallet address, or for another wallet. If I want to offer somebody a membership, I can just go use that flow and then they would get the NFT in their wallet and then they can come read the blog if they wanted to click next year I'm going to choose a payment method by default.
02:24:54.422 - 02:25:27.170, Speaker D: Obviously we show the currency that the user has enabled here. So 0.1 ETH. But we're also trying to find other option and for example, we support natively, the concept of swap and purchase, which is a mechanism where if I don't have enough ETH, but I do have USDC, in one single transaction, the user will be able to spend the USDC that would get swapped into ETH into a membership at once. It's taking forever to load. I suspect this is the slow Wi Fi. There's actually not going to be a lot of other option because that wallet that I have only has USDC, sorry, only has Girdy ETH.
02:25:27.170 - 02:25:42.106, Speaker D: Just going to click here, seeing the confirmation screen and it's loading. Yeah, one key. That's the name of the membership for me at that address. It's going to be 0.1 e. I'm just going to pay with crypto. MetaMask is going to pop up.
02:25:42.106 - 02:26:00.610, Speaker D: Please MetaMask. MetaMask when you click this is actually running a simulation and that's why it's taking time. There's a network call involved here. I'm going to spend 0.1 E plus a little bit of gas, as you know. Confirm here. We now have this little wait screen and hopefully it won't take too much time, but you will see that right away.
02:26:00.610 - 02:26:27.510, Speaker D: When that membership has been bought and the transaction has been confirmed, the content underneath the screen will update. So hopefully again, shouldn't take too much time, but can hide this. Oh, I use a different account, I guess. I didn't even connect with the Ethwadalu address that I had, but you'll get the confirmation anyway. Yay. So MetaMask confirmed. We pretty use a different RPC endpoint.
02:26:27.510 - 02:27:05.310, Speaker D: Hopefully we'll get that shortly. Yay, return to site and Wagme should update, please. Wagme update this. Okay, so we use this flag in Wagme that allows you to watch, that allows you to refresh. I guess it's not refreshing here. Let's refresh the page just to make oh, what is going on here? Demo effect. Full force.
02:27:05.310 - 02:27:34.756, Speaker D: What's going on? Did I mess up my why is window is not defined? Of course window is defined. All right, let's actually hide this for a SEC maybe. All right, I'm confused about this thing. Okay, connect my wallet again. Oh my God. That's when things break. That's the one they use.
02:27:34.756 - 02:27:59.324, Speaker D: Connect. Well, yeah, I should be fine. Is this the WiFi? Yeah, it was the WiFi. Okay, signing wallet. All right, going back to the blog post. What is going on here? I'm confused. I made a mistake somewhere in my code here.
02:27:59.324 - 02:28:20.370, Speaker D: But let's refresh that page so I am not connected again. Just going to uncomment this. Connect. Yay, sign your wallet. Sign again. I do have the membership though. All right, well, maybe there is a little something that is not working as I wanted to.
02:28:20.370 - 02:28:36.050, Speaker D: I'm just going to double check this. If it's my code, maybe there's something here and show the address as access. False and 61. That's the address that I'm connected with though.
02:28:38.900 - 02:28:40.128, Speaker H: Possibly you signed in with the.
02:28:40.134 - 02:29:03.084, Speaker D: Wrong wallet because your balance is different when you create. That's maybe what I was thinking. But it looks like it's the same one though. If you look here, it's 61 and then 61 here. So looks like when I created a contract when you actually did the sign up, maybe I did the wrong one. Okay, let's do it again. This one? Yeah, it looks like this one didn't have one.
02:29:03.084 - 02:29:14.020, Speaker D: So purchase. I guess I didn't buy with that one before.
02:29:16.970 - 02:29:17.990, Speaker C: Confirm.
02:29:26.470 - 02:29:37.236, Speaker D: Google's being blocked normal. I don't know why. Go ahead. Mint.
02:29:37.268 - 02:29:37.556, Speaker B: Mint.
02:29:37.588 - 02:29:58.062, Speaker D: Mint. It has minted now. Yay. You see it now? So I can close. Now I have access to their content. Don't know what happened the first time, but now I have access to their content.
02:29:58.196 - 02:29:58.880, Speaker C: Cool.
02:30:00.050 - 02:30:17.010, Speaker D: Makes sense. All right, one final step. Obviously, I go back to the dashboard. You see there is two I guess I bought with that other address, which is you're, right? I think it was a different address. I don't know why I did this, but I have two members now on my blog. They're both me. You can see when they expire, both of them.
02:30:17.010 - 02:30:35.962, Speaker D: And I can do a bunch of things. So I'm not connected as the lock manager anymore. I switched accounts. But if I go back to that account that I had, the ethwaital one, which is the manager for this, I am a manager again and I can do things like extend, refund. So it's like, oh, this person actually didn't want one. I can refund them if I wanted to extend their membership. I can do a bunch of different things as well.
02:30:35.962 - 02:31:03.374, Speaker D: A fun thing to do is, as I said, inside of unlock the transferability is really something that is programmable. And we have the concept of the owner of the NFT. So owner off in the EOC 721 sense. We also have the concept of a manager of the NFT. And it could be that the owner owns the manager has the transfer, right? So you can make it so that my hot wallet is the owner. I can show around and like, OOH, look, I have this NFT. The manager, the person that the address that I have to transfer, right, is my cold wallet.
02:31:03.374 - 02:31:26.910, Speaker D: And this is maybe something that I store at home or somewhere else, making it a lot more secure. So if my hot wallet gets compromised, my NFT is not lost. I can just go to my cold wallet, transfer the owner from this previous hut to the new hut, and keep it safe where I'm at. So that's one thing that I can do. Obviously you can also transfer the NFT as the manager here. Makes sense. So that's kind of the rough demo.
02:31:26.910 - 02:31:44.474, Speaker D: Again, sorry about the little issues. Let's go back to the slideshow. So live coding. We did this kind of I think it worked. It's loading YouTube here. So forget about that slide. We also have, as I said, ways to do backend and smart contract.
02:31:44.474 - 02:32:03.458, Speaker D: I'm not going to go into details, but there's actually a video here. You're more than welcome to check that out. Mention the hooks. The hooks are ways to alter the behavior of the contract when there is a new membership being purchased. I'm going to try to make speak even faster. We can change the behavior on cancellation, change the determination of whether a membership is. Valid, so you can say it's valid only if it's Tuesday.
02:32:03.458 - 02:32:31.338, Speaker D: Well, okay, a membership is valid only if it's Tuesday. You can easily do that on the Smart Contract quick video that we have. You're more than welcome to show up on our booth for more details, resources okay, quick point. If you want to add any kind of monetization to your project, just use Unlock. That's the way to do this. As a creator, we have a dashboard that you can use to deploy membership, sell verify tickets, all of that. Add credit card processing.
02:32:31.338 - 02:33:08.406, Speaker D: If you want to allow for people to pay in Fiat, you can check this checkout URL, which is similar to what we had in that model. And as a developer, you can integrate directly into your smart contract, into your front end, into your back end, and all kinds of application. Quick inspiration unlock live here. Live Here live streaming you can create hey, something where I live stream and every from time to time, only the members can see the content. Unlock plus lens create kind of token gated posts. Unlock plus Xmtp messaging, so only messaging to subscribers, et cetera, et cetera. Other inspiration you can create NFT lending platforms, subscription tools for people that have multiple subscription.
02:33:08.406 - 02:33:46.242, Speaker D: A fun thing to do is like, you can have voting just for people that have a specific NFT with tele, etc, etc. We have prices and the hackathon, so please build on top of this and hopefully you'll earn some of these team members. Myself, Julian, Chris in the back, kelly in the back as well. Michael at the booth right now, and Shelly was hopefully making it from Montreal, where she's based. Scan these YouTube tutorials, so you're more than welcome to scan that QR code. You can look at my face even more if you really want to. We also have docs and tutorials, so, again, take a picture.
02:33:46.242 - 02:34:21.540, Speaker D: Scan that as well if you want to go to our Doc site where there's a bunch of obviously guides and tutorials and details about this protocol. And then we have for creators, kind of a lot of no code guides that let you do a bunch of things from Token, getting Discord server all the way to A WordPress, et cetera, et cetera. We're also available on Discord, so if you don't find us at the booth, feel free to ping us on Discord. We have team members all across the world, so someone will be awake at 03:00 A.m. To help you if you're stuck. And that's pretty much it. Thanks for your time.
02:34:21.540 - 02:34:32.950, Speaker D: I think I've stolen the time for Q and A, but maybe nuno. No? All right, sorry. Come ping me afterwards.
02:38:17.640 - 02:38:18.052, Speaker B: Hello?
02:38:18.106 - 02:38:18.710, Speaker D: Hello.
02:38:20.120 - 02:38:22.576, Speaker G: Sorry, would you have a second mic right for Danny?
02:38:22.688 - 02:38:33.370, Speaker B: No, they don't. So I'm going to hand you. I'll use my loud voice for the recording, too, so I'm going to hold it, okay. Or I'm going to give it to you. You're going to hold it? Sure.
02:38:36.300 - 02:38:40.890, Speaker C: It doesn't go from this church, but.
02:38:45.900 - 02:38:47.648, Speaker F: Do you want to use this bump?
02:38:47.684 - 02:38:49.876, Speaker D: Can you use that one so you're not tripping over your wire?
02:38:49.928 - 02:38:52.444, Speaker B: Yeah, I didn't see a power cord.
02:38:52.492 - 02:38:53.090, Speaker D: There.
02:38:57.060 - 02:39:15.300, Speaker B: Your oh, okay. Get displayed to the hooked up to display. I think everyone's at dinner.
02:39:22.770 - 02:39:23.520, Speaker D: Great.
02:39:31.590 - 02:39:32.980, Speaker B: I won't bump it.
02:39:36.890 - 02:39:39.640, Speaker D: Okay, perfect.
02:39:43.690 - 02:39:44.920, Speaker C: Can I help you?
02:39:46.810 - 02:39:48.922, Speaker G: Is it mirroring right now or no, no.
02:39:48.976 - 02:39:49.434, Speaker D: Okay.
02:39:49.552 - 02:39:57.546, Speaker B: Yeah, let's mirror it. I was going to tell him after, but we could hand him out now.
02:39:57.568 - 02:39:59.100, Speaker D: Too, if you prefer.
02:40:02.440 - 02:40:03.830, Speaker H: So yeah, can you.
02:40:06.860 - 02:40:08.184, Speaker E: Oh, I got what you're saying.
02:40:08.222 - 02:40:09.352, Speaker B: I thought you were saying there's another.
02:40:09.406 - 02:40:14.656, Speaker G: Cord we had the last time too, with the pushing.
02:40:14.708 - 02:40:16.780, Speaker E: Yeah, it seems to be this cable.
02:40:17.200 - 02:40:18.732, Speaker G: Can we just plug it directly in your computer?
02:40:18.786 - 02:40:19.390, Speaker D: Yeah.
02:40:22.320 - 02:40:25.230, Speaker F: There does seem to be a fault from the wire. Yeah.
02:40:29.220 - 02:40:30.540, Speaker B: Are we mirroring?
02:40:30.700 - 02:40:31.424, Speaker F: We will be.
02:40:31.462 - 02:40:33.724, Speaker B: I just switched directly to your device.
02:40:33.772 - 02:40:36.256, Speaker D: Instead of no, it should be fine.
02:40:36.278 - 02:40:37.520, Speaker G: About 50 seconds.
02:40:39.940 - 02:40:41.636, Speaker D: Good to go? Yeah.
02:40:41.738 - 02:40:44.164, Speaker G: You have your mic on? Are you guys both speaking?
02:40:44.282 - 02:40:45.444, Speaker B: Yeah, I'm going to hand it to him.
02:40:45.482 - 02:40:45.732, Speaker F: Okay.
02:40:45.786 - 02:40:47.270, Speaker B: Oh, we're on. Good.
02:40:48.360 - 02:40:49.780, Speaker F: We'll have to switch because the record.
02:40:49.850 - 02:40:50.980, Speaker G: Will only capture.
02:40:53.000 - 02:40:54.260, Speaker B: We'Ll coordinate.
02:40:58.540 - 02:40:59.320, Speaker D: A little bit later.
02:40:59.390 - 02:41:00.890, Speaker F: Okay. So I can grab that mic.
02:41:02.700 - 02:41:04.036, Speaker B: How do I start? Oh, sorry.
02:41:04.078 - 02:41:04.890, Speaker D: There you go.
02:41:06.480 - 02:41:07.390, Speaker E: I did.
02:41:08.000 - 02:41:09.228, Speaker G: He's going to grab another mic and.
02:41:09.234 - 02:41:10.060, Speaker C: Give you a hand over.
02:41:10.130 - 02:41:12.796, Speaker G: Oh, I guess, yeah, tweet it for.
02:41:12.818 - 02:41:14.716, Speaker C: Him, but everything should be good.
02:41:14.818 - 02:41:15.470, Speaker F: Okay.
02:41:17.280 - 02:41:18.590, Speaker D: Stream looks good.
02:41:21.520 - 02:41:22.270, Speaker C: Yeah.
02:41:24.560 - 02:41:26.556, Speaker B: That'S a good looking title page.
02:41:26.658 - 02:41:27.310, Speaker D: Yeah.
02:41:41.640 - 02:41:46.648, Speaker G: Switch whoever's, like, by the computer talking. Ideally, you'll still have the audio, so.
02:41:46.654 - 02:41:50.890, Speaker F: It'S not a big deal. So I can sync this one to the same.
02:41:51.580 - 02:41:51.944, Speaker D: Okay.
02:41:51.982 - 02:41:57.740, Speaker G: I think you just hand that around the last one of the day. So should be fine, and then yeah, the whole table.
02:42:17.500 - 02:42:47.580, Speaker B: Check, one, two. Thank you. Hey, guys, let's get started. So we're really excited to show you our new framework called Council. It's for deploying dows and a complete toolkit on top of that, which we'll get into if you're not familiar with DAOs, that's okay, we're going to get into that a little bit, but first let me just introduce who's talking to you. So I'm Ryan Gorey. I'm head of engineering at Dell.
02:42:47.580 - 02:43:28.530, Speaker B: We're a research and engineering company who builds DeFi protocols and tools. And with me I've got Danny, who is our front end lead. And then I've also got Gio, who does business development and community at Dell. So, yeah, we're going to talk a little bit about what Council is, what we built, and why it's important, and then we're actually going to deploy contracts, configure, and run the UI and create proposals. This seems like a lot to do in 30 minutes, but we have tools that are going to make this really streamlined and really easy, so we're pretty excited to show it off. After that, of course, we've got prizes. We hope that you all will build on us, and we'd love to work with you all on that.
02:43:28.530 - 02:43:33.680, Speaker B: So to get started, I'm going to hand it off to Danny and he's going to tell you a little bit about council.
02:43:34.500 - 02:44:11.340, Speaker H: Thanks, Ryan. So, decentralized governance. Just out of curiosity, how many of you have ever participated in a Dow or voted on a proposal or any of that type thing? Awesome. So as you know, this is a big topic and we don't have time to discuss everything about decentralized governance. But I do want to point out sort of two ideas, maybe plant two seeds in your head on why council is maybe a little bit different than what you're used to. The first one is that first bullet point you see there. It's the flexible definition of voting power.
02:44:11.340 - 02:44:49.944, Speaker H: So many of us have probably seen like a one token, one vote type of model. Maybe if you're in a smaller group, you've got a Snapshot Poll and then a multi SIG that actually executes the proposal for council. We want to build this kind of for the future. So maybe one token, one vote doesn't make it to be the actual perfect way to structure a Dow. So we want to build that into our protocol. So we'll see this in a minute. But the component I want to put into your brain right now is that voting vaults is the way we accomplish this.
02:44:49.944 - 02:45:15.840, Speaker H: It's a very flexible way to define voting power on your own terms. That could be NFT ownership. It could be one token, one vote. If you're a fan of another Dow that does things similar to you, you could even adopt their token as your voting token. It's entirely up to you. So your creativities and imagination is kind of the limit there. And then the other big piece I want to just point out is the trustless execution.
02:45:15.840 - 02:45:59.712, Speaker H: So if you're in a small group, maybe you have a Snapshot Poll, which is like a sentiment on chain poll, but then you're trusting a multi SIG, like a three of five or a five of seven to actually implement and execute that. And that can be hard to do at scale. So with council, you'll be able to vote on proposals, but it's also the execution of those proposals that can happen trustlessly. So anyone can be the one to actually hit the button to execute that proposal. So that's kind of the two big differentiators I wanted to mention. Definitely come by our booth and nerd out with us about governance. We got a lot of really interesting thoughts about it.
02:45:59.712 - 02:46:43.628, Speaker H: So the next thing I want to just point out real quick before I hand it back to Ryan to get back into the meat of the workshop here is we've got sort of two main components. We've got the core voting contract, and this is where your proposals are going to be created. This is where you're going to vote. And then the other piece which I just mentioned is going to be the voting vaults. And simply put, these are just smart contracts that have a single query vote power method on it and you can define the body of that method however you want. Again, it could be based on your balance of tokens, it could be based on your NFT ownership, any way you want to structure that. So you would call query vote Power, pass it the address that you want to.
02:46:43.628 - 02:47:33.580, Speaker H: How much voting power does this wallet have, does this contract have? And you get back that number and that's the extent of it. Council has a bunch of other plug and play features that we invite you to read our docs. And today we're going to go into that last one more specifically, which is the locking vault that kind of represents that one token, one vote concept. So we'll get into that today. And as Ryan mentioned, we do kind of consider the Council protocol as sort of a full stack solution for governance. So that's not just the contracts, but a reference UI, a TypeScript SDK if you want to get scripty. And then we have this CLI that you'll see today where we can deploy contracts and even interact with them on the command line.
02:47:33.580 - 02:47:37.520, Speaker H: So with that said, I'm going to hand it back to you, Ryan.
02:47:38.260 - 02:48:07.850, Speaker B: Thanks, Danny. So, yeah, let's get into demos. So the Council kit today is just a mono repo, basically. And if you haven't worked in a mono repo before, it's just a single repo that has multiple packages and apps within it. And so you can find that on our github.org delve slash Council kits. And then you can fork that like any other GitHub repo and start using any of those tools that we talked about, the CLI SDK and the UI, which you'll find in the app there.
02:48:07.850 - 02:48:51.236, Speaker B: So I've got that cloned down already and what I'm going to do is the first thing I'm going to do is deploy some contracts. We need a place to deploy that, so we need to spin up a localhost network so that we can just test around. If you want to spin up a node, we can do that with the CLI as well. And then within a mono repo, you're going to start with yarn workspace for every command that you're going to call. So then at that point you're going to say the name of the package or app that you're going to call a script on. So in this case it's going to be at Council CLI. And then the CLI is meant to be really easy to use.
02:48:51.236 - 02:49:14.590, Speaker B: You don't have to know the commands, the options or anything. You can stop at any point in your command. And what it's going to do is fall back to this prompting interface. So if I just leave it at Council, which is like the entry point of the CLI. We'll see that we're going to get prompted and it's going to help us walk through the rest of this CLI. Yeah, definitely. How's that?
02:49:19.300 - 02:49:20.050, Speaker C: Good.
02:49:21.860 - 02:49:46.680, Speaker B: Okay, awesome. So now we've got our Prompt UI, which is going to kind of walk us through the rest of the command that we want to run. So again, you don't have to know how to use this, just call Council and then walk through multiple choice here. So I'm going to go ahead and start this local server. I'll accept the default port number. And there we go. Now we've got our node running and a bunch of accounts similar to Hard Hat and Anvil.
02:49:46.680 - 02:50:44.018, Speaker B: All of these accounts are going to be the same as the accounts that will get spit out in those networks as well. So if you have these added to your account or to your wallet, you can start using them right away. So now that we have that running, let's go ahead and start deploying. So I'm going to say Yarn workspace at Council CLI and I'm going to stop again at the entry command of just Council. So I've got my prompt now and this time I'm going to go down to deploy. So with the CLI you can deploy any of the contracts within the Council protocol if you want to do like a piecemail deployment or some kind of custom deployment. But then there's also two commands in here that are kind of like template deploys.
02:50:44.018 - 02:51:14.666, Speaker B: So we have a default one which we won't go into today, but I encourage you to go and look into that if you're interested. But what we will be deploying is this simple deployment here. And so this is just going to be one core voting contract that Danny mentioned earlier. One locking vaults so that I can deposit tokens and get voting power. And then also if I don't already have a treasury or a voting token deployed, it's going to deploy those for me as well. So I'm going to choose simple. I'm going to pick the chain I want to deploy to which is localhost.
02:51:14.666 - 02:51:44.400, Speaker B: I'll accept the RPC URL, that's the default one and that's what my server is running on. And then I need a wallet key here. So I'm going to grab one of the wallet keys that I had over here on these initial counts just to pay for this transaction. Awesome. So like I said, this is a new local network. There's no voting token deployed on this thing. So I'm just going to go ahead and hit blank here where it's asking for my voting token address.
02:51:44.400 - 02:52:12.650, Speaker B: I'm just going to hit enter and at that point it's going to ask me for mock voting token name. So it's going to deploy something called a mock ERC 20. It's just an ERC 20 with some extra methods that you can call to set balances of certain accounts or mint and anybody can call those. So it's really good for testing. So I'm going to accept the default mock voting token in MVT there for the symbol. And there we go. Now we got a mock ERC 20 that's been deployed and we have our address here.
02:52:12.650 - 02:53:01.316, Speaker B: So the next thing that's going to get deployed is our core voting contract. And the first thing you have to decide for this is how much voting power is it going to take to meet Quorum for this core voting contract. This doesn't mean so for example, right here, the default, I've got a million, doesn't mean that there needs to be a million votes towards yes to make the proposal pass. It just means that there has to be a million votes towards the proposal and then if the yeses have it, then the yeses win and the proposal can be executed. So I'm going to leave this as a default, as a million and then I need to choose how much voting power someone has to have to create a proposal. So this is really a mitigation for spam. You don't want a bunch of people just coming in and creating proposals if they're not engaged with your Dow.
02:53:01.316 - 02:53:29.164, Speaker B: So setting this kind of minimum proposal power just make voting power makes it so these people have to be kind of engaged, right? They have to have some stake in the game. So I'm going to accept the default there for 25,000. And there we go. We've deployed our core voting contract. So the next thing that we're about to deploy is our locking vault. This is the one that you put tokens in and it's going to give you voting power back. And the first parameter that you're going to have to choose is a stale block lag.
02:53:29.164 - 02:53:49.944, Speaker B: I don't want to go too much into detail on this. It's a kind of complex parameter. Usually you can just accept the default. And the idea here is that it should span the entire length of your proposals. You don't want this to be shorter than your proposals, but for local testnets, probably just do something like 100. Keep it kind of low. There we go.
02:53:49.944 - 02:54:30.950, Speaker B: So we got our locking vault deployed and we got the address, but then you'll also see that we deployed a locking vault. Simple proxy. So simple proxy. If you're not familiar with like upgradable proxies, this is a pretty typical pattern for upgradable contracts. Basically we can use the proxy address as kind of a fixed address and we can change out the contract behind it, in this case the locking vault, without having to change what address is approved inside of our core voting contract. So now that that's deployed, the last thing I'm going to deploy here is the treasury. We're probably not going to be using the treasury today, but it's going to deploy it anyway just in case.
02:54:30.950 - 02:55:09.010, Speaker B: Okay, so now I've deployed all my contracts and I'm just choosing a name for this deployment. This is arbitrary, it doesn't do anything to your deployment, but it's a name for a file that's going to spit out with all of your information about your deployment and then also a path for where that's going to go. Perfect. So I've deployed all my contracts, I get all my addresses here. And if I go inside of packages, the council CLI, I can see at the path that I chose here deployments. I'll have a new JSON that's going to be all of the addresses and information about my deployment. And this is what I can use as a reference moving forward.
02:55:09.010 - 02:56:04.190, Speaker B: So it's going to have my address, the name of the contract that got deployed, a hash and then the deployment arcs. Awesome. So now that we have this deployed, how are we going to interact with it? Let's get the UI deployed and so we can actually look at our deployment. So I've got my reference over here on the right and over here on the left I'm going to jump over to apps. And this council UI here is the reference UI that we mentioned earlier. So inside of the council UI, if I go to source and config, this is basically where you're going to tell your UI what address all your contracts are deployed to. And then also there's some metadata that you can add in here that isn't available on chain and that'll help inform your users on their voting for their proposals.
02:56:04.190 - 02:56:31.110, Speaker B: We have all of that information in the README. You can definitely check that out. I won't go into all the fields that you can fill out in there, but we have references here for mainnet go early. And then of course, like I said, it's in the README. So today we're just going to be looking at localhost. So I'm going to copy some addresses over there. I need my core voting address right here.
02:56:31.110 - 02:57:07.518, Speaker B: And then I just need my locking vault. We can ignore the time lock for now, we didn't deploy one of those. And for the locking vault, again, remember you want the proxy because that's the one that's going to be fixed. And then one more field I do want to talk about in here is this type. So this type tells the UI what to show for these vaults because you're going to have multiple vaults and they're all going to have different functionality, different ways of measuring voting power. So you might have to have different UIs for all of these vaults. And so we out of the box kind of support the vaults that we've already developed.
02:57:07.518 - 02:57:42.314, Speaker B: So if you're interested to see what those are, capital C, council Config has them listed down here. Which vaults have pre built UIs ready to go if you add in anything else. You can add in arbitrary string, but it's incumbent on you to build out the UI for that vault. It will have a fallback UI, by the way. It'll just show you what your voting power is, but you won't be able to actually do anything with it. Okay, so I've got my addresses in there. Once you've got your configs ready to go, you'll come over here to Council Config TS and map those to your chain IDs.
02:57:42.314 - 02:58:22.442, Speaker B: Today we're just going to be messing with localhost, so I've commented out Mainnet and Gurley and now we're good to go. So from here I'm going to do Yarn workspace again and this time we're going to call something on the council UI and we're just going to say dev to run the dev server. Awesome. So now we have this dev server running on port 3000. And there we go. So the UI is built to be redesigned basically for your brand. We didn't go crazy with the design.
02:58:22.442 - 02:58:49.598, Speaker B: We tried to keep it kind of functional and simple. And the idea here is that we used a UI library that's very themable. We use tailwind for anybody who's familiar with that. It's going to be really easy for you all to rebrand and turn into your own. But we do have a landing page that's kind of a placeholder if you want to build off of this. And then the rest of this is going to be a full blown governance app. So you can see all of the proposals, you can manage your voting power within the voting vaults.
02:58:49.598 - 02:59:19.230, Speaker B: So right now we just have the locking vault. You can see a list of all of the voters that have voting power in this. So you're just curious to see how much voting power or how much someone's been delegated to. Maybe you're looking for someone to delegate to. You can do that here. And then you can also see some details about yourself in your profile, which is also what you'll see if you click on one of the voters in the voters list. So you can see some stats about them as well as their voting history, which is kind of fun to go back and see how people have been voting.
02:59:19.230 - 02:59:40.082, Speaker B: So there's not a lot going on in this UI right now. So we talked about doing two things or three things. We've already deployed contracts and we've got a UI running on top of it. That was pretty quick. So now let's go ahead and create a proposal. If you remember to create a proposal, there is a minimum voting power required. So let's go get some voting power real quick.
02:59:40.082 - 03:00:40.360, Speaker B: And to do that, we're going to have to have some of those MVT tokens, those voting tokens that we deployed. So getting some of that, we can actually use the CLI to do that as well. So if I say Yarn workspace at council CLI, and then I'm just going to stop here at the entry command of council again. Awesome. So you can see we have this mock token down here. This is really just for testing purposes, but I can say mock token and I can say set balance and then enter in my mock voting token address over here. And then the account that I want to set the balance for, I'm going to set it for that first initial account that got funded with my local testnet just because I already have that one in my wallet.
03:00:40.360 - 03:01:14.812, Speaker B: So I'm going to grab it up here. It's the same as the first hard hat wallet that comes out. So if you already have that, it's the same one. So I'll put that in as the account. And then for the balance, I'm going to give myself a million because I want to be a whale and I want to be able to meet quorum on my own 123456. And then I need a wallet key, of course, to pay for this. So I'll grab one of those RPC URL and there we go.
03:01:14.812 - 03:01:46.176, Speaker B: If we go back to the UI, we should see that we have a bunch of voting token balance waiting to be deposited and turned into voting power. So I'm going to go ahead and approve. I'll use default just to approve as much as I can for now. And then now that I've approved, let's go ahead and deposit that. And there we go. You can see my balance went down to zero, but my voting power went up to a million. So I'm getting one for one on my tokens.
03:01:46.176 - 03:02:18.270, Speaker B: And at this point I have enough voting power to meet the minimum voting power needed to create a proposal. So we'll go back to the CLI for that. I'm just running the same command again. And then this time I'm going to go down to proposal. So I'll hit enter there and I want to create. So for the voting contract address. This is the core voting contract that the proposal is going to be created inside of.
03:02:18.270 - 03:02:49.020, Speaker B: So I'm going to grab the address of the one I just deployed and then I need a voting vault. So when I create a proposal, I also get the first vote on that proposal. So this is the vaults that are going to be queried for voting power for that first vote. And then it's also going to be the vaults that it checks to make sure that I have that minimum voting power required. So for this, I'm going to throw in my locking vault proxy there. All right. And so now I need a target address.
03:02:49.020 - 03:03:13.754, Speaker B: This is the contract that's going to get called if this proposal gets executed. So let's pretend that our proposal, we felt like 25,000 was too high of a minimum amount to create a proposal. So let's say we wanted to set that to 10,000. We wanted to lower that. So that was a parameter on core voting. So let's go ahead and target core voting. And then we need some call data for this.
03:03:13.754 - 03:04:02.840, Speaker B: So this is encoded function and arguments for this proposal that's going to get sent to that target contract. Creating this call data can be complex sometimes, but we've got you back with the CLI again here. So if I go back to that entry command again, we can go to encode. And so inside of code, I have every single contract that exists within the protocol. And then inside of these, I have every method so that you can encode any call data for any contract inside of the protocol. So we said we were going to do something with core voting, so let's go to core voting. And we said we wanted to change the minimum proposal power, so let's go ahead and choose that.
03:04:02.840 - 03:04:25.840, Speaker B: What do we want our new proposal power? We said 10,000, so let's put that in two, three, and then decimal precision. I won't go too into detail of what this is. It's pretty common with all tokens. They all have a decimal precision. The mock voting token has 18. So we'll accept that as a default, and then we get the call data that we need. So now I can copy this.
03:04:28.630 - 03:04:29.118, Speaker E: Paste.
03:04:29.134 - 03:05:01.924, Speaker B: It over here as my call data for my proposal, and then, like I said, you get the first vote. So what's the initial ballot going to be? I'm going to say, yes, this is my proposal. And then to pay for this, I'll choose again one of these private keys. RPC URL looks good. Last call block. So this is the block after which you can no longer execute this if it wasn't executed. So if it reaches this block, your proposal is a dud.
03:05:01.924 - 03:05:15.590, Speaker B: You got to create a new proposal. So I'm just going to accept the defaults here. Oh, no, we've got a little error. Let me look.
03:05:28.670 - 03:05:29.178, Speaker F: Yeah.
03:05:29.264 - 03:05:30.780, Speaker D: Are you recording this?
03:05:32.430 - 03:06:14.190, Speaker B: We are, yeah. But I'm happy to sit with you all after too uninitialized. Okay, so I believe this is a problem with the deployment, so we might have to back up and try this again real quick. I might have hit too many defaults, so let's do this really quickly. So I'm going to do it all real fast again. I'm just going to run council, start that server. Okay, so we've got four minutes.
03:06:14.190 - 03:07:02.430, Speaker B: I think it's best probably to go into Q A instead of trying to rush through this and then not leaving any Q A time. I'm happy to sit with anybody who runs into this issue and solve it with you. We weren't running into it when we were doing demos, so I'm sure I just did something on the fly that I wasn't supposed to. But that's how you're going to use the CLI to deploy these contracts to get all the information you need to configure the UI. And then you saw in there, in the prompting UI or the prompting interface, that you can create proposals, execute proposals, interact. With the mock token and encode any call data that you need for these proposals. So with that, we've got some awesome prizes that Geo is about to tell you about.
03:07:03.280 - 03:07:36.008, Speaker I: All right, let's hear about some. Thanks. Thanks, Ryan. That was fantastic. Okay, so our first bounty is going to be around creating a new boarding vault. So we just deployed an entire Dao, and it was based on the locking vault, which is basically one token, one vote for this first price. We really want to hear and to see what you think is important for a Dow, what you think the voting power in a Dow should be attributed to.
03:07:36.008 - 03:07:45.370, Speaker I: So the best custom vault, voting vault, and the best innovative way of defining voting power will go home with a $3,000 price.
03:07:47.100 - 03:07:47.560, Speaker D: Perfect.
03:07:47.630 - 03:08:24.704, Speaker I: Thanks, Ryan. For a second body, we have the best UI integration. You just saw the whole UI that our team worked very hard on creating. But like with all software, there's always room for improvement, and there's always new, exciting things to integrate into it. You could use some sort of universal messaging system, push Protocol Xmtp, or you could create some UI for users to be able to easily create proposals in the Web UI instead of using the CLI, so nontechnical users have a better handle of things. And for this one, we also have a $3,000 price. And last but not least, we have the best use of the SDK or CLI.
03:08:24.704 - 03:08:55.040, Speaker I: As you saw, the CLI is very complete. It's very thorough. But if there's any additional functionality you would like to see on it, or if there's any scripts that you could think of that would be very useful to have to add new functionality to the whole suite, then we'd like to see those too. And there's $1,500 price for that one. And with that, I'll shoot it back to Danny and Ryan. If you have any questions or you can find us in our booth right outside. I think it's right on the other side of the venue.
03:08:58.820 - 03:11:40.050, Speaker D: At least five.
03:12:25.220 - 03:12:27.168, Speaker G: The mic working. Oh, yeah.
03:12:27.254 - 03:12:28.050, Speaker C: All right.
03:12:31.300 - 03:12:32.160, Speaker D: Whoo.
03:12:32.520 - 03:13:03.550, Speaker G: Hey, everybody. I know I'm competing with dinner right now, so thank you all for being here. So I'm going to talk a little bit about Uma. I know some of you have already heard the spiel both at the booth and maybe at side parties. So thanks for coming back again to hear a little bit more. I'm going to talk about how Uma is a decentralized truth machine. And what that means is you can bring any true fact about the world that's provable on chain, and then your smart contracts can use that to either allow or disallow transactions to use the data in whatever way that you need.
03:13:03.550 - 03:13:27.828, Speaker G: And I'll talk about a couple of different applications as well as what you could build at the hackathon. So a lot of people have a misconception about Oracles. People just think like, oh, okay. Data feeds or price feeds? Price data. How do we set up a network of nodes that can deliver the data that we need? With Uma, you don't need a network of nodes. You just need one person that's willing to say, here is a true fact about the world, and also, here's a bunch of money. If I'm wrong, take my money.
03:13:27.828 - 03:14:19.832, Speaker G: That's the basic flow. And that means that you have a really flexible architecture. So you can ask questions that are really basic data. Things like, what's the price of bitcoin? A typical oracle question. Or you could ask natural language, things like who won this election? Or did this deposit happen on this other blockchain? Or what's the result of this off chain calculation that could be super complicated, this like, ZK circuit that you're calculating? Or did this governance proposal pass? Which is actually a use case that we're diving into right now around Dow governance, which I'll spoil right now a little bit, but get into later. So, yeah, optimistic oracles, the pattern is you enforce correctness after a dispute, somebody's making this assertion, they're putting a bunch of money at stake. Everybody's watching the Oracle for assertions coming through, and if nobody challenges them within the challenge window, the data is safe to use.
03:14:19.832 - 03:14:50.444, Speaker G: Everybody had this big financial incentive. You had a long enough challenge window, and 99% of the time, proposals are correct. For that reason, disputes are actually rare. And when we see disputes, it is usually because either the proposer did make a mistake or the disputer made a mistake, or there is some dispute about the wording of a question. And I can talk about some examples. Or you could actually go to Oracle Uma XYZ right now because we have some disputes that are in flight that voting opens up later today. We do refund gas for voting.
03:14:50.444 - 03:15:30.620, Speaker G: So if you get some, you know, $5 worth, you can go and become an Uma voter, and you can spend that gas to vote and know that you're going to get it back as long as you vote correctly. And that's probably the best way to learn how we resolve these things that are around natural language, wording, human, readable questions. So here's what goes into it. You could have somebody that's requesting some piece of data or a smart contract that's set up in advance to expect some piece of data. You have somebody could be anybody who's making a proposal and posts a bond that's required. And then you could have anybody else that's a disputer post a matching bond. If a dispute comes up, you need a dispute resolution process.
03:15:30.620 - 03:16:14.184, Speaker G: So that's where Uma comes in. You basically have this shelling point game where all the Uma stakers are committing a secret vote on chain so you can't copy people's answers. Is it still project? Okay, so secret vote on chain can't just be lazy and copy people's answers. You have to actually analyze the evidence and think what is the truth here? Because that's most likely to be the result. Then everybody reveals and you have your result. It's also good to have a documented methodology of truth. So if you have some complicated question like you're running this whole protocol and you have to get a whole bunch of crosschain data and run calculations in a specific way, it's really important to let people know how to run those calculations, make it predictable.
03:16:14.184 - 03:16:55.912, Speaker G: Because without that proposers aren't going to risk money on making a proposal that might actually be disputed where there is some ambiguity of what the answer will be. And then you need these economic guarantees that one disputers will show up and they're incentivized to show up and two, that voters will show up and they'll resolve disputes and they'll actually vote. And that it would cost way too much money to try to bribe the voters than to just arrive at the right answer. This is kind of the flow. I think that you can probably find these slides on our website or in previous things. I'll figure out how to share it, but it's a pretty simple workflow. So asking a question, post a bond along with an answer to the question.
03:16:55.912 - 03:17:31.220, Speaker G: If no one disputes, great, you have your answer after the challenge window. Maybe that's 2 hours, maybe that's two days. It depends on your use case. If somebody does dispute, it goes to the voting mechanism and it's kind of a choose your own adventure thing at that point. Some things like Polymarket, which uses us for prediction markets, they wait until we get a final answer from our voting system and that's what they use. Other things like across, which uses us for cross chain bridging, they actually throw away the disputed answer because they don't want to wait until it's all resolved. It opens it up to new proposals then that somebody else proposes the correct answer so that their relayers get refunded faster.
03:17:31.220 - 03:18:16.754, Speaker G: So these are examples of real questions, real use cases. I talked about Polymarket and prediction markets. We're also really good for insurance, so Sherlock and Cozy both use us. It's great because you can ask these natural language things where there's no clear data source of whether a smart contract was hacked or if some severe weather thing happened that you would have an insurance payout. But you can ask the Oracle and we can provide that answer and some other things that are worth talking about. We also have these interesting on chain derivatives that you can do, like shapeshift. Dao used us for on chain VC fundraising in a DeFi native way, where instead of the VCs getting a discount on a token that they could then sell and make a profit even if the token price goes down.
03:18:16.754 - 03:18:59.054, Speaker G: What they bought was an on chain instrument that has a boosted payout only if the token price goes up over the long term. So it's kind of like an embedded call option. Uma is going to verify the Fox token price and then based on that token price, you're going to get a greater or lesser payout as the VC who bought this option. So it's much more incentive aligned. You're not going to have VCs dumping on you, but the VCs get an increased upside if they get the good outcome that they're looking for. And then something really cool if you're using Uma, you can actually trigger events after you get a result. So you can say here's some question about something that's going to happen in the future and you can think about how Polymarket uses this.
03:18:59.054 - 03:19:29.734, Speaker G: They're setting up betting markets around a basketball game or something. The game hasn't happened. Obviously no one's going to actually trigger this with a proposal until the game is over. But you can start using it to bet on it for days or weeks in advance and then once it's time, somebody can come in and make a proposal. And then when that happens that can flow to other contracts. You can define a callback function that automatically some stuff happens after the value is settled and the function is called price settled. Don't get distracted by that.
03:19:29.734 - 03:20:00.560, Speaker G: It doesn't have to be a price, it could be any kind of data. So it's kind of like an if this then that thing. So you're waiting for some event in the future. You get a proposal about that event, that proposal is accepted. As soon as that's settled. You can just have all this other stuff that happens in this callback function that maybe automatically sends some tokens to somebody or makes some change to a smart contract, whatever your workflow is. And it actually makes your smart contract interactions much more autonomous because Uma's system already incentivizes people to raise disputes and to settle things.
03:20:00.560 - 03:20:34.330, Speaker G: Know it's actually settleable and then you don't actually have to do anything. You're not like, oh, let's go and get this price. You can define this callback function atomically with the settlement. It'll trigger the callback and do some stuff in the rest of your smart contract system. So definitely use this callback methodology if you're using Uma for your hack. So yeah, I mean this allows the real world to actually reach out and touch your smart contracts like some hurricane hit and you need to trigger some insurance payouts. That contract could automatically send the funds to the people that are owed insurance.
03:20:34.330 - 03:20:43.870, Speaker G: They don't have to come back later and because it's happened and it's confirmed, then they can claim it. It can literally just send it to it as part of a callback function. It makes it much more efficient.
03:20:46.790 - 03:20:49.458, Speaker B: Yeah, so I'm actually on the website.
03:20:49.544 - 03:20:53.106, Speaker F: Looking at the docs as well. I see this as more for like.
03:20:53.128 - 03:20:55.378, Speaker B: A game theory and because of the.
03:20:55.384 - 03:21:00.014, Speaker F: Incentives like most optimistic world crystal match. So what if the hurricane ever occurred.
03:21:00.062 - 03:21:02.340, Speaker E: For the vote groups that are collectively better.
03:21:03.530 - 03:21:04.722, Speaker F: Is that a possibility?
03:21:04.866 - 03:21:07.414, Speaker G: If what happens I'm sorry, let's say.
03:21:07.452 - 03:21:13.526, Speaker F: The main token holders, they vote for this honestly for their own personal gain. Is that a possibility?
03:21:13.718 - 03:21:51.570, Speaker G: It is if you're securing some huge amount. So the way that you would try to attack Uma, you can't actually buy or borrow enough tokens to influence voting yourself. So this is the attack vector. You would try you would deploy a smart contract that's a bribe smart contract that says, hey, it's securing this contract that has $5 billion in it. We're going to go steal the $5 billion with some faulty Oracle data. It's going to send the money to the smart contract and automatically divide it up between the co conspirators. And so the way we deal with that, I think anything up to like, 50, $60 million that could be stolen, it's not economically worth it to attempt a bribe attack.
03:21:51.570 - 03:22:37.810, Speaker G: Given Uma's economic security, if it's a couple of billion dollars, it's worth trying. But what you can do is you can have an alternate resolution path where you're using Uma and all of its earlier game theory around proposals and disputes to make sure disputers show up. But then once a dispute happens, instead of waiting for the Uma vote and then using that Uma vote to move money, maybe you jump to your protocol's on chain governance system or some other kind of dispute resolution system, or you just throw it away entirely. And then all that Uma is settling is the bonds, and that's extremely economically secure. Like, you could set a 50 west bond and it wouldn't make any difference. Nobody's going to be able to set up a bribe attack for 50 west. So in that case, either you go to some alternate governance system or you just keep letting people propose, and maybe it locks things up for a little bit.
03:22:37.810 - 03:23:10.810, Speaker G: And depending on what your contract system is doing, you might make different trade offs. And across is a good example. Across is securing $40 million, and I think that across actually would be happy with using Uma for final settlement, like that's within the range that it's safe. But across doesn't want to lock things up for the entire Uma voting period. They want their relayers to get refunded faster. They don't want to get dossed through this thing. So if a dispute comes through on a cross, the disputed bundle of relayer refunds is just thrown away, and somebody can propose a new one immediately.
03:23:10.810 - 03:23:44.924, Speaker G: And that gets things done a lot faster. And then over the next few days, uma is going to cycle through and settle bonds. So it's a really good question. And then, yeah, talk to me later about sovereign security, which is kind of that alternate path which no one's used yet, but we baked it in for exactly that use case. So this is how you make an assertion. You can see all of the components here where you're kind of requesting data and providing data simultaneously. But what's nice about this is you don't need to go find some third party to deliver your data for you.
03:23:44.924 - 03:24:14.090, Speaker G: You probably already know what the answer is in a lot of cases, but you don't want people to have to trust you. So this keeps it decentralized while also being efficient. You're like, I know that oiler got hacked, for instance, so I can go to the insurance protocol and I say Euler got hacked because I want to get paid out on my insurance, but you don't have to trust me. And the people that provided the insurance don't have to trust me. It's up for the liveness window. If I'm wrong, take my money. And so it still keeps it decentralized while letting you do all kinds of automated workflows that are cool.
03:24:14.090 - 03:24:56.012, Speaker G: So, yeah, I mean, just running back all kinds of stuff. I think it's important to remember that this optimistic Oracle, it's not just for delivering data because you have these callbacks. You can use it to automate things that you want to have happen in response to something that happens somewhere else on chain or on a different chain or in the real world. You're triggering things based on almost anything as long as it's publicly verifiable. And you can actually one interesting use case is build a collection of undisputed facts on chain that you can use to build other things. And we've had previous hackathon projects that were exploring that. All this stuff, this exists.
03:24:56.012 - 03:25:24.744, Speaker G: It's not hypothetical. These are real things. I'm going to focus a little bit on number three right now with optimistic governance because we're trying to solve a real problem for DAOs to keep them decentralized and autonomous so they can focus on just getting organized. So this is a normal Dow governance flow. You have a forum discussion and then people vote on Snapshot and then it kind of stops being a Dow and a multisig just decides whether or not to do it. And so we're trying to solve that. You just drop off.
03:25:24.744 - 03:26:07.924, Speaker G: And there's good reasons to use snapshot, though. There are trade offs for on chain voting. I think the gas cost for uniswap voting, which has delegated voting, it's over $3 million since they opened up governance. Even if you only had like and that's in the best case scenario where you do have delegated voting and you have a large treasury that you're securing, let's say that your treasury is $1 million. Are you going to spend $3 million on gas? To manage this $1 million treasury, you need to have gasless voting for the vast majority of things that human beings might want to organize around. So we're trying to kill multisigs for Dows for the most part. Like, multisigs are not the right tool for Dao vote execution.
03:26:07.924 - 03:26:32.528, Speaker G: Your Dao is the multi SIG. You can use our Oracle to verify basically this thing passed on snapshot, therefore I can execute it. Anyone can execute it. And in the future, we'll probably set up bots that just automatically propose and execute, just watch snapshot and it's like, hey, this passed. Okay, propose. Make it fully autonomous like that. And the truth is economically incentivized and it's super easy to set up.
03:26:32.528 - 03:27:03.300, Speaker G: A huge number of these Dows have this pattern where you have snapshot. You have a safe with a bunch of your money in it and a multi SIG, and you just don't want to use the multi SIG. You can attach the Uma module, which is audited by OpenZeppelin and live in production with a bunch of people right now and then configure that with your snapshot space. It'll take an afternoon, maybe, if you're doing it by yourself and taking your time with it. Or you could come talk to me at the booth and we'll do it in like five minutes. It's really easy. And this is the flow.
03:27:03.300 - 03:27:31.264, Speaker G: So you deploy your module, you're setting the parameters, and then it's kind of like normal. You just go through snapshot. You're creating your snapshot proposal. The only difference is you can attach a specific transaction bundle and you're saying, execute these transactions once this is done. And then if it passes, you're going to see a button in snapshot. So it makes it easy for anyone to just click the button to propose on chain after the challenge window, if nobody disputed it, click the button again and execute it. And that's open for anybody to do.
03:27:31.264 - 03:28:07.004, Speaker G: You don't even have to be a Dao member. It's just something that has been proven now through Uma's system. And you can also set your challenge windows to be pretty long. We've had DAOs that have implemented this that set the challenge window to like, five days because they're not in any rush. They don't need to move quickly the way that across as a protocol needs to do. The Dow is like, hey, I'm going to move $5 million, but really make sure that it's correct and they're okay with it happening days later and they have plenty of eyes on it. So we're getting a lot of adoption early on in DFI, which has been interesting to see.
03:28:07.004 - 03:28:49.912, Speaker G: I think part of that is because a bunch of these DFI protocols know us from back in the day when we were doing these more on chain derivatives and exotic option type things. So they know us and used us already, see shapeshift pop up again. If they already did their VC fundraising round on chain using us, it was kind of easy to sell. But I think a big part of it too, is DeFi protocols really want to be decentralized and that's on know, like, why did you get into this space? Because you want decentralization and you know that using this multi SIG is bad. It's also a practical thing. It feels very precarious to be a multi SIG signer, especially in the United States. And there's a lot of legal and regulatory surface area there where it doesn't look good to be a multi SIG signer.
03:28:49.912 - 03:29:22.020, Speaker G: And even if that wasn't the case, it's really inefficient and annoying and you don't feel like you're doing your job because if you want to get things done quickly, people are just bugging you like, hey John, can you sign this transaction? I'm not necessarily going to look through and analyze every transaction myself. I'll be like, okay, yeah, Hart said to sign the transaction. The transaction is probably fine, but that's not how it should be. This way it's all being rigorously checked both through the voting process and afterwards by a lot of third party people, not just you, as the signers. And you don't need to chase down signers across time zones. Anyone can propose and execute. I'm like, the snapshot vote is done.
03:29:22.020 - 03:29:57.728, Speaker G: I've done this for Dows. I'm just like, hey, excited for them, you're able to propose this now and then. I'm like, but I can too. And so I just go and propose then on their behalf because anyone can. Lossless is kind of interesting because that's a protection protocol where they had a tool where you're able to essentially reverse hacks, where if you have tokens that were using earlier, their special token contract, it includes a freeze and transfer function. And they were able to rescue a bunch of tokens that were stolen, I think in the Ronan hack. And they were looking to do that for things like WETH, where their old token model wouldn't really work.
03:29:57.728 - 03:30:33.532, Speaker G: And they were able to use OSNAP to bridge the results of their lossless token holders on whether to unfreeze or whether to transfer funds to a particular address based on some public evidence. So that was kind of cool to see this integrated, not just for your typical treasury management thing, but for actual core protocol governance, which is how they're using it for this new product they're rolling out. And then plus company is neat because it's a very small Dow. They don't have a lot of money in their safe. It's basically a network of creative agencies. And they wanted to set up internal Dow for the 3000 something members of their agencies. And they want all these people to vote, but it's not about a lot of money.
03:30:33.532 - 03:31:00.932, Speaker G: If you were actually to do this on chain, this Dow instantly becomes totally unviable. Like there's no point to do this, you're going to spend so much on gas, no one's going to vote. I think that they're using NFT based voting. And that's another neat thing about snapshot voting. You could have voting power that's calculated all kinds of different ways. You could consider three different tokens like the Across Dow does. They have their basic across token, they also have staked across LP tokens, and then they have the across success tokens.
03:31:00.932 - 03:31:33.680, Speaker G: And all of those things have voting power and snapshot, which is easy to set up. That would be a nightmare to set up on chain. And if they wanted to give like, NFTs to their community members and add some governance rights to those, how are you going to do that in a smart contract? It'd be absolutely terrible. And if you only have $1,000 worth of ACX, why are you even going to vote at all? This lets your dao be more decentralized in the sense that your voters can actually vote. You don't have to delegate everything. You can actually be engaged as a small token holder, which people want to do. So this is this beautiful future of Dow coordination.
03:31:33.680 - 03:32:13.164, Speaker G: Yeah, we got like, a lot of tutorials. If you go to Uma XYZ or Docs uma XYZ, you'll see some tutorials. You can deploy a prediction market or an insurance protocol or a bunch of other stuff within a pretty short time frame. And even if you're not doing prediction markets or insurance, it'll walk you through all the steps of how Uma stuff works so your specific use case can be modified. I know this was billed as a workshop, but I'm mostly just like talking a lot with words. But the thing about Uma is it's kind of a cheat code where you can use words to govern what happens. Like write out a couple of sentences, here's what I want to have happen.
03:32:13.164 - 03:32:43.172, Speaker G: Here are the rules of this smart contract. And so all you need to do to modify the tutorial is just change what the words say. So it's not as technical, it's not a lot of smart contract work. You can use the audited smart contracts as is. Just change your wording to your use case prizes. So we have a really weirdly big first place of 5000, and then second place it drops down to 2000. But there's also a pool prize of 3000 that gets split between everybody that does some Uma or across stuff.
03:32:43.172 - 03:33:23.904, Speaker G: You can also do across stuff. Across is kind of a sister protocol that a lot of the Uma team members were working on initially. And we split into two separate things, but still kind of, you know, come talk to us about that too, like cross chain bridging. If any of your stuff is related to that. There's a lot of cool things you can do, especially around passing messages, which some protocols have started to do. It's a new feature added to a cross where you're not just sending tokens to some other chain, you can also add a message that goes along with those tokens that could then trigger some stuff that happens on the other chain, which has been underexplored so far, and reach out to us. We're always hiring.
03:33:23.904 - 03:33:56.540, Speaker G: We have a bunch of open positions. If you don't see a position that looks right, but you're really interested in this stuff, please reach out. We're also starting a community ambassador program too, where I think we're going to start sending people to hackathons and things like this. I think especially with OSNAP, our optimistic governance thing, that's much more I don't know, it's more of like a wide audience thing than the Oracle as dev infrastructure. So we want to reach out to a lot more people and we want to grow that community. So come talk to us about that as well. Oh, and our referral program is kind of interesting.
03:33:56.540 - 03:34:14.688, Speaker G: If you refer somebody to us, you get paid with an on chain option, and our Oracle will verify how long this person stayed at the company. So your option will pay out more based on how long they're staying. So it's kind of similar to the success token thing. You get like this boosted on chain payout. If this is a good candidate, they make it to the interview stage. Okay. Boosted payout.
03:34:14.688 - 03:34:31.620, Speaker G: They get hired. Boosted payout. Six months boosted payout. And I think that we actually have time for Q A. Or if you all are diving into your hacks, I know that the hackathon has just started. This is the last talk, right? Or last workshop today. Okay.
03:34:31.620 - 03:34:36.530, Speaker G: Any other questions or thoughts on this? Ideas?
03:34:36.610 - 03:34:37.240, Speaker D: Yeah.
03:34:42.250 - 03:35:09.150, Speaker G: Probably. Yeah, I mean, depends where you are, I guess. I mean, we're not going to tell you what your taxes are, but it's like any other token thing. But yeah, you'll get some tokens. I think it'd be like some uma, tokens at the end of the day. And this is not tax advice, but you wouldn't actually have anything until the expiry date of the options. And so whatever, uma, is worth at the time that you exercise it is probably the relevant thing.
03:35:09.150 - 03:35:13.120, Speaker G: But I'm really only familiar with the American context, so it depends on where you're at.
03:35:17.830 - 03:35:19.300, Speaker F: This would be about insurance.
03:35:19.750 - 03:35:21.202, Speaker D: This is similar to the first question.
03:35:21.256 - 03:35:29.582, Speaker F: Where we're talking about the main motor. So how would this gracity transform the current insurance infrastructure?
03:35:29.726 - 03:35:30.580, Speaker D: How would.
03:35:32.650 - 03:35:58.462, Speaker G: So I think there's a couple of aspects to it. There's a lot of conflict of interest of the insurance company that sold you the insurance, also deciding whether or not you collect the insurance. Everybody kind of understands the game is you pay the insurance company money and then they try not to pay you, and they'll find any way not to pay you, and this takes it out of their hands. And so there's a couple of ways to think about that. One is you need to make it a lot simpler. It needs to be publicly verifiable. It's not based on specific things.
03:35:58.462 - 03:36:24.630, Speaker G: It's not like, oh, my sink leaked or something. There's no way for our Oracle to go and verify that this was from your sink leaking. You could have higher level stuff like, oh, the smart contract system was hacked. That's like the active insurance thing that people use. You could also do something like custodial risk insurance. It's like, I have a bunch of money in Binance. Is Binance going to lock withdrawals? Like, I want insurance against withdrawals being frozen on Binance? That seems like that would be really practical.
03:36:24.630 - 03:36:45.980, Speaker G: And you're not buying that insurance from Binance, obviously, which is kind of like the way insurance currently works. It's the person who wants to pay you the least. And it's not up to the person that deposited funds in the insurance pool either. They're not voting on it. This is going to a neutral third party oracle whose whole incentive mechanism is built around finding the truth to whatever question it is and is receiving all kinds of questions.
03:36:49.390 - 03:36:52.540, Speaker F: Let's say I have my funds and.
03:37:07.030 - 03:37:47.010, Speaker G: Potentially, I guess it's all happening on chain with Uma's stuff. So if you had some funds that are off chain, you'd probably convert it to USDC or, you know, there are custodian. Like, I'm imagining this whole enterprise stack of normal insurance companies. They would probably go to Coinbase custody or someone to hold it for them and then put it into this smart contract that's controlled by Uma and pay consultants, like some ludicrous amount of fees. But yeah, you should be able to do like to the extent that companies can interact with the chain at all, it's permissionless. So then after you do that, you could probably leave it open too for just random people to be like, here's 20 more dollars for the insurance pool.
03:37:48.630 - 03:37:50.498, Speaker D: Yeah, okay.
03:37:50.584 - 03:38:02.260, Speaker G: Yeah, no, that's perfect. If you check out our insurance tutorial, let me know if it looks good. Yeah, okay, awesome.
03:38:04.070 - 03:38:06.480, Speaker D: Cool, thanks.
