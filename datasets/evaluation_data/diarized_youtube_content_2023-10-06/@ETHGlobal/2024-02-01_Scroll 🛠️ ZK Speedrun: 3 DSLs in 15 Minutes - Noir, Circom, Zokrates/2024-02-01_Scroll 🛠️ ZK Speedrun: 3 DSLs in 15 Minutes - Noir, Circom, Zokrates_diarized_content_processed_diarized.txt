00:00:15.350 - 00:00:29.420, Speaker A: Hello, everyone, and welcome to the circuit breaker scroll workshop. ZK Speedrun. Three dsls in 15 minutes. Noir, circom and Socrates. Joining us today is Ahmed Castro, who will be taking us through this session. And with that, I'll pass over to Ahmed to get the session started.
00:00:30.590 - 00:01:44.694, Speaker B: Thank you, Ronnie. Yes, we're going to cover different dsls, which are the language needed to build circuits. So if you want to follow it with me, you can scan this QR code that will direct you to this page. And, yeah, basically we're going to go one by one, and I will just show the same process for each one which you, as a developer, maybe you're a solidity developer that want to get into CK. So what you need to do is first create a circuit, then generate approve, then generate a solidity verifier. And then you can verify that from a smart contract and you can add some custom logic so you can connect it with your dow, with your ERC 20 tokens or everything that we as a solidity developer, we are used to. And also last workshop that we did with it, global, which should be also, if you're watching on YouTube, it should be in this global YouTube channel.
00:01:44.694 - 00:02:24.420, Speaker B: I think it was really good. The circuit breaker attendees, like all of you guys, were asking some really good questions. So if you have any more questions about this, we can take a look it at the end. So, yeah, let's get started with Socrates. Socrates. It's going to put it here to open a terminal. Socrates is.
00:02:24.420 - 00:02:47.820, Speaker B: Okay, here you go. So, let's start with Socrates, which I think it has a really good developer experience. The documentation is very polished. I would recommend Socrates as your first DSL language. If you don't know, which do you want?
00:02:59.760 - 00:03:33.374, Speaker A: Ahmed, you froze a bit. You still there? Think he's having some Internet connection issues, folks. So just bear with us. One momentum. Hey, there you are.
00:03:33.492 - 00:03:34.702, Speaker B: Hey, can you hear me now?
00:03:34.756 - 00:03:36.880, Speaker A: Okay, yeah, you froze for a second.
00:03:37.570 - 00:03:45.060, Speaker B: Okay, so, as I was saying, we're going to start with Socrates. These are the commands to install.
00:03:46.230 - 00:03:47.666, Speaker A: Share your screen again.
00:03:47.768 - 00:04:04.180, Speaker B: Oh, okay. Sorry about that. Is it ready now? Sorry. Here you go.
00:04:05.110 - 00:04:07.542, Speaker A: Yeah, just go to the. Yeah, there you go.
00:04:07.596 - 00:05:08.630, Speaker B: Okay, so, yeah, first, socrates here, I already installed it. So you can first run this command and then just put your username here if you want to load it into your environment variables. So here I'm using Socrates 88. This is the installation part. So let's start by creating a proof. So let's create a circuit. And last time we mentioned that circuits are like the syntax for creating a circuit, it's very similar to a programming language, but the difference is that you write assertions instead of like you can compute stuff.
00:05:08.630 - 00:06:08.262, Speaker B: You can create variables, loops, if statements, but the difference that you make assertions, and only if, only if all the assertions are satisfied, are complete, you will be able to generate a proof. So here what I did is I have a circuit that has a and b as input. We're going to do very simple circuits for the sake of the example, but I think all of the example are going to exemplify and get you in the right mindset to what you need to do in order to write any type of circuits. So this circuit is about two variables, a and b. And you're proving that a times a equals b. But a is a private variable. So you have two numbers and you only reveal one number and the other one is private.
00:06:08.262 - 00:06:34.450, Speaker B: And in this case we're like revealing only b. B is your public variable and a is your private variable. And we're going to generate a proof by passing these two parameters. A is three and b is nine, because three times degree equals nine. So we run these commands, and now the proof was reading into the JSON file.
00:06:46.350 - 00:06:49.120, Speaker A: Hey Ahmed, I think we lost your audio again.
00:07:21.040 - 00:07:34.880, Speaker B: You will be able to verify by using this. You pass the proof and it will return true if your proof is valid. So first we're going to launch this smart contract.
00:07:36.020 - 00:07:47.300, Speaker A: Hey Ahmed, can you share your screen again? You kind of froze for a bit. I don't know if maybe you can also go back to maybe like the last 30 seconds, just kind of.
00:07:47.370 - 00:07:55.384, Speaker B: Okay, and let me, give me a second. I can also look for a different Internet connection. Give me a second.
00:07:55.582 - 00:07:56.330, Speaker A: Okay.
00:07:56.860 - 00:08:16.290, Speaker B: In the meantime, just in case you miss it, you can grab from here, from the QR, the link to this page. I will be right back. All it.
00:09:43.090 - 00:09:48.240, Speaker A: You also try sharing or saying something.
00:09:48.690 - 00:09:49.806, Speaker B: Yes. Can you hear?
00:09:49.828 - 00:09:51.200, Speaker A: Cool. Yeah, I can hear you now.
00:09:52.050 - 00:10:29.866, Speaker B: Okay, switch my Internet connection. I hope it's good now. Okay, let's continue then. Basically I generated, so first I improved that three times three equals nine, but I'm going to keep three private and nine public in order to prove it. I pass the tree and the nine as inputs, and what I get back is the proof, which is this one. So the next step is to verify the proof. So we're going to verify it on a solid smart contract.
00:10:29.866 - 00:11:36.578, Speaker B: So I run this command and I get the solidity verifier. Once I have the solidifier, we can deploy this contract and I'm going to deploy it on scroll testnet, but it should work also on Ethereum or on all EVM chains that supports all the pre compiled needed for this to work, which are all the layer ones, all the optimistic L2s. And many just be aware that many cke evm don't support this jet and scroll does. But with a caveat that you have to restrict the amount of easy pairings that you do. So what you need to do as a developer, what you need to know is that this is very hard for ckvms to support. The ckvms will continue to improve this in the future for sure. But now you have to know about the limitations about it.
00:11:36.578 - 00:12:20.286, Speaker B: But yeah, we're going to do this on scroll, which is working fine. And yeah, let's do that now. So first I'm going to have two contracts. One is going to be the verifier contract, which is the one that was generated by the DSL, which in this case is Socrates. So I compile it, there's some warnings, but I don't have to worry about it. So now I deploy the verifier contract and then this verifier contract is going to expose a verifier function and that verifying function is going to be called from another smart contract. So let's take a look.
00:12:20.286 - 00:12:59.862, Speaker B: So this is the verify function from my a Times a equals b circuit. So this is the verifier contract. And what I'm going to do now is to deploy a second contract that's going to use this verify function. Let's take a look at this. So this second contract, we're going to call it like custom logic contract. So the custom logic contract is going to do two things. First, it's going to verify the proof.
00:12:59.862 - 00:13:26.706, Speaker B: We're going to send a proof as parameter, and also we're going to send an input. And by the way, something that I miss here is that the proof has to be true. This is specifically for Socrates. This is the way, like the Socrates smart contracts work. Incorrect proof. You can put a message here. So we're going to verify the transaction by sending the proof.
00:13:26.706 - 00:14:24.546, Speaker B: And you have to get a valid proof to continue the execution. And what is the next execution? You can do whatever you want. For example, if you're doing like private transactions on ERC 20 tokens, then you send a transfer here. If you're doing a dow with a voting out here you vote for the proposal. If you are doing social media, like anonymous social media, here you create the post and here is the part like here you can put whatever you're already used to doing on solidity. So yeah, this is our contract and let's try it out. So I'm going to compile it, going to launch it, to deploy it, and as a parameter, we're going to pass the verifier address that was generated from Socrates.
00:14:24.546 - 00:15:09.480, Speaker B: So we're going to deploy this. And as you can see, in order to call the send proof function, we're going to need two things. One is the proof and two is the public input. So you can find those here on the proof. So the proof is this one, this abcding is the proof and the public input is this. Do you remember that we're doing like a times a equals b circuit and b is the public input. So we are not revealing a.
00:15:09.480 - 00:15:46.594, Speaker B: And in this case we are just passing b as parameter. Do remember that we did three times three equals nine. So we're going to only pass nine as parameter because that's the public input. So yeah, this is in a format that remix won't like that much. So I'm just going to quickly put this in a format that it will like the proof. So I think that should be it. And also I'm going to pass this as a parameter two, which is basically also passing as an array of one.
00:15:46.594 - 00:16:19.606, Speaker B: And this should do it. There you go. And in this example, I'm just doing one thing with the custom logic. I'm just storing the public input because the public input is what will allow you to play around with your CK logic, as you can see. Now the public input was stored and you can fake it. You can put just whatever number here because it's going to revert. Right? So yeah, that's the cool thing about ck.
00:16:19.606 - 00:16:39.490, Speaker B: Okay, so this is Socrates. This is a speed run. So we're going to go to the next one. You have any question about Socrates? And if I can answer, we can do that at the end. As I mentioned before, let's go with Noir. Now we're going to do a very similar thing with noir. We're going to go to the same process.
00:16:39.490 - 00:17:19.822, Speaker B: We're going to get a circuit, we're going to generate a proof, and we're going to verify it. So let's do it. Okay, so I already have installed narco, which is the noir command. I have version 22, which is the latest one. And here, this is how you can install it on Linux, on Mac, and both apple silicon and intel. Let's create the hello word that noir offers. And now we are going to pass.
00:17:19.822 - 00:17:59.146, Speaker B: You remember that we passed the tree and the nine in the command line for Socrates in noir. We pass it on this tomal file. So we're going to pass one and two, and this is going to be run on this circuit that basically prove that X and Y are different. You pass two numbers, parameter X and Y, and you're proven that they're different, but you are only revealing y. So X is private. So yeah, you're going to pass parameters. You're only revealing one, but you can know for sure that the private parameter is another one.
00:17:59.146 - 00:18:21.540, Speaker B: It's a different one. So now we're going to generate the proof just like we did before, and our proof is going to be in the proof directory. This is a very long proof. You go. And now we're going to verify the proof again by generating a solidity smart contract. Here you go. Here it is.
00:18:21.540 - 00:18:56.686, Speaker B: And we are going to the same as we did before. We're going to deploy this smart contract on chain. Remove this. Okay, this is the ultra verifier contract, which I think is a very funny and silly name because it's using underlying technology of plunk about the version ultraplunk. And they always keep putting these numbers like turboplunk, ultraplunk. I don't know what's next. Okay, so we have the verifier here.
00:18:56.686 - 00:19:33.750, Speaker B: It also has a verify function that we're going to call from a contract that I'm also prepared for today with custom logic. And in this case, we're going to do exactly the same. We're going to verify the contract in this case. We don't need to put this on the required. This is the way that the noir contract verify contract is done. You just need to put this here to verify the proof that you pass a parameter, and you can see that we're passing the parameters in the same format. First the proof, and then the public inputs.
00:19:33.750 - 00:20:19.820, Speaker B: And finally you can add just custom logic, which we're going to do the same. You're just going to store the y, the second parameter, the public one. Okay, so now the same as we did before. We have to specify on the constructor which verifier address we're working on, and we deploy it, and then we will have to pass the proof. Right? And we have to pass it in a very similar way that we did before. So first we pass the proof and also the public inputs. So the proof is here, this super huge number.
00:20:19.820 - 00:21:23.280, Speaker B: So just one recommendation. For it to be compatible with remix, you have to put the zero x at the beginning and that's it. And then the public inputs, you can find them on the verifier TML file that was generated for you. This is the only public input. So we are going to pass it in this format like a string on an array, and we pass it on an array because usually you will want to pass many public inputs that will help you to do the logic on chain like on your smart contract. So right now the Polykyput is zero, but when it gets confirmed, it's just going to become two on this case. Okay, here you go, the confirmed and we start the number two.
00:21:23.280 - 00:22:02.570, Speaker B: Okay, so that's for noir. Now let's go with circum, which again is going to be something very similar. Let me see if I have installed correctly. Circum here. Yes, looks like some install. So I'm not going to install, I already have it. Let me check if I have snarks also installed.
00:22:02.570 - 00:22:43.878, Speaker B: Yeah, looks like it's installed. Okay, so if you want to start yourself, just run these commands. Sorry. That will get installed for you. So here, this is the circum syntax. And we're going to do this circuit that is actually going to do some computation, which I think is super cool. Going to check for some computation, which we're going to check that the input a is going to be multiplied by the input b and it's going to output on c.
00:22:43.878 - 00:23:36.594, Speaker B: So yeah, we're going to check that a times b equals c. The only public input which is the output is going to be c. So we're going to also create these files. So you remember that this is a bit similar to noir, that we put the inputs on a tomo file, you were putting it on a JSON file. And then we're going to run all of this, which is going to save this. Okay, we're going to run all of this, which is going to take a while because it's doing. You have been prompted just a couple of times to put some entropy because we're doing the power of Tau and you know that we're using the KCG ceremony for court 16.
00:23:36.594 - 00:24:42.014, Speaker B: So basically it means that maybe some of you may participated on the KCG ceremony by the trunk foundation where everyone can contribute to the randomness. And the more people that contribute, the more safe to get the protocol. So we're just going to do a couple of contributions here with just some random stuff just to get it set up. It's worth to mention that if you're using some DSL that use trusted setups like this one. And once you go live, you may want to do it like in a free, safe way, or you may use some other snarks that don't use this initial setup. And in that case you won't need to do the step. So yeah, it will depend on what TSL you're using, and each one has some pros and cons.
00:24:42.014 - 00:25:35.034, Speaker B: So before launching, I would recommend you just go into the forums from that language, from the DSL, and just ask what recommendations are there so far. As you can see, the three of them have very similar characteristics, and the language may look different, you may have your favorite yourself, but in general they're all the same. They have inputs and they have public and private inputs. And you do assertions, you do checks. And then if everything is correct, then you will return a proof. And that proof can be verified multiple ways. It can even be verified like off chain.
00:25:35.034 - 00:26:31.482, Speaker B: You don't have to do blockchain stuff in order to ck, but of course doing verifying on Ethereum is something very unique because it allows you to have something that can be public and verified by multiple people. So yeah, Ethereum is giving us this property, which is super cool. Okay, so here the inputs of the proof. So we basically pass during all of these. Okay, we are computing that here, the input that three times eleven equals 33. So 33 is going to be our public input, which is exactly here. This is the public input.
00:26:31.482 - 00:26:55.734, Speaker B: So basically this is the proof. This is the proof, and this is the public input. It's like 21, but it's 21 on hexadecimal, which is 33 on decimal. You can also see the proof here. This is the proof. And this is the proof. And this is where is the public input? I can find it here.
00:26:55.734 - 00:28:00.702, Speaker B: Well, anyway, this is the public input. And isn't the format that you already expected from solidity. So again, let's do the same process again of generating the verifier. Here you go. And the verifier is here. Again, we can go and put it on remix, we can deploy it, and also we can now create a custom logic circuit which is very similar to what we already did. We pass the verifier as parameter, and in this case the inputs are already format here.
00:28:00.702 - 00:29:00.186, Speaker B: So it's going to be very easy to pass them. And of course on your web app, as we mentioned in the previous secret breaker workshop, you will usually want to build this on a web app. And when you do it, well, you will have like each Socrates, Circum and noir have some JavaScript way of doing everything, Javascript way of passing the parameters and JavaScript way of generating the proof. You would usually want to do it there, unless you're doing some back end stuff, some proving on the back end. Not like specifically a privacy app. But privacy apps are like very, I think something that very new, very unique, something that was not possible before and now was by using our Ethereum accounts, which I think is super cool. And it's something that you can use on L2s to save gas.
00:29:00.186 - 00:29:46.080, Speaker B: So I think that it's a good, like doing privacy app on L2s is something that we as developers, there is a lot of opportunities here because there is something very new and a lot of room for creativity for us to think about new stuff. So as you can see here, I passed the parameters and I verified the proof. Now it's on there. Just very simple custom logic. But yeah, this is my overview of the three of them. Each one has different characteristics. If I can summarize what I think personally about each of them, I think circum is like the one that has more adoption, has more community.
00:29:46.080 - 00:30:35.390, Speaker B: I think it's super cool and I think that noir, the team is working super actively on it. I like a lot what the team is building and also I think they're very focused on developer experience. And also noir, on top of being the language for creating a circuit for EVM language is also going to serve to create circuits in a non EVM language. That's going to be the astic L2, which I think is super cool, but this means that it is a project that is being worked on a lot, so it has very active development. So I think that's super cool. And about Socrates, I think that the interface is really good and it's very easy to pick up. The documentation is really good.
00:30:35.390 - 00:31:28.480, Speaker B: And yeah, probably I would recommend this as your first experience with CK, either Socrates or noir. I think circum is more complex, but for developer experience I think it's very easy. But I think that there is more activity on circum and on noir, but each one has some features over the other. So when you want to actually build a product using either of this, you will have to check if it has everything that you need for your specific app. So yeah, this is my spirit room, probably it took me more than 15 minutes that I was planned to, but I'm happy that you guys tagged along. So yeah, let me know if you have any questions.
00:31:29.650 - 00:31:42.580, Speaker A: There was one towards the top saying, I wish you would go back to the ways one can use the verifier soul. They thought that you rushed that a little, but maybe because it was in 15 minutes.
00:31:44.710 - 00:32:24.234, Speaker B: Yeah. About generating the solidity file. The thing that you need to understand is that there are two contracts. One contract is generated for you and the other contract is like your logic, like what you usually write in solidity. So let's pick for example. I think this one is a good example. So with this command, you generate a contract and you deploy it and it's going to be sitting there and yeah, it just has a function that you pass the proof, it returns true or false, or it will revert if the proof is false.
00:32:24.234 - 00:32:49.474, Speaker B: If not, your program will continue. That's one contract, you don't need to write it. It's going to be generated for you. And yeah, it's going to have a lot of numbers that you don't need to understand. The only thing that you need to know is that it will have a verify function. And the verify function is going to be called by the other contract. That's where you will be coding.
00:32:49.474 - 00:33:31.538, Speaker B: And what would you be coding here? So you will have basically on one side you will need to verify. So we have a verifier call to your other contract. So the previous contract that was out to generated, we're going to call the verify function from that contract. And if it pass the proof, because you send the proof and if it's not correct, it's going to revert. So if you pass a correct proof, then you can add your custom logic. And what things can you do in your custom logic? So you have a couple of tools that you can build here. So one part is that you have the public inputs.
00:33:31.538 - 00:34:04.326, Speaker B: So when we pass stuff to the circuits, you have the public and the private inputs. So the private, no one can know about it, especially your smart contract. It doesn't know about it. Why? Because it's private. And everything on your smart contract is public, right? So the private stuff is going to stay off chain, it's going to stay on the circuit. No one will be able to see it, but the public stops is going to be here. And you can play around with the public information here on solid.
00:34:04.326 - 00:35:12.146, Speaker B: For example, if you're doing a voting app, you can play around with stuff such as you can keep the voter anonymous as a private input, and you can keep the vote public as a public input. So the public input, you can play around with it, you can do your solidity stuff with it, you can do some computation, whatever you want. And yeah, on the other hand, for example, you can have for example a defi staking protocol, for example that if you want to stake or unstake, for example, when you're on staking from a public perspective, you will only be able to see the public params is the amount that you are on staking and where it's going to be sent. But the private input is the original owner. You won't see it because that's the anonymous part. So it will depend on your app. So you have some privacy stuff that will stay on the circuit and all the public stuff you can play around here in solidity.
00:35:12.146 - 00:35:25.882, Speaker B: So that's like your custom logic. So that's what you will be able to do here. So two things that are in here. First, verify, which is called the other contract. And second, just whatever you want to do your customer like.
00:35:26.016 - 00:35:40.190, Speaker A: Yeah, nice. And another question was, I would like to know if you can touch on converting arbitrary statements to math, which what is fundamental to creating circuits that would create the proofs.
00:35:41.270 - 00:36:25.470, Speaker B: Yeah, I am not the right person for that, but I'm not very familiar with all the math stuff. But there is the best resource that I found so far, which is a good middle point for all the maths. Also a little bit of programming stuff is the Ck MOOC by Berkeley on YouTube. I think this will be my full recommendation here. Yeah, I think it has both. And he go like very low level. It will go very low level on everything that the institution.
00:36:25.470 - 00:36:41.780, Speaker B: So yeah, you can find this on this was done by Berkeley University. This will be my recommendation. This is the most up to date. But yeah, I'm not the person for the math stuff.
00:36:44.810 - 00:36:55.240, Speaker A: Let's see. And then should we check out the PTOW or R one Cs files to get or is it better to ignore them?
00:36:58.350 - 00:37:42.950, Speaker B: This one. As a developer you don't need to touch on these files, other the PTOW, you can just ignore it and you will need them to generate the proofs and to verify them and to make the verifier contract. But yeah, as a developer you don't need to touch them, you just need to open up your ceremony. So many people can contribute to it and to make it more safe. But after that you don't need to touch it anymore.
00:37:44.890 - 00:37:50.810, Speaker A: And I think you may have mentioned this, but which HDl among these is most user friendly for beginners?
00:37:51.470 - 00:39:00.426, Speaker B: Yeah, I think either Socrates or noir. That would be my two recommendations. But just take into consideration that circum has more community, has a bigger community and also has a bigger more products have launched using circum so there are more use cases and example products just take into consideration. But as you can see here, it has these signals and this is the way of checking constraints, I think for developers. If you're coming from, maybe you're a web two developer or you're a solidity developer, I would recommend either noir or Socrates. And also the nor guys have been putting a lot of effort lately on the documentation. Probably noir.
00:39:00.426 - 00:39:05.540, Speaker B: Yeah, it will depend on the project. Okay.
00:39:05.910 - 00:39:17.720, Speaker A: In the noir example, upon submitting the proof in customlogic Sol, the public number was updated from zero to two. How does this prove that the numbers are not equal as was written in the noir code?
00:39:18.890 - 00:39:50.474, Speaker B: Yeah. So we pass one and two, right. First was the x was one and y was two. So what we're proving here is that we passed a number that is not two. But this particular example is not like practical. This is just an example. But let's put this into a practical context.
00:39:50.474 - 00:41:04.038, Speaker B: Like an example with something practical. Is that, for example, like I mentioned before, for example, you have a list of voters and like an array, you can imagine an array of voters, which is x, your private input, and y is your public input, which is the vote, like for or against. Maybe two means against, one mean four. So when you go to the contract, it is relevant at this point because you already know that only if you are part of the list, you will be able to generate a proof. So that's where private keys and public keys come into play, because you can only prove that you are part of this list only if you have a private list, for example. And usually this is done by using hashing. So you can think about only if you have the key.
00:41:04.038 - 00:41:39.234, Speaker B: You can unlock the private part, but the public part is just public. So you can't generate proof if you don't have the key. But the key is going to remain private. So that's the important part. And so you can safely go and submit this on blockchain with a proof that you were only able to do it if you have the key. But if you have it, you won't expose it. That's the cool part.
00:41:39.234 - 00:42:31.954, Speaker B: And also you won't know if it was list, for example, you won't be able to know which one are you. So, yeah, different things that you can play around with here. This example, as I mentioned, is not like really straightforward. It's not practical just to say like, okay, x and y are different because you could have picked one or three or four or five of ticks. You don't know which one. The only thing that you know is that you didn't pick two. And the thing is that for this example, you can generate an infinite amount of proofs, or you can generate a different proof with the same number for one and two, you can generate the same number two times.
00:42:31.954 - 00:43:29.160, Speaker B: So as a developer, you also have to think in ways on how to restrict the proof generation. Maybe you can think of ways of how to make people not to do the same thing two times, like to double spend. And here you also need to be using nullifiers and stuff. I'm going talking about other stuff. But in general, you as a developer, what you will care about is the public inputs and how to not double spend and the nullifier. So yeah, in this example, just passing one and two doesn't say too much, but the power of Ck and the thing that we were not able to do before is that this is going to be obscured. No one will be able to know.
00:43:29.160 - 00:43:33.640, Speaker B: What was it? I don't know if that answered the question.
00:43:36.650 - 00:43:39.980, Speaker A: Okay, and then last question, what if Halo two?
00:43:42.190 - 00:44:18.790, Speaker B: Yeah, really good question. I thought about adding halo two here, but yeah, it will definitely not be a speed run at all. Halo two, actually halo two is not a DSL, but it serves the same purpose, the three of them. So how are they similar? How? Halo two is similar to noir, circum and socrates, so on halo two. Can you write circuits? Yes. You can write circuits. Can you generate proof? Yes.
00:44:18.790 - 00:45:20.054, Speaker B: Can you verify them? Yes. Can you generate a solid smart contract that is able to verify the proof? Yes, you can do that too. And how is it different, how is it different than all of the three of this? And as you may have know scroll is reading on halo two. Because the privacy exploration from the PSE privacy and scale exploration repository from the CKVM is written on halo two. And why did they decide to do it on halo two and not on these others? Is because Halo two is more flexible. It allows you to go like one step deeper and fine tune everything. You can go like one step behind into a little bit more cryptographic part.
00:45:20.054 - 00:46:25.178, Speaker B: And you can think about it as you can write code in C, in C plus plus for example, but you can write the same code in C or even in assembly, it's going one step lower. Halo two allows you to go one step lower and just do more specific stuff that you won't be able to do in either of this language. But the problem is that it's very complex and you just need to fine tune because you have all these different possibilities. You have to understand a lot of concept words. And it's also not a DSL, because as you can see, the DSL are a dynamic, specific language. So it's a language that works, that serves only one purpose. So Socrates, noir and sip and circum, it serves only one purpose, is making CK proofs.
00:46:25.178 - 00:46:59.734, Speaker B: But Halo two is not a TSL, it's a library. It's a ROS library. So you write your ROS program and you import the Halo two library, and you can start writing your circuits that way. And as you may suspect at this point, the syntax is very hard. It's very hard, but it's also very cool. And you can do a lot of cool things. And that's why it's the preferred language for the CKVM.
00:46:59.734 - 00:47:26.354, Speaker B: That's the language. The library is not a language. Right. It's a library that was a library that was picked because it gives you a lot of flexibility and it expands the things that you can do. But unfortunately, and the reason why I didn't add it to this speed run is that you just don't have this Halo two export verified. You just don't have it. You have to write the SSL itself.
00:47:26.354 - 00:48:07.054, Speaker B: Maybe in the future you will have like a command that will allow you to do it. But it's not there yet. It's not there yet. And also, it's not the main reason of Halo two, because Halo two was developed, I think, by the ccash protocol, and now it's used by scroll and other projects. But yeah, the thing is that the objective is just going very deep and doing this low level stuff. The objective, not the developer experience, but in the case of Socrates and Aztec and circum, yes, the objective is the solidity verified. That's why it's the developer experience.
00:48:07.054 - 00:48:24.740, Speaker B: That's why you can have solid verifiers and all that stuff. Yeah, but yeah, really good question. Because Hilo two is part of this group of tools that allow you to do the exact same thing.
00:48:27.050 - 00:48:42.514, Speaker A: Nice. Awesome. Well, cheers. We're a bit overtime, but yeah, thanks again, Ahmed, for another great workshop presentation. And thank you all, everybody else, for asking these really thoughtful, insightful questions. As a reminder, hacking has begun, so you can begin. Hacking.
00:48:42.514 - 00:48:51.150, Speaker A: Yeah, we've got one more workshop this afternoon and then another team formation session. So awesome. If you, everybody has a great rest of your Friday and have a great weekend.
00:48:51.650 - 00:49:06.346, Speaker B: Yeah, thank you, Rory. Thank you everyone for participating and doing all these great questions and happy hacking. I can't wait to see what you build on. Circuit breaker.
00:49:06.538 - 00:49:07.182, Speaker A: Awesome.
00:49:07.316 - 00:49:07.770, Speaker B: Cheers.
00:49:07.850 - 00:49:09.770, Speaker A: Have a good one, everybody. Bye.
