00:00:06.890 - 00:00:39.234, Speaker A: Good morning everyone. Welcome to this workshop where we'll learn today about Unlock Protocol. This is a workshop that is dedicated to developers or people at hackathons that want to build on top of the Unlock Protocol. Here's to get started, a quick agenda about what unlock is. First we'll start up an overview. Then we'll look at the ecosystem, what kind of tools, including the subgraphs from the graph, and what kind of integrations exist out there. Then we'll move into final section about two different tutorials.
00:00:39.234 - 00:01:10.834, Speaker A: One of them is to show you use cases for front end and how to create one, as well as use cases for smart contract integration, as well as creating a hook, which is something that is very specific to the unlocked smart contracts. First of all, a little bit about myself. My name is Julianistu. I'm the CEO and founder here at Unlock Protocol. Before that, I was actually working in a company called Superfeeder, which was sold to Medium in 2016. Superfeeder was building RSS feed API RSS, our core building block of the open web. And really you have to think of unlock as another building block for the open web.
00:01:10.834 - 00:01:57.566, Speaker A: I'm a big open source advocate, I'm a W, three C invited expert, and I'm also a member of the Graph Council. You can find me online at Julian 51, mostly everywhere, or use my site@uroboat.com Ouvreboite.com. So let's jump right into it. What is unlock protocol? Unlock Protocol is a protocol for memberships. What does that mean, you might ask? Well, simply thought Unlock Protocol is a system to create membership and sell access NFTs membership NFTs in minutes. It allows developers like yourself to create memberships, subscription ticketing solution, add token gating to websites, create certifications and gaming.
00:01:57.566 - 00:02:41.070, Speaker A: And we'll come back to all of these. It is obviously completely open source under the MIT license. It is community governed, which means that we have a Dao and a governance token. And if you're building on top of Unlock, we invite you to join our Dow so you can help us make decisions about the future of the protocol. There's a set of application that we have built at Unlock Labs, but also other people have built similarly with libraries and developer tools. It was funded by me in 2018 and we now have a team with diverse experience from Google, Facebook, GoDaddy and multiple others, as well as a global community of people around the world. So let's talk more about memberships and NFT specifically.
00:02:41.070 - 00:03:09.582, Speaker A: So can I use any NFT to represent membership? And especially here, you might recognize some of the popular projects out there. The short answer is no, you should not. I mean, you can, but you should not. And the reason why you should not is because these default NFTs, specifically the collectible NFTs, are limited in what they allow you to do. For example, the number one limitation is that they're valid forever. They're perpetual. And when you create a membership of any kind, you actually probably want to have it time bound.
00:03:09.582 - 00:03:56.674, Speaker A: Think of your Netflix membership or your Amazon Prime membership. It is time bound, it is valid for a month and it renews for another month and for another month and for another month for as long as you pay, but it is not valid forever. Similarly, think about a certification. Your driver license in the US. For example, is a membership to the DMV and it is limited in time. It's valid for five years and then you have to renew it to prove that you still know how to drive. So using regular NFTs would not work really well for this this time aspect as we just alluded to also allows you developer to build in recurring revenue mechanisms for your application or for your community to have sustainable funding.
00:03:56.674 - 00:05:06.874, Speaker A: Every week, every month, every year, depending on what is the timeline that you choose. Because the NFTs expire over and over again allows you to move from the concept of royalties, which is very linked to the NFT concept, to more continuous revenue, where, again, as your community is accruing revenue on a constant basis. Similarly, at Unlock, we've built inside the smart contract several capabilities that would allow you to support not just crypto payments, but also payment using for example EFC 20 tokens, and specifically on top of that also fiat payments using credit cards for example, and we'll come back to this in the future as well. It also allows for off chain access verification as well as onchain access control. Each of these NFTs can be signed to prove their authenticity, and then from the signature we can generate, for example, QR code that are shown on tickets as a way to prove that somebody might have or should have access to a venue, for example, if they're attending a concert or conference. Similarly, some memberships are transferable, but others, and I'd say almost a majority of them, should not be transferable. Your Netflix account is probably not transferable.
00:05:06.874 - 00:05:56.042, Speaker A: Even you share your password with your friends. A certification, a diploma is definitely not transferable. You don't want to be able to transfer your diploma from an organization to another. But you can also imagine that some social clubs, for example, have memberships that are transferable. If you're not currently part of the club, you can transfer that to someone else that will be able to join the club, and then you're not able to join anymore. Obviously the contract that we've built at Unlock are ESC 721, which is the same default NFT contract that you've used in most places, but it has been built with a ton of characteristics. When you think about collectible, it's important, maybe even critical, that the contract itself is immutable, that whatever is in the contract on the first day is there forever.
00:05:56.042 - 00:06:39.740, Speaker A: But when you're thinking about membership as a more generic concept, it might actually be interesting to be able to kind of upgrade or change how the contract behaves. For example, the price of the membership might increase and that is something that is support natively by unlock as well. Specifically unlock's contracts are updatable. You can change the name of the contract, the price of the membership, the duration of the membership, the supply, the number of membership that there could be. You can also change a specific membership. You can imagine that in some cases membership can be revoked, even though somebody might have paid for this. You might allow them to cancel and get a refund or they can be assigned to someone else.
00:06:39.740 - 00:07:29.974, Speaker A: The contracts are also upgradable. We've built the contract with the idea that the protocol will evolve over time and each contract should be upgradable, not by us, obviously, but by the person who deployed it. So a specific creator that has deployed a membership contract should be able to opt in to a new version of the protocol if one has been made available by the Dow. Finally, and this is really kind of an interesting aspect here, the protocol contracts, the public locks as we call them, are programmable. They're programmable because we realize, like as a developer, you might want to build custom logic into your membership contract. So we do that with a system of hooks that allow developers and maybe even at some point creators to add or change the behavior of the smart contract based on some characteristics. So for example, that's how we support discount codes on membership.
00:07:29.974 - 00:08:24.800, Speaker A: You can say the membership price is $10, but if a user, as they go through checkout, as they purchase their membership, they enter a specific discount code, they should only be paying $5 or $8 and that is through the use of hooks. And we'll come back to this in the last section of this presentation. Let's talk about some key important use cases because I alluded to a few, but let's be more specific. As I said, event ticketing, a ticket to a conference, a ticket to a concert is a membership, a one off membership, one that is just for that specific event, but it is a membership. You can also build some kind of recurring subscription. I mentioned Netflix, Amazon Prime, these are good example of this. If you use substack or if you support some creators using patreon, you're probably familiar with the idea of the recurring subscription where the user pays on a monthly basis a certain amount of money.
00:08:24.800 - 00:09:09.622, Speaker A: They can also be time based. So you can build for example, seasons in your application and say okay, there's cohorts that are used for people to, for example, govern a specific project only for the duration of the project. So basically these are type based membership. We mentioned certifications, credential, diplomas, all of these are membership. You're a member of the university or the alumni class of a specific year and that's how you get your diploma. You are member of the people that got trained around using Ethereum for a year and you get that certification, it is vetted for a year. You can use it to prove that you have gone through the certification, but at the end of that year it should be considered expired because maybe your knowledge is not up to date anymore.
00:09:09.622 - 00:09:38.890, Speaker A: It is also useful in the context of gaming. Think of games where you unlock a level. Well, this is a membership to that level. Again, a bit strange to think of this as membership, but it really is if you think at the core of what a membership is as a user, as a player, you're part of the group. You're a member of the group of people that get access to level two. You can also be a member of the group that have access to a specific game item, a sword or something like this. It's also valid in the context of loyalty programs.
00:09:38.890 - 00:10:23.714, Speaker A: So think of it as your airline miles program. You have a card that's a membership card that show that you're loyal to the brand and that you should be treated as a loyal customer. In that example. Unlock can also be used for attendance NFTs, the proof of completion, the fact that you went somewhere or as a way to commemorate something on chain. And finally, you can also use the unlock contract for digital collectibles like PFP collection that we've seen before, or even any kind of other NFTs regular collectible NFTs. The time limit aspect, the time bound aspect can actually be very useful there as well. If you want, for example, to have dynamic NFTs that evolve over time.
00:10:23.714 - 00:11:06.702, Speaker A: So you can imagine your PFP gets older unless the user extends it or renews it. In that example. Let's dive deeper with some more specific use cases. So for ticketing, based on how the protocol is deployed right now 100% of the ticket revenue goes to the creator or the event organizer. It's not like a platform that would take a cut here. The organizer fully controls the ticket distribution and maybe if they won't fully controls potentially the secondary market, they can avoid transfer or they can require transfer to go through a specific clearinghouse for these to happen. They can also create an ethic maybe where smart contracts shine.
00:11:06.702 - 00:11:50.526, Speaker A: Interoperable experiences for attendees before, during or after the event. Imagine if the ticketing for the event is an NFT. You can use it, for example, to connect to a discord server before the event and join all of the other attendees. Or you can use it when you connect to a reservation website to book, for example, a hotel room and prove that you have a ticket to get a discount for this. So that's the kind of thing that you can do before the event, after the event, or maybe during the event. You can use this as a way to build a system where people kind of vote on what is the best session of the conference and only people that have a valid NFT can actually vote using a tool like Snapshot. If you were to use traditional ticketing system, it would be really hard to build.
00:11:50.526 - 00:12:47.234, Speaker A: You would have to build authentication into your application that plugs into the event ticketing application. And they probably don't have an API for this, and even if they do, they can restrict who can access that information. It's also useful after the event where you can imagine, for example, like next year's conference might have a discount for people that were here the previous year. If you have that concept of NFTs ticket, it's really easy to just program the smart contract to say whenever somebody has a ticket from last year, they should get a 10% discount. Tickets are membership cards that connect to a community of people that are interested in a specific concept. Unlock for ticketing has been used at multiple conferences in the crypto space, in the Ethereum space, and here we're showcasing Dapcon, which is a conference happening this year again in Berlin between September 11 and September 13. Dapcon has used unlock last year.
00:12:47.234 - 00:13:29.070, Speaker A: Actually there's about 1000 attendees that are mostly in the crypto ecosystem. What's interesting here, they're using unlock, obviously, but they're also using unlock on a specific chain. We haven't talked about this yet, but unlock has been deployed on nine different EVM networks. So obviously you probably know of Ethereum mainnets, you know of Polygon, but Defcon chose Gnosis chain, which I think is a very good option to deploy this smart contract. We're also on optimism on Apitrum and multiple others. You can find them all in our doc. What's interesting about Dapcon is like they're a crypto conference and so it only makes sense that as a crypto conference they're dog fooding, they're using the technology that they are writing or talking about.
00:13:29.070 - 00:14:16.526, Speaker A: And in that example specifically, they decided to use unlock for this. We also have built inside of the unlock a reference ticketing application, a system to verify authenticity of tickets by scanning QR codes. So really excited about that use case and if you want to build some kind of ticketing solution, you should try to inspire yourself from what Dapcon has done. Other examples of conferences that have used unlock east Taipei a couple weeks ago in Taipei, EFCC in Paris has used unlock last year as well. Ethborsha is using unlock for ticketing, et cetera, et cetera, et cetera. Another example of use case that we talked about is the concept of subscriptions. So subscription enabled token access to experiences and services.
00:14:16.526 - 00:14:47.190, Speaker A: Think again. A Netflix subscription. It gives you access, not token based, but it gives you access to their streaming service to view applications. Your gym membership gives you physical access to the gym so you can exercise there. It is sustainable subscription and recurring revenue for the business that host it. They can use crypto or credit card for these things. And what's important here is, like, the business has a direct relationship with the members.
00:14:47.190 - 00:15:14.186, Speaker A: There is no middleman involved in that situation. There's no service in between these two things. The Netflix example is an interesting one, right? You can get your Netflix subscription either from the Netflix.com website or through Apple or Google on mobile devices when that happens. Through mobile devices. As a matter of fact, Netflix and Apple and Google act as middlemen here and they can change the terms. They can decide to not validate how the application works anymore.
00:15:14.186 - 00:15:45.206, Speaker A: And this is not ideal for a business like Netflix, obviously. This is obviously useful for content. We talked about substac briefly for software. If you think about in app purchases, a lot of these are subscriptions that know just ways to unlock different features into an application. Think about music services like Spotify, obviously, video, podcasting, et cetera, et cetera. So if you're trying to build an application in that field for creators, definitely think about monetization using something like Unlock. An example here that is really powerful, I think, is the example of DeFi Robot.
00:15:45.206 - 00:16:42.090, Speaker A: DeFi Robot provides trading tips and mechanisms to automate some of the trading. And what's interesting about that membership, it's using Unlock. Obviously, on Ethereum Mainet, the monthly membership, if I'm correct, is about $300 or almost $300, which is a very pricey one. But once you have the membership in your wallet, you can access a dedicated Telegram channel as well as access some key feature into the application. At this point, DFI Robots, which is a pretty simple application, is making about $150,000 in annualized membership revenue. So again, if you build these things right, that's actually a very significant revenue opportunity for any kind of community or software application there. These time based membership we talked about a little bit are not necessarily recurring, but they're kind of time limited.
00:16:42.090 - 00:17:18.966, Speaker A: So think of it as seasonal or even sometimes perpetual memberships that, for example, give you access to a Discord or Telegram. You approve some of that, obviously. What's interesting here is, like at Unlock, when you create your membership contract, you can choose the currency. And so since that kind of time based membership is really used in the Dow space, there's something really cool about using the ERC 20 currency of the specific community as the pricing mechanism. Example of this is cabin. So Cabin is a project that actually launched two days ago. It's a network city.
00:17:18.966 - 00:18:37.626, Speaker A: It's basically a community of people that have some kind of co living places. And they have a membership where if you are a citizen and that's how it's called in the membership, you get access to some specific airdrops specific features that are allowed only for Cabin members. What's interesting here is what they've built is a system where if you have 1000 cabin tokens, the membership is free. And for this they actually use a hook system that we'll discuss in the last section of this presentation onto certification. We talked about this earlier, your diploma, the fact that you've taken a course that you maybe attended, hackathon non transferable, obviously critically, but also time limited most of the time to make sure that your knowledge are up to date. Example of people that are using unlock for this is a team called Planodao that have created the Certified Digital Asset Advisor, which is basically a proof that you went as a financial advisor through some education around cryptocurrencies and around crypto assets, digital assets altogether. And that to date they have certified over 100 financial advisors that went through that curriculum and in the end received one of these NFT as a proof of completion.
00:18:37.626 - 00:19:19.098, Speaker A: What's interesting about these NFDS is like they can be represented or added, for example, to a LinkedIn profile as a way to show again to your potential customers that you are certified here. So building certification application I think is also one of the things that we're excited about to see people do in the ecosystem. We talked about gaming briefly. This is a very popular game in the web3 space. It's called pixels. It's a multiplayer game built on blockchain and they use unlocked memberships as a way to create these inapp purchases. And you can have different kind of feature into the application that are time limited.
00:19:19.098 - 00:20:19.634, Speaker A: And if you acquire these NFTs, then you are able to actually do certain things inside of the game. So really if you're building a game, think about using time limited NFTs as a way to do this. Another example of loyalty, another example of use case is the ring around loyalty. One of the examples that we want to highlight here is a company called Stakes, which is basically building a loyalty program around a restaurant brand or chain. And what's interesting here is once as one of the customers, you have one of these NFT, you get some priority access to a reservation system that allows you to book restaurants and be treated as a premium customer and access to some premium table, maybe free drink or dessert, and a ton of other possibilities that each restaurant might offer to their customers. Finally, attendance NFTs, sometimes called PO app in the ecosystem. It is basically a system, it's basically an NFT that someone can earn if they have done something.
00:20:19.634 - 00:21:13.438, Speaker A: It is valid forever. And what's interesting here, it can have dynamic metadata attributes. We talked briefly about them, but still unlock is usable for PFP project from, you know, one, one of one to 10,000 plus static or dynamic NFTs can be minted on demand by users or can be airdropped and obviously supported on all of the networks that unlock supports. Tales of Electora is an example of a collectible that was built using unlock. And what's really interesting about Tales of Electro is like you can see here examples, each of these avatar actually has a component of both the avatar and so called weapons, which are both NFTs. And if a given address or given user owns both an avatar and the weapon, the weapon will show in the background of the avatar. You can see here, for example, the arrow and the bow displayed behind that wolf.
00:21:13.438 - 00:21:56.820, Speaker A: If the user of that NFT were to sold the weapons, then the avatar would not have the bow and arrow. It's kind of dynamic based on this and I think this is a very powerful tool. Just a reminder for everyone who's joining now. Unlock protocol for memberships and memberships are a very core primitive to lots of businesses. Can be used from even ticketing all the way to digital collectible through recurring subscriptions certification, credentials, gaming loyalty, attendance, NFTs. Really you have to think about unlock as a framework for NFT memberships and memberships can be lots of different things. So thank you very much for listening to me until now and let's jump into the right section in a couple minutes.
00:21:56.820 - 00:22:35.866, Speaker A: Let's now talk about the unlock ecosystem and the developer tools that we put for people to use inside of their applications. So, first of all, quick reminder, unlock is a protocol. It's a smart contract system. Of course you can and you should if you can just use the smart contract and not rely on anything that was built on top of us by the Unlock Labs team. However, if you want, and we think it's a good way to kind of scaffold your application, you can start by using some of the tools that we've built. For example, we have built two really important front end applications. The first one is what we call the unlock dashboard.
00:22:35.866 - 00:23:25.674, Speaker A: The unlock dashboard is a way for what we call lock managers to deploy their membership contract, their lock. From there they can also manage the contract. They can change, as we've seen earlier, the contract is updatable, so they can change some settings, the price of a given lock, the number of memberships, the duration of these memberships, et cetera, et cetera. They can also manage members so they can see the list of existing members, they can change the membership status of someone, can refund, can cancel. They can also AirDrop membership NFTs to specific addresses or even use some of the features that we built, such as the wallet list AirDrop, where it's basically airdropping NFTs by email. The recipient gets an email with a claim link that they can use to bring the NFT from a placeholder address to their own wallet. Obviously, as I said earlier, these membership contracts are NFT contracts.
00:23:25.674 - 00:24:14.478, Speaker A: Like, I mean, they're ERC 721, which mean that you can also customize the metadata on this NFT, starting with the image, obviously, or even set custom attributes for the type of membership that you have. So for example, if you're organizing an event or building an event platform, there's a set of metadata specific to events so for example, the location, the starting date and the starting time. The finishing date and finishing date and finishing time. But also, for example, things like description of the events. You can say, okay, this is a conference happening on blah blah blah with speakers X and Y and Z. Similarly, we also have built a second really important application that is called the Checkout. The Checkout UI is not meant for lock managers, but really it's meant for the soon to become members.
00:24:14.478 - 00:25:02.960, Speaker A: It's a way for people to mint NFTs by purchasing them. And I say purchasing, but in some cases, these NFTs can be free as long as they're claimable by the end users directly, and not only airdropable by the lock managers, you can use the Checkout UI. The Checkout UI is a flow that has multiple steps that obviously starts with connecting the wallet and finishes with minting the NFT. But during that flow, the lock manager can configure it so that some metadata is collected as well. So for example, if you're organizing an event as we talked about, you might want to collect information about the attendees, their first name, last name or email address. That is something that you can easily do with the checkout. We have a way to configure this with kind of a no code tool accessible from the Dashboard, the checkout builder, but you can also configure this in code and we'll talk about this a bit later.
00:25:02.960 - 00:25:48.966, Speaker A: Finally, as I said earlier, unlock smart contracts are built in a way that they instantly support payment using fiat. So using credit cards specifically, and you can do that from the dashboard, configure things from the dashboard, and then users can enter their payment info from the Checkout UI. We also support some interesting mechanisms such as swap and purchase. Swap and purchase is basically a flow on the checkout that user can pick if they don't have the currency of the membership, but they have another one that can be swept on the same network, on the same chain for the one required by the lock. So let's take an example. Maybe I deploy a lock that is using USDC as its currency on polygon. But myself, I've actually never bridged USDC token to polygon.
00:25:48.966 - 00:26:26.114, Speaker A: I only have matic token on polygon. It's not a problem. The checkout flow will actually include a one click option for me to swap. So pay with my matic that gets swapped into USDC, into a membership in a single transaction. I don't have to leave the UI, I can just do that straight from the Checkout UI. So that's the two tools, the Dashboard and the Checkout that are basically UI frontend that you can use to get started or also use into your application. We also have built a lot more developer tooling that are directly useful for you developers to integrate unlock into your applications.
00:26:26.114 - 00:27:03.886, Speaker A: First of all, we mentioned this earlier, the concept of subgraphs. So as you know, the graph is a protocol for onchain data indexing, but beyond that and we have built custom subgraphs for unlock smart contract. These custom subgraphs include obviously representation of the locks, the smart contract. So you can get all of the information from a smart contract at once using the subgraph or multiple locks at once from the subgraph, but also the memberships. And they're called keys in the context of unlock. So you can retrieve all of the members on a given lock in one single transaction. I think the subgraph actually has a and it's not an unlock limitation but it's a subgraph limitation, has a maximum of 1000 keys, 1000 items.
00:27:03.886 - 00:27:38.202, Speaker A: But you can paginate and kind of do 10 00, 10 00, 10 00 and kind of add things up from there. The subgraphs also include what we call receipts, which is basically an object that you can use to identify what payments were made on a smart contract. Another useful developer tool that we have introduced is called unlock JS. This is a JavaScript and TypeScript actually library that retrieves data from the chain. So you could use that instead of the subgraph. But it also includes the ability to trigger transactions to change the state of the chain. It is based on ethers.
00:27:38.202 - 00:28:14.294, Speaker A: JS and by the way, you could very well use Ethers with a specific lock, but it does provide a lot of syntactic sugar for things that would require a lot more manual handling. So you should check out Unlock JS if you want to deploy locks for example, or if you want to purchase memberships. This is definitely possible. Again, you could very well use existing libraries like Ethers or Web Three JS or others in other languages if that's easier for you. Unlock JS is completely optional. Another tool that we built is called the Paywall. So I mentioned earlier the checkout UI.
00:28:14.294 - 00:29:13.722, Speaker A: The Checkout UI is basically a UI that can be displayed using two mechanisms. On one side it can be done as Checkout URLs, so kind of standalone web pages that can be opened in a new tab for the user or it can be used as part of the Paywall which is a JavaScript library that can be embedded inside of any web application. The Paywall obviously supports signing riffium and includes all of the Checkout steps. This is really useful if in your application you want to, for example, identify users or allow them to purchase membership without sending them to a different web page. That Paywall is obviously completely configurable using a JSON object. So you can customize the title, the image, the number of locks that are displayed and the metadata collected, for example, as I mentioned in the previous step. Finally, a last tool that we have which we think is really useful actually there's a couple more tools, but for this presentation I will only clarify these is the concept of hooks.
00:29:13.722 - 00:29:48.194, Speaker A: As I said earlier, the smart. Contract themselves are programmable. You can change the behavior of your membership contract using these hooks. There is at this .7 hooks on the contract that can all be called or implemented sorry for your specific lock and change the behavior. Some of the popular hooks include, for example, the on key purchase, which is basically a hook that gets triggered when someone purchases a membership and one that's about to be minted. That hook is really interesting because it allows you to do things like check that the user meets certain criteria.
00:29:48.194 - 00:30:42.886, Speaker A: So for example, are they on a specific allow list? If so, then yes, they can complete the purchase of dimension, or no, it will fail the transaction. Another characteristic of that on purchase hook is that it includes the ability to customize the price that the user pays based on certain characteristics. So if the user is on the loudest of discounted people or if they have entered a discount code at the time of purchase we'll actually come back to this specific example in the last section of this presentation and so please jump to that step if you're interested in this. One last thing that I want to mention is existing integrations unlock, the public lock. Sorry, in the unlock protocol, the public lock, the membership contract is just like any other ERC 721 contract. It is implementing the base ERC 721 specification, including stuff like transfer and everything. So it does work with any existing framework like ethers, third, Web three, JS, Wagme, et et cetera, cetera.
00:30:42.886 - 00:31:36.666, Speaker A: Like I mentioned, but also any kind of wallet, whether it is a proper MetaMask hardware wallet, obviously, but also things like Magic or Privy if you want to use these wallet as a service kind of approaches. Finally, unlock has been integrated by different teams inside of their application or by us inside of the other applications. I mentioned Magic as an example. That's something that we have a tutorial from on the Docs website Stripe that lets you connect with Stripe Connect as it's called, to receive payment in crypto superfluid. The streaming protocol uniswap that's for something that I described earlier as the swap and purchase Flow East Pass that allows users to download iOS Android passes into their phone, their person's, NFTs, et cetera, et cetera. If you're building an integration into an existing platform, please get in touch with the team. We'd love to hear from you.
00:31:36.666 - 00:32:05.486, Speaker A: We'd love to help you build this. I want to show you another kind of overview of the unlock protocol ecosystem. So basically these are all applications that either work or have integrating unlock natively. So you have a bunch of protocols. So for example, lit protocol is a token gating protocol that does encryption. You can very well use the unlock membership to decide whether a specific piece of content should be encrypted or not encrypted using unlock works with Superfree that I mentioned earlier, works with Livepeer Actually. We'd love to see Livepeer integration.
00:32:05.486 - 00:32:43.402, Speaker A: So Live is a video protocol, a streaming video protocol that you could use to token gate, live streams. A bunch of application also use unlock. So you mentioned, I mean, Guild is a good example, but Coinbase are two of the UIs that you can use as a creator to deploy or manage rather membership and connect these membership to your community. You can use stuff like Beam for video or Monetize to integrate in Notion, et cetera, et cetera. We also have a bunch of agencies and friends that are using unlock directly into their application. And so you can see some of the names there. Finally, there is a ton of projects that are built on top of unlock.
00:32:43.402 - 00:33:19.420, Speaker A: You can use that list. And as a reminder, we're actually unavailable on nine different network, which means that one of them is missing from that slide. But ether mainnet polygon gnosis chain optimism. Arbitrum celo binance Palm is the one that's missing from here. Again, check our docs, we have all of the links with this. And by the way, on all of these networks, we've obviously deployed the corresponding subgraphs or any of the other smart contract that we would use such as the credit card or system, et cetera, et cetera. Let's move on to the next section after this.
00:33:19.420 - 00:34:05.304, Speaker A: Let's jump right into our first tutorial of the day, how to build a token gating application with unlock obviously on the front end only. So we're not going to write any smart contract code, we're not going to write any solidity code. We're only going to focus on building a front end application using JavaScript technologies. Let's actually first look at the basic app that I built. This is a regular NextJS application. I'm starting from there and what I want to achieve is basically have this section here be a members only section. So only visible if the user has authenticated first and obviously if they have a membership in their wallet, if they don't have a membership in their wallet, we will prompt them to purchase one.
00:34:05.304 - 00:34:32.144, Speaker A: And obviously until we know who the user is, we'll add a mechanism to authenticate users. So let me actually do a quick show of the application. This is the basic app component. Again, vanilla NextJS application. It has a single page which is page here in a single content section, which has a little bit of content that we want. Token gate. Let's get started by first installing a couple dependencies here.
00:34:32.144 - 00:35:11.528, Speaker A: And I want to install two dependencies specifically. I have them here. Yep, here they are. Wagme, which is a JavaScript, actually a react hook framework for dealing with smart contracts and connecting wallets, and Ethers, which is a low level JavaScript library that interacts with the same smart contracts and wallets. So I'm going to just go ahead and install these two things pretty basic and then we'll go look at our app. Here what I want to do first obviously is add the dependencies that I just installed. So I'm going to just do that at the top of the file.
00:35:11.528 - 00:35:44.612, Speaker A: Nothing too fancy. Then I'm going to create what is called a Wagme client. That is what's going to use. That's what our application is going to use to interact with the wallets. And here we see we're pressing this little property AutoConnect True, which is basically allow users who have already connected to stay connected and AutoConnect when they load the page. But then we're also passing a provider. The provider is the network component if you want, that allows the application that we're building to connect to the blockchain and we're using the RPC endpoint that unlock provides for development purposes.
00:35:44.612 - 00:36:39.928, Speaker A: You're more than welcome to replace that line specifically with Alchemy infura or any of the RPC provider that you actually recommend using your own as soon as you hit production. We see here we have a little network component here and we're actually going to import that from a config file that we have. I can't type today from network and obviously I need to remove that little N from the config file. Let's go look at the config file. There's not much in it for now, just the network. Once we have this, obviously the next I think that's what I want to do. Once we have this, we need to wrap the component here inside of what is called a Wagme provider and this is a react provider for specific context which allows us to connect down the application.
00:36:39.928 - 00:37:05.804, Speaker A: So that's the basic setup here. Let's double check. But the application is still accessible. Nothing's changed because we haven't actually done anything from a code perspective. Let's now look at our index page and that's actually more interesting here. What we want to do on that page is obviously get started by make sure that the user is connected. For this we will use other components from the Wagme library.
00:37:05.804 - 00:38:11.252, Speaker A: So I'm going to just add these dependencies right away at the top. So first we're going to use Use account which allows us to get information about the user that's connected and use Connect which lets us connect the user. I'm also using this injected connector which is basically a way to retrieve the injected wallet in the web browser. So I'm just going to include these two hooks here and I'm going to change the behavior of the application a little bit so that if the user is not connected, we will basically add a button to let the user connect, which seems pretty straightforward. And then we're going to just change one thing for now which is if the user is connected, we will show the content. And obviously I am missing a little parenthesis here, but we'll also add not just the content but a button to disconnect. And since we're going to have two component in the same element, we do this and for the disconnection I'm actually going to use another feature from Wagme, which is this disconnect function here.
00:38:11.252 - 00:38:28.170, Speaker A: So that's pretty much it for now. Let's go refresh the page. I'm already connected because I connected before. So what I'm going to do here is disconnect from here. So you see that happening here and I'm going to disconnect from here. So if I refresh the application now, I only see this connect button, obviously because I'm not yet connected. I click connect.
00:38:28.170 - 00:39:00.336, Speaker A: My wallet should have prompted, but again connected earlier. It is not prompting me to connect, but I'm connected and then I can see the content. So again, fairly straightforward. Now what's interesting though is we now have a connected user. We know what the user's wallet is and so that's going to allow us to move to the next step which is to add a special component which we'll call basically something like Token Gate. And so let's actually do that. I'm going to add a new component, Tokengate TSX.
00:39:00.336 - 00:39:34.592, Speaker A: And this component is going to be fairly simple. It is just going to for now, return the children. So it's actually not tokenate anything for now. It is just serving the content that it has. And what we'll do now is actually wrap the content inside of the Token Gate component. I just want to make sure that I'm including this at the top of the file as you can see here. And so now the content component is still here, but this time we wrap it into the Token Gate component which will have the logic of making sure the user is connected and has access.
00:39:34.592 - 00:39:58.824, Speaker A: For now, again, nothing changed oops mismatched between what the server shows. But if I click here, I can now still show the content. But this time what we have is the way to go through that, through this Token Gate component. This component is going to be a bit more complicated. Oh, actually I forgot to add the props here for the children. So this component itself is going to be a little bit more complicated. And so we'll get started working with this.
00:39:58.824 - 00:40:50.744, Speaker A: So here we're going to use again the Wagme library. We're going to use Use account which we'll use to retrieve the wallet address. But we'll also use this Use contract with which is a hook that lets us retrieve some information about a smart contract. What we'll do here is also include another library that we haven't used so far and I'm actually going to install it, which is this component that unlock Provides, which includes the Abi. The Abi is if you want the API description of what the smart contract has. And I forgot to say add here and I have a quote that I need to remove, but I'm adding this dependency now. It's going to take a couple of seconds to install.
00:40:50.744 - 00:41:33.496, Speaker A: And what's cool about that now is that I'll be able to use this into the code. So let's actually do this. I'm also going to add actually that's it for now. The first step is to then now add a bit of logic here, which I'm pasting here. So lock address, that's going to be another configuration that will come to this and address is going to be the user's address. So actually let's retrieve that directly from the Use account component. So I'm just going to do const address equals Use account and then lock address will actually include this from our config as well, which I'm going to just add in a minute here.
00:41:33.496 - 00:42:02.190, Speaker A: And so I'm going to now write it in the config. So the lock is the membership contract as we discussed earlier. And so I'm just going to add an address here other than the membership contract that I've deployed before. There is no need to go through that process here, but know that you can easily do that from the unlock dashboard. So let's actually go back to the token gear component. We have this interesting hook now that it's being called and it's going to retrieve some data. We'll look at the data in a second.
00:42:02.190 - 00:42:44.620, Speaker A: If there's an error, this variable is going to be set to true. And if it's loading, this variable is going to be set to true. And what we're passing as argument is first a lock address, the smart contract address that we're retrieving the abi of the public log, version 13, that's the latest version of the protocol that I've used here. And the function I'm using here is called balance off. This is a way to retrieve from the contract if a given address that we're passing as argument has any membership token that is valid, it will return zero if the user doesn't have a valid or if they have one that is expired. And obviously we'll return 12345 depending on how many valid membership the user might have. So let's actually now add a little bit of logic here.
00:42:44.620 - 00:43:37.452, Speaker A: Obviously if the page is loading, we don't actually want to show the children right away if there is any kind of error. We also don't want to show the content. But the last step is data. And actually we'll look at this in a second, but equals to zero, we will show something like you need a token to access this content. Let's save this and let's actually go to our page already. You self refresh, but you can see here that it says you need a token to access the content because as a matter of fact, and I'm just going to console log the data object here so you can all see what it's in there. It's a so called big number and it's a JavaScript object and this is the xadecimal value of zero.
00:43:37.452 - 00:44:13.530, Speaker A: So at this point I don't have a membership and I cannot see the content. So really nothing. I mean, this is what we expected. And so I guess the next step is to add another function here. So rather than actually tell the user hey, you don't have access, we'll basically show them something along the lines of if you don't have access, well you need to buy a membership. So I'm going to replace this with a button that's called Buy Membership and I'm going to add a new checkout function to our component here. This function will get started with an empty version of it.
00:44:13.530 - 00:45:00.644, Speaker A: So I'm just going to do nothing in here and we'll look at implementing this. For this we're going to use another library that the unlock team provides. Obviously completely optional but it makes things much easier which is the Paywall library. The Paywall library is basically as the name indicates, a quick little paywall that you can add to any web page that allows users to check out or purchase a membership. I'm also going to add another useful package which is called the networks package from unlock that has all of the configuration for unlock. They're again completely optional but it's simplify things greatly if you use it. So let's go back now to the code here and let's look at what we're going to put in the checkout.
00:45:00.644 - 00:45:51.592, Speaker A: So first we're going to do an interesting things, a couple of interesting things. We're going to load the provider used by the connector and connector is actually something that we get from Use account and that's the object that connects to the user's wallet if you want. So we're going to get that provider and then we'll instantiate a Paywall object and again that's coming from the unlock library. I'm just going to add this. I didn't add that at the top as a requirement here. And Paywall config and networks, actually networks we have it from the package that we just installed so I'm going to add that as well and the Paywall config will get it from the configuration and we'll go at that in a minute as well. So I'm just going to replace this line with this and Paywall config here.
00:45:51.592 - 00:46:41.080, Speaker A: I'm just going to copy paste what I have already built before and this is basically A JSON Blob and you can find all of the details on how to build this inside of the unlock documentation that lets you configure how the Paywall should behave. It should have multiple locks here but in this example just one, it could have multiple locks, just one here with the lock address on the network number five. We're going to skip the recipient step assuming the user is purchasing for themselves. And then we're going to put a name of my membership or my app membership maybe seems more accurate here. And we're also going to use what we call the pessimistic which is basically we're going to require the user to wait for the transaction to be mined before returning to the application. Let's go back to the token gear component now. So we have this Paywall but that is not enough.
00:46:41.080 - 00:47:05.520, Speaker A: What we need to add is the ability for the user to load the checkout. I'm just going to add this here and basically load checkout model. It's an async function that's going to show a little checkout model. And we'll go look at this right away. So let's actually go to the application. You see now I have a button here which is really useful. And I still have my console log, which makes this a bit messy, but it's fine.
00:47:05.520 - 00:47:34.804, Speaker A: If I click here what's going to happen. It's going to load the checkout model and I have my app membership and the Smart contract that I'm using here at the address that I've specified earlier. You can verify this is the right address here. So this is all great, but let's actually go look at the rest. If I close, nothing happens here, which is what's expected here. Result. What's interesting is like if there is a result, we will get inside of that result object a hash.
00:47:34.804 - 00:48:06.950, Speaker A: And what's interesting here is that we want to use the hash in our UI. I'll explain what it is in a second. So we're going to use React, use State. And here what we want to do is basically have a nicer UI to show the user that it's important to wait, that they are waiting for donation. So even though they might not have a membership, let's remove this if they have just bought one. We are going to wait a couple of seconds for the transaction to confirm. And then once this gets confirmed, hopefully they'll be able to see the children.
00:48:06.950 - 00:48:32.024, Speaker A: All right, so we're ready to do the final test on this application. And I'm just going to click Connect here. At this point, my wallet is connected, which is exactly what I wanted to do. And I'm going to click the Buy membership button. You see this little pop up shows up and I'm going to click Next. And this is a renewal because I probably have already purchased a membership before. So we'll have to send this transaction.
00:48:32.024 - 00:48:53.392, Speaker A: We can go see it on the Block Explorer, actually. And so you can see that a blockchain transaction is being minted. We'll have to wait a second or two here. Oh, this has been mined. We usually wait for a couple more blocks inside of Unlock. So I can close this, hopefully. And you see that now I can access those content.
00:48:53.392 - 00:49:38.930, Speaker A: So I refresh the page here and click Connect. You see that I can see the content once my membership is going to have expired, which should be actually, you know what, which should be shortly, I would have to reconnect and buy again. So this is it for today. Let me stop the video here how to use Unlock in Smart Contracts. Here we're doing something a bit special, which is we're going to implement a hook to modify the behavior of the public lock, which is the membership contract. What we want to do here is something actually pretty simple. We want to make sure that every time a new membership is sold, the price of the next membership goes up a little bit.
00:49:38.930 - 00:50:28.044, Speaker A: This is usually called a bonding curve and this is a good way to implement what is called a discovery, a price discovery mechanism where basically every time a new membership is being sold, the price goes up. And at some point you would assume that no more memberships are being sold because the price is now too high. So let's go ahead and get started. So to do this, we'll probably create a new folder here, which I'm doing here. Okay, I already have, well it's actually doing example here and we'll just CD into that one. I already have the bonding curve. Locally they will run common called NPX Arthat which installs the hard hat toolset.
00:50:28.044 - 00:51:13.664, Speaker A: Arthat is one of the popular tool sets in the ethereum world. You should definitely consider using it for any project that you use. It is not related to unlock. And so here just completing the default options and let's say yes, we'll install the toolbox here and wait for a few seconds. When hardware does this, it actually does install not only a bunch of dependencies, but also creates a scaffold for a project which is going to be very useful for us as we're going to go into this exercise. So let's wait a couple of seconds for this to complete. In the meantime, I'm actually just going to open the code here and show you what's in here.
00:51:13.664 - 00:51:38.600, Speaker A: There's actually a contract that is kind of short doc. It's very confusing, but it's not received at all with unlock and we'll actually remove that fine a second. It also has a test which basically tests the behavior of the contract that we're going to write. It also has interestingly a configuration file for Hanhat. And we'll actually start looking at this. So I see that the dependencies have been installed. We'll install two more dependencies.
00:51:38.600 - 00:52:29.450, Speaker A: One is the unlock contract package. So yarn add unlock protocol package and then we actually have a specific unlock plugin for Hanhat which we'll install right after this just to make sure that everything works as we expect. Once we have this, we need to modify our files to make sure that they include all of the required setup. And so we'll basically have to do one simple thing which is to add the unlock plugin here to make sure that it's going to be used. And that should be pretty much it. So let's actually do yarn run test just for the sake of making sure that everything is working as we expect it. Yarn run hard hat test, sorry.
00:52:29.450 - 00:53:06.276, Speaker A: And we're missing a bunch of dependencies here which we'll just install that's actually yarn as this. So yarn add and that should work. There's a quote somewhere. Yarn add here. Just installing all of these extra dependencies which are used by hard hat specifically. So let's give it a second for you for this to complete. But once we're there, what we're going to do is basically start by cleaning up that code.
00:53:06.276 - 00:54:04.876, Speaker A: So we're actually going to use we'll rename that rename to maybe bonding curve, bonding curve on type bonding curvehook sol and so that means it will pretty rename the contract as well to bonding curve hook and we'll remove pretty much everything that's in it. The constructor will just maybe not even have anything in here. Let's not make it payable because it's actually not going to be useful to be payable. And so that's the most basic version of our hook here. We'll also look at the test obviously rename that bonding ICOP type curvehook JS. I think that's fine and we'll go modify the test. So, quick indication.
00:54:04.876 - 00:54:58.276, Speaker A: So as I said, we're going to modify the behavior of the lock and we're going to modify the behavior of the lock when a new key, a new membership is being purchased. For this we actually have to implement two function in our smart contract. One function is called on key sorry, it's called key purchase price. And I'll explain in a second what this function does. And then we'll have to implement a second function which is a bit pretty basic, which is the on key purchase function. So what the first function does basically the lock, the membership contract calls that function with whoever is the sender of the purchase function with the recipient address, the referral and again, these are concepts that are specific to unlock. You should check it out in our docs as well as a data argument.
00:54:58.276 - 00:55:36.310, Speaker A: And then this function is expected to return a key price. Here what we'll do is return what is the default key price. So basically we'll make sure that we return the normal key price. And I realize I forgot to include the interface file for this to create. The second function is the one that actually is called at the tail end of the purchase function when the purchase has been successfully achieved. And that's the one that we'll use here to modify the state of the contract. And so to do this we'll just basically do something pretty simple which is go read.
00:55:36.310 - 00:56:16.860, Speaker A: I mean we'll basically create something where we'll have the lock that we retrieve as the sender of the transaction that calls this specific contract and then we'll retrieve the price. We'll multiply by two here the price doubles every time and we call the update key pricing function to change the price. So basically we've called this function, we change the price and obviously we keep the same currency. Token address is the currency of the lock which could be an ESC 20 or the base currency of the chain. So our contract is actually pretty much implemented at this point. There is not much else to do. The next step is obviously to modify the tests.
00:56:16.860 - 00:56:45.188, Speaker A: So here what we're going to start with is obviously use something that is very useful here. So actually we'll clean that first because I don't think we need any of that at the top here. We actually don't even need that part. We'll describe this as being the bonding curve hook. We'll just remove this function because we'll not use that. Actually we'll remove everything here. So again, we are in a pretty basic default state.
00:56:45.188 - 00:57:13.270, Speaker A: And then what we want to do is before any of our tests run, to do something pretty simple which is first to deploy the unlock protocol. And that's going to happen locally. And for this we use this function that we get from the Rhat plugin. So I'm just going to include this from Hardhat. So unlock deploy protocol. Then we're going to pass a bunch of default arguments for the lock. And so here we pass duration of seven days.
00:57:13.270 - 00:57:52.268, Speaker A: We use the base currency which we don't need to pass any address here, any smart contract currency, contract address. It will be an ESC 20. We set a key price of 1 Gy. Basically that is we'll have a number of membership limited to ten for now. And we'll call this basically a demo. Lock is the name of the lock. So what's going to happen next is we're going to create the lock using again that plugin that we use with the right arguments and we'll get hopefully the lock address in the result we will also deploy the hook.
00:57:52.268 - 00:58:15.508, Speaker A: So that's actually really important here. We'll wait for that to be deployed. Here we use the default hard hat way of deploying contract and then we'll do two things. The first one is we want to call this set even hooks function on the lock. This function does something really useful. It sets the hooks on a lock. And here we're basically only setting the first one, which is the purchase hook.
00:58:15.508 - 00:58:45.424, Speaker A: You can see that we're passing a bunch of zero addresses because there's a lot of other available on key transfer, on renewals, et cetera, et cetera. So we only want to set the first one for this demo here. So we pass the address of the onkey purchase hook that we just deployed, the bonding curve hook. And we also want to do something critical here which is add the hook to be a lock manager. Let's go back to the code. So I explained this a bit more obviously. This function, not anyone can change the price.
00:58:45.424 - 00:59:17.836, Speaker A: Only what called a lock manager can set the price of a hook. And the lock manager is the first person who deploys it or any other address that has been set to be lock manager. And here basically we're calling the lock to say hey, you allow the hook to be a manager as well. So once we've done this part, basically our code is ready. And so. The next and final step is to actually add one test for the sake of this demo. But you are more than welcome to add more.
00:59:17.836 - 00:59:50.788, Speaker A: So I'm just going to do this here. We're retrieving the list of signers, we'll make sure that the lock exists isn't set and then we'll make sure that the key price is basically our default from above here. We actually could use something locked at key price here. That's going to be cool. Let's now make a purchase. So we are basically calling the purchase function on the lock. That first argument is the values and we should actually pass probably.
00:59:50.788 - 01:00:09.720, Speaker A: I mean we pass zero here because it's a default currency lock. It's okay. We could actually pass the actual value. So let's actually do this, see if that works. And then we pass the recipient. So that's the recipient's address. So the person who's going to get the membership NFT, this is the key manager.
01:00:09.720 - 01:00:41.520, Speaker A: So it's the address that's going to have the transfer rights over the NFT that is minted. And then this is the refer which would receive any referral fee. That one is the data argument here. We leave them empty and that's the empty array. We pass arrays for each of these values. So actually let's just for sake of t do this. We pass an array for each of these because you could actually call this function with multiple values to purchase multiple memberships in a single poll.
01:00:41.520 - 01:01:12.912, Speaker A: Once this transaction has been executed, we'll just verify that the key price has been successfully changed to be now double what it was. So we had a key price of one guay and now we should have two guay. That's pretty much it. Code is ready now. So the next step is to run our test, which I'm going to do here right away. It compiles and we have obviously an undefined argument here because lock arg is actually not exposed. So I'm just going to keep that value that I had before.
01:01:12.912 - 01:01:55.816, Speaker A: I think that's going to make things easier. And so this time if I run the command it should compile fine and you see that the test passes. So we're done for that exercise. You can see that we've created a lock first in the code here we've attached a hook that basically changes the price of the membership every time a new membership has been purchased. Just make sure that if you want to learn more about this, go check our docs. We actually have a specific tutorial so the docs are at docs unlockportocol.com. We have a specific tutorial for how to create hoax.
01:01:55.816 - 01:02:18.324, Speaker A: The one that is on our website is the one to create a password protected purchase. So please do check it out. It provides more detail around hoax issue. You need them as well. In our docs you can find all of the reference for the API and the protocol itself. So please use this if you want to start implementing anything with unlock. Thank you very much.
01:02:18.324 - 01:02:19.090, Speaker A: See you soon.
