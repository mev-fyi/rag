00:00:06.250 - 00:00:39.626, Speaker A: Hi, everyone. I'm Kevin from Boba. Not sure if you have heard about Boba network yet. It's an optimistic wallop that allows you to make off chain calls within one single atomic transaction and that's called hybrid compute. Formerly Turing. That's what I'm super grateful today that I'm allowed to present you today to give a little bit of backstory of why we started with hybrid compute. Basically, we have all seen the Grace last year.
00:00:39.626 - 00:01:30.220, Speaker A: We have the play to earn games, right? Axio Infinity and all those copycats and comparable play to earn games which unfortunately weren't that sustainable, right? And we don't have a solution for that unfortunately too. But we at Boba believe that it's time for great games. And great games what have all of them in common? Great UX. They have an amazing gameplay. It's not like you need to wait for some things. It's easy, it makes fun. And you don't play games just to earn money, but because it's fun and to maybe even have some additional benefits like gathering, collecting some NFTs or whatever.
00:01:30.220 - 00:02:49.700, Speaker A: And that's what hybrid compute for. And before I get too deep into the technicalities, I want to give you a little bit of backstory. What's the differentiation between hybrid compute where you can make these off chain calls, and regular Oracles? Because that might be the first thing that you think about when I say you can directly call from your smart contract external API point and do some cool stuff with it. Not sure if everyone here ever used chainlink. Uma, the optimistic Oracle that's also here today, all of them have amazing solutions, don't get me wrong. They have their use case. They do incredible work with requesting data in a decentralized, secure manner, right? But when looking at GameFi, do we always need that async fully decentralized way of collecting data into our smart contract? I'm a smart contract developer myself.
00:02:49.700 - 00:04:37.400, Speaker A: I love decentralization. So why are we talking about centralization now? In the whole blockchain space, we always have that trade off between scalability, security, decentralization. And when we go back one step and think about GameFi, UX is still a great gameplay, still the most important aspect in the whole GameFi space and almost all web3 games incredibly, unfortunately fail at this and we need to change that. So in comparison to all these Oracles that we have now, I said different use case where we need to wait several transactions, minutes, hours or even longer, depending on the sensitivity of the data. There might be the need at some point that you can actually request data on time within the same transaction. Just think about when you play a game, you earn a nice little skin like a cold jacket or anything like that, and you would like to personalize that in some kind of way, right? You want some personal data that you have on your centralized backend, want to have that within your NFT in an autonomous and trustless manner as much as possible. So what you can do now you can have within your smart contract you can call your API endpoint in a synchronous way, get the data and directly work with it.
00:04:37.400 - 00:05:45.850, Speaker A: And that actually gives you a whole new possibility or opportunities to build some great new applications. As said, different use case than Oracle's. And that's what we are going to do today. So basically to give you some understanding how that in channel works right, Boba is, as said, a layer two solution. So what we basically did, we modified layer two Gaff. And when you basically call that smart contract function that triggers that API call, then we intercept that RPC call and replace the original call data with the result of the API call and save both of them to layer one which is in our case, ethereum. And that enables us to do that in the same transaction.
00:05:45.850 - 00:06:56.022, Speaker A: So to give you some understanding let me get that to the other screen to give you some understanding before you get shocked away by code the whole touring landscape which is, I said, the old name for hybrid compute. You will see that now and then on some places because everyone who has ever won a company knows that replacing a name is unfortunately a really difficult task. In general, we have three core components, actually it's four. We have your own smart contract that triggers the API call. Makes sense. Then we have your backhand itself that understands or needs to understand some way that needs to understand what kind of information you are sending from your smart contract to the backend. Because it will be or needs to be API encoded.
00:06:56.022 - 00:07:48.660, Speaker A: It just can't be plain text or something like that. And the same way other way around, if you return data from your backend to the smart contract, it also needs to be in an understandable format. And now we are coming to two other smart contracts that we might need to know or think about. And that's on one hand, the so called Turing Helper or Hybrid Compute helper, as you wish, and the Turing Credit. And both of them have a really close interplay. One of them, the Turing Helper is a smart contract that every project needs to deploy themselves. That contract basically is nothing else than your personal, let's say, key to your backend, let's put it that way.
00:07:48.660 - 00:08:38.402, Speaker A: And the Turing credit contract basically keeps track of your Turing helper, your smart contract. But why am I saying this? As with every Oracle, you need to pay for each transaction. For each API call you need to make a small deposit. In our case, it's a prepay. So you need to prepay your if you basically deploy a project, you need to prepay the amount of Boba tokens that you want to fund in advance. So that your users can actually trigger those smart contract functions. So every time you call your smart contract there will be 0.1
00:08:38.402 - 00:09:25.700, Speaker A: Boba token which is around a few cents currently deducted from your prepaid balance. And the Turing credit contract is deployed by us, the Boba team which keeps track of your balance, basically. And the Turing Helper contract is some kind of authorization, right? So that only your users or the contracts that you want, your custom smart contract, can actually call that endpoint. Otherwise I could just use your endpoint for free and you would pay for it. That's why we have two smart contracts here. But enough theory, sorry for that. I want to show you a little bit.
00:09:25.700 - 00:10:17.298, Speaker A: What you see here is really quite minimalistic example that I want to implement with you today. And what it basically does, it calculates the time delation based on the Special Relativity Theory by Albert Einstein. Sounds complicated. Right now it's just a basic math formula which would be quite hard to calculate in a smart contract, as you can imagine. Right? And that's why I chose that for today. If you want to do that with me, I have prepared a starter repository that I would ask you to clone. Then we could actually do that.
00:10:17.298 - 00:11:37.898, Speaker A: Basically it's on our official organization and it's called Hybrid Compute underscore Tutorial. That default branch is already the one that you can use to implement that with me today. And yeah, basically everything is already set up and we will go through every step that it's actually needed to perform your Turing call. To give you first insights on what we are talking about at all, I want to show you how does such an API call actually look like? The most let me look here. That's a more beautiful example. You can see it here. Basically it's really just a one liner, right? You can actually call your smart contract by calling a method on the so called Turing Helper that Asset your project needs to deploy it themselves.
00:11:37.898 - 00:12:42.080, Speaker A: But you don't need to change a single line there. It's really just fully prepared, already ready to deploy smart contract that you can use. You just needed to actually keep track of your balance to get back to the repository. To give you Asset a little bit of overview, we have said we have a couple of components here, right. We have our own custom smart contract that we will implement today. We have our so called Touring helper ready to deploy, nothing to change, basically copy paste that actually tracks if your smart contract is allowed to call that endpoint to actually be charged for that. So it's a whitelisting and some other error handling stuff and whatever.
00:12:42.080 - 00:13:44.674, Speaker A: But as said, you basically just need to know two core functions that will be useful for you. On one hand you have the so called Turing random function which gives you a super strong soil random number directly from layer two gaff. And we have the so called Turing TX function where you can call any endpoint with any call data you want. That's where you can actually do your off chain calculations or call further API, APIs such as Twitter or whatsoever. And yeah, basically that's the Turing helper. That's our custom contract that we will deploy today. And then you will need your own custom backend that understands the data you're sending to and data that you're returning from.
00:13:44.674 - 00:14:46.630, Speaker A: In our case, we just used AWS lambda function that's already prepared for us. I still uploaded it here so that you can actually have a look at it and understand it. But basically everything that it does is decode the API encoded data and encodes the result as well. So nothing super complicated or magic here. But as said, that's already deployed. So if you have cloned that for yourself, what you can do now is, as always, if we deploy on testnet we will need some kind of testnet tokens, right? Otherwise it's going to be hard to actually deploy anything. We have a nice little faucet for that on our gateway.
00:14:46.630 - 00:16:05.780, Speaker A: You can find it if you type on the Search for Gatewayrinke Boba network. And as you can imagine right now, that's the faucet. Basically this faucet itself actually uses hybrid compute itself. What it does is it asks you to copy your so called boba tag, which is nothing else than the boba prefix with MD five hash of your public key and post that on Twitter, just like I did here. If you have that, just need to copy the link and can put it in. Here what this does now if you click on authenticated faucet it actually requests from the smart contract the Twitter API and checks if you have posted that and then sends you the Boba and Eve. So that's what you would need to follow the workshop today.
00:16:05.780 - 00:17:25.146, Speaker A: So if we go back to our own project now, what I did is to actually give everyone here a little bit of a safe haven. If you code that today, then I want you to be sure that it actually works right for that very same reason, I wrote a simple test that actually checks if you did it right. So nothing to be done here. But basically what this test does is it checks the event that I'm emitting in the smart contract, which we need to do right now. It's undefined, undeclared variable. And yeah, then basically it just checks if the value within the event is the one that we are expecting to. And yeah, small hint not to confuse you too much, but basically, as you might know, solidity smart contracts don't support floating numbers.
00:17:25.146 - 00:18:14.650, Speaker A: And this formula returns actually really small number. That's why I multiply it on the back end, the floating number with 1 trillion. And here I'm just dividing it back to a value that makes sense. So basically what this would do now it calculates how many minutes basically your time is stretched if you almost move at the speed of light we're very close to the speed of light here. That's the velocity parameter. And then we have the proper time, which is the original time that we as a person actually feel like it is. I think everyone here, or most people have seen the movie Interstellar.
00:18:14.650 - 00:19:08.860, Speaker A: Not all of it is science fiction. The part of it where gravity and basically the speed of your aircraft stretches to time is true. So let's get hands on. I have prepared some setters on top here which you don't necessarily need, right? As you know, you can provide everything yourself. But basically every time when we want to use hybrid compute, we need our own custom Turing helper. That's the contract that we need to deploy ourselves. That's the one that we had a look at before run with the error codes and with the Turingtx function, with the Turing random function and so on.
00:19:08.860 - 00:19:50.582, Speaker A: So that's basically just deployed by us. I'm just assuming that for now. And basically what you need to do is provide that address to the contract so that your custom Smart Contract knows where to redirect your call data to. The second would be what's your actual backend? What's your actual backend? API URL. And that can be anything, as you might guess. In our case, it will be AWS lambda instance, which you can use yourself. I already pasted it in the tests.
00:19:50.582 - 00:20:31.160, Speaker A: If you look here, it's on top. It's here that's already live. So basically that's our Python file that we see here. So to actually make that work now we now have or assume that we have our hybrid compute helper. We assume that we know where the information should actually flow to. And now we actually need to do three basic steps, which could be, in theory, a one liner. But I want to make it simple.
00:20:31.160 - 00:21:38.170, Speaker A: So the first thing we would need to do is encode our parameters that we want to send to our back end in a way that the Smart Contract is able to handle. So basically what we need to do is we need to create a bytes value I'm just calling it right now params. And we basically just encode our two parameters that we get from this function proper time. Those are the 15 minutes that we saw before and the speed that we are moving at. So that's the first thing. Basically, we encode the data in an understandable format. So the next thing that we need to do is to actually do our synchronous API request.
00:21:38.170 - 00:22:20.700, Speaker A: So that works in a quite similar way with the Turingtx method that we saw before. What we get from the API itself is, again, a bytes. It's really it needs to be in a format, again, that the Smart Contract understands. So basically we get here our bytes memory. Again, I'm calling it OSB for now. I know that's not best practice. And now our so called hybrid compute helper comes into play.
00:22:20.700 - 00:22:58.630, Speaker A: And we see now that we have our Turing TX and Turing random function that we can use. The Turingtx function, basically. Let me see if we see that even here. Yeah. Requests that we send the URL that's our HC endpoint in this case, which is just a regular string. And our already encoded parameters, the ones above that's. It basically that simple.
00:22:58.630 - 00:23:18.042, Speaker A: Line sensor API. Request to your backend. No callback, nothing else. Super simple. And the next thing, what should I do with bytes? Now? No usage. For that. I want to have some kind of proper value, right? Want to have a number.
00:23:18.042 - 00:24:12.660, Speaker A: I want to have a string whatsoever. Now, it would be great if you know what your back end returns. Otherwise you get some random value out of it. In our case, I know that it's an integer value. So what I'm doing now is I'm defining that the first value of my Tuple is just a number and I decode the rest B value that we just got into Uinto. This place. So that should be it.
00:24:12.660 - 00:24:42.060, Speaker A: That result that we get now we just emit the event so that our test can actually read it and check for the accuracy. That would be the whole magic. This Asset. I hope I didn't confuse you too much. It's always a little bit difficult to go from zero to 100. But basically, this enables you to do a lot of crazy new things. Things that you couldn't do that easily before.
00:24:42.060 - 00:25:03.826, Speaker A: Everything is possible right now. We have oracles. We can do everything. But we all know we all went through Callback Hell in Web Two and it also can exist in Web three. Right? Asset chain link. Uma, all oracles are great. They have the use case.
00:25:03.826 - 00:25:43.940, Speaker A: This is a different one. So now I'm going to do the most risky part of my presentation. I'm trying to run the test. Let me see if everything works. So what these tests now do they basically deploy our Turing helper? Let me show you. They deploy Turing helper here. I said it's just our prepared contract from before.
00:25:43.940 - 00:27:03.740, Speaker A: Our own smart contract where we actually provide the Turing helper address and our backend URL, this case Asset AWS, lambda instance. And what we need to do now is we need to know basically the Turing helper needs to know which smart contract is actually allowed to call my Turing helper my endpoint for which smart contract I'm willing to pay for. Otherwise, I said I could deploy a smart contract and one of you needs to pay for it. Wouldn't be so cool that's this line basically a whitelisting to protect your funds. When we are talking about funds, we also need to basically fund a Turing credit contract which keeps track over your funds by actually knowing your doing helper contract address because your Touring helper triggers that API call. Finally. And that's why the touring credit knows from where the call comes from.
00:27:03.740 - 00:27:40.918, Speaker A: That's what we do here. We basically just add some boba tokens to the Turing credit contract, and the rest is just some basic checking if we get the correct address back and so on. So that's basically it. I am super happy that this works, and I hope you learned something. Maybe you got even some kind of, like, crazy see ideas for the next few days. I don't know. I would love to know them.
00:27:40.918 - 00:27:43.860, Speaker A: And, yeah, if there are any questions, I'm happy to answer.
