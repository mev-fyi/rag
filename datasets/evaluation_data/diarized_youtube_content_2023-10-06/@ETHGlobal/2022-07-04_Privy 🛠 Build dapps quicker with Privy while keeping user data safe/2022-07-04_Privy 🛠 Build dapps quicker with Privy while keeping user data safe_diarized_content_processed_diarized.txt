00:00:06.410 - 00:00:41.094, Speaker A: So hello everybody. We got 30 minutes and we're going to talk a bit about Privy and how you can use Privy to build awesome apps to delight your users and protect them at the same time during this hackathon, which is super cool. So before we start, I'll introduce myself. So who am I? So I like to describe web to me as like the past decade of what I've always been doing, which is a lot of Web Two stuff. I worked at cruise, self driving and Pinterest, social networking and a whole bunch of things. And then six months ago, what happened was my curiosity kind of led me down a Web Three rabbit hole where I decided to build an NFT collection to kind of learn by building. And I took the red pill and I swallowed really, really hard.
00:00:41.094 - 00:01:13.794, Speaker A: And that just led me down a whole rabbit hole where I got really excited about all this tech learning, solidity all the info that was missing and that was there, all the potential. And so what that has led to is a career change. And now I'm kind of a builder at Privy, which I'm going to talk to you about today. I'm the creator of the Blockchain Smokers. So this right here is Blockchain Smoker 1921 of my collection, and I'm a big privacy tooling advocate. And so I'm here today to talk to you about Privy and what it can do to help you with your privacy infrastructure needs. So how are we going to structure this? We're going to talk a little bit about a problem that I like to call the user data problem.
00:01:13.794 - 00:02:00.798, Speaker A: After that, we'll talk about how Privy is a solution to this problem. Privy fixes this. And finally we'll get into the fun stuff with a live demo. So what do I mean by the user data problem? So if you've either developed or even been a user in Web Three, you've probably seen and been confused by this screen. And this screen, like many others, is kind of like displaying the underlying issue that sessions are really hard and having a session that kind of propagates between experiences is a very challenging problem to the point where even great companies like MetaMask do a poor job. Now, in addition to this, we have another problem in Web Three, which is kind of shocking. And there's a tweet here from earlier this year which is kind of funny and sad at the same time where Maker Dow kind of couldn't reach out to some guy because they only had the wallet address on their lists.
00:02:00.798 - 00:02:27.286, Speaker A: And if they couldn't reach out to him within an amount of time, they were going to have to dump 600 million worth of ETH. Now this is crazy. And this is because notifying off chain is kind of unsolved, which is wild. Like Web Three has a lot to do still. That's crazy. Let's talk a bit about a positive example so here we have the openc profile page and you'll find profile pages like this on a lot of web3 DApps. And what do you see here? You see some information about the user.
00:02:27.286 - 00:03:06.834, Speaker A: Some of it is public like the username and the bio, but then other stuff like the email, maybe in this case there's none, but there could be like other kind of KYC data and you want to handle those, you want to have those. So you can create personalized experiences like users come back to your app if it has a delightful experience. And you can only really do that if you personalize. And you can only really personalize if you have this kind of personal information. So delightful and rich experiences require personalization. For that we need two things. At the very core you need more, but at the very core you need user sessions for like in between session state and you need user tables to persist that state and to persist user information between sessions.
00:03:06.834 - 00:03:44.802, Speaker A: Okay, so we want to save user data. What do we do? That's hard? And there's a debate about this right now, you may have heard this debate, the on chain versus on chain problem. I think Vitalik was on a podcast recently, literally debating this like two weeks ago and just it's not clear where the limit should be. But I think it's very clear that there should be a limit and some data should never be on chain. And the example I like to give is like your Social Security number. You probably don't want that to be on chain ever, right? And so if some stuff is on chain and some stuff is off chain, then we need to bridge that. And so let's say your ledger and you're keeping user data, like name, postal address, all these things off chain, well guess what, you can do it wrong.
00:03:44.802 - 00:04:22.858, Speaker A: It's actually very hard to get right. And so ledger had a, they got porn basically where they were doing great on their security for their hardware wallets, but they were doing a lot less great on their postgres DB that had PII data in plain text that got hacked. And this shows that when you do decide to kind of take user data off chain, doing it right is really risky. Okay, if you are going to do it, there's an old famous adage that says don't roll your encrypto. Now there's a reason for this. It's really hard. There's many mistakes you can fall into which are typically terrible for you, like timing attacks and brute force attacks and weak randomness attacks, architecture flaws, which is a really big one, ingestion attacks.
00:04:22.858 - 00:04:49.106, Speaker A: And I could go on. Now you can build your own crypto, but if you are going to do it, you have to do it right. And doing it right taints an insane amount of time and energy and expertise. Now you could choose to do this, but typically when you're building a DAP, that's not what you want to spend your time and expertise, and that's why you kind of shouldn't. So we have a problem here, right? Great products require personalization and PII, but collecting that is risky. And if you do collect it, it's hard. Privacy matters.
00:04:49.106 - 00:05:13.866, Speaker A: This is a big one, and I really like this one. One of the reasons why I kind of pivoted my career to Web Three is that I think the Web Two got something really, really wrong, and it's privacy. And a lot of these business models are kind of built around an asymmetrical kind of knowledge of the users. And in Web Three, we have a crazy good opportunity to redefine how we do privacy and how we do interoperability of privacy. And that's really cool. And finally, we need a bridge for off chain data, as we discussed.
00:05:13.978 - 00:05:14.254, Speaker B: Cool.
00:05:14.292 - 00:05:28.550, Speaker A: So we have an issue, and this is where Privy comes in. And I'm going to talk about it in a second, but you can find our homepage at Privy IO, and I'm going to talk now about kind of what it is and what we do. And you can follow along with Blobby, who's our mascot on the second one. Cute little ghost.
00:05:28.890 - 00:05:29.302, Speaker B: Cool.
00:05:29.356 - 00:05:49.930, Speaker A: So what is privy now? At its core, our mission is very simple. We want to allow you to associate user data to wallets privately. So bridging on and off chain data. Now, at a very high level, the most core kind of thing we use in our JS libraries. Oh, actually, I'll get to that in a second. So, first of all, in a few bullets, what do we do? We have APIs. They're very simple.
00:05:49.930 - 00:06:24.082, Speaker A: We have JavaScript libraries, and these help you manage your off chain data. We have end to end encryption user storage. So how does that work? That means that on the client, everything gets encrypted and then gets sent over the wire as ciphertext, and then you get it back as ciphertext, and you're going to decrypt it on the client. And I'll go deeper into this. But basically what it means is you have end to end encryption storage, which is the right way to do kind of privacy. And we also have sign in with Ethereum Session management, which kind of solves those two issues I was talking about, of data persistence and session management. We also have transparent cryptography we're building in public, and our crypto libraries are all open source.
00:06:24.082 - 00:06:33.850, Speaker A: And Privy can never see your data in plain text. The way we architected this is like we never see it. And finally, Privy is ready to use right now, and honestly, it's going to make you kind of develop on steroids.
00:06:34.270 - 00:06:34.730, Speaker B: Cool.
00:06:34.800 - 00:06:59.966, Speaker A: So at a very high level, what does our architecture look like at a high level? So at the bottom there, you have the browser. That's where you, the developer is building a DAP, and that's where your stuff lives. And maybe you have some on chain components which are on the right. And then you kind of want to link your user, which is in this case represented by the encryption keys and the little MetaMask logo. You kind of want to link that and associate some off chain user data with it. And that's where Privy comes in. And you can see that from the browser.
00:06:59.966 - 00:07:20.054, Speaker A: You can interact directly with our permissions engine, which we'll get into and our data store to store and retrieve this user data. So how do you do that? What does it actually look like? If you're going to remember one thing from this talk, remember this slide. This is like the thing that's super powerful that Privy does. It has two calls. Privy put and privy get.
00:07:20.172 - 00:07:20.454, Speaker C: Right?
00:07:20.492 - 00:07:58.434, Speaker A: So in this example, I have a user ID, which is ox eight, seven, two, and I'm not going to read it all. And in the first four lines, I'm saving two fields, email and age, and I'm saving them to the descripted data store. And then on the second, I'm just retrieving them. Now this looks really basic, but actually there's a lot of stuff that goes into this. So for this put call, what's going on is, like, on the front end. Privy is first checking with our permissions engine, that whoever is authenticated with the session, whether it be the user or the developer, like your app or a public kind of authentication. Like if they have access to this field, write or read access, depending on if they do, we kind of encrypt it all on the client and then send the ciphertext up.
00:07:58.434 - 00:08:23.574, Speaker A: And then for Privy Get, you're doing the same thing. You're kind of checking with the permissions engine if the person that's requiring these fields is allowed to see them. And if they are, then you're retrieving that as ciphertext and decrypting everything on the client. So this is ridiculous. Like, you're doing so much in so few characters with Put and Get, you're kind of doing user data, kind of encrypted storage in the best manner possible. This is awesome. So that's the storage.
00:08:23.574 - 00:08:48.978, Speaker A: And the other critical part is sessions, which I mentioned earlier. So how the sessions look like. So what we built and this is because after building a few apps, we realized that session management is something that is like a key pain. We built like a wrapper that makes it really easy to kind of manage user sessions. So this uses in browser providers like MetaMask or Coinbase Wallet. And so in this slide, it's kind of showing you the API of our CWI session. CWI stands for Sign in with Ethereum, which is an EAP standard.
00:08:48.978 - 00:09:11.722, Speaker A: And so you're initializing the session here and then you're just authenticating the user that's going to call up, like the MetaMask notification. They're going to sign a message, you're going to know it's there. And then basically under the hood, we're saving things to local storage. And we're persisting that in between your views. And then you can also create a client with that session and then you know who's authenticated it's? The user that signed that message. Right. So when you decide to retrieve fields later, you know that who it is.
00:09:11.722 - 00:09:20.814, Speaker A: And so if they're fields that only the user can see, they can see them. And so in this last line I'm doing that, I'm getting the email, and maybe in this case, only the user can view their own email.
00:09:21.012 - 00:09:21.566, Speaker B: Cool.
00:09:21.668 - 00:09:39.342, Speaker A: So that's storage and sessions done. So let's recap real quick. With Privy, you can kind of get back to building products really quickly and you can do it right. And doing it right used to be really hard. You no longer have to have this trade off. We think that's really exciting. You can store encrypted user data, you can use signing with Ethereum sessions.
00:09:39.342 - 00:09:55.560, Speaker A: And by the way, everything I just showed you, you don't even need a backend. This is why. This is a very hackathon friendly project. You could just do this in 2 seconds with only a front end. So we do have a console which you'll need if you don't have a backend to kind of admin your fields and your permissions. And I'll get into this, we'll see how it works in the demo.
00:09:56.330 - 00:09:56.838, Speaker B: Cool.
00:09:56.924 - 00:10:22.978, Speaker A: So we talked about the privacy problem, we talked about the Privy solution, and now I have time to do a live demo with Privy Flush. Now I hope the Wi Fi is going to be stable because it was a bit flaky earlier. Now, before we get into the demo, I want to do a very quick primer on permissions. But if you're a developer, this is probably sounding very familiar. Most things are defined by who can read them and who can write them. This is true of like Unix files all the way to In Privy, the fields. So in Privy, each field has read and write permissions associated with it.
00:10:22.978 - 00:10:48.554, Speaker A: And who are the roles? Like, who essentially can read and write. And there are three in Privy. There's self, and that's the authenticated user think the user that kind of signed the message with the MetaMask wallet. There's admin that's you the developer. That's kind of passing in the secret and public API keys that you got from us. And then there's public. And so you can imagine any kind of combination of these, exactly like you Schmod kind of like files on Unix to see who can read and write them.
00:10:48.752 - 00:10:49.354, Speaker B: Cool.
00:10:49.472 - 00:11:14.446, Speaker A: So I'm going to show you a demo and then we'll dive into the code on how it's working. So the demo is this fun little app called Privy Flush, which is kind of like encrypted dropbox where you can send encrypted files to an Ethereum address. So like everybody has an inbox by default. And you could send a file to someone so you can maybe use this to send a love letter that was very secret or maybe you were a bit more serious and wants to send like, KYC data, like someone's passport photo or driving license.
00:11:14.638 - 00:11:15.426, Speaker B: Cool.
00:11:15.608 - 00:11:35.338, Speaker A: So I'm going to switch to the browser now. So here we go. This is privy flush. Please appreciate my design skills. So here what's going to happen, is that we're not logged in, so I can't do anything yet. But I'm going to sign in with Ethereum. And to make things more clear for you guys, I have two kind of addresses I'm using here, like my primary and my secondary on my MetaMask, and I put them here.
00:11:35.338 - 00:11:40.810, Speaker A: Like, my primary is one D, four A, and my secondary is Ox eight eight five.
00:11:40.960 - 00:11:41.274, Speaker B: Cool.
00:11:41.312 - 00:12:04.430, Speaker A: So I'm going to sign in with my primary. Here we go. So I'm signing in with Ethereum, and this is the sign in with Ethereum Standard, by the way, which is an EAP that's super simple. And it's just like, it's normalizing and standardizing what this string looks like so that we get metadata that is machine Passable. So we're signing this, and now the app knows that I'm signed in as this MetaMask account, which for me is called Pushix.
00:12:04.590 - 00:12:04.914, Speaker B: Cool.
00:12:04.952 - 00:12:25.498, Speaker A: So my inbox is empty, and I'm signed in as one Ox, one DA, four. So it's this guy, right? And I'm going to send a file, and for now, I'm going to send a file for myself. And so this is the file. It's this driving license that I photoshopped. I'm a developer, not a designer, so please forgive me. And so I'm going to send it to myself. So I'm just going to copy the address from here, and I'm going to.
00:12:25.504 - 00:12:27.834, Speaker C: Put it in the wallet address and send.
00:12:27.952 - 00:12:42.640, Speaker A: And it is flushing. Okay, so hopefully it worked. And now I'm going to refresh the page. And you got mail. Look at that. And so now I can download and indeed I can see this. So I just want to go over what happened here.
00:12:42.640 - 00:13:03.142, Speaker A: I encrypted a file all on the client. Then I saved, like, the encrypted ciphertext somewhere, and then I could retrieve it at a later time. But when I retrieved it, when I hit download on the client, we just downloaded the ciphertext and the Privy client was decrypting it. So that's super cool. We just implemented, like, Dropbox with encryption out of nowhere. And I'll show you how quick it was. It's kind of crazy.
00:13:03.142 - 00:13:14.858, Speaker A: Now, there's a problem here, though. I can't send files to other addresses. So we'll try. I'll show you that it fails. So I'm going to try and send like, the same oops, I don't know what I picked there.
00:13:14.944 - 00:13:20.762, Speaker C: I'm going to refresh. Something terrible has happened.
00:13:20.816 - 00:13:21.660, Speaker A: 1 second.
00:13:23.390 - 00:13:29.440, Speaker C: Maybe the windows open behind her. I think you may be onto something. No, that's not it.
00:13:33.410 - 00:13:37.330, Speaker A: Let me try hard. Quitting. I'm going to restart the server.
00:13:37.830 - 00:13:46.760, Speaker C: This is what live demos are. And this is what we're here for. Okay, restarting the server, see if that refreshes things. Localhost 3000.
00:13:49.210 - 00:13:50.214, Speaker A: Here we go.
00:13:50.332 - 00:13:51.880, Speaker C: I'm still logged in.
00:13:54.330 - 00:14:05.500, Speaker A: Here we go. Yay. Okay, so I'm going to try and send it. And we said I'm going to try and send it to the second address, who is not me. Right? I'm logged in as ox one DA. I'm sending it to ox eight eight five. And so when I do this.
00:14:09.310 - 00:14:10.106, Speaker C: I'm here.
00:14:10.208 - 00:14:35.826, Speaker A: When I do this, I'm going to get an error. The error is not permitted to perform this operation on the field. Cool, so why is that? That's actually super simple. If we go to the console, so we see the field here, by the way, it's inbox. That's the inbox for the user, the permissions is self. And so that means that I can read and I can write only me self being the authenticated user. So what I need to do is change this and I'm going to change it to we need a special access group, actually.
00:14:35.826 - 00:14:53.274, Speaker A: So let's create that. We're going to do one where anybody can write to me and only I can read. So I'm going to create an access group. I'm going to call it public write, self read. And I'm going to say only I can read and anybody can write. So anybody can write me like a love message. So I'm saving this.
00:14:53.274 - 00:15:02.490, Speaker A: And now I'm going to say for my field, for my inbox field, I'm going to edit it and I'm going to say the default permissions are public Write self read.
00:15:02.560 - 00:15:02.746, Speaker B: Cool.
00:15:02.768 - 00:15:21.890, Speaker A: So now anybody can write me. So we've saved it. Now let's go back to our app here and I'm going to refresh and I'm going to basically try this again. Board, try a different file. This is another NFT. So I'm going to send this and we're going to send it to the eight eight five and it's going to flush.
00:15:23.270 - 00:15:23.778, Speaker B: Cool.
00:15:23.864 - 00:15:31.000, Speaker A: And now I won't see it here, right? So what I need to do is sign out and then sign in with the other address and we'll go and see if we got it back.
00:15:32.170 - 00:15:51.242, Speaker C: Signing in with Ethereum not connected. This should work. Come on. Okay, 1 second.
00:15:51.296 - 00:15:56.720, Speaker A: I'm going to see if maybe it's because I'm sessions are hard. This is what I was telling you. So maybe if I disconnect this.
00:15:58.850 - 00:16:02.798, Speaker C: And I switch to this and I kind of refresh now I sign in. There we go.
00:16:02.884 - 00:16:06.720, Speaker A: Sessions are hard. So I'm logging in as the second address.
00:16:08.290 - 00:16:16.560, Speaker C: There we go. It had the queued things and we should have the file, which we don't. So something went wrong.
00:16:17.330 - 00:16:23.462, Speaker A: Okay, I'm not going to live debug. We should see it here. And I probably made a mistake copy pasting the address. I apologize about that.
00:16:23.596 - 00:16:24.134, Speaker B: Cool.
00:16:24.252 - 00:16:47.786, Speaker A: So the demo is done. I want to kind of, kind of show what it would look like if we wanted to add a field. So let's jump into the code real quick. So this is by the way, there's a lot of boilerplate code here, but it's just like a Create Next app. So if you're familiar with JavaScript and Next, this is like pretty straightforward. So I'm going to go to the pages and there's the main page, which is index, and that's where most of the code that we're doing lives. So here we're using Session, which is using our sign in with Ethereum sessions that I talked about earlier.
00:16:47.786 - 00:17:20.450, Speaker A: It's using a react hook to kind of persist it through our pages. But what we care about and I'm going to look for it, is Privy session privy, which is where all the Privy interactions are happening. So we can see there's really two places where this is in action. And it's like on page load. We're loading the inbox by doing a Session Privy Get file, and we're saying for the logged in address, get the inbox field. And then the second one is on the send, which is the hook of when you post a form. It's saying Put file, and you're giving it to the destination address and you're posting it to the field inbox and you're pasting the file.
00:17:20.450 - 00:17:35.310, Speaker A: So real quick, what would it look like to kind of add a message? Let's say we wanted to build over the hackathon, I don't know, encrypted messaging. You could do this with Privy really easily. Now I'm going to just create a new field here. I'm going to call it Message. I'm going to do the same public read, self read, kind of permissions.
00:17:35.730 - 00:17:36.286, Speaker B: Cool.
00:17:36.388 - 00:17:48.398, Speaker A: And then in my app, I'm going to create a new constant. This is like a react hook. So I'm going to call it Message and a hook to call it Set Message. And this is Oops.
00:17:48.494 - 00:17:50.180, Speaker C: And this is use state.
00:17:51.350 - 00:18:02.114, Speaker A: It's a string and we default it to the empty string. Cool, thank you very much. I forgot the closing bracket. The computer is like this and it's just breaking my wrists.
00:18:02.242 - 00:18:02.630, Speaker B: Cool.
00:18:02.700 - 00:18:07.334, Speaker A: So then we're going to get it here, const Message. And we're going to do the same.
00:18:07.372 - 00:18:09.862, Speaker C: Thing, session Privy Get.
00:18:09.916 - 00:18:25.360, Speaker A: Remember that. And we're calling the Session address that's for the Oops, for the logged in user. And the field was called Message. Cool, so we're getting it. And then if it exists because it could be null, let's set it set.
00:18:29.170 - 00:18:29.920, Speaker C: Message.
00:18:31.730 - 00:18:32.910, Speaker A: Ulala.
00:18:33.490 - 00:18:35.598, Speaker C: Okay, message.
00:18:35.684 - 00:18:36.814, Speaker A: Here we go.
00:18:37.012 - 00:18:39.934, Speaker C: Text. So this is like a Privy client thing.
00:18:40.052 - 00:18:40.334, Speaker B: Cool.
00:18:40.372 - 00:19:01.850, Speaker A: So if we get it, we're setting it to the variable message. So now we have kind of the message in our handler memory in the thing message. We need to go and display it. So let's go display it beneath You Got Mail. So this is where you got Mail is. So if you do, I'm going to kind of add a div that just shows the message. And I guess we could show this only if the message exists, which in.
00:19:01.920 - 00:19:05.980, Speaker C: React you do like this. There we go.
00:19:07.550 - 00:19:08.202, Speaker B: Cool.
00:19:08.336 - 00:19:20.058, Speaker A: So what I forgot to do is that when I'm sending it, we need to set something to the message. So for now, let's go write hello world. So I'm going to do an away session.
00:19:20.154 - 00:19:21.054, Speaker C: Privy Put.
00:19:21.092 - 00:19:36.500, Speaker A: This time it's just put destination, address. The field is message. And let's just say whatever you guys want ethnyc hello world. And you could obviously make this more dynamic, but I'm keeping it simple for now.
00:19:38.390 - 00:19:38.946, Speaker B: Cool.
00:19:39.048 - 00:19:57.260, Speaker A: So now we're saving it when we upload the form and we're hard coding it to this message, and then we're going to get it. So let's go try it out. So we'll go back to Privy flush. So now I'm going to send a file to myself. So I'm logged in as OXA 85. So I'll make sure to send it to that. So I'll send this lover boy and I'll send it to myself.
00:19:59.310 - 00:20:00.460, Speaker C: Here we go.
00:20:03.680 - 00:20:04.940, Speaker A: It's flushing.
00:20:07.440 - 00:20:07.996, Speaker B: Cool.
00:20:08.098 - 00:20:14.016, Speaker C: I'm going to refresh. Something's not going right and I don't know what it is.
00:20:14.038 - 00:20:14.624, Speaker A: Oh, there it is.
00:20:14.662 - 00:20:19.410, Speaker C: It was just slow. You got mail. And why don't we see the message?
00:20:22.820 - 00:20:38.148, Speaker A: Let's go see. In the console, we can actually view data. And so for the user ox eight eight five, there is a message. I can't see it. By the way, this is cool. So because only the user self can see it, like me, as the admin can't see it. And so here it's not there, but there is a field and it's there somewhere.
00:20:38.148 - 00:20:40.890, Speaker A: So I wonder why it's not seeing it.
00:20:42.060 - 00:20:48.910, Speaker C: I promised this was working earlier. Message text sessionprefy get.
00:20:54.510 - 00:20:56.122, Speaker A: Okay, I'm not going to debug this live.
00:20:56.176 - 00:21:03.646, Speaker C: I'm just going to do one last thing. Message. And it was called message. Yeah, this should work. I can't think about why it's not.
00:21:03.828 - 00:21:13.038, Speaker A: Okay, one last time. Okay, I will debug this and send it in our discord later. I'm sorry about that.
00:21:13.124 - 00:21:13.518, Speaker B: Cool.
00:21:13.604 - 00:21:37.062, Speaker A: I'll go back to the demo because we have only a few minutes left. So I just want to kind of emphasize it's broken at the end here, but I promise it works. I want to emphasize how easy it is to build really powerful kind of things with Privy. And so the demo I gave you is like encrypted files or like sending encrypted messages, but you can actually go and see at demos. Privy IO. We have a few others. We have like a PII demo.
00:21:37.062 - 00:21:56.190, Speaker A: Let's say you're like an NFT marketplace or someone who has to do KYC requirements. You could collect them here. You could go see that we have a send demo that shows how to collect email addresses to then notify your users. And we have a quick start to get going. And all of this is open source, by the way. You can go find all our stuff at GitHub. Privy IO.
00:21:57.170 - 00:21:57.726, Speaker B: Cool.
00:21:57.828 - 00:22:23.910, Speaker A: So let's go back to our presentation. So for this hackathon, you can kind of find us at Privy IO. You can make an account right now at Console Privy IO, and our documentation is at docs privy IO. We have a discord, and we have prizes. So if you build anything with Privy kind of, we're going to consider you for this prize. You should go ahead. And so our three categories are best data driven, UX, most Interesting Data Stored, and most creative.
00:22:24.250 - 00:22:24.710, Speaker B: Cool.
00:22:24.780 - 00:23:04.986, Speaker A: So I have a few minutes left. I will take your questions. How does it work? Okay, so I wish I had the architecture diagram. I'm going to kind of talk you through it then. So the way it works is we use okay, I don't want to get this wrong live, because the cryptographers have a whole thing here, but we use a hardware security module, which is like, a dedicated hardware whose job it is to only kind of handle private keys and sign things. And for each customer, they have, like, a root key that's in that module. And then we use that to sign derived keys for each field.
00:23:04.986 - 00:23:49.634, Speaker A: And so when you kind of request a field both to save or to put you first go through our permissions engine, we know kind of who you are, and we can say this person can or cannot see the field. And if you can, then we go and fetch the root key. We ask it to create a public, private, symmetrical key pair, and we sign the field with that. And that's how you do it on the front and back end. Now, we can get into much more detail here, and this is public, and we want it to be publicly auditable. So come see me after, and I can kind of redirect you to the cryptography people at my company because it's not my specialty, and I don't want to misstep. That's a great question right now there's.
00:23:49.634 - 00:24:40.682, Speaker A: I mean, so I don't want to talk too much about pricing, but right now, you can send pretty much anything because we have free tiers, and in the first month, it's fine. Down the line, there'll be pricing per user, and so you'll kind of pay for usage there. Yeah, great question. So the question is, is it only about encryption, or does it also have, like, storage plugins, like, IPFS? So that's a really good question. So right now, the way we architected it, we can kind of swap out the storage component. So right now, it's kind of owned by us and our cloud storage. But down the line, we absolutely have plans so that you can kind of swap it out to either on Prem or IPFS Airwave or whatever you want.
00:24:40.682 - 00:24:49.254, Speaker A: Like, the storage is completely decoupled, right? Like, there's the permissions engine that checks the permissions, and then there's, like, the encryption that happens on the client, and then you're sending ciphertext.
00:24:49.302 - 00:24:49.418, Speaker C: So.
00:24:49.424 - 00:24:53.660, Speaker A: You could really store it anywhere. And so that's something we plan to kind of open up later.
00:25:02.120 - 00:25:02.532, Speaker B: Cool.
00:25:02.586 - 00:25:02.930, Speaker A: Thank you.
