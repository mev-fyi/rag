00:00:14.510 - 00:00:23.194, Speaker A: So is there any room that there's Ethernet in that I can now in the front desk, I'm trying to watch.
00:00:23.232 - 00:00:24.090, Speaker B: The streams.
00:00:25.850 - 00:00:27.094, Speaker A: Or even in that room.
00:00:27.132 - 00:00:30.280, Speaker C: That you guys are in. We can hook you up.
00:00:34.270 - 00:00:39.228, Speaker A: Even the AV Hoca fighter.
00:00:39.324 - 00:00:40.880, Speaker B: Yeah, I'm good.
00:00:40.950 - 00:00:41.520, Speaker D: Probably.
00:00:41.670 - 00:00:43.440, Speaker C: You know that area in the theater?
00:00:47.700 - 00:00:48.464, Speaker A: This one's not working.
00:00:48.502 - 00:01:04.560, Speaker C: Still system that were my adapter. I haven't checked here. Okay. Yeah, there was one on here. Okay.
00:01:14.690 - 00:01:16.110, Speaker A: Maybe it's my dapper.
00:01:25.240 - 00:01:25.990, Speaker C: Yeah.
00:01:30.200 - 00:01:32.232, Speaker A: Like were you in Tokyo?
00:01:32.296 - 00:01:38.098, Speaker C: I wasn't in Tokyo, unfortunately, though, I.
00:01:38.104 - 00:01:42.018, Speaker A: Was like, having calls with Tokyo for like, two months. We need everything.
00:01:42.104 - 00:01:45.506, Speaker C: Detailed system diagrams of every cable and.
00:01:45.528 - 00:01:47.250, Speaker A: I got there and everything set up.
00:01:47.400 - 00:01:48.360, Speaker C: That's amazing.
00:01:49.050 - 00:01:51.286, Speaker A: It was really a testament to how.
00:01:51.308 - 00:02:02.766, Speaker C: People speak about do you guys have like, an in house networking team or that you work with people at different for Wi Fi.
00:02:02.798 - 00:02:15.984, Speaker A: We have someone that connects with us. He's not part of the team, but he contracted her to come out for a little bit. So he was in Lisbon as well. For AV, it's just like me, but I kind of like, I'm bringing in.
00:02:16.022 - 00:02:16.610, Speaker C: Tech.
00:02:22.310 - 00:02:23.620, Speaker A: Find everything before.
00:02:25.750 - 00:02:32.786, Speaker C: It's super impressive. The amount of logistics. I'm sure I only know the half of it.
00:02:32.968 - 00:02:38.170, Speaker A: Yeah, like, that wouldn't be an issue.
00:02:38.240 - 00:02:42.700, Speaker C: Yeah, I don't think I've ever been to any global of that where I was like, wow, that really sucked. Every single one.
00:02:51.070 - 00:02:52.540, Speaker A: Everything that went wrong.
00:02:55.870 - 00:03:54.490, Speaker C: Yeah, exactly. It's like, oh, yeah. Extra hour to work on the project. It oh, wait, I have one.
00:03:58.890 - 00:04:01.000, Speaker B: Through this. All right.
00:04:01.690 - 00:04:02.822, Speaker A: I have more somewhere else.
00:04:02.876 - 00:04:12.930, Speaker C: Yeah, work technically.
00:04:25.070 - 00:04:26.410, Speaker A: Turn off the WiFi.
00:04:27.330 - 00:05:16.610, Speaker C: Usually it prompts me. It's like, do you want to let this USB device connect? Try? Yeah, but I can't. This one I actually don't have definitely the connection here. This one again. I thought I had Ethernet before when I was trying it. I might have just been having good luck with the WiFi. You can always log in from my laptop if you want to start.
00:05:16.610 - 00:05:53.570, Speaker C: Perfect. Oh, nice. Yeah, I was going to do live demos too. Okay. Self assigned IP. There we go. So I've got a self assigned IP, which I think means I can't check, I can try manually doing a DHCP thing.
00:05:53.570 - 00:06:16.230, Speaker C: Trying to trying to trigger yeah, I do have a Hub on me too. I know it's going to kill this network, but I can do it via hub.
00:06:17.450 - 00:06:18.520, Speaker E: Sounds good.
00:06:19.610 - 00:07:16.270, Speaker C: You didn't hear from me. The guy's going to track me down. Yeah, yeah, it's got a little attached. So small. All right. Oh, I've got I've got WiFi from somewhere. Yeah.
00:07:20.210 - 00:07:24.840, Speaker A: Assess over this. So this sounds good. Now testing, test thing.
00:07:38.930 - 00:07:39.614, Speaker C: Sounds good.
00:07:39.652 - 00:07:42.050, Speaker A: Now testing, testing.
00:07:49.730 - 00:07:57.690, Speaker C: Sounds good. Yeah, either way. Yeah.
00:07:59.100 - 00:08:00.570, Speaker A: Let me know if it's in the back.
00:08:14.540 - 00:08:25.860, Speaker C: 21 seven. Okay. I get an IP.
00:08:30.380 - 00:08:31.300, Speaker A: Adapter.
00:08:31.460 - 00:08:32.472, Speaker C: Just so you see here.
00:08:32.526 - 00:08:33.850, Speaker E: I get a 100.
00:08:34.700 - 00:08:36.200, Speaker C: Can I steal that? IP.
00:08:36.880 - 00:08:37.784, Speaker E: It's DHCP.
00:08:37.832 - 00:08:53.782, Speaker C: I can give you this. I can assign you one. Yeah, because I think I can I can manually do 10200. I know why that's assigning a 248. No, that's right.
00:08:53.836 - 00:08:54.514, Speaker D: That's 16.
00:08:54.562 - 00:09:11.654, Speaker C: Okay. Yeah. We're good. Yeah. So we're going to self assigned IP DSCP with manual address.
00:09:11.692 - 00:09:13.990, Speaker E: No, just use a static address manually.
00:09:14.490 - 00:09:51.990, Speaker C: Ten dot, 20 dot, zero dot, 102 525248 wait, 2525-2480. Yeah. Router is 10200 one. Did it give you DNS or DNS? Looks like it says connected. Nice.
00:09:52.440 - 00:09:53.060, Speaker B: We're good?
00:09:53.130 - 00:10:19.280, Speaker C: Yeah, perfect. I don't know what yeah, I think I'm using let me just double check. I think I've got it. Looks like it's a sign of me. Assign me a DNS server. I'd put one in in case double check works. Just be it doesn't work.
00:10:19.280 - 00:10:41.324, Speaker C: No, I've worked it. I wonder if you weren't connected somehow. No.
00:10:41.362 - 00:10:42.430, Speaker D: IPV six.
00:10:49.950 - 00:10:54.940, Speaker C: Do a terminal real quick and ping 10200 one.
00:10:58.430 - 00:10:59.180, Speaker D: Something.
00:11:00.430 - 00:11:08.240, Speaker C: Check one more time. I want to make sure 100%. I got an IP here. Sounds good. The WiFi was doing okay for me. Okay. It should be doing better now.
00:11:08.240 - 00:11:31.740, Speaker C: Oh, perfect. Yeah. Okay, perfect. All right, are you actually ready? Yeah. I think I'll run with the APL. Plug this in just in case. This is me on getting into HTP right now.
00:11:31.740 - 00:11:36.450, Speaker C: Probably just a dongle thing, not a big deal. Cool.
00:11:36.520 - 00:11:37.300, Speaker E: All right.
00:12:29.020 - 00:13:07.172, Speaker C: Yeah, wi fi is good. I'll do it by WiFi, figure out all this stuff. Why there T shirt. Okay.
00:13:07.306 - 00:13:08.564, Speaker F: Is it all good?
00:13:08.762 - 00:13:19.864, Speaker C: Yeah, you're good. Let me see. Plug it in via HDMI. It's going to work perfect. Okay.
00:13:19.902 - 00:13:20.600, Speaker F: You guys are perfect.
00:13:20.670 - 00:13:42.136, Speaker C: Amazing. Awesome. Well, thank you all for coming. This is a talk on building with ERC six, five, one. It's going to be a little bit technically in depth. We're going to chat a little bit about what ERC Six Five One is, what you can do with it, and then we're going to kind of get hands on into how you can use it in your hackathon projects this week. Obligatory intros.
00:13:42.136 - 00:14:34.216, Speaker C: I'm Jaden, I'm one of the developers at Future Primitive, which is a Web three venture studio. If you want to ping me this weekend for questions about ERC Six Five One that's my Twitter DMs are open, feel free to ask. Would love to help support anyone who's building ERC. Six, five, one. Related things. Yeah, we're Future Primitives, we build all sorts of crazy experiments with tokens. So we've done a lot of experimental NFT projects and ERC Six Five One is a proposal that we proposed based on a lot of the work that we've been doing on trying to push the bounds of what can you do with NFTs? How can you give NFTs abilities beyond just being an asset that's stored in your account and let them do things? So we've been doing a lot of crazy experiments with that and ERC 66551 introduces a new concept called a token bound account, ERC, six five one gives every single NFT that's ever existed or ever will exist its own wallet.
00:14:34.216 - 00:15:02.868, Speaker C: Your NFT has its own unique wallet address and that means it can own other NFTs. It can own ETH, it can own ERC, 20s. Your NFT can now own things natively because it has its own wallet address. It also means that you can use your NFT to interact with applications. Because your NFT has a wallet, your NFT can now do anything on chain that a wallet can do. So you could connect to OpenSea and trade NFTs as your NFT. Your NFT would own other NFTs that it buys and sells and trades on OpenSea.
00:15:02.868 - 00:15:29.596, Speaker C: Or you could trade beam coins or you can vote on proposals. Anything you can imagine doing with a wallet, your NFTs can now do too. And this works with everything. Like these addresses you can see on my screen are real token bound account addresses for real NFTs. And I'll show you that real quick. So one thing if you want to start playing around with ERC, six five one, that's really easy to do is if you want to see the token bound account address for an existing NFT, it's really easy. So this is the Genesis CryptoKitty.
00:15:29.596 - 00:15:58.920, Speaker C: This launched at ETH Waterloo six years ago, was when CryptoKitties launched. That's one of the first NFT projects. So this is a really old NFT. Nobody's touched this NFT contract in ages. But this NFT has a token bound account via, ERC, six five one. And an easy way to find that is to just replace Openc with tokenbound.org for any NFT, any, ERC, 721 NFT and you'll find whoops I got to deal with viewport sizes or something.
00:15:58.920 - 00:16:18.960, Speaker C: Here we go. There we go. This is the NFT's wallet address. This is a unique wallet associated only with this NFT. And this wallet can only be used by the owner of the Genesis CryptoKitty. You can think of it like a token gated nosa safe. Wherever the NFT goes, ownership of the wallet goes can.
00:16:18.960 - 00:16:47.764, Speaker C: This NFT owns this NFT via a tokenbound account. And so for any NFT you want to see the tokenbound account of, you can just replace OpenSea with tokenbound.org and you'll find it. So, yeah, every NFT from CryptoKitties onwards to the project you launched this weekend, it comes with a wallet. That means you can make assumptions that NFTs can own things and NFTs can do things, which is some really powerful things you can do in projects you're building. NFTs also have their own transaction history, which is kind of cool. You can see all the actions that NFT has done on ether scan.
00:16:47.764 - 00:17:32.196, Speaker C: So here's how it works. So, ERC, six five one proposes a couple of new smart contract it proposes a new smart contract and a new account interface inside the EIP. So what you're seeing here, it's kind of like it'll expand as we go through it. But you're used to NFTs existing on chain, right? So NFTs exist as a smart contract. There can be many NFTs in one smart contract and usually there's a user that owns the NFT, right? So in this case, we have a 721 contract called Nftb and there's a token with ID Four Five Six. And so this user owns Nftb number Four Five Six we're used to that everybody's kind of aware of, and NFTs are owned by wallets. What ERC Six Five One introduces is a new smart contract called the ERC Six Five One Registry.
00:17:32.196 - 00:18:16.576, Speaker C: And this registry is what gives every single NFT its unique address. You can query this registry with the Token contract and Token ID for any NFT and get back a unique wallet address that will be owned by that NFT. So the registry is a single entry point you can query for all of that data and it works with any NFT. The registry also deploys the smart contract at these addresses. So these token bound accounts are really smart contract wallets that are owned by the NFT and that ownership by the NFT owner is enforced at the smart contract level. So when you ask the registry for an account address for your NFT, it'll give you back an account address that you know will only ever be owned by that NFT. And so NFTs can own multiple accounts.
00:18:16.576 - 00:18:48.770, Speaker C: In this case, token one two three on contract a owns two accounts. Token Four Five Six on Contract B owns one account and this account is managed by the holder of the NFT. So this user owns Token four, Five Six. That means that they have full root execution permissions on the account. They can do whatever they want with it, they can use it as a wallet, they can do anything you can do with a wallet. But if they ever sell this token, everything in the wallet goes with the token. So when you sell the NFT, all of the things you've collected in the wallet go with it because it's really the NFT that owns the account.
00:18:48.770 - 00:19:19.204, Speaker C: And then the final piece of this is the implementation. Every account is really just a proxy to an account implementation that implements a very minimal interface and you can find all that in the EIP. But essentially the EIP provides a registry that everybody can query for account addresses for NFTs. And then it also provides a very minimal interface for implementations. It works on every EVM chain, wherever you're building, as long as it's EVM compatible, you can use it. You can also permissionlessly deploy that registry to the canonical address. It's fully decentralized, like we don't own it's in the IP.
00:19:19.204 - 00:19:51.648, Speaker C: You can go nuts deploying it and it works with every NFT on every EVM compatible chain. And so you can now build applications, assuming that NFTs can own things and do things. From day zero, there's been lots of people who have been helping us build this out. This kind of originated into projects that we were building on. But as we've started to speak with other folks and started to collaborate with other teams this is a list of a couple of the other companies that have been involved in helping refine the standard or building on the standard. We've got a working group of like 700 developers who are building on ERC 65 One. If you want to join or ask questions, it's available to you this weekend.
00:19:51.648 - 00:20:22.584, Speaker C: So, yeah, what you've seen already, there's a bunch of tooling that we've been building around ERC, six five One, that kind of core concept of NFTs having wallets. That's basically all you need to know to work with ERC six Five One. You don't need to do anything special on your NFT contracts. You can launch the most normal vanilla, off the shelf template NFT and it will come with a wallet. That's all you need to know. All you need to know is your NFTs come with wallets now and there's a few ways that you can interact with them. One way you can interact with them is via the Tokenbound Explorer.
00:20:22.584 - 00:21:02.792, Speaker C: So you saw this earlier when I went Tokenbound.org, when I replaced the openc URL, you can see on the Tokenbound Explorer the address for any NFT. So if I go back to this tab here, this is the CryptoKitty. I don't happen to own this CryptoKitty, but if I connect my wallet and go to my NFTs, you can see a list of NFTs that I own on chain. And so for any of these NFTs, I can go in here and I can see the account contents of the NFT. This is an NFT project that we released called Sapiens, which is one of the first collections to use this natively. But what happens is this Sapiens NFT owns these three NFTs, and these three NFTs are actually clothing items that the NFT can equip.
00:21:02.792 - 00:21:34.944, Speaker C: So you can see this background is an Equippable item, and this NFT has that background equipped onto its artwork. That's possible because this NFT owns this background token. But what's really cool is this NFT can own tokens that are from other collections, too. So this NFT is not part of the clothing collection that we released. This is from a separate collection. But you can also equip this NFT as a piece of clothing onto your Sapiens NFT. By giving NFTs wallets, we let NFTs own any asset.
00:21:34.944 - 00:22:06.436, Speaker C: And you can build on top of this crazy composability layer, like you can send any NFT you want to into another NFT. Another example here, if I go and show you this is someone who've sent a whole bunch of stuff into their Sapiens NFT. You can see this NFT owns an azuki and it owns a doodle and it owns a moonbird, it owns a CryptoKitty. And this just works out of the box because the NFT has its own address and can receive any asset. Sorry, I got to fix a bug in the renderer, apparently on this page, but that's the ERC six five one Explorer. You can go there. You can connect your wallet.
00:22:06.436 - 00:22:28.596, Speaker C: You can think of it like Etherscan for Token bound accounts. For any NFT, you can find its wallet address. You can see it here, and that'll link you off to Ether Scan, where you can see all the transactions it has done. It'll also show you everything inside the wallet. And if you own the NFT, you can transfer things out. If I click this, I can transfer this NFT to any of wallet. I can use this like a wallet through the Tokenbound.org
00:22:28.596 - 00:23:00.400, Speaker C: interface. So that's one place you can go to start building on top of Tokenbound accounts. If you want to link out to this in your projects, this is kind of like a good default place where people can play around with Tokenbound accounts, but there's a hackathon. So we're going to want to build some cool, interesting new custom stuff this weekend. So we have a lot of tooling we've built to help you with doing that. The first and foremost is a Token bound SDK. So if you go NPM, install at tokenbound SDK that's the GitHub repo tokenbound SDK this is probably the easiest way to get started building front ends with ERC six five one.
00:23:00.400 - 00:23:27.864, Speaker C: You're just an NPM package away and you can query for the address for any existing NFT. You can deploy the smart contract at that address, and you can interact with the smart contract at that address if you're the owner of the NFT. So you can build all the experiences that you see on the Tokenboud site. You can build those into your DAP. And you can kind of build experiences on top of these wallets and use them as an additional wallet inside your DAP. So I can actually show you real quick. Let's see.
00:23:27.864 - 00:24:03.088, Speaker C: Is this big enough for people to see? Can people kind of see what's going on here? Awesome. So this is just a normal this is what you get when you do Wagme create app. Wagme is a great front end development framework. If you're bootstrapping a Web three app, you can just run I think it's NPM create Wagme and it'll spin you up this project. This is basically a super basic project with the one exception that I've added, the Token bound SDK. I've done NPM install at Tokenbound SDK and now it's installed. So if I just run this server real quick all right, so I'm running the development server.
00:24:03.088 - 00:24:23.884, Speaker C: I should be able to spin it up locally. And fingers crossed that the Wi Fi works and it'll spin it up. There we go. So this is what you get when you just create a new Wagme project. It has some things out of the box, and you can see at the top we've added this Token bound account page. And so what you're seeing here is this is the address for the Sapiens project, the Sapiens that I showed you. And this is the token ID.
00:24:23.884 - 00:24:45.824, Speaker C: And this is the chain ID. So every EVM chain is a chain ID. Token bound accounts are tied to a chain ID. And so with these three inputs, this is the address I get back from the Token bound SDK. And so in here, in my Reacts component, it's pretty easy. I just added in the Token contract the Token ID, and that's it. It uses the chain ID of the provider I'm connected with.
00:24:45.824 - 00:25:21.212, Speaker C: And down here I instantiate a new Token bound client, passing it in the provider that I'm working with. In the front end application, if you're using VM, it's really easy to grab that. It's got a nice little hook. If you're using Ethers or something, you can pass that in as well. So I instantiate the Tokenbound client here and then it's one call away. I call Tokenbound Getaccount and this gives me back the Token bound account address for this NFT. And you'll see this address here is the same address that you see in this little iframe here, Sapiens number zero.
00:25:21.212 - 00:25:43.104, Speaker C: And we're passing in Sapiens number zero, we get back the same Token bound account address. So you can query that address really easily without having to know anything about how Token Bound works or how ERC six five works. Under the hood. You can get that address information into your applications and then you can start using it. There are other methods on the SDK. We have a Docs page at docs tokenbound.org where you can see all the methods on the SDK.
00:25:43.104 - 00:26:09.500, Speaker C: You can deploy the account, you can execute calls against the account. It's all pretty much the same. You pass in the provider from your front end application and you can start executing against those accounts. So that's the SDK, it's an NPM install away. You can start building 6551 related stuff into your front end without having to worry about how any of the smart contracts work behind the scenes. All that's taken care of for you. You can just use the NFTs that your application is already interacting with and interact with their wallets.
00:26:09.500 - 00:26:26.700, Speaker C: That's one way to build on top of the Token bound. It's token bound SDK on GitHub. Another thing we provide is a wallet implementation. So in 6551 you can actually bring your own wallet implementation. You don't need to use ours, you don't need to use anyone's. It's fully decentralized. You can build your own wallet for your NFTs.
00:26:26.700 - 00:27:03.112, Speaker C: We provide one that's out of the box. It's got some of the nice things you'll expect from a smart contract wallet, like four, three, seven support, 1271 support, so you can sign messages, some stuff around delegation and things like that. So it's kind of a fully featured extensible wallet that you can build on top of. And if you're using the SDK, you already are using this out of the box. If you're using the Tokenmat Explorer, you're using this out of the box. But this is a fully open source wallet implementation that you can start using if you want to hack on building a custom ERC six five one account implementation. If you want to add custom features to the wallets for your NFTs, you can fork this and go nuts and build a custom implementation.
00:27:03.112 - 00:27:23.472, Speaker C: That's the repo for it. Tokenbound contracts. If you're using the SDK, you don't have to worry about it, but you can totally interact directly with this. So I'll show you another demo of this if I just switch to my contracts directory. I'm not sure how many of you are familiar with Forge, but this is Foundry. This is Forge, the smart contract development toolkit. This is a script.
00:27:23.472 - 00:27:51.896, Speaker C: So this is a Smart Contract, but I'm going to run it locally. But you can use the same code inside of your Smart contract accounts or inside of your Smart Contracts that you're building this weekend. So getting the Token amount account address for an NFT is as simple as using this ERC six five one account lib from the ERC reference repo and passing in pretty much the same data that you passed in. In the SDK. There's two extra parameters. One is the registry address. This is the canonical registry that's deployed on every chain.
00:27:51.896 - 00:28:14.960, Speaker C: So this is the registry address. The second is a Wallet implementation address. So this is using our Wallet implementation again to pull it across chains. You can feel free to use it if you're going to do a custom implementation. You would pass your own custom implementation address here and then the rest is the details about the NFT. So a chain ID of one, because it's on main net, the contract address of the NFT and the token ID which is zero. And then the final argument is assault.
00:28:14.960 - 00:28:46.608, Speaker C: And so by default, this is zero. You can use the account with assault of zero. But if you're used to using Wallets within MetaMask where you have one seed phrase but you can have many Wallets, it's the same kind of thing. You can have one implementation for a Wallet, but you can have many wallets for an NFT. Using that implementation, just change the value of salt. So these are the default values, these two for the registry and tokenbound account address and then zero for the salt. And then the middle three are your token information, the chain ID, token contract and token ID.
00:28:46.608 - 00:29:33.608, Speaker C: And so if I run this, all this is going to do is calculate the account address of the NFT locally and log it out. If I run this script using Forge, it'll run this and then it gives me back the same address. Zero x 5416 because we're calculating the address for my NFT and the same kind of thing. You can call directly into the account contract from your smart contracts and use the execute fault call functions or the other functions on the Tokenbound account. So you can have smart contracts that are aware of NFTs, that are aware of the NFT's wallets and do really interesting things with them. One cool thing about if you're doing this with either the SDK or the Solidity library is you're not actually calling into any contracts. You're not making an RPC call when you calculate the address for an NFT.
00:29:33.608 - 00:29:59.750, Speaker C: You're not making a contract call when you use Solidity to calculate the address. Because addresses can be statically computed by the client, you don't actually need to make that network call. It just happens locally, which is kind of a cool benefit that you get with 6551 anyways. So there's a client SDK that you can use in your front end apps. There's a solidity SDK. You can pull it in from the ERC six five, one repo. You can also pull in our wallet contracts and start building in your application.
00:29:59.750 - 00:30:39.700, Speaker C: So that's Tokenbal wallet. One other thing we have is an iframe. So you probably saw when I was playing around with the Sapiens NFT that there's this little thing in the bottom that shows you the contents of the wallet, shows you the assets it owns, it shows you the wallet address. This is something we built for the Sapiens project because it's really useful if you're going to be on OpenSea trading NFTs to see the contents of the NFT's wallet and to see its wallet address. Like, I can come in here and I can copy and paste the wallet, and then I can go over to Etherscan, I can paste it. It's really nice to have this information accessible in OpenSea. This is all open source, so if you want to use this iframe in your projects, it's really simple.
00:30:39.700 - 00:31:24.850, Speaker C: There is a repo here. It's tokenbalance iframe I believe if you chat with Ray afterwards, there's also a URL that you can do it. What you do is when you're creating an NFT, you can pass in a custom animation URL field in the metadata, and that can point to a full website. So if you pass in an animation URL and you use the Token mount, iframe you'll get the artwork of your NFT rendered, but this nice little account overlay, that shows you the contents of the account and the account address within the NFT. And so that's a nice little know. In the interim, before OpenSea and all the other marketplaces support Tokenbound accounts natively, you can build in support for it at a visual level using the Iframe. So that's at Tokenbound iframe on GitHub again, we'll be here all weekend, so come find us and we can walk you through using that.
00:31:24.850 - 00:31:26.192, Speaker C: Yeah.
00:31:26.246 - 00:31:26.560, Speaker D: Finally.
00:31:26.630 - 00:32:04.129, Speaker C: Docs. Tokenbound.org. So this is where all the information you'll need to work with Tokenbound accounts is the contract addresses for both the registry and for the implementations. Some information on using the SDKs the iframe so, anything you want to know about Token bound accounts or using the Token bound tools is at docs tokenbound.org. And if you're interested in the actual EIP spec itself, you can look that up at EIP six Five one. It should be on the EIP site and you can read through here. This is kind of a really in depth exactly how it works behind the scenes, deep into some of the theories of it and all of the ways that the smart contracts are structured for building on top of it.
00:32:04.129 - 00:32:32.264, Speaker C: You don't necessarily need to know that, but you can go there and see it if you think that's cool. Finally, we've got some bounties we're giving out this weekend, so we're here. We would love to see people building on top of ERC six five one, building on top of this concept that every NFT comes with a wallet now. And so we would love to see you all build crazy stuff with us. We have some ideas for you if you don't have stuff planned yet. We've got some prizes for the best use of it, just best overall. Got the best NFT use case or NPC use case.
00:32:32.264 - 00:33:10.508, Speaker C: If you want to do some crazy stuff. Combining NFTs with AI controllers that do actions on chain, we think that's a really interesting use case. If you're around at Pragma yesterday you saw a demo of Benny talking with an NFT via a Web Three chat app and that NFT actually executing on chain actions to send him stuff. If you want to do something similar in that vein where you're giving NFTs AI capabilities you can use like, that's the NPC category. We'd love to see you build ups infrastructure. We would love to see some things built on top of this to make it easier to build with tokenbound accounts. So if you are building this weekend on top of ERC six five one, running into issues or just seeing things that you think should exist, like indexers if you want to build wallet.
00:33:10.508 - 00:33:55.344, Speaker C: Connect support if you want to build tooling for getting snapshots of a whole collection's, token mount, account addresses, or even if you just want to submit a pull request to any of the open source tools. That's the infrastructure category we would love to see all of you build on top of ERC six five one and contribute to some of the stuff we're doing. Open source. Finally, if you're a little bit less technical and you don't want to do like some crazy solidity or front end stuff, we've got a prize for the best on chain media use case. If you're creating art using 6551, what happens if you have composable NFTs that change the artwork? Or if you want to do like some interaction design or some visual design around how do we represent this concept of NFTs owning wallets and those wallets owning assets? Doing some visual stuff around. That there's a category for that. So anyways, that's ERC, six, five, one.
00:33:55.344 - 00:34:10.090, Speaker C: Every NFT comes with a wallet. Now every NFT that you launch this weekend in your projects will come with a wallet and you can feel free to use that. So yeah, thanks so much. You, um yeah.
00:34:14.220 - 00:34:16.840, Speaker F: Have someone close, like a label?
00:34:20.860 - 00:34:46.860, Speaker B: Okay, cool. All right, we're gonna get started right on time because we're gonna get through a lot of cool stuff today, guys. Thank you so much for coming. My name is Kevin Jones. I'm a developer relations engineer working for Edge and Node, working on the graph, and I'm also an advocate for Scaffold ETH, part of the Build Guild or the Biddle giddle, as you might have heard. Today. I'm going to be talking about Scaffold ETH, though.
00:34:46.860 - 00:35:07.492, Speaker B: It's basically this kind of awesome toolkit that kind of gets you up and started quickly for building DApps. So it's really, really useful for hackathons because it is just a really good starting point. This is all my contact info. Feel free to connect with me on whatever you prefer. I'm on Twitter, Telegram. I'll be here around too as well. I'll be at the graph booth.
00:35:07.492 - 00:35:31.580, Speaker B: So if you guys have questions about the graph or about Scaffold ETH after this, I'd be happy to help you guys out. So please connect with me. I don't have any slides. We're going to pretty much do like real time demo here. But first I kind of want to talk about Scaffold ETH. There's two versions of Scaffold ETH. I'm going to be mainly focusing today on Scaffold E Two, which is the newest flavor of Scaffold ETH.
00:35:31.580 - 00:35:55.684, Speaker B: There was a lot of cool improvements that have been made to the project and more specifically, it comes with Next JS. It kind of revolves around TypeScript. It also uses rainbow kit and wagme. And it also uses hard hat. We're in the process of making a cool build that actually might support Foundry as well. But for everyone here, this is kind of what you get with it. It's a GitHub repository.
00:35:55.684 - 00:36:23.580, Speaker B: So if you just search Scaffold Two, it's going to show up as the first kind of thing. You can come in here, you can template this and kind of copy it over to your own GitHub. That's usually what I recommend. And then you can kind of use that as kind of like your project for the hackathon. So we're just going to kind of get started. So I'm using tmux, which is just like a terminal multiplexer. It kind of always has the ability to have multiple windows in one kind of console, but you could just use multiple windows.
00:36:23.580 - 00:37:08.944, Speaker B: You kind of always need three windows with Scaffold because you have your back end, which is running hardhat, and you have your front end which is running NextJS and React, and then you have this kind of like third window where you're doing your deploys and kind of pushing your changes, right? So I've gone ahead and just checked out the repository already ahead of time. And I've also gone ahead and did a yarn install. So you do yarn install, it's going to basically install all of the dependencies for you and get you up and running. Once you're ready to go, you just do Yarn Chain. So Yarn Chain is going to spin up again a copy of Hard Hat. It's going to give you these kind of like Hard Hat accounts that are available for you to toy around with and start messing around with the EVM and start testing your smart contract. And then in the second window, we're going to run our front end.
00:37:08.944 - 00:37:28.480, Speaker B: So Yarn Start, okay, so Yarn Start is going to do exactly that. It's going to start up next JS on Localhost 3000. We'll open that up in a second real fast. Huge improvement over Scaffold ETH. One which use just straight react. Next JS is just really fast and awesome. And then same thing in this third window we're going to use for all of our deployments.
00:37:28.480 - 00:37:59.904, Speaker B: Okay, so we're going to do a yarn deploy. Now what that's going to do is actually Scaffold comes with a smart contract so we can see that our contract got deployed. We did a transaction, we created our contract and it tells us how much gas we use because we're console logging that stuff into Hard Hat, which is really cool. And we also see that Hard Hat mined that block, right? And then we see like, yeah, we can optimize our contract based on gas because we know that's there we see our contract address. Let's take a look. First of all, I'll bring up Vs code. We'll get to that in a second.
00:37:59.904 - 00:38:20.752, Speaker B: But let's go ahead and load up the application. So we're going to use let's see where's it at. Scaffold ETH. Here we go. So scaffold ETH is like I said it's. Next JS So this is kind of what you get when you launch Scaffold ETH. And one of the things you'll notice is that we got this kind of wallet that's automatically integrated.
00:38:20.752 - 00:38:38.008, Speaker B: So Scaffold ETH has this concept of burner wallets. So you don't necessarily have to use MetaMask, you can just use the burner wallet. It's ready to go. And we have this kind of identity that we can start testing with. So I can grab some funds from the faucet by just clicking that. That sends some funds from Hard Hat into my burner wallet. And I'm ready to start interacting with my contract.
00:38:38.008 - 00:39:13.480, Speaker B: So where's my contract? Well, it injects, it automatically here into debug contracts. So it basically takes the Abi for the smart contract, which is kind of like the interface, right, that tells your smart contract and your front end how to talk to each other. And it creates and populates all these fields for you so you can start doing testing against your kind of functions and you instantly get an output on your variables, right? So you see like, all right, cool. We have a greeting variable, looks like a string. We have an owner variable which is an address. We have a boolean that's set to false and then we have like a counter and then we have these reads functions as well. We also see our contract address here.
00:39:13.480 - 00:39:37.072, Speaker B: We see if it has any funds. We see what network we're on and we can come in here and say like, all right, well, let's change the greeting. So we have this write contract so we can tell right now there's a set greeting function in our smart contract and I can change it to whatever. So FUBAR and hit send. And now I've updated the state of the contract. So we have this kind of like it's like a Hello World contract, really basic. Let's take a look at what it looks like.
00:39:37.072 - 00:40:05.892, Speaker B: So let's go ahead and load up the directory for Scaffoldeth. Mainly the beauty of Scaffold is everything revolves around yarn. So there's like a package JSON file that has these kind of commands for you to just navigate and do stuff in Scaffold ETH. But more importantly, there's the two packages. It's a monorepo. So you have a Hard hat repo and you have a next JS repo. So we can go right into Hard hat and we can go into our contracts and go into the year contract and then we can see our contract.
00:40:05.892 - 00:40:37.828, Speaker B: So this is kind of like I said, the Hello World contract and we can kind of start hacking away at our contract. So I just kind of want to show you guys how this works. So we see here that we have this owner variable. Let's go ahead and dump that. I always like to kind of gut the contract. Let's also get rid of the constructor because we're going to make like an empty constructor and we're also going to get rid of this modifier and let's just say you made all these changes, right? We're also going to get rid of this withdraw function and we're going to save that. And then we could try to do a deployed now.
00:40:37.828 - 00:41:14.076, Speaker B: Now if we wanted to, we could do a yarn deploy. If it sensed changes in the contract, it would give you a new contract. But we're getting an error. And the reason why I want to highlight this is we had this constructor and we were passing some arguments in it and because Scaffold ETH uses Hard hat, we also need to fix the deploy script. So if you take out this constructor, which I did, I kind of ripped out the contents of it, made it empty. We also got to go into the deploy script and look at the actual deployment. So if you're not familiar with Hardhat, it's a JavaScript, basically uses Ethers to deploy our contract.
00:41:14.076 - 00:41:48.680, Speaker B: And we'll see here that we're getting a copy of our contract, or we're actually deploying our contract here, which is called your contract. And we're using some arguments that we're passing into the constructor. So it's basically complaining about that. So I'm just going to wipe that out because we were using the deployer count to set a variable in the constructor. So I'm just going to save that and kind of redeploy again. So if you ever want to force now it was successful. If you ever want to force your contract to deploy as well, if you do a yarn deploy again, it's going to see that, well, you don't need to actually redeploy the contract because it's the same.
00:41:48.680 - 00:42:34.040, Speaker B: But you can also force a contract by doing yarn deploy reset and it will basically force a new contract to be deployed. Okay, so let's take a look now. So now our UI is automatically changed, right? We've gotten rid of this owner variable, we've gotten rid of the withdraw function, and now we're kind of in this new state where we can start kind of like building out whatever we want, right? So we could see what that might kind of look like. So let's close the deployer script because we're not going to need to really mess with that at all. But we could actually, instead of using so earlier we had this modifier and we had this concept of access control. That's one of the things you learn when you're building on Ethereum. You need to have some kind of access control for certain functions.
00:42:34.040 - 00:43:20.580, Speaker B: Well, you can just actually import the existing Ownable smart contract, which is an Open Zeppelin contract, just by importing it like this. And then we can take our contract and then inherit that, right? So we import Ownable, which is just this Open Zeppelin contract. If you're not familiar with Open Zeppelin, it's kind of like a collection of contracts that are for different use cases and they're kind of like vetted and widely adopted. And then we can just import that and use it here, or sorry, inherit that as here and then save that. So when we make those couple changes again, we're going to do our change and then deploy a change and see if it goes through which it was successful. And then you're kind of in this feedback loop with Scaffold E. You're editing your front end right, with your editor.
00:43:20.580 - 00:44:10.680, Speaker B: You're deploying your changes using hard hat, using the yarn command, and then you're coming in here to the UI and reflecting and seeing your changes. And so you can start to do interesting things like maybe we want to see now that we have access to the ownable, we also have this transfer ownership function. So we might be able to call that in our deploy script. Like, let's say if we want to transfer ownership to another address or we want to renounce ownership of the contract, we can call the renounce ownership, which allows you to throw away the contract. So you can kind of use composable contracts that are already available from Open Zeppelin to kind of start your project. So if you're going to use ERC 20 token or create an ERC 20 token, then you can get the Open Zeppelin one. Or if you're going to do an NFT, you can get 721 or eleven fifty five s and just import those and they'll just show up here in Scaffold ETH.
00:44:10.680 - 00:44:41.232, Speaker B: And then we have this example UI, which is pretty cool. It just gives you some examples. One thing I always hear from developers is like, all right, I'm really good at writing Smart Contracts, but I don't know the front end components. So we're going to dive a little bit into that and show you kind of what that looks like. But there's a lot of components that are already written for you that make it easy to build DAP. And this is just a really good example of like, all right, well, we have this kind of window, we have this greeting option. We can actually say hello, world, here like this and hit send.
00:44:41.232 - 00:45:29.024, Speaker B: And it will update that by sending some transaction. And then what we'll notice here is our counter increased, right? We get our new state kind of coming over there. And then if we go back to debug contracts, we can see that now we've been able to actually send some ETH into the contract because this example UI, not only does it allow us to change the state, but it also has a value that it attaches to it, right? So we're actually sending in some value. We're paying for the gas, and we're kind of creating this interesting function. It's not that interesting, but it's cool just to kind of see how it works. And so let's dive a little bit more into the code of Scaffold ETH's front end. So again, if you're editing your contract, it's in your hard hat contracts, your contract, you can kind of come in here and do whatever you want.
00:45:29.024 - 00:46:11.520, Speaker B: If you're new to building on Solidity, what I always tell people do is go to Solidity by Example. Solidity by Example is just a really cool place to get examples. So an example would be you want to get like a mapping, right? You can come in here, grab the mapping, paste it into your Smart contract right here, right? Tab, boom, save it, deploy. And then we'll see that we got a new copy of our contract. And then we'll see that we have this new mapping available in our front end, right? Here it is. It's a my map. And then we can check this balance or something like that, like grab this and see if there's some kind of map to a value.
00:46:11.520 - 00:47:00.168, Speaker B: There's none, but maybe you do that in the constructor, right? Maybe at the time you deploy something, you set a value so you can start doing interesting things just by grabbing examples from Solidity by example and kind of pasting those into your contract. Okay, so Solidity by example is great. Let's go a little bit more into the UI. So, like I said, the magic to Scaffold ETH is it builds that debug contract tab for you, which allows you to kind of get up and running, start doing some testing. You can also do something like this where you say like, all right, new incognito window, go to Localhost 3000 and then you get this new identity. So not only do you have this kind of like, burner wallet here, but you also get access to burner wallet here. And you can start kind of testing different personas that are using your DAP.
00:47:00.168 - 00:47:49.448, Speaker B: And so that's really useful because the burner wallet is actually stored inside of the browser session. So if I was to come here and close this again and then also open up another incognito window, we would get this kind of new identity and a new burner wallet, right? So you can really kind of toy around with like access control or whatever kind of functions that you want with another identity. Okay, so let's look at the front end. So NextJS is awesome if you're just good with Solidity. And it can be kind of a little bit challenging when you start writing your front end. But the cool thing is, under pages we have this kind of example UI which references the components example UI. And then we have this contract data which allows us to get all of the contract data from our smart contracts.
00:47:49.448 - 00:48:15.344, Speaker B: And there's kind of some examples in there. And then also like a contract interaction as well, which shows you how to do like, use Scaffold ETH Write, which is like a hook that you can use. And so you can come in here and kind of use this. You can see with Scaffold ETH we have these hooks. So we have one for using this contract, reading the contract, subscribing to events or seeing the event history. So there's all this kind of interesting stuff. And then again we use Wagme.
00:48:15.344 - 00:48:54.080, Speaker B: So let's kind of start hacking away at a front end so you can kind of see what we would do. So what I always tell people is if you're building an app, use the index TS file, which is this kind of like a home thing. It's originally just set up to kind of show you where you should go to do stuff. Oh, also, real quick, there's a Block Explorer, which is really interesting. It's new, but it also shows you all your transaction history, which is really cool. You can see what you called, what function was called, and it's just kind of interesting to see the history of that. But yeah, so if you want to edit this thing, this is index TS, right? So we can come in here and we can just kind of wipe out some of this stuff.
00:48:54.080 - 00:49:47.204, Speaker B: So let's get rid of this and save that. So if we save it, boom, we get this kind of like clean slate. So you can kind of think of it like you're building your DAP inside of this home folder and it's going to be available inside the middle section, but you still get access to all everything that's wrapped around Scaffold ETH. Okay, so let's just say that we want to do something like this. We could say like, I don't know, we'll do const and then we say like, all right, address. We want to get the address of the smart contract from Wagme, so we can use sorry, not from Use account, right? And my IDE basically automatically imported Wagme for me here, so I'd have that enabled so we can see that we have Use account access and then we're able to access that. And so one example would be like, let's use one of the components that comes with Scaffold is called address.
00:49:47.204 - 00:50:10.490, Speaker B: So we can say address. We say address equals address, like this, and then close it off and save that. And what did I do wrong? Address equal oh, I need to import that. Yeah. So let's see, we can go from components example UI. I think it's under.
00:50:15.420 - 00:50:16.328, Speaker C: Just retype the.
00:50:16.334 - 00:50:20.156, Speaker B: Last say that again. Oh, yeah, maybe it'll pop up.
00:50:20.178 - 00:50:23.650, Speaker C: Yeah, just on line 13 there.
00:50:24.020 - 00:50:24.960, Speaker B: On where?
00:50:25.110 - 00:50:27.490, Speaker C: Yeah, retype the last letter of that word.
00:50:29.940 - 00:50:49.972, Speaker B: Oh, here, there we go. Thank you. I'm still learning like Vs code. I mean, I'm like a terminal kind of guy, so I'm using Vim. So this is all new for me. Okay, so that's just example. So here we can see we got access to the count, which is like just a component, right? And so we can get that.
00:50:49.972 - 00:51:08.732, Speaker B: We can also do something like grab the balance. So we can say like, all right, well, const, let's grab the balance. And by the way, I'm not a front end guy either. I'm still pretty much green. So we can say Use account balance. It's going to also import that for us. And then we can also create another one.
00:51:08.732 - 00:51:27.016, Speaker B: So let's be slow here and see if it actually takes it. There we go. Did. And the same thing. We can pass the address in here and sorry, boom. Still learning this AI stuff too. I got this auto completion.
00:51:27.016 - 00:52:04.948, Speaker B: Did I spell that wrong? Oh, didn't close it off, but you get the idea. So there's some components are available. So now we have the address here and then we can also get access to the balance, right? So there's all these interesting components in there. I'm not going to get too far into it because it takes a while to build out a full UI, but I would say go into the examples here, into the contract data, contract interactions, and you can start kind of doing some stuff. But I also want to showcase one other thing. So as you guys know, I also work for Edge and Node, working on the graph. And so I wrote this blog post, which was also quite interesting because there is a bounty available for the graph.
00:52:04.948 - 00:52:46.936, Speaker B: And so if you want to use Scaffold ETH and you also are interested in using the graph, the graph is kind of like this API layer. I wrote a good blog post that walks you through how to set up Scaffold ETH. And there's a special package of Scaffold ETH. Or I should say a special branch called Subgraph package for Scaffold e two. And inside of here, there's a complete dockerized version of the graph that you can set up. And so my blog post actually walks through basically all the stuff with Scaffold E that I went through at least the basics of deploying your contract, making some changes, but it also goes into how you actually spin up the graph and how you create a subgraph using the command line stuff. Again, there's also these yarn commands written for you.
00:52:46.936 - 00:53:14.496, Speaker B: So it make it really easy that you can generate a subgraph based on your smart contract. So if you write your smart contract, all you got to do is just run these yarn commands and it will generate all the subgraph information for you. And then you can publish that to docker. So the one caveat to this solution is it runs in docker. So if you want to use Scaffold ETH and you want to run it locally, this is a really cool way to do that. And then you don't have to deal with the Internet connection if there's any issues. But you can also take your subgraph at some point.
00:53:14.496 - 00:53:50.476, Speaker B: That's what I want to show you guys next. So let's say that you want to deploy this to a testnet, right? Everything we've been doing kind of is local. The next thing you might want to do and how much time do I have? I got 10 minutes. The next thing you might want to do is actually do a yarn generate and actually generate a deployer account. So you don't want to use Hard Hat accounts to deploy your smart contract because everyone has the private key, right? So you need to generate a new private key. So we store that in an environment file locally. And then you can just do a yarn account and you can fund this account so you get access to the address and you can just fund it.
00:53:50.476 - 00:54:56.092, Speaker B: Like you could just go on your phone. Like if I pulled this up right now, I could send some testnet ETH there, and then you can do a yarn deploy like this network and Sapolia or Goreli or whatever testnet you want, right? So that's really useful because you can use Hardad as that catalyst just to push your contract to a testnet. And then you could use, if you stop by the graph booth, there's a sheet that walks you through how to deploy a subgraph using the CLI, and you can deploy it to a testnet as well. So there's this kind of like seamless and options for you on how you deploy your smart contract. And then on top of that, you can come into the front end. And if we go to the next JS directory and we go to this Scaffold config, there's a target network key setting so I could change this to whatever I want. So if I want to switch this to Sephola like this, hit Save and then go to my UI again, it's going to tell me that, well, first of all, it's going to get rid of my burner wallet because we don't have access to the burner wallet anymore.
00:54:56.092 - 00:55:07.616, Speaker B: So then we're going to say after I actually connect to MetaMask so we have that option and we can see now that I have my MetaMask connected, I got ten Sepolia ETH and now my DAP is hooked to spoila.
00:55:07.648 - 00:55:07.844, Speaker C: Right?
00:55:07.882 - 00:55:41.264, Speaker B: So it's that easy. You just deploy your contract to the testnet using the Deployer account, update your UI, then you can take your application or your front end, and you can do a yarn versel yolo like that, and basically it'll take your thing. And if I did it right now, it would say like, all right, we need to authenticate. Oh, I already did it earlier. So then it's taking my contact, uploading it to Versaille, and then I have my front end available so that my team can start interacting with it.
00:55:41.302 - 00:55:41.648, Speaker C: Right?
00:55:41.734 - 00:55:49.668, Speaker B: So it's this kind of full seamless solution where you use Scaffold ETH to kind of do everything. So what else can I show you guys?
00:55:49.754 - 00:55:50.390, Speaker C: Okay.
00:55:52.920 - 00:56:42.100, Speaker B: So one thing I would say too is I don't know if you guys are familiar with Speedrun Ethereum, so this Shameless plug, but Speedrun Ethereum is an awesome way. Like after the hackathon, if you kind of want to get more involved in the Ethereum community and the building community, speedrun Ethereum is this kind of like set of challenges where you can go through and do different projects and deploy different things. The first one is like an NFT. Then you create a Staking app and then you create a token vendor and then eventually you actually get invited to the Build Guild which the Build Guild is kind of this collection of developers or group of developers community that are all kind of working with scaffold ETH and helping the community grow forward. And so far there's about 770 builders. There's been 784 builds of Scaffold e one and Scaffold e two. And then on top of that, we have certain developers that want to be really involved in the community.
00:56:42.100 - 00:57:16.530, Speaker B: And you can actually get a stream and you can actually be funded as a developer to create and use Scaffold ETH, or promote Scaffold ETH or build on top of Scaffold ETH and help the ecosystem. So that's a really cool thing. I also have a Poop, so I would love for you guys to get my Poop after this. Yeah, so I think right now, I think maybe we can open it up for questions and see if anyone has questions about Scaffold ETH or anything that I showed. It's got to be at least one question. Anyone?
00:57:19.300 - 00:57:21.484, Speaker C: You said maybe on a Foundry version.
00:57:21.612 - 00:57:39.072, Speaker B: Yeah. So we are working on the core developers of Scaffold Two are working on a kind of a cool choose your own adventure style thing where you might check out the repository and say, oh, I want to actually use Foundry, or I want to use, I don't know, whatever, different component.
00:57:39.136 - 00:57:39.412, Speaker C: Right.
00:57:39.466 - 00:57:54.750, Speaker B: So we're looking to do more stuff like that, and that's in the works. So that'll be coming soon. Oh, I didn't really actually test show as well. There are yarn tests, so we use hard hat. So there's some yarn tests that you can do. At least there was. Maybe they got rid of them, actually.
00:57:54.750 - 00:58:01.390, Speaker B: So maybe that's part of the plan, is we're going to use Foundry tests or something like that.
00:58:04.080 - 00:58:05.068, Speaker D: Two questions.
00:58:05.234 - 00:58:11.440, Speaker C: One, I noticed that the branch for the subgraph looked like it was a little bit behind others.
00:58:11.510 - 00:58:36.948, Speaker B: Is that something that we should yeah, I think that's a great question. So the question was about the branch being behind on the main branch. Yeah, that's something probably I need to work on and merge it all up, but I haven't gotten a chance to do it. I didn't actually write that branch. Simone from Edge and Node wrote it, which is super awesome. But yeah, it's okay to use it. It's missing the Block Explorer, and I can't think of anything else that's really drastically changed.
00:58:36.948 - 00:58:42.090, Speaker B: Everything else is very close in commits. It's not that far behind.
00:58:42.620 - 00:58:43.080, Speaker C: Okay.
00:58:43.150 - 00:58:45.500, Speaker A: And the other thing was the Next.
00:58:45.570 - 00:58:48.556, Speaker C: JS project that it creates uses, I.
00:58:48.578 - 00:58:50.236, Speaker B: Think, the older style, instead of the.
00:58:50.258 - 00:59:08.256, Speaker C: New app directory that NextJS is sort of migrating towards that emphasizes more type components. Is there like a flag or an option to switch to that, or is there a reason why one should really not do that?
00:59:08.358 - 00:59:40.316, Speaker B: Yeah, so, yeah, the question is we utilize an older style of deploying NextJS app and create NextJS app. I don't think there's an option that I know of to change that. That would be something that we would look to the community for people that want to be involved, maybe that's something you could be part of the Build Guild and help with. Something like that. But I can't think of anything that you can do right now. Maybe in the future we'll switch everything over. Scaffold Two is kind of in a really fast prototyping mode right now.
00:59:40.316 - 00:59:48.380, Speaker B: There's a lot of developers working on it, so they're doing a lot of future stuff. But maybe that's something that's coming that I. Just don't know about. Yeah. Fair enough.
00:59:48.450 - 00:59:48.684, Speaker C: Yes.
00:59:48.722 - 00:59:56.354, Speaker B: Another question. Do people in Build Go do client projects? Like work for clients?
00:59:56.482 - 00:59:57.206, Speaker A: Yeah, absolutely.
00:59:57.308 - 01:00:12.874, Speaker B: Yeah. So if there's certain projects that you need help know, we can work with you on that kind of stuff. Just come find me afterwards and I can get you in touch with someone that can help you with that. Thank you. I thought I saw another question. Yeah.
01:00:13.072 - 01:00:19.438, Speaker C: Hello. My name is Tim Garrett. I'm happy you're here. And I'm going to be using Scaffold for my project.
01:00:19.524 - 01:00:20.766, Speaker B: So if you know how to do.
01:00:20.788 - 01:00:35.300, Speaker C: This stuff, if you've gone through and Ethereum and or know Scaffold ETH, I can do somebody to help with that part. It's going to be a cool project. It's going to be interactive blockchain. It's going to light up and won't be able to miss it.
01:00:36.870 - 01:00:37.506, Speaker A: I love it.
01:00:37.528 - 01:00:38.980, Speaker B: Thank you. That's awesome. Yeah.
01:00:39.350 - 01:00:54.460, Speaker C: Room for one more person? All right. Yeah, it's really good. I'll say doing the first lesson of Cedar on Ethereum, we'll make sure everything's updated and you have the right versions and stuff. Like, let's say you update your operating system and it wipes out everything.
01:00:57.040 - 01:01:20.452, Speaker B: Yeah, that's good. Yeah. And it's also worth noting that Speedrun Ethereum right now, all the challenges are actually written with Scaffold e one, so you might notice there's some differences if you're going through, like, what I did. But the good thing is there's, like, tons of videos online for just Scaffold ETH version one that will walk you through that stuff. Awesome. Any other questions? No. Thank you guys so much for coming.
01:01:20.506 - 01:01:21.510, Speaker D: Appreciate it.
01:03:36.660 - 01:03:39.090, Speaker C: It okay. So that should be good.
01:03:40.660 - 01:03:41.600, Speaker F: Test. Test.
01:03:41.670 - 01:03:42.672, Speaker D: You guys are good to get started.
01:03:42.726 - 01:03:45.936, Speaker C: Whenever, but yeah, it has to be, like, you know, it could be, like, down here.
01:03:45.958 - 01:03:46.960, Speaker A: So that's all fine.
01:03:47.030 - 01:03:52.690, Speaker C: As long as you hear yourself doing test, don't go back to this.
01:04:03.360 - 01:04:05.630, Speaker F: Test. Okay, cool.
01:04:06.240 - 01:04:13.780, Speaker C: What feel like that's?
01:04:29.700 - 01:04:40.630, Speaker F: I'm gonna hold it. I feel like it doesn't go if I clip it. I feel like it doesn't go if I clip it. Like, I can't really hear the tap. Like see, it doesn't really pick up.
01:04:41.580 - 01:04:43.384, Speaker C: Yeah, it's not picking up in the room as much.
01:04:43.422 - 01:04:46.090, Speaker F: Honey, this is better.
01:04:52.140 - 01:04:57.772, Speaker C: No, the room should be this, too. It's all from here.
01:04:57.826 - 01:04:59.004, Speaker F: See, I'm I'm okay holding it.
01:04:59.042 - 01:05:00.750, Speaker C: You're okay holding it's fine. Okay.
01:05:01.280 - 01:05:02.670, Speaker F: Just gotta hold it.
01:05:08.160 - 01:05:08.876, Speaker A: Between each one.
01:05:08.898 - 01:05:20.692, Speaker C: Because this one's kind of getting low. Okay. Once we kind of get there, but do you want to clip it on? You're better off to take this off so it doesn't rustle. Take your lanyard off.
01:05:20.826 - 01:05:21.510, Speaker F: Okay.
01:05:28.030 - 01:05:29.340, Speaker C: If you don't mind me.
01:05:33.410 - 01:05:34.286, Speaker F: Can you hear me?
01:05:34.308 - 01:05:36.960, Speaker C: Can I pick up a little bit higher?
01:05:39.730 - 01:05:42.958, Speaker F: There we go. I don't know if it's oh, there we go.
01:05:43.044 - 01:06:00.966, Speaker C: Cool. Hearing the screen still, and you can kind of hear it. Yeah, it shouldn't be too loud. As long as, like okay. People can hear you.
01:06:00.988 - 01:06:07.882, Speaker F: As long as that's true. Do you mind if I just hold it at one point? Okay.
01:06:07.936 - 01:06:17.566, Speaker C: Sweet. Okay, cool. Yeah, for sure. But if you want, you can hold it. I don't mind. Perfect. But I 100% know people in here.
01:06:17.588 - 01:07:00.068, Speaker F: I kind of like holding it, but sweet. Okay, I think we're going to get started. All right, so welcome to our presentation. Thanks for being here. We're a highlight. So we're a platform to help creators build code based generative art collections. So Highlight kind of helps creators use no code tooling to deploy collections, create gated content, create a portfolio, kind of survey their content on chain.
01:07:00.068 - 01:07:43.120, Speaker F: But what we're most excited about is code based generative art. So we're really inspired by artists like Kim Asendorf, who's a popular artist in the generative art space that we're working closely with, because we're going to be launching a platform at the end of this month. So, like I said, Highlight kind of offers no code tooling. With this code based generative Art, you're going to be able to integrate, like, AI models. Gans we kind of do all the stuff in the background for you to create beautiful mint pages and all these sort of things. And this summer, we're going to be collaborating with a bunch of artists and brands just to kind of push the boundaries on code based generative art. So OpenSea coinbase.
01:07:43.120 - 01:08:28.720, Speaker F: Obviously, our friends at ETHGlobal are some of our partners. So today, what we're going to do is we're going to help you kind of like we're going to walk through what it takes to deploy a code based generative art collection on Highlight, and we're going to switch back and forth with technical explanations of some of the cutting edge protocol innovations we've made. Also some of the new stuff that we've developed on the generative arts side. Yeah, and so Saurabh is going to walk you through that. But before we jump into creating a collection, I just want to show you what an end product looks like. So if you come to Highlight and create a generative art collection, we're going to create this kind of, like, mid page for you. So this is kind of like your typical collection on Ethereum or on an EVM chain.
01:08:28.720 - 01:09:20.916, Speaker F: And the way that it works is when you mint a token from this collection, what we do is we take a bunch of parameters from the transaction, the mid transaction, like the transaction hash the block, hash, the token, ID, the timestamp, like, all these different sorts of things. We input it into the script that the artist initially uploaded, so the actual generative art script. And with that custom input that's unique to your transaction, that script is going to output a unique NFT, and you're not going to know what the NFT looks like before you mint the token. So, for example, we can iterate through possible outputs. So if I press randomize, here what's going on is we're just sending in virtual parameters. So we're like virtualizing a transaction. So virtual transaction, hash, token, ID block, hash, that sort of thing.
01:09:20.916 - 01:09:47.630, Speaker F: And we're inputting it into the script that the artist uploaded. And this is outputting what you see here. So this is like an example NFT that you could mint. So before Sarub is going to walk you through actually deploying a collection like this, we're just going to mint one. So press mint here. This collection is on Guerley. It's going to ask me to pay a small fee, which I will happily do.
01:09:47.630 - 01:10:19.352, Speaker F: And as you can see here, we have a pending transaction. And what's happening in the background is Highlight is going to pick up this transaction and then pass these mid parameters into the script. And then it's going to output a render through our rendering engine. And that metadata is going to get assigned to our token. So this should complete. It's happening right now. Once it completes, you can view it on a marketplace, on ether, scan, kind of whatever you want, but you're not going to know what it looks like.
01:10:19.352 - 01:10:27.368, Speaker F: It should sign right about now. There we go. So that's kind of the output.
01:10:27.544 - 01:10:28.270, Speaker C: Cool.
01:10:37.440 - 01:11:09.252, Speaker E: Yeah. So we've already gone through the actual Min page. What we're going to go through now is actually the creation page of this. Basically how you end up with that Min page at the end of it. As we're going through, we'll go through the technical details of it, what basically happens in the background to end up with or how we capture the image or the traits of the token. So I'm going to go ahead and create a collection. So this is basically we provide different types of collection, goes from generative to series, to open edition, limited edition.
01:11:09.252 - 01:11:46.516, Speaker E: And one of one, which is basically auctions, the one we're going to focusing on is going to be the generative series. So I'm just going to go ahead and create a collection. The first page you see is basically just it basically takes you through what's needed to render a generative art based. One of them is index HTML, which is basically your art. And that's what's rendered in an iframe. And then you also have the highlight gen script, which I'll go through the details of it, but all it does is provide a bunch of attributes which are related to the transaction. The creator can decide when they want to capture the image, the attributes of the token and everything.
01:11:46.516 - 01:12:20.556, Speaker E: So again, there's an example project that you can actually download. So you don't have to write the script yourself. You can just play with it. But yeah, let's go ahead. I'll just take you through the so it's going to be open source soon, but for now it's kind of like in restrictive mode, but I'll take you through a few of the methods of the GenScript that it provides. So as Aishan was mentioning that we basically virtualize a transaction when you actually mint something. So we got two methods which are generate random hash and generate random address.
01:12:20.556 - 01:13:07.640, Speaker E: All they do is basically just map through alphabets and create a random transaction. So you don't have to actually create a transaction, it'll just create a random transaction provided to your script and in the end you can actually see what the output of the art looks like as you keep going down. So the two main methods that we use here are, these are both open source XMR three, which is a hashing algorithm. It's available anywhere in the public repository. And then SFC 32 what we do with these algorithm is that when you actually call so one of the main methods that you call on the script is random, which works like math random, if you've ever played with it gives you a random number between zero and one. But the way we do it is basically it's a pseudo random number generator. It takes a seed using these two algorithms.
01:13:07.640 - 01:13:53.736, Speaker E: And the way it works is if I go to the seed method, it's going to take in the hash and the token ID to generate a seed. And then the seed that gets inputted into pseudo random number generator and you have a random number which basically every time you input the same transaction, you'll have the same art. So what happens is when you mint, we basically provide the same transaction, hash, block, hash and all of those values. So that gets encoded on the chain. So every time you open that URL, you'll have the same art on the blockchain. In terms of creators, the two main methods that creators are usually concerned with or they have to play with are the capture preview and set attributes. What they do is basically capture preview is if you've ever gone on OpenSea, you've looked at an image of a token.
01:13:53.736 - 01:14:33.220, Speaker E: That's what capture preview does is that you can actually call this method anytime in your script that tells highlight that you're ready to capture an image for the token. We take an image of the token and upload to OpenSea and that stays there. And same with site attributes, we take the attributes, we basically upload that to OpenSea and then you have that encoded on chain. So going back to the creation process, I'll just get started with a random script. So I have a few bunch of demo scripts. I'm just going to run through one. So I'll take this, it'll basically upload that to our centralized server and at the same time we use RV as our decentralized server.
01:14:33.220 - 01:15:19.850, Speaker E: It uploads that to RV and it stays there for permanency and then for validity of the code, again I'll go through. Yeah, so once you land on this page, it's basically a test script page. You have your P five JS JavaScript file which renders the art. So this is basically what the code renders. And then these are traits on this side which we capture in Live. So if you actually refresh or change the attributes so if I'm going to randomize it, the traits are captured using our rendering engine with the script and a virtual transaction. So as a creator, you can actually play around with changing the hashes, transaction hash, block hash, and you'll see different script, different traits, and you can just basically validate your art as you want it to be.
01:15:19.850 - 01:16:00.192, Speaker E: So again, you can not only randomize it, you can actually input custom hash, which will come in handy when we go to the next step. So if I keep moving forward, this is one of the key pieces of the generative art addition size. You can put it to anything. Like, I'm just going to go with 20. But this part is what allows the creators to say that they have a set of hashes that they want their art to use. So you can have a creator can say like, I want only these 20 set of hashes to use for my art. So whenever a Mint happens, we pick randomly from one of those 20 and we assign that to the metadata.
01:16:00.192 - 01:16:49.008, Speaker E: And that makes sure that whatever the art the creator wanted is basically just given to one of the collectors. We'll go through the details of how that happens, but I'll just give a demo of what that looks like. So basically as a creator, you can come here, you can say, I like this one. So if you click basically add, it adds to the selected hashes and you can keep on changing, generate more tokens. It'll take different virtualized transaction and you can keep on adding them. So you build a list of transaction hashes that basically the collectors would use for their art, just going back to the details of it. So the way it works is basically, we've already gone through this part, which is that you have a set of hashes, but we have basically EVM data manager, which listens to live events on contracts.
01:16:49.008 - 01:17:24.048, Speaker E: Whenever event happened, let's say a Mint happens, we pick that event up, it processes through our pipeline of transaction service. And when it ends up at this service, what it does is that it basically knows that a Mint happened and what was the transaction of that Mint. So it grabs the transaction details from the EVM chain, let's say optimism or Arbitrum or any of the chains. And then it uses those inputs, which would be transaction hash, block hash, token ID, and it uses the Mulberry 32, which is, again, open source algo. It inputs those values into the algo. And again, this is the algorithm. And then it outputs a number.
01:17:24.048 - 01:17:57.848, Speaker E: So the number can be whatever your collection size is. So let's say I just input a 20. If I input these transaction hash block hash, I'll get a number anywhere between one to 20. Given that number, I'll just use this list of hashes that creator wanted and just pick one of the transaction hash and use that hash for the art. A few key things about this whole process is that this algorithm is independently verifiable, which means that the algorithm is publicly available. The transaction is available on chain. You can basically run the same algorithm over and over and get the same output.
01:17:57.848 - 01:18:36.536, Speaker E: So even though it's running centralized, you're always free to just verify that you got the art that you were supposed to get. The second part is that we guarantee processing of events in order. What that means is if you minted a token first, let's say you got Token ID One and someone has got Token ID two. We make sure that the transaction of Token ID One gets processed or gets the art first, then the Token ID two. That's important because there is a point where a collision can happen. So let's say someone gets the curated hash number one, and another one got the one. So you want to make sure that the first one who is the valid recipient of the art gets it before the other one.
01:18:36.536 - 01:19:06.960, Speaker E: So this is basically two key details of our algorithm and how it basically assigns the metadata. So going back to it, I'm just going to forward through it for simplicity's sake. I'm just going to discard this. So I'll discard the select outputs. I'll go through the next step. This is, again, another one of the point where the creator can validate what they're actually trying to capture is actually equal to the live view. So this is the art being rendered in an iframe on the live view.
01:19:06.960 - 01:19:39.820, Speaker E: So it can be basically anything. Right now, it's a static image, but it can be moving image, but the preview image would be the one that's a PNG or JPEG or something. And that's what we capture at runtime. And these are the values that the creator has so they can provide a delay. So if your script takes longer to run, you can say, like, I want it to capture after 20 seconds. You can change those values, you can change the image resolution. And once you validate, the art is valid, you can go to the next step at this point ishan will come and talk about the details of the protocol.
01:19:40.960 - 01:19:41.592, Speaker D: Sweet.
01:19:41.656 - 01:19:46.364, Speaker F: Thank you. Saurabh all right.
01:19:46.402 - 01:19:46.652, Speaker C: Yeah.
01:19:46.706 - 01:20:07.408, Speaker F: So we ran through all the generative art stuff. Now let's deploy the damn thing. So we're going to just configure a bunch of details about the collection. Configure details about the mint. You can deploy this collection on a bunch of EVM chains. We support Five right now, but we're going to keep adding them for this mint. We're just going to go with Goreli.
01:20:07.408 - 01:20:56.116, Speaker F: Yeah, you can basically customize, like, whatever you want about the contract, add it to the filter registry, whatever you want. We'll just put in some dummy values for this swadaloo 2023, upload a custom logo that represents the collection. And you can also make the tokens on the collection non transferable. And the way that this works is that the collection that you deploy is highly modular. So you can swap in pretty much any behavior you want to define how the NFTs on your collection operate. So coming here, the collection that you actually deploy basically can refer to a bunch of modules. So almost anything that you want about the collection that you want to modify, like the behavior you can.
01:20:56.116 - 01:22:14.590, Speaker F: So whether that's burns transfers, how the metadata is rendered, how the metadata can be updated, how the royalties can be updated, how the NFTs can be minted, you can have your own custom smart contracts or use some of our modules and then swap it into the collection, and then swap them in and out, remove them, that sort of thing. So a couple of interesting things about this is one, because you're swapping in essentially your own code, you can introduce any behavior, right? So any conceivable logic on chain, you can swap it into your collection. So that takes collections from having you being able to configure stuff about the who, like who can mint this NFT, or who can update metadata to who, what, where, when, right? Because you're writing custom code. Another thing about these modules is they're what we like to call composably autocratic, which means that they can define their own behavior about if they can be swapped or if they can be removed. And a second order consequence of this is that creators and collections can define a path to gradually decentralize the collection. So like an example of this is, let's say when we first deploy this collection, we have a really simple module for the metadata. The metadata is frozen, nobody can update the metadata and only the owner can swap this module out.
01:22:14.590 - 01:22:57.740, Speaker F: And then the mint happens. All the NFTs are distributed, maybe to each one of you, everybody owns an NFT and then the owner can swap this module out for a more decentralized module, right? So module two now says that if all the holders of the NFT on the collection vote on updating the metadata to something of their choice, they can, and also maybe if they vote, they can also vote to swap the module out. So you've not just decentralized who can update the metadata, but you've also decentralized who can define the behavior of who can update the metadata. So it's kind of like a meta decentralization and then yeah, maybe after this they vote to also swap this module out for an even more open module.
01:22:58.480 - 01:22:58.844, Speaker C: Yeah.
01:22:58.882 - 01:23:08.028, Speaker F: So here's like a really quick sample implementation of what a module looks like. This is solidity, if you're familiar, I'll zoom in just because might be a little small.
01:23:08.194 - 01:23:08.524, Speaker C: Yeah.
01:23:08.562 - 01:23:28.500, Speaker F: So can update metadata. Like this example implementation, what it says is all the holders of the NFT. If like over 50% want to update the metadata to something, they can also they got to do it before a certain time. That timestamp is also an Easter egg. It's a Unix timestamp. First one to figure it out. I don't know, I'll give them like that amount in GWe or something.
01:23:28.500 - 01:23:45.176, Speaker F: But there's also can swap can remove itself. So this is like the composable autocracy part. So in this example, implementation, this module is fully locked in. Like this behavior is locked into the collection. And then finally you can define behavior about transfers.
01:23:45.208 - 01:23:45.356, Speaker C: Right?
01:23:45.378 - 01:24:10.236, Speaker F: So, like here we wanted to make our collection non transferable. So all the tokens are in this case, consensually non transferable. Sweet. So coming back to the collection creation. All right, so final page before we deploy the collection. Now we're going to define the mint details. So you can sell each of these tokens at a fixed price, or you can use a Dutch auction, which is a schedule of decreasing prices.
01:24:10.236 - 01:24:32.680, Speaker F: But we'll keep it simple. We'll go with the fixed price. Maybe we'll make it free. You can define kind of all these mid parameters. When it starts, when it ends, maybe only let each person mint two tokens. And then something really interesting we have here is we have this idea of gated minting. So you can create kind of these really complex gates that restrict who can actually mint on the collection.
01:24:32.680 - 01:25:13.664, Speaker F: So let's create a gate, call it demo. And you can add like a bunch of these conditions. So maybe the first condition we want to add is only holders of board Ape with a certain metadata attribute can mint on this collection. So we can go to this condition, come to the board ape, kind of OpenSea collection page, paste that in maybe, I don't know, board Apes with a purple background can mint on this collection. And then we can add another condition, like holds a minimum amount. So you have to own that board Ape with a purple background. And you have to hold a minimum of two ethers.
01:25:13.664 - 01:25:20.468, Speaker F: So it's very elitist mint. But we can change this to all. So you can switch between like an or clause and and clause.
01:25:20.644 - 01:25:20.936, Speaker C: Yeah.
01:25:20.958 - 01:25:43.570, Speaker F: And so we can just create this complex gate. Now the gate is applied to the mint. So the way that our mint works is creators can actually gaslessly swap this gate in and out. So this is a good summary of our mint architecture. This is what it looks like on chain. The mint module is a smart contract. The collection is another that's the one that's the smart contract we're going to deploy for you guys.
01:25:43.570 - 01:26:18.344, Speaker F: We have this concept of Mint Vectors. So Mint Vectors are just like different ways to mint on the collection. So you can paralyze a bunch of different sales, right? So you could have a mint vector that's like only board ape holders can mint at this for a free price, you could have another Mint vector that's going on at the same time that's like for a public Mint. So it's analogous to mint phases on a normal collection. So at the top left, you see the user comes to highlight they want to Mint on the gated Mint. We evaluate their blockchain account, make sure they can actually Mint on the collection, and then we construct a key. We pass the key into the module.
01:26:18.344 - 01:26:50.858, Speaker F: We unwrap this on chain with EIP seven, one, two, and then we Mint on the collection. And because these vectors are off chain, the creators can actually come in and kind of edit the Mint config without a transaction. So that's like a nice detail for them. Sweet okay. So I think we've configured the mint. We can just review everything that we've created and then deploy this collection. MetaMask is going to pop up.
01:26:51.024 - 01:26:53.260, Speaker C: Sweet okay.
01:27:04.590 - 01:27:33.110, Speaker E: Yeah. So once the bin is actually deployed, we're just going to quickly go through I think we're running out of time, but we'll just quickly go through the actual Mint page. So if you land on the Mint page, basically we've done full circle where we started from. You have the actual art. You can mint it because it's a gate. I don't think I have that much either. So I'm just going to go ahead and remove that gate, which kind of serves as a purpose to show that.
01:27:33.110 - 01:28:05.710, Speaker E: So I go ahead. It kind of happens in a gas plus way, so I'm just going to go ahead, save it. And once that's done, I'm just going to go back to the Mint page and I'll be able to mint it again. Same process. Once you mint it, you go through the transaction, it captures the attributes. And just to round it off, the way it happens is we have a rendering engine and metadata logic. Again, when the transaction happens, we capture the transaction values, whether the capture details.
01:28:05.710 - 01:28:47.374, Speaker E: It goes to a rendering engine which runs Chrome headless, and it relies on the attributes and capture preview. It outputs image, URL animation, URL attributes. And at this point, what we do is basically we take these attributes, we upload them to RV for decentralization, and then we upload them to s three. The way we do dual upload is basically we want to keep updating the tokens, but anyone can verify that what values that are on chain, they stay on chain and nothing from the centralized server changes anything. So we do a dual upload so you can verify anytime the metadata of the token. But yeah, so that's basically, again, the capture happened. It showed the image and it went through it.
01:28:47.374 - 01:28:55.874, Speaker E: But yeah, at this point that was just basically a demo. But we'll talk about there's a competition that we're running and Asian will talk more about it.
01:28:56.072 - 01:29:25.834, Speaker F: Sweet okay, so we're almost done. We'll take questions, but real quick before you take questions. So we're running a competition for the hackathon. There's $5,000 in prizes. You can win up to 3000. It's really simple. All you have to do is just we'll give you access to our beta platform, which you can find this form on the ETH Wadulu website, but just make a Generative Art collection with the same flow that we just ran through.
01:29:25.834 - 01:29:55.910, Speaker F: We're going to judge you on creativity, kind of any cool thing that you put input in there. And also we talked about the composability of the protocol. So if you want to introduce your own modules, if you know Solidity or you can use our modules, you can get creative with it. You can win $3,000. And also the winner of this competition is the official ETH Waterloo NFT. So whoever wins your collection, we're going to distribute your NFT to all the attendees at the end of the sackathon.
01:29:56.490 - 01:29:56.854, Speaker B: Yeah.
01:29:56.892 - 01:30:05.340, Speaker F: And if you go to this page, if you're new to Generative Art, you can kind of learn how to do it. You can get a collection set up in like 5 minutes. It's pretty simple.
01:30:06.190 - 01:30:07.050, Speaker C: Sweet.
01:30:14.990 - 01:30:18.080, Speaker E: Any question if someone has any?
01:30:19.650 - 01:30:20.400, Speaker C: Sorry.
01:30:25.290 - 01:30:27.720, Speaker E: Yeah. Which part?
01:30:28.090 - 01:30:41.940, Speaker C: This one. If I want to programmatically, like how? Like.
01:30:45.930 - 01:31:20.376, Speaker E: Yeah. So basically if you go back to our Tools app so let me open it up, you have a demo that you can download. So it's basically an example project and you can actually let me open it up. But what it looks like is basically this file. So you have index HTML. I'm going to open it to the text edit. So basically it's a sketch JS file.
01:31:20.376 - 01:31:39.940, Speaker E: As a creator, you can have a sketch JS file. I think I can open it. Yeah. So it's a sketch JS file. It calls highlight token, but you can take a look at how it calls the highlight token, but you download the demo. It calls the capture, preview and set attributes, the one we talked about. And that's what captures the image and attributes.
01:31:41.720 - 01:31:43.220, Speaker F: Generating cards.
01:31:43.560 - 01:31:44.710, Speaker C: Can you have like.
01:31:47.400 - 01:31:54.952, Speaker E: Can I have what? Based on text. Oh, based on text?
01:31:55.006 - 01:31:55.176, Speaker C: Yeah.
01:31:55.198 - 01:32:17.320, Speaker E: So we're adding those capabilities, but right now it's just basically either any open source script that you can use, p five JS or something, but yeah, we'll add those resources soon, but we can talk about it more. Yeah, so those are the things that we're introducing in our next build. So right now this is basically.
01:32:46.180 - 01:32:46.544, Speaker C: Is.
01:32:46.582 - 01:32:47.264, Speaker G: He muted or not?
01:32:47.302 - 01:32:48.192, Speaker F: It's unmuted now.
01:32:48.246 - 01:32:50.450, Speaker G: Okay, check 123123.
01:32:50.840 - 01:32:52.660, Speaker F: Everyone ready for airstack.
01:32:53.560 - 01:32:58.084, Speaker C: All right, there you go. Let's just wait for people.
01:32:58.122 - 01:33:01.940, Speaker G: Get in 3 minutes. When I say air, you say stack.
01:33:04.060 - 01:33:04.872, Speaker A: Let's try it again.
01:33:04.926 - 01:33:08.280, Speaker C: Air. Put her on there, buddy.
01:33:24.650 - 01:33:26.600, Speaker G: The screen itself does not be that simple.
01:33:29.050 - 01:33:32.630, Speaker C: System display.
01:33:44.400 - 01:33:47.150, Speaker D: Yeah, still zoom here also, right?
01:33:48.880 - 01:33:57.838, Speaker F: Better? Is this better?
01:33:58.004 - 01:33:58.720, Speaker C: No.
01:33:59.890 - 01:34:11.598, Speaker D: Editor and what about the Internet? Yeah, that's the Internet. That's Internet.
01:34:11.694 - 01:34:20.064, Speaker C: That's not it can work.
01:34:20.102 - 01:34:24.130, Speaker D: With that. How is this?
01:34:29.870 - 01:34:36.250, Speaker C: How's that's?
01:34:40.080 - 01:34:41.868, Speaker G: I'll start then he's gonna do most of it.
01:34:41.874 - 01:34:45.390, Speaker C: Yeah. If you can just once I give it to you. Just put it here.
01:34:46.080 - 01:34:47.590, Speaker G: All small.
01:34:51.080 - 01:34:52.070, Speaker D: Is it?
01:35:30.690 - 01:35:31.166, Speaker F: We're good?
01:35:31.188 - 01:35:33.534, Speaker C: We're fine. Yeah. All right.
01:35:33.572 - 01:36:25.786, Speaker G: Hi, everyone. I'm Jason and this is Sarves from airstack. Today we're going to show you how to build applications using airstack. How to use the APIs high level. First of all, airstack is a single API that enables you to query and combine data across chain cross project in a single query and response. We have APIs today that blockchains Ethereum, polygon every transaction since the Genesis block and new transactions within a few seconds as they're finalized, as well as very strong in areas such as identity. So ENS Farcaster lens poops NFTs Socials A lot of projects are using airstack for identity resolvers, for creating recommendation engines, for doing all sorts of new types of data ware experiences.
01:36:25.786 - 01:37:06.662, Speaker G: Sarvish is going to show you exactly how to use airstack and what the APIs are involved. I'm going to show you first the cheat codes really quick and then Sarvish will go into actually the details. But if you go to app airstack XYZ, you'll see a marketplace first of queries that other people have run and have shared with the community. So after you run a query, if you want, you can share it. So here are popular queries such as recent transfers of Dai token, metallics balance of Apecoin, a bulky NES query that Sarbash actually ran. And the cheat codes I'll show you is sarbash is going to show you how to write queries from scratch. The cheat codes is using our AI generator to write the query for you.
01:37:06.662 - 01:37:32.674, Speaker G: I actually recommend trying it to start because it's a great way to very quickly learn the APIs. If you look at on the left hand side, these are all the APIs that airstack offers. And I can write a query that is cross chain, cross DAP. And the AI will write the query for me. So I can say, show me all holders of orange dow. And we have a chooser. You can select it from about 10,000 different tokens poops NFT projects.
01:37:32.674 - 01:37:59.738, Speaker G: Orange dow is on Polygon and I can say and their web3 Socials and ENS. And the airstack AI will generate this query for you. And so here you can see it's putting in get token balances of this contract address. It's looking on polygon. It's getting the first ten. You can increase the number of responses. And for each person it's getting the token balance that they have, the owners, their domains, primary domains and their socials.
01:37:59.738 - 01:38:48.750, Speaker G: And so here, since we see that orange dow, this token holder, his lens name is Byron Sue Lens. You can see his ENS names and you can see this for the next person, next person, next person. So it's a great way to learn how to use the APIs I'll do one other just to show you is you can also do this like in all sorts of different directions. So I can say for Stani Lens, show his NFTs and their images. And so here we're combining, we're getting Steiny Lens. As you know, obviously he's the founder of Lens, that's an address on Lens that's on polygon, resolving that to a zero x address. Then we're going looking up all of his NFTs and also getting images which we've resized so you don't have to go out to IPFS and get them yourself.
01:38:48.750 - 01:38:58.900, Speaker G: So here is stani's NFTs as example. So let me hand over to Sarvesh though and he'll give you an entire tutorial about how to use the APIs. Over to you sir.
01:39:17.290 - 01:39:50.158, Speaker D: Okay, so I'll use next couple of minutes to go through what's currently possible with Airstrike APIs. And then I'll cover a couple of use cases that you can build with the APIs right now. So in this diagram you can see we are currently live on ethereum and polygon chain. And on the left side we have like most basic building block of any of the blockchain based projects. So we have all the tokens NFTs balances and transfers for NFTs, we have off chain metadata and resize images. We have whole vertical on identity. Like this is where lot of people are integrating Airstrike.
01:39:50.158 - 01:40:18.214, Speaker D: So you can query all the ENS domains and their primary domains. We have lens and forecaster. You can query Poaps with Airstrike right now. And then on the last side we have sales data coming from NFTs. So we have sales from OpenSea, Blur and Darable. We also aggregate this sales data on specific NFT level or a collection level or a marketplace level. And this aggregation runs on different timelines, like daily, weekly, monthly, yearly and lifetime.
01:40:18.214 - 01:40:53.874, Speaker D: So this slide is a basic summary of what you can build today with Airstrike in this hackathon. And these are like couple of use cases that we feel it's very easy to build on Airstrike right now. This is not an exhaustive list you can add because Airstrike is a general purpose product, so you can add more to it. But to go through, the first thing is identity resolver. So I'll build a couple of queries from this use case, I think three or four of them. But if you have any zero x address or any ans, you can actually ask about the Lens for caster co ops NFTs. So this is an identity resolver.
01:40:53.874 - 01:41:20.014, Speaker D: Similarly, you can build groups if you are building like a chat application and you want to figure out what are the groups you should build. So you can build groups based on NFT holders or the Poops, the event that attended together. So this is possible. I'm going to build this recommendation engine today. So a simple recommendation engine based on Poop. So if you have a Lens profile and you need to recommend what other lens profile that profile should follow. So based on similar events you attended, I'll try to build a recommendation engine today.
01:41:20.014 - 01:42:08.574, Speaker D: Definitely token balances transfer history, token getting is very much possible. So you can use token balances API and put a wallet and a token address and check whether the wallet has a token or not. This new thing that we are looking into how airstack can be used for ZCAS association so you can prove what's on chain truth and so airstack can be source of truth and then you can generate proof and validate with some other protocols that's here today. And one more area that we are looking into to build very awesome visualizations on top of airstrike. So we have a lot of data on NFT sales and ENS and Poop so you can actually build a visualization like find me the common wallets who attended each ranveer in each Waterloo. A lot of those visualizations are possible. I'll go through a couple of use cases I'll prepare like the queries that I'm going to build.
01:42:08.574 - 01:43:04.174, Speaker D: So I'll start with very simple query. I want to build a token getting use case so I want to build like token balances along with NFT images and metadata. So I'll go here on the wallet. Yeah, so here I have all the list of the APIs but for token getting I want to build with token balance. So I'll select the token balance I will filter based on a wallet so I will select this as a variable and I will select all the fields that I want as an output. So definitely I need amount and because I'm fetching balance so I need to query name and symbol and if the balance is of NFT then it also makes sense to ask about any images or metadata it might have. So I'll select those fields and yeah, from the token I should also select address and token ID.
01:43:04.174 - 01:43:32.662, Speaker D: Right, these are all the fields that I'm going to use for the query. Now let's go to the filters part. So we have very complex set of filters that is allowed. So you have and or Nor in clause. So all the clause you have used in anysql or any database programming language, those kind of filters you can build in airstrike APIs. So I'm going to add filter on owner right now and so my query is complete. Now I'll add a variable so it autocompletes.
01:43:32.662 - 01:45:20.780, Speaker D: Okay, so just a second, let me just reload it. Yeah, now it loads properly. Quickly build the same query again, select amount, token, address, name, symbol from the NFDS I will select images. Yeah, I will rename my query variable to something more meaningful so I will name it identity and I will put it here in the variables then. Now it should be able to tell me it's a little bit weird. Sorry about this. I'll just use this one.
01:45:21.390 - 01:45:22.140, Speaker C: Yeah.
01:45:25.790 - 01:45:59.910, Speaker D: Okay, we are ready with the query. So let's say first I want to build token gating and I want to fetch balances based on ENS name. So I just put an ensalix so that's possible. If you are integrating with Lens or Lens then you can also put a lens profile here. So you can also query based on Lens profile you can get the same result. Definitely you can put a wallet address. So I'll just select my wallet so that's possible too.
01:45:59.910 - 01:46:34.574, Speaker D: Now let's say you're building token getting so not just owner but you also want to add a filter on token. So you will add a filter here and you can just put your token address. You see like I have the token so this query can help us help you build the token getting applications. I'll go to the next use case. So next use case is more about identity. So you want to figure out holders of Moonbirds collection and along with you want to know about what are the social profiles and the primary NS of those holders. So holders are returned from the token balance.
01:46:34.574 - 01:47:13.790, Speaker D: So I'll again use the same kind of query and again the token address is Moonbirds for me. So I will change to the moonbirds. I don't care about owner right now because I'm looking for all the holders so I will remove that. Okay, now I am interested in social profiles of the owners. So in the owners, the owner represents a wallet and you can ask any question about the wallet from this field. So you can ask social profiles, I'll select the DAP name and the profile name. Similarly you can select ENS domains.
01:47:13.790 - 01:47:54.150, Speaker D: We also have primary domain if you are interested in that. So this completes the query, you can just run it so it gives you all the holders of Moonbirds and it will also give you all the domains and primary domains of those holders. Let's see some of the interesting data points here. Okay, one more thing you can add ask for 200 records in one go. So initially by default it takes ten. So I will add 200. So you can see you're getting lot more records.
01:47:54.150 - 01:48:34.182, Speaker D: You can see right, this Moonbird is being held by this lens profile who has this ENS and this is also a primary ENS for him. So you can resolve lot of identities with this combination. Okay, now last two queries are more like a recommendation engine that I'm trying to build today. So the use case is I have a lens profile and I want to know what all event I have attended. That's first part of the query and the second part is from one event that I have attended, I will figure out what are the other lens profile who has attended same event. So I'll build the first one. So the first query is to get the lens profile.
01:48:34.182 - 01:48:47.870, Speaker D: Given the lens profile find the Poops. So because I'm querying on Poops, I need to go to the Poops API and my input is a lens profile. So that's an identity for me. So I will select owner.
01:48:49.570 - 01:48:50.320, Speaker C: Right.
01:48:50.690 - 01:49:18.440, Speaker D: Then from the Poops, I will fetch some details about the Poop event itself. So the description and the name of the event. Yeah, so this is complete. If you want we can change like these variable names. These are not that good, but I'll just keep it same right now. Okay, so this is my lens profile and I can also select event ID.
01:49:18.590 - 01:49:19.290, Speaker B: Yeah.
01:49:23.180 - 01:50:23.526, Speaker D: Okay, let me just see what happens here. Let me try putting here. So I will ask about the event, I'll select some more fields name of the event. I can just run this query. So you can see I have attended these events. One of those event is ETH Denver 2023. So the event ID is 1030 93.
01:50:23.526 - 01:50:39.654, Speaker D: So I'll just remember this one. So here the input was a lens profile. So I could see this lens profile has attended this event. Now in order to build the recommendation engine, you need to also figure out what other lens profile has attended the ETH Danver.
01:50:39.702 - 01:50:39.914, Speaker C: Right?
01:50:39.952 - 01:51:19.602, Speaker D: So that's my second query. So fetch web3 socials and primary DNS of the people who attended ETH Danware. So this time again, I'm in poops API. But this time I want to filter based on event ID and the event ID of ETH Danver. So I will use this event ID that I got in the past query and I'll put it here. Now in this case I want the lens profile of the attendees, right? So I will go to the owner and I will select the socials and I last DAP name and the profile name. If I put it here, I get the lens profile.
01:51:19.602 - 01:51:53.966, Speaker D: So not everybody has a lens profile. But I can also select the identity and user addresses. So it will give me the wallet address. At you can, you can see this lens profile also attended East Denver. So if you are building any application which has a social angle, you can actually build a recommendation engine with this kind of queries. I can also add more records to it so you'll see more data coming. So there is also one profile on Forecaster who attended the East Denver.
01:51:53.966 - 01:52:43.714, Speaker D: So combining these two queries I can build a simple recommendation engine where I'm finding people based on the same activity on Poops. Okay, let me showcase couple of more queries. I want to showcase this bulk social query once. Okay, so we have this wallet API, and we have social API. So sometime you have a use case where you want to ask for more than one wallet. So you want to look up for 100 such wallets, right? So here we are using something called in clause. In the in clause you can pass array of addresses in one go and you can select so in this query I'm putting like I'm finding based on some identity.
01:52:43.714 - 01:53:18.462, Speaker D: So the identity here is a wallet address. So I have 100 wallet addresses and I'm asking for social profiles for those wallets. So I'm getting all the results in one query. So you can ask about like in bulk of 200 profiles in one go along with this if you're building your apps. So we currently have two SDKs react and Python. I can quickly showcase how SDK looks like and how you can add these queries to SDK and get the data. So this is a python SDK.
01:53:18.462 - 01:54:00.910, Speaker D: So you need to first install the Python SDK and once you have the SDK you need to import necessary files. So Airstrike client is a class that we export and in any of the SDK you will need an API key to integrate. So in order to get the API key you will go to the profile page. So here I have a profile. In the profile you will get your API key, you will copy this API key and you put it in the SDK and any query that you would want to run, you build on the query builder and you put it here. So you'll initialize your query. The next thing you'll do is you will create a query object and you'll just execute that query.
01:54:00.910 - 01:54:41.930, Speaker D: So in this case you can see I have poops query already created here for service lens and you can see each query response give me two things, an error object and a data object. So if error is none, you will get the data and you can just use it. Sometimes you are building an application which requires lot of data and one API cannot give you all the data. So you need to use pagination. So in that case SDK provides you two boolean flags in the query response that is next page and previous page. So if you have a next page in your query response you can ask for the next page again here. So this will give you the second page.
01:54:41.930 - 01:55:23.626, Speaker D: Similarly, if you want to go to the previous page then you can again go to the run the previous page method. So I built this small utility function where you can just pass Airstrike SDK client, a query and variable. What this function is doing, it's executing the query, it's collecting the response and it will keep on doing it till it goes to the last page and as soon as it gets the response it will return it in one. So this way you can actually integrate any of the query into SDK. So because the SDK is general purpose, you just need to work on the query part and put your variables here and you will just run it and it will give you the response like.
01:55:23.648 - 01:55:24.220, Speaker C: This.
01:55:29.900 - 01:55:34.890, Speaker D: Yeah, I think this is it. These are the use cases I wanted to cover.
01:55:35.280 - 01:55:54.850, Speaker C: Yeah, thank you for talking. If you wanted to query based on all of the NFDS generated from minted by one contract based on the properties of these NFDS. Can we only get it from one contract and then query from the properties of those?
01:55:58.860 - 01:56:44.312, Speaker D: So for NFTs, you will be able to query based on so the token represents the collection here. So you will be able to query based on let me select the tokens API here. So you will be able to query based on address, name, symbol and type. Yeah, you can put the address of the contract and ask it. And we have one more thing that I want to showcase. So in the token NFTs, if you want to query specific NFTs of a contract and you want to query based on traits. So something which has a background color green, right? So you can basically go to the attributes and you put, like, trade type is background color, and you put the value as green.
01:56:44.312 - 01:56:50.372, Speaker D: Right. So it will only give you the NFTs of that collection who has that background. Yeah, custom properties.
01:56:50.436 - 01:56:51.050, Speaker C: Right.
01:56:55.680 - 01:57:06.240, Speaker D: From Genosis, we only have Poops right now, poops. But for Ethereum and Polygon, we have all the data from Genesis to the live blocks.
01:57:06.740 - 01:57:24.148, Speaker C: For example, can we get information at certain ENS? How many postings the person has done, how many have been minted for the particle? The problem mirror is so we can.
01:57:24.154 - 01:58:04.000, Speaker G: Get you the enslave person, we can't get you their mirror. Yes, we have five $2,000 prizes. The first three are just for our three favorite projects. Build anything you want on airstack. There's lots of ideas in our notion, and then we have a $2,000 prize. Specifically, if you build something that makes use of airstack and Xmtp or AI or Attestation, and Xmtp is specific. We do a lot with a lot of Xmtp projects are building with airstack.
01:58:04.000 - 01:58:40.248, Speaker G: No, we do not. Xmtp is an awesome way to message people with an Ethereum address and what they've been missing before airstack was a way to resolve, say, from a zero X address to an ENS or a lens or Farcaster, et cetera, et cetera. And so we've kind of teamed up together to make that possible. And so a lot of applications are making use of that. And so if you build something Xmtp, there's $2,000 from airstack plus another 1000 from Xmtp available. And then finally, if anyone just wants to build a unique visualization of airstack data. So if you see right now the response here is a JSON file.
01:58:40.264 - 01:58:41.196, Speaker C: If you want to build something that.
01:58:41.218 - 01:59:06.340, Speaker G: Is just a unique visualization of the response, that's another $2,000 boundary we have as well. And just to show you real quickly an example. We built a demo app you can look at on demo airstack XYZ, which is just a front end to, I can say, put in any lens, Farcaster, ENS, et cetera. And it's pinging the airstack APIs and giving a visual response rather than the API response.
01:59:06.760 - 01:59:08.340, Speaker C: Those are the five bounties.
01:59:12.600 - 01:59:13.060, Speaker E: Exactly.
01:59:13.130 - 01:59:13.364, Speaker C: Yeah.
01:59:13.402 - 01:59:17.236, Speaker G: So if you check out an app called I can show you afterwards called Converse.
01:59:17.268 - 01:59:18.628, Speaker C: It's that get converse.
01:59:18.724 - 01:59:44.610, Speaker G: They have a recommendation engine. It's built on top of airstack, where if you click on a button that says who can I message? It'll show you everyone that went to the same events with you from Poops, everyone who you've sent tokens to or from your transfer history with airstack. So it's kind of getting past that cold start problem in Web Three and showing you people you know already based on chain data. Other questions, anyone?
01:59:45.460 - 02:01:22.592, Speaker C: All right, if you need any help, our Telegram chat is our team is there. So good. Okay.
02:01:22.646 - 02:01:23.970, Speaker A: Chudis up test.
02:01:24.980 - 02:01:30.370, Speaker D: Okay. Pardon me.
02:01:30.760 - 02:01:33.332, Speaker C: Yeah, just talk to me a little more. Hello?
02:01:33.386 - 02:01:35.524, Speaker A: Hello. Is that good?
02:01:35.642 - 02:01:49.788, Speaker C: You're good? And don't be afraid to speak up.
02:01:49.874 - 02:01:57.250, Speaker A: Appreciate it. Yeah. All right, I'm going to wait maybe a couple of minutes.
02:02:21.100 - 02:02:21.850, Speaker C: Oh.
02:02:33.360 - 02:03:14.070, Speaker A: Here we go. Dinner just got served.
02:03:14.810 - 02:03:15.800, Speaker B: Got it.
02:03:17.690 - 02:03:37.760, Speaker A: Tough, tough competition. Maybe we can, like, snipe some people in line because the line's long. I don't know. Anyway, cool. All right, thanks, guys. Thanks, everyone for coming. I'm York.
02:03:37.760 - 02:04:20.766, Speaker A: I'm part of the engineering team at Hyperlane. And today we're going to talk about permissionless, interoperability, and what that means. If you have questions afterward or if you want help with integrating hyperlane in the hackathon, definitely come up to our booth, or you can ask me questions at the end. So just to start today's session, I think we need some definitions of the title slide. So permissionless, I think a lot of people throw that term around. It's kind of like at this point, used for marketing. But generally the word permissionless means that a protocol is accessible to anyone.
02:04:20.766 - 02:05:31.246, Speaker A: There's no kind of discrimination or censorship for specific classes of users to access a protocol. And Interoperability, I think our definition that we can use today is composability for applications that are on different infrastructure layers. And so the Internet is highly interoperable because we have all these shared protocols that are quite permissionless. We have Http, TCP, et cetera. And in Web Three, we're just starting to establish kind of these shared standards that allow applications to communicate with each other. But the problem we see today is like, the crypto space is facing this scalability problem, and people have kind of identified this as the barrier to adoption for the next billion users. And there's all these great teams at hackathons like this building out these new scalability solutions to onboard that next set of billion users.
02:05:31.246 - 02:06:23.750, Speaker A: But the problem is we're ending up with these kind of highly divergent infrastructure layers that don't actually use shared protocols to communicate with each other. And that leads to a big problem. I think if you look at the evolution of crypto, we've continued to diverge with respect to what protocols we use. I think maybe the first decade was just bitcoin payments, like a very simple application. And then we kind of evolved to these smart contract VMs and that got a little more complicated. And we saw Ethereum and Nier and Solana all popping up with different protocols. And then some people got excited about app chains because there's different scaling properties that you can have if you don't opt into this monolithic infrastructure layer like Ethereum.
02:06:23.750 - 02:07:02.654, Speaker A: More recently, we're seeing Ethereum kind of coalesce around the roll up scaling roadmap. I think Vitalik had like a seminal blog post about that. Arbitrum and optimism now do more daily activity than Ethereum l One. And these protocols also kind of have their own new standards. There's these new DA layers that are in service to those roll ups. So we have Ethereum 4844, this EIP that kind of changes the cost structure for posting call data to l One. We also see Celestia.
02:07:02.654 - 02:07:28.700, Speaker A: It's this new modular DA that maybe app chains can post call data to. Again, a lot of different kind of diverging protocols. Maybe in the future we'll see some sort of like plasma or sharding solution. I think there are probably some teams here working on that. I don't know what happened to my slides. Oh, there we go. But, yeah, this is a problem.
02:07:28.700 - 02:08:36.270, Speaker A: On the flip side, looking at this from an application perspective, we're seeing a lot of DApps actually adopt these new infrastructure layers, which is like, super exciting. So actually, just like a couple of days ago, zora, which is like this big kind of NFT social Feed and Explorer application that is one of the most popular applications on Ethereum, announced that they're going to be rolling out their own layer two using the optimism op stack. I think you guys have probably heard of like, Coinbase's efforts to work on their own L2. They launched Base Testnet a couple, I think, like maybe a month or two ago. If you look at this website, l Two Beat, you can see kind of the evolution of activity over time across these different infrastructure layers. And what you'll see is that actually a majority of activity has migrated to l Two S. And so we need a way for these applications to communicate with each other.
02:08:36.270 - 02:09:22.170, Speaker A: And the problem today is we have a highly fragmented market. So we have arbitram, optimism. Kind of the two main leaders. I would say ZK. Sync It's like the fast follower. They launched the first validium So people are super excited about that. And as an application developer, when you're choosing what roll up to deploy your application on, it's a really hard choice because you have to think about what's the security story of this specific roll up? What does the current ecosystem look like? Is there enough liquidity? Are my users going to be stuck here if the platform decides to change their terms of service? Or maybe they're going to censor users based on like OFAC or something like that it's a really tough choice.
02:09:22.170 - 02:10:08.474, Speaker A: There's all these different interfaces for interacting with these things. So, for example, Arbitrum, Optimism, Zksync all have different smart contract interfaces for handling deposits and withdrawals from L One to L2 moving assets between different L two S. There's kind of also highly fragmented, like bridge solutions. So depending on what applications are, where there's different bridges available. And then more recently, we're seeing these kind of general message passing protocols to move arbitrary information between L two S. Pop up. Hyperlain is an example of this, but again, there's just like all these things to account for.
02:10:08.474 - 02:10:47.158, Speaker A: And as an application developer, you have to kind of know about all these interfaces and you have to custom integrate every single one of these new roll ups, new infrastructure layers. And that's just like a really bad place for us to be in. Actually, just this week, Vitalik posted about this. So, like super topical. Vitalik's, like, all in on roll ups being the layer that applications should build for. And he wrote a blog post about kind of what the solution space looks like for interoperability between L two S. And I highly recommend this post.
02:10:47.158 - 02:11:47.530, Speaker A: I don't know what's going on with the connection here. Yeah, I highly recommend this post, as well as the three Transitions post, which talks about kind of this evolution of scaling solutions and how we can actually get users to adopt these things in a way that's Internet scale. But yeah, what's the solution to this problem of fragmentation? At Hyperlink, we think it's modularity. You may have heard the term modular blockchains. It's also a heavily used marketing term at this point. But the main idea is you want to separate the interfaces which are exposed to applications from the actual underlying transport layer stuff. So if we have all these roll ups that have different kind of security properties, I think the three kind of examples we can work with in our head are like, Arbitrum, Optimism, and Zksync.
02:11:47.530 - 02:12:55.300, Speaker A: All of these roll ups have very different kind of security stories, like when you can view them as settled, what the finality looks like, can you use soft confirmations, et cetera. And as an application developer, you shouldn't have to think about that or custom integrate that. So instead we can have this universal interface that looks like a message passing interface. And under the hood, depending on the path that we're taking, we can actually leverage different underlying transport layers. But the application developer shouldn't have to necessarily understand that. There should just be kind of like a community governed set of standards for like, okay, if we're going from L One to Optimism, we're going to use this specific transport layer, which is like the Optimism bridge to collateralize my deposit. But again, the application developers shouldn't need this crazy switch case statement of if this network do this specific function call.
02:12:55.300 - 02:14:29.790, Speaker A: So that's where Hyperlane comes in. Hyperlane is. This kind of like universal interface that tries to abstract all these different bridging interfaces through what we call this general message passing interface. So as an application developer, all you need to understand is this dispatch interface and this handle interface. So I can walk through kind of the lifecycle here, but your smart contract or your EOA for that matter can call into this interface called dispatch, which basically specifies a destination blockchain via like a chain ID, a recipient address on that destination chain and just like an arbitrary body of bytes, raw bytes. And behind the scenes our protocol will handle the transport layer stuff and then on the destination chain, basically the handle function will be called on the recipient that you specified and that will also provide the origin chain sending address on that origin chain and the body that that sender sent. And now obviously as an application developer, you want kind of strong guarantees around the content and kind of like validity of messages that you're receiving or messages that you're sending that they're actually going to get delivered.
02:14:29.790 - 02:16:05.630, Speaker A: I'm happy to kind of talk about the different guarantees that we have for different pathways. But generally because this is a hackathon, I think it's better to sometimes avoid those nuanced discussions of what the security trade offs are and just try and build something which is useful or demonstrates a new use case. But yeah, the idea again with modular interoperability is as an application developer we actually have this interface where we allow you to configure your security preferences and your risk tolerances. So we have this interchange security module interface that as a message recipient, you actually just configure as an address if you opt into this configuration layer. And the idea is when you're receiving a message, our protocol will ask you, hey, what is your security module mechanism of choice? We provide a bunch of off the shelf components that you can kind of select from and compose for the various channels. So like optimism, canonical bridge or using wormhole or whatever it is, our protocol will ask your application what security module you've configured for this specific origin and sender and body. You can actually have control flow on the message body which actually changes the security requirements.
02:16:05.630 - 02:16:37.450, Speaker A: And so an analogy, there is like wire limits in traditional finance. Like if you're just transferring $10 across two chains, you might not care so much about the guarantees that you have in your application and you might not want to pass those costs on to your user. But if it's like a million dollar transfer or if it's like some sort of governance action, then you might want to really ramp up the verification requirements.
02:16:40.190 - 02:16:46.474, Speaker C: When you say like security modules, that just generally means which bridge do you want to take?
02:16:46.592 - 02:18:01.646, Speaker A: Yeah, sometimes it's which bridge do you want to take? We think that bridge is like a loaded term. So there's also different flavors of security. You can opt into economic security versus reputational security or you can have certain gary I don't know why this keeps dying. So, for example, our default security mode for a lot of pathways is this economic security mode where we have a set of validators who are staking on the origin chain and they're producing these attestations of messages which are being sent from that chain. And as a recipient of messages from that chain, you can say, I want to leverage this economic security, which gives you a discrete cost to attack the system. And kind of it gives you a lower bound of like, hey, up to this, or I guess an upper bound up to this economic value on this specific message. I have kind of strong economic guarantees that this message was actually sent from this chain because otherwise the validators will be slashed.
02:18:01.646 - 02:18:45.540, Speaker A: It's kind of economically irrational and so that's like one type of guarantee you could look for. Alternatively, you could have these sorts of like, if you're using a canonical bridge, you have this fraud proof system where you can always kind of do forced inclusion or those sorts of things. But yeah, economic security is not the only mode we can do, like an optimistic security model, which is like a very different trade off. And it's actually like you can think about it as operating over the same bridge or the same tunnel, but just like, the security constraints that you're imposing on that bridge actually look very different. Yeah.
02:18:46.950 - 02:18:48.530, Speaker C: Who are the validators?
02:18:48.950 - 02:19:23.578, Speaker A: So right now we just have like right now it's like a whitelist, but we're really soon hoping to transition to a fully permissionless validator model where you can put up any staked asset, it actually doesn't matter what asset it is on the origin chain. And you're basically just like, producing attestations. It's kind of super easy to run because there's no consensus. The validators are not networked with each other. They're just producing attestations on messages that are being sent outbound. Just need like an RPC connection to a chain.
02:19:23.674 - 02:19:25.280, Speaker C: Do you know how many there are?
02:19:26.530 - 02:20:34.766, Speaker A: Depends on the chain. We have all the information in our docs if you want to check it out. The last thing I want to highlight is this modular security paradigm allows you as an application developer to eliminate this scary choice of being locked into a specific bridge or a specific security model or pathway for your users because you can configure this. And so in future, if some sort of, like, ZK lite client becomes available for some pathway, you can just configure that later on. And this is kind of like a way for you to again separate the application layer from the transport layer. And we think this is really important for just, like, application developers when they're reacting to kind of the evolution of all this infrastructure. They shouldn't impose those things on their user.
02:20:34.766 - 02:21:24.150, Speaker A: They shouldn't have to tell their entire user base, hey, we're actually migrating bridges, so you got to go and unbridge and then Rebridge and then migrate to our new version. That's crazy. So this is just like kind of the model that we think is better, and it's really a framework for how to think about interoperability. We obviously have specific opinions about what the default security modes should be. And as an application developer, if you don't specify your own preferences, you will kind of by default be opted into our preferences. But yeah, that's the modular framework. The last thing I want to highlight about this modular security paradigm with hyperlane is you can deploy hyperlane anywhere.
02:21:24.150 - 02:22:20.002, Speaker A: So we have a guide right now in our docs that walks you through all the steps. Right now it's only available for EVM networks, but we have several other environments that are pretty much like production ready. We're running on testnet on Solana. We have a fuel VM implementation. We're working on a Cosmos SDK module. So really we want to make this protocol and this framework available everywhere so that you, as an application developer, not only do you not have to choose a specific bridge, you don't even have to choose a specific execution environment if you're worried that later Solana might become might eat up all the DeFi market share or something. Hyperlane allows you to easily have your application exist across all these execution environments.
02:22:20.002 - 02:23:45.474, Speaker A: And maybe in kind of the near future, your users don't even know which environment they're running on because they just have this single interface into your application and you decide where it makes the most sense for them to get routed to. But yeah, the specific kind of thing I want to highlight here is now if you want to spin up your own roll up, which is kind of, I think, like we saw earlier, something that a lot of people are thinking about. There's this kind of traditional problem of, like, okay, you've spun your up, your roll up, but, like, it doesn't do anything because it's not connected to anything. There's no bridges operating to it, there's no liquidity, et cetera. And in the past, if you wanted to make those connections to existing ecosystems, you have to go out and you have to talk to organizations and kind of do BD and establish trust and ensure that the bridge that you're getting to come to your ecosystem isn't risky for your users and isn't going to just rug you or something. And now that you can deploy hyperlane and you can configure your own security, you don't have to do any of that. You can start as a new roll up.
02:23:45.474 - 02:24:21.150, Speaker A: You can operate your own deployment of hyperlan. And as you scale up and as you kind of progressively decentralize, you can continue to configure the transport layer with stronger and stronger security guarantees for your users. But to start out, it doesn't really make sense for you to impose those requirements before you launch your roll up. You don't want to require that there's like a full light client implementation across a bunch of different clients or something. You just want to be able to launch your application, test it iterate.
02:24:23.250 - 02:24:23.566, Speaker B: Yeah.
02:24:23.588 - 02:24:25.280, Speaker A: We think this is like a big yeah.
02:24:26.050 - 02:24:29.470, Speaker C: Do you guarantee that message actually get delivered?
02:24:30.230 - 02:26:15.090, Speaker A: That's a great question. So that's probably one of the biggest things that you need to understand when you are kind of building for this MultiChain future is the introduction of asynchrony and execution across many chains definitely introduces a lot of complexity and one of those complexities is we don't have strong guarantees of transaction inclusion at least today. So unfortunately the way our protocol works is you pay a fee on the origin chain which covers the gas costs on the destination chain of transaction inclusion, but if that destination chain's validator set is deciding to be mean or whatever, they can just censor you and then your hyperlane message won't get processed in future. We have ideas about basically building hyperlane messages into the block proposer auctions themselves. So we could have block proposers like potentially an eigen layer set being aware of hyperlain messages that want to be included for a specific block and we can have a more sophisticated fee market for message inclusion. But right now it just falls back to basically transaction inclusion, which is not something we have guarantees about today. So even as a user on a single chain, when you attach a fee to your transaction, you don't have guarantees that it'll actually get mined.
02:26:15.090 - 02:26:20.958, Speaker A: Just kind of like an assumption we make based on the market dynamics.
02:26:21.134 - 02:26:21.860, Speaker C: Yeah.
02:26:23.270 - 02:26:26.050, Speaker D: On a regular chain you can cancel transaction.
02:26:27.110 - 02:26:29.080, Speaker C: Is there kind of cancellation process?
02:26:30.330 - 02:27:23.080, Speaker A: That's a good question. So we don't have a native concept of cancellation or timeouts or ordering or anything like that. The core protocol is kind of very unappinionated in that respect. But there are middlewares that you can opt into which can kind of introduce basically timeouts or cancellation semantics to messages with the trade off being that you lose out on some composability because now applications need to understand that, hey, there's this header attached to Messages which defines some timeout or whatever. But yeah, that's a great question and something we honestly, I think should think more about.
02:27:24.330 - 02:27:25.080, Speaker B: Yeah.
02:27:28.330 - 02:29:07.130, Speaker A: So just to give a few examples of kind of like the developer primitives and tools that are available on top of this protocol for you guys to use that are maybe less intimidating than just this raw bytes pipe between chains, we have this warp route subtraction which should be familiar. It's like similar to traditional token bridging where you can basically just connect either canonical token or native token to a bunch of synthetics on a bunch of chains. Again, the kind of modularity of hyperlane allows you to evolve and configure the security of this warp route. So you could just as an example, which we've talked to with a lot of customers, or like a lot of customers are excited about this specific example of having application specific security. So if you're transferring on a warp route more than, let's say, 25% or 50% of all of the circulating supply on that chain, you might want some administrator in your application to actually function as a notary or veto or something, just to ensure that your application didn't get rugged by some bridge. And with the Interchange Security Modules, you can totally do that really easily. So you can have these different safety modes.
02:29:07.130 - 02:30:06.570, Speaker A: We just actually sent the first token transfer between the Solana DevNet that I mentioned earlier and the EVM. So that's maybe something you can play around with this weekend. We also, like I said, have been expanding to other ecosystems. So if you guys are interested in kind of some of those longer tail ecosystems, definitely be happy to chat. But yeah, this is just one abstraction. We also have this concept of Interchange Accounts and Interchange Queries, which, again, is like an API that, as a developer, you can use kind of simplifies some of this, like, cross chain control flow. So Interchange Accounts are basically a way for you to have a contract on one chain own assets or do actions atomically on another chain.
02:30:06.570 - 02:31:05.322, Speaker A: So basically, if you're familiar with the concept of, like, a smart contract wallet, this is like smart contract wallet for your contract on another chain. Basically, your contract on the origin chain can send calls to be proxied by its interchain account on some other chain and you can send assets to your interchain account. We think this is pretty useful, especially for DAOs. If you want to give ownership to some Dow that exists on another chain, you can just do that counterfactually without the Dow even opting into it. You can just be like, hey, Dao, I'm giving you this permission to your interchain account. Come and take me, or whatever. And so, yeah, this is kind of a powerful primitive for just managing assets on different chains.
02:31:05.322 - 02:32:05.314, Speaker A: You could do some sort of multi chain portfolio management type thing without actually bridging those assets, which is sometimes risky. And then the Interchange Queries API allows you to basically make cross chain view calls so you can go query a contract function on some other chain. Some examples of using this have been, like looking up ENS ownership or NFT ownership on Ethereum because there's a lot of, I guess, network effects on Ethereum l one. But people want to migrate their application ecosystems to other chains. So this is a way for you to kind of have remote views into other chains, state and networks. And that's it. I guess I'm almost at time.
02:32:05.314 - 02:32:46.250, Speaker A: Anyway, I can't really do the demo because my WiFi has been really struggling. But I would love for you guys to check out our docs. We have a message explorer with an API. We have $10,000 in prizes this weekend, so big opportunity. If you just want to use one of these APIs, you could deploy hyperlane to one of these new chains. You could try deploying hyperlane to Zora or Base or one of these new roll ups and have your application do something cool with that. I think we're also looking for people to use warp routes if you use one of these APIs.
02:32:46.250 - 02:32:54.020, Speaker A: Interchange accounts interchange queries I'm sure that would qualify. Yeah, that's it. Thanks for coming.
02:32:58.230 - 02:33:02.846, Speaker B: What? Okay, because this this is Ethernet.
02:33:02.878 - 02:33:08.760, Speaker A: So should have oh, this is Ethernet. Should have turned off the WiFi. I just heard you on the screen. Got you now. Good.
02:33:13.770 - 02:33:14.920, Speaker C: Is there another?
02:33:28.210 - 02:33:30.170, Speaker H: I really want to build on Hype.
02:33:30.330 - 02:33:33.310, Speaker A: Yeah. Should I build on polygon?
02:33:34.450 - 02:33:48.718, Speaker H: It's cool that you could connect. I'm super interested in the Dow use case because so many people's Dows are stuck on a specific chain harmony. Hopefully the stream wasn't on that one.
02:33:48.804 - 02:33:51.354, Speaker F: Uniswap was lol having a big debate.
02:33:51.402 - 02:33:54.600, Speaker C: About how they should so yeah.
02:33:59.370 - 02:33:59.846, Speaker H: Thank you.
02:33:59.868 - 02:34:02.440, Speaker E: You have to hold this in your hand then, because you don't have yeah.
02:34:02.810 - 02:34:03.560, Speaker F: So.
02:34:07.790 - 02:34:08.154, Speaker C: One.
02:34:08.192 - 02:34:08.538, Speaker D: One.
02:34:08.624 - 02:34:09.740, Speaker B: Yeah. So good.
02:34:25.330 - 02:34:50.440, Speaker H: Wow. It looks funky on my screen, but it looks good for all of you. That's all that matters. But hey, everyone, welcome to the last workshop of the day. So you can get to hacking soon, I promise. This is about gating your DAP with a Polygon ID verifiable Credential. So we'll be getting into Polygon ID, which is like an ID solution, and we'll talk about Verifiers issuers, all kinds of things.
02:34:50.440 - 02:35:11.822, Speaker H: This is polygon ID. I thought I had a oh, there it is. My slides got all mixed up. This is what I get for messing with them right before I'm going on. But GM, everyone. I'm steph or pilia? I'm a developer relations engineer at Polygon. I'm also Oceans 404 on Twitter if you want to tweet or anything or link up there.
02:35:11.822 - 02:36:00.720, Speaker H: But today I'm talking about polygon ID. And Polygon ID is really cool to me because it uses ZK proofs, and it lets users prove pieces of their identity with Verifiable credentials so that they can just present proof of a Credential rather than giving up their private data. So that works for things like birthdays, country of origin, and then any customizable use case that you can think of. But it's all in the sake of preserving privacy for users. And that's really important when we're doing things on chain, right? Because things on the blockchain are permanent and most things aren't encrypted. So it's really great to be able to just use a Credential and ZK proofs to be able to prove something about you without having to actually put that information on chain. Okay, so this is the first example of something.
02:36:00.720 - 02:36:19.918, Speaker H: This is just a data type. It's called job held. And you can imagine this as a Credential. It has some different fields. So it has employed by technical role and start date. So these are some of my examples of job held potential credentials. So I'm currently employed by Polygon Labs.
02:36:19.918 - 02:36:47.690, Speaker H: It is a technical role so that boolean is true and I started back in May last year. Previous to that I worked at Amazon. It was also a technical role and had a start date and before that I was at Sony. So these are three examples of credentials that I could hold in my wallet that would be of the type job held Credential. This is another type of Credential pet ownership. This is my dog Teddy. So has dog could be a Boolean field, this would be true.
02:36:47.690 - 02:37:49.738, Speaker H: Has cat for me is false, I'm allergic but pet count is two. So you know, I have at least one dog and my pet count is two. So it's a little mysterious. But all of these are just claims and how do we know any of these claims are true? So I could say anything, I could say I went to the moon, I could say that I work for NASA, but how do we know if any of that's true? And we know it's true because it's been issued by a trusted issuer who has given a Verifiable Credential that is actually signed by that issuer. If we trust an issuer we can also trust that they're only giving out trusted verified credentials. So these can all become trusted issuers or verified credentials by being signed by a trusted issuer. So if I said I was employed by Polygon Labs and Polygon Labs actually issued me this Credential, we could think, okay, I trust that the company's only issuing this Credential to people who actually work there.
02:37:49.738 - 02:38:45.298, Speaker H: Same for the other two places I was employed by. So this is just an example. Is this issuer trustworthy? Like could Teddy the dog say that I've been employed by NASA since 1950? Probably not because we don't trust that he's a trusted issuer. And this all gets into the triangle of trust and the reason why Polygon ID or any type of did works and it all comes back to issuer trust. So if the Verifier can trust that the issuer only issues credentials to people who satisfy whatever conditions they have, then they can accept DK proofs based on the credentials that they've issued. And so in practice, this is what it looks like. So the issuer in the job held case would be George, my previous manager at Amazon, hey George, he's not watching, he's like still way back in web two but good for him.
02:38:45.298 - 02:39:33.266, Speaker H: So George could issue me a Verifiable Credential of job held. He can say that, yes, I was employed by Amazon, my role was technical and this was my start date. Then a Verifier website or DAP could come and say, hey, has Steph ever had a technical role in a job, yes or no? And I would have something in my wallet that would say, true, I have had a technical role before. So I could present this Credential and create a ZK proof based on the Credential that says that I satisfy the requirement of having had a technical role. So you can think of a Verifier that might want to do this. Maybe it's LinkedIn and they want to give me a badge for being a technical developer, or maybe it's my next job and they want to know if I've ever coded before. So they're also interested in this.
02:39:33.266 - 02:40:15.774, Speaker H: But the power of polygon ID is that these issued verified credentials can be used unlimited times by different Verifiers and they're all using that same data that only has to be issued once. So you might be thinking like, how do we prevent Teddy the Dog from being a trusted issuer? We don't actually have to. So the Verifiers can specify which DIDs are trusted issuers. So you can see in this code, allowed issuers is set to all. So for this case, anyone could actually issue this type of Credential and the Verifier would accept it. But you can imagine that down the line. Maybe a Dow could manage who is a trusted issuer or any other solution to kind of like improve the trust.
02:40:15.774 - 02:40:42.978, Speaker H: Maybe there could be even scores of issuers to make sure if someone had issued a bunch of bad Verifiable credentials, they were bumped down in the list. So I don't know if anyone ever watched Harry Potter. I did. I watched all the movies. I read all the books. If I'm on a plane, chances are if I have something mindless to do, I'm watching Harry Potter. But anyway, Harry Potter has one of the most famous issuers of all time, and that's the Sorting Hat.
02:40:42.978 - 02:41:24.274, Speaker H: So when someone new comes to Hogwarts, they put on the hat and the issuer says which house they're in. So Harry is famously on the fence between Slytherin and Gryffindor. But then at the end the issuer which is the Sorting Hat is like, hey, Harry, which house do you want to be in? And he says, Gryffindor. So he's kind of like self selected in. But the issuer which is the Sorting Hat gives him that badge of like, okay, you're in Gryffindor. And so you can think of that house as like the verified Credential. And then Griffin, or the issuer is the Sorting Hat and Harry is the person holding the Credential and he can reuse that verified Credential in lots of different places all over Hogwarts.
02:41:24.274 - 02:41:48.522, Speaker H: So maybe he's getting into the common room and he's using a magic door that's the Verifier and it unlocks the Gryffindor common room. Or maybe he's trying out for the Quidditch team. So I can't remember what this guy's name is. Is it Lee? Anybody know? There we go. The team captain can say. Only Gryffindors can be on the team. So he's checking against that verifiable credential.
02:41:48.522 - 02:42:25.820, Speaker H: Again, for Quidditch team eligibility. So that's just an example of how you can reuse these credentials anywhere. So what does this look like in the Polygon world? It's not quite as fun as the sorting hat, unfortunately, but this is what your data looks like. So I have three different Verifiable credentials in my Polygon ID wallet, which is a mobile app. The first is almost like an event ticket proving that I went to Polygon at the Pit, which was an event. The next is an example of proof of personhood. This actually hasn't been implemented yet, so if anyone wants to connect WorldCoin and Polygon ID, that could be a killer hackathon project.
02:42:25.820 - 02:43:08.630, Speaker H: But all of this data is stored in your wallet and it holds the VCs and interacts with Verifiers once you need to prove your identity. So this is what it looks like as that VC is issued. So you scan a QR code and it says Accept Credential offer. Then the claim is added to your wallet and it's put in your data and then you have some information about the VC that's held directly in your wallet. And then this is what it looks like when you go to actually verify claims. So Verifiers or DApps will have a QR code on their website as well. You'll scan the code and it'll ask for a proof request of something specific.
02:43:08.630 - 02:43:41.406, Speaker H: So in this case it was Polygon ID membership. Are you part of this Dao? Yes or no? And then it generates a proof for you. So you don't have to code this or anything. It generates a proof that actually shares the answer to this question. So yes or no and then you can manage this from your wallet forever. So if you don't have the Polygon ID mobile wallet app yet, you'll have to get it in order to kind of interact with the demo site and any of the other Polygon ID sites. Right now we just have a mobile wallet.
02:43:41.406 - 02:44:16.262, Speaker H: We don't have a desktop wallet yet, but that's another cool hack idea if anyone wants to build like a desktop Polygon ID wallet. But currently there are two ways to issue claims. So to be the sorting hat, this is the easy way. There's currently only two types of claims that you can do the easy way, which is by using the demo issuer UI. So the first one is an age Credential, so that's what I'm going to demo today. And the second one is a country of residence Credential. So some things you could check with an age Credential or like sample use cases.
02:44:16.262 - 02:44:54.614, Speaker H: Are, are you older than 13? A lot of social media sites like TikTok and Instagram and Be Real. The first thing they do when you log into their app is they say add your birthday, you have to be over 13. So that could be a cool use case for a DAP as well. If you're creating like a social DAP or maybe you're creating a DAP that's just for kids. And you say you have to be younger than 18 in order to sign the yearbook or post a message so you're making sure you don't get, like, creepy adults. And then for the KYC country of residence Credential, maybe you want something that's specific to Canada. I'm like loving all of the stories that Canadians say.
02:44:54.614 - 02:45:31.000, Speaker H: I think it's so cute. So maybe you say, sorry, only people in Canada can use this app, and you have to prove that your country of residence is Canada. Or maybe you're creating like, an election app for a specific country. And you say you have to be a resident of this country in order to use the DAP. Or maybe it's something like Countrywide and it's only for EU residents. Anything like that could work for the demo issuer UI because it is able to create these two types of credentials. So I'm just going to really quickly show you the demo issuer UI so it looks like this.
02:45:31.000 - 02:45:50.790, Speaker H: Oops. Come on. Wi Fi. So you sign in with your polygon ID wallet, and then you can create claims just to issue yourself as demos. So like I said, you can either create an age claim or a country of residence claim. I'm just going to give myself an age claim. So it auto fills all of these fields.
02:45:50.790 - 02:46:20.786, Speaker H: But the main thing you want to think about is the data that you're putting in the actual claim. So this one is for birthday. I'm just going to add my birthday. Or actually, no, I'm going to add a slightly different version of my birthday. This birthday is August 24, 1994. So I'm submitting this, and then it'll create a QR code. So I'm opening up my polygon ID mobile wallet app, and all I have to do to get this QR code in my wallet is scan the QR code.
02:46:20.786 - 02:46:59.150, Speaker H: So it's asking to issue this Credential to me in my wallet. I'm just accepting the Credential and it's added. So now I have this birthday Credential or this KYC age Credential that I can use all over the Internet. And that's kind of the basis of our Verifier, which is what I'll show you next. Okay, actually, before we get to the Verifier, there's a second way to create or issue credentials, and that's by using our dockerized issuer node. So this is what you'll need to do if you want to create custom credentials. Like, let's say you wanted to issue people anything.
02:46:59.150 - 02:47:29.210, Speaker H: Basically, that's not an age Credential or a country Credential. You'll have to host an issuer node. It's Dockerized, which is kind of nice, and then you can just kind of host them publicly with Ngrok. And that's how you can kind of demo your app if you want to go this way. So if you want custom issued credentials, scan these two links that will take you to the code for the issuer node. And also the docs to the issuer node. And I put all of the slides, by the way, in the discord channel.
02:47:29.210 - 02:48:01.030, Speaker H: So if you missed anything or need the links, they'll be in discord. Okay? So going back to the Triangle of Trust, we've learned about two things. The issuer, which is either that demo issuer UI or the self hosted issuer node. Also, we know the identity holder is you and you hold those credentials in your polygon ID mobile app. So the last thing that we are not quite sure about yet is the Verifier. And this is what receives those ZK proofs and checks against them. So back to the Harry Potter example.
02:48:01.030 - 02:48:48.094, Speaker H: We saw the demo Verifier and what it unlocks. In this last example, the demo Verifier is actually a VC gated website. So it's a Verifiable Credential gated website and it unlocks a secret DAP or app that you can only see if you've proved your birthday. So this is what it looks like, and the request is prove you were born before 2023 in order to view. So I think that's everybody in here, no babies are hacking at ETH Waterloo this year, but maybe they could eventually maybe Vitalik's kid, honestly, if he had a kid. So if you need to prove that you were born before 2023 to view, you would be doing something like this in the code. So this is kind of like a really simple query.
02:48:48.094 - 02:49:11.098, Speaker H: And the Credential subject is on line nine. It's birthday. And you see this funny looking query language on line twelve. It has like a dollar sign lt, which stands for less than a value. So less than 2023 one. So we're checking for line nine. The birthday field is less than or before January 1, 2023.
02:49:11.098 - 02:49:50.310, Speaker H: And so this is the proof request that we'll send from the front end via QR code. And this is what it'll look like on the front end. So a modal will pop up. It'll say, scan this QR code from your polygon ID wallet app to prove access rights. And if you can scan this and successfully generate a ZK proof, it'll send back a successful authentication response to the website and you'll see the next page. And so this sounds a little difficult, but it's not because I created a template for you all on GitHub. And what this gives you is all of the front end and also the server code for creating this Verifier website.
02:49:50.310 - 02:50:24.750, Speaker H: So with the last 10 minutes, I'm just going to kind of like walk you through what this template looks like and what it does and the parts that you should modify for your own DApps. Oops. Okay, so this is that GitHub repo. You can see there's two folders in the repo. There's a front end and a server. So the great things about this are that it's built with react JS, which a lot of people know because it's just like a pretty common JavaScript library. It's already VC gated for you with that Polygon IDH Credential we saw before the birthday Credential.
02:50:24.750 - 02:51:05.562, Speaker H: It's fully connected so that the DAP that you hide behind the VC Credential is already connected to a demo DAP with examples of how to read from the blockchain and also write to the blockchain. So you should only have to kind of do some Frankensteining and just a slight bit of open heart surgery when you're adding your own smart contract in because it's mostly done. Or you'll just see examples. It's also already styled with configurable components from Chakra UI. When I'm hacking, I like go down this rabbit hole of I'll just create the components myself and then I realize I don't have time. So I just made that decision for you to make it easier. And then it's also just like ready to interact.
02:51:05.562 - 02:51:43.420, Speaker H: So it's connected with Rainbow Kit wallet and it is connected by default to polygon networks, but you could replace those with anything you want. So to get started with the template, you'll just come to this GitHub and you'll say use this template and you'll click create a new repo. It'll have you clone the new forked repo from GitHub down and let me show you what it's got. So I'm running it right now. It has a server and also a front end. The server is making two different API calls to the Verifier SDKs of polygon ID. So let me just open the code quick.
02:51:43.420 - 02:52:12.166, Speaker H: So this is the server. This is the index file. It has just like a general welcome page. It's really not doing anything here. So the server runs on localhost 80 80. This is just telling you the two available API routes. So the first one is Get Auth QR and that shows you that QR code that generates the proof that's sent to your wallet, or generates the request for the proof, I should say.
02:52:12.166 - 02:52:56.210, Speaker H: And the second one is API verification callback. That's what sends the callback to your front end saying whether or not you successfully authenticated. So you need to be running this server in order to be able to get and post this data to Polygon ID. And then the last thing to mention is that when you're running the server, this is in the instructions in the README as well. But you'll want to run Ngrok on the server so that you can have a public URL for the server because of that callback to the front end. Otherwise you'll have some issues with cores. And also the Polygon ID app has to know about the public URL of your server.
02:52:56.210 - 02:53:23.230, Speaker H: And if it's just on localhost, it's not connected to the Internet. So the Polygon ID app has no way of saying, hey, this is the response from your API call. So that's the server. It's pretty minimal. It's just built with Express and also sockets. There's nothing in the server you should need to modify except for one file, and that's proofrequest. So inside of proofrequest, we see that Credential subject birthday and the query that I showed you in the slides before.
02:53:23.230 - 02:54:11.870, Speaker H: So this is that query of birthday is less than January 1, 2023. If you wanted to, you could change this date, or you could totally change the query from Kych Credential to a country Credential or a custom Credential, as long as it existed already in some type of schema. So that's the server and then the front end is what's interacting with the server. So I'll just open the README first. So each of these folders, the front end and the server also has their own README with a few more instructions. But this is just that page that is created for you. You know what, I'll actually just go to where I'm running the front end locally, which is Localhost 3000.
02:54:11.870 - 02:54:45.566, Speaker H: So this looks almost exactly like that other page that I had, except for this is kind of just a full stack template version. So I'm just going to quickly prove my access rights to this page with my wallet. So, as you saw, I already created that Kych Credential and gave myself a birthday that's definitely before 2023. So I should be able to authenticate with a proof. And it looks like it's preparing off. So once it starts running authentication, yes, it runs the spinner. It said verified proof.
02:54:45.566 - 02:55:21.946, Speaker H: And it shows me the secret page or the VC gated page, which is actually a DAP. And like I said, what's cool about this is this DAP is already connected for you to the polygon ZKE EVM testnet. So it's got the wallet connect button, all of that's done. So conceptually, all you have to do for all of your applications is write the smart contract with all the business logic and then kind of port it into this DAP. So in the front end code, you would just start changing out just like the front end things. So I'll show you. So I had a demo smart contract.
02:55:21.946 - 02:55:58.210, Speaker H: My DAP that's behind the gate is just a counter app. So all it's doing is I push the button and it's incrementing the counter up one. So I sign it goes up to 19, and that's all tracked on the blockchain in the smart contract. Basically what I wanted to do with the counter DAP was give you an example of reading from the chain. So this value 19 is read from the blockchain and then writing to the chain with the increment counter that's updating a value. So you have both of those examples when you're doing anything with your smart contract. Low battery.
02:55:58.210 - 02:56:21.914, Speaker H: Okay, so all of that DAP is happening. The DAP code is happening in the Vcgated DAP file. So feel free to gut all of this or change it to reference your smart contract. I just had the smart contract address. Here my ZKE EVM. Smart contract. Address.
02:56:21.914 - 02:56:44.450, Speaker H: So if you change this out, then you should also be able to go through and update the read function. And also the increment. Counter is the write function. So you can see there's already a read contract function. So all you would do is change out the function name to whatever your function was using. And then the other thing you would update is the Abi. I just put mine here.
02:56:44.450 - 02:57:31.938, Speaker H: It doesn't necessarily have to be there, it's just where I rooted it. So the Abi will just have all of the available functions from your smart contract. So I had two called Retrieve and what was the other one? Increments. But all of the polygon ID stuff is created for you. So the only things you would be customizing really are the queries and the type of Credential. So changing the age Credential to either country Credential or your custom Credential that was issued either by the demo issuer node or your self hosted node. Yeah.
02:57:31.938 - 02:58:04.106, Speaker H: So again, this is that QR code to the template. Hopefully it's super helpful, but if not, I'll be around all weekend and also in the Polygon discord to answer any questions and help. I love building, so I'd love to help you if you run into anything. No question is too dumb, I promise. And actually, if you use this template, you're automatically in the running for two of our prizes. I just have to plug the prizes really quick. We have $10,000 in prizes this weekend, so 3000 for a public good with account abstraction.
02:58:04.106 - 02:58:33.794, Speaker H: So if you wanted to double up on prizes, I saw that Nosisafe has Safe APIs. They're also giving away $2,000 for hacks with account abstraction. So if you built something with Safe APIs on polygon, you'd be eligible to win like $5,000. Pretty good. Next one is best, most innovative hacks deployed on polygon Zkevm. Zkevm is what I just showed you. So this counter app was deployed on Zkevm.
02:58:33.794 - 02:59:03.006, Speaker H: Zkevm is so similar to Ethereum that all you have to do when you're deploying to it is change the RPC URL. So instead of Gorely ETH, you point to polygon zkevm testnet. That's the only thing that changes, which is pretty awesome. So you don't have to worry about code, you just change the string. So the best tax on that are also eligible for three K. And then I just added some random ideas that I had. I feel like EIP 6551 is so interesting.
02:59:03.006 - 02:59:27.650, Speaker H: The NFTs that can own other NFTs. So super interested in any hacks like that. Or maybe you're interested in cross chain hacks. The protocol before me just did a really cool cross chain hacks workshop. So work with that if you want to do a crosschain hack. The next one is directly related to ID, which is what we just talked about. So $2,000 for best use of polygon ID's verifiable credentials.
02:59:27.650 - 03:00:07.202, Speaker H: So VC gate your adapt, just like what I showed you, whether it's an H Credential, a country credential or something custom. And you're eligible for two K there. And then the last one is mostly for beginners, but I plug it anyway because everyone can win this prize. All you have to do is build in public. So we want to see your tweets about what you're building so that my social media team can go like, whoa, ETH Waterloo looks so fun. So all you have to do is deploy on polygon and post a tweet about it, linking your smart contract to your GitHub. This is a specific link, so if you open this link, it'll pre generate the tweet for you.
03:00:07.202 - 03:00:31.082, Speaker H: So if you're like, oh, shit, I gotta submit my hack tomorrow. All you have to do is click this button and update literally one thing. This should be the easiest thing you do all weekend. Add your GitHub here, tweet it out, and you'll win a portion of that two K. All right, I think that's everything for me today. Thank you so much for listening. And like I said, I'll be around all weekend.
03:00:31.082 - 03:00:34.240, Speaker H: Ask me for help. I'm happy to help. Thank you.
03:00:46.850 - 03:00:47.760, Speaker C: Thank you.
03:00:49.650 - 03:00:51.180, Speaker H: Last time of the day. Are you free?
