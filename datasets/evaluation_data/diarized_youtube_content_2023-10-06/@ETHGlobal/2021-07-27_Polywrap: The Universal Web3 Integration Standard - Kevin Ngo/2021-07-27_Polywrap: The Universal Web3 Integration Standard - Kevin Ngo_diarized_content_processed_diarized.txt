00:00:00.250 - 00:00:48.012, Speaker A: Hey, everyone. Yeah, thanks for having me. I'm Kevin. I'm wearing many hats at polywrap, but in general, I do developer relations, engineer, software engineering, and some operations work. So here today, I'm going to talk about our project, polywrap, and our goal is to become the universal Web Three integration standard. You before I dive into the tool chain, I just want to talk about the history for a bit. polywrap was first conceived at Hack FS in August 2020 by Jordan, Caesar, Roberto, and Ori, and it was elected as a finalist at the Hackathon, which gave the project a lot of attention.
00:00:48.012 - 00:01:30.140, Speaker A: It gave it the momentum it needed to grow into a Dow, which is a decentralized, autonomous organization with 60 plus members. We were able to raise funding, attract talented developers, and some amazing launch partners. Some of our launch partners include Wallet, Connect, Fleek, Gnosis, three Box Labs, pocket Network, Taurus, and many more. Just a note about our launch partners. These are partners that have been helping us during our pre alpha. And the ways they help us is reviewing our documentation, helping us with development, doing press releases, and a lot of other things. So, yeah, if any of you are watching, any of launch partners are watching.
00:01:30.140 - 00:02:26.654, Speaker A: Thanks so much. And some other news. We've been working on pre alpha, and our alpha version will be releasing in about a month. And Jordan, one of the original developers on polywrap, will be speaking at ECC in Paris later this month. So Polywraps solves what we call the Web Three integration problem. So how do we define integration? Integration for Web Three developer is if you want to integrate protocol, business logic, let's say, like Uniswap or Maker dows like Uniswap swap function or add liquidity functions, or maker Dows, Mint, dai, or deposit collateral, if you want those, into your own decentralized application. That's what integration is in web3.
00:02:26.654 - 00:03:51.110, Speaker A: And it's difficult today because of the tools that we have. And to really understand Web Three integration, we have to start with Web Two and what integration looks like in the Web Two era. So in Web Two, if you're a Web Two developer and you want to integrate API logic into your application, for example, Reddit, Twitter, Google, or Stripe, all you have to do is send a query to a rest endpoint and, for example, Twitter would tweet on your behalf. And it's fairly easy to do. There's a lot of tools for this and there's a lot of standards because it's been around for a long time and you know exactly where to send the fetch request. With Web Three, centralized servers are replaced by decentralized networks like IPFS or the Ethereum blockchain to interact with protocols. What protocol developers have done is create SDKs that you can integrate into your decentralized application.
00:03:51.110 - 00:04:57.420, Speaker A: And most of these SDKs are written in JavaScript. So all the business logic that used to live on centralized servers are now bundled into your application, allowing you to interact with protocols like do queries or mutations. And while this is great, there are a lot of issues when it comes to these types of SDKs, especially with JavaScript. So what are the issues with JavaScript? One, it's not standardized. So if you were trying to integrate, say, the business logic of Uniswap maker and Gnosis into your app, they're all written in different ways, and you'll find that it's going to be difficult for them to be composable. The second reason is that it's not scalable. So when you want to integrate more and more business logic into your decentralized app, you'll have to download more SDKs into the DAP.
00:04:57.420 - 00:05:42.140, Speaker A: This is going to bloat the DAP, increase the bundle size, and just make the app run a little bit slower. Third reason is JavaScript, slow and insecure. So we all know that in the crypto space and in the blockchain space, that security is paramount to the success of any protocol. So this is a huge factor too. And lastly, JavaScript is not multiplatform. So JavaScript is a language that's written primarily for the web developers. And if you wanted to, say developer your app on a drone or some other IoT device, it's going to be a bit harder.
00:05:42.140 - 00:06:50.250, Speaker A: So what a protocol developer has to do is develop maybe another SDK in another language. And this presents another issue, because now they have to maintain multiple SDKs at once, which increases the maintenance costs. So our solution to the web3 integration problem is polywrap. So with polywrap, we're trying to take the ease of web two development and how easy it was to integrate API logic into your applications without sacrificing decentralization. So the idea is that you would write protocol business logic and bundle it into what we call a polywrapper or a wrapper, and then deploy that wrapper to decentralized endpoint like IPFS. Then your client, when it launches, would download these wrappers at Runtime and be able to use the exported WASM modules. So I'll go into more detail about what that all means.
00:06:50.250 - 00:07:52.280, Speaker A: And for our example, we'll be using uniswap. So we developed a Uniswap wrapper and what it is, and this will be the same for any wrapper, whether it's uniswap or gnosis or any other protocol, but the composition of the wrapper is pretty similar. So you have a manifest file in YAML format, and all this does is that it orchestrates the package. Then you have a GraphQL schema file. So wrappers are queried at Runtime using GraphQL in your application. So this GraphQL schema file will provide the types and the shape of the queries that you can send to this package. And most importantly, it contains the business logic of uniswap in WASM modules.
00:07:52.280 - 00:08:46.040, Speaker A: So WebAssembly allows for exporting functions that can be used in your JavaScript application. So all of this is done at Runtime. You can build your WebAssembly business logic using different language that compiles down to WebAssembly. So for example, right now we have support for assembly script which compiles down to WebAssembly. And then once you wrote all your business logic and the GraphQL schema, you can deploy to the centralized endpoint. In this example we're using Ipffs, but we also have support for ENS and more support for other methods coming soon. So here's what happens.
00:08:46.040 - 00:10:04.144, Speaker A: At Runtime, your application launches if it's enabled with polywrap, then the polywrap standard will download the wrapper at Runtime, which includes the business logic in WebAssembly modules. The WebAssembly modules export the functions like say, swap or functions that let you add liquidity and then they could be used in your application. So unlike a JavaScript SK, none of the business logic is bundled into your application. It's all at runtime. And since WebAssembly doesn't assume running in a web environment, there's potential for your application to use business logic in any type of environment. So today we have support for web apps, but it's possible to run DApps on your Apple Watch, for example, or the phone, or even a drone. And again, WebAssembly can be written in just one language that compiles down to WebAssembly.
00:10:04.144 - 00:11:15.752, Speaker A: So this could be assembly script, but pretty soon we have support for Rust and Go. So unlike protocol developers creating SDKs, they don't have to create a separate one for JavaScript or Python and be forced to maintain all those, they just need to write one SDK in one language. So yeah, there's unlimited possibilities when it comes to polywrap. Today we have about maybe six wrappers deployed to IPFS, with the major ones being uniswap and ENS. But we are going to be developing more and we're going to have bounties open for people to contribute to the project and create their own wrappers and deploy to IPFS to expand the ecosystem. So now I'm going to talk about the developer experience of polywrap and how you would integrate it into your decentralized application or DAP. So all you have to do is two steps.
00:11:15.752 - 00:12:05.710, Speaker A: So the first is to install the client, so NPM install at polygraph clientjs. And by the way, this is assuming you're creating a JavaScript application today we have the client in JavaScript, but we're writing it for Python in the future too. And second, any protocol is just a request away. So once you instantiate the client, you can call the query methods on it. So here we have a query method and it accepts one object which has two properties, a Uri that points to the wrapper that you want to use. So in this case we want to use the uniswap business logic. So we're pointing to where the uniswap business logic is being deployed, which is ensapi uniswap east.
00:12:05.710 - 00:13:03.330, Speaker A: And then in the query property, the value is a string that shows which method we want to use from the business logic. So here you can specify either mutation or query. Here we're using mutation and we're showing that it's just a generic swap function. Now, building your wrapper. This is if you're a protocol dev team that wants to build your wrapper and deploy to a decentralized endpoint for other people to use. So first you would define your schema in the GraphQL file on the left here we have the type, which is a generic query, and then a generic method with arguments custom type and it returns a string. And then on the right you would implement WASM functions.
00:13:03.330 - 00:13:52.630, Speaker A: So what you see on the right here is a language called Assembly Script. And you notice that if you're from a JavaScript or TypeScript background, it looks very similar. So if you have a TypeScript background, you'll most likely be able to implement something like this. But what we're doing here is importing the custom types that we wrote from W Three. W Three is just a custom folder that holds code generated types that you can use in your WASM implementation. And here we're defining different functions inside that would hold the business logic and you can customize it however you want. And it's highly composable.
00:13:52.630 - 00:14:53.100, Speaker A: So this means that you're able to import other wrappers that are deployed into your own wrapper, which is really cool. So here on the left we're importing like a generic query from another wrapper that's deployed into our application. And then on the right we're able to import that query and use its methods. So just reviewing the benefits of using polywrap, it's multiplatform, meaning that it can run in any environment that can execute WASM functions. It's hyper composable, meaning that you have other wrappers that you can lean on as dependencies and put into your application. It's fast and secure because it uses WebAssembly. So WebAssembly is a low level language and it runs very quickly in the browser.
00:14:53.100 - 00:15:50.542, Speaker A: And all WebAssembly modules are given allocated their own memory to use. So it's pretty secure and it's scalable because no business logic is bundled into your application. The only thing you have to install in a JavaScript application is the JavaScript client. Cool. So now I'll head over to our demo. All right, what you see here is the univ Two swap page, except that our team went through the entire interface code base for the swap page and we replaced all the uniswap JavaScript SDK with our own polywrap functions, which was a huge task. So I'm going to show you how the swap works.
00:15:50.542 - 00:16:36.570, Speaker A: But first I want to show you the deployed univ Two polywrap business logic. So we deployed it to ENS, which is the Ethereum name service. And if we go down here, you'll see this is going to be the Uri that we ping with GraphQL and you can see the content that it resolves to. In this case it's an IPFS hash. And this IPFS is going to hold the business logic. So if I click this, it'll send me over to IPFS and you can see this is what we consider the wrapper. So it has the YAML files that orchestrate the entire package.
00:16:36.570 - 00:17:43.022, Speaker A: Again, it has the GraphQL schema that provides the types and the shape of the queries that you can send to the package. And most importantly, it has the WebAssembly modules which were originally written in assembly script but compiled down to WebAssembly. We separated mutation which is functions that provide write operations with queries which just allows you to fetch data from the protocol. So this package is downloaded at Runtime and just showing you the code here on the top here we have three functions that are called when you perform a swap. Best trade exact in swap, call parameters and exact call. And this is what the code looks like in your decentralized app. So here after you instantiate the polywrap client, you can call the query methods on it and we're pointing to the ENS Uri that you saw earlier, which results to the polywrapper and then you can call query.
00:17:43.022 - 00:19:13.600, Speaker A: So here we're calling query and we're specifying the function that we want to use in the exported the instantiated WebAssembly module that exports these functions. And here we have a variables object that can hold variables to be injected in this template literal. So if I go over to the variables tab, you can see the different variables that are being put into the query. So I'm going to perform a swap here, just wait a little bit and then click this to perform the swap and then MetaMask will pop up and then we'll just wait for a little bit for the transaction to confirm. But yeah, what you just saw is all the business logic of uniswap V two happening at Runtime. So if we open Ether scan here, we can see that the transaction is successful. All right, well, thank you everyone, this has been pretty fun and if you want you can follow me on Discord and Twitter is on the bottom left here or please visit our website.
00:19:13.600 - 00:19:32.660, Speaker A: We're looking for contributors and looking for people to join our community. The community is super support. If you have any questions with building your polywrap applications or wrappers, you can just ping me or anyone in the channel. Yeah, thank you so much.
