00:00:07.610 - 00:00:55.510, Speaker A: So I'm Leo. I'm from Cismo. And so today we are going to do a workshop. So there will be very few presentations, but more like trying out a bit, our tutorial, our boilerplate and stuff like that. So I hope you enjoyed. So at CMO, what we do is that we leverage zero knowledge proof to enable users to aggregate their identities and selectively declose some piece of personal data directly to applications. So here we can see we have zero x one and zero x two, and we are able to aggregate this data, generate a zero knowledge proof of some small piece of personal data inside it, and bring it to an application with a single sign on.
00:00:55.510 - 00:01:47.150, Speaker A: So, SSO Flow, I'm going to do a demo right now so you will more understand how it works. So for a bit of context around this demo last year, what we have done is we have printed a code of tornado cache with a two meter high artwork. So it was a physical painting. Two months ago, it arrived on Twitter and people asked us to have it and to have a version of it. So what we did is we did a lottery to be able to gain this artwork. The problem was, okay, we wanted to gate this lottery only to users of Tornado cash. But when you use Tornado cash, you can deposit and withdraw a lot of times, so it's highly uncb resistant.
00:01:47.150 - 00:02:31.130, Speaker A: So we decided to also add a way to have CB resistance to enter this lottery. We use Gitcon passport for that? So Gitcon passport is a way to connect your Twitter, your GitHub. So it's a bit like Doxing, because all happen in your public identities and it analyze your activity. Basically the commits you have made, the tweets you have made, and based on that, it will give you a score of CBD resistance. And for instance, a score of 15 is a good score of CBD resistance. Let's say I am human. So here, this mode is very interesting.
00:02:31.130 - 00:03:01.586, Speaker A: Use case because you want to prove that you have used Tonadocash with a very private wallet. You don't want to reveal at all and you want also to prove that you have a Gitcoin password. So basically that you are civil with your very public wallet ENS. And so using Sysmo and Sysmo Connect, you will bring these two data without revealing the address that was used behind. So let's go to the demo. So we have what we call the App Store. So.
00:03:01.586 - 00:03:37.560, Speaker A: It's app. Tismo IO. You can go there and try it out. You click on demo here and here you can see the lottery registration. So basically, this is the application, lottery registration. To be able to enter, you are going to do SSO Flow sign in with Cismo and requesting data from the user to be able to enter the two data we request here is, okay, I am well a Tornado cash ethereum depositor on Mainet. And I have a Gitcoin passport with a score more than 15.
00:03:37.560 - 00:03:59.162, Speaker A: So I do sign in with Sysmo. I'm redirected to my sysmo data vault. So the Sysmo Data vault, it's like a password manager when you import all your different accounts. So this one is a demo one. So we can see here there is a lot of accounts that already have been imported. I can show you mine. My real one you will see.
00:03:59.162 - 00:04:49.414, Speaker A: So I won't do all the one because otherwise I will DOX myself. But you can see I have a lot of accounts and I import them just once, like in password manager, in one password, for instance, you import your different accounts when it's imported, it's linked to your vault. And in Sysmo data vault you have what we call the vault secrets that you will be able to use in zero knowledge proof to prove that you own these different accounts. So thanks to that, you will be able to prove to application that you own your different accounts if you want. And we will see this later how to use a devex to request some proof of ownership of different accounts. But you can also do some membership. Basically, what is this membership? You have groups of all the accounts that have exactly the same characteristics.
00:04:49.414 - 00:05:27.580, Speaker A: For instance, here you have the Tonadogash ethereum depositor groups. If we see the content of the groups, it's all the depositor on Mainet. So it's basically all the accounts that have made this action. So what we are going to do is that we are going to prove in zero knowledge proof here. So all happen in the browser that we own an account that is inside this group and we are going to send back this proof to the application that will verify it, verify it off chain or on chain. If we take the Gitcoin passport, it's exactly the same. So you have the group of all the Gitcon passports and we can see here the content.
00:05:27.580 - 00:06:02.820, Speaker A: And there is a particularity is that it's a key value data group. So the key is the account and the value is the score of your Gitcon passport. And what is interesting here is that you can do predicate or statement around this value the application can request. And this is what's happening here. That okay, you are part of this group, but also you have a score that is more than 15 and the application won't know exactly which score I have inside. But the application, we know that they have more than 15. This is just what is interesting for the application.
00:06:02.820 - 00:06:49.626, Speaker A: So I do generate ZK proof. The ZK proof is generated, it's sent back to the application and I can verify my ZK proof and I will be able to enter the lottery. So here the flow. The verification happened off chain, but it can also happen on chain. We have a solidity library that we can call to verify the proof. So we have what we call the factory. The factory is a UI dev tool that enable to browse the different data groups and create data groups.
00:06:49.626 - 00:07:18.818, Speaker A: So data groups here are very important because it's a source of data you will be able to use inside your application. So we can see here for instance, that there is around 1000 groups that have been created. So you can go there, it's all open and you can search. For instance, the gitcoin passport one is here. We can see the last generation. The next generation regroups are snapshot groups. They are run at daily frequency.
00:07:18.818 - 00:07:53.538, Speaker A: And you can choose basically the frequency you want for your group to refresh this data. I will show you how we can create new data groups. So you can do all in the UI tool. Also you can do a manual group. Like basically you just put your addresses, your list of addresses, or you can use what we call data providers. Data providers are just a way to fetch data from the outside world. So for instance, here we have a lot of data providers that have been made by the community.
00:07:53.538 - 00:08:39.390, Speaker A: Also you can also code your own data providers that will appear here for all the other developers. So we can create a group together. I propose that we use like the GitHub one. Here you can see the different accounts we have. We have like web3 accounts, but we also can have GitHub, Twitter or Telegram accounts. So basically, if we do a group of all the GitHub contributors of the repository, you will then later be able to prove that you are part of this group without revealing exactly who you are. So basically you can import your reputation from your web two activity in this example, or bring some web two activity and web3 activity together in one proof.
00:08:39.390 - 00:09:21.758, Speaker A: So here we can take for instance, I don't know, let's take the foundry one. So it's an interesting one, I think. There is no group for this one. So you just need to put here the repository. So here we know that there is 274 accounts that contributed to foundry. Just continue. So here you need just to put a description and specification around your data group so other people can search for groups and reuse them for their own application.
00:09:21.758 - 00:10:18.974, Speaker A: So when you create groups, you just bring data for all the other people to be able to generate zero knowledge proof out of it. So let's say data group of all the contributors to foundry. So data groups of all committers to the so in the specifications. What is good is to put the very more precise one like to put all committers to the repository. Okay? So let's say foundry, GitHub contributors, data groups. Here you specify the frequency you want. So either once it will be computed just once or weekly or daily.
00:10:18.974 - 00:11:38.864, Speaker A: Let's put daily because then we will have updated data each days here public information is to be able then to contact you if we want to change the group or whatever. So I will put mine because I'm the one that did the group and let's go. Okay, so you see your group is being created. What happened here it creates so the factory is a UI tool on top of the Sysmo hub which is a repository that contain all the infra that computes all these groups and puts them in merkel trees in what we call posadon merkel tree to be able to use them inside zero knowledge proof. So it computes all these merkle trees, sends a root on chain and then it's available for everyone to be used. Here what happens. So you can see the code you can directly code your own groups by hand as a developers and do really more complex stuff like using multiple data provider together, computing some score around it and trying to normalize stuff whatever you want once we have this group so we can do zero knowledge proof out of this group so what will happen here? It will be automatically checked.
00:11:38.864 - 00:12:40.744, Speaker A: If all is good then it will be merged automatically and when it's merged it's deployed. For instance we can see an old one. So you will understand for instance if you see today there was this group that was created and so here we can see that the group is generated, the merkel trees are created and then the root of all these merkel trees are sent on all chains and then they are available to be used in Cismo Connect. While it's generating and deploying we are going to effectively use Cismo Connect to an app. So we have provided some boilerplates for that. You can go to stocks, Sysmo, IO and we have here all the sections build with Cismo Connect. In the overview you will see so exactly what I demoed you.
00:12:40.744 - 00:13:34.150, Speaker A: So you have a button you need to forge the request you want to do for the user. So basically you will say okay, I want that he's part of this group, this group and this group. The user generates his secret proof in his browser, send back the ZK proof to the application, your application and you can verify it off chain or on chain. Okay, sorry. So if you go to the installation here we have a create system connect script that will basically set up all the different bowl plate we have. So let's start running it. What is the name of your project? So let's say workshop.
00:13:34.150 - 00:14:13.506, Speaker A: So when you start the script asks you for an app ID. What is an app ID? It's basically when you create an app on top of this mode. It's like when you do connect with Google you need to register your app so the proverb part will allow only your front end to be able to request data from the user. So it's for security reason, basically. So you create your sysmo connect app. So it's very easy. It's permissionless, you just need to go to the factory again and to create your Cismo Connect app.
00:14:13.506 - 00:14:56.270, Speaker A: So let's say is global workshop. So it's fun when you add a picture and authorized domain. So here you can put like Localhost to test in localhost. And then once you deploy, you can update it to add the authorized domain for your app. And by creating this app, you will have an app ID. So this app ID is the one you will put into your piece of code. Like when you install the front end button and the Sysmo Connect Verifier.
00:14:56.270 - 00:15:18.840, Speaker A: Okay, you put your app ID here. It reconnects it. And let's start by the off chain. So we have an off chain and an unchained border place. So you can do what depending on your sorry. I am so sorry. Is it better like that? Thanks.
00:15:18.840 - 00:15:59.590, Speaker A: So let's go to the off chain one to start. So it will set up a next JS application with Cismo Connect installed in it. Okay, let's go to workshop. Yarn dev. So here you will see, okay, you have the front end, you have your button, and this is what is used to request your ZK proof. You have the system Connect config where you have your app ID and the different data you want to request. And then you have your API, your backend to verify the proof.
00:15:59.590 - 00:16:34.766, Speaker A: Okay? So when you launch it, you will arrive on a very simple front end that you can modify to just do your needs. But here you can see what we are going to request. So we are going to request authentication. So it's basically proof of ownership of an account and claim requests that are basically proof of membership into a group ID. You can see the different group IDs here. So you can see when we click, it goes directly to the different Group ID. Sysmo app contributor.
00:16:34.766 - 00:17:15.026, Speaker A: For instance? Okay, we do Pro resismo generate ZK proof. So here you have like six different ZK proof. So it takes a bit more time in the browser to run it's, around 2 seconds by ZK proof. So if it takes a bit of time, it was pretty fast verify. Okay, then it's verified. So it calls the back end and verified the result and prints the result here. So then you can use them to do whatever you want, store it into the database or whatever if you want to update.
00:17:15.026 - 00:17:47.342, Speaker A: So let's try to update it. So here you can see the button. It's very easy. You just need to put your config sorry, just need to put your config with your app ID. And here you can impersonate accounts. You have your app ID that was automatically filled and you have here the accounts that you can impersonate. So you can change this to say, okay, so we use Foundry.
00:17:47.342 - 00:18:30.350, Speaker A: Let's impersonate const. Which is Georgia's. Okay, I think I think I did a mistake here. Okay, so we do again your proverb with Cismo and we can see here. So we have our ISGlobal pari workshops. I discovered the app ID and changed here the impersonated account. So now I use const.
00:18:30.350 - 00:19:08.060, Speaker A: Let's go see our group how it goes. So it's been sent on chain, so yeah, it will be ready in around two minutes I think. So during that time it send. Let's try to set up the maybe unchained border plate. So we will have the unchained one. So we are using Foundry for this one. So I don't know if you are very familiar with Foundry, but we also have a package for RDATs.
00:19:08.060 - 00:19:45.228, Speaker A: But we advise you to use Foundry and we have these boilerplates that are all well set up. So I think it's a good reason to start on Foundry directly if you want. And it's really like a ten x tool when we compare to the old adat. So I really advise you to do it. Okay, so we start again. The Create sysmo connect app. Let's take again the sysmo app ID.
00:19:45.228 - 00:21:01.834, Speaker A: So we have this one and we take the unchained one. So in this border plate you have a font folder where you will have a next JS application with all wagme and VMs that will be able to allow you to call directly your contract. And you have an SRC folder here with AirDrop sol that is using Cismo Connect to verify the proof. So it's very easy, you just have to put it here and to import it from this library. So all this is in the documentation also. So in the installations part, then you have a claim with Cismo function where you will have the Sysmo Connect response that you will be able to verify regarding the data you wanted. So you need between the front end and the back end or here the smart contracts you need to have exactly the same request, otherwise it will fail because you request something and you verify it, but if it's different, does not correspond.
00:21:01.834 - 00:21:50.714, Speaker A: Basically it's like a signature. When you do a signature, you verify your signature against a specific message and you verify that your public key corresponds to this verification here. It's exactly the same. So let's go to we don't have a lot of time, so I'm going to modify it to just put our new group ID and to use an authentication of type vault. So I will explain you just later what happened. So we are going to say, okay, I want to verify a claim request from being part of this group. So let's go on our so it's almost finished.
00:21:50.714 - 00:22:32.040, Speaker A: Okay, let's go to browse our groups. Okay, so our group is here, we can see the content of the group. So we have all the contributors. Our gear consists here, so it will work in the value. The data providers was developed to put the number of commits you have made. So then here it's interesting because we can do request of having done like more than 50 contribution into this repository. We take the group ID here and I can put it directly there.
00:22:32.040 - 00:23:22.784, Speaker A: Now, if I go to the button part so we are looking for the Sysmo connect button. Here we see our config where we have same so our different impersonator address. So let's change this one to have the GitHub const and let's change our request. So here we have our authentication request and our claim request. So we say we need to have exactly the same between the font and the smart contract. So we put a vault. So here, let me explain you the vault.
00:23:22.784 - 00:24:04.556, Speaker A: We have created an app and we are doing zero knowledge proof from a user to an application. This app has an app ID. This app ID is a random number. Basically inside your sysmoda vault you have a secret that is stored in the browser, in the system data vault like the password manager. And if you hash zero knowledge proof this secret with the app ID, you will have a unique number the vault ID that will identify you to the application. This vault ID is very important because it can be used as a nullifier for your app. Let's say you do an AirDrop, you can just store this vault ID as being used and the user won't be able to claim again his AirDrop or on off chain.
00:24:04.556 - 00:24:55.550, Speaker A: You can use it like a bit more as a user ID into your app and it's like an anonymous user ID. But you will be able to authenticate each time and you don't need an email or I don't know or whatever. So let's go do here just verifying this is okay, I think this is almost done. Sorry. The group ID is here and here we go. Okay, so when the create Sysmo connect app has launched, it say you need to launch local chain. This is just so you can deploy your contract easily and don't pay each time on your local chain.
00:24:55.550 - 00:25:37.680, Speaker A: Sorry, I need to go to the unchained foundry and launch my chain and same here I will go to the front end and do yarn dev. So all should be explained here. I don't know, I have okay, so all here should be explained. When you run it, you have all the explanation on what to do exactly here. So let's go to our new system connect it's because I have the off chain one. Sorry. So I will launch it again.
00:25:37.680 - 00:26:29.646, Speaker A: Okay, so what happened? When you launch the font, it will also deploy your contract into your local chain and each time you modify your contract it will redeploy into your local chain the contract. Okay, so here it asks me to connect my wallet, ask me to just I need to switch. Sorry. Okay, so we say I am in this local chain, I'm connected with my account. I do claim with Cismo. I see that I request only ownership of my vault ID here. It's my random number that will be computed in zero h proof.
00:26:29.646 - 00:27:26.958, Speaker A: And here we are checking that gekkonst, which we are impersonating here is part of the Foundry GitHub repository group. So what happened here is that we download the world group in the browser and we generate the ZK proof out of this group. So all happened in local in your browser. I think this is because the WiFi is a bit slow, but let's try again. Maybe let's take another group. Let's take I think we were going to take the rest one that we already have. So if we change the group, we need to change it also in the contract.
00:27:26.958 - 00:27:58.854, Speaker A: Let's go again. I'm a bit out of time, sorry. Okay, let's do claim with system again. So now we have the rest GitHub contributor group. We do generate zika proof, we are redirected back to the application and we can do our claim with Cismo. Okay, so sorry for that. Yeah, I think we are running out of time.
00:27:58.854 - 00:28:23.180, Speaker A: So I won't show more. If we want to build on Cismo, go to builders. Cismo IO. Here you will enter a telegram channel where you can ask for help for whatever happens. And we will be here doing this report all the weekend. Thank you for your time. Just add it.
