00:00:06.170 - 00:00:19.360, Speaker A: Hello and welcome everyone, to the Learn Web three dow workshop blazing fast smart contract development using Foundry. Joining us today is Hardvick, who will be talking us through this session. And with that, I'll pass it over to Hardwick to get the session started.
00:00:19.970 - 00:00:41.002, Speaker B: Absolutely. Thank you, Rory. I'm just going to share my screen and confirmed you all can still see it get started. Hey, guys. Hello everyone. It's been a while since I've done any global workshops. Really hyped to come back and to give you see a lot more.
00:00:41.002 - 00:01:09.202, Speaker B: We are in 2022 workshops, but today we are talking about smart contract development and testing using validate. So a little bit about me. My name is Haradit. I don't know first name legally. The co founder at Learn, an education and vibe list for this talk workshop. I'm going to be keeping an eye on chat. So I have chat a bit over here.
00:01:09.202 - 00:01:51.818, Speaker B: If anybody has any questions, you can put it in chat. I'll answer sort of as I go along. As happens, feel free to pause me at any time. And yeah, try to keep this conversational if you have any questions. So what is foundry? So Foundry is a solidity based smart contract development environment that kind of falls into the same category of tools as like Hardhut or Truffle or aperture switch you might have used before. The main difference is that everything you do in Foundry is done in solidity. So you're writing tests in solidity.
00:01:51.818 - 00:02:22.898, Speaker B: You're writing your deployment scripts and all of that in Solidity. Everything you're doing is in Solidity. Unlike for example, Hardnad or Truffle where you have to do stuff in JavaScript or in Heapworks or brownie and similar, you have to do stuff in Python. Everything on foundry is done in solidity. And we'll see there are certain advantages doing that. There's actually a very good case for doing all of this stuff in Solidity as it avoids kind of that one level of abstraction. That all.
00:02:22.898 - 00:03:00.806, Speaker B: You now also need to have an understanding of JavaScript. You also need to have an understanding of how JavaScript test sheets work. You also need to understand how to convert UN 256 to a big number and then back and forth. And it's just really annoying. So doing everything in Solidity very helpful. That's one of the key differences. You might want to consider using battery or that if you're relatively newer, if you're kind of starting out, you double tab past experience in JavaScript for Python and you're learning solidity fabric might be a better fit for you.
00:03:00.806 - 00:03:53.874, Speaker B: So you can just focus on sort of solidity based stuff all around. The second thing is, and this is actually also a pretty big deal, foundry is very fast, as much as eight times faster with the alternatives. The reason for this is Foundry was built from the ground up. It's written in rust, first of all. And everything that factory used, it totally was built from the ground up to sort of support this project. It's not really relying on external things as much compared to something like Hard Hat, where first of all it's JavaScript, then it's using the Solidity JavaScript compiler and then it's using Ethereum JS. Overall, it's relatively much slower than Foundry is now for this hackathon.
00:03:53.874 - 00:04:37.598, Speaker B: If you're just starting out again, maybe this doesn't matter as much to you right now. If you have a simple project with maybe one or three solidity files, the time difference between Hardhat and Foundry is going to be pretty negligible. And you might not notice major time differences. But as you start working on bigger projects, this time difference becomes very noticeable to the point of the Solnet Library. It's pretty famous. The Solid Library takes 6 seconds to get compiled and be set up using Pro Breed. It's going to take up to like 45 seconds on DAP tools and even a couple of minutes if you're using Hard app.
00:04:37.598 - 00:05:25.090, Speaker B: And that really adds up over time. So as you're trying to fix a bug, 5 seconds versus two minutes for compilation really adds up a lot. So it's pretty fast. It's up there. So generally Foundry is broken into three specific segments and we're going to take a look at a couple of them today. So there's Forge, there's Cast and there's Annabelle. So Forge is the main sort of the Compilation tool, the CLI, where you kind of do everything related to running, like creating a new Foundry project, compiling your contracts, running tests, all of that stuff happens with Forge.
00:05:25.090 - 00:06:07.022, Speaker B: Cast is a CLI tool to sort of send transactions to the Ethereum webwork and so on. So you can call functions on your smart contract, any network using Cast. So it's kind of like the terminal based way to call functions and stuff on Ethereum. And Addville is a local ethereum node that you can run for development data testing purposes. It's kind of like hard hat Node or Truffles Ganache? This is the local EVM implementation that just is really fast. You can run your tests against it. You can fork a network and run it, add will and so on and so forth.
00:06:07.022 - 00:06:55.582, Speaker B: We're mostly going to be focused on force today, and I will try to take you through as much as I can about Foundry and what you should care. So let's just jump into it. We should just start writing code. So the first thing you want to do is, if you haven't already installed Foundry, if you don't already have Foundry on your machine, what you want to do actually, let me just pull up the page for it first. That will be here. There is a curse command you have to run, but I will send it in chat and I will also open that page so you can find it yourself. But basically, yeah, if you already haven't installed Foundry, I'm on a macOS, so you have to run this command, you need to download the Foundry Up binary from Paradigm.
00:06:55.582 - 00:07:43.054, Speaker B: And once you've installed Foundry Up, that is the sort of package manager for Foundry, kind of like the tool you use to keep Foundry up to date and install it and all of that stuff. So I already have Foundry up on my machine. And once you've downloaded it, you just type Foundry Up and it will install the latest version of Foundry, which basically means the latest version of forced cast and andel on our machines, right? So once this is all done, we will start by creating a new project. So create an empty direct break. I'll call it foundry tutorial. Public foundry tutorial. And what you want to do is just type Forge in it.
00:07:43.054 - 00:08:34.362, Speaker B: And this will forge I am into the small folder. Yeah, see the into the folder you create and then type forge in it. And this will set up a new Foundry project in that folder. And now let's just open this up in Vs code to see what it looks like and what we have over here. So we start off, it gives us a simple solidity contract to get started, right? We have a counter contract that just has a number. You can set that number or you can increment that number over time. So the way things work in boundary, as I said, everything is Solidity, right? So you write their contracts in Solidity, but then you write their tests in Solidity.
00:08:34.362 - 00:09:04.042, Speaker B: This is a test for that contract. And then you also write your scripts in Solidity. This is where you might want to deploy your contract to an actual network and so on. Other than that, what we have is we have a lit folder which comes with the Force Standard Library installed. And we'll get into what that means. But this is really cool stuff. But just to get you familiar with the basic commands, the very basic commands that you must know are Forge build.
00:09:04.042 - 00:09:43.186, Speaker B: So once you have the project, you run Forge Build. This will compile all your Solidity files and it says, hey, compiler run successful. And at this point, you will have an out folder that comes with the Avis of all your contracts. So most of these contracts currently come from the Standard Library, but your contract counter. This is the Avi for counter solve. It comes from forged build. Once you've built it, the another basic command you need to know is forge test and Forge test, as the name suggests, runs the tests against your contract, runs the tests that you wrote.
00:09:43.186 - 00:10:36.802, Speaker B: And the cool thing about this is it actually gives you the gas cost required to run each one of your tests, since your tests are written in Solidity and you're calling other Solidity functions, that can tell you the gas cost for that test. And in fact, if you do fuz testing, which we'll get into, it also gives you the average gas price and the median gas price, average gas cost, and the median gas cost required to run that test. So forge, build and forge test. Two basic commands you must know. Okay, so this BIST contract obviously is super simple, but we'll get into a couple of neat Foundry features that I'll show you, kind of why it's so cool. So we'll start off by creating a new contract. First of all, create a new contract.
00:10:36.802 - 00:11:04.686, Speaker B: Let's call it mirror. Sol. And this is going to be an extremely simple contract. I'll just copy paste this. This is going to be an extremely simple contract, which all it does. It has a function called mirror, which takes in a number X, and then it returns the same number back, unless that number is 50. If X is 50, then it returns 42, but otherwise it just returns X back.
00:11:04.686 - 00:11:31.340, Speaker B: So 99% of the cases, it will just return the same number back. But then there's this one sort of edge case where it will return 42. So what we want to do is we'll create a test file. For this, we'll create a test file. And the convention with Foundry is your test files are named Contract T sol. So the contract name is Mirror. So this will be mirror T sol.
00:11:31.340 - 00:12:06.078, Speaker B: Once you have this test file, we write the test as a regular, solidity contract. And I will copy paste it because I already have it. But we'll walk through this ourselves. So what's happening over here? So, first of all, we import the testing framework, quote unquote, from the Force Standard Library. And the Force Standard Library comes from this Lib folder over here, rates. You can look at the test sol file that we're importing. It basically imports a bunch of other files and reinsports it.
00:12:06.078 - 00:12:42.350, Speaker B: But it allows us to write tests and solidity. And then we import the actual contract that we're testing, which is wirro. With that, we declare a new contract virtest is Test. And then we have a function called setup. So every test will have a function called setup, which initially sort of sets up the testing environment. Specifically, in this case, it deploys a new version of the mirror contract and saves it as a state variable. So you can call functions on the same contract over and over in your following tests.
00:12:42.350 - 00:13:15.174, Speaker B: Then we have two test functions over here. Again, the convention in Foundry actually, I think this is enforced, is your test functions must begin with the term test. So you cannot have a function named simple. Over here, you have to name it like Test Simple or Test XYZ. So you have a super simple test called Test Simple. And we're like, okay, assert equals mirror, mirror, five and five. So this is just checking.
00:13:15.174 - 00:13:48.386, Speaker B: Okay, if I call the mirror function with x equals five, it should return me five. It should be equal, and if it's not equal, the test will fail. So the assert equal nice helper function comes built into the testing standard library. This is pretty basic test over here. This one is more interesting. So Foundry has support for what's called Fuzz testing. And what Fuzz testing basically means is it can sort of so in this case we're setting x equals five ourselves.
00:13:48.386 - 00:14:20.378, Speaker B: We're setting x equals five manually. But in the Fuzzing test you'll see somebody say something. So in the Fuzzing test, we take x as an argument and then we just pass that argument forward. Can I send Mirror Sol? Sure. I don't know if I should just put it in chat. There you go. In the first test we take an argument and we pass that argument.
00:14:20.378 - 00:15:05.694, Speaker B: So we're not testing for a specific value of x, but what fuss testing does. And this is a more general concept than just Foundry, this is more general sort of computer science related stuff. But first testing basically means that the tester itself, the testing framework itself, will try to find random inputs to your function. It will try to find random inputs to your function and it will try all of them out. And if it fails at any one input, it will let you know. So in this case, it will try out different values of x and it will assert equals on all of those values of x. And if it fails at some point it will let you know.
00:15:05.694 - 00:15:40.380, Speaker B: So you might have guessed what's going to happen over here if we run this test. What we are going to do is let's go back to our terminal and type forge test and it may not detect it the first time. It's not running as many times right now. So by default that's a good question in the chat, really, by default. Finally tests 256 values randomly. So it runs for 256 tags randomly. And currently that's not enough to bind the obvious issue in our code.
00:15:40.380 - 00:16:02.474, Speaker B: And it depends on your sort of call. So first testing is not 100% guaranteed. You can't have it run like all infinite values. You need to set some sort of limit. And to do that in this case, so fungrate. Consider foundry POML file. This is sort of the configuration file.
00:16:02.474 - 00:16:50.206, Speaker B: If you used hard hat before standard, like the harder hat config JS file, where you can set different configuration values for cloud rates and specifically for bus testing, what you can do is add a bus parameter and set clown rate underscore bus underscore runs. And I'll set it to say 1000 writer runs. And if I run force test again, it's still passing. There we go. Tests with the range of values every time. So we reduce the number of runs even more if you want to test even more values. But in this case you can see it says test Fuz failed with the argument 50, right? So we didn't tell it to run x equals 50.
00:16:50.206 - 00:17:27.290, Speaker B: It just randomly fails under the argument 50. So it was testing for random values. And this Fuz testing is very useful. And this is obviously a very simplified example. Looking at this code, you can clearly tell some error function isn't beginning as it should. But typically these bugs aren't this easy to find. You can imagine some sort of complicated D five protocol with 100 solidity files all across the project, all sort of importing each other and inheriting from each other and having all the fancy stuff around there.
00:17:27.290 - 00:18:22.940, Speaker B: And sometimes it's easy to skip out on certain edge cases. Oh, a multiplication is going wrong somewhere or there's some dangling if condition that's going to given a certain input, it's going to be something that's not expected of it. So sometimes manual testing fails to patch certain types of bugs that Fuz testing can help you to patch. And it's really useful. That Foundry comes with Fuz testing as a built in feature and all you have to do is just take an argument, take an argument in your tests and pass that argument forward and it will automatically generate random values for those arguments. That's all you need to do. Can you define a range for those numbers? If you had to define a specific range, you're probably better off just using like a regular S function instead because you know a minute max value for it.
00:18:22.940 - 00:19:07.334, Speaker B: If it's a really large Maxwell value, I think there's probably a way I'm going to have to look in the config for it, but I do not know that off the top of my head right now, unfortunately. Okay, great question though. So that's our fuz testing. Now what else? I want to show you one more cool thing about Foundry. So let's go ahead and create another new contract and we'll call this one cheat codes. Solve and cheat codes are really bold. So we'll create a super simple contract again, as we have this contract called cheat codes, which stores a number and a last timestamp.
00:19:07.334 - 00:19:51.430, Speaker B: And it has one function called set number which takes in a parameter new number. And it just requires that the current block timestamp is greater than the last timestamp plus 120. So this basically means that set number is being called at least two minutes after last timestamp because block up timestamp returns the timestamp in seconds. So we're saying that the current timestamp is greater than the last timestamp plus 120 seconds. So two minutes. And if that is true, that the update number equals new number. And you said last timestamp equals block timestamp.
00:19:51.430 - 00:20:41.662, Speaker B: Again, a simplified example, but you can think of things like the compile and governance mechanism or like time lock related things where certain functions can only be fall in certain type intervals. Very useful feature to have generally on a smart contract, but can be a pain in the ass when you're testing for it. How do you test for it? You don't want your test to wait for two minutes just because your function cannot be called again until two minutes. Ideally, you want to do some sort of happy things around there and make it believe that kubernetes have passed. And this is where cheat codes come in. So we'll create a test for this. We'll call this speedcodes key soul and cheat codes key soul.
00:20:41.662 - 00:21:15.970, Speaker B: What we're going to do actually, let me this out. So I'll set up a basic one layer plate structure, same as before, quant cheappotes test. This test imports the standard testing library and imports the cheap code solidity file. So we'll take a reference to the cheappote smart contract. And in our setup function, we'll just deploy the cheat code smart contract. And what we will also do actually this is fine for now. So we'll deploy the cheat code smart contract.
00:21:15.970 - 00:21:56.900, Speaker B: Now, when this is deploying, when this is just deploying, initially, latch hang step equal to zero, right? That's a default value per unit. In solidity, this is equals to zero. One thing you have to note is when tests are being run, they're being run in sort of a simulated EVM environment, right? And initially, when your tests start running, your Blob timestamp is also equal to zero because it's not connected to a real network. It's equal to zero initially. So in that case, if we just try calling set number right now.
00:21:59.110 - 00:21:59.474, Speaker A: Can.
00:21:59.512 - 00:22:49.220, Speaker B: Somebody tell you what are cheat codes? Yeah, we're getting to it. We'll get into it. So right now, cheatboats is just the name of this contract. And I'm going to get into what boundary cheap pose actually artist, if we have a test, something like test set number, and we just do cheap set number five right now, this test will fail. And why will this test fail? Because when the test starts running, block timestamp is going to be zero, and zero is not greater than zero plus 120 initially. So this test right now as it is, will fail. And we can see that if I just do force test once more.
00:22:49.220 - 00:23:34.530, Speaker B: This is the mirror test, but sheetcode test over here, test set number fail with the reason editor, right? And that is the result in the require statement over here. So apparently this test is failing because zero is not greater than zero plus 122. Things to note. First thing, you can actually create failing tests in Foundry. So you can expect a certain test to fail, and that is okay. So the way to do that is to change the name from test set number to test fail set number. So this will tell Foundry we want this test to fail, and that's expected behavior.
00:23:34.530 - 00:24:09.066, Speaker B: So now if I run Foundry test once more yes. Now if I run Foundry test once more, you'll see, everything tests, everything is good. It expected that test to fail, and that's perfectly fine. But now what if we want to call the set number function once again. So create another test set number, blake and we do a set number again. And this runs into the same problem. Block timestamp hasn't moved forward by two minutes.
00:24:09.066 - 00:24:36.734, Speaker B: This is where Valerie cheat codes come in. So, Fallery has a bunch of cheat codes. They're basically things that allow you to alter the state of your execution environment. They allow you to change things in the EVM or how the quant is behaving. So that's why it's called a cheap code. These things do not work on a real ethereum network. They only work within the Foundry sort of environment.
00:24:36.734 - 00:25:20.420, Speaker B: And they're meant to make your testing easier and faster. Right. Specifically in this case, what we want to do is there is a cheat code called and cheat code is, by the way, called Biray VM cheat code name. So VM is something that's built into the standard library for courts. It's kind of like the virtual machine, the EVM that you're making direct cheat code calls to it. So you say VM warp 150, let's say. And the warp sheet code, what this does, warp sheet code increases block timestamp by whatever value you tell it to.
00:25:20.420 - 00:25:56.240, Speaker B: So when we do VM warp 150, it's going to move block timestamp to 150 and then call the set number function so our tests will immediately pass. And on a real ethereum network, it's the same thing as actually waiting for two minutes to go by. You can see this time, nothing failed. This time, cheap codes. Both of the tests passed over here, this is not the only cheat code that Foundry has available to you. There are actually a bunch of cheat codes that are really full. Let me show you the list.
00:25:56.240 - 00:26:24.550, Speaker B: And there are a bunch of cheat codes. We don't have time to go through all of them, but warp is one of the first ones you see there. Sets the block timestamp to whatever you want it to. You can change the block difficulty, you can change the block number. You can change the block coinbase. You can change a whole bunch of things. My favorite one has to be Prank, where you can behave as a different address even if you don't have the private key for it.
00:26:24.550 - 00:27:22.494, Speaker B: It's really useful in case it looks things like if you're testing something against an ave flash load and you need money to pay back the flash load, I just prank some wheel somewhere and just take 10 million dies from them and do the outlet flash load thing. Prank is pretty cool, but they have a bunch of cheap codes you can use and change a lot about the EVM within your testing environment, which makes things easier. Last thing before we head off for almost that time is a common question is how do we use all these other libraries we're familiar with? I want to use open Zeppelin contracts. I want to use solate. I want to do all these things. OpenZeppelin contracts by default were designed for hardnad, they were designed for fanbade. But fanblade supports them through you have to do something called remappings.
00:27:22.494 - 00:28:15.738, Speaker B: And let's say you wanted to create an NFT collection. So what you do is you type board install openzeplin Openzeplin contracts which is their GitHub repovation GitHub repo. And what this is going to do, it's going to download it so that you get cloned the repo into your projects. And specifically it's going to put it in the Lib folder next to the poor Standard Library. If you notice over here, you know how we are able to do import for Standard Library. Sol so basically you can import things from your lib folder including Open Zeppelin contracts and you can also change how these imports work. Let me just see.
00:28:15.738 - 00:29:04.074, Speaker B: So Forts comes with this thing called remappings. By default. It has support for three remappings, which is the Fort standard library, OpenZeppelin contracts and DS test. So what this basically means is typically if you have a contract over here sol and if I had to import from the Lith folder, it would typically look something like this I'm in the SRC directory. It's like go back, go into Lith, I go to open the link pawn cracks and then yada, yada yada, whatever you play. And just a little advice, remapping allows you to remap those packs so your imports can look clay. It comes with the open zeppelin contracts remap built in.
00:29:04.074 - 00:29:39.942, Speaker B: So instead of typing lib OpenZeppelin contracts, I can just do import openzeplitcontracts whatever. So if I have an e soul over there, I then just import it like that. Import open Zeppelin contract. And Forge will figure out because of remappings that it's supposed to grab it from link OpenZeppelin contracts and whatever. And you can see this. If I do forge build, it should build without any issues. There we go.
00:29:39.942 - 00:30:54.990, Speaker B: You can also have custom remappings. So if you take this Remapping, then you output it to a file called remappings TXT. Then you can now create your own remappings. For example, for a library that's not supported by default. Like if you are cloning the AADE repo or the Uniswap repo or whatever, you can feed your all remappings for it over here. But as an example, let's say I want to create a Remapping called ERC 721 ERC 721 solve because it takes me directly into that specific folder where I need to go. And now again, if I import build the result file, something went wrong for your lib oops equals lib.
00:30:54.990 - 00:31:33.354, Speaker B: I messed something up over here. Now if I do a course build see, it works perfectly fine. That is all I wanted to cover about. Finally today bunch of cool. So we cover bus testing, we cover cheap codes, remappings and imports. It's obviously pretty fast on files have been taking less than 1 second to finish. On hard hack, this would generally take decently longer.
00:31:33.354 - 00:32:05.426, Speaker B: And yeah, I'll take a look at chat now for any other questions. Oops, I did not need instruction by Sweet. So let's go back to the slide deck. And there we go. Full. So, yeah, guys. What? Yeah, so that is that.
00:32:05.426 - 00:32:27.174, Speaker B: Thank you for listening. Let's take a look at Chad. Yeah, if you want to learn more about building in Web Three general just learning about Web Three general, hit us up at learn. Web three at learnweb three IO. Or you can find us on Twitter and Discord. Always there if you have any questions. So remapping raises some errors.
00:32:27.174 - 00:33:07.762, Speaker B: Did not find the file. You have to create a remappings TXT file in the root of your project. You can either do that manually, or you can run Forge remapping remappings TXT to input it directly over there. I do not use emacs. I am OBS code plan. I don't know for a complete beginner between Hardat and Foundry, depending, it depends on your background. If you already know JavaScript and you're just getting started in the space, and you're only making small projects, hardat is probably easier because you already have that knowledge.
00:33:07.762 - 00:33:54.920, Speaker B: But there will come a point in larger projects where Hardat starts getting a little bit annoying. And changing between data types for Solidity and JavaScript can get a little bit tedious. You have to constantly convert data types back and forth, at which point doing Foundry would be better. However, there's nothing stopping you from just starting off with Foundry. At most, you'll learn some even more solidity. With that point, your install fails. Are you on Findens or Linux or macOS or whatever? Are you getting sure? Can we expect a defined reason on the test fail? So actually what you can do is you can log things.
00:33:54.920 - 00:34:55.126, Speaker B: I did not show that, but let me bring that up. So when you're creating test files, they have a bunch of logging helpers in the standard library. So you can do stuff like long underscore UN or long underscore string or long underscore address, whatever it may be. And if you run it, you need to run it with a verbose mode. So if you just do, like, force Test, these logs will not show. But if you do, like, forged test V with verbose output, it will show you all these logs. Regarding defining specific reasons, specifically for asserts, what you can do over there is if you look at all of the different assert helpers that exist I showed you assert equals.
00:34:55.126 - 00:35:31.480, Speaker B: There's a bunch of other ones, but you can absolutely provide a string. I don't know if this is very readable, but you can absolutely provide a string with the cool arguments for assert equals or any of the other asserts, which will be the error that shows up if an issue happens. Yes, Foundry was written at Rust op three DSPO solidity developer extensions. I think I just use water, really, which I. Believe is just for visual. Solidity developer. I believe that's what it's called.
00:35:31.480 - 00:35:55.826, Speaker B: This one. That's pretty much the only thing that I use. I used to use some of the other app extensions, but this one covers most of what I need. Cool. Sounds like that's pretty much all the questions. I don't know if I missed anything, but yeah. Thanks, everyone.
00:35:55.826 - 00:36:06.878, Speaker B: We're overtime. Roryal, back to you. Check us out at learn. Web three, and if you have any questions, reach out. We'll get back to you. Cheers.
00:36:07.054 - 00:36:15.842, Speaker A: Yeah, cheers. Thanks so much for joining us today. Great presentation. And, yeah, as Hardik said, reach out if you have any questions, but, yeah, awesome.
00:36:15.896 - 00:36:16.174, Speaker B: Cheers.
00:36:16.222 - 00:36:17.466, Speaker A: Thank all so much.
00:36:17.648 - 00:36:19.990, Speaker B: You relate. Bye.
