00:00:07.290 - 00:00:43.526, Speaker A: My name is Simeon. I'm integration lead for Neon EVM. So how many of you are developers and hackers here? Are there any hackers? Okay, nice. How many of you use hardhead develop framework? Okay, only a couple. How many of you use Foundry? Wow, a lot of Foundry users. Okay, that's good. And yeah, today I will talk about what Neon EVM is and how do we help scaling Ethereum DApps.
00:00:43.526 - 00:01:46.858, Speaker A: So I guess for all of you happened a lot that you want to swap your ten USDC into some shit or scam coin on Ethereum. And basically at the same time some degen NFT collection is out and trending and everyone tries to mint it. And basically gas fees are going to eat all of your ten USDC that you have saved for months. And I think that's pretty bad. And one of the main, I would say disadvantages for Ethereum is that one trending DAP can congest the whole network. And this actually is not really beneficial for all users. So what did we build in Neon EVM is we built an EVM that is using the architecture and basically execution layer of Solana.
00:01:46.858 - 00:02:52.670, Speaker A: And a lot of people and hackers ask me, is it a layer two, is it a layer one? Actually, it's neither a layer two. It's nor a layer one. It's actually something in between. And let me just show you a quick slide of the architecture. So as you can see, Neon EVM is actually not anything more than just a smart contract in Solana that can execute EVM bytecode in Solana virtual machine. So we have built a smart contract in Rust that understands of EVM bytecode and can execute this bytecode without the Solana virtual machine. But with only having this smart contract, basically we can't really bring up Ethereum developers and EVM users because basically they would need to change their tech stack and Ethereum users can't really use MetaMask or their EVM wallets.
00:02:52.670 - 00:03:49.750, Speaker A: So we have also one more pretty important component called the Neon proxy. And as you can see, the Neon proxy on the one side actually accepts Ethereum like transactions. It provides just an ethereum RPC API. And on the other side, it unwraps the Ethereum transaction, creates a Solana transaction and calls our Neon EGM program inside it. And you're going to ask, okay, how do you, for example, solve scalability issues? And it's simple. It's simple because of Solana parallel execution. And actually how Solana works is that let me just show you one more slide.
00:03:49.750 - 00:04:47.542, Speaker A: Yeah, I think Solana is actually stateless. And basically when constructing a Solana transaction, this is actually what a Solana transaction looks like. And as you can see below the header, we have the account list. So this account list basically defines all the accounts that are going to be read and written for this transaction. So if we have two different DApps, let's say we have one Dex and one NFT collection, and if we have two same transactions posted at the same time. Those transactions are going to be executed not sequentially but parallel. And that's actually the whole example that I gave you.
00:04:47.542 - 00:05:17.646, Speaker A: That one DAP cannot congest. The whole network actually holds for Ethereum but doesn't hold for Solana. The gas prices will go up only for that app but for other DApps the gas prices will remain low. And this is something that you can actually use. And also let me just go to the other slide. So we enable developers deploy on Solana but without changing their tech stack. The same as users.
00:05:17.646 - 00:06:15.590, Speaker A: They can use MetaMask, they can use their EVM accounts. So if you are using Hardhead, if you're using Foundry, it's all right, you just change the RPC to our RPC and you can deploy. Another good thing is that our main aim is to become fully interoperable with Solana. So for now we only showcase and I'm going to show you how we can deploy a Solana SPL token as a wrapped ERC 20. And basically you can underlyingly Mint, you can underlyingly transfer from your MetaMask and SPL token and you can use in your DAP. So let's just go and see. This is just a very simple hardhead project and this is the interesting part.
00:06:15.590 - 00:07:14.454, Speaker A: So you can see we have token that is called ERC for SPL. And you can see something very interesting. Here are the two Solana token programs that are basically Neonivm has pre compiled contracts that can interact natively with Solana, SPL and Metaplex. And you can see we have wrapped the whole ERC 20 interface with calling the underlying SPO token. So we also have a deployment script you can see. So what the deployment script does it deploys a token and then after that it means to the deployer account just 100 tokens. So let me show you, let's just run and wait a little bit.
00:07:14.454 - 00:07:49.810, Speaker A: Let me just show you what in the configuration we have to do. Basically, as you can see, we only add Neon DevNet as another network. If you go to Neon Docs, you can see that here are all the materials. So you can see how to configure and choose DevTools. We have the neon faucet. Basically you can connect to your MetaMask, just request 100 tokens. You're going to see our MetaMask.
00:07:49.810 - 00:08:56.450, Speaker A: Yeah, we have received the tokens and yeah, you can just go ahead and deploy. So our token is deployed if we come and see let's find Neoscan. Yeah, so this is our native Explorer. So if we go to DevNet okay, and now you can see that we have two transactions. The first is contract created and the second one is Mint. Basically we can also if you want, we can basically verify our contract. Let me just see.
00:08:56.450 - 00:10:53.908, Speaker A: We need the four parameters and we need the deployer address. Let's just take it from MetaMask because that's the deployer. Okay, so now we should verify our contract again is the same as verifying with Etterscan okay? False PYT code mismatch maybe we need to less trench it. Okay, anyways, let's just not lose time with that and I want to show you some interesting things here in this transaction. So if we come and basically add our token I guess the problem here is in hardhead some cache so if I had just cleaned all the cache and artifacts maybe it will work. So it's not a big deal. Let's just add our token in our okay, you can see we have the token and we have 100 tokens.
00:10:53.908 - 00:12:13.620, Speaker A: So the most important thing is that you can see the transaction hash and you can see we have one underlying Solana transaction, right. Because we have deployed our contract on Solana and it's an actual if we click, we can basically see that this is the Solana Explorer and we can basically see that we have minted 100 tokens on Solana, on SPL. So that showcased that we have actually interacted with the Solana SPL program and let's just try know we have the token here right now. Let's just send it to let's say this account just copy this account. Let me just send 50 tokens. So right now we are transferring from one account to another EVM account but underlyingly we will also perform the SPL transfer in Solano network. So it's confirmed.
00:12:13.620 - 00:13:24.952, Speaker A: Let's see what happens. So this is the transfer as you can see, we can see that we have transferred and also we have one underlying Solana transactions and the Solana transaction actually transfer from this account to the other. As you can see this is something interesting here the addresses are the same but actually the transfer from and to is actually in this account metadata because basically Solana is a little bit different than Ethereum solana is stateless. So I can show you another slide. This is a typical Solana program in a nutshell, Solana is like a big file system. So you have two types of accounts you have program account and you have a data account. So you can see that a Solana program has some executable BPF bytecode and we have a flag executable.
00:13:24.952 - 00:14:28.530, Speaker A: So this is an executable stateless contract and how does the contract create a state by itself is it creates a Solana data account for itself and actually saves the state there. So basically how Neon EVM works is basically Neon EVM is a stateless smart contract that can execute bytecode. And you can see we have Neon account which is like an externally owned account which is like a data account. And inside the data we have all the Ethereum metadata. For example, Ether address, node balance and so on. And for example, Neon EVM can deploy another contract and the same those contracts, when they want to save their state, they create theirselves another data account. So that's pretty much it.
00:14:28.530 - 00:15:51.520, Speaker A: I think we have three or four minutes left so I'll just leave it for some questions. So as we can see, we have native interoperability with Solana but in the future we will try to achieve a full interoperability so the developers can use any contract, can integrate with any Solana smart contract only by using Solidity and using their EVM DevTools. Yeah, I'll leave some time for questions if you have maybe something interesting like we have all the most important materials here in our docs. We also have some tutorials how to deploy with Hardhead and so on and so on. So it doesn't really matter how. If you want, you can just start as a beginner and just deploy on Neon EVM. It's not that hard.
00:15:51.520 - 00:17:10.320, Speaker A: Maybe yeah, maybe I can share something interesting that we are almost going to start and introduce support for Solana NFTs so for builders that are interested in some Solana collections, they can deploy their DAPs on Neon EVM and basically use their Solana collections soon and introduce them to their DAP. Or if you want to use Solana liquidity you can just, let's say deploy a uniswap V two fork and basically deploy a pool with SPL tokens on Solana. Or deploy a pool, maybe create like hybrid pairs like SPL and DRC 20 pair or anything like that. So it brings up a lot of other possibilities for DeFi as well.
