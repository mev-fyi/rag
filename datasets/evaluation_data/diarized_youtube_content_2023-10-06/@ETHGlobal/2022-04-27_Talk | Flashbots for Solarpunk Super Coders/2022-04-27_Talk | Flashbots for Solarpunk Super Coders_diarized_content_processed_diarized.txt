00:00:14.370 - 00:01:41.090, Speaker A: Hello. Does it work? Yeah. So just going to wait a few minutes, maybe some people are going in or out and then we start in like one or two minutes. Thank you. Well, I think since the talk is a little bit short, we just jump in and if people stream in later, then we should still be ready for the code examples and the technical details. So let's say hello, I'm Chris from Flashbots and here's my colleague Mateosh. And we are happy to give an introduction for developers in what we do and how you can actually play with it and with our infrastructure.
00:01:41.090 - 00:02:29.390, Speaker A: So I guess I would like to know who is already familiar with Flashbots here. All right. Have you used a flashboard protect already too? Send a bundle ever manually. All right, okay, that's good. Then we have a little bit of context, then we dive into more of the technical details. So if anybody's interested the slides, they are online and it's linked again at the end. So the talk is titled Flashbots for Solarpunk supercoders and it's because we share the democratization values and openness and permissionlessness and maximizing the social good ideals at Flashbots.
00:02:29.390 - 00:03:40.310, Speaker A: So we really try to contribute to a open permissionless system where much of the value is available to the community. It is very important, like we really strive towards open, supporting also the future of Ethereum. In this talk it's just a little bit about us Flashbots, which APIs and services we have and then common libraries to interact with us. And then I show you a couple of code examples and there is an example project that you can clone. I'm not sure if you're familiar with the background with PHA wars and miners searchers trying to extract value from the public mempool and miners doing their own things like front running and back running transactions. And this was having a very centralizing force. And flashboards came up with some research as basically a research collective that focused on illuminating the dark forest, which means making what is happening and what is going on more transparent with in form of writing of videos, of data.
00:03:40.310 - 00:04:31.542, Speaker A: We have a bunch of dashboards that quantify the amount of mev that is extracted and also about how to tap into that, how to become a participant in the whole network, to democratize it, so that not only a very small group of privileged players have access to this, but that this is a decentralized nature where people where everybody if you have ideas, you can just tap in and become a participant in the network. This is a very important thing because the centralizing effects they just also compound and the distribution of the mev benefit. So our goal is to maximize social goods as well. There's some writings like you can easily find it on writingsflashbots. Net or on docsflashbots. Net. There's a lot of background and context that you can find.
00:04:31.542 - 00:04:53.498, Speaker A: There things we do let's get into the more practical side. We have the flashbots relay. Flashbots protect. We have mev inspect. So the relay, which basically is the central entry point for the bundles and simulations that forwards the bundles to the miners. So you can use this API. The API is a little bit tricky to use because you need to sign the requests.
00:04:53.498 - 00:05:44.862, Speaker A: There's a couple of robbers that you can use in libraries for Python Go JavaScript TypeScript. Rust and I will dive into them later. Flashbots Protect is a user facing service where you can set your wallet endpoints to RPC flashbots net and it will route valuable transactions through Flashbots so your transactions will not get front run. And you also have a reverb protection with that. You can actually disable the reverb protection by using Protect with fast mode, which routes direct transactions without simulation to the miners. So if you just visit RPC flashbots net then you will have a table with the advantages of both approaches. But it's usually a very simple way to protect your transactions from being front run by bots from the public mempool without needing to do any signing or anything.
00:05:44.862 - 00:06:38.474, Speaker A: It's like just a MetaMask endpoint or whatever. Mev Inspect is a Python tooling that automatically inspects the new blocks and the blockchain also historically to quantify Mev opportunities, be it front running, back running, Arbitrage and other things. We have a pretty wide range of things that are quantified there and the data is shared on Dashboard and explore flashboard Net. So visit that if you want to have some charts that give you insights into how the trends are developing over time. Most of this is also open source software, so we appreciate contributions. It's pretty easy to jump in, it's very easy to participate on open issues or PRS or get most of these things even running locally for yourself. Of course, we have Mev GEF, which is a Go Ethereum implementation that has a couple of additional features.
00:06:38.474 - 00:07:32.766, Speaker A: So you can do transaction simulations there where you can send it a bunch of transactions, a bunch of bundles, and it will simulate those against the state that you specify. And then it returns you the value difference for what is it worth a minor. And you get a couple of additional informations about individual transactions. And it's very useful for quickly working locally with the Flashbots release stack. We do a lot of research and collaborations. There is a lot of open research, we writings and specification work in collaboration with a bunch of teams and de wide ranging collaborations and also always are opportunities to contribute. We are hiring as well, so if you're interested, look at Flashbot's jobs.
00:07:32.766 - 00:08:11.626, Speaker A: There is a bunch of open opportunities, especially for engineers, plus points if you have a Go experience. It's a very collaborative environment. I would definitely encourage you to take a look at that if you are interested in opportunities and also check out our GitHub repository, it's GitHub.com Flashbots. I touched on this briefly. Using the Flashbots infrastructure gives you a couple of advantages like privacy, front running protection, river protection, block priority. So the bundles, they are added on the top of the block and it lifts also certain transaction size constraints.
00:08:11.626 - 00:09:13.890, Speaker A: So if you have like large data that you want to send through, gaff won't let you do that through normal transactions. I think it's like 500 KB is a size limit. So you need to do something very interesting to actually go over this limit. But there is a bunch of use cases and this transaction size limit is also not applied through bundles. Quick overview how it really works. Users send transactions to the Mempool, goes to the miners, then there is the searchers that look at your transactions in the Mempool and slip in a transaction right in front of it that does whatever they can do to maximize their value based on the impact your transaction has. Of course there is like very quick growing segment within a few weeks it was like ten bots that competed against each other and this leads to a lot of transactions by bots that are in mined into blocks.
00:09:13.890 - 00:10:11.634, Speaker A: So here we have the solution. Here is Flashbots with Mevgaf and the flashboard Three where searchers do not send their transactions back to the Mempool, but they send it to the flashboard Three. There they get simulated and sent to the miners and the miners will only include those if they do not revert in the end. So basically it's also for searchers advantages because they can send and resend better and better bundles but do not get penalized by having a bad bundle actually mined and losing the transaction fees. Flashbots Protect is currently completely excluding searchers or bots that transactions get routed directly from users to Flashbots to the miners. There is thinking about how to involve searchers in a non front running way that's coming later. And we also have mev boost.
00:10:11.634 - 00:11:41.742, Speaker A: I don't know, are you guys familiar interested in Mev Boost? It's basically an approach to proposal builder separation for Ethereum Two that is currently very also collaborative project with a big part of the community and we try to think through all the challenges and get the approach that it's possible that a consensus client, besides talking to the execution client, can also get additional private transaction flow. So there is relays that send basically blocks to MEV Boost which runs as part of the validator consensus client node or instance and the consensus client can then choose which block to use. If it's coming from MVB Boost, then the transactions are not revealed, only the header and the validator signs the header and only after he signed the header he receives the block payload which guarantees transaction privacy here. So this is a very interesting project. I encourage you like the specification is all on GitHub, as you see here flashboards Mevboost or if you search mev boost on Google, you will find this very easily. All right then, let's dive a little bit into the technical details. This is the APIs that we have if Call Bundle and if Send Bundle is our classically most widely used APIs.
00:11:41.742 - 00:12:38.478, Speaker A: Call Bundle allows you to simulate bundles so a list of transactions and you get the information whether they have rewarded, how much value they provided and so on. And with Send Bundle you can actually send it to the relay where it will be simulated internally again. And if the simulation succeeds, it will probably go to the minor except of a time of very high load where there is some rate limiting. If Send. Private Transaction is a relatively new API that we have, which does not require the payload signing. No, it requires a payload signing, but you can use a similar API to flashboards protect too. So Send Private Transaction, you Send one single transaction and it will internally get sent as either bundles to the relay because the bundles, they are only for one specific block.
00:12:38.478 - 00:13:40.422, Speaker A: So it's kind of a little bit of hit and miss if you get included. If there's like a lot of competing transactions and Send Private Transaction abstracts this that it will send it automatically for up to 25 blocks until your transaction is included. So if you're developing and you want to just an easy way to send transactions privately but don't have all the issues of resending and checking, if it's included, you can just send it to Eve send private transaction and of course, you can also use the RPC endpoint where you can use Send raw transaction that will either route non valuable transactions to the public mempool or if it's a valuable transaction through the flashboards relay through Send private transaction again. So if you send it to the RPC, it will use Send Private Transaction internally. The RPC endpoint is also open source software written in Go so you can take a look at that. Also you can run it locally very easily. And we also are always happy about contributions, issues, pull, request feedback, whatever.
00:13:40.422 - 00:14:32.918, Speaker A: If you run into anything, we encourage you to open and get in touch. And here is maybe the more interesting thing for hackathon. Like exactly how would developers what's what's the easiest way to interact with the flashboards APIs depending on your programming language? In Go, it's this flashboards RPC library. Maybe in Python it's the web3 Pi PY flashboard Provider. If you use JavaScript TypeScript, it's the Ethers provider and we also have one. There is also a community built one for Rust and I wanted to show just a few code examples how to approach that. And I decided to use JavaScript TypeScript because for a hackathon it's usually very accessible and you can maybe reuse the same code across backend and front end with node JS and the browsers.
00:14:32.918 - 00:15:09.250, Speaker A: So I will jump into that and show life with the Flashbots Ethers provider. So the repository, if any one of you is interested and I'm sure we can somehow publish the slides later, it's GitHub.com metacrist, this is my username and then it's the flashboard Ethers example. So if you just go on GitHub metacrist you should find it on the repositories. So I will show you now some live coding here. So basically what I did was Git clone the repository. It's in the README.
00:15:09.250 - 00:16:02.310, Speaker A: It's built on some TypeScript boilerplate project that does the right dependencies and that you can bundle the code as a node JS executable or for the browser with es build. So it's a little bit outdated maybe, but it is something that gets you started very quickly and that you can just install right now. So it's probably easily transferable to other things. But I'm familiar with that, so I use that. How it works is you clone the repository, you install the dependencies with yarn and that's basically all the setup you need. Here in the source directory there is four different main TS typescripts with increasing complexity and this is included from CLI TS. It's basically just include the run method and run it or from browser.
00:16:02.310 - 00:16:44.500, Speaker A: So is it large enough? Should I make it a little bit larger like this? So, the first example is a very simple setup of Ethers. This has a hard coded girly API key for infura. So I will deactivate this in a day or so, but feel free today to play with that too. It's in the configuration here. This is just some randomly created private keys because it's a little bit tricky how to handle them if you build for both the back end and for the browser. Because for the back end usually you would use a process environment variable, but for the browser this is not existent. You can use es build to replace these variables in the build process.
00:16:44.500 - 00:17:22.858, Speaker A: That's very easy. But yeah, it's up to you how you handle this. So, for the sake of simplicity, I just hard coded these values, but you really should not check them into code. So don't do what I did here. This is really for just for example, it has no values chain 85 and some helpers and is the girly relay endpoint. So in the first example it sets up a e first infuria provider, gets a block number and then gets the block for this number. It's kind of a very simple example and let's just run this a little bit smaller.
00:17:22.858 - 00:17:55.526, Speaker A: So you can run this in the CLI mode with yarn CLI. This is also written in the README. So here it fetches the block, the block number first and then the block. That's it. And in the README we also have the information what else you can do. So you can build it for the browser with yarn ESP browser and you can add colon watch so on every change in the code, it automatically rebuilds. There is no hot reloading.
00:17:55.526 - 00:18:41.334, Speaker A: So in the browser you still need to manually reload the code but it will automatically build it if you change anything. So it's waiting for changes. It's all fine, you open the browser test how do I do that? I think like this and here it's doing exactly the thing. Let's reload to see it better. So it's getting the block number and then it's getting the block and then here you have the block details and it all runs in the browser. Maybe if you target the browser instead of an infura provider, you do like a I think it's called default web free provider that connects to your MetaMask. So MetaMask can then sign your transactions and then broadcast them.
00:18:41.334 - 00:19:46.170, Speaker A: So you don't need infura. But this is up to you. But this shows you it's really kind of simple to reuse the same code with some constraints in both the backend in node JS as well as in the browser. In the second example, in the second example we create a transaction and in the third example we simulate it. In the fourth example we send it to Flashbots and get some statistics. So it's the same code as before, it's just that we create a wallet and here we get the maximum base fee for the future block and then we create a wallet with two, the wallet address and a bunch of parameters and basically that's it. So to use that you would for instance go in in CLI, choose main two and then you can run yarn CLI and then here you can see the transaction.
00:19:46.170 - 00:20:33.910, Speaker A: So in the next step it's exactly the same code, except that here we also add a simulating part. So basically you have to choose a target block which is the latest block plus one in this case. And then we simulate it which means it sends to the flashboards relay with Call bundle, the Call bundle API. The request is properly signed and then it returns you the simulation result. Let's see what this does. So I again go to CLI and just import this from main free and run yarn CLI again. So what do you think will happen with dummy keys? Exactly? Simulation is successful in the sense that it was simulated and a response has been received.
00:20:33.910 - 00:21:35.354, Speaker A: But it was of course invalid because in this empty wallet there is insufficient gas to send the transaction. So this is a simulation result that the transaction itself had an error. So success. Basically it's really up to you how you want to craft the transactions or where you get them from. And here, finally, in the fourth example, after simulation, if it's not an error, if it's not an error, we submit it to the relay with Send Raw bundle there's Send Bundle and Send Raw Bundle. In this provider, send Raw Bundle means the transaction is already signed and because it's here, here it's signed and if you do send bundle, it will sign it internally so it submits the bundle. But it won't happen here because the simulation has an error.
00:21:35.354 - 00:22:35.048, Speaker A: But we can comment this out and still send it anyway. Let's see what happens. I need to import main four, but where is that 72 oh yeah, simulation. Yeah, exactly. So this is here, it's just a compiler error basically that there's additional APIs that this does for you. And because I commented out the simulation error response, you cannot actually get the result. But there is two more additional APIs that's called bundle stats and user stats where you can query the flashboard relay.
00:22:35.048 - 00:23:23.484, Speaker A: Like how did this bundle do? What happened with this bundle? Did it have a reputation? Impact and user stats for seeing the reputation and some data about your signing key. Because we create basically we have two private keys here, one private key for your wallet and one private key for signing the requests that go to the flashbacks relay. And this signing key is impacting, whether you will end up in a high or in a low priority queue in times of high congestion. When we have a lot of traffic, the high priority signing keys will get simulated faster than those with the standard low priority. And it's pretty easy to get into high priority. You just need some successful bundles. So let's try this again.
00:23:23.484 - 00:24:28.538, Speaker A: And I hope I saved. I probably not, I need to save it's not like this. So the bundle here was submitted, but that it tells you here that the block that you sent it for has passed without the bundle being included. So kind of what we expect here, but it shows you if you want to interact with the flashboards relay from JavaScript, like this is all that you need to do and then you can do some additional user experience with error handling and so on. But this is a very simple way to get started in my opinion. Personally, I think for back ends the Go code is even a little bit simpler and more straightforward, but I think that's probably not true either. Okay, just going to wrap it up if you're interested.
00:24:28.538 - 00:25:42.980, Speaker A: Again, take a look at GitHub metacrist Flashbot e first example, and here you have the full code of the examples, but also if you're building applications or infrastructure services, user facing apps, be mindful of mev like mev exists. It's exploitable very often and it's not a great approach to just don't think and don't care about it too much. It's really important, like if you're a developer that you have some thoughts about how does your code, your application, your infrastructure impact users and emit mev because it is going to be exploited and this can be disadvantages to users or lead to centralizing effects. So if you have questions like there is a flashboard discord where there's very active discussions and it's very easy to get in touch. So if you want to get feedback also on your applications about possible mev, it's definitely relatively easy to get in touch. Also, Mateosh is here, so he is one of our mev experts, and he will also be able to answer a lot of questions. And I'm available after the talk too.
00:25:42.980 - 00:26:28.500, Speaker A: So that's it. I think we rushed a little bit through it, but if you want to collaborate easy, just join Discord, read the docs, join GitHub, and if you want to build something, I hope you have a lot of fun. Thank you. So maybe we have a few minutes for some questions. Any what is on your mind? All right then. I hope you enjoy the hackathon and happy hacking.
