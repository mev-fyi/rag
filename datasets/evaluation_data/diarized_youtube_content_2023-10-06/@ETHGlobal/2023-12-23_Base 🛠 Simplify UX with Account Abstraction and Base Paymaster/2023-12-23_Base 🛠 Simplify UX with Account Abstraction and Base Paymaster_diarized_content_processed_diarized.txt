00:00:06.650 - 00:00:43.530, Speaker A: Hey, I'm Carl Fluke. I'm a developer relations here at Base. The agenda today I'm going to run through really quickly kind of what is the thesis of base? What are we trying to build? I'm going to go over pretty quickly about four, three, three through seven account abstraction, just so I can kind of level set for what is happening. What is validation, mission execution? How does a paymaster work? I'm going to run through. I may actually flip this order. I may do a hard hat deploy first to just show how you can use account abstraction in the deployment process. And then lastly end with a front end demo of how an end user experience looks when you're trying to use account abstraction with Paymaster.
00:00:43.530 - 00:01:33.638, Speaker A: So why base? That's always the first question we get is why did Coinbase decide to roll out a layer two? So the big thesis that we have is that on chain users continue to grow. We've seen Ethereum scale and we see it continuing to scale. So as we have more of those users, we have more developers on chain. And that's kind of a key thing that we want to keep growing, is having developers actually building products to help consumers be successful on chain. As we get more developers, then we actually have the bandwidth to start to tackle new use cases. So some examples that we have on base here are like friend Tech was a new social fi application that brought a ton of users on chain, and it was very user friendly with the user onboarding. If you're ever in New York City, Blackbird is a restaurant loyalty.
00:01:33.638 - 00:02:06.274, Speaker A: They offer a bunch of coupons and loyalty programs for certain select restaurants. Parallel has brought a card game on chain. They're starting to innovate in that gaming space. Base Paint XYZ, if you've never seen them, it's kind of like Reddit, our place to where it's pixel art. Every day they have pixel artists make a new image and then you have one day to mint it. So very consumer friendly to where there's a lot of crypto behind the scenes, but it's usable. And then lastly, we have like our crypto stand with crypto.
00:02:06.274 - 00:02:33.518, Speaker A: So just bringing more advocacy and government things on chain. So most importantly, you can see this. I thought the Internet wouldn't work. So you should see a blue line that has ethereum essentially at capacity for the past two or three years. And then you'll see there should be a red line to where l two s are now, like five x the throughput of what l one is. And we expect that to continue to grow. Okay, this one worked.
00:02:33.518 - 00:03:05.720, Speaker A: So although that we've seen all this growth, we have more users on chain. We're still far from actually bringing the mass adoption. We're less than 10 million people and there's 8 billion in the world. So we have a long way to go. And some of the key blockers that we see is cheap block space. So l one was very expensive. I think we saw that after a DFI summer people were much more questionable about like can I spend $15 or $20 for a Dow vote? And some of that on chain activity started to slow just due to the price wallet technology.
00:03:05.720 - 00:03:43.810, Speaker A: So although developers are very used to the current wallets, they're used to the chrome extensions and the mobile apps, they're still very financially focused and I think we have a long way to improve them. And lastly, identity. The blockchain is a permissionless anonymous world, but once you start to add identity things you can start to have primitives like credit. So there's definitely some interesting growth for identity on chain. Coming base has been live since August, so we're four and a half months in now. Here's a long list of our which is not loading. Also, sorry, there should be like 100 dots here with eight categories.
00:03:43.810 - 00:04:18.400, Speaker A: But we're continuing to grow. So that's the quick thesis of base is we want to bring more developers and more users on chain. Coinbase has 120 some million KYC retail users and we're trying to slowly bring that audience and that capital on chain. So what is some fun things that base has been trying to improve in the op stack? The first was that we had a canyon fork upgrade. This was three weeks ago, I believe we deployed it to testnet and this makes it so that it's fully equivalent to l one. You can use the newest versions of solidity. It has a couple of other upgrades to it.
00:04:18.400 - 00:04:49.834, Speaker A: We moved our testnet to Sepolia. So if you're not aware, Gorely testnet is going away at the end of January. So it's going to be a slow migration of all of our devtools to sepulia. Some teams have started but there's still a way to go. Something very relevant to this talk is that we've been experimenting with a paymaster. So how can base as a protocol make a paymaster and help onboard apps and make them more usable? I'll go into depth as we get there. Two big protocol upgrades that we're actively working on.
00:04:49.834 - 00:05:28.820, Speaker A: Currently targeted for like early February is the dencoon layer, one Ethereum update. And this would make the first step of dank sharding happening, which should reduce gas costs for l two s by 60% to 80%. And so everybody's looking forward to that. As far as the l two world and then one more recently, EIP 7212, that makes it so pass keys could natively use their signatures on chain. Today. You kind of have to do some trickery of you can still use the pass key signature, but then you're kind of using a temporary key. And so we're looking at actually enshrining that into the base, l two.
00:05:28.820 - 00:05:52.570, Speaker A: Okay, so super quick run through of base there. Now let's talk about actual four three seven so we can level set so the demos make a little more sense. And my picture is still not loading. Okay, so the first most important part is you have user operations. I do have it now. So we have user operations here. Instead of transactions, you have these things called user ops.
00:05:52.570 - 00:06:30.620, Speaker A: The main advantage of user operations is that with 4337 you can batch these and multicall. So if you're doing DFI things in traditional world, you'd say, hey, I want to join this USDT pool. I have to approve USDC, I have to approve USDT. I then need to put what amount I want and then I get some kind of c token and I probably want to stake that for more rewards. So in an account abstraction world you can actually do all four of those in one batch transaction and the user approves something once. So that's kind of user ops is they more or less replace transactions. It just means you can also do more than one at a time.
00:06:30.620 - 00:06:55.890, Speaker A: Next is the bundler. There's quite a few bundlers out there, but the bundler is a resource out there that essentially collects all these user operations and they bundle them into transactions. So that's what makes multicall possible. And that's also what can help reduce the gas cost of user operations. Next is the entry point. It's probably the least exciting thing. That is just where the bundler sends these user operations to.
00:06:55.890 - 00:07:26.246, Speaker A: And that entry point knows how to validate or execute transactions. Then we have our contract account. So that's actually which smart contract wallet am I using? There's a lot of interesting stuff happening in that space. Now there's another eip out there called 6900. That's like standardized plugins. And some like biconomy and alchemy are starting to bring that first party, which is interesting. I'll skip over aggregators, but then you have the paymaster.
00:07:26.246 - 00:08:04.418, Speaker A: So the paymaster essentially allows the bundler to say, hey, this paymaster contract is actually going to pay for my gas for my user. And you can set kind of dynamic criteria of which users do you want to pay gas for and for the UX of this, that's really what I think matters the most for today. So to run through kind of that in more of like a hey, what actually happens with these user ops? This did load perfect. So we have this collection of user operations. They sit in this mem pool. The bundler looks at that mem pool, it bundles them. Then you see this loop for validation.
00:08:04.418 - 00:08:48.598, Speaker A: So it looks through all those user ops and says, hey, can I actually execute this? And that's where the smart contract wallet can actually say yes, I want to or no. So if you want to put guardrails over like spending a certain amount per day, or you want to put custom validation logic, you can, after you validate all of them, then you look through actually executing them. So that's taking that call data and actually calling what you're trying to do. So that's approve token one, approve token two, or whatever your use case is specifically. And then lastly is that simplify gas? So you can have the paymaster sign that they want to pay for this user operation. And then I'll show code examples of kind of like how you can actually do that. Okay, so we're going to do a demo.
00:08:48.598 - 00:09:27.150, Speaker A: I'm going to do this backwards. We're going to do the hard hat one first. So let me, how does this look? That's good enough. Okay, so in a traditional hard hat project, you'd probably see it very common that you would just say, hey, I want to deploy a contract. And you would just give it the name and the system would be smart enough to actually look at what is the file that matches that in your contracts folder. So here's just an example. I'm deploying a smart contract.
00:09:27.150 - 00:10:02.620, Speaker A: I'm logging what is its address. I'm storing a number in it. And then I'm just showing that I can also read that number. If you need an example and you want to deploy through smart contracts, this is kind of like the easy code example to start. So once I take that to the account abstraction world, this will show you how to do it with alchemy's account kit. So this kind of runs through the setup of how do you actually go from an eoa to being a smart contract wallet. So I'm pulling out the paymaster part here.
00:10:02.620 - 00:10:54.250, Speaker A: I'll end this section with that. The difference is since we have to pull that Abi and bytecode out of the compiled contract. So once you actually compile a contract, you get these artifacts and the parts that actually deploy on chain that matter is this storage JSon file. And so you want this Abi, which is your definition of saying, hey, what are my read methods? What are my write methods? And then equally importantly, you want what the bytecode that gets compiled, that's what actually gets sent over the transaction. So once I have those, I just am doing some setup of what chain, what addresses do I want to deploy. I'm loading my eOa, I'm creating that alchemy provider. So this is very similar to just, this is my RPC provider on what chain.
00:10:54.250 - 00:11:29.720, Speaker A: And then this is the part that's count abstraction specific. So what this is doing is it's specifying my EoA as the owner. It's setting what is my entry point address, which I'm just using Alchemy's default. And then it's setting the factory address so you can customize both the entry point and the factory, but this is just using the defaults. So what's interesting here is this smart contract wallet actually doesn't get deployed until it needs to be called. So it's called a counterfactual deployment. So you can find out the address of this account before it's used.
00:11:29.720 - 00:12:10.214, Speaker A: So this is just showing that you can call get address before it's actually deployed. I'm setting up that paymaster middleware. I'll dive into that in a second. The main difference that you'll do for user ops versus transactions is you encode your call data as you'll either call, encode, deploy data, or encode function data. And that just takes that API and bytecode. Since I'm a little tight on time, I'm going to skip through. I'm doing a create two deployment here, just so I can know what that smart contract address is so I don't have to use an indexer to find out.
00:12:10.214 - 00:12:50.980, Speaker A: I can find out counterfactually, and then I can use that smart contract wallet to call that deploy transaction. So it's coming from my smart contract address. I'm sending it to a deployment proxy, and then I'm just passing in that new contract, and then I'm finding out what that contract address is because I have create two. And then I'm doing the exact same stuff I did before. I'm saying, hey, I want to write a value, one, two, three there. Just instead of me using a transaction like you would I have to encode the data as a function data here. So I'm calling that function store and I'm just giving it that new value.
00:12:50.980 - 00:13:23.194, Speaker A: So high level, that's like you can use hard hat to deploy smart contracts. To deploy new smart contracts. And the main advantage of that is like, I don't need a faucet anymore. I don't need to go to this permissioned situation. I know that this network has a paymaster out there that will pay for my deployments. So the nitty gritty of how our paymaster actually works is there's two things in the alchemy SDK that I set up. I'm going to skip over dummy because it's kind of the same thing.
00:13:23.194 - 00:13:59.800, Speaker A: But what this does is you get these properties of what was that user operation, and you have these extra values here. So you have gas limit, you have pre verification gas, and you have your max priority fees. So all this is doing is it's taking all of those fees from your user op and it's sending it to this paymaster. It's just a simple rest call. I'm posting that data, and if it says that, hey, I will pay for this, I can save that to the user op and then it's paid for. The bundler knows how to read that and pay for it. Okay, so that is hard hat really quick.
00:13:59.800 - 00:14:42.728, Speaker A: I am going to run out of time, so I will just quickly show my Internet may not be good enough. I should be seeing my smart contract wallet. Here, let me. Okay. Yes, I'm going to run out of time, so I'm going to skip over the front end. Most importantly, you can find these examples. The hard hat example, which is probably the most useful for actually deploying, is just more or less a hard hat plugin that lets you do that paymaster for you, that front end example is just a very bare bones alchemy example to mint an NFT.
00:14:42.728 - 00:15:11.060, Speaker A: And that's showing you the front end experience of you can create a net new address that doesn't have any gas and you can do transactions. And then lastly, I had net new added a biconomy example that just shows how you can also set up that middleware and biconomy so that you have more choices than just alchemy. And then. Yeah, so that's my talk. I went super quick. Thanks for coming. If you have any questions, I'll be outside and I'll be at the base booth all weekend.
