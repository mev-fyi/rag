00:00:01.770 - 00:00:13.920, Speaker A: All right. Hello everyone. Thank you for joining us tonight at ETH Global. I'm Sean On from the ETH Global team and I am honored to be joined here by Xiaozhou from Seller. Xiaozhou, would you like to introduce yourself?
00:00:14.690 - 00:00:52.510, Speaker B: Hi everyone. I'm Xiao Zhou Lee. I'm a co founder at Seller Network and leading the blockchain related development efforts at Seller. And so today I'm happy to introduce to you guys about our new initiative which is called Layer Two Finance. Its goal is to scale D Five protocols in place on Ethereum. Okay, so let's start. So first start with a very quick overview of what Seller is doing.
00:00:52.510 - 00:01:34.170, Speaker B: So, Seller is a layer two scaling platform. We have been here for three years and building all kinds of layer two scaling techniques. What we already have been doing include the State Channel Network, which is the first project we started. It's a highly scalable and deeply optimized generic multi hop state channels. And if you're interested and check out the code Open Source today. This has been running on Midnight for two years. And we also have a product called State Guarding Network which is an efficient watchtower side chain.
00:01:34.170 - 00:02:54.034, Speaker B: Because as you guys know that most of the layer two scaling they have. One common challenge is how do you protect layer two data? There's always been a challenge period, for example, the State Channel Optimistic Roll Up and many other projects. So we are building an efficient watchtower searching to address this availability data challenge issues. It has also been running on Midnight since last year. It currently only supports monitor for the State Channel Network, but we will extend it to also support the monitoring service for Optimistic Roll Up System, including our upcoming layer Two Finance Roll up systems. Now, the today's focus is Layer Two Finance, which is our new project at high level. It scales layer one DeFi interactions directly in place with layer two row up.
00:02:54.034 - 00:03:28.750, Speaker B: And later I'll talk about what I mean by in place. The onchain contractor code is open source. They're welcome to check out and contribute. And we are currently running testnet on Robston. It has been running since last week and it's pretty active. I think there has already been more than 200 D five transitions like investor sell transitions. So far more than 200,000 and it's working pretty well.
00:03:28.750 - 00:04:06.220, Speaker B: Except I think there are two times systems did recover due to the Rough ten long range reorg. So Roughten recently had a reorg of 80 blocks or 40 blocks respectively. That caused us to have to recover some states but still keep all the funds safe. So you're welcome to try out our testnet. The web UI UX will be significantly improved soon. So now it's more like MVP UI interaction. It will be updated very soon.
00:04:06.220 - 00:04:57.990, Speaker B: Okay, so what is layer two? Finance. Why are we building this? The motivation is clear. The DeFi operations today are expensive. I don't think I need to talk too much about this. Everyone know this. It's hard for small players to participate, so it becomes more and more like big well games. Then with the emerging technology of Ro up, including ZK Row app and optimistic roll up, people are generally asking like can we move all those D Five protocols to layer two? Let's just do everything at roll up layer.
00:04:57.990 - 00:06:35.670, Speaker B: So this is a very exciting future that we all hope to come soon. But we also understand that it's not that easy because it involves the migration of the whole ecosystem, including all the related layer one contracts and all the other infrastructures, non layer one infrastructures that are currently working with the Ethereum main chain. So this whole ecosystem migration may not be that easy and smooth. And moving DeFi protocol directly to layer to Roa system may cause liquidity fragmentation because those big wealth may not want or may not need to move operations to layer two because the transaction gas cost is acceptable to them. So they could just prefer to stay on layer one and do as your business. And also another problem is the protocol composability, it is similar to the ecosystem migration. So you have to make sure that all the protocols you want to interact are also on the same layer two Rob systems and have the same properties, similar like liquidity pool size, all those properties.
00:06:35.670 - 00:08:08.622, Speaker B: So we hope this could come soon, but it may not be that easy. So what we choose to do, our layer two finance introduce, is to not ask to move DFI to layer two roll up system, but move layer two to DeFi inside. So we build a roll up system to pull user request in the layer two roll up and then aggregate these D Five interactions in layer one to directly still interact with all the original DeFi protocols in layer one, like compound, ave, all the uniswap, you name it. So in this case, we can greatly reduce the average per operation cost, amortizer cost of each user and and still maintain the same ecosystem. Basically, all the previous concerns I raised about is gone. So we believe this is a much faster path for layer two for this roll up plus DeFi adoption in the Ethereum ecosystem. Okay, now here is a more deep dive of the high level system architecture.
00:08:08.622 - 00:09:15.674, Speaker B: So we have a set of contracts. In general, it's a roll up contracts. It is a domain specific roll up. It takes our pre compiled logic of how to deal with all those DeFi operations and the roll up contracts can talk to a bunch of strategies that also develop. For our layer two finance system, we have already developed a few strategies and we welcome the community to also to contribute to this part, to develop as many strategies as possible that they can be easily plugged in and to interact with the Rob contract. And these strategies will talk to the existing DeFi protocols in layer one. So the high level user overflow is like this.
00:09:15.674 - 00:10:23.902, Speaker B: So the clients make one time l one deposit on l one into the row of smart contract. They deposit 5000 USDC for example. And then the rob submitter will pick up this deposit and know that okay, now this client has this much of assets in the system. Then the client can send strategy operations to the Roa block submitter, the layer two server. It is currently a single server and later can be extended to a side chain. Then the roblox submitter will collect users request say I want to buy some shares of this of strategy zero onto sales strategy two. I want to sell some from strategy one and use that money to directly buy something in strategy three like all those normal financial operations you want.
00:10:23.902 - 00:11:53.606, Speaker B: And client can specify their operation intents and roll up block submitter will collect all those clients operation request with their signature metadata of course and then pack them into a row up block periodically and commit that row up block into the onchain row up contract. So the row up thing is similar to others so the contract will only store the block hashes and pass the call data used for data dispute. So currently we are using Optimistic Rob approach and we are also looking to collaboration with other decay Rob provider as well. Our current system is built upon Optimistic Rob and then also all the clients. Aggregated Intents will be the hash of all the Aggregated Intents will be stored on the rock contracts. There will be a few hours for example, dispute window. After that window the block submitter can execute the block and do the aggregate operation.
00:11:53.606 - 00:13:17.722, Speaker B: Say that I collect these few hundreds of operations from tens of hundreds of clients and in aggregate they want to commit 10,000 to strategy zero. They want to withdraw 20,000 from strategy two. So to each strategy there will be a single external function call and the strategy then will do some simple internal processing and interact with the DeFi protocol itself. So this is the high level user flow you can see that it is straightforward the way it save cost is obvious it reduced the on client request, the onchain cost to one to aggregate all the clients intention of the same strategy it into only one operations. So this is the high level high level overflow. So now going to some deep dive code overview. So this is the row up contractor, core function and struct.
00:13:17.722 - 00:15:33.086, Speaker B: So in each block we have root hash, intern hash, which summarize how this block want to interact with the strategies and metadata, block time, block size. Yes, technically, we can further compress these values into one single hash, but for this first version, which is for simplicity and crackness. So we keep four values stored on chain and we have basic operations like deposit withdrawal, commit block, which is the block ID, and the list of transitions which I'll talk about later, which is either core data and execute block that you submit the internal transactions. Again, to actually interact with the DeFi protocol, with the strategy. And of course, because it is an optimistic roll up, you can dispute if the block submitter submitted invalid state, you need to submit all the related transition and account proof. I'm not going to into details about the dispute logic but if you're interesting and take a look at our code, we have a full dispute cycle and these are some of the important transitions that user submitted all block submitter summarized to submit to the blockchain one is a commit transition. It's more like buy shares that the user says I want to buy some asset amount from this strategy ID and have a timestamp and signature and we have uncommit transition which is the user want to sell their shares which in our system we call it st token strategy token.
00:15:33.086 - 00:16:43.114, Speaker B: So when you invest your asset like USDC, you will get a corresponding St token of that strategy. And in the uncommitted transition, you can see that for this strategy, I want to sell my St token and get my original asset back and also withdraw transition that I want to withdraw my adult balance back to l One. Back to my l one account. And there's another important transition which is a commitment sync transition. This one is generated by the block submitter. So in each raw block the block submitter will look at all the clients commit and uncommit transition and generalize summarized transition. Okay, so previously I briefly talked about the high level of our architecture to give you an overview of how the systems works.
00:16:43.114 - 00:18:16.680, Speaker B: But in the upcoming hacks on and so we'll be focusing on helping communities to build the strategies as you can see which is this part the strategy. These are decoupled loosely coupled with our core roll up logic and they have very simple interface, they're very easy to be extended and flexible configuration. So I'm going to give you a quick overview of what a strategy looks like. Now you should be able to see this open source layer two finance contracts code GitHub repo and if you go to the contract strategy you can take a look at the overview of how to development developer strategy and how to test your strategy. You should read through this to build things and submit for the hacksaw. So here is the interface of the strategy which is pretty simple. So you have getasset address which is just to return the token address.
00:18:16.680 - 00:19:21.370, Speaker B: Currently we support the single token strategy only. It means that each strategy only have one like die is one token. If you want to do with something like multi token DeFi protocols then you may need to do the swap single token swap to multiple token within your strategy. The strategy interface currently only support one token. The two most important functions that the rob contract which is a strategy controller to interact with are this aggregate commit and aggregate uncommit. So the aggregate commit is the controller only method. It moves the specific amount of asset from the controller, which is the rob contract, into the underlying DeFi protocol.
00:19:21.370 - 00:20:49.430, Speaker B: Yeah, symmetrically, the aggregate uncommit is also a controller only method that moves the specified amount of asset from the DeFi back to the controller, which is like if the user's aggregated intent is to withdraw some amount of money from the strategy. This aggregate uncommit should be called and we also have harvest and sync balance. So harvest need to be implemented when the protocol provide additional yield, for example in the form of governance token or other tokens like a token. So then what this harvest should do is to sell the tokens, sell the additional tokens, transfer them into the asset token and reinvest into the protocol into the DeFi protocol. But be aware of those flash loan attacks when implementing this method. So you should restricted this method to externally owned accounts only. Sync balance is just to return the balance of the asset token managed by the strategy.
00:20:49.430 - 00:22:11.694, Speaker B: I think in many DeFi protocols it only needs to be a real function, but in some protocol DeFi protocols it might need to synchronize a balance with the protocol before returning to it. I think in most of the cases the real function is enough. Now I can go over with some simple examples you can see that we already have a few strategies built on and there are pull requests for more strategies which you can also take a look. So you can start with the very simplest strategy dummy which we use in turn to test our royal framework. So this is like the dummy strategy which is not a real one. So the aggregate commit is just to transfer the amount from drop contract from the controller to this address. Aggregate commit is to transpect sync balance is just to get the current address and this harvest because we are going to mimic the harvest behavior for this harvest.
00:22:11.694 - 00:24:26.842, Speaker B: Currently in this dummy contract, we specify external funder that whenever you call harvest you get some token from external funder, which is to simulate the behavior that will never harvest your asset increase. This is like a straw man strategy contract to show, like, the very simplest function of it. And we can maybe take a look at some for example this compound as example which is a real strategy that we are planning to launch midnight you can see that it is simple as well. So get strategy address sync balance easy determined you claim the token gather the token and go to uniswap to sell it to sell back to swap the token into the underlying asset like dial USDT and reinvest into compound aggregate gate commit is to get to receive the money from the rob contract which is a strategy controller and to invest those fund into a compound anchor me is similar like to redeem underlying asset from compound and transfer back to the Rob channel to the Rob contract. Yes, it is that simple right? Because compound itself is a relatively simple strategy. And some other CV we also have Ave which is even simpler and we have also have a curve which is a little bit more but it's still important. So you can see that building such strategy doesn't require a lot of effort.
00:24:26.842 - 00:27:09.810, Speaker B: You just need to put an adapter between layer two finance, rob contract and the actual D five protocols and you can use your imagination to build more complex strategies like for example to interact with multiple DeFi protocols or do whatever investment combination you like as long as you conform to the simplest strategy interfaces. And another thing about the strategy so what would it require if you want to hook up your strategy with the layer two finance? So in our smart contract we also have a registry contract that you can register assets which is what types of tokens asset you want to support and which registry you want to the system want to support. So in our current version we allow only the contract owner to register this register strategy and later this will be extended as a governance function to let the community to use a governance power to decide which strategy should be integrated into the system. I think that's pretty much all this. Please take a look at the detail, look out for this README and related links to see how to and also all those examples to see how to build a strategy. So that's pretty much all for my technical walkthrough of layer two finance we are continue building. So what's next? We will midnight launch our current version soon as alpha launch and we are continue developing more features and improvements in the upcoming releases like more strategy and some flow improvements which may require some strategy interface changes but the high level concepts will stay the same.
00:27:09.810 - 00:28:12.774, Speaker B: And we'll do gas cost optimization currently I think each commit each user like commit uncommit like layer two deposit withdrawal transition, I think it cost about 5000 gaps and we believe that could be optimized. And we will have more features like asset and st token transfer within the LTO systems and the fee structure, governance et cetera. That will be coming soon. Okay, I think that's it. Thank you very much. Happy to take questions if there's any I don't see any questions but we will also be on discord of the hacksaw and we have our own discord and telegram. Yeah, basically there are multiple channels to ask questions later we'll be happy to answer you.
00:28:12.774 - 00:28:13.800, Speaker B: Thank you.
00:28:14.730 - 00:28:28.860, Speaker A: Awesome. That was a very informative and educational presentation. Really appreciate it. A question for you if someone would like to have the slides, is that possible?
00:28:29.390 - 00:28:43.280, Speaker B: Sure? Yeah, definitely. Maybe I can just share the share the slide link to you. Yeah, I'll share the slide later.
00:28:45.010 - 00:29:00.360, Speaker A: Awesome, sounds good. Someone in the chat asked if wait, sorry. Yeah, never mind. Never mind. Oh yeah. Someone in the chat asked where's l two code running.
00:29:02.570 - 00:30:20.460, Speaker B: Yeah, so L two code is not open source yet. So we will open source part of the Watchtower challenging part soon and we are seeing how much of the internal business logic will be open sourced and how much of the community features will be open sourced. So at the bottom line, we will definitely open source open source all the Watchtower challenger, how to submit the block and how to reconstruct all the layer two states from the onchain contract and discover if there are any malicious fraud blocks and how to dispute the submitted blocks. All those logic will be open sourced because we are currently still actively develop and improve the course that part is not open source yet.
00:30:20.910 - 00:30:41.250, Speaker A: Awesome. Sounds good. And good luck to the developmental efforts. We're excited to see what's going to come up with that. And if anyone else has any questions, please feel free to drop them into the sponsored channel. So under sponsor seller. But yeah, unfortunately we're out of time.
00:30:41.250 - 00:30:50.080, Speaker A: But thanks to everyone for coming. Appreciate you all for coming so late at night, but this was very nice, enjoyable and in.
