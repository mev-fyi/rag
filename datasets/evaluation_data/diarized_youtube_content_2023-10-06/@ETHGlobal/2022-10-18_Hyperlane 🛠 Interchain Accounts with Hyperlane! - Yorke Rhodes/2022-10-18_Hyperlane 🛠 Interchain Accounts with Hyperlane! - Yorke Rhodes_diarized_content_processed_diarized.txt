00:00:06.490 - 00:00:18.590, Speaker A: Cool. Well, yeah. Thanks guys, for coming. We're going to have a lot of fun. My name is York from Hyperlane. We're formerly known as Abacus. If you heard of the Abacus Protocol we rebranded recently.
00:00:18.590 - 00:01:17.598, Speaker A: But yeah, today we're going to be talking about some developer tools that we exposed for you guys to use during the hackathon. I know the workshop was labeled with interchange accounts, but we also deployed a new middleware today for interchange queries. So we're going to cover both of those, hopefully. So yeah, first and foremost, what is Hyperlane? In case you guys aren't up to speed? Hyperlane is a developer platform that enables interchain applications. And so what that basically means is there's a smart contract API that's deployed on all of our supported chains, and you can use that API to send messages between blockchains. So you kind of enable composability between smart contracts which exist on different chains. And we have kind of like a novel security model that we do that we employ to enable this.
00:01:17.598 - 00:02:23.494, Speaker A: But I think I want to keep this talk focused on kind of like the developer tooling side of things as opposed to the security protocol, but happy to answer questions there that you guys have at the end. So, yeah, why do we care about interchain applications and why should you be building one? So today developers that are building DApps are faced with this choice of which chain they want to deploy on when they're going out and launching their V zero. And I think what developers don't realize a lot of the time is that that choice has kind of like a lot of downstream consequences. So we listed a few here. Developer experience. The tooling that's around a specific chain might be limited to that chain's ecosystem. Each chain has some Idiosyncrasies, and sometimes the tooling isn't as mature on newer chains or cheaper chains.
00:02:23.494 - 00:03:22.074, Speaker A: So you might be trading that off without realizing. And then I think this one probably should be the highest on the list. User experience. Just generally, like, when you're choosing which chain you're deploying on, really what you're choosing is who is the user demographic that's actually going to be able to use your application and are they going to be required to bridge? To some chain that they're not already on, which requires them to go through some third party application, usually taking on a lot of counterparty risk. We've seen a lot of bridge hacks recently, so generally you don't want to ask users to go through some third party application just to access your app. Then we have the platform risk. So this is kind of like once you've developed a network effect on a specific chain that you've deployed on, it becomes very hard to migrate that application or network effect to a new chain.
00:03:22.074 - 00:04:52.134, Speaker A: If you decide that the current chain has departed from some maybe morals or philosophy that you want to adhere to, maybe it's like some censorship property or something like that, it generally becomes difficult to migrate network effects, capital, et cetera. And yeah, this extends to Composability if you want to kind of reach new user demographics which are on different chains, or maybe like lower fee chains or higher security chains, et cetera. If your application isn't designed with cross chain Composability in mind, when you deploy to these new chains, you end up with these new siloed instances of your application, rather than an application where all of the users of your app are benefiting from kind of like the aggregate network effects. Instead you have these kind of siloed networks that in the case of an AMM, when uniswap goes and deploys on a new chain, it's an entirely new set of liquidity and so you kind of have to rebuild the network effects. A lot of times you have to deploy these artificial injections in the form of incentives to bootstrap the utility there initially. So yeah, there's all these consequences. And what people are doing today to go MultiChain or go cross chain really is not scaling.
00:04:52.134 - 00:05:59.690, Speaker A: Well they're, like I said, deploying these incentive programs and there's like all this mercenary capital in the ecosystem that's just like chasing these incentives and as soon as the incentives dry up, they just leave. And so it's not a really sustainable model for scaling to all of these new chain environments. However, we want our applications to support these new chain environments because there's all these different scalability improvements and enhancements being made which make certain user demographics more likely to use your application. So there's kind of this tension between the proliferation of these scaling solutions and new user demographics and being able to have an application which maintains its network effects across all these different chains. So this is where Hyperlane comes in. Hyperlane is a network that exists between blockchains, so it's not another blockchain. You don't have to choose Hyperlane.
00:05:59.690 - 00:07:13.590, Speaker A: You can just use Hyperlane tooling to deploy everywhere and it eliminates this choice. So today we're only on EVM chains and so you still get this nice property of only having to write your application logic once and kind of like deploying it everywhere in like a symmetric interface. And it's built to be this connective tissue that allows smart contracts to communicate between different chains. And so you can have intra app communication whereby you have a shared state model and some sort of state synchronization that exposes a user interface on all of these different chains, but actually is doing kind of like asynchronous state synchronization on the application side, which is like obfuscated away from the user. Or you can have inter app kind of composability. So even just like an app that's on chain X and another app that's on chain Y, they're not natively Composable because they're not in the same runtime. Hyperlane allows you to build the aggregator app that makes those two apps composable.
00:07:13.590 - 00:08:09.466, Speaker A: And yeah, like I said you bring your app to users on any chain. They don't have to learn a new experience. They already probably have a wallet that they prefer a certain custody solution on a certain chain that they're comfortable with. You don't want to enforce all of these additional frictions to your users just to use your application. Any friction in the initial onboarding experience is going to massively limit your ability to scale your audience and your customer base and then get rid of this platform risk. So this is a little bit out of date, but we're going to talk briefly about the lowest level primitive that hyperlan exposes to you guys, which is the Messaging API. And then we're going to talk about interchange accounts and then I deployed interchange queries today, so we're going to talk about that too instead of the other examples here.
00:08:09.466 - 00:09:25.310, Speaker A: So the Messaging API basically there's kind of two smart contract interfaces which are necessary to be implemented when using hyperlane. So on the sending side, you have to basically dispatch mail to an outbox on the source chain which specifies the identifier of the destination chain that you want to send the mail to the recipient address on that chain to receive the message and then the message itself. And you can see here that the message is just arbitrary bytes. So we're not enforcing any specific application message encoding on you. Really. This is a very low level primitive and you can do a lot with it. And then on the receiving side, in order to receive a hyperlane message, your contract needs to implement this interface called Imessage recipient and specifically this handle function which takes in an origin chain Identifier, the sender address on that chain from the origin chain and then the message that was passed by the protocol.
00:09:25.310 - 00:11:03.934, Speaker A: And it's important to note that I guess we need to implement this specific interface and actually also access control this function to the hyperlain protocol because otherwise anyone could just spoof any sort of cross chain message by calling your smart contract and pretending that it's coming from some chain when it's actually not. And that has a bunch of security implications which again I'm trying to stay away from but happy to answer questions. So yeah, this is slightly annoying that you have to deploy contracts on both sides of the message lifecycle like the sending chain and the receiving chain because it basically means you have to manage an application which is deployed on all these different chains and it can get kind of complicated. Again, we've built out a bunch of developer tooling to make that much easier. But I want to talk about this concept of interchange accounts, which is basically kind of like a middleware implemented on top of the messaging API that slightly constrains the messaging coding, but makes your job as a developer potentially much easier in terms of orchestrating and deploying and managing your app across end chains. So the messaging API that we just looked at, again, doesn't enforce a specific encoding. It could be structured arbitrarily.
00:11:03.934 - 00:13:23.600, Speaker A: You could have like JSON in there if you wanted to. And if you want to implement application specific feature like you're transferring an asset in an asset bridge or you want to do a swap or whatever it is, you have to implement that as like a specific messaging coding on top of the messaging API. But if we constrain the message encoding to basically actions which can represent kind of like the entire set of actions that can be taken on a destination chain and we leverage some properties of the EVM mainly like the create to opcode. We can actually create these accounts on remote chains that are controlled only by smart contract on the source chain. And so this allows you to basically have a smart contract on chain A that holds assets on chain B or does atomic actions on chain B. And yeah, basically the way this works is like there's an interchange account that's deterministically created from the source chain contract and that Interchange accounts bytecode basically restricts any incoming function calls to the source chain contract. So if you want to make one of these interchange account actions, you basically relay it through the interchain accounts API from the source chain contract, and then the hyperlane protocol will go and relay that to the destination chain interchange account, which will implements this handler that basically has access control saying, you know how we saw the messaging API here? Basically saying that only this origin chain and this origin sender mainly the interchain account owner can run this function.
00:13:23.600 - 00:15:31.880, Speaker A: And so the nice property we get from this API is like now you can only implement hyperlane interfaces on the sending side, you don't have to worry about deploying contracts on the receiving side because the hyperlane protocol will go and deploy these interchain accounts for you automatically whenever you route through this API. So you can basically dispatch API encoded calls to be made from your interchain account on another chain and kind of like the middleware wraps up all of the messaging API receiving. So an example use case of this type of pattern is cross chain governance. The way cross chain governance works today typically is like voting happens usually on one chain, like the hub chain, and then there's some basically either trusted multi SIG or Oracle solution to take the results of a vote that happens on a hub chain and actually propagate or broadcast that result to all the destination chains to perform the specific governance proposal that was encoded on the source chain. However, with interchain accounts, if you have a Dao contract that dispatches governance proposals to the interchange accounts API on the kind of receiving chain side of things, you can basically just set the owner of contracts that you want to be controlled by a dow on another chain to the interchange account of that. Dow and you basically have gotten cross chain governance for free. So just like one example.
00:15:31.880 - 00:16:30.330, Speaker A: But yeah, I think the Interchain Accounts API makes it much easier to work with the hyperlane system. So definitely recommend you guys check it out on the docs. And then I also wanted to highlight the Interchange Query System, which is like super new deployed on testnet today. But yeah, Phil's like another kind of like middleware developer primitive that basically just makes it easier to work with the hyperlan system. So I think you'll notice in the messaging API that there's no kind of like native callback support. So let's say you wanted to go and dispatch an action to some other chain and get the result of that action and then return back to the calling contract and then resume execution. It's not super obvious how you would do that with this API.
00:16:30.330 - 00:17:42.566, Speaker A: Maybe it is obvious to you, but we've found that it's somewhat difficult for people to understand how to implement callbacks. And so we wanted to build out this kind of like interchange Query system that just lets you read remote smart contract state on other blockchains, just like a super simple API. Now that we have basically on any hyperlane supported chain, this now becomes accessible to any smart contracts. And again, the nice property is the receiving contract or the contract which is being queried. Doesn't need to implement a hyperlane specific interface because we're just dispatching API encoded calls to be run against those to be run against contracts on the remote chain. So yeah, you can basically with this API, dispatch a sequence of function calls and provide a set of callback function selectors to actually receive those query results. So hopefully you're familiar with how function selectors work in the EVM.
00:17:42.566 - 00:19:27.090, Speaker A: But the basic idea here is you need to provide some way on the source chain to resume execution or kind of like recover the stack once you receive the message back from the remote chain of like, what was the value of the query on that chain? And so these function selectors basically say, what functions should I run once my query resolves and I've gotten a return value? What functions do I need to run on the source chain to kind of resolve that value or consume that value? Because we don't have an Async Await syntax in Solidity or the EVM, but something you could build with this Interchange Queries system, which I was toying around with hacking this weekend, is actually an Async Await syntax in Solidity that gets transpiled down to the Interchange Queries API. Just as kind of a fun demonstration that you can have Asynchronous smart contract runtimes and it just takes a little work. So, yeah, here's like a Quick or this is just the API. So yeah, it's kind of similar to the Interchange Accounts API, except instead of it just being like a sequence of calls, you also have to provide the callback. Again, this is compatible with legacy contracts. So you can make, let's say you're on polygon, you can go and make smart contract queries against uniswap v three. You can go and get price data from Ethereum.
00:19:27.090 - 00:20:36.120, Speaker A: These sorts of things aren't possible right now. And this is an example that I just put together really quickly. Sorry for the lack of syntax highlighting, but yeah, basically this is an example of querying ENS for the owner of an address from a chain which is not Ethereum. So you can just take the ENS interface, you can figure out what label do you want to query on the ENS registry. In this case, we don't actually have the hyperlain ETH domain, maybe we should go buy it. But yeah, if you wanted to query the owner and the expiry of the owner of that domain, you just abi encode calls to the ENS registry on Ethereum and then you use the interchange queries API to go and query that in an asynchronous way. You'll see that we have the resolve owner and resolve Xpreeselector here.
00:20:36.120 - 00:21:29.210, Speaker A: So basically these two functions will be run with the return value of what was basically queried on Ethereum. I'm still thinking about what the right interface here is. This is a little awkward for a way to implement callbacks, but, yeah, I just wanted to give a quick example. And, yeah, you could imagine building some sort of, like so this requires someone to do a round trip between chains and so let's say my contract queries some uniswap v three price oracle. Let's say it's like USDC and ETH. I want to go get that price. And then some other contract makes the same query.
00:21:29.210 - 00:22:33.150, Speaker A: Both of those queries, both of those queries are going to require round trips between the two networks, which kind of sucks. So another idea for the hackathon is like maybe implementing a caching system with this interchange queries API. And ENS is especially amenable to this. That's why I picked it as an example because there's this explicit Unix timestamp expiry attached to every kind of relevant piece of state on the ENS registry. So you could very easily build kind of like cross chain ENS cache contract that not only saves round trips but actually has atomic resolution of maybe addresses which are like popular queries. And the same can be said for other types of interchange queries. This was just the example I picked.
00:22:33.150 - 00:23:24.214, Speaker A: But yeah, I think we're at the timestamp so I wanted to give an opportunity for people to ask questions. That was probably a lot to get through, but yeah, so it will work between roll ups and what's nice is you don't have to wait the optimistic period, right? So all these use cases are optimized for low latency and high security. So right now I think we're on optimism. Arbitrum. I'm trying to remember what other roll up chains we're on. I think that might be it for now, but those are the, I guess, most in demand ones. But yeah, it's very easy for us to expand to new EVM environments.
00:23:24.214 - 00:24:38.020, Speaker A: So if there's like a specific chain that we're not on and you can check that in the docs, but if there's a specific chain that we're not on, we can definitely talk to you about expanding maybe like even tomorrow or something like that. You can? That's a great question. So the way our relayer implementation works is it will only include transactions whether they're callbacks or just cross chain messages. In general, the transaction will only be included if it's expected to not revert. And so what that means is in your callback receiver, like, let's say resolve expiry or whatever in the implementation of that function, you could have a reverting condition which says this much time must have elapsed between when I dispatched the query and when the callback is being resolved. And that's kind of like how you could schedule callbacks. Yeah.
00:24:38.020 - 00:25:51.540, Speaker A: Jerry, sorry, it's a little hard to hear. Yeah. So, like, what's the security model basically of like interj queries? Yeah, great question. So hyperlane is like an example of generalized message passing which is a generalization of asset bridging which has been demonstrated as super insecure and super shitty and probably shouldn't trust any of these things. So we're kind of like making what we think is like a fairly novel security trade off. We're basically establishing a distributed set of proof of stake validators that sits between all of these blockchains. They're actually staking on the source chains instead of kind of like guaranteeing that we can prevent fraud in kind of like, let's say the return value of one of these interchange queries.
00:25:51.540 - 00:26:57.820, Speaker A: Instead what we can do is we can guarantee that there's an economic cost to fraud, a minimum economic cost to committing fraud associated with a message that is sent outbound from a chain where hyperlain validators are staking. And we can do that because if those validators sign something which is not committed to by an accumulator that we have in our smart contracts, we can provide a fraud proof which basically slashes them. And so we haven't actually defined all of the economics around the system. Right now the validator set is permissioned. So to some extent you have to kind of trust the existing operators. You can check out our docs and the discord to both see who the validators are. They're fairly reputable organizations around the space, but also you can talk to them in the discord.
00:26:57.820 - 00:28:10.640, Speaker A: But yeah, right now it's a permission set. So you do have to kind of trust the, I guess, quorum of signers in that set. But we're hoping in basically the next month or two to transition to this permissionless proof of stake validator set where instead of this social trust or reputational trust, we have full economic security model which basically most of these other bridge systems have not really implemented effectively. Yeah, great question, though. I mean, that's kind of like the core differentiation of our protocol versus some of the other generalized message passing protocols out. There is this economic security model that has actual enforceable slashing conditions in smart contracts so you can have strong guarantees of what the cost is to commit fraud, which is not true of basically like most other security models. Awesome.
00:28:10.640 - 00:28:20.110, Speaker A: Yeah. Thanks, guys, for coming. I'll be around the venue all weekend, so if you have questions or need help with anything, we have a booth upstairs. Definitely come out.
