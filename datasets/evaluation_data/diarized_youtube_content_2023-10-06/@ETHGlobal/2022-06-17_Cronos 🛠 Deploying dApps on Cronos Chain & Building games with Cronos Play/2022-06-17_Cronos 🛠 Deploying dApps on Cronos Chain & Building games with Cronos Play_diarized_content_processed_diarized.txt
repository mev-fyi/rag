00:00:11.290 - 00:00:12.522, Speaker A: Hello folks.
00:00:12.666 - 00:00:19.246, Speaker B: What is up? Rick here from Kronos.org. Today we are going to have a.
00:00:19.268 - 00:00:24.966, Speaker A: Workshop on how to build a very simple react front end application by using.
00:00:25.028 - 00:00:26.386, Speaker B: The Create app method.
00:00:26.498 - 00:00:48.300, Speaker A: And then we want to build a little button that connects our front end application with our wallet of choice. And finally, we also want to build a function that helps us to fetch any NFTs that might be assigned to that specific wallet and ultimately then fetch it onto our website.
00:00:48.910 - 00:00:50.800, Speaker B: But why don't we get started?
00:00:52.210 - 00:01:06.820, Speaker A: So the very first thing that you want to do is you want to install a fresh Create React app and you can use any of the official methods that is available on the Create.
00:01:11.510 - 00:01:19.190, Speaker B: Documentation and then just create your basic react template.
00:01:22.510 - 00:02:10.280, Speaker A: So once this is installed on your local machine, there's just a couple of things you want to be in mind. So I am using React scripts 40, three. Maybe you want to use the same just for consistency sake. And then also I'm using the Webtree library, webtree model and D for styling and stuff like that, axios for API calls. But you can use Fetch if you want. That's really up to you. And then finally we also want to use DeFi Connect, which we are going to use in the Webtree model.
00:02:10.280 - 00:03:07.250, Speaker A: And yeah, another thing is what I did is I just replaced the CSS, the standard CSS with Antdcss. As you can see in here, that's Antdisentcss and that's the one that I'm going to use primarily here in the app right now. Just have a Hello Kronos text on the app. So if you go and visit, just launch the app NPM start, run Start. If you want to go and see what's happening in the browser, can just go here on the local host port 3000. And you see it just says Hello Chronos. What we're going to do next is let's give it actually some styling.
00:03:07.250 - 00:05:05.590, Speaker A: Maybe let's just remove this piece here, John. It's going to give it a name. Let's call it the Kronos app, the Workshop app. Also maybe add an H, two header and add quick description and then maybe also some culture action. So in here, what I want to do is the library that I mentioned before and it's actually what I want to use for the styling in here. So I want to use the primary button. It's not necessary, too much text.
00:05:05.590 - 00:05:41.400, Speaker A: Let's go back. Okay, I first have to import the button now from the package from the library. It can see what's happening in here. Maybe refresh this. And here we go. Now, this is obviously an empty button, so we have to add some configuration we're going to do next.
00:05:43.630 - 00:05:48.922, Speaker B: All right, so I think the very.
00:05:48.976 - 00:08:10.682, Speaker A: First thing is you want to create a state for two objects. One is the data state, the data object, which is basically going to store some NFT token values which we will need later on to basically populate the page with images and stuff like that, give it some color and we're going to save that, going to set the state to an array. And then as well, we want to store set the state of our wallet address like so. And these are our state objects that we will be using in the example app. And now there's a couple of libraries that we want to import. So the first one is we're going to use webtree model once we click on the Connect button. We also want to import the web tree library and we want to import Axios as well for API calls that we might want to do.
00:08:10.682 - 00:09:45.274, Speaker A: You can use other methods, you can use fetch for example, but that's totally up to you. Okay, now before we start to use the model, the webtree model, let's actually create the declaration. Actually let's just create the declaration for our provider because we're going to store the provider into here as well as declaration for web Three. And now what we want to do is there is a library, you could post it in here, but let's make a little bit cleaner. Let's actually create a new folder and call it Provider. And the provider is basically the method offered by the provider is basically the wallet that you will use in order to provide the information to your decentralized app or your front end of choice. In the context of webtream model, there's an option that we can use and let's actually create just a file.
00:09:45.274 - 00:10:45.362, Speaker A: We're going to store this option in here, a constant and then export it. Let's call it provider options. GS and then first thing we want to do is we want to import DeFi web Tree connector from DeFi Connect which is the native Kronos wallet that we will use in webtree models as well. And then what we want to do is we want to add our provider options. So this is available on our integration page. So I'm going to copy and paste it in here, but you can find that information obviously on the web extension integration. So you have the details in here.
00:10:45.362 - 00:11:36.898, Speaker A: As you can see, this is now outside of the context of webtree models specifically. But you get the point, you have the different options and the different variables that you want to use in the functions and we just use them in the context of webtree model by adding the custom example for the custom wallet. That's how it's going to look like. We have display option. The package, which is the important piece. It imports the package into the provider option and then the different options that we want to use, such as the support chain IDs, the RPC methods, the polling interval and then obviously the function, the synchronous function to connect to the provider. And then it passes, it returns the provider, which we then will use in our app.
00:11:36.898 - 00:12:36.310, Speaker A: JS five. So now we can close this and go ahead. What we want to do now is as I mentioned before, we want to create a web tree model configuration. Going to call it web tree model. So we initialize it with a new web tree model and in here we pass for example, we can pass the option for Cage provider. Now I'm going to set this to False, but this is optional. If you want to cage the provider details, you can set it to True.
00:12:36.310 - 00:14:06.390, Speaker A: But it's optional really. But the option that is not optional is actually the provider options which are required and the provider options, they will come from the file that we just created. Oh yeah, of course. Now we're good to go. Missed a comma after the first option. And now that we have the configuration for our WEBG model, what we want to do is we want to create a function. Actually let's call it a synchronous function connect.
00:14:06.390 - 00:16:15.010, Speaker A: And this function is basically going to be triggered by our button. So I'm going to call here an event non click and basically whenever we click on the button it will trigger this Asynchronous function here. But for now the function is empty. So let's actually start to populate it. First thing we want to do is we want to create a condition check if there's a provider and if there's no provider, then we want to start to first thing we want to do is invoke Pride and Web Tree objects. And since they were declared initially in here so we can actually now initialize them like so with the Webtree Model connect function and we initialize Web Three with a new web tree and pass the provider. Now what we want to do is we want to get the account details.
00:16:15.010 - 00:17:24.340, Speaker A: We await the promise from web3. Ethereum get accounts. Obviously you can also use the Ethereum request method to get the accounts. Just actually I think I was reading is currently the most recommended approach. So I'm going to go ahead and use the web tree ethereum. Get accounts method. Now we want to set the address because what this does is it returns the accounts that are assigned to our provider and we're going to use the count that's assigned as index zero.
00:17:24.340 - 00:17:27.826, Speaker A: What will happen now is if I.
00:17:27.848 - 00:17:28.420, Speaker B: Log.
00:17:32.010 - 00:18:23.000, Speaker A: The address so what happened now after clicking on Connect, the webtree model is triggered and it shows me the default address which is MetaMask and DeFi wallet. Now I'm specifically using MetaMask for this exercise because my NFT assets are stored onto my Kronos address which I passed to my MetaMask wallet. And what I want to do is if I click, if I select MetaMask.
00:18:25.500 - 00:18:26.250, Speaker B: Okay.
00:18:31.690 - 00:20:06.188, Speaker A: Let'S go back, see what happens. Provider web tree. Oh, of course I need to pass the provider, not the provider options in here. So if I go back now and try to test it again and connect. Now I should see my address being logged. Here we go. Now that that worked, let's go ahead with our exercise because the next thing we want to do is we want to actually get all my token IDs so that I can use the Token Uri method that I have in the contract that I will add in a second.
00:20:06.188 - 00:21:41.960, Speaker A: And this is a bit of a workaround to actually get all unique images assets that I own. And for that we will use a contract and abis that are assigned to the NFT contract where the NFTs are being generated. And the first thing that we want to do is we need to create a new folder, and this time we're going to call it Contract. And in here we want to create a new file, which you want to call NFT Collection JS. And in here I'm going to post in paste the abi details and the contract where the NFTs are go. I'm going to quickly show you what I mean by that. So there is an NFT faucet that Kronos provides, and I have used this NFT faucet which works very similar to the OpenSea testnet platform that allows you to create NFT assets on a testnet so that you can play around with the NFTs as well.
00:21:41.960 - 00:25:35.620, Speaker A: And what I do here is I do have a contract address for those test NFTs. And the contract address, if you use Chronoscan or the Explorer, will also help you get information on the Abi, which you can then copy into this constant in here. So now that this is done, what I want to do is I want to import I want to import these details like so, and I want to create a constant for the contract. And here we go. So as you can see here, we have all of the inputs and we will be working a lot with the Token Uri, which we will use to get the unique metadata of each of the tokens that one of these addresses owns or specifically the address that I use for this exercise. Okay, in order to achieve that, first thing I want to do is I want to get all of my token data and I'm going to use access to achieve that and the Kronos Explorer API endpoint. So I'm just going to paste in the address here that I'm going to use.
00:25:35.620 - 00:26:43.750, Speaker A: So HPS Chronos.org Explorer testnet Tree API, the module is account and the action is token and address. That's what we want. And also I see that I was outside the condition. We want to keep this within the main condition in the connect function. Next, I only want because this is going to return a couple of fields and arrays the value that is important for us. Let's say we're going to use only the data results, which contains the specific information that we want to use.
00:26:43.750 - 00:28:11.350, Speaker A: And then I want to use a function to only retrieve the unique unique IDs. So function get unique and then I'm going to map to index, I store the keys of the unique objects, then I eliminate the dead keys and store the unique IDs. Last but not least, I remove any key when the result is null. And by doing that, I will be able to have my unique token details, which you will need to create an array with the collection that I own. So if you're going to log that, you want to see what happens with our token. Our token is basically declared and initialized with the function that we just created to return the unique IDs. And here we go.
00:28:11.350 - 00:29:18.000, Speaker A: These are basically my unique tokens. But as you can see, I don't have the metadata in here yet. To get the metadata, I want to use the token Uri that was set in our contract. So what we want to do next is we want to create a for loop. I'm going to just paste it in here. So let's have a look at this for loop. So it starts as index zero and it goes for as long as there's a token length.
00:29:18.000 - 00:30:42.350, Speaker A: So the token length is basically the amount of tokens that I have and it will run incrementally until it reaches the token length. And the first thing that I want to do here is we want to create a variable for token meta Uri and we want to await a promise and we are going to use the contract methods token Uri which I mentioned before. And in here we're going to use the token index in order to get the token ID and run the call. Also what we want to do is because we are using IPFS in this specific example to store the metadata of the NFTs, we want to replace the standard IPFS protocol here with an Https protocol so that the server isn't blocked when we try to fetch the details. And then we want to fetch the metadata and save it as a JSON. And again we will replace the IPFS with the Https method because we want to specifically get the images. And once we get the images, we want to push the return data into the collection array that we have declared here.
00:30:42.350 - 00:33:31.460, Speaker A: And what will be returned is actually so if I log the collection, we should see the specific metadata for here we go, the tokens that they own and that's the image. So now that this worked, what we want to do is we want to settle the state of our data object by passing the collection that we just created. And what we can do is we can create here in the front end a new field. I'm going to call it maybe we don't need the H one header here, but here we're just going to write NFT collection owned by address to keep it simple and in here. Now we want to run a loop with the new data that we have like this. And what we want to do here is we want to pass maybe first standard key, just our index and then our source. And in our source we will want to loop through the image fields.
00:33:31.460 - 00:34:06.572, Speaker A: And also maybe alt tag. Maybe let's just put the index in the alt tag. Maybe you can put the name here. We used Uri, Token ID and Image. Maybe you could have passed the name as well and you could have put the name here in the altech. But for now let's just use it this way. And we also want to add a little bit of styling maybe here.
00:34:06.572 - 00:35:07.494, Speaker A: So NFT image, and this comes from our app CSS file. So you can see here I created a CSS class with width, height, border and border radius and then as well a little bit of margin. And yeah, I think also another thing we could add is as you can see, the address is assigned but the value is never used. Let's just assign let's actually just print out the value in here. Okay, now that this is completed, let's actually go and check out yeah, it worked. So if I go and connect with my MetaMask address first, I get my address and then I will be able to fetch also my items into the page. And this is it in a nutshell.
00:35:07.494 - 00:35:13.194, Speaker A: I hope you like this workshop and if you have any questions, please feel free to reach out to us.
00:35:13.312 - 00:36:35.202, Speaker B: Today we're going to have a workshop on Chronos Play, which is our latest SDK and it will allow game developers such as yourselves to bridge your games with the latest blockchain technologies. More specifically, the Kronos Play SDK includes certain functions and methods that have been introduced by ChainSafe already. And it also allows you the opportunity to use the Kronos functions as well, such as the Kronos RPC methods and everything that evolves around the Kronos network. More specifically, we will have a look at some functions such as getting the balances, but as well we will look at how you can actually get the ownership of specific tokens. And finally we also have a look of how you can import NFT images and replace it with game texture so that you can actually start building games that import NFT images and then replace it with in game textures as well. But why don't we dig into it? Okay, let's get started. So first off, the SDK assumes a couple of prerequisites in terms of understanding.
00:36:35.202 - 00:37:30.342, Speaker B: So you should have a little bit of unity knowledge maybe. I've done some example apps. If you haven't, there's a lot of good tutorials available on YouTube, which I would recommend, there's a number of them. And also perhaps a little bit of knowledge on ERC seven to one, ERC 20 and other EVM practices might be also some good prerequisites to have. If you don't have them yet, don't worry at all. There's a lot of good material out there that can help you to pick up very quickly on those concepts. Now another thing to bear in mind is the SDK is currently supporting WebGL iOS and Android Builds and other platforms may work, but there's no guarantee really that they will.
00:37:30.342 - 00:38:36.780, Speaker B: And we also will only extend our support to other platforms after we have stabilized our current architecture. Apart from that, I think there's a couple of things that we will need such as a mobile IDE. If you want to build on mobile devices for Android or iOS DeFi Connect, which we will need in the browser. So whenever we want to use a browser based game, we should have that extension as well as any other wallet that you might be working with, such as MetaMask for instance. And last but not least, it would be very good to have some assets, some NFT assets. You can use our NFT Faucet to create some test assets, or if you have already some, then you can use those as well. Now the first thing that you should do is if you haven't installed Unity yet, you can just go on our docs and click on the download link which is going to bring you to the Unity page and then just follow the instructions over there.
00:38:36.780 - 00:39:45.314, Speaker B: And then another thing to keep in mind is we will be using the RPC method in the functions and the scripts that we have in our Unity build in the SDK. And you can choose between whether you want to use, let's say, the main net, which is the chain ID 25 uses this specific endpoint here, the RPC method, or the other chain which is the testnet chain which has a chain ID of 338. So the first thing to do is you can choose whether you want to clone the repository or you just download the latest release from ChainSafe by clicking on the link here in the documentation. And then you can start to create a new 3D game or 2D game. If you want to build, let's say, a top down game or something like this, that's totally up to you. But for the purpose of this workshop, we want to focus on treaty objects. So I have done that already.
00:39:45.314 - 00:41:03.172, Speaker B: I'm not going to go through all the steps, but what I want to do is I'm going to open my latest environment in here in Unity. Then we have a couple of examples. Okay, so one thing that might be good to know is you might need a specific library. So if you're going to have an error output for the JSON net library, what you can do is you can just go to Package Manager and add the JSON net library for Unity and then import it. And then that should solve the JSON net error that you might have when you start your first project. Let's go back to our docs and let's have actually a look at our first example in here. So what we want to do is we want to run a script.
00:41:03.172 - 00:41:41.640, Speaker B: So what we're going to do is we want to create a script in here. Let's go to our Scripts folder and that's actually in the EVM folder. Let's do it in the EVM folder. Let's just give it a random name.
00:41:54.400 - 00:41:55.150, Speaker A: Okay.
00:42:15.520 - 00:42:21.470, Speaker B: And I'm going to use ESC for this. What we want to do here is.
00:42:23.360 - 00:42:25.070, Speaker A: Just paste this in here.
00:42:26.240 - 00:42:27.888, Speaker B: The class is going to be Example.
00:42:28.054 - 00:42:30.690, Speaker A: Since that's what we have been using.
00:42:31.540 - 00:43:19.190, Speaker B: When we created the script. But we also want to have a prefab. So let's just go into our webtree unity folder and create a prefab. I'll call it Example and add a component and then let's look for example. So here we go. And what we want to do now is we can test this actually.
00:43:25.650 - 00:43:25.966, Speaker A: But.
00:43:25.988 - 00:44:45.162, Speaker B: We still have to fill out a couple of things. So let's change this to test net has changed RPC method in here and what we want to have as well is our testnet address. I'm going to go ahead and open MetaMask, copy my address from here. And that's it. That's the script. And what this script is going to do, it is going to use the EVM balance off method and it's going to print the balance. So if I run the script now in Unity, I should see balance in here.
00:44:45.216 - 00:44:45.530, Speaker A: Okay.
00:44:45.600 - 00:45:33.360, Speaker B: So I have two audio listeners. Let me actually go back. Just remove this one here. I'm still running here. Let me just cross this off. Let's remove the scene. Okay, now this should work.
00:45:33.360 - 00:46:15.800, Speaker B: And here we go. So obviously that's not the conversed value. It's still in its wave format. So that's the test tokens that I have in my wallet. And it basically just tested my wallet balance in the test net which is around 125 crow. Obviously you can convert this anytime.
00:46:16.620 - 00:46:18.670, Speaker A: A couple of options to do that.
00:46:20.240 - 00:46:48.260, Speaker B: Okay, now that this one is working, let's actually have a look at my NFT balance that I have on the testnet. So I'm just going to take this piece here. But obviously you can follow the guide which will show you how to create the different scripts and prefabs. But let's just go ahead and copy.
00:46:50.520 - 00:46:51.812, Speaker A: This elements in here.
00:46:51.866 - 00:47:01.400, Speaker B: Those strings actually might not make sense to remove everything.
00:47:03.210 - 00:47:04.582, Speaker A: Because there's a couple.
00:47:04.636 - 00:47:10.840, Speaker B: Of stuff that we want to use.
00:47:12.190 - 00:47:18.580, Speaker A: Remove this.
00:47:22.890 - 00:47:29.834, Speaker B: And now we also need contract address. And what we want to do here.
00:47:29.872 - 00:47:31.500, Speaker A: Is we want to use.
00:47:34.990 - 00:47:44.800, Speaker B: The Faucet address that I have. If I go and have a look, I think I added it in another application in here, the one that I used for the web app.
00:47:45.330 - 00:47:46.686, Speaker A: And here we go.
00:47:46.868 - 00:47:50.960, Speaker B: I'm just going to take it. That's the contract address here.
00:47:53.010 - 00:47:53.586, Speaker A: And then.
00:47:53.608 - 00:48:41.490, Speaker B: I post the contract address of my NFTs in here. Save it. And now if I go back into my Unity environment, what I want to do now is I want to rerun this compiler error. Oh, okay, I have a duplicate when I copy pasted the information before. Now it should work. Then we run this again. And now it should print the balance.
00:48:42.870 - 00:48:44.194, Speaker A: Of the NFTs that I have.
00:48:44.232 - 00:48:45.682, Speaker B: And in fact, there is around four.
00:48:45.736 - 00:48:47.460, Speaker A: Test NFTs that I have.
00:48:48.150 - 00:48:51.640, Speaker B: They're all ERC 721.
00:48:53.770 - 00:48:55.400, Speaker A: So that worked as well.
00:48:57.850 - 00:49:23.360, Speaker B: And now let's just go back and try to get the ownership of a specific NFT. What we want to do here is actually just need the token ID.
00:49:38.210 - 00:49:38.574, Speaker A: And.
00:49:38.612 - 00:50:15.710, Speaker B: The contract by mistake. Don't need the account, don't need the RPC method. And here we're going to put in, let's say 53, which is the ID of one of the NFTs that I have. And now it should print out my address. So come back here and I run the script to run the build.
00:50:18.780 - 00:50:26.224, Speaker A: Play it. Okay, didn't go true.
00:50:26.262 - 00:50:28.610, Speaker B: Let me try to save this again.
00:50:32.720 - 00:50:36.350, Speaker A: Okay, I didn't save it. Now it should work.
00:50:41.240 - 00:51:17.948, Speaker B: It's played. And here we go. Now it printed my address. And this is how you can check the ownership of specific NFTs as well. But let's do one that's a little bit fun. It's actually about how to import specific NFTs. And for this example, I'm just going to remove this prefab here.
00:51:17.948 - 00:51:45.830, Speaker B: For this example, you're going to create a quad object. So you can just go here and create 3D object. I used a quad, gave it some scale and then I've added a script in here. That's the one. So for now, we don't want to use the player prefs method. We actually want to use just a hard coded address.
00:51:47.420 - 00:51:48.888, Speaker A: And then in a minute I'm going.
00:51:48.894 - 00:52:26.470, Speaker B: To use the player prefs once we start to create the build. Okay, so we have our account, we have the contract and the token ID. Now you're going to see how the token with ID 53 is going to look like. We use the testnet RPC method, we use a string owner off method here in the function. We check for chain network, contract, token ID and RPC method. And then we have a condition. So we want to compare the owner off and the account.
00:52:26.470 - 00:53:35.076, Speaker B: So basically if the owner of that NFT equals to the account that I'm specifying here in the string, then I can start with the process of fetching the Uri from the chain. But I also want so because this is using the IPFS method, I want to replace IPFS in the string with the Https method so that it will work in our Unity build. Once that's done, we fetch the JSON from the Uri and we do that by using Unity web requests. And we then use the response data method to get the JSON response from the request and what we will do then is we will pass JSON to get the image Uri. And here again, we want to make sure that we replace the IPFS with Https. And once that's done, we should be able to fetch the image and display.
00:53:35.108 - 00:53:36.890, Speaker A: The image in the game and basically.
00:53:38.300 - 00:53:41.484, Speaker B: Get the texture of the image and.
00:53:41.522 - 00:53:49.928, Speaker A: Replace it with the white color that we see here in the quad.
00:53:50.104 - 00:54:30.010, Speaker B: So I'm going to save this and I'm going to play this. And now you can see it's logging the the details from the Uri. And it should replace this white quad, as you can see here with this little helmet that I have in my NFT faucet test faucet.
00:54:30.350 - 00:54:39.242, Speaker A: That's actually one item that I've been using, a top down game example which you can Google up on YouTube.
00:54:39.386 - 00:54:42.922, Speaker B: It has been presented with the Blockchain.
00:54:42.986 - 00:54:48.826, Speaker A: Gaming Alliance and also with ChainSafe very recently.
00:54:48.938 - 00:54:50.834, Speaker B: So if you have some time, try.
00:54:50.872 - 00:54:55.380, Speaker A: To Google it or search and it's on YouTube. It's quite interesting.
00:54:56.390 - 00:56:07.080, Speaker B: Okay, now that this is working, I'm going to put this back to Player Prefs. I'm going to save this. And what I want to do now is I want to build and test it this in our browser. So just going to show you what you can do. You can use the Web login scene and then when you go ahead and in the build settings, a couple of things that you have to do. You have to select WebGL and in the player settings, if you want to use the DeFi wallet, you will select the Kronos login here for the DeFi wallet. If you think you will mainly work with MetaMask, then you can go ahead and select the second template in here.
00:56:07.080 - 00:56:11.304, Speaker B: So what we want to do now.
00:56:11.342 - 00:56:11.930, Speaker A: Is.
00:56:14.380 - 00:56:37.666, Speaker B: Just build and run this, save it. Now it's going to take a bit to build the scene, all the scenes.
00:56:37.698 - 00:56:39.042, Speaker A: Because it's two scenes.
00:56:39.186 - 00:56:56.160, Speaker B: What it will show is basically a login scene where you have to connect your wallet. And then once that is done, it will basically replace any NFTs that you might have.
00:56:58.210 - 00:57:00.698, Speaker A: With the white quad in the second scene.
00:57:00.794 - 00:57:08.030, Speaker B: If you don't have any NFTs, then the quad will basically remain white and.
00:57:08.180 - 00:57:16.286, Speaker A: No texture will be lauded to the game. Okay, now that the build has completed.
00:57:16.478 - 00:57:32.114, Speaker B: Let'S go and check out our game in the browser. As you can see, we have a login screen, we have our MetaMask and our DeFi wallet in here. Let me see if my MetaMask is connected.
00:57:32.162 - 00:57:32.578, Speaker A: It's not.
00:57:32.604 - 00:57:43.770, Speaker B: So let's go ahead and here we can see the DeFi wallet, the wallet connect option, and as well MetaMask. I'm going to use MetaMask this time because my NFTs.
00:57:45.570 - 00:57:46.654, Speaker A: Have been created with.
00:57:46.692 - 00:58:08.920, Speaker B: My Kronos MetaMask account. I'm just going to go ahead and improve. And now I should see my image. Yeah, here we go. And that's it in a nutshell. So I hope this was. Helpful.
00:58:08.920 - 00:58:16.380, Speaker B: And I hope you have enough information to start to build your own NFT games.
