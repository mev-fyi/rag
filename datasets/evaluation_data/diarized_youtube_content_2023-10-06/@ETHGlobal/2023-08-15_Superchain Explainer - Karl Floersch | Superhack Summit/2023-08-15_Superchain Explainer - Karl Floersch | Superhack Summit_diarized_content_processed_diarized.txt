00:00:07.370 - 00:00:21.630, Speaker A: And we're going to kick us off with our very first talk today, right away with Carl talking about superchain 101. So without further ado, please welcome Carl here with me to tell you all about Superchains. Hey, Carl.
00:00:22.290 - 00:00:24.206, Speaker B: Why, hello. How's it going?
00:00:24.388 - 00:00:29.334, Speaker A: It's going great. We'll let you get started. Welcome.
00:00:29.532 - 00:00:53.022, Speaker B: All right. Well, I apologize for the semi false advertising, because this is definitely not a 101. This is more like significantly more very in depth. If you want a real 101, the DevCon talk is probably the way to go.
00:00:53.156 - 00:00:58.090, Speaker C: But you know what? We are all about getting into the weeds.
00:00:58.170 - 00:01:20.454, Speaker B: Also, notably, some of you might have seen some of this presentation before because it is on the YouTube, but I think it'll be a good refresher. There's way too much information here, so it's a good one. But yes, no fun allowed. This has to be a boring presentation because it's very in the weeds. Let's go. Let's do this. Time's up.
00:01:20.454 - 00:01:26.834, Speaker B: Okay, so, super chain to the rescue. Raman, why are we building the super chain?
00:01:26.882 - 00:01:30.330, Speaker C: Well, it's to scale because blockchains are.
00:01:30.480 - 00:01:47.594, Speaker B: Insufficient for the decentralized web that we want to create. Why is that? Well, because of congestion. Oh, my gosh. It's horrible. So blockchains don't scale, right? Like, we are often paying $15 for a transaction.
00:01:47.642 - 00:01:48.746, Speaker C: It's insane.
00:01:48.938 - 00:01:53.930, Speaker B: My transaction was just an Electronic Arts trying to tweet no, not tweet.
00:01:54.010 - 00:01:55.120, Speaker C: Trying to x.
00:01:56.050 - 00:02:11.686, Speaker B: And paid $13 for that transaction. No way. No way. So we need scalable infrastructure that is decentralized, but can still support the insane amount of traffic and throughput that, we.
00:02:11.868 - 00:02:14.134, Speaker C: Require and this isn't new, right?
00:02:14.172 - 00:02:35.854, Speaker B: Like, this has been a problem from day one. First response to the bitcoin white paper. We very much need the system, but the system you proposed does not seem to scale. Sorry, Satoshi. We have to make progress on top of it. So, anyway, this has been plaguing the industry since 2008. It's now 2023.
00:02:35.854 - 00:02:45.746, Speaker B: Goodness gracious. Let's do this. Okay, before we get too sad and cry, let's imagine a future, because we.
00:02:45.768 - 00:02:47.090, Speaker C: Are very close to that future.
00:02:47.160 - 00:03:11.962, Speaker B: We are incredibly close. What if things were different? It wasn't just crypto, wasn't just about meme coins. And everyone was using it for literally everything, all, like, from social media to games to et cetera. The whole world was running on decentralized infrastructure. Well, what would that be like?
00:03:12.016 - 00:03:15.962, Speaker C: Right? We can literally abstract away the back end software set.
00:03:16.016 - 00:03:28.110, Speaker B: We don't have to worry about what provider we're using, because we're using a decentralized network of providers that are all competing on the same Internet standards. It's like standards for the entire Internet's back end.
00:03:28.260 - 00:03:30.526, Speaker C: And additionally, if we had that, we.
00:03:30.548 - 00:04:15.802, Speaker B: Would have so much more composability. People can actually work together. Application developers can work together. The boundaries start to dissolve between one application or the other, and we don't need to worry as much. We can think more about the applications that we're building, and not so much just about the infrastructure cost, I mean, let alone all of the amazing open source software that we would then be using. And this is how we currently the Internet from a walled garden, difficult to hack on and contribute to ecosystem, to a vibrant, vibrant world. And so obviously, of course, in reality, these pictures were going the other direction.
00:04:15.802 - 00:04:25.874, Speaker B: Stopped using some blog FAM. That's our sponsor. Okay, anyway, no. Oh my gosh. I literally need to update these slides with the Twitter on this.
00:04:26.072 - 00:04:28.274, Speaker C: You can build in this world, right?
00:04:28.392 - 00:04:46.182, Speaker B: You should be able to build the application logic for Twitter that is horizontally scalable as a smart contract in a haggathon weekend. That's where we need to be. Okay, so the decentralized web obviously still can be realized. We've been working on it for years.
00:04:46.316 - 00:04:48.806, Speaker C: Started out building out E 2.0 like.
00:04:48.828 - 00:05:01.066, Speaker B: We were trying to shard Ethereum directly. Then we realized that we needed to build it out in layer two, which we formed Plasma Group to scale Ethereum in that way without having to ask.
00:05:01.088 - 00:05:04.782, Speaker C: For permission, we just implement it. And then we realized that not only.
00:05:04.836 - 00:05:22.542, Speaker B: Is there a scalability problem, but optimism. We realize there's a public goods funding problem, aka there's no way to build open source software and get rewarded for it. So that's kind of the transition from Plasma Group to optimism.
00:05:22.606 - 00:05:26.502, Speaker C: So anyway, but it's not just been us. It's not just been us building out this tech.
00:05:26.556 - 00:05:55.406, Speaker B: It has been a massive web3 ecosystem full of developers and tons of incredible contributions. Talking about roll ups, the roll up centric Ethereum roadmap. And it has allowed us to over time to find the extraction layers that allow us to scale this software together. Right? In order to really unlock the Internet stack, we needed to define the stack of software that all works together, the.
00:05:55.428 - 00:05:58.222, Speaker C: Transport layer, et cetera, that all works.
00:05:58.276 - 00:06:27.622, Speaker B: Together to serve the Internet. We're doing the same thing this time for the decentralized web, for essentially the stateful. Decentralized web first web one was kind of stateless. So all of these different contributions, they've led us to L2. They've let, you know, shout out to Barry Lynette. We are starting to see the architecture clearer and clearer. And so that's really what this talk is about.
00:06:27.622 - 00:06:44.282, Speaker B: It's trying to give you the intuitions around what are the different layers of this stack and how do they all fit together and how all of that comes together to tackle congestion with the super chain. Let's go super hack.
00:06:44.346 - 00:06:44.714, Speaker C: POW.
00:06:44.762 - 00:07:05.934, Speaker B: One, two, three. Okay, so what is the super chain? First, the basics, right? Scaling to support the Internet requires more than one chain. Why is that? Well, because a chain, you need to be able to sync the chain, download all the transactions, replicate it on your local machine. That is a critical property of chain software.
00:07:06.062 - 00:07:08.266, Speaker C: But if we were to just increase.
00:07:08.318 - 00:07:09.106, Speaker B: The size of a chain?
00:07:09.138 - 00:07:13.206, Speaker C: Arbitrarily. Well, what happens? The blacks get bigger and bigger until.
00:07:13.388 - 00:07:29.702, Speaker B: My computer explodes and forms a black hole because there's too much information in one place. We need to horizontally scale. It's a fundamental law of nature. But it's not MultiChain, right? The superchain is not quite the MultiChain.
00:07:29.766 - 00:07:40.382, Speaker C: Future because multichains are insufficient. Each different chain has its own different trust model, its own different validator set. So each one has security.
00:07:40.516 - 00:07:41.806, Speaker B: So as you bridge from chain A.
00:07:41.828 - 00:07:48.994, Speaker C: To chain B to chain C, that is actually a different asset that you fundamentally created versus bridging from chain A.
00:07:49.032 - 00:07:59.730, Speaker B: Directly to chain C. So this weakest link security really increases the risk of building out cross chain DApps.
00:07:59.890 - 00:08:02.962, Speaker C: And also deploying chains is super expensive.
00:08:03.026 - 00:08:33.790, Speaker B: If you have to replicate all of this infrastructure, form consensus, et cetera, it is very expensive. So we need a system where chains are truly commoditized, where we can really make use of them as a fundamental construction on the Internet, similar to how virtual machines commoditized. Anyway, it's not Monochain, it's not multi chain. Super chain. Let's go. Okay, so super chain properties we can kind of go into all about, but.
00:08:33.860 - 00:08:38.030, Speaker C: I'm not going to really go into that because there's too many words and I like pictures.
00:08:38.190 - 00:08:45.506, Speaker B: So it's not marching. Is that multi chain? So, first up, just one visualization that we can start with.
00:08:45.608 - 00:08:47.906, Speaker C: Is it's all of these different layer.
00:08:47.938 - 00:08:50.962, Speaker B: Twos that share a bridge and share node software?
00:08:51.026 - 00:08:59.354, Speaker C: So they're all, instead of having totally isolated ecosystems, they're all using the same standards to communicate with each other, and.
00:08:59.392 - 00:09:03.670, Speaker B: They are all on the same security model using a shared bridge.
00:09:03.750 - 00:09:15.710, Speaker C: Okay, so that means that because all of these op chains are standardized, the DApps that are building on them get superpowers. Because now I don't need to think.
00:09:15.780 - 00:09:26.922, Speaker B: Oh, is this going to be compatible with this chain? Do I need to change my application for that chain? No. Instead you can write an application once and be ensure that it is compatible everywhere.
00:09:27.066 - 00:09:35.650, Speaker C: So you can then build out these abstractions and deploy directly on the superchain. So I told you that we were going to be a little different restaurant.
00:09:35.730 - 00:09:47.950, Speaker B: Stuff online that you can find already. So this is a bonus section governing the standard. Okay, so shout out to David Hoffman.
00:09:48.050 - 00:09:51.046, Speaker C: Standardized open source modules for layer two chains.
00:09:51.078 - 00:10:17.630, Speaker B: That's the op stack, if you like, Google it or YouTube it. So that makes sense, right? Open source modules makes sense, right? It's all open source. If it licensed modules, it's swappable. We broke it down to consensus execution. The proofs are modular, so you can do ZK proofs, fault proofs, et cetera. But what does standardization really mean in this context?
00:10:17.710 - 00:10:25.042, Speaker C: Because it's a little nuanced, especially when you're in a decentralized protocol context, who defines the standard.
00:10:25.176 - 00:10:49.574, Speaker B: Okay, so let's unpack that. I've recently started to like tab not going to lie anyway. Okay. The op stack, right? Everyone's familiar, hopefully. So the op stack implements that is the standard, right? And it implements a shared bridge and consistent client software across all of these different op chains.
00:10:49.622 - 00:10:51.802, Speaker C: Now, notably, it is still the case.
00:10:51.856 - 00:11:09.486, Speaker B: That you can plug different things in or configure it in different ways. But the way that you plug in those modules and the modules, they are standardized so that you have nice abstractions that you can play with and kind of a shared ground that you can rely on. Now, how do we think about this rubbit?
00:11:09.518 - 00:11:14.958, Speaker C: Well, the optimism, governance, optimism, collective governs.
00:11:15.054 - 00:11:18.342, Speaker B: The Op stack sets V zero, V.
00:11:18.396 - 00:11:20.982, Speaker C: One, and that boom, that expands out.
00:11:21.036 - 00:11:56.786, Speaker B: To the rest of the client software, the shared bridge, so that everyone is upgraded on the same version, similar version two, everyone is upgraded on the same version. All of these just op chains stay in lockstep. What does that do? Well, it helps keep a vibrant ecosystem and I'll tell you why. So let's see all of these different op chains. Okay? So first off, let's talk about standard security. What does that do for the security model of these chains? Well, what I talked about before with the MultiChain stuff where you go from.
00:11:56.808 - 00:11:57.966, Speaker C: Chain A to chain B to chain.
00:11:57.998 - 00:12:11.202, Speaker B: C, and that's a different token that you cut out on chain C versus chain A to chain C. That is not the case because you have this standard security across the bridge. Okay, so that's useful.
00:12:11.266 - 00:12:12.290, Speaker C: That's already useful.
00:12:12.370 - 00:12:34.206, Speaker B: That means that we're not fragmenting the token standards and all of that stuff. But another and very important point is universal tooling. Now, I already mentioned all of these things, but I think it's worth repeating so that we can gain some intuitions for this stuff. So let's say a developer is deploying their smart contract to an op chain. Okay, great.
00:12:34.308 - 00:12:48.750, Speaker C: Well, let's say now, because they are all the same software, like all of these op chains are standardized, that same deployment works on all of the op chains. And that also goes for the tooling.
00:12:48.830 - 00:12:58.578, Speaker B: Let'S say Block, Explorers, Wallet, Debuggers, et cetera, they all work on the same standard. This is the power of standardization more broadly.
00:12:58.674 - 00:13:00.390, Speaker C: But I'm just trying to really connect.
00:13:00.460 - 00:13:10.934, Speaker B: It to why you need it in web3. Now side notes, a couple of chains. It's a bajillion chains, tons and tons of chains.
00:13:11.062 - 00:13:20.266, Speaker C: What can we do now? Well, we can actually build out abstraction layers so that a developer, instead of thinking about the chain that they're deploying to, right?
00:13:20.288 - 00:13:22.538, Speaker B: Yes, it's compatible with all the chains. That's great.
00:13:22.624 - 00:13:30.906, Speaker C: But now we can actually go one more step, meta and say, okay, we're going to build software that abstracts it away. And now I can deploy directly onto.
00:13:30.938 - 00:13:32.554, Speaker B: The super chain broadly.
00:13:32.682 - 00:13:37.714, Speaker C: I can think about, oh, I need to instantiate, I need to provision this.
00:13:37.752 - 00:13:41.630, Speaker B: Many chains for my application. To work, right? I need to auto scale.
00:13:41.710 - 00:13:44.946, Speaker C: All of those things start to become possible.
00:13:45.128 - 00:13:59.282, Speaker B: Once you're on the same standard, you're sharing the same APIs, you're working together in an open source manner. So now the block explorers don't just have to be on a per chain basis. They can be abstracted and they can be on a super chain basis.
00:13:59.346 - 00:14:08.058, Speaker C: Wallets, they can be on a super. We can start to see super chain wallets emerge that, you know, that all of these chains have standardized security so.
00:14:08.144 - 00:14:11.194, Speaker B: You can display the asset, doesn't matter.
00:14:11.232 - 00:14:20.042, Speaker C: What chain it's on. Or similarly debuggers, debug across the superchain, send one transaction, boom, have it affect the whole network.
00:14:20.186 - 00:14:23.154, Speaker B: So that's the power.
00:14:23.272 - 00:14:38.514, Speaker C: And I'll just say right now, similar what I said about Kubernetes or containers. I'm ready for not just Kubernetes, I'm ready for like, let's build out all of this software.
00:14:38.562 - 00:15:21.860, Speaker B: And obviously it is nowhere near to that today. That's the key power of open source. Now, speaking of the key power of open source, let's talk about cooperative innovation. Let's talk about sharing our innovations. Okay? So another shout out to David Hoffman. I'm not going to lie, he kind of talked about this analogy for EVM equivalents, which is exactly the analogy that we use kind of for the Op stack, and that is the peloton. So the peloton is like when you're racing in a bike, you kind of break the wind first here, right? So you use less energy if you're riding behind folks who are out in front.
00:15:21.860 - 00:15:47.814, Speaker B: This allows everyone to move faster, right? Because they get to trade turns. This guy's in front and that guy's in front, et cetera. You can look about peloton's work I don't know how to buy. But the cool thing here is that the Peloton is kind of like the standard, right? It's the open source standard. Everyone is benefiting. They're all working together. They don't need to worry so much about upgrades, about customizations, et cetera.
00:15:47.814 - 00:15:57.902, Speaker B: Now, boom, someone forks the stack, right? It's MIT licensed, it's open source. They change something up. Maybe another person does the same. Boom, they change something up.
00:15:57.956 - 00:16:03.706, Speaker C: Now they're riding, they are venturing into totally new territory. That means that they have the latest.
00:16:03.738 - 00:16:10.690, Speaker B: And greatest Craziest software, but they've also incurred a bit of maintenance burden, right? They're hitting the wind.
00:16:10.840 - 00:16:17.442, Speaker C: So what do they do? Well, they ride out front with their innovations, but then they contribute them back to the stack.
00:16:17.506 - 00:16:34.742, Speaker B: And now everyone who's in the Peloton is benefiting from that innovation and we push the industry forward. That is what it is all about. It's about building open source software and standards to push the industry forward. And that is the beauty of open source.
00:16:34.886 - 00:16:38.438, Speaker C: Now, what happens, what about open source.
00:16:38.454 - 00:16:41.886, Speaker B: Is one thing, but open source has had a bit of a struggle, and.
00:16:41.908 - 00:16:43.966, Speaker C: That is that there is not a.
00:16:43.988 - 00:16:54.414, Speaker B: Strong incentive in a decentralized system to contribute back to the upstream to contribute back to the collective. Really?
00:16:54.532 - 00:17:00.226, Speaker C: And what does that mean? That means that if I build my custom software, there's an incentive for me.
00:17:00.248 - 00:17:05.202, Speaker B: To keep it to myself, add some kind of proprietary license instead of giving it back to the public.
00:17:05.256 - 00:17:07.590, Speaker C: Good. Now what do we do for that?
00:17:07.660 - 00:17:16.310, Speaker B: Well, obviously optimism is not just about scaling ethereum, but it's also about funding public goods and so retroactive public goods funding. Let's go.
00:17:16.380 - 00:17:39.326, Speaker C: So another incredibly cool thing is that the standard also encodes standard ways to give back to op stack contributors and reward them for their incredible contributions that push the stack forward. That means that we're not only benefiting from the open source software, permissionless innovation, et cetera, but that permissionless innovation, once.
00:17:39.348 - 00:17:49.426, Speaker B: It is integrated, once it is really caused impact. The people who build it get rewarded. Impact equals profit. So this is exactly how this kind.
00:17:49.448 - 00:17:53.646, Speaker C: Of creates this nice drywall where demand for block space increases secrets of revenue.
00:17:53.678 - 00:17:56.446, Speaker B: And that goes back to the builders, users.
00:17:56.558 - 00:18:01.286, Speaker C: And importantly, how does it go back? How is it distributed? Because that is a nontrivial governance problem.
00:18:01.388 - 00:18:14.158, Speaker B: Well, critically, it is a citizens house discretion. That means one person, one vote. We care about people always in balance with the token house and nice checks and balance the system, the bicamel.
00:18:14.194 - 00:18:15.706, Speaker C: Anyway, I could get into that for.
00:18:15.728 - 00:18:41.906, Speaker B: A long time, but I won't. The point is that it's all about non plutocratic governance that is truly decentralized to govern and contribute to the stack. So we're making public goods profitable in a non plutocratic way. We're making them sustainable. So we know that we can rely on the open source infrastructure. We're not going to have a heart bleed and we can make sure the internet is decentralized. Because one of the things that we.
00:18:41.928 - 00:18:44.114, Speaker C: Don'T really recognize is that it is.
00:18:44.152 - 00:19:14.890, Speaker B: Incredibly important that the incentives of the system, the incentives of the decentralized protocol promote decentralization versus allowing centralized parties to outcompete the decentralized ones. All right, so let's do this. So we're back. We're back. That was a nice little bonus, right? Reminder building out the super chain. They're all standard deploy on the super chain coming soon. Now, it's been a decade.
00:19:14.890 - 00:19:27.082, Speaker B: Pretty kind of savage how long we've been working on this thing, but we are closer than ever. And really this is a green field. I don't know. That was a bad Windows XP.
00:19:27.226 - 00:19:31.986, Speaker C: Anyway, it's a green field. Green field and you can contribute to.
00:19:32.008 - 00:19:39.906, Speaker B: Help this thing become real sweet. All right, that's governing the standard. So architectural foundations, this is the thing.
00:19:39.928 - 00:19:42.854, Speaker C: That I was talking about. This still in the weeds. The boring stuff.
00:19:42.972 - 00:20:03.306, Speaker B: Let's get into the boring stuff. No, okay. It's all about abstraction layers. When things are beautifully done, there's usually a well thought out set of abstraction layers. So derivation, that is the core abstraction layer the most important. So this is the process by which the L two state is determined. That means that essentially it is a.
00:20:03.328 - 00:20:05.194, Speaker C: Pure function on the L one chain.
00:20:05.242 - 00:20:28.246, Speaker B: So you use this derived function. Boom. Now it spits out the L two chain. It's a pure function. So if I have ethereum, that's the ethereum block space. Now I run this derive function and I get the L two. All right? So if I send a transaction, let's say I'm I send a transaction to ethereum, the derived function, pure function, transforms that.
00:20:28.246 - 00:20:37.874, Speaker B: It's almost like an index or like an index on ethereum. Boom. It now updates the balances in L two. And this continues.
00:20:37.922 - 00:20:39.446, Speaker C: Even if there's nothing happening in the.
00:20:39.468 - 00:21:04.382, Speaker B: Blocks, it's still producing L two blocks. Now, similarly, Alice can submit to L one directly or can submit to a sequencer which then submits it on her behalf. And this amortizes the cost of the transaction and also provides her low latency confirmation that derived function happens again. Boom. Now we have the L two because.
00:21:04.436 - 00:21:08.260, Speaker C: Remember, the sequels are submitted that transaction to L one.
00:21:08.870 - 00:21:23.638, Speaker B: Pretty simple. Okay, so let's go over. This is an important game. Everyone needs to remember Myth. This is where we're in Mythbusters. The Sequencer can forge transactions, true or false. Okay, well, we're going to see.
00:21:23.638 - 00:21:45.802, Speaker B: So Alice says a transaction to the Sequencer. It's a signed transaction. Only Alice knows the private key. The Sequencer changes the recipient of the money of the tokens, let's say. And now the transaction signature. Well, it's invalid, but the Sequencer is not done yet. The Sequencer will submit that transaction to ethereum.
00:21:45.802 - 00:22:03.074, Speaker B: Okay. Uh oh, the Sequencer just submitted an invalid transaction. What's going to happen? Well, derive this derive function happens when I'm locally deriving the chain. This is not necessarily something the Sequencer does. Anyone can derive the chain. I spin up a node and I'm deriving the chain, remember?
00:22:03.192 - 00:22:09.986, Speaker C: So I locally derive the chain. As I'm deriving the chain, I realize that this transaction is a little iffy.
00:22:10.018 - 00:22:14.354, Speaker B: It has the wrong signature, so I'm going to throw it away. Boom.
00:22:14.402 - 00:22:16.146, Speaker C: And I'm going to create an empty block.
00:22:16.258 - 00:22:38.894, Speaker B: Ignoring the invalid transaction, myth busted. The sequencer cannot forge transactions. That is incredibly important. Your mental model, it really must be that the state of L two is derived and determined objectively based on layer one. That is critically important and no one can change that.
00:22:39.012 - 00:22:41.374, Speaker C: If I'm deriving the chain myself, no.
00:22:41.412 - 00:22:44.450, Speaker B: One can make me derive an invalid chain.
00:22:45.030 - 00:22:51.870, Speaker C: Okay, so that's deriving one chain. But really all roll ups are just different derivation functions on ethereum.
00:22:51.950 - 00:23:28.702, Speaker B: So there's the L two chain, and it's the result of calling derived on an L one chain. But they each have a slightly different derivation function. Okay, so the red derivation function results in the red chain, blue and the blue and purple and the purple if that's purple. And they each have their own sequencers that are submitting transactions and of course, when those transactions are submitted, boom. Now there's new transactions on layer two for all of the different layer twos. So if I want to submit to red chain, I can, or I can submit to blue chain and derive that I can do that.
00:23:28.756 - 00:23:30.762, Speaker C: Or let's say I derive purple chain.
00:23:30.826 - 00:23:31.470, Speaker B: It all works.
00:23:31.540 - 00:23:39.646, Speaker C: This is why L two scales, by the way, because every time I decide to sync a new chain, I'm not syncing all the blocks on all of the chains.
00:23:39.678 - 00:23:47.090, Speaker B: I'm only syncing the chain that I care about. This is why we need a super chain. This is why the kind of mono chain thing doesn't quite work out.
00:23:47.240 - 00:23:50.670, Speaker C: Okay, so now that was there at.
00:23:50.680 - 00:23:59.162, Speaker B: Deriving chains, but let's go to deriving super chains. Okay, so practically infinite roll of chains. What does this do?
00:23:59.216 - 00:24:03.018, Speaker C: So instead of defining our derived function.
00:24:03.184 - 00:24:23.514, Speaker B: As just a function of L one, we're going to define the derivation function as an L one, comma the configuration of that chain and make sure that that configuration is, of course, a standard configuration. Otherwise, the derivation function will throw that results in an L two chain.
00:24:23.562 - 00:24:31.310, Speaker C: But notably, if you change the config. So let's say you change the chain ID. Now you're deriving a different fold.
00:24:31.390 - 00:24:33.394, Speaker B: This gives you access to basically an.
00:24:33.432 - 00:24:36.658, Speaker C: Infinite number of chains. Literally. It is a standard.
00:24:36.744 - 00:24:44.854, Speaker B: So you can instantly derive all the things kind of like looking into a Kaleidoscope. All of the stuff is there, but.
00:24:44.892 - 00:24:46.422, Speaker C: You'Re just looking at it from different.
00:24:46.476 - 00:25:03.086, Speaker B: Angles and kind of getting a different view of what's going on. Got to have a little trippy imagery when you're talking about infinity. It's pretty cool. That's mass for you. Okay, so you're deriving all of these different chains, these infinity chains. It's not infinity. Of course.
00:25:03.086 - 00:25:19.230, Speaker B: There's a limited number of bytes and a half, but it's practically infinite. Okay, so that is how we get a Bajillion chains. All right, let's see. Okay, I think I have 15 minutes left, if I recall correctly.
00:25:20.950 - 00:25:23.166, Speaker C: So let's talk about cross chain messaging.
00:25:23.198 - 00:25:36.854, Speaker B: But we'll go reasonably quickly. So how do these chains communicate with each other? Because we talked about how you get the state of a chain, but now how do chains talk to each other? How do they bridge between each other? So Alice and are.
00:25:36.892 - 00:25:37.622, Speaker C: Let's start off.
00:25:37.676 - 00:25:56.526, Speaker B: What does messaging look like in a normal world? Alice sends a letter to Bob. She has a two and a message and a proof. The proof is her signature. She goes and she gives it to Mo the mail person, and hand Mo the mail person, gives it over to Bob, and he checks the two. He checks the signature to make sure.
00:25:56.548 - 00:25:58.398, Speaker C: It'S from Alice and then reads the.
00:25:58.404 - 00:26:00.314, Speaker B: Message knowing that it's authenticated.
00:26:00.442 - 00:26:03.354, Speaker C: Well, what if I told you that these were actually chains?
00:26:03.402 - 00:26:05.202, Speaker B: They were chains talking to each other?
00:26:05.256 - 00:26:10.978, Speaker C: Well, actually, what happens is Mo initiates tells Alice Chain, hey, I want to.
00:26:10.984 - 00:26:34.522, Speaker B: Bridge my tokens to Bob. Chain sends that transaction migration tokens. Boom. Now, Alice Chain just does its magic and it generates a message that will go be sent to Bob that we want to send to Bob. Now, Mo, the person who initiated the transactions, where the analogy breaks down a little, but it's pretty close.
00:26:34.656 - 00:26:39.674, Speaker C: Mo takes that as well as a proof, a proof of the validity of.
00:26:39.712 - 00:26:49.470, Speaker B: That message and sends it over to Bob. And Bob validates the two, the message and the proof. And the proof, the message is executed on Bob chain.
00:26:49.890 - 00:26:50.302, Speaker C: Right?
00:26:50.356 - 00:27:07.298, Speaker B: So what we're doing is we're relaying message and we are proving we actually how do we actually achieve this? Well, the two is easy, the message is easy, but the proof is pretty hard to do. So how does this actually work in.
00:27:07.304 - 00:27:08.846, Speaker C: Practice and how do all these proof.
00:27:08.878 - 00:27:10.406, Speaker B: Systems work just in general?
00:27:10.508 - 00:27:11.970, Speaker C: We're total distraction layers.
00:27:12.050 - 00:27:16.070, Speaker B: We need to be able to think at a high level and then zoom into each detail.
00:27:16.140 - 00:27:17.638, Speaker C: So first we're at the high level.
00:27:17.724 - 00:27:19.042, Speaker B: How does this work generally?
00:27:19.106 - 00:27:21.994, Speaker C: Well, a message is generated on Red.
00:27:22.032 - 00:27:33.114, Speaker B: Chain and that wants to be relayed. Someone wants it to be relayed on Blue Chain. Well, what happens is the two is of course Blue Chain, the message is arbitrary and the proof we'll get to that.
00:27:33.152 - 00:27:34.766, Speaker C: So how does the proof actually how.
00:27:34.788 - 00:27:37.454, Speaker B: Does Blue Chain know that Red Chain actually sent it?
00:27:37.492 - 00:27:40.154, Speaker C: Well, because Blue Chain knows the derivation.
00:27:40.202 - 00:28:09.570, Speaker B: Function of Red Chain based on its chain ID and chain config. What can it do? Well, it can derive that chain in some way. Boom. It derives the chain based on L one because of course all of these chains are connected to L one. So it derives the chain and then it checks the authenticity of that message. So you might notice a problem, right? If you were to do this kind of like fully verifying proof, it would not scale whatsoever. All the chains would be verifying the messages from all the other chains.
00:28:09.650 - 00:28:12.442, Speaker C: So what do we do? Well, all of these proof systems, they.
00:28:12.496 - 00:28:37.118, Speaker B: Somehow manage to compress that proof into a small number of steps, whether that be a fault proof or a validity proof. They are all running this derivation function in some sense and validating the correctness. Now, the fault proof does it only if there's an error and a validity proof does it upfront using math or some other method.
00:28:37.214 - 00:28:43.522, Speaker C: So importantly, right, I was thinking about modularity. Importantly, all of these proofs are valid, all of these proofs are fine.
00:28:43.576 - 00:28:47.314, Speaker B: So the Op stack, it's all about modularity. We need to be able to do.
00:28:47.352 - 00:28:50.466, Speaker C: Fault proofs attestation based validity proofs, ZKP.
00:28:50.578 - 00:28:55.030, Speaker B: Validity proofs, all that stuff needs to support all proof types.
00:28:55.370 - 00:28:57.142, Speaker C: So now we can message between them.
00:28:57.196 - 00:29:04.762, Speaker B: But each message is asynchronous. Well, we don't have time, unfortunately, to go into shared sequencing directly but at a high level.
00:29:04.816 - 00:29:05.818, Speaker C: It's actually very simple.
00:29:05.904 - 00:29:22.778, Speaker B: Basically, if you want to be able to send these messages back and forth, you need to be able to do them atomically. And therefore you need both chains, the sequencers on each chain to coordinate and get those messages, get a guarantee that both messages will be played on each chain at the same time. That's shared sequencing.
00:29:22.874 - 00:29:24.206, Speaker C: And it gives us the ability to.
00:29:24.228 - 00:29:50.662, Speaker B: Do things like flash loans and really tighten up that interoperability. And so boom, we can coordinate these sequencers. And there are many different ways to do this. Okay, so now we've got crossing messaging Synchronization. But I cannot end this talk without talking about the elephant in the room scaling data availability. We still have a bottleneck, right? If you were looking at this system, you would notice that we're deriving infinite chain. Great, fantastic.
00:29:50.726 - 00:29:52.682, Speaker C: But we're only deriving it based on.
00:29:52.736 - 00:30:07.054, Speaker B: A very limited amount of data. That means that we've only scaled compute. We have not scaled data yet. That is the data bottleneck. What am I going to do? So what do we need to do?
00:30:07.092 - 00:30:09.610, Speaker C: Well, first we can add in more element data Availability.
00:30:09.690 - 00:30:31.346, Speaker B: So that's EIP four eight four. That is the most key fundamental thing that we're shipping actually very soon. So very excited for EIP four eight four. Additionally, in order to horizontally scale, at least in the near term, we need to do more. And that is where the plasma protocol and alternative data availability providers come in. Plasma.
00:30:31.378 - 00:30:32.306, Speaker C: Remember plasma root.
00:30:32.338 - 00:30:40.442, Speaker B: We're going back to our roots, baby. Okay, so plug in additional data availability. Providers with a plasma API. How does that work?
00:30:40.496 - 00:30:43.242, Speaker C: Okay, well, notably, this is not just.
00:30:43.296 - 00:31:12.302, Speaker B: Alt DA in the abstract. This is a protocol for coordinating and basically allowing Alternative Data Availability Providers to plug into the same unified system. So what do they do? Well, we augment l One. Data availability. Instead of taking the raw transaction data, what do we do is instead of submitting that to Ethereum, we hash it and we commit to that raw transaction data and we submit the commitment to Ethereum.
00:31:12.446 - 00:31:19.666, Speaker C: That allows us, in the derivation process, assuming the data is available, to pull in all of this information and validate.
00:31:19.698 - 00:31:23.458, Speaker B: It against the Ethereum total ordering of transactions.
00:31:23.554 - 00:31:25.074, Speaker C: And that also allows us to plug.
00:31:25.122 - 00:31:31.580, Speaker B: In multiple different Data Availability Providers all submitting their own kinetic in a standard format and process.
00:31:32.190 - 00:31:42.014, Speaker C: That means that we've gotten all of these we've horizontally scaled Data Availability Providers, which means that we've got infinite chains which can meet infinite data.
00:31:42.212 - 00:31:53.966, Speaker B: Very exciting. So this is how you get close enough to infinity scalability. Obviously, it's easier said than done, but importantly, the Data Availability Provider may break. And this is what makes it a.
00:31:53.988 - 00:31:56.174, Speaker C: Plasma as opposed to a side chain.
00:31:56.302 - 00:32:03.854, Speaker B: So if the data that was committed to on Ethereum becomes available, what do we do? Well. We can do a data availability challenge.
00:32:03.902 - 00:32:05.422, Speaker C: Notably, these are subjective.
00:32:05.486 - 00:32:19.174, Speaker B: They cannot be penalized directly on Ethereum. Ethereum doesn't know who's right or if the data is available or not. It's off chain data. But users can submit this Data Availability Challenge and then withdraw from the chain. So how does it work?
00:32:19.212 - 00:32:20.570, Speaker C: Well, Alice says, Give me the data.
00:32:20.640 - 00:32:49.106, Speaker B: And tells Ethereum to give me the data. Now, either one of two things happen. Either the data is revealed, aka the Data Availability Provider posted, or the commitment is deleted from Ethereum and is therefore ignored from the total ordering of transactions that is directly available on L One. And that is all done in this derivation process that we talked about before. It is not any different. And so this also, by the way.
00:32:49.128 - 00:32:58.090, Speaker C: Just as a note, that means that if we build out the right abstractions, then the proofs that work for roll.
00:32:58.110 - 00:33:00.738, Speaker B: Ups, roll up chains also work for plasma chains.
00:33:00.754 - 00:33:04.130, Speaker C: Now, notably, plasma chains are fundamentally secure than roll ups.
00:33:04.210 - 00:33:37.634, Speaker B: There is no way to get the same level of security for your data as posting it directly to Ethereum. But it does mean that even if the Data Availability Provider goes offline, you don't lose safety. You'll lose access to the data for a short period of time. But you can always get that data with a Data Availability Challenge. So not too bad. Great. So these are the two things, right? Roll up all data on L One secure, inexpensive plasma commitments to data on L One less secure, but nearly free.
00:33:37.634 - 00:33:48.338, Speaker B: Very exciting. Infinite chains, chain messaging. Synchronization infinite data. That is how we create the super chain.
00:33:48.514 - 00:33:49.494, Speaker C: Let's go.
00:33:49.612 - 00:33:50.358, Speaker B: All right.
00:33:50.524 - 00:33:52.774, Speaker C: Oh, no. It's congestion. What are we going to do?
00:33:52.892 - 00:34:08.070, Speaker B: POW. Knocked them out. We're done. We are in that world we believe in, that we know we can create the decentralized world. And it was created because of folks like you contributing to the Op stack.
00:34:08.150 - 00:34:10.154, Speaker C: Folks like me. We're all doing it together.
00:34:10.272 - 00:34:18.366, Speaker B: It's one happy party of open source software. Notably, this is all not actually here yet.
00:34:18.468 - 00:34:27.534, Speaker C: However, we're still building it, right? We're still building it. We know that the concepts are there. This is what I just talked about is a culmination of an enormous, enormous.
00:34:27.582 - 00:34:28.866, Speaker B: Amount of research that has been done.
00:34:28.888 - 00:34:33.474, Speaker C: In the Ethereum and elsewhere communities finally.
00:34:33.592 - 00:34:45.990, Speaker B: Ready to be implemented in open source license software for the community, for the world public goods forever. So, to infinity and beyond, right?
00:34:46.060 - 00:35:02.042, Speaker C: We are so close. We can see that incredible future ahead of us. We are getting there. It will get there with all that public goods funding, generating revenue with this open source software that goes back to the contributors that built it. Very exciting.
00:35:02.106 - 00:35:15.586, Speaker B: Together, we can build the open source Internet and realize Ether's phoenix impact equals profit. The earlier you start building public goods, the more profitable shall be because the more impact you can have because we.
00:35:15.608 - 00:35:25.460, Speaker C: Are currently in a state of, honestly, a little bit of crisis. Not to scare you, but we're very unclear if decentralization on the Internet is going to win.
00:35:25.770 - 00:35:45.018, Speaker B: Hopefully it does, for everyone's sake, because we're humans and we want the Internet to be human first. So that's how we create the super chain which births the collective come contribute. Welcome to the collective, because you're already in.
00:35:45.104 - 00:35:46.058, Speaker C: Did I tell you?
00:35:46.144 - 00:35:54.390, Speaker B: Anyway, stay optimistic. Thank you. I actually didn't get the questions. I'm sorry. No worries.
00:35:54.560 - 00:36:18.580, Speaker A: We actually have a couple of minutes, so anybody in the audience wants to ask any questions, feel free to send them in the chat and we'll relay them here. We do have one question right now, which is kind of from what you just talked about in the last couple of slides. The question is around the incentives for actors to challenge if the data is available and kind of how do you the economics of all of that?
00:36:19.370 - 00:36:32.566, Speaker B: Okay, great. So basically the problem is that this is the Fisherman's Dilemma. So if you want to look it up, the problems with it, this is why we don't do data Availability for L One, but there's a really nice property on L2 with Data Availability Providers.
00:36:32.598 - 00:36:46.222, Speaker C: So who pays for the data? That question well, it is the person who wants the data pays for the data itself, because we can't figure out if the person who is asking for the data is asking for it because.
00:36:46.356 - 00:36:52.378, Speaker B: It is genuinely not available or just because they're trolling the Data Availability Provider.
00:36:52.474 - 00:36:56.114, Speaker C: So there's an interesting catch, though. It might not be attributable on l.
00:36:56.152 - 00:37:09.218, Speaker B: One, but it is subjectively attributable on L2 for the person who's submitting the challenge. So I know if I'm just griefing the Data Availability provider, we need to protect against that. That's why the person who submits pays the bond.
00:37:09.314 - 00:37:16.134, Speaker C: But if I am a user of a Data Availability Provider and they go rogue, I submit the challenge and I.
00:37:16.172 - 00:37:19.590, Speaker B: Get off of that data availability or can migrate to a new one.
00:37:19.660 - 00:37:21.654, Speaker C: So that is actually how we can.
00:37:21.692 - 00:37:37.150, Speaker B: Remain secure and also kind of get around the trickiness of the Fisherman's Dilemma. Again, this doesn't negate the need for roll ups. Roll ups have this incredible unstoppable property that Plazas just fundamentally cannot because of the titian's dilemma.
00:37:38.050 - 00:37:58.660, Speaker A: Awesome. Hopefully, Laura, your question got answered. If there's any follow, sort of put that in chat. We'll relay that to Carl. But that was an amazing talk. Carl, thank you so much for that amazing 201 Primer and looking forward to see more on the super chat. All right, thank you.
