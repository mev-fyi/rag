00:00:06.090 - 00:00:23.550, Speaker A: All right. Good morning, good afternoon, good evening. Depending on where you're calling from, we have Rahat here from Polygon doing a workshop on Improving UX in Web Three. If you have any questions, they can go into the Zoom chat and Rahat will be more than happy to answer them. And with that being said, I will pass off the mic to Rahat.
00:00:24.290 - 00:00:46.950, Speaker B: Awesome. Cool. Thank you all for attending my talk, Improving UX and Web Three really excited to be talking about this. Holds a special place in my heart as a former front end engineer. So hopefully you can take this and make some really awesome hackathon projects really quickly. About me. I'm Rahat.
00:00:46.950 - 00:01:35.050, Speaker B: I'm the lead developer, relations engineer over at Polygon. So my team are the folks you might see running around to conferences, doing tech talks, hackathon stuff and all that. So like I mentioned before, I've previously been like a front end engineer, solidity engineer overall, just like an indie hacker and Web Three enthusiast. And these are some places you can find me a little bit about Polygon before we start. In case you're not familiar, polygon is leading platform for ethereum scaling and infrastructure development. We provide a bunch of different types of solutions. If you've already kind of been dabbling in Web Three, you might be more familiar with our proof of stake blockchain, which was like our primary solution coming up in the coming months or sooner.
00:01:35.050 - 00:02:33.290, Speaker B: I always have to figure out how to word that without giving too much alpha. We're releasing several more kind of like products we recently talked about, Zke EVM, which will be out very soon. So really excited to be talking more about that in future workshops as well. So kind of like going off of that a lot of different scaling solutions like Polygon as well as others in the space. We talk about adoption and we talk about it through scaling, through higher throughput, through making blockchain interactions and everything more scalable. But there's other aspects of it too, besides just like scaling on top of ETH. Adoption is easier if I, as a user, can use your DAP quickly and easily.
00:02:33.290 - 00:03:14.582, Speaker B: And we're going to break down what that means a little bit throughout the workshop. And we're going to do that through different types of connections and ways that people interact with your app. And the best place to begin is Wallet Connections. This is the point of entry for how a user is going to first interact with your DAP, connect to it, and be able to perform any type of transactions. No matter what kind of DAP you have, there's going to be some Wallet connection feature on it. So this is just a quick code example of like a handle wallet connect function. Nothing too fancy.
00:03:14.582 - 00:04:05.770, Speaker B: So this is just handle wallet connect. It's an async function. In this specific example. This is how you would kind of connect to, let's say, a browser injected wallet like MetaMask. So I'm pulling Ethereum out of the window. If you're a front end engineer and this is your first kind of foray into Web three, you might be thinking, what do you mean pulling the Ethereum object out of the window? So if you have a wallet such as MetaMask in your browser, it automatically injects an Ethereum object into it. And this is what's going to allow you to get access to things like the account that the user has in their MetaMask, connecting to it, starting to perform transactions, et cetera.
00:04:05.770 - 00:05:07.360, Speaker B: So this would be a basic way of grabbing information about the user and getting their address. Here's a quick demo of how that would work in real life. So you just add a connect wallet, hit Connect Wallet, MetaMask pops up, they choose whichever address they want and you're pasting the address onto your screen. In the example that I gave before, I was just console logging it out, but in that demo, I actually put it in some HTML and displayed it onto the page. So it depends on how you use that information and how you want to use it in your UI. Another wallet connect pattern that I see a lot of folks doing is taking this initial function of connecting to your wallet and then let's say you're using React. I'm using an example from React just because I've been a React developer before, popping it inside of like a use effect.
00:05:07.360 - 00:05:47.340, Speaker B: But essentially what's happening here is that this function runs right when this page loads or when this component on this page loads. Right. Another way to think about that, if you want to think about it in more of a framework agnostic way, it's just like some JavaScript that's running as soon as you hit the page, please don't do this. So this is a tweet that I put out, like a while back. This is just a pet peeve of mine. Being asked to connect your wallet as soon as you land on a page is a terrible user experience. I should be able to look around and decide if I actually want to connect to your application first.
00:05:47.340 - 00:07:24.234, Speaker B: And nine times out of ten, unless I know who you are and I specifically know who the developer is of this app, I'm not going to continue using your app, and a lot of people probably won't. And what I really want to kind of drive home with this kind of pattern is what you're essentially doing here is removing the ability for your user or your customer to give consent to actually connect to their wallet. Yes, they can go into MetaMask and reject it, right? But if you don't have any further functionality for connecting again, then how would they know to refresh their app to reconnect? This is a bad user experience on that side because they don't understand what they're connecting to before they connect to it. And you don't want something to just happen on a website as soon as you land on it, right? If you think about it this way, if you just go to a website, music starts playing, a video just starts playing, that is actually something that is sort of punished by Google in your Google search rankings. If you do something like that, it'll actually hurt. I think your SEO score overall, and I would like to really drive it into you that you should view that the same way with Wallet Connect. While it doesn't affect your SEO rankings right now, I hope one day it will so people stop doing it.
00:07:24.234 - 00:08:25.630, Speaker B: But it's really the same concept. You don't want an interaction just happening on a website unless you're the one to actually begin that interaction. So this is more of a philosophical technical thing coming together, right? And the other side of this is it really promotes bad security practices. Because if we're training the customers and users of our applications to just say yes to everything as soon as they land on it to start connecting and using an application, are they really going to go into every single thing and figure out, what did I connect to? Is this like some NFT rug or something like that or whatever? It's just not good security practice. So definitely please remember not to do this. I see this a lot in past hackathons where I've judged projects. I've seen this a lot even in real production applications, and it's not a good user experience overall.
00:08:25.630 - 00:09:08.646, Speaker B: And there are some folks who are going to try to justify this with something called the three click rule. The three click rule states that apparently if someone is on your website and wants to get to one specific thing, some specific type of feature, and use it, if it takes more than three clicks, then they get frustrated and leave. There is no data backing this up whatsoever. I've looked for it. It doesn't exist. So if you do see that justification of the three click rule, even if we applied this rule, not all clicks are created equal. Not all clicks should be considered.
00:09:08.646 - 00:10:09.018, Speaker B: Among this fake rule, as I refer to it, is because if you look at a web two application, the first thing to do before going into the actual app part is signing in with email password, or signing in with Google, or signing of Facebook, something like that, right? No matter what, that's always been the first level of giving consent and connecting to an application. In the case of web three, it is connecting with your wallet, but the concept remains the same. You have to get that consent first. You have to allow the user to choose to connect first. And that does not count among the clicks that it takes to actually traverse through your application that is separate. So we've talked about some of the clicks, some of the initial connecting your wallet, but now we can dive a little bit further and deeper into that side of things. Once you're connected to your wallet, sometimes they're on a different network.
00:10:09.018 - 00:10:51.190, Speaker B: Maybe they were on a separate sort of a separate DAP. They were on another network. Maybe they were on Ethereum Main net or whatever. And maybe your application is built on Polygon network and you need them to switch networks when they actually connect their wallet. So getting your user on the right network is kind of like the next step in making sure that this UX is as fluid as possible. So sometimes when I go into a DAP and I click maybe I'm on the Ethereum Main net, but the DAP itself is on the Polygon Main net. And sometimes the pop up that I get is like, hey, you're on the wrong network.
00:10:51.190 - 00:11:53.562, Speaker B: Without giving me any information on what network I should be on or how I can switch, or what if I don't have the network and I need to add it. A really nice built in way within MetaMask is you have this pop up that can come up that says, hey, this site needs to be on the Polygon Main net. Do you want to switch? How do we get to this experience? You can actually use the MetaMask API documentation. They have some really nice examples on how to use the window Ethereum request methods. You can find this, like I said on that docs, I'll also be sharing these slides out so you don't have to scramble and copy and screenshot this. But here's just like the method for adding an Ethereum chain and then the parameters, which just be like the chain ID, RPC, URLs, and the chain name, et cetera. Once you add this information and make that request, you get this pop up on MetaMask.
00:11:53.562 - 00:12:58.902, Speaker B: And now instead of the user having to figure out, oh, what network should I be on? You're just automatically letting them know, like, hey, we need you to switch. Click here to switch, and you're good to go. So going a little bit further for wallet connections, I showed you one specific kind of like user flow, like a user who has MetaMask, right? But the important thing for you when you're building out your applications is to make sure you're not just focusing on browser wallets, right? So abstractions are really nice. Libraries are really nice. There's a lot of really cool, awesome open source tools that can help you out in this to make it easier so that you don't have to do this gigantic big request function here. So you don't have to write your own handle Wallet Connect function and wrap it in Use Effect or whatever. Some really good abstractions to use that make a lot of that easier is using things like Rainbow Me, the Rainbow Me kit, as well as Wallet Connect.
00:12:58.902 - 00:13:56.098, Speaker B: And I think rainbow me actually has wallet connect baked in. So what that does is it gives you just like this modal and some functions that automatically allow you to connect not only to a browser wallet, but to mobile wallets, hardware wallets, et cetera. And these are great for just like, being as inclusive as possible to different types of users. If your goal is to make sure that your DAP is being used by several types of users, you want to make sure that you have the ability to actually connect to those different types of wallets. So that's where things like Rainbow Dash Me and Wallet Connect will come into really helpful, be really helpful for you. And another really good open source tool that pairs with those are like the Wagme react hooks. I think they actually have in the documentation how you can use Wagme with Wallet Connect to create a nice connect wallet functionality.
00:13:56.098 - 00:14:28.930, Speaker B: And Rainbow Me is also built using both Wagme and Wallet Connect. And again, I just want to drive this point as much as possible. Hopefully I'm very passionate about this point. Let your users choose to connect. Cool. Now let's talk about the next part of just like, the overall user experience for using adapt. And a lot of that is waiting.
00:14:28.930 - 00:16:14.402, Speaker B: If you've ever been to one of my workshops or really any workshop from anyone that has involved doing some type of transaction and waiting for that transaction to be filled, there's sometimes an awkward pause or in my case, I sometimes try to distract you and talk about something else. But it's probably like a very not good distraction. And you can tell that I'm stalling for the transaction to go through. But no matter how fast a blockchain is, no matter how quick we can make it and how much we improve, there's always going to be that little bit of awkward waiting time of like, when is this transaction going to finish? Is it going to finish? Is there going to be an error? What should I do afterwards? Right, I want to talk about implementing what are called optimistic UI patterns. Optimistic UI patterns are things you've probably already seen in different applications in the web two world. So think of it as like I'm on a website, I click some link that goes to another page and that page has to then get some information from some API and it might take some time for that information to come in, right? But instead of making the user wait for that information to come in and then loading the page, we preload the page with some sort of skeleton, some type of loading spinner or feature or something like that. I'm sure you've seen different websites, some examples that off the top of my head that I know.
00:16:14.402 - 00:17:22.454, Speaker B: If you're like an Amex card user, if you click on different things for your and this probably works on several credit card companies where you go in, you go to a page like you're looking for maybe your transactions or whatever, and there's like a skeleton page loading as the data gets filled. I highly recommend doing something like that. You don't have to do something like, so complex as like a skeleton, but just like a little spinner or like a loading animation thing would be cool. There's like free spinners everywhere on the Internet that you can just copy, paste and put in that are free to use. So definitely look at making sure that your user knows that your app is loading something, maybe waiting for something externally, but your app knows that something happened and there's some sort of reaction that you're taking. So let's take a look at one of the ways that I implemented this in one of the very first DApps that I had ever built. So this is a Pokemon battle between a charizard and a Lugia.
00:17:22.454 - 00:18:29.200, Speaker B: So the smart contract that actually powers this is just keeping track of their HP and it has like an attack feature. So what I'm going to do is I'm going to click the Use Flamethrower button, my metamass pops up, I pay some amount of gas, I hit Confirm, and you'll see that now there's an animation of a charizard using Flamethrower on this Lugia. And the reason I'm doing that is because I am waiting in the background for this transaction to actually finish. Right? But I'm letting the user know that, hey, you clicked on Use Flamethrower. Charizard is now using Flamethrower on Lugia, right? Your user actually knows that something is happening, something is going on, and that's the main thing that you want to do. When a user clicks on something, like, maybe it's a Mint NFT function, maybe it's sending some tokens to someone else. Whatever it is, let the user know that something is happening.
00:18:29.200 - 00:19:29.730, Speaker B: And let's dive into that a little bit more in terms of the code for how something like this would be set up. This is just some basic boilerplate code grabbing some contract address, contract API for whatever I'm connecting to. And then this example is specifically using Ethers, the NPM Ethers JS library. So I'm connecting to my Lukia battle contract and then I have an Asynchronous function called Attack. And what I want you to really focus on here is that with Asynchronous functions there's, all of these Await keywords, right? And in between those await keywords is where you're going to be able to implement your most crucial kind of like UX and UI updates. So here I don't really have anything. I'm just like awaiting, I'm attacking and then getting the current HP for each of the Pokemon.
00:19:29.730 - 00:20:30.306, Speaker B: But in this example, what I did was in my UI, I made sure that while we were waiting for the transaction to go through, that the animation of the charizard was starting up, right? So that's going to be how you actually make sure that your user knows what's going on in the background, or at least that something is going on in the background. So the main takeaway from that is just like distractions and updates are your friends. Distractions, like the little charizard animation updates, like letting your user know like, hey, this transaction is being mined. A really good example of this, and this is from uniswap. So I'm on uniswap. I want to change one matic, let's say, for USDC. And you'll see that fetching best price thing was a little loading spinner.
00:20:30.306 - 00:21:08.862, Speaker B: It was waiting for some asynchronous thing to happen, which was just like getting information about what the current price is. And it had the little loading spinner. Now I hit swap and a little pop up comes up that says, we're waiting for a confirmation. We're waiting now for the user to do something. So it gives the user some action that they need to take. So we go into MetaMask, accept everything. You'll see a little pending animation on the top right? And you'll also see that we let the user know, or uniswap let the user know that the transaction was submitted.
00:21:08.862 - 00:21:57.250, Speaker B: They can view this on the explorer. And eventually, again, we let the user know that everything was updated and the matic was swapped for USDC. So again, this comes back to the whole concept of distractions and updates are your friend. Distractions can be spinners, can be little things, just like letting them know, like, hey, this is going through, don't worry about it, and then showing them the results of each action that they take. So in the case of uniswap, it was more just like letting the user know that they need to go and click something in MetaMask. After they've clicked that cool transaction has been submitted, you can check it out here. They gave us the link and then eventually we got that little toaster pop up that showed us that, yes, the swap happened.
00:21:57.250 - 00:22:36.862, Speaker B: Everything was good, right? So the thing with a lot of apps built on in web three is just like, we're not really giving the user enough updates. We're not telling them what's going on in the background. And that is key and crucial to letting the user know that things are happening. Because people have short attention spans. If they click something, nothing is happening. Something could be happening in the background. They just don't know something is happening, right? If they don't know something is happening, maybe they get disinterested and leave your app.
00:22:36.862 - 00:23:34.174, Speaker B: Maybe they start clicking again and who knows how many times they click on some type of transaction. So you've got to make sure that you're giving the users that feedback at every kind of step that you're able to provide that. And just, again, driving this point home of like your distractions and updates. Again, they happen during and after asynchronous function calls now kind of going beyond the front end. What else can we do to make a better user experience? Using polygon to supercharge your DAPs user experience. One thing that I really like pushing a lot for better user experience is something called Gasless Metatransactions. So this is a little poorly done map of how you can implement guest list transactions and we're going to be breaking down each of these individually as well.
00:23:34.174 - 00:24:33.154, Speaker B: But it goes into the whole you sign some transaction and there's an EIP that allows you to go and create like a structured sign data. For this. You send it to something called a relayer, which is just some service where you can preload some amount of funds to essentially pay for the gas for the user. So you sign some transaction, that information is sent to the relayer. The relayer is then able to wrap that request into an actual transaction and send it to the contract. So now you're able to let's say if you want to do, like a free NFT Mint, you're actually able to cover the gas costs for the user. And that creates a really good user experience, especially for people who are brand new to Web Three, so that they can just quickly use your DAP and just possibly just look around and get used to it.
00:24:33.154 - 00:25:38.982, Speaker B: The whole concept of doing something like a 30 day free trial or something like that like that exists in Web Two doesn't quite exist in Web Three. But this is one way you can implement something like that, like a try before you buy type deal. So coming back to EIP 712, which was the first sort of sign transaction thing that I mentioned inside of in the Ethers documentation, a quick way of doing that is with this sign type data method. So from a JavaScript front end you can create the signature and it's just like a JSON object. You put whatever information you want into it and you send it to some Http endpoint provided by a relayer. Relayers can be found through like Openzepland Defender Biconomy Ethereum gas station network and at the end of the day, you're just making a post request to some endpoint that they provide you. And this is something that is really awesome and well implemented by Lens Protocol.
00:25:38.982 - 00:26:43.530, Speaker B: So Lens Protocol allows you to do a lot of their social media kind of stuff like liking, replying and interacting with folks. It all gets stored onto the polygon blockchain, but you don't have to pay any gas for it because they're using something like a relayer in the background so that you don't have to worry about gas, which creates an actual really good user experience for a Web Three social platform. So again, these are just like different things you can do to improve UX. It's not just front end, it's also kind of like the back end layer and different things you can do to make the overall user experience better. Something like Gasless Metatransactions are economically viable on a solution like Polygon. Doing that on Ethereum mainnet will probably get prohibitively expensive, especially if you're trying to pay for gas upfront. And yeah, just thank you again for attending this talk.
00:26:43.530 - 00:27:51.140, Speaker B: Just leaving some of my information up here again, if you want to come find me and if you enjoyed this talk, please let us know. You can tag us on Zero X Polygon devs or tag me on Twitter at rahat codes. Thank you all. I did see just a couple of quick questions. So do you have a library recommended for Svelte? I'm not too familiar with Svelte, but I can definitely take a look at some and drop them in Chat if I find any. Yes, Lens Protocol was something that they enabled casless transactions with while adding a Connect Wallet button to the website, like a home page. How do I know whether the user has already connected to the website without calling Connect Wallet in Use Effect to know if they've already connected to the website? So if you use certain libraries, like Rainbow Kit or like Wagme Hooks, they have built in hooks that allow you to see if a user has already connected before.
00:27:51.140 - 00:28:32.670, Speaker B: So I think generally, I think most people probably won't connect manually, I guess probably through MetaMask. So I think that's probably like an edge case that may not come up too much. But yeah, there are certain functions in those libraries that will help you out with figuring out if there is a connection or not. But yeah, cool. I think that looks like all of the questions. So thank you all and really looking forward to seeing what you all build during this hackathon.
00:28:34.230 - 00:29:00.678, Speaker A: Awesome. Thanks, Rahat, for your time to do this workshop for ETH Online. It was super interesting. It was a side of things that even I haven't seen before, so loved it. And thank you to the rest of you for tuning in. The workshop recording is available on YouTube for you all to reference back to at any point throughout the next month. And if you have any questions, feel free to reach out to Raha or the rest of the Polygon team.
00:29:00.678 - 00:29:14.330, Speaker A: They're also available on the sponsor Polygon Discord channel in the Ethanline Discord server. So yeah, with that being said, I hope everyone has a great rest of your day. Bye.
