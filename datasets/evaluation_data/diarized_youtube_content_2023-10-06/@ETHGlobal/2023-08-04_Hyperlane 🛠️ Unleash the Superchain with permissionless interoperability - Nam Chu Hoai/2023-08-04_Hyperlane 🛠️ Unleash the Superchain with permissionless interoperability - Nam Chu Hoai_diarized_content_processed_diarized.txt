00:00:07.610 - 00:00:18.960, Speaker A: Hello everyone, and welcome to the SuperHack Hyperlane Workshop unleashed in superchain with permissionless interoperability. Joining us today is Nam, who will be taking us through the session. And with that, I'll pass over to Nam to get the session started.
00:00:21.330 - 00:00:43.494, Speaker B: Cool. Thanks, Rory. Yeah, so like Laura said, my name is Nam. I'm one of the founders here at Hyperlin. And yeah, very excited to be participating in Superhank. We've been big fans of Global in general. So this is not your first ifglobal hackathon.
00:00:43.494 - 00:01:39.130, Speaker B: You probably have seen others around. If you will be participating in one of the upcoming ones in either New York or Istanbul, we'll be there as well. But yeah, I think for today, we really like, I've always been enjoying these kind of online hackathons scaling Ethereum last time around. And there's always really cool hackers and projects kind of coming out of these hackathons. So, yeah, looking forward to that for this one. Right? We'll be talking about SuperHack, which is kind of in the theme of the Op stack and the super chain. And so we felt like part from a very, I think generic, maybe kind of like workshop that maybe we would do normally, we would want to focus on how we as hyperlain or how attackers using hyperlain can kind of unleash the super chain with what we call modular or permissionless interoperability.
00:01:39.130 - 00:02:40.234, Speaker B: All right, sounds good. Yeah. So let's start with what is the super chain? This is the genflay we'll talk about. What is the super chain, what is the current state of Op stack interoperability? And I will go into what's hyperlain and why it might be interesting for kind of the super chain and by extension for folks here hacking at SuperHack. And so I hope this is not news, but, you know, kind of who's participating for Time Gear by Optimism Labs has kind of built the Optimism chain and the stack that they're using to kind of deploy that chain. The initial kind of chain is called the Op stack. And I think since the creation of that Op stack, there's been a lot of interesting folks who have kind of used that stack to deploy their own chain.
00:02:40.234 - 00:04:12.638, Speaker B: And so most recently, probably the most noteworthy as well, is Base Coinbases l Two, I think zora PUBLiCUS network like Gitcoin. I think there's a lot of interesting examples of folks kind of deploying their own roll ups for the applications and making certain modifications either technically or culturally, kind of like to basically customize, I guess, the blockchain or the roll up to their needs. And I think superchain is kind of like this concept. I think that Op Labs and various folks using Op stack have been kind of trying to rally around as this kind of vision for how Op stack chains kind of together can make this more cohesive network and ultimately scale Ethereum vision further. And if you're more interested in kind of like what exactly that means and how, let's say the Op Labs folks have been thinking about that. I highly recommend going to their website. But one of the things, obviously, that this kind of vision of this kind of network of chains requires is interoperability between these chains, right? Let's say if you had Gitcoin, if you had Zora on Ethereum, those contracts were able to interact with each other because they were sharing the same VM, right? They were able to make calls to each other, compose with each other.
00:04:12.638 - 00:05:55.450, Speaker B: And that is something that now that these are technically different blockchains is something that you need an interoperability protocol to kind of allow for messages to be sent between these applications. And so I will quickly go through the current state of OpSec and Operability. Basically, how does Op Stack communicate with, let's say, the l one? And to be honest, the current state of Op second operability is not super great, right? So, one, you can really only use the contracts that dope SEC has primarily the cross domain messengers to send the messages between the L One, which is obviously Ethereum, as well as the L2, the chain that you deploy either optimism base. There's no way really, if you have an application on base on Zora for those connect to, you have to technically kind of send it back to Ethereum, wait seven days, and then send the message back up to the other L2. And I Think The Op labs folks are kind of on the Docs are recognizing that to ultimately Extend The Super chain revision, there Needs to be this ability to Do Cross chain Transactions that are faster than that Kind Of seven day period, but also Allow for, again, not Just Like, faster to l one, but Also Faster to Other L2. S. I think the second thing that we saw last week is that there's actually no out of the box UI for the standard bridge for Op Stack deployers.
00:05:55.450 - 00:07:09.122, Speaker B: Let's say if you deploy a new Op Stack chain, you actually have to figure out how to build a UI that kind of allows users to, let's say, deposit USDC on the L One standard bridge contract to ultimately receive USTC on L2. And then the other way around, and then even there was the UX is kind of rough and we'll go into exactly why that is the case. So again from l one to l two. It's actually pretty simple. On the right side you can see the diagram. Basically the user calls the bridge USC 20 contract on the L One standard bridge, which ultimately calls the cross domain messenger on L One, which is the send message function that ends up calling the optimism portal with the deposit transaction function and that emits a deposit transaction event. And then because roll up is literally rolling up over L One state, the rollout will ultimately kind of have a virtual deposit transaction transaction on optimism or on the l two, which calls relay message across the main messenger, which itself will basically call finalized bridge ERC 20 on the l two standard bridge.
00:07:09.122 - 00:08:09.042, Speaker B: And that's how basically you get kind of this synthetic USDC, let's say, on optimism, because you deposited the USDC right on ethereum as collateral. And so this actually is pretty nice, right. The user initiates only single transaction on the origin chain and the message is automatically processed kind of like as part of the rolling up over l one state. And so you have kind of like full security, right? Like there's no kind of additional trust assumptions beyond just the normal roll up trust assumptions that you have. However, sending from l two back to l one looks a lot more complicated, right? So today what you have to do is as a user, you call the Bridge USC. 20 contract sorry, l two standard bridge contract and the Bridge USC. 20 function that will with the synthetic USDC that you have, right, that will basically burn the USDC on l two.
00:08:09.042 - 00:09:33.950, Speaker B: It will send a message to the cross domain manager which itself will kind of call initiate withdrawal on the l two due to l one message passenger. And that basically writes this particular message to storage on optimism l two. And so at some point later, like, I think the doc say it could be up to an hour later, the proposer actually proposes the state route of that l two onto the l two output Oracle contract, l one. And that's right where anybody depending on the configuration of the contracts, somebody could basically contest and submit a fraud proof. Effectively, like, hey, the statement wasn't actually the case, but let's kind of just assume optimistic case a proposer proposes a valid state route, then we as a user, we can make a second transaction called proof withdrawal on the optimism portal. And for that, we basically check the merkel proof on the we attach a merkel proof to that transaction which basically proves our particular message in the storage slot on optimism. And optimism portal is basically able to check that verbal proves against the l two output Oracle.
00:09:33.950 - 00:11:27.640, Speaker B: And once that is the case, the optimism portal will basically kind of have this pending withdrawal, right? We'll rate the famous seven day period to make sure that there were indeed no fraud proof submitted in that time period. And then after that, the user has to initiate this third transaction to ultimately finalize the withdrawal, right? And that will ultimately call relay message on the l one cross domain messenger, which will call finalized bridge USC 20 on the l one standard bridge. And that's what releases the USDC to the user, right? And so when you said it's a little rough of an experience because there are three transactions over a period of seven days that a user has to manually submit. Developers have to make UIs, have to create tooling using the SDK that is provided to allow users even actually to do that, it relies on the proposer, usually a single EUA to actually propose these state routes. And so there's kind of like life misconceptions on that. And then probably the biggest thing obviously still is the fact that you have to wait this seven day challenge period for Tokens, but ultimately any message to kind of make the way from L2 to L One. And so, yeah, so that's I think a pretty rough experience and I think the reason for why many users never actually end up using the kind of like canonical bridge, right, but actually use third party systems like things like pop across, connect to kind of actually bridge, let's say around.
00:11:27.640 - 00:12:54.686, Speaker B: And so we think that the Hannah are great and for this and many other reasons worked on Hyperlain, which is basically a more generic interoperability protocol allowing any chain to be connected to any other chain. And so I will quickly go over what the kind of flow looks like in Hyperlink and ultimately how that might be beneficial to the superchain and how you hackers here at SuperHack can kind of improve Denverability of the super chain ultimately. So the basic mesh flow looks actually fairly similar, right? So basically, we have these contracts called mailboxes on every chain that Hyperlain supports, that is both EVM chains, but can also be non EVM chains. And so there's a bunch of non EVM implementations that are about to go live. But for now, I think I'll just kind of instruct for instructional purposes, just kind of assume the EVM. But basically we have mailbox contracts on both chains, right, and as a sender. And like, for example, the l one standard bridge in the kind of op stack token bridge context can just call the dispatch function with basic destination, which is just like a chain ID, basically, of the destination chain, a recipient, the address of the address of the recipient on the destination chain.
00:12:54.686 - 00:14:43.320, Speaker B: Right? So in that case it would be, let's say the L2 standard bridge contract and then the body which basically just kind of signifies hey, mint this synthetic or release this collateral token right? There's arbitrary bytes depending on the application. And yeah, basically we have kind of this system that we go and more into, it called Interchange Security modules where those are the contracts on the destination chain which the recipient can specify to ultimately say like hey, under what circumstances do I accept messages? Under what circumstances do I believe that this sender has actually sent a message? And with that, basically you can relay that message to the mailbox and the message recipient will basically be called with this kind of handle function and then they can again do whatever they need to do with that. And so war browse are kind of like hyperlains. Take on again the classic block and mint token bridge similar to the standard bridge in the Op stack where there's basically the collateral contract on, let's say, Ethereum which accepts the collateral that sends a basically like mint synthetic message via the mailbox to the hip ERC 20 contract on, let's say, any other chain. Let's say, in this case, your Op Stack chain. And basically that contract can again specify what security model it wants to use. And if it kind of accepts, which is what we call the ism the transaction submitted by the relayer is able to basically process the message to this contract or mint the synthetic token and then the same thing obviously applies vice versa.
00:14:43.320 - 00:17:04.494, Speaker B: And so the nice thing about War Browse is, for example, that we do have a out of the box UI, right? So let's say if you, instead of using the standard bridge, use War Browse to deploy a token bridge between Ethereum and optimism, you aren't able to use other security mechanisms for kind of the withdrawal from optimism, right? So you could, for example, choose to either go through the canonical bridge, but you could also choose to use a validator based system or use Staking or eventually there will be maybe better validation mechanism like Light clients available. And so the key piece here is that the warp brow but these token bridge contracts are sovereign to the issuer and so you can actually add custom functionality onto the token contracts themselves to facilitate both things like securities and features. One of the things that, for example, we recently had been attributable work on is the ability for a token to be votable on both L One and L2 so that you can vote on L2 for a proposal on L One. So there's a lot of kind of cool extensions basically of War Browse that you can do and that's another offering that Hyperlate has that kind of brings us to how can hyperlaid improve super chain interrupt. And so actually there was a contribution last week by another contributor who kind of basically add a hyperlain as a pre deployed contract onto the Op stack, right? So basically, if you go to this repo and you deploy the Op stack using this fork, you automatically have the Hype built in mailbox contracts on both L One and L2. And it modified the standard bridge to basically allow for certain configurable tokens to basically be withdrawn with a different mechanism other than the kind of like l Two output Oracle and therefore the Seven day window. And because of that, because it uses kind of the hyperlain mailbox system, it also benefits from this kind of relayer system where a user can just pay a relayer on the origin chain for this kind of prosciutto investigation chain.
00:17:04.494 - 00:19:08.860, Speaker B: And so ultimately the user experience is that you only have to sign for withdrawals. For example, you only have to sign a single transaction optimism and you just pay extra amount of ETH so that you no longer have to submit these transactions on Ethereum. And so it ultimately looks a bit like this on the standard bridge, instead of it calling the L2 across the main messenger it just calls the dispatch function depending on the configuration. But let's say it calls the dispatch function on the mailbox and then the relayer will basically kind of like relay that message to the mailbox depending on the Ism used by that particular token, the L One standard bridge will kind of get the handle call from the mailbox and then release the token to the user, right? And so that's where the Ism piece comes in because part of hyperlain's kind of ethos is basically there's different security modules for different trade offs, right? So again, maybe for yeah, it's like the most secure token on the roller and so therefore you want this kind of very heavy system that makes sure that there's prop pools available. You have to wait seven days but maybe if you are like a game and you want to take a certain different trade off you are able to specify a different Ism that is say let's say a multi state, right? Like it could be like if you're on like maybe like Zora has kind of their validators that could be run and that would allow developers or token issuers to basically have withdrawals that are faster, right, that don't have to wait seven days. Obviously, again, the security is different but there's no kind of a single answer that we can think of. And so that's why we want to support kind of like this generic modular interface to allow developers to pick whatever trade off they want to choose.
00:19:08.860 - 00:20:44.650, Speaker B: You can actually also wrap the kind of optimism portal l Two output Oracle into an Ism itself and then again allow different tokens to kind of have different security mechanisms under the kind of same interface. What you could also do is you could actually move the once you have this kind of like mailbox and modular interface you could actually move the cannon fault prover as Ism, right? And so again, therefore allow tokens to kind of selectively move into different proving mechanisms. We also basically have all the contracts basically set up to support staking and permissionless lashing. So you could imagine, folks basically validators, let's say in this kind of multi SIG ism basically have an economic stake and if they ever lie about it, they would actually get slashed. And there's a cool kind of construction where actually because generally in hyperlain the state can only be slashed on the origin chain. But because there is this kind of very secure canonical bridge that doesn't exist from L2 to L One you can actually communicate the slashing condition over that canonical bridge to L One and have the stake live on. L1, which actually means that for restaking, for something like Eigen layer, you could have validators validate messages from multiple roll ups with kind of the same economic stake and therefore get higher economic efficiency.
00:20:44.650 - 00:22:09.106, Speaker B: And then last but certainly not least, Isms are composable and so they allow you to basically aggregate multiple verification mechanisms, right, where you could basically say like, hey, I want something super secure. So I actually want both the canonical bridge but also this set of validators to agree on a message for me to consider it secure. And so these are kind of these what we call security Legos that developers can use to kind of ultimately adjust the trade off that they want to choose when it comes to sending messages between different chains, right? And in this particular case, let's say from L two to L1. And so, yeah, so there's a lot of really cool, I think, opportunities here because I think the Op sect interop has been so focused on the kind of, like, classic canonical bridge of the seven day fraud window that there's a lot of opportunity for you hackers here, SuperHack, to kind of improve the interoperability of this Op stack. Right. We very much agree with, again, I think the super chain kind of proponents that this is the world we're going to be living in, right? There's going to be all these super chain chains that use the Op stack to deploy kind of their own roll ups. But for that we just need better interoperability between all of these roll ups.
00:22:09.106 - 00:23:44.334, Speaker B: And so here are the few ideas that I think we want to share with you guys. Certainly not kind of like limited to this. But one thing that you can do is you can support the high Blaine Ism interface not just at the standard bridge level but even lower across the main messenger or even optimism portal level so that you kind of have more like op stack native, I guess the opsect native interface but have this kind of modular security via hybrid. Like I mentioned, you can kind of implement just kind of slashing where you have fast withdrawals via validators, let's say on a multi stick Ism, but still have economic security attached to them because their stake will be slashed via the kind of slower security mechanism of the canonical bridge. Other things you could do is, I think if you've seen uniswap X, right, the kind of like uniswap take on cowswap, one inch fusion, they kind of explicitly talk about this opportunity for doing swaps cross chain, in our case cross roll ups. And so being able to basically have these settlement oracles, you can implement them with hyperlain and therefore support kind of like native cross chain swaps. Even if you don't want to do kind of let's say like uniswap X style swaps, you can even still support moving tokens from one roll up to the other.
00:23:44.334 - 00:25:03.818, Speaker B: So right now, again, the standard bridges are between the L1 and a single L two. But let's say if you moved, like, USDC into base, you can't directly move the USDC over to Zora. And so one thing you could do is you could modify the standard bridge contract on l One to basically be able to kind of, let's say, collectively collateralizetc on both Base and USTC on base and Zora. And so that would allow users to actually indeed send USTC directly between roll ups. And so that's, I think, another thing that you could could because there's no, I guess, default UI, you could use the warp UI, the template UI that we have for our warp routes, and you could just modify them for the standard bridge so that folks can use that if they didn't want to kind of deploy the warp brow contracts themselves. And then actually, one really cool thing as well that we have is what we call dynamic withdrawals, right? So let's say right now, I just kind of frame it as for a single token, you could just use, let's say, validator based security to do withdrawals. But actually what's really cool is you could also do something along the lines of like, oh, withdrawals of, let's say, 100 USDC or less, which are basically smaller retail users.
00:25:03.818 - 00:26:07.858, Speaker B: We actually support using the validator based mechanism. But for withdrawals larger than 100 USDC, we actually do require folks to kind of go over this kind of slower path, right? And so, again, that allows kind of more, I think, just better trade offs for people to actually use these bridges versus kind of relying on just like, I think, third party solutions to kind of support, say, token bridging. And then the last two, I got kind of maybe more like application things. For example, you could bridge Zora NFTs to base with War browse that we recently announced our NFT support on the War browse. So that should be pretty easily done. You can just go on Docs and deploy these War browse. And similarly, you can kind of take inspiration from, I think, two weeks ago when we announced this kind of tally integration, where you allowed to use warp tokens on the L2 to vote for proposals and L One.
00:26:07.858 - 00:26:39.226, Speaker B: And so you can do something similar, let's say, between PGN and optimism, I think that's it. I think I'm surprisingly good on time. If you want to learn more, read our Docs docs at hybrid XYZ, join our Discord, follow us on Twitter. Can follow me individually on Twitter under at non broad or add me on Telegram under the same handle. You can email me. You be like, we are going to be on, obviously the global Discord as well. But yeah.
00:26:39.226 - 00:27:19.442, Speaker B: So please do not hesitate to reach out. We are very active. We pride ourselves to have great response times on our Discord as well as in person. If you kind of come to Istanbul the remainder of the year, and, yeah, I think with the remaining time, I would love to take questions and go from there. All right, so first question I see. Sombulio said, can we transfer tokens to Zora or Girly testnet and how? Yes. So like I mentioned, you can basically obviously use the default standard bridge contracts and then you can subjects to this kind of seven day window.
00:27:19.442 - 00:28:18.010, Speaker B: Or what you can do is you can deploy hyperlain basically to Zora, because hyperlain is provisionalist, which I guess I haven't gone into. But you can deploy hyperlain to Zora and then deploy what we call the war brow between Zora and Girly. And that kind of allows you to have basically a token bridge that kind of isn't subject to the seven day window. And so for that, as I mentioned, I will link you to the relevant docs pages. Give me 1 second to see her and then deploying on warp routes is here. And then Nicholas asked in this, can you explain what included in the body parameter? Can we pass the function? You want to conduct destination contracts. So at the base layer let me actually back to Figma.
00:28:18.010 - 00:29:54.090, Speaker B: Basically at the base layer right there is just kind of the arbitrary method passing. And so you as the sender and therefore receiver, have total freedom as to what do you want to pass in the body parameter, right? And so what you could do, for example, if you want to call something on a destination chain, you could just write in the body basically abi encode like your function call, right? And then as the recipient, you basically receive that body. You kind of like parse that abi encoded a function call and then the message recipient on the destination chain makes the call to kind of your desired destination chain contract. So that's kind of like one way to do remote function calls, right? I think if you are kind of on the existing chains that we have deployed on, we have API called interchange accounts, like the Accounts API. And that actually does it automatically for you, right? So you basically just specify again a call and a struct. Let me see if I can actually screen share that right here. So basically here you can call kind of call remote function and specify a bunch of calls.
00:29:54.090 - 00:30:24.900, Speaker B: And then actually the kind of hyperlink contracts will create you a proxy account on the destination chain which will make those calls on behalf of your sender contract. And so that's another way of kind of like doing remote function calls on this APJ. So I hope that answered those two questions. I don't see any more questions that folks have. Yeah, if there's any more questions, happy to stick around and answer them.
00:30:26.870 - 00:31:01.874, Speaker A: Yeah, if you want to just go ahead and take yourself off mute and ask questions, feel free to do so. And yeah, if there are no more questions, thank you, nam for the great workshop and presentation and thank you everybody else for attending. So yeah, we've got a few more workshops later today, but, yeah, hopefully everybody's super hack is starting off to a great start, so cheers. Thank you all.
00:31:02.072 - 00:31:05.950, Speaker B: Thanks, Cord. Bye.
