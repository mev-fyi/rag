00:00:00.090 - 00:00:27.030, Speaker A: Today's workshop with superfluid. We have Patrick and Francesco with us, who will walk you through DeFi surfing lesson money streaming. So I will let them take the floor in a second. Please, anyone who has questions, post them in the chat. And if you want to keep this conversation going afterward, join the Discord Channel sponsor. Are superfluid in our event.
00:00:27.100 - 00:00:27.762, Speaker B: Discord.
00:00:27.906 - 00:00:32.038, Speaker A: All right, without further ado, Francesco, I'd like to introduce yourself.
00:00:32.204 - 00:01:04.366, Speaker C: All right. Hi, everyone. Super cool to be here with all of you. I'm usually on the other side of hackathon, so it's always exciting to be on this side. Bit envious of you, but it is what it is. So I'm Francesco, I'm one of the founders of Superfluid, and today here with Patrick, my colleague, we're going to tell you a bit about what we do. But the main point here is to make you understand what you can do, right? Because the most important thing at a hackathon is building, and we want to see what you can do with our technology.
00:01:04.366 - 00:01:50.666, Speaker C: So I'll give you a brief intro on what Superfluid is, and then I'll hand the mic to Patrick, who will show you how to use it. So here we go. So Superfluid superfluid is a protocol for digital native programmable cash flows. This is very important because so far, there's never been a way to digitally represent a cash flow. Now, cash flows were always a series of transactions over time, but they were disjointed, right? You got a payment now, you got a payment in the future, and then afterwards you would piece them together and say, okay, this was a cash flow, right? But that makes it very hard to program around. So what we did at Superfluid was trying to improve that from the ground up. So we built digitally native cash flows.
00:01:50.666 - 00:02:56.830, Speaker C: So why we're doing this is because we think digital money is broken. Now, obviously, we use it every day. It works, right? We all use money, but the fact that we've ported an outdated system without upgrading it is what it's this mistake we always do with online businesses, right? Like, if you think of Netflix, when they started, it was Blockbuster, but with a website, they did exactly the same thing, but they had a website. So it's obvious that when you start using the Internet, you just kind of copy things, but then when you start using the medium to its full extent is when you go kind of next level. And we think while obviously the blockchain is a great way to move value on the Internet, we still haven't seen Money 2.0 because services are flowing in real time, right? When you sign up for service online, you start using it in a continuous way, right? You sign up to Netflix, you get access until you kind of sign off, but you still pay once in a month, right? There's this disconnect between how you pay and how you use the service. And that is only there because our payment systems are so antiquated.
00:02:56.830 - 00:03:47.726, Speaker C: So what we want to do at Superfluid is build the next generation of money. So we're rebuilding money from scratch, improving on the token standards. We have to create a more expressive money layer, a money layer that can express cash flows on chain as a data structure, enabling developers like yourselves to use those cash flows into their applications in a way that wasn't possible before. And we do this through perpetual money streams. So money streaming is this concept of transferring money over time, so you have to throw away transactions. Don't think of money moving as lump sums, but instead think of money moving fluidly, right? So every second, a tiny bit of money is moving from one account to another. Now, the way this happens in Superfluid is without gas and without intermediate transactions.
00:03:47.726 - 00:04:50.402, Speaker C: So as a user, you open a stream with one on chain transaction and after this, money will keep flowing until you stop it or run out of money. It literally flows forever with no gas, right? So this is really powerful if you use it properly and you can use it for a lot of different things. But the really cool thing is it ties service provision and value transfer directly, right? Every second of value that's transferred to you, you can provide services and vice versa, right? So every second of a service you use, you can pay for. And this is very important, because if you don't have delays, you have no on payment risk. And obviously, as crypto, we can do all of this with no intermediaries and we can embed logic into it, creating even more interesting applications. Now, the way Superfluid works, we basically store a lot of data on chain, on kind of how the money should be transferred over time. We use the system's clock, so the blockchain's clock to tick forward the balances, and the balances are updated on the fly, because they're basically calculated at every block by the blockchain.
00:04:50.402 - 00:05:20.322, Speaker C: But this doesn't require transactions, right? We only make transactions when we change the state. So when we open a flow, when we update it, or when we close the flow, then we have to make a transaction, but otherwise the money will flow with no transactions. And that's very important because it gives users a very good experience. They only do one transaction and money flows forever. Now, the way Superfluid is built, we use a concept called Super Tokens. Super Tokens are, ERC, 20 tokens. They're compatible, but they're different, they're much better, they can do more stuff.
00:05:20.322 - 00:05:56.714, Speaker C: And you can make any token a Super Token, by upgrading it, basically wrapping it like wrapped ether. You can also create your own tokens using the Super Token standard directly. In this case, you never have to wrap and unwrap. We also have a concept called the agreement library, but that's a bit deeper. So go look for it in our docs. Now, when we say Superfluid is programmable cash flows, what it means is you can build applications which react to cash flows. So if I send a stream of money to what we call a super app, this super app will be able to react to that stream.
00:05:56.714 - 00:06:22.258, Speaker C: So imagine I start sending you money and your reaction is to send me a token back, right? And what we've just created is a streaming exchange, which is one of our bounties for this hackathon. So this kind of logic is possible with Superfluid, but it requires a bit of a shift in mindset. And the reason I say that is because we're used to transactions, right? We're used to an instantaneous transfer. So I send you money. Now you have it. That's it. Now, cash flows have a lifecycle.
00:06:22.258 - 00:06:51.982, Speaker C: You start a cash flow, you can update it, you can close it. And because of this, we need to build our applications with real time mentality, right? As long as the user is paying, I have to do things. When the user stops paying, I have to do other things. Right? So, bit of a shift in mentality, but it's extremely powerful. Now, super apps, you can build Superfluid in two different ways. Use our JavaScript SDK, which Patrick is going to show you, or use the Superapp framework. Now, we're going to do another call with that in our discord next week.
00:06:51.982 - 00:07:10.070, Speaker C: So if you want to work with Superapps, come join us there. And we'll have another workshop. So if you're not a dev, but you still want to kind of wrap your head around this, go to our dashboard, and there you'll be able to just open streams. We support all the testnets. We're on XDI. We're on Matic. So just go crazy, try it out.
00:07:10.070 - 00:07:21.500, Speaker C: And if you have any questions, go to our discord and we can help you there. Now I'll leave the floor to Patrick, who will drive you through how to actually use Superfluid in your app.
00:07:22.590 - 00:07:28.282, Speaker B: Fran, while I'm doing my presentation, do you want to maybe pull up the bounties so we can rattle those off real quick?
00:07:28.336 - 00:07:56.310, Speaker C: Yeah. So for this hackathon, we have $10,000 in prizes. Our top prize is $2,500 for whoever can build a really good UX UI for a checkout experience. Now, Superfluid are perpetual streams, right? So they're perfect for paying for services. The example I was using before, subscribing to Netflix, use it every second. You should pay for it every second. And for that, we need a really good checkout.
00:07:56.310 - 00:08:21.562, Speaker C: We then have free bounties that are $1,500 each. And these are for a streaming exchange for a way to stream money into a savings account. And in this one, there's actually a joint bounty with staked out. So check that out. It's extra $1,000 if you use stakedao and Superfluid. And the third bounty is for whoever uses the ERC. Seven seven.
00:08:21.562 - 00:08:59.286, Speaker C: Callbacks this is also a functionality that's built into our tokens. And we want people to start appreciating this more because it gets rid of token approvals. Now, if you've ever used Uniswap or other apps on Mainnet, you know that approving a token every time is expensive, it's annoying, and ultimately it's unnecessary. You'll find out how by checking out Superfluid. We also have $3,000 in an open bounty pool. So anyone using Superfluid, even if your hack doesn't kind of fit into these categories, you still get a piece of that action. So Pat, go for it.
00:08:59.468 - 00:09:44.120, Speaker B: All right, so now that we're all jazzed about Superfluid, we know what we can do. Let's talk about how we're going to do it. So this is the surf lesson of the day, is we're going to learn how to ride the Superfluid wave. So the first, if you want to take one thing away from this little workshop here, is that I want you to take a look at this line here, alice Flow. We're passing Bob's address and we're passing some number. So in essence, what this is doing is in one line we are creating a flow of tokens from Alice to Bob at a specific flow rate. And that's pretty much it.
00:09:44.120 - 00:10:37.542, Speaker B: That's the gist of what we'll be learning today. And let's dive in. So we kind of package up all the things that you need in a JavaScript SDK. And you can read the docs on this if you want to learn more. Essentially it's just a matter of installing a couple of dependencies depending if you're using ethers JS or web3 JS and then calling the initialize function on the SDK, which is just going to fetch some contracts addresses from a resolver and then it's going to load them up so that you're not having to do any of that stuff. And you can jump right into creating new streams. The docs, of course, are here if you need it.
00:10:37.542 - 00:11:23.414, Speaker B: And once you've set up the SDK, now we can figure out which token we want to stream to somebody by going to the token list and getting the address. And then we create a user object so Carol equals SF user and we provide some details about Carol, such as her wallet address and the token that we want to be streaming. And then we call that function that you saw earlier, carol flow. And we provide the arguments there. So who are we flowing to? Who's the recipient? We provide their address and then we provide a flow rate. And so the flow rate you're seeing here is 1000 tokens per month. And there's a lot of decimals and calculations and stuff that you're going to have to do.
00:11:23.414 - 00:11:59.486, Speaker B: So let's figure out how we can calculate flow rates. I put together this helpful little tool here. And by the way, the presentation is fully open source. You can click the link, we'll put it in the description of the video you can click the link and load it up and play with the code and edit it. You can copy the code into your application directly. Some of these will be react components that you can just grab. So for this example here, what we're going to do is first we're going to set some base values.
00:11:59.486 - 00:12:35.102, Speaker B: So we're going to calculate how much time is in a certain period. So in 1 minute we have 60 seconds. Everything is in base seconds. Here something to keep in mind. We're always dealing with seconds because that's like Fran was saying, that's the clock for the blockchain's internal clock is in seconds. So in 1 minute we have 60 seconds. In 1 hour, we have 60 of those one minutes and then 24 for a day and 30 for a month.
00:12:35.102 - 00:13:19.030, Speaker B: And so once we establish those now when a user goes maybe to your DAP and wants to say, hey, I want to flow one token per hour, well, you're going to need these constants here to calculate what the flow rate should be. And so in order to calculate the flow rate, all we do is we take one token and divide that by the period that we're looking at. So if it's 1 /hour, we do one e 18 divided by 1 hour. And that's going to give us the flow rate in tokens. Now you might be saying, what's this one? E 18. So this is one with 18 decimals. And that's standard for most tokens to have 18 decimals.
00:13:19.030 - 00:14:01.370, Speaker B: And it's something that you might need to pay attention to when you're getting started. It might be easy to say, okay, one is one token, but it's not. It's actually one with 18 decimals. And I put a link in the bottom here. Make sure to pay attention to units when you're working in Solidity or in JavaScript and you're calling functions on this library, there's a link to the docs there. So if we run this, we can get a flow rate that we'll use when we call the SDK. So for instance, one token per hour is two seven, seven, this really long number.
00:14:01.370 - 00:14:37.858, Speaker B: And one token per month is also this really a long number. And that is our flow rate in seconds adjusted for 18 decimals, which we call units of way. So don't get too hung up. This is a little confusing right now. Just remember that you got to pay attention to units when you're using tokens, okay? So now we know how to create a flow. We know how to calculate the flow rate. So Alice started flowing, right? And now we want to see what's happening with the flows.
00:14:37.858 - 00:15:15.810, Speaker B: So now it's time to fetch some data back. So we wrote a transaction on chain, and now we want to get something back about Alice's account or maybe about someone else's account. We're going to use a really nice query service called the graph for this. And with the graph. We can query things like account details, different flows that are opened, events on our super tokens and transactions. There's a link here to the playground if you want to go poke around and start writing queries. And there's plenty of docs and resources in the link here.
00:15:15.810 - 00:15:57.082, Speaker B: Now don't be scared off. If you're not familiar with GraphQL you can pick it up pretty quickly, especially with the examples that I'm providing. But essentially you're just going to define a query in your app and then you're going to call, make a post request. So you can use Axios, you can use Fetch, you can use any library. There's also Apollo GraphQL which is specifically for that, but you don't need that. You can take this example here and copy it and run it and it'll work just fine. The only thing you need to pay attention to, maybe that might trip you up, is how to pass arguments.
00:15:57.082 - 00:17:02.782, Speaker B: So in this example we're asking for an account and the arguments that we're providing are give me an account that has an ID of this value and that's the account address, that's the wallet address for the account that we want. So that's how you pass an argument to a query. And then inside the body of this request we are just passing the structure of the data that we want. So we want to get all the flows owned by this account. And the specific elements of that we want are the flow rate which we talked about earlier, the sum, which is how much tokens have been flowed over time, the last time it was updated and then some details about the specific token. So this example here is in a react component which is in the presentation that you can just copy and that's in componentgraphquery JS. And so all this is doing here is taking that query that you just saw and putting it into a table.
00:17:02.782 - 00:17:27.334, Speaker B: So we see for this account, for Alice's account, she started a flow rate. Here's the flow rate, that's one token per hour. If you're familiar, the last update here is a timestamp and the sum is zero. That's a little interesting. We'll come back to that and the token details. We have the ID, which is the address of the token and the symbol. So this is EPAC.
00:17:27.334 - 00:18:22.720, Speaker B: So this is the super token version of E. So at this time and you can go into your console and your browser and convert this to human readable time if you want. At that time Alice started flowing tokens. At this rate she started flowing ETHX. And so you might say, okay, well let's say that was 3 hours ago or something, right? Why is the sum zero? Well, the sum zero is because what is actually written on chain right now does not account for the time since the last time she updated. The balance is moving. So the Ethex is flowing right? But because we're not submitting transactions like every single block to update something.
00:18:22.720 - 00:19:18.190, Speaker B: The value, it appears as if it's zero in this query that we made. And we need to do some calculations to account for the difference. Right? So she started streaming 3 hours ago and she hasn't submitted another transaction since then. So what's on Chain, you have to do a little bit of extra calculations. Now if the recipient wanted to go and take those tokens, they can totally do that and do whatever they want with it that would submit a transaction and write it and then this value would get updated, right? But this is just something to keep in mind that what's on Chain is only the last action that somebody took. So in order to calculate the actual sum of tokens flowed in 3 hours, we need to do a little bit of extra calculation. So on line seven, here is the actual calculation.
00:19:18.190 - 00:19:54.540, Speaker B: We're just taking the existing sum from the query that we got earlier, which was zero. And then we are adding to that the difference in time. So now minus the last update, this is basically the difference between now and the last time the transaction was submitted times the flow rate. So if now is now, right, 3 hours ago is a new date. 3 hours ago, we're going to set last update time equal to that. We have the flow rate from the query. We have everything we need.
00:19:54.540 - 00:20:50.178, Speaker B: We just need to multiply the flow rate tokens per second times the amount of time that has passed. And if we do that, then we will get about three tokens and you might say, okay, why is there a little bit of precision loss here? Well, there's a number of reasons why, but for the most part, if this is dollars or something, we don't really care when it gets down to that number for your UI, it's not that important what's on Chain is going to be correct. You don't need to worry about that. But when it comes to making your front end and showing this data for users at this point, don't worry about a little bit of precision loss. You can always make improvements later. So once you start working with calculating flow rates and stuff, like I said in a previous slide, units are important. Don't forget units.
00:20:50.178 - 00:21:17.410, Speaker B: And so you might want to start using a big number library. And I would recommend Ethersprojectunits. Or you can use BN JS. Those are two good libraries to use and that's going to help you convert between 18 decimals, et cetera. Okay, so now for the final boss. So streams are alive. You have to remember this when you're presenting this information to your users.
00:21:17.410 - 00:21:59.026, Speaker B: These aren't fixed transactions. It's not $10, $10. It's like $10 per second per hour, right? It's alive, it's growing, it's moving. And so I've got an example here and the react component is also in the presentation that you can grab. Basically if you just calculate the, the increment over 2 seconds and then create a timeout a timer that updates the react component every 2 seconds, then you can make a nice little UI County here. And here's a couple examples. So things to keep in mind here we have this really long number.
00:21:59.026 - 00:22:29.740, Speaker B: Do people care about all these extra digits? Probably not. So let's trim that down. Let's go down to four digits. And then we're also missing some commas over here, so let's add the commas. Okay, good. We've got a nice formatted number and then we also got a nice animation there that's making the transition a little bit smoother, makes it feel more friendly of an application. So this component, like I said, is available for you to just copy and drop right into your application.
00:22:29.740 - 00:23:15.270, Speaker B: Okay, so your adventure is awaiting. We talked about Super Tokens, we talked about streams, how we can move tokens over time. Two other features that I didn't dive into today, one is ERC seven Seven. And like Fran said, there's a bounty specifically on using that feature which allows tokens to react to certain events. So if you send somebody tokens, then the recipient logic can be triggered and all this magical stuff can side effects can happen using Callbacks. And so that's ERC seven seven. And then if you ever wanted to execute 100 transactions at a time, you can use the batch call feature.
00:23:15.270 - 00:23:56.200, Speaker B: And all of these features are native to Super Tokens right out of the box. So, really looking forward to see what you guys are doing with Super Tokens. And then if you want to bundle all that up and you're feeling ambitious, dive into super apps where you can automate some of this stuff and code in a lot of business logic. So feel free to reach out to us on Discord and check out Docs in the example section if you need help. Yes, it's time to take some questions. Fran, are there any that you've seen so far?
00:24:02.080 - 00:24:42.576, Speaker C: Yeah, so there seems to be a bit of maybe something I should have cleared up a tiny bit better in my pitch. So just wanted to make this clear. A user can have as many streams as they want, both incoming and outgoing at the same time from the same account. So if you're a business, for example, you're accepting subscriptions, you could have hundreds of users sending subscriptions into your account. Now as the receiver, you don't have to make any transactions to receive that money. It is automatically consolidated into your balance and it's yours to spend. There's no delays, you don't have to do any actions.
00:24:42.576 - 00:25:03.936, Speaker C: It's just there. And actually it's really cool because you can also stream it out. So if you are receiving a stream of money, you can also stream money out and you could potentially have an account with no balance, right? Zero balance. But with $100,000 coming in and $100,000 going out every second.
00:25:04.118 - 00:25:06.450, Speaker B: Just make sure you save for retirement, though.
00:25:06.920 - 00:25:48.976, Speaker C: Yeah, absolutely. But that's possible, right? So you don't have to do anything as a user. And when Pat was showing the streams, the sum that you see there is stream specific, so that is not necessarily related to a user's balance. That is just to calculate how much that specific stream has moved so far. Check a user's balance. What you would want to do is basically check you either just query the blockchain and say, how much is his balance? Or you want to sum all their streams, sum all their transactions, and then you can calculate it yourself. So there's two different ways of doing that.
00:25:48.976 - 00:26:01.620, Speaker C: But this was more about specifically, Alice is sending money to Bob. How much money has Alice sent to Bob so far? Right, so the sum zero does not refer to a user's balance.
00:26:05.320 - 00:26:12.890, Speaker B: We have one question about when does the ERC 20 get swapped to super token? When I start a stream question mark.
00:26:15.100 - 00:26:59.848, Speaker C: So, no, basically you would want to do that beforehand. So if you want to use superfluid, you first have to upgrade your tokens, right, so then you kind of top up your Super Token balance and then you can stream. But the stream and the balance are kind of separate. Right, so you can have Super Token balance because you want to use other superfluid functionalities, not necessarily streams. And you can receive a stream without needing to ever upgrade. Right, so the upgrade is just kind of a utility, but ultimately you can think of Super Tokens as their own tokens. There's another question, which is how does that go into the balance on chain without gas fees? Well, we get that question a lot.
00:26:59.848 - 00:27:40.390, Speaker C: My kind of go to answer is blackmagic, but the truth is, basically we are using the blockchain in a slightly different way, right? We're not using it like a paper ledger. We're using it like a live machine with state and a clock. Right? And the clock is what moves the money, it's not transactions. So that's kind of a simplified way of explaining it. But if you join our discord, we can kind of go over this. I'm happy to kind of explain it in more detail that's Discord superfluid finance and we're there all day and just kind of love these kinds of conversations. So just kind of come and join us.
00:27:40.390 - 00:27:45.990, Speaker C: I think Catherine switched on her video, so she's probably going to kick us out now.
00:27:47.400 - 00:28:18.510, Speaker A: Thank you, guys. That was a super great presentation. I'm sure that everybody learned a lot. There's been a lot of good questions and yeah, you can either join on the Discord, the specific Superfluid Discord, or for the next three weeks, you guys will also be on the Ego Bold Discord channel. So feel free to hop in there. Anyone who would like to continue this conversation really appreciate your time and everybody's time today. Thanks for everything.
00:28:19.360 - 00:28:21.310, Speaker B: Thanks, Catherine. Thanks, everybody.
00:28:23.760 - 00:28:30.080, Speaker C: Thanks, everyone. Bye. And good luck at Hack Money. Make something cool. Make me proud. Bye.
