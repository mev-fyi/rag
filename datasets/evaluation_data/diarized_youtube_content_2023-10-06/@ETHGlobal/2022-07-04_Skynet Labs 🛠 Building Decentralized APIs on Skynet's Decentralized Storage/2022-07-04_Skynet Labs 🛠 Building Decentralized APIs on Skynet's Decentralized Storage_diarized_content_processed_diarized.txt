00:00:06.410 - 00:00:41.740, Speaker A: So for centralization and storage, we're looking mostly at application data. This might be about the user, this might be about a collection of users. And with this centralized storage, we can oftentimes think about this as like application front ends too. We don't want to necessarily host our whole website on AWS or or whatever else. And this is a little bit what Skynet is known for is our decentralized storage. But we can also look at centralization and compute resources, which is where this talk is going to go eventually. And we can think about things like APIs that work over that application data.
00:00:41.740 - 00:01:06.500, Speaker A: And for our kind of model here, we can think about this as our application backends. Of course, this is the off chain backend. Typically our compute. A lot of times a smart contract is going to be on chain. But there's also other APIs that get utilized all the time that we can focus on decentralizing. And Skynet is our magic bullet for solving these things. So I want to talk to you a little bit about what Skynet does and what we're building towards.
00:01:06.500 - 00:01:39.370, Speaker A: And so I'm going to talk to you hopefully only about ten minutes about Skynet and then show you what it looks like to use Skynet. But first, as a primer for what it looks like to eat, how Skynet is built, I want to have a little diagram here. Skynet is built on the SIA blockchain. It is an application specific blockchain focusing on decentralized storage. And it has hosts on its network, and it also has renters. And on Skynet, we have individual users in their web browser. And on Skynet, what we can do is have a user take a piece of data.
00:01:39.370 - 00:02:07.842, Speaker A: This can be an image, it can be a video, it can be their user profile data, and they want to send it to a Skynet portal like Skynetfree. Net. That data will then get broken into lots of little chunks and stored across a lot of hosts on the saya, network. Once that's done, once that data is persisted, that user will get back a Skylink. If you're familiar with IPFS, this is similar to a CID. It is immutable. It's like a fingerprint for that file.
00:02:07.842 - 00:02:26.634, Speaker A: It is a way that the user can later verify that the data that they're getting matches the data that they're requesting. And with the Skylink, they can pass that to a friend. It doesn't have to be isolated to that user. So now we have user B. They have the skylink. They say, hey, Fileportal.org totally different.
00:02:26.634 - 00:02:52.898, Speaker A: Skynet portal not run by skynet labs. I want this file. What happens is Fileportal.org has a connection with a bunch of hosts. It will select some that are the fastest. It'll grab enough pieces to reconstitute the original data and pass it back to the requester. Okay, so this is kind of what Immutable data on Skynet looks like.
00:02:52.898 - 00:03:22.300, Speaker A: We have a mutable data layer too. But talking about decentralization and decentralized APIs, there's something interesting here. Right on the right hand side, when we're still in the blockchain world, all this end to end is verified through typical blockchain stuff. But when we start using browsers, it gets a little bit weird. And if you notice, I was being a little cagey with my language. The skylink is an identifier. That means that the data is Verifiable, but that doesn't necessarily mean the client is verifying it.
00:03:22.300 - 00:03:54.374, Speaker A: Which brings about a question, right? Are we just putting our faith in the portal at that point? It might be open source or whatever else, but do we have a centralization point happening there? Let's kind of look at an example. We've got a user, they've got this file, and they use Chrome because they love Chrome. And using chrome. They request this skylink from Badportal.org. Badportal.org, not surprisingly, returns out Bad data. But because Chrome is dumb, it doesn't know anything about Web Three and the protocols and the protections we've built.
00:03:54.374 - 00:04:40.870, Speaker A: It's going to just pass back this bad file to the user, and the user goes on their way. But we could do a thought experiment, right? Like, what if Chrome browser did understand Web Three primitives and the protections that those can grant a user and incorporated them in the browser? And what that might look like is that our request goes out to badportal.org. We get back a bunk response, and the browser is like, hold on, I know that this is not the right data because I can verify this with the Skylink. So let me go reach out to another portal. Hopefully they won't lie to me or censor the data or whatever else. The file comes back, it gets verified now, not just Verifiable. And the user, without thinking about portals or anything else, gets the data that they need in a fully decentralized fashion.
00:04:40.870 - 00:05:08.238, Speaker A: Okay, so Skynet's not building a browser. Don't worry. I know that's always quite a task for some engineers. But we've built something called the kernel. And so what the kernel is, is it's either run as a browser extension or in an iframe, and it is able to load code hosted on Skynet. And it will pull that code, verify the code, and then run that code as a decentralized client side API. And lots of websites can share that code.
00:05:08.238 - 00:05:47.766, Speaker A: So what does this look like in practice? Well, we have a website, our kernel and our portal. And let's say we have greatscap HNS that's one of the naming services we support is Handshake. And so the application in its code will say, hey, kernel, use the module for doing uploads to do method upload. Okay? And it'll send that request to the kernel. The kernel knows how to handle this. And so it's going to load that blob of data, run it as a web worker, pass on that request to the web worker and say, hey, I need you to do upload. And this was requested from Greatscap HNS.
00:05:47.766 - 00:06:31.362, Speaker A: And then this blob of code will know how to handle that. It'll talk to the portal, it does all the verified fun and eventually gets back to the browser in a protected, safe way. Fully verified, end to end, fully open source, and fully permissionless. Okay, what if we wanted to get a little bit fancier? Well, the kernel also has an identity layer where you have a seed and public private keys for doing updates and signing messages and things like that. And so we might say to the kernel, hey, I will need you to use this module located at this Skylink to do the action registry update. But the module needs the user's key. But we don't trust the module with the user's key.
00:06:31.362 - 00:07:17.480, Speaker A: The kernel is the only one that gets to have the user's key. And we definitely can't trust the client side application because anyone can deploy that very trivially onto Skynet. So what happens is the module says, all right, I need a key kernel. Can I have one? The kernel will create a derivative key, a brand new key just for that module, and then we can do our signing and our interacting with the portal. And so I hope this gives you a little bit of a sense of what it looks like for our vision of creating a decentralized API where we can still do authentication, we can still do access control from modules calling other modules, they know the identity of the caller or what the host website is. And let's see a little bit of what this looks like in code. Because you're hackers, you're here to code.
00:07:17.480 - 00:07:42.894, Speaker A: So what you basically have to do, this is the module code for a very trivial module. But you'll clone a repo and you have a file where you start writing out your code. And aside from this boilerplate, basically we have to add handlers. So the requests have a method, and this method is called Say Hello. And then we define a function that handles the requested method. So this function is called handle. Say hello.
00:07:42.894 - 00:08:18.314, Speaker A: We'll log some data, and then we respond to the query with arbitrary data. And here it's an object with messages of the key and y hello as the value from the client side in a react app or wherever else. This code is real clean and simple. And so you import this call module. You want to have the Skylink of the module, which we here just have as a constant, and we say await call module. So call out to the to do module. We want to do Say Hello and pass along some arbitrary data or action or whatever else.
00:08:18.314 - 00:08:56.902, Speaker A: We'll await the response, grab the message and be able to use it. And so, getting started building these APIs is actually not that complex. We have a pretty tight built pipeline where you're able to quickly deploy these things to Skynet just using your CLI and iterate against it. But APIs are made to be consumed, right? For the most part, we want more people consuming the APIs than producing the APIs. And so how can we do that? I've already talked about, saya, Skynet, Skynet kernel. I know it's a lot going on. So let's look at what these layers of abstraction are on.
00:08:56.902 - 00:09:37.978, Speaker A: Saya we have this fast and secure data storage and a decentralized blockchain that is still private though. So we need to make this accessible to the web, which is what Skynet does. And then to make these rich applications for web two, developer experience on web3, we need to enable identity and shared code execution, which is what these Skynet modules can do. These kernel modules, excuse me, can do. And then lastly, what we're seeing is that people building these kernel modules then just write normal JSON libraries that wrap the annoying call module or whatever else. Right? So we're going to see a few of these in the demo. But the idea here is that we can do another layer of abstraction.
00:09:37.978 - 00:10:15.290, Speaker A: So it just feels like interacting with JavaScript code for the end developer. The user doesn't really have to know too much that even a decentralized back end is supporting it. And we can empower really powerful, decentralized experiences where users can share their data across different apps in a safe, private way. Okay, so let's build a social DAP on Skynet. So modules tend to isolate and separate out specific types of behavior. And so we, for building a social application, are going to need something for identity. We're going to need a social graph.
00:10:15.290 - 00:11:02.670, Speaker A: We're going to need a feed of posts from those users. And then we're probably going to want everyone's user profiles so that we can have pretty things like avatars and BIOS usernames. So there is a set of developers in our community that have published Skynet DAX Library, that is one of those wrapper libraries so you don't have to deal with call module or anything else. These expose methods for interacting with these abstractions on Skynet. And if you want to follow along or follow along later, or want to take a picture, this is the GitHub repo of the code that I'll be working with in the demo. And let's build. Okay, so let's take a look at that repo.
00:11:02.670 - 00:11:29.094, Speaker A: Sorry about the plosives. Are folks able to see? Great. I think that seems pretty good. Okay, so I'm in this hackathon ideas workshop, and this is the code I'm working against here. And I want to show you that as a react app, I've already built out all the UI elements. So this is just mock dummy data that is not coming from Skynet at the moment. But this is what I want to build.
00:11:29.094 - 00:12:16.390, Speaker A: And so I want to start off here. I want to build an idea hackathon idea, decentralized web app where we can have people join a social graph of hackathon participants and mentors. They can create new ideas and then see a feed of existing ideas from other folks in the hackathon. So that new idea page will be over here and I can put in some details. And if you take a look at the repo later, you'll notice kind of everywhere, these wires everywhere that I have these kind of mock statements. But all of the logic for dealing with the kernel and these decentralized APIs is going to be in this hooks folder. So basically all of this is UI stuff.
00:12:16.390 - 00:12:51.602, Speaker A: But we're going to really focus on authentication and then using these social modules. So let's take a look at this right now. Basically to do authentication, I have to use the functions in the Lib kernel library, which is produced by Skynet Labs. And first off, we need to load the kernel. So this is our bootloader. And once we do that, we'll set state in our UI to say the bootloader is loaded. So let's kind of just start stepping through this actually.
00:12:51.602 - 00:13:25.602, Speaker A: What does it look like when we don't have a bootloader loaded? Let's start from the very beginning here. All right, so the bootloader is not loaded. Bootloader loads pretty fast. So we'll get rid of these skeleton elements and our bootloader is loaded. Once our bootloader is loaded, our user is not logged in. So we have to provide a button here to log into the kernel. Again, I'm just kind of showing the UI and login flow here.
00:13:25.602 - 00:14:19.100, Speaker A: But then once they authorize with the kernel, produce their seed, then the kernel will load and we'll start kind of preparing to load in other data. And once the kernel is loaded off of Skynet, the code that does all this protection, then we'll be fully ready to use this data. And again, this is just mock demi data for now, but what does it look like if we drop that off and actually call the necessary functions for interacting with Skynet kernel. So we await an init that's our bootloader. And then we basically await a promise from login complete. So whenever the user is finally logged in, then we can start doing some stuff in our application. So these are just kind of fairly boilerplate, honestly, if you want to build a react app following my example here.
00:14:19.100 - 00:15:18.426, Speaker A: So let's go ahead and save. I'll do a hard refresh over here. And now in actuality, I will be calling out to Skynet to load that bootloader, load in a kernel and get going with it. Okay, so now if I've done my authentication correct now the user is authenticated and I can start interacting with this library that exposes all this social behavior. So as I mentioned before, we have identity, which gets us the user's ID in this public decentralized social network. It's a ed two five 5119 pub key. And we can use that to then look up their profile, look up their social deck, and look up their feed deck.
00:15:18.426 - 00:15:55.820, Speaker A: So this is their friends list and this is their lists of posts. And I'm not going to use any post here. We're going to have some selective elements where we modify which posts we actually want to show or display. And so instead of returning, the photographers are distracting. Instead of returning this kind of mock data for our profile, let's start using the Use DAX hook to actually expose real behavior that will then export to our UI. Okay, so right now I'm returning early with mock data. Let's comment that out.
00:15:55.820 - 00:16:49.674, Speaker A: And now if I reload my app, what should happen is I should load my bootloader. We'll temporarily see the kernel loading. And once that's loaded, now that decentralized API is going out, grabbing my profile data that, you know, on my own, assigned on Skynet, all the data's persisted to Skynet, the user profile images persisted to Skynet, and it's loading that identity into our application. And what this looks like from the code side is that we have the identity DAC. We say, hey, grab the user ID and let me know when you get it back, and then let's pass that to our profile abstraction and we want to get the profile for that user ID. Then once we have the result, let's update the state of our application and keep going. So there's a lot of Reacty stuff going on here.
00:16:49.674 - 00:17:31.798, Speaker A: If you're unfamiliar with react, the actual kind of kernel stuff is not too deep or dense here. Okay, so also we waited until we were authorized authenticated on the user side, and we waited for a kernel to load. Well, great. How about these avatars right here? If we go and look at our element for that on our hackers component, we kind of have a function where we say we want to get the user avatar for some predefined folks that we know. These are our participants and mentors. So we have a list somewhere. I've defined a list.
00:17:31.798 - 00:18:14.246, Speaker A: It's going to be in the bottom of Use DAX. I've defined a list of the user IDs that I want to define as like participants and mentors. And so now I want to grab their avatars. Instead of grabbing this mock data and under Get User avatar, I can stop returning my mock data and instead say, let's create an instance of our profile deck. Remember this library that wraps a module interaction and called Get Profile with the user ID. And then that's a Skylink, which is we need to then define the portal that we're accessing them from. And that's what this method does.
00:18:14.246 - 00:19:03.734, Speaker A: But at the end of the day, when we save that, what will happen is we can refresh our page and as these things load again, our application reaches out to the kernel saying, hey, I need this profile for this user ID. But I want you to use this module and the code in this module. And then it will reach out to the next place which will reach out to the Skynet. And so now we see these being pulled in in real time off of decentralized storage. This is fully decentralized end to end, which is pretty impressive, especially if you have experience building on some other decentralized storage projects. All right, how am I doing on time? Decent. So this is kind of cool.
00:19:03.734 - 00:19:50.760, Speaker A: Like, I'm a brand new user. I don't follow any of these people. But I have a list of basically I can bootstrap my social graph that will follow me from application to application on Skynet by basically writing my own method that says, here's a list of people, go follow all of them and tag them as being associated with a specific event. And so that's what this follow user list method does. I say let's use the social deck for all of the users in our user ID list that was hard coded into the program. Let's go ahead and follow that user ID. And if I pass in some details, I can then add some metadata too so that later on I can know why I followed them or whatever else.
00:19:50.760 - 00:21:09.978, Speaker A: And there's nothing built into any of the protocol pieces that require me to use this tagging or use whatever else. This is all community developed and open source and everything else. So I think that's an interesting aspect here that we can design how we want social graphs to work and even extend how they work and use that extension in our application, but still have that data be interoperable with other folks building in the same paradigm. Okay, so if I save that's now as those load, I already know these user IDs, but I can click Follow all and I'll just in the back end that module will start following these users. I want to mention maybe right here before I forget, this is kind of the cutting edge of what Skynet is working on. We've focused a long time on decentralized storage and we've started seeing all the potentials for decentralized APIs being fully hosted on decentralized storage. So there are spots where we are still doing optimizations things that are called sequentially that with a couple of hours work will be called in parallel.
00:21:09.978 - 00:22:03.230, Speaker A: And so you'll notice things that like following these folks is going to take a little while. But we're excited to have developers start building on things now so that they can have a voice in the direction that things move and what we focus our efforts on. All right, I'm going to just try to fly through a few more before doing my closing appeal to everyone. Let's look at our ideas feed and instead of returning our mock data, let's return actual data. So here what I have is a set of users and for each one of these things, I'm going to eventually grab their user profile, but we've kind of looked at the profile deck. So I'm just going to skip over it. But what we have is a I broke something fun.
00:22:03.230 - 00:22:54.720, Speaker A: Okay, what we have is a reducer here. Basically what that means is it's a piece of state that we can kind of keep updating with the previous piece of state's state. And so what we're going to do here is call this updater every time we see a new user and grab their current social feed. And we are going to grab their whole social feed actually, but we can just really quickly filter it. So what we're going to do actually specifically is call, sorry, it is down here on our feed deck. We're going to call load posts for user. We're going to pass it our user ID and we'll get back a big list of posts and we can quickly call a filter on it to say we only want posts that have a content field that we've extended that is called event.
00:22:54.720 - 00:23:53.060, Speaker A: We could say activity hackathon, whatever else. But here we can just say if it has an event field, let's use it. And then we'll pass that onto dispatch ideas list, which is a complicated way of updating the state. But you can see that grabbing the data off of Skynet is actually pretty easy for the end user now that the module developer has abstracted this decentralized social network behavior. And it would be cool if things loaded. All right, so the last behavior that we haven't seen, maybe we can watch a few of these ideas load and pop over into creating a new idea. But while it's grabbing some of those, we've created a create post method here that we can call from our user side as well and we can just pass it a title for our project idea, some text, identify the event price, track, whatever else.
00:23:53.060 - 00:24:53.510, Speaker A: And now we're making a post on that user's social feed that has this extended metadata that any application can utilize for whatever they want. But this is really cool because you'll in the ecosystem have other folks that are building aggregator type infrastructure. And so now your application specific data that is tagged with certain stuff can still be included by maybe scrapers or aggregators or other user interfaces. And that's the beauty of this fully decentralized structure is that this application data is totally interoperable everywhere else. And again, you'll see that we're using the feed deck to create a post pass. It this information that we've formatted in the correct way and then it will be added to the feed. So let's take a look for a brief second to kind of see we're loading in some of the feed items from members of our list up here above.
00:24:53.510 - 00:25:24.960, Speaker A: But let's go ahead and add a new idea. We want to have a super big prize winner and we'll be at ETH New York trying to do the public goods track, and we'll be building know, solidity flutter and hard hat. I don't know if those make sense together. And we're looking for a team. Now. When I press that button, I can call again. This create post.
00:25:24.960 - 00:26:31.190, Speaker A: And what happens is that data is persisted to Skynet. And then I'm immediately pulling that data off of Skynet into the social feed, using fully decentralized storage, using decentralized code stored on decentralized storage, and using a decentralized stored on Skynet piece of code to do all that verification, all that message routing and everything else. So from end to end, it's always forkable, it's always verifiable. And for the user, they don't have to have crypto or a wallet or anything else to interact with it. So I hope you see some of the potential and are a little bit excited about some of the direction that we're going. Again, if you want to look at this later on, you can see where I just comment out mock data on the Hackathon Ideas workshop. And we also have beta documentation because this is still new and is at kernel beta Skynetlabs IO.
00:26:31.190 - 00:27:03.562, Speaker A: And I'm going to annoy someone by going about 30 seconds over here. We are doing a call for builders. So we've just released this beta. We really want feedback from folks building decentralized applications, especially those that have maybe experience in Web Two or elsewhere. We're putting up $8,000 in prizes for anyone that it creates or consumes kernel modules in your application. So there's gold and two silver prizes. But you don't have to create a kernel module or a decentralized API to be eligible.
00:27:03.562 - 00:27:35.690, Speaker A: You could just bring in some of these social components, identity, user profile, whatever, and still be applicable for the prize. I just said all that. To learn more, check out kernel beta Skynetlabs IO. If you want a free account for 100GB of upload for decentralized storage, check out Skynetfree. Net. Come say hello to me. I'm going to be downstairs chilling at my booth for a long time, and I super appreciate everyone's time and attention and check out our discord.
00:27:35.690 - 00:28:22.652, Speaker A: I don't think I have time for questions. Is that correct? Okay. How do you configure the gateway available? Not necessarily, no. If you want to have kind of like that sort of privacy on Skynet, what you'll want to do is use encryption to do that layer of interaction. I mean, I guess in theory, you could spin up like a private, saya, and a fully private Skynet because it's all open source and you can do that. But by the default architecture, the idea is that these portals share this kind of big data lake, more or less, no matter what portal you're running or accessing it through. Yeah.
00:28:22.652 - 00:29:11.560, Speaker A: So the economic relationship for getting data on the SIA is between the user and the portal. So Skynet Labs is using a freemium model where we let users have 100GB of storage for free and pretty generous access speeds. But if you want to ramp those up for $5 a month or whatever else, because we're focused on making this really accessible for Web, two users that aren't in the crypto space yet, but it's a fully open source stack and we're really excited for folks to open up portals where you can pay in crypto or anything else. And then the portal itself is paying in, saya, coin on the SIA network, because that's what that protocol does. All right, thank you so much for your time and attention. Come see me if you're interested in the prize, and I'd love to help you out.
