00:00:05.690 - 00:00:20.000, Speaker A: I think with that, we are ready to move on to our next talk. And for this one, I'd like to invite Paul and Titania for talking to talk about Polygon Nightfall. So without further ado, let's welcome Paul and team.
00:00:20.610 - 00:00:38.434, Speaker B: Hello. Hi, everybody. Paul Brody here. So I'm the global blockchain at EY, and, wow. So just, I was watching the last presentation. That is a very tough act to follow, but we are going to do our best. I'm only going to take, like, two minutes before I introduce my colleague Chitanya, who is incredible.
00:00:38.434 - 00:01:48.794, Speaker B: But I want to talk just a little bit about the history of nightfall and how it became Polygon nightfall at EY. There's a couple of things that we spend a lot of time thinking about. One is, what is it that enterprises need, right? And there are a lot of brilliant people like Sandeep and others who have been thinking very heavily about scalability. But one of the big challenges for enterprises is enterprises can't just use a mixer, right? Because enterprise tokens and assets are often, they are unique, they're often attached to business contracts that represent kind of complex business relationships. And so we have spent a great deal of our time over the last five years, really pretty much nonstop over the last five years from a research perspective, thinking about how to enable privacy at scale. Now, the first version of Nightfall, I think back when ether was $100 apiece, we spent $3,000 worth of ether just to build our prototype ZKP based supply chain and move some tokens around. And that was an amazing piece of work, and it proved the case out for us, but we kept iterating.
00:01:48.794 - 00:02:39.390, Speaker B: And where we ended up earlier this year was with nightfall three, which is a ZK optimistic roll up technology. And we built that out. And in cooperation with Polygon, we're really turning this into a layer two system where everyone can access private transfers and payment at scale with very efficient gas costs directly on the Ethereum main net. So that is kind of critical to our goal. And when we started talking to the different layer two providers, and there's a lot of them out there, and they're all populated by incredibly brilliant teams. But the relationship that we struck up with Polygon, with Sandeep and the team was incredible, because at heart they understood a couple of really critical things that we shared with them. A huge commitment to public blockchains, an unshakable commitment to the ethereum ecosystem.
00:02:39.390 - 00:03:12.154, Speaker B: Ey. We are, without a doubt, the biggest sort of large enterprise investor in the Ethereum ecosystem. We pour our energy into this ecosystem. And then thirdly, we're both very committed to ZKP technology, both for scalability and for privacy. And so that match the relationship that we built over that has been the foundation of the work that we've done. We are so excited about kind of where this is going. I believe we are all underinvested in privacy, that enterprises need it for sure.
00:03:12.154 - 00:03:37.460, Speaker B: It's an absolute requirement, but I think far too many consumers and individuals are underselling their own value by not investing more in their own privacy. So I very much look forward to that. And I am incredibly delighted to hand over to my brilliant and talented colleague Jatanya Konda to actually explain what Polygon Nightfall does and give us a quick demo. Chitanya, over to you.
00:03:41.220 - 00:04:16.350, Speaker C: Don't forget to unmute. Thank you, Paul. Yes, I'm Chitanya, and I work with EY's blockchain R D team. Today I'm going to show you a live demonstration of what Polygon Nightfall does. And hopefully a very wise man once told that live demonstrations, especially of tech nature, are a courier seaside. One that I repeat time and again, because I always end up with a short end of the straw. I hope today is not one of those days for me.
00:04:16.350 - 00:05:20.704, Speaker C: Let me share my screen as I walk you through. Okay, now, I hope you all can see a PowerPoint presentation, so I'll give you a bit of context about what Polygon Nightfall does before I give you the nightfall demonstration itself. What is Polygon Nightfall? You all must be pretty much aware the very first iteration of Nightfall was built as a privacy protocol, or it still is a privacy protocol. What it enables us to do is to do private transfers of ERC twenty s, seven twenty ones, or eleven fifty five s between two parties, such that the contents of that transfer is private, so nobody can see the value or the token id. At the same time. The recipient is also anonymous, so it's essentially a privacy protocol. Now, just to give you a high level summary of how it works, because this is not the point of our talk.
00:05:20.704 - 00:06:07.164, Speaker C: Here you have three kinds of transactions. You have deposits, transfers, and withdrawals. With a deposit, what you do is you take a token out of l one and you put it into l two. When I say l two here, it's really a shield contract that sits on l one and you take any token, the VRc 20, of a certain value. You submit this proof, called a deposit proof, which then provides the equivalent commitment that holds the value you've just deposited. A commitment is just one way to obfuscate the contents of a token in terms of a deposit that's really not private. Because when you move tokens from layer one to layer two, or back to layer one, that's not where we get privacy.
00:06:07.164 - 00:06:55.736, Speaker C: We get privacy when we're within layer two itself. So now moving on to the transfers, where we actually get private transfers itself. What we're going to do is in order to spend a token, a user will first have to create something called a nullifier. A nullifier essentially spends the commitment they own, and there's no way to connect a nullifier to the commitment it belongs to. So all someone who's watching the block game can see is that something has been spent, but they can't see what has been spent and how much is within it. At the same time, when you're transferring something to some other person, what you're going to do is create another commitment of equivalent value that you've just spent. And obviously, because it's obfuscated inside a commitment, the contents of the commitment itself are not visible.
00:06:55.736 - 00:07:30.196, Speaker C: So the value is hidden once again. And also the other piece of data that would be as part of this commitment is the public keys that the new recipient owns. So this new commitment now belongs to somebody else. Anyone who's watching the blockchain can't really see who that recipient is or who received this new commitment. Now, withdrawals are pretty much the opposite of deposits, pretty similar to transfer. You're going to spend a commitment. When you create a nullifier for a commitment, there's no way to associate what commitment was just nullified.
00:07:30.196 - 00:08:00.864, Speaker C: So no one can see what commitment was spent, and you have an equivalent value being released from layer two to layer one. The layer one part, again, is visible for everyone to see. So you would really want to do transfers with privacy inside layer two. That's the whole point of how you'd want to use polygon. Netfall. Now, this bit of work that I've just described about has existed for some time now. It was first released back in 2018.
00:08:00.864 - 00:08:46.432, Speaker C: So what's different between the version then and now is that it does optimistic roll ups. The very beginning, the cost of the transactions that we've done were quite high. They ranged about in the $100 nature back in the 2018. The reason why it's quite high is there's generally a lot of data that's been stored on the smart contract in terms of what's held in a Merkel tree, all the commitments and nullifiers, and you're just sending one transaction at a time. You're not really batching up. Now, both of these changes have already been modified where the smart contracts are optimized such that we really don't store any data that's not really required to be stored on any smart contract. And two, we also bat.
00:08:46.432 - 00:09:24.648, Speaker C: But what optimistic Rob does, it takes it to a whole different level, where you're really not doing a computation itself on chain anymore. You're really providing what the end state of a computation should be. And in case that is wrong, you're expecting a challenger to challenge that the end state that you just provided was wrong. By doing this, you're saving all of the gas costs of computation itself. And at the same time, you're able to scale a lot more in terms of having higher transaction throughput, because you can fit more data into a block. Now. So that's how polygonite four uses optimistic rollups.
00:09:24.648 - 00:10:15.416, Speaker C: Polygonitefall uses zero knowledge proofs for privacy. So that's the ZK part. And it uses optimism for scalability, both in terms of higher throughput, but most importantly, lower transaction fees. Now, just to give you where this sits in the current ecosystem of layer two solutions, layer two solutions exist in the form of both off chain solutions and on chain solutions. With onchain solutions, there's usually two approaches one tends to take. Lately, you either use zero knowledge proofs, snarks, or starks of some kind, or you use optimistic roll ups. Using both of these, you can either get the benefit of privacy with some very good scalability, or you can directly register as just purely a scalability solution where polygon Nightfall is.
00:10:15.416 - 00:11:02.860, Speaker C: It's an optimistic solution that uses scalability, but also provides privacy. You would know of other optimistic solutions, such as optimism and arbitrum today, which are built to be scalability solutions from scratch. So, moving on. Now, just to give you a comparison of private transactions, if you were to do an optimistic version of a private transaction as opposed to a ZK version of a private transaction, what I mean is using optimism for scalability versus using ZK for privacy. ZK for scalability. There's pros and cons to both of these. A very good pro for an optimistic solution is that the gas costs are way lesser.
00:11:02.860 - 00:12:12.932, Speaker C: So the gas cost of polygon Nightfall is about 9000 gas per transaction. That comes down to about based on various gas prices. Of course, that number is calculated based off of 75, as opposed to ZkZK solutions, which tends to be more expensive in terms of gas. Now, on the other hand, with aztec light solutions, which is ZkZk solutions, they have finality much faster than optimistic solutions. They have finality pretty similar to what a layer one would have. Optimistic solutions tend to have a one week wait period, predominantly because you would want to give enough time for challengers to challenge bad blocks. If there exists any one way that Polygon night force circumvents this is it uses the concept of instant withdrawals, a feature that is provided by using liquidity providers for fungible tokens such as ERC 20s, so that using liquidity providers with instant withdrawals, which is a built in mechanism, you wouldn't have to wait one week.
00:12:12.932 - 00:13:10.148, Speaker C: It could just be the layer one finality as well. The other big differences between the two approaches is that polyvin Nitro, being an optimistic solution, uses something like a fraud proof. Fraud proofs tend to be ones that are only submitted in case an invalid transaction ends up on the blockchain. ZK solutions, on the other hand, work on valid proofs, which means you can't submit an invalid transaction to the blockchain to begin with. You've got to have a valid transaction that will verify the proof. Generally with ZK solutions as well, you have computational resources that both of these use with a Polygon Nitfold solution. It's relatively lighter in terms of the kind of zero knowledge proofs that you would do, as opposed to an entire ZK ZK solution that is on a very high level what polygon nitfold does.
00:13:10.148 - 00:14:08.852, Speaker C: But before I move on to showing you a demonstration, I just want to give you a quick overview of what are the various players involved and what do they do inside a polygon Naxo system. So here you can see three players. You see a transactor, a block proposer, and a challenger. Transactors are users who generally create transactions such as deposits, transfers, and withdrawals. And then they submit them either directly to the blockchain or they can also submit these transactions to the block proposes the transactions that you submit to the block proposals usually are transfer and withdrawal transactions, not deposit transactions. Those will have to be submitted directly and always to the blockchain. Block proposers then take all of these transactions that they receive from various users and they put them into different l two blocks, and they submit these l two blocks into the layer one, which is ethereum.
00:14:08.852 - 00:14:47.268, Speaker C: In this case, each layer one block. An ethereum can hold more than one layer two block, depending upon how big these layer two blocks are, and that would exist on the state of l two blocks. The final state they hold would exist in layer one inside layer one blocks. Now you have a third player called challengers who are continuously monitoring the system. What they do is that they will take these blocks that are put up, these l two blocks that are put inside the main net. They will check the validity of both the blocks as well as the transactions within the blocks. And if everything's fine with those blocks, they do nothing.
00:14:47.268 - 00:15:25.900, Speaker C: But in case they do find a wrong transaction or a block that was created wrong, they will then create something called a challenge. This challenge will basically prove how the block that is on the main net is actually wrong. When I say mainnet, sorry, ethereum, is actually wrong. And if that proof verifies, then challengers will succeed. And two things will happen. One, the block proposer who just proposed the wrong block will be slashed. And two, the block proposer would have submitted something called a stake.
00:15:25.900 - 00:16:17.744, Speaker C: With every l two block that they create, that stake will be released to challenges as payment for the work they've done. So that's the incentive mechanism that the challenges would have and block proposals. Their incentive mechanism is that transactors will pay them fee with the transactions they submit to be put up into a block. So those are the different participants. And finally, I will not go into further details about off chain transactions, how block proposals are registered, how challenges are submitted. Just to give you a bit of a roadmap before I move on to the demonstration. Currently, this protocol that I was just discussing about has been deployed into the testnet, and we're testing it rigorously to catch any obvious or not obvious, and all sorts of bugs that we could think of.
00:16:17.744 - 00:16:59.200, Speaker C: Once that's done, the next step would be, is to have a proper security audit of the protocol. And then there would be a restricted value mainnet deployment. When I say restricted value, it would be the amount of transfers would be pretty small. Originally, there might probably also be a bug bounty program run simultaneously after the main deployment. And finally there will be, after the main deployment has been successfully run for quite some time. Of course, the restriction will just be lifted, and for there to be no restriction in terms of the transfer at all. That's everything in terms of context.
00:16:59.200 - 00:17:57.452, Speaker C: Now, I will move on to the fun part for you, but the scary part, to do a tech demo of me. This here, which you see is a polygon nightfall wallet. It's very preliminary looking, just because we're much more focused on having this tested itself rather than having it part of Polygon's website already. But you can imagine it to be as sophisticated and as beautiful as Polygon has their wallet today. And it will be part of the website too. So this Polygon nightfall wallet is run by any user who wants to use this layer two solution to do transfers of private nature. All of the keys, both that pertain to the keys that will be used to send transactions to the Ethereum blockchain or the keys that correspond to the layer two itself, which is the secret keys that will give you ownership of commitments.
00:17:57.452 - 00:18:26.156, Speaker C: All of those are stored within users browser. None of this will be inside a server anywhere. So this will have proper privacy for a user. And everything in terms of privacy sits at the user's end in their browser. Now another thing is you'd notice that here we have ERC twenty s and ERC 720 ones. And obviously deposit transfers and withdrawals for all of these. Something else to notice, ERC 1135 is also possible.
00:18:26.156 - 00:19:21.964, Speaker C: It's just not part of this demonstration right now. And yes, that's pretty much everything. Before I go on to give you a demo. So firstly, I will start off by doing a deposit of ERC 20 to myself. Which means when I create this transaction and I sign this transaction, what's happening is that the very first transaction was to approve the shield contract, to take some ERC 20 balance from my ERC 20 contract and send it to itself. The second transaction is to actually send it to the blockchain. So what you see here is I have an element balance of a million I had, and now I moved ten of that to layer two.
00:19:21.964 - 00:20:05.640, Speaker C: But it says pending deposit. So that's interesting, right? Why is it not part of l two already? We've got to remember that it's a roll up solution where lots of transactions are required to be put into a block. At the moment, all I have is just one transaction. Before I go any further, I just want you to show what other players exist here. So the one who's running the browser, this wallet here, I'm the user, I'm one of the participants in this network. The other users are sitting here. You have our block proposal, and you can see that a block proposal was started and they've registered themselves onto the layer one contract and they're listening for any sort of incoming events.
00:20:05.640 - 00:20:40.276, Speaker C: And then you would have a second player called a liquidity provider, who provides the services if an instant withdrawal is required. And then you have a challenger who is continuously monitoring the system to see if there's any bad block proposed. Other than that this is just the transactions being run up and a bunch of logging that's not very interesting. So today, right as we speak, there's four players all up and running the system. So one transaction was created. It's still pending. So now let's create a second transaction.
00:20:40.276 - 00:21:19.068, Speaker C: This time let's do an ERC 721 transaction. I'm picking a token id one. I'm submitting this from. I'm approving this first in the ERC 721 contract, and then I'm actually submitting the transaction. So what happens now is that this ERC 721 token has to move from l one to l two, since everything is pretty quick. What you have not noticed is that initially it was a pending deposit, but as soon as a block was created, what that means is that it is now in l two. So the l two balances have been updated.
00:21:19.068 - 00:21:55.788, Speaker C: So we've created one deposit of the rc 20 that was ten, and one other deposit of ESC 721. So that's why you see these balances in l two. The current block size is just you. For the sake of demonstration, I did not want to create 20 transactions as you were all looking at it quite boringly, but obviously these block sizes can be much bigger than that. Very quickly, let's see what our other players are doing. So we have a block proposer block proposal just said, oh, I created a good block and this is the hash of that block that I've just created. And this is the current balance list for the user myself.
00:21:55.788 - 00:22:41.164, Speaker C: So both of us are doing our job quite well and we're both pretty happy. Now what I want to do is I want to do a transfer. I want to do a transfer of an ERC 721, let's say to somebody else. The default address is to myself. But that's not fun, is it? So I'm going to do a transfer to somebody else and let's pick a token. There's just one token in layer two for the moment in the US 721, I pick that and we'll submit this transaction. I'm signing this transaction to be sent to the blockchain and pretty soon you will see that this LCU transaction that I have goes into pending upflow once again.
00:22:41.164 - 00:23:12.516, Speaker C: It's pending because it's not been proposed as an l two block onto l one yet. We need a second transaction to create some blocks. So I'm just going to create another transaction. In this case, let's say a deposit of $10 of ERC 20. And I'm going to sign that as well. Okay, now you will see that. Oh well, let's update again.
00:23:12.516 - 00:23:53.216, Speaker C: Now you will see two things have happened. A block must have been created. Yes indeed it was. A git block was created. So I now have a balance of 20 because I had ten originally and I just added ten more and I'm less by one ERC 721 token. So just to quickly give you an overview, there is a second account here obviously that I used to send it to, and that second account has a balance of ERC 721 one. Just to give you a quick understanding of the second account, for the moment I'm just running the second account in a browser myself.
00:23:53.216 - 00:24:25.530, Speaker C: The keys, the level layer two keys that we're using are very different here. But layer one, they're both the same people because I'm the same person. So my layer one balance, according to that ethereum address is still the same. But under layer two I have two different accounts and these are the balances of those two different accounts. But you can extend this logic to anybody out there in the world. It does not necessarily have to be me, it would run the same way. Now just going back to my original account, I'm just going to quickly log out and log in again.
00:24:25.530 - 00:25:08.680, Speaker C: Okay, now let me retrieve my balances. Now I'm going to do something else here, which is to do a withdrawal of an ERC 20. I will click on withdraw and I'll submit ten. But you've got to remember, if I just click submit right now, there's the problem of finality being one week, and I really don't want to wait one week. I just want my transaction straight away because I need to look for something badly. So I have the option here called instant withdrawal. So I'm going to click on instant withdraw and I will click on submit and then I will confirm that transaction.
00:25:08.680 - 00:26:04.680, Speaker C: So now you see I have a pending outflow of ten, which means I should pretty soon withdraw ten out of layer two and that should end up in my layer one balance. At the same time, I need a second transaction for this to be blocked. So I'm just going to create an ERC 721 transaction of token id two, I will sign that too, and then I will let's look for the balance in a minute. Okay, so you'd notice that, well, another step actually, you notice two things here. One, I've just given myself a new 721 token again into l two. So there's that. But there's also an update to my l one balance.
00:26:04.680 - 00:26:48.840, Speaker C: I moved ten out of my pending outflow into l one balance, which meant I was able to instantly withdraw the $10 instead of waiting for a finality of one week. Now let's just see what the liquidity provider saw. So the liquidity provider received an instant withdrawal request for this transaction hash, and he provided, or she provided me with the money straight away. The mechanism behind this is this. When I create an instant withdrawal, what I'm doing is submitting a request that I'd like to instantly withdraw this token. And this is the fee I'm willing to pay. Liquidity providers are listening to these events.
00:26:48.840 - 00:27:44.264, Speaker C: Those are the events that they're listening to. And as soon as they see an event, what they're going to then do is to basically create, accept this request I just made and transfer the subsequent amount for me while taking on the wait time. For the wait time I would have gone through of a week period onto themselves. So liquidity providers, like challengers, are continuously monitoring the network. So they would know if they give me the money straight away today, is that safe or not? They would know that because they're continuously checking all the blocks and all the transactions and all the blocks. By doing so, they know that eventually, after a week, this transaction will be finalized for sure, because there's no bad block before this transaction. There's no way for this transaction to be removed from the network, considering that they will do this verification themselves.
00:27:44.264 - 00:28:27.450, Speaker C: Provide me the liquidity that's required straight away, and they will receive the money that I would have received a week later. So that's what's happening with the liquidity provider. There's just one final interesting case I'd like to show you. I'm going to do just two deposits for this of ERC 20. Okay, that's pending. I need a secondary in a minute or two, you will see there's a pending deposit of 20. You will see that I now have an elder balance of 20, but let's just give it a few minutes and we'll see something pretty interesting.
00:28:27.450 - 00:29:10.336, Speaker C: Okay, now you saw I had a balance of 20, a 30 area, but now I only have ten. And 20 were moved back to pending deposits. So what just happened with something naughty? Let's look at it. You see, there's a block proposal here. And clearly, so far, block proposals has submitted three good blocks. But the last block that he just created with my two deposit, he purposefully created a bad block of type, incorrect root, and he submitted onto the blockchain. So what happened was as soon as this block was submitted, because that was a block that's part of Ethereum.
00:29:10.336 - 00:29:40.232, Speaker C: Now in layer one, my balance got updated saying, well, your balance is now 30, but clearly, somebody was monitoring the network, which was a challenger. A challenger was monitoring my network, the network of Ethereum. And then they realized, ooh, this is actually a bad block. Let's take a look at that. They notice that I just received a block here. Q new block, proposed event. I've just received a block proposed.
00:29:40.232 - 00:30:26.668, Speaker C: I'm going to verify the validity of the block proposed. That's what they would have done. So as soon as they verified, there was a warning, they said, block checker block invalid with so and so issue. As soon as that error was picked up, it then tries to create a commitment for the challenge, which is challenging, incorrect route, and eventually, it would have submitted the challenge to layer one. Our challenge commitment has been mined and sending reveal, which is. Yes, reveal is to reveal the challenge itself, and the challenge would have been provided to layer one. Layer one will then do the computational steps of the challenge itself.
00:30:26.668 - 00:31:05.236, Speaker C: And on successful challenge, it will do a rollback of the entire state until the first bad block was. Until where that bad block was. When that happens, a rollback of all of the transaction state is done, and a rollback was received by everyone, including the challenger. So that's what happened. Our state was rolled back, where we still have 20 waiting to be deposited, and I don't have that balance yet. Now, what happened was, I only have one proposal, as you can see. And as soon as this bad block was submitted, this proposal was basically slashed.
00:31:05.236 - 00:31:41.668, Speaker C: So they're no more the proposal. Now, on a good day, if I were to have another block proposal right now, these transactions would have ended up back in the mempool for this second block proposal to have picked up, and they would have submitted for me. So these transactions would have eventually made it back to l two without me doing anything. That's just the way the entire network works and the different players are interacting with to give a proper, valid transaction state to the system. That's pretty much everything, really, in terms of demonstration. I'm happy to take any questions.
00:31:41.754 - 00:32:07.630, Speaker B: Now, Johnny, I got to say, you keep saying that live demos are career suicide, but the reason you keep getting picked for them is that you always execute them and then look like a rock star. So, thank you. Thank you so much. I'm sure Karthik's going to tell us that because of the time constraints, there are no questions, but really, truly brilliant. I'm so proud of the work that you have done, the R D team that has done, and the work that we are doing in cooperation with Polygon to make this real.
00:32:08.960 - 00:32:55.784, Speaker A: Paul and Zitania that's mostly correct. There is one question that I do want to ask, a quick one that came in, but before I ask that question, I want to just say I've just been looking at hundreds of comments and everybody's just been extremely happy with how easy you made that to understand and follow and of course the demo work. So I just want to make sure that I point that out. It was a super conveniently well made, easy to follow presentation that covered really technical topics. So thanks for that. The question is a simple clarification that came in from one of the listeners, and the question is, would challengers be able to reverse transactions made a mistake, such as kind of giving an invalid wallet address or any other keys, and kind of just how does the if it's possible to reverse a transaction upon finality?
00:32:55.832 - 00:33:40.184, Speaker C: I guess so, yes, there's a one week finality period. You really have to do any sort of challenge within that period. So there's various ways a transaction or a block could be wrong. Either the transaction that was submitted to begin with was invalid, the block browser still went ahead and submitted it as part of a block, or the block itself that was created with these various transactions was malformed and that was submitted onto the network. What then happens is that block now is part of layer one. Let's say other blocks were continuously proposed on top of these blocks as well. At this point, a challenger who is looking monitoring the system, they would pick up this very first block proposed that was wrong block.
00:33:40.184 - 00:34:15.040, Speaker C: They will then submit a challenge that challenges that very block. And when that happens, all of the blocks along with this block and the ones that come after will be rolled back. So that entire state is basically rolled back. And when that rollback happens, that rollback is not just happening in layer one of the blockchain. Everybody who's keeping track of their own state in terms of commitments or transfers or transactions, they will also have to update their own state. So block proposals, challengers and users, they will all update their own state according to the rollback that happened. I'm not sure if that answered your question, Karsik.
00:34:15.120 - 00:34:31.610, Speaker A: I hope so too. We'll see if there's a follow up question that comes in, and if there's still any confusion or follow up questions, I'll just ask them directly over email and connect you both. So thank you so much with that amazing presentation, and we are ready for our next talk.
00:34:31.980 - 00:34:32.390, Speaker C: Thank you.
