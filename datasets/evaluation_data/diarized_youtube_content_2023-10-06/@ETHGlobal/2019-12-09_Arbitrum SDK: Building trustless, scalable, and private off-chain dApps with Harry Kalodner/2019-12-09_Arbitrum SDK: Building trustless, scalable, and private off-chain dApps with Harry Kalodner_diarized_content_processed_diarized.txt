00:00:00.410 - 00:00:39.190, Speaker A: Essentially fast off chain progress. That's what we want. We want to be able to execute not on Ethereum, but with the security of Ethereum. That's the fundamental goal. And the way Arbitrum does this is through a process of using dispute resolution. And so instead of just kind of running all the execution on chain, we instead make claims about execution and then support efficiently a way to kind of challenge and derive whether or not that claim was true. So that in the happy case, you don't need to run anything on chain.
00:00:39.190 - 00:01:26.886, Speaker A: And even in the worst case, you only need to run a very small amount of computation on chain in order to ensure the correctness of a very large amount of computation off chain. And that's kind of the really cool thing Arbitrum provides, which gives us these off chain contracts that actually have the security of Ethereum, which is where the magic is. There's no kind of separate consensus, it's all just reduces to Ethereum security. And my favorite part of this is that we support just deploying your existing solidity contracts into layer two. A lot of layer two systems. You need to learn some new framework and new tooling and a lot of new complexity there. So this is true of state channels, if you're familiar with that.
00:01:26.886 - 00:02:27.078, Speaker A: This is true of optimistic roll up if you're familiar with that. But we have kind of this magic which is don't write anything new, just take your existing contracts and go. And so how do we do this? I went through a little bit. Fundamentally we use a combination of techniques, no fancy cryptography involved, which is really nice because it means it can actually be fast. So we do all of this with just a combination of protocol, design incentives and this custom virtual machine architecture that essentially just makes sure that we can run all of this kind of back and forth dispute efficiently on chain. And so what are the important things to know about Arbitrum when you're thinking about, hey, can I use this? Well, there's really only one kind of important role and that's this idea of validators. So in Ethereum you have all of the miners running your contract, which is why it's so slow.
00:02:27.078 - 00:03:37.650, Speaker A: Instead for Arbitrum. Each Arbitrum contract has a set of validators who are the people who are actually running the code for your contract. And the really cool thing that Arbitrum provides is this any trust guarantee, which is that any single validator can ensure that the contract will run correctly and compare that to something like kind of if you compare that to other scaling solutions. So for instance, side chains that use something like a Byzantine fault tolerant, essentially a separate consensus mechanism where you need two thirds of the validators to be honest, which is kind of a huge assumption and it's very easy to worry, well, wait a second, what if they're not as friendly? They can just steal all of my money here. Allowing anybody to ensure the correctness is really key. We have this validators, we have this idea of kind of dispute resolution. What do the validators do? How does this work? So first of all, the validators are incentivized to not fight to act honestly.
00:03:37.650 - 00:04:40.150, Speaker A: And so in the happy case, most of the time parties aren't malicious and the first thing we want to do is be really fast when nobody's acting maliciously under normal conditions. And so we can have a set of validators, for instance, that most of the time they're all going to be up and available and they can just unanimously sign off and say, hey, we agree, this is the correct next update and the system will accept the state immediately. So there's no challenging, there's no disputes because everybody's set up in advance that we all agree. If you don't have that, then you go into this fallback system that I described earlier where one validator has to say, well, I assert that the new state will be X and somebody else can challenge. So I'm not going to go into the details of how all this works right now. I'm just giving you a little bit. My co founder Ed Felton is going to be giving a talk tomorrow afternoon where we go into more of the technical details.
00:04:40.150 - 00:05:43.158, Speaker A: More of what I want to talk about today is how the hell do you actually make use of this stuff? A lot of kind of the weirder, more technical layer, two solutions, building on top of Ethereum are pretty tough to use. And one thing that's really important to me is to build a solution that's actually kind of accessible to developers that people can actually use. So what do we have today? First of all, what's actually out of what I'm talking about? What's out there, what's usable? So we have a public alpha that's been out since around June and that's all open source on GitHub. Anybody can check it out. URLs at the bottom we have the ability to support solidity contracts so you can easily compile take an existing DAP and port it onto Arbitrum. And I'm going to walk through quickly if we have time, which we should, what that process looks like because it's really simple, which is nice. These contracts can send and receive tokens and so they can kind of interact with the regular on chain contracts.
00:05:43.158 - 00:06:27.270, Speaker A: And so you can have this layer two scaling and this extra speed boost for your contract while still being on Ethereum and having the advantages of being on Ethereum. So a little bit about what the parts are of this system, what's the code, what am I actually saying you should use and how does your contract involved. So there are really kind of two halves of the story. There's the half about kind of what the validators are doing, what your smart contract is doing, and then there's the half, which is your front end. So you're writing a front end. Your user is interacting with it, it's interacting with your contract. What does that look like? So I'm just going to do kind of a quick overview of those chunks.
00:06:27.270 - 00:07:12.610, Speaker A: So first of all, we start with a solidity contract. We run it through the Arbitrum compiler, which transforms it into this kind of weird, magical Arbitrum program and then we deploy it. You have a set of validators, the program is distributed to all of them and they post on chain with essentially a commitment to this contract. So they say, hey, we want to create this contract. Here is a hash of it. We're barely doing anything on chain, just this small transaction to commit to say essentially we all agree what code we want to run, we're not revealing what it is, but we all agree that this is the same code. And then these validators start asserting.
00:07:12.610 - 00:08:03.800, Speaker A: So they're in the happy case, they're all unanimously asserting together, we're not even on the blockchain, but we're getting finality, we're getting security and it all works. And so then what does the front end side looks like? So now we're talking about the user. So kind of the standard for Ethereum is you're using Web three, maybe you're using Ethers JS. If you've done any Ethereum development and web clients kind of you're using one of these libraries and they talk to the Ethereum blockchain. Well, we don't want to change that experience, we just want to move it over into layer two. And so what we do is we have a custom client called the Arbitrum provider, which essentially bridges the gap between your front end and Ethereum. And what that means in practice is you could take an existing front end, plug in five new lines of code and suddenly that's a front end to an Arbitrum contract with no further changes.
00:08:03.800 - 00:08:50.370, Speaker A: And so just really to emphasize, this is kind of quite a small amount of work and you'll see how much in a second. And yeah, all of this is live, all of this is usable. There are a couple of different demo applications that are on the GitHub that are easy to deploy. They're very simple. They're just to demonstrate essentially what the different components are and how they work and hopefully we will see some even cooler stuff built on it during the hackathon. So that is that. And now I want to take a little time and just walk quickly through what it actually looks like to take an existing application and port it onto Arbitrum.
00:08:50.370 - 00:09:25.814, Speaker A: So let's see, I'm going to make this big and hopefully is that big enough to read? All right. There is nothing worse than having way too small text on a slide. Actually, let's make that even bigger for the hell of it. So what do you do? You want to actually start using Arbitrum? You want to deploy on it? What does this look like concretely? So we're going to use a Truffle based project. If you've done any ethereum development, that's kind of the de facto standard right now. There are a few competitors that are up and coming, and we'll support all of them. But right now it's truffle.
00:09:25.814 - 00:10:12.090, Speaker A: You have some sort of front end and you want to start and this is all just a regular ethereum DAP. And now you're like, okay, I want to use this magic layer two stuff. I want to have way more scalability for my software without compromising security at all, without a separate blockchain, without a separate consensus, without some weird cryptography, just a few clicks and suddenly have this further level of scaling. And so what does that look like? Well, first we need to actually deploy our contract to the Arbitrum backend. So we add a few lines. We add the Arbitrum network to Truffle. So normally with Truffle, you deploy on Robstein, you deploy on Mainnet, you deploy on Ganache.
00:10:12.090 - 00:10:45.260, Speaker A: So we're just adding kind of a new deployment target for your code. And so all of the rest of your Truffle project is the same. All we're doing is changing the network. And that is it. And that will essentially kind of take your arbitrary solidity contract and prepare it to be run in layer two. And so you can do this with contracts that you have today. And it goes super smoothly with a couple of restrictions that are listed on this website if you want to go into detail.
00:10:45.260 - 00:11:18.040, Speaker A: So that's the back end that's done. We have our kind of test client, which is let me just scroll down here. Yeah. So you run Truffle migrate, you select the network, and it produces this contract AO file, which is your Arbitrum contract. So now that you've designed that, that's essentially ready to be launched. You're now ready to create a VM. And for the purposes of kind of the current state of the alpha, there's just a magic command to do that for you.
00:11:18.040 - 00:11:55.140, Speaker A: And so what this command here will do is it will, on your computer, launch an entirely fresh blockchain using Ganache launch. Well, in here we say three validators who are all independently running and talking to each other, and it'll set them all up with your contract IO. So it's just going to be kind of a one click in the current alpha to set up everything. And that's all. So now you have an entire Arbitrum contract running off chain, all set up on your computer. So that's the back end side. Next up, you have this existing front end and you want to port it.
00:11:55.140 - 00:12:29.926, Speaker A: So you are, for example, using Web three JS. And so somewhere in your code, you have a block of text that looks something like that. It tries to connect to MetaMask if that's around. If not, it does some fallbacks. It looks for kind of whatever your provider is. If you've done any blockchain programming then you've seen code like this in your front end where the browser app, maybe it falls back to infura. It's looking for a connection to Ethereum but now we need it to not talk to Ethereum.
00:12:29.926 - 00:13:11.580, Speaker A: Now we want to port it over to this entirely different backend. And the trick is we can do that extremely simply. So all we need to do is we build this new Arbitrum provider and we say, well, in this first segment here we have a connection to an Arbitrum validator. We also pass a connection to Ethereum because we need both of these because Arbitrum isn't a separate network, it's just part of Ethereum running on top and so the provider needs to talk to both. So we swap that in. Instead of web3 being a direct connection to Ethereum, it's now a connection that goes through Arbitrum and we're done. And that is the entirety of the process for deploying in layer two.
00:13:11.580 - 00:14:05.370, Speaker A: And just to emphasize the cool thing here is that this is accessible. That this is something that can be applied to new contracts. What we want to see is we want to see that layer two scaling is not only accessible to companies with large research teams who invest and spend months in building this stuff. We want this to be tools that are accessible to people today or within the next couple of months when we're ready for full deployment. And that is kind of the trick, is to make the experience as similar as possible to your existing Ethereum developer experience. You don't need to learn anything new. You can use all your existing tools but your contract is running in this totally new setting entirely seamlessly.
00:14:05.370 - 00:14:48.518, Speaker A: So yeah, so that's the developer experience and we hope that that was kind of interesting. Layer two is like a whole new world into the Ethereum space. There's been development in this sector for a couple of years now. We're nearing the moment where some of this stuff actually becomes usable. And it's going to be necessary because Ethereum doesn't scale. And so within the next kind of if there's ever going to be adoption of smart contracts then this stuff is critically necessary. Right now DApps get excited when they get in the kind of thousands of users is a huge win.
00:14:48.518 - 00:15:32.422, Speaker A: But when you look at kind of standard applications, that's nothing. And when you have things like CryptoKitties, for instance, as the typical example of you have an Ethereum DAP that actually starts to get adoption suddenly the entire chain grinds to a halt. And so having these solutions are kind of fundamental to being able to actually produce DApps that will really kind of survive adoption. So yeah, that is my spiel. Happy to answer any questions or let you guys get to hacking or get to sleep. So thanks. Yeah, absolutely.
00:15:32.422 - 00:16:18.382, Speaker A: So do you know how Ethereum two will affect? Yes, I will give my view of essentially the relationship between layer two and Ethereum 2.0. So number one, Ethereum 2.0 is not going to be generally usable for at least the next couple of years and we need a solution before then. Number two is that neither the sort of techniques that I described or Ethereum 2.0 alone can actually scale enough for, let's say, global adoption. And so in the long term, fundamentally, both solutions are needed. This is only made better by a faster layer one.
00:16:18.382 - 00:17:04.780, Speaker A: And fundamentally, the promise of layer two is that no matter how fast your layer one is, your layer two will always be better because fundamentally it's an enhancement layer and so it'll always be necessary. The slightly more technical answer to that is that we and many other people in the Layer Two community are extremely excited about Ethereum 2.0 Phase One, because it does this magic thing, which is it suddenly says that the ethereum blockchain can guarantee that massive amounts of data something like last I heard, it was like ten megabytes per second of data is available, unknown to all of your users. And you can do some amazing layer two scaling based off of that. And so we are all extremely excited because it'll only make all of these solutions better.
