00:00:00.170 - 00:01:12.846, Speaker A: Welcome to our workshop. So I'm TF from text and network. And also here's our team member, Chris. So in this workshop we'll be introducing how to build what Text and Network does and in what scenarios should you use Textile Network and how do you build a privacy preserving and computational powerful Web Three services. Okay, so I know you have heard a lot of projects that are focusing on solving the scalability of the blockchain well, Texan Network is not addressing the network performance in term of TPS. Texan Network is focusing to provide a more powerful version of Smart Contracts and we are focusing on the performance of individual Smart Contracts, which in terms are those aspects. So here's a comparison between the Web Three applications and Web Two applications in some aspects and I know this is not a very fair comparison because the main breakthrough of Web Three is trustlessness performance.
00:01:12.846 - 00:02:52.110, Speaker A: It suffers a big disadvantage. For example, the time and space resources you can use in an individual Smart Contract is very limited because of the limitation of gas fee, file size and also the functionality are very simple and basically focus on crypto and the very basic business logics while lacking off some rich functionalities. That is mainly due to the consistency requirement and also because of the consensus mechanism we have to wait for the block confirmation and also it's very difficult to protect your privacy on the blockchain. So we have paid a very heavy price to achieve the trust and Texan Network is aiming to solve the performance and privacy issue for the individual. Our solution is to build a layered architecture for the apps and by moving your business logic from onchain to off chain, we don't have to be restricted by the consensus mechanism of the Smart contracts. While we are using the trusted execution environment technology which is a privacy computing technology, we can guarantee the application's trustlessness in terms of confidentiality and also integrity. So in conclusion we put them off chain so we will have a higher privacy and we can build interactive applications.
00:02:52.110 - 00:04:18.250, Speaker A: Well, by using the PE technology we can guarantee the integrity and confidentiality of your application even without the blockchain. So here's the idea of a layered architecture of the envision of the future applications. Today you already see a lot of middleware infrastructures acting a very important role in our DApps, for example the Oracles or the IPFS. Well, in the vision of Web Three we are still lacking one very important cornerstone which is computation. Today they are most built on the layer one on layer one blockchains. Well to support more meaningful to support more meaningful applications, for example like games, interactive games, we do need an infrastructure that can do some high performance computation while keeping the user's data privacy and Texan Network is aiming to becoming this role. So as you can see, we pull the computation from in the middleware Texan Network well, only when you need to generate a finalized state? Will you need to generate an on chain transaction or in other words, the relationship of Python network to a blockchain is like a backend to a database.
00:04:18.250 - 00:05:27.542, Speaker A: You only need to write a finalized state on chain while the computation can be completely off chain and protected by the privacy computing technologies. And let me introduce you the T service, which is the application running on the middleware textile network. T service is for trust services and it's a bit different from the on chain smart contract. First, it's interactive based on a request response based protocol and we also wrap it into a red four API, just like calling a web two service. But it's trustless. And also due to the nature of Pixar network, we are not a layer one blockchain, we are stateless, but we provide very convenient way of interacting with layer one blockchains. Third, because we are opting and using the privacy technology, privacy computing technology, we guarantee your data privacy in your applications and the privacy data during transmission, during computing are private, unless the developer choose to review it.
00:05:27.542 - 00:06:36.918, Speaker A: So it's opt out privacy. So, on the development wise, you can sync the T service like a type, you can sync pixel network like a typo oracle. But instead of feeding the internet data, we feed you the result for your entire business logic and which guarantee the data privacy and the computing performance in term of the computing and storage resources. So, we migrated on Python interpreter environment inside the trusted execution environment. Currently we are using Intel SCX and you can develop the trusted applications using one of the most popular language which is Python service oriented development framework and also supporting a lot of third party libraries. So, the example, let me begin with our Hello World example on Pixar network, which is called the Millionaire problem. It's one of the most fundamental privacy computing program proposed by Professor Yoti Ji.
00:06:36.918 - 00:07:32.702, Speaker A: And the problem is, assuming there are two millionaires, they want to know which of them is wealthier without revealing their actual worth. So, in an ideal case, you want a judge and both parties can trust it and both party and guarantee is honestly executing the business logic and well keeping their data privacy blockchain is designed for trust. However, it's very difficult to implement on today's architecture due to privacy issue. Well, in our case on Texas network, because by default we can guarantee the data privacy. You can implement such a hollow world application in a very simple architecture. Just like imagine you are developing a centralized application, the two users don't trust each other, but they do trust you and they send their privacy data to the application and the application will serve as a judge. Tell them the result.
00:07:32.702 - 00:08:01.490, Speaker A: It's very straightforward. Well, on Pixar network, we execute those applications inside the security enclave. So you can guarantee three things. First, you can always guarantee the textile node is honestly executing your code. And secondly, you can guarantee the integrity. You can always guarantee the node feed you back the correct result without tampering. Thirdly, it can guarantee the data privacy during execution.
00:08:01.490 - 00:09:06.374, Speaker A: And the way user interact with hexa network is based on interactive protocol. And all the entrance of the T service are marked by a URL, a web3 URL just like the IPFS one. And using multi hash, it indicates the hash of your T service code. Just like because it's compatible with IPFS, you can directly serve the code on IPFS and both users will establish a secure connection with the encouragement in the text node. And just like you can imagine it's like an HTPs handshake and the node the computer provider serving as a middleman, although he's a service provider, it cannot read any private data submitted by user or during the computation. And the code for solving the miniature problem is very simple. So in our case, we have two entrance.
00:09:06.374 - 00:09:17.930, Speaker A: First, both users submit their submit their worth and the function is called submit value and you write a Python function. And secondly, after both users have submitted.
00:09:18.010 - 00:09:20.270, Speaker B: Their worth, both millionaires.
00:09:21.970 - 00:09:22.942, Speaker C: Send their worth.
00:09:22.996 - 00:10:02.470, Speaker A: And they will call another function called get result. And we directly feed user the result by very direct business logic. And all those code are running inside the security enclave, which means the node will not be able to read or temper the computation and you just feedback the user result and both users will be able to decrypt the result on their client side. Yeah. And when you are developing key service, there are several key concepts. First, request and response. They are in JSON format.
00:10:02.470 - 00:10:40.634, Speaker A: They carry both confidential and non confidential data. And there's a certain field called data which is encrypted, which contains the encrypted data. And only the user and the secure enclave have the decryption key. Any third party, including the service provider, will not be able to decrypt them. And the IPID means the hash of the code is the only Identifier of the code. So when two users are calling the same IPID, we can guarantee they are calling the same key service. And also UIL is consistent with text header and the code of the hash and the function.
00:10:40.634 - 00:11:27.410, Speaker A: And the user identity is represented by ECDSA keypad. And later you can find them on our developer documentation and also Texas Network support. Temporary storage mechanism causation we keep them by default, seven days by default. And you should not rely on it will be available during your Pservice lifecycle, but you should not use it for permanent storage. And for the Python develop framework, we call that PEXA and which in short of Python plus PEXA, that is a Python runtime environment. We migrated inside Intel SDX and it's derived from Python 2.7. And in addition to Python 2.7,
00:11:27.410 - 00:12:10.374, Speaker A: we have added some crypto and blockchain library support. So for example, you can directly generate signatures, generate wallets inside the Python code and due to the nature of Tservice, we also removed the file system network and process access. So it's pure computation. And also we are keep expanding our framework, adding vertical to add some third party libraries to support more functionalities on Tesla networks. And I'll briefly introduce how you interact with a layer one blockchain from Tessa network. Chris will later show us the details. So the basic idea is very robust and simple.
00:12:10.374 - 00:12:44.154, Speaker A: The idea is generating signature. So the problem we are solving is how can we trigger a transaction on layer one? Or in other words, how can we verify whether a result is generated from Texas network or is a forged one. And the solution is we generate signatures inside the PServices, inside the security encolase and later we could verify such signatures on Solidity using EC recover function and then you can authorize transactions. For example, assuming there are two players.
00:12:44.202 - 00:12:45.986, Speaker B: Want to play a poker game.
00:12:46.088 - 00:14:15.146, Speaker A: Poker game is the multiplayer poker game is not very easy to be built on layer one because it should be interactive and also you need a certain level of privacy. Well, on Texan network you could just build in a very straightforward business audit. Well, after the game is over, the taxi network could generate a signature and the winner could submit that signature to Solidity smart contract and the Solid smart contract can verify that signature whether it's coming out of PEXA network and execute the transaction. For example, who will take the chip on the table? We provided a library called PEXA ECDSA which is compatible with Solidity's easy recover. And because of our private preserving feature, the user could safely submit their private key into the T services and the T services will generate the signature for them. So, some ideas of building a taxi network first, game and NFT are always a hot topic and especially for the games, today's games are suffering from some limitations when are building on blockchains. For example, you may easily build a chess game on blockchain, but if you want to build a card game which requires interaction and requires a certain level of privacy, it's much easier to be built on Texas Network.
00:14:15.146 - 00:15:11.546, Speaker A: And also some developers are building some gamification type know for example, in the previous East Global there were people building the Prisoner Dilemma game on Texas Network and combine it with yeah, and also collaborate computation and DeFi privacy and also identity. For example, how do you authenticate a user without revealing his details? It's like the T service will tell yes or no, but the user won't need to reveal their actual privacy data. Yeah, and let's begin with the demo. So we have two demos. First demo is about how you set up an SDK and execute some basic text and network request. Second demo is how you authorize layer one transactions.
00:15:11.658 - 00:15:12.830, Speaker B: So Chris.
00:15:26.020 - 00:16:15.920, Speaker A: Okay, so first we connect to our code and to send a request on Texas network. You can set up the Texas SDK on our documentation. And there are three very simple steps to send a request. First, you import our SDK in your local Python, although it's Python, but it's running on your locally on the SDK. And the second step is to generate your identity. And we already support a function by initiating a request object. And if your first time using this, the SDK will automatically generate a key pair, elliptic curve key pair representing the user's identity.
00:16:15.920 - 00:17:13.156, Speaker A: And go ahead, we call the send function, which will carry the Python code with it, by the way. So due to the nature of Texan network, there is no deployment necessary for the T services. And on protocol wise, the user is required to carry your T service code inside your request to the node. And the node will hash your code and find out the app ID. And engineer wise, our node will cache the code for the T services. So you don't actually need to submit every time, but by default, you can just submit the T service code as a parameter and you'll call the send method to send a request. When sending the request for the first time, the Texa network will do three things.
00:17:13.156 - 00:18:09.700, Speaker A: So first it's called a remote attestation. That means your computer will establish SSL type connection with ankle in the Texan node. So after the handshake they will do like DC helman key exchange and they will negotiate AES 128 key communicating directly between the user and the enclave. No one else in the world have that key. So yeah, it's basically like SSL handshake and all your traffic is communicated by is encrypted by as. And as you can see, there are some debugging data, but the request contain a status and a response. And also most importantly, there is a data field and which contains the secret data in your request which is encrypted by AES.
00:18:09.700 - 00:18:29.260, Speaker A: And also there's a response. Response will also be carried and you can decrypt them and process them in your Python code. And next, Chris will demonstrate how to generate a signature and verify it on solidity.
00:18:30.000 - 00:18:30.910, Speaker D: Go ahead.
00:18:31.600 - 00:18:34.540, Speaker C: So this contract that we just executed.
00:18:35.920 - 00:18:37.950, Speaker B: What it is, is basically just.
00:18:42.780 - 00:18:43.144, Speaker E: This.
00:18:43.182 - 00:18:57.570, Speaker C: Right here, it calls this ECDSA signing key each sign and it generates a signature and it's signing this message up here. This is Abcdeft, and then here's my private key.
00:18:57.940 - 00:19:01.056, Speaker E: And so the signature is returned and.
00:19:01.078 - 00:19:05.628, Speaker C: Then it's added to the response. And so if you look up here.
00:19:05.734 - 00:19:09.936, Speaker B: The decrypted data, this is the response.
00:19:09.968 - 00:19:12.656, Speaker E: From the taxa server that's been decrypted.
00:19:12.848 - 00:19:17.056, Speaker C: And so right here is our signature.
00:19:17.168 - 00:19:18.116, Speaker B: And so what we're going to do.
00:19:18.138 - 00:19:19.750, Speaker E: Is verify that this is.
00:19:21.720 - 00:19:23.640, Speaker B: A valid etherm signature.
00:19:24.380 - 00:19:28.344, Speaker E: We have this solidity contract that has.
00:19:28.382 - 00:19:31.544, Speaker C: Been deployed to the testnet and it's.
00:19:31.592 - 00:19:41.704, Speaker B: Simply just we have this is valid signature well down here where is it? Is valid signature?
00:19:41.752 - 00:19:41.964, Speaker F: Yes.
00:19:42.002 - 00:19:43.580, Speaker B: So it takes two arguments.
00:19:44.980 - 00:19:47.776, Speaker A: The message, the original message, which is.
00:19:47.798 - 00:19:56.724, Speaker C: Just Abcdfg, and then a signature, which.
00:19:56.762 - 00:19:58.310, Speaker B: I'm going to paste in here.
00:20:01.000 - 00:20:11.800, Speaker C: And then we can call it and the return value is true. That's because this signature is valid.
00:20:12.300 - 00:20:12.664, Speaker E: Yeah.
00:20:12.702 - 00:21:03.610, Speaker A: So the key is first, inside the Texas T service, you use the ECDSA library to generate a signature, and it is safe for the user to submit a private key inside the T service because it's entirely running in the security enclave. And after you generate a signature inside the T service, you output the T series inside the and if you want to verify the signature, you call the Ecrecover in Solidity, and the format is entirely compatible. So the easy recovery will tell you whether the message is legit generated from the text IP service. So that's a way you authorize a transaction on layer one.
00:21:05.500 - 00:21:06.250, Speaker D: Yeah.
00:21:14.080 - 00:21:46.802, Speaker A: Okay, and here are some useful links. So for the developer documentation, go to Das Texas Network. And also you can always go to our booth and first floor. We are happy to answer all your questions in your development. And also our ending days will be on discord to answer your questions. So, yeah, please mark those link. And happy hacking.
00:21:46.802 - 00:21:47.960, Speaker A: Thank you, guys.
00:21:49.450 - 00:21:50.310, Speaker D: Bye.
00:22:13.950 - 00:23:03.500, Speaker F: We refer to it as a natively verified bridge. These bridges are like light clients IBC. They're great because they're verified by the chain's underlying validator set. So you're not adding any additional trust assumptions outside of the ones introduced by switching domains inherently. The other great thing is you can kind of pass any type of data between these two domains using this system. Unfortunately, these bridges are really difficult to create because they're heavily dependent on the underlying consensus mechanisms and the underlying chain to like, I can't just take IBC and now use it for my ETH to avalanche bridge because that's just not how ETH or Avalanche works. So they have to be kind of developed in a bespoke way.
00:23:03.500 - 00:23:34.760, Speaker F: The next kind of bridge is called an externally verified bridge. What's great about these bridges is they're portable between all domains, so they pretty much will work the same regardless of what chains are connecting. You can pass general data between them. Unfortunately, the concession that you're making when you're using this type of system is that you have introduced a third validator set that isn't necessarily the same as your origin chain validator set or your destination chain validator set. And that can be problematic because.
00:23:38.410 - 00:23:38.774, Speaker D: The.
00:23:38.812 - 00:24:23.534, Speaker F: Security in all of these systems is only as strong as your weakest link. And so when you've added an additional validator set, that's really what's holding the security of all of your payments. Shout out harmony. The next one is locally verified bridges. These are bridges like atomic swaps, where basically you take some transaction where you want to go from chain A to chain B, and instead of including everybody in the chain and including it as part of the state, you kind of match up to somebody else who's willing to go the opposite way, and you swap funds. This is great because you're not really adding any trust assumptions. Basically, your counterparty will always verify that you did something correctly.
00:24:23.534 - 00:24:43.660, Speaker F: They usually happen through some kind of commit and unlock mechanism. The downside is it works the same between all domains. Like, you really only need a hash function in the signature for the most part. The downside is you can't really pass complex data around because that doesn't translate easily to a two party system.
00:24:46.270 - 00:24:46.634, Speaker D: Yeah.
00:24:46.672 - 00:25:39.978, Speaker G: So Lane covered, externally verified and locally verified. And so you can see that externally verified, it's quite extensible and portable, meaning you can sort of pass any type of data and move it to any type of chain. But it's insecure for reasons that you're trusting another external party with your funds or data. And then she also touched on Locally Verified, which is, I guess, very secure and minimally trustless, but not very extensible. And so we'll see that optimistically verified bridges are somewhere in a middle ground between these two things and can achieve both of these just kind of at a high level. The way that an optimistic bridge works, specifically, I guess we'll talk about Nomad is that someone from the user perspective will send a message, and we'll have an off chain actor pretty much attest to that and say, okay, this user sent this message. Let me sign a piece of data which attests to this message.
00:25:39.978 - 00:26:35.630, Speaker G: And so we'll post that on the other chain. And the other chain, before accepting it, will start a fraud window and basically say, okay, within this amount of time, we'll let someone dispute it and submit a fraud proof which will basically tell the protocol, hey, if this attestation was invalid, don't listen to it and disconnect from the messaging channel. The reason why this is more secure, though, is that with something like a multi SIG, which is an externally verified example, you have basically a K of N honest actor assumption. If you have a three of ten multisig, you need at least eight honest actors. As soon as you have seven, there's now three malicious actors, which is enough to compromise your multisig in an optimistic verified bridge, then you really only need one honest actor to maintain liveness. As long as there's one honest watcher which is inspecting these active stations from the updater, you can assume that your funds and data are safe.
00:26:37.730 - 00:26:43.860, Speaker F: So does anybody have any questions right now about the different types of bridges before we move on?
00:26:47.510 - 00:26:48.260, Speaker H: Yes?
00:26:49.990 - 00:26:56.680, Speaker G: Yeah, sorry, maybe it wasn't too close. What part did I miss?
00:27:00.730 - 00:27:01.480, Speaker D: Yeah.
00:27:06.410 - 00:28:00.826, Speaker G: That'S a good point. So, I mean, like, at the moment, nomad. For example, a watcher is a permissioned role where it's like a whitelisted role, and if they submit an attestation of fraud that is enough for the protocol to disconnect. Eventually this will be something that's permissionless, it just kind of like, takes a lot of engineering work to get there. But the way we think about this specific trade off is that at the very worst, if you're a malicious watcher, you can grief the channel, but you can't actually steal funds. And so we think that this is a more desirable trade off than permitting some kind of scenario where you can actually steal user funds. Are there any other questions? A little bit.
00:28:00.826 - 00:28:09.760, Speaker G: I know we're having this problem here's. Sure.
00:28:10.610 - 00:28:10.974, Speaker D: Yeah.
00:28:11.012 - 00:28:49.210, Speaker G: So it's a lot like sort of the way an optimistic roll up is modeled instead of with an externally verified bridge. Let's say you have a multi SIG. If the threshold number of signers sign off on something, that's kind of what serves as your proof that this event really did happen on the other chain. We kind of flip that model and we'll have basically one signer attest to something, and we'll post it on the other chain and let a committee of watchers essentially inspect this attestation and say it's either valid or invalid.
00:28:50.510 - 00:28:50.886, Speaker D: It's.
00:28:50.918 - 00:29:26.120, Speaker G: Basically you give the watchers the power to veto something as opposed to giving someone the power to actually say that it's correct. Right now they are whitelisted parties. So a lot of l one teams want to run their own watchers. A lot of DFI apps, for example, want to run them as well. We want them to be such that the incentives are already aligned, but eventually this will be a permissionless role. So at the moment, it's a whitelisted thing now. Go ahead.
00:29:27.530 - 00:29:27.894, Speaker D: Yeah.
00:29:27.932 - 00:30:10.062, Speaker G: So the dispute window for Nomad right now is 30 minutes. A lot of people ask, why not seven days, I think for optimism or Arbitrum. The reason why it's this long is that the process of actually proving fraud is much longer. There's a lot of transactions you have to submit on ethereum. And from what I kind of understand at this point, there's also some social coordination aspect for us because it's a whitelisted role and you're just submitting an attestation that fraud happens. We don't need nearly as much time. And so really the way we parameterize the fraud window is just it's based on the economic cost that it would take to censor the chain.
00:30:10.062 - 00:30:17.270, Speaker G: Essentially, if you're a watcher and you need to submit a fraud proof, how much would it cost if you're trying to censor that fraud transaction?
00:30:20.570 - 00:30:21.078, Speaker D: Cool.
00:30:21.164 - 00:30:27.082, Speaker F: We'll leave more time for questions at the end, but I'm going to keep it moving for now, so hang on to them.
00:30:27.216 - 00:30:27.562, Speaker H: Okay.
00:30:27.616 - 00:31:38.030, Speaker F: So another important concept that exists in the cross chain world that doesn't exist in the single chain world, the regular DAP world is asynchronous solidity. And basically what I mean by this is the states of the two chains that you're connecting do not know about each other. So if you think of the example of an AMM? Well, why does that work as well as it does on ethereum? It's because when you have a transaction, you have solo read write access to the state of the blockchain, which means that constant product formula can remain constant because the liquidity is always traded equally. If you're building like a cross chain AMM, that same assumption does not hold. So you can't say that like oh, I have full access to trade USDC on Matic for USDC on optimism. And it happens as soon as I submit my USDC on matic because the optimism chain has no idea that you wanted to start this transaction in the first place. So these are the types of things that you have to be aware of when you're developing cross chain applications that you may not have had to think about when you're developing regular DApps.
00:31:38.030 - 00:32:32.490, Speaker F: Asynchronous patterns are very common in regular web development. So this is a direction that I think is useful to go in, but it is something that is different than most of the tooling that is available, most of the ideas and development patterns that are commonly used. So now we're going to dive in a little bit to building a Zap and kind of what that looks like. So first, what is a Zap like? What does the anatomy look like and the architecture? You have basically a contact on the sending chain and the receiving chain. And then you'll submit your transaction to the source contract on the sending chain, which will then call your bridge. In this case, it's connect. That happens to be the one I'm most familiar with and you call XPAL, which then will initiate a cross chain transaction.
00:32:32.490 - 00:33:45.000, Speaker F: This is where the Asynchronicity comes in. As that transaction is propagated across to the destination chain by a network of relayers and then validated either by the nomad timeout or somebody else is willing to take on that risk for the timeout, then the action is propagated to the target contract. So there's also another concept in this crossing development platform with connects about authenticated and unauthenticated data. And what that means depends heavily on the optimistic timeouts because we are built on top of nomad, there is latency built in as part of the security mechanism. Again, optimistic systems in general use time as a way to gain security. Like if nobody submits a transaction or disputes that something has happened within a certain window, then you know that that data has been authenticated. Because the assumption is there are enough actors in the system who are incentivized to have correct data that if it is incorrect, somebody will say something.
00:33:45.000 - 00:35:00.634, Speaker F: So in Connects we have this concept of authenticated data and what that really means is like permission calls. So when you're executing a cross chain transaction, you'll want to make sure there are some calls where the data that you're using is completely fungible, like a token transfer you don't really need that data to be authenticated. However, in contracts that check like message sender, you need to make sure that that data has gone through the fraud proof window so that you know or can assume that then it is authenticated by the time you're acting on it. For example, if I am doing cross chain governance, I really need to make sure that I know that the data that is coming from some chain to the target chain has gone through that fraud proof window. Otherwise it is spoofable by the relayers. It doesn't matter if it's spoofable for transactions that are completely like fungible, again, token transfers, but for something that is more sensitive, you have to make sure you have that extra security. So yeah, then unpermissioned calls are calls where you can go from the source to our relayers, obtain the target all pretty much immediately as immediate as blockchain gets in the time span of two on chain transactions.
00:35:00.634 - 00:35:07.310, Speaker F: Whereas again, permission you have to wait before you propagate the data for it to go through that fraud proof window.
00:35:08.530 - 00:35:09.280, Speaker H: Yes.
00:35:12.130 - 00:35:13.640, Speaker D: All like.
00:35:35.230 - 00:36:09.110, Speaker F: So the actual authentication depends a lot on how the target contract is implemented. We'll walk through an example of this in the simplest way is the message sender. So we will pass through the original message sender from the origin source chain. But any relayer, if you don't wait for this data to go through the fraud proof window, could insert any message sender that they want because nobody's challenging on it. It hasn't been submitted as correct by the underlying system. So that's why you have to make sure that you're waiting.
00:36:13.930 - 00:36:47.070, Speaker G: Yeah, I think a good example here is think about a token bridge. So there's like two token bridge contracts and ultimately when you decide to send some assets to another chain that's you calling the token bridge contract, which calls our underlying message layer. And so the message sender ends up being the token bridge router on ascending chain. And so that gets wrapped up in the message. And so basically the token bridge router on the other chain will only accept the message if it's from the other token bridge router.
00:36:52.650 - 00:36:53.110, Speaker D: Correct?
00:36:53.180 - 00:36:53.800, Speaker G: Yeah.
00:37:05.050 - 00:37:05.800, Speaker H: Yes.
00:37:07.850 - 00:37:11.190, Speaker F: Oh, that you're gonna new DL.
00:37:17.490 - 00:37:28.240, Speaker E: Value and then but also.
00:37:31.890 - 00:37:32.640, Speaker D: Like.
00:37:35.430 - 00:37:42.420, Speaker F: No, the chains will not know about each other's state. Like they'll only know what data you've passed through.
00:37:44.630 - 00:37:45.138, Speaker D: Cool.
00:37:45.224 - 00:37:45.860, Speaker H: Okay.
00:37:48.310 - 00:38:28.242, Speaker F: Now we're going to walk through some example codes. The example, I'm just going to lay it out for you. It's very simple. It's pretty much just like set value on destination chain contract from source chain contract using connect. So here we have some example solidity code for how you would integrate that. The source sol is basically what you would call that's your entry point for this user flow where you call this with your intended updated value on the origin chain. This will then create the parameters to Xcall, which is the function.
00:38:28.242 - 00:39:36.802, Speaker F: That will initiate the cross chain transaction. It's designed to mimic the lower level solidity call pattern, but cross chain X and then you call Xcall. Once you do that, the relayers in our system will automatically pick up that this transaction has been submitted and simulate it on the destination chain. If it fails, then they know, okay, well, this is more likely a permissioned call or explicitly specified that it wants to use the authenticated data flow. And now I'll just wait for that to be fully propagated. Once it's fully propagated, meaning that the message has made it through to the destination chain via the Nomad system and has gone through the fraud proof window, then you can go ahead and call the updated value on the target contract. On the target contract, I'm not saying your name, but if you look closely at this modifier, this only executor modifier, you can see that the origin sender, which is the message sender on the origin chain, is asserted to some specific address and the same with the domain.
00:39:36.802 - 00:40:00.454, Speaker F: So again, if you're doing cross chain governance, I only want the Ave dow on main net to be able to influence parameters for the Ave contracts on polygon. Then I could assert that using something like this only executor modifier that exists on this update value contact. Does anybody have any questions before we dive?
00:40:00.522 - 00:40:01.140, Speaker D: Yeah.
00:40:05.830 - 00:40:16.920, Speaker F: Well, you can pass arbitrary data between chains, but you can't like, if you didn't pass it, the chain won't know about it. So you can read anything that you've passed through, but you're the one who has to initiate that.
00:40:32.030 - 00:40:32.538, Speaker I: Right?
00:40:32.624 - 00:40:42.960, Speaker F: Yeah, I mean, there's no, like, the chains that's the whole thing with Asynchronously is they are not composable. They don't know about each other. And so you are the one who has to pass that data through.
00:40:45.890 - 00:40:46.640, Speaker D: Yeah.
00:40:53.430 - 00:41:26.346, Speaker F: What do you mean? Can the parameters be changed? Yeah, well, I mean, it's your target, baby. You can do what you want. Yes. Sorry. So the question was, can the parameters be changed on the target contract? So if, like, I want to change the admin? Yes, you can. That's completely up to the implementer of the target contract. These origin sender and origin domain properties are just things that we expose when you make X call.
00:41:26.346 - 00:41:48.530, Speaker F: So when you create that Xcall contract on the source chain, that information about which chain it's on and who called that function is passed through to the destination domain. So that changes based on who calls it and where it's called from. Whether or not that matches with who the admin is on the target contract is up to the implementer.
00:41:53.350 - 00:41:54.100, Speaker D: Cool.
00:41:54.870 - 00:42:21.440, Speaker F: So there's an example repo here. I'm going to kind of exit this presentation and look at some of the other cool things that you can do with connects. So one of the other things that we're really excited about with our new protocol is the ability to do JS style solidity callbacks. So what does that mean? This actually may be more relevant to your use case, but basically sorry.
00:42:22.770 - 00:42:23.520, Speaker H: Okay.
00:42:27.250 - 00:43:24.322, Speaker F: So the source contract implements this interface called Icallback. The Icallback interface is right here. And what this means is this is any contract on the source chain that can process return data from some call executed on the destination chain. So when we execute arbitrary call data, we just use the dot call on your destination domain and then you get back whether or not that was a success and what the return data from that contact call was. If you have defined a callback when you initiate this call, an X call, then the protocol will automatically take the success result and the return data and propagate it back to the origin domain. So this could look like in this example, okay, I want to update some value, but I'm not going to specify a value. Instead, the target contact is going to randomly choose a value.
00:43:24.322 - 00:43:53.020, Speaker F: So I call change value, that will update the contract value from three till eleven or something. And then I've specified a callback that will emit an event with that new value. And so once that's changed, that information is sent back to the origin domain, where then I can say, oh great, the random value is eleven. And so that's kind of what I mean by solidity style callbacks. And you can see is there a question?
00:43:53.950 - 00:43:54.602, Speaker D: No.
00:43:54.736 - 00:43:55.130, Speaker H: Okay.
00:43:55.200 - 00:44:11.666, Speaker F: And you can see that here in the source they implements the callback interface. And this is the callback function where it decodes the new value that was set from the data and emits this event. Are there any other questions?
00:44:11.768 - 00:44:12.420, Speaker D: Yeah.
00:44:27.110 - 00:44:46.966, Speaker G: Exactly. The fraud windows. Let's just say that you wanted to build your own app. The fraud window that we have for our core contracts are 30 minutes, but you could technically deploy your own set of core contracts, change the latency and yeah, it's definitely configurable, depending on what level of security you want.
00:44:47.148 - 00:44:47.880, Speaker D: And.
00:45:03.730 - 00:45:11.562, Speaker G: We have our own Watcher implementation. This is what we provide to partners and other apps that want to run it. It's just running a docker image.
00:45:11.706 - 00:45:37.110, Speaker D: Yeah, construct.
00:45:44.930 - 00:45:45.342, Speaker H: Right.
00:45:45.396 - 00:46:33.060, Speaker F: So your first call would still have succeeded, but the sorry, repeat the question. Yeah, so the question was, if I have a revert on the target contract, what happens to the original transaction? Like what happens to the flow? Where does it fail and where does it break down? If you have a revert on the target contract, there's a fallback function, so any funds would just get immediately sent to your recovery address. It's prespecified, but if you have also specified this callback interface, the fact that it failed will still get propagated back to the specified callback contract. Are there any other questions?
00:46:36.790 - 00:46:37.540, Speaker D: Cool.
00:46:38.630 - 00:46:49.800, Speaker F: Yeah. So I'll just give you some updates on timelines then. We're finishing up our audits for this protocol, and it should be live yes.
00:46:50.970 - 00:46:51.880, Speaker E: Go back.
00:46:54.650 - 00:46:55.640, Speaker D: All back.
00:46:59.550 - 00:47:02.700, Speaker A: Yeah, we'll fix it.
00:47:08.290 - 00:47:20.100, Speaker F: In the middle of a workshop getting called out by my CTS unreal. Any other questions?
00:47:23.670 - 00:47:24.130, Speaker D: Cool.
00:47:24.200 - 00:47:55.340, Speaker F: Awesome. Well, I hope you guys learned a little bit about what goes into building a cross chain applications and the things that you should be thinking about. If anybody at this workshop has been contacted by Duck, he's over here in the back, and you guys could probably reach out to him and find him somewhere where it's more okay to talk. Awesome. Well, thanks guys. What.
00:48:08.390 - 00:48:27.560, Speaker B: Web Three native software distribution in just a few minutes? Basically, Web Three native ways to publish your apps and games using IPFS polygon and other amazing protocols. So definitely don't want to miss this. Come on over. If you want to publish software with your Ethereum key, come learn how. Room Three.
00:48:40.370 - 00:48:43.054, Speaker E: It had a few other people too.
00:48:43.092 - 00:48:52.298, Speaker B: That were going to mingle in here's.
00:48:52.474 - 00:48:56.240, Speaker E: Cool. All right.
00:48:58.050 - 00:48:59.840, Speaker B: Thanks again everyone, for coming.
00:49:04.770 - 00:49:05.520, Speaker D: Cool.
00:49:21.390 - 00:49:28.214, Speaker B: Sounds good. Well, welcome everyone. Super nice to see you all here. I'm Alec Co, founder of Alice.
00:49:28.342 - 00:49:31.982, Speaker E: This is Zach, a CTO, and yeah.
00:49:32.036 - 00:49:51.486, Speaker B: We'Re here to learn about Web Three native software distribution. And let's get right into it. So what is Web Three native software distribution? Well, basically a lot of elements that you already know like publishing fetching and secure updates from existing Web Two systems like GitHub or other auto update systems.
00:49:51.518 - 00:49:53.666, Speaker E: You'Ve used before, but also now we.
00:49:53.688 - 00:50:38.340, Speaker B: Can imagine new cool use cases like Dows coordinating software together. So if you imagine a Dow publishing a new version of an Ethereum client like GEF, that's what you could do with Web Three native software distribution. And then if you're monetizing apps or games for any type of asset, we have software licensed NFTs in our system that you can use as a form of DRM to token gate your application in. Again, a Web Three native way and native crypto payments. So why do we need Web Three software distribution? Well, right here we're still publishing everything on Web Two platforms. So we have some really amazing protocols here. Even Ethereum's Geth is built and published on Microsoft Azure Blob store.
00:50:38.340 - 00:51:40.398, Speaker B: Polygon. Boar uses GitHub releases, which is also ultimately Microsoft servers. We rely heavily on docker hub for managing infrastructure, especially things like Graph nodes, but it also goes down all the way to the end user from the emerging Web Three gaming stuff, mobile wallets that you download from centralized app stores, you name it. Pretty much everything is still being published over Web Two, so we're putting massive amounts of energy in a decentralization just to decentralize it at the distribution level. So we got to change that. And the issues with this include lots of the things you're already familiar with, but risk of compromise, censorship risk, availability, risk, and then if you're using payment infrastructure, all this stuff right now is centralized to Apple, Google, Meta, all of these companies that you have to ask permission for, and they take 30 to 50 plus percent of your take rate. So these centralized payment infrastructures, we got to get away from them, and then they take a high take rate anyway, so it's not very regenerative.
00:51:40.398 - 00:52:30.882, Speaker B: And what can we do now that we're in Web Three? So first it looks kind of familiar. We have to start with porting over all the common features from things like GitHub and Steam and Versal, those other types of platforms. That includes the ability to version, publish, fetch, and then securely update your artifacts, and having auto update systems, as well as the ability to manage team level and project level access control so that you can actually have an organization account and then separate projects underneath that have separate access control. But Valust is a set of tools that coordinate all these Web Three protocols together to make publishing in Web Three easy. And then once reported over, no reliance on a single entity for distribution, not even Vallast. All we're doing is pulling together all these protocols together. So there's no centralized thing.
00:52:30.882 - 00:53:04.958, Speaker B: Vallast IO is just a gateway. You can monetize your software directly now with NFTs. So again, no need to ask Apple or Google or anyone for permission, or even to have a bank account for that matter. You could just create a wallet, publish your software, set a price, and you're good to go. And then of course, DAOs can coordinate software releases. So these giant softwares that we all rely on, we can actually decentralize the publishing process for that a little more. And then we also have the ability to create super awesome auto update systems powered by these smart contracts and IPFS.
00:53:04.958 - 00:53:46.566, Speaker B: And the protocol fees can actually provide public goods funding. So revenue generated by software licensed NFTs can actually be pointed at things like radical Drips or Gitcoin grants. And so there's this connection between the Monetized software and the donation based Drip mechanisms that we have now. And so how does it work? Well, there's lots of different options. We make it pretty easy. But architecture essentially is such as you publish all the software on IPFS, everything gets archived on a filecoin for long term storage. And then we use Polygon and other EVM chains to checkpoint and handle the access control and versioning.
00:53:46.566 - 00:54:31.354, Speaker B: And then from there the Valis client and SDKs, everything like that is aware of all the latest releases. So you can say, hey, I want the latest version of Ethereum Gas 1.0.0, something like that. And then how do we use it? Well, we have a web front end CLI, a GitHub action for if you're already doing GitHub releases or if you're already doing your own system there, it's just copy and paste the workflow at the end to add it to your publishing step. And then we have TypeScript and go SDKs for all the developers that want to kind of dive deeper into the nitty gritty there and then so this is what the web app publishing page looks like. It's pretty simple. It's just account project the version and then you could drag and drop your assets from there.
00:54:31.354 - 00:55:16.234, Speaker B: So if you're a game developer, this might be the move for you to drag and drop your Unity build or drag and drop your static web app over into here and call it a day or a binary, whatever you want. Our CLI allows you to easily create and publish releases as well. And so here we have Vallast Publish, the organization account acmeco, and then the project is called Go Binary. And then the version publishing here is 1.0.0. And then I'm just publishing the disk folder that I built. So if you're publishing and building stuff, you could just point it there and you could also configure multiplatform releases. So if you're building for both Mac, Windows and Linux, the CLI lets you.
00:55:16.272 - 00:55:18.234, Speaker E: Actually configure which binaries go to which.
00:55:18.272 - 00:56:04.422, Speaker B: Platform and the Val system will know how to account for that. And then like I said, we have a GitHub action. So if you're already doing releases, this is a super simple example where basically it's just tracking the repository, go IPFS, and then anytime a release is made, it just takes that release and publishes it under Valid. So it's a super easy way to get started there if you already have an existing workflow. And then you can transition more into the web3 native workflows. And then again SDK super easy, all you need is a wallet. And then you could plug in IPFS nodes, your own RPC stuff, or you can use the default valus IO infrastructure and then you could find it at Valus IO.
00:56:04.422 - 00:56:31.700, Speaker B: The docs are pretty detailed, they go over the whole system as well as the different nuances. And then our discord is Valus IO discord. We're always super excited to help and we have teammates from around the world, so chances are someone's going to be awake. And then our GitHub is valus IO or valus IO. You can find all the cool things there. And then I guess our Twitter is valus underscore IO, if you want to check that out. We're posting lots of updates there.
00:56:31.700 - 00:57:04.234, Speaker B: And then as far as the prize pool for anyone that's publishing on the platform, you automatically get qualified to the prize pool. And then we're selecting five other apps that are doing a little more novel use cases or some other cool things that we're going to pick out of that group as well. So pretty simple, all you have to do is publish and qualify the pool. And then yeah, so super excited. I'm going to pass it over to Zach. He's going to go over the system and how it works and we'll go from there. But thanks again and best of luck at this hackathon.
00:57:04.234 - 00:57:08.430, Speaker B: Really amazing stuff. And yeah, we're here to help zach.
00:57:09.650 - 00:57:11.710, Speaker I: Yo, yo, yo. What's poppin?
00:57:13.330 - 00:57:13.694, Speaker D: Cool.
00:57:13.732 - 00:57:17.060, Speaker I: So I'm just going to take you guys through a quick demo here.
00:57:26.490 - 00:57:26.854, Speaker D: So.
00:57:26.892 - 00:57:49.782, Speaker I: You can check out the front end web app on app Vallus IO. Sorry, just bear with me here. A bit of a slow internet going on here. Okay, cool. So you've connected your wallet. You're all good to go. You'll see your dashboard like this.
00:57:49.782 - 00:58:17.082, Speaker I: It's kind of just like a virtual GitHub esque dashboard. And you'll see we have our projects here. We have some activity of all the transactions that have taken place. We can audit all of those different transaction hashes. See those on our block. Explorer, shout out to Polygon. Our app Vallass IO is currently on Polygon, but we also support any EVM based chain.
00:58:17.082 - 00:58:50.024, Speaker I: So check out the contract, check it all out. So the first thing that we are going to want to do is to create an account. So if we go to the account creation page, we have a couple of options here. So the first thing that we can do is that we can upload an account image. So I usually use this one. This is my crypto coven. And then we can set our username.
00:58:50.024 - 00:59:38.972, Speaker I: So just like kind of any other distribution system or package management system, like NPM, docker, all of these different things, you need a namespace. So in the case of Valus, this is an Immutable namespace. And that's again just to kind of prevent any kind of like changing or supply chain attacks type of stuff there. So here I'm just going to go with let's just go with Metaverse co I'll keep that all lowercase. And so then the display name is not Immutable. This you can change it to anything that you want and it's kind of just like a display name on Twitter. Anything else.
00:59:39.026 - 00:59:43.820, Speaker D: So I could say the Metaverse.
00:59:45.780 - 00:59:46.530, Speaker I: Company.
00:59:47.140 - 00:59:47.888, Speaker D: Cool.
00:59:48.054 - 01:00:01.110, Speaker I: And then we can put in a website there. We can say like Hello World or something like that. And then just a quick description so.
01:00:01.720 - 01:00:10.664, Speaker D: We make Metaverse stuff cool.
01:00:10.702 - 01:00:36.210, Speaker I: So that's it for the basic info there. Then each account on Valeth can also function as a team. So again, it's just like a GitHub organization or like a virtual team or anything kind of like that. So normally this is where you would take your list of addresses and you would paste them in here. I'm just going to take my local.
01:00:36.820 - 01:00:44.450, Speaker D: MetaMask address and create that. Oh.
01:00:49.400 - 01:00:56.792, Speaker I: Interesting there. Okay, some weird stuff going on here. This might be an internet thing.
01:00:56.846 - 01:01:03.070, Speaker A: Sorry. There we go.
01:01:05.840 - 01:01:52.180, Speaker I: Okay, so you'll see that? Here it is prompting me. So we're a big fan of open source, we're a big fan of public goods. So everything on Vallast is free by default. It's all metatransactions. So all I have to do here is just give it a quick signature with some basic info here and I can create my account. And so while that's pending I can check that out on the Block Explorer, make sure everything's AOK there and you'll see everything's good. So now I got Redirected to create my first project.
01:01:52.180 - 01:02:30.396, Speaker I: So I'm just going to select Metaverse Co as my account and now I can create any kind of project that I want. And again you can kind of think of this higher level namespace just as know you have your local GitHub account and then you can publish your GitHub pages or anything like that under your default GitHub namespace and you can have any number of kind of like federated namespaces under that root namespace. So for me I'm just going to.
01:02:30.418 - 01:02:30.990, Speaker D: Say.
01:02:32.720 - 01:02:43.712, Speaker I: Let'S just call it Metaverse. Metaverse. And then again we can just do another display name.
01:02:43.766 - 01:02:47.040, Speaker D: So the Metaverse.
01:02:50.020 - 01:03:01.670, Speaker I: Something like that. Website. This is again if you're submitting to the youth global hackathon you might want to put your website in there or your GitHub or something like that.
01:03:07.490 - 01:03:10.560, Speaker C: Sorry I'm not the best speller here.
01:03:13.810 - 01:04:27.766, Speaker I: I'm just going to put Hello World in there too. So we have a full discovery page, a lot like a Steam esque marketplace because a big thing is not just open source software but developers have to eat too. So there's a lot of paid software on ballast and paid native crypto DRM games. In this case, let's say that we'll do like installable game and then we can set that with some tags here we can say game application. And so once we do that now we have a couple description fields that we can add that will show up on our Vallus profile and throughout the marketplace when people search for our game. So I'm just going to say a super cool Metaverse game and then I just have some example markdown here that.
01:04:27.788 - 01:04:30.726, Speaker D: I'm going to paste in there.
01:04:30.828 - 01:04:46.620, Speaker I: And so we have our Metaverse game join thousands of players online for the next revolution of web3 gaming, experience distant lands and discover untold treasures in the Metaverse. Free to play, no pay to win.
01:04:49.310 - 01:04:50.060, Speaker A: Okay.
01:04:53.090 - 01:05:36.300, Speaker I: We have the idea of account level access control, but then there is also the idea of project level access control. So we might have some team admins that are managing our organization. We want them to be able to add other people through this kind of like role based access control system. But then we might just have Verifiers or publishers on the development side where you're a developer, you have your development key and you want to be able to verify a build. So this is where I would then paste my development key and I'm just going to copy that from MetaMask again.
01:05:37.330 - 01:05:38.080, Speaker D: Cool.
01:05:38.610 - 01:06:31.006, Speaker I: So now all the fun stuff when you're on a marketplace and you're on a game, games need trailers, games need a lot of good stuff, a lot of screenshots, interactive content. So for this I'm just going to pick my main promo image. There it's of lost lands, forgotten kingdom, then I'm going to add a couple screenshots for my game. So here are my din characters. Here's my cool metaverse girl in the metaverse with her metaverse glasses. And then that's it. All I need to do is create my project.
01:06:31.006 - 01:06:38.800, Speaker I: And again, if you're doing like a live stream or presentation of your own or anything like that, you can paste any YouTube link here.
01:06:39.910 - 01:06:40.706, Speaker D: Thanks.
01:06:40.888 - 01:07:37.940, Speaker I: You can add all kinds of other content and videos and it'll all go right to IPF. So there we go. Now we are back on the dashboard here and I am just going to select my new account, Metaverse Co. And so you'll see, my new project Metaverse pops up a super cool metaverse game. And if I click that, I am greeted by this beautiful profile. And now this is where I will be able to manage my versions. Any activities, any other members, or maybe like people that are in my dow that are distributing software that want to collaboratively sign off on releases and distribute their software together with me.
01:07:37.940 - 01:08:06.700, Speaker I: But then, yeah, all of my nice little screenshots, all of my nice little markdown right in there all ready to go. And so then we're also tracking all of these downloads through like IPFS gateways. So there's a lot of really cool metrics that you can see to track how many users are actually pulling my files from these decentralized networks and playing my game or running my app.
01:08:08.130 - 01:08:12.030, Speaker D: Cool. So let's publish.
01:08:12.930 - 01:08:59.572, Speaker I: So I'm just going to do version 0.0.1. Usually I just use Simver for any semantic versioning and then we can do a basic description. So I'm just going to say initial release. Then I'm going to take my hello, world. Go, Binary. That is my metaverse game. And then it's just as easy as publish release sign.
01:08:59.572 - 01:10:03.560, Speaker I: One more signature right there. And just like that we have published our first release. So here is our release from the IPFS gateway. Anybody can now take our Vallast client, do a Vallast install on this game natively and then stay tuned because our game client with our built in wallet support Sapphire will also be dropping very soon. So again, just to take another look at this, this is the basic settings page. It's pretty much the same as the account creation page, but there's a few additional settings that we have here now. So a huge part of Vallast, again is that not just the distribution but also the monetization of software.
01:10:03.560 - 01:11:06.748, Speaker I: So as part of that, we're web3 native. So we need to have web3 native DRM for our software. So each project on Valus has a built in project ID that I can activate and embed within pretty much any SDK. So whether it's like Tunesafe Gaming or Morales or any of those, I can tick those and check a digital signature against somebody's token balance to then token date my application. And there's different levels of security that you can implement there with that kind of DRM. But this at least gives developers the primitives that they need to monetize their software in a web3 native way. And this is really powerful because when someone goes to distribute software on somewhere like Steam, you might already have paired with a game publisher, they're taking 1015 percent.
01:11:06.914 - 01:11:09.016, Speaker E: Then you go to put your software.
01:11:09.048 - 01:12:14.530, Speaker I: On Steam itself, they're taking 30%. Apple is taking 30%, google is taking 25%, Gumroad is taking 15%. Bits is taking like 20%. With valid, it's two and a half percent. And then we take all of those funds, they go to our community treasury, and then we cycle that money back into open source projects. So what we can do here again, we're on polygon, so everything's in matic, we can set a default price, we can set a limit, and we can set a royalty percent so that if anybody transfers one of these game licenses to somebody else, there is a royalty on that as well. So then you're also able to customize your royalty address and all of these aspects to monetize your piece of token dated software natively on the team.
01:12:15.620 - 01:12:20.004, Speaker D: Cool. Yeah, awesome. Yeah.
01:12:20.042 - 01:13:03.644, Speaker B: We're about to wrap this up with just one more example. So if you are a Go developer or you're building some kind of CLI and you prefer to do more of like a CLI publish, then we have also check out this example projects repo for sure. We have a bunch of different ways that you can publish different types of software here. So we have a Go project, multiplatform Go, a rust solidity project as well. So there's definitely different examples there. But just to show you what the CLI is capable of, we're actually in this example repo right now with the CLI publish multiplatform project. And the command can work both ways.
01:13:03.644 - 01:13:48.092, Speaker B: So if we have one binary, for instance, this one is a single Go binary here, that when we build it, it's just one hello world. To do that, it's literally just valus publish and then the version and then the folder. I actually need to make that folder, but then there we go. So then if I run the make publish that'll actually do this, build it'll, select the account I want to sign and send this from, and you can see the meta transactions. Oh, need to bump it one more version. So you can see there it knows when an existing release has been used. And I guess I did this a couple more times than I realized.
01:13:48.092 - 01:14:21.660, Speaker B: Let me just go to five. But yeah, basically it'll upload the binary, publish the release, and it'll do all the metatransaction stuff. So you could actually see all the open gas station network stuff that's happening in the background, all the magic that we make your lives easier with. But basically, yeah, right there, it's confirming that transaction. And then it just published that Go binary it shows you the link to Go and fetch it. And then boom, there's my binary right there. And then with SDKs you can also do the same thing and fetch it at this namespace.
01:14:21.660 - 01:14:26.668, Speaker B: And then similar for the multiplatform, do.
01:14:26.674 - 01:14:28.990, Speaker D: You want to say that? Okay.
01:14:29.440 - 01:15:16.600, Speaker B: For the multiplatform it's the same thing, only now we can additionally describe other releases. So you saw I just uploaded the disk folder and just called it a day, but with this I can actually specify in the Valus YAML the account I'm publishing to the project, the version. And then let's bump this up to like eight just in case the files the same way. And then we have an install field here where you can actually describe the name of the binary and then the platforms that you're targeting with this. And then we use the Go standard combinations here. So you can basically say, hey, if I'm building for a Mac on a regular AMD 64, this is the binary I'm publishing. If I'm building on Linux or Windows, these are the binaries.
01:15:16.600 - 01:15:59.320, Speaker B: And then I just have my build script here tell Go to build multiple versions of this. So essentially I have in this folder a bunch of different versions that work on different platforms. And in this Valus YAML, I'm describing those versions and which platforms. And then since the Valus YAML is already set up, I could just run a Valus, publish it'll, parse everything and know I didn't hit save on that. And then it will publish each of the binaries as well as some additional metadata that lets the rest of the system know about the different platforms. So I'll jump to this in a second as soon as it confirms.
01:16:01.040 - 01:16:02.060, Speaker A: That's interesting.
01:16:02.210 - 01:16:53.084, Speaker B: Okay, so let's go to the Acmeco site here and then go to this multiplatform project on the website and then the launch will take you directly into the folder. But then if you actually go to the higher level metadata here, you'll see this is kind of a JSON we use to describe that install stuff. So basically all this metadata is just to tell the front end how to actually interact with the project. And so, yeah, it supports pretty much any type of software and there's all kinds of different ways to publish depending on your preferences and your stack. And like I said, anyone that publishes gets qualified to our prize pool and then we're picking five finalists out of that group as well. But anyone who publishes is going to qualify no matter what.
01:16:53.122 - 01:16:54.172, Speaker A: So that's going to be pretty easy.
01:16:54.226 - 01:17:16.100, Speaker B: And then, yeah, we're always here. Definitely come find us if you need any help. Come join our discord. We're super stoked to have you there. And yeah, send out the good help action for sure. Well, amazing stuff everyone. I guess we'll just take a couple of questions if we have any and then yeah, sweet.
01:17:19.640 - 01:17:20.100, Speaker E: Yes.
01:17:20.170 - 01:17:57.010, Speaker B: So this project here, so. With the token. Gating. It's actually pretty interesting because this is a weekend hackathon. We're very curious to see what comes out of that. But this Acme Co has an example for a token gated unity game that basically if I launch it, hopefully the Internet will play nicely with us. But we have this example here, and in the docs we have how to actually set this up and a separate video and a separate walkthrough as well.
01:17:57.010 - 01:18:15.572, Speaker B: And then for Unity apps, we also have an example script here. So if you go to this page on the docs token getting your software, you'll see the general flow and then some links to examples. And then this one is the unity example we put together for the signatures. And then basically the way it works is oh, this is the wrong one.
01:18:15.626 - 01:18:17.610, Speaker E: Actually, but.
01:18:20.380 - 01:18:47.650, Speaker B: I think it's this one. So yeah, this is just the unity game. And then you connect the wallet and it'll do the balance check from there. And then yeah, this is going to be interesting, but I have it firing off in the console right here. That one in success means that the balance is there. So yeah, it's definitely possible to Tokyo get a unity game or any type of app and yeah, look forward to that.
01:18:48.020 - 01:18:50.832, Speaker D: Sweet. Cool.
01:18:50.966 - 01:18:51.970, Speaker A: Thanks everyone.
01:18:54.760 - 01:19:00.180, Speaker B: All right, best of luck, everyone. Enjoy the hackathon and have a great weekend. We'll see you soon. Cheers.
01:19:14.510 - 01:19:15.260, Speaker I: And.
01:19:20.110 - 01:19:23.590, Speaker H: This is M One. Yeah, it shouldn't be.
01:19:23.760 - 01:19:27.200, Speaker F: I'm not sure why after I've unplugged it that it show.
01:19:27.650 - 01:19:29.054, Speaker H: Oh, it changed the image.
01:19:29.102 - 01:19:29.700, Speaker D: Okay.
01:19:31.350 - 01:19:37.540, Speaker H: I would like terrible for me.
01:19:40.630 - 01:19:42.130, Speaker F: Yeah, it's terrible.
01:20:10.420 - 01:20:11.890, Speaker D: Open this up.
01:20:13.780 - 01:20:15.280, Speaker H: Absolutely terrible.
01:20:20.260 - 01:20:21.770, Speaker D: It it.
01:20:35.130 - 01:20:36.902, Speaker H: Okay, I can see what's going on right now.
01:20:36.956 - 01:20:37.560, Speaker D: Great.
01:20:41.150 - 01:21:31.244, Speaker H: Yeah, I'm all set now. This is not great either. Hi, everyone. So before we get started, sorry about that delay earlier. I'm not sure why my computer wasn't playing nice with everything, but we're ready to get started and hopefully we don't run over time. So what I'm going to be doing during this little workshop is a high level overview of the Bitdao performance funds, which is like a sort of subset of Dow tooling that we came up with in order to sort of improve the proposal process to reduce counterparty risk for DAOs. So, yeah, let's talk Dow tooling.
01:21:31.244 - 01:22:16.690, Speaker H: How familiar are people in here with Dows who's heard of a Dao interacted with one? So a Dao is a decentralized autonomous organization. There's like many levels of it. It could be a bunch of people in our group chat who's just decided that they want to share control of a multi SIG to multi thousand user organizations that have token staked voting where they make decisions over treasuries that are worth hundreds or even billions of dollars. Before we get started over here, if you guys want to pull out your laptops and just open up this repo, we're going to be doing a little code walkthrough of what we've got over there later on. But yeah, before we get started, is anyone not familiar with a Dow? Is anyone have any additional questions on what exactly a Dow is?
01:22:24.200 - 01:22:24.950, Speaker D: Yeah.
01:22:28.120 - 01:23:49.390, Speaker H: Basically it's like a co op, but we've bought it on chain. It's like fully transparent, like who's voted for what and so on and so forth and why things have or have not passed. I'm going to leave this up for like 30 more seconds and that should be good. It if you guys are already familiar with Dows, you're probably familiar with what the voting process sort of looks like for the majority of DAOs these days. So typically you'll have like an initial proposal thing on a forum, like Discourse, right? And then they'll use some sort of combination of the Gnosis, safe, like Safe, Snap, Plugin and Snaps in order to sort of push proposals in, in order to move funds on chain, interact with contracts on chain with the Dow multi sync. Are any of you unfamiliar with any of these platforms? So our existing process is sort of like people can go and propose something on our Discourse forum, write up a proposal, being like, oh, hey, I want X Bit in return for these deliverables, right? If it receives enough interest on it, we then take it to a vote on our Snapshot forum, if that makes sense. And if it passes a vote on our Snapshot forum, what ends up happening is we then allow execution via our Gnosis to transfer funds over.
01:23:49.390 - 01:24:30.440, Speaker H: So basically, what's the problem with this process? So basically at Bitdell we want to fund projects and associated entities to grow sort of the Bit ecosystem. But you sort of face counterparty risk when doing so, right? So let's say that someone puts a proposal in and they're like, I'm going to build a house, I want 10,000 bit, or something like that. It's going to be like a charity or something like that. Once you release the funds for them, there is no way to sort of guarantee these funds. They can rug pull you fairly easily, right? They can just simply be like, oh, screw you, I'm not going to build this. I'm just going to take the funds and run. And we've seen cases of this before through malicious proposals on other Dows.
01:24:30.440 - 01:24:54.956, Speaker H: The solution that we sort of came up to this was performance bonds. So basically we're trying to implement a performance bond process wherein folks are required to stake some sort of collateral into our proposal process. This sort of helps solve this problem by providing an economic guarantee for the Dao itself. We're locking this collateral into an intermediary contract that can be slashed if certain.
01:24:54.998 - 01:24:56.230, Speaker D: Goals are not met.
01:24:57.160 - 01:25:27.964, Speaker H: So we're going to come up with a cute example. Here we have blimp dow. Let's say there's only like seven Blimps in the world. So this is kind of a high risk venture. Let's say that this Dow comes to us and we're like, we want to buy one of those seven Blimps and we want 100K bit to buy one of these Blimps with a performance plan in place that we'd effectively do a bit. Dow community members can request that the Blimp dow community members post about 100 ethan collateral before releasing the funds if the proposal passes. And then there's two possible outcomes to this.
01:25:27.964 - 01:25:40.784, Speaker H: Either Blimpdow would buy a Blimp and 100 ETH in collateral is returned or Blimpdow fails to buy the Blimp and 100 ETH is about recouped by the Dow itself and sort of yeah.
01:25:40.822 - 01:25:41.810, Speaker D: Do you have a question?
01:25:45.620 - 01:25:47.212, Speaker E: How do you make the proposal?
01:25:47.356 - 01:25:48.050, Speaker D: Yeah.
01:26:03.980 - 01:26:17.164, Speaker H: So for Blip, Blimpdow because their initial condition for success was, you know, wanting to buy a Blimp, there are only two states for this. Either you successfully have bought a Blimp or you have not successfully bought a Blimp. Obviously there can be like multiple tiers to this.
01:26:17.282 - 01:26:17.950, Speaker D: Yeah.
01:26:20.400 - 01:26:40.912, Speaker H: So collateral can be staked. So the contracts that I'm going to be walking through later, they're effectively like middleman contracts you're able to post collateral into that can be slashed by guarantors or individuals from the Dow if certain criteria are not met. But we're going to be walking through the contract for that shortly.
01:26:40.976 - 01:26:41.590, Speaker D: Yeah.
01:26:43.720 - 01:26:55.992, Speaker H: So why do we choose performance balance in this particular context? Basically it's because it increases community engagement proposals. It's forcing the other entities community to participate within it because obviously who else is going to be posting a collateral for this?
01:26:56.046 - 01:26:56.696, Speaker D: Right.
01:26:56.878 - 01:27:34.916, Speaker H: It sort of formalizes on versus off chain interactions. It imposes basically consequences, like I mentioned before, on rug pull like behavior and it's a good vehicle for Dow co investments, basically. So let's say that one Dow wants to invest in another Dow who's building some sort of tooling. The other Dow can fund the performance bond completely from their own treasury to sort of formalize the agreement together. So I'm going to be doing a really quick code walkthrough as well of the contracts themselves, if you're able to pull that up. This is the win ran through treasury thing.
01:27:34.938 - 01:27:35.876, Speaker A: This is where we keep most of.
01:27:35.898 - 01:28:25.204, Speaker H: Our Dow tooling and treasury tooling code and so on and so forth. So I'm going to be walking you guys through a pretty simple single collateral multi reward bond. So this is a bond where you can stake in some sort of ERC, 20 collateral and then receive some arbitrary set of, ERC, 20 tokens or something as rewards or redeem from that particular bond itself. So everything is fairly permissioned by sort of like other members. You can see that we have obviously a deposit function over here where people are able to stake sort of a claim within this Dow, within this reward bond itself. There is a sort of particular lockup.
01:28:25.252 - 01:28:29.256, Speaker D: Period that they have to deposit their.
01:28:29.278 - 01:28:54.690, Speaker H: Funds to this bond during or else they won't be able to meet the rewards which is all sort of set during the initialization. So we pass in sort of metadata like describing the bond that's sort on chain we're passing in settings to sort of govern the parameters of the Dow on chain on the initialization. Oh, is it hard to read? I'm really sorry.
01:28:55.860 - 01:28:56.832, Speaker D: Is this better?
01:28:56.966 - 01:29:15.216, Speaker H: Yeah. And we're basically able to init this, right, that's just like the basic deposit contract. We also have a time lock multi reward one. So this is what we know.
01:29:15.258 - 01:29:16.264, Speaker D: Pictures, please.
01:29:16.382 - 01:29:17.290, Speaker H: Thank you.
01:29:18.380 - 01:29:21.450, Speaker D: It's not great, sorry.
01:29:21.820 - 01:30:50.630, Speaker H: We also have a reward contract that people will be able to have their rewards deposited into and redeemed afterwards if the bond actually does succeed in this particular context that maps and is tied to a particular bond deposit contract. Right, so basically it's pretty simple. So we have mapping of the claimant itself, the person who deposited or the guarantor who deposited funds into the original bond contract to their reward pool debt ratio which is an integer representing the amount or the ratio of the tokens that they had within the initial pool. And we have individual reward pools so the tokens that they will be eligible to withdraw to withdraw from and a redemption timestamp over here, which is like the point at which we know that if the bot has not been flossed they should be able to redeem sort of all the collateral basically once funds are available. So when the empty timestamp sort of is set and it has passed, you're sort of able to iterate over and collect any of the arbitrary, ERC, 20 token rewards or initial stake that you've deposited within these and the time lock has sort of expired and so on and so forth. It's a pretty simple single pool style solution for these things. It's pretty similar.
01:30:50.630 - 01:31:00.570, Speaker H: I would even call it like staking reward management. It's just allowing for a one to many sort of redemption pool that we have over here.
01:31:03.980 - 01:31:04.728, Speaker D: Yeah.
01:31:04.894 - 01:31:18.620, Speaker H: So you can see how we sort of calculate the reward debts over here as well after the redemption, the corresponding lockup period.
01:31:19.120 - 01:31:22.076, Speaker D: So you can have your claimant like.
01:31:22.098 - 01:31:27.264, Speaker H: The the debt tokens that they were issued upon them staking within our bond and the total supply of it.
01:31:27.302 - 01:31:32.128, Speaker D: It's just basically a very simple they're.
01:31:32.144 - 01:31:44.630, Speaker H: Owned like a portion of the rewards pool depending on how much they deposited originally. And it's pretty standard over here.
01:31:46.860 - 01:31:47.610, Speaker D: Yeah.
01:31:48.140 - 01:32:43.032, Speaker H: Something that I do find a bit more interesting. Within this is the permissioning system that we have in place. So if you step out a little bit, we also have pretty cool role access control on a Dow level for who's able to sort of control each of these pools and so on and so forth because we're basically deploying these pools on sort of like a per Dow basis. So I'm actually going to go into one of the contracts where we store all of these roles, which is in the roles contract over here. So we have the Dow admin and the Dow creators who are able to be deploying these laws and manage the admin functions such as setting timestamps and so on and so forth. Within them we have Dow people which is like typical Dow users who are then able to interact and maybe save and claim guarantors. We have the super user which obviously has sort of all permissions within it.
01:32:43.032 - 01:33:58.124, Speaker H: And then we have a system admin who is sort of able to set pause and unpause contracts and sort of in case of emergency. I can sort of show you guys how that ties into our bond contracts over here. If we take a look at not the bond creator contract, it is in the sort of like bond Factory and bond mediator contracts. So effectively these all inherit from the role access control document over here. And what ends up happening is that you're unable to create bonds for particular Dows unless you have a role for a particular Dow. So we have a cool encoding system where you might have a unique Dow ID linked to a particular address and roles for those particular addresses unique to that particular Dow. And because we might have multiple entities or multiple other Dows and sort of counterparties to our on chain investments and so on and so forth, we want to make sure that only those counterparties sort of have access to creating these bond and staking sort of contracts.
01:33:58.124 - 01:34:34.350, Speaker H: Right? So we basically have independent factories for each of these individual things and only the admin folks from each of these Dells are able to deploy both the rewards and fund the rewards and create individual bonds sort of for each of them. I guess that's sort of a high level overview of what the bond sort of does and what it is. And I'm curious if people sort of have questions about a little bit like a few more questions about what exactly the use cases or the implementation details themselves.
01:34:34.800 - 01:34:43.696, Speaker D: Yeah, okay. Yeah.
01:34:43.798 - 01:35:38.688, Speaker H: So we also have interfaces for what a typical single collateral bond would look like where you're just depositing like some arbitrary ERC 20 as collateral. Again, the functions are fairly standard when it comes to things like this. You're able to deposit a certain amount of collateral, redeem a certain amount of collateral. An interesting parameter of ethereum is that there's no floating point math, right? So when you are redeeming your collateral based on the ratio of what you deposited in, there will always be like trace amounts of dust tokens left within it. So we also have like a sweet yeARC 20 thing to remove all the remaining tokens into it and back into the original Dow treasury so that we're not leaving dust tokens on contracts all over the chain. Yeah, I guess I can also talk about sort of the slashing mechanism over here. So remember what I mentioned in the Blimp out example.
01:35:38.688 - 01:36:15.864, Speaker H: If they don't meet their particular goal, like being able to buy a Blimp versus not being able to buy a Blimp. You have like an implementation of a slash function where you're able to enact a penalty for the individuals who stake their funds within that bond collateral contract, which just allows for a super user or a Dow admin to basically call out the amount that they're flossing from it and having to put in a string for the reason and do it on chain, if that makes sense. And this would just keep the amount of tokens or like the collateral from that particular bond back into the Dow.
01:36:15.912 - 01:36:25.632, Speaker D: Who'S put up the collaterals, if that makes sense. Yeah, I guess.
01:36:25.686 - 01:36:40.784, Speaker H: Do people have any other questions about how this improves proposal flow or I guess sort of other tooling within our ecosystem?
01:36:40.912 - 01:36:41.590, Speaker D: Yeah.
01:36:46.460 - 01:37:41.092, Speaker H: High risk of regulation for this system, the bond sort of payment system. So I like to sort of think of them as like a formalization of a contract on chain. So basically this is sort of a method of posting up some sort of collateral. This often happens off chain right, where you might be trusting some sort of middleman otherwise it's just that this is sort of happening in a much more transparent and regulated sort of way. I think maybe in the States, the Dao bond tokens or the debt tokens that you receive as a part of the bond because it can be redeemed for things that might cause some issues. But I think that in more Dow friendly jurisdictions that it shouldn't be too much of an issue. But we all know that the States is not particularly friendly for tokens or anything regarding like Dows or what might potentially be securities.
01:37:41.236 - 01:37:46.760, Speaker D: Yeah. Yep.
01:37:58.700 - 01:38:29.508, Speaker H: Yeah, I was this is usually what the majority of Dow proposal processes sort of look. Like I mentioned before, many of them use discourse which is sort of like a forum plugin if you're familiar with duty forums. Discourse is just sort of like an alternate newer version of that. People are able to sort of post up ideas or things that they want funding for proposals. They have to have big formal write ups. Oftentimes people aren't looking at it too closely. I know some folks are probably familiar with the US law proposal.
01:38:29.508 - 01:39:01.568, Speaker H: It's just for the proposal they paid schools like a bunch of money for very ill defined returns. Usually the initial things that are put to vote on the snapshot have to reach consensus or interest on the discourse forum first. So it's a website and if you're interested in proposing something in the bitdao discourse you can just go to our website and we have a link to our discourse, like in the top bar.
01:39:01.654 - 01:39:11.316, Speaker D: Yeah, but I think that this might.
01:39:11.338 - 01:40:12.330, Speaker H: Not be like the best solution for the problem at hand right. Because you're effectively shorting whatever token that you've put into the bond in which return for the rewards token. But it's a step towards sort of improving what is sort of a very uninvolved proposal process, right. An issue that we've seen facing us the majority of the time is that proposals are sort of pushed through by insiders. I don't know if you guys are familiar with the soland drama that's going on right now, where initially the vote was like 94%. We don't want to take this liquidation and do it OTC, right? And then some folks stepped in with a lot of insider tokens and one guy voted and it suddenly got pushed to, oh, hey, we're actually going to be liquidating an OTC. We think that putting up things like this sort of incentivizes the community to come together and vote more and it has them put more faith in the game and it allows them to be on a more equal footing as folks are sort of able to post Nclateral sort of all by themselves.
01:40:12.330 - 01:40:32.370, Speaker H: We're sort of also looking for more tooling along those lines that sort of makes the proposal process more engaging and more accessible to community members sort of overall. We actually do have a prize available sort of today. I'm going to pull it up in our.
01:40:34.180 - 01:40:37.250, Speaker D: Medium oh my God.
01:40:37.860 - 01:41:06.632, Speaker H: Where we're looking for more ideas for how we can improve our proposal process from what we have today. So we're offering about like $10,000 in prizes. We have sort of two tracks with this. We have dow treasury deployment. So basically we found that ladder's Dow Treasuries have to be managed really conservatively to avoid principal loss through systemic failure. For example, you put all your money into some yield farm and that yield farm gets hacked, right. Oracle misfires or other mechanical exploits, right.
01:41:06.632 - 01:41:44.976, Speaker H: And we're basically looking for solutions which this can be tooling, visualization dashboards, operating structures and so on and so forth, that would help allow Dows to help deploy their Treasuries out size for yields. For example, something that you could build could be like a Gnosis safe module that allows whitelisting and passive deployment of treasury assets to blue chip yield farms. Or like collateralized or margin loans that people could take out from the Dow Treasury for some sort of interest track. Two, which sort of fits more into line with the little presentation that we have today, is trying to improve the Dow proposal process. So like I mentioned before, again, the majority of Dow proposals are created in private.
01:41:45.008 - 01:41:45.156, Speaker C: Right.
01:41:45.178 - 01:42:30.692, Speaker H: And the initial vision that's been proposed on the forum itself has already been reviewed by core stakeholders and insiders and generally we already know it's going to be pushed through the moment it's been posted on the forum. Yeah, it's not great. This process can take many, many months and it's usually unpaid. And so people aren't really incentivized to do this unless they already have a large stake within the dow itself leading to sort of like insider convolution on these Dow proposals. We want to be able to find a way to leverage a wider range of community contributions for ideas and development without them having to go through this process. And that's just not something that's happening with the current Dow status quo. And we're just looking for solutions to try to incentivize the construction of Dow proposals in a public way.
01:42:30.692 - 01:42:52.990, Speaker H: Right. Whether it be through community participation in bonds, whether it be through community participation and open ideation on what exactly the proposal contents are and with Gao members being able to signal that they're opposed to certain parts of it in a very explicit and formalized way.
01:42:54.320 - 01:42:54.780, Speaker D: Yeah.
01:42:54.850 - 01:43:11.280, Speaker H: So it's just definitely beneficial this could be definitely beneficial to the ideation process in terms of Dow rebrandings, in terms of protocol functionality upgrades, protocol parameter changes and sort of any other aspects that many Dows have their users sort of vote on chain on a day to day basis.
01:43:12.900 - 01:43:13.360, Speaker D: Yeah.
01:43:13.430 - 01:43:29.530, Speaker H: So if you're interested or you have any ideas for what you could sort of build for either of these tracks, happy to meet you at the big Dale booth and chat a little bit more and yeah, thank you, I guess, for coming to the talk today. It's 530. Exactly. Yeah.
01:44:14.780 - 01:44:15.530, Speaker E: Okay.
01:44:17.580 - 01:44:22.724, Speaker C: So I'm Julian Traversa with Swivel Finance. Just a quick introduction to Swivel.
01:44:22.772 - 01:44:25.076, Speaker A: We were founded ourselves as a hackathon.
01:44:25.108 - 01:44:34.060, Speaker C: Project at East Denver 2020. It was a pretty simple idea at the time, but things kind of just get the ball rolling, so hopefully you guys can do similarly.
01:44:35.520 - 01:44:37.724, Speaker B: As far as the workshop today, really.
01:44:37.762 - 01:44:39.724, Speaker C: The goals are hopefully a little bit.
01:44:39.762 - 01:44:41.656, Speaker A: Less technical, although it's going to be.
01:44:41.698 - 01:44:59.940, Speaker C: A bit overview of the technical details. But the goals are really to kind of explain how developers can trade rates and make applications around these things. At the moment, this sector is really largely unexplored beyond the first layer of creating fixed rates. So there is a big opportunity for people creating hackathon projects.
01:45:00.440 - 01:45:03.988, Speaker B: That said, the two real big goals we have for it are to kind.
01:45:03.994 - 01:45:44.064, Speaker C: Of identify the various fixed rate protocols out there and where their yield actually comes from, as well as a few strategies and kind of how to work around them. I said enter to Swivel, right? And where our yield specifically comes from. We take feature deposits in money markets like compound ave, urine, et cetera, and we split them into two components. One is the redemption value for your deposit and the other is the actual interest you earn until some future date. So the most common use case there is the fixed rate lender will have this cash flow and want to just trade it away immediately for something up front.
01:45:44.182 - 01:45:44.560, Speaker D: Right.
01:45:44.630 - 01:46:24.060, Speaker C: And in doing so, the lender effectively gets themselves a fixed rate while the other person is purchasing some future cash flow. And this user purchasing the cash flow is effectively speculating that the interest rates will increase over time. And this is traditionally the largest merc in the world with interest rate swaps and DFI. It's still pretty small. So, yeah, I mean, the best example, again, just walking you through it, you have one lender that has $1,000, and you have one other user that is willing to pay effectively a market rate of 5% for one year. So that would be $50. We take this deposit, we put it into compound, and each user gets part of those cash flows.
01:46:24.060 - 01:46:38.256, Speaker C: $1,000 in redemption value and $1,000 earning interest until one year from today. The next step from there is really just calculating, okay, how much does this user that owns the tokens earn over the entire period?
01:46:38.368 - 01:46:38.692, Speaker E: Right?
01:46:38.746 - 01:47:20.960, Speaker C: So under the assumption then that the rates moved up from 5% to 8%, they paid $50 initially, they earned $80. So this user is actually profiting. That 60% profit. I mean, honestly, in today's context, this is a pretty old slide is very different, right? If rates are 1% and they go up to 2%, you're getting 100% profit. So the trading opportunity is better now than it has ever been, but the ecosystem is still not really as mature as it can be. We use an order book, which is very important, but there's about five other protocols around that try to address the market but completely fail to address what these yield tokens, these end tokens really.
01:47:21.030 - 01:47:22.960, Speaker B: Are, which is a derivative.
01:47:23.460 - 01:47:33.824, Speaker C: In the same way an options price is based on some spot asset, this yield token that earns future yield, the value is going to be based on how much interest it earns.
01:47:33.872 - 01:47:34.870, Speaker D: It's that simple.
01:47:35.240 - 01:47:41.400, Speaker C: So when you look at an AMM or otherwise and try to price these assets, it's actually nearly impossible.
01:47:42.380 - 01:47:44.516, Speaker B: The LPs. Just get arbitraged.
01:47:44.628 - 01:48:13.856, Speaker C: It really ends up horribly for all parties involved. And pretty much everyone right now is just hand waving this fact away, saying, hey, we'll give token incentives kind of works, right? Token incentives work. But we've seen similar things with options protocols where Hedgek had Molly Winter mute come out and say, hey, our LPs are losing 30% a year, but they don't care. And now Hedge, a lot of you probably don't know it exists. That said, there is a wider ecosystem.
01:48:13.888 - 01:48:15.044, Speaker D: Of fixed rates, right?
01:48:15.082 - 01:49:12.260, Speaker C: And my goal isn't just to show our project, but to kind of introduce what developers can do with this ecosystem. Right? There's about six different fixed rate protocols. They all generate rates or yields in minorly different ways or provide markets for the tokens in mildly different ways. Obviously, I'm biased to assume that if it's a derivative, you need an order book to properly trade it. That said, when you look at the yield tokenization method, and this is one that is seared across a number of protocols, we were the first to come out with it, really. But at this point, there's about five others that all use the same model where you take some deposit in a money market compound and you split it into these two components. At the moment, there's no standardization whatsoever across all these protocols and it leads to a very difficult user experience.
01:49:12.260 - 01:50:20.700, Speaker C: In general, this is something we're working on and then moreover, as well as a liquidity provider or user, it is actually very difficult to even just properly interact with these protocols. You don't know who's really providing you the best rate, you don't really understand the underlying interactions. But regardless highlighting the point of the talk, where does the yield actually come from in this model? It comes from one party that is potentially speculating that the rates could go up, or it comes simply from time premium, and that if the rates maintain a consistent rate, let's say you're willing to take a slightly lower fixed rate than the current variable, one you're effectively being paid, or you're paying the other user to release your time premium. Get a immediate capital today and this is obviously worth something. The market is pretty naive at this point, so it hasn't really been powerfully pricing these things, but more opportunity for traders. The difficulty with these models, good ones, is it's very good for building blocks. You can rely on a lot of other stacks and integrate all across the ecosystem.
01:50:21.040 - 01:50:23.676, Speaker B: It's also really great because regardless of.
01:50:23.698 - 01:50:39.184, Speaker C: The rates, there is a supply and demand on each side. The great example is if the rates are high 8%, there's a big incentive for you to lock it in and kind of get rid of your capital. And alternatively, I already gave the example.
01:50:39.222 - 01:50:40.336, Speaker B: If the rates are very low like.
01:50:40.358 - 01:51:43.028, Speaker C: They are right now, it's very attractive for users to come and long them. I think really the best example that we've been trying to push recently has been the staked ethereum trade in that a lot of users are trying to short staked ethereum. But you can also just own staked ethereum and lever yourself up on the interest rate, which again, this is only viable because of this sort of supply and demand. The other really most common and in my opinion viable model is just over collateralized lending, but through the use of a similar instrument with principal tokens, right? If you have, let's say $150 in ETH, and this is provable same way any sort of money market does prove it at the moment with whatever oracle, et cetera, and liquidation you can instead of minting variable yield, mint principal tokens, these are redeemable at a future date for one dollars. And from your point of view, if you sell them today, you're borrowing at.
01:51:43.034 - 01:51:43.972, Speaker D: A fixed rate, right?
01:51:44.026 - 01:51:58.876, Speaker C: If you're able to sell your principal token for $0.95, it means that you've borrowed at a fixed rate of roughly 5% a year because you just have to come up with that last $0.05. So it's actually. Also a relatively flexible model, but there.
01:51:58.898 - 01:52:00.508, Speaker B: Are issues with it as well, right?
01:52:00.594 - 01:52:16.636, Speaker C: The supply and demand isn't quite there as much, but the big thing is that there is an abundance of borrowers in the ecosystem. So these markets tend to be a little bit more liquid and they can scale, they can scale a little bit easier.
01:52:16.828 - 01:52:18.748, Speaker B: So you have this really accessible user.
01:52:18.764 - 01:52:48.184, Speaker C: Base that you kind of just can immediately identify and that's great. And this is one that has been largely growing more recently under collateralized lending. I'm a little bit more dubious on this end, but we've seen some incredible growth out of companies like Maple where they allow a centralized entity to essentially sponsor a pool and they're doing the due diligence upon the borrowers that are lent out to that pool porter. On the other hand, similarly, they allow.
01:52:48.302 - 01:52:50.120, Speaker B: Dows to raise debt.
01:52:51.020 - 01:52:56.156, Speaker C: There's a lot of risk here that make it a lot harder to create trading strategies around.
01:52:56.258 - 01:52:57.452, Speaker B: But if you're the sort of person.
01:52:57.506 - 01:53:18.164, Speaker C: That is willing to take on some minor amounts of risk, there are large amounts, there's a lot of profit just to gain currently. There just is. So the question starts to become how do you start to create strategies that can actually be applied to this sort of sector? And what sort of building blocks can people build next?
01:53:18.282 - 01:53:18.564, Speaker D: Right?
01:53:18.602 - 01:53:49.128, Speaker C: If fixed rates exist, what else can be done? Obviously, the most common trading strategy is longing and shorting the rates, right? If you want to long the rate, it's literally as simple as purchasing the token, purchasing the end token and holding it and trading it away. Once prices go up, however, there's usually some other strategies folded into a bond. And the most common one is largely people that are trying to I don't.
01:53:49.144 - 01:53:50.304, Speaker D: Know if it's on the side yet.
01:53:50.342 - 01:54:27.336, Speaker C: To borrow at a fixed rate. So here's a quick code example of exactly that. Right, in this example we're using Swivel and we're going to be borrowing directly from compound. So in our scheme, we're off chain with on chain order book. We have an off chain order book with on chain settlement, which means that all of these things are effectively coming from our API. All of the order, the amount and the signatures, and then you immediately just input it into your functions. We have SDKs in pretty much every language for this.
01:54:27.336 - 01:55:20.184, Speaker C: If you guys are hacking and want to do anything off chain. And as well, there's other ways to integrate on chain too. So what's happening here is effectively there are these arrays that are input. This order itself contains a bit more of a complicated object that's imported, but it effectively includes all of the information on Swivel about the order. Effectively, what is the underlying protocol? USDC or something? What is the maturity and Unix? So let's just say December 21, and then per order, what is the amount as well? That you wish to fill. This is all done with EIP 712, so this is all pretty familiar for people at this point, but you also have to submit all of the signatures in EIP 712 format and then include the C token that you're trying to input. We add in here, honestly, in my opinion, pretty straightforward.
01:55:20.184 - 01:56:51.610, Speaker C: After that, after you actually input all of the orders, is identifying how much you've actually spent, how much did you lend out in C token exposure, and then after that, you can borrow pretty exactly the exact same amount. So in this scenario, you have someone that comes in, they lend out total lent to swivel through all these orders and then immediately in the same transaction, borrow. This actually highlights the big issue with a lot of these AMMS, because let's say you come in and you're a large borrower that is able to move the rates up, right? So this is completely separate from whatever system that the rate trading itself is happening on and you can immediately move the rate up and profit from whatever differential on its derivative. This is the same sort of thing you could do if there was an AMM trading an option and you were able to move the market. And it's essentially something that is unique to rate markets. In that unlike spot markets, there's no cost to manipulating Oracles, right? If you want to change the price of uniswap, you need to spend billions of dollars in capital to maintain it for a block or two. This is easy to measure, but if you want to abuse and manipulate the actual rate on compound, what does it cost you? It just costs you moving your capital for 1 second and paying a marginal amount of interest, right? So it's actually very important that we're using this order book because it allows people to avoid this attack.
01:56:51.610 - 01:57:21.184, Speaker C: But from the user's perspective, this is pretty simple. You're borrowing at a fixed rate, you have bought total Lent and sue token exposure and then as well had that amount of debt pretty precisely. These are available now, so if you want to get into early mev, these are things you can do and there are not actual many participants doing it because there's not a lot of profit here, I'm going to be completely honest.
01:57:21.302 - 01:57:23.140, Speaker B: But these opportunities grow.
01:57:23.290 - 01:58:14.050, Speaker C: I've manually been able to do these arbitrage before. And best example here is we've had these tokens, we split them up into principal tokens and yield tokens. And inherently, because they've been split up into two components, well, you can combine them back into the same one as well, which means at a base and core level, one principal token and one yield token is always equivalent to the value of one underlying token. So you can inherently assume the price of both. However, a lot of these other protocols are quite inefficient, like very inefficient. They have pools for each of these individually and anytime there's individual pools for two assets that should be trading at the same price, you can arbitrage the two. So here's a quick code example of doing exactly that and going on to cents and arbitraging the two.
01:58:14.050 - 01:59:19.636, Speaker C: You come in and this takes a lot of parameters. Hopefully you've hard coded some of this or made a more advanced contract, but just for brevity's sake, it's pretty parameterized. You input exactly the maturity, the underlying and the sort of asset you'd effectively like to lend and the amounts you would like to lend. Go in, identify your starting amount so you can effectively calculate your profit and loss at the end of the transaction. Buy a certain amount of sense Pts by a certain amount of sense YTS hopefully the same amount because you've calculated that off chain and then immediately combine them, right? This seems like such a naive strategy that you would think people are actively doing these things, but these protocols are in a nascent state and this means that, yes, people can go out there and create contracts that will profit off of this arbitrage. Your biggest worry at that point is generalized front runners coming and taking your money. But yeah, in this case I returned the profit you make more realistically, you probably want to require that profit exists so you do the transaction, otherwise you'd revert.
01:59:19.636 - 01:59:21.588, Speaker C: But I don't know, I didn't decide.
01:59:21.604 - 01:59:22.730, Speaker A: To do that in my demo.
01:59:24.780 - 01:59:45.200, Speaker C: So the next one, right. This is an actual trading strategy rather than immediate arbitrage or an attack which with previous two kind of work in that there should be across all of those different strategies of trading yields over a long term basis. I'm giving you a lot of words behind this. There should be a trend towards mean reversion, right?
01:59:45.270 - 01:59:47.308, Speaker E: Fixed rate protocols, regardless of the source.
01:59:47.324 - 02:00:43.344, Speaker C: Of their yield over time, should center around the same rate because the people supplying the supply side of the formula always should be optimizing on their own accord. So with that in mind, there are a lot of opportunities just for creating strategies around either immediately arbitraging tokens that are across different protocols with slightly different risks but that mature at the same time, or alternatively being willing to take some amount of time risk there as well. So again, it's very important, I think, that there are a bunch of protocols that have different sources of their yield and these are real sources. These are not illegitimate sources, these are sources that are sustainable because this can create a healthy ecosystem that people can build on top of. So the example of that code walkthrough, right? So PT arbitrage I'm back to Swivel's code base again. So there's the same order objects, et cetera, but then in here as well.
02:00:43.462 - 02:00:46.092, Speaker B: This is the pool for yield protocol.
02:00:46.236 - 02:01:21.052, Speaker C: And its principal token, an FY token. Similarly, we start at the front and we get the initial balance. We calculate the amount that we actually went out on Swivel and then we see exactly whether we can sell that amount on yield. So this entire thing assumes that you already own the yield token. But with that said, the assumption here is that the rates have oscillated a certain amount and you are reversing your position. You are betting on a return to mean and you just easily do this on chain with an activation. More ideally you could set this strategy on chain.
02:01:21.052 - 02:01:25.616, Speaker C: Say if the variance is greater than x percent, the calculation can actually be.
02:01:25.638 - 02:01:26.560, Speaker D: Executed.
02:01:28.820 - 02:01:37.620, Speaker C: At the end of it. Essentially you just close the order. And likewise, you should really be checking to make sure that your R profit is positive rather than just returning it.
02:01:37.690 - 02:01:39.190, Speaker D: But there it is.
02:01:39.960 - 02:02:13.640, Speaker C: The effect here is and I had an entire nother deck for this thing but is that you are creating a deeper and wider fixed rate ecosystem if there are participants that are willing to do this. Arbitrage and we're actually building an entire protocol around this core concept in addition to Swivel that takes all of these principal tokens and accepts whatever minor amount of time risk, you're able to increase the volume of every single individual protocol, profit yourself and ensure that the ecosystem itself is healthy.
02:02:13.720 - 02:02:13.976, Speaker D: Right.
02:02:14.018 - 02:03:31.208, Speaker C: These are the things that are actually necessary for the growth of any DeFi ecosystem and it's what drove spot volume, is integrations. These are the important things. This is honestly relatively similar strategy and that instead of cross protocol betting on mean reversion between principal tokens, this is within protocol bet that there's just going to be reversion between major stablecoins and we have seen this on even a short term basis between Dai and USDC with only recently USDC kind of reverting from that. But the idea here is you're just trying to go from one asset into the other. There's a Swivel order, you come in and you try to fill it as quickly as possible and immediately afterwards come and trade on uniswap and trade back into Swivel. The result is here you are profiting should there be any more long term disjointments and rates between stablecoins and this is a relatively basic strategy, right? There's plenty of ideas you can even build on top of this similar stuff. I think one great hexon idea, if people are really, really looking for one, is the ability to just arbitrarily trade from one token into another, get it sealed and then trade back at the.
02:03:31.214 - 02:03:32.052, Speaker D: End of the period.
02:03:32.196 - 02:04:00.656, Speaker C: Just a wrapped product is pretty simple. And things like that, again, are what the ecosystem legitimately needs. I mentioned this kind of a moment ago, there are issues with the growth and if you can find people that are willing to kind of work around these things, which we're trying to do, you can fuel and profit massively. Traditionally you have things like IMM dates around these fixed rate protocols or not.
02:04:00.678 - 02:04:02.460, Speaker B: Protocols, but whatever asset.
02:04:02.540 - 02:04:02.928, Speaker D: Right.
02:04:03.014 - 02:04:35.420, Speaker C: You have single dates four times a year. That all of the contracts for every financial everything mature. This makes it so people can actually create structured products on top of them and kind of do the whole building block thing. This exists traditionally. However, our compatriots have been kind of reluctant to adopt this through standard with us. This is something that we're spearheading now and it seems like we're getting more adoption of. But it is extremely important for people to grow and these strategies really to be applicable for there to be shared maturity dates.
02:04:35.420 - 02:05:07.828, Speaker C: Another really big thing is, I mean, I showed you some of the code integrations and they look like kind of a pain in the ass because a lot of them are. And one of the things we're specifically working on as well is a standard to reduce the stress of a developer trying to integrate with fixed rates. This is something that I'm spearheading with the yield team and that anybody that wants to integrate with any fixed yield and honestly, I count this with our bounty as well, even though it's kind of a separate thing. Anyone that wants to integrate with a.
02:05:07.834 - 02:05:08.856, Speaker A: Fixed yield should just be able to.
02:05:08.878 - 02:05:57.528, Speaker C: Buy this token off an open market and redeem it later on for the value. So you don't need to do anything other than know how to integrate with uniswap and then use the interface afterwards. So again, if anyone wants to learn more about these things in particular, please compile a booth because I think there is a lot that can be done and there's a lot of opportunities and yeah, I think I'm a bit early but it's fine. If anyone really is looking for hackathon ideas, I do think we have a link. I think we've posted it in the Fglobal discord but we pretty much have SDKs in just about every language. We can help everyone out with their integrations and do some legwork as well. Just come hang out and yeah, I suppose that's most of it.
02:05:57.528 - 02:06:11.790, Speaker C: From my end. We've got Bounties for 2000 believe and they're really wide reaching, right? So anything from minor integrations to dashboards, pretty much anything.
02:06:12.480 - 02:06:13.950, Speaker D: Yeah, that's about it.
02:10:29.380 - 02:11:27.344, Speaker E: Thanks everyone for being here. My name is Eric Tang and I'm the co founder and CTO of Lifepear. Today I want to talk a little bit about building disruptive web Three streaming applications with Lifepier Studio, which is a set of developer tools that we recently launched. But before we get into that, if you're unfamiliar, Livepeer is building the video streaming layer of Web Three. And in order to talk about building disruptive streaming applications, I want to cover a couple of topics. One is what are some of the core tenants of Web Three applications? Right? What makes it unique and how does it compete with traditional web Two applications, especially around these consumer apps? I want to give a quick introduction into video streaming technology. And then I'll give you a couple of examples of new technical architecture that you can start to follow and start to think about your hacks.
02:11:27.344 - 02:11:31.220, Speaker E: Of course, talk about the exciting part, which is the hackathon prices.
02:11:32.360 - 02:11:33.012, Speaker D: Cool.
02:11:33.146 - 02:12:34.612, Speaker E: Let's dive in. Core tenants of Web three applications. So let's take a look at some of this historic view, right? Where do we come from and what is Web Three actually putting forward? Back in the when the web was first invented, we were really in this kind of read only world, right? People created protocols and we were able to kind of send messaging messages around to each other. And when that evolved to this web Two world, we started to have this read and write ability. We were able to interact with applications and actually write information into the back end. That enabled us to build much more much richer user experiences that gave rise to these really interesting applications that are on the web. In Web Three, we started to introduce this new component, which is ownership.
02:12:34.612 - 02:13:25.304, Speaker E: So now you can read, write and own. And with that new element, we can start to think about building new types of applications that are way more interesting than what we have today in terms of consumer apps. One of the things that are really interesting that's happening is in Web Three, people, users are becoming owners, right? There's a lot already being written about the owner economy. Lots of applications that are building in this space already around the owner economy, anywhere from digital assets to DeFi. To me. One really interesting example here I want to highlight. We use YouTube today to watch video, right? Artists launch their music videos on YouTube and people can watch it.
02:13:25.304 - 02:14:27.128, Speaker E: There's an interesting experiment, a company called Glass. On Glass you can still watch music videos just like YouTube. But the additional thing is now you can also purchase music video. And if you're a fan, you went on Glass and you purchased a music video NFT, which is a limited edition, you start to create a direct relationship with the creators. And as the creators become more and more popular, the fans start to be able to take ownership and be benefit from the success of these creators. Because these NFTs are limited editions, and owning these limited editions early in the career of an artist can become a lucrative thing later down the line when the artist becomes more famous. Another interesting toolkit, tool that we have now is incentive design and permissionless participation.
02:14:27.128 - 02:15:41.684, Speaker E: So what does that really mean? Well, in the web Two world we have this technical architecture where we have the front end and the back end and the database all living in a centralized ecosystem, right? So the user data lives in that siloed environment. And these environments are proprietary intellectual properties that are developed by companies and that are owned by the companies and ran by the companies in the Web Three world we have blockchain architecture, right? So the blockchain essentially is replacing the back end database and becoming the user database. We have smart contracts that are also open source and composable and that we can use to program digital assets. And on top of that we have clients and users. So this creates a fully decentralized model of building application where there isn't intellectual property, but the ownership. And the ownership and the interaction from the user data happen in an open way. And this introduced some interesting tools that we have.
02:15:41.684 - 02:16:36.048, Speaker E: So now we have a way to create incentives, right? So these incentive design mechanisms are really popular in DeFi, but it doesn't only live in DFI, for example. It solved this really interesting conundrum in the Web Two world where when you're building a new consumer application, you get to this cold start problem. You build an application and no one knows about it, you have to bootstrap this user base from scratch. And if you look at the network effect curve, the more user you have, the more valuable the application becomes. But in order for the application to become valuable, you need to have these users. So this bootstrap phase is really hard to get by and is really costly for companies to build these user bases. Well, in Web Three we have this new tool, there are tokens.
02:16:36.048 - 02:17:43.560, Speaker E: So in the early phase, when there's not a lot of users, we now have a way to create financial incentives for people to participate in the applications that help us smooth out that demand curve. And over time you have the financial utility and the application utility Cross that helps you get to network effects a lot faster in a much more smoother curve and much less costly for the application developers. And this is already starting to take shape in the past few years, even in the infrastructure space. So here we see a lot of interesting computation. Infrastructure has been bootstrapped using these token mechanisms where each year a lot of value is being distributed to the participants in these protocols. And these protocols and infrastructures are being bootstrapped and becoming this global and really efficient infrastructure. But it doesn't stop there, right? It's not just about tokens.
02:17:43.560 - 02:18:44.508, Speaker E: Creators can also take part in this. And currently a lot of creators are taking part in this through NFTs. You can kind of look at NFTs as a way to capture demand in this demand curve where you have the long tail fans, where you can monetize as much the way you monetize their attention is by, you know, YouTube and things like that. But for your more loyal fans, you can start to sell NFT collections. And over time, these NFT collections can help the creator capture more of the economics on this demand curve. Another really interesting example is DAOs. So Dao, at the very beginning were groups of people that are coming together, putting together a treasury and they start to figure out rules of how to operate and use the resources in the treasury.
02:18:44.508 - 02:19:51.136, Speaker E: But over time it's also evolved into this interesting way to collaborate and actually do projects and develop things and create products. So now we have Dow governance, we have Dow Tokens that go through these governance mechanisms. They have their own inflation schedule and token supply. There's a market for these Dow tokens that can be traded on the DeFi marketplaces. So essentially what you can do now is you can create a project, create a Dow, launch your own token and use that token liquidity to bootstrap the participation in your dao and build product on top of that. So it solves your product building problem, it solves your initial user bootstrap problem and it creates this new way of distributing ownership of these applications in the early days to the users. And being live here, we see a lot of these applications starting to come align.
02:19:51.136 - 02:21:00.460, Speaker E: These are interesting consumer mass adoption applications, not just blockchain niche applications. And we're seeing a lot of interesting examples in the verticals of decentralized social networking in Web Three creative economy and also starting to see that in decentralized gaming where games are being created. But also there's very nontrivial video streaming components in these games. So how does that all relate to video streaming and live here we're talking about building a disruptive streaming app, right? In order to do that, let's go through a quick overview of video technology and see how it works in the Web Two world and how it is working in the Web Three world. Video accounts for about 80% of the Internet's traffic. So without a doubt it's the most important tool that you can use when you're building a mass consumer application. And the reason is that video is the most effective tool for storytelling and for communication.
02:21:00.460 - 02:21:56.220, Speaker E: It's the most direct and the most dynamic and the most impactful. So if we look at video streaming application, there's really three parts. There is your video ingest or video upload, your video playback and your video processing. A traditional video application architecture, technical architecture, looks something like this. On the left side you have your server side logic for your application that's connected to your database. You have a front end where there's a player that's loading from the server logic and the player allows people to and the front end allows people to upload a video into a media server, which is kind of the linchpin of this whole thing. The media server allows you to upload the video using a transcoding engine to transcode the video so that it can be streamed.
02:21:56.220 - 02:22:52.540, Speaker E: The video will get stored into an object storage. It gets put into a CDN for caching and it gets put into the video player. So for the video ingest component, we have these little three little squares. As a product for live streaming, people usually use tools like OBS studio, which is very popular amongst twitch streamers. These are kind of live broadcasting tools. The advent of Instagram or TikTok or other mobile applications are giving rise to kind of mobile native broadcasting and video creation and as well as kind of like in browser web in browser broadcasting as well. Oh boy, running out of battery.
02:22:52.540 - 02:24:12.370, Speaker E: Anybody have a my computer running out of juice. It it. All right, back at it. So in terms for Livegear, we have a set of tools for developers to build video ingest or upload experiences. We have a mobile SDK that allows anyone to build a mobile application that broadcasts a live stream into Livegear. And we also have an in browser SDK that allows anyone to build an in browser broadcasting experience so your user don't have to download like OBS or something like that, moving over to delivery and playback. Usually for mass scale video applications, videos need to be uploaded into a CDN, and that's usually from a media server.
02:24:12.370 - 02:24:49.234, Speaker E: But sometimes video can also be delivered directly from a media server, depending on kind of your use case. But there's always a video player that's in the front end and there are lots of open source solutions, lots of closed source solutions that's a video player. The playback is usually in. The most popular playback mechanism is called HLS. It's a file format, it's an Apple standard. And because Apple's, Apple, they control the market and they dictate how video streaming works. And adaptive, fair rate streaming is a really important concept here as well.
02:24:49.234 - 02:25:32.900, Speaker E: And what that means is when you're watching videos, even though everyone thinks that they're watching the same video, but they're actually watching different versions of the video that's being transcoded, right? So imagine if I record a video in four k, I upload it into a video streaming platform and someone is watching it on their mobile phone. They're not watching my 4K video that's being uploaded, right? They're watching a much smaller version, like a 360 p or a 480 p version that's being transcoded down. And this is a really important concept because in order for video to be delivered at mass to all the viewers around the world.
02:25:34.710 - 02:25:35.426, Speaker C: It needs to be.
02:25:35.448 - 02:26:20.750, Speaker E: Delivered no matter what networking condition, no matter what device they're using. And that means video needs to be transcoded into many different formats to accommodate for that. So here's a pretty good example. Imagine I'm walking on the street near my home where there's pretty good cell reception and I'm watching a get home, I'm on my WiFi, it automatically switches to 1080p. Maybe then I go for a run and I run through an alley where there's no good WiFi reception. It can go directly down to 360 p. And this type of switching can happen in a seamless way so that users don't even notice that's being switched.
02:26:20.750 - 02:27:00.080, Speaker E: Sometimes when you're watching Netflix, it starts out really grainy and it becomes like high resolution after a couple of seconds. That's adaptive bitrate streaming at work to help optimize your viewing experience. Video delivery playback. We talk about video players, right? There's a bunch of options out there. We're happy to provide some recommendation for you as you're thinking about building your apps. Video processing, it's another really important component that happens in the back end that people don't usually think about until you start to really build an application. Thanks.
02:27:00.080 - 02:27:36.920, Speaker E: Video processing is really transcoding. We talked about it a little earlier and transcoding is actually a really computationally intensive step, right. Because what you're doing is you're decompressing the video, you're recompressing it down to the different versions and then repackaging it, reencoding it, and then you're storing it. Usually it happens something like this, you just transcode it all in many different versions. Especially for live streams. It can be even more costly because live streams every second is new video. Right.
02:27:36.920 - 02:28:25.414, Speaker E: There needs to be a lot of concurrent transcoding that happens to support a consumer at scale live streaming applications. And that's where lifeyer comes in. Life here is a decentralized video processing infrastructure network. I'm not going to get into too much of how lifeyer works just on the high level. The way it works is there's a global registry and a set of smart contracts that controls who gets to participate in the network and who gets rewarded. Anybody can participate through this protocol. And the participants are basically GPU providers that have a ton of GPUs.
02:28:25.414 - 02:29:21.350, Speaker E: Right now there's about 100 participating nodes on the network. A lot of these nodes are kind of professional data centers around the world. There's up to about 70,000 GPUs in the network processing video any given time. And this is completely decentralized, which means any of these nodes can go away at any point. And the network software is written in a robust way that it will automatically retry so that the end user viewing experience is never impacted. The there's this kind of on chain and off chain portion of the protocol so that all the video streaming components in this protocol are completely off chain. But they're cryptographically signed so that only the setup and the settlement happen on the blockchain.
02:29:21.350 - 02:30:37.010, Speaker E: And we recently moved over to Arbitran which provided a lot of really nice benefits in terms of gas price and scalability. And the economic mechanism works something like this, right? Where token holders can stake tokens towards the node operators on the network. When they stake their tokens, they get a portion of the rewards of those operators and over time they get to align their incentive and you get to create this flywheel where the increased volume of video going to the network creates more revenue for the participants on the network, which creates more value for token holders. That drives the demand of the token, which over time creates more value, creates more volume for the network and that kicks you into this. Flywheel. So, talking a little bit about building with Liver Studio live Peer studio is the toolkit for web3 video developers, right? So there are three components to it. You can live stream, you can do video on demand streaming, and you can mint NFTs.
02:30:37.010 - 02:31:31.590, Speaker E: So here are a couple of examples. In order to add video streaming to your hack, you can just use a simple set of APIs. The API allows you to upload your video into Live Peer and it will ingest your video, it will transcode it, it will store the video for you, it'll cache the video and will give you a playback URL. And all you have to do is embed that playback URL into the video player of your choice, put in your application, and then you're done. Your video now becomes streamable. Additionally, if you want to mint a video NFT using that video that you just uploaded, all you do is configure your upload to also export to IPFS. And now what you get back is the playback URL plus the CID or the IPFS hash for that video.
02:31:31.590 - 02:32:13.166, Speaker E: Then you can use that hash and use the video Minting SDK that Livepeer has and mint the NFT on a EVM compatible blockchain. Another example, you can add live streaming into your app into your hack. What does that mean? It means all you have to do is you create a live stream in the Live Gear API. And then when you create the Live stream, it gives you a ingest URL that you can use to ingest your video into. And there's an authentication key that allows.
02:32:13.198 - 02:32:14.180, Speaker A: You to do that.
02:32:14.790 - 02:33:08.980, Speaker E: After that, the video gets ingested transcoded stored, sent to the media server, and you can play back that video. And all of that is done automatically. Now, another interesting thing that you can do is at token gating. So what does that mean? It means you can say I'm live streaming now as a creator, but only the people who own my NFT are allowed to watch my live stream. So the way that works is you configure for your live stream to be token gated, and when you ingest the video, it becomes playable. But every time anyone wants to watch the video, there is a webhook call that gets kicked off through the media server. And you can implement a webhook handler using any logic that you want.
02:33:08.980 - 02:33:50.210, Speaker E: Usually people check for ownership of an asset in a wallet. And of course, the wallet address can come with the webhook call. So you can go on the blockchain, look at the state, the data on the blockchain, and make a decision on whether a user is allowed to watch a video or not. And that's how you token get a video. Getting back to ideas and prizes, there's $20,000 of total prizes for Live, period. This time, what we're looking for are experimentations in social applications. Here are some examples.
02:33:50.210 - 02:34:35.386, Speaker E: Recently there's an interesting protocol that got launched called Lens Protocol and it's kind of a social graph smart contract framework that allows anyone to build social applications on top. And people have been experimenting with Lens plus Live Here building kind of video centric social applications that are pretty interesting. But beyond that, there's already a lot of existing examples that you can take a look at. There's an application called Discover that's been live for a while. There's application called Beam that's kind of a decentralized Netflix. There's. Lens tube.
02:34:35.386 - 02:35:10.342, Speaker E: Iris is another project that's building a life peer integration with Lens. So lots of interesting kind of opportunities here, especially if you think about incentive design and how you can create incentives for creators to come and be early adopters in these social applications on top of our creators. We also would love to see experimentations in the creator application space in the creator economy.
02:35:10.406 - 02:35:10.922, Speaker B: Right?
02:35:11.056 - 02:36:22.530, Speaker E: And I think there's already some really interesting creator applications in Web Three. NBA TOPSHOT is probably the biggest one if you think about the NBA or if you think about the basketball players as creators, they're able to sell NFTs through the TOPSHOT platform. Mirror is another good example where writers are creators and writers are able to use a number of different kind of value creation and value capture mechanisms offered by Mirror. And it's kind of a Web Three version of media. Another category that we're seeing a lot of interesting experimentation around is decentralized gaming plus streaming. So obviously decentralized gaming is not just about video streaming, but what we're seeing is when you add video streaming onto the gaming component, gaming becomes a lot more viral. And we've seen this in the Web Two world where games are now kind of almost created for twitch streams.
02:36:24.390 - 02:36:24.754, Speaker D: To.
02:36:24.792 - 02:37:17.950, Speaker E: Look really good and to look really fun, right? And we're starting to see even in game broadcasting components with SDKs like Genbid, where game developers are embedding video streaming capabilities in the game because it's such an effective mechanism for driving more gamers to come and play their games. So we'd love to see that. Of course, there's a lot of interesting it kind of crosses over with metaverse. A lot of interesting metaverses are being built in Web Three right now. Even see some weddings that happen in the metaverse, especially because of COVID So the first place is 10,002nd, place 7003rd, place is 3000. Come and find us at the booth. We'd love to help you with your hack.
02:37:17.950 - 02:38:12.994, Speaker E: We have our development team here, product team here. If you have any questions at all, if you want to talk to us about your hack ideas yeah, come and find us then we have a couple of minutes for Q and A. If anybody have any questions, I'm happy to have answer them. Yeah, really, really good question. So the question is about token gating, right? Like where is the token? Where where is the gating happening? Right? Really great question. The problem that it solves is that it's gating the actual video streams instead of gating just the front end web page. Right.
02:38:12.994 - 02:38:21.062, Speaker E: Because if you only get the front end web page, what happens is people gain access to the web page, go and copy the video URL and share it and it's over.
02:38:21.116 - 02:38:21.720, Speaker D: Right.
02:38:22.170 - 02:38:55.550, Speaker E: So the way this works is it actually issues a JWT in the video streaming workflow and it creates a session ID per viewer so that you're essentially giving about 60 seconds of viewing rights every time, every time it's being granted. And then you can re grant DataBoard.
02:38:57.830 - 02:38:58.146, Speaker D: Yeah.
02:38:58.168 - 02:39:52.760, Speaker E: So the question is about what about the back end? How does that happen? Currently, the application implements the back end. So you basically register a webhook callback URL and then the webhook just calls that URL with the parameters from the front end. Of course, if you want to build a DAP that you don't want to build in back end, how do you do that? Well, you can do a couple of things. There's two protocols that I know of that are working on this. One is called unlock Protocol, another is called lit protocol. Both of these things allow you to kind of build a DAP using the DAP architecture. If you're interested in building some tooling around those DApps with live peer, I think that would also be a fantastic hack and I'd love to give you a price for that.
02:39:52.760 - 02:40:28.526, Speaker E: Yeah. The question is, is there a way to upload audio files? And the answer is yes, you can upload audio files. You can also stream doing a live stream. Do a live stream of an audio only stream. And that would also just automatically work. You paper. Yeah.
02:40:28.526 - 02:40:38.910, Speaker E: Can you upload just an audio file? You can yeah, it's the I think it's the same way that you will upload a video file and then I see you can just upload the audio file.
02:40:40.050 - 02:40:41.560, Speaker D: So, um.
02:41:04.490 - 02:41:20.366, Speaker E: Yeah, good question. So for token gated streams, do the transcoders on the network have access to those streams? The answer is yes. It would have to go through the GPUs in order to get it transcoded.
02:41:20.398 - 02:41:20.980, Speaker D: Right.
02:41:24.630 - 02:42:39.770, Speaker E: You could configure the stream so that it doesn't get transcoded. The output stream would just be the source stream that comes in, if that's what you want to do. Okay. I think the question is about royalties, right? So if you want to create so, for example, if you want to create a video, create an NFT and be able to distribute royalty to the original creator, how that would work, is that right? Cool. It just works like creating an NFT that has royalty already built in. Right. So life here actually just gives you the ability to mint that NFT, whatever NFT that you want to mint, you can just do that.
02:42:39.770 - 02:43:15.320, Speaker E: The SDK basically allows you to specify the contract address, and from there, the SDK packages up the metadata in a nice format and puts it into IPFS so that you can just use that as your NFT metadata and everything, which can be done. And you can, of course, customize the metadata however you want for the NFT. For the way to.
02:43:21.770 - 02:43:22.520, Speaker D: That.
02:43:31.290 - 02:43:56.558, Speaker E: Yeah. Yeah. So the question is not, can I rotate between different transcoders so that no one gets the whole thing? Technically, yes, but you have to build it yourself. And the way you would do that is to run a light tier node.
02:43:56.654 - 02:43:56.962, Speaker D: Right.
02:43:57.016 - 02:44:30.980, Speaker E: And then you can just build that kind of scheduling mechanism into the node, and of course, the whole stack of lifetube is open source. If you're interested in doing that, I can show you where it is in the code. Last call. All right, well, thank you for being here. Yeah, our team will be here all weekend. I personally will be here all weekend, so come and say hi.
