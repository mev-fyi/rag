00:00:16.090 - 00:00:56.554, Speaker A: This is deployed optimism. 0.5 seconds, your money back. The first, like, five minutes of this talk are going to be me be talking about how to deploy. In the second 40 minutes of this talk are going to be talking about optimism in general, trying to answer architectural questions about what's going on under the hood. So this should be pretty quick because it's very easy. So if you were working on optimism, maybe about a year ago, you would have known that optimism used to be really annoying to deploy to because we had this custom compiler and it was a total nightmare and it made people really annoyed.
00:00:56.554 - 00:01:15.022, Speaker A: So we got rid of it. And I'll talk a little bit about how we got rid of it, but for now, the reality is it's really, really easy to deploy. Anything that runs on Ethereum should run on optimism one to one. The gas is all the same. The contracts are the same. It runs the same bytecode. You can use solidity Viper, whatever you want.
00:01:15.022 - 00:01:50.400, Speaker A: Works really, really well, and we spent a lot of time trying to make that happen. So deploying with Remix is very simple. First you got to add your network, the optimism network, to your wallet. So I made this website called Chainid Link, and you go to this link, chainid link, question mark network equals optimism and hit connect. And of course, I probably have signed oh, no, there we go. Oh, it's because I'm already connected, so whatever. I'll sign up to something.
00:01:50.400 - 00:02:13.174, Speaker A: There we go. Okay, right, boom. Connect to optimism, and I'm connected to I guess this should be optimism. Whatever. Cool. All right, so you do this with whatever wallet you have, connect to optimism, and then go to Remix and write your contract. And I have a simple contract here that doesn't do anything.
00:02:13.174 - 00:02:37.482, Speaker A: It doesn't matter. This is simple, but can be as complex as you want. Save it. Connect MetaMask to your injected web3 provider and that's it. Just deploy. And what is this? This is on main net. So there you go.
00:02:37.482 - 00:02:51.250, Speaker A: Deploying on main net. That's it. That's easy. It's the same thing. It's really simple. Just like deploying onto Ethereum, except it's faster and cheaper. Okay, we go back to this.
00:02:51.250 - 00:03:09.874, Speaker A: Doing it. So, with Remix, pretty straightforward, hard hat, also very straightforward. Same general concept. Just add optimism to your network config and deploy. I do have a very brief example of this straightforward. Look at me. This is my network config.
00:03:09.874 - 00:03:37.006, Speaker A: That's all I added. I just added an optimism network. And then I can deploy my contracts. So I have my adder, same thing as before. I have my deploy function, same thing as before. And deploy if it'll ever deploy. There we go.
00:03:37.006 - 00:03:49.966, Speaker A: That was easy. Okay, that's it. It's the same thing. This is why this talk is really boring. It's just showing you how to deploy a contract. Same thing with Truffle, literally just the same thing. You just add optimums in your network config.
00:03:49.966 - 00:04:36.974, Speaker A: Maybe I can share the slides later if you want the link to this, but very straightforward. Same thing with Brownie, except you don't even need to add it to the network config because it's in there already. And that's it. That's literally all it is. This is not a very interesting talk. So I will talk about the more interesting side of things, which is how optimism can actually be this easy to use, which is as a result of this concept of EVM equivalence, which is sort of a stronger form of EVM compatibility. Where this trick is, the EVM is a very delicate beast, and every time you change the EVM a little bit, you can say that you're compatible because you're compatible with all the RPC endpoints.
00:04:36.974 - 00:05:41.910, Speaker A: But if you change the behavior of the EVM, all of a sudden you get into sort of a weird state where you get developers who are relying on some very small feature of the EVM and you've told them that you're EVM compatible, but then this one feature of the EVM doesn't actually work. So are you really EVM compatible? I would say no, but because so many people have said, oh, I'm EVM compatible, that we've come up with this new idea of EVM equivalents where you're essentially just running an EVM that is like a production EVM that's being used to run the Ethereum mainnet. So it's the same exact virtual machine, and you can actually take this EVM and really run like a main net node with it. In this case, we're using Geth's EVM to do this so our client runs Geth. Okay. Yeah. So let's sort of describe at a high level why is this okay, let's describe at a high level how this whole system even functions, because it's quite interesting.
00:05:41.910 - 00:05:57.462, Speaker A: You have your layer one. Oops, there you go. You have your layer one. And your layer one is pretty you know what that looks like? It's a blockchain. Right? And then what we have is these two components. We have this thing called the op node. The op node.
00:05:57.462 - 00:06:28.022, Speaker A: And it pulls transaction data from layer one, sort of just, like, pulls in layer one blocks. And from these layer one blocks, it deterministically generates a list of layer two blocks. And then it takes these layer two blocks and it executes them. At this point, you just have, like, a blockchain on layer two, and it's fully derived from layer one. So just like a pure function on layer one blocks that generates layer two blocks. And then you need to execute those blocks. So executing the blocks just happens.
00:06:28.022 - 00:07:06.514, Speaker A: In Geth, we take Geth, and Geth has this very beautiful API called the Engine API, which is sort of a new thing for the merge. But what it allows us to do is to treat Geth like a thing that can be driven after the merge. You will no longer have the execution and the consensus. Parts of ethereum are being split into two pieces. So you have the part that executes blocks and you have the part that figures out what those blocks should be. And we sort of realized, oh, well, we can actually apply the same exact idea to layer two. Why not? You get the blocks from layer one.
00:07:06.514 - 00:07:36.838, Speaker A: That's the consensus. And you do the execution in this execution client. So in this case, the block execution literally just happens in Geth, which gives you this perfect EVM equivalence because you're not doing any sort of weird translation into a different virtual machine. You're just running Geth so everything just works how you would expect it to. Okay, first of all, before we do that, does anyone have questions? I guess it's a workshop. It's kind of like a lecture. All right, well, if people have questions, just stop me.
00:07:36.838 - 00:08:24.234, Speaker A: We could do the whole microphone thing. Let me move this up. Okay, so this is there we go. Okay, so part of the safety of an optimistic roll up is sort of the ability to prove let's go a little back. Essentially, if people aren't familiar with the idea of an optimistic roll up, you're publishing transaction data. You take transaction data from users, you sort of bundle it together and you publish it to layer one. And then what you're also doing is you're executing these blocks and you're generating the results, right? When you execute your block, you get a resulting state route that says, this is what the state of the system is.
00:08:24.234 - 00:09:10.538, Speaker A: You get a bunch of sort of information about the state of the system and we execute a bunch of blocks. And then after a certain number of blocks, we take the state root of that block and some other information about it, and we publish it to layer one. And the idea is that if we've published this data to layer one, then contracts on layer one can actually start to make decisions about what's going on on layer two. You can use like, merkel proofs to basically prove something about the state of layer two, given one of these sort of checkpoints, and it allows you to do so. Deposits into a roll up are very, very easy. It's just a transaction on layer one. And this allows you to do withdrawals from a roll up because you can do a proof that says, I can prove that you let's say you burned this amount of money on layer two.
00:09:10.538 - 00:09:55.558, Speaker A: I can prove that to you because I have a merkel proof, but I can only do that if I have something to do a merkel proof against. And that's what these checkpoints are. So we do these regular checkpoints that get published to layer one. And this gives something that contracts on layer one can execute a proof against so that they can make decisions about what happened on layer two. And this gives you deposits and withdrawals. But the question is, how do you actually guarantee that this thing that is being published to layer one, this state route, or this output that's being published to layer one is actually correct? Because it could just be anything. I mean, the whole point of the optimistic roll up is that you are not performing the execution of transactions on layer one.
00:09:55.558 - 00:10:36.118, Speaker A: So Ethereum has no clue if the execution result is correct. You're kind of just telling it this is what the result was. But it doesn't have any proof of this. So what we want to do is we have a program that we're running and we want to prove that that program ran correctly, right? We want to take this now. I'm getting these sort of mathematical stuff, but it doesn't really matter that much. We have a program, and we want to prove that the program ran correctly. That allows us to shit, say, based on the transaction inputs that we've published to layer one, the output, the state route that we published to layer one is absolutely correct, and it can't be wrong.
00:10:36.118 - 00:10:55.020, Speaker A: So how do you do this proof? Well, whatever. You have a program. What does our program look like? Our program, it takes L one blocks. It generates l two blocks. Then it executes those L two blocks. And then that finds that final state route from the last L two block. It's a very simple program.
00:10:55.020 - 00:11:15.474, Speaker A: And then, more generally, what is a program? Because it's important. We have a machine architecture. It can be whatever we want. It can be like X 86, or it can be something even simpler, or it could be the EVM. And then we define operations within that architecture. Essentially, we have Opcodes. Right.
00:11:15.474 - 00:11:51.258, Speaker A: So the EVM has a bunch of Opcodes. X 86 has Opcodes, blah, blah, blah. And it's a series of operations, right? And this is universal. Like, this is sort of what a program fundamentally is. And what we're really trying to prove is something about a series of execution steps inside of this machine architecture, right? It could be the EVM. We're trying to prove this Opcode happened, then this Opcode happened, then this Opcode happened, and I actually executed those Opcodes correctly. So we have this series of steps.
00:11:51.258 - 00:12:21.234, Speaker A: The EVM is fully deterministic, right? So given a starting state and the EVM, everyone gets the same result. This is why this entire blockchain thing even works. And we want to prove that we ran, let's say, the EVM correctly. So we sort of want to prove the correctness of this trace of you just think about it. The list of execution steps. That's what I mean when I say a trace. Just the list of things that happened except on Ethereum.
00:12:21.234 - 00:13:30.800, Speaker A: We don't want to reexecute every single step, because if we wanted to reexecute every single step, we'd be wasting a huge amount of gas and it'd be really, really expensive because the whole point of the optimistic roll up is to sort of not have to do all this work. And you really don't want this proof process to be executing an entire Ethereum transaction because it's really hard and really expensive. The question is, how do you do something like this with the EVM? Because it's a very complicated program. The answer is, well, either you go and you build an EVM interpreter in the EVM, which is a huge amount of effort and it's not worth it, or you can just do something much cleverer where you take your program and you compile it into a much simpler machine. So our program here is Geth, which is sort of like a slight wrapper around the EVM. And then we have these little other parts that I talked about figuring out the L two blocks and figuring out the final state route. You kind of think of that whole thing as your program.
00:13:30.800 - 00:14:02.600, Speaker A: And what you're going to do is you're going to compile it. So you're going to compile it into a simpler architecture, right? I mean, you can compile Geth, right? This is a thing that people do. So you take your program, you compile it into a simple machine architecture. And if we want to get an execution trace out of this, we run our program. It's a compiled binary. We run that with some input and we run an Emulator. And at every step we sort of record what the state of the machine was.
00:14:02.600 - 00:14:34.850, Speaker A: So we take what is the state of this virtual machine at step zero? Okay, the memory is this the program counter is this. The stack looks like this. You take that, you take a snapshot of it and you do that process for every single execution step. So you can't really execute this whole thing on Ethereum. A single transaction generates a massive execution trace. So you could, I guess, do this proof by just executing every single step on Ethereum and seeing what the result was. It should give you a result.
00:14:34.850 - 00:15:01.500, Speaker A: It's a machine, a virtual machine. You can run it on Ethereum just like you can run pretty much anything else on Ethereum. So you can run every single execution step on Ethereum, but it would take forever and it would be really expensive. So you don't want to do this. You instead introduce this idea of Bisection games. And this is sort of what Trubit really pioneered years ago and getting into some more annoying mathy terms. But you don't need to know about it.
00:15:01.500 - 00:16:03.726, Speaker A: The idea of the Bisection game is that if you think about your program as a series of execution steps, and you say that the starting step, step zero, is based on a known state, we all agree on step zero, but we disagree. And we agree on step zero because we must have sort of if you think about it from the optimistic roll up standpoint, let's say that each one of the things corresponds to a block. If I'm challenging block N, it's because I disagree with the result that was published for that block. But doing that is sort of an implicit statement that I agree with the result of block N minus one. Because if I didn't agree with the result of block N minus one, I would have challenged N minus one instead. So you can follow this logic backwards and backwards and backwards. And the idea is that you should be incentivized to always challenge the first thing that you disagree with because you should just challenge the earliest thing, because if you wipe whatever the point is you're going to challenge the earliest thing.
00:16:03.726 - 00:16:52.378, Speaker A: And so we agree on the starting state because the starting state is the output state of the previous block, which we agree on. So we agree on the starting state, but we obviously disagree on the ending state of running this virtual machine and we have to figure out which one of us is right. And if you sort of think about it, if we agree on the starting state but we disagree on the ending state, then at some point in the middle, there must be some step where we agree on the previous step, but we disagree on the next one. That's just sort of I could prove it, but it's sort of intuitive. At some point you got to a point where you disagree. So you want to find out how can you find this first execution step where you disagree. Because if you can just get down to executing a single execution step, that's very, very cheap.
00:16:52.378 - 00:17:41.454, Speaker A: And you can do that on ethereum, no problem. So you want to figure out how you and your sort of your adversary can the person who published this result or this output, this claim about the state of layer two, how you two can sort of play a game and figure out where this first disagreement is. And the process that we do is we generate our execution traces and we generate a snapshot of this machine state at every single execution step. And then we turn that trace, sort of we hash that snapshot and then we generate a merkel tree out of it. So if you think about the machine starts here and then the machine goes into its next state. And remember, this is all deterministic, right? The machine just operates on a state and it produces some output state. So you go from step one to step two to step three.
00:17:41.454 - 00:18:34.270, Speaker A: And at each point you're taking a snapshot and you're hashing it and then you generate this big merkel tree out of this array of machine states. And so then you want to try to find you and like I said, your adversary are trying to find the first step that you conflict on. And so what you do is you start making your way down the merkel tree and you look at each route and you say, do I agree with this route, this intermediate node of the merkel tree or not? At this point, let's say we've gone down the merkel tree and we say, okay, we disagree on both sides. Remember, this is in order of the execution. So this means we disagree on the second half of execution and we disagree on the first half of execution, somewhere in the first half. So we always want to find the earliest step. So we're going to start thinking about the first half of the execution.
00:18:34.270 - 00:19:01.714, Speaker A: And let's say, okay, we agree. We sort of go down here, and we agree on the first two steps. We agree on this route, but we disagree on this route. And so if we agree on this route, that means we agree on these two execution steps. We agree here. We agree here because we both have the same thing in our little merkel trees that we're comparing, but we disagree here. So now the question is, do we disagree here because this is different, or do we disagree here because this is different because they're both part of this intermediate node.
00:19:01.714 - 00:19:54.822, Speaker A: And then maybe as an example, you say, okay, we disagree because this is different, but we actually agree on the contents of this. So by doing this game, we just go back and forth and we compare our trees and we try to find the first node in the merkel tree where the hash is different. And that first node in the merkel tree where the hash is different represents or the first leaf node in the merkel tree represents the first execution step where you agreed on the previous step but you disagreed on the next one. So what we're going to try to do is we're going to try to execute this step because you're saying that the result of this step was X, and I'm saying the result of this step was Y, and we're going to figure out which one of us is right it. And we're going to do that by executing this machine step on Ethereum. So how do we do this? It's pretty interesting. We literally just built a machine interpreter in solidity.
00:19:54.822 - 00:20:34.710, Speaker A: So we deliberately picked a very simple virtual machine called or just simple machine architecture called MIPS. And it's about 400 lines of actual solidity code. So you can actually see a VM interpreter on chain for very little code, which is really cool. So just to reiterate the full challenge process, in a nutshell, someone publishes a proposed version of the l two state. This takes the form of a hash. Then somebody else comes in and challenges that state. And then the proposer and the challenger play this game where they go back and forth and try to find the first step where they disagree.
00:20:34.710 - 00:21:20.962, Speaker A: And so you find that step. So one of them now executes that machine step on chain, literally just like a virtual machine instruction on chain. And it's just a program, like a machine architecture is just a program itself that takes instructions and generates some output. So you execute it, then Ethereum knows who's correct because Ethereum is the one doing the execution, so it knows who wins. And if the challenger wins, then the state proposal is invalidated. So this means that somebody else has to come in and say, actually this was the correct result of executing that block on layer two or whatever it is, and then whatever. So optimistic roll ups are a solved problem.
00:21:20.962 - 00:22:01.394, Speaker A: I think this is actually very true. They're complicated, but not really in a lot of ways. That architecture that we were describing is actually very straightforward. The changes that we made to geth are like less than 400 lines of code total and I could have gone on for way, way longer, but I won't. So we can go to questions if people have any questions about optimism, how it works, any of these little there's sort of a lot of jargon in here, but mean yes. Do we have a little extra mic? Okay, yeah.
00:22:01.432 - 00:22:11.490, Speaker B: Thank you for the talk so far. My beginner question I would say, would be like, what's the benefit for me to deploy to optimism versus Mainet?
00:22:13.210 - 00:22:39.040, Speaker A: Sure, yeah. So the primary benefit is just that you're going to get essentially the same exact experience as on mainnet, except it's going to be way cheaper. And we could do this by kind of separating the execution like mainnet. You have thousands and thousands of nodes that are executing all these things. Optimism, it's just the people who care about optimism. There's just like a lot less people on the network. So it's just cheaper in general.
00:22:39.040 - 00:23:36.650, Speaker A: But yeah, so it's cheaper. We've added some interesting stuff to make it also faster, which is sort of these interesting things you can do when you are a layer two. You can introduce this idea of a sort of sequencer which is a block producer and the block producer can give you really fast, pretty reliable confirmations. And so you get sort of a much snappier experience. You get to see what your transaction did within like a second or two instead of waiting 15 seconds. And when constructed correctly, these things basically give you the same security guarantees as Ethereum with basically one added security assumption, which is that there's a single honest participant watching the chain and willing to perform the challenge process if necessary. So you get basically all the benefits of Ethereum with a single honest party assumption.
00:23:36.650 - 00:23:48.290, Speaker A: So you're not trusting like a majority of some set of validators just like one person on the network is incentivized properly to do this and it's cheaper and faster.
00:23:49.190 - 00:23:52.210, Speaker B: And you also pay with ETH and gas.
00:23:52.290 - 00:23:54.230, Speaker A: Yeah, you also pay in ETH with gas.
00:23:55.610 - 00:23:56.406, Speaker B: Thank you.
00:23:56.508 - 00:24:04.040, Speaker A: Of course, other questions we'll pass the.
00:24:06.990 - 00:24:30.638, Speaker B: I think we read up somewhere online that one of the sort of subtle differences between deploying on ethereum Mainet and deploying on optimism is that it said something about being careful about using block times for timings in your contracts. Could you maybe just allude to where that comes from? Why the block time is not consistent in optimism?
00:24:30.814 - 00:25:18.000, Speaker A: Sure. Yeah. So this basically comes from this block producer that we call the sequencer. And it's just that you can't make the assumptions around the sort of what's the word? Like the fidelity of the timestamp are a little weaker than on ethereum and it's because the sequencer has a little bit of room. You have to give them a little bit of room in when they can create their blocks. And so technically the sequencer within certain bounds can manipulate the timestamp. It always has to be going up and it always has to be basically within a certain window of the current actual ethereum time.
00:25:18.000 - 00:25:58.638, Speaker A: But there's leeway for them to go omitted into the future or something like that. Right. You can trust it for many things if you're just trying to keep time over the course of, let's say days or even hours, sort of longer periods of time where that minute or two minute fidelity doesn't really matter that much. But if you expect time to work within very, very tight periods of time, you sort of have to trust that the sequencer isn't going to try to use that to explicitly mess with your contracts. It's just something you need to be careful with, if that makes sense.
00:25:58.724 - 00:25:59.214, Speaker B: Yeah.
00:25:59.332 - 00:26:00.000, Speaker A: Okay.
00:26:05.510 - 00:26:12.534, Speaker B: How does optimism compare to ZK roll ups in terms of security assumptions and also speed now and also in the future?
00:26:12.572 - 00:26:49.998, Speaker A: I guess that's a good question. At the moment, optimistic rollups are functional. I'll say they're way more reliable. I mean, maybe except for like StarkNet, which is still in alpha. I guess one of the main selling points at the moment is that they're very functional. You have different assumptions about the safety. Really it all boils down to whether you want to make the one honest party assumption or whether you want no assumption at all.
00:26:49.998 - 00:28:03.154, Speaker A: And the R1 downside long term of the optimistic world is just that you have this basically you need to give people enough time to be able to actually challenge these state proposals. And so you need a window of time that we call the challenge period where somebody can come in and challenge something. Both of these things, I mean, the realistic thing is that optimistic roll ups are still 1000 times easier to build. And so there's sort of like the other side of the security argument which is like, how secure is it if there's like two people in the world that can really audit it? At what point is it the more complexity you introduce into your system, the more you're opening yourself up to bugs. It's just sort of like security ends up being this spectrum and we actually think in a lot of ways, optimistic roll ups end up being more secure, at least now, in the long term, like, I don't know, very long term for me, five plus years, you might see ZK roll ups. I actually think that the way to build these systems correctly in the future is to do an optimistic roll up. And then when these state results are published, these checkpoints are published immediately.
00:28:03.154 - 00:28:45.718, Speaker A: Start generating a ZK proof between the last two checkpoints that have been published. In the worst case, you get this optimistic roll up. If no one's publishing these validity proofs, it's an optimistic roll up. But when people are publishing the validity proofs, the validity proofs, you don't even need to think about waiting the seven day period. As soon as that validity proof is up, you're able to withdraw. So now it just becomes a problem of optimizing your prover so you can get very, very fast proving times and you can just publish these validity proofs very quickly. And so you cut down on your withdrawal time to be just the length of the proving time.
00:28:45.718 - 00:29:31.234, Speaker A: So I think realistically, that the future is probably going to be like a hybrid optimistic ZK thing. And luckily, optimism isn't designed in a way so you can slap this on the current system and you don't have to change anything. I just think it's, like, overly complicated is my answer for ZK. Cool? Other questions, comments, concerns, opinions. I think we got, like, 15 more minutes. Or if people are tired, we can just go to bed. All right, I think we're just going to call it.
00:29:31.234 - 00:29:36.000, Speaker A: We can just do questions afterwards if people have them. Cool.
