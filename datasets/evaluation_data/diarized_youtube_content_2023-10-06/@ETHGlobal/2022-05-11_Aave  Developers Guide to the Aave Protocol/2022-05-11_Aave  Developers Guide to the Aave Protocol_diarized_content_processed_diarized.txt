00:00:12.170 - 00:00:12.720, Speaker A: You.
00:00:15.170 - 00:00:31.374, Speaker B: Great. Hi everyone, thank you for joining us for our last talk of the day. Andrew is going to be doing an Ave workshop about developers guide to the Ave protocol. If you have any questions, just leave them in the chat on the side there and we'll get to them at the end of the workshop. You can go ahead.
00:00:31.572 - 00:00:55.514, Speaker C: Awesome. Yeah. Thanks so much. So, yeah, as said, my name is Andrew Schmidt. I am a Web Three developer at Aave, which basically means they do a lot of front end development, but also working with smart contracts and subgraphs and all the things that make Web Three protocols unique. And I'm going to talk about extensively how to develop with the Ave protocol. And so the agenda for today, first we're going to look at what's new in V Three, the features to build on top of.
00:00:55.514 - 00:01:37.042, Speaker C: And this is especially relevant because the hackathon prizes for Ave are all related to V Three integrations. And then I'm going to talk about how exactly to build. So if you want to write custom smart contracts, if you want to integrate Aave into a front end, that includes making transactions, getting live data, historical data, and then I'm going to do a live demo of the world's simplest flash liquidity. We're going to deploy and run a transaction. We can do it extremely simple in under five minutes. So for those that don't know, Ave 101, basically it is a protocol where people can participate as suppliers. So they're providing liquidity and they're earning interest in real time on their assets.
00:01:37.042 - 00:02:24.310, Speaker C: And then people are able to borrow that liquidity and pay an interest rate. And the borrowing happens in an over collateralized fashion. So in order to borrow, you have to have a sufficient amount of collateral and if that collateral amount ever falls below that amount, you have what's called a liquidation where someone comes in and pays back their debt and then is able to claim a portion of their collateral plus a small fee. And this is able to keep the protocol as a whole over collateralized and keep the system in check. And so Ave has this concept of markets. So a market is basically just a deployment of the protocol mainly to certain networks. So here is like the Ave landing page where we have a lot of the different networks that the protocol is currently deployed to and kind of bridges into what's new in V Three.
00:02:24.310 - 00:03:10.274, Speaker C: So there's three main kind of sections of innovation. We have capital efficiency, risk and then decentralization. So starting with capital efficiency, the big one is portals. So portals is a way to facilitate cross chain transactions. So previously, if you want to move funds between different deployments of the Ave protocol, you basically have to withdraw your liquidity from one market, bridge it and then supply it on the other instance. But what portals will allow you to do is it'll allow bridging solutions to mint unbacked a tokens. So as a user, instead of withdrawing Bridging and redepositing, you can just do this all within one bridge transaction.
00:03:10.274 - 00:04:02.034, Speaker C: And this will allow funds to seamlessly flow between these networks. And the way that bridges are approved is through the governance process. So currently, I don't know if it has started yet, if not, it's starting in the next couple of weeks is the first round of approving bridges for this. So currently this is not something that you can build on top of, but it's something to keep in mind for hackathon projects, because having a MultiChain approach and building dashboards and tools is definitely something that would be applicable for V Three. And the next is something that is live is efficiency mode. So this is a way to maximize collateral efficiency by increasing the collateral factor that's available whenever you're deposit or supplying and borrowing assets within a same asset group. So, as you can see in this diagram, you have USDT, Dai, USDC, these are all stablecoins.
00:04:02.034 - 00:04:33.594, Speaker C: And then you also have an ETH asset group. And within these assets you're essentially able to create a leverage position where you're getting more exposure to these assets. But it's not as risky for the protocol because they are all very correlated in price. And so liquidations become extremely efficient here. And so this is basically just a way to provide enhanced risk parameters for assets in the same category. Next is risk and security. So there's a number of different things that governance is able to now enact to keep the protocol a lot safer.
00:04:33.594 - 00:05:05.110, Speaker C: So the first two are borrow and supply caps. These are pretty easy to understand, they're basically just a limit that's placed on individual tokens. So say I can only supply a certain number of this asset or only borrow a certain amount of this asset. And this prevents against things like infinite Minting exploits or exploits which require draining the entire liquidity. So borrowing all of an asset and then using it to perform some certain action, this is a prevention against that. And the next we have isolation mode. So this is particularly useful for new asset listings.
00:05:05.110 - 00:05:55.590, Speaker C: So when an asset is listed in isolation mode, essentially it can only be used as a collateral by itself and it can only be used to borrow stable coins against it. And what this does is it basically allows the protocol to take the risk of listing this asset and isolate it to only these certain asset pairs. So it has a much minimized risk impact on the protocol as a whole. And this is great for newer assets which want to essentially get introduced to the protocol with conservative risk parameters to start out with and essentially prove themselves as a viable candidate for being fully listed as a collateral asset. And next is decentralization. So there's a number of things that the government is now able to have. So we have risk admins and these are basically entities that can be whitelisted in order to update the parameters of certain assets.
00:05:55.590 - 00:06:40.822, Speaker C: Update things like the interest rate parameters, the collateral factors, liquidation thresholds, we also have listing admins. So these are people that are able to enact strategies for listing assets. So say they are only able to list assets in isolation mode or up to this certain borrower supply cap. And this is particularly interesting to look into for a hackathon because you could create essentially strategies for creating automated listing admins based off of a certain amount of staked tokens or a certain parameters of the assets. So basically it allows for permissionless, asset listing and it happens through this whitelisting process where the government is whitelisting an address and then this address can perform.
00:06:40.876 - 00:06:43.846, Speaker A: This function and then some other features.
00:06:43.878 - 00:07:33.254, Speaker C: That are very useful. Introduction of Permit so instead of having to approve the tokens in order to supply or repay, you're now able to do a gas list permit function, saving users fees, repayment with a tokens. So if you have supplied and borrowed the same asset, you're now able to repay with those a tokens instead of having to perform a flash loan and a swap, which is currently what the repay with collateral feature does, then we have a simplified flash loan function. And this is actually what we're going to be using at the very end of this presentation. I'm going to show just how simple this function can be and it's also 20% more gas effective and we also have a flash borrower role. So currently you have to pay a fee when you're taking out this flash borrow position and people with the flash borrower role will have this fee waived for them. And this is again approved by governance.
00:07:33.254 - 00:08:20.918, Speaker C: And finally listed assets can support multiple incentives. So you can be earning a bunch of different rewards for supplying or borrowing one asset. So, building on top of the protocol, I'm sure this is what you are all here to see. So the main point of integration for the protocol is this pool contract. So the pool is basically what handles the logic for the entire protocol. And this is also where most of the main functions exist. So the core ones supply, borrow, repay, withdraw, in addition to kind of the periphery functions like liquidations and flash loans and enabling emode and enabling collateral, basically anything that involves a user interacting with the protocol, that core logic exists in the pool contract and then so how do you actually interact with these contracts? Well, there's a few different ways.
00:08:20.918 - 00:09:06.982, Speaker C: Probably the easiest way if you're developing smart contracts natively is to import these NPM repos. So the ave core repo, this is where the pool contract is held and the core logic for a tokens and debt tokens. And then we have this periphery repo which we'll touch on a few of these contracts in the next section. But this is also where the rewards contracts are. So for claiming rewards for querying reward balances within smart contracts and then finally for calling these functions, we also have a JavaScript SDK. So this allows you to import objects. So you would import say a pool object and then instead of having to import an Abi and do all this work you could just call pool supply and perform these transactions directly from your front end.
00:09:06.982 - 00:09:58.082, Speaker C: And so what I got a QR code here for is just the Ave NPM registry where you can view all of the different packages that we have listed. There's quite a few ones that I don't have listed here that are still quite helpful for oh and then finally down here at the bottom, if you want to interact with an Ave contract, obviously you'll need the address link or the contract address. And so this link and the docs in general will give you all of the links from the different markets so that you can make the correct contract queries. And then finally for smart contracts I want to highlight the Ave sandbox. So this is a tool that lets you take any production V three or V two market and create a fork of it inside of a hard hat node. And one really cool feature of this is that you're able to faucet all of the production assets. So say you want to test an extreme position where you're supplying a whole bunch of a different asset.
00:09:58.082 - 00:10:15.150, Speaker C: This allows you to do this in a production environment. By using the faucet you can also connect this sandbox to the Aave front end to test your features directly. So it's just a really useful tool if you're ever trying to extend the Aave contract logic or if you want to test some feature.
00:10:15.890 - 00:10:17.470, Speaker A: The next is for live data.
00:10:17.540 - 00:10:59.014, Speaker C: So if you want to essentially integrate what is currently live on app Aave.com into your own interface, the easiest way to do that is with these two contracts. So the Uipool data provider is where all of the reserve and user data can be fetched. So these two functions will essentially return an array of every single thing you could want. So for Getreserves Humanized, this is going to return an array of all of the different assets with their parameters, their current interest rates, what is the current total liquidity, the total amount borrowed, the interest rate curves, you can see the parameters. For user reserves this is all current position. So all of your a tokens, your debt tokens and then for incentives it's pretty self explanatory.
00:10:59.014 - 00:11:25.700, Speaker C: For Get reserves it's all of the assets which are currently earning incentives. What's their emission, what is the APY then? The Get user reserves is all of the reserves that a user has claimable and the contract helpers. The SDK that I mentioned earlier also has objects in order to query these contracts directly as well. So the SDK is not just for submitting transactions like supplying and borrowing. It's also for fetching data.
00:11:26.550 - 00:11:28.482, Speaker A: And so after you fetch this data.
00:11:28.536 - 00:12:06.314, Speaker C: Probably what you'll want to do is format it. So when you fetch data directly from contracts, it'll be formatted with decimals. You won't have the USD values. And we have this other contract package called Math utils. And this exposes two extremely helpful functions. You can take the data directly from those contracts I just mentioned, and when you pass it into these two functions, you'll get out an extremely nice user readable summary with all of the interest rates formatted correctly, all of the USD values formatted correctly. And the user summary will also calculate the user's health factor, their current collateralization, all of these useful fields.
00:12:06.314 - 00:12:10.386, Speaker C: Anything that's shown on the Aave front end comes from these two functions right.
00:12:10.408 - 00:12:13.502, Speaker A: Here and for historical transactions.
00:12:13.566 - 00:13:02.014, Speaker C: So when you query live contract data, you're getting a view of what the contract is like currently at this current state. But if you want to get historical data so fetching all of the transactions for a user, the historical interest rates, the historical balances, either for a user or say, you want to get the total liquidity for a certain asset on a certain block, that's what the subgraphs are most helpful for. So I've linked the GitHub right here in this GitHub. It will show you all of the different deployments. So each market has its own subgraph deployed for it. And there's also a lot of helpful examples in this repo of queries for fetching the user transactions, fetching historical things. And you can also use this subgraph data directly with the Math utils package because the subgraph data is going to be formatted the same way as the contract with the decimals, the USD values.
00:13:02.014 - 00:13:25.434, Speaker C: So this math utils can be very helpful for formatting this subgraph data as well. And so now we'll move on to the demo. So I would actually encourage people, if you're able to, to follow along, because this demo is extremely simple. You'll be able to deploy and run your own flash loan. And I'm confident less than five minutes. It's not a joke. So I'm going to show you just how easy this can be.
00:13:25.434 - 00:14:00.494, Speaker C: So when you scan this QR code, you're going to get to this repo, which I put together. And so in B three, there's two different types of flash loans. There's a batch flash loan, which lets you do specify multiple assets, and the simple flash loan, which is the new one. This just lets you specify a single asset and a single amount, greatly simplifies the process of taking out these flash loans. And so I'm going to do an example with this simple contract. So all you have to do is open this up and it's going to open your contract directly inside of Remix. Remix is an IDE for developing, deploying, interacting with smart contracts.
00:14:00.494 - 00:14:26.410, Speaker C: And if you're not super familiar with Remix. I've also linked a tutorial here from Chainlink. It's an awesome guide for getting started with it. So what do we do with this contract? First we'll just take a look at the logic inside of it. So it is about as simple as you can possibly get inside of this execute flash loan function. What we're going to be doing is we're going to call this function on the pool contract. We're going to be specifying an asset and an amount and the receiver address.
00:14:26.410 - 00:15:05.638, Speaker C: So where these funds are actually going to get sent is to this. So they're going to get sent to this exact contract and they're going to get sent to this function right here called execute operation. And so inside of this function is where your logic would go. If you want to perform any action, call any smart contract function for liquidations, for arbitrage, for moving funds. You can input any logic that you want right here. And at the end of the transaction what it's going to do is it's going to calculate the amount that you owe the premium and this is specifically for testnets. So it's going to take the ave faucet and faucet the funds to cover this fee so you don't have any overhead.
00:15:05.638 - 00:15:14.140, Speaker C: It's extremely, extremely simple. And then this approved is how the pool is going to pull these funds out after the transaction is over.
00:15:15.150 - 00:15:16.366, Speaker A: So what I'm going to do here.
00:15:16.388 - 00:15:30.066, Speaker C: Is I'm just going to compile this contract first. So when you're compiling a contract it's important to match the version of solidity. So we need to use the eight point ten compiler and after we do that and this loads we'll be able.
00:15:30.088 - 00:15:40.578, Speaker A: To compile our contract should compile over. K doesn't usually take this long.
00:15:40.744 - 00:16:18.930, Speaker C: So okay, our contract has now been compiled and we can go to this other tab and this is where we're going to deploy our contract. So most of the time your environment is going to be set to injected web3. This will link to your custom, this will link to your MetaMask wallet or any other injected provider like frame, whatever you want to use. So currently I have my MetaMask wallet connected here and what I'm going to do is you're going to want to deploy the Mysimplean contract. This is this contract that we have open right here. And when you deploy this it's going to take two different parameters. So it's going to take the addresses provider, this is going to be the market which you want to borrow the funds from.
00:16:18.930 - 00:16:54.990, Speaker C: And then specifically for the testnets we're going to include a faucet and this is where we're going to faucet those funds to cover the fee. And I've included all of these addresses here inside of this repo so you don't have to go hunting for them. One other step that is not mentioned here, but you will need the base token for the network. So for example, if I want to do this contract on Arbitrum Rinkbeat, which is what I'm currently going to do, I need Arbitrum Rinkbeeth in my wallet. And if you just Google the faucets for these different networks, each network hosts their own faucet where you can get these assets, and then they'll just send them directly to your wallet.
00:16:55.730 - 00:16:56.046, Speaker A: Yeah.
00:16:56.068 - 00:17:00.830, Speaker C: So after I input these addresses here, the address provider and the faucet.
00:17:01.250 - 00:17:03.754, Speaker A: Now I'm going to deploy this contract.
00:17:03.882 - 00:17:05.178, Speaker C: So this is going to trigger a.
00:17:05.204 - 00:17:08.066, Speaker A: Transaction inside of my MetaMask need to.
00:17:08.088 - 00:17:19.060, Speaker C: Hide my zoom thing here. And after I confirm this transaction, it's going to deploy this contract to the Arbitrum Rinkbe test network. Should be extremely quick.
00:17:19.670 - 00:17:20.082, Speaker A: Okay.
00:17:20.136 - 00:17:59.982, Speaker C: And now after this transaction is confirmed, we now have our deployed contract right here. And the function that we're going to be using is this one down here at the very bottom. This execute flash loan function. And so inside of this, it takes two parameters the asset that you want to borrow and the amount. So how do we get these? So inside of this guide, I explained that in order to get the asset address and the available amount, what you're going to want to do, probably the easiest way, is to do it directly from the Aave front end. So on the reserve overview page, you're going to get this view. So in order to get the asset address, all you have to do is click this link and it'll open it in a block Explorer.
00:17:59.982 - 00:18:23.660, Speaker C: And this will also give you the token decimals. So when you're inputting an amount to a solidity contract, you're going to have to input it as an integer. And so each individual asset will have its own number of decimals. So if I want to just take a flash borrow of five USDC, I'd have to input five with then six zeros after that, and that number would represent five.
00:18:24.750 - 00:18:26.394, Speaker A: So that's what I'm going to do right now.
00:18:26.432 - 00:18:31.980, Speaker C: I'm going to go to the details page for USDC. I'm going to open this.
00:18:33.470 - 00:18:36.194, Speaker A: Oh, no, it opened my zoom window.
00:18:36.262 - 00:18:59.918, Speaker C: But here. So this is the asset. And if you click this token page, this will bring you to a page where you can see the decimals of the token. So I now have the address and I have the decimals. And so for the amount. So in order to get the amount that you can borrow, it's the total amount that is supplied minus the total amount borrowed. So this is just the amount that's outstanding in the contract.
00:18:59.918 - 00:19:29.754, Speaker C: So I can see that there was 5 million supplied and zero borrowed. So there's 5 million available for me to borrow. I'm actually going to borrow a little bit less than that. There might be some rounding. And so you always want to go a little bit less than what you see. So believe this is 4 million and then adding 1234 or five six decimals to account for the USDC decimals. So what this contract should do is borrow this 4 million USDC from this pool and then just return it in the same transaction.
00:19:29.754 - 00:19:37.746, Speaker C: It's about as simple as a Flash borrow as you can possibly execute. So let's see once this transaction is.
00:19:37.768 - 00:19:45.070, Speaker A: Confirmed come on, Minimask.
00:19:48.210 - 00:19:50.530, Speaker C: Okay, it looks like it was confirmed.
00:19:52.070 - 00:19:54.462, Speaker A: So we're going to open this in a Block Explorer.
00:19:54.606 - 00:19:57.090, Speaker C: Oh, this is not the right Block Explorer.
00:19:58.310 - 00:19:59.714, Speaker A: I want to use a slightly different.
00:19:59.752 - 00:20:00.820, Speaker C: One so I can.
00:20:03.130 - 00:20:11.846, Speaker A: See the amounts. Okay, so I input the hash of.
00:20:11.868 - 00:20:58.210, Speaker C: This transaction and of course it's not found yet. Well, I guess I will just go talk about it and then hopefully we will revisit this link once the transaction hash is available. Yeah, so basically that's probably the simplest possible way that you can execute a Flash borrow. And so as I kind of mentioned earlier, this is only for testnets. So because it uses the faucet, obviously you can't faucet on a main production network. But this is a great way for you to test your logic, get a contract out there, deploy it, run it, and then once you have your logic refined, then you can remove that faucet, deploy your contract to mainnet, and do whatever you were hoping to do with your Flash.
00:20:58.370 - 00:21:00.774, Speaker A: So now to the fun part.
00:21:00.812 - 00:21:40.862, Speaker C: So, prizes. So the prizes that Ave is currently offering for the hack money, hackathon is for all for Ave V Three integrations. So mentioning a bit like what kind of things you could build. So basically anything that involves interacting with the Ave V Three pool. So supplying funds, borrowing funds, implementing some sort of data dashboard for these, doing something with the new simple Flash loans, doing something with emode, coming up with a novel way for asset listing or integrating permissionless. Asset listing through the borrow caps and supply caps and isolation mode. So the possibilities are really endless.
00:21:40.862 - 00:22:19.678, Speaker C: And I really encourage you guys to be creative, think outside the box. There's so many things that can be built with this protocol, and I encourage you to take risks. So, some resources, this is yet another guide to this, details the process of building with these B Three features. And then we also have a very extensive developer docs which walks through basically everything that I've gone through today in more detail. And then finally, even if you build a really cool project and you don't win the hackathon, not the end of the day, because there are still grant programs which will sponsor you to continue building these projects and contributing to the protocol. So with that, it's the end of the presentation.
00:22:19.774 - 00:22:21.906, Speaker A: I will go back and check on.
00:22:21.928 - 00:22:23.540, Speaker C: Our transaction real quick.
00:22:28.230 - 00:22:31.650, Speaker A: Is it still not found? That's a bummer.
00:22:33.110 - 00:23:08.020, Speaker C: Well, we can see it in the other Block Explorer, I guess, but now I guess I can now open it up for questions as well. We wait for this. Hey, I love your comment, but is there any questions from the audience? Keep refreshing, I want this transaction to show up.
00:23:14.940 - 00:23:24.270, Speaker B: So someone below is asking if you said my idea is to add NFT as collateral to Aave and wonder if you're already working on this question mark.
00:23:26.160 - 00:24:01.480, Speaker C: I think it's something that's being researched. It's quite a difficult topic because NFTs are non fungible. This kind of eliminates the ability of using this pool model. And so the pool is kind of what makes Aave unique in that it has the pool of all of these assets where everyone is created equally. So it's definitely something that could be researched using a similar Ave model to governance and listing certain collections as pools. But I don't think it's something that's directly applicable to the Aave protocol.
00:24:03.500 - 00:24:03.960, Speaker A: Perfect.
00:24:04.030 - 00:24:25.710, Speaker B: Do we have any other questions from anyone? We'll also have the Discord open. Under ETH Global there is an Ave sponsor channel where you can go to all your questions. There we go.
00:24:42.090 - 00:25:15.950, Speaker C: Through a smart contract. Is there a way to harvest programmatically? So I'm assuming this means well, there's kind of two different forms of yield in Ave. So you have the interest that you're earning from borrowers and then you also have incentives. So you are able to do both of these programmatically. So your borrowing interest is actually accrued automatically. So you have what's called a token. So whenever you supply a token to the protocol, so you supply ten USDC, you'll receive ten a USDC and that balance will be continuously increasing with the interest that you're earning.
00:25:15.950 - 00:26:02.954, Speaker C: And then you'll also have rewards that you could potentially be earning. And for those rewards there's a separate contract called the rewards controller. And this is under the V three periphery repo that I mentioned. And inside of this contract there's a function called Claim Rewards. So you're able to do that manually or also programmatically from another smart contract using Vanilla JS. Is there a way to take advantage of the Ave utilities? So this is actually something that's on the roadmap. Currently the Ave utilities is only written for Es six.
00:26:02.954 - 00:26:33.606, Speaker C: So this is basically react JavaScript. It's something that's on the roadmap to make it compatible with Vanilla JavaScript. I would still recommend if you want to just look through the source code, there could be bits and pieces that you could take out if you're looking for just doing specific things like calculating the compounded interest or calculating a rewards balance. But no, we don't currently have exported functions for Vanilla JavaScript. Oh, that is a great point.
00:26:33.788 - 00:26:36.310, Speaker A: I should be on test at Harpis Scan.
00:26:50.410 - 00:27:16.318, Speaker C: Thank you so much Sandor. I am sure it will be here. Perfect. So here is the transaction we executed. So you can see that this is the pool contract. And so the pool contract sent our contract 4 million USDC. And then we used the Faucet contract on the testnet to mint this 2000.
00:27:16.318 - 00:28:01.530, Speaker C: This is the fee for performing the flash borrow. And then at the end of the transaction, this 4 million plus the 2000 that was minted is returned back to the pool. So if this were to be implemented on a live production network, essentially the only thing that would be different is this step right here. So you wouldn't be able to mint the tokens to enable to perform this, but you could essentially get these tokens from any other source. So say you wanted to front the transaction yourself, so you would fund this 2000 USDC. Or if you were performing something that freed up collateral, you could then use a portion of your collateral to pay back this fee. Or if you're earning simply a bonus for performing something like a liquidation or an arbitrage, that's where these funds could come from.
00:28:01.530 - 00:28:14.320, Speaker C: So this contract that we demonstrated is meant to just be a nice example of the things that you can possibly build with flash loans. So I hope this is a good starting place if you were hoping to use this feature in your project.
00:28:18.170 - 00:28:18.822, Speaker A: Great.
00:28:18.956 - 00:28:32.446, Speaker B: Thank you, Andrew. That was very informative. I'm sure everyone enjoyed that. As I mentioned before, if you have any questions, bring them over to discord board. And I think that's all from our end, I think. Don't see any more questions. I guess we'll call it a day.
00:28:32.446 - 00:28:41.600, Speaker B: Today's the last day. Sorry, tomorrow is the last day of workshop. So thank you for joining us for the last one today. And there's plenty more tomorrow, so we hope you guys tune in.
00:28:42.770 - 00:28:45.050, Speaker A: Yeah, thanks for watching, everyone. Bye.
