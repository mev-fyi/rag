00:00:00.170 - 00:00:20.254, Speaker A: Any of the products that use our infrastructure yourself at some point maybe. I don't know if you have traded on Quickswap or like Spooky swap on Phantom or used Inserter before something. They're all using our infrastructure for one use case or another. So yeah, if you have so definitely let us know. Awesome to hear.
00:00:20.292 - 00:00:52.730, Speaker B: Always cool. So it looks like. So let's get started. Hello, welcome everyone, to the Gelato workshop. It's nice of you to join us this evening or afternoon or morning, wherever you are, depending on where you are in the world. So we have Helmar from Gelato doing his workshop on how to automate your smart contracts using Gelato. And with that being said, drop your questions in the Zoom chat if you have any and I'll pass the mic off to Hilmar.
00:00:54.050 - 00:01:39.910, Speaker A: Yeah, hi everyone. Thanks for joining me here for this small workshop that I will be giving Brandon, by the way. Also in this call is also available in the discord chat or wherever you are to help answer questions. And yeah, I will try to be as quick as possible, but still if you want to dive deeper into certain bits within this process, then just let me know in the chat. I've got the Zoom Call chat right next to me here. So I see when you ask some questions, but yeah. So, automation on Ethereum, on smart contract land, how does it work? You will find it all out today.
00:01:39.910 - 00:02:50.526, Speaker A: And we've been actually working on our product or on our developer tooling for over two years now. Being kind of like web three Ethereum developers ourselves back in the day. We kind of stumbled upon the issue of if you want to kind of automate certain smart contract executions on Ethereum or any other smart contract platform, you kind of have to run your own infrastructure, your own server, somewhere off chain yourself in order to kind of periodically call certain functions. Let's say you want to execute a trade on uniswap every day for the next 30 days. You kind of don't want to do it yourself manually with your MetaMask. You kind of want to kind of automate that whole process, right? And this is kind of like a bit complex on Ethereum or on smart contract platforms in general. And especially the question always is who is running that server, that automates that transaction, right? Is it just like your small server running? And then what happens if your server is down and if you're not the only user of that kind of automated feature, maybe like 1000 people rely on it working adequately, right? And then your server goes down and the whole thing doesn't execute anymore.
00:02:50.526 - 00:03:54.278, Speaker A: Like what happens then? Right? So all of these questions we are going to answer today and yeah, so this workshop is of course around Gelato, but I will actually walk you through like a simple to use use case, what you can do and this is how you can lick your ice cream NFT every five minutes on ethereum. Or we will actually do it probably on another network that is a bit cheaper. But yeah, so we'll have an NFT and this NFT lives on polygon, for example. And we want to lick it every five minutes. And if you lick it, one scoop of this delicious ice cream NFT will disappear and you can only lick it every five minutes however, because if you lick it every couple of seconds, then you get brain freeze. So in order to kind of like not to have to do that manually, of course, because you don't want to wait there and click every five minutes to lick it, we will automate it and I will show you how to do it using Gelato. But yeah, maybe before we jump into the whole tutorial, I just want to give you a quick overview of what Gelato is.
00:03:54.278 - 00:04:57.258, Speaker A: Gelato is kind of like a middleware developer tooling project. It's fairly similar to, for example, the Graph, but a bit different in the sense that you don't just have certain servers running that read data from the chain, you actually have servers running at your disposal that can write to the chain automatically. And yeah, basically it enables you to build what I like to call serverless applications. So your DAPs, you can just deploy your DAP, you can automate transactions happening in your system and all of that without having to run your own centralized script or server somewhere in the cloud, for example. You can just leverage an already existing decentralized infrastructure, the Gelato network, to do all of that. Yeah, so why do you need that? Right? So as you probably know, or you are kind of like learning at the moment is that smart contracts are actually not that smart, right? They are pretty dumb. They just store certain logic, they store certain state.
00:04:57.258 - 00:06:15.860, Speaker A: But if no one executes these functions within these smart contracts, then nothing will actually happen. They will just stay there and do nothing forever, right? So only when a transaction is being sent to that function will the logic within it actually be executed, right? And so if you have a function that kind of like does payouts to your users every day, for example, and no one calls it this payout will never happen, right? So you want to write like a bot, so to say that kind of like monitors, okay, every 24 hours and then it calls that function, right? And it usually takes quite a lot of time to build, monitor and maintain these bots. And I'm not talking about just running a simple script that kind of does one transaction maybe for you every day or so. I'm talking about building a production ready system where you have thousands of users and you rely of these thousand transactions being executed at the same time without getting stuck and with getting resubmitted and stuff and to do that is actually not that trivial and it requires a lot of time and effort. And what it does, it distracts you away from what you should pre primarily focus on, which is the UX and your users, right? But also if you kind of build it yourself and you run yourself, then you are basically the central point of failure. Your server goes down, the whole depth goes down. That sucks, obviously.
00:06:15.860 - 00:07:03.074, Speaker A: And usually what projects like MakerDAO did in the past. They had to build up this whole notion of their own keeper system where they incentivize other people. They had to build these clients. They had to incentivize a lot of other players to start running them for them and stuff, which allowed you basically can skip all of these processes. You can just plug into an existing decentralized network and you are good to so this is what Gelato is. It's kind of like this on chain bot as a service API that you can call it saves you a lot of time, it's super reliable, it's decentralized, so there's no single point of failure. And it's actually very cheap because you don't need to incentivize bots to only execute transactions within your application.
00:07:03.074 - 00:07:51.534, Speaker A: Because these bots are executing transactions on Quickswap, Spooky, Swap, Insadep, MakerDAO, whatnot they kind of pool these transactions together and because they're executing so many, they have to extract very little value out of each single one in order to actually turn a profit. And yeah, so these are kind of like some of our users, incident Keeper, Dow, Fukumbo, Quickswap. Whatnot a lot of projects used to allow these days and how it works is these bots execute transactions. Let's say the bot has to pay ten cents to the miner, right? And for you to order, in order for in order for you to get a transaction mined, you have to pay the bot, for example, twelve cents. And then the spread is basically what the bot receives. There's this beautiful Gel token as well. And the Gel token is basically stake that bots have to stake in the Gelato network.
00:07:51.534 - 00:08:30.734, Speaker A: And only if they stake, they can have access to all these transactions that are automated within the Gelato network and they can make a profit. And the more transactions executed by Gelato, the more potential revenue the system has, the more the bots will have to stake and so on and so on. So kind of like a positive feedback loop and yeah. So what's the token for? As I said, Staking, if these bots somehow decide not to execute a transaction, even though they should have, then they can be slashed and there's a governance that kind of like controls this whole mechanism. Very simple. And because slides are boring, let's jump right into the demo. I think that's the most exciting part here, right? And yeah, if you have any questions, let me know.
00:08:30.734 - 00:08:58.466, Speaker A: In the chat, I thought there already been a couple of questions. But Brandon, you were so kind and answered them, which is very nice of you. Okay, so there's this application. Let me just make sure I think the screen is big enough, right? I zoomed in a bit. Let me know in the chat if you don't really see that. But yeah, so it's available for you as better app gelato Network. And the application we are showing you today is called Gelato Ops.
00:08:58.466 - 00:09:38.338, Speaker A: Right? And Gelato Ops is kind of like the entry point to Gelato where you can go to Gelato and tell it to execute anything you want, basically. And we have this beautiful tutorial right here where it's still in beta. So I don't know why this X is over there, but it's just like that. You have to create an issue on our repo to request it to move to the right. But what you do is you click Create Tutorial here and then we will walk through you through, like, an example that you can use. And usually what you have to do in order to automate a smart contract is you have to have that smart contract you want to automate in the first place. Right? So in this example, let's just say this smart contract that we want to automate is an ice cream NFT.
00:09:38.338 - 00:10:04.054, Speaker A: And with this transaction, we will now mint this ice cream NFT. By the way, we are on the Polygon network. Why? Because it's very cheap and fast. But this also works on Ethereum, Mainet, Robson, Ringby, Phantom, and also Arbitrum. So there are a variety of networks you can choose from. Now, what we see here is that we have the smart contract deployed. That's nice.
00:10:04.054 - 00:10:31.154, Speaker A: And we can decide what we want to automate on there later. But now it will ask us to deposit some funds in there. Right? And why? Because these bots, they need some money to pay miners. That's why you need to deposit some funds in Gelato. And this is just like a prepaid SIM card. Basically, you click on deposit, you confirm, and then the transaction is being mined in the background. And now you basically have one matic worth of balance on Gelato to pay for your transactions.
00:10:31.154 - 00:11:09.170, Speaker A: Now let's get to the fun part and say Create task. And now we can create the task, which is basically, okay, how can we communicate to Gelato what we want to automate? Okay, so what we want to automate in this case is we minted this delicious ice cream NFT. You guys remember? And the sweater keeps them warm when licking ice cream. Indeed, it does hopefully give you warm spitzer and it's very cold. But yeah, let's not get distracted from the tutorial here. So we got the ice cream, right? And let's say lick Hilma's ice cream. Hilma is my name.
00:11:09.170 - 00:11:50.142, Speaker A: And the ice cream is what we want to lick. And it sounds wrong, maybe, okay? But let's just go with that. For now. And now what we can do is it will ask us for a contract address which we want to use to automate a function on. Okay? And luckily this tutorial shows us the contract address of the NFT we just minted right there. And so we can just paste it in here and what it does, it fetches the Abi from PolyScan where it was verified automatically. And what we can do now is we can see all of the functions that this smart contract has, right? And let's say there's this Lick function, right? And this is the Lick function we want to actually automate and call every five minutes.
00:11:50.142 - 00:12:45.986, Speaker A: So you click on it and then it will ask you to either predefine an input that you want to pass to that function or you can actually dynamically derive these inputs via a secondary smart contract called a Resolver. We can maybe walk through that example later on if we still have time, but for now, we just use the simple predefined inputs option. So my token ID is number 22 as you can see here. So we type in 22. And now the second kind of like step window opens here. And what we can do here is we can define what interval we want to use to kind of periodically call this function. And in this case, let's just say we want to call it every five minutes, right? And because we selected start immediately right here, what we will do is we will and my local time is quarter to 11:00 p.m..
00:12:45.986 - 00:13:23.926, Speaker A: And so we will call it soon after and then five minutes after and then five minutes after and after and after and after, for as long as I have balance, basically. Or for as long as I didn't stop the task. Then it shows me. Okay, I've got a dollar 71 in balance here, which should be enough. And then if I click Create task, it will ask me to assign a transaction on chain and then we create a task. All right, so what happens when we create this task? Right, when we create this task, we basically emit events on chain in the smart contracts and hey, the task was created nice. We emit events in the smart contract on chain.
00:13:23.926 - 00:14:21.662, Speaker A: And what happens then is we got the Gelato, the bots that comprise the Gelato network, they are constantly listening for these events, and they will pick up these events which will basically tell them, okay, please automate the lick function of this particular smart contract, which is this ice cream NFT and lick it, but only lick it every five minutes, starting then. And please use the person's account balance for doing so. Right. And here's, by the way, the smart contract, it's verified on, verified on ether scan. And actually let me now I don't know if the color changed for you guys, but yeah, I've got this thing where I try to get the blue light out of my screen. And I don't know if it's actually you were seeing that, but now the car should be better. So basically here we got the lick function, right? And this is the lick function.
00:14:21.662 - 00:15:12.326, Speaker A: Yes. And as you can see, it got this requirement here that we can only call it every five minutes, basically, and that we want to avoid, basically with Gelato. And yeah, so Gelato bots should have now picked up the task in a couple of seconds or minutes, should have started calling this function. And then we should actually see this NFT SVG slowly change from having three ice cream scoops to only having like two, for example. In the meantime, by the way, if you want to kind of check out what other people are doing, there's this cool leaderboard, right? You can click on the leaderboard. And here are basically all the tasks that have been created by other developers in the past that have used Gelato. And you can basically check out you can click on them, you can check out how often they execute.
00:15:12.326 - 00:15:47.162, Speaker A: This one, for example, executes like around 60 times a day. And what it does actually Brandon build it here in this call the OG. And what this does basically is there are these NFTs called Avogotchis, and you can pet them every 12 hours. And what this is, is kind of like a petting service, Avogatchi. So it just goes to all the Avogadchis and it pets them every so often. And there are a lot of others like matrix swaps using it, then key dow and Polygon using it to pay out rewards. Every so often there are like a bunch of use case, basically.
00:15:47.162 - 00:16:06.334, Speaker A: But let's say here, okay, we see. We actually already pay 0.1 Maddox for an execution. Okay, what's going on? And okay, wow, our ice cream got licked one time already, right? We have one scoop missing. We got a lick that happened here. And what we can do is we can scroll down, we see. Okay, today we executed.
00:16:06.334 - 00:16:56.500, Speaker A: Once we click on this bad boy and we see here's basically the transaction on PolyScan, right, we can check out the logs, what happens, and yeah, here's basically the transaction. And this will just keep on executing for as long as I've got a balance on my account. Now, what I wanted to show you as well is actually creating a task that is a bit more complex. I think I've got still ten minutes left. So if we got like a bunch of questions, then just write them in the chat and interrupt me. Otherwise, I will just keep going and show you guys actually a more complex way. I will just keep going, right, if no one interrupts me.
00:16:56.500 - 00:17:19.766, Speaker A: Cool. So we can also create another task. All right, and this task actually is a bit more complex. So let's call this task increment counter every, let's say every time resolver are.
00:17:19.788 - 00:17:23.706, Speaker C: We just allowed to interrupt to you and ask questions?
00:17:23.888 - 00:17:25.034, Speaker A: Yeah, please.
00:17:25.232 - 00:18:27.680, Speaker C: Oh, shit. I did not realize that I had a bunch of questions in Chat, man. I've looked through contracts. I had somebody from Paradigm that I was talking to and me and him, we both really thought that Gelato was kind of a way to implement the whole paradigm. So paradigm had this concept of long term AMMS. Basically it's called a TWAM, right? Like a time weighted AMM. And that's like me and him, we both thought that Gelato was the way to do that because you guys had the whole time weighted AMM because using Gelato, you could basically do trades over a period of time.
00:18:27.680 - 00:18:39.300, Speaker C: Except that's not how TWABs end up working. There's like a specific math equation that goes yeah.
00:18:42.470 - 00:18:49.110, Speaker A: Because this goes very much into detail of one use case. Right. Should we maybe talk about that afterwards probably?
00:18:49.260 - 00:18:55.766, Speaker C: Sure, yeah. Let me let you finish and then if you have some time perfect.
00:18:55.948 - 00:19:50.618, Speaker A: Yeah, let's do that. I think otherwise it's probably over the top of most people's head. And then I think it's probably better to talk about it afterwards together, just because I just want to also walk you through maybe another small thing you can do, for example, which is you can actually let's say we have this counter smart contract right here and I actually have to see, or is it only on Gurley? Counter resolver? I think only on girly. So let me just switch networks to you can these are all the networks, by the way. I think someone asked these all the networks where Gelato is on. So we switch to Girly and now we're on Gurley. Cool.
00:19:50.618 - 00:21:07.826, Speaker A: So increment counter on Gurley. And so what we can do is let's say we have this counter smart contract right here, okay? And how does counter smart contract looks like? It looks like this very simple. It's what you could expect is basically just a counter, right? What it does, it just increments account. This is just like an example function that we implemented, right? It does nothing special, so we paste it in. What we can do is we get the increased count function out, but rather than actually predefining the inputs to that function, let's say the ice cream has been leaked again, the ice cream will keep getting leaked, but maybe let's say this increased count function, right? Let's say you don't actually want to predefine an input there. Let's say you actually want this input, this amount that you pass to the function to be derived dynamically by another contract, for example, which is, for example, interesting if you want to do trades, right, because trades always like the price and the slippage parameters, they always have to be kind of like created dynamically on the fly. And let's say you want to create that input dynamically rather than predefining it.
00:21:07.826 - 00:21:47.034, Speaker A: What you can do is you can click create dynamic inputs via resolver. And what you need is basically you need a resolver. You can deploy a resolver smart contract which will actually return you when to execute that particular function. And this is what an example of such a resolver looks like. It's called counter resolver. And what it does, it's very simple. It just actually returns true every three minutes, for example, right, this is just like a simple condition, but it can have arbitrary conditions, like if the price on new service X, for example, right? So what it does, it returns true or false.
00:21:47.034 - 00:22:50.094, Speaker A: True if Gelato should execute, and false if Gelato should not execute. And it returns the encoded function of this counter smart contract which we want to execute, which is this increase count function, and it returns the amount that we should call it with, in this case, 100, right? So what we can do is we can go to these beautiful deploy files. This is the address of that resolver, sorry. And what we can do is we can go to Gelato, we can type in, hey, I want to use this resolver to actually query and return to me whether I can execute. I want to call the checker function on this particular contract and now I want to create the task. And now what happens is Gelato will actually call every so often, will call this resolver and call this checker function and actually will wait until this checker function will return true. And when it does return true, it will indeed start calling this counter smart contract on your behalf.
00:22:50.094 - 00:23:19.286, Speaker A: So there are two ways of doing it here. You can either just define a time when you want to execute something and predefined the inputs, or you can deploy a custom resolver contract which does something complex. Like it checks like 100 different pools. If they can be harvested, for example. And if one of them can be harvested, you just return them and then you execute them. And let's just go here whether it was successful created. Yeah, this is my new task and this is on Gurley.
00:23:19.286 - 00:24:09.462, Speaker A: And I don't know if we want to just quickly because the guy said it got licked again, let's quickly switch over to Maddox and yeah, we can see it actually got licked again. Cool. I think this is enough. And there's a lot of stuff here in Docsor network, so make sure to check it out. We go through how you can create a task, how you define the inputs, either predefining or by the resolver. And actually what's quite cool, we have these real world examples of projects, for example, ETH Aland, which is a yield harvester on polygon or uniclean NFT project or gotcha care this NFT padding service, right? We've got a lot of stuff that you can check out, so definitely check it out. And if you by the way find any bugs in here, you can always contribute and do like a PR to our docs to improve them because it probably sucks.
00:24:09.462 - 00:24:48.214, Speaker A: So apologies for that. But yeah, so this is basically what was going on. So what's next for Gelato? We actually will support young builders like yourself who want to build some cool stuff with free credits. So we pay for your transactions depending on what you do and how big. Right? But we will give you some free credits if you would like to for just like to try it out yourself. And then at some point there might be Gel transaction mining rewards. We have this Gel token and maybe the most used task will receive some rewards at some point.
00:24:48.214 - 00:25:13.440, Speaker A: Who knows, maybe this will come as well. And then also you can soon use off chain data for your transactions. So not only data returned by the smart contract or by the time you can also get data from like an API or whatever you want. Right, so cool stuff coming, but yeah, that's basically it. Thanks for listening, guys. And these are my contact details, all from Gelato on various networks. Definitely reach out to us.
00:25:13.440 - 00:25:20.610, Speaker A: And yeah, if you have any questions, I don't know if you reserve time, but then now is the time to ask them. And yeah, thanks for listening.
00:25:22.950 - 00:25:24.980, Speaker C: Now. Waste your time now, man.
00:25:26.570 - 00:25:44.666, Speaker A: Yeah, you can definitely waste my time now. If there are any super straightforward questions from anyone, I can just answer in 10 seconds, then you can go ahead, man. Otherwise there is a question.
00:25:44.768 - 00:26:07.522, Speaker D: It's not super straightforward, though. It was mentioned on this last slide and someone actually sent me a link to a documentation which I quickly looked at. But if there is a very quick way to illustrate it on your screen sharing, I would be very grateful to show how to query off chain data.
00:26:07.656 - 00:26:44.954, Speaker A: For the yes, great. Off chain data. Off chain data is at the moment not that straightforward that I can just send you. I can't show it to you on the UI because it's not hooked up to the UI yet. So in order to do it, you would actually need to interact with our smart contracts via Etherscan right away, which is also possible. This is a smart contract, right? And there I think it's actually on that branch, right? So it's not even on the master branch yet. So it is a bit more sophisticated, I would say, but still doable.
00:26:44.954 - 00:27:52.322, Speaker A: And we can definitely help you get it done. So basically this is a smart contract and there you have what's called a polywrap task, this one, right? And rather than kind of like and we can explain to you what you actually have to input to this function here, but basically what you do here is you pass an IPFS CID. So kind of like an IPFS identifier. And this Identifier will tell Gelato which polywrep it should check out and which polywrep which polywrep is basically just like a script, like a JavaScript script, written assembly script, though, which will return to Gelato like a boolean, that indicates whether or not we should execute a transaction on your behalf. And we got this writing resolver thing, polygon resolver. And this actually walks you through it how you can write your own kind of off chain script that can call APIs, that can call like a subgraph, that can just do anything you want, basically. And this will then return true.
00:27:52.322 - 00:28:05.590, Speaker A: And the data you want to execute. And then Gelato will actually take that and execute that stuff for you. But yeah, as a small disclaimer, it is not hooked up to the UI yet. So you would have to interact with all Smart contracts. Vanilla.
00:28:08.190 - 00:28:10.140, Speaker D: Thank you very much. It's awesome.
00:28:10.510 - 00:28:12.060, Speaker A: Okay, no worries then.
00:28:12.990 - 00:28:24.014, Speaker E: Hello? Yeah, I wanted to ask if you can counsel, like make the bot stop the automating after you have started it.
00:28:24.212 - 00:28:41.330, Speaker A: Of course you can. You just go to your ice cream. That was licked four times. Look, it's gone. It's gone forever now. And what I can do now because I don't want it to eat more of my money, right? I just click on pause and I'll pause.
00:28:42.870 - 00:29:10.540, Speaker E: Okay. Does the bot adapt to dynamically changed Smart contracts? You have a pool of address that you want to send some ethers to. Now, let's say if an address was removed not from this, I'd not to explain it, but if an address was removed, would the bot adapt to it?
00:29:11.970 - 00:29:55.020, Speaker A: Yes, it can. If you, for example, use like a resolver here, right? So what you can do here is you can have this function that returns true when Gelato should execute something and it returns a payload. And in that payload, for example, what it can be it can be, for example, an array of all the addresses you want to send ETH to. Okay? And then this array, you can maybe as the admin of the application, you can just remove certain people from it, certain addresses from it. And Gelato will only ever take what this contract returns to it. So it will never send money to anyone who is not in that area. So as long as you got that array, you can manipulate that.
00:29:55.020 - 00:30:18.810, Speaker A: Yeah, you can change it on the if you if you want specific help there, brandon can definitely help you out. Yeah, cool. Anyone else? Guys.
00:30:23.420 - 00:30:25.416, Speaker C: Is there other questions I don't.
00:30:25.438 - 00:30:33.580, Speaker A: Want to yeah, do we still have time for the young gentleman's?
00:30:34.720 - 00:30:36.380, Speaker B: You have like 1 minute.
00:30:39.520 - 00:30:42.316, Speaker C: We can always talk later, my dude.
00:30:42.508 - 00:30:46.464, Speaker A: Okay, let's just do it after the call, right?
00:30:46.662 - 00:30:56.660, Speaker E: Yeah, you guys can create another Zoom channel. Not for workshop, but for you guys. Question. Maybe some people can hop in if they like.
00:30:56.810 - 00:31:07.124, Speaker A: Yeah, let's just do it in our discord in the voice channel. Discord. We have the Gelato channel there. Let's just do it in there.
00:31:07.322 - 00:31:15.172, Speaker C: Yeah, discord as well. What's. Your name, by the way, in the Gelato discord. It's just so I can tag you in case you're willing.
00:31:15.236 - 00:31:18.490, Speaker A: Yeah, let me just write in the chat. It's X.
00:31:19.760 - 00:31:20.830, Speaker C: Thanks, man.
00:31:22.480 - 00:31:56.368, Speaker B: Cool. All right. Thank you so much, Omar, for the awesome workshop. It was super interesting and taking the time to answer everyone's questions. And to the rest of you, thank you so much for tuning into Gelato's Workshop. I hope you learned a lot and that it was really interesting for you. And this workshop can be found on the Oval YouTube channel and otherwise, like Omar said, he could be reached on Discord in the sponsor Gelato Channel and other forms of contact information that he had posted in his last slide.
00:31:56.368 - 00:32:00.710, Speaker B: But thank you so much, and I hope that all of you have a great rest of your day.
00:32:01.720 - 00:32:03.250, Speaker A: Yeah, was a pleasure, guys.
