00:00:22.430 - 00:00:57.140, Speaker A: Is the volume. Okay you thank you. Okay, so thank you very much for attending. My name is Herman Martinez, I'm from nosis. I've been working as a software engineer a couple of years now. Thank you for attending, especially because it is 1230 in the night. So I guess a new day, a new talk it and maybe we can say GM to everyone in the room.
00:00:57.140 - 00:01:38.654, Speaker A: And now let's focus. I'll be talking about Nosisafe a couple of different points. I will start with a brief overview on the Safe architecture showing what are the contracts, the services and the interfaces we use. Then after that I'll show you who is using the SafeCore SDK. There are some defied platforms, some Dows core infrastructure. We also going to see what is the SafeCore SDK. There's a mono repo with a bunch of packages inside of it.
00:01:38.654 - 00:02:36.034, Speaker A: We will see what are them and why should we use it and for what. And finally, what is the basic flow of the Nosisafe using the SafeCore SDK how we can create a new safe, propose a transaction, getting all the owners to sign it and finally execute it. So let's start with the Safe architecture. There are a couple of layers being the main one, the contracts, there's the Safe contract. There are some libraries like the Multisend that can for example allow to batch multiple transactions into just one. There are also modules for example the Allowance module or some recovery mechanisms that can be implemented that way. Also we have a lot of tools related with the Safe here.
00:02:36.034 - 00:03:48.982, Speaker A: Today we are going to focus on the Safe deployments package. This package allows to track the different networks where the safes are deployed, what are the addresses for the different versions. Then we have the Services transaction service Client Gateway Notification service Configuration Service Today we are going to talk about the transaction service that allows to store transactions temporarily, to share them across the different owners and collect the signatures from them. And finally we have the interfaces, web interface, mobile app, a CLI and the SDK, which is the thing we are going to talk about today. But before of that, before that, who is using the Safe course decay, some Dows are using it. So if you are hacking on a project that DAOs may use then probably it's worth checking it. And, of course, Nosisafe uses the SafeCore SDK.
00:03:48.982 - 00:04:52.080, Speaker A: We are trying to migrate some of the logic in our web interface to use this SDK. Also Zodiac which is a composable Dao tooling standard Radical which is a decentralized GitHub for DAOs or Yarn DeFi vaults for Dao, Treasuries and many more. So what is the SafeCore SDK? It is a set of software developer tools that facilitate interaction with the Safe contracts and services. And it can be used by external applications that run standalone or by scripts that run in a backend. For example, it is available on GitHub and there are some packages inside of it. So everything is built on top. On top of the Safe contracts, the Safe Transaction Service and the Safe deployments package that I mentioned before.
00:04:52.080 - 00:05:49.822, Speaker A: And the packages that form this monorepo are the SafeCore SDK types. This one collects or has the different types that are shared among the different packages in the monorepo. Same happens with the Safe Core SDK utils that has some functionality that is shared. Then we have two very similar packages. There are the Safe Web Three library and the Safe Ethers library that act as wrappers of the web3 JS and Ethersjs libraries. And they also export the Safe contract instances, well typed with typechain. So we can consider these packages as the internal ones, the ones you wouldn't need to use.
00:05:49.822 - 00:06:35.710, Speaker A: And then there are two more that offer the full functionality, one of them being the Safe Service client. This is an API that calls the Safe Transaction Service. So all the actions that happen off chain in this flow for executing transactions can be handled by the Safe Service client. For example proposing transactions to the service. The owners can get these transactions from MIT. Well, that's basically it for the basic flow. Then there are different other options for decoding data or getting data from a safe.
00:06:35.710 - 00:07:20.762, Speaker A: And then we have the other package, the SafeCore SDK that handles basically the actions that happen on chain like deploying a new safe, creating a new transaction that later will be sent to the service, executed, et cetera. So today we are going to focus on the SafeCore SDK and the Safe Service client and how they both work together. So let's start with the basic flow. There are some steps. First, we need to initialize the SDKs. The Safe Core SDK and the Safe Service client. Then we may or may not deploy a new Safe.
00:07:20.762 - 00:08:48.390, Speaker A: If we don't have one with the SafeCore SDK, then we can create a transaction with the Safe Core SDK, propose it with the client, get the transaction from the service. If we are a different owner who is not proposing the transaction with the client, we can decide if we want to confirm or reject this transaction and finally execute it. And then in the end we will see some examples of some checks we can do in the interface in case we are building an application that shows a button for example, to execute a transaction, we can check if it's already executed or not, or if it has all the minimum required signatures or not. So let's start with the initialization of the Safe Core SDK. This SDK supports web3 JS and Ethers JS as we saw before, thanks to the Safe Web Three and Safe Ethers library that acts as wrappers. So if we go to the last line, we can see we are calling the class Safe that comes from the SafeCore SDK and we can call the method Create which is static and asynchronous and that receives an object with a couple of properties. The first two are required and the second and the others are optional.
00:08:48.390 - 00:09:55.402, Speaker A: The two required one are the ETH adapter. This is the wrapper for the Web Three or Ethers Library in this case Web Three that we can initialize by setting by passing the Web Three instance and assigner address. The assigner address will be the owner of the safe we are connecting to the SDK so we can do an action with one owner and then change this signer address to sign a transaction with a different owner. The second property is the safe address. So we are connecting one owner to that specific safe address. And the other optional parameters are a boolean is L one master copy because there are two different versions of the safe ones that emit events and one that doesn't, depending if it's L one or L two network for affording us. And the last property is the contract networks.
00:09:55.402 - 00:10:51.802, Speaker A: That one is useful in case we want to try the SDK in a network where the Safe contracts are not officially deployed by us. So you could do it by yourself. Take note of the addresses where the safe contracts are deployed and then build an object with type contract network config and you could specify the chain ID and the addresses for these contracts and then everything would work for Ethersjs. It's almost the same with the difference that ETH adapter in this case would be an instance of Ethers adapter that comes from the library safe. Ethers library. And we need to pass, instead of a signer address, an Ethers signer that will be the owner. So now we have the Safe core SDK initialized we can also initialize the Saveservice client.
00:10:51.802 - 00:12:08.540, Speaker A: This one is much simpler. We just need to call the constructor of the save service client pass the URL where the service is running and the instance of the ETH adapter for the transaction service URL. We are providing different URLs depending on the network but it is a service that can be run by yourself also. So you should replace that URL now if you don't have a safe address to provide to the create method we saw in the beginning, we can deploy one for that. The SafeCore SDK exports a class that is called Save Factory and we can initialize in a very similar way as the previous one by calling Save Factory Create. This is a static and asynchronous method that receives very similar properties with the difference that it also receives the property safe version. In case we want to deploy older versions of the safes, in case this one is not used, the current version will be used.
00:12:08.540 - 00:13:20.030, Speaker A: Then once we have the safe factory instance we can deploy a new safe. If you go to the last line there's the method deploysafe that receives an object with a couple of properties being the first one the Safe account config there is where you can configure your safe for example with an array of different owners, the threshold and some other properties that are not included here. But you can check in the Docs. There's also another property the Safe deployment config. Because the Safe contracts are deployed deterministically, we can use assault nons to alter the data and get a different address where the safe address will be deployed. So if you want to deploy your safe in a specific address with a prefix or a suffix, then you can try different sal nonsense until you find the one that fits your use case. And finally we have a callback that receives the transaction for the safe deployment.
00:13:20.030 - 00:14:26.694, Speaker A: In case the web app or the script where this deployment is running ends, you can get this transaction hash and check it or track it by yourself later. This method returns an instance of the SafeCore SDK initialized with the deployed account. So it's the same calling the deploy save method or the Create that we saw in the beginning. So now we have our SDK initialized and we are ready to create a single transaction. We can do that by calling the method Create transaction from the SDK and pass a transaction object that has some properties like two data value and some others. Also, the Safe contracts allow to create or execute batch transactions. These are multiple transactions that are executed into one.
00:14:26.694 - 00:16:04.354, Speaker A: So using this same method the create transaction, we can pass an array of metatransaction data objects with the properties, two data value and operation and also some options for the transaction that has these multiple transactions inside of it. Now that we have a transaction, a single or a batch transaction, we can propose it to the service with our client in order to make it available for the other owners. We can call the method proposed transaction from the service client and pass an object with the properties safe address. The Safe transaction we want to propose the safe transaction has of this transaction and the sender address being the sender address, one of the owners who is proposing these transactions and for the safe transaction hash, we can get it by calling the method Gettransaction hash from the SafeCore SDK. So now we have a transaction that is pending in the service for the owners to confirm it. These owners can get this transaction if they know the safe transaction hash, they can use the service client and call the method Get transaction to get it. But if they don't know the transaction has, there are other methods that allow to get some transactions from the service.
00:16:04.354 - 00:17:04.840, Speaker A: For example the get pending transactions. This would return a list of transactions that don't have the minimum required of signatures yet. So these owners can add theirs. But we can also get the incoming transactions or the multisig transactions from the service just by providing the safe address to the method. So now it's the turn of the owner where they can confirm or reject the transaction in the case they want to confirm it. If you go to the last line, the safe service client has a method confirm transaction where they can specify the safe transaction hash and add their signature. To get this signature from the owner in the previous line we can see that the method signed transaction hash from the SafeCore SDK by providing the safetx hash will return it.
00:17:04.840 - 00:18:19.990, Speaker A: Owners can also reject transactions and these rejections follow a different flow. We cannot reject a transaction once the signatures are public. So we need to create a new transaction that has the same nons as the transaction we want to reject. So the method from the SafeCore SDK create rejection transaction providing the nons we want to reject will generate a transaction object that we also have to send to the service, collect the signatures from the owner and execute it. And if we execute this transaction before the previous one, the one we wanted to reject, then it will become invalid. So now we have a transaction in the service with the minimum amount of confirmations and it's ready to be executed. We can call the method execute transaction from the SafeCore SDK and pass the parameter safe transaction.
00:18:19.990 - 00:20:03.710, Speaker A: This parameter, we have to get it from the create transaction method where we pass the transaction object we received from the service and then we have to iterate on the confirmations from the service and add them to this safe transaction object. And once we have this safe transaction object with all the signatures then we can execute it. Finally, some checks we can do on the interface. If we want to see if a transaction was signed by a specific address, then we could check the transaction we got from the service that it has property confirmations and see if these confirmations belong to a specific owner or if we want to see if a transaction is already available for execution. Then we can count the number of confirmations and see if it's greater or equal than the safe threshold. So now the question is will you be integrated with us or will you be the next integration? We are available on Twitter. Our twitter handle is nosisafe and if you are interested in participating in the discussions, we have discord and a forum that you can check in chat or forum nossisafe IO and that was it from my side.
00:20:03.710 - 00:20:22.134, Speaker A: So thank you very much. Now if you have any questions okay, we have a microphone coming, I think.
00:20:22.252 - 00:20:26.920, Speaker B: Yes. When two.
00:20:30.390 - 00:20:54.526, Speaker C: What are the test? What are the best practices for contract upgrades for the Gnosis safe and how often do they happen? I guess because I just started deploying a Gnosis safe recently and hasn't been updated. But is there a best practice to subscribe to something to see security vulnerabilities or any information about those upgrades you.
00:20:54.548 - 00:21:13.990, Speaker A: Mean the upgrades of the contracts? Yeah. The contracts are not upgraded very often, so when they are, it's something that will be public and announced. So I don't think there's nothing to check constantly.
00:21:14.490 - 00:21:15.400, Speaker C: Thank you.
00:21:23.380 - 00:21:55.930, Speaker D: Hi there. Thanks very much for the talk. I'm going to apologize in advance. I'm just going to make sure that I actually understand what the hell is going on with these contracts, if that's okay. Basically, from my understanding, you have the ability to deploy a Gnosis Safe contract. Once you've got that Gnosis Safe contract, you then have your does that count as the owner? Is that the thing that actually submits the final transaction when you've batched up your collected signatures, when you want to submit a safe transaction? I was wondering if you could just kind of explain to me the interplay between those services a little bit more.
00:21:56.640 - 00:21:59.148, Speaker A: Sorry, could you repeat just the last question?
00:21:59.234 - 00:22:08.930, Speaker D: I was wondering if you could please explain to me a little bit more the interplay again between your three sets of contracts. Sorry to ask you to repeat yourself.
00:22:11.380 - 00:22:16.364, Speaker A: So how the execution happens and how the signatures are checked.
00:22:16.492 - 00:22:18.132, Speaker D: Yes, that's okay. Thank you.
00:22:18.186 - 00:23:02.092, Speaker A: Okay, so there are basically two ways of collecting the signatures. Once a transaction is built off chain, somebody defines the data, the value, and these parameters a transaction has and that is shared with the owners. These owners can get the transaction hash and they can decide if they want to tell directly the contract. Yes, I approve this. Or somebody can collect off chain all the signatures, concatenate them and call the method execute transaction from the contract and send them directly.
00:23:02.236 - 00:23:22.570, Speaker D: So effectively, you have the ability to have like a separate keeper who submits that aggregated transaction. Or if you were to have the situation where all four of your owners were, if you had a four owner safe contract, if all four of the owners were to tell the contract directly that they wanted to authorize it, you'd be able to do that without having to collect the signatures, is that correct?
00:23:25.580 - 00:24:02.404, Speaker A: In that case, there's no need to collect them, but you need to provide like a fake signature telling the contract that a specific owner signed the transaction on chain. So if you know that somebody signed on chain, then you can make a fake signature, a prevalidated signature with his address, and by sending that to the contract, the contract will understand that fake signature and will check that he did it on chain before.
00:24:02.522 - 00:24:03.140, Speaker D: Nice.
00:24:03.290 - 00:24:03.604, Speaker E: Cool.
00:24:03.642 - 00:24:06.230, Speaker D: Thank you. I really appreciate the question. Sorry.
00:24:07.960 - 00:24:13.160, Speaker A: Of course doing that or doing everything off chain will afford gas.
00:24:16.410 - 00:24:18.086, Speaker C: Is there a way to set a.
00:24:18.188 - 00:24:46.000, Speaker A: Timeout on a transaction so that maybe the owners of a safe could agree that a transaction will happen, like a certain period of time in the future? Is this available? Not in the basic functionality. Okay, so once a transaction is proposed for example to the service and all the minimum required signatures are available. Anybody could execute it. Okay.
00:24:51.250 - 00:25:10.898, Speaker F: It'S a bit of a stupid question, but could you repeat sort of how the multi SIG works with Nosa Safe? Like just how that would integrate into a contract? So if I understood it correctly, that there's the Safe contract and that's where the signatures pool is that the correct understanding.
00:25:10.994 - 00:25:14.040, Speaker A: That's where the signature sorry, could you.
00:25:14.350 - 00:25:30.160, Speaker F: Explain that interface with a multi SIG one? Like a few slides back? I think that might have been too far. That one the is transaction executable. Could you maybe explain that just a little? I'm pretty new to the space.
00:25:30.930 - 00:26:18.700, Speaker A: After getting a transaction from the service using one of the methods or directly with an endpoint, the service returns an object, which is the object transaction of type save multisig transaction response. And there you can get a transaction object with all the confirmations that were sent by the owners of chain to the service. So if you get this object and we count how many confirmations it has, if the number of them is greater or equal than the safe threshold, then you can execute the transaction. Otherwise you need to wait for more of them. Cool, thanks.
00:26:24.030 - 00:26:33.140, Speaker B: I know that a lot of the mev extractors are kind of using this now. What do you think are some of the really interesting applications you've seen of this in practice with them?
00:26:33.670 - 00:26:34.740, Speaker A: Of what?
00:26:35.110 - 00:26:36.770, Speaker B: Mev extractors?
00:26:43.900 - 00:26:49.070, Speaker A: I don't really have an answer for that. Okay, that's fine.
00:26:52.640 - 00:26:56.830, Speaker B: People are very forthcoming with that information, I guess.
00:27:07.400 - 00:27:19.510, Speaker A: Is there any other question? No. Yeah, okay. There in the back. Okay.
00:27:20.860 - 00:28:13.076, Speaker E: I think this is not this hackathon, but personally my project tried to implement this Gnosis Safe to manage NFT. So I wanted to make the function that many people can manage NFT in the Gnosis Safe bullet. But I think currently Gnosis Safe bullet requires the transaction to sign in the OpenSea. So I think OpenSeas like Metatransactions. So like off chain transaction needs to make on chain transaction in Gnosis Safe. But I think I checked the Gnosis Safe implementation and it has the EIP 1272 that is contract wallet signature verification. So I think Nosisf can use that EIP to validate the off chain signature in the smart contract.
00:28:13.076 - 00:28:20.590, Speaker E: So do you have plan to add that sign in using off chain signature into openc function?
00:28:24.680 - 00:28:28.016, Speaker A: Sorry, I'm not sure I understood correctly.
00:28:28.128 - 00:28:57.580, Speaker E: Okay, so Gnosis Safe has the EIP 1272 that is contract wallet signature verification. But currently if I use Gnosis Wallet to sign in into OpenSea, I need to make signature. I need to make the transaction on chain. But is it possible to sign in using the off chain signature by Nasisafe?
00:29:00.170 - 00:29:07.074, Speaker A: I think that's something that the implement. Sorry, technically the Safe supports these contract.
00:29:07.122 - 00:29:10.680, Speaker E: Signatures would have to implement logic to.
00:29:12.880 - 00:29:13.820, Speaker A: Just don't.
00:29:14.120 - 00:29:14.870, Speaker E: Okay.
00:29:25.100 - 00:29:56.440, Speaker A: Then we will be at the booth during the whole weekend. So if you decide to build some hack project these days, we will be around. So thank you very much. You it's.
