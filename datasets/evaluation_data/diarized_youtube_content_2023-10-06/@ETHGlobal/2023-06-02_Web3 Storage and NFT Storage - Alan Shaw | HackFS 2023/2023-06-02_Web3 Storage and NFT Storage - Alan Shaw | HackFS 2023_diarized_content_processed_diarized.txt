00:00:07.450 - 00:00:25.702, Speaker A: As was stated, our next presentation comes from Alan. He needs no introduction, but I'll give him one anyway. He's a software engineer working with Protocol Labs, currently working to make the distributed Web more accessible to developers. Alan, if you want to get started, I will hand it over to you.
00:00:25.836 - 00:00:56.926, Speaker B: All right, welcome to this presentation. I'm Alan, and this is a mashup of two talks about storing data on IPFS and filecoin using webfree storage and NFT storage. So let's do it. First of all, I'm going to talk about NFTs quite a lot. The kind of off chain side of them, how they can be stored decentralized on IPFS and filecoin for the long haul. So I'm kind of new to NFTs. Most people are.
00:00:56.926 - 00:01:38.342, Speaker B: They haven't been around for that long. But when I found out about them, I was super excited to see that the IPFS was already being used to store them. So, for example, if I go to any kind of website like this one, for instance, this is the game, it uses NFTs. They have a kind of marketplace and they have NFTs that you can buy and trade and stuff. Let's have a look at I don't know this one, for instance. I happen to know that this particular game uses the marketplace of marketplaces called OpenSea. OpenSea.
00:01:38.342 - 00:02:11.250, Speaker B: There we go. And I can just paste in, hopefully, the token ID of this particular NFT. Hopefully I click on it. Did that come up? There we go. Is it working? Hello? There we are. There it is. Come on, Internet.
00:02:11.250 - 00:02:50.638, Speaker B: No, OpenSea is not having a good time at the moment. All right, let's try one more time. Okay. Right. Anyway, this is a cool car, but I can click through and I can see that its metadata is here. I should just be able to click on this. This talk is like, fraught with danger, so we shall see how it goes.
00:02:50.638 - 00:03:11.160, Speaker B: It doesn't look like things are going to work out so well today. For me, anyway. This is going to IPFS IO. You can see in the bottom left there that it's a CID on IPFS IO. And the metadata for this particular NFT here it is, it's just come up, is stored on IPFS. So hooray for that. That's great.
00:03:11.160 - 00:04:10.214, Speaker B: And hang on, here we go, back to the notes. There we go. But why is data for NFTs stored on IPFS anyway? Well, it's because it's kind of prohibitively expensive to store data on chain on the ethereum blockchain at least. And IPFS actually has some really nice properties for off chain data that we'll go into in a little. So as I learned a little bit more about NFTs, I came to realize that the developers that are enabling NFT creators, so like OpenSea, for example, like foundation, like Zora, they already cared about users being able to access their data should they ever just disappear off the face of this Earth if they fade away like that. They still want people to access these NFTs that they've bought and created and created, so they don't want the NFTs to just disappear also. And so IPFS, this comes into play now, and this thing called IPFS can solve this problem.
00:04:10.214 - 00:04:50.740, Speaker B: It actually fits the bill really well. And from my point of view at least, it's not really surprising that it's being used. So let me just rewind a little bit and explain some basics of IPFF in hopefully not too much technical detail, but I've chosen a little NFT here that he's a little one eyed squid thing that's actually on that sandbox game anyway. So if I put him on ITFs, firstly, what do you get? You get a CID. It's called a content Identifier. And CIDs are a kind of cryptographic hash and they address the content, not its location. They address that squid with the one eye, not where it is.
00:04:50.740 - 00:05:42.070, Speaker B: And that means that any given CID will always refer to the same piece of content. So if that squid were to grow another eye, for instance, then the CID for that squid would actually change. And what typically happens is those CIDs are stored on chain and they're linked to from chain. And if that wasn't the case, if we used a regular URL to Google Drive or like dropbox URL or whatever, that could be problematic. Why could that be problematic? Well, the content at the end of that URL could be deleted by the owner, the domain could expire or the hosting, it could not be paid and then just go away. The image could or video or whatever it is could be altered in some way. So I could have my squid turned into a kubecat or something, which would be disappointing.
00:05:42.070 - 00:06:39.766, Speaker B: Or, for instance, the URL just might not be accessible from within your country. Or maybe you're in some sort of corporate firewall or something, where you actually need to get hold of that data from a peer that's maybe closer to you than the Internet location where it actually is. So IPFS, how does it work anyway? So if someone who's using IPFS requests that data by a CID, then the person who has it will send it back to you and they'll receive it, you'll receive it. And now two nodes have that same content and they can serve it to anyone else who comes along. So like this, if someone else comes on and goes, do you have this CID? The content for this CID and Weaver, one of those nodes can help to transfer the bytes to that node. We call it bit swapping because why not? That happens. And now three of them have it.
00:06:39.766 - 00:07:17.730, Speaker B: And the cool thing about this is that the original node who had the content can actually go away and the data will still be retrievable from other nodes in the network. And this is the awesome power of peer to peer hooray caveats. There's two caveats. The first one is that if all of the nodes that have the content go away, then you're not going to be able to retrieve it's. Kind of obvious, worth stating, if there's no one on the internet who has the content, you're not going to be able to get the content. That's caveat number one. Caveat number two is slightly less obvious, is garbage collection.
00:07:17.730 - 00:07:56.160, Speaker B: So depending on your configured kind of GC configuration, it might run at a particular time. It might run when your configured repo storage limit is hit. So you might be fetching things from IPFS. It all goes into your repo and eventually you'll use enough data that IPFS will go, okay, we're kind of full now, let's do a GCE run. And the third other time that it might be run is it could be run manually. So you can actually invoke GC from the command line. Or if you've got the HTP API exposed, you can call it from like that.
00:07:56.160 - 00:08:33.190, Speaker B: So what you need to do is tell architects this content is not garbage. Because when you obtain content from the network that you didn't actually add yourself, that content is eligible for garbage collection. So if I got this picture of the squid from someone else, then it could be garbage collected in the future. So what you need to do is kind of tell your IPFS that this piece of content is a rare NFT and it's not trash. Don't throw it in the bin, please. And in IPFS, that's referred to as pinning. And if you don't pin your data, then it will eventually be garbage collected.
00:08:33.190 - 00:09:13.930, Speaker B: So even if the content is super popular, you can still eventually exit the network. So these two caveats are why developers generally use a third party service like Pinata or Textile Fleek to store their content, because they have nodes that are publicly available and they stay online like twenty four, seven. And obviously they pin the content so it doesn't disappear. Cool. So NFT Storage, Molly just mentioned this earlier, so you kind of already know a little bit about it. It's something that we've been working on for a while now. It's a place where you can store your NFT data decentralized on IPFS and filecoin safe in the knowledge that it'll be there tomorrow.
00:09:13.930 - 00:09:46.834, Speaker B: And it hopefully goes some way to addressing that permanent problem. And it's free? It's free as long as we can possibly make it free. And one of the founding kind of principle rules is that it should be easy to store data using this service. So how does it work? Well, you upload your NFT data to NFT Storage, and NFT Storage stores that data on IPFS nodes in the network. That's right. We actually have a cluster and we store it on free nodes at least. Okay, so far so good.
00:09:46.834 - 00:10:58.220, Speaker B: But how's that different from any other pinning service? Well, behind the scenes, what NFT Storage is doing is it's negotiating deals to store your data with storage providers on the filecoin network. And so the filecoin network, you might already know, incentivizes the storage providers to store data quite heavily. They get paid to store data. They also typically get paid when data is retrieved and they also get block rewards for providing capacity to the network. So why is that good? Well, if NFT Storage were just to happen to just go away, like it's gone, and also every IPFS node on the network went away as well, then the filecoin storage providers who have the content will still have it and they will store it for the duration of the deal that's been made for them. And so you can think of these storage providers as just another set of IPFS peers with really strong incentives to continue storing that data. And this is hopefully a really good level of redundancy, basically, and should, like I said, go some way to solving that permanence problem.
00:10:58.220 - 00:11:13.194, Speaker B: So here it is again. NFT Storage. Free, decentralized storage for NFTs on IPFS and filecoin. And the URL is NFT storage. I've said it about a thousand times. You should go take a look. We have a simple API.
00:11:13.194 - 00:11:37.346, Speaker B: It's expressed as an open API schema. If you don't know what that means, it means we can generate docs like this. We can also actually generate clients from this schema, which is kind of rad in different languages. That's really cool. The API is real small. You're probably going to need even smaller subset of it like these two. Like if you want to upload a file, just post to upload.
00:11:37.346 - 00:12:14.274, Speaker B: But what I really wanted to draw your attention to here is this check API. And so with this API, you can actually check the status of the CID of any NFT that's been uploaded to NFT Storage. And the output for that kind of looks like this. And so you can see here the pinning status of this particular CID, but also the deals with filecoin storage providers that have been made or are being made currently. And so you can see their status like time date stamps for when things have happened. The on chain deal ID. So you can go and look it up.
00:12:14.274 - 00:13:05.300, Speaker B: You can see the address of the storage provider who's actually storing it or going to be storing it. And what's really interesting here is that there's two things. There's the batch root CID here and also the data model selector. And they're the kind of important ones because what happens is that as data comes into NFT storage, it gets kind of aggregated together into this big pile of data and that gets sent to miners. And then if you ever want to get your piece of data out of that big aggregate, then you're going to need the data model selector and that allows you to pinpoint your particular bit within the aggregate. So anyway, this is a cool API that you can use to check stuff. We also have the same thing in web three storage, which I'm going to talk about in a SEC.
00:13:05.300 - 00:13:20.166, Speaker B: JS client. We have an official JavaScript client. This one isn't generated from open API. We've lovingly handcrafted this one for you. It's got TypeScript, types. It's got nice API, Docs. We've got a metadata API as well.
00:13:20.166 - 00:13:52.626, Speaker B: And this metadata API is designed to make minting NFTs really easy for you by guiding you through creating like ERC, seven to one and 1155 compatible metadata. And we will take a look at that. Let's take a look at that now. All right, here's an actual demo. So let's see how it goes. Demo Gods are hopefully going to help me out here. Here we go.
00:13:52.626 - 00:14:14.218, Speaker B: Here's the whole desktop. Okay, so what I'm going to do is I'm going to use this metadata API. I've already installed the client from NFT storage using NPM. I'm importing it like this. And I've just created a version here. I've created my token already on the website. Just go to NFT Storage and create it.
00:14:14.218 - 00:15:06.074, Speaker B: I've exported it in my terminal so that should just work. And what I'm going to do is I'm going to try and store this image called Pinpy because it's appropriate about pinning and stuff. So Pinpy, let's try and store this using the metadata API. So what I need to do is call client store and then we give it an object that looks really similar to something that you'd get when you click through from your token Uri which is minted on chain. What is stored on IPFS, essentially the metadata for the NFT where the actual image file or video, whatever it is, can be stored, et cetera, et cetera. But it's really simple. It looks something like this.
00:15:06.074 - 00:15:56.646, Speaker B: I'm going to call it Pinpy. It has a description and I'm going to put it Pinpy comic because it's a comic thing. And then what's kind of cool here is that the property is called Image and this has to be essentially the URL to an image which is your NFT, essentially. But what we put in here is actually just a file. And what happens behind the scenes is that the NFT Storage client will automatically upload that image for you and replace that image with a URL to the IPFS asset which is stored on IPFS. So let's just quickly do that. Create a file.
00:15:56.646 - 00:16:22.926, Speaker B: I'm going to use FS read file Zen. I'm going to get the Pin by JPEG. Here we go. Get to give it a file name which could be different from the actual file we're reading from. And I'm just going to give it a mind type imagebook. Cool. So this returns a promise.
00:16:22.926 - 00:17:03.840, Speaker B: So I need to await on it. And I get back this object. I get this metadata object and I'm just going to log out the metadata URL. And this is the URL that you'd actually use in your minting process that would be stored on chain, essentially log metadata. I'm just going to print out the data here just to show that this file gets transformed into a URL to this particular asset. I think that's all I need to do. So we will see if this works.
00:17:03.840 - 00:17:39.386, Speaker B: Store. I'm in the wrong directory. Okay, sorry about that. Right, here we go. So let's just take a look here. This locked out the URL. This is the URL that we're going to put in on chain.
00:17:39.386 - 00:18:07.350, Speaker B: And also here is the data. And you can see this image got transformed into a URL as well. So that's super cool. Here we go. And what I should just be able to do is head on back over to here. And if I put this into my browser yes, there we go. And I should just be able to fetch it from any IPFS HTP gateway.
00:18:07.350 - 00:18:32.046, Speaker B: And this is the data that I uploaded to IPFS. So super cool. All right, that demo successfully done. Stop that sharing. Okay. Right, let's get back to slides because slides, slides are here. Here we go.
00:18:32.046 - 00:18:57.334, Speaker B: Cool. All right, so what do we do there? Well, we actually uploaded data and then we got back a CID from NFT Storage. And NFT Storage is doing the work of generating that CID from the data that we sent it. And there's a couple of problems with that. Firstly, we have to trust NFT Storage is doing the right thing. It's not giving us the CID of some malicious virus in some way. It wouldn't do that.
00:18:57.334 - 00:19:53.820, Speaker B: But you don't know in this trustless peer to peer world we're trying to inhabit. So it's better to have generated that CID ourselves. Why can't we do that? Why don't we do that? Well, before we get onto that, the other thing is that we have to wait for that CID to come back to us. We have to upload that data and wait for that CID to come back when actually it would be really useful to have that CID before we uploaded because then we could mint our NFT on chain whilst it's uploading. And if it's something big, then it might take a while to upload. So actually having that CRD generated on the client side before it gets uploaded is really useful because then I can use it somewhere else. I could maybe even store it in a database in my app or so it means that I don't have to trust NFT Storage, and I also get to solve this UX issue, basically.
00:19:53.820 - 00:20:27.250, Speaker B: So, yeah, why can't I just generate that CID before uploading the data? Well, turns out you can. New is storing cars, and cars are not automobiles in this world. Cars are content addressable archives. And it's kind of like Tar for Dags. And Dags are directed as cyclic graphs and they are the things that IPFS generates when you import data to it. So, yeah, tar for Dags, if that's a thing anyway. So it allows you to know that CID before you upload and in the client.
00:20:27.250 - 00:20:52.554, Speaker B: So on the client side, we can do the work to generate that CID. And it means assembling that data into the graph. But then we have that CID, we have that root file, but once we have the graph, we pack it into a car and send the car instead. Don't send the data. Send the car. It's got the Dag, and then that can just be stored by NFT storage. You know what's being stored is the thing that you added because you generated the CID on the client side.
00:20:52.554 - 00:21:23.762, Speaker B: So there we go. And it also means that we can split it up into multiple carts. You can send partial Dags like bits of it. And that's cool because if you got like a loads of data, you can split up into smaller bits. And it also allows us to send data that's more than 100 megabytes in size. One of the kind of quirks of this service is that we decided to put it on like cloudflare workers. And they are cool because they put your worker close to whoever's requesting that API or using that API.
00:21:23.762 - 00:22:04.722, Speaker B: But they do have a limit on how much data you can send them in one chunk. But it's okay because we can chunk up things so we don't have to abide by this 100 megabyte rule anymore. So you typically end up this is completely contrived diagram, but you might end up with something like this. A yellow line kind of rings around the nodes in the graph that you'd maybe be sending in one car. So you might send this set of nodes in one car, you might send this set in another car, and you might send this set in the third car. And we know that all of these cars are related because they have the same root CID. That's pretty cool.
00:22:04.722 - 00:22:31.660, Speaker B: And that allows like, failure and retry without sending everything. Again, we can just send any car in any order because it doesn't matter. And that allows us to also report on progress after we finish sending a chunk so we can say we've done enough and you get that UI feedback. So that's cool. All right, let's try real quick storing the car demo. I know, I feel like this is going way over time. I'm sorry.
00:22:31.660 - 00:22:55.060, Speaker B: All right, so here we go. And stop the share. Let's share my whole screen. Okay, cool. Great. So this is very similar to what we had before I've imported this extra IPFS car module. This is going to help us pack a car from our content.
00:22:55.060 - 00:23:27.742, Speaker B: The path I'm going to use is I'm going to use Pinpy. Again, the content is actually so that's just the file name, essentially. Read file. Read the file. Actually, I'm not going to use Pinpy at all because what I want to demonstrate is actual splitting and chunking. I've got my skate movie here is 24 megabytes. Let's just make sure that here we go.
00:23:27.742 - 00:23:54.840, Speaker B: Here's my skating movie is 24 megabytes. That's great. I'm going to use that. What happens is that the cars get split into ten meg chunks. So we should see free chunks, 210 meg size and one four meg movie. Here it is hiding. Here we go.
00:23:54.840 - 00:24:37.570, Speaker B: The cool thing is at this point here, we've packed this video into a car file and we've also got the CID before we've even sent it to our client. So we can got the CID here. And when we get the CID returned from the client, we can verify that the CID we created is a CID that has been returned to us. So I'm calling this method called store car pass. It the car. And the cool thing is that we've got this nice callback which gives us the size of the chunk that was the car chunk that was stored. So we can log out DA DA.
00:24:37.570 - 00:25:01.100, Speaker B: We can log out the how many bytes we stored for each chunk that gets sent. Hopefully that's good to go. There we are. NPM node node node index. Let's try again. Here we go. So you can see here we got that CID like straight away.
00:25:01.100 - 00:25:31.970, Speaker B: And so now what's happening is there we go. We got one chunk got sent, that's like four meg. And so these other two here's, a ten meg chunk just come through another ten meg. So we got free chunks, got sent, they all got sent in parallel. We send up to free in parallel to not Starve browser browsers. But that's the kind of cool thing about it. And the four megabyte chunk, even though it was maybe at the end of the data, it won because it's smaller.
00:25:31.970 - 00:26:05.150, Speaker B: And the CID we got back is the same as the CID that we captulated. That's pretty cool. Back to the slides. All right, we are getting on for finishing off, but at this point I've talked a whole lot about NFT storage. But web Three Storage is the brand new thing. It's just launched almost literally. And web free storage is built for any data.
00:26:05.150 - 00:26:47.258, Speaker B: So it's not just NFTs? If you remember this slide from earlier, then web free storage does exactly the same thing. But it's not just for NFTs, it's for any data. So you can put images, videos, you can put documents, whatever you like, even IPLD data as well. So you can pick what works for you the best. So if you're going to be minting NFTs, then you're probably going to want to go with NFT storage. It gives you the tools, as you saw, to create and store NFT metadata. And that metadata will comply to ethereum standards.
00:26:47.258 - 00:27:11.574, Speaker B: It also follows best practices for linking to data stored on IPFS and for everything else. Then web three storage has you covered. So you should check that out. The other difference right now is that cars are baked into the Web Three storage client that we've made. This is a nice JS client. We've done for Web Three storage as well. We'll catch up the NFT storage client at some point.
00:27:11.574 - 00:27:44.430, Speaker B: But at the moment you can see for storing files, at least, you just call like client put, and then there's no mention of cars here. It just does that for you. It will create the dag, it will split the car up. It will upload, it will do retrying if it should fail, for example. So hopefully even easier than NFT storage. All right, so let's really quickly dive into the architecture. This is essentially a fork of NFT storage.
00:27:44.430 - 00:28:06.038, Speaker B: In the future, NFT storage might the back end to NFT storage might be Web Three storage. And we'll see how that goes. But they are very similar at the moment. Very similar. What happens is that users interact with the Http API. They send car files, and we put stuff into our IPFS cluster. That's cool.
00:28:06.038 - 00:28:28.110, Speaker B: We have like a six node cluster. We put stuff on at least three of those nodes in the cluster. So that's kind of cool. And we backup everything to Pinata. Pinata provide a pinning service, as you probably have come across if you've done any kind of IBFS e stuff. And yeah, that's there the storage broker service. This is where all of the interesting stuff happens, basically.
00:28:28.110 - 00:28:53.814, Speaker B: And what it does is it grabs all of the CIDs from our database. Our database is called Bornet, no idea why. And anyway, so it batches them up into presence, or they're not really batches, they are aggregates of data. Essentially. They are presents for miners, and the presents are actually cars as well. Everything is cars. And what happens is that storage providers, they come and eat them up.
00:28:53.814 - 00:29:24.974, Speaker B: Not really literally eat them, but they will take them because it's the self serve kind of thing. They're like, give me the deals and I store that data. Cool. Okay, last bit free. When we say free, we often get questions like why? How is this even possible? Well, let me tell you a little bit about how it works. This is essentially that bit in the bottom right hand corner of our diagram here. Just expanded out a bit.
00:29:24.974 - 00:29:49.126, Speaker B: This is one particular storage provider who has some hard disks. Anyway, so what happens is that storage providers commit their hard disk space to the filecoin network. They basically say they've got this capacity and they get like significant block rewards for doing so. And that's this kind of circular thing, because that happens essentially as the block progresses. They get they get rewards. And this translates into real world profits. Profits are down here.
00:29:49.126 - 00:30:46.374, Speaker B: These money stacks at the bottom left, that happens. And that means that they're really incentivized to keep committing additional hard disk capacity to the network. So they keep doing that more and more just so they can make more profit. And of course, why wouldn't you do that? However, when the storage providers are storing data from users on the network, their likelihood of winning block rewards goes up by a big fact of ten X. So wow, look at those profits they just raced up. So you can see the potential profits to be made here by storing real user data. And this is such a powerful incentive for filecoin storage providers to store data, such as the data that is coming from a free storage or NFT storage, that they're willing to offer free storage in order to get this block reward multiple.
00:30:46.374 - 00:31:50.240, Speaker B: And in some cases, storage providers want to store data so badly that they'll actually pay users to store their data. So anyway, so as long as these block rewards continue to be really powerful incentive, which will be true for a long, long time and for example, like Bitcoin, block rewards are still an incentive for Bitcoin miners. Today storage should be free for all verified users on the filecoin network right now. And so if it's free for us to store data on filecoin, then it's free for you to store data with us. If you want to learn more about the mechanics behind that and how to be a verified user, then if you go to the filecoin docs and then click on there'll be a link there for filecoin plus it's docs filecoin IO and you can find out how to do it. And that is mostly all I have to say. But thank you so much for listening and hopefully I haven't gone too far over.
00:31:50.240 - 00:31:51.290, Speaker B: Bye.
