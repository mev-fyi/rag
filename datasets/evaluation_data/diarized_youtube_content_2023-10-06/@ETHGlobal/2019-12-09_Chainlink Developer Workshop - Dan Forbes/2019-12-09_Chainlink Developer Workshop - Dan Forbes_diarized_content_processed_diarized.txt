00:00:00.490 - 00:00:17.806, Speaker A: Hi guys. My name is Dan Forbes. I'm a developer advocate for chainlink. And today we have a relatively short period of time to talk about chainlink. So I'm going to try to do that in an efficient way. The workshop that we're going to be working off of today can be found on this GitHub repo that I set up. It's GitHub.com
00:00:17.806 - 00:00:46.586, Speaker A: dan Forbes slash Dan Forbes. So you can find all the information about me that you want there. So the workshop that we are going to be working off of today is this chainlink plus Remix workshop. So this is going to be a fairly an exposition of the basic capabilities that chainlink provides. I'm assuming that since you all are here, you're pretty comfortable with blockchain solidity development. So I'm guessing that everyone kind of knows what Remix is and all that stuff. Okay, cool.
00:00:46.586 - 00:01:32.134, Speaker A: So we don't need to talk about that. So I'm just going to use some technologies that you guys are probably already very familiar with to showcase the capabilities that chainlink exposes. So I already have Remixd installed. If you're not familiar with Remixd, that is like a little program that you run locally that allows you to pipe your local files over to the Remix online IDE so that you can work locally. So let me preparing before you guys came. Okay, so what I'm doing now is I'm in my home folder there before. I'm going to do things in a slightly different order here.
00:01:32.134 - 00:01:58.098, Speaker A: So before I use Remixd to connect to my local computer, I'm going to save the code that we're using, which I think I've already done this, but that's okay. Just for the sake of completeness, we'll do it again. So the code is right here on the workshop that I'm working off of. Here it goes. Takes you to this code that's up there on Gist. You can find it very easily. You'll see it in lots of chain link workshops and such.
00:01:58.098 - 00:02:27.660, Speaker A: And so because we're doing things simple, I'm just going to create a directory in my home folder called Workshop. That's what we're going to be working out of. We're just going to use this one solidity file. So I'm going to go ahead and save that. And now I'm going to use Remix D to connect and I've aliased RMX to be this helpful Remix command. So I can just run that. Sorry, any questions? Yes.
00:02:27.660 - 00:02:52.000, Speaker A: And then the back of the folder. Yeah, sure. 100%. So we won't use that alias. Let's do it from scratch. So this is what the command that I'm using is. So we're invoking the remix D application.
00:02:52.000 - 00:03:28.026, Speaker A: I would believe that S stands for Source. Doesn't bother me. Okay, so now we're in that Workshop folder that we created. It has that solidity file that we downloaded. So now I want to connect that to Remix. So we're going to invoke the Remixd command, s means source, I think. So I'm going to use the current directory specified by the dot as the source.
00:03:28.026 - 00:04:08.540, Speaker A: And the remix IDE that I'm using is just the standard remix that the Ethereum foundation puts out there. So once you are in the directory that you want to work with is minus s and then just space dot. Or I could pass a relative or absolute path to the directory that I wanted to use and I could be working out of some other directory. Just for convenience sake, I'm just in the directory that I'm going to be working in. But you could just specify whatever path was pointing to the source directory. And I think actually in the official documentation, they tell you to use an absolute path and not a relative path. But I think it obviously works fine.
00:04:08.540 - 00:04:41.734, Speaker A: Okay, remix IDE. This is why you alias things, so you don't make errors like that in workshops. But that's cool. We're also here to learn about things. So now I can go to remix ethereum.org and you can see it's very helpfully saying like, do you want to connect your local file system? And I accidentally closed that, no big deal because it's a nice little tool. And I'll just click here and say connect and boom, there we go.
00:04:41.734 - 00:05:09.402, Speaker A: We see it. On the other side there this a testnet consumer sol file that I downloaded. So because this is an IDE, it's helping me to figure out some things that I'm doing wrong. Specifically, I need to use a different solidity compiler. And now as much as I do like remix and I think it's a tool that we should all be using, it's not without its little quirks here and there. And that's why we do these workshops, so people are aware of them and understand them. So I always have to compile files twice in Remix.
00:05:09.402 - 00:05:47.558, Speaker A: So here we go. I'm going to compile it for the second time and God willing, it's going to work. So let's go to our workshop. We'll see what we're doing here. We've used Remix to compile the testnet consumer solidity file that we downloaded and now we're going to go ahead and deploy it to the Robston test network. So now when I come over here to the deploy tab of Remix, the first thing I want to do is I want to make sure that I'm using the web3 APIs that are being injected by my extension. In this case, I'm using the Brave wallets.
00:05:47.558 - 00:06:16.342, Speaker A: So we're going to use that. You can see it's already connected. And now I want to make sure that I'm deploying the correct contract. So I'm going to select the a testnet consumer contract that we compiled. These are all the dependencies that were also compiled when we compiled a testnet consumer. But we want to deploy the meat of this project, so we're going to deploy a testnet consumer. So now my wallet is asking me to pay for all this because I like you guys, and we're working with free money.
00:06:16.342 - 00:06:52.122, Speaker A: We're going to do this really quickly. And also because no one likes awkward silences in a workshop, especially me, as I'm sure you can tell. So now we're waiting for this to deploy. And so once this deploys, we're going to fund the contract with Link. And Link is the chainlink utility token. It is a mechanism for value transference as well as a mechanism for data transference. So it implements an ERC that was written by our CTO that exposes this transfer and call capability.
00:06:52.122 - 00:07:26.422, Speaker A: So what it allows you to do is you pay for the service that the Oracle is providing. And just in case we didn't really talk about that, I guess I kind of took for granted that you all know what Chainlink is. And what we do what we do is we bring off chain data on chain. And so what I'm working through right now is this process of getting the Ethereum to USD exchange rate and bringing that on chain into a solidity smart contract. Of course, the blockchain doesn't know about USD. It doesn't know about what the exchange rate is. So that's off chain information that we want to bring into our smart contract.
00:07:26.422 - 00:08:01.318, Speaker A: And so that's what we're doing right now. And so that is a service that we need to pay for. There's someone out there running the chainlink node and they're managing the infrastructure, all that kind of stuff. And so they're exposing the service and we're going to pay them for the service that they're exposing. And so we pay for that using our Link token. And then because it implements this ERC that was written by our CTO, that's also how we communicate the details of the request, namely reach out to this API to get the ETH to USD exchange rate. There's some other stuff in there that we're going to talk about.
00:08:01.318 - 00:08:40.290, Speaker A: But the long and short of it is, or in this case, the long and long of it is we need to fund this contract with Link so that it can make this chain link request. So that's the step that we're on now. We're going to fund this contract with Link. So while I'm doing that, are there any other questions? Because obviously I didn't necessarily do the best job of explaining everything. What's up? The workshop? Yes, and that was something I explained at the beginning of the workshop. If you go to Danforbes, you can see different workshops that I've done. And we're doing the chainlink plus remix workshop.
00:08:40.290 - 00:09:15.166, Speaker A: Okay? So one of the reasons that I like Remix is it exposes a lot of friendly capabilities for us. And one of them is that we can really easily copy the address of our deployed contract. So I just copied that to my clipboard. And now I'm going to fund this contract that I've deployed with Link. So paste that there. We only need one link to do this, but I don't like seeing weird OD numbers, so I always use multiples of five. Again, spending free money is so much fun.
00:09:15.166 - 00:10:04.234, Speaker A: What's up? Do we have a question? So that is a price that's set by the node operator. So chainlink is open source software that's run by people who want to run it and who want to provide this capability and receive link as payment for this capability. And so, like I said, they may have different infrastructure. Someone may be running their chainlink node on their laptop and you probably wouldn't want to use that node operator for a production use case. But there may be people out there who are very well known in the blockchain technology industry that are running these nodes. It's kind of part of what they do is their business. They have very high assurances regarding uptime.
00:10:04.234 - 00:10:24.740, Speaker A: They're using the best infrastructure, so they're providing these services and they're expecting to get paid for them and so they set the price that makes sense for the services that they're offering. Any other questions? That's a really great question about how Chainlink works. Okay, cool. Good seeing you again.
00:10:26.470 - 00:10:31.640, Speaker B: Say every minute you want the Ethereum price the most updated, every minute you'd be paying.
00:10:32.410 - 00:11:04.058, Speaker A: Yes. So right now that is kind of the way things work. And I'm hoping that I'll be able to show you something really specific to that that can help you. In that case, we are working on a feature called Service Level Agreements, which is going to create a more long standing relationship between a smart contract creator and a node operator providing this service. That's in the works. You can follow our progress towards that on our Pivotal tracker, which is a public feature tracker. All of our code is open source.
00:11:04.058 - 00:11:17.880, Speaker A: So you can follow all of this on GitHub, but that's in the works. And what I'm presenting today is kind of what we currently offer because it's enough and it's really cool and I think it's really helpful. Any other questions? Yep. No, this is great.
00:11:18.330 - 00:11:26.594, Speaker B: So say you're the smart contract developer and I'm also a smart contract developer and you're basically paying the node operator.
00:11:26.642 - 00:11:29.062, Speaker A: For say, the Ethereum price data.
00:11:29.196 - 00:11:35.482, Speaker B: Now what's to prevent me from just calling your contract? Like, I need that data too, but I don't want to pay for it. I just call your contract to get.
00:11:35.536 - 00:12:07.830, Speaker A: The I don't believe that you have to expose the data. That would be your choice. And in fact, to answer the previous question about Ethereum to USD exchange rate, I will show you a contract that we are maintaining that can be used for that. It's a reference contract that we're providing. So you can expose those kinds of capabilities. But I think that you could also maintain that information as private or certainly you wouldn't have to expose the information that you received. You could just perform some calculation.
00:12:07.830 - 00:12:34.702, Speaker A: Any other questions? These are really great questions. Okay, so we funded our contract with Link. Let's kind of see where we are. So now we're going to use Remix to execute one of these functions on this contract that we deployed. And we're going to provide it with some parameters that are in the chainlink docs. And again, one of the reasons why I like Remix is because we can do this. We can deploy a contract and exercise it all in one kind of go.
00:12:34.702 - 00:13:11.350, Speaker A: So I'm just going to the chainlink docs here and we'll talk about the data that I'm going to get from here if I can find it. Here it is. Okay, so we are going to be calling this request Ethereum Price method. And as we talked about, there's some node operator out there that's exposing this capability. And so this is the address of the contract that is associated with that chainlink node. There's an on chain and an off chain component to the Oracle. And so this is the address of the on chain component.
00:13:11.350 - 00:13:48.770, Speaker A: And then this is the job that we're going to call on that Oracle. So you can imagine that someone sets up one of these nodes. They're not just exposing one capability, they're exposing a whole host of capabilities because there's many, many data providers out there and they want to expose a certain set of that. And so we're telling them that we want to use this job ID. What's up? Yeah, I use capability a lot. It's a very general term. And so in this case, what I'm referring to is some API that's exposed by some data provider.
00:13:48.770 - 00:14:28.286, Speaker A: So chainlink we can really hook into any kind of API data provider, anything like that. So most of the APIs that we hook into are restful APIs that I'm sure you're all very familiar with, but there's no requirement for that. I wrote something that allows chainlink to query data from a gRPC API. If you have some proprietary API, you can hook it into that there's middleware that allows you to do that. So from my point of view, it's just this abstraction, this data out. There some data provider that exposes capabilities. And so we're going to get those into our smart contract.
00:14:28.286 - 00:15:20.558, Speaker A: And so we are going to tell let's look at this request Ethereum Price method actually, so you can see that we're going to specify the job ID which we talked about. And then when our request is fulfilled, it's going to come back and there's going to be a callback that's going to get executed with the data that the node is returning. In this case, we're calling a function that's on the contract we're currently writing. That's not a requirement. You could specify a callback on a different contract if you wanted to. And in this case, we talked about kind of custom middleware that you can write for accessing any data provider. There's also just built in adapters is what they're called that are kind of baked into the chainlink software that you can use to access data providers.
00:15:20.558 - 00:15:50.618, Speaker A: And so one of these built in adapters is Http get. As I said, it's very common to get data from a restful API. So we kind of expose built in functionality that makes that super easy for you. Now, of course, that API is going to return some JSON object. JSON object. So we want to tell the node what value in that response we want to get. So we provide a path that we want to walk to extract the value that we want.
00:15:50.618 - 00:16:32.982, Speaker A: So in this case, well, here, let's actually look at it. Let's see what data the node is going to have access to. This is just an Http get request, right? So let's go ahead and execute that request. I don't know what this is doing. Okay, sorry. This is not going to be easy, but that's okay. I do want you to see that we're not doing anything like, magical here.
00:16:32.982 - 00:16:55.374, Speaker A: We're just reaching out to this HTP API. It returns a very simple JSON response. I'm sure you're all familiar with that. But obviously we just want to get this exchange rate out of here. So in this case, we want to walk this path to USD. So that's what we're providing as a parameter to our request. Of course, if there was a more complex path we needed to walk, we can do that too.
00:16:55.374 - 00:17:36.022, Speaker A: We can dig into objects, we can specify array indices, all that kind of stuff. And then in order to play nice with Ethereum data types, we're going to take this value and we're going to multiply it by 100 before we write it back to the blockchain. So that's basically what we're going to execute. We funded our contract with Link so that we can send this request. It now has what it needs to pay for this request, as well as how it's going to transfer all of these arguments that we just talked about. So we're about to do this and make this happen. Are there any questions about that or anything that we've talked about at all? Cool.
00:17:36.022 - 00:18:25.660, Speaker A: So I'm going to go ahead and copy these values here and I'm going to paste them into this way that we're going to execute this method. It all right. So now it's happening. So while it happens, we can, of course, if we want, we can go see the transaction out there on Etherscan. But I also wanted to show you that we can look on our Explorer, the Chainlink Explorer. So what we do is we take that transaction and we paste it in here to the Chainlink Explorer. There's the job that we're running.
00:18:25.660 - 00:18:53.582, Speaker A: So what we can see here is this is what's actually happening out there on the chainlink node. This is, I believe, the invocation of the job, the ID of the invocation. We have the job ID. We are running this node. So there's all kinds of information in here for you and you can see that obviously we had to configure this job on the chainlink node side. And so we talked about the Http get task that it's performing. We talked about the JSON Parse task it's performing.
00:18:53.582 - 00:19:13.690, Speaker A: We talked about multiply. We didn't talk about these last two things. The node is going to convert that multiplied value into the Ethu int 256 data type and then it's going to write that back to the blockchain as a transaction. It's going to go through the Oracle contract and get called into that callback function that we talked about. Did you have a question?
00:19:13.760 - 00:19:20.560, Speaker B: Yeah. So all these items displayed within tasks are a part of the chain link Oracle like methods within that correct.
00:19:21.170 - 00:19:59.850, Speaker A: Specifically, they're part of the job that we set up and we invoked that job with the job ID when we made that. And so this has been created by some administrator on the chainlink node. In this case, we are composing built in adapters to achieve the functionality that we want. But one of these could be replaced with what's called an external adapter. And that's what allows you to query a gRPC API, a proprietary API. You can have business logic in the external adapter. So maybe you want to query multiple data sources and perform some kind of off chain aggregation.
00:19:59.850 - 00:20:19.342, Speaker A: They're very flexible. So there's the Oracle and then there's the data provider. You can just use Http get if you want to talk to the data provider. Or you can create this external adapter which sits between the Oracle and the data provider and does work that you as the external adapter developer get to decide what that work is.
00:20:19.476 - 00:20:22.898, Speaker B: By the way, is there a way to do a WebSocket? Like, is that built in or would.
00:20:22.904 - 00:20:43.362, Speaker A: I have to use that external adapter? You would need to use an external adapter, yes. Excellent question. I've thought about the same thing myself. You would need to use an external adapter. Oops don't want to show you that there's anything too. So let's see how this job is doing. Okay, it says that it hasn't yet written it back to the blockchain.
00:20:43.362 - 00:21:05.630, Speaker A: I don't necessarily believe that these things are asynchronous and sometimes they don't always work. So let's see if we get a current price. We do get a current price. So let's go see what happened. We made this request and this called our Fulfill Ethereum price selector. So let's go down. Here we are fulfill Ethereum price.
00:21:05.630 - 00:21:40.860, Speaker A: You can see there's some kind of helper functions that we have in here to make sure that things are secure and everything. But basically what we do is we update this state variable on our contract, this current price state variable, and now we can query it just like we would any other variable before we made this request. That value would have been zero. So unfortunately, I am at time now, so I don't have much time to go over kind of next steps. I hope that that was helpful and you understand what Chainlink does.
00:21:41.390 - 00:21:56.798, Speaker B: So if I wanted specific data, someone has to run the Oracle node. So is that what you're saying? I want data on the bitcoin price someone, I need the address, I need the function, someone else has to set that up?
00:21:56.884 - 00:21:57.520, Speaker A: Yes.
00:21:58.210 - 00:22:00.814, Speaker B: Are you creating like a database of data sources?
00:22:00.942 - 00:22:50.142, Speaker A: Yes. So there are third party marketplaces out there that already exist. And they're run by really reputable people that are trusted members of our ecosystem. But they're independent because chainlink what we want to do is bring this promise of decentralization out to the Oracle layer so that you can build end to end blockchain applications that include real world data, but that don't sacrifice the guarantees of blockchain decentralization, determinism, data integrity, all of these kinds of things. And so this is a much more sophisticated example of composing chain link capabilities. Namely, this is that reference contract that we're maintaining with the ethereum to USD exchange rate. There are 18 node operators involved in this process.
00:22:50.142 - 00:23:20.090, Speaker A: There's an on chain aggregation process where we take the median of the different values that we acquire. And so I'm going to have this demoed at our booth, which is right out there, so I can go over all of this with you. But today's workshop was pretty short. We covered the basics. You saw how to make a chain link request and how to use our capabilities to access off chain data from a smart contract. I hope that you guys use it in your hacks. If you're wanting to do so, please come find me.
00:23:20.090 - 00:23:30.590, Speaker A: It's my job to help you understand how to do that. And I hope that you have more questions now and you'll come by our booth and ask them. Sure.
00:23:30.740 - 00:23:42.990, Speaker B: So besides the USD reference contract, if I want to query several independent nodes to get the same data or whatever, do I have to send out like a separate job to each node in my contract?
00:23:43.070 - 00:23:43.860, Speaker A: You do.
00:23:46.710 - 00:23:48.580, Speaker B: What do you say about.
00:23:50.550 - 00:24:30.970, Speaker A: So in this case, what we're doing is there's 18 node operators and across them they're querying eight different data providers, so we get lots of different data. Oh, wow. It's actually been bumped up to 20. So we're adding new node operators to this contract that we maintain all the time. But we want to make sure that the value that we write back to our reference contract is rock solid because we're providing it to you in the community and you might use it in your smart contract. So we don't want to provide you with bad data. So what we do is we take these 20 different values that come in and then we take the median of those values.
00:24:30.970 - 00:25:13.898, Speaker A: So let's say that at the data provider level, there was a breach of trust. Maybe, God forbid, at the oracle level, there was some breach of trust, but somehow one of these 20 data points was bad. In this median aggregation process it would get discarded. But that's an implementation detail that we as the smart contract developers made because in this case we are smart contract developers providing a reference implementation of the capabilities that we expose. Maybe it would have made more sense in this case for us to take the median. So maybe we discard the two most outlying values on either end and then we take the mean. That would be another way of aggregating the values.
00:25:13.898 - 00:25:40.120, Speaker A: The idea here is that Chainlink is exposing capabilities where you can even aggregate values, where you can have a decentralized source of off chain information. And you as the smart contract developer can then make smart decisions about how to use that off chain data. But first you need to be able to get that off chain data into your smart contract in a way that makes sense.
00:25:42.170 - 00:25:43.320, Speaker B: We don't have to.
00:25:48.730 - 00:26:24.960, Speaker A: This is the reference contract that we're maintaining for this very specific use case. But it's very important to me that you understand that we are open source software. We support an independent community of node operators and data providers. So as the creators of this technology, we are showcasing it. We are assuming the role of the smart contract developer and composing our capabilities in a way that we want you all to see. But that is not to say that you need to rely on chainlink for any of this. That's antithetical to what we do.
00:26:24.960 - 00:27:04.380, Speaker A: We want to make sure that this is fully decentralized. There are these third party marketplaces. You are able to run a node if you would like. I would not encourage you as a smart contract developer to run your own node and then only query that node for data because now you're creating a highly centralized system. So we are a tool of the smart contract developer. We expose a set of capabilities that enable them to get off chain data into their smart contracts in a way that makes sense. Sometimes we compose those capabilities in a way that we want to showcase, but that doesn't mean that's how you have to use it.
00:27:04.380 - 00:27:12.720, Speaker A: Any other questions? Great questions. Please come by the chainlink booth and ask some more. Thanks guys.
