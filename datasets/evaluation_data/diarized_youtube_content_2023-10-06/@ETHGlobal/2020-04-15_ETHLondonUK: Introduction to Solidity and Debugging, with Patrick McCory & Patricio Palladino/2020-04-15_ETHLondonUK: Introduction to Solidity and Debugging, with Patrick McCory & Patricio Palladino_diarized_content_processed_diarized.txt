00:00:00.410 - 00:00:00.958, Speaker A: Cool.
00:00:01.124 - 00:00:05.680, Speaker B: Okay, guys, so we're just going to begin. Have I got the thumbs up to start?
00:00:06.130 - 00:00:06.542, Speaker A: Yeah.
00:00:06.596 - 00:00:06.958, Speaker B: Awesome.
00:00:07.044 - 00:00:07.630, Speaker A: Great.
00:00:07.780 - 00:00:25.686, Speaker B: So welcome to London, everyone. Before I begin, who's actually from London here, raise your hand if you're from the area. That's about half the room, maybe 60%. That's really cool. So the rest are just from around the world. If you're from Italy, you know, you could just go outside as well. I'm only joking looking.
00:00:25.686 - 00:00:55.422, Speaker B: Okay, so I also want to get another raids of hands who's done any solidity programming before? Okay, so you're all quite familiar with it then. So maybe that's going to be too easy for you guys. Maybe I can try to make it a bit harder. So what I'm going to do first is I'm going to give a brief overview about smart contracts and solidity. And then we're going to build a very simple contract that's a hello, world that's censorship resistant and can never be taken down by any nation state. Everyone likes a censorship resistant hello, world. Okay, sorry.
00:00:55.476 - 00:00:55.742, Speaker C: Yeah.
00:00:55.796 - 00:01:04.270, Speaker D: Before you start, I think there are some people in the room who weren't here earlier with the WiFi. So is there any WiFi details? Okay, cool.
00:01:04.420 - 00:01:23.720, Speaker B: You all need WiFi. So if you connect to the club quarters and type in the room number nine nine, you can put any email address or name in and you'll automatically connect. So just one last time, look for club quarters on your WiFi list and the room is nine nine nine.
00:01:24.410 - 00:01:25.526, Speaker D: And then you can just put any.
00:01:25.548 - 00:01:32.140, Speaker B: Last name, any last name. You can put Sasha Nakamoto v. Butter in if you want. We can all be V butt Butter in today.
00:01:32.590 - 00:01:33.340, Speaker A: Cool.
00:01:33.710 - 00:02:02.820, Speaker B: So what is a smart contract, just to make sure everyone has a high level view of what I think a smart contract is. So the first definition that was really released was from 1994 by Nick Zasbo, which is a smart contract. It's a computerized transaction protocol that executes the terms of a contract. But for me, when I read this definition, it doesn't really make any sense to me. I can't really process or compute it that well. So raise your hand if this makes any sense to anyone in this room.
00:02:03.510 - 00:02:04.114, Speaker A: Cool.
00:02:04.232 - 00:02:42.126, Speaker B: Exactly. So a better way to think about it for me, is that a smart contract is a trusted third party with public state. Public state means it doesn't keep any secrets whatsoever. If you give this trusted third party your date of birth, that date of birth will be visible to everyone in the world. Now, the smart contract gives you some guarantees. First, when I deploy the third party, its code can never be modified, give or take, how you design it. And if I want to call a function, let's say the vote function, it will always execute the code I expect, as in if I call vote, it will run the vote function.
00:02:42.126 - 00:03:13.562, Speaker B: There's no hidden black box code there in most cases. And also, one of the safety features is that it will never stop halfway through. So if I call the vote function, it will either execute all the code or it will stop and revert and not execute anything. So it's all or nothing. And of course, it likes the gossip and it can't keep any secrets whatsoever. So that's the best way for me to think about a smart contract. I want a third party to coordinate some protocol or action or game, whatever.
00:03:13.562 - 00:03:25.070, Speaker B: And all that third party is doing is really coordinating and making sure everyone in this room has the same set of code. And everyone here can execute the same code on the same state as a cute little robot.
00:03:25.570 - 00:03:26.366, Speaker A: Cool.
00:03:26.548 - 00:03:46.114, Speaker B: Now, on Ethereum, you have two types of accounts. The first is an externally owned account. That's your ethereum address. And as a public private key pair, I have a private key on my computer. I can do digital signatures, and I can authorize transactions. And of course, the public key, the Ethereum account, is what I give you guys. And you can all send me money.
00:03:46.114 - 00:04:23.610, Speaker B: Now, there's three different types of transactions on Ethereum. The first one's really straightforward value transfer. I can sign a transaction where I can send anyone in this room some ETH that's sort of like just like bitcoin, in a sense. But then we can go a bit further. So we can create a contract creation transaction is what I call that where in the transaction, in the payload, we put the bytecode of the contract. We deploy that to the network. Then this transaction will create the smart contract in its initial state so everyone here can see that I created this smart contract and everyone here can get a copy of the bytecode.
00:04:23.610 - 00:04:53.942, Speaker B: And finally, an invocation transaction. If this is a voting contract that's on the blockchain, I sign a transaction where I say I want to call the vote function on this contract. With these arguments, I sign that, I broadcast that to the network. And of course, in that transaction, we'll process the vote. Of course, they all have the same transaction format. But in terms of the idea, there's three different types. Now, on Ethereum, there's also this idea of gas.
00:04:53.942 - 00:05:01.034, Speaker B: So who's heard of gas before? I guess I should really ask, who hasn't heard of gas before? Okay, everyone's. Okay, one person.
00:05:01.072 - 00:05:01.514, Speaker A: Cool.
00:05:01.632 - 00:05:29.074, Speaker B: You don't have to really raise your hand if you don't want to. But on Ethereum, there's this idea of gas. Okay, so why do we have gas for? One of the issues is that when we send this transaction to the network, we're sending it to thousands of people in the world. We need to make sure that this transaction doesn't do a denial of service attack. It doesn't do a for loop 10 billion times. We need some way to measure computation. We need some way to limit the amount of computation a single transaction can do.
00:05:29.074 - 00:05:58.320, Speaker B: So we have a gas unit, and I'm going to explain that in a second. And there's a gas price. So one of the quirks of this network is that let's just say I want to call the vote function. I need to sign a transaction, I need to broadcast that to the network, and I need to get that in the blockchain. Who puts it in the block? Miners. These guys solving that proof of work. So I need to set a gas price such that when the miner includes my transaction, they get rewarded a fee for doing this.
00:05:58.690 - 00:05:59.198, Speaker A: Okay?
00:05:59.284 - 00:06:08.020, Speaker B: So it's a bit like going to the gas station. For every gallon of gas I want, it costs a dollar. And if I use ten gallons, then the miner is going to get $10.
00:06:08.950 - 00:06:09.700, Speaker A: Cool.
00:06:10.150 - 00:06:38.060, Speaker B: So just have a very simple illustration of how gas works. Remember, on the Ethereum virtual machine, at the end of the day, everything's assembly. There's opcodes that are executed, and every opcode has a fixed gas cost. So in this case, grabbing the timestamp will cost ten gas. Now we're just going to run through a very simple example. Of course, this is not what UpCodes look like in real life. This is a much prettier way to represent them.
00:06:38.060 - 00:07:15.910, Speaker B: So in my single transaction, first what I'm going to do is fetch the timestamp and the hash for black block 500. Now, this will cost me 60 gas to run both of those UpCodes, both of those steps in the execution. Now, when I want to add them both together, I add the timestamp and the block hash. It all cost me up to 65 gas. Then when I fetch the coinbase transaction, oh, I run out of gas. Coinbase required 50 gas, but my transaction had a gas limit of 80. So because of the gas limit, I can't finish this execution.
00:07:15.910 - 00:07:33.790, Speaker B: So I go to fetch the coinbase, it explodes, I get an out of gas exception, and everything rolls back. And that's exactly a good way to think about Ethereum transactions. If you don't allocate enough gas, then it's going to explode and not finish the execution.
00:07:34.930 - 00:07:35.582, Speaker A: Cool.
00:07:35.716 - 00:08:16.490, Speaker B: And finally, what does this look like on the network? So every 12 seconds, there's a new block. And in this example, I've created a smart contract, and the contract code is here, and it cost me up to 98,000 gas. Later on, blockchain created, and no one's using the smart contract. And then finally, Bob comes along, he signs a transaction, he broadcasts this to the network, and of course, he's going to call a function on the smart contract. So again, as an example, I've deployed the voting contract. And then over here, Bob may have casted a vote in my contract. And that's basically how we'll be processing the blockchain.
00:08:17.390 - 00:08:18.140, Speaker A: Okay?
00:08:18.750 - 00:08:28.750, Speaker B: So now what we're going to do is go through a very simple, solidity example of writing. Hello, world. So I want everyone to go to this website, remix ethereum.org.
00:08:29.170 - 00:08:29.774, Speaker A: Okay?
00:08:29.892 - 00:09:05.798, Speaker B: There's an online IDE where we can write simple code and test it out. Now, what's important is that on this network, we have this Ethereum virtual machine. So all of the programs are executed in the Ethereum virtual machine. And finally, the most important thing to take away for Ethereum is that these programs will not do anything in the background for you. Normally, when you write a program, you can have a task that's always running in the background. You can't do that on Ethereum. Your smart contracts won't do anything unless there's this transaction.
00:09:05.798 - 00:09:15.840, Speaker B: Unless you send a transaction, that's the only time your contract will do any execution. So there's no idea of this background task. Everything's event based.
00:09:17.730 - 00:09:18.334, Speaker A: Cool.
00:09:18.452 - 00:09:25.620, Speaker B: So now let's go into our Remix example. And is there any questions before I continue, or is everyone quite happy with that?
00:09:27.990 - 00:09:28.770, Speaker A: Okay, cool.
00:09:28.840 - 00:09:34.340, Speaker B: And remember, guys, this is a workshop, so ask as many questions as you want. There's no such thing as a stupid question.
00:09:36.870 - 00:09:37.390, Speaker A: Cool.
00:09:37.480 - 00:10:04.198, Speaker B: Oh, actually, there's one last thing I want to highlight while you guys load up Remix. When I first discovered Solidity back in 2016, this is the first example you'll see on Remix with Zabala program. So in this very simple example, it's a simple voting contract. There's a list of proposals. So when I create the contract, where is the code for that? Well, I've deleted that. Okay, so when you create the contract.
00:10:04.214 - 00:10:04.686, Speaker C: Oh, there it is.
00:10:04.708 - 00:10:35.720, Speaker B: When you create the contract, you say, there's a certain number of proposals that I want to send. So maybe there's three proposals that people can vote on. So when I create it, I say there's three proposals, and all of this gets stored. Then over here, there's the vote function. So I want to vote for proposal one. So what I'll do is I'll create a transaction where I say, I want to go to this voting the ballot contract, I want to call the vote function, and I want to vote for proposal one. I put that in, I broadcast it, and then it will process the vote function.
00:10:35.720 - 00:10:44.822, Speaker B: So that's the very first example I ever seen for Ethereum, and over the years, it's been updated on Solidity.
00:10:44.966 - 00:10:45.930, Speaker C: Whoops.
00:10:47.310 - 00:10:48.460, Speaker A: Okay, cool.
00:10:49.470 - 00:11:45.770, Speaker B: And also one last note is when you write these smart contracts, they tend to have 40 lines of code, but they hold millions of dollars of assets. So if you are going to write smart contracts, I assume everyone here will at some point in their lives, you have to make sure you have an adversarial mindset, because this 40 line code program will be deployed on this public network that anyone in the world can access. So if you have a single bug in your contract, it will get exploited by someone. So in this example was the first Parity Wallet hack in 2017, where they lost $32 million. And then this was the Dow hack where the Dow got drained of $55 million. So the dow was this Kickstarter program. The idea was that we deploy this contract, anyone in this room could donate funds, and then it has a big pocket of money, I guess about, like, Molok Dow.
00:11:45.770 - 00:12:21.260, Speaker B: Now, later on, anyone here could submit a proposal. If that proposal gets enough votes, then it gets funded and the proposal gets the funding. But that contract had a bug where the attacker was able to drain $55 million. And it's a very subtle bug that maybe we'll cover later. Now, one interesting thing was that why this black hot hacker was draining the funds. The Ethereum Devs also discovered it, and they were also trying to drain the funds. So you have the hacker and the white hot hackers both draining the funds at the same time, trying to save the day.
00:12:21.260 - 00:12:52.334, Speaker B: The empowerity wallet got hacked again, and they lost around $280,000,000. And this was guy by DevOps one nine nine, he accidentally killed it. What was interesting there was that, yes, some people remember this then. So in this attack, what was quite interesting was that there was a central library contract. When we program, we write dependencies. We say, I want to import this code, and I want to run this code. So they had a library contract and they had 50 wallet contracts.
00:12:52.334 - 00:13:20.650, Speaker B: That all depended on the library. The issue was that this library contract had a suicide function that anyone could call. So DevOps came along. He set himself as the owner. He then sent in a suicide command and destroyed the contract. And by destroying the library, he also froze all of the other wallets because the functionality no longer existed, because the library was deleted. I mean, I have a whole range of talks around for attacks, but this is a big deal.
00:13:20.650 - 00:13:45.886, Speaker B: You don't want anyone to make a T shirt for your smart contract, okay? And that's really it. So when you do write these smart contracts in the future, please look online. Read as many tutorials as you can on how to break smart contracts. Maybe we'll try to break one later if we have time. And last thing is, it's slow, expensive, and everyone has to share this resource. As you're going to see, smart contracts are very expensive. They execute.
00:13:45.886 - 00:13:59.750, Speaker B: So you want to minimize what you do in the smart contract and maximize what you do off chain. You don't want to do everything in the smart contract. And that's it. So these are little links that I've made. So last year I taught a yep, go ahead.
00:13:59.820 - 00:14:02.378, Speaker E: So when you kill the contract, where does the money go?
00:14:02.544 - 00:14:32.194, Speaker B: So in this example, with the library, all the money was on the 50 contracts here. So every contract was a wallet. So I had a wallet contract one, wallet contract two, and you had the library. So when this library is destroyed, the money is still on the wallet contract, but the wallet contract has no functionality, so it's frozen. It's just stuck there, which must be so painful. I mean, if I were the victim of this, I would just be really annoyed that I can see my money there, but I can't withdraw it.
00:14:32.312 - 00:14:35.010, Speaker D: But technically, the suicide does usually return.
00:14:35.160 - 00:14:46.520, Speaker B: Yeah, you give it an address and it sends it all there, right? Yeah, well, typically, but the library obviously doesn't have money in this case. But normally when you do destroy a contract, it sends the remaining funds somewhere else.
00:14:46.890 - 00:14:48.300, Speaker A: Yeah, go ahead.
00:14:50.590 - 00:14:52.410, Speaker E: Can it be resurrected?
00:14:53.950 - 00:15:25.794, Speaker B: It depends on how you design it. So I think we've created two opcodes. You can do that, but obviously this wasn't predicted in time, so not yet. No, I mean, what you could do is you could hard fork the network and reinstate the contract and I'd be a believer that you should do that. In this scenario, it's verifiable that the funds are locked and is verifiable that this was deleted and by simply recreating it, you would withdraw all the funds. I'm quite positive. I mean, I would opt into that, but a lot of people wouldn't, which is why it hasn't been done.
00:15:25.992 - 00:15:26.642, Speaker A: Cool.
00:15:26.776 - 00:15:27.940, Speaker B: Any other questions?
00:15:29.190 - 00:15:29.922, Speaker A: Okay, awesome.
00:15:29.976 - 00:16:08.642, Speaker B: So what we're going to do now is we're going to run through this first tutorial. So if you want to type in those links. So what I did last year was I taught a master's course in MSC on cryptocurrencies, and these were the tutorials that I gave to the students. So they're quite in depth in terms of a lot of the constructs that you can do in solidity and how to break smart contracts. But we'll just run through the first one for now, so you don't really have to open it, but I'll send these links later on and you can look through the tutorials if you want. They get incrementally harder. So with the remix I'm doing now, if you find this too easy, then you can just jump ahead to this one and do this yourself right away.
00:16:08.642 - 00:16:12.900, Speaker B: This is probably the hardest one and I don't think anyone will get that done in 20 minutes.
00:16:13.670 - 00:16:14.034, Speaker A: Cool.
00:16:14.072 - 00:16:19.830, Speaker B: So let's just go through the Hello, World example. So now I can sit down and go on remix.
00:16:23.010 - 00:16:23.950, Speaker A: Whoops.
00:16:26.210 - 00:16:49.990, Speaker B: Okay, cool. So this is the remix IDE. Okay, so what we're going to do is create a new smart contract. So if you go up here to the top left, you'll see a little plus button. You just click that, okay? Top left, little plus button. And then we can type in the name of the new file. So we're going to call this hello world soul.
00:16:49.990 - 00:16:51.894, Speaker B: Keep an eye on time.
00:16:51.932 - 00:16:52.520, Speaker A: Awesome.
00:16:53.530 - 00:17:03.580, Speaker B: Okay, so again, top left, hit the little plus button, and then you can call your contract whatever you want, but I'm going to call it Hello World sol.
00:17:05.470 - 00:17:06.220, Speaker A: Cool.
00:17:07.970 - 00:17:41.130, Speaker B: So you'll notice when you open this new file, your first error message will appear, which is basically telling you need to be able to inform remix or whatever compiler you're using, what version of Solidity you want to use. So in this case we just type in Pragma Solidity. And I'm going to make the text bigger now. No .6.1. So how do I zoom in? See, that's how you tell an old man. I don't know the shortcuts.
00:17:41.950 - 00:17:42.700, Speaker A: Cool.
00:17:49.160 - 00:18:18.460, Speaker B: Okay, so the first thing you do is tell remix what version of Solidity you want to use. So we just type in Pragma Solidity version 0.6.1. I always forget to do this. Then I always get that the error message. Okay, and then next what we're going to do is define our smart contract. So we're going to call it Contract Hello world. Curly, bracket, curly, bracket.
00:18:18.460 - 00:18:24.830, Speaker B: Then I'll just wait a few seconds because I can see people are typing and catching up.
00:18:35.600 - 00:18:36.350, Speaker A: Awesome.
00:18:36.800 - 00:19:07.700, Speaker B: So now what we're going to do is the whole point of this Hello World is that we want to tell the world hello. So what we're going to do is first define an event, which would be we're going to call it Event message. And this is going to take a string, which would be another message. So what's really nice about Ethereum is that when I call a function in a smart contract, you can create events.
00:19:07.860 - 00:19:08.232, Speaker A: Okay?
00:19:08.286 - 00:19:40.688, Speaker B: So if I watch a smart contract, I'm just watching it and I want to figure out when some cool event happens. As you're going to see, when you call a function in the contract, you can make the program emit a message to the outside world to notify the outside world that something cool happened. And that's the whole point of an event. It makes it really easy for anyone watching the smart contract to be notified when something happens. So what we're going to notify the world about is to say hello for now.
00:19:40.854 - 00:19:41.520, Speaker A: Okay?
00:19:41.670 - 00:19:51.190, Speaker B: So now what we're going to do is create a function called Send message. And it doesn't take any parameters for now.
00:19:53.480 - 00:19:53.940, Speaker A: Okay?
00:19:54.010 - 00:20:30.032, Speaker B: So we're going to define a function called Send message. Now you'll notice one aspect here is that we have the keyword public. So when I deploy this smart contract to the world, I send it into the blockchain. I have to define a function to either be internal so no one can execute this except the smart contract or public. If it's a public function, then anyone here can execute the function. So if you're familiar with Java or JavaScript, this is probably quite similar. Some functions can only be executed by the program, other functions can be executed by anyone.
00:20:30.032 - 00:20:44.820, Speaker B: It's external API. So here we use public to say it's accessible by anyone. And then what we're going to do is emit the event message. And for now we're just going to hard code it to say, hello world, whoops.
00:20:46.780 - 00:20:47.530, Speaker A: Cool.
00:20:49.740 - 00:21:27.732, Speaker B: So obviously it's a really boring program, but of course it's censorship resistant and no one can take this down because we're all cipher punks. So now that we've written this code, I'm just going to put this out a bit. Now what we want to do is deploy it, run the function, and then we can emit Hello World to the world. So we'll go to the solidity compiler, which is this one. It should be the second menu down. Can everyone see that by the way, because sometimes remix is a bit can I see your example? Sometimes remix doesn't set this up. Yeah, I thought so.
00:21:27.786 - 00:21:28.244, Speaker A: Cool.
00:21:28.362 - 00:22:00.850, Speaker B: Okay, so guys, if you don't have the compile option, go to the little plug down here, the plugin manager. Now what we're going to do is activate the solidity compiler and activate deploy and run transactions. So there's a second option, bottom option. So just to repeat, go to the little plug, the plugin manager, activate, deploy and run transactions. Activate solidity compiler. You can ignore the rest. I never use the rest.
00:22:00.850 - 00:22:46.700, Speaker B: Okay, so now we go to the compiler. So what you should see is that it should autocompile and already be compiled, but I always click as the be double share because I don't trust autocompile. I've ran into some troubles in the past. Okay, and now we click on is deploy and run transactions. So can everyone see this on their screen? Raise your hand if you cannot see this on your laptop down there. Mary, can you help the guy behind you just because you're there? Awesome. Okay, so can everyone see this on their laptops?
00:22:47.920 - 00:22:48.568, Speaker A: Nope.
00:22:48.664 - 00:22:52.520, Speaker B: Chris, can you help that guy there? The guy in the blue?
00:22:52.680 - 00:22:53.390, Speaker A: Cool.
00:22:54.240 - 00:22:59.410, Speaker B: And okay, can anyone else not see this?
00:22:59.780 - 00:23:00.480, Speaker A: Are you okay?
00:23:00.550 - 00:23:08.420, Speaker B: Yes, let me just jump down quickly. All my helpers are gone. Just click that one.
00:23:08.490 - 00:23:08.964, Speaker A: Which one?
00:23:09.002 - 00:23:21.720, Speaker B: Oh, click compile up there, down, hit compile. Hello world. Okay, see, exactly, that's why we don't trust the auto compiler. My point proven.
00:23:22.940 - 00:23:23.690, Speaker A: Cool.
00:23:25.260 - 00:24:04.564, Speaker B: Okay, so guys, what we're going to do now is we're going to deploy hello world. So we have to click deploy, bam. So the default gas limit for this transaction is 3 million gas, but our contract will actually cost in practice. Let me see how much it actually costs. Calls about 100K gas, so I'll go through that now actually. So guys, hit deploy. Everyone click the word deploy and just click it once.
00:24:04.564 - 00:24:20.990, Speaker B: Now when you go to the bottom right hand side down here, you'll see a transaction in the VM and it should have a big green tick. If it doesn't have a big green tick, raise your hand because then something went wrong. Okay, has everyone got a big green tick there?
00:24:21.520 - 00:24:22.364, Speaker A: Cool.
00:24:22.562 - 00:24:29.688, Speaker B: So click it and we can get cool information about this transaction. Oh, you guys. Okay, awesome.
00:24:29.874 - 00:24:32.690, Speaker A: Cool, it works.
00:24:33.940 - 00:25:06.170, Speaker B: So you'll notice that this is from a certain address that's you because you signed the transaction and you broadcast it and we've sent it to the Hello, World constructor. Basically, we've created the smart contract. So there's a new address for the smart contract. I allocated 3 million gas for this transaction. That was the maximum quantity of computation I was willing to pay for. I was willing to pay up to 3 million gas. I only used 100,000 gas, give or take.
00:25:06.170 - 00:25:21.890, Speaker B: And you'll see down here that, well, there's nothing interesting yet, but we can all see that the contracts created. So if you scroll here to deployed contracts, just here, click the little right arrow next to it.
00:25:23.300 - 00:25:23.952, Speaker A: Okay.
00:25:24.086 - 00:25:43.590, Speaker B: And you'll see the function send message. Okay, so again, go to the left hand side, go to deployed contracts, click the little arrow and you'll see the list of functions. Okay, so has anyone not got to this part yet? Raise your hand if you're not here yet.
00:25:44.700 - 00:25:45.304, Speaker A: Cool.
00:25:45.422 - 00:26:19.888, Speaker B: Everyone's here. So all we have to do is click send message. Bam. It's like clinic, bang, the dirt is gone. And now we've sent the transaction to the network, and we should hopefully have emitted the word hello, world. So click the transaction, scroll down to the bottom, and we'll see in the logs that there was an event called Message. So we've notified the world that there was a hello message, and the message was Hello, World.
00:26:19.888 - 00:27:04.400, Speaker B: And so everyone here has now admitted and notified the world of hello. Okay, so just one last time in the logs, you'll find a transaction with hello, World, send message. Okay? We click it, we scroll down and we can see the event. Now, this is obviously a really useful feature for more than just Hello, World. If your contract's doing anything interesting whatsoever, please emit an event because it makes it really easy for anyone watching your contract to watch for interesting events and to do something in response to this. But the issue is that Hello World's a bit boring. It would be really nice if we could send more than just Hello, World.
00:27:04.400 - 00:27:06.480, Speaker B: So let's go back to our contract.
00:27:07.620 - 00:27:08.370, Speaker A: Okay?
00:27:08.900 - 00:27:10.140, Speaker E: What's the topic?
00:27:10.300 - 00:27:11.440, Speaker A: Oh, topic.
00:27:11.780 - 00:27:23.620, Speaker B: Where is it? I don't really know the best way to describe that. I think that's just the how would you guys describe the purpose of topic?
00:27:24.360 - 00:27:31.072, Speaker D: It's a hash of defense okay. To collect the event.
00:27:31.226 - 00:27:31.816, Speaker A: Oh, yeah. Okay.
00:27:31.838 - 00:27:34.292, Speaker B: It's a hash of the word event and parameters.
00:27:34.356 - 00:27:35.304, Speaker A: Yeah, okay.
00:27:35.342 - 00:27:52.380, Speaker B: I always forget. So basically the point of topic is that when you're writing code in web3 and you want to watch for an event, you normally say, this is the event I want the watch for. So that's just a hash of the word of the string event in the parameters.
00:27:55.600 - 00:27:57.360, Speaker A: Cool. Yeah.
00:27:57.510 - 00:28:06.096, Speaker E: When you say it's a hash for everything in those tags is the meaning for the marble trees in the blockchain.
00:28:06.288 - 00:28:35.804, Speaker B: So in Ethereum, where do events live? Let me get to that first. So in Ethereum, every transaction will produce a receipt. The output, the finished execution and what we care about. The event lives in the receipt. So in the blockchain itself, there's no record of the event. We don't store the event. When we execute the transaction, we get a receipt and we get the event data there.
00:28:35.804 - 00:28:51.996, Speaker B: Now, in Ethereum as well, in the block header, there is a merkel tree of all the transaction receipts. So you can verify yourself that this transaction receipt actually exists for this block, for this transaction. So there's a commitment to it.
00:28:52.038 - 00:28:54.070, Speaker A: Yeah. Cool.
00:28:55.000 - 00:28:58.550, Speaker B: Okay, so any other questions before I continue?
00:29:00.760 - 00:29:02.150, Speaker A: Okay, yeah, go ahead.
00:29:04.520 - 00:29:10.520, Speaker B: Yes, I forget how much scott exactly. It's not too expensive. Let's say 1000 for now, but we can Google it.
00:29:10.670 - 00:29:22.556, Speaker D: Yeah, I know that the function also returns a value instead of emitting events. If it's a transaction, can you actually get the result of that value?
00:29:22.738 - 00:29:39.648, Speaker B: Not very easily. Events are much easier. So normally when you run the transaction, the whole point of the return statement is to return to another smart contract or to another function. It's very difficult to get it out. So hard that I would even bother trying.
00:29:39.814 - 00:29:43.628, Speaker D: And one good point is smart contracts can't read these events.
00:29:43.724 - 00:29:45.248, Speaker A: Like you said, the event is in.
00:29:45.254 - 00:29:49.872, Speaker D: The history or in the receipt. One smart contract can't go like, read some events.
00:29:50.016 - 00:30:15.484, Speaker B: Yeah, that's a very important point. Just to reiterate that. So events are only for humans and meet space for you and I. They are not for other smart contracts. If contract A is calling contract B, you return a value to that. So what you would normally do is returns. In this case, we're going to return a string and we'll return hello world.
00:30:15.484 - 00:30:17.150, Speaker B: And let's just put this in now.
00:30:17.600 - 00:30:18.350, Speaker A: Okay?
00:30:19.120 - 00:30:20.720, Speaker B: We need to do memory.
00:30:22.100 - 00:30:26.690, Speaker A: Cool. Okay, cool.
00:30:27.940 - 00:30:49.556, Speaker B: So memory means that memory means is that this variable will only exist for this transaction. It's not stored for long term. And actually, there's some subtle attack factor. I mean, not attack factors, subtle bugs. If you mix up stories and memory. If I get time after the next tutorial, we can go through one of the bugs. It's in one of the tutorial sheets.
00:30:49.556 - 00:30:54.490, Speaker B: If you look at tutorial two, I think it's in there of how you can mix that up.
00:30:55.740 - 00:30:57.688, Speaker D: Yes, exactly.
00:30:57.774 - 00:31:00.636, Speaker A: Message what one?
00:31:00.738 - 00:31:02.316, Speaker E: The message hello world.
00:31:02.418 - 00:31:10.780, Speaker B: So this is hard coded in the bytecode. So when I deploy the contract, it is hard coded in the program right now and that's on the blockchain.
00:31:12.320 - 00:31:14.780, Speaker E: But is it not in the hash format?
00:31:14.940 - 00:31:29.430, Speaker B: The hash format? So you mean this hello world here? So this is a program, so there'll be bytecode and that bytecode will live on the blockchain. So hello world is hard coded into the program.
00:31:33.720 - 00:31:53.790, Speaker D: When I look at the API that gets posted on a certified contract on and it says this method returns. This actually for a transaction function? Is the API actually saying this function is just emitting an event?
00:31:55.680 - 00:32:08.930, Speaker B: Is that for event? I'm pretty sure that's just for returns. So if it says returns, will it be this statement here effectively equivalent. So it shouldn't I don't think the API should say what event is there, but I don't remember.
00:32:10.340 - 00:32:12.640, Speaker D: Okay, so API doesn't say what events.
00:32:15.860 - 00:32:25.136, Speaker B: Chris no, I don't think it does. No. Yeah, it doesn't. So the return just means that this function will return a value. But again, that's only useful for other smart contracts.
00:32:25.328 - 00:32:26.070, Speaker A: Yeah.
00:32:27.160 - 00:32:48.670, Speaker B: And that's important. So the reason for that is if there's a contract surviving on the blockchain that says an Oracle service, I want to interact with that Oracle. So I need to know the return statement for that. So I look at the Abi, I see the function, I see the return statement, then I can write a contract that will match that. That's one of the purposes why you would have that. Again, it's for contract space.
00:32:49.040 - 00:32:49.452, Speaker A: Okay.
00:32:49.506 - 00:32:50.524, Speaker B: Any other questions?
00:32:50.642 - 00:32:51.140, Speaker A: Yep.
00:32:51.240 - 00:32:58.700, Speaker D: That event, is that public? Yes, it can be called by can be called from outside smart contract.
00:32:58.860 - 00:33:07.910, Speaker B: So if you want to play with this, this will live on the blockchain and you have to send a transaction to the network that invokes this function.
00:33:08.280 - 00:33:09.716, Speaker D: That invokes same message.
00:33:09.818 - 00:33:10.336, Speaker A: Yep.
00:33:10.448 - 00:33:11.892, Speaker B: And then anyone can read it.
00:33:11.946 - 00:33:16.630, Speaker D: You can't send a transaction that invokes message. That invokes message.
00:33:17.000 - 00:33:26.720, Speaker B: Message. Oh, not the no, no, you can't just call the event. Yeah, not that I know of. The abi the events. I don't think events from the Abi.
00:33:26.900 - 00:33:28.750, Speaker D: Maybe because people go ahead.
00:33:31.440 - 00:33:41.756, Speaker B: Where is the Abi? I don't think I've ever looked at the Abi on remix before. In the compiler. That's seat.
00:33:41.868 - 00:33:42.530, Speaker D: Yeah.
00:33:43.380 - 00:33:51.200, Speaker B: Oh, Abi. I've never used this feature. Here we go. Oh, it's just copied it. Of course, that's seat.
00:33:52.100 - 00:33:52.752, Speaker A: Oh, okay.
00:33:52.806 - 00:34:02.740, Speaker B: There it is. Oh, I didn't know that. Yeah. Is this saying that the event exists? Thank you for that. This shows you how often I look at APIs.
00:34:04.120 - 00:34:04.804, Speaker C: There you go.
00:34:04.842 - 00:34:05.430, Speaker B: Awesome.
00:34:06.760 - 00:34:08.470, Speaker D: Somebody executes that function.
00:34:10.280 - 00:34:13.144, Speaker A: Yeah, cool.
00:34:13.262 - 00:34:33.200, Speaker B: Okay, so awesome. I learned something new. Good job, guys. Okay, so now I'm going to quickly move on to one more task and then I'll give it over to the build alert crew to go through the debugging. Okay, so what I want to do now is allow anyone in the world to set a message and emit it.
00:34:33.350 - 00:34:33.856, Speaker A: Okay.
00:34:33.958 - 00:34:55.610, Speaker B: Bit like a bulletin board or a broadcaster. So this is really easy to do. It's just like any programming. We're going to give an argument or a parameter, so we're going to do string message. And of course, again, we have to put memory in there. So this will only exist for this function call and then we put message in.
00:34:57.660 - 00:34:58.120, Speaker A: Okay.
00:34:58.190 - 00:35:17.950, Speaker B: And again, we're just going we'll just keep hard coded hello, world in there. Why not? That's fun. Okay, so we're just going to modify the function, the OD and a new parameter called message with a type string. And then we're going to modify the event and put message in there.
00:35:18.560 - 00:35:19.272, Speaker A: Okay.
00:35:19.426 - 00:35:52.200, Speaker B: Very simple, very straightforward. So now what we're going to do is, again, we're going to compile it, make sure it compiles. Now in this list in deploy and run that menu, make sure you delete the old contract. So go to the old contract here and click the little bin. Make sure you delete that just to avoid running old code. That's normally a source of mistakes, and I've done that plenty of times. Then we want to redeploy the contract.
00:35:55.500 - 00:35:56.250, Speaker A: Okay.
00:35:58.080 - 00:36:04.750, Speaker B: Now that we've redeployed it, we actually have an option. Now the include a message.
00:36:05.840 - 00:36:06.348, Speaker A: Okay?
00:36:06.434 - 00:36:35.290, Speaker B: So we're just going to include a message to say, this tutorial rocks because it rocks so much. And then we're going to hit send message and send that again to your virtual network. Bam. If we scroll down, we'll click here and we'll all see that this tutorial rocks. So now we can enter in a random message and that'll always be emitted. Is there any questions?
00:36:36.300 - 00:36:42.890, Speaker D: When you deploy a contract, you get the address. Could you choose this address?
00:36:44.300 - 00:37:08.240, Speaker B: So there's two ways to create a contract address. The first one is typically based, so they tend to be deterministic. So the first one is based on your address and the transaction downs, so you don't really have much control there. The other one is based on, I believe, also the sender's address and the bytecode. Does that include the message? Doesn't that okay. I think that was one of the proposals.
00:37:09.460 - 00:37:10.064, Speaker A: Okay.
00:37:10.182 - 00:37:10.764, Speaker B: And assault.
00:37:10.812 - 00:37:11.152, Speaker A: Oh, yeah.
00:37:11.206 - 00:37:17.460, Speaker B: So it's just the inner code and the assault value next to it. So now you have a lot more control, can be more deterministic.
00:37:18.040 - 00:37:18.790, Speaker A: Cool.
00:37:22.920 - 00:37:46.060, Speaker B: I believe in the transaction field, it will be empty. I don't think you actually fill that until the contract is created. Yeah, but you could double check the code from I remember there was that you send it to when you first create the contract. The transaction won't have the address in the field from what I remember. Yeah. Damn. This is bringing back like three years of memory.
00:37:46.060 - 00:37:57.810, Speaker B: Just take this for granted. Now, is there any other questions at this point about so has everyone completed this part of the tutorial? Okay, what are you stuck on?
00:37:59.220 - 00:38:00.370, Speaker E: Public return?
00:38:01.860 - 00:38:07.584, Speaker B: Yes, that's it. That's the end. Oh, the old contract.
00:38:07.712 - 00:38:08.004, Speaker A: Yes.
00:38:08.042 - 00:38:13.990, Speaker B: Delete the old contract. Hit that little bin, make sure that's deleted because that.
00:38:16.040 - 00:38:19.468, Speaker A: Yep, yep.
00:38:19.504 - 00:38:24.840, Speaker B: And then you can deploy it again so you can redeploy it and fill in the message to say, this tutorial rocks.
00:38:27.500 - 00:38:28.250, Speaker A: Okay.
00:38:31.660 - 00:38:33.820, Speaker E: Why do you have to put in a memory keyword?
00:38:34.640 - 00:39:05.060, Speaker B: So a string could be an arbitrary size of bytes. So because it'd be an arbitrary size of bytes, we typically just say, this will exist for this function. So it's not like a native primitive. Native primitives. You don't have to worry about memory. But if you look at the tutorials, the tutorials are very in depth. It'll explain the difference between storage and memory and some of the bugs that would occur if you get them confused.
00:39:06.360 - 00:39:08.296, Speaker A: Okay, so I'm going to do one.
00:39:08.318 - 00:39:43.110, Speaker B: Last task because I think I have about two or three minutes left. So the only problem with this smart contract now is that it doesn't record any history. It'll always emit a message and not keep any storage or memory around. So we're going to try to do is keep a log of all previous messages. So I've got to remember how to do this myself. So we do this string array and there's all messages. Okay, I'm pretty sure where did I put public? I think it's here.
00:39:43.110 - 00:39:46.470, Speaker B: No, didn't like that.
00:39:49.480 - 00:39:50.276, Speaker A: Cool.
00:39:50.458 - 00:40:05.720, Speaker B: Okay, so in the code we're going to create a string array that's denominated by the little curly no, what do you call them? Square brackets. We're going to make it public just so it's a publicly accessible variable and anyone can read it. And we're going to call it old messages.
00:40:06.960 - 00:40:07.710, Speaker A: Okay.
00:40:08.800 - 00:40:16.590, Speaker B: And then here what we're going to do. And I hope this works because I haven't done this in a while. Push message.
00:40:18.000 - 00:40:18.750, Speaker A: Cool.
00:40:23.060 - 00:40:32.550, Speaker B: Okay, now what's important is that because this is in storage is a dynamic array. There's no fixed size to it. It could be any size.
00:40:34.760 - 00:40:35.510, Speaker A: Okay.
00:40:38.930 - 00:40:52.950, Speaker B: So just add in that new variable string array, public or messages, and you can also do dub push. I see people typing, so I'll wait a second.
00:40:59.010 - 00:41:03.978, Speaker E: In this case, it's also variable, the size of the string, the array of string unit memory.
00:41:04.074 - 00:41:29.190, Speaker B: Yeah, exactly. It's variable size string. So under the hood, solidity takes care of making sure there's enough byte 32s, because I think there's only a recent feature. I think it's only in the past year or two that they've had string. I remember when I started they didn't have a string and it was really difficult. Okay, so I think everyone stopped typing now. So again, what we're going to do is we're going to make sure this is compiled.
00:41:29.190 - 00:41:54.980, Speaker B: We're then going to go in the deploy and run, delete the old contract, always make sure that's deleted and this is empty. And we're going to redeploy the contract. Bam. Then we're going to scroll down here. And now you're going to see two fields. First is the send message function, where again, we can put in any message we want. So we're going to say if London is going to be great fun.
00:41:54.980 - 00:42:08.120, Speaker B: And we can send that to the know. Bam. Sent. So if we just scroll down for a second, we'll see the latest transaction. We can click it.
00:42:10.970 - 00:42:11.526, Speaker A: Okay.
00:42:11.628 - 00:42:50.014, Speaker B: And we can clearly see here that Eflondon is going to be great fun. Now, what is important is that this is the very first item in the know we've actually storaged something now on the network. So we go to old messages. You'll see that this is blue. So from what I remember a blue means is not going to be a transaction, it will be a call. What I mean by a call is that I've got a local copy of the contract, I've got the local state because I've got the blockchain I can simply read from it. So I'll do a call and I'll read from the contract.
00:42:50.014 - 00:43:37.806, Speaker B: I can also do a dot call that run the function locally, that make sure it does what I expect before I send it out to the network. So doc call allows me to run a function locally and not on the network. So what I always recommend is that when you actually write your smart contract and your web3, I typically run the code first before I send a transaction out because I want to make sure it's doing what I expect. So if we put in zero here the first entry in the list, we do all messages bomb, we get the string, it was stored on the network. If I put in one it should hopefully blow up. Yeah, it didn't change at all. Terrible error message remix, invalid upcode.
00:43:37.806 - 00:43:44.866, Speaker B: There you go, invalid upcode. Such a good error message but I think everyone gets go ahead just on.
00:43:44.888 - 00:43:49.570, Speaker D: The call it runs locally.
00:43:55.370 - 00:44:03.338, Speaker B: No, because you're not interacting with the network. It says local between you and your blockchain but you can run through the.
00:44:03.344 - 00:44:05.510, Speaker D: State changes and make sure they're going to succeed.
00:44:05.590 - 00:44:05.786, Speaker A: No?
00:44:05.808 - 00:44:28.110, Speaker B: Yeah, exactly. So the motivation is that you run the function first and you can verify yes, that's definitely going to cast my vote, it's not going to fail. And then you broadcast that out to the network so you make sure that it works first. Of course I could do another talk about breaking smart contracts and there's some subtle bugs around unpredictable execution.
00:44:28.270 - 00:44:28.994, Speaker A: Go ahead.
00:44:29.112 - 00:44:39.314, Speaker D: Yeah, I have a question about the receipt. Like we see what event is there also a way to see what is changing the storage in the state?
00:44:39.512 - 00:45:11.120, Speaker B: What we change is actually, I don't know how easy this is the access but technically in the block header what is it under? Maybe there's a commitment to the entire state. So in a block header there's a commitment to the new state of the network. But I do believe that there's a commitment between every previous state for a transaction and every post state. So you can actually look up the state difference in the commitments for that. But an easier way is just to read the contract yourself.
00:45:13.250 - 00:45:15.360, Speaker D: The old message array to change.
00:45:17.010 - 00:45:35.478, Speaker B: It will, but I don't think it's going to be an easy to read format given what's in the block header. I don't think it's a straightforward work out the difference. I mean obviously you can see the byte difference. But my advice would be just to read the contract. I mean, actually just look, do your local call and look at what's up.
00:45:35.644 - 00:45:36.360, Speaker A: Yeah.
00:45:38.410 - 00:46:20.454, Speaker B: For what? Exactly? They can get large and expensive, and there's some very subtle attacks around that. The motivation is that I never use dynamic arrays, but the motivation is that there's some item you want to add to a list. So one example could be a lottery. You want to append a new lottery ticket to the list, and then at the end of the lottery, I just tell the smart contract my lottery ticket was 50 entry 50, and then the contract can look that up. Yeah, exactly. You should delete it over time. So one of the salt la tax is that you could have a for loop here.
00:46:20.454 - 00:47:03.486, Speaker B: So what we could do is for U and I equals zero I is less than O messages length I plus plus. And then we could actually emit every old message. You don't have to type this in. This is just for fun. Now, can anyone tell me what would go wrong here except for my error message because I misspelt it. Can anyone tell me the issue with this function? With this for loop, it will consume a lot of gas. So if this list has, let's say, 50,000 elements, then actually the issue is that I call the send function, I run through the code, I get the here, I run this 50,000 times, I run out of gas.
00:47:03.486 - 00:47:27.818, Speaker B: And what happens if you run out of gas? Everything reverts. If everything reverts, you can never finish this function execution. So you actually break the function. So dynamic arrays are really dangerous and never do a for loop around a dynamic array. That's one of the subtle attack factors. I mean, I could go on for hours with subtle attack factors, but that's one of them. Any other questions?
00:47:27.984 - 00:47:28.700, Speaker A: Yes?
00:47:31.070 - 00:47:41.680, Speaker B: No. Strings are just as big as they can be, as far as I'm aware. I don't think there's any upper limit except for the gas. Any other questions?
00:47:44.940 - 00:47:45.690, Speaker A: Cool.
00:47:47.980 - 00:47:52.956, Speaker D: You want to know all the visitors and you want to use that for.
00:47:52.978 - 00:47:54.988, Speaker B: The reason you just mentioned.
00:47:55.154 - 00:48:03.100, Speaker D: How can you gather them all using the needs that we have in the documentary.
00:48:03.760 - 00:48:35.850, Speaker B: So I think here is that well, this is going to be one of the limitations is that if you have an array of 50,000 elements, you probably never want to grab everything at once because it's just too expensive. Computationally. What people tend to do is use mappings. So this is technically like a mapping. I can access a variable. So what you could do is say function, let's say, emit old message, and then we actually put a Uwint in there. Okay, I and then what we do is we just emit this.
00:48:35.850 - 00:48:51.830, Speaker B: So what you would do then is just do it individually. So every new function would emit this whole message. So you can still access everything, but you just never try to grab everything in a dynamic array.
00:48:52.250 - 00:48:54.918, Speaker D: You don't usually do it, but you could set up link lists and you.
00:48:54.924 - 00:48:56.122, Speaker B: Can parse through them and you can.
00:48:56.176 - 00:48:57.866, Speaker D: Watch how much gas you have left.
00:48:57.968 - 00:48:58.586, Speaker B: You can do that?
00:48:58.608 - 00:49:03.020, Speaker D: Yeah, doc, once you're getting close to running out of gas and then do that.
00:49:04.510 - 00:49:19.086, Speaker B: Yeah, I actually did that in my own voting contract years ago. So the idea there is that you got to have a function that keeps so basically in a solidity, which you can access is what is that opcode? Is gas used, gas left. That's it.
00:49:19.108 - 00:49:19.246, Speaker A: Good.
00:49:19.268 - 00:49:37.350, Speaker B: They made a successful keyword. So you can actually check how much gas is left in the transaction. So you can say if gas is left is greater than 50,000. Continue. I could actually just do it now. So let's just say we have a U into checkpoint.
00:49:39.050 - 00:49:39.798, Speaker A: Okay?
00:49:39.964 - 00:49:46.298, Speaker B: So we do is that we go through four U and I equals zero I. It's less than I don't think I've.
00:49:46.304 - 00:49:48.250, Speaker D: Seen a single production contract.
00:49:48.750 - 00:50:19.442, Speaker B: No, I would never do this. This is just me doing this for fun. Now it's like, oh, messages I plus one. So you could have a function like this, for example, where you just see if the checkpoint else checkpoint equal I, then you just stop. So we'll look a bit like that, but please never do this in production. If you do, you've never taken this class. But yeah, you could do something like that.
00:50:19.442 - 00:50:27.800, Speaker B: Then you could keep recalling that function. It'll eventually get over all the elements. Although that's all full of error messages, so it's broken. Go ahead.
00:50:29.130 - 00:50:38.346, Speaker D: What about you say, like, I want to just run 1000 elements at a.
00:50:38.368 - 00:50:42.198, Speaker A: Time, calling it until you yeah, that's.
00:50:42.214 - 00:51:08.020, Speaker B: Basically this idea here. But this is like arbitrary number. So what happens is that you'll go in this function, I should really fix this shooting i. That's annoying me. So the idea is that in this function you call it, it'll start a zero because it begins with zero, and it'll start going through every element in the list. And every time it tries to, it'll do emit message. Old messages i.
00:51:08.020 - 00:51:16.528, Speaker B: Why is this complaining? Oh.
00:51:16.614 - 00:51:17.440, Speaker C: Oops.
00:51:23.030 - 00:51:28.370, Speaker B: Yep. There you go. Camo KS. Chris is probably laughing right now because I never do camo kius.
00:51:29.450 - 00:51:30.600, Speaker A: Okay, cool.
00:51:31.130 - 00:51:43.210, Speaker B: Let's get rid of that. I'm done with this. Okay, so what you'll see here is that you'll call this function it'll start from I. It'll then start looping through. Do I still have gas left?
00:51:43.280 - 00:51:43.798, Speaker A: Yep.
00:51:43.894 - 00:51:54.720, Speaker B: Emit a message. Gas left. Emit a message. Eventually you'll run low on gas and it'll store the checkpoint and finish. You could even do a return there. Actually, you should have a return there.
00:51:56.210 - 00:51:58.842, Speaker E: Meeting of the message costs 50,000 gas.
00:51:58.906 - 00:51:59.520, Speaker C: Right.
00:52:00.370 - 00:52:10.850, Speaker B: This is like an arbitrary number. Normally, that's like 5000. It's very small. It's like 2000, 5000. It's not very big. That could be 10,000. Actually, that needs to be 30,000 because you're storing something.
00:52:10.850 - 00:52:30.470, Speaker B: But yeah, that'll be the idea. You'd leave enough gas left over to store the checkpoint and then return. But please never do this. No, please don't. This is for fun. This is a really good example to highlight gas and the limitation of making sure you have enough gas left. So this is only for that purpose.
00:52:30.470 - 00:52:32.860, Speaker B: Have you ever a production coal like this?
00:52:33.230 - 00:52:35.450, Speaker D: But the car also uses gas.
00:52:36.750 - 00:52:54.458, Speaker B: Yes, exactly. Everything here costs gas. Normally you get to this point though, you'll just save the checkpoint in return. So you have 30,000 gas to do this, giving that requirement. Awesome. So now we're done. So we're going to move on to the builder task.
00:52:54.458 - 00:52:56.000, Speaker B: So just jump on up, guys.
00:52:56.850 - 00:52:57.710, Speaker A: Yay.
00:53:00.130 - 00:53:01.280, Speaker B: You need this.
00:53:02.310 - 00:53:48.820, Speaker C: So the idea of this session is to help you get a complete development environment for smart contacts and DApps. And everything is contained in this repository. And everything that I'm going to explain is here written in the repository. So if you want to go deeper into something, or if you miss some part of it, or you think that something is too easy for you, you can just skip parts of it. Go there and read by yourself. So the first thing that we need to do is clone this repository and install it. Can you read this? Is it big enough?
00:53:49.990 - 00:53:50.740, Speaker E: Yeah.
00:53:51.670 - 00:54:19.420, Speaker C: Okay. So I already cloned the repository. But you have to do that like it's a normal repository. On GitHub go here, copy this URL git clone, paste it, enter that's it. And then to install this, you just have to type NPM install. It may take a few minutes, so let's wait for everyone to install it.
00:54:45.090 - 00:54:46.030, Speaker A: Popular.
00:54:47.970 - 00:54:49.790, Speaker D: Does everyone have the URL?
00:54:51.810 - 00:56:24.980, Speaker C: So let's go back to URL. NPM install? Yeah, you need to install node JS. So if you don't have node JS installed or this NPM install fails, you can go to this section on the repository that says Development Environment Setup. And there you can go to this other repository that will teach you how to install everything. You can just copy and paste these things from the other repository to check if everything is already installed, just paste them. And if everything goes well, you should.
00:56:26.630 - 00:56:28.406, Speaker D: What version of Node are you using?
00:56:28.588 - 00:56:30.280, Speaker C: I'm using Note Ten.
00:56:32.490 - 00:56:33.560, Speaker D: To go with.
00:56:34.830 - 00:57:02.450, Speaker C: I would do that because it's the current LTS version. So I would go with ten. But twelve or 13 should also work. Okay. Yeah. So if you go to this other repository that it's linked on the installation section of the one I linked, there's instructions to install node Gyp.
00:57:03.430 - 00:57:04.050, Speaker D: Thank you.
00:57:04.120 - 00:57:08.626, Speaker C: But I wouldn't recommend using node twelve. I would use Node Ten.
00:57:08.808 - 00:57:11.826, Speaker A: Yeah. Okay.
00:57:11.928 - 00:57:16.246, Speaker C: Has everyone installed this repository for those.
00:57:16.268 - 00:57:18.520, Speaker D: Who have the dev environment ready?
00:57:23.610 - 00:59:20.406, Speaker C: Okay, let's wait one or two more minutes. NPM is node package manager. Yeah. So most tools from the Ethereum development ecosystem are based on Node JS. So even if you don't like using Node, you will probably be using it because that's what most people use. You can use another platforms and languages, but you'll probably be better with Node JS as there are more tools and more things to use with the front end. There's a small front end here.
00:59:20.406 - 00:59:26.680, Speaker C: We won't go very deep into that during this session. But you can see a small front end.
00:59:29.370 - 00:59:30.120, Speaker A: Yeah.
00:59:34.810 - 01:01:26.670, Speaker C: Doesn'T it? I mean, you have to run NPM, run dev in the front end which will start parcel vandler going to be using a bunch of tools on this setup. The main one is called Vidler, which is a task runner and a development network. What does it mean? With Vidler, you can do most of the things you need to compile and test and debug your smart contracts. So if we run NPX VDLR help, Vidre will be executed and you see all the options, all the things that you can do with it. So if we want to, for example, compile our smart contacts, we just run NPX Bidler. Compile.
01:01:30.130 - 01:01:30.922, Speaker A: Oops.
01:01:31.066 - 01:02:15.272, Speaker C: Compile and that's it. I have already compiled them, so nothing happened. Let's do some video clean and compile them. Okay, so Vidlery has everything you need to test your smart contracts. Just like Remix from the other tutorial. Vid has its own testing blockchain. So whenever you run your test, it starts up a new blockchain where your smart contracts are going to be deployed and executed and you are going to be testing them from outside the blockchain in JavaScript.
01:02:15.272 - 01:02:54.330, Speaker C: Is everyone familiar with JavaScript? Raise your hand if you are with JavaScript. Okay, so normally you're going to test your smart context from JavaScript. And what is going to happen is that you are going to use an Ethereum library to connect to the Ethereum network. In this case, this library is called Ethersjs. With Ethers, you are going to model your smart contracts in JavaScript and interact with them through it. Through them. So let's see a small example of this.
01:02:54.330 - 01:03:39.362, Speaker C: Go to the test folder, create a new file example and here you can write your test using Mocha and Chai. Does everyone know? Or raise your hand if you know what Mocha and Chai are. Okay, so less than half of it. Mocha is just a test runner for JavaScript. It's not something ethereum related. It's like a super popular JavaScript project which is very easy to use. You just have to write these describe methods where you declare your test.
01:03:39.362 - 01:04:45.036, Speaker C: Like this describe is just like a section of your test should do something. So we describe you just declare a section of test like a vandal of tests that you are going to run and with it you declare one test. You just have to provide a title and a function that will test anything you want. And Chai is just an assertion library that you are going to use to actually test things. So you use it like this, expect something to be equal to something else and to run the test. You just run NPX vidlear test. There's a whole bunch of tests running here, but the one that we just created is here.
01:04:45.036 - 01:05:47.190, Speaker C: Something should do something. Is anyone here? Are you following me? Yes. So one is any value we want. So let's say that here it's ASD and we rerun this test. And as we are expecting it to be one, like ASD should be equal to one, this test will fail and we see it here. So assertion Error expecting ASD to equal one. Right.
01:05:47.190 - 01:06:32.550, Speaker C: So this is just a JavaScript test. It has nothing to do with Ethereum so far. So let's do something with Ethereum. This repository already has a simple smart contract. It's pretty much the same idea that Patrick explained, like a poll where there is a bunch of proposals and people can vote for them. And that's pretty much it. The only difference is that here you have an owner which is you don't have to read this whole thing, we're just going to go through it.
01:06:32.550 - 01:07:40.990, Speaker C: So in this smart contract you have an owner that is the person who deployed it, who's going to be able to add proposals, start the poll and close it. So when you deploy this contract, the owner will be automatically assigned to the deployer and the name of the poll will be stored and our state variable is open will be set as false. So let's test that. That works from JavaScript. So this describe will use it to test the pole contract. And we want to test that it should deploy correctly. What we are going to do is to get a JavaScript model of that contract and we do it this way.
01:07:40.990 - 01:08:38.200, Speaker C: Remember that everything here is written down in the README. So you can go as many times as you want through this. And also you can ask us about this on the discord. So this is how we get a contract factory. A contract factory is just a JavaScript object that lets us deploy a contract. We are using Ethers here to get the factory. Yeah, ethersjs?
01:08:43.120 - 01:08:43.868, Speaker A: Yeah.
01:08:44.034 - 01:08:45.740, Speaker D: I don't see your importance.
01:08:48.240 - 01:08:50.044, Speaker C: It's already injected by Biddler.
01:08:50.092 - 01:08:50.690, Speaker A: Yeah.
01:08:54.980 - 01:08:57.024, Speaker D: It'S similar to the artifacts of.
01:08:57.062 - 01:08:59.650, Speaker C: Yeah, pretty similar, yeah.
01:09:20.320 - 01:09:24.020, Speaker D: What's the difference between Ethergs and web3 GS?
01:09:25.240 - 01:09:59.076, Speaker C: Well, both of them are Ethereum libraries. You can use any of them for exactly the same things. I think Ethergs is better for these kind of projects, like a hackathon project. It will bring you less problems, probably. And it's very documented. So that's why I chose Ethers for this occasion. You can use both with Vidler because it has a very modular architecture and Ethers is just like a plugin in Vidler.
01:09:59.076 - 01:10:05.010, Speaker C: And you also have web3 plugins. But it's pretty much the same.
01:10:19.630 - 01:10:28.382, Speaker D: Yeah, fairly new to testing in JavaScript. One thing I've never understood with these kind of tests is like describe is coming from where you're obviously not reporting it.
01:10:28.436 - 01:10:28.894, Speaker C: Yeah.
01:10:29.012 - 01:10:32.494, Speaker D: This context is being injected by the test runner.
01:10:32.542 - 01:10:32.754, Speaker A: Yeah.
01:10:32.792 - 01:10:34.578, Speaker C: Mocha injects describe and need.
01:10:34.664 - 01:10:34.914, Speaker A: Okay.
01:10:34.952 - 01:10:38.180, Speaker D: And then so ethers. Does that need to be brought in?
01:10:38.710 - 01:10:49.574, Speaker C: You can is it in the context already? It's already like in the global context. You can import it explicitly if you want, but just for brevity, I'm not doing it here.
01:10:49.692 - 01:10:56.218, Speaker D: Okay, so everything, all packages that are brought in as dependencies are in the.
01:10:56.224 - 01:11:02.522, Speaker C: Global context or is there no, not all of them. This is vid layer that is injecting these things. Okay.
01:11:02.576 - 01:11:06.320, Speaker A: Yeah. Okay, cool, got it.
01:11:09.010 - 01:11:20.190, Speaker C: Okay, so now that we have this pole contact factory, we can just do deploy together a new pole.
01:11:29.490 - 01:11:31.334, Speaker A: But yeah.
01:11:31.532 - 01:11:32.280, Speaker D: So.
01:11:39.690 - 01:12:04.000, Speaker C: Yeah, but it's like its own blockchain, so yeah, no, the contact, the contacts get compiled before running the test. This line just lost the compilation output. Yeah.
01:12:07.810 - 01:12:08.560, Speaker E: So.
01:12:13.110 - 01:12:26.950, Speaker C: No, we are using no, I mean you could but that's another set of library of tools. We are using Bidiller and Bidiller VM here. Bidiller um, is like the testing library.
01:12:28.330 - 01:12:29.080, Speaker A: Yeah.
01:12:36.670 - 01:12:46.110, Speaker D: I got curious. How do you say to the Ekers that say, oh, get contracts and code. He goes to the smart contract directory.
01:12:48.450 - 01:12:50.842, Speaker C: It goes to the compilation output.
01:12:50.906 - 01:12:51.086, Speaker A: Yeah.
01:12:51.108 - 01:12:57.280, Speaker D: How they figure out how they get it?
01:13:00.450 - 01:13:07.934, Speaker C: There's like a default path to look for those artifacts, but you can set any path that you want.
01:13:08.052 - 01:13:13.590, Speaker D: So I need to say I need to write micro the same name of the contract.
01:13:14.570 - 01:13:15.390, Speaker C: Right, right.
01:13:15.560 - 01:13:16.280, Speaker D: Okay.
01:13:21.130 - 01:13:28.842, Speaker E: The contract can be deployed that your functionality is like as close as you wrote it.
01:13:28.896 - 01:13:29.354, Speaker C: Right.
01:13:29.472 - 01:13:31.450, Speaker E: It actually deploys it.
01:13:31.600 - 01:13:33.340, Speaker C: It actually deploys it.
01:13:34.190 - 01:13:37.562, Speaker E: So we misuse the test framework, kind of deploy your contract.
01:13:37.626 - 01:13:38.766, Speaker A: Right, right.
01:13:38.868 - 01:13:43.310, Speaker C: Then you can use the exact same things to actually deploy it to mainnet.
01:13:43.650 - 01:13:51.220, Speaker E: Why don't you just write the script and run the script? Like why do we need the chai framework here?
01:13:52.630 - 01:14:17.670, Speaker C: Just because it's easier. Like chai? Because it's easier. You could just do that without chai. But it has a very nice API to test things. What you do need is a testing network and that's the main reason that you want to use Biddeler or something like that, because you don't want to test these things in a real network.
01:14:18.270 - 01:14:24.678, Speaker E: Where do you define the connection to the network? You have some kind of property file?
01:14:24.774 - 01:15:13.790, Speaker C: Yes, there is a config file that has everything that you need. We are not going to go through that because it's a lot of data and it's already set up for you. But going back to this so Poll has a deploy function that will take the same arguments that the constructor. So here we have to pass it the name of the poll. Right. So we just do that from JavaScript and what we're. Going to test is that the actual name is used in the smart contract.
01:15:13.790 - 01:16:10.290, Speaker C: And how do we do this? It's just by getting the name from the contract and comparing it with a known value. So we can get the name by doing just poll name. So this pole object is going to have the same functions that the solidity contact have but in JavaScript, just like a one to one model between solidity and JavaScript. That is very handy to test these things. Also the good thing of doing the test in JavaScript is that you can reuse that code on the front end of your application. So here we use chai just like for convenience to be equal pole number.
01:16:10.760 - 01:16:11.510, Speaker A: One.
01:16:19.570 - 01:17:10.320, Speaker C: In a way. No, not really because we already have one here. Why do I need because yeah, name is Async function. Because it has to go to the blockchain, ask for it to execute the name getter and then when that value returns the promise that this name represents resolves or something like that. I mean, Async functions are a little bit hard in JavaScript but most of the times when you call a function in a smart contract, you need an await. Okay, I'm going to add this dot only here. So we are only going to run this test.
01:17:11.970 - 01:17:22.894, Speaker D: Anyone at all? Everyone following along. Where is this test located? Is this in the test folder?
01:17:22.942 - 01:17:25.780, Speaker C: Yeah, I just created an example. She.
01:17:27.990 - 01:17:30.900, Speaker D: What NPX command are you running?
01:17:31.690 - 01:17:33.010, Speaker C: What's NPX?
01:17:33.170 - 01:17:35.298, Speaker E: What NPX command are you writing?
01:17:35.394 - 01:18:33.450, Speaker C: Yeah, NPX Biddler test. Well, Bidler starts its own node right before running the test and stops no, it's called Bidler UVM. It's like an alternative to Ganache with some smart contact debugging functionality. That is what I'm going to show next. Yeah. So you can go to its website here. There's like a section of useful Links and there's a bit of documentation.
01:18:33.450 - 01:19:52.580, Speaker C: But in general if you clone this repository and read the README you'll get a much better understanding than now because we have a very short time to explain a lot of things. But you should be able to clone this repository and use it as the base boilerplate for your project just by reading the README and a little bit of the test files, a little bit of the contracts and there's also like a tiny front end that you can use to base your front end. Okay, so if we go back here, what we are doing is deploying a poll with a given name and then getting this name and comparing to the same value that we pass. And as everything is going okay, we are just getting a contact passing. But what we want to show you is how to debug contacts because that can be a very frustrating experience. And for this I'm just going to break this contract on purpose. How do we do this? Do you want me to go back to yeah, it's fine.
01:19:52.580 - 01:19:53.666, Speaker C: Here?
01:19:53.768 - 01:20:04.010, Speaker E: Yeah. What's in the front end?
01:20:05.900 - 01:21:00.372, Speaker C: The front end connects Ether S to a live blockchain that's running locally. To run that one you can do NPX vidlear node and this starts like a local Ganache thing with some debugging output enabled like here. I mean it's not receiving any transaction, but you'll get some interesting output and then you can point your MetaMask or whatever wallet you want to. That all these things are explained there. So okay, let's break this smart contract. The easiest way to do this is just to add a revert function call just like this. This will make the transaction fail and everything reverts.
01:21:00.372 - 01:21:44.874, Speaker C: And let's do that. So what's going to happen is that this line that is trying to deploy the contract is going to fail. So when we run our test, we should see an error there. So we see like this test on red, that's because it failed. And the testing part is that here you have a stack trace of Solidity embed in a JavaScript exception. So Mocha will know how to show that. And that's what Bidlari VM does.
01:21:44.874 - 01:22:08.580, Speaker C: Whenever you execute a contract, it knows which contract it's executing. It's not just like blindly executing opcodes and it can shows you exactly where your test failed. So if one of your tests fails, you just have to go there and figure out why. Of course it's here because we just studied it.
01:22:08.950 - 01:22:12.260, Speaker D: So your runner stopped, it didn't run any further test.
01:22:13.110 - 01:23:09.858, Speaker C: Yeah, that's because I added this only here just to make things faster. Also, we can pass revert string which will be available in the error message, but it's not very useful. There's no things like string concatenation in Solidity, so we can do things like this. This doesn't exist in Solidity and the reason why they don't exist is because these are quite expensive operations. Like string operations can get expensive pretty fast. Like if a string is to be concatenating, two of them, we run out of gas. So revere reasons are cool, but not so much.
01:23:09.858 - 01:23:45.230, Speaker C: You only get a fixed revere reason. They are good for testing. You can do things like making sure that a transaction actually meets the revere reason that you want. Like we could test for this string and that's something very common. There are many examples of this in the actual test of the poll contract in this repository. But for now, let's just run it like this. So instead of saying transaction revert without reason, we should get a better error.
01:23:47.330 - 01:23:48.190, Speaker A: Oops.
01:23:55.350 - 01:24:35.838, Speaker C: Okay, so now we get this kind of weird error message that it says VM execution, VM exception while processing transaction and the revert reason. But you still get the Solidity stack trace here. It's just a single frame because it's only the constructor, but you'll get the entire stack phrase. But still this is useful. But this is useful to figure out which line of the contract failed, but not why. Because you can actually output values from there. So one of the things that Biddler has is console log.
01:24:35.838 - 01:25:19.518, Speaker C: Just like JavaScript for use it, you just have to import this contract that is called Nomiclabs Builder console log and then just call it like if it were JavaScript. So we could do something like console log, deploying the poll with name and get values out of the contract. So this is how you can figure or try to figure out why your contract is failing which is kind of the same that you do in JavaScript or any other language. You just output parts of the state of the program to is there a.
01:25:19.524 - 01:25:29.042, Speaker E: Way to think about smart contract in a way that I get the breakpoints and then it stops and then I go like one line after another.
01:25:29.176 - 01:25:59.980, Speaker C: You can do that in remix like the previous thing that we saw, but not in Biddler. Right? So for now the tools that you have for debugging are console log and stack braces. So if we rerun this test with the console log on it, you should see it here. So deploying the poll with name poll number one.
01:26:01.230 - 01:26:01.980, Speaker A: Yeah.
01:26:05.950 - 01:26:06.806, Speaker C: Can you repeat?
01:26:06.838 - 01:26:08.620, Speaker D: Is there any reason why cocoa live?
01:26:09.650 - 01:27:02.720, Speaker C: Because we still have to implement that. That's like a ton of work, especially like things like the code in the state can be extremely hard and we haven't had enough time to implement it now. Mostly because we were trying to get the basics working. Things like stack traces and console log weren't the thing before builder and we just recently launched these things. And then the other thing that you can use to debug your transactions is to enable like a very verbose bid layer mode. So to do this you have to go to Bidlair config JS which has a ton of things but we can ignore most of them for now.
01:27:06.850 - 01:27:13.410, Speaker D: About the console log, there is a real contract console deployed.
01:27:17.990 - 01:27:59.220, Speaker C: Everything here is on a real blockchain, it's like a simulated blockchain that Biddler starts and stops automatically. But yes, there is a console contract. It's not exactly a contract, it's a solidity library, those are treated a little bit differently. But yes, you can actually go to the console contract like this and you won't understand the thing because this is a little bit of EVM magic. It's not like actually printing anything, it's Vdlair that detects these things and print them. But everything in a smart contract is printed in solidity. Yes.
01:27:59.220 - 01:29:35.170, Speaker C: So going back to the verbose output that you can enable, you just have to go to the config here. Most of the data of the config is in this module exports offshoot and here we have networks configuration, it's like a section of the network and Vlavm is the one we are using. It's like this special automatic network and here we can do something like login enable true. And when we rerun the test we are going to get lots of output for every transaction and call that we do. So instead of just seeing the JavaScript execution of the test, we are also going to be able to trace every transaction and call. Okay, so do we need more time? Okay, so if we rerun this you are going to see a trace of every call into the blockchain. So first we do this call ETH account to get the actual account that the node has.
01:29:35.170 - 01:30:53.692, Speaker C: Then this net version we can ignore it. It's just like an internal Ether thing to figure out how to set itself up properly. And then we have this ETH estimate Gas. What is going on here is that Ethers is trying to make a transaction but it has to know how much gas to use. And it does it by calling this ETH gas method of the node which will run or simulate the transaction, figure out how much gas it takes to run it and then maybe improve that approximation a little bit to be sure that it's not going to fail and return that number. But as our constructor method is always failing, the if send transaction is also failing because when the node tries to simulate this transaction it will fail and we are going to see this here. So what you get is the name of the contract that is being deployed, who is sending that transaction, how many ETH that transaction has.
01:30:53.692 - 01:31:03.580, Speaker C: In this case it's just zero the console log. I mean any coil to console log will be displayed and also the solidity stack trace.
01:31:07.680 - 01:31:13.084, Speaker E: The constructor sold the call when creating the transaction.
01:31:13.132 - 01:31:13.584, Speaker C: Right?
01:31:13.702 - 01:31:14.224, Speaker A: Right.
01:31:14.342 - 01:31:19.060, Speaker C: So if we change the contract.
01:31:20.840 - 01:31:21.156, Speaker A: To.
01:31:21.178 - 01:32:33.276, Speaker C: Make it stop failing and we rerun the test, it's going to pass and we are going to see the other things. So here estimate Gas was successful. Then Ethers made the ETH sent transaction pretty much the same one. But here it used Sungas and it was mined in a block. And then there's a bunch of things that Ether does to actually confirm that the transaction has run successfully. And then finally there's this ETH call that it's going to call Paul name like the function name of Poll and you get some data like who sent it and which was the Poll contract and that's it. I mean if you add more things like another call to Poll name or a call to another function, you are going to see more if calls or if sentence actions depending on whether if it changed the state or not of the contract.
01:32:33.276 - 01:32:59.160, Speaker C: So if you are calling to a function that changes the state of the contract, ethers will know that it has to send a transaction and that's what it's going to do. If it doesn't change the contract, it's going to do a call. That is what Patrick explained of running a transaction locally and returning the return data of that simulated transaction.
01:33:04.540 - 01:33:13.230, Speaker D: Can we specify a different address for the call to full name because it's using the creator to do that query. So we wanted to use like a different address.
01:33:13.920 - 01:33:57.986, Speaker C: Yeah, sure, you can do that. We can do an example. So to do that, you are going to use the connect method of ethers. Here. You can pass it, I think, an address or what ethers call a signer. Signers are ether subtraction for accounts, but we first have to get them so we can do this or signers and then do something like signer one. Let's rerun it this a bit.
01:33:58.028 - 01:33:58.620, Speaker A: Yeah.
01:34:00.190 - 01:34:46.760, Speaker C: Oops, thanks. So, yeah, it was sent from this and from this, right. So things like this are explained on the README. So if you want to go to the details of how to do all these things and many more, you can read that. So any questions so far, sir? Name, I think, on that.
01:34:58.320 - 01:34:59.070, Speaker A: Yeah.
01:34:59.520 - 01:35:10.610, Speaker E: How does the get information works? Does it actually run against the blockchain? How much of the gas was used?
01:35:12.040 - 01:35:55.520, Speaker C: Actually, it's like a binary search of gas. Like you first run with a random value, the transaction, like simulate it not like actually run the transaction and see if it fails. If it fails, increase the gas. If it fails, increase it. If it pass, try a little bit lower gas. And just like that, you could do something clever or more clever, but it's better to be sure that you are going to get a right estimation than doing it faster.
01:35:56.020 - 01:36:02.052, Speaker E: As I understood, every operation has a pre specified gas cost, right?
01:36:02.106 - 01:37:03.832, Speaker C: Yeah. The thing is that you are going to have different control flows for every transaction depending on the actual state of the contract. So let's say that you have an if state variable equals equals one. Yeah. So it's going to depend on the state, which is a natural problem even for production applications. Because sometimes if your contract is being used like a lot and you may run into the situation where a gas estimation is not correct for the time where your transaction gets mined, like you may estimate the gas do this dry run of the transaction and then the state of the contract changes before your transaction gets mined because of another transaction getting mined before it. And that can be a real problem.
01:37:03.832 - 01:37:19.390, Speaker C: So what you normally do is multiply the gas estimation by like 10% more or something like that. But most libraries, like Bidler or other frameworks already do that for you.
01:37:24.000 - 01:37:29.310, Speaker E: Sufficient, but the gas price wouldn't be high enough.
01:37:31.860 - 01:38:09.660, Speaker C: You may wait for a very long time. Yeah. So one of the reasons to use a simulated testing network is that you can mine transactions immediately. So whenever EBM receives a transaction, it mines a new block. So you don't have to wait forever for your test to run. You could actually run them against even Mainet if you are willing to spend some money on them. But that's going to be super slow because you need to wait for transactions to be mined.
01:38:09.660 - 01:39:21.576, Speaker C: Okay, so we are running out of time. I invite you to visit the repository if you haven't and read through its README. It has sections explaining all of these things and more. Even things like setting up your Visual Studio code, proper explanation of Ethers, or if you don't know how to work with Mokanchai. There's also I know five minutes tutorial that's just like an actual test with lots of explanations on what all these things are, why describe it's there, why it's there without being imported, and things like that. And then after the Ethers explanation you are going to find other things installed like Waffle's Chi Matchers. This is a library that adds very handy assertion functions to Chi.
01:39:21.576 - 01:40:19.332, Speaker C: So you can test for things like revert reasons, or you can also test that a given event is emitted in your transaction or its parents and things like that. There's more info on how to debug the transactions. It's pretty much the same that I showed, but with more details. Some explanation on how to deploy your contacts. Because so far we've been deploying them to Wheeler EBM, but that network is both automatically created and destroyed. So this won't be useful for things like testing your front end or actually deploying it, but there's a script that will help you deploy it to a real network. There is a bunch of networks to try your smart contacts on.
01:40:19.332 - 01:40:57.570, Speaker C: Vidler VM can also be used like persistently. You just have to run NPX vidler node. This is going to start a JSON RPC server that every transactional library knows how to use, every wallet and library knows how to use. But there's also a bunch of testing networks that are live and actually maintained and more realistic or similar to mainnet. Those are called Robsten Coban rinkavi and Goldie. You can use pretty much any of these. All of them work.
01:40:57.570 - 01:41:39.548, Speaker C: And here there's an explanation on how to use them. And finally there's like a super simple front end bit with react. It doesn't have much functionality, you just kind of get an overview of the state of the poll and very basic voting functionality. But it already has things like connecting your contract to the network, setting up Ethers and things like that. That can be very cumbersome to get right the first time. So take a look at it. I think all of it, it's contained in a single file.
01:41:39.548 - 01:42:03.672, Speaker C: It has explanation for all the things that it does and that's pretty much it. Enjoy the hackathon. Join the discord server. We are going to be there. There's a vidler channel. You can make any question that you want about Biddler in general or about this tutorial. So feel free to join and ask wherever you want.
01:42:03.672 - 01:42:04.150, Speaker C: Thank you.
