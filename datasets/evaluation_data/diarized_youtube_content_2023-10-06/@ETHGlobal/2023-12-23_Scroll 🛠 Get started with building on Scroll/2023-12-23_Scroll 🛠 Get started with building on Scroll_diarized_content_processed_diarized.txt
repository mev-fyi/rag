00:00:07.210 - 00:00:41.542, Speaker A: Hello, thank you, everyone, for joining the scroll workshop. Just as a heads up, this is kind of a beginner level workshop for really introducing the idea of what a layer two is, what a roll up is, and how to really get started with scroll deploying contracts and hopefully just better understand understanding what Ethereum needs to do to scale, how to scale securely. I'm Daniel Helm. I lead the developer relations team at scroll if you want to find me on any socials. Anything else, DG helm down here in the corner. So, agenda. We're going to talk about Ethereum having a scaling problem.
00:00:41.542 - 00:01:15.326, Speaker A: We're going to talk about what scroll is building to kind of solve that. We're going to talk about deploying your contracts on scroll and then of course, prizes additional info relative to the hackathon. But I'm going to leave this up here for a while. I will show it again at the end of the talk. It is a QR code to get you in a telegram group for hackers. We also have a faucet bot in here, so you are able to show up, say, drop your address and you'll get some scroll sepolia eth to get started hacking, which is the first step. All right, so let's talk about Skrull.
00:01:15.326 - 00:01:57.634, Speaker A: If you show up on the Skrull website, you've never heard of us, you're going to see that we're seamlessly extending Ethereum's capabilities with zero knowledge, tech and EVM compatibility. An l two network, devs, devs, Skirl Bridge, a lot of jargon, right? You see this, you don't understand what some of these things mean. It might make you feel a little bit like this. But if you walk away with one piece of knowledge from today's talk is that for users and devs, scroll is pretty much Ethereum, right? Like the experience. Pretty much Ethereum. And I'm going to show you quickly what that looks like. We have a clone here of uniswap, and we can see that I'm logged in with my wallet and I can get in here and grab some.
00:01:57.634 - 00:02:24.030, Speaker A: Go swap that for Ethereum. See what my best price is here. Great. We're going to swap this thing. And if you've used uniswap before, this should be a similar experience, right? Your metamask pops up, you confirm the transaction, you've done your swap, and instead of waiting 12 seconds for an Ethereum block, you wait 3 seconds for a scroll block. So that's the idea. What it looks like to use the ZKe EVM.
00:02:24.030 - 00:02:55.054, Speaker A: Let's get into talking about what it actually is, though, why we're building it. And yeah, so anything you're using on scroll, like all these projects that are deployed either to our testnet or our main net, which came out about a month and a half, two months ago, should all have this similar level of experience for you. But let's talk about blockchain scalability. We are all here because of the beautiful promise of Ethereum. We are a platform for decentralized application. It's a single network where you share code and data. You create all these new possibilities.
00:02:55.054 - 00:03:30.014, Speaker A: It's open to all and anyone can join in. Just not too many people at once, right? If too many people try to use scroll at the same time, you see a situation like this, you go to mint your NFT, swap your token, and it asks you to pay $132 in gas fees, right? This is a mess. This is not accessible. This is not the Ethereum that we want. What's happening here? Well, if you're unfamiliar, we have this idea of an Ethereum block, and what we're doing is we're sending a transaction and we're asking the network to do some work. And that's measured in gas. Each block can only do so much of this work.
00:03:30.014 - 00:03:58.934, Speaker A: And so the block, or the person creating the block is going to pick those transactions that are going to pay them the most to do that work. We are paying the highest gas price. This is the idea of block space. And once that block space fills up, once a block is full, it becomes an auction and the price goes up, right? A lot of hand waving here, but that's the general sense. Okay, so we have a problem. We're engineers. We say, let's make a better system then, right? So let's put our protocol designer hats on.
00:03:58.934 - 00:05:12.110, Speaker A: I think the first thing anyone wants to say in this situation, yeah, this is easy to solve. We just make the chain do more work, right? Just make Ethereum do more work. Well, let's remember how Ethereum works, right? We have this decentralized network, and we can imagine each one of these dots as nodes in that network, right? As a transaction comes through, every single one of these block or one of these nodes has to do the work of that block, right? They have to verify what a transaction does and redo that work on the network. So what we're actually saying when we say, make the chain do more work is make every single node do more work, right? And for some nodes, supercomputers with ten gigabit Ethernet cables, they're going to say, yeah, I can do more work, this is no big deal. But for maybe resource constrained smaller pcs, people running things at home, they're going to get priced out, resourced out, if we just try to keep cranking up the constraints or the requirements it takes to run a node. And what happens is our happy, healthy graph that looks like this gets a lot of people priced out, which makes it more vulnerable to bad actors, right? We don't want that. What we're doing there is we are sacrificing decentralization.
00:05:12.110 - 00:05:59.546, Speaker A: And this is one aspect of what's labeled as the scalability trilemma. The idea of that is that when you design a blockchain, you get to pick two of three things, scalability, security, decentralization. Right? And so in this situation, we've cranked up the requirements for our nodes, and this is typical of high TPS chains. We have sacrificed decentralization for scalability and we've maintained some level of security. So solution two of our protocol designer, right? Okay, we can't make the chain do more work, but what if we just made a new network, right? So now we have our graph and we just say, like, all right, let's cut a line down the middle. We'll take all the nodes and validators from one network, we'll still call it Ethereum, and then we'll make another one, Ethereum prime. And so now we have two networks.
00:05:59.546 - 00:06:41.018, Speaker A: We've doubled up the amount of work that we can do without increasing the network requirements. But there's an issue here too. Right now we have half as many validators putting up stake, half as much security there. Not to mention we have to figure out how to bridge the gap of this black line, which is a nontrivial problem. And this is the idea of maybe the multichain ecosystems that sacrifice on security, they maintain their decentralization and they scale this way, but it's still not ideal. So part two of this story is when we come in and save the day with l two s and roll ups. As we mentioned, ethereum is this network of nodes doing a bunch of work.
00:06:41.018 - 00:07:05.070, Speaker A: And we're going to symbolize that as a big block here. So I have very mature graphics. Thank you. We can think about this work as the block and we can break it into subwork, right? So maybe this top block up here is minting an NFT. Maybe this is swapping our token. These are things that smart contracts do on Ethereum right? Now. Thought experiment.
00:07:05.070 - 00:07:57.422, Speaker A: What if we just dedicated a piece of the work that Ethereum was doing. And we just dedicated that to making sure that a different network was not breaking its rules, that something off chain was not lying, cheating or stealing, and a smart contract was able to consistently verify that. Well, this is the idea of securing an off chain protocol using Ethereum. So a layer two exists as its own off chain protocol, using a layer one as an important piece of its architecture, and we say that it is deployed on top of it. Now, roll ups specifically use l ones to have certain security guarantees here from Ethereum. Right? We have to really constrain some of these things. And so we have things like ordering data availability, censorship, resistance, state transition, correctness.
00:07:57.422 - 00:08:56.486, Speaker A: A roll up has to inherit all of these things to be truly secured and know that we're not lying, cheating, and stealing as a protocol and roll ups on Ethereum, we say that they inherit the security of Ethereum. The idea here is that when you use a roll up like scroll, there are no additional trust assumptions beyond the trust assumptions you make of. And this is a little bit of a bastardization of the trilemma here, but we can imagine this as Ethereum really locking down the security side of this triangle. And so we can say now, okay, we've got security locked down, let's make a new network, an off chain protocol. Let's crank up the constraints of it, the resources of it. We'll make the chain do more work, and through that we can become more scalable while still building on top of traditional chains that are highly secure and highly decentralized. And this is my wonderful graphics about l ones and l two s.
00:08:56.486 - 00:09:32.526, Speaker A: There are a lot of l two s in the marketplace. You've probably heard of a lot of these, and there they are listed on a wonderful site called L two beat. But coming back to our protocol design game, right, we've said, okay, we're going to make a roll up. This is good, but the roll up could do anything, right? We're just using Ethereum for the security, but our roll up could do whatever we want. Well, let's look at maybe Scroll's biases here. We look at the situation. We say Ethereum already has this incredible ecosystem, right? You're here part of the ecosystem, and it also has all these tech parts of its ecosystem.
00:09:32.526 - 00:10:30.002, Speaker A: It's got great tools, educational resources, wonderful users and communities, and smart contracts that are ready to deploy. So we're already inheriting Ethereum's security. Why not also just inherit all of this from Ethereum? And so as a choice, we can say wherever we can, let's just behave exactly like Ethereum's virtual machine, that thing that does the work on the network so developers don't have to change their mindsets, learn new gotchas or anything else. And that is kind of the basis and the idea of scroll, thinking about how to scale Ethereum in a reliable way without being a bad developer experience. So coming back to this model, we can see that still we have this idea of Ethereum doing work, making sure that a new protocol is not breaking its rules. Let's look at different ways you can do that. So on the bottom here, we have what we call optimistic roll ups.
00:10:30.002 - 00:11:12.098, Speaker A: And what they do is they say, here's all the transactions that came into my chain, ethereum, layer one. Let me show them to you, and I'll just show them to you. We'll sit and wait for seven days and see if anyone raises their hand and says, no, this is not how things are supposed to work. We call this fraud proofs, and it's this, like, economic incentive, this game, where you expect there to be one honest actor that's going to say, no. The chain over here, the off chain protocol, is lying, cheating, or stealing. Now, skirl takes a different approach. Right? What we do is we put all that data on chain, and for something that we call a ZK roll up, right? We are not an optimistic roll up.
00:11:12.098 - 00:11:31.714, Speaker A: We're a ZK roll up. And unfortunately, this means I now have to talk about zero knowledge. So let's get into part 30 knowledge proof. All right, is everyone still with me? We're going fast. All right, zero knowledge proofs. Here we go. Let's do another thought experiment.
00:11:31.714 - 00:12:12.338, Speaker A: We've got a lot of work. We've got some input or data that we're going to put into this work. And it is a lot of work. It takes a whole host of supercomputers that we don't really trust to do this work, and it takes days. Right? Now, we can imagine we have a magic wand, and out of that work, we can have a receipt for the work, right? The receipt for the output of that work can be verified by one of these really simple computers. And that simple computer doesn't have to go back and redo all the work of the sukuver computers. It can just verify the proof cryptographically and say, no, I know, I can guarantee that all this work was done correctly.
00:12:12.338 - 00:12:49.170, Speaker A: Right. This sounds kind of magical. It sounds like you need to get in a time machine for something like this to exist. And we do. And it's back to 1991 when we had papers and constructions coming out like checking computation in poly logarithmic time. This paper has this funny little line where it says in this setup, a single reliable pc can monitor the operation of a herd of supercomputers, working with possibly extremely powerful but unreliable software and untested hardware. We do not trust the supercomputer, but we can still monitor and verify its output.
00:12:49.170 - 00:13:40.290, Speaker A: Okay, so back to our imagination scene here. Let's kind of like specify what this work could be. What if the work being done was the EVM, the Ethereum virtual machine, right? And it's doing work over incoming transactions. And instead of supercomputer, we have a really powerful blockchain network called scroll, right? It's got a lot of resource requirements, but that's okay because it will output a proof and that proof won't be verified by a raspberry PI, but instead by Ethereum smart contracts, right? That little bit of work on Ethereum is able to verify all the work of a second Ethereum, doing more work than Ethereum itself using zero knowledge cryptography. And it can verify those proofs. So that is the idea of scroll. We are a ZK roll up.
00:13:40.290 - 00:14:32.674, Speaker A: And that thing on chain on Ethereum is a ZKe EVM proof verifier, right? Is sitting there constantly, about every 20 minutes getting a new set of proofs over the transactions that come in in order to secure scroll and to make scroll something that can be scaling Ethereum, I won't get too deep into the transaction lifecycle and everything else like that. If you want to talk about it, see it at the booth. But the idea here is that we can have a whole lot of blocks coming in every 3 seconds, commit a chunk of that to Ethereum, and then later on kick off gpus producing proofs. And then those can commit those to Ethereum as well. So Ethereum's got all the incoming transactions that came into scroll. It also has a proof that our state transition was done correctly. So why build on scroll for this hackathon? Well, it's got great developer experience.
00:14:32.674 - 00:15:16.270, Speaker A: We are bytecode equivalent with the EVM, which means that all your favorite tooling, all your favorite tutorials, open source contracts are good to go, right? You can copy, we have this phrase copy paste deploy that you might see around. And that's the idea. You don't have to have any hidden gotchas as you're building with scroll. It's got higher throughput, it's got lower gas fees, and your users are going to get quicker feedback because we've got three second block times relative to Ethereum's twelve second. And lastly, I think maybe this is a term that gets maligned a little bit, but I think alignment here is pretty interesting. We are here not to just scale Ethereum as a technology, but we take it seriously to also try to scale Ethereum as an ecosystem. Ethereum as a culture.
00:15:16.270 - 00:16:05.524, Speaker A: Originally Skrull, its origin story was it was built as an open source project in collaboration with the Ethereum Foundation's privacy and scaling explorations team. And so really building that out is, I think, core to our dna. So, done a lot of talking. I think we'll have plenty of time to maybe ask questions about scroll, but let's see what it looks like to deploy using scroll. So let's go to open Zeppelin's ERC 20 contract and go ahead and just copy this. You can Google search for something like this, and if you're not familiar, there's a tool called Remix that the URL is probably too small to see, but it says remix ethereum.org and it's a nice browser based way to test out smart contracts and deploy them.
00:16:05.524 - 00:16:33.592, Speaker A: Let's make a new contract here and we will call this token Sol and I will paste my ERC 20. My guess is when I go to compile this, it's going to want a newer version, I think it does. So it wants me to try out 822. But now let's see if I can compile this. There we go. It's happy enough. I've compiled my contract.
00:16:33.592 - 00:17:22.550, Speaker A: What does it look like to deploy it on scroll? Well, as long as you have your metamask set up the scroll network, you can go to injected provider metamask. It will recognize the correct network in your current account. And I can put my initial constructor amount. So let's just say that and I will deploy. Now we see we're creating the token it asks to deploy. Put in a really high gas price, but shrug, give it a few seconds here. And now we are deployed and we can see that down here I have a contract address and I can go to sepolia scrollscan.com
00:17:22.550 - 00:18:24.530, Speaker A: and check out the contract that we just deployed on Scroll 24 seconds ago. Okay, well a lot of you are not going to be using remix to deploy, so let's take a look at what this looks like using foundry, if you're interested. I think the best way to kind of get started using foundry hard hat other traditional devtools is to check out our docs at Docs Scroll IO and we have actually Quickstart links down there, but down in the developer section we have a developer, Quickstart. And here it goes through how to acquire ether, how to set up your network configurations for both Mainnet and Testnet, and then the configurations for setting up hard hat and boundary. But I'm too lazy to look at the docs. I like cheat sheets. And so instead I'm going to go to something that we put together for ETH India, which is called ethindia scroll systems.
00:18:24.530 - 00:19:05.802, Speaker A: There's also a QR code on the postcards that we have on our booth, and it tells you all about some of the things going on. There's a cheat sheet right here, and it also has wonderful information about verifying contracts and settings for things like forge, things like boundary, and things like hard hat, rather. So let's follow along with these a little bit. I think I could go to showing how to use this with Forge. I could say forge init and I'll say ETH India live demo. And I will create a new forge project here. Wonderful.
00:19:05.802 - 00:19:54.420, Speaker A: Now I will CD into that and let's open up our code here. Close out the other one. Sorry. Okay, this is very zoomed in, but when you init a new Forge project, it actually comes with a Sol file. You can put whatever you need to in there, but we'll just start with the default one. But we want to go into this foundry Toml file and modify our configuration just a little bit so that it knows about scroll and scroll sepolia and how to verify contracts using them. So I'm going to copy paste these RPC endpoints in this etherscan configuration, place it here in my foundry Toml file and save.
00:19:54.420 - 00:20:35.310, Speaker A: And so now I should be able to write forge create. We're going to compile and deploy the counter contract for our RPC URL. We just set one up for a label of scroll sepolia and that configuration file. We want to verify this on scroll scan because that's part of getting your nice little bounty. And we'll also provide a private key, I believe goes like this. And I have set in an environmental variable, so you can't get my private key like that. Oh, nice try.
00:20:35.310 - 00:21:35.180, Speaker A: Let's try it again. Okay, there we go. Now we have compiled and it's saying nothing is there. So let me go ahead and do this live demo. Fun. Okay, let me go ahead and just try one more forge init and try another one here saying rough demo. And then I can open up this again.
00:21:35.180 - 00:22:41.580, Speaker A: I want to take information in my foundry Toml file to set my configurations and just try and run that same command as before. Forge, create, counter the RPC URL. And it helps if you have a space after scroll Sepolia. Probably my issue. So now we've actually compiled it and we can see that it interacted with Etherscan. And because it's actually already seen this contract, because I've verified it before, before we even verified it, it knew what this contract was. But we could go ahead and modify it if we needed to, and it wouldn't know what it was at that point.
00:22:41.580 - 00:23:45.774, Speaker A: So now we've modified that a little bit. Let's make sure we can actually verify on Scroll Sepolia and doing its best now. So let me grab this and we will open that up back in sepolia scrollscan.com. And we can see that this contract has been verified and our modified code is viewable here. And that's it. So that is deploying on scroll should work seamlessly out of the box with all your favorite, devtooling any tutorials, demos that you're used to. So again, we have a hacker telegram group.
00:23:45.774 - 00:24:24.854, Speaker A: I'd encourage you to scan that QR code, ask for help here or in the discord. You can also get your sepolia testnet eth, your scroll sepolia testnet eth by following the example of other people for how to grab it. And again, we have that cheat sheet and not only has information on deploying and verifying, but also has information on every other kind of partner here at ETH global that is deployed on scroll sepolia. So if you want to both deploy on scroll and safe, you can use those things together by grabing the contract's addresses there. That is Ethindia scroll systems. Now for the prizes. If you are engaging with this side of things, we have two categories.
00:24:24.854 - 00:25:01.160, Speaker A: So one, I just demoed how to deploy and verify a contract on scroll that would have put me in the $7,000 prize pool for doing that work. If you are a newcomer to the space, we welcome you. Get something deployed, build something this weekend. If you are building something maybe a little bit more complex, advanced, you might want to apply for our best on scroll prize. And we will have ten $1,000 winners for folks that complete this, build something on scroll that we think is fun, innovative, weird, whatever. We really like things that people are passionate about. And we'll have ten of those winners for $1,000.
00:25:01.160 - 00:25:37.590, Speaker A: So I think that's it for me. But hopefully I left enough time for questions as well. Cool. See if I can mount, like, read lips. All right, let's get some questions. Do we have a documentation for how to integrate safe with scroll? I can't actually hear you. I heard the word documentation.
00:25:37.590 - 00:26:04.590, Speaker A: Oh, safe. Yeah, absolutely. So let me pull up that cheat sheet again. This is ethindia scroll systems. It's actually cheat sheet, but there's a link at the top of that and you can see ETH India partner integrations. We can go to safe, and you'll see that we have a site that is like a front end for safe. If you want to use that on scroll or scroll sepolia, you can check out their docs.
00:26:04.590 - 00:26:42.020, Speaker A: You can see kind of a demo using AA authkit. You have their factories, their safe core protocol, contract addresses, and their transaction service API. So I think that should be everything you need to get going there. Any other questions? Why don't you come up? It's always a good workshop when Daniel Helms at the helm. Anyone else have questions? Why don't you come here so they can hear you better? There's no questions. Anyone raise your hand. I can also come to you if you're shy and repeat the question.
00:26:42.020 - 00:26:49.420, Speaker A: Any questions? It. All right, well, let's rock and scroll. Thank you so much, everyone. Come see us at our boot.
