00:00:06.810 - 00:01:17.394, Speaker A: This presentation is powering dapps with one inch and my name is Tanner and I've been a contributor to Oneinch for about two and a half years now, working on governance teams backend, and now currently developer relations. So today we're going to talk about the three one inch swap protocols that we have, and then we're going to talk about integrating these projects, these protocols into your project. So that's going to be talking about our APIs, our documentation, some example repos, as well as integration tips to make it easier for you to do so. Brief summary about one inch we actually started at ETH Global at East New York in 2019. We didn't place very well in the actual rankings, but we still grew to become a pretty successful protocol with now almost 3 million users, over $300 billion of total volume processed through our contracts, and gave people access to over $55 billion of total available liquidity, as well as having 70% of the aggregation market share. So first we're going to talk about what it means to swap with one inch. We'll talk about our original aggregation protocol.
00:01:17.394 - 00:01:51.800, Speaker A: We will then talk about the limit order protocol and then our latest, which is one inch fusion. So today we are currently live on twelve different chains with our aggregator and our limit order protocol. And then with our latest one inch fusion, we're live on nine of those twelve chains. And we will continue to expand to more chains as there's more liquidity and more need for swapping. So first off, the one inch aggregator, this is what people who know who one inch probably knows this part.
00:01:52.490 - 00:01:55.474, Speaker B: It sources swap liquidity from all popular protocols.
00:01:55.602 - 00:02:07.226, Speaker A: It combines these protocols to optimize the swap output for the user, and then it executes all the swaps in a single transaction. So if we just take a simple example, someone who is just trying to.
00:02:07.248 - 00:02:09.402, Speaker B: Do a swap from USDC to Dai.
00:02:09.546 - 00:02:33.502, Speaker A: Today on Ethereum, they're probably going to take their USDC and just go through Uniswap. This is fine. Uniswap is a very major player in the space. It's tried and true, and people don't have to worry too much about what's going to happen on the other side. They know they can trust it. But the UI that one inch offers is very similar to Uniswap. It has the input token, the output token, and you just click one button and the transaction goes through and you get your output tokens.
00:02:33.502 - 00:03:09.086, Speaker A: So quite similar. So let's just say the same user decides, okay, I'm going to go through and send my tokens to the one inch router. Now then the one inch platform will do some complex calculations and probably end up just sending the user through Uniswap again. But they're not going to do that in all cases, especially in bigger swaps. Specifically, it might split it out into multiple different dexes in a single transaction. So it might put some of that transaction through dodo, it might convert some of the USDC into tether using curve, and then finally take that tether, put it through sushiswap and come out to Dai, and it'll do whatever it needs.
00:03:09.108 - 00:03:11.098, Speaker B: To to get the best output for the user.
00:03:11.274 - 00:03:18.814, Speaker A: Some of you might be thinking, well yeah, that's also going to increase gas costs by quite a bit, and that's true, but we factor that into our decision making process as well.
00:03:18.852 - 00:03:20.286, Speaker B: So if it takes more gas but.
00:03:20.308 - 00:03:36.978, Speaker A: It gives you more tokens to off set that, then that's still the path we're going to take. So in the case where it does just go through Uniswap, which happens a lot of the time actually through our aggregator, you might be wondering, well, if it's just going to go through Uniswap in the end, shouldn't I just be going directly to the Uniswap router?
00:03:36.994 - 00:03:38.222, Speaker B: Won't that actually save gas?
00:03:38.306 - 00:03:40.362, Speaker A: And let's just compare those head to head.
00:03:40.496 - 00:03:42.266, Speaker B: So if you do a swap through.
00:03:42.288 - 00:04:13.478, Speaker A: Uniswap with this specific token pair, it'll be about 205,000 gas. And if you do the exact same swap through one inch, which then eventually goes through Uniswap, you'll actually only spend about 175,000 gas. So even in cases where it's an extremely simple swap that just goes through Uniswap, it will actually be cheaper through us because we've optimized the logic that skips the router and goes directly to their pools. Next, let's talk about one inch limit order. So this supports makers and takers like a traditional order book.
00:04:13.644 - 00:04:15.446, Speaker B: Takers pay the gas fees for the.
00:04:15.468 - 00:04:53.214, Speaker A: Transaction, which means gasless swapping from the user's perspective. And this removes mev opportunities. And that's because you basically say this is how many tokens I want to get for my swap, and there's really no room to do anything there because if it's less tokens than what you agreed upon when you placed the order, the transaction is not going to go through. So again, UI looks very similar to a basic swap. There's just two new UI elements. One is the rate at which you actually want to swap those tokens for you can just click set to market and make it essentially a market order. Or you can go a little bit higher if you think there's an opportunity to make more money later by setting it at a higher price, and then there's also going to be the expiration time.
00:04:53.214 - 00:05:03.554, Speaker A: So how long you actually want this order to last inside of our system? We default it to some small value. You can set it to forever if you want, but sometimes people don't want trades executing six months later that they.
00:05:03.592 - 00:05:04.686, Speaker B: Totally forgot they placed.
00:05:04.718 - 00:05:32.926, Speaker A: So it's totally up to you on that kind of a diagram to show what's going on behind the scenes. When you place a limit order in our system, you, the maker, aka the user, would say, okay, I want to sell 50 USDC for 50.1 die. You will sign that transaction, essentially giving our router the permission to swap this USDC for you. And then that will go off into the one inch API. The one inch API will then feed that order to anybody who wants to listen to it.
00:05:32.948 - 00:05:34.606, Speaker B: So they have the 50 USDC for.
00:05:34.628 - 00:05:48.050, Speaker A: The 50.1 die and anybody who wants to listen for this and decide, is this an order I'm interested in? They can kind of go through that on their own time, and eventually someone will say, yes, that is something that interests me, and they will execute it from their side.
00:05:48.120 - 00:05:49.838, Speaker B: So they'll pay the gas, they'll execute.
00:05:49.854 - 00:06:18.758, Speaker A: The transaction, and you'll get the 50.1 die. Okay, on to one inch fusion. So the user submits a swap request with a signature, just like limit order. And this will kick off a dutch auction that is created for the swap that the user is trying to do. And then the resolvers will asynchronously compete to fill this order during the dutch auction. And again, users are protected from mev by design here because at each step along the way of this dutch auction.
00:06:18.854 - 00:06:20.278, Speaker B: There is a specific price at which.
00:06:20.304 - 00:06:37.266, Speaker A: The token needs to be swapped for. So there's no room for anything to be taken from the user's side during these swaps. So there were a lot of terms that were listed in that last slide, so let's kind of break them down. What is a fusion dutch auction? Or more generically, what is a dutch auction? And in a traditional auction, you start.
00:06:37.288 - 00:06:38.722, Speaker B: At a very low price, and over.
00:06:38.776 - 00:06:51.526, Speaker A: Time it goes higher and higher until eventually there's only one bidder left and that's the price that the item is sold at. In a dutch auction, the price actually starts at something quite high and it works its way down until some bidder decides, okay, this is a good enough.
00:06:51.548 - 00:06:53.058, Speaker B: Price for me to actually purchase.
00:06:53.154 - 00:07:39.350, Speaker A: So a fusion dutch auction does the same thing, but with token prices. And then also, what is a resolver? These are entities in the fusion system that are all watching these dutch auctions while they occur, and they're the ones that are actually swapping all or part of the order as a dutch auction slowly reduces the token price from their perspective. So here's a really simple diagram of what would happen in a dutch auction. The y axis is rate and the x axis is time. The top left point you see there is going to be the highest price that the token will be sold for from the user's perspective. So it'll be something slightly higher than market rate. And across the whole fusion auction, it will slowly go lower until some minimum value, ideally when resolvers are happy to fill it and find their profits in the trade.
00:07:39.350 - 00:07:46.006, Speaker A: So again, the UI is quite simple. You have the input and output tokens, you have the transaction cost, which is.
00:07:46.028 - 00:07:47.014, Speaker B: Zero, which is really cool.
00:07:47.052 - 00:08:21.662, Speaker A: It means you don't need any of the native gas token for whatever chain you're actually doing the swap on, which is going to be really good for mainstream adoption and ease of use for new users specifically. And then we have the preset, which is going to be like how long this dutch auction will actually last. I think it still defaults to three minutes, and then it will give you the estimated output as well as the minimum output of the dutch auction. So here's the UI, just kind of showing this thing actually happening. It's going to show you today in your history, there's USDC being swapped for die. It's going to show you how long the dutch auction actually has left on it. In this case, it was two minutes and 49 seconds.
00:08:21.662 - 00:08:34.690, Speaker A: And it's going to give you its estimate for what the actual return will be. In this case, it's going to be almost exactly as many tokens as you put in, because it's going from stable to stable. So again, let's look at what's going on with the diagram.
00:08:34.770 - 00:08:38.966, Speaker B: So we have the user, they say, I would like to swap 50 USDC for die.
00:08:38.998 - 00:09:05.506, Speaker A: The fusion system will estimate something around 50 die coming back to them. The user will sign that transaction and then it will go off into the one inch API. The one inch API will then start a dutch auction. It'll say that, hey, this user is trying to sell 50 USDC. We expect there to be something around 50 die coming back, and this auction will last three minutes and all of the resolvers in the system will now be monitoring this dutch auction and they'll be choosing to either fill it or.
00:09:05.528 - 00:09:07.006, Speaker B: Not fill it as it progresses.
00:09:07.118 - 00:09:17.494, Speaker A: So during most of the blocks after this auction starts, most people are going to be passing. But eventually the price will get to some point in which resolvers now are interested in filling this order, either part.
00:09:17.532 - 00:09:18.230, Speaker B: Or all of it.
00:09:18.300 - 00:09:28.586, Speaker A: And if they both try to fill the entire order, whoever is earlier in the transaction will get the priority and the other person's transaction will fail. But that's not going to happen in.
00:09:28.608 - 00:09:31.238, Speaker B: All cases because partial fills are allowed.
00:09:31.334 - 00:10:03.234, Speaker A: So if the first resolver fills only a portion of the order and the second resolver is also filling part of the order, there are many cases where they will both actually have their transactions succeed. So resolvers are competing with each other and also working together to fill the order as efficiently and fast as possible. So here is a graph of an actual swap that happened on our system for a massive amount of 3700 ether. And it's kind of a noisy graph, but the dotted line near the top, that's perfectly flat. That's the market rate at the time.
00:10:03.272 - 00:10:04.258, Speaker B: This auction was started.
00:10:04.344 - 00:10:32.258, Speaker A: And you'll see that the curved line with the dots across it is the actual rate at which the tokens were being sold for. So there are I think about 17 different points along this graph where resolvers jumped in and filled part of the auction. The first one happened around the 24 second mark and the last one happened at the four minute and 48 second mark. So by the five minute mark all 3700 ether had been swapped for USDT and all slightly above market rate. Now granted it was only like $1.
00:10:32.294 - 00:10:33.774, Speaker B: Above market rate, but that's still pretty cool.
00:10:33.812 - 00:10:43.738, Speaker A: That's a massive trade that happened all above market rate, which just wouldn't happen if you probably went through a normal pool. So you might be asking yourself, where.
00:10:43.764 - 00:10:45.054, Speaker B: Do these resolvers get their liquidity?
00:10:45.102 - 00:10:53.918, Speaker A: Like these entities, how are they actually fulfilling these swaps? And that is kind of the beauty of the system is it doesn't really matter. All that matters is that the swaps.
00:10:53.934 - 00:10:55.782, Speaker B: Are fulfilled at the specified rate.
00:10:55.836 - 00:11:15.866, Speaker A: So resolvers might be getting their liquidity from centralized exchanges. It might be through personal funds, it might just be using a Dex like one inch behind the scenes to actually do the swap. Or they might be doing something more sophisticated like cross chain swapping. Okay, so we went over the aggregator, limit, order and fusion now kind of.
00:11:15.888 - 00:11:17.018, Speaker B: At a high level.
00:11:17.184 - 00:11:22.830, Speaker A: Now let's ask the question, how do we actually use these in my project and that's where Dev portal comes in.
00:11:22.980 - 00:11:25.434, Speaker B: So Dev portal is the official hub.
00:11:25.482 - 00:11:57.510, Speaker A: For integrating one inch into all of your projects. It provides things like the API keys to access our APIs documentation for the swap APIs, as well as many more APIs which we'll talk about briefly toward the end. It'll also give you examples as to how to do this. And yeah, so the link is portal Oneinch dev. That's where you'll actually go to see all these things. And don't worry about writing any links down throughout this presentation. At the very end there will be a link to everything we talk about today, so don't worry about catching anything mid presentation.
00:11:57.510 - 00:12:14.714, Speaker A: So if you go to the dev portal website, you're going to see a homepage, you log in with Google or GitHub. From there you're going to actually just choose what application name you want to give your project. It can be anything really, it's just like an alias. In this case I used test and then after that you'll hit your dashboard.
00:12:14.762 - 00:12:18.974, Speaker B: Which will have your API access key. It'll have your requests as well as.
00:12:19.012 - 00:12:21.886, Speaker A: The rate of the requests that are going through. And if you go to the top.
00:12:21.908 - 00:12:23.038, Speaker B: There'Ll be a docs page where you.
00:12:23.044 - 00:12:44.818, Speaker A: Can actually see all of the information about the various APIs. So we click on docs we see on the left now there's a bunch of different APIs on the left side. To keep things simple, we'll just jump in and we'll click on this swap API. That'll give us a drop down with a couple other links and we will go straight to the swagger documentation. So we'll go down, click on Swagger and we'll see all the different endpoints.
00:12:44.834 - 00:12:46.840, Speaker B: That this API has to offer.
00:12:47.210 - 00:12:54.874, Speaker A: So we'll click on the top one, find the best quote to swap with one inch router and that will bring us to an interactive documentation page based.
00:12:54.912 - 00:12:56.710, Speaker B: Off of our swagger files.
00:12:56.870 - 00:13:17.106, Speaker A: And so the middle is going to be what chain you want to be on as well as all the query parameters to influence the output of the swap. And on the right will be code snippets for whatever language you actually want to do these calls in. So there's code snippets for node, Python, curl and go currently. So let's go ahead and just fill out some of these parameters. We're going to fill in USDC and.
00:13:17.128 - 00:13:18.514, Speaker B: Die as well as a rate of.
00:13:18.552 - 00:14:08.178, Speaker A: 100 USDC and we'll just click on the try it button right inside of the UI and we get our response lots of decimals because it's die, but that's roughly 100 die coming out on the other side. Now also something that's really cool is as you fill out these query parameters, the code snippets update themselves too. So in this case we now have a fully functioning call to our rest API using node js. So I'm just going to take that code snippet and I'm going to copy it into webstorm over here so we can run it locally, copy and paste that here, and then add one little bit of extra code to actually make the function call itself. And when we run that we'll see at the bottom it's this exact same output, well, almost the exact same output, but we see that the function works. Not much needed on our side besides actually writing the code to call it. Now you can do this with all.
00:14:08.184 - 00:14:09.378, Speaker B: Of our APIs, just go through the.
00:14:09.384 - 00:14:40.090, Speaker A: Documentation, use the rest endpoints, fill out the queries. But fusion is pretty complex, so we made an SDK on top of it to abstract that by one layer. So here's the link to the fusion SDK, and it is written in typescript and it simplifies interactions. Like I just mentioned. If you go to that link and you check out the readme, there will be examples of how to use the various function calls and try to make it as simple as possible for you there. And we additionally have an actual example.
00:14:40.160 - 00:14:41.574, Speaker B: Repo that uses the SDK.
00:14:41.622 - 00:15:25.226, Speaker A: So if you're using the SDK and it kind of is causing some struggles, there's actually one that we made that just writes a concrete swap from token a to token b, and you can check it out that way. So this is the link to that one, like I just mentioned, it's a simplified version of a use case for the Fusion SDK. And again, this is probably best used as a reference because it's hard coded everything. So it's not really meant to just be parameterized, just take a look at it, copy it if you need to, or just use it as a reference while you're using the Fusion SDK. Some important notes about the one inch API requests themselves, which can hang people up, is if you're using our aggregator, you can't do it exclusively within a smart contract call. You actually always need to be making.
00:15:25.248 - 00:15:28.682, Speaker B: A rest call to our API first to get the call data.
00:15:28.816 - 00:15:37.166, Speaker A: And the reason for that is the way our aggregator works is it's doing a lot of off chain computations, like actually a pretty insane amount of off chain computations because it needs to look.
00:15:37.188 - 00:15:38.830, Speaker B: At all liquidity sources that we track.
00:15:38.900 - 00:15:45.214, Speaker A: On the chain and then it needs to use your specific input amount to find the correct output amount. So all of this obviously can't be done on chain.
00:15:45.262 - 00:15:46.546, Speaker B: So this is a step that is.
00:15:46.568 - 00:16:02.854, Speaker A: Required no matter what kind of swap you're doing through our platform on the aggregator. So kind of a diagram to kind of show that happening. Let's say you have some node JS backend that's trying to do some sort of scripted swap behind the scenes and you have your smart contract and somewhere inside of your smart contract you want to make a call to the one.
00:16:02.892 - 00:16:04.642, Speaker B: Inch router to do a swap.
00:16:04.706 - 00:16:11.146, Speaker A: And it looks something along the flow like this. This will fail or you probably won't even get this far, but visually this.
00:16:11.168 - 00:16:12.538, Speaker B: Is what the failure would look like.
00:16:12.624 - 00:16:49.510, Speaker A: What you actually want to do is your back end needs to make a call first to the one inch API with the token input, token output and the amount that will get you the call data you need. And then you can pass that into your smart contract which will eventually make the call to the one inch router. Complexities also increase by one step. If you're going to be doing things from your UI, these need to go through a proxy. If you try to do it without a proxy, you're going to run into content security policy issues as well as cores issues. So this means using something like lambda for your proxy or even a simple node Js server that you just run locally next to your project. While you're trying to do a proof of concept.
00:16:49.510 - 00:17:01.254, Speaker A: We'll reference a simple node JS program that I wrote to make that easy as well. So let's say you have some front end. You try to make your first request to the one inch API to get the call data for your swap and.
00:17:01.292 - 00:17:04.054, Speaker B: This is where that failure would occur. So what you actually need to do.
00:17:04.092 - 00:17:05.734, Speaker A: Is have your front end first call.
00:17:05.772 - 00:17:07.290, Speaker B: Out to a proxy layer.
00:17:07.370 - 00:17:22.126, Speaker A: That proxy layer will then make the call to the one inch API and then you can send that information into your smart contracts. Here's the link to the simple proxy that will help you just kind of proof of concept, easy to get through.
00:17:22.228 - 00:17:23.698, Speaker B: All you do is just pass it.
00:17:23.784 - 00:17:53.846, Speaker A: The endpoint that you're trying to talk to and it will do the rest of the work behind the scenes. Simple proxy and then again, this one also has a very simple readme. It's really hard to mess up. So don't be scared, just jump in and give it a try. And then lastly, the dev portal has a lot more access to APIs than just our swapping platform. We have things like spot price information token information balances API. We just launched our portfolio API as well.
00:17:53.868 - 00:17:55.286, Speaker B: So there's a lot more there that.
00:17:55.308 - 00:17:58.426, Speaker A: Can help you a lot in your project X to just simplify the bootstrapping.
00:17:58.458 - 00:18:00.638, Speaker B: Process so you don't have to do things yourself or you don't have to.
00:18:00.644 - 00:18:03.870, Speaker A: Jump around and use a lot of third party providers that all come together to make your project.
00:18:03.940 - 00:18:05.166, Speaker B: So Dev Portal is a great place.
00:18:05.188 - 00:18:18.494, Speaker A: To start and then it also gives you great access to a really powerful aggregator in the system or swapping tool too. So yeah, that's everything for me. Thank you guys. And here is the link QR code that will give you links to everything.
00:18:18.532 - 00:18:19.262, Speaker B: I talked about today.
00:18:19.316 - 00:18:34.180, Speaker A: So that means dev portal fusion SDK, an example repo using the fusion SDK and then a really simple basic local proxy. So use these to build whatever you're going to build now or during the hackathon. And yeah, come by our booth if you guys have questions and we'll help you with any technical questions that you have.
