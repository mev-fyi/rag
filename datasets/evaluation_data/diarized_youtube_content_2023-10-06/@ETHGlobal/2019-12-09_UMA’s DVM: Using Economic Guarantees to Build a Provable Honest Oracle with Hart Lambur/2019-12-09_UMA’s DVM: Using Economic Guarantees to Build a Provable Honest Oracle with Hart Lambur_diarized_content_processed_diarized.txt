00:00:00.410 - 00:00:36.246, Speaker A: All right, we're good to go. So, first of all, that thing Austin did was really, really cool. Who here was in Joey's talk on Oracles? Like an hour a little bit ago? Okay, so that'll give a little context for what we're talking about. We're going to go into this concept of, like, economic guarantees for Oracles and why that matters. And important is important specifically for applications. I'm Hart Lambert. Our project is, uma or universal market access.
00:00:36.246 - 00:01:18.514, Speaker A: So start off by just giving you guys like, 2 seconds of context for the problems we're trying to solve. So the underlying mission here is really all about universal market access. We really believe that financial risk and financial products should be borderless permissionless uncensorable, and that financial risk and financial products should move across the globe, much like information does today. And so the way we're going about doing that is really two interrelated components. We kind of do two things that tie together. The first are what we're calling self enforcing financial contract templates. These are design patterns for how to create financial products.
00:01:18.514 - 00:02:17.590, Speaker A: An example of that is synthetic tokens. So a synthetic token would be like an ERC 20 token that can track anything with a price feed. My colleague Regina did a great workshop on that last night, and you guys can come talk to us about it more. But separate to those financial contract templates, we also have a design for an Oracle that powers those templates and gets real world data into them. And what we want to talk about today is really this concept of putting an economic guarantee around that Oracle so we can prove in a sense that it's decentralized and cannot be corrupted profitably. So a lot of what I'll kind of start out with here and please do interrupt me, but I want to start out with just the motivation about why this concept of economic guarantees is important or matters in the DeFi space. And it just starts out with this idea that we're working in this ecosystem where we have the potential to come up with all this really useful financial innovation.
00:02:17.590 - 00:03:17.062, Speaker A: But it won't matter for shit if the products that we build have payouts that can get manipulated. If people can distort these systems, it just doesn't matter in the end. And our big starting premise here is that any on chain Oracle, anything in this permissionless, pseudo anonymous world, can be corrupted. So it's actually useful to go back and be like, okay, why is this not a problem in the real world, in the fiat world? And that's because we have this really useful concept of laws against fraud and manipulation and bribery and all this other kind of stuff. So if I go and try to bribe a contract, I go to jail. And this toy example we'll use for a lot of our talking, we got Alice and Bob here, and let's just suppose that they enter into a bet. It's a million dollar bet where they both deposit 500 grand and this bet is going to pay out according to an external reference.
00:03:17.062 - 00:04:02.130, Speaker A: The external reference here is what we're calling our Oracle turns out, right? Like if Bob could go and bribe this Oracle to say that he's right regardless of whether he's right or wrong, and in that case he can steal Alice's 500 grand. But of course if Bob does this in the fiat world, he goes to jail. It's as simple as that. So his costs of doing so are really very high. But in the blockchain world we don't have this concept of fraud. It's totally okay for us to actually hack the system and so Bob can go ahead and bribe this Oracle and it's completely okay. So this becomes a really big problem at scale.
00:04:02.130 - 00:05:12.000, Speaker A: If you take this example of Bob and Alice having this $1 million contract where Bob could make 500 grand if he corrupts the Oracle, you can imagine where Bob just scales that up and he just keeps entering into these contracts and now he's got a two and a half million dollar incentive. If he enters into five contracts, he's got now a two and a half million dollar incentive to go and bribe the Oracle and he could keep scaling this with as many contracts as he can enter into. So there's a large, large incentive here for Bob to break or hack the system. And ultimately this is our whole concept of why economic guarantees matter for these on chain Oracles. All right, so to state this a bit more formally, in this permissionless blockchain like Ethereum, private economic incentives end up being the only tool we have to incentivize behavior. We don't have fiat world laws, we can't send people to jail for bribery. So we need to build an Oracle system such that DeFi contracts can prove there is no profitable way, there is no economic incentive to corrupt this system.
00:05:12.000 - 00:05:53.498, Speaker A: And we really look at this as like it's useful to think about the extreme case is if we're going to have trillions of dollars of value in decentralized finance on Ethereum, we need to solve this problem within the DeFi context of how we're going to keep these systems secure. Okay, so that's kind of the motivation and context for how we're framing the problem. And actually it's important to even go back to kind of what Joey was talking about earlier. We are looking at this problem specifically within the DeFi context. This isn't like a generalized Oracle problem. We're not answering necessarily how much rain there is or stuff like that. This is really related to financial applications.
00:05:53.498 - 00:06:28.070, Speaker A: We can go into more on that later. So let's formally define this problem. We define this concept of this cost of corruption, profit from corruption framework. And so we define our cost of corruption as the minimum bribe you need to pay to corrupt the Oracle. So if I could pay a million bucks to corrupt this Oracle system. That's my cost of corruption. Separately, there is this concept of a profit of corruption, which is the configuration of the universe where I could extract the most profit if I were to corrupt the Oracle.
00:06:28.070 - 00:07:32.554, Speaker A: And then it follows, right, that what we're really looking to do here, to create a system where there's no economic incentive to break this Oracle. We want to build a system where the cost of corruption is always greater than our profit from corruption, this inequality right here. So just to kind of get our semantics right, in this toy example of this million dollar contract between Bob and Alice, the profit from corruption would be how much you could steal out of the contract. If Bob and Alice both put in 500 grand, the most they could steal would be this 500 grand number. Separately, our cost of corruption is whatever the minimum bribe we'd have to pay to corrupt this Oracle system. So cool, we'll get into a little bit of math, but the high level outline of how we're going to tackle this problem is just to chunk it up and break it down into the three steps we really need to do to prove that inequality. So let's create a system to measure this cost of corruption.
00:07:32.554 - 00:08:14.940, Speaker A: Let's create a system, measure the profit from corruption, and let's then define a mechanism to keep this inequality in check. So going into a few more sentences of detail on those three steps and how they work, and then we're going to dive deeper on all of them. Our core Oracle design is it is a shelling point style voting system. Joey mentioned shelling point styles a bit ago. It's a shelling point style voting system, but where there is a voting right. So voters get asked to vote on outcomes. Their votes are weighted by their voting stake, by how many vote tokens they have.
00:08:14.940 - 00:09:03.738, Speaker A: These vote tokens are freely tradable. The token holders are paid a reward for voting correctly and they're charged a penalty if they don't vote or don't vote correctly. The theory behind this is it looks a lot like 51% attack in proof of work. As long as 51% of voters are honest, they will vote honestly and the system will resolve truthfully. Cool. Second point, how do we measure the total value we're securing the total profit from corruption? Well, very simply, we can do this analysis pretty easily on any individual contract that goes back. And if we look at Bob and Alice's contract, we can figure out how much money could get stolen if somebody were to corrupt that system.
00:09:03.738 - 00:10:28.550, Speaker A: So what we're going to do is we're going to design an infrastructure where all contracts that are secured by this Oracle report their own individual profit from corruption number. And we can do a worst case analysis by summing all those values together. The last point is probably the most interesting thing, which is then how we go about maintaining this inequality, where we keep the costs of corrupting the system greater than the total profit you could make. And we do this with what we're calling a variable fee policy. And the theory the thinking is, if the cost of corruption is much greater than our proffered corruption, if that inequality is really very true or there's a big gap there, we're safe, our system is secure, and we don't have to do anything. But as the cost of corruption approaches the floor, as it looks like that inequality is getting threatened, we levy an increasing fee on the users of the system, on the contracts that are using the system, and we use that fee to buy and burn the voting tokens to support the floor. And because we do this programmatically, we have this very nice feedback loop where we maintain our floor price based off this credible commitment to tax the users of the system with this variable fee to enforce this floor.
00:10:28.550 - 00:11:17.270, Speaker A: It's probably the coolest, most interesting aspect of what we're doing, and we'll go into more detail on that in a couple of slides. Okay, so the math is pretty simple. We don't need to go into too much detail on it. But I just want to give some math on how we measure, actually measure our cost of corruption. So simply because these voting rights are freely tradable, and because in order to control the Oracle, you need to control 51% of the participating supply, we can actually use the market use wherever these voting rights are trading in the free market to calculate the cost it would take to corrupt the system. So here our math. We have this added parameter ada, which is just the percentage of non participating tokens because we can't assume all voters will participate.
00:11:17.270 - 00:12:40.560, Speaker A: But for simplicity, if you pretend that that's zero, that everybody participates, effectively, the cost of corruption is whatever it takes to buy or control half of the voting supply. Um, separately on our profit from corruption. The key thinking here is just what I sort of detailed earlier, where for any individual contract, it's relatively trivial for us to look at an individual contract and be like, okay, if I could control the Oracle inputs to this contract, here's how much money I can steal. So the way the system is designed is all contracts using the Oracle implement an interface where they report that profit from corruption back to the system as a whole. And then we are able to do a worst case analysis by summing that value across all contracts in the system. There are some interesting questions here which we time to get into, of course, man, where we can get into how we prevent unauthorized access to the system or what's commonly called parasitic usage, but we'll see if we have time for that. Okay, so if you take the two results from these last two slides our cost of corruption and our profit of corruption and we plug them into the inequality and move things around.
00:12:40.560 - 00:13:30.910, Speaker A: We can actually define like a floor price in our token, in the voting token that needs to be maintained for the system to be secure. And again, if you kind of take the ada parameter of non participation and for simplicity you say everyone's participating so it goes to zero. It means that we need the market cap of our voting token supply to be equal to twice the value it's securing. Simply put, let's say we're securing $50 million of value in the system. It needs to cost more than $50 million to buy 51% of the voting tokens or it needs to cost $100 million. The market cap of the voting token needs to be $100 million to secure the $50 million. And that's actually like the kind of simpleish math around this idea of an economic guarantee.
00:13:30.910 - 00:14:31.122, Speaker A: In our white paper, which we'll talk about at the end, we add in a concept of like a safe floor that's a little bit above the absolute floor to put in a bit of buffer. So if you do read the white paper and you're wondering what the difference is, that's why that Tsafe number exists. So now it goes into kind of the okay, wait, you guys say you're going to maintain this floor. How do you actually go about doing that? And it all stems from the fact that Ethereum and blockchains let us immutably program logic that will absolutely run. We credibly commit to what is effectively a taxation policy or a fee policy here. And so what we're able to do is every voting period, basically every cycle of the system, which we're parameterizing to be like roughly a day we run through this logic where we calculate what price, what floor price we're trying to maintain for our token. We observe and measure that floor price.
00:14:31.122 - 00:15:32.230, Speaker A: And if that floor price is below, if the if the current price is below the level that we need to maintain, we levy fees on the contracts using the system. We take that fee revenue, we buy and burn the voting token to support the fee and we repeat. And the thing that's kind of super fascinating about this is because it's all immutably programmed in the logic of our system, it also means third party speculators have an incentive to come in here and actually do this work for us. So a third party speculator, when they see the voting token approaching the floor, they have an asymmetric risk reward trade where if they were to buy this voting token at the floor, they know they can sell it to the buy and burn mechanism but they have unlimited upside. So we got to see how this all works in practice. But in theory there should be a strong incentive for third party speculators to actually enforce the floor for us based on the logic that's Immutably written in our system. Yeah.
00:15:32.300 - 00:15:36.738, Speaker B: Are you going to go into more detail on how this buyback actually occurs?
00:15:36.914 - 00:16:24.210, Speaker A: That's a great question. So what is in the code we've written and we'll get in later, like kind of where we are in the status of this thing? In the code we've written, we are programmatically collecting the fees. How those fees are being spent. We have not written programmatically into the system yet because the kind of DeFi and where you source liquidity has been changing so rapidly. You could imagine a number of options for how we would programmatically do this once the fees are collected. How do we actually do that buy and burn? Do we do an auction? Do we buy them on something like uniswap? There's a series of other ways we could do it. The simplest, most centralized way to start is that you entrust a foundation so the foundation doesn't get to choose how much fees they collect.
00:16:24.210 - 00:16:42.266, Speaker A: But once the fees are collected, perhaps you can entrust a foundation to actually go and execute that buyback on your behalf. That might be where we start, but I think very quickly we'll get into using uniswap or an auction mechanism, an on chain auction mechanism to do this buy and burn. Can I ask another question? Yeah.
00:16:42.368 - 00:17:10.260, Speaker B: Okay, so I mean, imagine an attacker in anticipation, buys up a bunch of tokens and then triggers this mechanism that says, oh, we need to buy and burn these tokens. But since he owns such a substantial fraction of all the tokens, he simply declines to participate in the auction that buys back, thus kind of jacking up the price. So you can almost kind of like arbitrage buy them up, wait for the auction to take them up really high and sell them back at a profit. Is that possible?
00:17:10.570 - 00:17:36.206, Speaker A: I'd probably want to talk to you more offline on that. Where my mind goes on that is that if an attacker comes and buys up a bunch of tokens, he's going to push the price up himself. So I'd have to think we think through the scenarios of where that yeah, exactly. So it'd be a fun thing to think through. Of course.
00:17:36.308 - 00:17:51.330, Speaker B: Okay, so getting back to this fee thing. So suppose the system decides that, okay, we're getting too close to the safety, we need to collect more fees. Now suppose I'm just a normal user who's participating in this contract. Am I just going to get some notice at some random time that, oh, you need to pay more fees?
00:17:54.870 - 00:18:30.442, Speaker A: Yeah, I guess there's video here too. The question is like, is the user experience for fees? How does that user experience look? Right? And so there's a bunch of implementation kind of decisions here about how you could go about doing this. Remember that the types of contracts that we think this system is securing are usually over collateralized. So if you do charge fees, you're taking it out of their excess margin, their excess collateralization. So because of that, the experience should be kind of like not costly or not. It shouldn't be that bad. It shouldn't impose action on the user.
00:18:30.442 - 00:19:14.080, Speaker A: You're right, though. But there's sort of edge cases that need to be considered more fully. If you were to impose an action on a user and then you push them below their collateralization threshold, that'd be a bad experience. So I think there's also other designs where the fees can be collected kind of lazily, and if contracts or participants in the system choose to not pay their fees, they may run the risk of being locked out of being able to use the Oracle system. So there's other stuff like that that could sort of solve that usability constraint. Of course. So, yeah, guys, okay, other nerdy shit with some cool math, but it's really not that hard.
00:19:14.080 - 00:20:44.220, Speaker A: What we actually have for this token mechanism is a model for what the fundamental value of our token should be. So what this is really saying, this math is saying this actually looks a lot like a discounted cash flow model that we can use to look at the fundamental value of a stock. So if you think of a low dividend paying stock like Amazon a while ago, it was something where theoretically, what Amazon should be valued at is the present discounted value of all the market's expected future dividends for that stock. Similarly, what's interesting about our design is that the market cap of the voting token should equal the expectation of all future discounted buybacks. And so what's interesting about this is that if the market expects use of the protocol to grow, the price of the voting token today should reflect that expectation of future buybacks. Which means that the voting token should trade above its floor, which means we don't have to charge any fees to any users if there is an expectation of future growth. So there is this interesting way where we are borrowing from the future, we're borrowing from the future of future usage to subsidize the cost of using the system today for early users, which is kind of interesting.
00:20:44.220 - 00:21:52.400, Speaker A: Now, to be clear, the system itself is not profit maximizing like a traditional stock or corporation is. The concept that we think this kind of works is it's this idea where the system is only trying to extract enough fees to support its own security. Once the system is secure, it charges no more. So in some ways, it's like a collective concept where the contracts using the system are opting in to be willing to pay the fees to secure the Oracle for their own collective best interest. But the system is not designed to extract any rent past what is needed to maintain its own security. All right, okay, I'll go fast here. So that's all talking about the nerdy stuff around the Oracle, but the other part about what we do is build at a lot of what we do and frankly, what we're kind of most known for is building these contract templates specifically for synthetic tokens or for other kind of financial products.
00:21:52.400 - 00:23:02.550, Speaker A: And so it's interesting to talk about what can you build with this infrastructure? And Joey earlier talked about this kind of fast versus slow Oracles. We very much look at this as actually a fairly slow Oracle. And I think the right question to ask is like when do you need an Oracle and in what context? And we just put out a research paper on something that we're calling bitdex. This is a design, a research design, a draft for decentralized BitMEX using what we're calling like priceless contracts. And really the design here is like, hey, when do we actually need an Oracle? And our thesis is that we can build most financial contracts and most financial products where we don't require an on chain price feed. We're not looking for a constant stream of prices being pushed to the chain. Rather we can really look at the Oracle as something like a dispute resolution process where if contract participants fail to agree that the terms of trade are being followed, you then call an Oracle to resolve a dispute.
00:23:02.550 - 00:23:54.642, Speaker A: And so the kind of thought process here is it's a little bit like L2 ish inspired where in the happy case, in the optimistic path, there isn't any need for an Oracle at all. All you really do is you need the Oracle to resolve disputes when the contract participants themselves fail to agree that the terms of the contract are being followed. And so there's a lot more really cool stuff we can talk about there. I'll get to the next slide, come back papers. Right, this paper here is on this paper bitdex that we put out that talks about this priceless contract concept. And then we have our Oracle paper as well. Yeah, so just quickly on development, we actually have the code for the Oracle written.
00:23:54.642 - 00:24:23.058, Speaker A: It's on our GitHub, it's on testnet. We are looking to deploy it to mainnet fairly soon. And we do have a series of financial contract templates. What we're doing here a lot is around synthetic tokens. So check out this token builder, the synthetic token builder, if you guys haven't already and check out our research paper on bitdex and priceless contracts. Cool. A bunch of us are here, you should come talk to us.
00:24:23.058 - 00:24:25.620, Speaker A: I might have a minute or two for questions.
00:24:35.030 - 00:24:35.780, Speaker B: Now.
00:24:40.390 - 00:25:13.040, Speaker A: Only it's, it's only so we did a proof of concept around one of our financial contract templates, not using our Oracle design that we deployed to mainnet in March. So we actually had someone created a token using our synthetic contract template that tracked the S and P 500 that had like a million dollars of value in it on main net and all that, that was using a centralized Oracle this Oracle design only exists on testnet right now, so we will be deploying it soon.
00:25:14.930 - 00:25:19.790, Speaker B: How long does the dispute process take? A resolve?
00:25:20.870 - 00:26:10.066, Speaker A: No, I mean, it's a parameter to the system. We're looking at making it about a day. So there's like a data commit, a data reveal, so it'll be like a two day process to get a result. So if you dispute a trade, you only pause that trade. You don't pause the system. So one way to think about the way this priceless framework design kind of works is that any disputes only affect the contract in question. It's like liquidating one CDP in the Maker system doesn't pause the entire Maker system.
00:26:10.066 - 00:26:30.650, Speaker A: You can resolve it asynchronously cost. So there's a cost of capital just like in maker, you can't liquidate. Well, actually, that's not right. I'll take that back. But in the design of the system, there's a cost of capital that you'd be required to file a dispute.
00:26:32.270 - 00:26:50.830, Speaker B: Regarding the voting, what's the biggest incentive? Liquidity and swap pool. What's the incentive to allocate capital? Voting token.
00:26:55.970 - 00:27:49.326, Speaker A: Yeah, well, so the voting, if the market is efficient, right. The voting token should actually reflect the market's expectation of future usage of the Oracle itself. There's a separate kind of angle to what you're talking about, where we need to incentivize participation, like people that we don't want speculators in this voting token, this is actually something where we really want people doing the work. And so in the system, there is an inflation parameter, effectively reward parameter that we can tune and might set at a quite high level to to only reward people that are doing the work and effectively penalize the people that are not doing the work. And I think that's perfect timing. Anything else, guys? Cool. All right.
00:27:49.326 - 00:27:50.320, Speaker A: Thank you.
