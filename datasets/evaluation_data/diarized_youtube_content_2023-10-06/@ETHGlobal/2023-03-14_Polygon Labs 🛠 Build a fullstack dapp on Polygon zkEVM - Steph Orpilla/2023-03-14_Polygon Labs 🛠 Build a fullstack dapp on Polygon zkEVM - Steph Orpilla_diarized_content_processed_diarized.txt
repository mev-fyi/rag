00:00:06.650 - 00:00:20.080, Speaker A: Hello, and welcome, everyone, to the Polygon Labs workshop. Build the full stack DAP on polygon zke EVM. Joining us today is Steph Orpilia, who will be taking us through the session. And with that, I'll pass it over to Steph to get the session started.
00:00:21.170 - 00:00:41.086, Speaker B: Hey, everyone, I'm Steph. Thanks, Rory, for that introduction. Welcome to this builder session on how to build and deploy your DAP on the Polygon ZK EVM testnet. Again. I'm steph. I'm a Devrel engineer at Polygon Labs. I'm also Oceans 404 on Twitter, and Oceans 404, I believe, on Discord.
00:00:41.086 - 00:01:19.570, Speaker B: So if you have any questions, feel free to ping me there in the sponsored channel. But I'm here to talk to you about Zkevm on Polygon, but also about all of the different prizes we're giving away for all of you builders who are scaling Ethereum this hackathon. So, we've got four prizes totaling $20,000. The first one is $5,000 for the best developer or community tool. We think one of the best ways to scale Ethereum is building tools to make the development experience easy, the Dow experience easy, and to make it easy for everybody to contribute and participate in Web Three. So that's the first prize. The second one is what I'll go into more over my presentation.
00:01:19.570 - 00:01:57.602, Speaker B: It's $5,000 for the best DAP deployed on Polygon Zke EVM, specifically our testnet in preparation for the main net launch. Next one is $5,000 for the best UX on a project using the DAP Store kit, which is a set of decentralized tools that will help you really quickly bootstrap a DAP Store, and then you can add your own UX on top of that. However you think users should be interacting, it's up to you. We can't wait to see how you get creative with that. And then last one definitely not least is $5,000 for the best use of Polygon ID, which is our decentralized identity solution. I see something in the chat. Yeah.
00:01:57.602 - 00:02:30.758, Speaker B: So, Rory just said if you have any questions, feel free to type them in the chat. Also, feel free to ping me on Discord just at me or one of my teammates, and we'll respond to you there right after the presentation. All right, so polygon zke, EVM. This is so exciting. I'm stoked about this, and lots of developers are. You can read more about our announcement and our blog post if you scan this QR code, but I'll get more into that first thing is why. So, we believe this is the best way to scale Ethereum.
00:02:30.758 - 00:03:20.570, Speaker B: So, as a developer, I love that when I'm deploying on Polygon Zkevm, it's pretty seamless. I can use all of the tools that I'm used to hard hat or just anything that I've used in the past for Ethereum or Polygon POS. It's also super fast, and we've improved security because it's an L two bait built right on top of Ethereum, and we'll be launching on main net beta really soon, and we've got a roadmap towards EVM equivalents with a type two category of Zke EVM roll up. And it's super fast. It's low cost, tons of great things about that. So the first part of Zke EVM is the ZK part. And quite honestly, I didn't understand ZK or I didn't have, like, a good conceptual understanding of it until I started learning more.
00:03:20.570 - 00:03:41.460, Speaker B: And this was one of the first things that clicked for me. So I just wanted to share it with you as well. This is a computer scientist explaining ZK. This is just the level one. So this will just be like a quick 32nd clip. But this scientist is going to prove he knows where a puffin is without showing you where exactly it is, and he's explaining it to this little girl.
00:03:42.550 - 00:04:07.530, Speaker A: Today I'm going to tell you about a thing called zero knowledge proof. So in the zero knowledge proof, there are two people there's a prover and a verifier. And I want to prove that something is true to you. But the weird thing is I want to prove to you that it's true without telling you any reasons why. I remember when I first heard about it, I was like, Wait, what? How could that possibly be right?
00:04:07.600 - 00:04:08.122, Speaker B: Yes.
00:04:08.256 - 00:04:09.830, Speaker A: So what do you see in this photo?
00:04:09.910 - 00:04:11.014, Speaker B: A wilder penguin.
00:04:11.062 - 00:04:25.298, Speaker A: Yeah. Hidden among all these penguins is a pussy. Do you want to try to look for it to see where it is? I know where it is, but I don't want to tell you. Do you believe me? You're not sure to believe me, right?
00:04:25.384 - 00:04:26.114, Speaker B: Yeah.
00:04:26.312 - 00:05:08.560, Speaker A: But what if I could prove to you that I know where the puffin is without revealing to you where it is? Let me show you. I took that photo that we showed you, and I put it behind this poster here. Why don't you go take a look through that hole? So when you look at this board, we don't know where the photo was. Trey, was the photo, like, the corner here, in which case the buffing would be all the way at this side? Or was the photo with the corner here, which case the buffing would be on the other side? So this is a really simple example of a zero knowledge proof. I convinced you that I knew where the puffin was.
00:05:09.650 - 00:05:55.630, Speaker B: Okay. So that example was just to show you that this mathematician can prove that he knows where the puffin is and prove to you that he knows that information without actually revealing it. So that's kind of like the basis of ZK, and that's how I like to think about it. So what is a zero knowledge roll up or a ZK roll up? It's using ZK proofs, like what we just saw, to prove validity of a statement without actually revealing the statement. So we know that the scientist knows where the puffin is, and he didn't have to tell the little girl exactly where it was to prove to her that he knew where it was. And then the roll up part is the second half of ZK roll ups. And that's kind of where the l two solution comes in.
00:05:55.630 - 00:06:49.166, Speaker B: And it moves computation and storage to a second layer and then just posts the proof on the Ethereum main net. So if we go back to that puffin and penguin example, there's a lot of user transactions that are happening on the layer two, which is the Zkevm, and those transactions are batched and processed on the layer two, which is Zkevm. And then instead of having all of the transactions on the layer one, only the validity proof is stored on the layer one, which is Ethereum. So just to give you a little visual, all those penguins and the puffin are on layer two. And then the proof, which is just that covered up piece of paper with the little puffin showing through, is on the L one Ethereum. So Zkevm is a layer two scaling solution. It harnesses the power of those ZK proofs and it rolls up all of the transactions on the layer one.
00:06:49.166 - 00:07:22.566, Speaker B: So you inherit all of the security of Ethereum, but you get to benefit from faster transactions and lower costs. So to keep it short, yzke EVM, you inherit Ethereum security. You achieve true EVM equivalents. It's fast and performant and the transactions are nice and low cost. So all of those things are great for scaling Ethereum. And here are some different industry use cases. Pretty much anything where you want to have maximum security is a great use case for ZK at EVM.
00:07:22.566 - 00:07:55.214, Speaker B: So DeFi traditional finance, supply chain stuff where you want to make sure things are secure. Healthcare, energy, infrastructure and gaming. Just tons of great use cases. And basically anything you build during this hackathon, we'd love to see you build on Zke EVM. And I'm going to show you how to do that. So the first thing is that you'll need some testnet ETH to deploy your contract so you can get that testnet ETH using our Zkevm bridge. This is Bridging l one assets Gorely ETH to zke EVM I know that Gorely ETH is kind of in short supply.
00:07:55.214 - 00:08:16.890, Speaker B: It's a hot commodity right now. And so we're definitely looking at having a Sepolia bridge as well. So that'll be coming soon. But for now, you'll have to bridge that Gorely ETH and you can do that by using the bridge. This is a QR code to the bridge. So if you want to scan that, go right ahead and I'll show you how to bridge. Send Gorely ETH to zkevm.
00:08:16.890 - 00:08:55.454, Speaker B: Okay, so I'm just visiting this bridge. I'll switch to the Gorely test network and now I'm on Gorely. You can see I have about 0.8 E in my account and I'm going to bridge just zero two over to Zkevf testnet. Just going to click continue. It'll pop open a transaction in MetaMask this is my little buyer browser extension. I love this app.
00:08:55.454 - 00:09:26.322, Speaker B: It shows me what's happening anytime. I have assets in and out. So that all looks good. And I'm just going to confirm this bridge. You can see I've bridged some Gorely ETH over earlier today, but now this transaction is processing and it'll take just a few moments to finalize. But once I do that, I can sign one more transaction and then the bridge will be complete from Gorely to Zkevm. So you can see it's going to require one more signature.
00:09:26.322 - 00:09:51.200, Speaker B: I'm not going to have you all wait for that because it's going to take a minute or two. But you can see that I've gotten Gorely ETH and bridged it over. And then earlier I used the same process to get some Zkevm testnet ETH. So I have 0.2 in my account from earlier today. So if you were to do this, you would just click the finalize button in 1 minute and then you'd have that e. But we'll skip that step for time.
00:09:51.200 - 00:10:39.758, Speaker B: Okay, so now that we have our testnet ETH, we can get to building. I don't know about you all, but I was just at ETH Denver last week and I tweeted we need a tracker for the number of Denver Uber drivers onboarded to web three this week because we were all Ubering. All over the city, and I feel like so many Uber drivers by the end of the week were like, oh, are you part of that Ethereum conference? I know what ethereum is. Somebody told me how to get a wallet, all these things. So I thought that was a pretty cool, fun way of onboarding Uber drivers. So I thought it would be fun to actually build a tracker and host it or deploy it on Zkevm. So we're going to be using this counter contract that I wrote and build a super quick front end so that we have a full stack Zkevm app.
00:10:39.758 - 00:11:01.666, Speaker B: So feel free to scan this QR code or go straight to my GitHub. It's just oceans 404. Full stack. Zkevm. I can't speak today and we'll get started coding. Just going to hide this little thing on the side. So this README will take you through all of the different steps to create a Zkevm full stack.
00:11:01.666 - 00:11:35.158, Speaker B: DAP. Like I said before, the really beautiful thing about Zkevm is that it's equivalent to Ethereum. So all of the tools and things you're used to working with work already by default, so we can use hard hat and different tools. But let's get started coding. So I'm just going to clone this repo. I've got a folder set up, so I'm just going to clone into my full stack Zkevm. So now I've got a second repo.
00:11:35.158 - 00:12:04.038, Speaker B: I need a CD into what did I call it? Full Stack. And I'll use this. So I walk you through some different set of steps. The first thing we're going to do is just take a look at the front end code. So we're going to NPMI and then NPM start. This is just installing all of the different dependencies for the front end. And then I'll NPM start to start the react app just to show you how the app looks before we do anything blockchain related to it.
00:12:04.038 - 00:12:23.674, Speaker B: So I scaffold it out just like a pretty quick front end. And it's just a classic react counter app. I think this is even in the react documentation. Let's see. Okay, so classic front end app. There's no back end to this. You click the plus one and it increments the count up by one.
00:12:23.674 - 00:13:02.670, Speaker B: Imagine that this is the counter for Uber drivers. But we want to move this counter on chain. So we want to deploy a smart contract to Zke EVM so that anytime I push plus one, it's an actual transaction to Zke EVM and it's posted on the blockchain. So what is the next step? Let's see. Next step is to install some of the different blockchain dependencies, mainly just like Ethers and Hard Hat and then some other tools. This is so that we can initialize a Hard Hat project. So I'll come back to my CLI and I'll stop the react app just for now.
00:13:02.670 - 00:13:49.162, Speaker B: And I'm NPM installing all of those different dependencies. So it's giving me a few warnings. But the next thing that we're going to do is we're going to copy the env over so that we have an env file. This will hold our account private key, which you'll grab from MetaMask, which just is the reference that is used to say that you have access to the account and you can deploy a smart contract from the account. When you need to get a private key, you can go into MetaMask. You click your profile, or rather you click these three little dots up here, go to Account Details and then export private key. It'll make you type in your MetaMask password.
00:13:49.162 - 00:14:19.270, Speaker B: I'm not going to do this because I would reveal my private key to you all, and I trust you, but not that much. So I already have this in a env file and I'll just copy this over. But if you wanted to do your own, we're done with that installation step. The next step is to copy the env sample to a env. So I'm just going to run that command. This is in the README. So it's doing a copy of env sample to an env file.
00:14:19.270 - 00:14:49.022, Speaker B: So now within my full stack repo, this env file was created. It's just a copy of this file. But what we need to do is fill in the actual private key. So I have a second env file that I'm going to just drag and drop in. This is a real env file with my private key. So I'll just move this in and it's going to replace this one. So that my private key is stored in an env file.
00:14:49.022 - 00:15:17.190, Speaker B: Now we can do the Hard Hat step, which is the next step. So let's just go back to this README. So the next thing we need to do is run NPX Hard Hat. But before that, we just need to temporarily rename the README file. When you run NPX Hard Hat, it creates a README for you. And it won't do this if you already have a README file. So back here, I'm just going to change this to the name of it of the README to setup.
00:15:17.190 - 00:15:41.646, Speaker B: So README setup. That way when we get a README file from Hard Hat, it won't conflict with the file. So coming back to my terminal, I'm just going to run NPX Hard Hat and I'll get some bootstrapping instructions. I'm just going to make this a little bit bigger. So the first thing we want to do is create a JavaScript project. The hard hat root works. We'll just keep that as the default.
00:15:41.646 - 00:16:08.986, Speaker B: We'll add a get ignore. Yes. And do we want to install project dependencies also? Yes. So this is bootstrapping out all of those different Hard Hat folders that we'll need to start writing our contracts. So you can see I'm getting a contracts file or folder. I'm getting a test folder and some scripts. These are all just things that come built in with Hard Hat, which is awesome.
00:16:08.986 - 00:16:36.144, Speaker B: So now we've got a project created. And to actually use Zke EVM, we need to configure just a few things in the Hard Hat config fold file. So let's copy paste in this code and then I'll explain what's going on here. So let's go to the Hard Hat config file. This is what comes default. So you've got a solidity version. Just one more requirement for some tools.
00:16:36.144 - 00:17:20.720, Speaker B: But I'm going to copy in the Hard Hat config from my README. So the differences for this are just the solidity version which needs to match whatever contracts that we write. And then the other thing is that because I'm initializing this Hard Hat app, inside of create react app, we want to put the artifacts, anything that's created about the contract in the source folder. That's what our react app is going to read. So we need to be able to reference the contract abi and things. So I like to just append the artifacts folder by default so that we're not dragging and dropping files in as we go. And then the last thing is networks.
00:17:20.720 - 00:17:53.916, Speaker B: So this is a custom network, it's Zkevm. And the RPC URL is this. So this is just grabbed from the polygon Zkevm documentation. And then the other thing about this is that we have that env file with my private key. So we're just referencing that within accounts so that Hard Hat knows what account is actually deploying any contracts we create. So that's the Hard Hat config file in a nutshell. And I documented all of that inside of my README.
00:17:53.916 - 00:18:28.004, Speaker B: So the next thing we need to do is actually create the smart contract. There's nothing zke EVM specific about this, but what I'm doing here is touchcontractscounter sol. So this is just creating an empty file for our Solidity smart contract. I'm going to copy in this code, this is Smart Contract, and we'll go through it really quick. So I'm copying and pasting the counter smart contract into a new file that I created inside the Contracts folder. This is a classic smart contract. So it starts with just the license pragma Solidity.
00:18:28.004 - 00:18:54.400, Speaker B: This is the version of Solidity that we're using. So anything over 0.8.9 and then this is the contract. So this is actually a little leftover I'm going to delete because that is not needed and I'm seeing some weird formatting, but ignore that. So Contract is the keyword that designates that whatever we're creating is a smart contract. So the name of this contract is counter. We're starting off with a current count of zero, which is just an unsigned integer.
00:18:54.400 - 00:19:35.650, Speaker B: Then we have two different functions that we'll be able to call on this smart contract. One for increment and one for retrieve. If you remember our front end, it had an original number, and then when you pushed the plus one button, it was adding one and counting up. So you can imagine that on the front end you're running some type of retrieve to get the original number, and then you're running increment to count up or to add one to the current count. So those are the two different things our smart contract is doing with the data. And our front end will be able to call these functions and also read the retrieve method. So now that we have our smart contract code, let's see what we need to do next.
00:19:35.650 - 00:20:18.168, Speaker B: Okay, so next thing we're going to do is create a deploy counter script. If you remember in our code, we already had a single deploy script and it was for that lock contract that was created by default. But we need some slightly different behavior. So we'll create a deploycounter JS file in that same folder and copy in this code. So I'm going back to my code and inside of scripts, I'll create another new file. I'm just going to call it Deploy counter JS and I'll paste in that deploy code. So this is really similar to what we got out of the box with the hard hat for the lock contract.
00:20:18.168 - 00:20:52.664, Speaker B: But the main difference is that we're not passing in any dependencies to the constructor of this smart contract. If you go back to the counter, there's no constructor here. We don't have to pass in a start count. Although maybe we could have if we wanted the counter to start at like five or something. But we've already hard coded it to zero. Whereas in the lock contract, part of the lock contract that it comes with is a constructor and it has an unlock time that you pass in. So if you were passing something in, your deploy script would look more like this, where you're passing in an unlock time.
00:20:52.664 - 00:21:35.060, Speaker B: But we're not doing that. So we can just use this deploy counter script to deploy a smart contract without any constructor arguments. So I have created a contract factory. I deploy the contract with the factory and then once it's deployed, we should have a contract counter deployed to with an address that links you to your Explorer. So if all goes well, when we deploy, we'll have a smart contract that is deployed to Zkevm. So to do that, we need to compile our code and then we'll run the script to deploy. So I'm coming back to my CLI and I'm just running that compile.
00:21:35.060 - 00:22:20.580, Speaker B: Looks like it compiled both of those solidity files successfully, so that's a win. And then the next thing we have to do is run our deploy counterscripts that we just created. And if you notice, the network flag that we're passing in is Zkevm. That is because if we go back to our hard hat config in the networks object, we have a network called Zkevm. So this matches what we're passing into our flag, which is Zkevm here. So I'm running the deploy script and it looks like there was a counter contract deployed to this address. So let's take a look at this on the Explorer.
00:22:20.580 - 00:22:59.740, Speaker B: By the way, this is the Zkevm Testnet Explorer. I really like the UX, actually. It's similar to Etherscan or polygon scan if you're used to either of those. It has some stats if you look at the home page. And then if you look at a specific address, it'll just take a minute to see. It might take a minute to show up, but we should be able to see the contract here. And let me check the chat really quick.
00:22:59.740 - 00:23:46.226, Speaker B: Yes, I'm just looking through the chat super quick and yeah, all of this will be available after the fact. And you can also ping me on discord. Okay, this is taking longer than it normally does, but we'll just give it a few more minutes and I'll just go back to the code for now. But what happens now is you can optionally verify your contract. I have instructions on how to do this in another repo, it looks like. Whoops is this? The wrong link. So I have a bug here or just a missing link, but I'll fix this as soon as the presentation ends and you'll have a link to how to verify.
00:23:46.226 - 00:24:41.070, Speaker B: But the next thing that we need to do is we need to turn our front end into a DAP. So there's like four pieces of code and I know we're running short on time, so I'm going to do this really quick. But the things that we're doing here are importing our counter JSON, which is the abi into our front end so that we can reference the different functions available on the contract and play with those from our front end. So I'm just going to grab these three pieces of code and add them to our app JS, which is what we're using with React. So I'm going to put the import statements towards the top and save and then I'll add these use effects and I'll explain the code. Oh, I also need to import use effect. Let's see what else.
00:24:41.070 - 00:25:31.500, Speaker B: And Ethers oops, let's see if the live coding gods are good to me today. We'll see. So that was just adding some read counter values. And then the other thing actually let me run the NPX start command or NPM Start just so that we have something to look at while we're changing things. Okay, so here's what changed with that addition of code. Oops cannot resolve. Let's see contracts counterjson.
00:25:31.500 - 00:26:09.678, Speaker B: It's complaining because we can't resolve contract counterjson. Let's see. That looks like it. I'm just going to move that temporarily. Oh, I'm going to stop my app and I'll restart. This is what happens when you live code in a demo. I swear this was working before.
00:26:09.678 - 00:26:58.682, Speaker B: I'll just go through the code because we're running short on time, but I'll be able to fix it and upload it if time permits right after the demo. So basically what I'm doing here is in the use effect. Instead of fetching the count from just like a state variable, I'm updating it so that it fetches count from read counter value. You saw for a second it was grabbing the eleven value. So what it's doing is looking at if type of window ethereum is undefined, so is not undefined. So if MetaMask is enabled, it's looking through the providers and grabbing Zke EVM so that's the provider that we've added in the hard hat config and it's getting the contract address. So the counter address, the counter abi and provider.
00:26:58.682 - 00:27:26.530, Speaker B: Oh, this is what I'm missing, your counter address. Let me grab that really quick. I needed to replace this value so let's see if that makes it work. There we go. Okay, so that's why it was complaining. You need to replace your counter address with the contract that you've deployed so that it can reference the counter abi. Okay, so coming back to that read counter value, what we're doing is we're grabbing the provider.
00:27:26.530 - 00:28:19.240, Speaker B: We have the counter address, the counterabi which is that counter JSON that is created after you compile a smart contract and then it's running the retrieve function on the smart contract. If you go back to your smart contract for counter, we had retrieve and increment. So this tutorial will walk you through how to add both of those different functions so that you can add those to your front end. Okay. And then coming back to app JSON, it's grabbing that value so that retrieve function returns an integer and then it's parsing that to just like a string because it's a big number by default in the contract. And then it's parsing the integer so that it knows the actual number to show on the front end. And then the last thing it's doing is updating the state here with set count, which is that state variable towards the top.
00:28:19.240 - 00:29:11.186, Speaker B: So the last thing we need to do is implement the second piece of state, which is the update piece of state. So I'm just going to add this is loading because we need a little loader while we wait for the blockchain to update. And then I'm going to grab this second piece, which is Request Account and Update Counter. So this is just a second piece that is updating the counter on the blockchain. So, again, we're grabbing our providers, grabbing the signer, and then referencing the correct function in the contract, which is increment. And the last thing I'm doing is changing increment, which was a constant or a function that I had just updating the front end. But we want it to actually call update Counter.
00:29:11.186 - 00:29:43.426, Speaker B: And then just for ease of life, I'm adding one quick little small update on the button so that the platinum has a loader and it loads when the smart contract is updating. All right, let's see if that all worked. Hopefully it did. Okay, it's looking good. The count starts at zero. If I press plus one, we should have yes, the MetaMask notification pops open. It's asking me to confirm this transaction and the counter is updated to one.
00:29:43.426 - 00:30:15.718, Speaker B: And so we should be able to do this however many times and see this update on chain from the front end that we've just built. So I'm going to confirm this. And now our count is two. And if this all worked, when I refresh the app, the count should say two, which it does because it's reading from the blockchain. So very successfully. This all worked and came together in the very last minute of this demo. I know we're super short on time, but you can get the code here and go through the README.
00:30:15.718 - 00:30:47.620, Speaker B: And I just also wanted to point out that our developer docs got a huge blow up. So check out our updated docs. They have everything you need to know for building on Zke, EVM, Polygon, ID, and anything else you're going to build for the hackathon. Thank you so much for coming and listening. Here is a QR code that links to all of these slides. And the code again, I'm Steph, I'm Oceans on Twitter and I'll see you around in the discord and can't wait to see what you all build for hacking or scaling ethereum. Thank you.
