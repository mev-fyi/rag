00:00:00.090 - 00:00:46.300, Speaker A: Labs and I'm here to talk about getting scalability plus security and what kind of properties that we want to get. And I think kind of and our solution which I think achieves like a lot of cool properties which you kind of may not have been focused on. So in terms of kind of goals of what we want when we're talking about scaling smart contracts and kind of building smart contracts there's kind of a lot of different things that we want to achieve that kind of are sometimes contradictory properties and a lot of different solutions have different trade offs. So we want scalability. And what does scalability mean is kind of and it means different things to different people. We want security that's pretty straightforward. We don't want anybody stealing our money.
00:00:46.300 - 00:01:22.680, Speaker A: We want compatibility interoperability so we don't want to all be in our own little boxes and not be able to interact with the blockchain in general. And we want smart contracting. So, I mean, asset transfer is great but this is an Ethereum event. We want smart contracts and we want to be able to do cool stuff there. So then scalability and this is a topic I think about a lot because scalability is really valuable and there's a lot of different elements of scalability. So the most common thing that people think about is high throughput like how many transactions per second can your system do? And that's obviously important. That kind of is directly related to how many users you have.
00:01:22.680 - 00:01:52.320, Speaker A: That's pretty valuable. But there's a lot of other important things going on too. So low latency, time to finality in Ethereum, if you want your users to actually be secure they might be sitting there on a little spinning ball for five minutes waiting for their transaction to confirm and get enough confirmations to be secure. And so you really want to avoid that. You really want to have a low latency experience where users can click and it's committed. You want to support many participants. So you want to be able to kind of have adapt that a lot of people can use.
00:01:52.320 - 00:02:27.370, Speaker A: You want to have ample storage. You don't want to have the tiny amount of storage that you can currently have in the Ethereum blockchain because storage is so expensive and you want to do complex computation. Like you don't want to be limited to only very, very simple pieces of computation and logic. And that's kind of both the size of the contract which I know from experience building our own system. The size limit is really annoying in terms of how much code you can write. And also you want to be able to run a lot of instructions per second and have an efficient machine. So I mean, not need to like the gas limit kind of is a very limiting factor.
00:02:27.370 - 00:03:22.346, Speaker A: So then the question is can we achieve all these things? That's a whole lot of properties that I just listed and I think probably most people would agree that they're basically all really valuable and you get into kind of sacrificing some for others, but optimally you would achieve as much of that as possible. And I think we have a solution that achieves good bit of that for a lot of applications and kind of just in terms of what we are, there's a lot of different places that scaling takes place. There's all the amazing work going on with Ethereum 2.0 and all that awesome stuff. But we are squarely focused on layer two, building on top of an underlying blockchain and adding a lot of value to that. So Arbitrum makes smart contracts scalable and secure. Arbitrum being kind of the main product that we're developing that I'm going to be talking about today.
00:03:22.346 - 00:04:10.060, Speaker A: And we use a combination of, let's see, protocol design, incentive mechanisms and a virtual machine architecture. And so we have kind of a lot of different components and a lot of different areas of research that have combined to make this possible. And I'll give you kind of an idea about how all of these different techniques come into play in our system so how Arbitrum works. And this is kind of going to go a little bit into the technical detail of essentially what our magic solution is so that you can understand if it's something that would be useful for you. And I'm going to start with some terminology that's useful in understanding what's going on in our system. So first of all, we are consensus agnostic that kind of we're a layer two. We don't care that much about the layer one.
00:04:10.060 - 00:04:42.840, Speaker A: It needs to work, it needs to be secure because everything's only as secure as whatever your blockchain is. But to us it's kind of a black box and so we just call it the Verifier and it could be anything. We're building on ethereum. I love Ethereum, so that's what we're doing practically. But in terms of the concepts I'm going to be talking about, this is just a black box. The most important concept that we talk about is validators. And these are kind of layer two validators and validators in our system.
00:04:42.840 - 00:05:30.566, Speaker A: And the core of our system is that when you create a smart contract, you specify a list of validators and those validators are the ones that are responsible for running that smart contract. And what our system does is it provides a really strong security guarantee that the system will run correctly if any single one of those validators is honest. And so you don't need that many validators to be able to assume this, especially if they're known identity. So let's say you have like ten validators. That's most likely more than enough for your application, for your users to be confident that they won't entirely collude, that at least one of them will be honest. And so now I'm just going to talk about an example of what using Arbitrum looks like in practice. And I'm going to use the example of a two player game.
00:05:30.566 - 00:06:02.926, Speaker A: Let's say that Alice and Bob are playing a game of chess. What do they do? Well, the first thing they do is they write a solidity contract or they download a solidity contract. They're probably not writing it themselves, which is this chess game. And what they do then is they load it up into a virtual machine, into a layer two execution environment. And so they both agree, they essentially both come together. They say, hey, we both agree that we are running this code and we're going to commit to that. And they create this virtual machine, which is essentially in smart contract world.
00:06:02.926 - 00:06:37.894, Speaker A: You can also call it a third party, but it's trustless. There's no kind of actual person that's running the game. It's just running on the network. And in this case, Alice and Bob are actually running it themselves since they choose to just be the validators for this contract. And if you're familiar with state channels, this is essentially that they are participants in a state channel together and it's a very similar model to that. And so they send moves to this kind of magic virtual machine. It'll validate their moves and it'll verify in the end of the game that the game's actually been correct and pay out to the winner.
00:06:37.894 - 00:07:31.690, Speaker A: And so you have kind of the entire smart contract going on in layer two with no need to go to the base chain at all for our case. And I'll dig into this more and this is kind of one of the biggest distinguishers of what we're doing. There's no circumstance in which this contract has to be on the main chain. It exists entirely in between Alice and Bob, no matter what happens. So the thing to talk about now is we have contracts, or in this talk I normally use the term VM because I like it better. And they have a set of validators. So then the question is, what are these validators doing? What's the magic protocol that they're running in order to achieve the antitrust property and achieve the things I'm talking about? So validators first of all, are incentivized to agree unanimously about what a VM will do because that's the easiest path forward.
00:07:31.690 - 00:08:06.066, Speaker A: Because most of the time we're just going to have the validators agreeing. They're not going to be in a fight, nothing's going to go wrong. They're just going to agree. And one thing you want is you want that fast pass to be really fast because most of the time that's what's going to happen. And so what they do in this case is essentially we have a virtual machine and we say, well, currently the virtual machine machine is in this state. So this is kind of the state of the channel between them. And then if you execute the machine sum, it'll be in this after state, and they're going to be some actions.
00:08:06.066 - 00:08:47.940, Speaker A: So our machine is going to send some money to someone on chain. It's going to do something. It's going to take some externally visible actions. Alice and Bob both signed this and done, confirmed and with immediate finality, with no need to wait. And so you can get the feedback instantly that these actions are going to occur, which means that your UI can update immediately, and you don't need to worry about security or a reorg or any of that stuff. But what if they won't come to an agreement? What if Alice and Bob just something's gone wrong between them, they're pissed at each other. Alice is trying to make Bob's life hard or the other way around.
00:08:47.940 - 00:09:25.730, Speaker A: What can we do then, if we can't get them both to sign the same thing and use this easy method? And so for that, we have this thing called disputable assertion, which looks a lot like a unanimous assertion. It's basically the same thing, except only Bob signs it. And so we haven't been able to actually get everybody involved to sign off, but we have a way forward. And so what Bob does is he broadcasts this assertion to the network, and at that point, a clock starts ticking. There's our clock. And Alice can respond during that time if she wants to, and she can say, hey, Bob's lying. That's wrong.
00:09:25.730 - 00:10:43.186, Speaker A: If she doesn't respond within that time period, once again, it's going to be confirmed. And so Bob can unilaterally move the state forward without having to put the contract on chain, without having to do any sort of major on chain operations except for a small transaction. And so essentially what happens here is when you make this disputable assertion, you deposit some funds, and if there's a challenge, then one or the other person will have their funds slashed. And so you're not going to have challenges unless people are willing to shell out a lot of money for no reason. And so the economic incentives here make it so that this should really not have to happen, because people will be honest, because they know that there's a guarantee that they'll get punished if they're not. So how do we handle these challenges? So let's say there's a challenge, and we had end steps of execution, and we're trying to figure out, was this true? Was this a lie? Without putting the whole contract on chain? And unfortunately, given time constraints, I can't go into all the details of how this works, but essentially what they do is they shrink the challenge down. So there's currently a dispute over N steps, and we narrow it down.
00:10:43.186 - 00:11:55.300, Speaker A: So then we get a dispute over N over two steps, and then N over four steps, and we shrink it down until we get a dispute over one step. And that's kind of the smallest unit we can get to. So we're disagreeing about, like, a really small thing and we want to settle that. And so the question then is can we make that really cheap to resolve? Can we prove one step without revealing a massive amount of data? And so we have the Arbitrum virtual machine architecture which is optimized for this purpose so that all one step proofs can be emulated in small constant time, can be sent to the network in small constant size, essentially everything's really cheap. And so we can have guarantees that no matter what, these conflicts will be cheap to resolve. There are four kind of major principles and ways that we did this. We always felt a little crazy going into this inventing our own VM architecture, but it's really cool because it gives you really strong guarantees about the gas cost of these disputes, which in turn makes the incentives of the system really easy to reason about.
00:11:55.300 - 00:13:08.786, Speaker A: And so what we essentially did is we made a machine architecture that's a merkel tree, there's some details into that, but essentially opcodes work on this merkel tree and they work near the root, so they don't need to go down to the leaves, which means it's pretty cheap to reason about stuff near the root. And so where in a conventional architecture you have kind of flat memory and code and you probably need to do merkel proofs into those in order to track what operation and what cell you're reading in the Arbitrage architecture through a little bit of magic. And I think I should have time to explain that a little bit. We kind of get rid of all these various logarithmic things that you'd otherwise have to put on the blockchain. And so essentially we do kind of this kind of magic transformation. So instead of having memory in the classic sense, we instead have these fixed size blocks called tuples and this will just be kind of a cell that contains a few values. And so where normally you would have just like memory being emulated and you'd have this flat memory and then you'd probably mercalize it and build a tree instead that's all just done at the application layer or at the compiler layer.
00:13:08.786 - 00:14:03.900, Speaker A: And so instead of having a read instruction, you instead have a read library call that uses all of these sub operations and makes it efficient. And so instead of having a memory read, for instance, be kind of log n in needing to trace through this tree, you instead just have kind of login little micro operations that each cost very little independently. And so this one step is very cheap. The other cool thing we get with this technology is we get privacy. And specifically the state of the VM is only revealed to that VM's validators. And since unlike kind of normal state channels under no circumstances ever have to go to the blockchain, you can guarantee that only these validators will ever need to know the state of that contract. And all that will be on chain is Saltable hashes of the VM state and kind of some metadata essentially about the execution of it.
00:14:03.900 - 00:14:39.814, Speaker A: But we have this strong guarantee that you don't need to put any kind of serious data on chain. You can reveal it if you want to, if you want to make it public, you can, but you don't have to. Compared to the regular blockchain where kind of it's part of the architecture that you have to make everything public and you can use cryptography to fix that a little bit, but it's kind of fundamental. So our company is in the middle of developing Arbitrum. It started out as a research paper, now we're a company, now we're building it. We should have our initial alpha release out within the next few weeks. There's a lot of various components of this system.
00:14:39.814 - 00:15:06.186, Speaker A: There's kind of all of the virtual machine related stuff. So assembler, runtime. There's kind of the honest validator code base that will essentially run this whole protocol in the background. So that as a developer, as a user, you don't need to think about any of this. You want to be confident it works. So it shouldn't be a total black box, but you don't actually need to deal with this in practice. And this is a layer two project building on top of Ethereum.
00:15:06.186 - 00:15:54.842, Speaker A: And we have built in interoperability with Ethereum. So you can take all of your existing ERC 20, ERC 721 tokens, own them in Arbitrum contracts, do whatever you want, send them back and forth and you can just take your existing Solidity code, run it through our compiler and deploy immediately onto Arbitrum. So you don't need a code for like a special framework, you don't need to fit into whatever kind of into what we're doing. You just take your existing code and click a button and you can deploy. So just kind of closing out Arbitrum. We can actually really achieve a lot of these scalability and with strong security properties that I talked about at the beginning of the talk using this combination of protocol design, incentive mechanisms and virtual machine architecture. And we're also hiring.
00:15:54.842 - 00:16:06.446, Speaker A: So if this sounded cool, we should definitely talk. So thank you very much. Yeah. Questions?
00:16:06.548 - 00:16:20.770, Speaker B: Yeah, I guess kind of a recurring theme I just keep hearing is like a lot of these layer two solutions is the whole like you could just take your smart contract and it'll just deploy it to other chain or network.
00:16:20.850 - 00:16:26.040, Speaker A: Yeah, just run. But there are a couple of Asterisks there for sure.
00:16:26.730 - 00:16:33.046, Speaker B: You kind of have to come up with actually an architecture. You're not just going to take the contract you have on main net, deploy.
00:16:33.078 - 00:17:17.810, Speaker A: On the side chain and somehow so essentially there are parts of Solidity that we can't support. So you can't support generic synchronous calls to on chain contracts because you're executing in this little layer two world. So you can't just arbitrarily plug into the existing world, but you can, for instance, support sending and receiving tokens. You can support a lot of that. Most state channel projects have kind of a framework you have to plug into. We're not doing that. So we do kind of take your existing Truffle project, install our provider, and deploy into Arbitrum and kind of assuming your contract doesn't use these unsupported features.
00:17:17.810 - 00:17:42.050, Speaker A: It is as simple as that. Any other questions, or feel free to call me out and follow. Yeah, no, absolutely. Yeah. See anybody else? Cool. Awesome. All right, well, thank you guys for listening.
00:17:42.050 - 00:17:45.040, Speaker A: Well.
