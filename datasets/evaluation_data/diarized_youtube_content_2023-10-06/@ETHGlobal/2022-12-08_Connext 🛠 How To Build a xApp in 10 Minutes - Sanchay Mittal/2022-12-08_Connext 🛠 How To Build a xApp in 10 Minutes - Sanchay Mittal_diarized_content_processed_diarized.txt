00:00:06.410 - 00:00:20.410, Speaker A: Again. I think I already gave my intro. I can do it third time. This is Sanchez Mittal and I don't know if Mike is working or not. I'm going to shout it out. Yes. So we are building cross chain domain applications.
00:00:20.410 - 00:00:50.610, Speaker A: Everyone is aware of DApps. I'm assuming that's the case. Everyone is aware of how the smart contract works. If not, we will go through that, no worry at all. But let's start with the mindset that if we are building any applications, they are not existing only on Ethereum. Now we have polygon, we have optimism, we have multiple chains which are coming up and they have their own incentive. The whole liquidity segment is all across these chains.
00:00:50.610 - 00:01:29.142, Speaker A: One has bigger or one has another. They have these incentives which are run multiple times and that's why people are getting more and more interested in Zaps. Or we call it cross chain DApps. Let's start with a basic intro which we will be using these terminologies a lot. We are not going to say chain because we know that there are multiple networks which are not exactly a chain. We can categorize it in a protocol or it could be a roll up which is very dedicated to a specific problem. So any L one L two side chain and non EVM compatible, we will just call it domain.
00:01:29.142 - 00:02:19.754, Speaker A: Right? So I'm assuming you guys are with me right now. And as I said, wrap is a cross chain domain native app. So any application which we will be building right now is going to be a cross chain DAP. That means it is available on Ethereum, polygon, any of the EVM chains, any of the non EVM chains as long as we are supporting and we are chain agnostic as long as it's secure. Right? So let's start with the second part. Yes, we are a bridge and people have this question are we secure? We have seen a terrible year last year and we saw three billions of hack and are we the same? No, but everyone says that. So let's explain how we are different.
00:02:19.754 - 00:03:21.978, Speaker A: But let's start with why bridge are unsecure. Why we saw this 3 million 3 million oh, sorry, 3 billion. 3 billion of hack which happened last year. What happened is that there are bridges which use these trust assumptions which are basically validator sets, multisigs. So you are depending on these ten people, okay, can I bridge my million of dollars and I will trust you guys? Okay, you three, I love you and you will take care of me, right? And that's the trust assumptions which we are making with these stupid bridges which are using multi six or validator set, that is simply third party and how we can stop it. And yes, there were some code bugs which we have to make sure that we have simply much more large audience. We have these TVL caps and we have much more audited power audited contracts so people can go through it and they can report any security issues which they are seeing.
00:03:21.978 - 00:03:58.286, Speaker A: So let's jump on to why Connect and how we approach this problem. So Connect uses modular stack. We don't create any new trust assumptions, we are not adding any sort of valid data set, we are not adding any multi sex. What we are doing this is the interoperable trellma. If you guys are not aware of I'll run through you very quickly. So everyone, if people don't know about scalable trelema that's okay. So when we are talking about interoperable trellimer, that is where we are talking about trust minimization, generalizability and extensible.
00:03:58.286 - 00:04:55.786, Speaker A: So when people try to create these bridges, they try to take these shortcuts where they do trust assumptions and try to avail generalizability and extensibility. So they can use a common interface for the bridges and they can have like a bunch of money goes from one side to another. But don't never think about the trust minimization. But we as connects, we take pride in it. We absolutely take pride in is that we 100% focus on trust minimization. We make sure that this is happening and then the user interface or the user experience. Yes, it's very important that if it's going to be horrible, I'm like you are secure guys, but that's a shit show, right? So we want to make sure that we have trust minimization, we have good user experience and how we can expand it to more chains, how we can make sure that anyone who is coming cross chain can easily come and they don't even think about it like okay, which roll up or which chain I'm using.
00:04:55.786 - 00:05:25.614, Speaker A: I just have these six five params which I have to put in and I'm all done. All good. So what we do is that first let's start with how we are focusing on security. We focus on security by using transport layer which are underlined, which are present for these bridges. So we don't create a new messaging layer. We use these existing messaging layer which are pretty secure already or they are the secures one for those bridges. So when I'm talking about polygon, the POS tech is the secureest.
00:05:25.614 - 00:06:20.214, Speaker A: They use validator set but that validator set actually runs the whole chain. So even anything happens to POS tech the chain will dissolve itself, right? So the POS tech is the secureest one right now for polygon. And same when I'm talking about Cosmos ecosystem it's going to be IBC, right? And when I'm talking about roll ups, it's going to be roll ups. So we use that as a transport layer and then we have another security layer above it where we have watches at whenever you are sending a message from one side to another. When we are receiving this message from polygon to ethereum we have this watcher set where we have 20 minutes where you can make sure that okay, anyone sees that this information is not correct. Guys, even if you are using Amb, if it's falsified, we can make sure that doesn't happen to us. We can report it and stop that bridging which is coming up so running too quickly.
00:06:20.214 - 00:06:59.566, Speaker A: How we can do it? We have pause button. So on each contract we see that something is going wrong, we have this pause button, press it sell, right? Nothing is stolen, everything is secure. We have TBL caps. We make sure that we have a TBL Caps. We know that we will start with some TBL cap and once we are increasing it, we will have another audit. We'll run through the community that please, if you see anything, report us. We have incentive for them and we have fire drills which we run through every time where we see that if anything happens, how we can do it? I mean, you have to run through it, right? You have to be prepared.
00:06:59.566 - 00:07:43.278, Speaker A: If anything worse happens, we have to be there and formal verification, additional audits, we do it all the time. Generalizability, we have an arbitrary message passing. That means that you can pass any message. It could be any piece of information. It's not only token, it could be NFT, it could be a simple I love you message. I don't know anyone wants to do that and if they want to send like do a Dow Governance they want to see if there is Aave in case right now we have polygon ethereum on multiple chain existing. But how do they do a Dow Governance? They can use cross chain and they can have the voting mechanism properly done through.
00:07:43.278 - 00:08:18.394, Speaker A: So an extensibility we are present on all the chains, how connects works. So it's very simple. For a user or a DAP developer what they have to do only is that use this X call I will run through the interface itself. They have to go through the X call and that's all is needed for the DAP, right? You have these seven params you have to put in there and everything is taken care of the connect. You can absolutely understand how the architecture works. And we have these active help providers. What they do is that they see, okay, there is a request of completing this message.
00:08:18.394 - 00:09:18.042, Speaker A: I will run through it, I will wait for the messaging layer for one and 2 hours. But for users, for the DAP, it's going to be one to three minutes at most at most, right? So you're having these transactions which are happening from polygon to optimism in two minutes in a single call and you can have multiple features available, you can put it in the encoding and you can have a uniswap trade happening. You can have abundance of use cases available where you can do anything cool in a single call which can happen in one to two minutes. Right? Let's run through how we can do this. So let's start that ten minutes which is on the clock, she'll be on the Zap. So why it's one click UX? As I explained better liquidity what we have right now. We can avail better liquidity if we know that there are incentive provided to the routers and there are users who wants to use it cheaper and faster transactions.
00:09:18.042 - 00:10:07.360, Speaker A: Of course, if you go like each and every chain, it's going to take like a huge time apps also it's not going to cheaper at all. You have to make these three to four or five calls where you have to execute it, right? You go make polygon Ethereum optimism on optimism you make a swap. So four calls already added, right? Four transactions already added. Here we are doing arbitrary message passing, so you can do a lot cool stuff and that's what it is and we don't pick anyone winning. We are chain agnostic. Users are going to use these multiple platforms so we have to make sure that we can actually onboard a lot of users and that's for the DApps, right? And we have a unify interface for all the chains, so it's not going to be different for anyone. And as I said, we can pass any message and that can be encoded into call data.
00:10:07.360 - 00:11:21.686, Speaker A: Okay, so I will run through really quickly how we can do everything on these slides. I was going to do a live examples that would have been so clue, but the internet is not working over here. So let's start with the anatomy of a Zap when we are talking about these. That one simple use case of interaction would be that you can use simple Xcall which is available on connects Sol. You can provide the parameters and then you can execute it. Another one is that you can have something cool over here happening on source Sol, right? You can have some functionality over happening here and then you can transfer the money so you can maybe do some swap which happens over here and then you can use Xcall and then you go over there and then do another solve or anything, whatever you like, right? And let's jump on to what we can build with this, right? I will run through this really quickly and we have these code examples where I will explain how exactly you can do it. It's over here, right? So what we can build, we can do token bridging, we can do simple X call where you have to transfer your money from one chain to another.
00:11:21.686 - 00:11:58.926, Speaker A: You can have crosschain governance where you can do voting yield optimization. So Ethereum has already consumed everything like any best API which is already available. So let's find out crosschain, right, we can have really better APY which is available on Optimism Arbitrum or any other chain which is popping up right now, right? They provide these incentive for the users to come and provide the liquidity over there. So you can get much better APY all across these chains. Dex arbitrage, you can have different swaps rate. Dex liquidity. You can provide the liquidity to the dex.
00:11:58.926 - 00:12:28.618, Speaker A: Again, better APY. Cross chain vault strategy. It's really cool. Really cool. So if you have these vaults and strategy management, you can have these funds which are already available on these multiple chains and can execute really it's more like LP providing as well as you can have these strategies which are already given through yarn possibly. And it's really amazing. I'll go through that in one SEC.
00:12:28.618 - 00:12:57.122, Speaker A: And we have these cross chain loans. So you can borrow on one chain and pay on another chain. Right? We have crosschain NFTs, so let's make it cross chain. Right? So if we have an NFT on Ethereum, we want to use it on a game of optimism. Or the gas fee which is provided on polygon is going to be cheaper. So we want to make a marketplace which is available on optimism. We can trade on polygon.
00:12:57.122 - 00:13:30.942, Speaker A: So once we have these things cross chain, we can have much more functionality available. Guys, I know that we don't have internet, but you can scan the QR code. You can start with this template which is available on Zap Starter where you can I will give like 1020 seconds. Just scan the QR code or read the link or click a pick and then you can go through that later on. Right? Okay. Yes. So connect with us, but we can show this QR code later on.
00:13:30.942 - 00:13:59.036, Speaker A: Let's jump onto this straight on the code side right now. Yes. So we have docs which are available. You can open that as well. Quickly click a pick and I will just go through the next slides. Awesome. So when I said Xcall, xcall is the main function which DAP or the user needs to understand, or user doesn't even need to understand.
00:13:59.036 - 00:14:37.732, Speaker A: DAP needs to understand that. So we have this Xcall function where we have these seven parameters which you need to provide to make any X cross chain call. Right? So you're providing a destination chain where you want to execute this function or where you want to receive these funds. And then you have this target address. This is two address, so it could be a receiver address or where you want to execute like a new functionality that would be your target address. ERC, 220 the token which you are transferring, if it's not related to token, you can address zero this and you can send any arbitrary message through that delegate. This is of safe functionality.
00:14:37.732 - 00:15:03.840, Speaker A: If something happens, I will go through that later on. Amount slippage and call data. Call data is one of the main way you can actually encode something if you are not encoding. It's a simple transfer. You can just zero exit slippage, maybe mention 3%. So we know that if it's going through the AMM, we wouldn't suffer loss. So there are like two types of billing which would be simpler, which we can do.
00:15:03.840 - 00:15:49.170, Speaker A: That is Xcall through SDK. So you don't even have to jump on the contract side. And if you are doing a contract integration, that's going to be asset transfers, unauthenticated calls where you don't have to know on the target side from where this call is coming up. Let's start with SDK. It's pretty simple, right? So we have these X calls available, we are doing an approve for the token and once we have done that, we are simply creating a call X call using the NXTP SDK base. So you can download the SDK, you just create this simple call and you are done with it and that's all. You are already across chain app for this.
00:15:49.170 - 00:16:46.270, Speaker A: As I said, there are lots of functionality, I will mention one of them which is very popular to you guys is that Dex arbitrage. So if you're talking about a price probably of ETH on ethereum it could be way different on polygon, it could be way different on optimism and you have to spot these Dex arbitrage and you can make a good trade, you can make money out of it and that will happen in one to two minutes. So you spot that, you make these transactions your money and that's what the Dex arbitrage is going to be about. This is a simple transfer as similar to the SDK but we are not using SDK, we simply want to use contract. You can just encode everything which is happening over here. So you have alliance happening, you transfer the tokens and you have the approve happen, you just x call it. Let's jump on to the really cool part.
00:16:46.270 - 00:17:49.680, Speaker A: So as I explained initially, we had the source contract, we have these target contract, right? So in source contract what we are doing over here is that we are sending a simple message that is a new greeting. We are sending a simple hello world over here and we are just creating X call over here, right? So when we already saw like if you want to transfer a token, that can happen, right? That can easily happen. You just put where the address zero is, you can put the token address and you can put the amount and that's what is needed. But when we are sending an arbitrary message, you don't even want to use the token transfers. You can do this where you can simply have these target contract created where this is going to exist on destination chain and this is the target address which will be on the source contract. Once you do that, you are simply checking that okay, did I receive suffice amount? If you want to and you can receive the message by simply decoding it. So you encode the call data, you decode it and send it to the function.
00:17:49.680 - 00:19:00.404, Speaker A: So we have a simple, very simple example where we are sending a simple message. But just think about this if we are encoding a swap data for uniswap and we are sending that, we are encoding that and decodes over here and then we process that function further here. So you can put any functions on the destination side and easily can execute it through this. So you're talking about one to three minutes of execution where you are doing impractical, where you have to do five calls, five transactions if you are not cross chain and you can do simply through this and yes, these are the three examples which I'm providing over here. Where can you do yield optimizations? You can spot the best yield out of all the networks can unknown cross loans. You can borrow one side, you can give it to another side. Think of it this way, we have a position created on ethereum but I have funds on polygon, right? So I would just want to send the funds from polygon and complete my position on the ethereum and that can happen in single call.
00:19:00.404 - 00:20:01.640, Speaker A: That's what the cross chain loans are about, cross chain NFTs. I've already gone through this. There is another part of this in the target contract we can have authenticated target calls. So sometimes we want to make sure that this call, where it is coming from, we want to make sure that this is the address I want to trust for, right? So the source address where I'm receiving that, I want to make sure that on target, that it is the one and that is required in case of crossing governance or in case of crossing vault strategies or even case. Of cross chain NFDS where I want to make sure that from where I'm receiving this address, these funds or these NFDS, or I'm getting a call of executing or transferring the funds from this destination to, like, a C chain that is coming from this source address. And that time we have to use this authenticate call. So here we have a modifier where we are putting only source and we are sending these origin.
00:20:01.640 - 00:20:31.220, Speaker A: Sender and origin. That would be a part of the reconciled call which happens underline the bridge. And it will provide you the address where the call came from. And that's what will authorize that, authenticate this. And that will take 30 minutes. So you have these two cases where you can execute things in one to two, three minutes and where you have use cases where you can do 30 minutes to 1 hour depending on. So you have these two really cool ways to actually implement multiple ideas.
00:20:31.220 - 00:20:54.670, Speaker A: Thank you very much guys, that's all from me. We can run through this. All the ideas I would love to hear from anyone. If you are online, you can send us these ideas on the discord which is available on the connects. So you go to theconnects network, you connect with us on the discord and we can chat more over there. Anything else? I would love to hear the oceans right now.
