00:00:00.330 - 00:00:26.370, Speaker A: Which is going to be presented by Sam and Anskar, who will share an overview of account abstraction, a proposed change that would allow depth to pay fees for users. Oh, I see we're a little bit early. I hope Sam and Anskar are there already. Sam Anskar welcome. In case you're.
00:00:28.630 - 00:00:55.200, Speaker B: Sorry, cut off a second. Okay, I don't yet see a shared screen. Here we go. Okay, so we are here to oh, let me also share my video. Hi everyone. So we are here today to talk a little bit about account obstruction. And the first thing we want to do is just briefly to talk about what even is account obstruction in general.
00:00:55.200 - 00:01:48.030, Speaker B: As you're all probably aware of, the whole idea of Ethereum was to move from bitcoin where you don't have programmability especially, you have always fixed effects, right? A transaction can always only send value from A to B or like from one UTXO to another UTXO for bitcoin. Whereas in Ethereum you have contracts and what contracts give you is full programmability. However, on ethereum today, that is only true for the effects of a transaction. So the actual validity on ethereum when is a transaction valid and can be included on chain, is always statically analyzed. That is only like a signature check and ECDSA signature and then a non check. Whereas on bitcoin you do, funny enough, funnily enough, have a limited programmability with the bitcoin scripting language. It's not turing complete and everything, but at least there's something.
00:01:48.030 - 00:02:36.960, Speaker B: So you can have native multi six on bitcoin, you can't have them on ethereum. And now Ethereum with account abstraction basically just is aiming at fixing exactly this. So you just add programmable validity on top of Ethereum as you have it today and basically why do we want to talk about it? Well, we recently published an EIP exactly on account obstruction. And then this is also like a good point to briefly talk about the we. So who are we, sam and I? We are here on the call today and to present to you this EP. And then we created the EP together with the rest of the quilt team, that is a research team within consensus and together with vitalik. And our focus in quilt has been mainly on Ethereum two in the last year or two.
00:02:36.960 - 00:03:18.842, Speaker B: And we actually came from the world amateur. Maybe you heard the words of execution environments, right? That was one of the big things we looked into. But it was more and more clear that most likely in it two initially we will have especially with Phase 1.5 where we just bring the it one as it is today into the e two context first before we do all these more advanced things. And so we looked into how can we bring the best of these more advanced e two features already to Ethereum today and this is what led us to account abstraction. But very importantly, don't panic we really try to make sure that this is like a very simple overview. We don't go too much into the technical details.
00:03:18.842 - 00:03:43.142, Speaker B: So let's start maybe with a simple motivating example. Say you're a user on Ethereum and there's a contract. Maybe it's like a multi SIG. Maybe it's a smart contract wallet, right? Something where you want to send it's. Basically your contract. You want to send from that contract a transaction to a different target contract or account or whatever. What you have to do today is you have to own an account, an extra account on the Ethereum Mainet that has ETH in it.
00:03:43.142 - 00:04:24.580, Speaker B: Then you have to send out a transaction to the contract and then the contract has to send like another transaction to the target. If you don't own a contract, an account, what you can do instead you can use a relayer, but then the relayer needs to have an account and then a relayer needs to send a transaction and then the contract has to pay the relayer and that just adds even more overhead, right? Basically the idea behind account obstruction is where we want to get to is this simple picture, right? You have a user, the user can just immediately initiate a transaction, add a contract, and then the contract pays for the transaction. The contract does whatever you want the contract to do, right? And this is the goal. And so the question is, how do we get there and what does it look like?
00:04:26.950 - 00:04:58.320, Speaker C: Yeah, so this is what Solidity could look like, not what it will look like. And this is based off of an early prototype that quilt put together of an earlier version of the EIP. So the first thing you're going to notice is the new account keyword before contract. And that signifies that this is an account abstraction contract. The next thing you'll note is that the signatures are embedded in the Call data, which you can see in the transfer function signature. This is a two of two multisig. So you end up getting two different signature arguments in the Call data.
00:04:58.320 - 00:05:34.762, Speaker C: We've skipped over it in this slide, but those signatures would be checked in the perform validation step, which is followed by PayGas. PayGas is a new opcode we're going to get into later. But essentially it determines how much the contract is willing to pay for the transaction. Once PayGas is finished, you move on to regular transaction execution. We have a series of examples that we think are really good at representing account abstraction and what it brings. These are not the only uses for account abstraction, they're just illustrative examples. So I want to first talk about the smart contract wallet, which I'm sure most of you are familiar with.
00:05:34.762 - 00:06:14.520, Speaker C: But for those who aren't, it's a wallet which is implemented on chain that provides additional features like social recovery, batch transactions and other cool things you can't do with an EOA. Nosisafe and Argent are two existing examples. So it's clearly possible to implement it. But, and this is a big but they still require an EOA to pay for gas. With AA, smart contract wallets can pay for their own gas and you don't need the EOA anymore. The second use case we'd like to look at are mixers which anonymize transactions by batching deposits and then allowing different accounts to then claim those deposits. Tornado Cash is a prominent example today.
00:06:14.520 - 00:06:32.890, Speaker C: But the problem with mixtures as they exist today is that you need ETH in your account to claim the funds. So you need external relayers. Again, with AA, the withdrawn funds, the anonymized funds can pay for the transaction and you don't need the external relayers.
00:06:33.890 - 00:07:58.514, Speaker B: A third example is what we call like in app tokens. And so you can imagine that you have a DAP and the developer of the DAP wants users to be able to just interact with the DAP directly without having to worry about the Ethereum chain and Ether and basically jump through all these hoops, right? And so the idea is that you could just have users pay for interactions with the blockchain directly in DAP token. So that could be if it's a game that could be in game currency or if it's like a different DAP, there could be whatever kind of token, you just can directly pay the contract and then the contract just sponsors your transaction and so you still get all the benefits from directly interacting with the blockchain. You don't have to go through some indirection, but you don't need to learn about all these to basically ever care about mainnet and for things like onboarding, while you could obviously do it with your own account and with Ether, you can always also just use a signed message from the web creator. They could basically just give you a signed onboarding statement and then you can just go directly to chain again and execute that and be onboarded in the contract. And then the tokens obviously there can be real economic value tied to it. It can also be simply used as a limiting mechanism.
00:07:58.514 - 00:08:54.274, Speaker B: This is like a very extensive use case which we think could have many different applications. And also with AA, obviously it's all just native. And then the last use case which we call DeFi arbitrage, this is somewhat also to highlight like I would say, the limitations of account abstraction. But the idea let's start with that is obviously I think you all know what DeFi is, right? And so oftentimes there are just simple arbitrage bots that look at or try to find opportunities to have simple profitable arbitrage trades all within one transaction. And so what you'll commonly see on Mainet today is like a pattern where these bots send like a transaction to one of their own deployed contracts. Then the contract checks for opportunities for arbitrage and if they don't find any, they just exit immediately. But the issue is that obviously that is inefficient because then you have a lot of these dummy transactions that just exit immediately.
00:08:54.274 - 00:10:31.408, Speaker B: They just go to the contract check for opportunities, don't find any exit, but they still obviously take up all the block space, right? And so the idea is with AA what you would hope to do is you could also just tie the validity of these transactions to the existence of the arbitrage opportunities so they cannot ever make it to chain unless they are also willing to actually do something, right? And so that would be an advantage. But and this is important and we'll talk about it later a little bit more for many of the more advanced DeFi use cases, obviously your validity depends on probably on the state of multiple contracts and then it becomes very challenging to make these use cases work. So this is on the most advanced side of things and so one question that we often get before we then obviously next thing will be we talk about the actual technicalities of the AP. But one question that we always get is how does account abstraction relate to all these other proposals? There have been quite a few other proposals in recent times that also want to solve some of the usability issues around ethereum and specifically these two are somewhat related and so we want to briefly mention them. So the first one is ERP 20 711. This is sponsored expiring and batch transactions which is a really interesting EIP. It is mostly orthogonal to AA and so obviously AA itself decides if you want to pay for a transaction whereas sponsored transactions decide like who pays for that, right? It is important though to note that this specific EIP as it is proposed today is not compatible in the sense you could still have both on chain but AA contracts could not be sponsors then under this EIP.
00:10:31.408 - 00:11:19.632, Speaker B: And so we were working on an alternative specifically Sam is working on an alternative EIP as a pre compile that also does the same thing. It basically authenticates a message and then sets the message sender but it would be compatible. And then last thing obviously this EIP had like multiple individual proposals and so it is important to note that batch transactions, that is definitely awesome for existing accounts today, but it is to note that AA contracts as they are fully programmable, they are basically natively able to do batch transactions. You can just send them a bunch of call data and they can then do whatever processing they want and send multiple subtransactions. That's fine. So you get batch transactions natively with account abstraction and then the other EIP. I want to just briefly mention that's 28 three, that's rich transactions.
00:11:19.632 - 00:11:52.832, Speaker B: That's also really interesting. In case you haven't heard of it. Do look into it. But it only brings very limited execution capabilities to EOAS. And most importantly, it does not give you programmable validity what AA is all about, right? So what it does is basically it lets you execute some code against your count account, which is interesting, but it's mainly useful for batch transactions. And again, you get those for free with account obstruction. So let's now dive into the actual technicalities of how does the EAP work.
00:11:52.832 - 00:12:39.292, Speaker B: And so it's important to note that account obstruction has been around forever is a strong word, obviously in the blockchain space. So there's one very early EIP, ERP 86 that was authored by Vitalik and that's from February 2017 already. And that was called abstraction of transaction origin and signature. And that's basically where this already started. And the idea obviously can be traced back even further. The challenge so far has been that implementing account obstruction is a rather extensive change to the protocol and it's hard to reason about the exact safety implications, right? There are all these different actors and you could have safeties at multiple levels. And so this is the key issue that has to be addressed for counterproduction to actually make it to mainnet.
00:12:39.292 - 00:13:32.352, Speaker B: And so our approach was to split the changes of the ERP into two parts. The first one is the protocol consensus changes, right? This is what every node in the network has to support to be able to continue to process blocks after a potential fork. And we would really wanted to keep those minimal. So you can very clearly see that those are safe, that there's no problem with them. And then the other side for A, and I'll talk about that in a second, is that there are some issues around just networking and propagation of transactions. And so we focus on very restrictive, easy to reason about mempool rules in the beginning and then the idea is to then iteratively change those rules to add additional features and we'll go through them now in a second. So first let's have a quick look at the protocol changes.
00:13:32.352 - 00:13:55.850, Speaker B: So there are two main ones. The first one is the introduction of a new transaction type. People often ask with AA there is no such thing as an AA contract. So there are still only two kinds of accounts. They are externally owned accounts, often called EOAS and contracts. This doesn't change. What we basically do is we add new capabilities to the existing contract type.
00:13:55.850 - 00:14:35.332, Speaker B: What we do is we introduce a new transaction type. What even is a transaction type? Until now there's only one type of transaction in Ethereum, but there's already another EIP called 20 718 and that's typed transactions. So that introduces the option to have multiple different forms of transactions that will also be used. For example with EIP one five nine, if you know about this one and this is basically the mechanism that this uses. And also account obstruction would use that and introduce a new transaction type for account obstruction specifically. And just to very briefly compare the two, like current transaction on Ethereum. I just added a little list.
00:14:35.332 - 00:15:01.740, Speaker B: Basically, it's an encoding of the following fields. Basically, you have nons. Obviously you have gas price, gas limit, the recipient of the transaction, the value, the call data, and then three pieces of the signature of the transaction with AA actually, because a lot of that is now the responsibility of the contract. So the transaction itself becomes very simple. You only have nons target, which is the AA contract and data. That's all right. The rest is then up to the contract.
00:15:01.740 - 00:15:47.812, Speaker B: Specifically, the contract sets gas price and gas limit. Interesting to note for compatibility, because again, we are just using the existing contract framework. So a transactions will technically come from a special entry point address. The only purpose of that is just to initiate a transactions. And then the rest like signature, verification, whatever you want to do, you just do that with the call data that the transaction provides. And also interesting to note, obviously, because you don't have these more extensive checks upfront, the base cost of the A transaction will be slightly lower than existing transactions. So now, the second protocol change is two new opcodes.
00:15:47.812 - 00:16:18.528, Speaker B: And the first one is a simple one, it's just a nons opcode. Until now, you can't actually, like during execution, you can't actually access the nons of a transaction. But that is required because you have to be able to sign over all fields of a transaction. And so, yeah, that's more technical change. The other one is more interesting, pay Gas. Sam already introduced that, right? Pay Gas basically is the new way that a contract can say let me pay for this transaction. Obviously, you can only call that if you are within an AA transaction.
00:16:18.528 - 00:17:07.536, Speaker B: So if it's actually a transaction that expects to be paid for by a contract, and then the contract gives it just a gas limit and a gas price, and then it works just as normal transactions work today. PayGas also acts as a checkpoint, right? Because any changes, for example, the payment itself, but then also if you want to update your internal whatever nons or something, all of these, they're basically set in stone. As soon as you call PayGas, everything after can only revert back to Pay Gas. And then basically, this is like a kind of obvious one. An AA transaction is only valid if it has been paid for, right? So the contract that you call into at some point has to pay Pay Gas. Otherwise the transaction is not valid and can't be included. The last one is just a quick note.
00:17:07.536 - 00:18:01.872, Speaker B: The Pegasus Opcode is specified to be versions, so we can have future versions. For example, so we can also specify ERP, 100 flying compatible gas prices. So, now to the mempo rules. The first one, I hope you came away with the impression that the actual protocol changes are very succinct and easy to reason about. Now the mempo rules. And the question is, why do we even need them? For normal transactions, you always have very simple validity behavior, right? You check the signature once and if it's valid, then it can only ever be invalid if another transaction from the same account reduces the balance or increases the nons or something, right? And that means you can always just reliably chain multiple transactions together and still be certain that they will all be compatible and you can just execute them one after the other. For AA transactions, this is way more complex potentially if you don't do anything about it.
00:18:01.872 - 00:18:48.032, Speaker B: And the reason is that if a contract accessed any stage before it made the decision, if it wants to pay, right? And this state changes, then you just don't know what the validity of the transaction is. It might be that even with the new state, the contract still wants to pay. But it might be that the new state will lead the contract to no longer be able to be willing to pay for the transaction. So anytime any state touched during execution changes, a pending transaction could potentially become invalid. And that is a problem for miners. Because miners now, when they want to assemble a new block, they just don't know reliably that this is a pool of valid transactions, just pick one after the other. But basically they would have to revalidate and then discard.
00:18:48.032 - 00:19:26.524, Speaker B: And this is an issue. And as well, nodes in general are vulnerable to so called mempool wipes. Where you have like a mempool is just like your list of pending transactions. And it can like with AA, potentially what could happen is that a new block comes in that changes some state and all of a sudden your whole mempool that only consists of AA transactions is invalid. All of a sudden, all at once, right? And you really don't want that because that introduces quite a few inefficiencies. And thus obviously these are only problems if you do it like the naive way, if you don't have any protections. But the lesson here is miners and nodes need a protection mechanism against unpredictable transactions.
00:19:26.524 - 00:20:00.760, Speaker B: They can change their validity whenever. And there are two restrictions that we introduced. The first one is an Opcode restriction. It's a full slide, but I'll just glance over it because the idea is pretty simple. The idea is just you don't want AA transactions to access any external state, right? The idea is they should only rely like before they decide to pay, after they can do whatever as normal transactions will. But before they decide on payment, they are only supposed to look at their own internal state of the contract, not look at the outside world. And you just do that by having a list of blocked Opcodes.
00:20:00.760 - 00:20:58.360, Speaker B: I won't go through all of them, but it's like the obvious ones. You're not allowed to look at the balance of other accounts, not at their code, not at state of other whatever, right? You're just not allowed to look at external state and this is not enforced by the protocol, right? You could still have a transaction that violates these rules, like in a block, that's fine. Where it is enforced is at the individual nodes. If you're running a node and it has a Mempool where it stores pending transactions, if the transaction violates this rule and accesses excellent state, you just don't keep the transaction around because it's unpredictable, it could change validity at any point, you just don't keep it around. And that way you know for certain my transactions can only be invalidated if their own state changes. And this is the first part of the two part solution that is very important here. And later on we'll talk about how you can then loosen these restrictions safely.
00:20:58.360 - 00:21:27.944, Speaker B: But let's first talk about the second part. The second part is what we call a bytecode prefix. So contract code, obviously that's just like a bunch of bytecode and that gets executed when the contract is called. And the idea is so what do we want to achieve here? We want to achieve that. We already achieved that you can only look at your own state for validity. But now what we want to do is we want to prevent other transactions from changing your state. So it's basically only you can only rely on your state and only you can change that state.
00:21:27.944 - 00:22:24.932, Speaker B: That is the goal. And so how do we prevent other transactions from touching the state? Well, guns were very simple, right? The prefix, the beginning of the contract code just has to have this simple prefix which basically just you just ensure that the transaction came directly from this entry point, which again, this is like this special address from where all AA transactions come. And if it doesn't, you're only accepting ETH deposits. So you just log a little receipt message, I mean, and then you just immediately return. And that way, like every contract that has this prefix, you know for sure that its state can only change via AA transactions. It cannot be modified from the outside. And this is really important because now if you just don't keep transactions to contracts that don't have this prefix and you also follow these restricted opcodes, then your Mempool is basically safe, right? Any AA transactions you have in your Mempool, they are safe.
00:22:24.932 - 00:22:57.780, Speaker B: They can never misbehave, they will always remain valid. If you are minor, you can always just take one after the other to include it in your block. All of these rules that you need, all the invariants that you had with the normal transactions, now also hold with AA transactions. And again extensibility, you can add multiple known safe prefixes. And this is important because now what we want to talk about after we talked about these restrictive rules, now we want to talk about how can we relax them, what kind of additional features can we bring to AA safely.
00:22:58.760 - 00:23:47.140, Speaker C: So the EIP 29 38 that we've described so far is useful mostly for single tenant applications, applications that are used at most by one person. These extensions expand that to allow for more complex prefixes, more users using the apps they take it from a very basic to a very full featured account abstraction implementation. So the first extension we want to talk about is delegate calls from AA. So this is say you have a library like Safe Int or Safemath and you want to call that from an AA contract. You do that with delegate call and this is safe to do, but it's only safe if the call target exists. So we introduce a new opcode set indestructible which obviously disables self destruct. So this gives you libraries and upgradable smart contract wallets.
00:23:47.140 - 00:24:36.880, Speaker C: Another really useful feature that we pretty much need is static calls into AA. So this gives you read only access to an AA contract. Now, this would always be safe because a read only call can't invalidate transactions, but we can't currently differentiate between static contexts and read write contexts. So we introduce new opcode is static, which remains true, returns true if the context is static. So this lets you read things out like exchange rates or smart contract wallet balances from AA contracts. This is probably the second most useful extension to AA which is read write calls into an AA contract. So the mempool wipe that Anskar described earlier is probably the biggest problem with read write calls into AA.
00:24:36.880 - 00:25:28.576, Speaker C: A single transaction would be able to invalidate tons of AA transactions and wipe nodes mempools we want to prevent that or at least make it safer. And the way you do that is by preserving the amount of gas an attacker would have to spend to wipe the ratio of the amount of work that would have to be revalidated to the amount of gas spent on chain. And the way we do that is by introducing a commit gas opcode. This establishes a lower bound on the amount of gas the AA contract will consume and it'll be called by the AA contract when it's invoked by a non AA transaction. So this enables deposits ERC, two, two, three tokens and surprisingly allows an AA contract to sponsor another AA contract. And we'll get into that a little bit more later. This is probably the most important extension to 29 38, which is multiple pending transactions.
00:25:28.576 - 00:26:21.008, Speaker C: So this lets you go from a single tenant application like a smart contract wallet to a multitenant application like a mixer or an exchange. This lets an AA contract propagate more than one pending transaction. In normal operation, the nonce is chosen by the person who creates the transaction. With this extension the miner chooses the nonce for the transaction immediately before EVM execution. That lets the AA contract choose its own replay protection and basically it can ignore the protocol. Nons the downside to this is that every time an AA contract state changes, all of the pending transactions for the contract have to be revalidated. This revalidation effort is bounded though, on a per transaction gas limit and a per contract cumulative gas limit.
00:26:21.008 - 00:26:55.490, Speaker C: And again, this enables very efficient multi tenant applications. So there's an interesting property about validation. Some parts of validation are pure, meaning that they can never be invalidated. Normal ethereum transaction signatures are a great example of this. So are ZK proofs. Once these pure validation portions are shown to be valid, they can never be invalidated. If we can cache the results of these validation steps, we can enable significantly higher validation limits since you don't have to repeat the validation every time.
00:26:55.490 - 00:27:40.848, Speaker C: The way we enable this is by adding a new prefix where the AA contract calls into itself and that creates a cache point where the EVM can intercept this call and cache the result of the pure validation. Now, to make this a little bit more efficient or elegant, we can introduce two new opcodes pure call and Is Pure, which detect perhaps obviously if the call is pure or not. Or we can just rely on mempool rules. We don't need a consensus change for this. And what this gives us is a lot more gas for ZK proofs. Building on top of that, we can actually increase gas limits even further with this dynamic validation gas limit. So well behaved contracts can commit to a minimum gas spend.
00:27:40.848 - 00:28:29.390, Speaker C: And if they do that, we can increase the amount of validation gas limit. The limit can be increased safely because we maintain the same ratio of on chain gas to revalidation work if an attacker were to try to wipe mem pools. And this gives us even more gas for ZK proofs and even more importantly, more pending transactions per contract. We've also been working on a sponsored transactions EIP that is complementary to AA, and sponsored transactions is where a sponsor pays the gas for another user. Unfortunately, EIP 2711 is incompatible with AA. So we're just introducing a pre compile that sets message sender based on an ECDSA signature. This lets you pay for gas and tokens, which is pretty exciting, I think.
00:28:30.500 - 00:28:52.340, Speaker B: So now we have like a summary slide. Unfortunately we are running out of time, so I think we should just skip it and directly go to the next one. But if you're interested, Vitalik recently gave like a really great talk about account abstraction at a meetup and there's a YouTube link at the end of our slides where you can go and listen to him. I would definitely recommend that. And he talks about that extensively.
00:28:54.120 - 00:29:12.540, Speaker C: So just a quick summary of where we are right now in the EIP. So EP 29 38 is a draft in the EIP's repository. I recommend checking it out. There's a link at the end. We've had some light discussion on the all core devs. Meetings. We want to move it to Considered for Inclusion soon, where we'll join the pool of pending features that can be added to hard forks.
00:29:12.540 - 00:29:26.290, Speaker C: We, as in Quilt, are aiming to get this into the hard fork after Berlin, which is the next hard fork, but we're really not sure if this will ever arrive on Mainnet, but we're really hopeful it will and we hope people find it useful enough to include it.
00:29:26.820 - 00:30:36.650, Speaker B: And just as a last tie into the very first day of these talks, if you remember, Vitalik talked extensively about the roll up vision, the roll up centric vision for e two, where basically e two becomes more and more and more of like a L2 management layer. And most of the scalability actually comes from execution on these L2 solutions. And so basically one question that we think is relevant not only for account abstraction, but for features in general is like, do you want to keep extending the base chain with all of these additional features or is it a better fit to just bring them to the rollups directly? And we are very open to the possibility that AA will not ever make it to Ethereum, Mainet because it's just not a priority. Although at the same point, there are some synergies that you would also get regarding L2 management with account abstraction. And so we are still confident it will provide added value. But this is definitely like a conversation that I think will be more and more important going forward. So we wanted to mention it, but with that, yeah, we want to hear from you.
00:30:37.980 - 00:31:04.930, Speaker C: Does account abstraction make your DAP use case easier? Could it? If it does, what extensions do you need the most? Is there anything else you could use, and do you think this is something that you would love to have in Mainnet, or do you hate it? Either way, please contact us on the ETH, R and D discord links here and also at the end. Yeah, so thank you very much and I think we have a few minutes for questions, but I'm not sure.
00:31:05.780 - 00:31:34.410, Speaker A: Wow, that was a very extensive overview. Thanks so much. We do have some questions and there was also a lot of discussion already going on during your talk in the chat, so also feel free to check that out later. But I want to relay at least one or two questions to you guys now. The first one being around backwards compatibility. Which parts of account abstraction are backwards compatible and which ones are not?
00:31:35.760 - 00:32:16.010, Speaker B: So I think what we tried is to basically have the changes be as minimal as possible and that includes having backwards compatibility. And so basically the idea is just existing contracts today because this new opcode, this Pegasus Opcode, is not yet in existence and so existing contractors don't use it. And so your existing contract will not be able to ever upgrade to an AA contract. But what you can do is existing libraries, as we said, can still be used. And so there would definitely have be the need for a one time migration to AA contracts if you want to use them, but there's nothing that would break or anything.
00:32:17.580 - 00:32:27.660, Speaker A: Okay. And then another question. Would ecosystem infrastructure need to be updated or integrate some special considerations to benefit from account abstraction?
00:32:28.640 - 00:33:02.650, Speaker C: I would say yes. Wallets are definitely going to have to change to support the new transaction type. You're going to have to introduce like Block explorers are going to have to handle the new transaction type, and they're also going to have to handle the UI of not exactly having a two and having a target. Instead, transaction hash uniqueness is another big one. So during EIP 29 38, we do maintain transaction hash uniqueness all the way through. So that one's a very minimal change. But in some of the extensions, transaction hash uniqueness changes a little bit and that'll require some work in the infrastructure as well.
00:33:03.740 - 00:33:10.200, Speaker A: Okay. And then last but not least, what is the difference between this and the gas station network?
00:33:15.020 - 00:33:15.976, Speaker B: Go ahead.
00:33:16.158 - 00:33:32.480, Speaker C: I was going to say so this is very complementary to the gas station network. Instead of having external nodes relaying these transactions, you could have a gas station network contract fact on chain that handles some of the work for paying for these relay transactions.
00:33:34.100 - 00:33:48.990, Speaker A: Okay, amazing. Yeah. Please do check out the chat because there's been a lot of discussion during the presentation. But now, due to time, I will not relay all of the remaining questions and move over to our next.
