00:00:07.290 - 00:00:27.878, Speaker A: So good morning everyone. Well, good afternoon. Actually. Welcome to East Global. The first talk. And yeah, today we have some sweet things for you. Ideally, I'll be talking about some of the things that developers fall in love when you embrace them, when you discover them, when you think, okay, how going to be doing this before? Right, let's get started.
00:00:27.878 - 00:00:54.110, Speaker A: So we are in 1970. Welcome to Digital Equipment Corporation. The computer they released was called PDP. How did it work? The entire system was basically one program, right? And if you needed to change something, basically there was one program running the entire thing. There used to be one program for every architecture. There was no way to add to remove. It was basically something monolithic.
00:00:54.110 - 00:01:36.730, Speaker A: But then came operating systems. So you have a trusted kernel that can basically do everything it likes. And then you have untrusted programs that interact with the kernel to do things so that you can have many programs and you can basically forget about what's behind. And how does this look like. So Adobe would have, let's say the T is the network, basically the things that the hardware itself. And then below you have different programs that might need to interact to these resources. So for example, if you want to use Spotify, spotify will talk to the kernel in a kind of standardized and abstracted way so that it can use the speaker, so that it can use maybe the network display, whatever.
00:01:36.730 - 00:02:13.794, Speaker A: Right. But fast forward into the future. Where are we, let's say 50 years later in, let's say, 2017? Yeah, well, I think we're at the same place because back at the time, every protocol that needed to be made had to be made from scratch because there was nothing to build an abstraction on top of. Right. So basically, well, writing the entire protocol every single time, there was no way to add and remove features. There was no way to easily customize things. But then this change, this started to change when Argon in 2017 released Argon OS, the first version.
00:02:13.794 - 00:02:49.714, Speaker A: It was the first solution to a problem. It was revolutionary in many terms. And still as of today, it is unhacked, it's very robust and it worked based on templates. Right? So different templates for NGOs, for associations, for for profit companies. And it was good for some of these use cases, but at the same time, it had some challenges for it to be used in simpler use cases. And some of the lessons learned is that there are not two equal communities. Two dows are going to always need different things.
00:02:49.714 - 00:03:32.138, Speaker A: They are going to have different flows. They are going to require something unique to them at the same time. The same dow always evolves over time. You can start today and you have no idea of what your community is going to look like in the future, what you will need. And you cannot, I mean, it's super hard to design for this ahead of time. And another lesson being learned is that many times Argones has been forked and has been implemented for very big projects like Lido, Decentraland and so on. The thing is that this is not ideal because you need to fork and maintain a big code base, right? So if you can extend instead of forking and maintaining a whole thing, that's a big bonus.
00:03:32.138 - 00:04:40.882, Speaker A: And for this, this year, in 2023, March this year, we have released OSX, which is basically a massive leap forward, which consists of two components. So we have a Dow core, and then we also have untrusted plugins or external addresses, let's say contracts that can interact with the Dao core. Doesn't it sound a bit familiar to you? I think it should, because basically we're talking about the same concept of an operating system, which is there are some plugins, some contracts, some wallets that want to use the Dao. They want the Dao to do something with shared resources, pretty much like programs do in an operating system. So for example, if a plugin wants the Dao to transfer some dai to another address, there will have to be some governance proposal on the plugin. But essentially the plugin will need to have permission to go to the dow. And then the Dao internally has a permission database, which is basically the bible of everything that can happen within this community, right? But then we've been talking at least the title is about the Unix of Ethereum.
00:04:40.882 - 00:05:25.446, Speaker A: Let's get a bit into this. What's? The Unix philosophy. If you're developers, you're most certainly aware of some of the basic principles of it, which is writing programs that can do one thing and do it well, right? Doing components, building programs that can work together, that they can talk to each other very easily, that you can compose, that you can combine and architect something bigger than just the program itself that needs to grow indefinitely. And also flexibility. If you build small pieces, these small pieces should be able to work in many scenarios, not just for one specific use case, right, that should be reusable by many other tools. So again, you can build more complex things and more interesting things. This is a very simple Unix program.
00:05:25.446 - 00:06:25.298, Speaker A: All it does is just opening a file, reading some data and reading it back, writing it back, et cetera. The blue dots here, the blue functions here, they are the absolute simplest things you can find. You don't have an open file function, you don't have a write buffer wired, no. You have a generic function that works everywhere for every single kind of thing. But on top of this, for example, with programs like the one we had here, imaging, we compile this, we eventually have a layer on top in which we can start composing some of these programs, some of these binaries that we made to make something more interesting, more complex and more tactical way. How do we translate many of these terms? Let's say for ourselves, for Aragon OSX? So in Unix, everything is a file, okay? For us everything is a permission. Because eventually you want to execute something, right? There are system calls like read, write, exec, etc.
00:06:25.298 - 00:07:05.218, Speaker A: For us there is dow execute, asking the kernel to do something permissions for example, change mod, change group, change owner. Well, we have granting and revoking permissions. And then we have some of the basic utilities like LS, Copy, et cetera, which are some of the plugins that we ship ourselves. And some of the plugins that anyone can do, can be a multisig, can be token voting, et cetera. There are some additional guiding principles that we have inherited not only from Unix, let's say, but some other languages, like for example, Rust. We like there to be only one correct way of doing things, right? We like clarity, we like developers. We want developers to be explicit about they do.
00:07:05.218 - 00:07:47.838, Speaker A: If this code is going to be audited, it needs to be obvious what the code is doing. We don't want any hidden magic behind the scenes. At the same time, we want people in general the community to only pay for the gas for features that they need and that they are using. Just no hidden bloat, not just shipping 20 million things that you don't use, but they are there, right? And it needs to be easy to understand and to reason about because after all, it's all about security. So then let's start talking about plugins. Because Argonize X is basically about a community, is basically something valuable that needs to be protected by many people. There needs to be many people behind for this to be secure.
00:07:47.838 - 00:08:37.380, Speaker A: And for this we need plugins. What is a plugin? Basically a plugin is our way to solve a small problem, a small custom problem. Following the Alex follows a fee. So make it simple and stop remaining the wheel. Basically reusing everything else that we as argon offer for free. Basically plugin versioning upgradability, so shipping new versions, allowing people to easily upgrade to the newest features that you ship, maintaining data, maintaining statuses, using the permission management system which is one of the top most beloved things about the initial versions of aragonos. Also interact with other plugins, also combine different plugins together to achieve the custom scenarios that your dow needs and more that we're going to see really soon.
00:08:37.380 - 00:09:26.422, Speaker A: And the end goal of this is stop reventing the wheel because we want to ship fast, because we don't want to be rewriting things that have been already solved in the past. So how does a plugin look like? So first of all, the green box here is let's say the plugin that for example, we would like to have a multisig, okay? But at the same time we're going to need what we call the plugin setup just above, right what does this plugin setup do? It's a contract that the developer does which manages installations, updates of the plugins and uninstalls. It's basically a script in which you can do basically everything. On top of that, when you want to publish a plugin version, you publish the plugin setup. We have a registry and then in this plugin registry you can create your own repository. You even get an ENS if you want. And then you keep publishing different builds.
00:09:26.422 - 00:10:24.750, Speaker A: If you choose your plugin to be upgradable, people will be aware that there is a new version. They can create a proposal and they can get the latest and greatest features that you just ship to them, even yourself. And then on the other side there are all the goodies to just make all of these accessible to UIs, to any applications that you can think of. So in the end, what's the landscape that this leaves us? Let's see so as I said, there are not two dows that are exactly equal. So most likely you could, for example, want to start with a dow with maybe one multisig plugin and then maybe eventually install another one, maybe install a token voting one and maybe the feature maybe you want to do off chain voting and you install a third one and you decide that you want to remove one of the other ones. So you're basically decoupling, let's say, the shape of your dow, the shape of your community from how the actual dow works. So for example, here at the top, imagine that there are many operations that the dow can perform, many functions.
00:10:24.750 - 00:11:18.638, Speaker A: These functions, they have different roles associated to them. When you install a plugin, you grant it some permissions and depending on the permissions of this plugin, the address can perform these operations. Right? But if tomorrow, for example, I decide to remove the multisig plugin, let's say I am doing a clean uninstall and then I could install maybe not a multisig, but that token voting that could do the exact same thing, but with a different logic. So you're basically setting yourself to be feature proof in terms of evolving, operating without committing your dow to be, as it is today, forever. So let's see some code because my whole point in this presentation is to show you how easy it is to do a plugin. So this is the absolute most simple plugin that you can get. All you have to do is inheriting from plugin clonable, for example, or from plugin ups available.
00:11:18.638 - 00:11:45.502, Speaker A: You get for free all of the tooling. You can just simply forget about the rest. In this example we have a plugin. What it's doing is preparing a list of actions. And these list of actions, eventually we connect to the Dao to which this plugin is linked, let's say, to which this plugin is listening to the permission database and we're asking the Dao to execute these actions. That's it. That's the hello world.
00:11:45.502 - 00:12:30.700, Speaker A: That's the hello Dao, let's say plugin that you can build. What if, for example, our plugin wants to start using some additional permissions for itself? What if we want to restrict the plugin itself? We don't want just anyone to go there. We want some function to be guarded. So first of all, we will need to create here our own permission ID which is basically by 32, computed by hashing some value. And then below on the function that we want to guard, we are going to add this modifier. This is the basic building block. Then only the people who holds the permission, in this case my plugin permission ID on the Dows database is going to be able to use this.
00:12:30.700 - 00:13:17.980, Speaker A: This is something fluid that you can grant, you can remove, you can evolve, you can iterate, you can have another plugin with a different logic, you can have a different version of this plugin with maybe fixing a bug, et cetera. So it gets really flexible for you to just evolve. How does a plugin setup look like? So there is the Iplugin setup interface which is basically the method that your install script should implement. So this is a two step process. Step number one you prepare the installation, the update or the uninstallation of a plugin. And then step number two, Dadao has a proposal and eventually the community accepts and decides to apply the permissions that you have requested. And essentially the plugin becomes installed, updated, whatever.
00:13:17.980 - 00:13:45.090, Speaker A: Here you have some example of one of our own plugins. So the Motorsick plugin, what you have is a constructor. We do the initial deploy to have, let's say, the implementation on chain that we will then carbon copy. We don't need to deploy every single time. So we use proxies. So in this example, what we do is pre installation. Your function will receive some parameters that you're going to encode with the settings of this particular plugin.
00:13:45.090 - 00:14:27.906, Speaker A: And then you can just simply copy this line that we provide you the tooling to just use it. And then this creates a proxy with your specific plugin instance you get your very own plugin. And then the last step is requesting permissions. This may seem about Burpos, but essentially what we're doing here is, well, we're building a list of permissions. So we're saying please allow the Dow to upgrade the plugin settings or please allow the Dao to upgrade the plugin itself. And at the same time, oh please Dao, allow the new plugin to use, to do execute or to do something right. So you do your wish list of permissions and then the community assesses whether they like them or not.
00:14:27.906 - 00:16:04.314, Speaker A: And eventually if they approve them, these three permissions here are going to make it to the Dow's permission database. Okay, so what is a permission? As we saw before, basically it's a source of entropy, a string hashed which is then a number. And we use it to shield functions and permissions they look like granting permission to who to do what on where. So allow the dow to do this on the plugin but what if we want things to be a bit more, let's say more granular? What if we want some conditions to be a bit more restricted, right? So you can use permission conditions which is nothing more than a contract that you can define, right? So for example, when you have some plugin trying to execute some operation you could tell the dow okay, whenever someone wants to perform this action, ask this contract and if this contract says yes, you just continue, right? So they allow for us to basically decouple the fact of the features themselves with the restrictions. And this prevents things like plugins going super complex because you need to combine a matrix of I want to do this, but not that, but yes, but no, it gets extremely complicated. If you can decouple these things, again, you can have very composable, very modular things, a very modular protocol, without needing to rebend the wheel because most of the time, some of these conditions will have been implemented by someone else. Same as plugins.
00:16:04.314 - 00:16:58.740, Speaker A: Some of these plugins will have already been implemented by someone else and you can just pull them and get, let's say, their upgrades for free as well. So in the end, permissions for us would look like grant permission to a certain contract to do a certain role on some target optionally when a condition is met and with this you can just go and build the moon. So this is how simple a permission contract would look like. The only thing it would need to implement is basically the is granted condition. It would receive the parameters of what is being attempted to do and eventually it needs to return yes or no in this case, first parameter being greater than the second one. So this is all I've got for you. There's much more you can just find us Carlos and Juliet we will be here around.
00:16:58.740 - 00:17:37.194, Speaker A: We have here a couple of plugin examples for you. So one is an example of a plugin to understand how it works and the second one is more of a project in which you get a plugin and you get also all of the integrated testing and some JavaScript. Client for it to connect on a UI and also some basic subgraph indexing in case you want Uri to be more user friendly. And all of this, feel free to take pictures of these QR codes at the same time. You can also go to Devs Argon.org and you'll get all the whole documentation of the protocol. And also you can join us on Discord.
00:17:37.194 - 00:18:56.310, Speaker A: So some people from the community are very active, also helping around. And, yeah, the TLDR for me is the sky is the limit. If you don't have to remain the will to build the next big thing and you can focus on customizing only what you need and recycling everything that there's around then basically you're ready to go build the absolute next big thing. So that's it? Pretty much. I'll be happy to ask many questions and expand any of the topics that you think for the presentation. I would have a question about the initial deployment of a DRO. Does the initial deployer or owner needs to write code as a smart contract to set up everything and to include plugins? Or is it just a call to an existing contract so you could decide to deploy it yourself, but most likely you want to use something that we call the Dao factory, so you call the Dow factory, which is a contract that we deploy ourselves, is there.
00:18:56.310 - 00:19:40.660, Speaker A: And then you pass it a list of the plugins that you want it to have. Right. So by default, the deployer, if you happen to deploy it yourself, you would be kind of having total permission on it with the intent of installing a plugin and then dropping this permission and yeah, can give you more examples on that. Absolutely. But yeah, there's a contract that does everything for you. Thank you very much for the speech. Can you please tell us what are your most popular plugins for now, which you created, I mean, your team and what are custom plugins your clients and other dows created that are very commonly used? So we ship four standard ones.
00:19:40.660 - 00:20:28.914, Speaker A: We ship the multisig plugin. We also shipped another variant which is called the Address list, which is a version of it which is intended for everyone to vote. Whereas in a multisig you only expect some people to just say, okay, in an Address list you have an explicit list of address and they vote. And then you have the volition of this, which is token voting, so you can vote with an ERC 20 token, et cetera. It supports delegation, it supports many other things that you expect. Then there is another interesting plugin, interesting, we call it internally the Dictator Plugin, which is basically the admin plugin in which one address is able to do everything. This in cases that, for example, you need to experiment or you need to kick start the dow, you could manually grant permissions to yourself.
00:20:28.914 - 00:21:11.650, Speaker A: But the idea of having a plugin, the benefit is that everything is encapsulated. You just add it as a whole and remove it as a whole. So you could start us with this plugin, then upgrade to multisig, then upgrade to any of the other ones that you would say regarding what the community is doing. I don't know, maybe Juliet Carlos can expand on this. But the idea as of now, depending which we are, is people do their custom thing. It's not that they're just publishing plugins around. This may well become, let's say, the next step, but at this point it's more like not needing, I mean, being able to recycle and just adding the extra plugin that does this very small thing that any of the existing plugins could not possibly solve for you.
00:21:11.650 - 00:21:18.900, Speaker A: Not sure if this replies the question. Hi, can you hear me? Yeah, I guess.
00:21:19.350 - 00:21:32.680, Speaker B: Thanks for your presentation. I'd like to ask if I'm going to use the Aragono Six, will I be able to use the auto generated client as it is done on the Aragon app?
00:21:33.530 - 00:21:42.220, Speaker A: Sorry, I have it. That trouble. Could you speak a bit louder? Yeah, so I can close the door? Thank you.
00:21:48.150 - 00:22:01.660, Speaker B: Yeah, thank you. So let's say I'm going to use the Argonio Six to create my dow. Will I be able to use auto generated client as it is done on the Argon app?
00:22:02.190 - 00:23:08.320, Speaker A: So what we ship is the Argon SDK, which basically provides all the tooling to interact with basically ethereum IVFs and subgraph. Okay. Then on top we built abstraction layers so that you can interact with anything related to the Dao in general. But at the same time, we also sorry about that. So the second example here you get an example of a JavaScript client that uses the SDK to just add the custom things that you need for your client. So the idea is that you get maybe 95% of that tooling there and you can just right away start calling web three, call this contract or IPFS, fetch this data, et cetera. So it's not auto generated because the custom bit that only, you know well, you know, what do you want? We can't possibly know how you intend to use for example, maybe you want to use the graph, or maybe you want to use a back end and index something there, or maybe, I mean, there's no general rule here.
00:23:09.330 - 00:23:18.334, Speaker B: And last question, could I use SDK to work with already existing one dows that are created from the client as.
00:23:18.372 - 00:23:20.462, Speaker A: Well from the app? Yeah.
00:23:20.516 - 00:23:23.586, Speaker B: For example, to fetch the data to get all of the dows, as long.
00:23:23.608 - 00:23:54.106, Speaker A: As you can basically call the contracts, as long as you from JavaScript, you can simply fetch the information, obviously. Yeah. So again, the message is the SDK gives you all of the building blocks for you to build. On top, we use it ourselves to build our own plugin clients. Right. And you can just replicate this, just write the custom 5% thing and forget about the rest because we did it great again. So.
