00:00:07.050 - 00:01:02.670, Speaker A: All right, welcome to the ETH Bogota hackathon workshop. I'm Josh Kites, and I'll be talking about Aztec Network. And my colleagues will come in a bit later and share some details on building bridges with Aztec and using our domain specific programming language for writing zero knowledge proofs that we're developing as well. Yeah, we're really excited to be sponsors for ETH Bogota, and we're excited to support you guys in learning about the Aztec network and building some cool new applications. So in this workshop, I'll do a brief overview of what Aztec is, talk about some hackathon specifics, like prizes and some resources that you guys can use to learn leading up to the hackathon. I'll cover some specifics around the SDK. Laisse will cover building bridges, and then Maxime will cover Noir.
00:01:02.670 - 00:01:56.500, Speaker A: So what is Aztec? Aztec is a privacy focused network deployed on Ethereum right now. So it's a scaling solution on Ethereum built on zero knowledge proofs. So it's actually recursive zero knowledge proofs. So for the privacy aspect of the network, users are generating zero knowledge proofs to verify ownership of specific assets. Those are sent to a roll up back end and users encrypted. Transactions are rolled up and then published to Ethereum Layer One. This provides some unique capabilities that other roll up designs do not have.
00:01:56.500 - 00:02:57.480, Speaker A: Mainly, we have this capability of doing a ton of transactions with the rest of the Ethereum Layer One network directly from the L2. So that means I can enter and exit a DFI position directly from the Aztec roll up and not have to withdraw my funds to Ethereum Layer One to do that. So you can do like, basic, ERC, 20 transfers. You could do DFI deposits or DFI claims. And really, since the Aztec roll up processor contract lives on Ethereum l One, and it is designed such that it can be manipulated by any user with assets on the roll up, the roll up processor can dispatch these funds out to the rest of the Ethereum Layer One network. So Lasse will talk a bit more about how you can connect the roll up processor with essentially the rest of Ethereum with these bridge contracts. It's a really cool feature that Aztec has.
00:02:57.480 - 00:03:49.074, Speaker A: And one benefit of that is, like, all of these DeFi interactions that you'd be doing from Aztec are actually private. So what you see on Ethereum Layer One is just that some user from Aztec send a transaction out into Ethereum layer One, did some DeFi interaction or other interaction, whether it's like on chain voting. I saw someone at East Berlin recently made a private voting contract. We're thinking about what NFT contracts might look like. What capabilities can we get with private NFTs? Things like like, this has been deployed for a few months now, so it's still relatively new, and we're just starting to really build out this ecosystem. It's really cool. So, yeah, on the Aztec network, you get cheap private DeFi.
00:03:49.074 - 00:04:46.934, Speaker A: So you don't have to interact with Ethereum layer one, you can just send assets privately on the Aztec network itself, cheaply, since it is a roll up. So if you're transferring assets within the Aztec network, you get complete privacy where you don't know or nobody else on the network knows who the sender or the recipient of the transaction is, or the transaction amounts when things are going to or from Ethereum layer One. Obviously, amounts have to be public. If you're depositing funds, you know, it's public information which address is depositing to Aztec. Or if you're withdrawing funds, it's public information which address the funds are going to as well as the amounts. So, yeah, all states on Ethereum are still public, but Aztec adds some new capabilities. So as I said, Aztec is a roll up of a roll up.
00:04:46.934 - 00:05:49.220, Speaker A: So what's really happening is we can roll up a whole bunch of transactions, especially if these are like DeFi interactions. Let's say there's a handful of positions that are swapping ETH for wrap staked ETH on Aztec. These interactions can be rolled up into one transaction. Those rolled up transactions can then be rolled up into another layer by the backend infrastructure. And that roll up is then published to Ethereum as well as the transaction information needed for data availability to recreate the state of the Aztec network. So, yeah, Aztec is recursive zero knowledge roll ups. I want to share this QR code.
00:05:49.220 - 00:06:13.046, Speaker A: This is actually this Google Doc right here. This is Ebogata hackathon resources list. We're adding to this page right now. So we have our testnet. There's information here about how to connect to it. Our Block Explorers general developer resources we're adding to this list. So this is kind of like our one pager.
00:06:13.046 - 00:06:50.710, Speaker A: Go to Resource guide for people that are starting to or developers that are starting to build on the network. So a lot of the information that you might be looking for will be here. If you need more, definitely feel free to reach out to us. You can always ping me on Discord or Twitter. My discord is Josh C pound one or Twitter at Cratesjosh. So that's a good guide for just, like, resources for developers. I want to touch a bit on the prizes that we're offering.
00:06:50.710 - 00:07:39.240, Speaker A: So we have $20,000 worth of prizes up for grabs. I think it's ten K for first prize, five K for second prize, and then third and fourth prize would each get $2,500. Those last two amounts might not be exactly correct, but something like that. So we have a list of projects that we'd like to see. We'll publish more information about this on our Twitter, and you can reach out to me if any of these sound interesting. But we're thinking about things like Private NFT Bridge. I know Joe's been thinking about this, so he's got some details that he could share.
00:07:39.240 - 00:08:33.026, Speaker A: We'll also be happy to talk more through the specifics of what these can look like at the hackathon. So if you guys are interested in building this, reach out to us. And we want to see these things built as much as you guys might want to build them. So we're definitely interested in collaborating with you guys and just helping you build cool stuff. So, yeah, private NFT bridge is one or just like thinking about ways that using NFTs privately in really any use case that you guys might come up with could be interesting. We have existing bridges like swapping for wrap, staked, ETH, entering element positions. We have some published bridges that we haven't deployed yet that we're going to make available for the hackathon on the testnet.
00:08:33.026 - 00:09:15.890, Speaker A: So then when those go live on main net, you guys could have one of the first interfaces potentially. So seeing these front ends, like we have a dollar cost average bridge that's in its final stages of being audited. So that would be like you can deposit some die and then just specify, I want to buy like $10 worth of ETH every day for the next however many days. So this is just like a nice automated way to dollar cost average into ETH. Or you could go the other way for selling. It'd be cool to see like a payment streaming front end. We actually don't have the bridge written for that yet, but that would include like you need to write a bridge contract and then do streaming payments.
00:09:15.890 - 00:10:04.786, Speaker A: I think payroll is a really interesting use case for Aztec. A lot of people don't want to make their payroll information public. We have an audited 4626 vault standard, and since that's a standard across DFI, we can make it very easy to just add any protocols, DeFi protocols that support the vault standard. It would just be like a contract that we'd have to add to the bridge contract address. So building a web interface for interacting with vault standard contracts would be really nice. Also liquidy, we have a liquidy integration for entering positions. It'd be cool to get support in a liquidy wallet for actually interacting with this.
00:10:04.786 - 00:10:44.414, Speaker A: So hopefully we have the liquidity bridge on our testnet. I'll publish a list closer to the hackathon dates of the actual bridges that we're going to have deployed on the testnet that aren't on main net yet. Those will be fun to hack on. Something that I'd be really interested in seeing is a standalone application for account management. We have Zkmoney, which is a let's just go to it real quick. I'll go to it on my testnet account. I'll probably be doing this on the demo, but it allows you to deposit funds, register an account, enter some DeFi positions like element lido.
00:10:44.414 - 00:12:10.166, Speaker A: We have Urine live now, but the wallet I can send shield, I can register an account. So it would be cool if we had an application that did account more specifics around account management, like being able to recover an account that you lose the keys for or do account migrations. We have these things in the SDK, but we don't actually have an application that can do these things yet. So kind of a wallet that's more focused on account management, not just like managing funds, because Aztec does have this interesting account abstraction model built in the way account notes work in our infrastructure. Another cool thing could be an AirDrop manager. So creating an application that could allow people to AirDrop tokens to users, but on Aztec, so this would all be private. The docs would be a really good thing to reference if you're interested in building this, just in terms of how accounts work, how account keys work, how you could design a system where someone sends funds to an account and then shares a private key, or there's different mechanisms that we can make this work.
00:12:10.166 - 00:12:55.078, Speaker A: But I think an AirDrop manager would be cool. Airdrops have been obviously a big driver for user adoption in Ethereum, so making the same for Aztec would be sweet. With that, I think I will go into building with SDK. I want to show here I'll go to the made this repo. It's essentially a command line tool. It's a command line application for interacting with Aztec. And it's basically just a command line wrapper around the SDK.
00:12:55.078 - 00:13:29.814, Speaker A: So I'm kind of using this as the kind of like reference code for the SDK. I've been working on it pretty regularly and it shows a lot of the features of the SDK. So kind of want to just go through some of this code and show what the SDK can do. So, yeah, it's just at CLI. If you guys want to clone it. Let me hide this. We can look at my Vs code.
00:13:29.814 - 00:14:14.722, Speaker A: So this is a oak cliff command line tool. And I'll highlight the pieces of using the testnet first. And I'll go into just some basic commands so you can see how it works, but you can see a lot of the specific SDK commands that will be useful if you're going to use this. The Aztec SDK is written in TypeScript, so it's really nice for building web applications or just anything that supports TypeScript. The first thing I want to note is using the SDK version in this. Right now I'm using this testnet version. Since we're developing on the testnet.
00:14:14.722 - 00:14:52.434, Speaker A: If you go to the NPM page, you can see on the Aztec SDK page there's a bunch of versions published. Just check this and see what the latest published version is. We're developing on this actively, so these versions change pretty regularly. And the back end is tightly integrated with the SDK. So if you have a version mismatch, it might break everything. Yeah. So with that package JSON, I guess.
00:14:52.434 - 00:15:24.438, Speaker A: So all the code lives in SRC network config, I guess is the first thing I'll mention. Our testnet is chain ID 677868. So you'd have to add this to your MetaMask. Let's see if I go to MetaMask. If you guys can see that, expand the view. Okay, here we go. So I go to networks.
00:15:24.438 - 00:15:49.300, Speaker A: You guys will add this information. It's Aztec main network and then RPC Mainet fork. Aztec network. Chain. ID. So, yeah, when you're using Zkmoney or the Command Line tool, you'll most often connect with MetaMask. You can generate your Aztec account keys using MetaMask by just signing a message with your Ethereum account.
00:15:49.300 - 00:16:35.714, Speaker A: Okay, so going back to the code, let me take a step back real quick and just do a very high level of what this tool does. I think it's pretty cool because it's a command line tool. So it's pretty easy to interface with. Just type in some commands. But it allows you to connect to MetaMask or Wallet Connect through a command line tool. So you can use Truffle dashboard to open a local RPC endpoint that will forward transaction requests to your browser. So you could use MetaMask to sign.
00:16:35.714 - 00:17:15.674, Speaker A: So that means you could use a ledger or any hardware wallet that MetaMask supports. Or if you use Wallet Connect as your wallet, it will display a QR code, and you'd connect to the Command line tool using Wallet Connect. And then message shining requests will go directly to whatever Wallet Connect wallet you've connected with. I've tested this almost exclusively with MetaMask, not as much with Wallet Connect. So some of the Wallet Connect stuff might be broken. If you run into that stuff, let me know at the hackathon, and maybe we can hack on it and fix it. But here's some commands on how you can install it to use, just like with the Aztec CLI command.
00:17:15.674 - 00:17:58.646, Speaker A: But if you're running this from this repo, you can just do bin dev and then the command. So I'd run, like, balance, and that would be the Balance command. This is just the convention that Ocliffe uses. So I mentioned the network config. This network config info will come from the connected wallet. So whatever network your MetaMask is connected to, that's a network that the command line tool will use. So if MetaMask is connected to Mainnet, you will be sending transactions on Mainnet.
00:17:58.646 - 00:18:47.820, Speaker A: If you're on the Mainnet fork testnet, you'll be using that network. So it makes it easy to switch between Mainet and the testnet. Just be aware of that. So there's this base command that is run before all commands in the commands directory. Everything in the commands directory is just a command. So there's account info, command add, key, balance, DeFi, bridge, deposit, get fees, history, register transfer, withdraw before all of those before each one of those commands is run, when you run it through the command line this base command runs. So this base command let me get rid of this for now so we can see more.
00:18:47.820 - 00:19:16.878, Speaker A: Basically, what it does is it checks what wallet you have set in config. So this would be like MetaMask wallet connect. I always just do wallet connect. And you can read more about setting this config. In the README, there's details on how to work exactly. But if it's like Wallet Connect, it does this. If it's MetaMask, it'll go through this.
00:19:16.878 - 00:19:55.730, Speaker A: But it's basically setting up your Ethereum provider. Once that's set up, it gets the chain ID so you don't have to manually specify it. It just gets it from the wallet. You can use the log SDK flag in the command line tool to debug to run the debug flag on the SDK. So it prints a whole bunch of extra stuff just to see what's printing. But then it sets up an instance of the SDK with the Ethereum provider and the server URL. This is just the Aztec backend infrastructure, and we're just connecting to the backend that we run for the appropriate network.
00:19:55.730 - 00:20:46.660, Speaker A: So this will basically get all of the proof data that you need, all the data that you need to verify your transaction history, generate proofs, and do all this stuff. So we'll run the SDK to get all the data and sync it up. Then there's a couple additional commands for getting an Aztec signer and then getting your Aztec account keys. So we can just look at the balance command, or it will just like, print your balance and actually, let's just run this so we can see what it does. We'll connect to MetaMask. So I'll do truffle dashboard. This is going to start.
00:20:46.660 - 00:21:40.770, Speaker A: You can see here in my browser, just started, Truffle dashboard. I'm going to connect my MetaMask to this, confirm the connection, jump back to Vs code, go to a new terminal. I'll do. I'll run the balance command rather. And what this is going to do is start the SDK. Looks like it's kind of slow right now, maybe because I'm recording and doing a bunch of other things simultaneously. So now it's awaiting user signature.
00:21:40.770 - 00:22:00.010, Speaker A: I'll see the incoming request on Truffle dashboard. I'll process it. I'll go to MetaMask. Here's the message. It wants to generate my Aztec privacy key. This is having me sign a message. These signed messages from my Ethereum account generate my Aztec keys.
00:22:00.010 - 00:22:53.974, Speaker A: And I can see my Aztec balances here. I was looking at the balances. So, yeah, this command line tool is really nice to see how you can get your account keys and take an account by seeing how these are implemented here. Let's see how to do something like a deposit. That's something that most users will want to do. Actually, let me take a step back and mention this concept of account aliases. So when you register an Aztec account on the network, you have to specify an alias.
00:22:53.974 - 00:23:44.522, Speaker A: This is just like an alphanumeric string. I think it's 20 characters or less. But this can be basically anything that hasn't already been claimed. So this just makes it easier to send funds to people because you can send it to a name instead of some crazy long number hexadecimal number that nobody remembers. So it just makes it much more usable. You can deposit or transfer funds to Aztec public keys directly or to these aliases. So in a lot of these commands, you'll see like in balance or in deposit, you'll see this parse Aztec recipient function, which the recipient can be an alias or Aztec public key.
00:23:44.522 - 00:24:25.474, Speaker A: And it will just parse it and specify it will return an Aztec public key. But if it's an alias, it will resolve to the appropriate public key. If it already is a public key, it will just resolve to that. So yeah, registering Aztec accounts is handy because you can also specify additional spending keys that are different than your root private key. Your root private key is the key that you'll use to initially register accounts. But then spending keys can be different and you can add like an arbitrary number of spending keys. So you could have a different spending key for each device.
00:24:25.474 - 00:25:17.150, Speaker A: So you don't need to copy and paste private keys around devices. And then those can be yeah, you can just add those as well. So, yeah, there's this type of account abstraction with Aztec accounts that's really handy. So going back to the deposit example, you can get your Aztec account keys, this would be like your public key and root private key. Settlement time would be instant. Or next roll up parse the recipient. You can check if the account is registered with the SDK.
00:25:17.150 - 00:26:39.654, Speaker A: Here I'm checking a flag if the spending key is required. The SDK for some of the controllers. Actually, this is a good thing to dive into. There are these controllers, in this case the deposit controller with the SDK, which will do a lot of the proof generation and transaction signing requests and management on behalf of easier. So it's pretty easy once you have kind of the setup phase of the assets you want to use, the amounts, the accounts that you're using, you can just create a deposit controller with your ethereum account, the amounts, where they're going, and then you'll just call a number of functions on the controller to basically interact with the Aztec backend. So creating the proof, signing the transaction, paying transaction fees, or like in this example, seeing if there's pending funds, if there's not pending funds, like waiting to be deposited into the network, you'll submit a request to deposit those funds and then actually sending transactions on the network. So that's all super handy.
00:26:39.654 - 00:27:39.806, Speaker A: There's controllers for depositing funds, registering funds. There's a register controller, transfer controller, withdraw controller, and there's also an account migration and account recovery controller. Those aren't in the command line tool yet. And this would be something that would be cool to add for like a wallet management application. But yeah, those are in the SDK and they're functional so it's just we don't have an interface for them yet. And you can view all of this stuff in the SDK, or actually, probably a better place is just, let's go to Docs Aztec network. There's a lot of good information on the SDK right in our docs with examples that are more probably more clear just because there's not a ton of code around them.
00:27:39.806 - 00:28:32.846, Speaker A: It's just like, very specific to the actual case. So you can see the register controller here, how you'd set it up, what it takes. It might be useful to look at these docs pages in conjunction with the command line tool to see how it's implemented in a working application. But yeah, I think with these docs pages and this reference application, you're probably in a good place to start digging into what the SDK can do and how it's actually implemented. And this command line tool is actually pretty useful if you're building other applications on Aztec. One of the difficult things with developing is all the transactions on the network are encrypted. So even just looking at the Explorer, you can't get a lot of information.
00:28:32.846 - 00:29:20.970, Speaker A: You can see there's like, oh, these transactions happened recently. I look at it and there's just like a bunch of encrypted data. So even just knowing if your transactions are working or where they're failing can be difficult. So having two applications to compare and contrast against is helpful to figure out if things are working. When I've been developing this command line tool, I've been using Zkmoney a lot. So I'll look up what Zkmoney is telling me and what my command line tool is telling me, and if there's a discrepancy, then there's a bug somewhere. I need to add something about this DeFi bridge command.
00:29:20.970 - 00:30:04.890, Speaker A: This is a work in progress. It is functional as it's written, but it's just doing an ETH to wrap stake to e swap, passing the bridge. ID five ETH and ETH in and wrap staked, ETH out. All the stuff is hard coded. It's setting it up and then using the DFI controller to actually do the interaction. If you're doing anything with bridges, you'll do something similar with the SDK. But yeah, all this stuff is hard coded in, and this is functional, so you can use it as reference, but if you have questions about it, feel free to reach out and we can dig into more of the specifics in Bogota.
00:30:04.890 - 00:30:24.740, Speaker A: So, yeah, I think that's all I need to add. I think Laissez is up next, talking about writing DeFi bridges, actually writing the contracts in solidity. So thanks for listening and see you guys soon.
00:30:27.110 - 00:31:25.154, Speaker B: Hey, I'm Leslie. I'm part of this Aztec smart contract team. I'll be giving a short introduction on how to build bridges to L from Aztec Connect. So the agenda for today will be that we'll look a bit into some background. Then we are getting started how to design some of these bridges what do you need to think about writing bridge contract? Just again, where do you start on this? Testing and a couple of gotchas. So as background from on Aztec Connect, you can essentially see the Intaction between Aztec Connect and the bridge as a swap with two input assets and two output assets where the output might be delayed for some period of time. This delay depends on whether the bridge is synchronous or asynchronous synchronous.
00:31:25.154 - 00:32:32.490, Speaker B: Just being here that it's like instant it's happening to send transaction and async meaning that it will happen later. An example of an async bridge is the element bridge that's live now where you insert some point and after the maturity you will be receiving tokens. So any of these ABC and D assets can be e a supported ESC 20, a virtual asset or nothing. And every of these assets have like a unique ID where the virtual assets when you're returning these so this will be when you're minting them from the bridge. Essentially the ID will be the entire nons and a virtual ID offset. Something to be aware of is that the amount of tokens A and B that you're sending to the bridge will be the same value. Mean that if you're sending ETH and die to the bridge, you might run some issues that you would seldom set, like one e and one die.
00:32:32.490 - 00:33:25.760, Speaker B: But this is a way to get around some free rider issues that we have. If we don't do some of these things, we're looking at getting rid of these. But at the moment this is how it is. So essentially we are having the good old trade off. A meme I receive Amb, you receive CND from the point of view of the bridge, a note on rebasing tokens. If you're depositing a rebasing token into Aztec Connect, the note that will be generated for internal accounting is based on the value when you deposit it, meaning that if you're depositing staked e, when you want to withdraw it, you will withdraw the same amount that you deposited so you will lose all of your rewards. This is why we're using the rep staked eve as an example.
00:33:25.760 - 00:34:44.920, Speaker B: So going back to just how this was outlined, the reasoning behind Outlining is as like a two for two swap is that we can essentially do this for all bridges, or at least a huge deal of bridges, which allow us to have the same circuit as all of the bridges can be specified in the exact same way from the point of view as the connect roll up. So we are specifying what to do through something we're calling like bridge call data. So this is a UN two five six that uniquely specify what interaction should happen. It's not fully using all 256 bits, mainly because the field that we have in our circuits is a little less. So we have a bit that's just empty, but it will specify like, what bridge should it be using, what is the input output assets, some configuration, and a bit of aux data. And this aux data is UpTrade data that can be used by the bridge. Often this will just be like a flag for entering or exiting a position, but it can also be like a price or whatever you essentially want it to be.
00:34:44.920 - 00:35:50.490, Speaker B: But this is specific to the bridge. So when you're doing a DeFi deposit or an intersection with DeFi protocol from Aztec, you'll have this blob. It's a bit simplified, but you have this Blob of data that is your transaction. So it has some public bridge call data which specify what will you be injecting with and a public value for the DeFi deposit. And there's a couple of other public values. So here you can essentially see what is the amount that will be deposited into this DeFi injection from the transaction, but you cannot see from who the reasoning behind the DFI deposit value and bridge call data being public is that l one needs to know what it has to do and how much funds to send. A nice thing with this is that when we are doing this publicly, we can use it to save a lot of gas because we can aggregate bridge call data that are the same.
00:35:50.490 - 00:36:46.170, Speaker B: So if you have two users that both want to swap ETH at the same price, they can have different values, but you can aggregate them up on this one DeFi interaction instead. That swaps 15 E and then you have these DeFi deposits on the side. But from l one point of view, you will just see like one user or here being the roll up performing this action on the bridge. So there's a couple of important points when we talk about aggregation. If you just do like, navel aggregation here, as we were saying, like curve swap ETH to rev Staked ETH. So through Staked ETH and then revving it, you will have an issue of like, okay, you didn't specify any price or slippage, so now you just have infinite slippage. It's private, but don't help you if you lose all the fonts.
00:36:46.170 - 00:37:36.940, Speaker B: If you just take the route of specifying like a minimum output amount, you have another issue that you just can't aggregate these because, okay, now they differ. And even if they had both them were depositing five E, if they were both expecting like 4.7 as output minimum, when you aggregate them, you would have like ten E deposit still with 4.7 as the minimum output. So it doesn't really help there. We'll essentially do as we saw some of the input before, where we're specifying like a price. If we have both of them want the same minimum value per ETH, then we can aggregate them up, which just gives us this one inspection on main net.
00:37:36.940 - 00:38:13.578, Speaker B: Then we have a couple of different types of these bridges. So beyond the. Sync and the async. As we briefly talked about, we have a stateless and a stateful bridge. So a stateless bridge is what you might know as like a SAP or spill or recipe. It's essentially a bundle of transactions, you could say, that executes and then you end up with some other token in the end. Often it won't hold any funds beyond when it's actually doing the call.
00:38:13.578 - 00:39:19.210, Speaker B: And the code is often pretty small for doing this. It's very nice for doing fungible positions or just moving some of this simple stuff. Or when you're interacting with stuff like urine where, okay, everything is integrated in another protocol and they have this way of managing their positions. And then you have the stateful ones which handle some accounting internally and they might hold funds between its actions. Generally you have a large footprint of these because they need to handle the accounting and they often useful for more long standing actions that are non fungible. So if you have borrowing position, if you're doing like DC limit order, stuff like this is useful. Then a couple of other notes just on bridges is that gas usage on a bridge is bounded.
00:39:19.210 - 00:40:42.886, Speaker B: So a bridge will be listed on the roll up with an upper limit on how much gas it gets spent. This is to ensure that the entire roll up will not fail if a bridge fails with an out of gas. But it also means that you need to be aware of variations in gas usages that depends on L1 state and can be altered by other parties. If not you are aware of this, you might end up in listing the bridge with two L gas in some cases, and then sometimes it will revert and you might need to list it again with a higher limit to actually get out of the position. If a bridge will revert in a call, the roller will not fail, but it will emit an event where it's just like false for failing, but otherwise it will just continue. Executing this can make debugging a bit tricky if you start with doing end to end tests just because you won't see any of your revert messages directly, you would need to look for them inside events. So to get started on stuff like this, you essentially can go to our like, we have an Aztec Connect Bridges repo which has like a small introduction on how to set this up.
00:40:42.886 - 00:41:34.810, Speaker B: We are building it all with Foundry, so you can also use the Foundry book essentially to get some help there on how to run Foundry. Or if you're having specific issues that are foundry based, you could take a look there. Otherwise go to our discord to ask for help. Then we'll be there. When designing bridges, you need to just keep in mind a couple of things like should the bridge be synchronous or asynchronous should it be stateful or stateless? Can the bridge be done by just using it like ESC 4626 if it can build the ESC 4626 instead and then use the generalized 4626 bridge.
00:41:37.070 - 00:41:37.386, Speaker C: Or.
00:41:37.408 - 00:42:32.620, Speaker B: Of course only do this if there's not already like a canonical 4626. If there's one of these, just list it instead. Don't need a separate bridge if any of the output tokens are rebasing. Is there a wrapper already for some of these tokens? So for like wrap staked ETH is one of these canonical wrappers but for other rebasing tokens such as the A tokens there is not really a canonical wrapper right now but there's one soonish. But you might run into issues where there's no wrapper. So you need to make one and then you need to think about how can you use the aux data to support the bridge. So it's something that is useful to just pass along instead of having to fetch from an oracle or whatever.
00:42:32.620 - 00:43:01.326, Speaker B: So if we look at the Curve state div swap, this is essentially like a synchronous bridge. It's just doing a swap. It doesn't need to hold any state. So stateless could we do it with an ESC 4626? Probably, but it will be a bit annoying. It will not be as composable as just using like rep staked instead. Yeah. Staked DF is rebasing.
00:43:01.326 - 00:44:02.642, Speaker B: So we are using rep staked and what can we use the aux data for? We can use it for price data related to the slippage. So with this in mind, we can essentially draw out a couple of diagrams where we are going from the roll up to the bridge. Bridge will swap like when we entering Swap ETH on Curve Stake ETH is wrapped and returned to roll up and reverse order when we're doing the withdrawal. This allows us to support like replacing token on Stack Connect. When we want to implement the bridge, we just need to figure out what language would we like to implement. Solidity Viper Huff if you're into that. If you want to implement it in Viper, be aware there's a couple of quirks because our execute function is called Convert which is a keyword in Viper.
00:44:02.642 - 00:45:16.206, Speaker B: So if you look at the Viper Curve LP bridge for reference, you will see that we have brute forced a selector or a function name that will hit the same selector. For Solidity we have a bridge base that you can use. It contains some addresses that might be useful for you as like a subsidy and also a couple of useful error codes modifiers some of this stuff. Then you also need to think about can you do pre approvals or do you need to approve like the roll up or other contracts every time? On some bridges you can do a pre approval of the roll up to just pull the funds. It will save some gas when you're doing the executions, but on others, if you're like listing new assets down the line, you might not be able to do this full pre approval and need like a function to do it later on. But it will save you some gas if this is possible. When you get to testing, we have like two stages, which means you'll have unit testing where you just show that the bridge works when it's by self.
00:45:16.206 - 00:46:24.910, Speaker B: So you test edge cases, all of the stuff where you check that all the reverts are hit, that the output values are actually what you expect them to be, and that you like fast values that can be fast. So go look at the exampleunit t sol for reference of this and then the end to end testing. You can use our bridge test base to mock roll ups and execute the defiance action and check that the events from the defiance action is throwing like failures when you expect it to, and that the output tokens are actually transferred as we expect it to. And we have an example end to end test for reference. There a couple of gotchas that we just need to keep in mind is even though you have two input values or two input assets, you only have one input value. The gas estimation is used up front often. We also use it from the sequencer to figure out how much you'd use to pay.
00:46:24.910 - 00:46:59.194, Speaker B: And this can happen like multiple hours before the Intaction is executed. So it's pretty important that it's somewhat precise when testing with the roll up. If the bridge reverts, it don't revert the roll up. So you need to check the events. And when you are aggregating, it requires identical call data. So think careful about what you're putting into the aux data, otherwise it might be impossible to aggregate efficiently. And then ending.
00:46:59.194 - 00:47:55.330, Speaker B: Note on building a bridge with depth. If you're building a bridge that hold depth, so say like an open an average position. So deposit a token A, use that as collateral, borrow token C. Now the bridge will have token C as depth. What happens if the bridge is liquidated because of market conditions? Can a user deposit and borrow on another risk value or risk risk parameters? If they can, they might be able to borrow using someone else's collateral, which is not ideal. So you need to think of some of these case, like all the cases where the balances of the bridge can be changed by someone else in a negative direction, needs to be taken care of when doing this. And for borrowing, this is a bit more complex.
00:48:01.240 - 00:48:44.100, Speaker C: Hello. Today I'm going to be showing you how to make a basic zero knowledge circuit in Noir and how to interact with it using TypeScript. Noir is a domain specific language that enables creating and verifying zero knowledge proofs. So first you're going to want to go to Noir's GitHub page, which I have open right here, and clone the repository. Noir is written in Rust and heavily inspired by Rust. Thus you're also going to need to install Rust before being able to use Noir. More instructions can be found here in the Noir book that gives some more information on installation and also on the syntax, data types and other information that might be critical for your development.
00:48:44.100 - 00:49:34.880, Speaker C: So we're going to head here, where I already have the Noir repository open. I'm going to CD into cratesnargo and I'm going to do a cargo install. I'm specifically going to install it, install it in my path so that I can access it from anywhere else on my machine. However, unless you're on Linux, you might have some issues with installing this Noir. Specifically compiles down to an intermediate representation that any proof system that is compatible with that intermediate representation. Noir can then generate proofs using that proof system. Right now, Noir is specific to Aztec C backend, which can lead to some build issues on different machines.
00:49:34.880 - 00:50:16.560, Speaker C: So if that's the case and you're having some trouble, replace this line, this Aztec backend dependency with this line here, and this will use the C backends WASM executable instead. And this should build on any machine. So I just did a cargo install and now I have nargo. I'm going to head to a separate example project. And you can see I can do a nargo help now, and I can see all the commands that are possible with nargo. So I'm going to create a nargo project. So I'm going to do nargo new circuits.
00:50:16.560 - 00:51:08.446, Speaker C: This is just a blank hard hat project that I initialized using Yarn for testing purposes. So I'm going to do nargo new circuits. And you can see very basic project with a main file and a nargo tomal similar to cargo in Rust. So we're going to now edit this circuit and going to make some slight changes. Anything returned from the main function must be public. That's why you can see this pub word here. All inputs to main are by default private, but you can specify pub if you want it to be a public input.
00:51:08.446 - 00:51:51.066, Speaker C: Our circuit is going to be very basic. We're just going to calculate what X times Y is and we're going to return that. We're not even going to put in a specific constraint into this just yet. So now if you want to check whether or not the syntax is valid, you can run a nargo build. Oh, you can see actually here I am not inside of a nargo project, so I have to CD into circuits. And now I'll do nargo build. You can see the constraint system was successfully built and then two more files have popped up, approver TOML and a Verifier TOML.
00:51:51.066 - 00:52:32.800, Speaker C: You can see it already found the specific values that I need to specify in the proverb Tomal. I need both the private and public inputs, while the Verifier just needs the public inputs. So we're going to start with some basic examples. So I'm going to do three times four equals twelve. So save both these. So now we can actually compile our program. I'm going to do Nargo compile P and P here will just be the name of the build files that I create.
00:52:32.800 - 00:53:23.338, Speaker C: We successfully generated our intermediate representation, which is called our Acer, which stands for abstract circuit intermediate representation to be specific. And you can see two build files inside circuits, acer and Tr represents the solved witness, which you can use or can't use. And we'll get to right now as I describe how we're going to prove and actually verify this circuit. So now I have this test folder here that I can use. You can see I have a few packages I need to install. These represent the TypeScript wrappers around a lot of the Noir logic that would normally be done in Rust, but is now enabled in TypeScript. So I'm going to do a yarn.
00:53:23.338 - 00:54:25.990, Speaker C: Ad Noir WASM I'm also going to do a Noir ad for the Brettenberg library, which is the C backend and proof system, and then also the Aztec backend for some specific logic and different ways of verifying proofs that I'll show you. So these packages are getting installed. Okay, now that they're installed, we can actually verify some proofs. So we need to fetch our Acer, the intermediate representation, from the file. So I have this helper function I made here, path to UN eight array. It just reads the file and specifies it in a UN eight array. That's just due to this function requiring a UN eight array.
00:54:25.990 - 00:55:34.960, Speaker C: So I'm going to first you're going to want to read in the byte array and then deserialize it. This is the same thing we're actually going to do for our witness. And then we can actually set up our prover and verifier using that intermediate representation. We can then create a proof using our witness and we can then verify it. And we can then write a test verified equal to true. And that's our basic test right there. So if I then run MPX hard hat test, these are all passing, although there's nothing inside these tests right now.
00:55:34.960 - 00:56:17.238, Speaker C: So I'm going to show you some different strategies for how to do this. This witness byte array relies on the solution that the rust came up with. But this is not necessary. You can actually compile the Noir program itself using this compile inside of the Noir WASM package. And then this will store this has then the Acer, the intermediate representation and the program Abi. You can then specify the Abi directly within TypeScript here. And then you're going to do the same thing that you did previously, where you set up the proverb and verifier.
00:56:17.238 - 00:57:16.430, Speaker C: You create the proof and verify the proof. You'll notice here though, in create proof with witness, we pass in the Bretonberg witness array. While in just create proof, we pass in the Acer and Abi, which is what generates and they generate the Witness array within the TypeScript package. So we can kind of combine these strategies how you'd like to your own preference. And I'm just going to copy and paste a couple of examples in. So here we can read the Acer from file, but still specify the abi directly like this. And then we can also compute the Witness ourselves and then use create proof with Witness if we so choose.
00:57:16.430 - 00:58:13.230, Speaker C: This is probably my preferred strategy or just compiling it directly. I prefer the JavaScript objects to this array. It's important to note, though, when you're computing a witness, to have an even number of bytes specified as the program will break otherwise. So now we can save this and run our tests. And we have four passing tests where we have now proven and verified our program. So there will be other links in the description, but updates to this example repository will be made here and you can follow along as updates are made to the TypeScript Wrapper and Noir itself. And this can be used as a reference.
00:58:13.230 - 00:58:13.840, Speaker C: Thank you.
