00:00:07.610 - 00:00:50.490, Speaker A: All right, it's great to be here. I am here to tell you guys how to decentralize your front end for this hackathon and potentially beyond. And we're going to talk about how to do it with a tech stack that we're calling the Blockchain Operating System. So just to kick it off, like what is the Blockchain operating system? So, two main things. One, it's this common layer for discovering open web experiences that's compatible with any blockchain, which is a part of it that we're really excited about and then maybe even more directly for those of you who are developers in the room, probably most of you, it's a tech stack for building fully decentralized applications. And most importantly for this talk, it's about decentralizing your front end. So the main reason we decided to build Boss is to solve a few different problems.
00:00:50.490 - 00:01:28.098, Speaker A: So onboarding and distribution are common ones. Compliance is one that's becoming a lot more important, especially if you're building financial applications complexity. Another one for developers. There's a lot that comes with building a front in these days and we aim to make it easier and then we're really excited about bringing Cloth platform to support to this ecosystem and really just letting blockchains collaborate in a more compelling way. So, the Boss stack is a few different pieces. We'll mainly be talking about user interfaces and blockchains today. But we also do have some products for onboarding, mostly around users being able to use blockchains without actually needing an explicit wallet.
00:01:28.098 - 00:02:26.118, Speaker A: If they're new to their crypto journey or using a crypto application, they may not have a wallet and they may not want one just yet. And we do have some products for that but less relevant to this talk. And here's kind of a snapshot of a few of the different pieces that fit into the Boss stack. Again, we have what's called these gateways which are going to be basically interfaces that enable users to interact with the front ends of various decentralized applications like say, Aave, Uniswap, Liquidy and others. And the code for these will be stored both on the near blockchain for the front end and then on, say, the ethereum blockchain for the smart contracts. So, one of the biggest things we aim to solve when we set out in building the Blockchain Operating System is that typically developers are forced to make a choice between distribution and decentralization when it comes to their front end. You're way better off like kind of baking your front end into a few existing applications or even hosting your own front end and promoting the hell out of it if you're trying to get distribution.
00:02:26.118 - 00:03:23.514, Speaker A: If you want decentralization though, those are kind of counter to the things that you want. Fortunately, we think we have a way to kind of thread the needle and actually give you both increased distribution while also giving you even more decentralization you would have had if you're hosting your own website on like Vercell or something like that. So to make it very clear in exactly how it works, let's imagine that you guys are developers and first you're going to deploy a smart contract to Ethereum and now you need somewhere to deploy your front end. And let's say you choose Boss and you choose the near blockchain. So what you're going to be doing today is you will actually be deploying basically like react's JSX code. Like these components. You'll make a component for your DAP that you will deploy to the near blockchain and then users will be able to interact, access that interface, conduct some actions that will then result in a transaction and then they can send that transaction to Ethereum, which means they can have basically they're interacting with two different blockchains in one experience.
00:03:23.514 - 00:04:04.762, Speaker A: They don't necessarily know that all they care about is accomplishing their goals. And a component of this we're really excited about is that since you will be able to deploy your code on chain, what this means is that dows that are currently managing their smart contracts can now also manage their front end all on chain. So we're hoping we can see a world where every single dow will do this. Like if you have smart contracts you will at least have some basic user interface or even a very full feature user interface that you as a dow will maintain an upgrade that reflects the usage of your smart contracts. To make this a little bit clearer, we'll talk about it from the user angle. So let's imagine that we have a user. The first step to use Boss, they're going to navigate to some kind of interface or front end.
00:04:04.762 - 00:04:25.202, Speaker A: This could be MetaMask, this could be Zapper on iOS, it could be Nier.org. Soon it's going to be Urbit, which we're pretty excited about. And it could also be this site called Bossug. That's basically like a doc site that we have. So by going to any of these they can access all of the same applications. So then they're going to select a DApp that they want to use. These are four examples we have available today.
00:04:25.202 - 00:05:03.470, Speaker A: Ave one inch, uniswap or liquidy. Let's say they select Aave. So after they select Aave, then the Ave front end code is going to be loaded from the near blockchain. So there'll be an RPC request to the near blockchain which will then return the JSX. And that JSX will be rendered in a specialized virtual machine that'll be running on one of those different gateways that the user first navigated to. And this virtual machine is designed to basically be a strict subset of JavaScript that has some extra security guarantees so that if it is near and there's private keys in local storage, for some reason those are not able to be stooped easily. That's the goal.
00:05:03.470 - 00:05:45.674, Speaker A: So then they've loaded the front end, they're doing their thing. They're like, I want to deposit 100 USDC into Ave great forms a transaction because now they're just using a front end and then it hits the Ethereum RPC sends the transaction to Ethereum. They then get some kind of receipt showing them that the transaction was mined, get a message saying that they were deposited. It updates the front end. Now they're happy and they've used a fully decentralized or cross platform application. What's really cool if you want to get really paranoid with this, which we like to do, is that gateway in the first step can be self hosted and it can be self hosted very easily. You can run this in an Electron app and soon we'll have that as an access point.
00:05:45.674 - 00:06:17.326, Speaker A: Or I think even more commonly we'll just see people using their typical mobile wallet and they'll be able to access the application. Kind of skipping DNS entirely, skipping going to this front end entirely. Just interacting with two blockchains at most. One blockchain if it's fully built on near, or two blockchains if the front end is on near and then the back end is on Ethereum or an L2 or Salana or whatever it may be. And the best part for you guys is that it's super easy to get started. So there's basically five steps. If you guys want to want to build with this today or even get some things running, you can go to near.
00:06:17.326 - 00:06:36.380, Speaker A: You can use the search function to search for these five different applications. You can click Fork, you can make changes, and then you click Save. And that Save is actually going to be a transaction to the near blockchain. It's super cheap. Should be a few cents. If anyone in here needs some near, come talk to us at the Near Booth. We'll get you guys some near and you'll be on your way.
00:06:36.380 - 00:07:14.120, Speaker A: And then the other aspect of this that we're really excited about is that every single component that you build can be composed of other components. The same way if you're familiar with React, where you can have higher order components and you can compose components, you can pass State and props between them. You can do that with Boss, with a bunch of different components. Like there can be ten different components that are deployed. I gave an example of a page for Polygon that shows a few of their different applications, all of which are available on Boss. And then it shows an interactive swap component there that's also being rendered in the same page. And this is actually going to be like seven different components, all of which are composed together into a single experience, which is really cool.
00:07:14.120 - 00:07:50.194, Speaker A: So now on to the fun part, which is the demo. And we'll actually walk through how you can access Boss components and how you guys can get started for this hackathon. So this is actually a demo that was created for ETH Soul. And I think what's fun is it's going to be a very easy way for us to show how you can get started. So in this demo, there's basically four different components that are going to be showed. You see that little widget line? That's basically a different component that's being loaded into this higher order component. So some of the things you're going to get out of the box here is like detecting the network that the user is on.
00:07:50.194 - 00:08:10.166, Speaker A: That's going to be like the first thing that this component is doing. Then you can detect basically who the sender is going to be from state. And we have some examples of how to do that. You can load their balance, their ETH balance, and you can load their stake ETH balance because in this case, this is like a lido component example, like helping people stake their Ethereum. And I think it'll be even easier.
00:08:10.198 - 00:08:16.682, Speaker B: If we actually just go to this and show you what's happening.
00:08:16.736 - 00:08:36.146, Speaker A: So here you can actually see this being rendered. This is the Lido component and I can go up here and I can click fork. Now we're seeing the code so users can actually do this. They can view the source code in the browser. Same way you'd be viewing the source code for like a smart contract on Etherscan so they can check out.
00:08:36.248 - 00:08:44.890, Speaker B: I can't actually see it on my screen. Bear with me.
00:08:45.820 - 00:08:49.870, Speaker A: Somewhere in here we'd be able to see the smart contract, but I cannot actually see it.
00:08:51.200 - 00:09:04.316, Speaker B: Maybe let's just go to the actual light out contract itself. See here, here we go. So let's fork this one here you.
00:09:04.338 - 00:09:33.624, Speaker A: Can see the smart contract so like a Savvy user would be able to actually check the smart contract, go cross check it on another website and be like cool. I am very confident that this is going to actually send my e to the contract I want to, which in this case is the Lido contract. And you can easily change that to say, the Lido contract for polygon. And then I can just click save and it's actually just going to show me the state diff. So this is like showing you like the code. Is that's actually going to be saved to the near blockchain? Click save data.
00:09:33.822 - 00:09:37.130, Speaker B: I'll probably have to sign a near transaction maybe.
00:09:37.820 - 00:10:02.828, Speaker A: Oh, I don't even have to. Yeah, if it's below a certain size, then you don't even necessarily have to save it. Do a transaction in order to save the state diff and then bam, we're good to go. And I can preview this. I can preview it here so I can actually see what I'm doing and then just hop back and forth between the in browser editor. Or you can download a Vs code extension that will make it a lot easier to compose your wraps. Like if we have from the previous.
00:10:02.924 - 00:10:05.680, Speaker B: Example we had that you can see.
00:10:05.750 - 00:10:29.896, Speaker A: Here, there's like these widgets that are being loaded. The widget means it's another component. So if you use the Vs code extension, you can actually click into this and you can then see the component or pull in the component so you know what it is that you're going to be interacting with. Yeah, and then if you go to near, you can actually use the search functionality here and find a few different components so we can look for Ave.
00:10:29.928 - 00:10:53.660, Speaker B: For instance, the Wi Fi is going to cooperate. I think this is the one. I cannot see this. Yes. Okay. This is for Ave on the polygon zkevm testnet. Where did my browser go? Here we go.
00:10:53.660 - 00:11:01.774, Speaker B: While that's loading, we can oh, there we go.
00:11:01.812 - 00:11:08.258, Speaker A: So you can see this is like an Ave component that someone in the community built. We can then go to develop and.
00:11:08.344 - 00:11:11.186, Speaker B: Check out the details which will show.
00:11:11.208 - 00:11:34.282, Speaker A: Us who deployed it. It'll show us all the source code and then go ahead and fork it. And maybe in this case we'll want to change the network that maybe we don't want it to point to Ave on Polygon Zkvm. Maybe we want to sorry guys, I can't see it on my screen here. But we can change it to point to like Aave on Polygon or Aave on Ethereum or whichever network it's deployed on.
00:11:34.416 - 00:11:36.282, Speaker B: And then we can do the same.
00:11:36.336 - 00:11:38.554, Speaker A: Thing and save it here.
00:11:38.592 - 00:11:39.514, Speaker B: It's over here.
00:11:39.632 - 00:11:46.714, Speaker A: Or we can save this version of it locally. This will be saved in the browser so you can just kind of like edit while you're testing. And then if you want to publish.
00:11:46.762 - 00:11:48.670, Speaker B: It, then you can do the transaction.
00:11:49.670 - 00:11:56.210, Speaker A: So in this case, I'm actually just forking it. Live demos.
00:11:58.310 - 00:12:12.430, Speaker B: All right, let me just pull up the slideshow again. Cool. There we go.
00:12:13.440 - 00:12:43.060, Speaker A: All right, so just diving into some more of the technical details and showing you what we're doing here. So a lot of this right now, this assumes a react dependency out of the box. We're launching a version of the virtual machine that will not make that assumption because I'm sure plenty of you want to use other JavaScript packages. So right now we use Props and State if you're familiar with how React works. So like Props, you can pass between components. You can also pass state. But State in this case will be more global, which means that you can just store State between components.
00:12:43.060 - 00:13:22.544, Speaker A: So here's an example of how you can use Ethers. So we inject Ethers just by default right now to make it easy for developers to get started. So you can see here, this is like basically doing a get balance function from Ethers pretty simple, similar to what you've been doing before. And then the result here will do a state update. And then similar to updating any sort of state in a component, it uses the lifecycle of React and this component will rerender with the state balance to whatever the user's balance is. So that's an example of just like how state and props are going to work. Similar kind of thing here.
00:13:22.544 - 00:14:19.888, Speaker A: I think this one's actually doing the kind of smart contract call. So you can see, you can assume here that we have the lido contracting in there and then encodes the data using the standard that Ethers is expecting in this case, like balance of and we'll call it and then it will then update the interface based on the result of that transaction. And then a very important part for everyone who's building a front end, you're going to want to style this component. So by default we actually enable sorry, this is an example of that composability we're talking about where you can have this kind of like, other component, pass the props to it and yeah, it shows an example of basically how to do that. And then finally we have styling. So by default it'll let you use styled components. So it should be like a nice and familiar way for you to include your style sheet.
00:14:19.888 - 00:14:49.656, Speaker A: So you don't actually have to pull in an external style sheet. You can just build into the component like similar like you would do in a lot of typical react components. And that is what I have for you today. So we do have some bounties here. So we have ten k total in bounties. I think it's split up between a first place prize of three k, two second place prizes of two grand, and then two or three of one k. If you scan the QR code there, you can check it out and you can also come visit us at the near booth.
00:14:49.656 - 00:15:41.082, Speaker A: We're on this side. There's also like file coin in the graph right over there. We're right between them if you have any questions. And we'll be here all weekend and yeah, we still have a good amount of time left, so I'm happy to answer any questions that anybody has about how this works. All right, yeah, great question. So I guess our goal here is that you can fully decentralize this, right? So there's a few different layers. If you want to decentralize a blockchain application, right, there's going to be the front end code and where that's going to be running, there's going to be the smart contracts.
00:15:41.082 - 00:16:16.646, Speaker A: Those parts are almost like the easy part. The harder part is like, well, making sure that if you need radical decentralization, like I'm in a place where there is serious censorship, then you're also going to probably need to run your own RPC. And most applications these days have some kind of data layer. Hopefully it's the graph, which fortunately is getting very decentralized, but a lot of times it isn't. And if it's not, you need some easy way to access that data. So that's been a general big problem on most blockchains. At near, we've worked with a lot of teams and created a lot of solutions to kind of make just more easily indexable or accessible data available to developers.
00:16:16.646 - 00:16:48.374, Speaker A: But we basically want front ends at some point to let users kind of define their data layer, define their RPC, define their wallet, and define each of the different parts of the stack. That part is tough right now, basically the gateway is usually just choosing an RPC provider, they're choosing the data provider and making sure that developers can essentially be agnostic to the choices that the gateway providers might eventually make is a bit of like an experience problem.
00:16:48.492 - 00:16:50.040, Speaker B: That's one of the ones.
00:17:09.140 - 00:17:57.980, Speaker A: Oh, you mean like if millions of people are accessing. Yeah. So that actually gets into that first question is like it sort of depends on which part of the stack will end up getting. Essentially DDoS, the near blockchain itself can handle quite a few transactions and these are mostly view calls, so they're not actually going to be updating state for users who are accessing it. Which means that it really comes down to RPC load. So we have a few applications not actually related to Boss that send a lot of transactions to the network and so there are some pretty battle tested RPC solutions. So that probably is going to do okay, but depending on which one whoever's running the gateway chooses that might fail, right? That's a common one we see in blockchains that get kind of a lot of load as RPC fails.
00:17:57.980 - 00:18:23.796, Speaker A: That could be a problem. The data layer in theory could be another problem. Like if the app you'rendering, the component you're rendering is making some assumption, maybe the developer has like, oh, we didn't want to use the graph so we just built our own API and it's running on some really small EC two instance that could then fail. Or just like the gateway itself if it's like again, running on a small EC two instance or something. So it depends. There are ways to do it. Like neo.org
00:18:23.796 - 00:19:16.638, Speaker A: for instance, it could handle a lot of simultaneous users, but it's because they built it in a way to anticipate that because they get a lot of load already. There's quite a few people who visit that page on a monthly basis. But yes, smaller instances of each of those could lead to some failures. But it is possible to build these things in a very resilient way these days. Maybe not like tens of millions of concurrent users, but definitely like pretty substantial numbers, especially for this industry right now. Oh, I see. Yeah, this is definitely designed more for kind of like it doesn't be static but like pages where the dynamic loading is data.
00:19:16.638 - 00:19:46.154, Speaker A: I mean you could use a different it is just the front end code, right? It's just JavaScript. You could stream content too. Maybe you're even streaming it from filecoin or something. Yeah, that would work fine. Basically you shouldn't be using near to store videos for instance or something that would need to be streamed, even photos. Near is kind of like a sweet spot where because it's a Sharded system, we can handle a higher state load than most chains can. But it's not designed for petabytes of data like Filecoin is.
00:19:46.154 - 00:20:25.606, Speaker A: Right. A great solution for that would be like combining Filecoin to actually store the video using their new CDN solution to kind of stream it and then piecing it together. And creating the UI can be done on using Boss. That would be like my recommendation for that stack. What is the cost effectiveness of scoring? Yeah, so it's like one near per either 100 maybe it's a megabyte. So it tends to be pretty cheap for front ends. Most front ends that I deploy and a lot of times after you deploy the first version when you do updates, it's just uploading the state diff.
00:20:25.606 - 00:21:28.214, Speaker A: So it ends up being like usually a few cents for most front ends for something really rich. If you stored the images and just stuff like that, it could get a little crazy. But yeah, I would recommend using other solutions for that media and then just using this for the front end code. The idea is like mission critical stuff, right? You want people anywhere to be able to access it, have those pieces there and then the nicer images and stuff like that can come from elsewhere. Yeah, it's a good question. So I mean, the biggest thing is like yeah, obviously our approach to scaling is like adding more shards. We don't know how many shards we can add.
00:21:28.214 - 00:22:00.094, Speaker A: I think right now they're testing with 100 and that's working pretty well. We don't need that many yet. Going beyond, there probably there's some kind of like there are going to be some sort of limits that are hit eventually. But I think we've got like the reason that we chose Sharding and took on all of the complexity that comes with that is that we believed it was a much more future proof solution than a lot of the choices that are made. So we're confident we can scale for a while. And I mean, the other thing that happens, the price of near were to go up. Just like if the price of ETH goes up, that can manipulate the storage prices in a weird way.
00:22:00.094 - 00:22:53.100, Speaker A: So what we do there is similar to ethereum is like you just update kind of some of the assumptions that are made so that the real cost can either stay static or go down even. And that could go the other way too. Whether the price of year goes up or down, we can kind of adjust the static costs. That is a great question. So the long term answer will be absolutely. The short term answer today is unfortunately, yeah, you're going to have to use the packages that we have sort of pre install and that's just because of the security assumptions of the VM. But that is a common request and it's like one of our top priorities is to enable that.
00:22:53.100 - 00:23:39.310, Speaker A: The problem we have now is we have to kind of add them manually. And so we get a lot of requests and we don't actually have to make that choice for developers. So we are, I think, pretty close to the V, two of the VM that will allow you to import probably most JavaScript packages, or at least it will be way more like the choice of the developer rather than the choice of us. So, yes, soon you will be able to use tailwind. Today you're going to have to use style components, unfortunately. That is a great question. I don't have a great answer.
00:23:39.310 - 00:23:54.276, Speaker A: I would say, yeah, style components, ethersjs, you can assume. I would look at a few examples. Definitely check out. Like Aave lido, uniswap, like some of those. Just to kind of see some of the common patterns. We'll give you an idea. We should have a list, though.
00:23:54.276 - 00:23:56.710, Speaker A: We'll get on in making that.
00:23:58.600 - 00:24:00.070, Speaker B: All right, thanks, everyone.
