00:00:06.330 - 00:00:31.538, Speaker A: Hey guys, it's hit six, so I think we can get started. Thank you guys for showing up. My name is Dorian Crutcher. Can you guys hear me okay? Is that good? Yeah. I'll be teaching you guys how to build a smart contract on near in JavaScript using our JavaScript SDK. So, again, my name is Dorian Crutcher. I work in the developer relations team for near, actually the host of the web series called Blockheads and Nearbytes.
00:00:31.538 - 00:00:54.726, Speaker A: Blockheads is kind of a way to learn how to build applications on near. Just a quick way to again, just like tutorial videos and whatnot. It's really fun. And Nearbytes is just like a quick look into developer space within near ecosystem. So it's like a little news channel of quick little bytes of near information. It's really cool, really fun. So go on our YouTube channel Shameless Plug, go subscribe and check it you.
00:00:54.726 - 00:01:11.410, Speaker A: By the way, I'm always on our Discord Channel to answer developer questions. If you go on to near chat, you can join our Discord Channel if you ever have any questions on building about near. We have office hours every day from 11:00 a.m. Pacific Standard Time to 12:00 P.m. And 04:00 a.m. Pacific Standard Time to 05:00 a.m. Sorry.
00:01:11.410 - 00:01:18.710, Speaker A: P. M. Yeah. A. M. For our European friends. And fun fact about me, I live here in San Francisco and I play dodgeball.
00:01:18.710 - 00:01:47.520, Speaker A: So with that, let's get started. So what is near if you guys are not familiar with it? Near is a layer one blockchain with a block production time of 1 second. It's also a proof of stake blockchain certified carbon neutral by South Pole. So we're an environmentally friendly blockchain. We're very proud of that. And also, we are almost infinitely scalable through our sharding mechanism called Nightshade. I'm going to talk more about that in a little bit.
00:01:47.520 - 00:02:49.566, Speaker A: Near also comes with this EVM compatible layer called Aurora. So if you're a solidity developer and you are interested in utilizing a technology that allows for fast transaction times like low transaction fees and near infinite scalability, you can use Aurora to actually deploy slilly smart contracts onto near, and also exchange assets to and from the near blockchain to Ethereum. So, story time. So Nier was actually originally supposed to be an AI company building on blockchain. What it was for, I'm not entirely sure, to be honest. But the founders, Ilya and Alex, who worked at Google and Microsoft in their hunt for various blockchain, couldn't really find one that was actually easy to develop on and also easy for end users to onboard onto. So they decided to repurpose Nier into something that can be developer focused, founder focused for scalability and easy for its end users to onboard onto.
00:02:49.566 - 00:03:27.034, Speaker A: The way we accomplish that is by offering various technologies for the builders to build and write smart contracts. Like, we have smart contract libraries for Rust. We have one that we're going to be teaching you today for JavaScript. So that way you don't learn a whole new language to write a smart contract and build your sensors application, you can just use what you know and get started. Right today for end users, we have our primary feature of our near wallet, which I'll show you guys in a minute too. It's like a really easy way to essentially have users sign in and sign out your application and interact with the near blockchain. And then for founders, again, it's near infinitely scalable.
00:03:27.034 - 00:03:50.790, Speaker A: So as the blockchain grows, you shouldn't see a decrease in transaction speed or sharp increase transaction fees. And again, it's supposed to grow with the company. So it's really cool. So, yeah, that's 2017. 2018 is when they pivoted blockchain, 2019 is when near built the main net. In 2020 is when we shipped the main net. And then after that, Near Inc.
00:03:50.790 - 00:04:35.780, Speaker A: Actually split into various companies such as Near Inc. Which turned to Pagoda, which is our development branch, near foundation, which is our nonprofit branch, and then Aurora, which is our EVM layer, essentially. And our hope is to become like the primary entry point of web three builders. So why JavaScript? Like, why JavaScript as one of our smart contract languages? Well, we believe that JavaScript is the language of mass adoption. Currently there are around 20 million developers that currently can read and write JavaScript code. And actually I'm just kind of curious, how many of you guys know JavaScript here in this crowd? Like, raise your hand if you guys know JavaScript. How many guys are learning JavaScript also? Okay, so we have a few people who know it, people learning, it awesome.
00:04:35.780 - 00:05:15.582, Speaker A: So, yeah, if you know JavaScript, it makes it really easy for developers to onboard into web three space. So essentially this also allow you to build a full decentralized application in one single familiar language. So you don't have to spend months learning a whole different language for your smart contracts, you can just use what you know and begin building. So with that, again, you can build, test, deploy all in one stack. And what is that stack? I'm going to explain it to you now. So we have Near Sdkjs, which is our library to write smart contracts. In JavaScript, we have Workspaces JS, which is essentially a way to test your decentralized application locally on your computer.
00:05:15.582 - 00:05:50.502, Speaker A: So that way you don't have to deploy it to our testnet. To interact with your smart contract. You can actually run the entire simulated node on your computer and also modify the environment of that node. So block, height, epoch, number, anything you want. It's really, really handy. We also have Near CLI which allows you to interact with the near blockchain from your terminal. It's a wrapper around this next tool called Near API JS, which allows you to interact with the near blockchain by plugging it into your front end application, your backend node script, or again, your CLI, your terminal.
00:05:50.502 - 00:06:23.286, Speaker A: And we have our wallet selector too. So near has a variety of wallets that allow you to sign in or sign out of applications on the near blockchain. So we have our native one, which is my Nearwall.com. We also have a whole bunch of other ones like the math wallet, ledger wallet, and a whole slew of things. So we try to open it up for as many wallets as possible. For this particular workshop, I have a little QR code giving you resources to learn more about our new Sdkjs and how to build on it. We're going to be running through the workshop example project that we have listed here.
00:06:23.286 - 00:06:50.238, Speaker A: So if you guys want to take a picture of this, you can, or you guys can find me afterwards. I can give this to you again. So see a few cameras going up, so wait till those go back down. Cool and cool. If you guys need this again, I'll be happy to give it to you. So yeah, with that let's code. So the very first thing I want to show you guys is essentially a way to get your application off the ground very quickly.
00:06:50.238 - 00:07:52.994, Speaker A: So if you are familiar at all with Create React app, it's a way to quickly load in a project structure so you can have an application ready to go. We have this similar tool called Create Near app which will essentially give you a smart contract template, a front end template with frameworks such as React as our primary one, or just Finljs, or allowing you to plug in your framework or even no front end at all. And also lets you set up scaffolding for our two different smart contract languages which would be JavaScript and Rust. So I know better than to trust conference Wi Fi. So like, I already load it beforehand, but to show you guys what that would look like, you can just simply type in NPX, make this a little bigger. There we go, make it nice and big. So NPX creates near app, then at latest, and then it gives you this really easy prompt to run through.
00:07:52.994 - 00:08:34.466, Speaker A: So select your smart contract language. I would choose TypeScript essentially compiles down to JavaScript for your smart contract languages, just to essentially be more deliberate for your typing of your variables while you're running your smart contract. So just TypeScript, our front end framework would be React JS and then you can just simply give your project a name and then you're off and ready to go. So if I were to again, I already ran this beforehand so I don't load in all dependencies and risk getting stuck on conference WiFi. So I'm going to make this bigger too and then just do code. Actually, I think I already opened it. Yeah, there we go.
00:08:34.466 - 00:09:06.394, Speaker A: So here is essentially like what you would get for there we go, for your scaffolding for your project. So you have contract, you have front end, you have integration tests like all pre built in. I'm going to go through the smart contract really quick just to show you guys what that looks like. So I go to source and go to contract. TS. Make that a little smaller. Close this out and you can see just a very basic smart contract for near right here.
00:09:06.394 - 00:09:48.162, Speaker A: Essentially all it does is allow you to store information on the blockchain, like in the form of a string, and then retrieve information to then be inserted into the application that comes with this template. So it's really simple. All we're doing here is saying is modifying this preset hello to different strings, retrieving that and displaying it to our application. Just to go over these really quick basic tools. Up here we have Nearbind gen, near bind. Gen essentially acts as the glue around your smart contract to make it so that the near blockchain can actually interpret what you're writing. It comes with this handy little it only comes with one little field here called require init.
00:09:48.162 - 00:10:14.702, Speaker A: So if your smart contract has some metadata that you have to want the user or developer to input in before they actually use the application, you can just set this to true. Essentially, initialization functions are functions that only get called once. If you try to call them again, it throws an error. But we don't really need that right now for this particular example. So that's all nearby gen does. Again, it's the glue that makes your smart contract readable to the near blockchain. We have this import for this tool called near.
00:10:14.702 - 00:10:50.214, Speaker A: Comes with a whole bunch of functions that will help aid you in your smart contract writing. We have near log which essentially allows you to return logs both to the console and to the near blockchain. So if you're writing specific events, that's the tool you use. Or if you're just like debugging and you want to see what your contracts are turning, you can use near log for that. We have signer account ID, which returns the name of the last account that signed a transaction or that you're particularly calling to that contract, random seed, which returns like a random string and a whole lot more. So I'm going to go back to the contract. We have call in view.
00:10:50.214 - 00:11:29.058, Speaker A: So call method is essentially a way to change or add information to the blockchain. This will incur what's called a transaction fee in the form of gas. And gas on near is essentially the cost of the computation that goes into a transaction. So again, change methods or call methods, same thing will incur a small gas fee which is typically less than a penny. A view method is a simply a way to query information from the blockchain which incurs no gas fee or no transaction fee. So you can call a view method basically as much as you want. So you can see down here we have our view method called getGreeting.
00:11:29.058 - 00:12:10.514, Speaker A: That just simply retrieves this string and we have this call method or change method called set greeting, which accepts a parameter call and message which is of type string, which will essentially update or change the string. So again, that changes the information of the blockchain. You can see this class here, which acts as your state for the blockchain. So this class is one field called greeting, which is of type string, which is by default set to hello. And that's what we're updating with, the smart contract. So if I run there we go. So here we have a whole bunch of handy little scripts for our smart contract.
00:12:10.514 - 00:12:25.306, Speaker A: So if I run not there, there we go. Package JSON. Yeah. So if I run yarn Deploy, that's going to create what's called a dev account. Deploy. There we go. A dev account on near.
00:12:25.306 - 00:12:54.050, Speaker A: So a dev account is simply an account that's meant to be used for your development environment. It's like a randomly generated account on our testnet, meant to be something you can throw away, something you can use to manipulate it's. Auto funded with 200 test tokens which are just like fake near tokens. So you don't have to risk using actual real near. You can make as many dev accounts as you want. They're meant just to be disposable, essentially. So you can see it gives you like a link to our Explorer showing you.
00:12:54.050 - 00:13:26.218, Speaker A: This is also actually a really cool tool. We have an Explorer for near, so you can get information about a transaction. This particular one just shows that this contract has been deployed to this developer account. It also shows you information about how much gas is attached, how much gas was actually used, the deposit value of near, which is the amount of near gets sent to the contract account and more. So great, we have our developer account and we have deployed our smart contract to that developer account. Before I continue, just want to say one little note. All accounts on Nier essentially are created with an empty smart contract.
00:13:26.218 - 00:14:03.560, Speaker A: So if you were to create an account right now on Nier, you would create an account with an empty blank smart contract. As smart contracts get compiled down to WASM files, those WASM files get deployed onto an account and then Populate said smart contract. So that's all we're doing when I say we're deploying a smart contract onto an account. So awesome. So I'm going to take their account name and show you what our CLI tool is. So if you remember, one of our handy tools is Near CLI. So I can set the contract name, the contract ID as the developer account name.
00:14:03.560 - 00:14:39.666, Speaker A: Then using Near CLI, I can actually retrieve information from the blockchain and display it onto the account. So near view. Let's see contract ID and then get greeting. Get Greeting. And then if I go back to our actual smart contract. You can see that Get Greeting has no parameters in it, so we're not accepting any arguments, whereas Set Greeting does. So I'm just going to put an empty stringified object into my CLI and just hit enter.
00:14:39.666 - 00:15:05.722, Speaker A: And there we go. You can see our preset. Hello. So we just retrieved some information from the blockchain that was preset in our smart contract. Now let's just say I want to update or change this information. I could do near call contract ID, and then it'd be Set Greeting, and then I have the memory of a squirrel. So I'm just going to go back to our smart contract and I can see, oh, we have an argument called Message, and that message is of type string.
00:15:05.722 - 00:15:55.450, Speaker A: So let's include our stringified object type in message, almost messed up message. And then let's do Hi Dorian and then there we go. And then because this is a call method or change method, actually I have to assign this transaction so I can pay for the gas fees that are associated with it, so I can put in account ID. And then the account I have loaded onto my computer is called Blockhead Testnet after some web series I heard about, like from some guy named Dorian. I don't know, maybe check it out. Testnet, blockhead testnet. So it's doing a account function call and cool.
00:15:55.450 - 00:16:35.222, Speaker A: So it gave me it's like empty string because I don't have a log telling me, giving me more information about it. So I'm going to hit this, go to Explorer. I can see it succeeded, which is really good. Now if I go up two more times, get greeting, and then I've updated the information on the blockchain. So that's really cool. So now if I go down here, let's see, close this out. If I go to the actual front end code in the front end folder here and go to this wallet interface, you can see with our wallet sector, I have two particular wallets loaded in my near icon URL and then the ledger wallet.
00:16:35.222 - 00:17:17.170, Speaker A: So my near wallet is our own native wallet that we have available on our blockchain. And then again, there's like a whole slew of different wallet options. If you go to the actual repo, you can actually see what other wallet options there are. I'm not going to go too deep into what's happening here, but we have a handy Dandy sign in function for signing into your application or signing out of your application. We also have this view method and call method structures. So you can simply call this method in your actual application to make it a little bit easier on you while you're writing your smart contract. To build it out, you can see the contract ID here, the method name, the argument parameters, kind of like similar to what we put in our CLI.
00:17:17.170 - 00:18:00.822, Speaker A: You can actually attach prepaid gas onto a method so you can prepay for your gas. You can also attach a deposit. And then essentially a deposit is like the amount of near that you're sending directly to the contract account or the account that has a contract deployed onto it. So if you're dealing with a marketplace, you can send near directly to that marketplace to say, buy your NFT or something. If I were to run Yarn, start says app is starting, it gives you this nice neat little front end for your application. You can sign in, shows you the My nearwallet modal, and then it'll redirect you to my nearwallet.com or testnet my nearwallet.com.
00:18:00.822 - 00:18:26.400, Speaker A: And you can simply sign in with your application. So this is what your end user would see, essentially just like a very easy way to sign in and sign every application. No crazy cryptographic key pairs. They have to figure out how to understand. I'm from Riverside. Like, no one from Riverside is going to want to learn how to understand what a cryptographic key pair is. They just want to sign in like a Facebook application, right? So this is Riverside level usability, which is great.
00:18:26.400 - 00:18:49.746, Speaker A: So I'm going to hit next, hit Connect. And there we go. So I'm signed to my application, and one quick note about signing in. When you're signing into an application, I'm creating what's called function call access key. For this particular application, it says function call access key. I'm sorry. On near, there are two types of access keys.
00:18:49.746 - 00:19:10.618, Speaker A: We have full access keys and function call access keys. Full access keys give an application full reign over your account. It can send all your near tokens. It can deploy contracts onto an account. It can make more keys, which is kind of cool. A function call access key has restricted permissions to a particular account, meaning it can't do that. And it can't do these things without your explicit permission to do so.
00:19:10.618 - 00:19:38.870, Speaker A: It also has a limited budget for gas transactions. If a function call access key were to be called, like, calling a particular method, it only go up to about like zero point 25 near worth of transaction fees before you have to create a new one. So it's a whole key meant to protect your users. It's really cool. Cool. So again, let's see, they already sign in or just let me go wrong sign in. I think it might have like changed this off screen or something.
00:19:38.870 - 00:20:07.136, Speaker A: Let's see. I think it actually modified this during office hours. So yeah, I think it might have broken this actual application. My bad there. Let's just move on to our next example, which is I think a much cooler, much more robust example too. So if I were to go to let's see. So I have this really cool example called our coin flip example.
00:20:07.136 - 00:20:30.676, Speaker A: Going to go over here. So now we know the structure of a particular project on near. We have our front end, we have our contract. We have integration tests. So we've seen this before, so it's pretty cool. So if we go into our smart contract in contract TypeScript or contract TS, and again, TS is just TypeScript. You can write this in just JavaScript if you want, but I would recommend using TypeScript for your smart contracts.
00:20:30.676 - 00:21:09.224, Speaker A: It's just a little more deliberate for writing smart contracts. You can see here is a little bit more of like a complex smart contract, right? We have this function called flipcoin. We have this other function called points of like, what's going on here? It's crazy. And you also have this new imported tool from the Near Sdkgs. So this additional thing is called collection. So on near, we have a variety of collections ranging from vectors to lookup maps to unordered maps to lookup sets to unordered sets. They're just simply data structures that allow you to organize your information much easier onto the near blockchain.
00:21:09.224 - 00:21:36.412, Speaker A: So Unordered Map, for example, is simply something that has a key value pair, right? So give it a key. In this particular game, we're flipping a coin guessing heads or tails. The key in this case is the account name, and the value is the points associated with that account. So if you guess correctly, your points go up. If you guess incorrectly, your points go down by one. That's it. So you can see here we're essentially instantiating this collection by saying points of type.
00:21:36.412 - 00:22:21.572, Speaker A: Unordered map equals this new instance of this unordered map with this prefix called points. The only point of this prefix is just to differentiate this data structure from other data structures that you may use if I were to avoid data collisions on the blockchain. So if I were to copy this and make a new unordered map, I would have to give it a new prefix or else it would throw an error and give me a screen about like, a potential data collision. So, again, the game is just a coin flip guessing game. So we have one type called side. This is a custom type that gives you either heads or tails. We have this function called simulate coin flip, which essentially returns a side or a string of heads or tails.
00:22:21.572 - 00:22:48.320, Speaker A: We have that tool I mentioned earlier called random seed. And this random seed simply returns a random string constructed from our blockchain. And then you can get the character code of that random string and do character code modulo two to either guess heads or tails. So give you like a 10, meaning true or false. So if it's true, it's heads, if it's false, it's tails, and that's really it. So then it returns either heads or tails. So that's the simulation of that coin flip.
00:22:48.320 - 00:23:30.880, Speaker A: Then we have our actual call function, which is flipcoin, which takes an argument called player guess. And that player guess is of type side, meaning their guess has to be either heads or tails. And it'll also return a value of type side. So essentially the player which is like precious or count ID, that's the name of the player gets called here and saved to the value so that's the name of the player just gets saved. Here you can get the outcome of the simulated coin flip and then here you can collect the current player points. So this points get will simply return the point value from that unordered map as a number. And if they guess correctly then they get one point and if they guess incorrectly they lose a point.
00:23:30.880 - 00:24:05.630, Speaker A: Or if they are at zero, they won't go below zero using this conditional statement here. And after that they take the updated point value and set it to and set the new value in that unordered map. So you have the player points or player name as a key and a new updated point value as the value. And it'll simply just return the outcome to the console. Then you have a view method here which is points of so points of this particular player. It just simply retrieves the points that the current points the player has. Or if that player does not exist in an ordered map, it will simply return zero.
00:24:05.630 - 00:24:28.010, Speaker A: That's potentially an entire smart contract. So let's play a game. Let's play coin flip. So we'll do yarn deploy. There we go. Let's see. So it's building the smart contract.
00:24:28.010 - 00:25:14.098, Speaker A: It's pulling it onto our dev account, which we should get pretty soon. Again, conference WiFi. It's wonderful. So I could run yarn start. So here is our near token. One side we have the near logo, the other side we have the founder of near which is our co founder of vneer which is Ilya. I was so happy when my coworker made this.
00:25:14.098 - 00:25:38.680, Speaker A: I think it's the coolest thing. So I'm going to sign in, choose blockhead 27, testnet hit connect and then now we can play our game. So you can see I've played our game for this fifth year camp before, but let's have some audience participation. So if it's heads, raise your hand. If you think it's heads, I want you to raise your hand. So you have 12345. So many to count.
00:25:38.680 - 00:25:56.720, Speaker A: We have most people here thinking it's heads. If it's tails, then you guys win a prize, which is I guess my respect. So good job. So I'm going to hit heads. Oh my God. I think the tails won. Good job guys.
00:25:56.720 - 00:26:21.914, Speaker A: Okay, let's try again. Let's see if the people who lost can make up for their loss. Right, so who now thinks it's tails? Okay, we have like a few tails. Let's see. Okay, the tails won. Oh my gosh, I think the heads are losing. One more time.
00:26:21.914 - 00:26:56.370, Speaker A: Let's go for one more. Who thinks it's tails again? So two people loyal to tails, we're going to choose tails one more time. Okay, well, okay, I think we know who the winners are. I'll let you guys deal with your shame yourself. But thank you guys so much for playing this game and for checking out this workshop. We have a bounty here. For those of you who are building on near.
00:26:56.370 - 00:27:38.370, Speaker A: I think Till prize is like, ten k split into three different sections. For first, it's five k, second place is three k, and third place is two k for anyone building on the Near Sdkjs. So you're building an application on the nearest Kgs using the Near CKJS, then you're eligible to apply for the bounty. If you have any questions, I'll be here after this workshop. And also, we also have people at the near booth go over there, pick up some swag, let them know you came to the workshop, and yeah, thank you guys so much. If I can answer your questions, I'll be here. Cool.
00:27:38.370 - 00:28:17.214, Speaker A: See? One question there. So is near, like, developing, like, contract templates? Essentially, yeah. So we have a few Contract templates, like, in a form of examples on our GitHub repo. For near dash examples. We also have a NFT zero to Hero tutorial. So if you want an NFT Smart Contract template, you can simply go to near, look up the Zero to Hero tutorial, and it'll lead you to the GitHub repo for said Smart Contract. I think Near Dev is actually where you can go for our actual example code.
00:28:17.214 - 00:28:52.300, Speaker A: So go to near dev to see our different examples, too. I can also, if you have questions for a particular template, you can find me. I can help you with your search. Yes, for Python, we actually yeah, I think a few of our command members are making Python. We don't have one internally in pagoda that we're making just yet, but it's definitely something has been in rather high demand. So I hear a variety of community initiatives to try and make the Python repo. We don't have one currently.
00:28:52.300 - 00:29:47.862, Speaker A: Any other questions? Yes, so if you're deploying Near Contract, can you still deploy an Ethereum Contract? So if you're deploying a Near Contract, each Contract account can only accept, like, one wasa file at a time? If you want to deploy, like, a Slilli Smart Contract, that's a little bit of a different process, and you have to go to Aurora. So if you go to Search, like Aurora, I always forget what it is. Like Aurora near there is Aurora Dev. Essentially, this is the tool you could use to deploy a Silly Smart Contract. Essentially. I don't have much experience solidity myself, but from what I understand, it's as easy as changing the endpoint for your Silly Smart Contract deployment to an endpoint you could find in their developer documentation here. So.
00:29:47.862 - 00:30:01.998, Speaker A: Yeah. Check out Aurora. It's really cool. They also have some awesome swag. I wish they were here. Any other questions? Cool. Well, thank you guys so much.
00:30:01.998 - 00:30:06.730, Speaker A: I appreciate your time. You guys are amazing. Bye.
