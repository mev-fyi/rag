00:00:00.170 - 00:00:00.622, Speaker A: Everybody.
00:00:00.756 - 00:00:30.760, Speaker B: Thank you so much for joining us this morning. I'm really glad to host you with Arbitrum this morning. So if you have any questions on this wonderful workshop, feel free to ask any question in the chat. This workshop will be on how to build on Arbitrum. Basically, it just works. And with us today to present you this, we have Fred Lax and Daniel Goldman who will be taking it away and introducing themselves just now.
00:00:31.770 - 00:00:46.854, Speaker A: Awesome. Thank you. We will take it away from there. First of all, thank you to ETH Global and the Scaling Ethereum team for having us and organizing this. So welcome to our workshop. This is building on Arbitrum. My name is Daniel Goldman.
00:00:46.854 - 00:00:52.246, Speaker A: I am a software engineer at Offchain Labs. I am here with hi, I'm Fred.
00:00:52.278 - 00:00:59.562, Speaker C: I'm also a software engineer at Offchain Labs. And we hope to give you a sneak peek on how the developer experiences when working on Arbitrum.
00:00:59.706 - 00:01:29.914, Speaker A: Yeah, so we're going to focus on sort of what you need to know in order to build on Arbitrum. Just as like a quick summary. Probably if you're watching this, you're familiar with Ethereum, probably familiar with some layer two, but just like two cented summary of Arbitrum. Basically it is an Arbitrum roll up is what we're going to be talking about. This is an optimistic roll up style. Layer two solution supports generalized smart contracts on Ethereum and is trustless and permissionless inherited security directly from layer one. All good stuff.
00:01:29.914 - 00:02:04.930, Speaker A: And again, we're focused on sort of practically what you need to know in order to build. So as we get into this, I think a good mental model that is useful to have and we like to sort of frame things this way, is we can think about the various pieces of Arbitrum in terms of this line, this abstract line we draw. And there's the above the line and below the line components. Roughly speaking, above the line is like the layer two parts. Below the line is the layer one parts. So if we start by just thinking in above the line terms, what we mean is we have Arbitrum. Arbitrum is a blockchain.
00:02:04.930 - 00:02:51.602, Speaker A: If we kind of just ignore everything underneath it, right, ignore the rest, we can treat it like any other blockchain, right? Even though it's not an L one and has this other relationship with Ethereum, we can kind of act like it is, right? It takes transactions, it has blocks, there's a state, the state gets updated, it has certain rules it enforces and so on. So modeling, sort of having it in your mind that way is useful. And as we'll see, if you're developing, if you're just doing something only on Arbitrum, thinking of it as its own chain, you'll see it is very similar to developing on Ethereum as far as the bull overwhelmed stuff, waiting for the animation to sink in there. So where Ethereum comes in, it kind of comes in two places. One place is Ethereum is where Arbitrum gets its security. And that's like the massive handwave that we're just going to do. That's the part we're not going to go into.
00:02:51.602 - 00:03:35.230, Speaker A: That's basically the Arbitrum protocol. If you want to learn more about those details, you can see our CTO and co founder Harry gave a talk on Friday, which is on Scaling Ethereum website on YouTube, where he does more of like a protocol overview and deep dive. And then we have this documentation inside Arbitrum which is linked here, which is kind of like the Arbitrum Protocol bible at this point. So we're not going to sort of talk about those security properties. We are going to talk about this other thing that Ethereum does, which is basically the direct interactions between Ethereum and Arbitrum, which can be all sorts of things, but kind of the most important one is moving assets, right? Depositing Ether, depositing tokens. Withdrawing Ether and withdrawing tokens. So we'll discuss how we support those and of course, we have to support those in both directions.
00:03:35.230 - 00:04:03.738, Speaker A: Thank you, Fred, for the animations. Okay, so that's what we'll be covering generally. But again, we're going to start with just above the line. So what I mean by above the line is let's say you want to build something on Arbitrum and again, you want to just build on Arbitrum as though you were building on Ethereum. You're deploying something directly to Arbitrum. It doesn't have any sort of direct interactions outside of the Arbitrum chain itself. So what do you need to know in order to do that? What do you need to be able to do? And basically, if you're a DAP developer already, you don't need to know anything new.
00:04:03.738 - 00:04:27.922, Speaker A: You can use, for example, hard hat. And you can see this. I don't know if you can see my cursor, but you can see the URL. You just point it to an Arbitrum node instead of an Ethereum node and it'll just work. And then in terms of interacting, deploying other contracts, publishing transactions, reading state, you can use Ethers, web3, all of the tooling that you know and love, it all just works exactly the same way that it does on Ethereum. And that's basically it. That's all you need to know.
00:04:27.922 - 00:04:29.662, Speaker A: Thank you for coming to our presentation.
00:04:29.726 - 00:05:15.882, Speaker C: We can ask any questions, but before anyone leaves, we're just joking. There are a few gotchas when you're actually interacting with Arbitrum. And for example, by now we've had a few testnets up for over five months, I believe. And initially we had block numbers in the L two be the same as L one. And we actually changed that to get rid of some weird edge cases that actually started showing up. And now the system that we settled in and are pretty happy with is having the notion of l two block numbers, the arbitrary block numbers and L one block numbers. And we do this exactly so we can keep this seamless experience, because when developers are using, for example, block number for timing assumptions, we want to keep that and not break that kind of contract.
00:05:15.882 - 00:05:52.758, Speaker C: But when you have a sequencer at play, that starts getting a bit weirder. So the design we settled with here, for example, is that whenever you're inside a smart contract and you call, for example, block number, you get VL one block number. So you can preserve timing assumptions. And when you're looking through the JSON RPC interface or from outside the chain, anywhere you're interacting with like a block explorer, you see the arbitrary block number. And of course we have the necessary fortices so you can have access to both of them in both places. But we're talking more about the default block number get exposed to. The second gotcha is we actually use ARB gas instead of gas.
00:05:52.758 - 00:06:32.946, Speaker C: And that is because when you're in the layer two, we have a different set of constraints and a different metering system. And how we account for the computation done and the effort done by the network to actually accommodate your transaction is a bit different. For example, call data costs are mostly like the dominating cost when an L two isn't under congestion. And what that means practically is we have our own system for metering gas. And for example, if you have a hard coded gas limit on a static call or on a transaction you're sending in, that might not be the same in Arpgas. So those are small things you need to tweak that don't necessarily affect the logic of your contract but might not work out of the box in certain edge cases.
00:06:33.058 - 00:06:41.318, Speaker A: Yeah, and just to be clear, Arbgas, as Fred said, it's like the metering is what's very different in Arbitrum, but the actual asset that's used for Arbgas is still ethereum. That's how you pay for gas.
00:06:41.494 - 00:07:25.660, Speaker C: Exactly. And the third glad, I should say ether. Yes, it's our base currency that gets bridged over from the L one. The third Glatch up is we don't have a contract size limit that is bounded by the L one. So the reason for that is actually interesting because the way we do our proving, which is interactive proving, and Harry talks a bit about that on his presentation, if you're interested to go deeper into why that doesn't actually limit us. But that means that when you're actually deploying contracts to Arbitrum, we still have a limit, but we set the limits in a way that we believe that our software can handle and it's much larger than the alone. And the culmination of all these glitches is that pretty much we have a few opcodes that might not behave the way you expect.
00:07:25.660 - 00:08:13.370, Speaker C: The first being like block coinbase, we don't really have a minor mining floor blocks to create an L two block. So that doesn't really make sense in our context. Same for block difficulty. And the three other opcodes are the gas limit, the gas left and the gas price which instead of telling you the gas using the l one metering system, it returns you the ARB gas limit or the ARB gas left or the ARB gas price. And in terms of interrupt, when we look at all these gotchas they're kind of quirky but they usually work out of the box. We haven't found any weird contracts that break weirdly and they're quite easy to catch and prevent. But the more interesting side is when you're actually doing interoperability between the layer one, the layer two and back and all that.
00:08:13.370 - 00:08:46.082, Speaker C: And there are three key components you need to keep in mind when you want to do that using Arbitrum. The first one is the inbox. And what the inbox does is it's the incoming interface for transactions that you want to send to Arbitrum. And outsbox is the opposite. It's the outgoing interface. So the inbox deals with l one to l two transactions and the outsbox l two to l one transactions. And the third component important for interop is ARP sysys which is a pre compile that lives in the L two.
00:08:46.082 - 00:08:55.560, Speaker C: And using this pre compile you're able to trigger L two to l one transactions. So this is kind of like the high level overview and we're going to go deeper into a bit of each of these.
00:08:56.490 - 00:09:37.074, Speaker A: Thank you, Fred. So, yeah, we'll start with sort of interoperating upwards which is to say from layer one to layer two or from Ethereum to Arbitrum. So a way to think about this is in sort of the normal case, if you're interacting kind of above the line with Arbitrum, you create this transaction and you sign it sort of the way you normally would and you hand it off to this Arbitrum node which aggregates transactions and posts them in batches. Right? And when they get posted in batches, this is a roll up. So the data is going to get posted on layer one and then these messages get queued up on layer two and that's where they get executed. Right? So that's kind of the standard way of doing things. When we're talking about interopping with layer one or from layer one to layer two, we're kind of doing the same thing.
00:09:37.074 - 00:10:23.762, Speaker A: We're getting a message into Arbitrum, but instead of doing it kind of from the outside and posting it in these batches, we're doing it directly from a layer one contract. And basically the way we do that is we can just do that. So we have this feature where you can have a layer one contract, make this external call where it includes some encoded data, some abi encoded data of the message that you want Arbitrum to call on layer two. So you can do some stuff on layer one and also do some stuff on layer two in a single transaction. The sort of textbook case of when you'd want to do this is bridging tokens, particularly depositing tokens, right? So depositing a token means what? Well, it means on layer one, you're sending it to a contract where it gets escrowed. And then on layer two, we're saying, okay, the token got escrowed. Let's mint some token where it's where it's available.
00:10:23.762 - 00:10:56.926, Speaker A: We'll talk about withdrawing later. So this lets you do that. You can do those two things. Now, an important consideration here is it's very important that this operation is atomic, which is to say we want either both to happen or neither to happen, but not one. In other words, you can imagine a situation where you escrowd the tokens on layer one so that l One transaction succeeds, but then the arbitram transaction reverts, right? And now what's happened is you've just sent some tokens to a contract and nothing else happened, and you lost your tokens. And that's bad because you like your tokens. So we account for that.
00:10:56.926 - 00:11:31.670, Speaker A: That's this sort of retryable part. The way these interactions work is they create what are called retryable tickets. And basically what this means is if you're doing this when you use a retryable ticket, if the layer two side of one of these transaction reverts for any reason. But I guess the important one here is if it reverts due to insufficient gas, insufficient ARB gas, you can kind of just try to retrigger it. So for about we have some time period, about a week, it kind of lives in this retry buffer, and you or anyone else can just execute it again. So in this case, okay, your tokens didn't get minted because you didn't give it enough gas. You just try again with more gas and you're safe.
00:11:31.670 - 00:11:45.610, Speaker A: Basically, as long as you use this for any sort of operation where you're doing an L2 thing from layer one. If you use this for triable tricket, you should be safe, right? Because you're guaranteed this atomicity.
00:11:46.110 - 00:12:03.810, Speaker C: And it is a bit weird if you think about it. Like, you have a contract on the l One that needs to pay L2 gas, and it can get annoying to manage your funds with those dynamics. So what you can do is the l One contract creates a ticket, and then you have a new way, an externally owned account on the L2 that pays for the gas that that contract created.
00:12:04.310 - 00:12:27.242, Speaker A: Yeah. And that's the other thing that we're very happy with, how this method has settled. We think we covered everything. The other thing that's handled here is those dynamics of, like, there's layer one, gas to pay, but also layer two, gas to pay. And what if you overshoot it, right? What if you give too much gas for layer two or something? Basically, with the retryable tickets, everything also gets refunded safely. So in the worst case scenario, you overshoot it. You'll just have your extra ether available on layer two.
00:12:27.242 - 00:12:54.674, Speaker A: It's a little more, a few layers of complexity there that's hard to just explain briefly, but essentially there's no way that you can lose funds. So this covers all those nasty corner cases. And to be clear, you can do this with anything. So you can encode any sort of layer two contract call from layer one. The example I gave here is the Bridging tokens and I want to go a little deeper into that example. So you can look at our bridge. We link to it somewhere in here.
00:12:54.674 - 00:13:34.862, Speaker A: But our token bridge basically on Arbitrum, there's no native notion of tokens. There's no native notion of a token bridge. We don't need it. All we do is we leverage things like these retryable transactions to build this bridge basically as a DAP, right? So it has contracts on layer one and layer two and they communicate with each other in these specific ways. In terms of the bridge itself, the sort of layer one to layer two communications that need to happen is we say, okay, there's some ERC 20 contract on layer one. We need to create a sort of paired up corresponding contract on layer two, right? When you deposit, it's got to end up somewhere at its own ERC 20. And basically so that is one case.
00:13:34.862 - 00:14:13.658, Speaker A: Like the first time you interact with one of these tokens through the bridge, we deploy a kind of standard RBRC 20 contract on layer two, which includes the standard open Zeplinearc 20 stuff, along with some additional stuff to handle bridging, minting and stuff like that. Obviously, we need to be able to deposit tokens as we described earlier. So once we have a layer two pairing there we can deposit. And then we also added this nice feature which is mint and call. So minting is like the layer two side of depositing. If, say, you want to deposit something on Arbitrum and immediately stake it into some lending pool, you can just do that in a single transaction. And as with before, that call part is arbitrary.
00:14:13.658 - 00:14:16.000, Speaker A: So, yeah, you get a lot of flexibility there.
00:14:19.970 - 00:15:13.930, Speaker C: Yeah, so we've seen how the flow goes upwards when you're going from the l One to the l Two. But when you're going downwards from the L2 to the l One, there is also some interesting interactions to look at. And the way you can trigger L2 to l One transaction from the l Two is by talking to the Arpsys pre compile. And there is a function in this pre compile called Send transaction to l One and it allows you to trigger an arbitrary call in the l One as well. And how this works is you give it a destination address and any call data you want to be triggered on the l One and that's it pretty much at least the start of it. After that, you need to arpos batches many of these l Two, two l One transactions together into a single merkle route. And this merkle route is then part of an assertion that is made by a validator on our protocol.
00:15:13.930 - 00:15:39.960, Speaker C: And how this works is after you wait for the roll up confirmation time, which is part of every optimistic roll up sending messages from the L2 to the L One, you're able to trigger this call. And how you trigger it is you give a merkle proof of the inclusion of your transaction in the ad assertion. And all this is part of the outsbox that we mentioned earlier. And we have many convenience methods that help simplify this flow for you.
00:15:41.310 - 00:16:03.950, Speaker A: Yeah, and I'll just say also in this case, once again, you can encode any l One contract call from l Two, so it's generalized. And here we don't necessarily get into some of those complications with gas because basically whoever triggers the OPAC message is just paying for gas on l One. Right, so it's in that sense a little more straightforward than the other direction. But yeah, in both cases we can do generalized contract calls in both directions.
00:16:05.090 - 00:16:51.470, Speaker C: And this also comes with a few small gotchas. And there are two main ones. The first one is after your transaction gets included into a merkel route, it can be replaced on the all one until it actually succeeds. So that means if your transaction reverts, you can try it again and be it because you're out of gas or because of an external contract dependency and you can keep on retrying it. The second gotcha is that the metadata for a transaction isn't available in the traditional solidity syntax because it works, let's say, sort of like a meta transaction. So, for example, if you do message sender, you're going to see the outboxes or the bridges address, you're not going to see the actual L2 sender. So what you can do is you can create the alt box to know the message sender or the l Two block number and timestamp in which this transaction was created.
00:16:52.530 - 00:17:42.686, Speaker A: Yeah. And so there's sort of a more general gotcha that I think most people now understand about optimistic roll up or any optimistic style layer two solution, which is when you're going in the one direction, there's this delay, right, which is to say, from l two to layer one, you have to kind of wait for the dispute period. And this is just sort of the fundamental security property of roll up. So in some sense, it's unavoidable that you'd have to wait for this window. However, the good news is that if you are withdrawing something that is fungible, which is to say ether or some token, we have all sorts of ways of speeding this up. Right, and the techniques here, basically we like calling them liquidity exits, also atomic swaps. But with all of these things listed here, the general idea, I'm just kind of looking at the clock to debate how much detail we want to go into, so I won't go into too much detail, but general idea here is you want to move some token from layer two to layer one.
00:17:42.686 - 00:18:28.030, Speaker A: Instead of waiting and doing the slow withdraw, some untrusted third party can say hey, I'll just take that from you and I'll send you tokens directly on layer one, okay? And basically the idea is, because this is a roll up, everything is transparent, everything is published on chain. At least in Call data, they can see that it's going to be valid and they sort of absorb this cost in terms of time preference. So we have one implementation that does something like this. That's our token bridge link. So in our token bridge, we just include the simple method that lets you do a version of this. We've had other third parties that have built really cool stuff. Hop Exchange does something where it kind of batches withdrawals together and then a liquidity provider can see that they're valid and kind of provide liquidity at the destination.
00:18:28.030 - 00:19:02.554, Speaker A: Connect is kind of in some sense a very different approach where you don't actually do a direct withdraw. You just sort of do this atomic swap via hash time lock contracts across two chains. That would be like the way I get my token from Arbitrum to Ethereum is I just send some of that token on Arbitrum and then they send me some on Ethereum. None of them actually crosses through a bridge. So Seller has its own mechanism. All these mechanisms kind of have their own pros and cons. It's also kind of a really broad and interesting design space in terms of coming up with new ways of doing this, ways of incentivizing liquidity application specific fast stuff.
00:19:02.554 - 00:19:09.340, Speaker A: So this is definitely if you're thinking of hackathon ideas, this is a good thing to ruminate on, which maybe we'll talk a bit more about later.
00:19:12.110 - 00:20:04.394, Speaker C: And in terms of when you're building smart contracts, it's not just about the Solidity or the Viper working or whatever. It's about the whole infrastructure and tooling setup actually working for you. And that's something that we have that comes from actually our Bos and us sticking the JSON RPC interface from Guest and we have things like chainlink the graph truffle onboard JS Ethers and they all work against Arbitrum out of the box. And the cool thing is that much of the tooling actually works because of the JSON RPC interface. And there has been a start in actually moving forward to having tooling that understands the multi chain worlds better. But all these tools work really well when you're looking at a single chain such as Arbitrum or Mainet. But when you start looking at different chains interacting together or layer one to layer two, these are things that still aren't there.
00:20:04.394 - 00:20:14.830, Speaker C: There has been a community push to improve all these but it's actually a very big thing for this hackathon, at least in my opinion. That is there's a huge space to build things with this mentality.
00:20:15.330 - 00:20:53.046, Speaker A: Yes. And on that note, we'll just quickly go over our prize bounties for this hackathon so you can see one of them is best Arbitrum related tooling. And stuff Fred was just talking about is definitely a fruitful place to start is to think about what tooling out there could use better multi chain support. And yeah, it's sort of like Fred said, the ecosystem is kind of in this midway point where it's starting to happen more. And know wallets block explorers, data providers are sort of integrating this multi chain stuff but there's still a lot of work to be done, including some low hanging stuff tooling. We're also including stuff like data know, getting stats on Arbitrum. Anything around there is fair game for that prize.
00:20:53.046 - 00:21:22.886, Speaker A: Best use of Arbitrum scalability that's kind of the most broad, that's kind of the above the line prize, right? So just build something cool. That the sort of thing you might build on ethereum but build it on Arbitrum. And we're especially interested in ways that you really take advantage of the scalability gains. So maybe something that would be priced out practically on layer one or even literally impossible to do on layer one because the contract is too big and it's past the size limit. Or transactions require more execution that can fit in a block. Stuff like that is definitely stuff we're excited to see Bet use across train interrupt. That's a lot of the stuff we talked about.
00:21:22.886 - 00:21:53.554, Speaker A: Now this kind of L2 to L One, l One to L2 messaging system and there's all sorts of stuff you could do there. I talked about moving liquidity in faster ways. There's also, again, some application specific stuff is kind of cool. Think about how you can design an app where it has some messaging built in. Yeah, you can go wild. Best integration with the Arbitrage protocol is actually maybe kind of the broadest. But this is stuff that some sort of application that kind of interacts with, let's say, the fraud proof and dispute logic kind of, sort of.
00:21:53.554 - 00:22:32.422, Speaker A: So, for example, having some insurance market where you can get some crypto economic guarantee that an Arbitrum assertion finalizes the right way, something like that. Again, that's another category you can really go wild with. But yeah, we're very excited to see what people come up with. We've already spoken to a few and people have cool ideas. Cool. So yeah, what now as far as what's next? Again, if you want to get started building, you can just get started building. We have this token faucet you can use to get some testnet stuff directly on Arbitrum, meaning like testnet ether, which is coven ether, our testnet's over coven.
00:22:32.422 - 00:23:11.802, Speaker A: And also we have just some testnet token that we deployed that you can play with. We do not have an official token. It is strictly a testnet thing. This Arbts is a client side library, a TypeScript library, which basically it abstracts a lot of the details, particularly around Bridging tokens, deposits, withdrawals, tracking, balances, kind of abstracts that away. So I definitely recommend using that if you're doing something that is related to Bridging bridging tokens. Also, a lot of the stuff we talked about is documented, but I will just say the documentation is in a state of being updated, so feel free to just if there's something that is confusing or something we mentioned here that you can't find documented, just reach out to us. Happy to answer.
00:23:11.802 - 00:23:17.050, Speaker A: We'll probably just send you a link of like, a branch that's not yet merged because most of it should be out there somewhere.
00:23:19.950 - 00:24:01.462, Speaker C: We also created this repo called the Quickstart Interrupt. And what we did there is pretty much this presentation is the high level idea and if you want to get hands on and see what are, like the specific code segments we're talking about, you can go there and check. These slides are over at the Eat Scaling Discord if you want to check it out. And if you open the Quick Start Interrupt, you can see, for example, the Create retributable tickets that I saw someone in the chats was asking about that you can see, for example, how to trigger an L two two one transaction as well. It has pretty much the general overview, so you can start coding. We also have a small document, the testnet contract addresses that has, for example, the Inbox address and those kind of things, so you can get started building.
00:24:01.596 - 00:24:17.326, Speaker A: Yeah, some other infrastructure we have. The graph Ether is already deployed, things like that. So it's a good place to start. If you're deploying here's, links go free to reach out to us. We'll be active on Discord. We're generally active on Discord, but especially now during the hackathon. And, yeah, the inside Arbitrum, that's the one we mentioned.
00:24:17.326 - 00:24:49.206, Speaker A: If you really want to do a technical deep dive, that is the place to start and probably end. Should have everything quick Shout out, we are hiring, so please reach out to us if this sounds like something you want to be a part of. There's all sorts of roles open and I think with that, most importantly, you can follow me here on Twitter. You can follow Fred as well. Thank you. With that we can open it up to questions. So, yeah, if there's any questions from the chat or I see we have a nice little crowd here on Zoom, feel free to just unmute yourself and chime in.
00:24:49.206 - 00:25:05.600, Speaker A: But yeah, I also thought we could take this opportunity to share some of the ideas that Fred and I are we've been sort of brainstorming on, like, what would we do if we were part of the hackathon? Which we are not, because that would just be unethical. But there's definitely a lot of stuff that could be done here.
00:25:06.610 - 00:25:51.340, Speaker C: I do. Have my personal favorite that maybe I'll start by sharing that, which is there's a great space for execution markets to be created because if you remember going back daniel, could you go back to the downward slide? Yeah, if you look at the downward slide, the thing is you have two transactions that need to happen here. You have the first transaction, which is to trigger your L2 to l One transaction. And then after the roll up confirmation period, you need to trigger the l One transaction. And there's a really cool space there for you to create an incentivized execution market so that users don't actually need to execute that second transaction because anyone can trigger it. And you can do some pretty cool setups for that. And that's something that please someone build.
00:25:51.340 - 00:25:53.020, Speaker C: I'm begging you.
00:25:53.630 - 00:26:18.120, Speaker A: Yeah, especially for things that, as a user, you kind of want to just be able to set it and forget it. Right? So that's different than a withdrawal where I want to have access to my money and maybe use it next. But if this is like the result of a token vote or something along those lines, as long as it migrates its way to layer one, eventually you're happy. So the ability to just say, here's a fee. Someone will execute it later, it's nice. UX. And, yeah, fairly low hanging as far as things go.
00:26:18.120 - 00:27:20.970, Speaker A: I think another one that I sort of alluded to is and kind of related stuff like for the stuff that you can't do like fast liquidity exits for like withdrawing a non fungible token or any sort of non fungible bit of data in the abstract sense. You can't directly inherit Arbitrum and ethereum security for any sort of fast withdrawal in that sense. But if it's acceptable for an application, you can build some other security considerations. You can withdraw an NFT and then basically, for example, have this crypto economic claim that I swear that this token that I have on layer one represents valid ownership of the NFT, and if I end up being wrong, I get slashed. That kind of thing. And I think you could probably generalize that in some interesting ways. So, yeah, I think reaching those cases because this is just fundamentally one of the limits of optimistic style roll ups, thinking about making that more kind of broadening the type of fast exits we can do, even if it involves some different security assumptions, is a cool space to explore.
00:27:22.750 - 00:27:49.234, Speaker C: And in terms of places to see code and get started, we have the interrupt quick starts that we mentioned. And what that does, just reiterate, is the classic greeter style contracts that people do when starting off. You can have a greeter on the L2, a greeter in the L One, and they greet each other. But we also have a token bridge implemented that wraps around all that. And if you want something a bit more hardcore and some more intense codes. That's also a great place to look at.
00:27:49.432 - 00:28:28.800, Speaker A: Yeah. So the solidity code of the Token bridge, that's the most extensive usage of our interop stuff. And then yeah, this RBS repo, if you look at some of the tests, I think is probably the best place right now where you can just see how to instantiate things and how it works. But, yeah, if you're literally just doing deposits and withdrawals, RBS is going to be the easiest way to do it. If you want to more directly interact with the contracts, our documentation does show you how to do that. And yeah, excited to see what people come up with. We still have, like, a minute or two if anyone has any questions, but otherwise, again, we'll be monitoring the discord and taking any questions there.
00:28:32.210 - 00:28:39.970, Speaker B: Thank you so much. Daniel and Fred, there are some questions in the chat. I don't know if anyone wants to pitch in verbally.
00:28:41.030 - 00:28:43.140, Speaker A: Yes. I didn't see those. Sorry.
00:28:43.830 - 00:28:52.982, Speaker B: Yeah, there's a few questions that came from you in the chat. Worst case, you can always address them in the discord or you take the two minutes that we have left to cover.
00:28:53.036 - 00:28:57.480, Speaker A: Yeah. Fred, do you see them? I think I'm just scrambling with Tabs here.
00:28:58.170 - 00:29:53.634, Speaker C: We have, like, a minute left, so pick a few low hanging ones. There's a question, which is, can we verify contracts on the Block Explorer? So right now, we don't have contract verification built in, but what you can do is you can always just compile the contract yourself and see the created bytes codes from that. And you can check it against the box Explorer does show you the deployed bytescode. Or you can query yourself the JSON RPC interface and see and verify the contract effectively. Let's see, where can we access the slides has been found. If we could review the size limits, what is it, and in what cases would you come up against it? So sometimes people write very big contracts with a lot of logic and with superclasses that they inherit from, and the contract gets very big, and then you can't deploy it. So what you do is instead of inheriting, you do a composability set up.
00:29:53.634 - 00:30:00.186, Speaker C: And the downside of that is that you need to do external calls for that. And I don't know, all ethereums here.
00:30:00.288 - 00:30:03.630, Speaker A: Are probably also just need to rewrite your contracts, which is inconvenient.
00:30:04.530 - 00:30:30.180, Speaker C: And also external calls. Prices went up recently, I think it was two days ago. So that's also not very nice. And the cool thing is your design isn't constrained by the system itself, it's constrained by yourself. And we do have a limit, but it's pretty damn high. I'm curious to see if anyone's able to hit it. If they do, please send on our discord with codes that actually make sense.
00:30:32.410 - 00:31:04.220, Speaker B: Thank you, guys. I think we'll wrap this up. I see there's a few questions that are remaining feel free to go in the discord, post more questions. Daniel, Fred and their team will be there and help you brainstorm and debug whatever you may have may encounter. So thank you for this amazing session. Really appreciate having you and yeah, looking forward to some of the cool projects that come out of this.
