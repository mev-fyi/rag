00:00:06.330 - 00:00:18.910, Speaker A: Jordy on stage and Jordy's going to be talking about Polygon Hermes and special introduction to the polynomial identity language. So, without further ado, let's welcome Jordy.
00:00:21.010 - 00:01:20.014, Speaker B: Hello. Hello everybody. Thank you very much. Let me share my presentation right now. First of all, before starting, I just want to welcome to the Polygon Zero people. It's a luxury to have them on board and very excited to work with already, as Daniel and Brandon already said, we have been already working with them in the last weeks and has been very productive. And I also want to thank you to the Polygon founders for setting up this collaborative environment in the technical things, I think that we can go much farther together, helping one each other as a team.
00:01:20.014 - 00:01:56.806, Speaker B: So it's going to be very incredible. And I'm sure that we are going to scale Ethereum. That then is the goal that we have altogether. So, with that said, I'm going to present today the pill, just to understand where the Pill fits in the project. Well, let me just here, just second, let's see. Okay, the most critical thing for roll up is generating this proof. Generating this proof is quite hard.
00:01:56.806 - 00:02:47.766, Speaker B: But the idea of this proof is we have a note state, we have many transactions. In the case of Hermes, we have normal Ethereum transactions. We want to be EVM compatible by code, but by code we don't want to compile or using the compiler. We just want to implement the actual bytecode. So we have normal Ethereum transactions and we want to create a new state route. Okay, so building this circuit is this deterministic program or this circuit is the challenge. So to build this circuit, what we do is mainly well, the project that we are following right now is we are building a Stark and then in order to reduce the gas cost to 300K or even lower, is just to verify this Stark with a Plunk or growth 16 proof.
00:02:47.766 - 00:03:36.230, Speaker B: So this is the main approach and the fact of using Starks, this is a little bit game changer between traditional R one CS systems like Plonk or Gloss 16 and more polynomial base. This is in comparing with electronics. This is just working with Normal and SANORS, normal gates and you just put them, a lot of them. Or when you introduce the clock, when you introduce a clock in the circuit, you can reduce the Semelectronics and run many cycles. So here is where the polynomial takes very importance. When you read the word polynomial, just understand it as an array of values. At the end of polynomial is a set of values.
00:03:36.230 - 00:04:15.382, Speaker B: You can represent a line by two numbers. Well, you can represent a big polynomial with many numbers. So you just have the values. And this works well in this concept of clock of a step. So you have a state machine, and every time in the state machine, you have a new value. And this is represented by a polynomial in each step, one value and so on. The idea of defining this prover is that we need to commit to a set of polynomials and then defining a set of relationships, identities between these polynomials in order to build these state machines that work together.
00:04:15.382 - 00:05:25.226, Speaker B: And here is where the polynomial identity language, this language that we created for creating these special relationships between polynomials and building these state machines with this relationship, with this set of relationship with this compiler, this will be used for generating the Starks, for generating the prover of the Stark and then the verifier of the Stark. So to start, I think the best way to understand how this polygonal identity language is just do an example of how this works. Okay, let's start with what would be the hello world of this language. In this case is we are defining a very simple state machine that actually computes 32 bit numbers from two numbers of 16 bit numbers. So it's a state machine that has two steps, okay? So it's just even steps and OD steps. In the even step we just get a number and put it in a register. And in the second step we just shift the register and add the second number and then we start over again.
00:05:25.226 - 00:06:01.078, Speaker B: So we can generate as many 32 bit numbers as we want. So we have one register in this case is one state variable, this case is Oat and we have one input that's a value that we can put at any state. We can put the value that you want, we can put each value and every two steps we are generating one new 32 bit numbers. So hope we would rewrite that in pill. Okay? This would be as simple as that. We have a constant polynomial. It's a constant polynomial that's so the first is, the first number is one, the second 010-1010.
00:06:01.078 - 00:06:50.562, Speaker B: It's like the instruction, what it's doing? We have the frame, the input of the system, the number that we freely can set to any number that we want and we have the register itself, the register out. Okay? And then we start defining the constraints to these polynomials. The first constraint is that we are forcing that free in. It's a 16 bits numbers. Okay? In this case we are doing it's included in another constant polynomial that we have defined. It here on top that includes all the numbers between zero and FFF. So all the 16 bit numbers, okay? So with this we warranty that the free in can be any number but just between zero and zero xFF and then we define the constraint for this state machine.
00:06:50.562 - 00:07:24.050, Speaker B: Actually, we are saying that the next step must be if set is one. If it's the first step, then this is going to be one. The second part this is going to be zero. So if it's one, we are just putting the input to the register. Okay, if a set is zero, so it's the second step, then this is going to be zero, but this second one is going to be one. And then what we are doing is we are shifting the out and adding the free in. So every two steps we are generating a number that we know for sure that's going to be maximum 32 bits number.
00:07:24.050 - 00:07:54.406, Speaker B: And we define it this way. Let's move to a more complex state machine. This case we are going to define state machines that generates groups of five numbers of 32 bytes. Numbers that fulfills this relationship. A times B plus C must be D to two, to the 32 plus E. Okay? So we are dividing this most significant bit and less significant bit. We are doing the arithmetic operation.
00:07:54.406 - 00:08:33.010, Speaker B: In this case, it's a multiplication and a division. Okay? So how we do that? Okay, we have a state machine with five registers, ABCD and E. And the idea is that in the five first steps we are just latching. We are putting the input, we are setting these registers, we are setting A, we are setting B, we are setting C, we are setting D and we're setting E. And once we have all the registers set, then we force the condition. When we have to force the condition. Well, we have this next polynomial, we call it latch.
00:08:33.010 - 00:09:13.170, Speaker B: That's actually when you want to force that, this condition fulfills. So we have a state machine where you just load five numbers and then you are forcing that these five numbers fulfills this condition. So how would we write that? Well, we will write this. We have this constant polynomial, set A, set B, set C and set d and set d we have also the large polynomial and we have also the free in it's, the input, and then we have the five registers. Okay. And here we start adding the constraints. The first constraints is we say free in must be a 32 bits number.
00:09:13.170 - 00:09:47.710, Speaker B: Here is the first thing that it's important. We are using the results of the other state machine, the bytes four out. So this free must be a number that must be included in the bytes. That means that this number must be a 32 bit numbers. Because we have the conditions that we generated in the last state machine. Then we calculate the next state machine in case it's A prime, B prime, C prime and D prime. And this is if set A is one, then we just set the free into A, and if it's zero, we just keep the last value.
00:09:47.710 - 00:10:32.798, Speaker B: Okay, so this is the conditions for the next ABC and d. Okay? And finally when latch is one, we must fulfill that molesum is zero and molesum is like an intermediate polynomial that we say that A times B plus C minus d to ten to 30 plus C and this must be zero in order to fulfill this operation when latch is one. So here we just define it a state machine where we can do arithmetic operations. In this case it's this addition plus here you can do an addition just for example setting B to zero or you can do a subtraction by setting A and B. We'll see in the next example how we use this arithmetic circuit. So let's now build something more complex. Okay, let's build a computer.
00:10:32.798 - 00:11:22.622, Speaker B: Let's build a state machine that actually execute instructions. Okay, so here we have five registers, we also have a 6th register. We call it the program counter actually is the line that I'm executing. This is another register that this is in this state machine we have a bunch of polynomials that are somehow they are the instruction that I want to execute. Okay, we'll see these polynomials, how this works but this is the instruction. We have also a frame and with this we have a state machine to go from A to A. Prime is the next state of A and we are evolving, we are executing we can put any instruction that's defined by all these bits that compose the instruction and we are executing this.
00:11:22.622 - 00:12:11.310, Speaker B: Okay, so let's see different instructions how this would work. Well, first the definition would be just we define all these polynomials the same way that we saw before. We define here set of for these instructions must fulfill some initial conditions. For example, we want that in a be binary. So we say that in a times in a minus one must be zero. Here the only condition for this to happen is that in A is either zero or one. We want free in to be also a 32 bits numbers, we want also the constant to be also 32 bits numbers but in this case we are at an offset just so that const can be also positive and negative 32 bit numbers but signet positive big numbers.
00:12:11.310 - 00:12:48.086, Speaker B: Okay? And we have an address that's just 16 bit numbers. It's the by two, the one, the first one that we had. Okay, so let's start with instructions that move from A to B or from B to A or something like that. Okay, for this there is part of the instruction that it's in A, in B, in C, in D and in A. Here these are selectors of which register we want to we have this intermediary register, we call it op. Okay? So the data is we will load from eight B-C-D and E and we load to op. Okay? This is the first line of the polynomial language.
00:12:48.086 - 00:13:16.802, Speaker B: So if in A is one, then we load A. If in B is one, then we load B. Okay? We add them together. We can also set a const. We can also put a constant value so the instruction can have a constant value. For example, if we want to put seven in register A then const would be value seven. And we also can select the free in and we set we have these set values to ABC and D.
00:13:16.802 - 00:13:44.970, Speaker B: So, for example, if I want to move from B to C, then in B would be one, the other. Scenes would be zero. The points would be zero. And set C would be one. And the set A, set B, set D and set D would be zero. Okay? So in this case this will fulfill this relationship. If I want to put a seven in D, then const would be seven all in A and B in C and D in E and in free would be zero and the set D would be one and the other sets would be zero.
00:13:44.970 - 00:14:43.934, Speaker B: Okay? And this is how we define until these instructions. So the instructions for moving, okay, we can also do conditional jumps, jumps and conditional jumps. In this case we have a circuit, I'm not going to enter in detail how this works, but we have a circuit that determines if the operator is zero or not. And if it's zero and the instruction is a jump, then instead of loading the program counter to the program counter plus one, we just load a new address. So we do a conditional jump in here just by defining, by defining which condition the next program counter must fit. Okay, so we have conditional jumps and we want to do also arithmetic operations. We can want to do multiplications additions and so on and how we do that.
00:14:43.934 - 00:15:39.486, Speaker B: Okay? And this is probably the most important slide of my presentation because this is the trick and the main thing that we are doing here. Okay, so here is we are connecting the last state machine, the state machine that do operations with the main state machine. When the main state machine we have the instruction arithmetic. When we force we have this arithmetic instruction, then we are saying that the values in ABCD and the operator must be included in the last state machine. Arithmetic A, arithmetic B, arithmetic C. And so somehow what we are doing is we are connecting in the main state machine. We are assuming that summary metting function is okay.
00:15:39.486 - 00:16:19.702, Speaker B: So we can set up freely, we can put the values in the registers and we are saying okay, these conditions must fulfill and we assume that this is okay. But this is because this is delegated, the verification of this is delegated to the other estate machine. And this concept of connecting different state machines with the Plockup again, thank you to the Aztec people with the Plocap idea. This is a great thing. This allows us to connect these estate machines and this is what allows us to do engineering. We can generate like many state machines that are doing different things and connect them all together. Okay? Of course, now we have a processor.
00:16:19.702 - 00:17:19.226, Speaker B: So we have a processor. Then we need to define an assembly. This is a little bit how we would work the assembly. We define this from going from one register to other and we have the arithmetic or the Jumps operation. So this is an assembly but there is something that's missing here and it's how we warranty that we are executing the right program. We want to have like a Rom, we want to have a program and we want to force that we're executing a program because if we see here these are free inputs, you can put any instruction that you want, this is okay, it will fulfill these relationships but how can I create a Rom and execute this program? Okay, so let's move forward and from this assembly we create this table. So we encode these instructions with bits we have in A and B and C and D and we create what we call it a Rom.
00:17:19.226 - 00:17:49.334, Speaker B: A Rom at the end is another polynomial where the first instruction, the second instruction, the third instruction and we encode all these polynomials somehow. This is a bini polynomials. We have the constant, the constant value which wider the address and we also embed the line with the line of the line of the program. This is the first line. Well, the line zero, line one, line two, line three, line four, line five. Okay, so we have a set of values and with this we have a polynomial. Okay? We have a polynomial, it's the Rom and we want to guarantee that we are executing this Rom.
00:17:49.334 - 00:18:21.938, Speaker B: And how we do that again with a single block up we are taking all the polynomials that compose the instruction, the address, the set A, set B, Jumps arithmetic, all the instruction altogether. We pack the same way that we did it in the Rom instead of having the line in this case we have the program counter. The program counter indicates which line should be executed and then we just force in the last is that in strace is included in the Rom. With this condition we guarantee that we are executing actually a Rom.
00:18:22.034 - 00:18:22.342, Speaker A: Okay?
00:18:22.396 - 00:19:24.398, Speaker B: So with this we can have a Rom that executed. So we have a processor with a Rom that's executing and all that defined it with polynomial identities with this language. Okay? Of course the EVM for building the EVM, the state machine is similar to this but with much more complex. We have of course instead of working with 32 bits operations, we are having 256 operations. We need to deal with the gas, we need to deal with the maximum, we need to deal with the stacks, we need to deal with the calls. So there are some extras because we are tailor mating this processor in order to execute of codes, ethereum of code. So this is why we are adding these fine tuning things that will help us to implement the opcodes but they are the same of course will be many other state machines like Kecax Signature Verifications comparators.
00:19:24.398 - 00:19:54.446, Speaker B: There is a lot of state machines but with this we will create the full Ethereum virtual machine. So Summarize is we have this pill language. This is like the hardware layer. We are defining these state machines that work together. With this we define the state machine. We have an assembly and with the assembly we create a Rom which actually has a specific program. And it's a program that actually implements Ethereum.
00:19:54.446 - 00:20:22.582, Speaker B: It's a program that process as an input process many transactions and calculates the new state. Actually it's a single process that executes all this. Okay, we have an executor that actually is the runtime, the thing that takes up the transactions and actually creates these polynomials. And then with this we generate the Star. This is better represented in this next slide. Okay, so we have the executor. Executor generates a proof.
00:20:22.582 - 00:21:00.770, Speaker B: Of course. Here we have an assembly, we have a Rom. We compile that to an assembly and we plug it to the executor. The executor generates a Stark. With the pill language we compose the Stark and with the pill language through Circum and all the Stark we generate a circuit to validate the Stark. And then at the end is verified in is the process is very much this. Of course the prover is not the only thing that we have to implement.
00:21:00.770 - 00:21:25.610, Speaker B: The prover is just a piece of running of Uzikvn. There is also a note with all the transaction pools and so on and of course all the smart contracts. Layer one, layer two here if you want to see how we are going to do all the transfers. Layer one to layer two. I did a presentation in Liscon so you can find it in YouTube, you can find there. And of course we also have this coordinator selector. We have a new protocol.
00:21:25.610 - 00:21:50.594, Speaker B: We now improve efficiency. Probably we'll have some opportunity to explain how it works. But this also what gives the centralization. But all this piece is what we are building somehow in Hermes and the planning for Hermes. Of course, this is not full commitment. This is a project we are doing is quite challenging. But this is the schedule that we are managing internally.
00:21:50.594 - 00:22:24.466, Speaker B: We are very excited right now. We are running very fast. We have an incredible team right now that's very motivating for doing this. I think we have at least in my eyes, we have the best team in the world for creating that. I'm sure that we are going to get it. We are very excited and yeah, looking forward and hope to scale Ethereum very soon. I don't know if there is any questions but that's all on my side.
00:22:24.648 - 00:22:42.470, Speaker A: Thanks so much. Jordy, there's a couple of common recurring themes in the questions which is people want to know how they can learn this on their own pace. Because there's a lot that happened in this talk and people are curious if they can find whether it's a copy of your presentation to other links to understanding where you've talked about PIL.
00:22:42.890 - 00:23:05.420, Speaker B: I will make it copy. And everything we are doing is open source. So sometimes we are not publishing right now because we are changing very much and it's things like that. But we will open very soon as the pieces get more consolidated. And, yeah, you can check out Polygon Hermes repo, and there is a lot of information there. Awesome.
