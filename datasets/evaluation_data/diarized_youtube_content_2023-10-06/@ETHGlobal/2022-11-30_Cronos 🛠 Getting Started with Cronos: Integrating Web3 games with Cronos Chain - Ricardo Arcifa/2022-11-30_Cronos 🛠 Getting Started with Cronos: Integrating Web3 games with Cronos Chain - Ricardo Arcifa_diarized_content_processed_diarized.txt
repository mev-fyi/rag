00:00:11.290 - 00:01:33.280, Speaker A: Hello folks. What is up? Rick here from Kronos.org. Today we are going to have a workshop on how to build a very simple react front end application by using the Create app method. And then we want to build a little button that connects our front end application with our wallet of choice. And finally, we also want to build a function that helps us to fetch any NFTs that might be assigned to that specific wallet and ultimately then fetch it onto our website. But why don't we get started? So the very first thing that you want to do is you want to install a fresh Create React app and you can use any of the official methods that is available on the Create documentation and then just create your basic react template. So once this is installed on your local machine, there's just a couple of things you want to be in mind.
00:01:33.280 - 00:02:02.566, Speaker A: So I am using React scripts 40, three. Maybe you want to use the same just for consistency sake. And then also I'm using the Webtree library, webtree model and D for styling and stuff like that, axios for API calls. But you can use Fetch if you want.
00:02:02.748 - 00:02:04.086, Speaker B: That's really up to you.
00:02:04.188 - 00:03:07.250, Speaker A: And then finally we also want to use DeFi Connect, which we are going to use in the Webtree model. And yeah, another thing is what I did is I just replaced the CSS, the standard CSS with Antdcss. As you can see in here, that's Antdisentcss and that's the one that I'm going to use primarily here in the app. Right now I just have hello chronos text on the app. So if you go and visit, just launch the app NPM start, run Start. If you want to go and see what's happening in the browser, can just go here on the local host port 3000 and you see it just says Hello Chronos. What we're going to do next is let's give it actually some styling.
00:03:07.250 - 00:05:05.630, Speaker A: Maybe let's just remove this piece here, going to give it a name. Let's call it the Kronos app, the Workshop app. Also maybe add the NH two header and add quick description and then maybe also some culture action. So in here, what I want to do is the library that I mentioned before and it's actually what I want to use for the styling in here. So I want to use the primary button. It's not necessary. Too much text.
00:05:05.630 - 00:05:44.620, Speaker A: Let's go back. Okay, I first have to import the button now from the package from the library. It can see what's happening in here. Maybe refresh this. And here we go. Now this is obviously an empty button, so we have to add some configuration which we're going to do next. All right.
00:05:47.790 - 00:05:48.922, Speaker B: So I think the very.
00:05:48.976 - 00:08:56.640, Speaker A: First thing is you want to create a state for two objects. One is the data state, the data object, which is basically going to store some NFT token values which we will need later on to basically populate the page with images and stuff like that, give it some color and we're going to save that, going to set the state to an array. And then as well we want to store set the state of our wallet address like so. And these are our state objects that we will be using in the example app. And now there's a couple of libraries that we want to import Axios as well for API calls that we might want to do. You can use other methods, you can use Fetch for example, but that's totally up to you. Okay, now before we start to use the model, the webtree model, let's actually create the declaration actually let's just create the declaration for our provider because we're going to store the provider into here as well as declaration for web3.
00:08:56.640 - 00:10:19.560, Speaker A: And now what we want to do is there is a library, you could post it in here, but let's make a little bit cleaner. Let's actually create a new folder and call it Provider. And the provider is basically the method offered by the provider is basically the wallet that you will use in order to provide the information to your decentralized app or your front end of choice. In the context of webtream model, there's an option that we can use and let's actually create just a file. We're going to store this option in here a constant and then export it. Let's call it provider options. GS and then first thing we want to do is we want to import DeFi web tree connector from DeFi Connect, which is the native Kronos wallet that we will use in webtree models as well.
00:10:19.560 - 00:11:14.682, Speaker A: And then what we want to do is we want to add our provider options. So this is available on our integration page. So I'm going to copy and paste it in here, but you can find that information obviously on the web extension integration. So you have the details in here. As you can see, this is now outside of the context of webtree models specifically. But you get the point, you have the different options and the different variables that you want to use in the functions and we just use them in the context of webtree model by adding the custom example for a custom wallet, that's how it's going to look like. We have display option the package which is the important piece.
00:11:14.682 - 00:12:27.650, Speaker A: It imports the package into the provider option and then the different options that we want to use, such as the support chain IDs, the RPC methods, the polling interval, and then obviously the function, the synchronous function to connect to the provider. And then it passes, it returns the provider, which we then will use in our app JS file. So now we can close this and go ahead. What we want to do now is as I mentioned before, we want to create a web tree model configuration. Going to call it webtree model. So we initialize it with a new Web Tree model and in here we pass example. We can pass the option for Cage Provider.
00:12:27.650 - 00:13:46.740, Speaker A: Now I'm going to set this to False, but this is optional. If you want to cache the provider details, you can set it to True. But it's optional really. But the option that is not optional is actually the provider options which are required and the provider options, they will come from the file that we just created. Okay. Oh yeah, of course. Now we're good to go.
00:13:46.740 - 00:14:48.700, Speaker A: Missed a comma after the first option. And now that we have the configuration for our Webtree model, what we want to do is we want to create a function. Actually let's call it a synchronous function connect. And this function is basically going to be triggered by our button. So I'm going to call here an event non click and basically whenever we click on the button it will trigger this Asynchronous function here. But for now the function is empty. So let's actually start to populate it.
00:14:48.700 - 00:17:06.930, Speaker A: First thing we want to do is we want to create a condition check if there's a provider and if there's no provider, then we want to start to first thing we want to do is invoke Pride and Web Tree objects. And since they were declared initially in here so we can actually now initialize them like so with the Webtree Model Connect function and we initialize Webtree with the new Web tree and pass the provider. Now what we want to do is we want to get the account details. We await the promise from Webtree Ethereum get accounts. Obviously you can also use the Ethereum request method to get the accounts. Just actually I think I was reading this is currently the most recommended approach. So I'm going to go ahead and use the web tree adm, get accounts method.
00:17:06.930 - 00:17:27.834, Speaker A: Now we want to set the address because what this does is it returns the accounts that are assigned to our provider and we're going to use the count that's assigned as index zero. What will happen now is if I.
00:17:27.872 - 00:17:28.460, Speaker B: Log.
00:17:32.030 - 00:19:37.150, Speaker A: The address so what happened now after clicking on Connect, the Webtree Model is triggered and it shows me the default address which is MetaMask and DeFi wallet. Now I'm specifically using MetaMask for this exercise because my NFT assets are stored onto my chronos address which I passed to my MetaMask wallet. And what I want to do is if I click, if I select MetaMask okay, let's go back, see what happens. Provider web tree. Oh, of course I need to pass the provider, not the provider options in here. So if I go back now and try to test it again and Connect now I should see my address being logged. Here we go.
00:19:37.150 - 00:21:17.752, Speaker A: Now that that worked. Let's go ahead with our exercise because the next thing we want to do is we want to actually get all my token IDs so that I can use the Token Uri method that I have in the contract that I will add in a second. And this is a bit of a workaround to actually get all unique images assets that I own. And for that we will use a contract and abis that are assigned to the NFT contract where the NFTs are being generated. And the first thing that we want to do is we need to create a new folder and this time we're going to call it Contract. And in here we want to create a new file which you want to call NFT Collection JS. And in here I'm going to post in paste the abi details and the contract where the NFTs are go.
00:21:17.752 - 00:23:04.680, Speaker A: I'm going to quickly show you what I mean by that. So there is an NFT faucet that Kronos provides. And I have used this NFT faucet which works very similar to the OpenSea testnet platform that allows you to create NFT assets on a testnet so that you can play around with the NFTs as well. And what I do here is I do have a contract address for those test NFTs. And the contract address, if you use Chronoscan or the Explorer will also help you get information on the Abi, which you can then copy into this constant in here. So now that this is done, what I want to do is I want to import these details like so, and I want to create a constant for the contract. And here we're going to use the Web tree ethereum contract, the two options that we just created.
00:23:04.680 - 00:25:35.620, Speaker A: Let me have a look. Contract NFT collections. Okay, now let's test if you're able to lock the contract. And here we go. So, as you can see here, we have all of the inputs and we will be working a lot with the Token Uri, which we will use to get the unique metadata of each of the tokens that one of these addresses owns, or specifically the address that I use for this exercise. Okay, in order to achieve that, first thing I want to do is I want to get all of my token data and I'm going to use access to achieve that. And the Kronos Explorer API endpoint, I'm just going to paste in the address here that I'm going to use.
00:25:35.620 - 00:26:21.168, Speaker A: So htpschronos.org Explorer Testnet Tree API. The module is account and the action is token and address. That's what we want. And also I see that I was outside the condition. We want to keep this within the main condition in the connect function. Next, I only want because this is going to return a couple of fields and arrays the value that is important for us.
00:26:21.168 - 00:27:54.450, Speaker A: Let's say we're going to use only the data results, which contains the specific information that we want to use. And then I want to use a function to only retrieve the unique IDs. So function get unique and then I'm going to map to index, I store the keys of the unique objects, then I eliminate the dead keys and store the unique IDs. Last but not least, I remove any key when the result is null. And by doing that, I will be able to have my unique token details which you will need to create an array with the collection that I own. So if you're going to log that, you want to see what happens with our token. Our token is basically declared and initialized with the function that we just created to return the unique IDs.
00:27:54.450 - 00:29:02.860, Speaker A: And here we go. These are basically my unique tokens. But as you can see, I don't have the metadata in here yet. To get the metadata, I want to use the token Uri that was set in our contract. So what we want to do next is we want to create a collection. So let's declare connection as an array and initialize it as an array. And what we want to do next is we want to create a for loop.
00:29:02.860 - 00:30:20.176, Speaker A: I'm going to just paste it in here. So let's have a look at this for loop. So it starts as index zero and it goes for as long as there's a token length. So the token length is basically the amount of tokens that I have and it will run incrementally until it reaches the token length. And the first thing that I want to do here is we want to create a variable for token meta Uri and we want to await a promise and we are going to use the contract methods token Uri which I mentioned before. And in here we're going to use the token index in order to get the token ID and run the call. Also what we want to do is because we are using IPFS in this specific example to store the metadata of the NFTs, we want to replace the standard IPFS protocol here with an Https protocol so that the server isn't blocked when we try to fetch the details.
00:30:20.176 - 00:32:09.852, Speaker A: And then we want to fetch the metadata and save it as a JSON. And again we will replace the IPFS with the Https method because we want to specifically get the images. And once we get the images, we want to push the return data into the collection array that we have declared here. And what will be returned is actually so if I log the collection, we should see the specific metadata for here we go, the tokens that they own and that's the image. So now that this worked, what we want to do is we want to settle the state of data object by passing the collection that we just created. And what we can do is we can create here in the front end a new field. I'm going to call it maybe we don't need the h one header here.
00:32:09.852 - 00:33:55.336, Speaker A: But here we're just going to write NFT collection owned by address to keep it simple and in here. Now we want to run a loop with the new data that we have like this. And what we want to do here is we want to pass maybe first standard key, just our index and then our source. And in our source we will want to loop through the image fields and also maybe an alt tag. Maybe let's just put the index in the Alteg. Maybe you can put the name here. We use Uri Token ID and image.
00:33:55.336 - 00:34:38.650, Speaker A: Maybe you could have passed the name as well and you could have put the name here in the altech. But for now let's just use it this way. And we also want to add a little bit of styling maybe here. So NFT image and this comes from our app CSS file. You can see here I created a CSS class with width, height, border and border radius and then as well a little bit of margin. And yeah, I think also another thing we could add is as you can see the address is assigned but the value is never used. Let's just assign let's actually just print out the value in here.
00:34:38.650 - 00:35:13.280, Speaker A: Okay, now that this is completed, let's actually go and check out yeah, it worked. So if I go and connect with my MetaMask address first I get my address and then I will be able to fetch also my items into the page. And this is it in a nutshell. I hope you like this workshop and if you have any questions, please feel free to reach out to us.
00:35:13.730 - 00:36:27.250, Speaker B: So today I will walk you through some of the updates of our Chronosplay SDK. And more specifically, I want to guide you through our documentation so that you have everything that you need to build your next gen game during the ETH hackathon in India. So what you will see here is this is the main path of the documentation. If you visit our docs chronos.org, you will obviously have many other tabs, but I guess the one that is relevant for this specific workshop is called Chronosplay and maybe a couple of words about what Chronosplay really is. So in a nutshell, it is a gaming SDK that we have been preparing together with ChainSafe and it essentially connects the world of gaming with Kronos. So it allows you to integrate your next generation game or any game that you might be working on with Kronos and then ultimately really help you to create seamless experiences for the players that might be playing your game in the end.
00:36:27.250 - 00:36:51.180, Speaker B: So a couple of things that you will be able to do with the SDK. Obviously you will be able to connect and interact with the Kronos network, but you also will be able to provide in game NFT functionality as well as the ability to use authentication modules with different wallets. And I think another very important point is that we do not only support Unity, but also Unreal and C.
00:36:53.890 - 00:36:54.254, Speaker A: So.
00:36:54.292 - 00:37:36.300, Speaker B: A couple of things to bear in mind. What I want to do is I want to walk you through every step from start to finish. You might have already some familiarity with Unity. If you don't, that's fine because the purpose of this workshop is really to pick you up from step one and walk you through to get you started with the Unity Kronos play SDK. There's a couple of things that we will be doing. Obviously, whenever you get lost or whenever you have some questions, you can always consult our SDK. It really has the steps that I will walk you through today.
00:37:36.300 - 00:38:07.160, Speaker B: So I think it makes sense to familiarize yourself as well with the SDK. So first things first. The tab that is the most relevant to us is the Unity tab. So obviously we are assuming here that you have a basic understanding of Unity. If you don't, that's okay as well. Also to have some ERC sound 21 and EVM practices would be a good prerequisite to have. If you don't, again, it's still fine.
00:38:07.160 - 00:38:58.870, Speaker B: But yeah, so the supported operating system for this is for this specific workshop I'm going to use WebGL, but you can obviously also explore the possibility of iOS and Android builds. Then what we want to do is there is a link. So you can go ahead and download the Unity SDK. You can either follow this link, go to the official Unity website. It's definitely a good way to get familiarized with the SDK with the Unity framework as well. Now for example, if you would be running on a Windows machine, you would go for the Windows version. If you're running on a Mac machine, you would go for the Unity Hub version.
00:38:58.870 - 00:40:08.314, Speaker B: You just have to choose the one that's right for you. Then another thing to bear in mind, if you were to use the RPC methods, you can always switch between the mainnet RPC method and the testnet RPC method. Now, the news from quite some couple of weeks ago is that now we support the subgraph and we have deployed our subgraphs, which means that in theory, there's no need to use the RPC method in the development mode anymore. But I will show you a couple of examples just in a couple of minutes. So there's two ways of importing the SDK. The first one is by either using GitHub to clone the repository into your machine or you just can go ahead and download the latest releases from ChainSafe from the SDK. And once you have downloaded it, the first thing that you want to do is you want to import it into your, let's say, project.
00:40:08.314 - 00:40:45.150, Speaker B: If I were to create a new project, then I'm just going to leave it as it is, just going to show you what happens here. So all you want to do is creating your project and once that is created it's going to take a couple of seconds. Once that's created I want to copy or import the library and the package that I just downloaded here into my asset folder.
00:40:59.590 - 00:41:00.850, Speaker A: And voila.
00:41:04.630 - 00:42:35.010, Speaker B: This is as simple as it is to import the SDK into your game build. Let's just close this for a minute and go back into the documentation. So before even starting with the few examples that I have prepared I want to quickly walk you through the documentation. So the first one is EVM. So what this is it's really a standard interface for EVM methods and there's a couple of methods outlined here in the section. For example, the player account the player press getstring is basically the one that will help you retrieve the address from your wallet once you log in through your wallet of choice in the game scene. And basically, obviously we can use hard coded account by just copying our account address but using the player pref gets string method is basically dynamically fetching the equivalent account address that we have in our wallet then we can use the block number which is basically going to get the current latest block number.
00:42:35.010 - 00:44:16.076, Speaker B: Obviously here you can see you can switch between mainnet and testnet and yeah once we create the integer for block number then we await the promise of the EVM method and then we basically pass chain in the network and if you want to print the block number it will basically return the current latest block number. Then we can use balance off which is basically getting the balance of Kronos that is related to specific address that we have and the specific network that we have. So for example if I wanted to know what my current address is once I log in I would basically pass in here my wallet address or as I mentioned before the player prefs Getstring method in here. Then we also can use the verify method to verify assigned message. So basically what you do is the EVM verify method we pass a message and a signature which we define in here for example and it then returns the address of the verification with the message. We also can print anons if we needed a nonce. In this example we're using the RPC method but as I mentioned before we don't need to necessarily use the RPC method anymore so this is optional.
00:44:16.076 - 00:45:38.940, Speaker B: If you prefer to use the RPC method you can if you prefer to use the subgraph method all you have to do is remove the RPC option in here. Also something that might come in handy is a way to convert your way to crow and vice versa and that's the option to do that here. Basically you will find it under the EVM method. Now for ERC 721 contract tokens basically there's a couple of methods that you can use such as the balance off option that is basically going to count all the ERC 721 tokens that are assigned to one specific wallet address. And then we can use as well the owner off method which is basically a way to find the owner of a specific ERC 721 token. And here the option that we have again chain network contract and token ID. And then we want to verify the ownership by passing the chain network contract and token ID into the owner of function of the ERC 721 method.
00:45:38.940 - 00:47:09.330, Speaker B: Now we can also use the owner of batch method basically to get a balance of the batch and the list of a specific set of token. And the way we do this is by creating specific lists in here with different token IDs. Then we have the uri. So this basically returns the metadata of a specific token and we will have a look in this very shortly, as soon as we jump into the Unity editor because this is something we will be using when we want to replace, let's say, a game object with the data, the raw image data that comes back when querying for the Uri. And then the last one in here is the method that gets all specific ERC 721 tokens that belong to a specific address. Now there is a couple of other options like ERC 20 custom RPC and also some login, some examples such as the login example and other useful links and even a 2D game example that might be helpful. But in the interest of time, what I want to do now is I'm going to close what we have in here and jump directly into the Unity editor.
00:47:09.330 - 00:48:09.558, Speaker B: So all you'll see here is I prepared a couple of game objects with a couple of scripts. So if you go to the first one that is basically as you can see in this code snippet here, where is it? So it's called your C 721 balance of Kronos. I think it's self explanatory. What it does, it basically is the one method that we use to get the specific balance of NFTs that belong to a specific address. In this case it's my address, it's one of my test accounts test addresses. In here I put in the NFT asset address and also the network which is testnet and Kronos. So this is actually very cool because before I go ahead I want to show you something.
00:48:09.558 - 00:48:12.840, Speaker B: We have a faucet that is quite.
00:48:15.770 - 00:48:16.710, Speaker A: Helpful.
00:48:17.530 - 00:49:23.086, Speaker B: So whenever you want to create an NFT, a test NFT on testnet you can do so by visiting our NFT faucet. So I'm going to open this now. As you can see that's the website, all you have to do is you connect with your address and it's going to take a couple of seconds to load. But essentially what will happen here is it gives you an option to create your specific NFTs description attributes and also an image file that you can upload. And once that is created, you can basically use it to create test NFTs, which I have done. As you see, there's a lot of different NFTs and helmets that I'm using in Unity. So I think that's quite cool.
00:49:23.086 - 00:49:50.200, Speaker B: It's something you can test as well when you want to create some test NFTs. Let's go back to our Unity editor. So let's try to run this script. Going to unmute it. So this is going to return the amount of NFTs that I'm owning. So there's around four NFTs okay.
00:49:54.200 - 00:49:54.708, Speaker A: So.
00:49:54.794 - 00:50:10.904, Speaker B: Next thing I want to do, I'm just going to stop this, mute this again, and then we jump to the next method which is going to check for the ownership of a specific NFT. I don't know what happened here.
00:50:10.942 - 00:50:11.530, Speaker A: Yeah.
00:50:16.940 - 00:51:22.060, Speaker B: Okay. So in this case, I'm using the RPC method. As you can see, this is basically the way the SDK was working for Kronos before. But since we launched a subgraph, we don't really need this part anymore. But let's just use it to give you a sense that both options are actually possible. And what this will do, it will print the owner of Token with the ID 53. And here we go.
00:51:22.060 - 00:52:15.440, Speaker B: I can confirm that's definitely the address that I used, so that worked as well. Okay, I'm going to stop this again, untag it. The next one that I want to check is the balance of Chronos, the EVM method. And in here again, all I'm using is the option for chain, network and account. I pass them into Balance off and then whenever I print, it should print my current balance of test row in waveformat. That is correct as well. I'm going to stop this again.
00:52:15.440 - 00:53:05.120, Speaker B: And now I want to actually test something that I mentioned before, how to import NFT texture into the game. So what I did here is I created a quad game object and then I assigned the component, the script component, to import the NFT texture. You can check out here. So there's a couple of things that I've been setting up here. I have a response with an image I'm going to use in my Unity Web request. So what happens here is we have four options. Kronos testnet, the contract address and the Token ID.
00:53:05.120 - 00:53:52.286, Speaker B: Then we have the Uri from which we will get the specific. So basically this is our Uri that will be generated once we pass the chain, the network, the contract, and the Token ID. And we query for this information and it will return the Uri if it is available after specific metadata. And what we want to do here is a little condition. We want to check whether the UE starts with IPFS, and if it does, we want to replace it with the HTPs protocol to ensure that we don't have any strange error locks when we.
00:53:52.308 - 00:53:53.760, Speaker A: Try to retrieve the data.
00:53:55.330 - 00:54:34.714, Speaker B: So next step is we fetch the. JSON from the uri. And then basically, this is how we start our unity web request. It's a get request. So we get the Uri, we await the web request, and then we create a response data object. And in here, we're basically going to use the JSON utility to download the data that will contain our response, and more specifically, it will contain the image URL. And here again, we want to make sure obviously there's a bit of repetition here.
00:54:34.714 - 00:55:08.470, Speaker B: In a real world scenario, we would try to reduce this in a smarter way, but essentially we want to check if the image Uri starts with IPFS, and if it does, we replace it with the Https protocol. And then ultimately we just fetch the image and we replace the empty game object with the image texture. But let's have a look and try to see how this will look in action. So if I run the script.
00:55:12.390 - 00:55:12.706, Speaker A: It.
00:55:12.728 - 00:56:36.366, Speaker B: Just imported the image that I created before some time ago by using the NFT faucet, which I showed you a couple of minutes ago. Okay, so how can I actually make sure that I can display only NFTs that belong to my address? So the last option will answer that question. It's a login example. It's a little bit longer, but essentially what the login example does, it basically makes use of the player prefs get string method by which I retrieve the account once I log in with my wallet. And I want to make sure that the owner of the specific NFT and account owner are the same. And if they are, if the condition turns true, then I run exactly the same script that I just showed you. So if you were to do this in a real example, obviously okay, this is set up.
00:56:36.366 - 00:57:16.492, Speaker B: I can try to just create an example login. So we have the web. So click on, build on run, save. And what I want to do now is click on Login, select MetaMask, and here we go. I basically authenticated with my address. I made sure that my address is the same as the count. It owns this asset.
00:57:16.492 - 00:57:44.072, Speaker B: And if the condition turns true, it basically loads the asset into the game by replacing it with the game object. Okay. And with this, I want to conclude this workshop. If you have any questions, please feel free to reach out. You will find most of the information on the documentation, but we are here to help. So any questions, just let us know. Thank you, everyone.
00:57:44.072 - 00:57:44.630, Speaker B: Bye now.
