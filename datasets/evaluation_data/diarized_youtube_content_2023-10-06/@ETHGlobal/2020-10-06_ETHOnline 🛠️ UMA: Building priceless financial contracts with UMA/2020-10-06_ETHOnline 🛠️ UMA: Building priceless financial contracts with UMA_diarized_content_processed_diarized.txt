00:00:00.250 - 00:00:25.120, Speaker A: Everybody to the Uma intro workshop titled building Priceless Financial Contracts with Uma. Joining us today is Hart and Sean, who will be taking us through the session. One quick reminder for everybody to stake their spot for ETH online. If you are having any issues, please don't hesitate to reach out to myself or anyone else on the ETH Global team. And with that, I'll pass it over to Hart to introduce himself and get the session started.
00:00:29.390 - 00:00:30.380, Speaker B: Hey, guys.
00:00:30.990 - 00:01:02.990, Speaker C: All good on the stream? Okay. Hey, all. I'm Hart Lambert. I'm one of the co founders of Uma. Presenting with me is Sean Brown, who's our technical evangelist developer relations guy who's active in our discord on E Global. We're super stoked to be here because we love these ETH Global events and we love these hackathons. And we're really excited to just walk you through our version of how to build pretty cool financial contracts and synthetic tokens on Uma.
00:01:02.990 - 00:01:13.286, Speaker C: So I'm going to do a screen share. Let's make sure this works. Emily, thumbs up that that screen went through. Looks good.
00:01:13.388 - 00:01:13.894, Speaker B: Looks good.
00:01:13.932 - 00:01:20.650, Speaker C: Cool. Okay, so yeah. Sean, why don't you introduce yourself for 2 seconds just so people know your voice.
00:01:21.790 - 00:01:40.800, Speaker B: Hey, everybody. My name is Sean Brown. Like Hart said, I am the technical evangelist. So really my job is to interact with people like you and help you build on top of, you know, if you're pretty active in this hackathon, you'll probably interact with me a few times.
00:01:44.390 - 00:02:27.680, Speaker C: So, guys, we'll do a quick outline of our agenda here. We did our introductions. We'll check that box. I'm going to do a quick presentation, quick little overview of how we look at Oracle risks and our sort of philosophy here and how our priceless contracts work. This whole concept of how we can actually build DeFi contracts that minimize Oracle usage rather than be reliant on on chain price feeds. And then Sean's going to go through and do a cool demo of how to actually create a synthetic gold token using Uma, and kind of show you guys how quick and easy that can be. And then we'll just reiterate the prizes we have in this hackathon and leave some time for Q A.
00:02:27.680 - 00:03:32.740, Speaker C: Generally speaking, we want to make this pretty interactive. I think usually people save questions for the end, but if anyone has any burning questions, please do feel free to kind of jump in. All right, so let's get started with kind of our view on Oracle things. And if you think of DeFi, most of DeFi depends on some sort of price feed for something that's happening off chain or some sort of lending requirement. And if you think about this, let's just take the typical example of maker or compound or a lot of these sort of lending like protocols where you have two states, you have the state where the collateral backing a position is good, and in the green or it's not good. You're below your collateral requirement and you need to get liquidated. And the typical way this is all configured is there is a price feed, there's an on chain price feed that determines whether you are in the good state or the bad state.
00:03:32.740 - 00:04:52.810, Speaker C: And that's all well and good. That's all well and good except for this price feed is pushed pretty infrequently and becomes this point of arguably centralization, a point of brittleness, a major point of weakness in this system design. And kind of more importantly from the perspective of cool hackathon project, it's expensive and difficult to have a price feed pushing prices on chain and you can't really have a price feed for anything. You've got to do a lot of work to have one of these things exist. Also talk more about how the relative lack of frequency of price updates can be problematic for some types of financial contract designs. So the example here is that you've got this point of brittleness like we saw in the BZX Flash loan attack, you get one bad or inaccurate Oracle price feed and your whole system can get wrecked. There's this major point of dependency or brittleness around this price feed that is pushing prices just by reading from an API.
00:04:52.810 - 00:06:11.026, Speaker C: So I've already kind of made this. The broader philosophy here or our kind of look or approach to this system is that Oracles are this major point of weakness for DeFi as they're currently designed. This on chain price feed is brittle and kind of dangerous and our best approach is attempting to minimize Oracle usage and changing the design pattern so that we are using an Oracle as rarely as possible as a form of dispute resolution. So the slide here we go back to the middle slide. We want to make sure that a position is correctly collateralized. But our whole approach here is to look at it optimistically, to look at it like we are going to say, hey, let's use participants on the blockchain to actually observe the state of a contract and not push a price feed to the blockchain, but only have those participants observe whether a contract happens to be correctly collateralized or not. And you can think of this for those of you that are kind of familiar with layer two systems for scaling ethereum.
00:06:11.026 - 00:07:30.458, Speaker C: This is almost like a layer two approach or layer two kind of type of thinking applied to Oracles where we're going to say hey, this contract is correctly collateralized until somebody tells us it's not. And only when somebody says hey, this thing is uncollateralized, only then we will liquidate the contract and if somebody disputes that then and only then we'll call an Oracle. So it's this whole idea of pushing the monitoring of the collateralization of the system to the participants of the system itself without us pushing a price to the blockchain. One analogy that can be useful for thinking about this is thinking about traditional legal contracts and financial contracts are really they're analogous to legal contracts in the real world. And the example we like to use is if Sean and I were to write a legal contract between the two of us, say under the State of New York law, we would write this contract well, hoping that the other side does the things they say they're going to do in the contract. We only use the court system. We only litigate this contract if Sean and I fail to do what the contract specifies.
00:07:30.458 - 00:08:26.798, Speaker C: And we're trying to apply the same approach here to DeFi contracts where the Oracle is like a court system that we would only use in the example of there being a dispute, a genuine dispute between counterparties or between participants. So this design allows us to be more performant because we are not pushing prices every 15 minutes to a blockchain. This is literally happening in close to real time. The moment somebody thinks a position is under collateralized, they can go and liquidate it. That lets us do high performance things. It lets us do things in closer to real time and lets us scale DeFi contracts where we don't need to be constantly pushing prices to the blockchain to do interesting things. So, just to put some terminology here, we call the kind of top layer of this Oracle process, we call it the DVM, the data verification mechanism.
00:08:26.798 - 00:09:11.822, Speaker C: And the design, or the goal here is to use the DVM as rarely as possible. It's like taking somebody to court. So we've designed these contracts, these priceless contracts, where participants observe and make sure that they're working correctly, and they only use the DVM if there's a genuine dispute. So this is like a cool tweet we had from earlier in March when we were first pushing this out. And people like this idea of generally minimizing Oracle usage. It sounds great. But the other important aspect of why this makes things so resilient is that it changes the design approach for how Oracles get used.
00:09:11.822 - 00:10:36.540, Speaker C: Rather than having an Oracle be real time and timely, we actually use dispute as an after the fact, look back in time decision about whether something was correctly collateralized or not. It slows down the process and it lets us, in a much more decentralized way, understand whether a liquidation should have happened or not. So this is just a slide on how the Uma token accrues value, but the Uma token functions as effectively a seat on the jury to determine whether these disputes were correct or not, if we want to extend this court analogy. So it's a voting system where owning tokens gives you the privilege of resolving disputes, of resolving whether a price should be A or B. And the system itself has a unique set of token economics, which I'm going to discuss in another presentation later in the Summit. Or you can see some of the stuff on our website but our token economics work such that the Uma token holders themselves extract fees when needed to maintain the security of the system. So that's my quick kind of overview of our philosophy around this priceless thing.
00:10:36.540 - 00:10:50.590, Speaker C: I'm not sure how easy it is for us to take questions right now, but maybe we'll just let Sean move forward and then take questions at the end. What do you think, Sean?
00:10:51.250 - 00:10:54.180, Speaker B: Sounds good to me. Yeah.
00:10:55.830 - 00:11:04.020, Speaker C: So Sean's going to go through and give us a cool demo of how to actually create a synthetic token. And yeah, you took over the screen share. Great.
00:11:05.690 - 00:11:53.330, Speaker B: Can everybody see my screen? Okay, good. Awesome. Yeah. So now we'll get into the actual hands on portion of this presentation. So, like Hart said, we're going to basically try to show you how in 20 minutes you'd be able to use the Uma infrastructure to create your own example synthetic gold token. So the idea behind the synthetic gold token would be that this would track the price of a gram of gold against basically a US dollar. Or what we'll use in this situation is an example dai token.
00:11:53.330 - 00:12:52.950, Speaker B: And just to reiterate, like Hart said, and like I said in my introduction, I'm really not an engineer. That's not my role on the team. So really the purpose behind this demo and the purpose behind this walkthrough is that this can be kind of spun up by anybody with some preliminary technical knowledge. And so on this slide, we give a real brief overview, step by step instructions with links to each part of the documentation that would walk you through the steps that you have to take to do that. And then this continues on the next slide, where our ultimate goal, like I said, is to create this synthetic gold token. And we'll display that within a MetaMask account that's basically connected to our local test network or local development environment.
00:12:54.730 - 00:12:55.094, Speaker C: You.
00:12:55.132 - 00:13:11.022, Speaker B: Know, with Murphy's Law and live coding and all of that, you never know. But hopefully at the end of all this, we'll be able to display this synthetic gold token in our MetaMask account. So I will minimize this.
00:13:11.076 - 00:13:11.680, Speaker C: Now.
00:13:18.290 - 00:14:09.370, Speaker B: We'Re going over to our terminal here, and I really want to start this basically from step one. So right now we're in an empty directory, as you can see, titled ETH online. The first step would be to go into the Uma protocol GitHub. So it's GitHub.com Umaprotocolprotocol and clone the protocol repository. So just requires that you have git on your machine already, but we'll clone this here. Next we're going to want to think about our prerequisites and also our dependencies.
00:14:09.370 - 00:15:04.420, Speaker B: So if you follow this documentation that's listed in the slide deck, basically the only two prerequisites that you need are node and yarn. So real quick, we'll just make sure that we have the latest stable versions of this. So, yes, we have the latest stable version of Node, which is good. And we also have the latest stable version of Yarn, so we can navigate into our protocol repo. And now that we're here, we can install our dependencies. So just takes a Yarn command and this will take a few seconds. So while that's going on, we can talk about what we're going to do next.
00:15:04.420 - 00:16:10.360, Speaker B: The first thing we're going to do is, of course, compile our smart contracts, but then, as I mentioned, we're going to start developing on a local test network. So the next portion will be actually spinning up that local test network using the Ganache CLI, which is one of the dependencies that's being installed right now. And we'll just use this command where basically we'll spin up our test environment where we'll have some example ETH accounts that have a large amount of ETH in them. And we also set a large gas limit so that when we deploy our smart contracts, we don't run into any issues with the gas limit there. So this actually just finished, so I've got a few errors. I think it's just a problem with my local environment. So we'll proceed and see if that causes any issues, but I don't think it should.
00:16:10.360 - 00:17:18.730, Speaker B: So next we will compile our smart contracts. This will also take a few seconds. So as that's going on, one more thing to note on spinning up our Ganache test network is we'll actually add one more flag to this command, and that will be the D flag, which stands for deterministic. The only reason why we're doing this is for demo purposes because I wanted to basically set up a MetaMask account beforehand where we could use that mnemonic to connect the MetaMask account to our local test network. So yes, let's see. Awesome. So this is finished now, and in our small probably can't read this, but in our small terminal over here, we will spin up this Ganache test network with the D flag.
00:17:18.730 - 00:18:23.460, Speaker B: And we can now see that we have an example test network spun up on our local machine on port 9545 with some of the parameters that we talked about and also example accounts with a million ETH in each of those accounts. So I think this is probably a good time to talk about our MetaMask account. And like I said, the goal of this is eventually at the end, we'll see that we created a synthetic gold token and hopefully we can see that in our MetaMask account. So to do that, we're going to need to connect our MetaMask account to our local test network. So to do that, we just come in and we specify a custom network. Essentially, like I said, this is on our local host port 9545. So we'll connect that.
00:18:23.460 - 00:19:12.302, Speaker B: Awesome. Now we have a million test ETH in our development MetaMask account. Wish I had an actual million ETH, but this is just test ETH and we'll use this to pay for our development transaction. Cost and all of that. So we've now compiled our smart contracts and deployed and spun up our local test network. So normally what I would advise doing is actually running our Truffle test with the test command just to make sure that all of the dependencies installed correctly and your local environment is set up for development correctly. But this takes like ten to 15 minutes.
00:19:12.302 - 00:20:34.140, Speaker B: So just in the interest of time, we won't be doing that today. But probably a good thing to talk about is within this Truffle test command, we can see that we pass a network flag. So for the test command, we would be passing the test network or our local Ganache network that we just set up. But this is important to think about for later. Because if you are following along right now or you're trying to do this later on and you want to deploy this somewhere that's not your local test network, then you can do that pretty easily by just passing parameters to this network flag and connecting with a couple of options that we have here. So like in this command here, when we run this Truffle command, we can see that we're trying to connect to the Rinkabee test network, and we're going to try to connect with a mnemonic. So all of those instructions are here, and you can think about the steps that I'm doing today as being translatable directly over to test networks like Rinkabee or Covan, and also to Mainnet as well.
00:20:34.140 - 00:21:33.360, Speaker B: Cool. Also, just to reiterate, like Hart said, if anybody has any questions, I know I'm going through this kind of, you know, don't hesitate to say something in the chat. Cool. So moving forward to the actual synthetic token creation and the exciting parts in this. So we have our local test network running, and like I just talked about, we'll connect to that in our Truffle console by running this Truffle command, so we'll do that. Awesome. So now we're connected to our test network, and we'll go ahead and migrate our contracts.
00:21:33.360 - 00:22:53.000, Speaker B: And so you can see in the logs here all of the different contracts that are being migrated to the test network. We don't really have time to go through each of them today, but it might be useful to look through those logs and kind of understand some of the things that are available there. And then the next step that we're going to do is creating an EMP creator or a contract factory for this thing that we call the EMP. The EMP stands for an expiring multi party contract. And Hart talked about this a little bit, but one of the things that we offer is these priceless financial contract templates. So really, anybody can create one of these templates, but when they're created that template itself, or the factory that can create instances of that template needs to be approved by the Uma network before it can actually be used on mainnet. So that's what we're doing here is we're creating an instance of this contract factory.
00:22:53.000 - 00:23:54.782, Speaker B: Great. And next we'll actually get into some of the financial engineering aspects of this and talk about how easy it is to do a wide variety of things just by parameterizing. That's a tough word to say. This EMP contract in different ways. So I know this is kind of difficult to look at, but this is the step that will be defining these parameters. And I think this should be a little bit easier. But if we look at some of these parameters and think about what these things mean, the first thing is this expiration timestamp.
00:23:54.782 - 00:24:35.070, Speaker B: So like I said, we're creating an expiring multiparty contract and the important word there is expiring. So this contract will expire at some time in the future. So this is where we define that. So this is a Unix timestamp and I preset it for I believe this is Halloween of this year. So it will expire at the end of this month. And the next thing would be this collateral address. So like I said before, we're going to create a synthetic gold token that's collateralized in Dai.
00:24:35.070 - 00:25:45.110, Speaker B: So normally this address would point to the testnet address or the main net address of whatever collateral currency you want to use. But for development purposes here we have that address basically on our local test network. But you can kind of think about the financial engineering aspects of it here. Because if you, say, use a stable coin like Dai as your collateral currency in financial contract, then you have a very different contract than if you use something like, say, WETH or something that's more volatile. Because then you kind of introduce other aspects or other exposure to position holders in this financial contract. And so you can use basically like any ERC, 20 token for this collateral. But also similar to the financial contract template, this needs to be approved by the Uma network.
00:25:45.110 - 00:26:24.866, Speaker B: It needs to be proposed and then approved by the Uma network to use this. The next thing is this price feed Identifier and probably the last parameter that we'll talk about. And this is probably the most important. So here is where we define how this token actually gets its price. Like what actually gives this token the price that it trades at. So right now we're defining the price Identifier as gold USD. So I mentioned earlier and we can also see it in the name here.
00:26:24.866 - 00:27:41.500, Speaker B: But what this will be is basically the price of 1 gram of gold in US dollars. And similar to the collateral currency and the contract factory, this also has to be proposed and then approved by the Uma network. And basically you can think about it as like a deterministic way to get to the price of something. So when you actually go to the Oracle or the DVM for a price request, you need that Oracle to return this specific price identifier. So for this specific contract, what it would return at the expiration time would be the price of 1 gram of gold when this contract expires, kind of like Hart was talking about as well. If a dispute process happened and somebody was under collateralized and then got liquidated and then a dispute happened, then a price request would happen at that timestamp as well for the price of 1 gram of gold in US. Dollars.
00:27:41.500 - 00:27:55.280, Speaker B: So I know we covered a lot there, so just want to make sure that there aren't any questions. All right, cool.
00:27:57.010 - 00:28:03.460, Speaker A: Sean, there's a couple questions in the chat, but I'm not sure if hart has answered that for.
00:28:06.070 - 00:28:06.578, Speaker B: Answer.
00:28:06.664 - 00:28:25.960, Speaker C: Sean, I'm handling some questions in the chat for you, so I don't think they're directly relevant to this demo so far. So keep talking. And, yeah, if anyone does have questions around this demo, maybe drop them in the chat here and we'll address them in real time.
00:28:28.670 - 00:29:32.010, Speaker B: Cool. Thanks, Hart. So now that we talked about the parameters for a while, we'll actually use those parameters and create a financial contract with those parameters. So we'll take those things that we just talked about and create a financial contract with an expiration of October 31, tracking the price feed of basically 1 gram of gold in us. Dollars and using dai as the collateral currency for this financial contract. So we set the constructor parameters there, and then we won't talk at length about all of these things. But I mentioned there needed to be an approval process for the collateral currency, the financial contract template, and also the price identifier.
00:29:32.010 - 00:30:49.638, Speaker B: So that's just what we're simulating here is we are approving all of those things and basically adding them to the whitelist that allows for them to be used on this, uma, network. So we'll just run through these commands real quick. So first we are approving that price identifier that we listed in the prams earlier. We're then registering and approving that financial contract factory for the EMP. And then the final step is we are registering and approving that collateral currency. So dai in this case, it cool. So we're all set up now, and we've approved those things on our local testnet, and now we can actually submit that EMP contract and create that thing.
00:30:49.638 - 00:32:45.530, Speaker B: So we'll so calling the create expiring multiparty function will create that EMP and create the instance here. So now that we actually have the EMP created, if we type in EMP, which is our variable name here, and then dot and tab, we can see all of the different methods that we would be able to call on this financial contract. A couple of useful ones that we'll use today would be EMP token currency, which returns the address for that synthetic gold token that we're creating with this EMP contract. And then the other one would be EMP collateral currency. So we'll call this method to return the address of the example die token that we're using as the collateral currency for this contract. So the cool thing that we can do with this and the reason why we did it, is if we go back to our MetaMask account that's connected to our local testnet, we can take this token currency address and we can add this token to our MetaMask and register it. So we input the token address and we can see that it's returning the token symbol that we defined earlier.
00:32:45.530 - 00:33:36.790, Speaker B: So now we're actually able to track that synthetic gold token in our MetaMask wallet. And then similarly, we will do the same for the example dye that we're using. So we will add that token as well. And now we can track the amount of dye and synthetic gold that this account has on this local testnet. Cool. So we have the instances of these things created, but we actually haven't minted anything or taken a position in any way. So that's what we'll do next.
00:33:36.790 - 00:35:14.870, Speaker B: And we'll actually first issue ourselves some example die so that we can mint these synthetic gold tokens and then we'll mint those synthetic gold tokens and talk about what our collateralization ratio is and what some of this actually means. So using this command, we can see that we're basically minting 10,000 die tokens and allocating that to our development account so we can run this. And since we're actually tracking die in our MetaMask account, we can see that our die balance has now gone up to 10,000. And then we can also approve the EMP to spend our die for us so that we can then mint synthetic gold with it. So now that we've approved that and we have die in our position, probably the next thing that we would want to do is use that as collateral to mint synthetic gold. So if we think about what the price of 1 gram of gold is, I didn't know this off the top of my head, but I looked it up beforehand. It's approximately like $60 a gram.
00:35:14.870 - 00:36:48.398, Speaker B: So if we wanted to achieve a collateralization ratio, that's kind of typical for a financial product and also is one that we defined earlier in the parameterization step. So if we wanted to achieve a collateralization ratio of 1.5, then we can think that a token sponsor would probably need to basically use about $900 worth of collateral as collateral for say, like ten synthetic gold gram tokens, if that makes sense. So in this command, we'll actually mint these synthetic gold tokens with our Dai. So here we'll change the actual numbers that we're using because we're tracking a price index that's more expensive than just like a one dollars to one token ratio. So we'll mint with 900 die, we'll mint ten synthetic gold tokens and submit that transaction. And now if we come back over to our MetaMask account, we can see that we've minted or created ten synthetic gold tokens with 900 die as our collateral.
00:36:48.398 - 00:37:21.200, Speaker B: So in basically this situation, with this financial contract, what that means is each synthetic gold token basically tracks the price of 1 gram of synthetic gold. So at the contract expiration, I should be able to basically return these synthetic gold tokens for the amount of die that the price identifier, or the oracle returns at that time.
00:37:25.010 - 00:37:25.760, Speaker C: Cool.
00:37:27.910 - 00:38:45.980, Speaker B: And I think the last thing to touch on is I don't think we necessarily have time or need to get into this today, but this tutorial goes on to basically show you how to do other functions that would be necessary as a position holder. So an example would be returning some of those tokens for a specific amount of die. So you could do that by running these commands and then also depositing and withdrawing collateral. So if, like, a position holder wanted to add to their position to make sure that they're correctly collateralized or withdraw to maybe they're over collateralized and they want to use their currency for something else, you could use these commands to do that as well and basically interact with your position in any way that you would necessarily need. And I think that basically concludes the demo. So I'm pretty happy because we accomplished what we set out to accomplish. Hart anything that I missed or anything you think we should focus on a little bit more?
00:38:48.110 - 00:39:19.938, Speaker C: I thought it was pretty good demo. I'm biased, sean, but I thought it was pretty good demo. So there was one question here that I think is worth digging into. Tomo is asking how long the price ID whitelisting process would actually take. And I think it's important to note that what you did here, sean, is you ran this locally, where you can create whatever you want locally. Nothing's holding you back. For this to exist on mainnet in production, it's pretty open.
00:39:19.938 - 00:40:22.214, Speaker C: Like, you can literally create a token to track something you come up with however, you need to get that price identifier, the price ID approved by the, uma, token holders. And the idea here, just to make this make logical sense, is that the uma, token holders in the DVM have to be willing to vote on the thing that you are asking them to approve. And so they need to make sure that they're able to vote on this thing. And so we have a process where we write what we call an UMIP, uma improvement proposal to define what a new price identifier looks like, and then we ask token holders to vote on it. And that process could take as little as four or five days to kind of introduce it to the community and then go through the voting process. And once it's approved, then that price identifier is real, and you can create your synthetic token on mainnet. And so we're quite excited to see people are beginning to do this, create.
00:40:22.214 - 00:41:42.730, Speaker C: Price Identifiers fires for all kinds of cool things. And so really, your ETH global hackathon idea could become a main net thing pretty easily with this four to five day process. So one question Carl's asking another question is do we have an additional token that represents the collateral and is the collateral transferable? So the EMP contract, the way this is written, the EMP contract is what holds your collateral and it's not a token because it's not fungible in the same way that when you mint die your vault or your CDP, it's not tokenized because each CDP is different. It represents a different amount of collateral and all those sorts of things. I actually believe you can transfer ownership over a token sponsor position. I believe there is a transfer. Actually, that's an engineer question that would allow you to transfer ownership of your sponsor position, but it's not tokenized.
00:41:42.730 - 00:42:04.030, Speaker C: Carl's also asking where can you see the collateral position? I mean, it's easily observable in the EMP contract itself. And we have built some tools. We built a tool tools, umaproject.org, that provides some insights into EMP positions.
00:42:05.350 - 00:42:06.002, Speaker B: Yeah.
00:42:06.136 - 00:42:56.670, Speaker C: But also, Carl hop in our discord and ask more questions and Sean can go deeper on this. Tomo is also asking if third parties can add or remove collateral from your position. Third parties can add collateral to your position. So if you are a token sponsor and you created, say, these ten synthetic gold tokens and you're at risk of becoming under collateralized and let's say my new friend Carl wants to add for some reason, wants to add collateral to that position, he can go ahead and do that, and the token allows that. However, he can't withdraw collateral without my he can't withdraw collateral because it's my position. Right. So anyone can deposit additional collateral, but no one can remove it besides the position owner.
00:42:56.670 - 00:43:01.534, Speaker C: Those are actually some pretty good questions.
00:43:01.732 - 00:43:08.920, Speaker B: Those are, yeah. Very financial engineering centric too, which is always awesome.
00:43:11.370 - 00:44:42.420, Speaker C: Maybe the last thing I'd sort of add to note here is that as a team, we're pretty into financial engineering and pretty into inventing cool new things. And so our discord, we are all about working with people to try to come up with cool new ideas or cool new ways of creating new financial products, both using this EMP contract and then also innovating on how to modify or hack the EMP or other related contracts to do other things. So, for example, Sean is working with somebody in our community right now to create a price Identifier for tracking the price of gas on ethereum, which is going to allow us to create gas futures or tokens that track the value of gas on ethereum, which we think is pretty cool. There's a bunch of other ideas in the works that I won't get into right now of different interesting types of synthetic tokens people are looking to create. And I'd also add that at hack money, which was the ETH Global hackathon. Two times ago, the Potion Labs team came up with this brilliant way of creating an insurance or kind of a new form of options contract that is a significant modification of the EMP to create a type of insurance, really, on any type of ERC, 20 asset, which we thought was pretty cool. Yeah.
00:44:42.420 - 00:45:22.472, Speaker C: Sean, you want to handle this question? What's this? When somebody wants to close their position and return their synthetic gold, let's say the price of gold went up, where does the initial Dai come from to pay out the profit? So, remember, this is Robert's question. It's useful to think of the participants involved. If I go and I mint these ten synthetic gold contracts with Dai, I still own those contracts. I'm not short gold until I sell them. So if I sell those gold contracts and let's say the price per ounce of gold, sean, what did you say it was? Like $60, $60?
00:45:22.526 - 00:45:25.876, Speaker B: Yeah. Per gram, actually, definitely not per ounce.
00:45:25.908 - 00:45:26.240, Speaker C: Per gram.
00:45:26.260 - 00:45:26.792, Speaker B: Per gram?
00:45:26.856 - 00:46:08.536, Speaker C: Yeah. Okay, so I sell these ten tokens, which represent 6 grams of represent 10 grams of gold, for, let's say, $600. I sell those to Sean. Now, I'm short gold because I have to maintain the collateralization requirement of my sponsor position, and Sean owns gold. I can close my deposition at any time as long as I get back ten gold tokens. I just need to get those back. But if the price of gold went up and I want to close my position, sean's not going to sell those ten gold tokens back to me for $60.
00:46:08.536 - 00:46:29.776, Speaker C: He's going to only sell them back to me for whatever the market price is. So if the price is now $70, I would have to pay $700 to buy back those ten gold tokens. Sean makes his $100 on this trade. And I now have my ten gold tokens, which I can use to close my debt position, to close my token sponsor position.
00:46:29.958 - 00:47:02.520, Speaker B: And also to add to that as a position holder, because I'm keeping track of the price of a gram of gold and I know that that's going up, I'm probably also, if I'm following the correct collateralization ratio, I'm also adding to the collateral that's backing those ten tokens. So when those are redeemed, the extra price amount comes from the added collateral that's still backing that. Yep.
00:47:04.620 - 00:47:15.710, Speaker C: Good question. Good point of clarification and yeah, Robert, sorry, I missed that question earlier. You asked that earlier, but I missed it.
00:47:16.640 - 00:47:17.390, Speaker B: Cool.
00:47:18.740 - 00:47:58.430, Speaker C: So, Sean, why don't we just the last two slides here. Let's just give a quick overview of our prizes again. So we're going to be awarding $5,000 worth of prizes. $3,000 the first place, 1500 to second, 500 to third. One fun, cool thing we're going to do is we're going to actually use the, uma, token holders to actually vote on who should win these prizes. We're just going to try doing this, and we're going to do this using a snapshot page voting thing. So I think that'll be kind of cool and kind of fun.
00:47:58.430 - 00:48:39.656, Speaker C: So that'll be kind of fun. To see how this works, we have office hours in our Discord Channel, and we also have a calendar of events with everything, Uma related at calendar. Umaproject.org, please do jump in our Discord, or there's two Discords, either in the East Global Discord in that channel or in our own Discord. Feel free to join that. And Sean's got all of our social media and website links up. Really? I don't know.
00:48:39.656 - 00:48:53.260, Speaker C: We really love these ETH hackathons. They're really fun. They're fun to do in person. They're actually fun to do online, too. So we're here to help out with you guys. Hit us up. We want to be responsive.
00:48:53.260 - 00:48:58.640, Speaker C: Sean, what we got on the last page, we got our people.
00:48:58.710 - 00:49:14.980, Speaker B: Yeah, these are just like some of the people that you'll probably interact with on Discord. So just get to know them because you'll probably be talking to them a lot if you're building a project with AMA.
00:49:16.040 - 00:49:32.090, Speaker C: Yes. And we're six days into October. We got a solid three weeks to go. We want to see you guys build cool things. So hit us up and let us know how we can help.
00:49:33.180 - 00:49:33.930, Speaker B: Cool.
00:49:36.080 - 00:50:09.650, Speaker A: Thanks so much, hart and Sean. That was a great session. And I'm sure you can even share these slides in the, uma, Sponsor Discord Channel. And the hackers can go through that in their own time. But if there's no more questions from anyone on the call, I want to say a big thanks to Sean and Hart for the session. And yeah, if you have any questions, feel free to reach out to them in the Sponsor Channel, and I'm sure they'll reply quickly.
00:50:10.580 - 00:50:11.056, Speaker B: Thank you.
00:50:11.078 - 00:50:14.216, Speaker A: AMA cheers, guys.
00:50:14.318 - 00:50:17.670, Speaker C: Thanks so much. Emily thanks, guys. Have a good one.
