00:00:31.720 - 00:00:40.924, Speaker A: Hello. Check. Check. Okay, this is outside one. That is okay. Yeah, that's okay. Can you please turn it on again? Hello? Check.
00:00:40.924 - 00:00:43.950, Speaker A: Check. This is all going to work. Yeah.
00:00:48.640 - 00:00:49.756, Speaker B: Can you go on YouTube and see.
00:00:49.778 - 00:01:05.976, Speaker A: If we're it check. Hi, guys. All right. Cool. Right now? Sorry.
00:01:06.158 - 00:01:06.856, Speaker C: I don't think so.
00:01:06.878 - 00:09:49.140, Speaker A: I think I'm already ready. Have they turned it on? Hello, check. I can hear me now, but there's a lot of disturbance at the line. I guess there's a lot of static. No, I know, but I'm just saying, there's just too much static in the sound. I'm not sure if everybody has the same thing. Hi.
00:09:49.140 - 00:10:00.708, Speaker A: This seems to be static on the headphones. Yeah. Check. Check, one, two, three. Hello, check. Check. There's too much static.
00:10:00.708 - 00:10:03.636, Speaker A: One, two, three. Too much static.
00:10:03.828 - 00:10:06.272, Speaker D: Just start the static.
00:10:06.356 - 00:10:09.208, Speaker E: I don't think it's much coming through. It's not on the main feed.
00:10:09.384 - 00:10:24.048, Speaker A: Okay, there is. Yeah, for sure. Okay, everybody to go to channel one. Yeah. Check. Check, one, two, three. Check, one, two, three.
00:10:24.048 - 00:10:27.490, Speaker A: There's no one here yet. I guess they're yet to bring people in.
00:10:32.000 - 00:10:33.550, Speaker E: Everyone will be starting.
00:10:36.400 - 00:12:08.520, Speaker A: Can you also tell them to stay on channel one? Yeah, I'll start. Test, one, two. Hey. Check. Test, one, two, three. Hey. Check.
00:12:08.520 - 00:12:21.500, Speaker A: Test one. On two. Hey. Testing, one, two, three. Please. Sapal Laker, Under. Guys, please be inside.
00:12:21.500 - 00:12:29.790, Speaker A: Getting in. Check. Test one. On two. Hey. Workshop, right now. Hey.
00:12:29.790 - 00:12:38.846, Speaker A: Check. Test, check. Nice. Workshop here. Test. Workshop. Yeah.
00:12:38.846 - 00:12:57.600, Speaker A: How are you getting it? Workshop on deployments. You it. Workshop. Guys, we're starting. Oh, my God.
00:12:59.570 - 00:13:00.480, Speaker B: I will.
00:13:05.170 - 00:13:13.780, Speaker A: Just one, two, three. Yeah, we take photographs, whatever. Pictures and stuff. Check. Somebody has to be here. Check. Okay.
00:13:13.780 - 00:13:46.890, Speaker A: Because they want to keep on schedule. There's no one showing up. Yeah. Check this. One, two. I had told these guys specifically not to cut them, so I'm not trying to push them. Check.
00:13:46.890 - 00:13:56.750, Speaker A: There's still some static, but it's okay. Much better. Yeah, it's better now. Can I just take it with me? Check. Hello. Hi. One, two, three.
00:13:56.750 - 00:14:22.600, Speaker A: Hey, guys. Can you hear me out? Can you hear me properly? Any issues? Yeah, there is. Okay. Hi, Kishore. Vishnu. How are you doing, man? Good. Thanks, man.
00:14:22.600 - 00:14:58.058, Speaker A: People are yet to come, I guess. Audio number check. Test, one, two. Hey. Check. Get people instead. Test one, people, please.
00:14:58.058 - 00:15:16.850, Speaker A: Two a, check. Test, one, two. A. Check. Check. Hello, 1234. Check, one, two, three.
00:15:16.850 - 00:15:18.370, Speaker A: Phil for dujaki.
00:15:22.790 - 00:15:30.310, Speaker C: Hey, maybe just mention I mean, I told everyone who got it personally.
00:15:34.250 - 00:16:09.890, Speaker A: I can ask everyone. I'm just going to stage, maybe. Hey, guys, can you hear me? All right. On the set as well. Just FYI, all of you guys need to be on channel one. And if you happen to change it, you'll probably not be able to hear anything, what I'm saying, unless, obviously, the voice travels through air. But otherwise, I think it'll be good if you can just with a show of hands, everybody's okay? Can anyone hear me all right? No, you don't have headphones.
00:16:09.890 - 00:17:57.590, Speaker A: You have headphones right there or no, just ask someone for headphones. They'll give you the headphones yet? It people said look for headphones, right? Guess what? Curious. I need one just for questions in I need one for my for myself. Medical Kaliko. We will rama. Yeah, I think it's fixing up for the gear for me. Check, check.
00:17:57.590 - 00:19:03.820, Speaker A: Profit. Are there guys you can stop in the front for the ones who are looking for the headphones? You have to wear headphones to be able to hear me. Yeah, please check this one too. Hey, Kevin. The speaker is loud there, I guess. Looks like the figure on the normal speaker, not on the headphones. Please.
00:19:03.820 - 00:19:31.440, Speaker A: Nobody will be hearing anything for me. Those guys are not supposed to be on the speakers. Those guys are on the speakers on the next room. And the speakers. Yeah. Have them fixed, please. Thank you.
00:19:31.440 - 00:20:15.054, Speaker A: Cables, right? All the chairs. Sorry, don't on yet, I think. Sorry. Headphones you need? Yes. All the chairs? Yeah. Check, check. One, two, three.
00:20:15.054 - 00:20:50.586, Speaker A: Check, check. Are the headphones missing behind? Headphones are missing behind, I believe chairs at the back don't have the headphones. The ones behind don't have it. Are they there? All the chairs? Exactly. Yeah. We should get them.
00:20:50.768 - 00:20:54.000, Speaker F: Someone given the instruction to whatever.
00:20:54.530 - 00:20:54.990, Speaker A: Sorry.
00:20:55.060 - 00:20:56.014, Speaker B: We need to start.
00:20:56.132 - 00:20:56.800, Speaker A: Okay.
00:20:57.730 - 00:20:58.750, Speaker B: We need to start.
00:20:58.900 - 00:21:05.920, Speaker A: Okay. No one there, but the seats of the back don't have headphones, by the way.
00:21:07.810 - 00:21:09.006, Speaker B: You can tell them, like, they move.
00:21:09.028 - 00:21:12.000, Speaker C: Up, but, like, we need to start because, like okay.
00:21:14.290 - 00:21:33.894, Speaker A: Yeah. Okay. I'll have to keep announcing then. Take care. Sounds good. All right, guys, just a quick housekeeping question. A comment, actually, is if you want to hear what I'm saying right now, you won't need to move to channel one, and that is the only way to hear me properly.
00:21:33.894 - 00:22:10.550, Speaker A: Otherwise it's going to be a little hard trying to hear me out. Like this second thing is that all of you guys may have a barcode scanner or barcode in front of you, a QR code. What you could do is if you have MetaMask installed on your phone, you could just scan that and you will get some credits in matic and in stack tokens. Cool. I'll start then. Okay, so how many of guys here have MetaMask? All right, almost everyone with ones who don't have MetaMask, please install that. I think that'll be very helpful.
00:22:10.550 - 00:22:48.720, Speaker A: The second thing is, how many of you guys are back end developers here? So it looks like almost everyone knows back end or about front end coding. 30, 40%. And what about solidity developers? Okay, so that's about 25%, I guess, right? And that's not a bad number, actually, because I think all of us over here are basically here to learn new things. But then I think this conversation over. Here will be much more relevant to the ones who are front end and backend developers. And for smart contracts you need to use other layer ones like Polygon or Ethereum. Right? Now.
00:22:48.720 - 00:23:41.102, Speaker A: Quick thing about us. Stackos is a decentralized cloud. It is the world's largest decentralized cloud. And I'll go through the numbers soon. Talk about the vision first. Right? So first of all, the way we look at this thing is we kind of challenge the status quo by empowering humans, machines, dows to govern their application infrastructure that is decentralized, unstoppable and extremely easy to use, right? And by this basically we stand for ensuring we provide freedom of speech and expression, right? So that's in a sense what you do because right now if you want to run applications the front end and the back end, all you have to do is rely on these settled cloud providers like Amazon, Web Three, Amazon, AWS and S Three for storage and then also comes along with GCP, Azure, you name them. Right? So that's where StackWise comes in.
00:23:41.102 - 00:24:23.598, Speaker A: As fundamental mission is that we are a cross chain infrastructure protocol that is basically a bedrock for all the future generations of applications to come. That means not just your smart contract layer, but also your front end and the back end applications can be run on the decentralized web. A quick thing about myself is I am a finance and international Business major from Harvard University. I came from US last year, moved here permanently, hopefully for some time at least. Mechanical engineer by background. But I've worked in the cloud space since almost over twelve years, ten years. And I've got patent in Kajunic engines and basically helped build AWS during the early days of the start.
00:24:23.598 - 00:25:09.758, Speaker A: That's 2011 ish. So what are the current landscape? Right? So the first thing is that we talk about uniswap. And uniswap is something which everyone knows. How many of you guys know uniswap? Okay, that's a good number. But we all know this thing that they kind of delisted all the security tokens from their website and that is kind of very ironical for someone saying there's a Web Three project. But in a sense they can be forced by the governments and the Secs to kind of self regulate or have them remove the security tokens because it comes under the purview of the SEC when you talk about a parallel equivalent of parla. So how many of you guys know Parla? Very few, I guess.
00:25:09.758 - 00:26:12.500, Speaker A: Few hands. That's it. So how many of you guys know Donald Trump? Everybody. Right? Cool. So you probably also knew before Elon Musk came in he was banned from Twitter, right? And that was because of whatever ideologies they had. But in a sense, if you think of it this way, not really talking about what ideology you believe in, but thinking of this as a bar on people didn't like what he said, so they kind of banned him from there, right? So Twitter kind of removed Donald Trump, they ended up using Donald Trump and his community started to use an application called Parla and guess what happened, right? They used Parla and the AWS completely shut down parlor application from the servers, right? Not just that, Apple App Store also removed it from their App Store. So that's kind of you see this is coming more and more in this world where when we want to start expressing ourselves there is going to be a complete industry trying to protect itself and that's kind of what we kind of fight for.
00:26:12.500 - 00:27:29.638, Speaker A: Other thing is that why do you think Web Two has been so successful? Right? But what are the problems right now? Also I think which comes along. So the first thing a drawback of Web Two is that the incentive mechanisms are not aligned. And when I say that it's basically the shareholders of the company are the ones who benefit from the protocol or their services, but not the people who are using it. So that's kind of the dramatic changes in this outlook. It is pretty expensive to operate for the ones how many of you guys have built on AWS or created servers and launched there? Okay, so that's about 20%, right? And you are probably also familiar with DevOps and one of the most expensive engineering domains and it takes a lot of things to fall in place to make it work properly. So for instance, if you're to get a production environment up, it takes about six to seven weeks to get a stable production environment ready, right? Just to make sure everything works fine and not nothing falls and drops apart. But that being said, what really changes things is that is that something which we should be worrying about, right? Because first of all, it may take you that long, but yet we have seen time and time or time and over again that these services do not really even though they're production, all the secrets are lost, people get hacked and whatnot LastPass, they got hacked yesterday.
00:27:29.638 - 00:28:18.700, Speaker A: So that's kind of concerning when you talk about someone who's a security company also can't protect their environment. So that's something which is kind of concerning. So again, no anonymity, right? That means if you are deploying, let's say on AWS, you need to first give your grandfather's details to Amazon, right? And that's kind of ironical, right. How do you really work with this at scale? Something like a Dow can never ever kind of own it because again, Dow doesn't have a grandfather, unfortunately. Right. But for people to really run this a community to govern this, the only way which we are aware of right now is a Dow and that's kind of an issue which comes to Web Two and why it can't really be used in a Web Three world. Now that bars the question what we have so far.
00:28:18.700 - 00:29:14.630, Speaker A: Yes, the Web two provides us extreme easiness of use. It does provide us lot of these benefits of the great user experience. It has ways of ensuring people can access the software faster. But is it really decentralized if you're using AWS even though front end layer? Because all that so far we've heard like in the last few years is we have smart contracts, they call it decentralized, but obviously they're using all these central services. So as an example of Facebook and how do you decentralize something like that? So, first thing is, as an example, I've just given like 12345 pillars and again there are many more. But just for simplicity and trying to fit something on the screen, one presentation layer, that is the UI interface, right? Then you have the data storage layer, which has something like S Three or databases and whatnot then you have the AI analytics machine learning. Again for integrations.
00:29:14.630 - 00:30:41.586, Speaker A: Also for communication, you require services which can guide a message and you can receive messages, be notified when an event happens. And then of course the data sources, right? That means that you need people to add data to Facebook so that you can actually use it as a social network. So if today, if we have to build something like Facebook on the decentralized web, the two things which we have right now, so one is the data layer, that is the storage, that means S three, you have IPFS for data, then you have blockchains like Ethereum and Polygon as services. And then you have chain link, right? For any of the others of course, but chain link one of the prominent ones which kind of get off chain data on chain, right? So that is kind of something which we have so far, but everything else currently runs on AWS. And again, I'm not naming AWS alone, but I think it's a generational problem, right? And how do we solve something like this in this new Web Three era we're trying to talk about? So that's where Stackos comes in. Stack OS is a replacement for all of your presentation layers, your AI analytics layer, your integration layer, and again, there are several of those, right? And I'm sure you guys can tell what are the different services which kind of rely, we rely on AWS even though we are kind of supposed to be decentralized, right? So the real things which Stack OS really solves for you, first of all, the high DevOps cost is eliminated. That means you don't require to run infrastructure.
00:30:41.586 - 00:31:06.122, Speaker A: You don't need to know AWS, you just need to know any of your normal regular applications and docker. So how many of you guys know docker here? Oh, that's the most number of hands I've ever seen in the conference. So that's amazing, right? So all you need to do is dockerize your application and you're ready to go. Right? And I'll come to the details of how it works. Really. Second one is environment preparation. Again, it cuts down from seven weeks to 30 seconds.
00:31:06.122 - 00:31:59.774, Speaker A: So you can get your application live in less than 30 seconds on Stack OS. That's kind of the power it kind of brings to you, again, when you're trying to build something crypto native. How do you make sure that you can pay without your credit card? Because again, you don't want to share your grandfather's details to get access to a bank account and do whatnot right in a decentralized web at least. The fourth thing is the governance, right? That is again, as a Dow, as I said earlier, that this is kind of what it kind of solves for. How do you ensure that if the community wants a feature to upgrade, they can vote for it and agree that the next version should come out right? So that's kind of this thing works. Now this is the older slide, the new version, which we have, probably makes this thing into two steps, right? But first thing is that to deploy anything on Stack OS you need to do docker. So dockerize your application, right? Once you do that, you just go reserve Compute on Stack OS.
00:31:59.774 - 00:32:40.126, Speaker A: It's just say that you want to purchase 500 megabytes of Compute for Ram and let's say 200 millicores of Compute. And it can be very granular, as granular as you want. And after that you could just go to the UI and you just click a button and it just deploys those things on Stack OS. So that's kind of how easy it is. I'll go through a demo just of that. So as I said earlier, so we are the category leaders in the decentralized cloud and the numbers talk for itself, right? But it is the world's most utilized and the fastest growing decentralized cloud. So we have total about this is 73.
00:32:40.126 - 00:33:05.330, Speaker A: It's an older version I think we have about morning or yesterday is about 80. We were hitting at 81 million requests website served to the network. We have about 3500 plus applications deployed and we have about almost 1600 applications running on Stack OS, right? And that's kind of the power of what we have. In fact, we went main net. We've been working for over six years. By the way, guys, it's not a new project. We just came out from nowhere.
00:33:05.330 - 00:33:39.040, Speaker A: But our main net was last in the month of August. Interestingly, after August, in next five months, in January of this year, we overtook the largest competitor and now we are about four to five times larger as they are. So that's kind of what our growth story is. Keep an eye on the version two that's coming. And version two has got a lot more features and way to distinguish ourselves. We're trying to get it done through before this ETH India, but looks like it's going to be early January. So we kind of worked it out and obviously please be in touch and we can talk about those details as well.
00:33:39.040 - 00:33:59.698, Speaker A: Again, if you want to contribute to Stackos, reach out. We have a booth out there. We're really good. And one thing to do is that you can join Ambassador program and also follow us. Right? Again, this will be recorded and you can always stop by our booth. One thing I want to mention is for the ones who are starting up, we have some really good venture capital firms as well. So please do go to our desk.
00:33:59.698 - 00:34:16.794, Speaker A: I'm not sure if we have forms here. Fill your details then there for that. And we have some contact with VCs as well. So if your product is good, please reach out. Follow the seed. One of the best venture capital firms is kind of based from Australia is over here. Andre is here.
00:34:16.794 - 00:34:57.370, Speaker A: He was very kind enough to accept a limitation here. So please reach out and I think we can make some great connections before this. Now let me just get to the next part of the section, which is next part of the presentation, which is kind of just showing you how it is and how easy or hard it can be for you to deploy. Right? So this is a new account. So what I'm going to do is first of all, all of you guys, can you just try to see if you can import that wallet into your MetaMask? You've been able to do it. How many of you have been able to import the new wallet which is there? Okay, so does everyone have MetaMask? I know the crowd is increasing, guys. FYI, if you're not able to hear me, please feel free to come in front.
00:34:57.370 - 00:35:28.420, Speaker A: There is your headphones, which you can use to hear me properly. But did you all find a barcode in front of you, all of you to raise your hands if you have found that barcode on your seat. Okay, so that's a good number of people, right? So just again, open MetaMask on the polygon network, scan it, and that ball will be imported. It will have some credits for you to use. Use them. If you don't use them, it'll probably be taken away later on, but please use them. I think it'd be of a lot of value.
00:35:28.420 - 00:36:10.798, Speaker A: All right, so once you have MetaMask, what I would do is if I'm using my phone to log in, I would just use Wallet Connect and then you can just scan that with your MetaMask. It'll automatically just log you in, right. For this presentation, since I want to show you what's happening here, I'm just going to use my laptop to really log in and stuff. So I also have MetaMask on my laptop. I'll just say MetaMask and ask me to connect to a subnet. I'll pick authority and once I do that, I just sign a message. Once that happens, it will take me to this next section where you can basically see that you don't have any apps deployed.
00:36:10.798 - 00:36:47.686, Speaker A: But this is kind of the screen you'll see in front of you right now. Let's say I want to do a few things. Maybe I'll start with giving an overview of this right of the dashboard. Again, all the deployed apps will be shown here. And over here on the top left, you will see different kind of things. So let's say first we'll show you the CPU, how much you have bought and how much is being used, your bandwidth, your memory and your storage, right? So you can basically pick what you need. And once you do that, you can go to the hardware place to basically show you what you can purchase, how much you can purchase.
00:36:47.686 - 00:37:29.866, Speaker A: So you can actually just click here and purchase resources and then just add how much compute you need, right? And then you do next, and then you are able to pay, right? What I'm going to do right now is giving you a much more simpler example. But if you have to go to the App Store, you could go to App Store. And once you're there, you have a set of applications already here, right? So what I'm going to do is, as an example, show you how to deploy an app and without actually paying for it right now. But the workflow itself, I think will work. So deploy custom image. But one disclosure here in good faith, this is a new UI which we have. So I hope you guys don't face any bugs here, but if you do, please report them.
00:37:29.866 - 00:38:15.464, Speaker A: It'll help us in trying to just make it well again. The domain name, which I probably didn't mention earlier is App V two stackers IO, right? And that is a new domain for the new version of UI in case it's not working for you or there's some glitches over here or there, go to App stackers IO. That is the older UI. So this is the older UI, but this is the exact same thing. It's just a better experience over here. So let's say I'm going to pick this image in Docker. So this is an open source Ethereum Explorer.
00:38:15.464 - 00:38:47.576, Speaker A: So in that when you kind of go down, you would traditionally, let's say for this example, you run this command to run this Docker image locally and get that application running, right. So on Stack, just keep in mind that you see is it clear enough? Yeah. Okay. Can you guys read this? Okay, so you can basically, if this is a command, you run your port 80. 80. Your image name and whatnot. So we just come here and do this exact same thing, copy your Docker image name, give your tag name there and your application name.
00:38:47.576 - 00:39:05.420, Speaker A: So I'll just keep it Explorer. Next. Here is where I put the port IDs. So this port is what? Your container port and what do you want exposed. So you say 80 80 and then you have your host URL. This can be any domain you want. I'll just take for now, for this case, I'll just take this as domain which Stackhost provides you by default.
00:39:05.420 - 00:39:33.256, Speaker A: There you can basically save a stateful set. You can basically set a Replica account. So let's say I want one as a Replica account and then if I want stateful set, I can fill that up. Or if I have to pass arguments in Docker, you can pass arguments as well. So you can pass arguments if you have environment variables, you can just put them here. If you have a command which has to pass at Runtime, you can do that. But in this case, for this example, we don't need any, as you saw already.
00:39:33.256 - 00:39:51.484, Speaker A: So I'll just do next and I'll pick my Compute. Keep this prices. You don't necessarily need to pay 100% for everything. You don't need a four gig machine to run smaller applications. And in most cases, if you don't have traffic, you can use less. Right? So that's something. Just pick low and if you need more credits, that's fine.
00:39:51.484 - 00:40:12.960, Speaker A: Please reach out. I think you get $5 worth of Stack tokens and like one dollars worth of matic. So if you need more for your application, please reach out to our desk and we'll give you more. For this example, I'll just pick 101gb bandwidth next. It's going to tell me how much I need and stuff. It's telling I don't have any subscription yet. What I will do is I'll just try to purchase them on the fly, right? So I just do a deploy.
00:40:12.960 - 00:40:43.896, Speaker A: It will send MetaMask to open and here I can just pay for it now. It can take the polygon time to finish the transaction. All of us probably are aware that when there's a lot of load on the network, it intends to become slower. So I'm hoping nobody's minting NFTs, nobody's having NFT sales in the bear market. So the transaction should probably go very quickly. But it is kind of still the cheapest chain, so it kind of works out really well. There you go.
00:40:43.938 - 00:40:44.704, Speaker G: All right, perfect.
00:40:44.822 - 00:41:43.850, Speaker A: So you just saw this application got deployed, I don't know, I think maybe like in 510, 15 seconds. So I'll just copy the external DNS and app is up. So that's how quick it is to deploy on Stack OS, right? And I can assure you, and for the ones who use AWS, it's going to be quite a while to get anything running. So that's kind of what we really bring in to this space. Now let me give you another kind of example here, right? So I'll just close this and let's say if you want to really see what's happening on the network, so you can basically go run a shell in case you don't want to do this, you can actually purchase your hardware directly instead of going through a dad deployment time. So let's say I want to do 500 millicores of CPU memory. Next again, I'm lucky to just have two me a stack in my wallet.
00:41:43.850 - 00:42:27.580, Speaker A: But not everyone will of you all have it, so please reach out if you need more. So right now what I'm doing, I'm giving a demo of how you can purchase compute separately from a deployment, right? Okay, error but that's fine. But I'm sure it's got already a bought here. So if you see this 500 has been bought here, all I do is now I can just basically go and deploy any apps right as I want. In this example, let me just see if I can launch a shell to see what's happening there. So I can create some credentials and password username passwords to log in. In fact, the shell is just as an equivalent of what you would as another application on the net web.
00:42:27.580 - 00:43:05.250, Speaker A: So it's going to take some few minutes to start up, but let me see if it's already up here. Perfect. It looks like it's there. So I can just pass the Credential which I chose to create the service and then you can basically save things, right. So how many of you guys know Kubernetes and commands for that? Okay, decent. You can easily just do same thing. So all your Kubernetes commands will kind of work here, get pods, right? So this is basically how you see the services which are running right now on my network, my wallet is my network here.
00:43:05.250 - 00:43:34.700, Speaker A: That's what controls everything. So you'd see explorer fepdy and stuff. So the other two applications which are running, right. So you can again troubleshoot. If you want to see logs, you could do cubectl logs and you can basically see what logs were there. And if you refresh the page more times, you can see that. If you can tail it again, the commands are just as it is the same general commands which you use for Kubernetes.
00:43:34.700 - 00:44:19.676, Speaker A: It supports that. I think this is F, if I'm not wrong to do a follow, right? So when people as and when people are serving this website so you just see I just press cementors here, I'll just refresh this page and you should see that coming, right? So that's kind of you can actually see the logs as well as they're generated, right? So yeah, I mean otherwise you can go to your App Store and you can pick an app from this place pretty easily. So for the ones I'll just show a game like how fast it can deploy. If an app is on the App store, you can just click and run it. So for this one I'll do hexgl deploy, I'll just use the same name. I can change the name if I want to, but I'll just keep it this way. Next, everything is pre configured.
00:44:19.676 - 00:45:01.060, Speaker A: It's saying I don't have enough compute here, but I will automatically buy. As I'm running this transaction. Resources. Okay. It looks like I don't have enough, but if you did, you'd be able to see an app here, right? Let me see if I can just delete something and create without paying. So I'll just go here. I'll just delete the shell because I think it takes pretty good amount of resources.
00:45:01.060 - 00:45:59.800, Speaker A: I'm not sure if I have enough again. Still. Maybe I do. All right, so I'll just come here and let's say I want to deploy this hexgl game and everything. As you see, I've got enough capacity available now deploy. So that game now is deployed on stack OS. So you can just copy that domain enter and app will be up in a second.
00:45:59.800 - 00:47:00.420, Speaker A: This is the Internet. Speed. Not my fault. In a second, it'll probably just load up completely, and then it should be pretty easy to run. So the entire game right now is I don't want to show off my skills of not being able to play properly, but that's kind of what it is, right? So this is a real game which is working on the decentralized cloud, and you saw how quick it was to really have it running. And I hope you kind of enjoyed what I just showed you. If there are any open questions, please ask those questions.
00:47:00.420 - 00:47:30.396, Speaker A: But yeah. All right. Yeah. Anyone have any questions here? Guys, the microphone which is going around. Okay, there's a question there's.
00:47:30.588 - 00:47:32.800, Speaker B: So who's running the servers?
00:47:33.300 - 00:48:11.084, Speaker A: Is it a group of operators or where is it all hosted? Yeah, it's a good question. So what happens is that there are people around the world who can run these networks. So we have an orchestration layer on top of Kubernetes, right? So people or operators around the world who can run Kubernetes servers, they can basically launch it, install our services there, and then connect it with, overall, the blockchain network, which we have. It's a layer one for infrastructure. So that's how that communication and everything gets handled. As I said, with the V Two version is much more complex and it's much more powerful as well. But that's kind of how it works.
00:48:11.084 - 00:48:29.030, Speaker A: Anyone in the world can basically create an account, and with your obviously MetaMask, not taking your grandfather's details, but you'll be able to just add your clusters to the network. And when people deploying, they just deploy in those servers and they get paid for the cluster operators get paid for hosting the applications there.
00:48:29.800 - 00:48:31.376, Speaker C: How are you ensuring that the cluster.
00:48:31.408 - 00:48:35.600, Speaker B: Operators serve the right content and they're not acting maliciously?
00:48:35.680 - 00:49:14.336, Speaker A: Yeah, so that's a question of verification. Right? And there are a few things. So what is done is that when people are running services, there is another service which sits on the cluster. And his job is to basically verify what's running there. And then what happens is, since his network, all the clusters are connected with each other, they can keep pinging to ensure that the version which is there is true version. And the moment they detect that there is a malicious cluster doing illegal things, they will lose their stack tokens and they have some more things in place as a collateral, which the guarantee is there for, and they just get slashed. So that's kind of how it works.
00:49:14.336 - 00:49:37.704, Speaker A: It's much like the new V two of ethereum. And same thing goes with polygon as well, right? Because if it is a malicious actor or a malicious node, it just completely removes them from the network and they lose their share of things. So that's how we do it. Great question, actually. Thank you. One last question. Yeah.
00:49:37.704 - 00:49:42.872, Speaker A: They never give me time to host this. I don't know why. So I wanted to know hello? Can you hear me?
00:49:42.926 - 00:49:43.530, Speaker H: Yeah.
00:49:45.740 - 00:50:11.856, Speaker A: I can hear you. Okay, yeah, sure. So I wanted to understand if let's say I have a microservices architecture, and you're said that we have pods. So if I wanted all of the pods to be in a one particular cluster in a specific region because I know my users are coming from us, so why would I want to have it in India? Can we do that? Yes. The concept of V Two, which is coming actually V Two makes it more easier. Right now, it's kind of distributed. But with the V Two, what happens is that you can create a subnet.
00:50:11.856 - 00:50:35.404, Speaker A: So people don't create clusters, really, they create a subnet. And that could be for purposes more than this. For example, for GDPR compliance, for the ones who want only European regions to be deployed onto. So you can have a custom subnet serving a specific problem. Let's say, for example, gaming, right? And you want high GPU kind of servers and clusters. You can add a subnet for that specifically. So that's kind of the feature which comes with V two.
00:50:35.404 - 00:51:06.804, Speaker A: Right now you basically are kind of distributed. It's random right now. It is right now, but I think in January it should be more proficient that way. But talking of it from just this point of view, I think that's how we kind of work. Work, right. And once that subnet is basically deployed, is it like, only my applications are going to be in that subnet or is it going to be everybody's else? It will be shared across other, not mine services as well? Or is it like private to me? So your application is always private to you.
00:51:06.842 - 00:51:07.140, Speaker F: Okay.
00:51:07.210 - 00:51:52.512, Speaker A: So the way it works is that any application, when you are signing with your wallet, it ensures that there is a separate isolation of your network just for you. Okay. So even though right now it's kind of protected that way, but it kind of extends it even more further. Right? Because if you want to deploy actually, that's a good follow up. An answer to this as well is that let's say you have an application, which requires back end, two different backends, right? Let's say AI thing as well, a database as well. So what you can do is that you can give environment variables for the endpoint within the pod as a pod, so the back end can talk to your, let's say, database, all internal to your network. So your wallet is your kind of a special network just for you, which only allows internal communication.
00:51:52.512 - 00:52:13.612, Speaker A: Right? So that's how it works as well, if you want to build like a two application or three layer architecture. Yeah, cool. Thank you very much, guys. You're asking me to step down, but please sorry. So please come to our desk and just ask. If you have any questions, we're happy to answer them. We also have discord community.
00:52:13.612 - 00:52:36.530, Speaker A: You can join and ask your questions there. So thank you very much for hearing me out and I hope you enjoyed this. Sorry. Yeah, so guys, if you really want to go out, that's fine, but kindly just keep the headphones down here so that the next set of people can actually just pick it up from here. Yeah, cool, sounds good. Thank you, guys.
00:56:05.030 - 00:58:08.614, Speaker G: Yeah. One, two, three. Yeah.
00:58:08.732 - 00:58:11.426, Speaker A: Sorry, I didn't get it. Just ask them to switch their headphones.
00:58:11.458 - 00:59:36.150, Speaker G: To channel one for audience. Can you switch to channel one? Do you hear me? Perfect. Okay, so hello, hackers. My name is Kilfidase. I work for Ziggybop project. So today we're going to talk about next generation stablecoin with optional privacy. So we'll start first by just brief introduction to our project, why privacy is important, what are we trying to build, what's on our roadmap.
00:59:36.150 - 01:00:39.406, Speaker G: And we'll talk about what task we prepared for the hackathon, what ideas you can use for hacking something together with us, and just in the end, have a small live demo of the API we're trying to propose to you to use during the hackathon. So, in Ziki Bob ecosystem projects, we have three main products. So the Bob itself is a multi chain, multi collateral stable token with what we call optional privacy. Then the Zikibob UI itself is basically a DApp for private micropayments, which could be done at the Zigibob protocol. And then for simplified integrations with another projects and some easier hypothesis testing. We also developed the Zikibob cloud solution, which is basically some semi custodial wallet for integrating private transfer and making them sort of private transfers as a service. So in our use cases for Bob, we are currently exploring the main dominant use case is related to the payroll and invoicing.
01:00:39.406 - 01:01:26.842, Speaker G: So this is a big problem with the privacy related things when it comes to making payrolls in stablecoins. So that's kind of a big hit for making it a private use case for making salary transfers within the privacy pool. Then we're also exploring some other use cases, like vendor purchase intonation tradefi use cases. For example, like for crypto off ramp and on ramping from bank deposits or something like that and minor remittances. So when we talk about for example, employee salaries management, so how it could potentially work. So we have our employer, which would like to distribute salary on, for example, a monthly basis. So he has some probably already stable coin allocated for salary payments.
01:01:26.842 - 01:02:16.830, Speaker G: He can convert his USDC, for example, into bob at a one to one ratio. Then he can deposit this Bob into the privacy pool, Ziki Bob. The employer can deposit his swap the bob into the privacy pool, then pay privately salaries within the pool to all other employees for the ZK addresses they provided. And then employees can withdraw the BOP and use it for their everyday expenses whenever they need it. So other use case includes vendor purchasing organizations. So basically here the idea is that you can organize easily some peer to peer payments within the privacy pool. You can buy some things, you can sell some things to other peer to peer participants for some small amounts with ease.
01:02:16.830 - 01:03:11.620, Speaker G: So, so far we have acquired a few important partnerships with our protocol and we are working hard on expanding this list. So we are working on integrations with additional AMM protocols, lending markets and different invoicing providers and so on. So now a few words about the Ziggybop and how it works technically. So, as I said before, Ziggybop is a day app for private micropayments. So it accepts only bob stablecoins for deposits. Once the stablecoins have deposited into the Ziggybob application, they can be anonymously transferred between participants of the pool by using the Ziki addresses. And once you desire to withdraw from the pool, you can withdraw it to any public address preserving anonymity and you can withdraw any amount and no one will know the direct link with your deposits or private transfers you did before.
01:03:11.620 - 01:04:08.062, Speaker G: So in order to facilitate this kind of activity, zikibob uses as neural knowledge proofs to authenticate transaction details without disclosing them publicly on chain, like sender, receiving addresses, transaction amounts. So the Zikibob application is being, the pool itself is being deployed on polygon. So that's the main network of the project. And the simple UI allows you to abstract from the complexity of the ZK snarks and to easily access your ZK accounts and to use the ZK balance for everyday activities. So here's how the UI looks in basic. So, zero knowledge proof confirms the validity of each action. So the action might be either deposit, transfer or withdrawal from the pool without revealing the particular details of the action on chain.
01:04:08.062 - 01:04:58.622, Speaker G: And only the actual sender and the receiver of the particular operation is being able to actually decode and access the private fields and metadata of this particular transaction. And a few words about the Zikibok cloud. So that's actually the API we want to propose you to use the hackathon. So basically it's a semi custodial API which is offering private payments as a service. So important point is that it shares the same underlying tech and infrastructure as the Zikibobd app and the UI itself. And the main intent here is that we want you to use it to smooth tender transition from web Two to web three apps, to simplify potential integrations and speed up testing of new ideas, hypothesis and so on. So, a few words about our roadmap.
01:04:58.622 - 01:06:00.440, Speaker G: So, we plan to work hard in the future for hard development of new use cases. We'll expand salary use cases and explore new ones. We'll work hard on the different technical protocol improvements like migration to a new ZK Snark technologies, adding some new business features to the protocol. We'll plan to work on the decentralization of the protocol and each and every part in that, and also work around some innovations in the field of anti money laundering and KYC processes and see how it can seamlessly integrate with our protocol. So now let's jump into the hackathon. So, the task for the hackathon for you to be eligible for bounty application is simple. We want you simply to make some solution which will help us to increase mass adoption of the Bob Stablecoin and the Zikibob Protocol and to overall strengthen and broaden the ecosystem of the Zikibob project.
01:06:00.440 - 01:06:57.370, Speaker G: We want you to do it by integrating Zikibob Cloud API with basically any service, product or application of your choice. Either it already exists or you plan to develop your own. So, in order to be enabled to access to Zikibob Cloud API, feel free to reach out to us in our official Zikibob Sponsor Discord Channel for getting access to the production keys for the Ziggybop Cloud APIs. So you'll get some pre funded wallets for that. Feel free to just say your team name, include the list of members and we'll send out you the necessary keys. So, just a few ideas for what you can hack during the hackathon and where you can integrate this Cloud API. So, it could be any donation of fundraising platforms, it could be something related to the Dao accounting problems, it could be also related to payment splitting between friends when paying for dinner, for example.
01:06:57.370 - 01:07:44.194, Speaker G: It could be also some technical integrations within existing wallets, or the developments of new browser extensions or something like that. You can also work on integrating Zikibob Cloud different social media bot platforms like Telegram bots, Twitter bots, you can write your own browser extensions and so much more. So of course this list is not complete. Feel free to add any idea you want. So we don't want to limit you here. Basically any legit and viable use case for the Ziggybop Cloud will be highly appreciated in case it just actually have some potential to be used by real users. So, a few words about requirements and prices.
01:07:44.194 - 01:08:24.482, Speaker G: So, what we are offering is the five bounties of 2000 USD equivalent which will be paid in Bob. So also feel free to get or already have the swag for. Everyone who uses the Ziki Bob successfully uses Ziki Bob API in their projects. So in order to qualify, the only actual criteria is to just use the Zikibob API. You are free to use to any other tools and qualify for other sponsor submissions. Please indicate Zikibob project in your final submission as well. And during the judging process, we'll consider of course, creativity, novelty, usefulness, and the general implementation details of your solution.
01:08:24.482 - 01:09:17.510, Speaker G: We'll see how integral is the usage of the Zikibob Cloud API within your project. We also will see how your project aligns with the overall vision of the Bob ecosystem we have. So that's what we call general Bobiness. And also just take a note that extra credits might apply in case you want to natively integrate with Zikibob SDK libraries, which directly operate with Snark shortcuts and proof generation. So this might be more advanced topic, but in case you successfully did something like that, that would be definitely considered and rewarded with some extra credits for the grading. So, yeah, now we'll try to see some live demonstration of the protocol and how it works. So we'll start from the UI.
01:09:17.510 - 01:10:02.228, Speaker G: So once we log in into the UI application, we'll see that we have public and private account. On the public account, we currently have ten bob, which is equivalent of ten USD. So what we can do here is we can just click Max and make a deposit into the privacy pool. So we'll sign some request into our MetaMask wallet. We'll wait until the UI and SDK library generates necessary proof for the SDK shortcode evaluation. We'll wait until the proof is being sent to the relayer, until the relayer sends his transaction. The pool itself, as I said, is deployed on polygon.
01:10:02.228 - 01:10:42.690, Speaker G: So we'll wait until the transaction is mined. So hopefully it will take just a few more seconds here. So, yeah, here it is. And in a few seconds, we will see that our public balances actually decreased by ten Bob and our private balance actually increased by the amount we deposited. And if we go into the history, we'll see that we just made 40 seconds ago, a deposit of 9.9 bops. So that's how simple the deposit looks for UI.
01:10:42.690 - 01:11:29.480, Speaker G: And now a few words about the Cloud API we want to use. So, all the methods are described in the docs we provide for the hackathon, so you can explore it in a textual format. But for some practical testing, we also developed this insomnia collection of API requests, which is the simplest way we thought it would be for you to try to integrate and play around with the API we're providing. So in order to use that, you will need the API key. So I just prepared one of the API keys we could try to use. So, yeah, it's already here. Let me see if I can increase the font.
01:11:29.480 - 01:12:19.480, Speaker G: Yeah, this one should be better. So the API key provides you access to one of the basically ZK accounts which is being held in the custody of the API service we provide. So in that sense, these accounts are being managed by some semicastodial solution. So we have a few requests through which you can interact with your ZK account on the API service. So you can request basic information about your account, like balances and transaction history. Since the account is new, we see that we do not currently have any balance, we cannot transfer anything, and we don't have transaction history. So in order to just get some funds into account, we'll go to the further request and generate the receiving address.
01:12:19.480 - 01:12:47.420, Speaker G: We'll copy that and go back to the UI, to the transfer tab. And now we'll send from a UI account to the Zkbob cloud account, for example, six bobs. So we'll confirm the action, wait again until the proof is generated. The transaction has been submitted through the relayer and been processed by the polygon network validators. So it will again take a few seconds here.
01:12:49.110 - 01:13:17.696, Speaker A: It all right.
01:13:17.718 - 01:14:16.884, Speaker G: So our transaction went through. If you go back to the history, we'll see that we just sent six Bops to someone else to the ZK address. And if you go back to the Zkbop cloud collections collection of API requests and request once again the account information, we'll see that our cloud account just got his balance increased. We'll see that in the transaction history, we now have this entry, which is telling us that we just got some incoming transfer in this transaction hash for this amount, which happened on this timestamp, and we received it on this ZK account. So now the remaining part is basically how do we make the transfers outside of our cloud accounts? So here we have two basic scenarios. So we can either make some transfer to ourselves, which is called basically loop transfer, so we can do that. So we'll just enter that.
01:14:16.884 - 01:14:54.064, Speaker G: We want to send, I don't know, two bobs. So here we use nine decimals of precision. So that's why we add nine zeros in the end. So we'll send the request to make a transfer for our own shielded address. So no funds actually get out of the account, but we'll just see how it looks in the history and how it's been represented by the API responses. So now we can request the status of the recently sent transaction. Recently sent request now tells us that the job is being relayed by the service.
01:14:54.064 - 01:15:43.890, Speaker G: So we'll wait a few seconds until it goes through. So it should take probably the same amount as it takes through the UI. So as the underlying infrastructure, the technology is the same. It's used the same pool, the same smart contracts and just the same infrastructure. Okay, so now we see that the transaction went through successfully. We see the transaction hash. We can actually copy that transaction hash go to polygon scan Android here and see that actually something happened, something was sent to the pool smart contract address.
01:15:43.890 - 01:16:42.708, Speaker G: And if you now go back to the account info, we'll see that our balance only decreased by the amount of the small fee we paid for the transfer to ourselves. And if we go back to the transaction history, we'll see that we got a new action which actually tells us that we just transferred money from ourselves to ourselves just to play around. And the second thing we might try is just to send money to some other account. So we'll need some external ZK address for that. So for that we can go back to the UI, click on the ZK account tab, generate the receiving address for our UI account, and basically make a transfer here. So we'll again enter some amount of like four bob. For example, we'll enter the CK address here, we'll submit the request and until again, wait until the request goes through.
01:16:42.708 - 01:17:58.760, Speaker G: So we'll see that request is being now processed by the relayers. So just another ten or 20 seconds and it will be marked as successful. And after the request goes through, we'll actually see that our funds came back to our UI account where we initially sent them out of. Okay, so the transaction is completed. If you go back to the account balance, we'll see that our balance actually decreased. If you go to the transaction history, we'll see that we now have the transfer out event for some amount, some fee. We paid basically all the information we have for our transfer.
01:17:58.760 - 01:18:44.818, Speaker G: And if you now go back to the UI, click this little refresh button, we'll see that now we got some okay, we accidentally said 0.4 bob, but no problem. So, yeah, we just got some incoming transfer for our UI account, which is outbound transfer for our Ziki Bob cloud account. So I guess that's it about the basic functionality of the Zikibob cloud API and the UI. So, yeah, now go back to the presentation. Just a few quick links for you to check it out and be prepared for the hackathon. So the first link is just the link tree of all the links related to the project, to the UI, to the docs.
01:18:44.818 - 01:19:39.000, Speaker G: The second link is just the general resources for the hackathon, the description, the bounties, the suggestions for the ideas. Yeah, feel free to reach us in the sponsor Zikibob channel discord for requesting API keys or any other questions or just came by our booth to ask for some questions in person in case they are there. And just in case you want to receive some small AirDrop for our team for your private personal ZK account, just feel free to scan these QR codes and we'll distribute some small present for all participants of this workshop in the next hour. It so I guess that's it. Yeah, if you guys have any questions. Probably have time for one or two.
01:19:59.590 - 01:20:00.340, Speaker A: Hello?
01:20:02.950 - 01:20:04.180, Speaker G: Doesn't work.
01:20:07.590 - 01:20:08.340, Speaker A: Hello?
01:20:09.190 - 01:20:12.284, Speaker C: It's working now, I think.
01:20:12.422 - 01:20:31.416, Speaker B: So I was wondering, so not that long ago, tornado Cash had some legal trouble in the United States, I believe. And I'm wondering if you're concerned or.
01:20:31.438 - 01:20:34.712, Speaker G: I'm wondering how is VK bob's situation different?
01:20:34.766 - 01:20:41.240, Speaker B: Like, are you guys concerned about regulators not really being such a fan of privacy?
01:20:43.340 - 01:21:09.968, Speaker G: Yes. So that's the question everyone asks. So we think that's important to not forget about the existence of regulators and to make such kind of protocols in a way that we want to cooperate with regulators and prohibit illicit activities. So there are a couple of heuristics. You can apply for that. So we started by setting very strict limits on the amounts you can process by the pool. So the deposit size is very limited.
01:21:09.968 - 01:21:53.570, Speaker G: So you cannot deposit a lot of money into the pool. You cannot withdraw a lot of money into the pool at once. The pool size itself is very limited by 1 million bob price now. So it's not very interested for hackers with big bags of stolen money to try to launder them through such kind of thing. We're also thinking in a way of how we can integrate some zkyc solutions like polygon ID or something like that. And we also continue our research into ML and KYC integrations and see and what we can develop here. Or in case you guys can potentially suggest something throughout the hackathon, this also would be highly appreciated and highly graded from our side.
01:21:56.100 - 01:22:05.460, Speaker A: Yeah, I wanted to know about the stable coin. How is it backed and how do you maintain USDC to the bob?
01:22:06.120 - 01:22:36.690, Speaker G: Yeah, so Stablecoin model is closer to the over collateralized one. So for now, we started with a simple approach of backing the stablecoin just one to one with the existing stable coins like USDC or BUSD. But in the future, and we're already working on that, we'll add this collateralization mechanics where you can print and mint new tokens with the collateralization of other volatile assets like ether matic or some more complex derivatives like LP positions or something like that.
01:22:37.460 - 01:22:48.516, Speaker A: And the relayer fee is always 0.1 bob, or is it 0.1 ZK bob? The relayer fee between multiple parties, the transactions that happened.
01:22:48.698 - 01:22:52.740, Speaker G: Yeah. So the relayer fee is 0.1 bob.
01:22:53.960 - 01:23:12.340, Speaker A: And when you sent that amount back, like the 0.4 bob, which was from the cloud wallet, the ZK cloud, to the one which is noncustodial, would that be somehow tracked on chain or that is something cannot be linked together, that this was one you sent to and.
01:23:12.350 - 01:23:13.612, Speaker D: This is one you got back.
01:23:13.746 - 01:23:30.640, Speaker G: So, yeah, the only thing that could be tracked on chain is that you paid the fee of 0.1 bob, but that's it. Nobody knows from which amount you paid it, so no one knows the actual amount transferred. And since everyone has the same fee, that actually doesn't leak anything and last.
01:23:30.710 - 01:23:48.708, Speaker A: Question is, if I may, the API key, can that be some sort of like, multi signature? Like, can I get it to share with other and then sign it on behalf of them? Or how does that API key really work? I mean, is that going to be transitioning to any other model where we can have multiple signatures?
01:23:48.884 - 01:24:17.792, Speaker G: Yeah, sure. We do not have any solution for multiparty thing, kind of for now, but that's definitely a good idea. We'll work in the solution. So I have personally a couple of thoughts on that. So it's not ready yet, but definitely we'll be added in the future if we'll see the sufficient demand for these cloud like applications and from projects which are not willing to directly integrate with SDK, which can be complex for someone. So, yeah, I think that makes sense.
01:24:17.846 - 01:24:18.450, Speaker A: Yeah.
01:24:37.200 - 01:24:43.550, Speaker G: It yeah. Please guys, leave the headphones on the seats if you want to leave. Yeah, thank you.
01:30:28.190 - 01:30:39.150, Speaker H: Hey, can you just raise your hands if I'm audible? Awesome. That's great. I hope everybody has colored paper in your hand with a sketch. Thanks a lot.
01:30:39.300 - 01:30:40.190, Speaker E: You're good.
01:30:40.340 - 01:30:55.810, Speaker H: If your friends because this previous workshop got delayed, if your friends wanted to attend for the Questbook workshop, please ensure that they are here and tell them that they have to tune into Channel One. I'll be starting in a minute.
01:30:59.270 - 01:31:00.660, Speaker A: Awesome. Cool.
01:31:02.070 - 01:31:27.354, Speaker H: Hi, everyone. Thanks for coming for the workshop. I'll give a brief intro about me, myself, and Questbook before we start this presentation. I'm Harsha. I'm the co founder at Questbook. Questbook is a place for builders to apply for grants, and it's a decentralized grants orchestration tool for protocols to disburse their grants as well. And till now, we disburse close to $1.2
01:31:27.354 - 01:32:05.190, Speaker H: million in the last six months to developers. So if you're a builder, if you're hacking something at the hackathon, keep an eye on the product because this is where you'll find all the grants opportunities. Right now, I've also set up the grants program for polygon. So I've been on both sides of the table. I have been on the admin side where I operated the grants program. And for the last six months, I myself, like any one of you, have worked on a grant proposal for compound. I have requested a $1 million budget allocation as part of the grant proposal.
01:32:05.190 - 01:32:36.482, Speaker H: In this presentation, I'll walk you through how I worked through that proposal. And there's a charm at the end. I'll tell you what's the current result of that proposal as well. It's a very special day because today is the announcement date for that proposal as well. I'll share the result towards the end, but yeah, I'll share both sides of the table. Now, make sure you have the paper and the pen with you. So first, just write down whatever idea you have.
01:32:36.482 - 01:33:13.000, Speaker H: Like, it could be vague, whatever idea you're planning to hack at this hackathon, it could be. Very simple. It could be very crisp. It need not have a detailed roadmap. Just write your idea on your papers. So I'll walk you through how a grant's proposal has to be written and make sure at each slide you're implementing the suggestion on that slide. Cool.
01:33:13.000 - 01:34:05.928, Speaker H: Let's cut to the chase. So what I'm going to do now is these are all actual grant proposal reviews which were done. So all the screenshots which you are looking at, these are the reviewer comments across protocols, across proposals. So we'll be actually talking data, see what kind of proposals interest a grant reviewer, what they focus on, what they don't. Okay, first, whatever idea you have written, make sure that you have a USP. It could be anything. Like, it could be, say something like this right here there are existing products like what you are planning to hack, but what is that small USP which differentiates from the existing products in the market? It could be very simple, right? Like for example, in this proposal, they used a more legit collateral compared to any other proposal which was trying to do the same thing.
01:34:05.928 - 01:34:23.836, Speaker H: It's a very small USP, but still it caught the reviewer attention, it caught the committee's attention. So make sure that however small the USP is, make sure that you point it out. I'll read it out if you're not able to see. So the second proposal has a very strong UI.
01:34:23.868 - 01:34:24.560, Speaker A: UX.
01:34:24.980 - 01:34:50.360, Speaker H: It's a very simple product. It's a very common product, very common proposal across the grant programs. But the USB this proposal has is a strong UI. So it need not be a web three differentiator, it could be a web, two differentiator. It could be as simple as a user experience, how it feels even that is a USB for you. Make sure that you call it out in your proposal. This is something interesting.
01:34:50.360 - 01:35:27.124, Speaker H: This is something which we might generally miss. If your proposal is specific to a demographic, right? Like if it is specific to a particular region, a particular country, make sure you point it out. I mean, this is not relevant for all the proposals, but there could be proposals where you are implementing an activity, a community activity, which is very specific to that particular region. So make sure that is called out. Like if you look at this proposal, the whole attention on this proposal was because it was related to that particular region. It got the attention because it's relevant in that particular region. So make sure if it's demographic specific, it is very clearly called out.
01:35:27.124 - 01:35:56.416, Speaker H: It is one of the key metrics. When you review a proposal, it will stand out, right? This is regarding having a USP on the proposal. I'm hoping that you're making note on the pages. So how much grants to request. I think it's quite intuitive. Look at similar proposals on other grant programs. There will be very similar, like if not exact matching, but there will be similar products which you are trying to propose as well.
01:35:56.416 - 01:36:38.620, Speaker H: If you are at an experimentation phase, if you are at a phase which you're not sure of a very detailed roadmap, if you are not aware what three months is going to look like for the product, clearly call it out and ask for an experiment grant. So all these grants which you request for experiments, keep it very minimal. Ask for a reasonable grant. Committees do review proposals which do not have a product yet. They do appreciate experimentation, but make sure that you call it out. And you also also have to clearly share what your metrics are going to be. On what basis are you going to measure that your experiment is successful? On what basis are you going to measure that your experiment is not successful? And ask for a reasonable budget.
01:36:38.620 - 01:37:17.252, Speaker H: Because any abnormal budget, it catches the attention in a negative way. Immediately there is a cross mark and there will be questions. So make sure that you are putting up a reasonable budget. And if you're an experimentation phase, call it out. Whatever contributions you have done, whatever development has been done to your product, make sure everything is relate to the community member. I understand that because the grants process is through a form through the committee, you might not always have access to the Grants Committee. The best way to deal with this is to ensure that all the progress is relayed on the community channels.
01:37:17.252 - 01:37:49.140, Speaker H: Make sure this is put up on all the telegram groups of that particular protocol. Make sure it is being discussed. Take feedback from the community on discord. Okay, this is the way the Grants Committee will be part of these channels and they will have an eye of what your progress is. Make sure every development is communicated to the channel. It's always good to be over communicative. Start from the scratch of the product and share the entire implementation details.
01:37:49.140 - 01:38:14.350, Speaker H: Of course, team is quite crucial, especially if you're at an experimentation phase. Make sure that your credentials are called out by credentials. It need not necessarily be you worked at XYZ. It could also be your previous GitHub contributions. It could be your previous contributions to similar projects. It could be relevant experience in that particular product which you are building. So more relevance, the higher the mark.
01:38:14.350 - 01:38:48.548, Speaker H: For example, they had a very detailed organization. The proposal applicant had a structure in place to handle the product. So make sure if you're a team of more than one, then clearly lay out who is handling what on your product. Again, this is kind of a repetition from a previous point. This talks about previous work. Make sure that all the product developments are related to the community. As I said, if you look at this proposal, their previous contributions were really crucial.
01:38:48.548 - 01:39:20.018, Speaker H: Like they might not have shared this with the interest of this grant proposal. Getting accepted. But the entire community was aware that the applicant previously worked on similar products. That played a really crucial role in accepting this particular proposal. Go to the product detailing. So if you look at this particular proposal, they went to the extent of writing a white paper for their grant proposal. Like very detailed, right? Like spend that time.
01:39:20.018 - 01:39:49.710, Speaker H: Don't rush into submitting a grant proposal. Don't rush into I know there are these grant cycles and you'll have to submit them before the grant cycle ends. But when you are doing it in a rush, it's always evident. Make sure that a grant proposal is as detailed as possible. Do your research. Make sure that research you have done is showcased in your proposal as well. Like here the single USP was that they had a white paper and though there were like five, six negative comments on this proposal on different elements, this still got accepted.
01:39:49.710 - 01:40:18.900, Speaker H: This was one more team which cracked the proposal grant. Because of participation in the community, it's always a good habit to share your observations. Even if you are researching about your product, even if you are having learnings, make sure that you hit them up on discord. Share it in the community. There are similar people who are working on similar products. They would like to collab with you. They would like to set up a one on one call to share feedback.
01:40:18.900 - 01:40:30.620, Speaker H: Don't miss out on these opportunities. It's always good. All these discord communities are very proactive. The community is very generous. So don't hesitate to share your learnings and observations.
01:40:32.400 - 01:40:33.256, Speaker A: This is crisp.
01:40:33.288 - 01:41:12.010, Speaker H: Make sure the first line of your product grant proposal clearly explains the product. It should not complicate the thought process of the reviewer. What is the easiest way for the grant reviewer to proposal reviewer to understand your product? That should be your first one to two sentences. Make sure that the product presentation is very crisp and clean. These are the do's. There were proposals which have a direct red mark which get rejected outright if you miss out on certain details. So I'm hoping you're making notes or just adding whatever slide is relevant to your idea.
01:41:12.010 - 01:41:53.372, Speaker H: Lack of details. Even if you are at an experimentation phase, even if you are at an idea or an initiative which did not still yet take shape, make sure that it is very explicitly called out, right? It should not come out as hey, there are details were not shared. Even if the details are not shared, they should know why certain details are not shared. Maybe if you're at a development phase, you are still yet to figure out who your developers are going to be for this product. Call it out. Make sure the committee knows in and out of your proposal or your approach, your research, your work being done on that particular product. This is little difficult to predict.
01:41:53.372 - 01:42:29.916, Speaker H: To be honest. This is not entirely in your hands. There could be circumstances which could affect your grand proposal. Like it could be a great idea in a bull market, but it could not be something which will catch attention in a bear market, right? So there could be proposals though. A great idea, perfect implementation, fantastic team, but still might not get accepted because of the circumstances. So make sure that you take this feedback from the grant committee review team so that you are aware why your proposal is not getting accepted. If it's something to do with the circumstances, you will have to just hit back when the time is right.
01:42:29.916 - 01:43:10.290, Speaker H: So this is one of the key elements which we don't have control on. We also don't take this into consideration while submitting a proposal. This is very simple, very basic. Across all the grant programs, this is one line which everybody cares about milestones. There are protocols which take for example, if you apply for a grant at Ton, you will have ten milestones as a mandate. So you will have to define ten milestones for your grant proposal. It's very difficult, right? When the moment you are defining ten milestones, you are going as granular as possible.
01:43:10.290 - 01:43:37.030, Speaker H: You are explaining them every single implementation detail, every specific action which you take with your team. So the more milestones there are, the detailed the proposal is. It's always good if there are no milestones. It's very clearly visible that you are coming here for free money. Though grants from the marketing standpoint might look like free money, it is not. Protocol is treating this grant money as an investment. They are not just using this for marketing.
01:43:37.030 - 01:43:40.762, Speaker H: They want to ensure that their protocol grows when they give this grant to a project.
01:43:40.896 - 01:43:41.194, Speaker A: Right?
01:43:41.232 - 01:43:53.140, Speaker H: So when you are requesting for a proposal, make sure that your milestones are very clearly laid out. It can't be random, it can't be vague. You don't get access to open grants just because you have a great idea. You have to have a very detailed milestone set up.
01:43:55.190 - 01:43:55.602, Speaker A: Okay?
01:43:55.656 - 01:45:04.646, Speaker H: This is one proposal from Filecoin which stood out amongst many others. There are multiple things which were good about this particular proposal. I just only called out three to four crucial elements. Look at the project description. So when you are giving out your project description, when you are giving out your proposal ideas description that clearly shows how much research you have done on that particular idea, right? So if you look at this proposal's project description, the entire research they have done and also they also talk about similar product which has been implemented within Filecoin itself, similar proposals, why the previous proposals didn't go about why is this unique as compared to other proposals in the grants program? It clearly calls out, they talk about the entire research which is being done in order to ensure that their project is very clearly described. What is the value that you are adding? This is another key element. Like if you look at a template of a grant proposal, you might not find explicit side headings for this.
01:45:04.646 - 01:45:38.066, Speaker H: Like they won't have a very clear heading stating that, hey, can you share the value this proposal is going to add to the protocol? But this is intuitive. This is intuitive for a reviewer. This is what a reviewer will be looking out for. They would be looking out for what this particular proposal what this particular idea is, adding value to the protocol. But this is in general not actually called out in the proposal form. So make sure that you include this in the description you include this in your proposal even though it's not actually asked in the application form. And this is obvious.
01:45:38.066 - 01:46:17.102, Speaker H: The deliverable is very similar to milestones and you have a very detailed like this proposal has a very detailed roadmap. Starting with if you look at their proposal, they literally have a weekly submission for their development, like 25th January, then they have 1st February, then they have 15th February. So they have a very detailed execution plan. They are also promising the deliverables in the like if you have not clicked a picture, they're also promising the deliverables and the development roadmap date wise. So if you look at it, it's very clear, right? It's very evident that they have done their research. They know what they are doing. They know how to organize their team.
01:46:17.102 - 01:47:11.248, Speaker H: They know how to get their team to deliver the promised deliverables. Again, coming back to the team slide, the Credential slide, which was again relevant experience, not just contributions, not just GitHub contributions, but your contributions in the relevant field, in the relevant product ideas is what matters. So I'll quickly summarize, these are not actually asked. Project description of course is asked in a different way, but these are the things which are not explicitly asked on application forms. But make sure that you include this on your proposals, project description, value deliverables, development roadmap and relevant experience. This is the current status of my proposal with compound. The result will be out in 19 hours from now.
01:47:11.248 - 01:47:42.836, Speaker H: But I have requested for a $1 million budget to disburse through Questbook. I have worked on this for the last six months as a grant applicant. So I was in your shoes for the last six months working on my proposal, doing my research. I'll quickly brief you what all went into because this is a huge ask. This is literally ten to 13% of comp treasury that we are requesting from Compound, right? And this is not the first. Like this proposal is about launching a grants program for compound. It is like a meta proposal.
01:47:42.836 - 01:48:03.728, Speaker H: This is a proposal to launch a grants program. Now, they already had CGP 1.0, which was successful, and I'm relaunching CGP 2.0, which means that I need to have a clear definition of CGP 2.0. What am I trying to do here? What are my learnings from CGP 1.0. It took a lot of time. It took me six months.
01:48:03.728 - 01:48:35.000, Speaker H: This proposal is to run the grants program for six months. So to run a grants program for six months, I had to do research for six months. So I'll quickly explain what all went into the six months. First one month, I did a lot of research. I spoke to the previous grant committee members, I spoke to active community members of Compound. I prepared a first draft of the proposal. But even before I shared it with the community, I shared it individually, one on one with the active community members, the core compound developers, the core contributors of Compound.
01:48:35.000 - 01:49:05.456, Speaker H: I got their feedback even before I put it out there. Right then, the first draft of the proposal, I took the feedback on the community. There's a discourse forum, I put it up there. The proposal for voting was put last week. But on the discussion forum, I have put it up six months back. Like, took the feedback, spoke to the token holders. At the end of the day, people like, if it's such a huge grant proposal, if this has to do with a million dollar budget, if you're requesting for a high budget grants, it goes through a voting forum.
01:49:05.456 - 01:49:25.500, Speaker H: And for that, the token holders will be voting on your proposals. So it's not just a discourse forum community which is showing interest in your proposal. You will need interest from the token holders. The token holders are the ones who are actually going to vote on your proposal. So I had to make sure that I get their feedback. Their feedback is incorporated. Had to explain them why this program is being launched.
01:49:25.500 - 01:49:55.296, Speaker H: And also there is a threshold for every quorum. Like for Compound, it was 400,000 votes. So at least when there is a 400,000 votes being voted, only then the proposal will be valid. I had to go through legal compliances. Then the process to put up the proposal itself took a month. And at the end I had the proposal up last week and it is going to end soon. I have 415,000 votes for the proposal and two votes against my proposal.
01:49:55.296 - 01:50:21.016, Speaker H: There were very basics which I stuck to. I ensured that the structure is very detailed. I feel this is simple. You have to just stick to your basics and be very persistent. Like, I'm not personally a very deep programmer. I don't have a very deep knowledge into technology. But I was very persistent in understanding the concepts.
01:50:21.016 - 01:50:44.420, Speaker H: I was very persistent in understanding the community. I was very patient in speaking to I spoke to more than 300 plus grant applicants when I've set up the grants program for polygon. So when you are proposing something, make sure that you speak to the community members. So this was one of that. Like, my research took a lot of time. Almost month and a half was just speaking to the community members. Be active in the community.
01:50:44.420 - 01:51:06.092, Speaker H: It's okay if nobody is responding to your messages on Discord. It's okay if nobody is responding. Nobody is answering your questions, but still ask them. There will be people who will be generous and eventually connect with you and coordinate with you to ensure that your proposal is out there. This had a very simple structure. I always start the proposal with the summary. The summary is not towards the end.
01:51:06.092 - 01:51:28.740, Speaker H: I ensured that the summary is very clear. People know why I'm putting up this proposal. I've put up the purpose. Why am I even launching CGP 2.0? The problems solution. How am I designing my particular program? What am I expecting out of this proposal? And last comes the credentials. Why am I even doing it? What's best book and the product and the compensation details.
01:51:28.740 - 01:51:49.460, Speaker H: I always ensure that it's pictorial. Make it as easy as possible for the reviewer to understand. Make it simple to comprehend for a reviewer. I had a grant program structure, very pictorial. I put up my research. Like, I've done a lot of research. Make sure that you speak to relevant members.
01:51:49.460 - 01:52:15.780, Speaker H: Also discuss this in similar Discord communities. Like, it could be a different protocol, but a similar protocol. Make sure that you're also talking to those community members. Like, if you look at my draft, I start off by saying that these are the core contributors of Compound. One of them was the grant lead for the CGP 1.0. So this is my first line of my proposal. I have done my research.
01:52:15.780 - 01:52:39.610, Speaker H: That is what I wanted to say. I spoke to people, I put in efforts. I have done my research. I ensured that all the loopholes are blogged, program design. What is the inspiration? It's not like an idea which is entirely unique. Ethereum foundation uses a very similar model. So I ensured that all the programs which are already using similar models are also mentioned.
01:52:39.610 - 01:53:20.080, Speaker H: Whatever is uncomfortable, whatever is the gray area, make sure that it's whitened out legal compliances. If there is anything, make sure you speak to don't hesitate to speak to legal advocates and take their opinion. Compensation details, be as clear as possible. What are you charging for? How much are you charging and why are you charging? And that's all. I have the quorum right now with 400,000 votes. If I was able to submit for a $1 million budget and in a bear market, I'm pretty sure each one of you would be able to do it. Just make sure that you are genuine and following the steps very sincerely and be persistent with your proposal.
01:53:20.080 - 01:53:29.788, Speaker H: I have my team, Richiek and Shweta, who will do a very quick demo. I think Richik will share what to be done with these color papers at the end of the talk.
01:53:29.874 - 01:53:30.510, Speaker I: Yeah.
01:53:35.360 - 01:53:39.230, Speaker H: You want to do it here only or you want to call it?
01:53:46.760 - 01:53:48.310, Speaker A: Hey, I'm audible right?
01:53:48.680 - 01:53:49.428, Speaker G: Cool.
01:53:49.594 - 01:54:36.540, Speaker A: So you can scan this QR code that's there and you'll be able to visit our website. So upon visiting Questbook, you'll be able to see all the grant details that is there. And this comes up like this. And this is for your own benefit. As in all the points that Harsha mentioned, they are jotted down here in a very crisp format for you to refer to them during the hackathon or even after that as well. And once you submit the proposal, it comes up and you can submit several iterations of it and use it during the hackathon to maintain your draft your proposal and at the end submit it on the fourth. I hope you have a great hackathon.
01:54:36.540 - 01:54:37.680, Speaker A: Happy hacking.
01:54:41.780 - 01:54:43.170, Speaker D: Yeah, thank you.
01:54:46.100 - 01:54:47.610, Speaker A: Thank it.
01:55:07.190 - 01:55:39.674, Speaker H: So I so the that's the end of the presentation. Thanks for being patient and listening to the entire presentation. Make sure these color papers, which you have with the ideas, are stuck at Questbook booth. Right at the entrance you'll see people with lime green shirts and there is a Questbook booth. You stick these proposals at that booth. We connect you to the protocols, all the relevant ideas. We connect you to the respective grant programs.
01:55:39.674 - 01:56:06.640, Speaker H: We ensure that you receive feedback. We ensure that you are involved with the community. So don't miss out this opportunity. It takes a huge route. Otherwise, make sure that all your ideas, however simple they are, put it up at the booth and grab a merch. Any questions? Sorry, I think we have a couple of minutes for the questions. Yeah, I can take a couple of questions if anybody has any.
01:56:06.640 - 01:56:28.890, Speaker H: Can you share the micro?
01:56:32.110 - 01:56:33.626, Speaker A: Am I audible? Yeah.
01:56:33.648 - 01:56:34.220, Speaker E: Okay.
01:56:35.170 - 01:56:55.058, Speaker A: So actually the question is you shared a completely detailed way of how to write a grants program. But I just wanted to ask about how can we come up with the idea, what sort of grant program that we can apply for or where can we prepare a grants program? How do you strike upon the idea for the grants program?
01:56:55.224 - 01:57:19.126, Speaker H: So it's a very simple answer, to be honest. You have to start participating in the community conversations. There are developer community calls which happen on all the protocols. There is not just a single discord group or a telegram group. There are multiple groups divided so that all the conversations are active. Divided so that all the conversations are responded from the core team. So you have to be active on discord.
01:57:19.126 - 01:57:39.890, Speaker H: You need to attend these calls. Don't hesitate to be dumb. It's okay. Everybody out there is putting out their idea. Make sure when you are part of this discord calls or this community developer calls, you share your idea. That is the best place because you'll get the response and feedback real time. Even if there are some other community members who are interested in idea, in your idea, they would collab with you to work.
01:57:39.890 - 01:57:58.962, Speaker H: So don't miss out on these community developer calls. Thanks a lot for staying back. I look forward to your color papers at the booth. We are around for the next three days. Finders and lime shirts.
01:57:59.026 - 02:00:04.960, Speaker A: Bye. It.
02:00:21.110 - 02:00:30.990, Speaker I: Let's speed test out of this. We can work with that.
02:00:36.950 - 02:00:37.650, Speaker E: What's up?
02:00:37.720 - 02:00:49.300, Speaker A: You want me to be here? You it.
02:02:36.310 - 02:02:51.138, Speaker I: Take a picture with a lot of people. There is no people. It doesn't work, right? Yeah, it's working. Oh, nice.
02:02:51.224 - 02:02:51.860, Speaker A: Okay.
02:02:55.770 - 02:03:03.340, Speaker I: I guess let's wait a couple of minutes. Maybe more people will show. But we're already live stream, right? I guess.
02:03:09.670 - 02:03:10.420, Speaker H: What?
02:03:13.940 - 02:03:30.558, Speaker I: It's bigger than this. He's already taking it. But take a picture. By the way.
02:03:30.644 - 02:03:30.990, Speaker E: Yeah.
02:03:31.060 - 02:04:12.570, Speaker I: Everybody should have his own laptop. It's like a workshop. If not, you can just follow me and bring the guide home. But it's strange to speak with people and I don't hear the sound. I've done so many of this, but it's the first silent keynote. Maybe we can key start it. I don't know if we should start.
02:04:12.570 - 02:04:15.050, Speaker I: Is it good?
02:04:18.130 - 02:04:19.280, Speaker G: Should we start?
02:04:23.000 - 02:04:23.908, Speaker I: Should we start?
02:04:23.994 - 02:04:24.856, Speaker A: We're good.
02:04:25.038 - 02:04:26.920, Speaker I: Okay, then we can start, I guess.
02:04:27.070 - 02:04:27.480, Speaker A: Cool.
02:04:27.550 - 02:04:35.100, Speaker I: So, yeah. Welcome, everybody. Let's do a quick round. Are you guys excited? I want to hear some voice.
02:04:35.520 - 02:04:36.220, Speaker A: Yeah.
02:04:36.370 - 02:04:37.740, Speaker G: Are you guys excited?
02:04:38.240 - 02:04:56.544, Speaker I: Awesome. Even if we are doing a silent keynote, it looks like we are here. That's great. I see some laptops here, but yeah, the idea was having a workshop of 1 hour and I think we have only 30 minutes. How many of people know infura or deployed already? DAP. Awesome. Cool.
02:04:56.544 - 02:05:19.320, Speaker I: Yeah. This is like literally some getting started guide. And yeah, basically I'm Francesco. I'm doing Devrel for consensus. Mostly doing MetaMask naps lately. But I'm excited that this hackathon we have not just Snaps Bounty, but we also have specific infura. If you guys went to get some swag on Infura.
02:05:19.320 - 02:05:23.050, Speaker I: We are, I think, on the full right side.
02:05:24.620 - 02:05:24.984, Speaker A: Yeah.
02:05:25.022 - 02:05:59.940, Speaker I: So the idea of this workshop is literally like trying to get an idea on how adapt look like, what's the review, what's the structure and the infrastructure that you want to do an intro to Infura and then basically do it for basic operations, sending and reading Ethereum transactions. We are doing an IPFS transaction when we are storing an image that's quite excited. And then if we have time I don't think we have time, but I will definitely send you the resources. Deploying an NFT on Mainet and mint an NFT on Mainet.
02:06:01.240 - 02:06:01.796, Speaker E: Cool.
02:06:01.898 - 02:06:36.812, Speaker I: So, depth review. So, I guess everybody, how many of you are hacking this weekend? Just want to try to understand. Okay, everybody's hacking and I guess also you have an idea to use Infuria or build a Snap. So that's quite cool. But the anatomy is quite simple, right? We have our own front end HTML, CSS, JavaScript web, three JS where you inject Ethereum truffle ganache for testing your smart contract. How many of you test your smart contract with Truffle. Normally we use some other tools.
02:06:36.876 - 02:06:37.730, Speaker E: Okay, cool.
02:06:39.160 - 02:06:50.180, Speaker I: And then obviously like on a lower level we are defining our smart contract. We can take some pre built templates from Open Zeppelin.
02:06:51.500 - 02:06:52.008, Speaker G: Yeah.
02:06:52.094 - 02:07:40.964, Speaker I: So basically like some react web three JS Truffle for testing and lower end Open Zeppelin and Solidity. So let's do a quick intro. So where InfUr is actually playing the role in all your anatomy of the DAP. You're obviously connecting to MetaMask when you're doing your transaction, but if you don't want to basically deploy your DAP locally when you're testing and you want to deploy it on main net or on testnet, you can use basically the Infura RPC. Right? And basically it's an old provider that is injecting in between MetaMask and Ethereum. Yeah, that's kind of the high level, obviously. Like you guys for the people that raised their hands, you know, a little bit already.
02:07:40.964 - 02:08:10.400, Speaker I: We also launched the decentralizing Fura node network, I don't know, in Berlin. That's super. So the idea is not just deploying your DAP locally and testing it, but having an efficient and smart way to deploy on different networks. Ethereum Networks is just an example. But if you go and we will go on the Infura website, we can see also that you can deploy your DAP on different networks. StarkNet is actually the latest. That's quite exciting.
02:08:11.620 - 02:08:13.500, Speaker G: Why use blockchain infrastructure?
02:08:13.580 - 02:08:52.380, Speaker I: Obviously we are using Fiora because we don't want to have and run our own node. Those I think we're using that a couple of months ago. But single full node requirements around 500 gigs. And obviously like full archive. I don't know if you were here like four years ago, but I remember I was doing some full archive stuff and it was taking like three weeks and now it's probably even more three, four weeks, I think like around eight to sync and download all the theorem blockchain distributed system or art. So there are basically different things. That's why we're going through an RPC provider like Infura.
02:08:53.360 - 02:08:53.820, Speaker E: Cool.
02:08:53.890 - 02:09:54.370, Speaker I: So you can run your own node and use a provider and you can rely exclusively on your provider. And I think the most powerful things that I see in the future is that with this decentralized Infura we can literally have full distributed node ownership and at the same time rely on the uptime time for having different nodes. So introscable IP, ethereum on IPFS layer twos near Aurora, those are just the main one. And it's basically an infrastructure provider where you can actually create different instant connection to Ethereum and IPFS. You have your set of APIs, you have different features like Node archive and interesting is analytics and metrics. So you can see how many transactions you're doing and you can see also there are different tiers, obviously. But I think the main one, it's like 100,000 transaction per day.
02:09:54.370 - 02:11:15.284, Speaker I: Yeah, 1000 developers, application trust Infura, I don't know, obviously MetaMask, but there is a. Bunch of other cool providers like I don't know if you know, Uniswap is using Fura and Comrade wallet zero x Opera although some people don't know Opera they're also running a wallet. But that is quite interesting. Those are the top five method call, right? Obviously the get block, my number, the get price, the syncing and the logs and basically what you see when you have in your account on the bottom right you see your bandwidth usage on a peak and on an average usage. So that's quite interesting infuria infrastructure overview. Yeah, this is a little bit going deeper but basically what's happening there are two ways that is talking on the architecture level but gateway is speaking directly with the RPC system or through WebSocket and it's basically diving into the performance cache and there is the data reconciliation part happening directly to the RPC system. Yeah, this is another deep dive.
02:11:15.284 - 02:11:43.216, Speaker I: A little bit on the backend side. But the most important part are the two, like the transaction service and the node management service, basically, where you can have your watcher, the nodes and the peer to peer connector. And on the transaction side you have the broadcaster and the pool and then optimization index. There are specific toolings that you can record different specific features. That's also quite interesting. Cool.
02:11:43.398 - 02:11:43.756, Speaker G: Yeah.
02:11:43.798 - 02:12:32.980, Speaker I: So the idea of this workshop was not me running only through slides. I have also a couple of colleagues here that had support but the idea was actually doing something just for purpose of time. I can run through already a pre built tutorial but the idea is that I can also provide these resources that you can go home and do it yourself afterwards obviously with style MetaMask I'm using Flask. How many of you know Flask? Yeah, it's basically the canary version of MetaMask where there are a bunch of settings and developer part like for snaps for example when you're building a snap you can deploy and use Flask. I'm just using flask. It's easier but it doesn't really change anything. So let's assume that you're going through the MetaMask phase.
02:12:32.980 - 02:13:14.896, Speaker I: We have also getting some girly testnet, it's not my favorite but paradigm is working well. Also ask me later if you need some girly happy to provide some and yeah, sign up infura literally we can go through but I can show you directly my infura. Let's see if there is internet. So basically that's the normal. So I already created an account. This is just a test account with three sample projects. So what you can see here is when you create a new key, basically you can create a new project but these are previous project that I build.
02:13:14.896 - 02:13:49.180, Speaker I: This is for itIndia. We have also truffle and itIndia. IPFS. Basically when you create a new key you can select the network right, web, three API, IPFS or Ficoin and based on that you can create a name and get your basically keys for talking with the env file. But yeah, basically assume that you registered. Probably you guys want to do it afterwards. But that's basically what I see, let's say, on my project.
02:13:49.180 - 02:14:24.800, Speaker I: And when you create the project, you can go on the manage APIs and you can see basically all the endpoints that are provided. So API key, obviously. So this is like a test account, so you can copy and do everything as you want, but this is just for purpose of testing. Interesting. You can see obviously we get started with ETH, but you can also deploying on scaling and side chain solutions like Polygon, Arbitrum, Avalanche, near and StarkNet. This is like the newest, let's say, family member that you can deploy to. And it's quite exciting.
02:14:24.800 - 02:15:18.212, Speaker I: You can also have different settings and specific security settings when you're accessing your secret recovery. Yeah, that's a little bit. So mostly what we will use is basically on the API key. And when we basically do and deploy our DAP, we can go in statistic and see how many calls actually happens in the past 24 hours. And this is basically the limit of 100,000 calls every 24 hours. And obviously if you need more, although if you look at different RPC provider like 100,000 calls for 24 hours, it's quite good. Yeah, you see also which requests volume and which network request of volume.
02:15:18.212 - 02:16:22.250, Speaker I: Obviously, we did Mainet today. Cool. Oh yeah, this is just an example. What you can do is using the curl, let me just get we can try it out, but basically what you can see here is I already added my oh, I need to see the I need to get in the folder in the Getting Started. What you can do is.
02:16:30.830 - 02:16:31.402, Speaker A: We can.
02:16:31.456 - 02:16:42.480, Speaker I: Just do that, but basically what's happening here is let's see where the.
02:16:47.490 - 02:16:47.806, Speaker A: Oh.
02:16:47.828 - 02:17:52.440, Speaker I: Yeah, it's on the right. But basically what happens is when you're calling infuria with your API key, you can basically see a resort like JSON RPC 2.0. The ID is basically the chain where you are and the result zero X. Yeah, so the idea was basically going through like the Getting Started guide with infura and that's basically this one here already basically downloaded for you. We were following those and after I put also some QR codes that you can go through. But let's just see what's going on here. So we are what happens basically is already run through this.
02:17:52.440 - 02:17:56.200, Speaker I: So I updated the.
02:17:59.930 - 02:18:01.030, Speaker G: Terminal.
02:18:03.550 - 02:18:53.094, Speaker I: We go to our project directory, we install the dependencies, we basically go through the template NVM. And this is basically this one here the TNV. So the structure that is let me just do it a little bit bigger. So basically the structure of the Getting Started is yes, you have a bunch of components. You have the two contracts, the migration and the NFT contract. You have different pages for the react part. And here you have the NV that basically you can define on sending the transaction variable and the IPFS variable and those you will get from the infura provider.
02:18:53.094 - 02:19:32.680, Speaker I: Here the one that we saw it before. So you go on your project, you manage key and it's basically the one that you see here. Yeah, so I did already this before. So basically you install Env, you go through this change here, you put your key and basically now we are running it and basically what's happening is I deployed that locally and and this is basically what look like. Let me refresh that's basically like.
02:19:35.370 - 02:19:35.686, Speaker G: A.
02:19:35.708 - 02:20:11.710, Speaker I: Normal depth that we deployed now locally, what you can do is connect, you see okay, this is my Flask account. And what we're doing here, we're just doing a transaction, right? We can do like, I don't know, like one or something probably spending even more gas fee right now. And basically this is where the send transaction is happening. We just did the transfer ETH.
02:20:14.530 - 02:20:14.846, Speaker F: And.
02:20:14.868 - 02:20:34.674, Speaker I: Basically we did the first sample project. If you want to deep dive a little bit in the code, there is this blog post that we wrote and you can see exactly where those transaction code implementation are implemented. So the transaction inside is in this.
02:20:34.712 - 02:20:35.620, Speaker G: One here.
02:20:37.670 - 02:21:27.620, Speaker I: Where basically you send the function and you basically do the web three provider, HTP provider and getting your current ETH balance. This is basically normal using a web three JS part that's basically like not the best but it's the most common one. And yeah, those are basically all the parts that are happening every time that you are clicking on the DAP and we are connecting the wallet where you're basically getting the balance value and when you broadcast the transaction, basically you are using the transfer. It's basically this one on line. That's a good question. Line 130 or something.
02:21:30.630 - 02:21:31.780, Speaker E: This one here.
02:21:33.270 - 02:22:35.514, Speaker I: Yeah, so that's basically it for the first part. And by the way, if you have any questions like shoot, because it's a long tutorial, it should take at least 1 hour to do it. And yeah, that's basically it. So what now we did is we send a transaction with the depth and we saw the structure, the anatomy, how it looks like and where you're actually doing the specific injection that's a little bit. So basically what's happening is the other things that we can do is that's the review of the transaction, you see the transaction summary. So this is the second part I already pre run for you. Basically what's happening is we're uploading a documents on IPFS and it will basically take this time, this is what we did.
02:22:35.514 - 02:23:18.324, Speaker I: So we set up the environment variable. So endpoints project idea, project secret. This as before we go through the IPFS project. So what you're doing is basically creating the IPFS project, you manage key and these are basically the idea, the secret and the endpoint. Are you guys following? Okay, cool. We run it. So I basically already run it and what we are doing is we can upload, I don't know, like an image or something, something like that.
02:23:18.324 - 02:23:53.950, Speaker I: This is the QR code for our Infura survey. We can just do it test infura. Those are attributes that are optional, but we can put number one and number two. So what's happening here is we are basically uploading the documents on IPFS. Boom, it worked. And we have also the IPFS ash that we are copying it for the next step. What's here happening is basically we prebuild like the IPFS explorer that is happening.
02:23:53.950 - 02:24:31.064, Speaker I: We are just submitting and boom, we have the display file that we can check it. So basically here what's happening is we upload an image to IPFS and what we can do right now is checking code. We can actually, I think even like display on localhost. Yeah, we did that already. And this basically what happened is we upload that upload successful. This dash, this is where it's displayed. Yeah.
02:24:31.064 - 02:24:34.010, Speaker I: Okay, so running Radib through the code.
02:24:34.700 - 02:24:36.010, Speaker G: We are almost done.
02:24:36.800 - 02:25:17.992, Speaker I: It's basically running through a code. We are doing the file upload part and that's you will find in the upload form TypeScript. We do this one basically those are the full file with the attributes. Then we do the upload operation where the JSON package is there we upload. Basically what's happening is we are running through the IPFS node for the upload part and then we are displaying it in the second part. Yeah, so that's a little bit it. Let me go back to the presentation, what we did.
02:25:17.992 - 02:25:44.896, Speaker I: So the blog post that you saw is here. So if you want to run this through at home, that's a useful resource for the next step. We need to use Truffle for testing our smart contract. But you can get getting started here. This is less important. You can also find it online. And yeah, we are basically going through what I did right now.
02:25:44.896 - 02:26:16.460, Speaker I: We pull out the code, we touch the NVF file and we set it up locally. We started the DAP, we run through the local host right now we send a transaction. We upload through IPFS. This is basically the next step, right? The minting and NFT. And then here I put some additional resources. This QR code is the survey that we're doing. We can send also when you're doing the survey like this presentation, if you're interested to take like three, four minutes.
02:26:16.460 - 02:26:38.116, Speaker I: And it's also helping us to trying to understand which network you want us to deploy next for infura purposes. Yeah, I mentioned before the decentralized Infura and if you guys are a node provider or you're interested to be part of, you can apply directly through this. I also added the QR code.
02:26:38.298 - 02:26:39.030, Speaker F: Cool.
02:26:39.480 - 02:27:09.470, Speaker I: I think we are there. You can obviously follow Infura and we have a bunch of videos from our Deverel friends at Infura and yeah, you can find our booth there if you're interested in also hacking on Metamas naps. We are around for the next three days. We have 10,000 in Bounties. And yeah, also feel free to stop me wherever you see me. And awesome to be here in India. Thanks, guys.
02:27:14.480 - 02:27:15.104, Speaker G: Oh, yeah.
02:27:15.142 - 02:27:38.830, Speaker I: We can take a couple of questions or one question. One question. Are there some questions? No, that's fine. We can talk later. Awesome. Thanks, guys.
02:27:43.120 - 02:27:44.940, Speaker A: We need HDMI.
02:29:06.150 - 02:29:06.814, Speaker D: Internet.
02:29:06.862 - 02:29:09.858, Speaker A: No, you will need the Internet. Right?
02:29:10.024 - 02:29:13.426, Speaker D: The Internet. No, it's fine.
02:29:13.528 - 02:29:17.820, Speaker A: I'll do it. Okay. It.
02:30:36.010 - 02:30:47.046, Speaker D: Not yet. Testing, testing. Yeah, you can hear me. All right. GM, everyone. I'm flywell. I'm here to talk about WorldCoin.
02:30:47.046 - 02:31:25.286, Speaker D: Today I'm going to start talking about how WorldCoin started. So crypto is awesome. We all know that. That's why we're all here. Unfortunately, the value has been hoarded by around 2% of the population. So what we wanted to build in WorldCoin is a way to bring crypto to everyone in the world and not just this 2%. So we started with this premise of what if bitcoin started by giving one bitcoin to each person? How would things have turned out? Of course, we cannot do this right now.
02:31:25.286 - 02:32:02.114, Speaker D: So that's why we decided to create the WorldCoin Token. The WorldCoin token. It's not live yet. We're going to launch it next year. It has a limited supply of 10 billion tokens. Every person in the world will get some share for free until it runs out. Of course, the problem we immediately run into is how do we make sure each person only claims their share once? If you can claim your share 100 times, then it's no longer a fair AirDrop, and we're going to end up in the same place that we were before.
02:32:02.114 - 02:33:02.230, Speaker D: That's why we sort of run into this concept of civil attacks, and we realize it's a bigger problem than just for airdrops. And I'll talk a little bit more about that. But civil attacks is this concept that you can very easily create multiple identities that look like the real thing and then undermine whatever share mechanisms, fraud mechanisms that you have in place. So we created this protocol called World ID. So World ID and the thing that we're here to present today and the thing that you can build on is a privacy preserving proof of personhood protocol. I'll explain in a second what that means. But what we wanted to do is be able to identify a single person and be sure that it's an actual human doing some interaction.
02:33:02.230 - 02:33:47.374, Speaker D: What we ran into is we wanted to make sure that this protocol was private, inclusive, and scalable. So private, we want to make sure that no information gets leaked about a person inclusive. We want to make sure that everyone in the world can get it. And scalable, it's part of the same inclusivity mission, right? So we looked at all of these options here to see what we could do to solve the civil attack problem and actually identify single persons. And we realized none of these options filled these three requirements that we had. Email or phone is very easy to spoof. KYC is not very inclusive.
02:33:47.374 - 02:34:36.978, Speaker D: A lot of people don't have passports. Fingerprint is not scalable because there's a limit to how many unique humans you can identify with fingerprint and DNA is just very complicated and just a little bit privacy invasive. So we created this beauty called the orb. You can actually see one here live. What the orb does is it checks that you're a unique person by, first of all, checking you're a human, you're alive. It has different fraud prevention mechanisms. And then it takes a picture of your iris, extracts that entropy that lives in the iris, and uses that to ensure that you're a unique person.
02:34:36.978 - 02:35:59.120, Speaker D: And I'll talk about how the iris extraction works, but what this enables is with no images, no name, no personal information, no KYC, we can actually make sure that a human is doing something only once. But even though we are not keeping these images, we wanted to go even further to preserve privacy. So we introduce a little bit of zero knowledge proof magic to the protocol. The way it works is whenever you're using this identity, you use it through zero knowledge proofs. So even though there's no personal information tied to this concept of an identity, through zero knowledge proofs, we can be sure that you're not even tracked across actions, across applications. So this protocol enables you to say, I'm a real person, and I have never claimed WorldCoin or I have never voted this poll, or I am only creating one social network account. All of these different use cases that we realized were susceptible to civil attacks, you can prevent with a protocol like this.
02:35:59.120 - 02:36:40.998, Speaker D: This is, in a more succinct way, what the protocol does. And we realized we could take this a step further by making this protocol privacy first. Decentralized identity, all centered around a single person. It's a fully open protocol, fully open source, self custodial. It lives only on the user's phone. And this is how it looks like. So you have your application like you're doing like this, you're doing an AirDrop, and you would mount something that looks like a captcha.
02:36:40.998 - 02:37:27.638, Speaker D: The user will get QR code. They would scan it with their WorldCoin app, and they would prove they're a unique person doing something only once, completely privacy preserving. So how does it actually work from a user standpoint? They go to an orph like this. Our goal is to have them distributed all around different cities, and you get your World ID. So this World ID that you get, lives only on your phone, fully self custodial. And you can use it to continuously prove to different applications that you're doing something only once. So this is where it starts to get a little bit tricky because of the privacy preserving characteristics.
02:37:27.638 - 02:38:04.902, Speaker D: So you download the WorldCoin app. The WorldCoin app will generate a random identity with a public and private pair. And you'll show the public pair to the ORV with a QR code. The ORV will then look at you, make sure that you're human, that you're unique. And once it passes that check, the orb only access a gate. It'll add your public key to a set on chain. So as you can see, your identity is not really tied to a wallet or tied to anything.
02:38:04.902 - 02:39:04.678, Speaker D: And the set is fully public on chain because it's just a list of public keys. It means nothing. So whenever you're using it, your phone, which has a private key, will generate the zero knowledge proof that proves that you know the private key to a public key in the set without revealing which one. So you can continuously prove, hey, I'm a verified person in the verified set, but I'm not telling you who I am in terms of how you would actually do this. It does look a little bit complicated, but it's actually not. So from your application, you would integrate this in two sides in your front end, in your back end, in your front end, you would mount the widget that we saw and that will enable the user to actually generate the zero knowledge proof and send it back to you. And then you just have to verify the proof.
02:39:04.678 - 02:39:35.380, Speaker D: To verify the proof, you can either verify it on chain or you can verify it with our API. So if you verify it on chain, you will get the proof. You would execute a transaction as you would normally do. Let's say you're minting an NFT and then the transaction would be the same. It would just include this zero knowledge proof. And then on your smart contract, you would verify the proof first, mint the NFT later. So, yeah, this is what the captcha looks like.
02:39:35.380 - 02:40:20.050, Speaker D: This is how it looks like on the WorldCoin app. When the user scans the QR code, they'll tell you like, hey, this app wants to verify you for something. And when they click verify with World ID, that's when the serial knowledge proof will get generated. There's a lot of use cases that would benefit from civil attacks, protection, these are just to name a few. We have other ideas that you can look at in our documentation, but the most intuitive things is, of course, things around voting and governance. One person, one vote, fair airdrops, person bound tokens, et cetera. You can start building already on World ID worldcoin.org.
02:40:20.050 - 02:41:03.642, Speaker D: A key important distinction here is while you're developing to use the network on testing mode, you can go to the simulator that we have it's linked there, simulator Worldcoin.org, where you can actually generate random identities. That is as if you've gone to an Orph so that you can actually test multiple times. Because of course, if you're using your actual production one, you're only going to get one. The integration is super simple. You install the Widget, you load it. You're just going to need two things the action ID and the signal.
02:41:03.642 - 02:42:08.270, Speaker D: The action ID you obtain from our developer portal, very easy to generate. It's what lets us scope down so that users cannot be tracked across applications. And then the signal is a very neat property of the zero knowledge proofs that it basically adds an arbitrary message that can become part of the signature for the proof. What does this mean is, for instance, imagine you're doing an AirDrop and the user generates you a serial knowledge proof that hey, I'm a unique human, please send my tokens to this address. If I were to intercept that proof, I could change the address and then use another person's zero knowledge proof to claim the token for myself. Fortunately, if you include the address as part of the signal and someone tampers with that, that will make the proof invalid. So depending on your use case, you're going to want to use the signal for protection.
02:42:08.270 - 02:42:46.510, Speaker D: And then very important to remember the proof that you get from the Widget, you have to verify it. The front end is not a trusted environment, so you have to verify the proof in a trusted environment. That means either on a smart contract or on your back end. If you're doing on the back end, it's a very simple API request and you'll get thumbs up, thumbs down. If you're doing on a smart contract. It's also quite simple. You call our smart contract with these parameters and the smart contract will revert if it's invalid or will continue if it's valid.
02:42:46.510 - 02:43:40.578, Speaker D: But very important to verify the proof. If you just rely on the Widget, you're not adding any protection because anyone can tamper with the front end. We're on Discord if you need any help, not only during the hackathon but afterwards. And we're super open to feedback and ideas and anything that you want to come up with. We do want to give a pretty big shout out to these open source projects that enable the protocol. So Semaphore is what enables the entire zero knowledge proofs ecosystem. The set of verified identities I talked about is actually a Semaphore group hovel we initially use in the WorldCoin app and Wallet Connect.
02:43:40.578 - 02:44:25.898, Speaker D: We use to interact between the WorldCoin app and your front end applications. We have $20,000 up for graphs in prices. We have a price pool, honorable mentions, and different categories. So we encourage you to build the requirements to qualify for a price is integrated both on the front end and the back end. The backend can be smart contract or an actual backend and a meaningful proof of personhood use case. You can find more information on this on our notion, which I'll share in a second. But to sum up World ID, we're solving civil resistance at scale.
02:44:25.898 - 02:45:06.654, Speaker D: It's a privacy preserving, self custody, open source protocol. Very easy to use and implement. Of course, we have a bunch of open positions and we're always looking to work with amazing people. So if you're interested worldcoin.org, unfortunately we don't have time for Q A, but I'll be in the back and you can also come find me at the booth or you can find me on Discord. This is the main page that you can look at for any resources, any information about it, swokun.org ethindia everything I talked about is going to be there and that's it.
02:45:06.654 - 02:45:32.276, Speaker D: Thank you so much. I can review a neighbor? Yeah, no, they we basically have to.
02:45:32.378 - 02:45:33.332, Speaker A: Wrap up at six.
02:45:33.386 - 02:45:34.628, Speaker G: So it's like ten minutes if you.
02:45:34.634 - 02:45:51.240, Speaker A: Want to have Q and A. Any questions? Give me a SEC.
02:45:51.610 - 02:45:53.080, Speaker G: How do we do this?
02:45:56.970 - 02:45:59.098, Speaker D: Okay, so I need to listen to the question.
02:45:59.184 - 02:46:16.532, Speaker A: Okay, this mic is this one. All right. Hello.
02:46:16.666 - 02:46:17.350, Speaker D: Hi.
02:46:17.960 - 02:46:37.836, Speaker A: So my question was that for example, during the voting, right? So how does the world coin verify if the person has voted just once? Basically, how is WorldCoin verifying the zero knowledge proofs? Yes.
02:46:37.938 - 02:47:39.524, Speaker D: So when a person actually verifies you will get from the WorldCoin widget, you will get three things. One is a zero knowledge proof that lets you verify that everything checks out and that the user is actually registered and generated a valid ID. The other one is called a nullifier hash. So this nullifier hash is a unique user Identifier, but that's unique to your app. So that lets you, as an app make sure that that is a unique person. You can use that single ID to identify the person uniquely, but the user gets their privacy preserved because that nullifier will be different for every app they verify in. So to your specific use case, from a boating standpoint, you would get a nullifier for that person for that boat, and then you would store that nullifier in your smart contract and if you see that nullifier again, you'll reject the boat.
02:47:39.672 - 02:47:42.336, Speaker B: Okay, so all the back end is.
02:47:42.518 - 02:47:44.690, Speaker A: Being done in the smart contract itself?
02:47:45.620 - 02:47:59.216, Speaker D: Yes. You can also do it in a centralized, normal back end server, but if you're doing the both on chain, then definitely do it on the smart contract.
02:47:59.408 - 02:48:02.208, Speaker A: So you said three things. One is nullifier.
02:48:02.304 - 02:48:23.560, Speaker D: What were the other two nullifier? The zero knowledge proof that you actually need to verify. And the third one is the root of the merkel tree that was used to check the user's identity. So it's just another parameter that needs to be verified. That one you don't have to do anything with. It's just necessary for the proof.
02:48:23.720 - 02:48:24.668, Speaker A: Okay, thank you.
02:48:24.754 - 02:48:25.630, Speaker D: No problem.
02:48:30.940 - 02:48:36.190, Speaker E: Like five examples of the applications you would be most excited to see people try out building here.
02:48:37.280 - 02:48:56.904, Speaker D: Sure. Let me give you random examples that come to mind right now. Something around reputation scores would be really cool where you get the value of a person only having one reputation. So that for instance, becomes insanely valuable for negative reputation.
02:48:56.972 - 02:48:57.204, Speaker A: Right?
02:48:57.242 - 02:49:17.384, Speaker D: Because if you can accrue negative reputation, you cannot just go in and create another account, anything around governance. So applied versions of voting would be really cool. What else comes to mind?
02:49:17.502 - 02:49:19.210, Speaker E: How about like social network stuff?
02:49:20.220 - 02:50:12.844, Speaker D: I mean, definitely there's a lot of value in social networks. So for instance, we already integrated with Lens and it starts with you can get a verified batch in your profile and it'll get more value. But what's interesting if you start to think about something like Web of Trust, where users who verify and then follow other people, their humanity can flow to the other people. And then you start to create a network of actual humans because you're going to be able to identify bots a lot faster, even if not everyone's verified with WorldCoin. So something around that would be really cool. Of course, anything that you can compute some sort of human score with to rank content and things like that, that would be really cool as well.
02:50:12.962 - 02:50:13.484, Speaker A: Very cool.
02:50:13.522 - 02:50:14.110, Speaker E: Thanks.
02:50:20.810 - 02:50:29.900, Speaker A: So I have this question like isn't WorldCoin relying too much on this hardware of this? I mean, what if someone tempers with it?
02:50:31.710 - 02:51:22.506, Speaker D: Yes. So two part answer to that. So one is we are also exploring other options to not rely on the hardware, not because we think it can be tampered with, but more because we want to scale as quickly as possible and not prevent anyone who wants to sign up to be able to sign up. So the way to do that is today you have to come physically to an orb. That's the constraint. So if we enable other mechanisms that don't require you to physically go, then we'll be able to scale faster and be more inclusive in the short run. The second part of that is the hardware has a bunch of different security mechanisms to prevent tampering with.
02:51:22.506 - 02:51:49.826, Speaker D: So for instance, all identities are inserted with a secret key that lives in a secure enclave. If you try to tamper in any way, the private key gets destroyed. I cannot go into much detail on all the security mechanisms, but yeah, I think of it like as a hardware wallet. Very hard to extract the key without destroying it.
02:51:50.008 - 02:51:50.402, Speaker G: Yeah.
02:51:50.456 - 02:51:55.126, Speaker A: And one last question that is there.
02:51:55.148 - 02:51:59.782, Speaker B: Any idea of migrating to Web of Trust?
02:51:59.836 - 02:52:01.702, Speaker A: If there are, of course.
02:52:01.756 - 02:52:30.110, Speaker D: Yeah, that is something that we have definitely considered and it's still very much in the radar. I think the problem that we run into with Web of Trust is it's a very hard thing to bootstrap. Like you need a seed of trusted entities and that's what we're doing with the ORV. But we could definitely see a scenario where the ORV is enough to bootstrap this and then Web of Trust becomes more valuable.
02:52:30.930 - 02:52:32.222, Speaker A: Okay, thank you.
02:52:32.356 - 02:52:58.508, Speaker D: No problem. Final call. For questions. Any other questions? All right, awesome. Thanks everyone and see you around.
02:52:58.674 - 02:52:59.660, Speaker A: Good luck.
02:55:34.690 - 02:56:36.546, Speaker B: I'm a blockchain engineer at Biconomy and we work on the Usability side of blockchain applications. And I'm going to talk about how you can build very simplified DApps and that improves the user experience for your end users through different products. Or we'll get into it like the fee abstraction mechanisms. Or it can be like, easy onboarding and even on the security side of things. So for that we have an ultimate toolkit called Biconomy SDK. So I'll talk a bit about it in the beginning and then what I'm going to do is I'll be doing a workshop which is going from a regular DAP to adapt that is using Biconomy SDK, using some of the features like gasless or forward. So we have been into the space for like three years and we initially started with realizing the usability problems in the space.
02:56:36.546 - 02:58:01.162, Speaker B: So for example, first thing was like gasless transactions so that was the first product and we have been continuously building for builders so that you can build better applications or your users can have better experiences when they come to your platform. And there are lot of DApps and they have come to us and told us that it improved x amount of interaction or in terms of user onboarding when they integrate the solutions of Biconomy. So I'll get into the products or even maybe we can chat later in blockchain if it has to go on next rapid growth cycle. There are three things, right? Like one is scalability, one is usability and another is interoperability. In terms of scalability we have made a very good progress but there are not many DApps which are actually usable. So there is still a lot of friction in terms of number of user interactions, right? And on the interoperability side as well there are multiple chains which are siloed and then you need to bridge your funds from one chain to another to do something on another chain. So this is a typical use case where user wants to for example I have some funds or some shitcoin on, let's say avalanche and I want to go and buy an NFT on polygon.
02:58:01.162 - 02:59:06.178, Speaker B: So I need to go through this entire process like connecting the wallet and changing the RPC. If it's completely new chain to my MetaMask or whichever wallet then I need to find out the details and first transaction I'm going to do is to get some native tokens because every interaction is like this checkpoint or where you're basically like it's a highway and you're paying taxes right when we talk about gas. And you need to manage the lot of other complexities as well in terms of failing transactions or bumping up the gas price, whichever wallet you are on and that's just one of the actions which could be like ten action thing that you want to do as a user. So you go and sign approve a transaction and then once you have the token that you want, but that's still on the chain, which is let's say we started with Avalanche or Polygon and then you need to bridge it to BNB and then change the RPC again. Then you need to have the native token for that chain. And then let's say you are buying an NFT. So you do that transaction and then you stake it to get some position.
02:59:06.178 - 02:59:30.840, Speaker B: So it's a very messed up UI and it takes like about ten to 15 minutes. With Biconomy SDK you can build like one click experiences that is cross chain and even on a particular chain within like seconds. So I just want to play a video. I think that speaks better. Let me know if you guys can hear the sound. All right, thanks.
03:00:02.490 - 03:00:18.810, Speaker A: It all right.
03:00:18.880 - 03:00:22.460, Speaker B: So, so far we have gotten into why of it, right?
03:00:26.590 - 03:00:27.500, Speaker A: All right.
03:00:32.670 - 03:01:17.302, Speaker B: So now I'll come to what is Biconomy SDK. So it's basically smart contract wallets plus the infrastructure to enable all of these one click experiences which I just talked about. And it heavily utilizes account abstraction, that is EIP 4337. And then there are other mechanisms because it's a smart contract wallet, right? So you can go wild with it, like with signature verifications, different kinds of fee abstractions. So that is the idea. So first of all, account abstraction means that your account and signer is different. So you park your address somewhere else and in order to initiate transactions, there is a key signing key which you can rotate and you can have multiple party computation, a lot of things.
03:01:17.302 - 03:01:53.726, Speaker B: And what I mean by gas abstraction is that just the thing which I talked about. You do not need to hold native assets. Someone can sponsor gas fees on behalf of you in native tokens or even in ESC 20 tokens. Or if adapt does not wish to sponsor, then they can make the user pay using the assets that they are holding in their smart account. And in terms of chain abstraction, once you integrate as a DAP, let's say I'm on five different chains, you do not need to make users change RPC and everything. So that's the idea. And I'll get into more details in terms of architecture.
03:01:53.726 - 03:03:17.650, Speaker B: So it's basically, like I said, there is a relayer, there's a bundler service for account abstraction, there is indexer service, there is a backend node and there are several packages within the SDK. So you can use all of them at once or just some of them. And some of the features that are exported out is one of that is social login. So you can have like MPC support and social logins for completely new or not crypto Savvy users and just give them the EOA address or a signer because basically smart contract wallet or this whole layer zero which we have built on, it just needs a signer, right? So as long as you have a signer on top of that there is a smart contract wallet which gets pinned up and this signer will be the controller of this smart account or smart contract wallet. And whenever you want to initiate the transaction, it's always just a signature verification. So your end user just signs the message but the fee abstraction happens like within the smart contract wallet and then there is a relayer or a bundler to poke your wallet because contract accounts cannot initiate transaction on themselves. So multiple things like you may be already aware about like custom signatures schemes and there is also something called concept of modules where basically you can enable a certain module in your smart contract wallet and say that for example in Nosisfe.
03:03:17.650 - 03:04:10.240, Speaker B: So the idea comes from safe itself where you can have like daily spend limit module or you can have social recovery module, session keys, et cetera. So using this the transaction can go through certain level of different access control and that skips your original sign in. So that's the idea. I'll just quickly script through it because I want to get into the workshop mainly. So this just talks about fee abstraction like gases transactions and the amount of fees that you are going to pay by estimating yourself on MetaMask and then bumping up, going through that whole process, the relayers to this job like bumping up and choosing the optimum gas price even in case of gasless or any other case as well where user is paying. So let's get into the workshop. So what I've basically done is let me just open this app.
03:04:10.240 - 03:04:26.500, Speaker B: So there is a version which is very simple boilerplate. There are other demos which I'll link in the references at the end of the session. But basically what this does is 1 second.
03:04:27.130 - 03:04:27.880, Speaker E: Yeah.
03:04:41.420 - 03:05:29.636, Speaker B: So here it's first demonstrating the connection from externally owned account. It could be like MetaMask or any other wallet and there is a smart contract which basically lets you set a purpose. So it's just a string which you set. It can be like capture a flag kind of a thing. But in order to do that, because I wanted to showcase some batching actions as well because there are like multiple clicks, right? So in the current world I deployed a test token as well. So we are going to be playing with these two contracts. So basically when you want to set a purpose or this string on a state of the contract you need to pay at least like one token or you can pay more as well.
03:05:29.636 - 03:05:57.024, Speaker B: So that's the idea. But because you are paying this, it's just a polling mechanism, right? So contract will pull so you need to give approval first and then this code is set. So I'll open the app here, I'm logging in with my MetaMask. So this is the address, I have some matic and I have some test tokens as well. So first I'll approve the tokens. So this is my first transaction. You'll set the gas price.
03:05:57.024 - 03:06:50.532, Speaker B: Then we will wait for it to get confirmed. So once this is done, let's say one purpose is like checking out the documentation. So this is just pretty basic stuff, right? So I did two transactions. I needed to have native tokens in Matic. So I'm doing everything on Mumbai right now. Now we will start modifying this DAP by going through Biconomy documentation. So let me get into it.
03:06:50.532 - 03:07:49.128, Speaker B: Our two of the transactions got confirmed, so we can check like a different code. Okay, this one failed. So this is the main entry for the Docs. And what I'm going to use is there are several packages. I'm going to use Social login and also showcase some sort of fee abstraction where we'll be using the gasless flow by account abstraction, paymasters. So the Paymaster I'm going to be using is a verifying Paymaster. So basically, as a DAP, you register on a dashboard called Paymaster as a service where you basically can whitelist your contracts.
03:07:49.128 - 03:08:10.290, Speaker B: That okay, these are the methods which I want to sponsor or these contracts, right? And then there can be like other levels of checks as well as conditional gasless. So as a DAP, you'll need API key. So we'll get into that. First, I'll just start and start doing the changes here. I have already added some states.
03:08:16.860 - 03:08:17.610, Speaker A: It.
03:08:39.680 - 03:09:11.504, Speaker B: So here there is login section which I have left out. And there is an initialized wallet. So currently I'm initializing or in the demo. Before that, I just initialized with my EO account. And we'll be making changes here. So instead of this, we'll be using a smart contract wallet and have that context in our application to keep using smart contract wallet for the transactions and to give you the overview of this. So basically I had these two methods, right, which we just invoked.
03:09:11.504 - 03:09:44.290, Speaker B: One is approve and one is like submit this purpose. But we'll be batching it into just one transaction. And instead of paying for gas fees, someone else is sponsor it. And there can be other ways as well where you can get a fee code from the relayer which is plugged in with the SDK, right? So in that case, user base. And you can also show in the UI that okay, these are the options like x amount of USDC, y amount of USDT, whichever tokens relayer supports. So that is part of other demos as well. So I'll shortly link the video over there.
03:09:44.290 - 03:10:00.630, Speaker B: So coming back here, basically we'll be changing the way login happens. So I'm going to start with the social login package from the SDK. Let me just comment out a few more things.
03:10:22.260 - 03:10:23.170, Speaker A: All right.
03:10:24.180 - 03:10:54.790, Speaker B: So, yeah, first we need to import some packages from Bicromy SDK. But first I'll start with Social login. So for that you import Web three Auth. So I'll just do yarn and for like rest of the things I'm just going to keep following the documentation. So you get an idea like which thing goes where.
03:11:09.160 - 03:11:17.140, Speaker A: Write this here's.
03:11:26.000 - 03:12:27.930, Speaker B: So this package gives you all the types used within the SDK and main entry point or the package which is going to be used most is the smart account. So we'll go with the social login by the time I'll also install other things. Okay, so it says that you need to initialize the wallet. So I'll come here, I'll remove this stuff, not getting the UA provider and since we are on Mumbai, I'll just change the chain ID. So after this we'll set the context.
03:12:46.300 - 03:12:47.160, Speaker A: All right.
03:12:47.310 - 03:13:35.840, Speaker B: And here in login we need to show wallet. So if there is no login context then if there is no provider then basically I want to pop up the model for showing the wallet. So this basically tells you that what is the EO that you want to select? Whether it is going to be like social login or is it going to be MetaMask also because you can set up on top of MetaMask as well. So this is my login context show wallet. So I've done this part. Now the next thing is let me make sure I installed all the packages should be in my node modules already.
03:13:37.490 - 03:13:38.240, Speaker A: Yeah.
03:13:40.790 - 03:14:11.820, Speaker B: So now I'll go to this references section and we will install smart account package and then write the wallet connection. So coming back here after here we can log the EO address like what is it is going to be generated using social login or it can be like your EO address as well. Now I will just set the.
03:14:16.470 - 03:14:16.834, Speaker A: So.
03:14:16.872 - 03:15:20.354, Speaker B: We'Ll follow this connect wallet for creating an instance of a smart account and then initializing it. And if you notice this wallet provider now becomes the provider which is coming from web three auth. So for the options I think it's easier to copy from here. So what we are doing here is we are creating an instance of a smart account and I'm passing the wallet provider which we got from our current logging context. And then these are the options. Like by default SDK backend node will use the default values like in terms of supported network IDs. But you can change these values.
03:15:20.354 - 03:16:18.520, Speaker B: And for the network config if you want to use gases transaction through the paymaster dashboard then you need to provide a DAP API key. So the dashboard looks somewhat like this. You go to a DAP and you copy the API key. Currently we are only supporting testnet for gasless transactions and for when user pays any RC 20 tokens you can also do on multiple main nets. So now we have an instance of smart account and you can log the address of the smart contract wallet. Like going to be my address and let me just set it to something. All right, so we have set a wallet provider and smart account address.
03:16:18.520 - 03:18:35.936, Speaker B: Now you can also go and since there is like if you want to also check what are the transactions so far on the smart contract wallet or if you need to get the balances you can use the balances endpoint which will fetch the balance from the SDK. So this gives you you can also get like USD value across all the supported chains which you have passed or you can also get like token amounts right? So if you need to show to the user in some form of widget right? Because once you go from EOA to using a smart contract wallet that becomes your primary identity right? So all the funds like you can query like which NFTs are there, which tokens are there and once this is done so we are ready to do the transactions basically. So what I'm going to do here is let me comment out some stuff here as well. So I'll shortly get into the demo of this working and when you initialize smart account if you're using webpack greater than five then you might run into some issues so we have added proper documentation to make your way through it. So I have done with the logout now we are not going to need these things anymore so I'll just start implementing in this here where we'll do like batching of both of these transactions. So let me copy what we are doing before for approve and now we don't need the EO address anymore and we'll create transaction array. So basically we are following batching transaction docs.
03:18:35.936 - 03:19:22.496, Speaker B: From here I use the API key which is shared across DApps on testnet but you can spin one using the dashboard backend as well. Once I've done this I also need to set up some watchers. So basically once you get the transaction hash you do not need to go to any external service like block native to see what happened with the transaction on my smart contract wallet. So you can attach the listener basically using the Emitter, which is the smart account class itself in the SDK. So that goes in the login section once these stuff has been done. So you get the events like transaction hash has been generated and you also get the event when it gets mined or even when relayer resubmits a transaction and the hash gets changed.
03:19:22.528 - 03:19:22.676, Speaker A: Right.
03:19:22.698 - 03:20:11.540, Speaker B: So you get all the updates and then you can even get the received and show to the user directly what happened. And this has to be created before you send any transaction so that it starts listening, like, what's happening on this now coming back to my implementation. So I just want to create like an array. So basically, whatever you want to batch, you can just keep adding the transactions, right? Like I'm just doing very simple stuff but it could be like let's say you're doing a swap and then for that swap, you will require approval. Once you get two tokens from the swap, then you want to let's say provide liquidity on some liquidity pool and then you get an NFT. Then you want to stake that NFT or move that liquidity to some other chains. So all of this can be combined as a batch transaction.
03:20:11.540 - 03:20:52.966, Speaker B: Now I'll copy my second interaction which is setting this purpose. So I'll just take to this point. Let's push this. Okay, so now we are ready to dispatch this transaction through the relayer. So let's say response and all of these APIs are available on smart account instance. So what I'm going to do is I want to send a batch of transaction and that has to be gasless. Like there are other methods.
03:20:52.966 - 03:22:14.150, Speaker B: So if you notice here and even if you go to the documentation you get let's say send transaction is there, but you can prepare refund transaction batch which basically creates transaction payload in which the user itself will refund and no one is sponsoring for the gas fees. So for this we are going to go with this here and the array which I just created is going to be part of it. And let me comment out some other stuff which is just like it will show my EO account and my smart contract wallet account as well here. All right, and let me just replace so that everything is consistent. So now this demo gets updated and we can do several transactions, maybe using social login or even like using my MetaMask. So here I'm getting two options. Let's choose social login.
03:22:14.150 - 03:23:04.974, Speaker B: So I need to open my Gmail. So it is constructing the private key using the Web Three network. And now this is my EO address which has been just spin up like it says, a public private key pair which I'm going to use for signing. And this is my smart contract wallet address which is created by Biconomy SDK. And these wallets are counterfeitual wallet address so it does not need to be deployed. So if you check on Mumbai Explorer, it's just an account, right? So you can send funds to it. It's a contract for me because I already done some transactions.
03:23:04.974 - 03:23:42.494, Speaker B: But if it's a new user, it's just an account. You can send assets if it is supposed to pay to the relayer within the same transaction. Otherwise it just gets created as a first section of the batch which will go through here. It's just one click. So where basically this guy needs to have some tokens which we use for previous interaction. And then you just do like one click. So maybe I can do from other ways as well.
03:23:42.494 - 03:24:11.560, Speaker B: Like let me connect my MetaMask. So here my EOA becomes this guy. It already has some tokens and my smart contract wallet address also changes which has been spinned up on top of this. You can do this in browser extensions as well. A lot of tooling like MetaMask snaps provided so you can show in a widget kind of a view. Now let me check if or we can just send some tokens. Let me just check quickly.
03:24:14.170 - 03:24:14.546, Speaker A: Cool.
03:24:14.588 - 03:25:19.670, Speaker B: So I already have some Ethan tokens and minimum amount is one. So this is my fee token and this is the contract we are going to interact with directly right now. Let's come here and maybe let's say something like start integration. So in this case, this guy just needs to sign a message and then the transaction will go through on this smart account. It will go through the account abstraction entry point and it will utilize the Paymaster which is associated with this DAP API key which we just added in the smart account config. And as you can see, why I've wrote those listeners is that it is subscribing on the transaction ID we received from the relayer and you get all the updates. So we get that this transaction hash got mined.
03:25:19.670 - 03:25:28.100, Speaker B: So let's check this on Mumbai.
03:25:31.160 - 03:25:31.764, Speaker A: Cool.
03:25:31.882 - 03:26:14.316, Speaker B: So I paid two ETH India tokens before that. I did approval of two tokens and I also managed to change the state on the contract. So the set purpose is there. And now we go back to the contract, the state changes and everything is just one click and someone is sponsored for your gas fees. So you can do this for your end users or they can also pay in, ERC, 20 tokens using the account abstraction flow as well and using like there are some methods in the wallet itself which allows you to do that and anyone can. If you go through the docs, you can also plug in like your custom paymaster in the gasless section. So that's possible as well if you guys are building these kind of custom contracts.
03:26:14.316 - 03:26:48.300, Speaker B: So that was it for the demo for my site and yeah, I have just added some resources or links. So there are other examples. What we did is that one of the products is Hyphen which is a cross chain bridge. So we folk that and added the Biconomy SDK support to it. So you can go here, play with it toggle and do Gases transactions or the transaction where user pays in whichever tokens they are. Let's say providing liquidity in. Right, so that's the thing.
03:26:48.300 - 03:26:50.510, Speaker B: All right, cool. Yeah, I'm almost done.
03:26:54.580 - 03:26:54.992, Speaker A: Cool.
03:26:55.046 - 03:27:19.080, Speaker B: I think I'll open to questions for two minutes and if you guys are hacking, just have fun and check out the prizes. Using SDK, you can apply for Biconomic Track or Ethereum Foundation track and build and have fun. Do I get time for any questions? Any questions from audience?
03:27:23.050 - 03:27:26.086, Speaker A: We can take one question. Sorry, we can take one question.
03:27:26.188 - 03:27:40.960, Speaker B: Yeah, no questions. I guess not. Thanks everyone.
03:27:48.570 - 03:27:49.320, Speaker A: It.
03:31:58.310 - 03:32:09.026, Speaker E: Can you hear me? Awesome. Anyone can hear me, right? Awesome. Hey everyone. Yeah, I think my voice should be fine for everyone. Everyone should be hearing me.
03:32:09.128 - 03:32:09.442, Speaker A: Cool.
03:32:09.496 - 03:32:33.610, Speaker E: Well, my name is Fabio. I am a developer at Push Protocol. And today we're going to be talking about more of a workshop. We're going to be talking about different ways on how you can integrate communications into your own protocol, whether they are notifications or whether they are chat messages. So that's the agenda we're going to be covering today. Basically web three communication. The solution about Push Protocol, we're going to be talking about push chat and we're going to be doing demo.
03:32:33.610 - 03:33:25.898, Speaker E: Most of the workshops are going to be hands on. Well, I think for everyone that has been in Web Three for a while, it's pretty clear that one of the issues that we have in Web Three scalability privacy, one of them is communication. By communication I mean is as of today, there is no way for users to receive information to their wallet addresses based on things that happen on chain or off chain. What do I mean by this? Let's say that you are about to get liquidated on a lending protocol today. How do you get notified about this? Well, you actually don't, right? You as a user have to keep counterly checking your collateral ratio to see if you're about to get liquidated. How do you know today there is a new governance proposal? Well, you have to go on Twitter or Discord to know about this. So if you think about it, that's not how we go on our lives in Web Two, right? So the reason I'm here on this workshop is because I received a notification 30 minutes before.
03:33:25.898 - 03:33:51.742, Speaker E: So I'm preparing myself to come here whenever someone sends me an email. It's not like I'm on Gmail pressing F five all the time. I receive a notification inform that I have received an email. That's how we do in web two. In Web Three, we still don't have this. So that's where Bush protocol started. So the applications for Web Three notifications, they are pretty endless, right? So I'm very passionate about Dows.
03:33:51.742 - 03:34:35.774, Speaker E: So imagine like getting notified on your wallets, for example. Notify all participants of this dao that there is a new governance proposal. Or for example, whenever there is a new yield farm for those farmers out there, or even better, let's say that you are on an NFT marketplace, it will be super nice to notify your users whenever someone places a bid on their NFT or whenever someone outbids you. So don't keep going back to the NFT marketplace to check the status of your bid. So the solution that Push Protocol is building is an open communication layer. That means that anyone can simply tap into the network and fetch the notifications themselves. The notifications are dynamic, which means there are no restrictions on what you're going to notify your users.
03:34:35.774 - 03:35:01.606, Speaker E: You can notify a governance proposal, you can notify a live stream, you can notify a newsletter, can pretty much notify anything even you can customize how you notify the messages. There is no restriction whatsoever on what you notify your users. This solution is multi chain. As of now we are on Ethereum Polygon. Sending notifications is gasless. So you don't pay to send the notifications. Of course you send notifications via smart contracts.
03:35:01.606 - 03:35:40.070, Speaker E: You have to pay the transaction fees. But if you don't send notifications on chain notifications, it's completely free. For the protocol they send you notifications, but also for the receivers and it's also platform aggroxic delivery because you can any front end, any mobile application, anything can actually display the notifications. It's an open network. You just call a note, say, hey, give me all the notifications from this address and display to the user however you want. So Push, we have empowered over 18 million notifications. As of now we have over 70,000, even though this right size 60, we now have 70,000 different addresses that they have obtained to receive Push notifications.
03:35:40.070 - 03:36:09.358, Speaker E: And we have over 100 integrations. And as I said before, the integrations can be pretty much anything. For example, the integration for Avi that they use is completely different from, for example, for Adal or for ENS. So there is no restriction whatsoever. The notifications are going to notify your users. We just close this bridge. Well on Bogota this year on Polygon Connect, we announced a new feature from Push Protocol.
03:36:09.358 - 03:36:31.350, Speaker E: We started notifications. We have been building notifications for over two years and a now we on Bogota, we announced something called Pushchat. So this wallet, if you have an address, I have an address. Well, we can start sending messages, we can start sending a video, we can send a GIF, a sticker, a PDF, pretty much anything. So we closed this bridge. So we started with notifications. Now we are doing messaging as well.
03:36:31.350 - 03:36:53.642, Speaker E: And back there, here, that's my face. This was on stage in Polygon Connect. We also provide a feature that is currently in development. But it's push video. So now I can video call other addresses as well. And this is us. We were doing a video call on stage and yeah, let's chat.
03:36:53.642 - 03:37:01.086, Speaker E: So I have prepared a video here. It's going to be this one. I don't know if the sound is.
03:37:01.108 - 03:38:05.760, Speaker A: Going to be goodbye. It cool.
03:38:06.210 - 03:38:23.730, Speaker E: So this is about push chat. So yeah, let's get started with the demos. So first of all, if you want to send a notification so first of all, let's go to our how we have a concept of channels. Let me just log in. Switch network.
03:38:24.710 - 03:38:25.074, Speaker A: Cool.
03:38:25.112 - 03:38:48.810, Speaker E: So the way it works is if you are a protocol service adapt or anything you want to send notifications to your users, you must authenticate yourself into the protocol. We call this creating a channel. Nothing fancy, just authenticate yourself to the protocol so you can notify your users. So this as an end user, those are what the users see. We have channels. So, for example, makerdal. We have rect.
03:38:48.810 - 03:39:21.270, Speaker E: Lancevi Earnfi, Banker let's say, for example, I'm interested in receiving notifications from Pro together. Me, as an end user, all I have to do is click opt in, sign a message. Then what happens is I give consent into put together to send me notifications. People cannot send you notifications. You as end user have to give consent. So in the hackathons, people they are building, if you want to send notifications, the first step is you create a channel push protocol. So for this, you go to our staging push.
03:39:21.270 - 03:39:42.410, Speaker E: That's our testnet, URL So we are on Gurley. We are also on Mumbai for testnets. I have previously created a channel. So that's the channel that I have. So that's the UI when you create a channel, so that's the UI that you have. Let me switch wallets here. Just refresh.
03:39:42.410 - 03:40:10.946, Speaker E: Cool. So once your channel is created, now I can notify my users. So we're going to go over different ways of how we can do this. The first step is we can send manual notifications. For example, you can send a newsletter to your users. Instead of sending a newsletter to email, you can send any newsletter to addresses. There are three types of notifications broadcast, which means notify all the subscribers of my channel target, notify this address subset, notify an array of addresses.
03:40:10.946 - 03:40:37.150, Speaker E: On this example, let's send the broadcast notification. Let's add a title, Hello World. And the message is going to be, hey, this is a special way of sending. So we add here a bold on the text. Hey, happy to be here. Let's add as well a media. So let me go to YouTube.
03:40:37.150 - 03:41:11.026, Speaker E: Let me take this ice cream video here. Just copy close here and just paste here. So just add a video on my notification. Once I click send demo notifications, it's going to be broadcasted to all subscribers of my channel. But let me do something here. So as an end user on the left here, this is the vision of the protocol about send a notification on the right, it's going to be the vision of a user that wants to receive the notification from your channel. So for this, let me create a brand new wallet just as a brand new user.
03:41:11.026 - 03:41:26.800, Speaker E: Just to simulate a brand new user, let me just connect to my DAP. So first, as I said, I have to opt into my channel. So I come here to my channel. How is it called? My channel is called Demo channel. So let's come here, demo channel. Here it is. I just opt in.
03:41:27.410 - 03:41:27.870, Speaker A: Okay.
03:41:27.940 - 03:41:49.654, Speaker E: So I will now receive notifications. So if I come here to the left, send notification. I just signed a message free. I sent notification and we got here too. So we got here on the left here. Because whenever we send a notification to everyone, this everyone includes yourself. And here on the left, on the right, we just saw the notification that I received and it's here.
03:41:49.654 - 03:42:05.130, Speaker E: My notification. I also got on my phone as well because I have the application installed. We also get here on the browser extension. So if I just copy my address here. Come here. Switch network verify.
03:42:06.590 - 03:42:07.340, Speaker A: Cool.
03:42:08.270 - 03:42:13.786, Speaker E: Notification is here. Also here that was playing around. We have a notification from Lo Fi Girl that I was playing around.
03:42:13.888 - 03:42:14.106, Speaker A: Cool.
03:42:14.128 - 03:42:43.062, Speaker E: I received my notification. Very nice. Let's go to the next step. So, other way of sending a notification is you can send notification using SDK and usually for hackathons, that's the way that I see the most of people integrating because it actually is very easy. It's just one functional call. That's pretty much it. So for this so I have the code here sending notification, SDK and this, all I have to do is just call here.
03:42:43.062 - 03:43:18.500, Speaker E: So most importantly, before I just explain what the code is doing for this workshop, all the codes that I'm showing, I just copy and paste from the documentation. Literally I did no change whatsoever, just copied from here. So if you go to Docs push, then developers send the notifications. Very interesting. Send notification using the push SDK. So that's literally I've just copied this code and paste it here. So all this code is doing is I just import the push SDK ether is because I need to sign a message and am because I'm adding my private key here.
03:43:18.500 - 03:43:41.126, Speaker E: We just need three things to send a notification. Actually two, but in this example it's three. I need the private key of the channel. What does it mean? It's the private key of the wallet that you created the channel. So it's going to be this private key here. I need the receiver in this case can be optional. If I say hey, notify everyone the receiver is optional, but in this case I'm saying hey, notify this address here.
03:43:41.126 - 03:43:58.826, Speaker E: And the channel address is going to be this address here. I just copy and paste here. So that's the address that is here. As you can see, this is following the type ten format, which is EIP five, five, column five. That's the chain ID. And this is the address. Because we are MultiChain and as of now we are only on EVM chains.
03:43:58.826 - 03:44:21.382, Speaker E: But soon we're going to be across non EVM chains as well. So that's a way to identify which chain you are. The only change that I need to change here is the receiver. Because I create a brand new wallet and the receiver is going to be this guy here, just come here and that should be it. And this code here just copy from the documentation. It's going to be a target notification. This is the notification title and body.
03:44:21.382 - 03:45:00.894, Speaker E: And that's actually the payload from the documentation from the notification. So if I go to send a notification, I run the code. I got here the response from the SDK and if I come here, the notification should be here and it's here. You got a notification here. I have to refresh here, but I should get from here and also I'll get on my mobile phone. If you install the mobile application, cool. We have send notifications manually using the SDK.
03:45:00.894 - 03:45:36.974, Speaker E: We can also send on chain notifications using smart contracts. To send notifications using smart contract, you just do a contract call, that's all. I have a contract that I have deployed here earlier. I hope this session is still open because I deployed this yesterday. So what this code is doing is, as I said before, the code that I got here from sending notification, I got from the documentation docs push sending notification. We're interested in using smart contract. So I just copy this and I paste it here.
03:45:36.974 - 03:46:07.190, Speaker E: That's what I have here. So what this contract is doing is it's just a ERC 20 token. When I deploy this token, I mint 1000 tokens to myself and all I'm doing is just overriding the transfer function. And when the transfer is successful, then I will notify the receiver of the token. So I'm going to transfer 100 tokens. These push tokens, my custom tokens that are created here. And when the user receives the tokens, the user will also receive a notification.
03:46:07.190 - 03:46:54.470, Speaker E: So for this, the contract is already deployed. So what I have to do so once you deploy the contract on a polygon or ethereum, you just have to do one more step. This contract is already deployed, so I'm not going to redeploy it again just for the sake of time. Once you deploy the smart contract, you just have to do one last step, which is the smart contract will be sending notifications on my behalf, right? So all I have to do is I have to give consent for the smart contract to send on notifications. How do I do this? When you deploy the contract, you just copy the contract address. You go to your channel UI that you created, come here, add delegate and then you add your contract here. Once this transaction is approved, then the contract can send notifications on your behalf.
03:46:54.470 - 03:47:14.246, Speaker E: But I have done this already. So that's the contract. I added this yesterday. So the contract has been deployed and also the contract has been added here. I gave consent to the contract send notifications. So actually, we can now send the notifications. So for this, we are overriding the transfer function.
03:47:14.246 - 03:47:43.970, Speaker E: So that's what we're going to be calling. So we're going to be calling the transfer function here. We're going to be transferring two, three, four tokens. Because why not? And we're going to be copying this address. So I'm going to be sending two, three, four tokens to this address. And this address will not only receive the tokens, but also receive the notification. Now I just confirm this and once the transaction is validated let's see here.
03:47:43.970 - 03:48:05.270, Speaker E: Yeah. Mongoli but it can also be on polygon and it's in taxi now.
03:48:08.600 - 03:48:09.060, Speaker A: Okay.
03:48:09.130 - 03:48:19.770, Speaker E: The transaction was sent. So if I come back here, if I refresh, then I should see the notification here. Yeah, it's not here. Let me just refresh here.
03:48:23.660 - 03:48:24.312, Speaker A: Okay. Yeah.
03:48:24.366 - 03:48:36.648, Speaker E: For a reason, the notification is not here, but that's fine. So that's the idea. So you can do a smart contract call, basically send all chain notification. You just do a functional call to the contract. Cool. So those are three ways you can send notifications. There are more.
03:48:36.648 - 03:49:11.428, Speaker E: So for the sake of time, I cannot go in every single ways of sending notification, but it's worth mentioning them. So there is one that I'm super passionate about. If you go to Docs, push developer Docs, sending notifications subgraphs, so you can send notifications from subgraphs. So you don't need to change any logic of your current subgraph. We have one helper function that import into our subgraph, and the subgraph starts sending notifications and it's also free. You don't pay to send the notifications. So, yeah, the Graph, a lot of people know the graph.
03:49:11.428 - 03:49:42.640, Speaker E: A lot of people have created subgraphs before. So in this hackathon you're creating subgraphs. You can extend this to also add notifications. Just one helper function. Don't need to change any of your logic. This way of saying notification I find super interesting. There is one more thing that I like to mention is of course we can send the notification ourselves but a lot of people for some use cases people not only like to receive the notification but most importantly whenever there is a notification.
03:49:42.640 - 03:50:20.112, Speaker E: What we can do, we can call your API, say, hey, this address here received this notification and we call your API. Why would you want this? For example, if you want to build an email bot, a discord bot, or a telegram bot, you just do your server, deploy the code, send to me or to any of the push crew team, the URL of your server. We whitelist this in our nodes. So whenever there is a new notification, we're going to call your API and then you can start building automations and things on top of this. This is called we use AWS SNS for this. And yeah, this is useful for as well. If you have your own mobile application, then you can send notifications yourself.
03:50:20.112 - 03:50:45.076, Speaker E: So you have 100% control of what you notify your users. We just call your API and you decide whether you want to notify your users or not on your own mobile application. The last thing that I'd like to show you guys is for chat if you come here. So we're going to be adding chat for adapt here. So if you come here, push, docs. Push. Pushchat for webtree.
03:50:45.076 - 03:51:16.400, Speaker E: This is a brief introduction on Pushchat, how it works, the encryption verification proofs, and yeah, an overview of how pushchat works. But what we're interested in here is integrating pushchat, not this. We're actually interested in this one here. So this is how we integrate pushchat. So TLDR is just one react component. That's pretty much it. So I have a code here, as I said, for here, just copied from the documentation push chat.
03:51:16.400 - 03:51:52.772, Speaker E: This app here. I just did an NPX create react app. I created this sample create react app. And I just installed the Wagme library and I installed the push protocol UI web. I just used the Wagme library because I need the use account hook. So what all this application is doing here? Yeah, this is the default that comes in. I just added the chat component here that we provide from the push SDK.
03:51:52.936 - 03:51:54.210, Speaker G: So we just need.
03:51:56.260 - 03:51:59.760, Speaker E: One more. Let me just copy from here. Copy.
03:52:02.340 - 03:52:02.752, Speaker A: Okay.
03:52:02.806 - 03:52:08.550, Speaker E: So we just need four information. So it's going to be here, it's going to be the address.
03:52:10.360 - 03:52:10.772, Speaker A: Okay.
03:52:10.826 - 03:52:33.176, Speaker E: So we just need four things. So the first one is the account. So where the messages are going from. So the notifications are going from the connected address on the DAP. This, the support address is the receiver of the notification of the chat messages. This can be dynamic depending on the application you're building on this case. I just hardly coded the receiver, the API key.
03:52:33.176 - 03:52:53.520, Speaker E: As of now, you need the API key to send the messages. If you need, just let me know. But soon we're going to remove this very soon. So as of now, we need this and the environment, which is this. We're on staging on the testnet environment. So for this, let me come back here. Push chat just NMPM starts.
03:52:53.520 - 03:53:25.120, Speaker E: So that's the default UI. And we see here on the bottom right corner the chat button. I just click here connect. Let me just decrypt because I'm decrypting the messages and here is the UI. Hi there. Nice to meet you. Hey.
03:53:28.420 - 03:53:29.488, Speaker A: Yeah, you're here.
03:53:29.574 - 03:53:57.900, Speaker E: The message has been sent. Also I'd like to show you guys the last thing which is I send the messages here. So the messages belong to you, to the users. So if come here to chat, that's the chat UI. And look, the messages that I just sent there, they're going to be appear here, they're here. So if you go like you could go to different DApps and you always see the chat messages with you. The chat messages go with you to different DAPs that you use.
03:53:57.900 - 03:54:23.284, Speaker E: So the messages that are sent there, they're here. I can send gifs videos, anything, memes emojis, anything you want to send. So yeah, also you don't need to use our react components. If you want to build a discord like application, you can use the rest APIs yourself and build the UI yourself. By no means you need to use our react components. Just an easier way to add it. But if you want to build your own UI, by all means you can do this.
03:54:23.284 - 03:54:52.646, Speaker E: We provide an SDK. It's the rest API SDK. You can build your own telegram or Discord for webtree. And that's all that I had. So as of now, it's the push chat. This is an alpha, but just for a brief time after, we're going to open this for everyone. So as of now, if you want to start chatting to any wallet on Ethereum or chatting or to any wallet on Polygon, just come talk to us.
03:54:52.646 - 03:55:19.006, Speaker E: We have poaps and poaps that give access to the push chat. We have $20,000 for hackers that are integrating push, whether notifications or chat on this hackathon. And we also have $1 million that we fund projects that want to keep building push. And that's all that I have. Those are our discord community. It's super, super active. And we also have a live workshop that we did a couple of months back.
03:55:19.006 - 03:55:23.760, Speaker E: Different ways of how integrate push and that's all that I have. Guys, thank you so much.
03:55:43.100 - 03:55:46.810, Speaker A: Please leave the headphones after you use at the very same place.
03:55:51.100 - 03:55:52.810, Speaker E: Yes, I saw.
03:55:57.660 - 03:55:58.810, Speaker A: He'll take this.
03:55:59.500 - 03:56:00.250, Speaker E: Yeah.
03:56:22.550 - 03:56:27.540, Speaker F: To land.
03:56:29.510 - 03:56:30.900, Speaker B: Can I plug the kill.
03:57:42.750 - 03:58:11.890, Speaker F: This light? It's right on my face. Can't even see it. Okay. Anyway, we gotta wait for some just right on the goddamn face. I don't see anyone. Do you see anyone?
03:58:12.040 - 03:58:12.738, Speaker G: Sorry?
03:58:12.904 - 03:58:52.500, Speaker F: Do you see anyone? Everyone just left. So we'll have to either wait they are all coming in. They are tired from the previous hospital. That's not a very good feeling, but whatever. I'm starting the timer starting? Yeah, I think so. Are we good to go? We can walk. Can you hear me?
03:58:53.430 - 03:58:54.130, Speaker E: Yeah.
03:58:54.280 - 03:59:08.538, Speaker F: Okay. I think he's going to announce. No, he is going to announce. Can you hear us?
03:59:08.624 - 03:59:09.306, Speaker E: Yeah.
03:59:09.488 - 03:59:15.214, Speaker F: Do you want to test yours? Am I audible? Is it on? It's on.
03:59:15.252 - 03:59:15.742, Speaker A: Right? Yeah.
03:59:15.796 - 03:59:35.540, Speaker F: Thanks. Maybe be on that side so there's no feedback. Yeah. And then I'll call you. Hi, everyone. My name is Faroop and I'm one of the co founders of Pauloom. Very excited to be here.
03:59:35.540 - 04:00:13.642, Speaker F: So Anumit is my co founder. We have both been in the web three space for about five years. We started with building a developer tool called Blockvigil and actually ETH india was the last ethnia, I think, 2019, when we first launched it. And since then we have gone on to build RPCs for Maddox before they were polygon. And it's kind of the idea of Paulum also came along there. So we saw a lot of developers and especially the larger DApps and companies using the RPC, a lot of in house indexing and trying to extract that data on chain and consume it, whether it's for their own use or whether it was for developers. And there was no transparency.
04:00:13.642 - 04:00:45.974, Speaker F: That was also very centralized. Right. So we started thinking about how can we solve this problem? And so that's where the power loom idea sort of kicked off. It's kind of funny because we actually presented one of the first use cases at Global Hackathon. So it's very, very dear to us to be able to do this also sponsor for the very first time open up our APIs to you guys. So nice to have you all here. So I'm going to just maybe quickly walk through about what Paulum does, talk about the bounties and then Anumit, my co founder, is going to take over, show you maybe how to use some of the APIs.
04:00:45.974 - 04:01:43.450, Speaker F: So we also have a bit of we are open sourcing something today that's probably our first major product and he might give a little bit of an overview. If you guys want to get your hands dirty, that's one of the things you could probably attempt for this hackathon. Okay, so Pauloom aggregates data from on chain sources and turns it into snapshots that can be consumed and be stored in a way that's already decentralized from day one, right? So our larger goal is to turn it into a network of its own where developers like you could propose data sets, people could snapshot it, or you could also be a snapshot of your own and in the end, the network could incentivize people who want to either consume or even take part in the network. So to just showcase what the current stage of our protocol does, we built this use case called Pooler. And that is actually going to be the focus for what we are doing at this hackathon as well. So Pooler is based off unisoft v two smart contracts. We are also supporting V three.
04:01:43.450 - 04:02:15.094, Speaker F: But for today's use case, we are just going to focus on V two. So the idea is that I'm just going to show you one of these front end systems. You can actually check out this code. Anwentra will probably walk you through it. So if you've tried DEXes, like Uniswap, like Sushi Swap, Quick Swap on all these EVM chains must have noticed that they all have like an analytics tool, right? So because you have all these markets now, all of this data is on chain as an end user or as a trader or as a developer who wants to build on it. So it's very complex. Right? So we have sort of shown how protocol works.
04:02:15.094 - 04:03:00.470, Speaker F: So as you can see here, we are sort of snapshotting the data for all about 180 pairs or so. Animat like for different ETH and other tokens. And we snapshot their data, aggregate their data and which is what you see here as liquidity volume fees. So you can also check that it's actually not, I mean, hopefully the WiFi works, but apart from that, you can look at it if this same data set is being stored on what we call hot storage. So we use IPFS because that is already a decentralized storage mechanism for people to pull in. So if you actually run an IPFS node, you can pull this exact same CID as well. So anyway, I'll let it not worry about the WiFi right now and we store the proof on a chain right now just to show that when the snapshot was taken place.
04:03:00.470 - 04:03:18.534, Speaker F: So this you can check it out from our website. So let me quickly walk you through. Let's see. After Pooler. Okay, so let's go through maybe the bounties that we are offering. This is actually the first time we are doing this as well. So our goal is to provide about $10,000 in total bounties.
04:03:18.534 - 04:03:51.286, Speaker F: So first price 4002nd, price 3000, and the third price being 2000. But if you want to allocate an additional amount for anyone who's willing to attempt, right? Because also we recognize it's the first time we are presenting to the developer audience. So if you're able to even use this in your existing project, we would love to help you out. And if you really are keen on building, taking that open source code base and it's going to walk you through more in detail. So we will help you and give you a grant after this hackathon as well. So don't think that this is the end of the runway. Okay.
04:03:51.286 - 04:04:38.082, Speaker F: So there are two ways to do this. So I'll just very quickly go over it. So one is we have turned what I've shown you as the Pooler use case and we have given out some centralized APIs so that it's very easy for you guys to consume it for the hackathon case. So you essentially look at the API docs. Anumath will walk you through this as well, get an API key, we have built a simple dashboard for you guys and then come and try out one of these three ideas. So these are just references, you don't have to work on these three different ideas, right? So we are just suggesting that this is few things you could build or if you are someone who knows how to write hardcore code, you want to go into the low level stuff, check out what Pooler does and maybe build your own use case on top of our protocol. So we are opening that up as well.
04:04:38.082 - 04:05:07.360, Speaker F: So we recognize the snapshotting process might be a lot more complex. So we're actually providing a hosted instance so you can just play around with the pool of code base. So anyway, Anwit is going to probably go more in detail and yeah, I think in terms of the URL, it's Paulom IO ETH India 22. That should take you to this notion page. And if not, you guys can probably go through your Defolia and ETH global prices list. So this link is there as well. Okay, anumath, over to you.
04:05:07.360 - 04:05:18.610, Speaker F: Yeah. All right. You want to start with this one? Sure. Okay. I'm not sure how loud I should talk. Is this like fine? Never. Okay, fine.
04:05:18.610 - 04:05:59.920, Speaker F: All right. So, yes, speaking of the hackathon topics, right, there are a couple of categories where we have broadly divided this. So, one is like you use the kind of pre rendered API endpoints that we have for Uniswap version two data along with a couple of other protocols. What you need to do right now is before you go into these integration ideas, I want you to take a look at the API Docs. So, where do you find the API Docs? Is you just scroll up over here and you'll find the API docs over here. Right over here. So I go over there.
04:05:59.920 - 04:06:13.602, Speaker F: There is the first one. It's all right. You don't worry about it. So, yeah, one of the things that you first need to do is you got to get API key. Right. This is the very first step. Obviously.
04:06:13.602 - 04:06:41.978, Speaker F: I'll come to the Postman collection after this. You have a dashboard that we are doing like a self serve. You go register, you get an API key. I hope that's visible over there. So this is the API key that you are going to use to interact with the endpoints, including in this Postman collection. Right. So these Postman Collection APIs, they specifically refer to the first category of integration ideas.
04:06:41.978 - 04:07:05.522, Speaker F: Let me quickly load those up. I don't know what is up with the sure. So these are the ones. These are like D five data hacks. So some things that you can build that you already have data on top of. Unisoft v two protocols, analytical tool, LP, API comparison. So I would not go so much deep into it.
04:07:05.522 - 04:07:35.934, Speaker F: These are very well documented by one of our team members who is a D Five specialist. So he has given you a good resource to get started with, good architecture that you can always refer. So, my point here is to kind of show you the JSON responses from the APIs. I'll go straight into it so that you can take a look at what these data points actually serve. Right. And the ideas. Then you can go into the examples that we have compiled it for you to get started with.
04:07:35.934 - 04:08:06.098, Speaker F: So, let me just shift to postman quickly. How is the display coming? Okay, awesome. There are a few important endpoints. Like what you can see over here is the Postman collection. It already has placeholders where the base URL is set to. One of those instances that we have included in the API docs and a token contract address. For example, like what is a token contract address? In Uniswap version two, like there are ERC 20 contracts.
04:08:06.098 - 04:08:35.118, Speaker F: They come together to form a certain pair contract address. So this is the individual token contract address. ERC 20. As you can see that it comes with all the information already attached to it. Right. So this is where things like building API, token trackers, liquidity trackers becomes really easy. Now, if I go over here, this is something that is known as the daily stats sort of thing.
04:08:35.118 - 04:09:17.214, Speaker F: So, as you can see this is a very short endpoint. It gives you some idea of the trade volume over 24 hours. And when we say previous value, if you read through a little bit of our documentation, you'll see that we do a snapshot based thing. Like, even what you're seeing as a trade volume of 24 hours, we always take a snapshot of where the last value was so that we can give you what exactly was the change percentage if I go to the next one? This is possibly one of the most important endpoints. This is the biggest summary endpoint that you will get. It's like close to 185 pairs. I guess that yeah.
04:09:17.214 - 04:09:48.786, Speaker F: Thanks for zooming in. Just can you stretch that up a bit? Just zoom it out. Zoom out. No, it's not stretching. All right. Regardless, what I'm looking at is like a JSON object of 185 pair contract addresses with their liquidity, their trade volumes over 24 hours, over seven days. And then there are some Ipfscids associated with these data sets.
04:09:48.786 - 04:10:49.354, Speaker F: So it's not like you always have to rely on constantly calling the V two pair. So you can build this into if you're building a front end, right. You can have these responses cached. You can use some IPFS helper libraries, right, which speeds up the fetches of these data sets, makes your dashboard or whatever tool you're building, the rendering of it, it becomes much, much easier. Right? So I could walk you through quite a few things, but here are the main points of using these data points is that you have access to a history of changes. That is what I'm trying to showcase to you over here that when you start querying these endpoints, what you start seeing is a change of snapshots. Like, as you can see that over here, when I'm querying something called V two pairs, recent event logs, right? Like, okay, what has been the swap event? What has been the Mint event? Right.
04:10:49.354 - 04:11:20.086, Speaker F: You get a JSON object like this. You run a filter over it on that event key, right. So you get a data set that has already been recorded, how it has changed over time, and you can start filtering based on basically your needs. If you just want to show Mint events, you could just go for it on this endpoint and yeah, definitely. There's the summary data point over here where you just pass like, a very specific pair contract address.
04:11:20.188 - 04:11:20.840, Speaker A: Right?
04:11:21.210 - 04:11:52.842, Speaker F: All right. But most importantly, I really like the third idea over here and the protocol hacks. I would really appreciate if someone picks up the number three or the one after protocol hacks. This is where you will see that we are already kind of giving you a centrally hosted sort of pooler code that you can see that's running on these endpoints that we showed you. Right. Unisoft v two overview. Like, you see this over here? This is the code that's already.
04:11:52.842 - 04:12:26.454, Speaker F: Open sourced. And if you just go over here, you can see the entire architecture set up. How do you hack into the Pooler code base? It's all available over here. And most importantly, the part about maintaining snapshots, having the changes tracked across time, that is already taken care of. You just have to enter this one simple settings key. That should take care of everything. Right? So it's the same API key that I have on my self serve dashboard.
04:12:26.454 - 04:12:56.198, Speaker F: That is enough for me to get started. Right over here, this API key. So when I take a look over here, this is the API key. This also will help you in hacking into the Pooler code base. What we're looking for is that we already have certain data points over unisops V two style AMM DEXes that are being served. We want something else other than this. That would be the best thing that could come out of this.
04:12:56.198 - 04:13:38.606, Speaker F: Or you could come up with a new snapshot service altogether. Like there were people asking about Curve finance or other protocols, compound RV. You could pick anything that you would like to hack on and follow what we have in the README as a proper architecture. So you have a full overview along with architectural documentation and code references which will take you to the right place within the code where things are working. Right, I think this is no, it's pointing to the internal repo. We'll have to edit that. Okay, we will fix the links.
04:13:38.606 - 04:13:50.840, Speaker F: That's not a cause of worry. But the rest of the code is already available. Regardless, the repo is open sourced. We will fix the links. Come down. Sorry, I wanted to show the white.
04:13:53.290 - 04:13:53.702, Speaker A: Paper.
04:13:53.756 - 04:14:00.454, Speaker F: No, so there's also this if you really want to maybe after the hackathon.
04:14:00.502 - 04:14:00.666, Speaker E: Right?
04:14:00.688 - 04:14:35.310, Speaker F: So you could go through the white paper. So there's this reference. It's available on our homepage as well. So this really goes into what is Pauloom aiming to do, where are we at today, how did we get here and what is Pooler being one of the examples? And hopefully someone in this audience can probably build our next use case. Anyway, once the WiFi gets fixed, that's the way to go about it. All right, so let's go back to the I was thinking let's maybe go through the Bounties again and just talk about yeah, sure. Kind of reiterating.
04:14:35.310 - 04:15:05.366, Speaker F: So I think I mentioned in the beginning, so we are giving away $10,000 in bounty. So this is just a rough variation of how we are trying to divide it. But it will be completely up to you if you have more people do a fantastic job. We are happy to even give a grant after the hackathon. So don't worry about this in terms of effort being given. And even if you're just a completely new developer, I love to mentor different hackathons. Like, I'm actually not based out of India, so I usually travel for many of these hackathons.
04:15:05.366 - 04:15:29.174, Speaker F: So I've met a lot of people. So if you're one of those so don't worry about it. Don't get overwhelmed by what we sort of went through. So even if you're able to play around with the APIs and sort of build something very simple, we would be happy to give you small. So that's what we have set up as a common price pool. So as long as you successfully integrate even a single API endpoint, we're happy to give you a price for that. And for those who want to challenge yourself, we have the categories here.
04:15:29.174 - 04:15:40.250, Speaker F: I'm really looking forward to the protocol acts like people coming up with I think we can open up for questions if people have yeah, for sure. I wonder if you have ten minutes for that. Let's leave some time for that. Yeah, we have some time.
04:15:40.400 - 04:15:41.100, Speaker E: Okay.
04:15:41.470 - 04:16:04.826, Speaker F: Is there a mic we can pass it on for the question? I'm not sure if there are questions. No, I don't think I actually can't hear, but let's see. Eyes are closed. Okay. Not seeing any questions. No questions. If we don't have any, we can go through the integration ideas.
04:16:04.826 - 04:16:24.150, Speaker F: Maybe a little more if you want to show, like, hey, to inspire people. We have some about 510 minutes. Are there any questions? Just maybe I can't see actually so clear, even I can't lights blocking me. No. Okay. So we'll just go through maybe some of these integration ideas. Did you cover the first one? I think you covered the I covered the first.
04:16:24.220 - 04:16:25.720, Speaker G: Let's go through this one.
04:16:28.090 - 04:16:43.870, Speaker F: All right. One of the things that I don't know, if you notice that we have three different endpoints open that are being snapshotted for you. Right. But an example, the endpoints. You want to open the endpoints. Hold on. So if you go back to the main page right.
04:16:43.870 - 04:16:48.750, Speaker F: Like, let's show you the endpoints that we have opened for you. The docs.
04:16:52.050 - 04:16:53.040, Speaker I: Come down.
04:16:54.770 - 04:17:29.754, Speaker F: These ones. So the postman collection is already built for you to place this in. What this will help you with is when you actually end into this LP APY idea. If you end up taking this up, the idea is to use these three different API endpoints that we already offer you use that, come up with certain sort of comparison. See what you have from the last 24 hours, fees that are generated. Right. And usually this is the formula used.
04:17:29.754 - 04:17:52.290, Speaker F: If you're not familiar with DFI, do not worry about it. We do have people who are pretty experienced in DFI and tokenomics. You can always ask them. And we will make sure that even if you don't know much about DeFi, you can build out the data points that can come up with a unique use case. Right. The idea is to also learn something while you're at it. So it's not just about code.
04:17:52.290 - 04:18:30.526, Speaker F: You get to learn a little bit about finance also, right? It's a thing that you should learn regardless. Right. So the API one I like, but also one of my most favorite ideas happens to be the Dex aggregator over here. So here you have the same three different APIs that you have, right? Like uniswap SushiSwap and Quickswap APIs. Right? And this becomes a place where you have the current price of the token fetched from different DEXes. Right. Why would you think you do that? There is something that I don't know if you've heard.
04:18:30.526 - 04:19:05.530, Speaker F: There's something called arbitrage, right? Like, how would you use this for arbitrage? Right. If you do not know these terms? It's really a good study in just understanding finance and game theory itself. So I would highly suggest, like, the dex aggregator is a very good place to start learning about it. There are a lot of good YouTube talks on these financial topics. You can definitely go check them out. So, yeah, we have once more to reiterate, three endpoints that are served for you. Right? They're Quick swap, soshi swap and unisoft v two.
04:19:05.530 - 04:19:30.914, Speaker F: Right? Do go ahead, do check them out. I'm just showing them a front end that shows all these things. But you will be using the API. These are the front ends that are using the same APIs that are included in the postman collection. So you can see the possibilities are quite a few. You can build your front ends, you can build insights, you can build report tools. Just go as creative as you want to.
04:19:30.914 - 04:20:00.074, Speaker F: Right. You have all sorts of data points that are available to you. It's a good place to start learning all about decentralized finance, how data moves across blockchain, learning how to build data generation tools, insights, reports, et cetera. So we'll also be on Discord if you guys yeah, we are on Discord, right? So the team is there. So we have a booth right in the middle of it. So if you see between, I think, Nosusafe and Etherspot or one of the teams. So look for us.
04:20:00.074 - 04:20:23.138, Speaker F: Come and ask questions if you want to ask in person. So if you don't see us there at the booth, then we'll be on the sponsor Hyphen Powerloom Discord on your ETH Global Discord. Right? So go check it out and yeah, I think that's about it. If there's any questions, we can go over it. Otherwise we should be good to go. So if you have trouble setting up the hacker dashboard or something, it should be pretty straightforward. You just sign in with your email.
04:20:23.138 - 04:20:45.820, Speaker F: It should give you the API key. Anything you wanted to go over the code maybe? No, it would be good to have some feedback from the otherwise we should listeners. I'm not sure who's having a question. Cool. All right, then. Let's wrap it up. Cool.
04:20:45.820 - 04:20:56.590, Speaker F: I guess since there are no questions, we have gone over kind of the open integration ideas and protocol hacks do go through it. We'll be waiting to hear from you.
04:20:56.660 - 04:20:58.254, Speaker E: Yeah, awesome. Thanks guys.
04:20:58.372 - 04:20:59.630, Speaker F: Thank you. Hacking.
04:25:51.100 - 04:25:52.570, Speaker C: Can people hear me?
04:25:53.020 - 04:26:39.200, Speaker A: Yeah. Okay, it should I get started?
04:27:06.840 - 04:27:28.600, Speaker C: I'll just give folks like another minute and then I'll start. Okay.
04:27:33.210 - 04:27:33.960, Speaker A: Cool.
04:27:34.330 - 04:28:05.182, Speaker C: Hey, everyone, welcome to my workshop building with Polygon ID API. What we're going to be doing today is still focusing a lot on the full kind of like full stack flow of how you would build with Polygon ID, but introducing the concept of also building with the API. So. Hi. I'm Rahat. I'm the lead developer relations engineer over at Polygon. Previously I've been a frontend engineer as well as a solidity engineer, indie hacker, web three enthusiast.
04:28:05.182 - 04:28:37.482, Speaker C: I've done a few of my own startups, which have all failed. So I can't tell you how to succeed on that side of things, but I can tell you what not to do and maybe that'll take you part of the way there. These are just some places you can find me. I'm most active on Twitter, LinkedIn, I guess. And GitHub is where you can find some of the code examples that we'll be going through and I'll also link to that later on as well. But first, let's play a game. This image that you see for here is a claim.
04:28:37.482 - 04:29:00.450, Speaker C: The claim is that I am a pixelated punk. So can you all verify? Am I a pixelated punk? Are these two images the same, yes or no? Yes. No. So the correct answer is yes. So corporate needs you to find the difference between these two pictures. There is no difference.
04:29:00.520 - 04:29:01.410, Speaker A: It's the same.
04:29:01.560 - 04:29:43.106, Speaker C: That's what we're going to say for now. But essentially what we just did was you just participated in what's sort of like an IRL version of Polygon ID. There is first what's called an issuer, who is issuing some type of claim, some type of information about you. You're holding that information in some capacity and then some type of Verifier is verifying if that claim is true or not. And we'll break that down a little bit further. But what exactly is polygon ID? So Polygon ID is a blockchain native identity system with programmable privacy. What does that mean? So a little bit of what I just kind of explained was called a triangle of trust.
04:29:43.106 - 04:30:21.566, Speaker C: You can program different parts of the triangle of trust to share specific things about yourself on a need to know basis. Right? We're going to be utilizing and taking advantage of ZK proofs to only share information that an end sort of corporation or Verifier needs to know. So this is just a little diagram of that triangle of trust. So this initial claim or this NFT was created by Pixel Portraits. Shout out to Pixel Portraits, by the way. They're awesome. And that NFT is owned by me.
04:30:21.566 - 04:31:12.734, Speaker C: You can go to my wallet and see it or whatever. And what you all did was verify that that is indeed me. It's like the PFP that I use on Twitter. It's PFP I use on a bunch of different places and I don't know how to personify a ZK proof in real life. One day I will figure that out and it's going to be amazing. But essentially what you'll usually do in these cases is like, you only share a specific part of that claim or that ID. So let's say a local municipal issued you a driver's license, issued you some type of identification, right? What are some of the key pieces of information on that driver's license? You have your name, date of birth, address, a bunch of different information, right.
04:31:12.734 - 04:32:19.346, Speaker C: Anywhere that needs your ID, you end up giving them your ID and they have access to all of this information, but they may only actually need one or two pieces of information from there, right? Or they may not even need to know 100% what your date of birth is. In the case of like, if you're going into a bar or a place that requires you to be 21 or older, what if you could verify you're 21 or older without giving them your actual date of birth? And that's kind of like the concept we're going to be focusing on today a little bit. So in previous workshops, we've gone through the flow and we wore two hats. We were both an issuer and a Verifier. In this workshop, we're still going to be both, but we're going to look at two different pathways and two different types of applications you can build during the workshop. So you can during this hackathon, be your own issuer, build that out yourself, and we'll go into what that means in a second. Or you can be a Verifier, create an application that consumes some type of claim that has been issued by whatever issuer you trust in real life.
04:32:19.346 - 04:33:08.610, Speaker C: These two entities should be different, hopefully, because you don't want to issue claims and then only trust claims that you've issued. That's not really decentralized, I guess. So you would have probably an issuer who is tied to some Verifier, like a local municipal or something like that, who issues you that ID or issues you a claim, and you would have these claims that can be verified. It's up to the Verifier to trust the issuer, and that's where that triangle trust comes in. The Verifier has to trust that the issuer gives proper credentials for all of this to work. So let's look at some demos and some code. So what you'll see here right now is what's sort of the UI platform for testing out and giving people claims.
04:33:08.610 - 04:33:54.096, Speaker C: So if I wanted to make a new claim, so I would go here and create Schema. This is all on platform test polygonid.com. This link will be available in the repo, which I'll be tweeting out. So there's a bunch of different information that you can put in here, but let's say I want to put in something like how old am I? Age verification, date of birth. So in this I would name my schema something. So I named it Age Verification, and I would give my attribute something which would be Date of birth. And I have three data types that I can choose from.
04:33:54.096 - 04:34:21.420, Speaker C: I can choose a boolean yes or no. I can choose a date, or I can choose a number. So I'm going to choose date. Just because we chose date of birth, this is optional over here. What you can do actually is click this and add an expiration date for your claim so that a claim after a certain amount of time will no longer be valid. I don't think it really makes sense in this case, but you might find different use cases for where you might want to do something like that. So you click Save and offer claim.
04:34:21.420 - 04:34:55.700, Speaker C: Great. Now, in the attribute I can put in my date of birth. I'm not going to put in my real one, but let's see, we'll do September 25 and this is again optional. So I'm just going to leave that alone. I hit Generate Claim offer, and I'm going to go ahead and open this link. So this link is now a claim that I can verify that I can add to my polygon ID wallet. So the Polygon ID wallet is a mobile application.
04:34:55.700 - 04:35:23.920, Speaker C: You can download it from the app store or Google Play, and that is where your claims or your credentials are going to be held. So as soon as I scan this with my polygon ID app, it's going to add this claim to my wallet. When it's added to my wallet, the thing is, it's not saved on a blockchain. It's not saved anywhere. It only exists on your local app, nowhere else. So everything is really dependent on your local storage. It's not saved anywhere.
04:35:23.920 - 04:36:04.584, Speaker C: You'll see that under my attributes. I have my date of birth listed over here. Although this is listed here, when someone makes a query to understand this information, what they can do is query for was this person born after this certain date? So instead of giving them the information that I may have been born on September 25, 1991, their query would simply verify that whatever their starting age point is, is greater than or less than mine. So they don't need to know my actual date of birth. They just need to know that I meet a requirement. So we'll take a look at those queries in a second. But this is the UI platform for issuing a claim.
04:36:04.584 - 04:37:10.476, Speaker C: Now, the issue here is this is not something you can use to make sort of like a robust solution for issuing claims, right? If you wanted to become an issuer yourself, you wanted to maybe partner with a local municipal. If you wanted to verify different things, whether it be date of birth, whether it be income level, whether it be Dow, membership, NFT, whatever, like pretty much whatever you want. You can create an app that does that verification and creates these claims. So how would we do that? What we've got here is an overview of the Polygon ID documentation. And one of the things that we've recently launched is the Polygon ID platform API. So now rather than going through and building on top of that UI platform, you have different endpoints that you can use to issue claims yourself through any type of front end that you want. So on your front end, maybe you want to verify someone's ID, maybe you want to verify that they own a certain NFT.
04:37:10.476 - 04:38:00.224, Speaker C: Maybe you want to verify income level in some way for like credit scores or things like that. You can do anything that is traditionally done in web two, gather that information and then issue a claim based on that. Right? So now you have the possibility of bringing things into Polygon ID, such as credit scores, income level, age verification, which is again what we're focusing on today, but kind of like whatever you can think of, it's up to your front end. Whatever your front end does is what it does and you issue a claim based on that. So if you wanted to go in and look at that API, we have an API reference here. All of these different endpoints can be run right away in postman. So you can go in, try them out, play around with them.
04:38:00.224 - 04:38:39.804, Speaker C: Definitely recommend if you want to build your own issuer, try out all these different endpoints and see what's possible. And one of my teammates, Steph, has actually created an awesome little starter template. So this is a react front end which allows you to it hooks up immediately with the Polygon ID API. All you have to do is go in and change a few environment variables and you're kind of like already set to go. You can build different things on top of that. But this is a really great starting point, especially if you decide that during this hackathon you want to focus on the issuer side. You want to build your own issuer, you want to build some type of verification platform.
04:38:39.804 - 04:39:21.276, Speaker C: So check this out. You can fork this, repo it's already got a few of the different endpoints that are available on that API, kind of like coded in there. You can add more as you go depending on your use case. So that is the Polygon IDE platform as well as the API. Those are the two different ways right now that you can issue claims. So what do you do after you've issued a claim? One thing that we see a lot, especially now in things like social media, Instagram, Twitter and everything like that, it requires you to be 13 years or older at some times to use it.
04:39:21.298 - 04:39:21.676, Speaker A: Right.
04:39:21.778 - 04:40:27.532, Speaker C: So again, we come to this point, do we have to share our date of birth every single time to these different platforms? Do they really need to know our date of birth? No, they just need to know if we're 13 or older so that we can actually use the platform. So in my case, I created a couple of claims already through here that verify that my age is over 13. When you do your actual verification, if you want to, you can build out a solution that Verifies ID and everything like that totally up to you. Polygon ID itself is really just like the platform that you would use to issue the claims, hold those credentials and verify them. The actual process of verification kind of happens elsewhere and you can bring that into Polygon ID. So I created this small DAP where it checks whether I am 13 years of age or older or not. And as long as I am 13 years of age or older, I will mint a soul bound NFT that I can use to token gate different social media platforms.
04:40:27.532 - 04:41:15.424, Speaker C: For example, let's say you're building on top of Lens Protocol. Maybe you want to token gate a Lens Protocol specific application. If we wanted to build a social media that's I guess more compliant with what web two standards are right now, and we wanted to make sure that only folks 13 or older were using something like a lens Instagram or a lens Twitter type thing. We could use this to token gate it after verifying if someone is 13 or older. So we've got a couple of contracts in here. The main contract that I'll focus on today is going to be this ERC 721 Verifier and it's inheriting from a couple of different libraries. So these library contracts are ones that you can just copy and paste right into your code.
04:41:15.424 - 04:41:53.336, Speaker C: Cool thing is, if you wanted to just get started and you're not too familiar with the ZK side of things, we give you a couple of library contracts so you can get started, leverage the power of ZK proofs and kind of like, abstracted away. At least for this hackathon. Though I do definitely recommend you go in, dive into it, and learn more about it as you go through. So in my case, I have all of these saved locally. You would want to make sure that you also have those saved locally. You can grab those from the tutorial in the Polygon ID docs as well as any one of the repos that I'm going to be sharing with you today. And this is just a basic ERC 721 Token.
04:41:53.336 - 04:42:36.280, Speaker C: Nothing fancy going on here. It's called social age check or sac. And the three main things that you want to focus on that do the magic here is this first function before proof submit and after proof submit. Before proof submit is going to check that the challenge input of the proof is equal to the message sender. So you want to make sure that the person who's actually verifying using their Polygon ID wallet is the person who is also trying to mint this NFT. They got to be one person, right? And then after proof submit is where you can basically, once these verifications are completed, this is where you can do pretty much whatever you want inside of this. If statement.
04:42:36.280 - 04:43:15.348, Speaker C: It's pretty much nothing related to Polygon ID. It's just me minting an NFT. So in here I've got the safe mint function which is taking the message sender as well as a new item ID that I created up here and setting the token Uri for an onchain NFT. So that on chain NFT is just being generated. Over here, it's just an SVG, nothing fancy. An SVG that just says that I am indeed 13 years of age or older. And you'll see, for my before token transfer, this is where I'm making sure that this becomes a sole bound token that you can no longer transfer it.
04:43:15.348 - 04:43:38.350, Speaker C: Your age is your own, not someone else's. You can't verify your age for someone else. And there's a few other tutorials that do some similar things. Here you can do something like if you were doing like an ERC 20 AirDrop, you want to make sure that that person or whoever you transferred the ERC 20 tokens to have actually been verified by Polygon ID. So this is the location where you would do everything like that.
04:43:40.020 - 04:43:40.864, Speaker A: Cool.
04:43:41.062 - 04:44:04.170, Speaker C: So let's go back to here and I've got a quick demo of that in action. So this is the polygon ID wallet. Pretty simple. You open up your app. Actually, hold on, I actually skipped something. Sorry about that. So one thing I forgot to show you.
04:44:04.170 - 04:44:46.340, Speaker C: So we've got so I've shown you how to actually build out the smart contract itself. There are two scripts that need to be run in order for you to actually utilize this. So these two scripts can be found inside of scripts. First is just your regular deploy. You want to deploy your function, deploy your smart contract. And then this set request, which is going to be how you connect your contract to this contract that has been deployed onto the Mumbai testnet. So, important thing to remember, polygon ID, the way you're using it right now is on testnet.
04:44:46.340 - 04:45:24.492, Speaker C: But essentially this is what's going to connect you to a contract that exists on the Mumbai testnet that allows you to take advantage of a lot of the ZK proofs that are underlying. And this is also where you would put your initial queries for whatever you need to validate. So in this case, I have an age query. I want to make sure that the person who actually uses this specific platform was born before this date. Definitely. Take a look at the GitHub documentation linked over here. This is a JSON query language for building out your query.
04:45:24.492 - 04:45:41.092, Speaker C: It's nothing too complex. You just need to figure out what each of these indexes mean. But the operator over here basically lets you know if the operation should be like a greater than equal to less than. So I believe this is number two.
04:45:41.226 - 04:45:42.356, Speaker A: Off the top of my head, I.
04:45:42.378 - 04:46:26.784, Speaker C: Think it's greater than. But take a look at the documentation and verify that before you do your own query. So this is what would set the actual verification for your smart contract. And then you have to build out a front end for a user to actually validate their claim. So I forked a small front end here that you can check out. Nothing too fancy, just a page where once again you're going to be scanning a QR code from your polygon ID wallet app. But you'll see here that once again you have this QR proof which is a JSON query language.
04:46:26.784 - 04:47:04.844, Speaker C: Again, just take a look at the documentation there to understand what pieces of data that you need. But this is going to be more related to the schema that you generate from your claim. So you're going to put some information regarding that. And you'll see here that for birthday I am checking if it's less than this specific date. So those are like the key pieces of information that you need as well as the schema details which you can get from your claim after you've claimed it. But from here it's pretty simple. From here you just use your polygon ID wallet to verify that ownership.
04:47:04.844 - 04:47:34.058, Speaker C: So let's go back a little bit. So again, I open up my wallet, I scan the QR code, a proof request is then sent. I want to generate the proof now it'll actually go to my regular wallet. So I'm going to connect to MetaMask and sign the transaction. So I go ahead, I connect my account. The proof is now being generated. And remember, we're minting an NFT at this point.
04:47:34.058 - 04:47:44.240, Speaker C: So there's going to be another transaction that we have to sign through MetaMask to make sure we pay our gas. So now the actual NFT is being created. This is the transaction for that.
04:47:46.750 - 04:47:47.500, Speaker A: Cool.
04:47:48.270 - 04:48:20.946, Speaker C: And once you're all set, you hit confirm. Now you own a soulbound NFT that has done some verification that you are 13 years of age or older and you own this as an NFT. So again, I'm not an artist. So you get a very basic NFT here that says that I am verified 13 or older. This is a solbound NFT that you can use to now gate different social media platforms. This is just like one very basic use case. So there's a lot of different things that you can build on here.
04:48:20.946 - 04:48:49.360, Speaker C: Like I said, if you want to focus on the Issuance side, you have the API, you have a starter kit from one of my coworkers steph. If you do end up using it, make sure you star that GitHub repo tweet at her. That you're using it. She'll appreciate that. And yeah, we'd really love to see what all of you build during this hackathon. Just a couple more things. These are some additional resources that you can use to build.
04:48:49.360 - 04:49:50.560, Speaker C: I actually just tweeted out the link to this GitHub repo, which contains everything, including the slides. So if you go on my Twitter, that is at or hot codes, you can link over to the GitHub which contains the slides, all of the resources, all of the links that you need, and I would highly recommend also going back and checking out Steph's original polygon idea workshop from ETH Bogota. She did a great, really good introduction on the very core basics of how everything kind of works. Stefan Manny's GitHub repos have additional examples of how you can build on top of it as well, manny's GitHub repo contains common errors that you might run into as you're building. So if you ever get stuck, need some help, troubleshooting. Manny has listed out and taken screenshots of very common errors you might get and how to fix them.
04:49:52.530 - 04:49:53.134, Speaker A: Cool.
04:49:53.252 - 04:50:04.260, Speaker C: If you've enjoyed this workshop, please let us know on Twitter. We're at zero x polygon devs as well as at Rahatcodes, which is me, and would love to take any questions.
04:50:05.350 - 04:50:07.220, Speaker A: I was told I have to wear this.
04:50:07.990 - 04:50:17.700, Speaker C: Anyone have questions? Think someone over here.
04:50:25.210 - 04:50:35.978, Speaker A: So once the issuer issues the claim, what if somebody else scans the QR code than the one whom you have issued it to?
04:50:36.144 - 04:50:42.938, Speaker C: So once one person scans that specific QR code, another person would not be.
04:50:42.944 - 04:50:43.466, Speaker A: Able to scan it.
04:50:43.488 - 04:50:45.694, Speaker C: It's like specifically for that one time use case.
04:50:45.732 - 04:50:49.710, Speaker A: Okay, what if before the actual user scans it, somebody else scans?
04:50:50.130 - 04:51:14.598, Speaker C: I mean, the ideal kind of situation would be that you do your verification and you send a unique link to that specific person. As long as they're not like that's, just like common web two security issues, as long as they're not doing anything like common phishing attacks or things like that, you should be fine. So that would be up to the kind of like the user to protect their link.
04:51:14.764 - 04:51:29.338, Speaker A: Okay, just one more question. There is this age related thing that we did lesser than 2009, January 1. Right. So in a few years, the date will change.
04:51:29.424 - 04:51:29.770, Speaker C: Right.
04:51:29.840 - 04:51:35.070, Speaker A: So how? Well, you have to update the front end accordingly.
04:51:36.290 - 04:51:55.410, Speaker C: So you can update your query at any time, both on the smart contract as well as the front end. So on the smart contract, the second script that we've run, that can be run as many times as you want, you can update that with different queries with different parameters, and your new query would be what would be verified.
04:51:56.470 - 04:52:41.620, Speaker A: Okay, thank you. Yeah, hello here. So actually I wanted to know the way we basically send the zero knowledge proof to the smart contract, is it possible in a way that someone else I create a zero knowledge proof from the polygon ID app, and then someone else creates a new transaction on the polygon blockchain rather than me doing it. And then basically we can prove that this person actually approved this transaction. So someone, let's say I assigned a zero knowledge proof and I gave a string or something like that of the proof to you, a JSON file maybe. And then when you send it to the blockchain, it could be verified that you did it on my behalf and it's allowed to do it.
04:52:42.230 - 04:52:52.930, Speaker C: So I guess I'm trying to rationalize why you would need ZK proofs for something like that, because regular signatures pretty much take care of that for you with like, the ECBs.
04:52:53.090 - 04:53:16.430, Speaker A: The reason I want it to be is that let's say because I want the verification of that, that it is authorized by me onto the blockchain. So in the ZK, we are doing this verification on chain. So I don't want it to be onto a device or maybe Intermediary or anywhere else on the smart contract itself verifies in ZK.
04:53:18.450 - 04:53:38.098, Speaker C: Okay, so again, it's possible everything is kind of like built on top of Circum and the ID and three protocol that's underlying for this specific way you use polygon ID. We're kind of abstracting a lot of that away, but if you wanted to go in and create your proofs, you.
04:53:38.104 - 04:53:39.380, Speaker A: Can definitely do that.
04:53:40.710 - 04:53:44.806, Speaker C: So I guess I'm not sure what the polygon ID specific question is here.
04:53:44.988 - 04:54:13.418, Speaker A: Yeah, the specific question is just that let's say I have a specific use case in which my transaction is being signed and sent to the blockchain. The smart contract from a centralized server, let's say. But I want the centralized server, like when it sends to the polygon blockchain, I want the smart contract to know that it was sent on my behalf. At the smart contract level, I want to verify this thing. So I'm not sure if signing a message just I can verify that on the smart contract level, but I'm sure if I send the zero knowledge proof, then it could be verified on the blockchain.
04:54:13.514 - 04:54:42.506, Speaker C: So kind of like what you're describing right now is what happens pretty much all the time on something like OpenSea. That is literally the process that they use. And that's done without ZK proofs at all. That's just done with signatures you set an approval for that you want OpenSea to be able to transact on your behalf and to sell an NFT once you have a specific offer or whatever. Right. So that's all done without zero knowledge proof. So I'm still kind of okay, got it.
04:54:42.608 - 04:54:58.878, Speaker A: So last question is that, let's say, what's the use case of like, I saw there are a couple of variables, like types, for example, like date, boolean and a number. So what's the use case of a boolean? Where can we use it and why is it there?
04:54:58.964 - 04:55:10.286, Speaker C: Yeah, I mean, if you wanted to do some true or false if you wanted to keep the query itself very simple. Maybe your front end, like the issuer has some complex sort of, like, issuer.
04:55:10.318 - 04:55:14.722, Speaker A: Will be proving that something is true. So he can clearly tell this. Like he's telling the value.
04:55:14.776 - 04:55:15.378, Speaker E: Exactly.
04:55:15.544 - 04:55:18.100, Speaker A: So why do we need proof and hide that?
04:55:18.550 - 04:55:19.298, Speaker C: I'm sorry.
04:55:19.384 - 04:55:29.480, Speaker A: So the issuer can basically tell. So with the zero knowledge proof, you will be basically telling that is that it's true or not? So it's directly boolean anyway, right?
04:55:32.670 - 04:55:40.310, Speaker C: In that case, I would see your point, but the way I see it is it's for just, like, ease of use, in my opinion.
04:55:40.390 - 04:55:48.070, Speaker A: Okay. Yeah, cool.
04:55:54.830 - 04:55:56.060, Speaker C: Any other questions?
04:55:59.410 - 04:56:01.134, Speaker A: Good. Okay.
04:56:01.252 - 04:56:03.120, Speaker C: All right. Thank you all very much.
04:56:05.110 - 04:56:08.674, Speaker B: So where exactly the proving part is?
04:56:08.792 - 04:56:11.490, Speaker F: Is it after the claim?
04:56:13.030 - 04:56:15.042, Speaker B: The issuer issues a claim, okay.
04:56:15.176 - 04:56:17.458, Speaker F: And then it stays in the wallet, right.
04:56:17.544 - 04:56:20.790, Speaker B: So the wallet will be sending only the proofs.
04:56:21.450 - 04:57:07.226, Speaker C: So the proving part actually happens in our case, happened within the NFT smart contract, right. We had those different libraries that we imported in that takes care of kind of abstracts away everything so we don't have to worry about it. And there's a smart contract deployed on the Mumbai test network that essentially does a lot of that work for you. And whenever you take your polygon ID wallet, you scan that QR code with that JSON query inside of it. That's what kicks off the smart contract to start the actual proof. So all of the information from that JSON query is sent to the contract. It also gets access to the claim that is in your wallet, if that's where you're scanning it from, and that's where the actual proof is verified.
04:57:07.358 - 04:57:08.040, Speaker G: Okay.
04:57:12.490 - 04:57:14.520, Speaker C: Are you all getting feedback, too? Yeah.
04:57:15.370 - 04:57:17.958, Speaker F: So where exactly is the proof generation happening?
04:57:18.044 - 04:57:20.194, Speaker I: Is it on the device, the mobile.
04:57:20.242 - 04:57:22.850, Speaker C: Device, or that is on the smart contract?
04:57:22.930 - 04:57:33.920, Speaker B: Oh, in the smart contract. Okay, so if I have a use case in which I'm kind of sending the proof, right, I don't want to expose my public key, right?
04:57:34.610 - 04:57:39.120, Speaker A: Is that Doable generating the proof on the device itself?
04:57:40.130 - 04:58:03.622, Speaker C: No, because the device itself, all it does is hold your credential, nothing more than that. That is the only use case for the actual wallet, just for holding the credentials. And within the smart contract, we're also verifying that this person who's connecting their regular wallet with the polygon ID app is the same person. So that'll require cool.
04:58:03.676 - 04:58:19.544, Speaker A: Yeah. Okay. All right.
04:58:19.582 - 04:58:23.430, Speaker C: So it is the end. I can take your question outside.
