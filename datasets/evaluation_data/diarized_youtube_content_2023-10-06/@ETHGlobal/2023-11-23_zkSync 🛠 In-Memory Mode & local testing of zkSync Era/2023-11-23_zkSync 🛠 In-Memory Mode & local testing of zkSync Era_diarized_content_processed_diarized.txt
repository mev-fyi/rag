00:00:07.210 - 00:00:59.386, Speaker A: Hi everybody, my name is Nick, I am here from ZK sync and I'm going to be talking about the in memory node for testing and local debugging. Whenever you're deploying your apps to Zksync we'll go through quickly an agenda today of what it is, but some background about myself. I've been a software engineer for twelve plus years, recently joined the Matterlabs company, came from SpaceX and yeah, let's get into it. So before I go into era test node, I do want to cover what it is we could be using for testing today. Sorry if it's like a dark background, little difficult to see, I'll just read it out loud sometimes. The first option is we have a public testnet, right? It has goerly as the l one. And the downside of this testnet is it's difficult to find funds from a faucet.
00:00:59.386 - 00:01:47.310, Speaker A: The second setup is having a full local dockerized network using three docker containers, and we have that available in this GitHub repo that I have listed below at local setup. So it is just a local network from a layer two down to the layer one with a postgres database. Takes a few minutes to get set up and these are two great resources to get tested your smart contract locally. But let's talk about era test node. So we wanted to build something that improves a lot of the problems and frustrations that people were having whenever they were developing for Zksync. So one, it needed to start up fast. So for era test node it starts up in less than half a second.
00:01:47.310 - 00:02:54.050, Speaker A: The ability to fork the upstream main net and testnet networks at any given height. We want to be able to replay transactions from these networks. We want to give you these pre configured rich accounts so that if you were to start it up locally, you don't have to worry about finding a faucet somewhere so that you could start just deploying and using your smart contracts support for getting the console logs for hard hat or foundry. The call stack should just be easily available to you for debugging purposes. And if you're having any issues with gas utilization or just questions about why is it so expensive for your smart contract, we wanted to make it really easy to dig into those gas details. So what does it look like to run the era test node? So first and foremost it's a binary. The one way you can run it is download the binary from our GitHub release and the command would just be eritest node run and it'll be up and running on port 8011.
00:02:54.050 - 00:03:53.586, Speaker A: The second way is you could actually just use NPX. So this NPM tool, we have a Zksync CLI tool where you can just say dev start and you don't have to download the binary manually, it will just take care of that for you and get it running. Finally, the last way to do it is to have it embedded in your hard hat configuration. So if you add this yarn package or this NPM package of matterlabs hard hat zksync node, then in your hard hat config you add the import statement that I have at the bottom of that exact package. Whenever you do things like NPM hard hat test, it will just run against that local node, spin it up for you, download it for you and stop it whenever you're done running your tests. We'll go into some examples about that later. But why did I give you that background? And how do these three different approaches compare? So just a quick high overview.
00:03:53.586 - 00:04:36.030, Speaker A: You have a comparison between the testnet, those docker containers and finally the era test node. So running locally, the testnet does not do that. It is not running on the public servers that we have. And this could be a downside. If you are running your tests in CI CD, sometimes you don't want to rely on a bad Internet connection. If you want to develop fully offline, you're on an airplane, you want to be able to develop everything locally rich accounts. So testnet, right, the downside is you have to find go early east, you have to find a faucet that you trust to get some tokens so you can actually use your smart contracts.
00:04:36.030 - 00:05:30.150, Speaker A: In terms of fast setup, Testnet is live, you don't have to do anything, it just works right now. However, the downside for something like Docker is it takes five to ten minutes sometimes to get running for the first time and then debugging. You don't get debugging with any of the other approaches like you do with era test node. So in terms of configuration for some of these, the chain ids are different, 280 to 72 60. Obviously the endpoints are different, but the major difference is layer one eritest node does not have that layer one component. It is just a layer two in memory node, similar to like the hard Hat network node or reth or anvil is another example. And it doesn't require or doesn't have that capability to communicate to an l one at the moment.
00:05:30.150 - 00:06:07.042, Speaker A: So if you need to test that functionality, go with one of the other options. I've been talking about it a lot, but let's go into a quick demo of how would we deploy a greeter contract. Let's talk about what you would need to add to your hard hat config. And really it's just a network with the URL pointed to localhost port 8011. So let's take a look at that. I have created a template project based off of Zkync cli template or create sorry. And what I was talking about with the greeter contract is right here.
00:06:07.042 - 00:07:02.654, Speaker A: We have a string that we are setting in the constructor and we have two methods where we get this greeting message and we set the greeting message. So what we can do is go ahead and start up the euro test node, euro test node run. And there you go, it's already running. So what we can do is actually start using it and it will be here, let me toggle presentation mode real quick. That way you can see a little better. All right, so NPM run, deploy, and for the network, I'm going to say in memory node. So you'll see the first thing it's saying is it doesn't have a private key, you need a wallet to be able to deploy.
00:07:02.654 - 00:07:51.902, Speaker A: But the nice thing about running the era test node is it spits out that information for you right at the beginning. It tells you what the chain id is, it tells you what port it's running on and it tells you what those ten rich wallets are that you could use locally. So in the env file, I'm just going to paste that in, run it again and let me scroll down so you can see it, so it deployed. And you can see if I scroll up that here is a summary of the transaction that happened in the lower command line. You will see that this is the contract address for the new greeter contract. Here are the constructor arguments. And in memory node you see this was the transaction, it was successful.
00:07:51.902 - 00:08:57.000, Speaker A: You can see who initiated it, who the pair was, what gas was used, what gas was refunded, what some of the events were, and it will still keep running ready for the next command. So let's get into that next command, which is we have the ability to interact with this new deployed contract. And what this script does is points to this greeter contract that we just deployed. It gets the greeter message, it sets the greeting message to hello, I'm just going to say dev, connect and then gets it one last time. So let's do instead of deploy, interact. And you'll see if I scroll up over here. That there was a call, there was a transaction, and that's to set the message, and then there's another call to get it one last time.
00:08:57.000 - 00:09:59.178, Speaker A: And in this project, we also have hard hat tests, right? So that whole workflow that I just showed you of deploying the contract, setting it, getting it, updating its value, it can all just be wrapped up into a single test and it will work. Now let's run this. Sorry, 1 second. All right, let's skip that for right now. I don't know what the error is. It looks like it's hitting an API rate limiting for an unknown reason. That's probably because the Internet connection for me is really not great down here.
00:09:59.178 - 00:10:59.550, Speaker A: But you can easily point to the hard hat node, but you'll notice that it won't actually be outputting the content to the node that is running in this console. And the reason is because whenever you are just doing hard hat tests, it is using the hard hat network. And this was that third example of how you could run it locally. Whenever you're running tests where we say, okay, import this node. And so whenever you do hard hat tests, it will just start up a node in the background, run against it, and spin it down whenever you're done. So it's great for CI and you don't really have to take care of or worry about too much. So just as a small recap, I showed you how to start this in memory node, deploy a contract, use some rich accounts, execute the contract, and hopefully run some automated tests.
00:10:59.550 - 00:11:53.550, Speaker A: Now, I have shown you just a basic node, like a hard hat node, but what we really wanted to do is make sure that you could actually debug some of your transactions. And what do we need to support whenever we want to have that capability for developers? The first two things are we want to show you the call stacks and we want to show you the console logs. So whenever we're looking at a bunch of tests or debugging, it's just console log everywhere. It's console log for hard hat, it's console log for foundry. So let's look at showing that exact value. So over here, what we're going to do is update the greeter contract. So when I say console log, that is this console log, that is the hearthat console.
00:11:53.550 - 00:13:10.340, Speaker A: And I have two new console log statements at the beginning of set greeting. So set greeting is called, and then the value that was passed in, I also added a check right underneath that says, hey, make sure that the greeting value that you're trying to set it to is not equal to the string test. If it is, go ahead and revert and say received a test value. We don't want that. We're going to compile the contracts again and then we'll redeploy. Going to take the new address, update the interact contract, and this time when we interact, let's take a look over here at the era test node. So as that ran, if we look up right here in the transaction, we can see the console logs are being spit out right inside of the transaction summary.
00:13:10.340 - 00:13:45.664, Speaker A: The call traces are here. It says there are 20 of them, but you don't see them. We hide them by default, but we can easily show them. So while this node is running, we've added a bunch of APIs so that you can update the settings about it. You can update the log levels, you can update information about how much show call information you want to see, et cetera. So we're going to call config, underscore, set, show calls while the node is running, and we're going to set it to all. So let's do the interact script one more time, and this time you'll see a lot more information.
00:13:45.664 - 00:14:43.488, Speaker A: All of the stack trace is showing up here, and you'll see it is indexed based off of the tree index for the entire call stack. So if you go in here, you'll start seeing things like the console log statements, the two that are right here, the two Cacax statements that you are using to compare that your string does not equal test, et cetera. But you can't really necessarily read all of the information easily. So we have another method to do that. And if you scroll down a little bit, set resolve hashes. So what we're going to do if we run this one more time is you should notice that these values on the right are no longer just hashes. We reach out to Openchain API, turn these values into human readable functions, so that as you're going through the code and you look through, you see, oh, whenever I called set greeting before that, it did execute transaction set, transaction origin, get raw code, hash.
00:14:43.488 - 00:15:42.860, Speaker A: All of these methods through the entire system are available to you. Oh, I need to show you what an error looks like. So I had added that check that says, hey, the value shouldn't be test. So what happens if we do set it to test? Can you easily tell what's going on? And boom, right here in bright red, it already tells you, look, execution reverted, received a test value. This is insanely useful whenever you are trying to debug a set of transactions inside of a batch. It just highlights exactly what the problem is, and you don't have to dig any further to resolve the issue. So, in terms of console log call stacks, readable events, and ABI functions easily spotting errors and reverts, that is just like first class citizen for the in memory node.
00:15:42.860 - 00:16:16.500, Speaker A: Now, the other nice thing about debugging is we want to be able to give you the ability to fork Mainnet, fork testnet in a few seconds and also replay transactions. So why would you want to replay a transaction? Well, let's talk about a scenario where a customer says, hey, within our tests, everything worked. But Zksync has an issue when some transactions fail with an error message. This is a long bunch of text. Here's the contract address. I tested it myself with the same result. If you need anything, please let us know.
00:16:16.500 - 00:16:50.556, Speaker A: And we don't have access to their console. We don't see what they're seeing. We're just hoping that they give us the information they need. But we don't have to do that. We know exactly what the transaction is. So if we were to click on this and open it in the block explorer, we can see the first hash like, yes, it failed, right? But we can take this transaction hash, and if we go back here, we can actually use a new method called replay underscore TX. Replay the transaction against Testnet, and we give it the hash of the transaction.
00:16:50.556 - 00:17:41.660, Speaker A: You'll notice that I already showed you show calls resolve hashes, but I added a third one in here, which is show gas details. They want to be able to see what was happening with the gas cost. Why is this thing using up so much gas? Or we thought that was the problem, so we took a closer look. And if we take this and make this as large as possible, I'll stop the node. So I run the command of replaying this exact transaction. Inside of here, you'll see that there were two transactions in this batch, so it gets each transaction so it's already forked testnet, by the way, it happened that fast. But what it's doing is it's taking those two transactions and it's replaying them one after another locally.
00:17:41.660 - 00:18:13.700, Speaker A: Now, it's also reaching out for every single one of these methods and getting the human readable function names that you see on the right. So the events are also being translated, so you can see the transfer events, et cetera. Right here you see the big bright red error, which is whenever they were calling set. Latest answer, it threw a panic. If we scroll up a little further. There is a new section inside of the transaction summary. There is a massive gas details section.
00:18:13.700 - 00:18:49.168, Speaker A: And let's take a look at what it does. Well, one, it breaks down your gas usage by transaction setup. You'll see 25% of it went to transaction setup, 64% went to account validation, 9% was spent on opcodes. And if you break down the transaction setup even further, you see 93% was spent on operator costs. If you keep digging, there are these overheads that we give you insight into. So all of this gives you the right tools to be able to dig down even further. And you can literally just replay transactions that are giving you problems in Testnet and Mainnet.
00:18:49.168 - 00:19:42.500, Speaker A: And if you notice, if I scroll all the way down, this node is still running, you can still execute transactions against this, you can still use this because it's still running and it's forked at that exact moment in time with the error that you just saw. So if you want to dig in further, you can, it's still live. Now, forking, you don't just have to fork at the latest block. You can fork at an exact block height, right? You can fork testnet, you can fork Mainnet. Whatever you need to do for your local testing, it should just work. So I talked about forking mainnet, testnet, forking at a specific height, replaying transactions, and digging deeper into some of those gas details to figure out why something is so expensive. In terms of CI CD, we wanted to make it easy so that this in memory node.
00:19:42.500 - 00:19:43.016, Speaker A: Yes.
00:19:43.118 - 00:19:50.408, Speaker B: Just a quick question about forking. So it's basically like replicating the state at some particular time.
00:19:50.494 - 00:20:46.830, Speaker A: Yes. So in terms of integrating it with your CI CD, one way is just the GitHub action. If you just need a node running that, you want to point something to it. It's this bottom part right here. You just say databutter era, testnode action at v one, and it's running, it starts up on port 8011. You can give it the extra parameters if you always want it to fork from a very specific block in testnet for your CI CD, whatever the case may be, in terms of what's happening next. And what do we want to see with a tool like this? So, one support for foundry, we want to have things like forge, anvil, rivet, all these things just sort of work in a very quick and fast environment that you can manipulate a lot of the underlying information.
00:20:46.830 - 00:21:39.160, Speaker A: When it comes to the node itself, you should be able to do what you need to test all of your smart contract from beginning to end. The project itself was open source from the beginning. So if anyone wants to contribute to it, we are encouraging the growth of that open source contributions for the project, adding the ability to connect to an l one. Like right now it's just an l two on its own, but there's just some work involved that's necessary to get it connected to an l one, so that you can test the full beginning to end support for more APIs. And then what else you can think of. This is all written in rust. If you want to take this in memory node, compile it down in WASM, now it's javascript.
00:21:39.160 - 00:22:50.260, Speaker A: You could have an in memory node running in your browser. You could have, theoretically, an in memory node that is right next to the transaction that fails in your block explorer in Etherscan, and you say, oh, why did it fail? And then it just replays it based off of forking at that exact place, tells you exactly all the details that you need to see, and you can just investigate right in the browser. So that's one idea that you could do. Yeah, we have GitHub discussions, and I'll make sure to circulate the slides through ethglobal. But one other project that we did this week, I know it's over, but ZK Quest was something that we had published this week where we basically built a little capture the flag video game for this week, and all of the development was against local era in memory node. So it was a true battle test of like this thing works. We've used it for doing a bunch of experiments in the company where we can manipulate and change the underlying system contracts for the ZK sync era node and validate that, oh, future changes are going to work.
00:22:50.260 - 00:23:15.708, Speaker A: We're changing the prover, the underlying prover, and we know it's going to work because it works for the in memory node. We know that we can make some drastic changes to the underlying system before pushing it out for the public to use, because we have this in memory node. Any questions? I know I kind of sped through it a little fast, just because I'm only.
00:23:15.874 - 00:23:25.452, Speaker B: Yes, with the foundry slide you were proposing to build for support foundry, no.
00:23:25.506 - 00:24:31.590, Speaker A: So we'd have to. Basically the way foundry is built is around Anvil, right? That is their in memory node. The thing is, it's built specifically just for EVM, similar to the hard Hat network node. But what we want is because Zksync has the ZKE EVM, which is EVM compliance, we actually need to tie it into this in memory node that we've built, we need to have a wrapper around it. If we build this wrapper so that these tools think that it is Anvil, then everything will just work from forge to rivet to other, just like foundry tools that they're building around having an anvil, like sort of in memory node. So same thing for hard hat, right? Hard hat has a network node that it starts up whenever it runs tests. If we just wrap the in memory node that we have to look like and have the interfaces of that network node, then it'll just be plug and play and it should just work.
00:24:31.590 - 00:24:37.844, Speaker A: And so that's sort of the idea here. Hopefully that answers your question a little bit.
00:24:37.962 - 00:24:42.970, Speaker B: Yeah. Right now with foundry, I can't really go and interact with.
00:24:45.820 - 00:24:52.328, Speaker A: For ZK sync, not at the moment. That's something we're working on right now where. Yeah, we're working on ZkForge and then.
00:24:52.494 - 00:24:53.976, Speaker B: Sorry, you said it's due to the.
00:24:53.998 - 00:25:35.020, Speaker A: Fact that it's also EVM compliance and then also the ZKe underlying EVM. Yeah, there are just differences that are not exactly supported from foundry. They haven't had to. There's a lot of foundry that we're working with them so that we can actually build a standard so that it can support different types of evms. Cool. Anything else? I know I wanted to leave some time for questions, so it. No.
00:25:35.020 - 00:25:41.720, Speaker A: Yay. Close.
