00:00:01.370 - 00:00:27.110, Speaker A: Welcome. All right. Welcome to the kinext workshop. So today we'll be going over building cross chain application with Kinext. With us today, Rahul and Victoria that may get to your question in the chat as well. I will hand this over to them to give a quick intro and kick off the session. Feel free to ask any question in the chat.
00:00:27.110 - 00:00:30.120, Speaker A: We'll be getting to them as well.
00:00:31.770 - 00:00:52.386, Speaker B: Awesome. Thanks a lot, Catherine. Really good to be here. We're really excited to be a part of know this is probably the most relevant hackathon to the stuff that we're doing. So we're happy to be here and support throughout this entire process. Like Catherine said. I'm Rahul.
00:00:52.386 - 00:01:25.090, Speaker B: I'm one of the co founders of Connect. I'm one of the tech leads here. So hopefully we'll get through this stuff and answer all the questions and help you guys out. So what I have here is this doc that I'll be going through. So it's kind of a hacker kit. And of course we'll share this with all of you guys after first of all, as an intro to Connect. So Connect, we like to think of it as Ethereum's Cross L two communication network.
00:01:25.090 - 00:02:17.426, Speaker B: So what that means is we are not an L two ourselves, but we enable communication between L two in the form of value transfer and liquidity transfer. Eventually things like message passing and things like that. As a brief history of Connects, we've actually been working on Ethereum Scaling Solutions for a really long time. For those of you who are not too familiar with Kinex, we have been building state channels for probably about three years now. We launched with their payment solution. Sorry, can everyone hear me still? That was weird blip on my thing. So we helped launch Spangchain's initial Tipping payments based state channel system and we had good results and feedback.
00:02:17.426 - 00:03:06.566, Speaker B: With that, we launched production. We got a lot of real world usage and feedback. And then that was kind of like our incubation period for how we started getting into state channels. We pulled that technology out and generalized it into a generalized state channel framework. For a while we were doing that and trying to basically build that as a layer two. And the way state channels went is that kind of became some of the issues with state channels sort of became very apparent when we tried to use it to directly scale Ethereum as a layer two. Some of the problems, as these are well known with state channels are the liquidity requirements and things like free option problems and things like that that don't really lend well.
00:03:06.566 - 00:04:04.970, Speaker B: They lend well to a very narrow range of applications. What we found though is this technology works really well for bridging between chains because essentially you can lock up funds on one chain and you can have liquidity providers who have channels on another chain seamlessly and noncustodially transfer value between them. And I say noncustodially because this is a very important part of our technology is that we use the validator set of the actual chain that we're on. So currently within Bridging technology there's a couple of ways to bridge. One of the main ways that people are Bridging now is using these things called POS bridges, which means these POS bridges have their own validator set. And then when you're on one chain you will burn some value or lock it up in a contract. Essentially these set of validators will validate that that has happened and then they will allow you to mint on another chain.
00:04:04.970 - 00:04:52.946, Speaker B: So the problem with this, of course, is that the validator set is different than the validator set of something like Ethereum. And then you get into these issues where if the stake is less than the amount that's being bridged through, then the validators kind of have an incentive to collude with each other. And the way our system works is we kind of bypass all those issues by relying on the direct security of the layer one itself. So anyway, at scaling Ethereum, what we want to do is we want to really lean into this metaphor about cross chain Legos. Ethereum is kind of money Legos and we see that cross chain is becoming a thing. There's no way around it. There's not going to be a single layer two.
00:04:52.946 - 00:05:42.090, Speaker B: There's not going to be a single Ethereum chain. As awesome as Ethereum is, people are going to build things on other chains. They may or may not be EVM compatible and we should kind of embrace that fact rather than try to be fully maximalist. I guess on just like one chain, one layer two, tier twos and other chains exist, it's fine as long as we have good ways and tools to build on top of them. And so some of the things that you can do by using connect, of course, like I'm mentioning, you can bridge instantly from any EVM chain into any other EVM chain. Eventually we will build, support and adapters for non EVM chains. But for right now, what you can do is EVM chains.
00:05:42.090 - 00:06:30.620, Speaker B: We have this concept of a withdraw helper which allows for cross chain metatransactions. So one big issue we've seen with Bridging across chains is once you get on a chain, you still need money to pay gas on that other chain, which if you're not using that other chain or don't care about using that other chain, you still have to get gas for it. So we've come up with a way where we use our routers as relayers who can send metatransactions. One big thing about layer twos and fragmentation of layer twos in general is it makes the user experience really bad because users need to know which chain they're on. They need to set their MetaMask for different chains and stuff. I just actually helped Victoria with this earlier today. And to get set up on.
00:06:30.620 - 00:07:12.862, Speaker B: It was, it was really interesting and eye opening to see a first time user of this stuff go through this process of adding assets. When you add an asset on Dai you're like, oh, this is my Dai on Matic. No, it's my Dai on Mainnet and then all this crazy stuff. So really what we want to enable is a user experience where users really don't have to know or care what chain they're interacting with. They can just be on whatever chain they're on and then interact with whatever chain they're doing. Like if they want to do a swap, they can do a swap on a different chain and seamlessly bring the value back to the chain that they're starting on. So I won't go into fully the prizes because these are all here.
00:07:12.862 - 00:08:04.394, Speaker B: But we are offering of course prizes to all our awesome builders and we have collaboration prizes with some really awesome teams like Graph and Optimism. Our main product that's out right now that you can use right now is this crosschain widget. So it's a widget that can be inserted, it's a react component that can be basically inserted into any DAP and it allows basically cross chain swaps. This is not working. So I'm going to have to go to this direct video link here. Basically it will speed this up a little bit. So you can see here the widget is getting from Maddox to Mainnet.
00:08:04.394 - 00:08:48.278, Speaker B: I say I want to send one, recipient gets one because it's a swap and then it will just transfer all the way through. So this is like a very normal Ethereum like interaction. I send my funds to this deposit address and then I will receive it on my receiver address at some point very soon. So it happens quickly because these transactions happen very quickly. So then I have my one USDC available on now, Binance because I transferred it from Matic. So a couple of the apps we're live with, we're live. This is the bridge I just showed you, which is Xpollinate.
00:08:48.278 - 00:09:39.726, Speaker B: So this is a cross chain bridge going between XDI Polygon and Binance smart chain. Right now we can add support for more chains. Basically the main limitation is just getting liquidity for those chains. Decentral games is another. They have directly integrated our widget to allow for easy onboarding directly in the app. So one big thing that we like is that this widget based operation allows apps to directly onboard users from Ethereum or any other chain directly onto whatever side chain they're using so they don't have to send users, be like, oh, go through the Matic bridge and then come back. Another thing is the Matic bridge itself has integrated us and Spacefold is our testnet bridge and then off L.
00:09:39.726 - 00:10:28.814, Speaker B: One is an interesting thing that I'll drive into later, but it's basically using the underlying connect technology to do cross chain arbitrage. So some of the ways that you can use connects, you can use the react widget, that's the quickest way. So you can just drop in a react widget and this will enable cross chain swaps and interactions with withdraw helpers which we'll get into. So it's a simple NPM package, you just drop it into your app, configure the props and we have some examples here of how to use it. And then what we've done very recently is we have broken up the widget into functions that can be used like an SDK. So you can create a full bespoke cross chain experience using this SDK. There's basically four functions that you can run to do the full swap end to end.
00:10:28.814 - 00:11:23.838, Speaker B: And we have docs and examples here as well. So one big thing that we're trying to push for in this hackathon as well is the withdrawal helpers because we think this enables a lot of very cool experiences. This allows you to build interactions with other contracts on different chains without needing native assets. So all you have to do is you write a special helper contract on some chain which you want. This will follow some interface and then you deploy it on that chain. Then when you're actually doing the swap, you'll generate call data which you will send to the router and then the router will help you withdraw using that call data into the chain. So like for example, one example I have here is a uniswap example.
00:11:23.838 - 00:12:07.254, Speaker B: So this is a way that you can use a withdraw helper to actually call a uniswap. So that means what you do in theory, what you can do with this is you can swap from, let's say, Xdai to Matic and then you can run this uniswap helper. So that will also do a swap at the end of your cross chain swap, like a uniswap swap on top of a cross chain swap. So the interface here is very easy. There's just a couple of functions that you implement. The main function is called execute. So what this execute function gets some data passed into it, then it will define some variables.
00:12:07.254 - 00:13:01.402, Speaker B: So these are some internal variables that are relevant to the uniswap swap itself. So the data gets passed in, gets decoded into this swap data, then it will actually call the uniswap router. So you pass in essentially amounts based on the uniswap interface. So amount in is how much you want to swap amount out min is the minimum amount you want to receive the tokens that you're swapping between the path of the tokens, the two address that's receiving it, and then the router. This is the uniswap router, not our connects router address. And then basically all this does is just call the uniswap interface functions and it's very simple to do that. One other example is superfluid.
00:13:01.402 - 00:13:38.230, Speaker B: So Superfluid is a project that's building like a new token standard for how to swap token for how to transfer value. I won't go into it too much because they have a whole project of their own. But you can essentially stream value like gaslessly. It's very cool. You should look into it more if you have a chance. But they do something similar so they just implement the execute function. The data that gets passed in gets decoded into specific data for this withdrawal helper contract.
00:13:38.230 - 00:14:28.358, Speaker B: So they have their super token, underlying token. Essentially what this is doing, this is wrapping an ERC 20 into their special super token. So you approve here and then you upgrade to and one really cool thing is the user doesn't need to do any of these approvals because the tokens are owned by this contract while this process is going on. And then you upgrade to and then it will give you back the two here or whoever you want it to be. Normally it would be you. Then you would end up with these upgraded superfluid tokens as the one who generated the call data. Then if you want to get a little more fancy and into it, you could use this direct browser node integration.
00:14:28.358 - 00:15:43.970, Speaker B: So we have a concept of a browser node which is basically a browser based signer for the Connect state channels themselves. So a little bit of diving into the architecture here. The way the browser node works is it uses an iframe to communicate. And the reason we're using this Iframe is while we're still getting building wallet integrations and things like MetaMask and things like that, we need a way for your private keys of your channel signer to be isolated from the DAP so that the DAP can't steal your private key and steal money. So what we do is our browser node injects an Iframe, which has its own storage and local storage and IndexDB and private key, and then that communicates over a JSON RPC post message payload to the DAP itself. And that allows the DAP to communicate with the entire Kinex network, essentially. So then if you want to do a direct browser node integration, all you do is install the browser node packages and follow this API.
00:15:43.970 - 00:16:40.900, Speaker B: And what I want to do now is dive into an app that was actually built using the browser node, which does cross chain arbitrage between uniswap clones on different chains. So this was built by Makoto INO from Ethereum Name Service. He did this as a hackathon project because he saw that there was this issue where there's a bunch of Unix swap clones on different chains and they have actually different prices for things. So you can use that to arbitrage because Connect is able to transfer value very quickly between chains. You can take advantage of these arbitrage opportunities without having your liquidity parked on the different chains itself. So here's a little diagram about how this whole thing works. So Bob, who is trying to use this system, say he uses the off L One UI to see an arbitrage opportunity.
00:16:40.900 - 00:17:19.406, Speaker B: The only time he actually has to interact with the system is when he does this initial transfer. So he will do a transfer to his state channel on the matic polygon network. Then he will call a function to actually get the funds into the state channel. Then you have a withdraw helper. So I just showed the uniswap withdraw helper. So the uniswap withdraw helper will exist on matic polygon and BSc, which you're doing the arbitrage between in this example. So you'll call reconcile deposit which gets the funds into the state channel.
00:17:19.406 - 00:18:06.954, Speaker B: Then you will generate the call data like we saw before in the uniswap helper, withdraw the funds back to matic polygon which will then create a swap from USDC to USDT. That swap will put the funds back into the state channel, which then again is able to reconcile the deposit back. So now you've essentially swapped your funds on one chain into a state channel. Then you can do the actual cross chain part. So what you do is you do just a simple function, which is a conditional transfer function where you set the recipient as the other chain. This goes through the router, you resolve the transfer, which basically reveals a secret. The way these transfers work is basically by hashlock.
00:18:06.954 - 00:19:06.290, Speaker B: So hash lock locks the funds to the router, router locks the funds to the other state channel. Now router can't access the funds or anything until the secret is revealed on this side. Router unlocks, router unlocks and then the funds are available here on the state channel. Then you do a similar thing, what you did on this side where you generate some data to withdraw, swap back, and then you do the whole thing where you swap again, reconcile deposit back in the channel and then fully back withdraw again back to Bob on BSc. So now you've transferred funds from here to here and you've done a couple swaps and you have probably made some money then. What I want to do now is kind of dive into a little bit of the code there just to make sure that it's clear on how we actually get these swaps done. This swap function itself, this is a react function.
00:19:06.290 - 00:19:46.750, Speaker B: This code is all available to show and share. The first thing you do is you create your providers obviously do all that stuff, all the boilerplate stuff, get your channels and create them if they need to be created. These are basic functions which are in our SDK. So everything that says node here is the SDK function. So get state channel by participants. The participant in this case is the chain ID and your counterparty is the router. So this is hard coded right now to our router address, which is the connect hosted router.
00:19:46.750 - 00:20:17.298, Speaker B: If the channel doesn't exist, you do a setup. So this creates a new channel and then if the same thing with the other side channel. So this is the two chain ID. Set it up if it doesn't exist, otherwise you're good. So now you have both your state channels. Then you get the balance. So if you need to add balance, this is the one part where you get the user to interact with it.
00:20:17.298 - 00:20:53.170, Speaker B: So you create a contract and then you do a token transfer from the user. This takes the user's provider and will actually pop up a MetaMask URL to actually do this stuff. Then like I was saying, you just call the reconcile deposit function on the from channel. Then you withdraw with the swap data. So this is when you actually call the get call data function on this withdraw helper contract with the amount you want to swap amount min. Right now this is just set at one so that the swap will never fail. And then the tokens in the path.
00:20:53.170 - 00:21:38.628, Speaker B: Then as you do a withdraw, I mean the reason we call it withdraw here is because it gets the funds from the state channel onto the chain. So you're getting the funds out from the state channel onto the chain. You're doing a swap using the withdraw helper and then you're putting the funds back into the state channel. So some boilerplate code to do all that. Like I said, so you reconcile the deposit again. So what reconciled deposit does is it takes balance that is on chain currently and puts it into your off chain state and then same thing. Then you do that actual cross chain transfer.
00:21:38.628 - 00:22:12.928, Speaker B: So the cross chain transfer happens with one function here. You create a pre image. Since you are the one that is both locking and unlocking the transfer, it's okay. And it is the right way to generate the secret right here within the app that is doing the locking and unlocking. So pre image is the secret. Lock hash is a hash version of the secret. You send the router the locked hash, not the secret here using the conditional transfer function.
00:22:12.928 - 00:22:48.120, Speaker B: So recipient is this recipient is the end recipient. So this is the forwarded recipient. Right now this is going to go to the router because this is your channel with the router. So recipient is who the router will forward the transfer to on what chain is two chain ID and what asset ID is two token. So then you wait for an event. Basically you have to wait for yourself to receive the event on the other chain so the router will do its thing. And for the transfer, you wait to make sure all that stuff happens.
00:22:48.120 - 00:23:49.000, Speaker B: We use like an event emitter based pattern to do all this. Then at the end, you resolve transfer on the two channel side using the pre image that you created before. And now when you do that, you have funds on your other chain. And then you're able to generate the withdraw helper data here and generate the two channel swap and do the same withdrawal here again. And this will actually withdraw it out to the recipient. Sorry, this will withdraw it back into the state channel and then you would draw it out at the end into this. This is kind of a bit of code to do all this stuff, but it all happens very quickly since this is all like off chain interactions and then at the end you're done and you have successfully completed an arbitrage and hopefully made some money.
00:23:49.000 - 00:24:35.922, Speaker B: So that's that just another bit of information on some of the stuff. The resources that we're providing another one of our boundaries based on metrics. So what we want to do is we want to provide visibility into the connects network. So we have a bunch of these routers running within the network. And right now these routers are broadcasting data, but the data is not being collected and displayed in a good way. So we have a bounty out for people to actually make use of this data, present it in a really useful way. So things like total value locked available liquidity throughout the entire network, number of transfers so payment volume through the network.
00:24:35.922 - 00:25:23.260, Speaker B: These are cool. Like DeFi ish stats that can be used. Basically this happens through a network communication protocol called Nats. So everybody is talking to each other in the Kinex network through this Nats messaging protocol. So all you really have to do to get the metrics is you have to start a listener on top of this instantiate it properly and subscribe to a subject that will let you listen for all the router broadcasts. So that's one and then basically for the purposes of the hackathon, we are hosting a testnet router which is going to be available on all these different chains. So arbitra Matic orly Rinkabee optimism.
00:25:23.260 - 00:25:58.750, Speaker B: And what we've done is we have actually minted a test token as well. So this test token is a mintable token that you can use to test very easily, cross chain swaps. And the router is already configured to swap between all these different assets. Cool. So that's about it for what we're going to do here. So I'll go for a couple questions here. So who runs the nodes? Yeah, that's a great question.
00:25:58.750 - 00:26:42.024, Speaker B: Anybody can run a node. So the way it works is you can run a node to become part of the network and as a node you are a liquidity provider, so you provide your own liquidity and you have to run the node yourself. So it's a little different than something like Uniswap where you can provide the liquidity and anybody can provide the liquidity and all of it is aggregated into one pool. It's a little more along the lines of something like e two staking where you have to stake the ETH and you have to run the node yourself. And the staked ETH has to be like sitting there on your own private key. There are public ones. Yeah.
00:26:42.024 - 00:27:28.616, Speaker B: So this is the main public one that I'm talking about. This is the testnet one. We also have a main net one, and the whole idea is that we want to abstract that part out of the developer. So another question. Say if one of the node doesn't have enough liquidity and I'm trying to transfer an amount more than what the node contains, can multiple nodes fulfill my request? Answer to that is, it's in progress? We have not fully got that. We're still kind of in the process of building that part out. So right now, one router has to fulfill your request, and that becomes a problem because the router can, in cases, run out of liquidity and we have to rebalance it.
00:27:28.616 - 00:27:32.030, Speaker B: But these are problems that we're working on right now.
00:27:40.080 - 00:27:47.650, Speaker C: Did the Arbitrage example work or how long did it take for that Arbitrage example to process and how successful was it?
00:27:48.580 - 00:28:28.990, Speaker B: Yeah, so Makoto did that for a hackathon. So it's currently not working right now. It was working. So it takes about 30 seconds ish for the whole end to end thing to work, depending on the speed of the chains and whatnot. But between Maddox and BSc, which are really fast chains, things are happening pretty quickly. Since he built it as a browser based app, it was a little more like latent and had some issues. But the next step for him to do this properly would be to actually build it into using a server node and do it all on the back end.
00:28:28.990 - 00:28:47.670, Speaker B: He was able to do some ARBs with smaller amounts of money, but currently the liquidity situation on some of these L two S is not that great. So when he tried to do it with a little more substantial money, he was kind of hitting slippage issues.
00:28:49.160 - 00:28:56.870, Speaker C: Okay, and what's wrong with the current? You said that it's currently not working. Do you know what's not working on it? Was there a change?
00:28:57.480 - 00:29:06.056, Speaker B: It just needs to be updated to our latest stuff. Like, we've changed some things on the router side that need to be ported over into the browser side.
00:29:06.238 - 00:29:07.770, Speaker C: Okay, thank you.
00:29:08.380 - 00:29:25.404, Speaker B: If it's useful, yeah, I can work with him to try to get it up and running again. I think it'll be a good example. Yeah. And of course, on the sponsored chat, we'll be there to answer any questions. Can even help answer questions about this stuff.
00:29:25.602 - 00:29:27.532, Speaker A: Hands on too with your build.
00:29:27.666 - 00:29:30.640, Speaker B: Yeah, exactly. Help. Hands on with builds.
00:29:31.860 - 00:29:59.544, Speaker A: Awesome. Thanks, guys. We're getting out of time, so I will invite everybody to keep asking questions in the sponsored channel. Rahul and Victoria are going to be there and happy to help you. Thanks so much, Aral, for this great presentation. And Victoria as well. It was lovely to have you, and I'll wish you a great rest of the day.
00:29:59.742 - 00:30:09.910, Speaker B: Thank you, guys. Yeah, really good. Yeah, we'll be hanging around looking at the chat, like, all day and all, please. Yep. Talk to you guys soon. All.
