00:05:27.570 - 00:05:30.738, Speaker A: You these nodes.
00:05:30.754 - 00:06:34.620, Speaker B: What exactly does that mean? It means that you need essentially a server running 24/7. Is that going to be an old computer? Is that going to be a Raspberry pi? Is that going to be a rack server? You're going to put that in the cloud? Are you going to be able to make sure that you can securely access that? Are you going to figure out how to know that if your demand grows? There's a lot of work that is completely unrelated to someone building a smart contract on Ethereum when it comes to actually standing up the infrastructure needed to get your applications out to users. But wait, what about like, clients? Unfortunately, while I'd love for them to exist, they're not really here for web browsers yet. They still need to handle a bunch of complex behavior in communicating across the network. And they offer a considerable amount of latency and bandwidth costs for historic lookups. And they always will, unfortunately. And so incomes your RPC service, this is what MetaMask uses whenever you use it to talk to an application.
00:06:34.620 - 00:07:16.310, Speaker B: This is what ledger smart contract integration uses. And Trustwallet and guarda wallet and myether wallet and basically every web app that you've used. But what exactly is it stands for remote Procedure Call. What happens is messages are communicated between the application and the node. In JSON, nodes expose it via Https API as well as WebSockets. It provides the lowest technical barrier of entry for application developers. Almost everything can communicate strictly through JSON and Http.
00:07:16.310 - 00:07:57.410, Speaker B: Who handles this? Was the miners now validators? It's a little outdated and sorry about that. Is this what Gas is for? No, it's not validators can choose to serve RPC, but they have no obligation to do so on the network. There is no on chain incentive for nodes to service applications with RPC. Even though it's the primary way that applications interact with the Ethereum blockchain. There's off chain solutions that we can use. Private entities have really stepped up to fill the need. And some examples of these are infuria Alchemy Anchor.
00:07:57.410 - 00:08:43.918, Speaker B: While these are accessible, they're all centralized and require monthly fiat payments to keep that application live and running. Typically the only solution for smart contract developers. And this is really the only way that smart contract developers who don't have the know how to manage infrastructure are able to interact with the blockchain until pocket network. What are we? We're an independent blockchain with a native token called Pocked and node runners can come onto our network and earn Pocked for servicing RPC. Relays apps can stake up that Pocked to get access to that RPC layer. What this does is it provides a utilitarian market for blockchain infrastructure. It makes RPC permissionless and decentralized.
00:08:43.918 - 00:09:27.360, Speaker B: It all sounds neat, but how does that help you as a developer here? One thing is you have less risks from outages. Pocket nodes run in a pretty variety of configurations we have people self hosting their own hardware, running computers right out of their worker home office. Some people choose to host up on cloud providers AWS, Azure, DigitalOcean, all the works. There's services that offer rented hardware directly that we have no runners run on. Talking here OVH, IBM, Cloud, Bare Metal, it's not really running in the cloud. They're renting that hardware directly. This makes Pocket resilient to outages at the cloud provider and data center level.
00:09:27.360 - 00:10:03.558, Speaker B: Also gives you the availability for the first time to own your access. Once an app is staked on the network, that relay rate is locked in. As long as that app remains staked. What this means is there will always be some guarantee of service as long as you keep those tokens locked up. What that means for you as an app developer, you don't have to worry about that monthly bill coming in. You can't accidentally run up a massive compute bill charge without realizing it because your users decided to go cog wild on the interface. You can recoup some of that initial infrastructure investment by unstaking and selling.
00:10:03.558 - 00:10:49.690, Speaker B: In short, with Pocket Network Web Three, infrastructure becomes an investment and not a return cost to end developers. So let's get started with what you can actually do at the gate. We offer a free tier through our portal so that you can get started right away. Building today. It's an application that we've built on top of Pocket Network. It's available directly at Portal, pocket Network, and it gives developers the user experience of the centralized options that they're used to building with today. Gives them a dedicated RPC URL, gives them security configurations for how they protect that URL, gives them dashboards about any meaningful metrics about where that service is flowing through, gives you alerts when you're approaching your bandwidth limits.
00:10:49.690 - 00:11:35.654, Speaker B: And the free tier is currently offering it's a quarter million relays a day. And it's as simple as going up, getting started, registering, creating an app. You have all that data available to you on an application page, your availability to set up security, set up your notifications, and you're ready to get rolling once you have that URL. So let's actually see how, when you get that URL, how you use it. We'll start with solidity development environments. If you're building a smart contract, we'll get Hard Hat as a popular example. It's as simple as in your Hardcat config JS file specifying in your networks mainnet.
00:11:35.654 - 00:12:30.422, Speaker B: Here example is our ETH mainnet endpoint and specifying Robston. Just drop in that Robston URL that you get from the Portal, rinkby and Gorely and COVID. All right, there that when you run anything in Hard Hat, you can just network specify the name you're running in that live environment. So you're building in Truffle. It's very similar in your module exports, in your networks, basically the same thing, except you have to specify that the port it's going through is 443 because it's SSL protected and you have to specify the network ID of the chain. But that's normally something that you have to do with trouble anyway, but just as easily. Take that format drop in the URL, you have Robs in your environment, you have Rinkbee, you have Gorely, you have COVID.
00:12:30.422 - 00:13:27.438, Speaker B: Again, just as simple as network and your network of choice, and you're running live with us. You can deploy, you can test, you can run queries everything that you would do from the console right to the network remix, say you've never really built with us before, and you want to just drop it in and start using us in a more IDE environment. All you have to do is navigate to that Deploy and Run tab, select Web Three provider from the drop down, and then put your endpoint in right there. And you're good to start deploying with us and testing with us in Remix Live as well. So now let's say you're using Pocket, but in a JavaScript front end in Ethers. It's as simple as specifying your URL and initializing it in their JSON RPC constructor and you're good to start making queries directly to the chain. Rebut web3 JS just as easy.
00:13:27.438 - 00:14:23.440, Speaker B: Take that URL, just start using it right on the chain. Rebut Python. If you're building something that lives in the back end, take that URL and drop it into Web Three Pi's constructor and you're good to start querying that chain. What about if you're not a DApp developer, but you're still interested in the space, you can use us in your MetaMask. All you have to do is select add a network from the drop down, enter in the public RPC information that we offer a variety of, and then you can repeat that for any of the chains that you interact. With MetaMask with including we have Avalanche, public RPCs, Gnosis, public RPCs, Fuse, Polygon, a whole variety of public RPCs that you as a user, not even as a developer, can take access of. These are available on our docs under our resources, we have a public RPC endpoint for you.
00:14:23.440 - 00:15:12.250, Speaker B: Additionally, let's say you're a developer who's not just building on Ethereum. I'm sure there's a lot of you here today. Here's an example of how you can quickly leverage us to not just build on Ethereum, but throw in optimism on Polygon as well. It's as simple as taking those endpoints and dropping them where you need to. That could again be in the solidity development environments, that could again be in any of your libraries as long as they work in a JSON RPC provider or in any of those environments, you're good to get rolling on those networks too. Currently, right now we have a full list of honestly now pushing close to 40 blockchains, some of the big ones that come to mind that we recently integrated StarkNet, Optimism, Avalanche. We have a whole variety and it keeps growing.
00:15:12.250 - 00:16:05.730, Speaker B: And so what we're going to encourage you today is that if you are building anything with us or if you're building anything this weekend and you need to deploy a smart contract, you need to build an interface to it. We're offering a $2,500 price pool split between any developer who deploys something and utilizes us, and we encourage you to. This link will take you to essentially what we ran down today and even more about how to integrate yourself in various uncovered programming libraries in case you're not a JavaScript or Python dev, as well as some other smart contract development environments like brownie and apeworks. So I'm excited to see what you all build. I'll open it up. Anyone? Just questions?
00:16:14.910 - 00:16:15.660, Speaker C: Yeah.
00:16:17.150 - 00:16:19.274, Speaker D: What's the sign of, like, an outage.
00:16:19.402 - 00:16:21.790, Speaker E: From the DNS.
00:16:25.250 - 00:16:27.594, Speaker D: On the RPC URL?
00:16:27.722 - 00:16:28.562, Speaker F: What's the stop?
00:16:28.696 - 00:16:32.386, Speaker D: If there's, like, a DNS outage on.
00:16:32.408 - 00:16:39.460, Speaker B: That, it's like a global DNS outage. We're talking yeah, I mean, that's a good question, but then we're now talking.
00:16:41.350 - 00:16:48.760, Speaker D: About, let's say, the DNS for that URL that were provided through, I guess through the app.
00:16:50.090 - 00:16:52.486, Speaker G: Are we hosting that or in the.
00:16:52.508 - 00:16:55.734, Speaker D: Portal, it provides the URL, right?
00:16:55.772 - 00:17:20.680, Speaker B: Yeah. What the portal is, is I can go back there. So the portal is an application that's built on top of Pocket directly. What that means is what that means is the portal under the hood is leveraging pocket network to kind of give that UX development layer to developers.
00:17:22.700 - 00:17:23.208, Speaker D: Okay.
00:17:23.294 - 00:18:01.890, Speaker B: Yeah. The portal is not pocket network. It is built on top of pocket network, but for a lot of smart contract developers or people building interfaces to smart contracts to actually kind of rotate through every hour the list of providers that you can receive service to changes. So every hour, each application gets a list of 24 providers that they can receive service from. And so for someone who's used to taking a URL and putting it into their D app, it's a lot harder than maintaining that rolling infrastructure, but under the hood, it's not fundamentally tied to that.
00:18:04.100 - 00:18:04.850, Speaker G: Okay.
00:18:07.700 - 00:18:39.724, Speaker A: You anyone else? Thanks, Jeff.
00:18:39.772 - 00:18:40.128, Speaker F: Awesome.
00:18:40.214 - 00:18:43.130, Speaker B: Thanks, everyone. Looking forward to see build again.
00:19:33.470 - 00:34:12.006, Speaker A: She go silent shall be like change my it Christ jesus. It's Jill house next. Chill house. It's the moon in the night it's the sun in the light shining bright bring me joy in the sky you always forever you want me here's, Sam? You right now? Oh, yeah. In a sweet time, let's come together. I get you it's right you it's like you try to find a place we can find, we can make now we can't run again never count again never count again never count again let's count together right now oh. Yeah in a sweet time let's come together right let's come together right now oh, yeah, you know sweet company let's come together right now oh, yeah let's come together let's get, let's get let's get oh, yeah and I know where you been tonight and I know she don't treat you right who are you supposed to be? Don't go back home so drunkenly saying that you want to make love to me.
00:34:12.006 - 00:35:38.740, Speaker A: I know why not? Your commodity taking me for granted. Now you got to leave. I don't want to hear your apologies. No more lies. Oh, yeah oh, yeah oh, yeah oh, yeah and I know where you went tonight and I know you don't treat you right maybe you do it to yourself if you ain't happy by my side, you go by someone now who are you supposed to be? Don't go back home don't drown to me saying that you want to make love to me, not you.
00:35:39.270 - 00:35:42.500, Speaker H: Okay, well, we're going to do this, but.
00:35:51.270 - 00:35:52.066, Speaker A: Okay.
00:35:52.248 - 00:36:12.778, Speaker H: Tonspanol, buetra, bueno, nosotros, bamosa, saraquito and tones, citrine, Preguntas and espanol iguanaspo and BUSCAR i, lesbian responder. But for today we're going to be doing kind of like the presentation in English and we still will try to share some resources in English and hopefully in Spanish soon.
00:36:12.944 - 00:36:14.700, Speaker C: So do we start?
00:36:15.070 - 00:36:26.766, Speaker H: Okay, cool. Well, so hello everyone. I am Diego. Lisarazo. This is Caldwell. Okay, I didn't picture that one. Okay, there you go.
00:36:26.766 - 00:37:10.718, Speaker H: So we're going to be talking a little bit about Coinbase, a little bit about Coinbase products. And Taylor is actually going to take over a little bit almost at the end for some demos. So I think that's kind of like really the important part, especially if you're hackers and you're going to be doing some hacking during the weekend with Coinbase products. So well, you see our pictures there. We're developer relations engineers. I think that's kind of like a long title just for saying we're developer advocates or developer evangelists and yeah, that's it. Okay, so this is light for me kind of like the important thing that is kind of showing is the transition between web two to web3.
00:37:10.718 - 00:38:18.610, Speaker H: And we're going to be talking a little bit about that at the very beginning because obviously not only the technologies change, but right now we're kind of like an interesting point, especially with web3 in terms of the maturity of the technologies that we are using in our day to day. So quite likely when you are creating a new DAP, you're going to be facing some well or using some technologies that could be in alpha state beta or that six months from now could change completely. So that is kind of like an important thing. The other thing has to do about kind of like the change in mentality of how things are done between web two and web3. And I think well, Taylor was going to tell me this is a good example has to do with AWS, specifically that right now on web two, because it has been around for so long, you can expect that almost everything works. You are not really thinking about what you are using. You are just solving the problems that you want to solve as a developer and then immediately spin like a new instance of whatever and it's going to work.
00:38:18.610 - 00:39:24.120, Speaker H: It's magic and it's only magic because it has been there for quite some time and you rely on those things, you already kind of like expect that things are going to work and you don't really think much about that. On the other hand, web Three, almost everything is well being created right now and that's going to be a big part of what our team at Coinbase is going to be working on now. So this is a little bit how at Coinbase we see what we are trying to do. So right now there are different parts of Coinbase, so retail, institutional and all that. But at the end the team that we're part of that is Coinbase Cloud. We have seen that we have that layer that is quite important in between the protocols and the business kind of like value that we're going to give developers and you see and we're going to mention them and we're going to kind of COVID a little bit some of those specific parts with data access, staking, trading identity. So today we're going to especially mention payments, although we're not going to focus there.
00:39:24.120 - 00:40:32.222, Speaker H: The important thing is going to be around Wallet and around Node that even this week, even today was the announcement for new features with Wallet, right? So specifically today and Node was launched two weeks ago, which I think it's amazing. And is this the one for Node? Yes. So this is something that I really like and is because the Node team spent a lot of time trying to simplify the entire experience for a developer to start creating a node and to start working with it. And that is going to appear in Taylor's demo and you are going to be able to go to the free tier during this weekend, create a new node and immediately you're going to be able to start writing, reading from the blockchain and you are not going to have a lot of effort. This is really kind of like click go and you are ready to go. A lot of people ask about like, hey, right now the free tier is Ethereum if you want to kind of work with one of the other blockchains. I think it's 25 last time that I heard from Sri that we have already working.
00:40:32.222 - 00:41:12.182, Speaker H: What is it that you do? That's pretty much the moment that you kind of talk with us and then we kind of let you have access to that if you kind of show us that you're going to work with that. But if you're going to have just like a project that you're going to create during the weekend, you're still going to well use ethereum and you have the free tier, which is amazing. And then you can pretty much be ready to go. Okay, so this is wallet. Okay, cool. So that's the other product that we're going to be talking about that we're going to have a demo. So obviously if you're going to create a DAP, you need a way to kind of sign your transactions.
00:41:12.182 - 00:42:07.398, Speaker H: You need to integrate it and that's pretty much a big part of the demo showing you how you can easily use Coinbase Wallet and integrate it into your DApps. Okay, so I think I'm already kind of giving you ideas for what you can do during the hack and we're going to mention that the challenges that we have. So if you start creating, well adapt, start having a project, an application that you are using Coinbase Node and you integrate or integrate and or you don't have to do both, it's pretty much what fits what you need using Coinbase Wallet, then by all means go ahead and do it. Like I said, we have new features that were released today including testnet. So we're going to go through that. I think there's a slide with that so we can show you. And I see that some of you are taking pictures of some of the slides.
00:42:07.398 - 00:42:51.850, Speaker H: So then you are going to be able to do that. This is for Pay, so we're just going to mention it here. This is something that if you want to pretty much kind of like do the entire on ramp, you also can use. But this is not the focus really for the hackathon. We just wanted to mention it there because obviously Coinbase Cloud is growing for once and we have more products. It's just that for this particular event we wanted to highlight Coinbase Node, Coinbase Wallet, but you have more. So my recommendation is that during the weekend if you have the time or after the hack, go to the documentation and you're going to be able to learn more about all the products and of course try to figure out how is it that you can use it in your day to day projects.
00:42:51.850 - 00:43:46.186, Speaker H: Okay, so these are kind of like well, I was mentioning about the different products. So here you can see a little bit about that. So data access, identity payments, I think for today pretty much we're going to be covering those two. So obviously with Node we're going to be focusing on the data access and with Coinbase Wallet you're going to have cover identity. But like I said, we have more than that and I encourage you to just go and check them, all these products. And I think this is something, this is complete and unashamed advertisement and is because we have some of the people from the Coinbase Node team right here and one yeah, like over there. And really one of the things that why we're collaborating and participating in these events is because we need your feedback.
00:43:46.186 - 00:44:36.294, Speaker H: Okay? So whenever we have a new product, whenever we have a new idea, of course we get excited about what we do, but we have all these resources at our disposal at Coinbase. But perhaps what we're thinking about is not exactly the same thing that you are doing in your day to day. So we don't want to kind of throw features like crazy without really covering what you are doing without helping you in your day to day. We are providing tools that you need to use and if you don't use them then, well then we're not doing a good job. So we need your feedback and a big part of the challenges that we're going to present at the end have to do with that. We're going to pretty much give you money if you use our products. But a big part of that is for you to give us the feedback.
00:44:36.294 - 00:45:05.494, Speaker H: Get your hands on, get dirty, find the bugs, find the things that you like, the things that you loved and the things that you hate. Because we know that, well, no product is perfect at any given time. We always can improve it. So it is important that you give us that. Okay, so obviously let's leave this link there for a second. Although at the end we are going to show like a QR code that you guys can go to. But if you're interested in learning more in general about the products, this is the place to go.
00:45:05.494 - 00:45:35.566, Speaker H: From there you can go to the documentation, from there you can get to the samples, from there you can create your Node account that I think are you going to create it from zero, the account. So Taylor is going to show you how to create account from zero. And pretty much 15 minutes after you leave this presentation you are going to have already a Node account running and you're going to be able to read and write on the chain. Of course. That's it. Well, there you go. No demo.
00:45:35.668 - 00:46:01.960, Speaker D: Yeah. So let's dive into some demos. So the first thing I want to demo today is the Node product that Diego talked about. So Node is our product that allows you to spin up and self serve nodes to read and write data from the blockchain. You can do it in a matter of seconds. All from the Cloud console that we have on our Coinbase Cloud website. So let me just exit out of this real quick.
00:46:01.960 - 00:46:49.070, Speaker D: So if I visit Coinbase.com Cloud, you'll be visited with this that says get started with Node. So you can click that and it's going to prompt you to actually log into a Coinbase account. So after you log into your account, you are now at the Cloud console where you can select a bunch of different products that you want to start building with. Today I'm going to show you how to build with Node. So here's the console. You can go up here and create a new project and start for free.
00:46:49.070 - 00:47:19.028, Speaker D: Today we announced support for Gorely testnet. So everyone here that's hacking away and wants to hack away at a testnet, you can use coinbase node on the Gorely testnet. So start free here. You can give your project a name. So I'll just name mine Tanode. And down here on the drop down, you can select a network. So once you do, that node is spun up for you and you're ready to go.
00:47:19.028 - 00:48:21.156, Speaker D: You'll be prompted with a modal that provides user credentials. So a username and password. These are your authentication credentials that you can use to actually read and write data from the blockchain using our endpoint. If this was for your project, you would want to go ahead and copy these to a secure location and then click Next. And then the next part of the modal actually shows you a code snippet that allows you to make your first request using our endpoints. So if I copy and paste this right now in a terminal, let's see. So spin up a terminal paste in that code snippet and it looks like I have a protocol error, but I'll show you a setup that's actually set up properly using postman in a second.
00:48:21.156 - 00:49:20.100, Speaker D: So that shows you how to make your first request and you should get back a valid response and then you're good to go. So after you create your node project, you'll have the dashboard full of different metrics so you can see how many requests are being made to your endpoint and stuff like that, how much traffic you're getting. Here I have a postman collection that has all of the different APIs that you unlock when you do spin up a node. Using coinbase node, we provide a set of advanced APIs that allow you to make complex queries to the blockchain. So if you're used to building applications by using native Ethereum APIs, maybe you've written code to get a bunch of transaction history for addresses or get NFT collection data. And you notice that it requires a lot of different requests. You have to get the contracts, the IDs, you have to put them all together in code with nodes, advanced APIs and NFT APIs.
00:49:20.100 - 00:50:09.110, Speaker D: You can do all of that using just one simple request using our endpoints. So here I have a postman collection and I have our endpoints for balances and allowances. This first example, you can see I can make one single request and get token balances for multiple tokens and multiple addresses at the same time. In this example, I'm retrieving data for USDC and Dai token for a single address. So I can go ahead and click Send here and you'll see that I get data back for multiple tokens just using one request. Going even further, the API endpoints do support both ERC 20 tokens and ERC 721 tokens. So if you are building NFT applications, you can use this as well.
00:50:09.110 - 00:51:30.880, Speaker D: And then as I go down the list, you can kind of imagine what things you can build using these endpoints. For example, the endpoint I just use right now to get token balances, you can use to build an asset page or asset menu for like a wallet application. If you want to build on that wallet idea, you can have a transaction tab within your wallet to get all of the wallets past transactions, who sent what to who and what transactions failed and succeeded. And to do that, you can use this endpoint here called Get Transactions by Address, where all you simply do is pass an ethereum address to this endpoint and you can get all of the transaction history in a paginated manner using a single request. So here you can see me grabbing transaction data for a single address and it provides a bunch of different data, things like transaction hash, the to and from addresses associated with the transaction, the token transfer data and stuff like that. We have another set of endpoints that are associated with contracts. So a lot of the time you want to read and write data to a specific contract, such as getting the total supply of the contract, or the name of the contract, the symbol, stuff like that.
00:51:30.880 - 00:52:13.076, Speaker D: It's all on chain data. But when you read and write or when you read the data from the contract, each of these is an individual request that you make. So what our contract APIs do is it allows you to get all the token metadata in a single request. So you can see here I query for token data for USDC token and I get the total supply of the token, the name, the symbol associated with the contract itself. Taking it even further, we supports NFT contracts as well. So here I'm getting the data or the on chain data for CoolCats, which is the name and the total supply. Now, when we talk about NFTs specifically, a lot of the data associated with them isn't on the contract itself and we store it off chain.
00:52:13.076 - 00:53:06.290, Speaker D: That's because storing data on chain can get quite expensive. So for that, if you're building something like NFT Marketplace, we have a suite of different NFT API endpoints that you can use to get NFT metadata. So if you're building a marketplace, you can query to list a bunch of different collections based on a collection or a contract address, you can get data for a specific collection to get deeper data for that collection. So here I have data for Mutant Ape Yacht Club. So things like the address, the name, the description, the symbol. We also do something cool where we take the image data for the NFTs and we cache them for different sizes. So there's their original size, the large size, small size and stuff like that.
00:53:06.290 - 00:53:43.350, Speaker D: And then building on the NFT Marketplace example, if you are building a marketplace, you probably want to be able to display NFTs and who's trading what, and a past. History of who's owned this NFT. And to do that, we have an endpoint for getting collection activities. So that's kind of a high level overview of the different advanced APIs and NFT APIs that Node unlocks. These are all available for both Ethereum Mainnet and Ethereum Gorely testnet. Yeah, sure.
00:53:47.560 - 00:54:37.144, Speaker H: I think I lost my well, one of the things that I really like, and this is again a little bit praised to the team, is that the first time that I was kind of like checking everything about Node, I was just kind of like using, well, curl. That's how I was kind of like checking all the requests when I was doing my little tests. But one thing that I really like that I think it would be really useful for you during the weekend is that if you go to the documentation, there's a section that is just sample requests. So it already kind of covers most of the big case scenarios that you're going to have. Of course, if you want to go into the details, the documentation is there, but these ones you can copy paste. And of course, because I was just using Curl, I was in my terminal that I don't have my Mac here. So now I cannot do it, or at least not how I would like to.
00:54:37.144 - 00:55:20.100, Speaker H: I really love the fact that because you have that little request that you can copy, then you can go to postman just like how Taylor was doing, and you can import that entire thing. So you could change just like, well, your credentials and you immediately can modify it if you want to. And then on postman, I start making a request. So I thought that it was one of these small things that the team did just to make the life of developers think. I thought that it was really cool when I figured out because I didn't know about that and I was like, just send on the terminal, blah, blah and then, oh, there is a better way to do it that is already covered. And sometimes those small details kind of show how much the team cares about that experience that they are trying to create for you as developers.
00:55:22.120 - 00:55:49.820, Speaker D: So reading and writing data from the blockchain is probably the first thing you want to learn as a developer. And you'll carry that skill with you throughout your journey as a Web Three developer. And we're here to make it super easy and super simple. Another key primitive to Web Three development is identity. And for that we have our Coinbase Wallet. Coinbase Wallet is a self custody wallet that allows you to store all your crypto assets in a secure manner. You own your keys.
00:55:49.820 - 00:56:15.320, Speaker D: Coinbase does not own your keys. That's a small confusion that some users have. So Coinbase Wallet, just to give you a little bit of context, I'm going to exit out of this slide real quick. Coinbase Wallet is our self custody wallet. It's a multi chain wallet, so it supports all layer one EVM chains as well as L2 EVM chains. So arbitram optimism, polygon. We support it all.
00:56:15.320 - 00:57:08.772, Speaker D: In addition to this, we support Solana, which is not EVM chain. And here you can see an example of Wallet. We have a few cool features for both users and developers. So the first set of features is that our assets page lists or assets from across all the chains. So if you have, let's say, Matic from Polygon and USDC and Ethereum or Solana, you can view all of your assets in one simple view. If you're a fan of collecting NFTs, we also have an NFT tab and close to instant NFT indexing built into our wallet. And then if you're a trader, you like to do some native DeFi trading, we have a DeFi tab as well for you to do that all embedded within Wallet and then moving on because I know we're talking to a bunch of developers right now, you probably care about the developer features.
00:57:08.772 - 00:57:58.356, Speaker D: So we build Coinbase Wallet as a developer tool as well, focused on the developer experience. So we do support things like testnets. And we recently released Testnet Faucets built into the wallet directly. So if you're a developer and you're used to going to different web applications to grab some testnet assets and you have to sign in with your social media accounts, you can instead sign up for Coinbase Wallet browser extension today and actually go directly into the settings, visit Testnet Faucets, and then click the testnet that you want to get testnet assets for. And then I'll just do it live here. And yeah, so you can basically get testnet assets sent directly to your wallet. So we currently support Gorely and Rinkbee, which is soon to be deprecated.
00:57:58.356 - 00:58:59.404, Speaker D: But yeah, let's just see if that sends Testnet. I'm actually not going to wait for it. So continuing on with the Coinbase Wallet demo, so you can see why Coinbase Wallet is a really cool product and why a lot of people would want to use it, not just users, but developers themselves. So I kind of want to show you today how you can integrate Coinbase Wallet support into the DApps you build and all the applications you build so that you can support this ecosystem of users that are actually using this product. So to do that, I'm going to go here and I have an example project. Just going to wait for it to load for a second. Okay, cool.
00:58:59.404 - 00:59:42.570, Speaker D: So here I have an example, very basic react application. It doesn't do much right now, it just has a simple button and displays some data. So it displays connection data such as the connection status of a wallet, the wallet's address, and what chain ID that they're connecting with. So right now the button does pretty much nothing. Now to integrate Coinbase Wallet into your DAP, what you want to do is you want to download Coinbase Wallet SDK which will allow you to integrate Coinbase Wallet in a very simple way. So to start with that, I'm going to go down here in my project and add Coinbase Wallet SDK as a dependency. If you're using Node or you would probably want to do like NPM Install or Yarn add.
00:59:42.570 - 01:00:24.756, Speaker D: So here's the code for basically what's rendered on the right. It's very simple. It's just a simple react component that has some state data where we store some state. And then down here we render a button and have a function called Connect that doesn't really do anything right now. Now when you connect a wallet to your DAP, we have this concept called a provider. And what a provider is, is it's an API extraction that allows you to read and write from the blockchain most wallets. So Coinbase Wallet, MetaMask, Trust Wallet, they'll all inject the provider into your web browser that allows you to use it to interact with the blockchain.
01:00:24.756 - 01:02:23.418, Speaker D: So in order to get that in our project, what we need to do is create a new file called Provider and then 1 second and then I have a code snippet here that allows to define a provider and get that provider from Coinbase using Coinbase Wallet SDK. So just going through the code real quick here, I import Coinbase Wallet SDK into my project and then in order to get the provider to start sending and signing transactions, I can instantiate Coinbase Wallet by passing it some of my app name and its logo. And then there's a handy function called Make Web Three Provider that lets you retrieve that. So now that I have this file, I'll go back to my main application file and I'll go ahead and I'll import that's. And once we have the provider in our application, we can then use it to actually make requests to the blockchain. So what I'm going to do now is I'm going to go to this empty connect function that is connected to our that is connected to our button and I'm going to replace it with a snippet of code. So our new code Snippet, what it does is it calls that Get Provider method right here to get the provider.
01:02:23.418 - 01:03:02.650, Speaker D: And then we use that provider to make two requests. The first request is to get the user's account that they would like to use to connect to their DAP with. And the second one is to read the chain ID that they're connecting with. So once we grab these, you'll see down here I store them in state. So set account, set chain ID, and then whatever stored in state will be displayed on the right. So now that I updated the Connect function, if I go over here to the right and I click this button, this Connect Wallet button, you'll see Coinbase Wallet pop up and ask if I want to connect. So what happened there is the provider just called the request to request my account.
01:03:02.650 - 01:03:44.630, Speaker D: So if I click Connect, I should now be connected to the DAP. And now the DAP has access to my public address and can make signing and sending of transactions on behalf of. So that's how you pretty much implement or integrate Coinbase Wallet into a DAP. It's pretty simple, just takes a few lines of code. There are a few open source projects that take this a step further. So if you want to support multiple wallets within your app, not just Coinbase Wallet, you can use open source tools like Rainbowkit, Wagme, web Three, react Web Three Modal. They all use Coinbase Wallet SDK and what I demonstrated under the hood.
01:03:44.630 - 01:04:36.646, Speaker D: And then as well, you also get support for other wallets as well so that you capture a wide variety of users. That's how you integrate coinbase, wallet. I just want to harp on the fact that Coinbase Wallet is a we're focused on making it a developer tool. So we did integrate built in testnet faucets. So everyone who's hacking today and tomorrow and throughout the weekend, feel free to grab some testnet ETH for Gorli testnet and just it's as simple as downloading Coinbase Wallet extension. I did want to call out our prizes that we have going on throughout the weekend as you're attending the hackathon. We do have a bounty of $10,000 split up between builders that are willing to use our Node product and our Coinbase Wallet product throughout the weekend.
01:04:36.646 - 01:05:44.682, Speaker D: So if you're building, consider building using Node as a product and it'll allow you to be eligible for our $6,000 prize pool. And then if you're interested in integrating Coinbase Wallet or demoing it as you do your demo, you'll be eligible for the $4,000 prize pool. And everything I demonstrated from Node and Coinbase Wallet are all available at this link that you see up here. It's a build with Coinbase Cloud workshop so it'll teach you how to make your first request using Node and how to set up Node and also how to integrate Coinbase Wallet into your DApps. I also want to call out that we do have a QR code up on the screen right now and you can go ahead and take a picture of that and it'll lead you to our link tree which has feedback forms of your experience using our tools. So we'd love to hear feedback on what we can do to iterate on all of our products. So whether you have feedback on Node Wallet or any of the Coinbase Cloud products as you're hacking over this weekend, we'd love to hear your feedback.
01:05:44.682 - 01:05:47.600, Speaker D: So please visit that QR code.
01:05:49.730 - 01:06:05.426, Speaker H: Yeah, and that's pretty much what we had for presentation. I don't know if we have time for QA at the end. Not I don't know how or it was just the 30 minutes. Okay, well, they're still not kicking us.
01:06:05.448 - 01:06:06.786, Speaker D: Away, kicking us out.
01:06:06.808 - 01:06:58.594, Speaker H: So we're still saying the only important thing that I want to mention is that we're going to be around here. And since we do know that we have also local developers personally, I can also answer questions in Spanish and we have some technical people here directly from the Coinbase Node team that can help you if you are interested in, well, solving any issues that you may have during the hacking. But in general, I think the best recommendation that we can give you is to go there and specifically with Node because it just asks for an email. So you can create an account right there, like on the free tier and it's going to take you just a few minutes. And right after that you can start pretty much doing what Taylor was showing you. So it's not a lot of effort for you just to get your hands on the product and immediately start figuring out how to integrate it with your existing projects. And of course we have the challenges.
01:06:58.594 - 01:07:07.318, Speaker H: So if you are interested in getting some money, then that is your opportunity to do something during the weekend. So that's pretty much it.
01:07:07.404 - 01:07:07.846, Speaker G: Yes.
01:07:07.948 - 01:07:16.554, Speaker D: It looks like we're out of time. So if you guys have any questions, feel free to meet with us. We'll be available throughout the weekend to answer any questions you guys have with our products. But yeah, thank you.
01:07:16.672 - 01:10:57.994, Speaker A: Thanks. Return this 130 minutes right there's. SA can't get you out of my head, boy I just can't get you out of my head, boy think about It, y'all lam you. I Just can't get you out of my head, boy don't. I think about I just can't get you out of my head, boy. More than I can think about. Think about la house mix, mix, chill.
01:10:57.994 - 01:13:25.220, Speaker A: House mix, mix. Sam me. I'm moving, I'm moving, I'm moving, I'm moving, I'm moving. Sam baby. WA.
01:16:41.100 - 01:17:43.272, Speaker C: So hi, everyone. My name is Nicolas and with my colleague Nikolai also, we're going to present and explain this motive of the hackathon working for Sigma SDK, doing stuff, funny stuff. With Sigma SDK, the first thing I want to ask is how many people here speak Spanish? Okay, a lot. So, okay, so what is Sigma? So, Sigma basically is cross chain interoperability protocol allowing general message passing, but also LC 20 and NFD transfer. So with our SDK and with our infrastructure, you can relay message, you can transfer tokens, you can transfer NFTs cross chain between EVM compatible networks.
01:17:43.336 - 01:17:43.950, Speaker G: Right?
01:17:46.000 - 01:19:32.780, Speaker C: So the basic idea here is that you have chain A and chain B and you have Sigma in between. And then of course, you can transfer the most popular formats. I would say RC 20 LC 721. And we use this acronym, GMP and GMP. It stands for General Message Passing. Okay, so lagi SK puerto infractutura para constraint application across chain transferring tuno, elosomo Digamo, funcionke, algoma complexion de liquid, et cetera. So Sigma okay, also with our infrastructure we have also our SDK.
01:19:32.780 - 01:21:45.220, Speaker C: So of course all of this is open source. And with our SDK. The main idea is to allow developers that usually are familiar with JavaScript or TypeScript to build cross chain applications in an issue like ne cross chain yasea lotipico in defy token erase NFTs general number contrado cross chain message. Passing poem basic tomar deamonto NoTOR repositories corona locals connectors in factors EO muto bamatar joe inigalai presenter para consulta quercar duda so we have a faucet UI so you can get tokens from this faucet and also we had so it's pretty straightforward. You just go to this URL and you get the tokens in case you want to use DevNet. You get the tokens and then you can do whatever you want. You can pay for your NFT transactions or transfer.
01:21:45.220 - 01:23:05.036, Speaker C: Sorry. So yeah, it's pretty like there is not too much hassle to do this using DevNet and Faucet UI. And the main idea, the main bounty prices for this hackathon is tier one is to build or showcase something using general message passing and this is the amount that we are giving for this. And also there is this tier two price in this case is utilizing Sigma SDK and showcase something with NFTs or SC 20, whatever your imagination can, I don't know, build. Now I would like to explain a little bit in more technical terms. How can you use our stuff or SDK and our infrastructure to build cross chain applications? So I'm going to show some code snippets, then I'm going to show you a demo of an NFT application and then I'm going to try to run live demo of RC 20 transfer. So yeah, I hope demo got behaves well with me today.
01:23:05.036 - 01:23:56.620, Speaker C: So basically for you to build with our SDK, you need to provide addresses because of course you need to know who are the contracts that you need to connect. And this is our standard configuration to use our SDK. So you define this stuff like domain ID, the network ID in this case is the chain ID of a node and then you provide the addresses. If you run our local setup, addresses are provided after everything is running. So you have this and then you can plug this and use it locally. So I would say it's a seal environment. So you use SDK locally and with the infrastructure locally.
01:23:56.620 - 01:25:19.844, Speaker C: If you want to use our DevNet, of course you have to go to our resources and get the addresses of our contracts and then you plug these addresses in this setup format and of course you define for instance here the RPC URL and in this case the RC 20 token, the address, et cetera. If you want to deposit. For instance in the case of RC 20, if you want to transfer some tokens from one network to another, besides of course the setup you need to initialize connections and in this case we have two separate ways of doing this because of course this SDK works in the front end and also in the back end. So if you want to do stuff or if you want to transfer tokens in the front end, you just initialize connection from web3 provider. In this case you are going to use MetaMask provider. So MetaMask is going to carry out approval and all the actions behind the scenes with the account. And of course, since in our infrastructure we have a fee structure, you need to get the fee in order for you to then do the deposit.
01:25:19.844 - 01:26:37.796, Speaker C: Because our entry point, and I think this is one of our advantages or entry point for our application is the deposit on the bridge. So you need to provide this fee and in order for you to provide this fee you just need to fetch this fee data. In the case of our local setup, fee data is like a constant and you get this and then you can play with it. And of course in the case of DevNet also fee is already provided so there is no miscalculation. And then of course you do the deposit and you define these parameters, amount, recipient address and fee data. And after that you should see if you are running for instance, infrastructure in your machine, you should see the logs of the message being carried out to the other network. Okay, so in el caso de la configuration para transferri tokente Sencia director local docker LePro directiones? Yes, I directiones.
01:26:37.796 - 01:28:57.000, Speaker C: Implemental opponent in etophedo you deni laurelle del nodo iconesso basic mano Quenta ketinique loma Portante del contrado caso dengrado. El Punto andra the locate locate crossito K as a Referencia al deposit on el puente. El contra de puente caso tinnko Oyame a porende quark employee claro. So for LC 721 it's kind of the same configuration but you add this SC 700 and 2100 address, of course again another address and it's like there is no much change in terms of what you are calling. You're always calling deposit method and you're always providing in this case, recipient address, basic fee and in this case the amount represents the token ID. So in a way transferring S 320 and NFTs kind of behaves the same in our SDK. So this is an advantage in a way that we don't want to provide different APIs or a lot of methods and we want to in a way make a developer's life easier.
01:28:57.000 - 01:30:05.260, Speaker C: And for this we have this straightforward way to use our SDK. In the case of generic handler it's a little bit more, I would say complex but still straightforward since from this week we have our contract is permissionless, meaning that you just register the resource. In this case resource is the function that you want to call in another network and then this registration make the function available for everyone and you need to provide this sort of format for the data. And the most important part of this is of course metadata depositor in this case is the address who is doing the deposit and then execution data. And execution data are the bytes that correspond to the arguments of the function that you want to call in the other network. And then again, it's straightforward. For instance, in this case, deposit function signature.
01:30:05.260 - 01:31:06.740, Speaker C: You can get this using web3 JS or Etherjs, providing of course the abi of the contract. And then you just trigger another chain. So you just call this, create generic deposit data and you provide this signature, the deposit function signature, the address or your contract in the destination chain and other parameters that are describing our documentation, like max fee deposit or address. And of course the data in this case, the color that I went to transfer and then using our contract, you just do again a deposit. So again, it's really straightforward, nothing really changed. Provide domain ID in this case for destination chain and deposit data. And deposit data in this case is going to be bigger because you are not just transferring an asset like an NFT or SD 20, you are transferring like a function call to another network.
01:31:06.740 - 01:31:45.260, Speaker C: There is like questions up to this point. Preguntas. Okay, if you have questions, you can ask me later. Okay, no problem. La transactions. Roberto no. Say yaga.
01:31:45.260 - 01:31:49.820, Speaker C: No, I Digamo incompetent.
01:31:52.680 - 01:31:53.430, Speaker A: It.
01:32:02.120 - 01:32:38.290, Speaker C: Another question. Or ota perunta. Okay. And I don't want to extend more because I want to show you how everything works. So first I'm going to show you the video of this is our NFT example that we have in the SDK. It's like pretty bare bones, it's super basic and simple, but it allows you to check the code and then see how easier is to use our stuff. So I'm just going to press play.
01:32:38.290 - 01:33:21.484, Speaker C: Okay, so what you see, of course you have the front end application, right? You are doing stuff with MetaMask. You are doing the transfer with MetaMask. You have of course the DevTools with the logs. And this in the right corner is our local infrastructure. So this docker image that you just run and you have nodes and relayers working for you with contract addresses. And then you wait a little bit because of course this is really fast, but of course it doesn't happen right away. And those logs that you are seeing right now are the logs of the relayers.
01:33:21.484 - 01:33:53.400, Speaker C: Relaying the message to the other network. So we should see a result in the transfer complete. So we managed to transfer one NFT to the other network. And this example, as I say, is currently in the GitHub repo. So you can just clone, install and run it. And it's pretty straightforward. I'm going to try now to run like a demo of the RC 20.
01:33:53.400 - 01:34:31.190, Speaker C: So I hope everything works. So here I have our local setup and I'm going to run it with Docker. You can also use there is a make command to do this, but since I like to tweak a little bit the Docker file, I always ended up to using docker. So now our infrastructure is running. And here is the example of the RC 20 application. Also like a really bare bones application for transferring tokens. So first we're going to run this command called Mint RC 20.
01:34:31.190 - 01:35:07.630, Speaker C: So what I'm going to do now is going to mint some tokens, 99 for me, then to transfer. So okay, everything went smoothly. Now I'm going to run the server. Okay. So demo god, please. Okay, so we have this bare bone application. And you can see that we have 99 tokens to this account.
01:35:07.630 - 01:35:45.080, Speaker C: And then I can try to transfer one or whatever. We can put, I don't know, eleven because we have a lot. So you get this message because you are getting first the fee as I show you in this code snippet. And then if everything works great, we confirm the operation. And I'm going to try to put this no. Okay. Of course.
01:35:45.080 - 01:36:16.530, Speaker C: Demo. Want to put it aside? Yes. Okay. So there is an issue. I'm going to try again. If not, you can check the repo. So but I don't have access to this.
01:36:16.530 - 01:37:07.382, Speaker C: Okay, so let's try this. I wanted to show you the locks, but since this screen size is kind of weird okay, so first getting the fee and yeah, so confirmation. And let's wait for it. So here are the logs. Now you are seeing the logs of the transaction being carried out from one node to another. So these are the logs of the relayers. And that's it.
01:37:07.382 - 01:37:30.938, Speaker C: So simple. It's pretty straightforward. This is our SDK. This is the main idea that we want you to get excited about. It like build with us. Build what in your imagination, a cross chain application looks like. And use our open source code.
01:37:30.938 - 01:38:06.084, Speaker C: Use our SDK, your infrastructure, your DevNet. And we are going to be here. So if you have, I don't know, questions, doubt, if you want to debug stuff, we are here to help you. So, yeah, I think that's it. Thank you, questions. You are the next. Okay, thank you.
01:38:06.084 - 01:38:10.020, Speaker C: So we are going to be here. Check us in the ChainSafe bounty.
01:38:43.720 - 01:38:58.320, Speaker E: I don't know if it'll work. That's fine. I'll be typing a lot. Yeah. Thank you so much.
01:39:10.650 - 01:39:11.510, Speaker A: Mirror.
01:39:27.280 - 01:39:49.964, Speaker E: All right. So I think that's the best resolution we're going to get, but that's all right. How are you guys doing? Thank you so much for coming. You guys having fun or what? Welcome. All right, so quick introduction. My name is Kevin. I actually work full time for a Web 2.0
01:39:49.964 - 01:40:07.940, Speaker E: company, NGINX. You might have heard of them. Most popular web server out there. But I also am a part time developer advocate for Scaffold ETH. Thank you. And I work basically in the build guild. If you're not familiar with Build Guild, it's basically a group of developers that like to build on Ethereum.
01:40:07.940 - 01:40:38.130, Speaker E: Most of them are fond of Scaffold ETH, which I'm going to be talking a lot about today. And I also have a nonprofit that I've founded in California just to kind of educate people about blockchain, specifically Ethereum. I'm also a mentor for Growic, which is a free Solidity track if you're interested in that. It's a free track and it's basically an eight week cohort where you can learn more about solidity. And I'm a photography and filmmaker. You'll see me running around, I'm actually shooting photos for the event today. So anyways, that's my contact info if you guys want to follow me at all.
01:40:38.130 - 01:41:01.476, Speaker E: So what is scaffold ETH? So most of what I'm going to be doing today is actually a demo. But I just want to give you guys a brief kind of overview of how it works and what you need to get kind of going and get set up. You need Git, obviously, because you need to be able to check out the repository. And then you need Node JS and yarn installed. Node JS is pretty much the prerequisite. You need at least version 16 or above. So make sure you have that.
01:41:01.476 - 01:41:21.400, Speaker E: Make sure you have the newest version of Yarn. Don't be using like an old version of Yarn on Linux. There's this kind of old version of Yarn that doesn't work properly. So just get the newest version of Yarn and then you'll be good to go. That's really the only tools you need to get going. It's going to spin up Hard Hat for you. So Hard Hat is like one of the main components to Scaffold ETH as well as React.
01:41:21.400 - 01:42:05.772, Speaker E: So it's going to spin up react for you and it's going to do a lot of the magic that you don't have to worry about, like setting up a hackathon project or any web3 Ethereum based project can. Be a hassle because you got to spin up all these different programs and make them talk to each other and figure out how you're going to inject your abi into react. And yada yada, everything's kind of already done for you. And I'm going to kind of show what that kind of looks like. And then everything obviously that I'm going to talk about today is based on Solidity. So we're compiler contracts in Solidity and that is pretty much the smart contract language of choice for Scaffold ETH. So if you're a developer, how do you spin it up? So the first thing you're going to do is clone the repository you're going to do.
01:42:05.772 - 01:42:46.516, Speaker E: Everything is based on Yarn scripts. If you're not familiar with Yarn, Yarn is really awesome because it is a package manager, but it also allows you to run these cool kind of command line scripts with simple commands so you can be like Yarn. This yarn, that yarn whatever. So Yarn Install is going to do all the dependencies for you and install all the prerequisites. So you don't really need to figure out what version of this particular React you want to use or Hard Hat it's going to do that for you based on the current version of Scaffold ETH. And then you're going to run Yarn Chain that's going to spin up your blockchain hard Hat right running locally and then you're going to run React on Localhost 3000 using Yarn Start. So it's Yarn Install, you only do that once.
01:42:46.516 - 01:43:34.260, Speaker E: Yarn Chain to spin up your block chain, yarn Start to spin up React and then you do a yarn deploy. And what that is going to do is going to use Hard Hat to take the there's kind of like a hello world smart contract I'm going to show you. We're going to start toying with it and it's going to ship it and deploy it and that's going to also automatically inject the Abi. So if you don't know what an Abi is, it's basically the way that the smart contract, your front end can interact with that smart contract in a way because obviously when you compile down your smart contract into bytecode it's not human readable specifically. It's not readable from your front end either. So as you interact with your application, pretty simple, you start to form blocks and you can start testing, right? And every time you do a deploy it gets a fresh copy of your smart contract and we'll show what that looks like as well. So that's pretty much all the slides.
01:43:34.260 - 01:44:10.084, Speaker E: I don't like doing slides because slides are pretty boring so let's just get right into it. So if you do a search for Scaffold ETH, the first one is going to come up is going to be the GitHub repository. So the primary repository for the actual Scaffold ETH is here. At Scaffold ETH there's also this challenges directory which is linked to the Speedrun Ethereum challenges which I'm going to talk about in a second. And then there's some examples as well. So the cool thing about it is you can find like ERC 721 example, you can find an ERC 1155 example. There's pretty much an example for everything you need to know or need to build on top of.
01:44:10.084 - 01:44:44.400, Speaker E: So it's a great starting point for hackathon projects, right? You don't have to worry about injecting the open Zeppelin contracts. They're already pretty much set and ready to go. It's even got a little bit of a front end going for you. It's already got Ethers JS hooked up, it's already got your API plugged in, yada yada, everything's kind of set up. So if you like, as an example, let's just say you went to Scaffold ETH examples and then you did a search here. You could type like ERC there's an ERC 20 demo, there's a simple ERC 720 111 55 and you can kind of pick and choose from that starting point. And that's a perfectly valuable starting point for your hackathon project.
01:44:44.400 - 01:45:23.496, Speaker E: Okay, but we're going to be focusing on Scaffold ETH, the actual main build. And that's where you should really if you're just like, toying around and building, you're going to use that. By the way, all the instructions of everything I said is going to be inside of the repository as well. So, like, the yarn install, yarn chain, yarn start, and pretty much everything I'm going to go through today is in here. So don't feel like you have to follow along. I'd rather you guys just kind of watch me do it, and then unless you're really good, you can follow along. And then after you get Scaffold set up, I always recommend people, if they're still learning to go to Solidity by example and copy and paste stuff from Solidity by example into your smart contract and start testing.
01:45:23.496 - 01:46:06.468, Speaker E: That way, once you get comfortable with Solidity, that's when you'll say, okay, well, I want to test my abilities. This is outside of, obviously, the hackathon, but when you want to start learning more, Speedrun Ethereum is a great resource. Now it's basically like a set of challenges that you go through. And real quickly, challenge zero is you build a simple NFT. Challenge one is you build a decentralized staking app, a token vendor, a dice game, and you go through and eventually you get invited to the Build Guild. Right? And then you can actually start kind of being part of the Build Guild community. And then obviously you get access to special chat channels, too, as well, where you can talk to the developers and the other builders and kind of work together to kind of solve these challenges.
01:46:06.468 - 01:46:20.252, Speaker E: It gets really hard after challenge four, so if you can get through these challenges, it's a lot of fun. All right, that's enough shill about that. But this is a good scan this if you want to know anything about Scaffold ETH. All the links for Scaffold ETH are in this one. Hi. Hello. Card.
01:46:20.252 - 01:46:26.288, Speaker E: So if you're interested in that scan that I'll give you guys just one quick second, and then I'm also going.
01:46:26.294 - 01:46:27.810, Speaker D: To give a POAP away.
01:46:28.420 - 01:46:59.164, Speaker E: So come see me afterwards and I will bring this up and you guys can scan the poops as well. Okay, so let's get going here. I use tmux. I don't know if you guys are familiar with tmux, but it's basically like a terminal multiplexer. It allows you to have more than one window open at a time. You can do this in multiple windows, but the general rule of thumb is you need, like, three windows open when you're working with Scaffold ETH. Okay? The first window is pretty much where you're going to do the yarn and install.
01:46:59.164 - 01:47:11.176, Speaker E: So you're going to set up, install the dependencies. I've gone ahead and done that. It takes a little bit over a minute to do. Okay. But once you get it set up, you don't have to do that again. You're good to go. Then all you have to do is do a yarn chain.
01:47:11.176 - 01:47:32.070, Speaker E: Yarn chain is going to spin up the Hard Hat node. It's going to run on Localhost. That's it. You can pretty much leave that window open all the time. I like to have it just here in the corner because you might use Hard Hat console to print stuff to that console. And you might want to debug your contract. And then over here in a new window in the same directory, you're going to do a yarn start.
01:47:32.070 - 01:47:58.248, Speaker E: So what's that going to do? It's going to spin up React on Localhost 3000. That's going to take about a minute. So we will let that do its thing. And then the last command, if you guys remember, yarn deploy, right? So those three commands, basically we've deployed adapt locally on our local host. We can see here that we saw some contract calls. Let me zoom out a little bit. We have some contract calls.
01:47:58.248 - 01:48:14.428, Speaker E: It tells us how much gas was used. We can see that React just started on the right. Now we see more contract calls and we see how much gas was used to deploy our contract. On the bottom, we even have our address. So we get this kind of like cool printout. It tells us how long it took. Let's take a look at Scaffold ETH.
01:48:14.428 - 01:48:37.044, Speaker E: So it says I'm on main net. Oh, let me disconnect from MetaMask. Okay, so this is scaffold ETH. So when you first get in Scaffold ETH, it's basically React, right? But what's cool about it is it has all this stuff already ready for you. Okay. This first app, home, you can think of this tab here. Like everything in here is like where you would build your DAP that you're actually building for the hackathon.
01:48:37.044 - 01:49:17.380, Speaker E: It's like your DAP inside of Scaffold ETH, right? And this is a special app, JSX file that's inside React and you can just build around that, right? So you can inherit all of the components that you have in React and whatnot. But what's cool is this debug Contracts folder. So what this does is essentially takes a copy of your contract and it builds like a full functional debug UI for you. So it has your variables, your functions, it has your contract address, it has the value stored in that all in this one location. And then you can really kind of test your assumptions as you're developing right in solidity. So let's take a look at what that contract looks like. So adam.
01:49:17.380 - 01:49:53.308, Speaker E: I'm going to use Adam. You can use whatever you want, but obviously Adam is just a basic text editor. And what do we got here? We got a Packages folder, and then we have a Hard Hat folder, and then we have a React folder. Okay, most of everything I'm going to show you today is really in the Hard Hat folder and we're going to be working out of the contracts folder and inside of that is your contract. So this is kind of like the de facto Hello World contract that comes with it. So we can see here that we define a version of Solidity, we define a license. We import hard Hat console so that we can do some logging to the Hard Hat console.
01:49:53.308 - 01:50:27.896, Speaker E: We name our contract and we also have like an event that we're doing that basically broadcasts the address that calls the purpose function and the string that they pass into that function. And then we have another variable that we define. And then we have the empty constructor which is not doing anything but we could do that. I'll show you about that in a little bit. And then we have Set Purpose which is a function that allows us to change that variable, right? We have this kind of like public variable here. We could change it here. Like if we say unstoppable like that and then save that and then do another deploy.
01:50:27.896 - 01:51:02.116, Speaker E: And by the way, you might want to reset and force a deploy sometimes just do reset and it will force a new contract to be deployed. So I just did that small change and then now we can look at the change here that's been changed in here, right? And so you're able to kind of just do your changes to the smart contract deploy, go back, start testing. That's obviously just a very simple test but let's get going a little further down the contract. Okay. Then we have inside this set purpose function. It takes a variable, essentially a string and passes it to the new purpose. And then we log that with console log using Hard Hat console.
01:51:02.116 - 01:51:26.332, Speaker E: And then we emit that event, right, so that we can capture the event and see that. So it's a pretty smart it's like just a Hello World. It's like the simple starter contract. Let's make some changes, let's make some interesting stuff. So the first thing you'll learn, you might want to do some kind of like access control. So let's just do like a quick kind of like janky access control. We'll make it owner, sorry, owner.
01:51:26.332 - 01:51:33.984, Speaker E: Public or address? Public. Owner equals. And we'll go back to our thing here and what do we see up here on the top?
01:51:34.022 - 01:51:34.224, Speaker G: Right?
01:51:34.262 - 01:52:11.852, Speaker E: So this is a burner wallet. The burner wallet is cool because you don't have to have MetaMask installed it's just using a browser wallet. And if you were to open up another tab, you still have access to that because it's in the browser, right? So you don't lose it. But if you were to come over here and say oh, well, new incognito window and do Localhost 3000 we would get a new instance of burner wallet because in Kineto On, right? So let's leave that open for right now because we're going to get back to that in a second. But my point is that we can just use this wallet and it's empty right now, but we can just grab some funds from the faucet clicking that button. We can even grab more funds if we want. You can grab the address.
01:52:11.852 - 01:52:39.236, Speaker E: We can come down here to the faucet and say, oh, I want way more. Let me, give me like, I don't know, thousand bucks send. I'm able to just grab those funds from hard hat, just dump them into my burner wallet so I'm instantly ready to test. I don't have to worry about MetaMask and nonces and any of that junk, right? So let's make a change. Let's grab this address and we want to do like access controls. Now we have access to this wallet. By the way, the private key is here as well.
01:52:39.236 - 01:53:21.184, Speaker E: So you can export the private key that it generates. So it's a full functional wallet, right? You can also import a private key. So if you just want to use like some one that you keep using and then let's go to the thing and let's define that variable, save it and then redeploy. Let's make sure it deploys correctly first, which it does. And then now what do we see? We got a new variable owner, right? So what we could do is say like, all right, let's make sure that only someone who calls this function here is an owner. Like an access controlled function. We could do something like a require statement, right? And we could say require that the message sender is equal, equal to owner.
01:53:21.184 - 01:54:05.888, Speaker E: Otherwise you are not allowed to call this, I don't know, something like that. So what I'm doing here is I'm just basically like toying around with my smart contract, redeploying my changes instantly. I was able to get up and running with adapt and testing my assumptions. So there we go. We have our contract, we got a new one. And then now if I want to come over here to this incognito tab, get some funds, go to the debug contracts and try to change the purpose, I don't know, to foo like this. It's going to say you're not allowed to call this, right? I've done some basic access control, right? But if I come over here and I can say FUBAR send and it lets me so good, bad, right? But let's go a little further.
01:54:05.888 - 01:54:50.540, Speaker E: Let's actually wipe out this concept of hard coded addresses and let's use anyone familiar with Open Zeppelin. Openzeplin, right? Awesome. If you don't know Open Zeppelin, got to follow those guys. The second thing you'll learn with smart contracts is inheritance. So we can see right here we can do like an import, right? We can import an Open Zeppelin contract and then we can make our contract inherited from that, right? And you'll see a lot of the examples like ERC, 20 example ERC 1120, 1155, 721 use this import and inheritance function. So let's do that and then let's save that and then let's deploy again. So instead of doing a hard coded owner, we're just doing this inheritance method.
01:54:50.540 - 01:55:16.008, Speaker E: And we don't have only owner. That's the thing we got to do is we got to inherit the modifier. So instead of using a require statement, we're using a modifier which is part of inherited access control ownable contract. But you can see what we're doing. We're toying around, let me deploy again because I forgot that. And then let's go back. But what's different now? Someone want to tell me what's different? The owner address.
01:55:16.008 - 01:55:53.140, Speaker E: It's unexpected. What owner address is that? It's just a random string, right? Well, Hardat uses the very first contract address, or I should say it has a set of 20 accounts. It uses the first account to deploy the smart contract. So what's happened is we've had Hard Hat deploy our contract, but it's hold on to the contract. Now we don't have any access control because before we had Hard coded the owner. So the next thing you'll learn with Scaffold ETH is that you need to be able to change the deployment. So if you look right below the contract folder, there's a deploy script.
01:55:53.140 - 01:56:30.640, Speaker E: And this is where when you do a yarn deploy, this is what's being processed, right? This is what's running. And you can see here that we get a copy of our contract. We set the deployer as the deployer, which is from the named accounts coming from Hardhat. And then we can see here that we get an instance of the contract. And so in this script now we have a copy of the contract here. So what we can do is call an inherited function, right? And if, you know, ownable or opens up on ownable, it has what's called transfer ownership function. And you'll even see it down here on the bottom because we inherit it.
01:56:30.640 - 01:56:57.800, Speaker E: And you can see it's right there. So now what we need to do is actually transfer the ownership of our smart contract to us. And so we can grab that address again like this. And then actually, you can see right here that I have it kind of like grayed out in there. So we can just grab that. And then here we can take the contract, call the transfer ownership and then put the address in here. So sorry, let me grab it again and then save and then redeploy.
01:56:57.800 - 01:57:16.512, Speaker E: Give it one SEC. That worked nice and fast. And now you can see that it matches again. So we deployed the smart contract called the transfer ownership function and transferred it to ourself. So that's cool. We've been able to kind of toy around with our contract. And you see how you get in this kind of loop where you like I said, you have Hard at running.
01:57:16.512 - 01:57:39.896, Speaker E: You have react open. You're testing your smart contract, building some stuff and then you just kind of start testing those changes. And you can even do things like I'll just do a couple more things here just to show you. We're done with the deploy script. So we're good. Now we have kind of access control. Let's pretend that we don't want to actually call only owner on that function because it's kind of boring to have one function that only the owner can call.
01:57:39.896 - 01:58:28.600, Speaker E: Let's make it a public function. But we could do something like let's require an amount of value is sent. Let's do 56 public price equals, I don't know, one Ether. So we can set a variable price and then we can come over here and then we can get back into our requirements, right? And we can say something like require message value which is the transaction value is equal, equal to price. Or we say not enough. Something like that, right? So now if we deploy our change oh, sorry, when I always forget this. You have to make that because we're accepting value now you got to make it a payable function.
01:58:28.600 - 01:58:50.424, Speaker E: So let's make it payable. Save that and deploy. Did I spell it wrong? I did. Thank you. One more time. But you guys can see how easy it is with Scaffold to get up and running with a project using this and start doing some changes.
01:58:50.542 - 01:58:51.032, Speaker F: So cool.
01:58:51.086 - 01:59:29.876, Speaker E: Now we have a function. But what do you see? Well, the UI is adapted and it said, oh, well, now we need to pass some value. So then you can start testing and we even have that new variable here, which is showing you the value in Way. So another thing you'll learn about when you're writing smart contracts is you need to send your transactions in Way and not in Ether. And so what this does is it kind of just gives you the variable. And if you didn't have this variable here, you could use this little cool green little icon that does the math for you, which one Ether is equal to times ten to the 18th power in Way. So what we could do is say, okay, well, now we have this function, we want to change it.
01:59:29.876 - 01:59:48.748, Speaker E: Let's set the purpose to bogata and then we have to pass in. If we were to pass one Ether sorry, let me do zero just so that doesn't freak out. And then click this little button. That would be the wrong amount. It's going to tell me not enough, right? But I could just grab this and copy this. Paste it here, send. Boom, it worked.
01:59:48.748 - 02:00:18.950, Speaker E: So now what happens with our smart contract? It has value. Now it's actually storing some value, which is cool. It's like this little vending machine, right? So we could probably write like a withdraw function in there. That would be cool, right? And then that one we would definitely want only owner, right? So we could use that only owner modifier. But let's just do one more thing that I just want to show you. With like one small change, you could do something at the very bottom of your function that says price equals to price, I don't know, times two like that. And then deploy that change.
02:00:18.950 - 02:00:41.964, Speaker E: And with one small line in the contract, you completely change the behavior of this kind of vending machine. It deployed successfully. And now if we change the thing to, I don't know, Columbia boom. Send. Now we'll see that the price adjusted, right? We did a simple modifier. Okay. So I think you guys get the idea.
02:00:41.964 - 02:00:52.930, Speaker E: It's just kind of like toying and tinkering around with your smart contracts, testing your assumptions with multiple identities, right? Multiple browsers. If you have problems and.
02:00:55.140 - 02:00:55.488, Speaker F: If you.
02:00:55.494 - 02:01:10.232, Speaker E: Have any issues, there's a telegram channel for getting problems resolved. I'll be around, I'll be shooting photos, but I'm more than happy to help you guys out if you have questions. Yeah, that's pretty much what I wanted to go over. Any questions? I'll try to get at least some time for questions.
02:01:10.286 - 02:01:10.890, Speaker G: Yeah.
02:01:17.440 - 02:01:51.554, Speaker E: Can you not do that? Yeah. Are you saying like, for a testnet? Let me kind of show you real quick. You can generate an account so you can do yarn. Here, let me open this so it's full screen. You can do yarn run generate. And what that's going to do is generate a special deployer mnemonic. It's going to place it inside of your directory, which I won't click on it, but it's right here, so it has the deployer address.
02:01:51.554 - 02:02:20.858, Speaker E: The mnemonic is in there, so you can inject that into MetaMask as well, so you have access to it. And then you can do a yarn account like this. And you can also what I would do is I have a punk wallet on my phone and it pops up a QR code for you. It goes by real fast, but you can just scan the QR, send some funds to that one. And then now you have this kind of like wallet that you have access to the private key, right? No, it's stored right here on your thing. Yeah, that's your deployer account. So, yeah, that's a good question.
02:02:20.858 - 02:02:40.862, Speaker E: I was going to show that, but I didn't have enough time and I want to be respectful of other people. I was going to deploy it. And you can also verify your contract with a yarn verify. You can do all this cool stuff. You can also do yarn surge and you can upload your DAP. Like you can build it with yarn build and then yarn surge and it'll upload it to surge. You can also yarn IPFS and push it to IPFS.
02:02:40.862 - 02:02:52.502, Speaker E: So there's all this stuff that's just already written for you. You don't have to hassle with it. Just take a look at the package JSON file and it has all the yarn commands. One more question. Yeah.
02:02:52.636 - 02:02:53.618, Speaker C: Testing.
02:02:53.794 - 02:02:56.550, Speaker D: Writing tests. Have you talked about that?
02:02:56.700 - 02:03:22.080, Speaker E: No. There is a test in there, so you can do like a yarn test, and there's a test in the hard hat test, and you can create and build around that. If I did it right now, it would fail because the test is designed for the hello world one that comes with it. But yeah, you can definitely just do a hard hat test. And I think that directory is right here. Test my test. And you write it like a normal hard hat test.
02:03:22.080 - 02:03:51.172, Speaker E: So it uses chai, basically. Hard hat and chai. Yeah. One more. So there's sneak peek. There might be a future version of Scaffolding that has foundry. There actually is one I think someone's already built, actually, that I don't think it's in here yet, but I would just keep an eye on the repository here and see.
02:03:51.172 - 02:03:57.364, Speaker E: I could actually check right now. Oh, there is one.
02:03:57.402 - 02:03:57.556, Speaker G: Yeah.
02:03:57.578 - 02:04:00.790, Speaker E: So there is one with foundry, I think. I think it's kind of like.
02:04:03.320 - 02:04:03.732, Speaker G: Yeah.
02:04:03.786 - 02:04:14.540, Speaker E: I don't know if it's been tested too much, but probably not the recommended one to use for this hackathon, but yeah, looks like there's already one. Thank you, you guys.
02:04:14.610 - 02:05:05.550, Speaker A: Appreciate it's, I think.
02:05:11.440 - 02:05:12.396, Speaker I: I think.
02:05:12.578 - 02:05:14.380, Speaker A: And this is my pointer.
02:05:14.800 - 02:05:17.244, Speaker I: Yeah need the pointer. I don't know.
02:05:17.282 - 02:05:18.780, Speaker A: I think I don't need a pointer.
02:05:22.400 - 02:05:23.150, Speaker H: Yeah.
02:05:26.540 - 02:05:27.570, Speaker A: You it.
02:05:36.020 - 02:05:37.040, Speaker I: Connected.
02:05:39.140 - 02:05:40.080, Speaker A: Joe?
02:05:48.820 - 02:05:50.690, Speaker I: Yeah. Hello. Yeah.
02:05:51.620 - 02:06:37.768, Speaker A: Hello. It. Yeah, sure. Presentation.
02:06:37.864 - 02:07:04.846, Speaker I: No. Hello. Hi. Good evening, everyone. Hi. So hello to the hackers in the house. It's really exciting to see so many builders who has arrived before the main event to build something cool.
02:07:04.846 - 02:07:29.488, Speaker I: So thanks for making it. And a bit introduction about myself. Do you guys want to stay maybe? Okay, sure. Yeah. A bit introduction about myself. My name is Tonya, working as a senior blockchain engineer at Clayton. So I am part of the ecosystem team.
02:07:29.488 - 02:08:07.892, Speaker I: So mainly building the peripherals of the ecosystem, like bridges, wallets and explorers and SDKs and libraries. So today I'll be talking about what is Clayton and what is Clayton architecture and how does it look as a protocol. And I'll also show the tech stack and some tools which we have in the ecosystem. And a quick demo on one of the feature on Clayton. And also at the end of the session, I'll provide all the resources which would be helpful for you to build for the hackathon. So since we are an ecosystem, we have many products running on the ecosystem. So if we are looking for a workshop, 30 minutes, it won't be enough.
02:08:07.892 - 02:09:05.016, Speaker I: So I'm going to provide you all the tools which we have and what all you can build on the ecosystem. So it should be helpful for the hackathon. So what is Clayton? So Clayton is an EVM based code base, mainly folk from go ethereum before four years. So since then it has been highly modified and streamlined in the EVM layer and the execution layer and the protocol layer storage layer and the Gossip layer. So Clayton is a service centric hybrid architecture, more like a POA or permissioned validator set in terms of generating blocks and validating blocks. So Clayton has a main net which is a layer one mainnet and also a L2 service chain. So service chain solution is also a blockchain where you can have independent validator set for generating blocks and validating blocks.
02:09:05.016 - 02:10:31.700, Speaker I: It's mainly for scalability and we have achieved some interoperability between the L2 side chain and the layer one main chain as well in the protocol level and in the smart contract level. And Clayton has 1 second block generation and instant finality which means a block is consensus upon and generated every 1 second which is quite fast. So here we are mainly concerned about the data consistency over data availability. If you're familiar with the Cap theorem which is in the left end, just the picture which says about the Cap theorem and since we are concerned about the data consistency, it is mainly useful for use cases like Bridging to port your sets. And Clayton has a two second round trip transaction latency. So this is quite fast and we did some tests in the main net and here are some metrics and this is the statistics compared to the other layer one blockchains and it has a two second response time and the average transaction latency is very low. So what is the round trip transaction latency? The round trip meaning the time which you submit the transaction to the blockchain and it gets processed, it gets validated and added to the block and gets propagated to the entire network and it comes back to you as a finalized transaction, the receipt which you receive.
02:10:31.700 - 02:11:16.436, Speaker I: So the entire transaction cycle, it only takes 2 seconds, which is quite fast and competitive in the industry right now. And this is really helpful in building use cases like MetaWars applications and gaming applications which requires very low transaction latency. And you can also build DFI applications and Arbitrage, et cetera. And Clayton can process 4000 transactions per second. So this is also based on the real world statistics in the main net and not in the testnet. So it can do a send transaction and it can achieve 4000 transactions per second. And for the other smart contract transactions based on the functions, it might add some overhead so it might vary.
02:11:16.436 - 02:12:06.580, Speaker I: However, we were able to achieve 2500 to 2800 transactions per second in the main net for the smart contract execution as well. And like I said, we have a service centric hybrid architecture so we have this governance council which we call as the validator set. So we have some reputable node operators in the validator set like Binance netmarble and Makeadao. And like I said, we have the service chain which is the side chain which is for. Scalability and you can interrupt with the main chain. So next we'll see how does the Clayton architecture looks like as a protocol. So since the beginning we have been on POS for block selection and particularly IBFT for consensus.
02:12:06.580 - 02:12:58.740, Speaker I: This is Istanbul Bison fault tolerance and this is mainly helpful for us to have 1 second block generation and instant finality. And we have a three node model architecture, we have a consensus layer which is the core node, and we have proxy node which is around the consensus layer. And we also have the endpoint node. So you might ask why it would matter for any user, right? But in other blockchain protocols, if you see no matter what job you do, you'll be running the entire core node architecture. But in Clayton it's little different. So based on your job, if you are a validator, you can just run the core node and the proxy node. And if you are an endpoint node provider service provider, like API service provider, you just have to run the endpoint node.
02:12:58.740 - 02:13:44.876, Speaker I: So the core node is the consensus layer where the consensus mechanism takes place and where you generate the blocks and everything. And the proxy node is like the century node, like a gatekeeper which protects the core node from resource exhaustion and from the wild internet. And this proxy node also helps the core node to generate the blocks in timely manner. And lastly, the endpoint node is the gossipers of the network. So this exposes the RPC endpoints. So if you are a developer and if you are interacting with the Clayton blockchain, you're more likely to interact with any one of the endpoint node. So you can submit transaction through the endpoint node and you can also retrieve the data through this endpoint node.
02:13:44.876 - 02:14:27.508, Speaker I: And we do first and first out transaction ordering from the mem pool. And we also have Clayton specific precompiled contracts starting from zero x three FF and it goes down like Fe, FD and so on. And we also support Ethereum precompiled contracts. So now we can see the unique features which Clayton has to offer when compared to the other blockchain. So we have an external account model, meaning we have multiple key pairs connected to a single on chain account. So what's the difference is if you take in other blockchains, you have a private key and a public key and address derived from this public key. So you have a single key pair attached to the onchain account.
02:14:27.508 - 02:15:34.132, Speaker I: But here we provide the option of having multiple key pair attached to a single on chain account, meaning it is updatable if you want to update the one single key pair. The private keys can also be updated and it can be removed and it can be added. So we have this option to have and maintain multiple key pairs. So this gives us the ability to do native multisig support. But in other layers you have to do the smart contract level multisignature and it also gives us the option to do role based access control with multiple keepers. For example, let's say you can have one keeper to just update the permissions or to add or remove the keeper and you can have one keeper just to execute smart contracts and one keeper to deploy smart contracts. So this is quite helpful because everything is on chain, you don't have to write a separate layer of smart contract and we have support for multiformat transaction model, like a separate transaction model for execution and deployment and also anchoring transactions for the side chain.
02:15:34.132 - 02:16:23.160, Speaker I: And the best feature is the fee delegation which is on chain where you can delegate the fee to a different person. So if you're developing a D app and if you don't want the users to pay themselves for the transaction, it can be delegated to a different person. So if you take the other networks, they achieve this fee delegation using a relayer network. So what they do is they write the logic in the smart contract and do some crypto signing magic and send to the network and the relayer network will pay the fee. So it is like a huge complex process but in Clayton everything is done on chain. So if you want to do a fee delegation so you can just sign the transaction and send to the fee payer. The fee payer will in turn sign the deployed transaction and execute the transaction and pay the fee for it.
02:16:23.160 - 02:17:19.056, Speaker I: I'll show a demo on this at the end of my session. So yeah, so we have this on chain fee delegation without having this complex relayer network and we also have cross chain checkpointing and another interesting feature is the dynamic and the deterministic gas model. So here, based on the network condition and the transaction rate, the price might go up and down by 5% but in a single block every transaction will pay the same fee. So we want to be deterministic and as low as possible. It's similar to the base fee of Ethereum but in other network you have the option for tipping and you can tip for the transaction and prioritize the transaction and you can skip the queue. But because of this the price is very volatile. But in Clayton we do not have that tipping model because we wanted to keep it as low as possible and deterministic.
02:17:19.056 - 02:17:58.980, Speaker I: However, the range is between 25 to 750 stone. So stone is something similar to guay, so you can see it's very less. So for simple transaction like send transaction, you just have to do like 25 guay and for complex transaction it won't go more than 750. So for this is a very useful feature for the D app developers, you can predetermine how much gas you will be using for a particular transaction. Now we look at the tech stack of the Clayton. So the top layer is the DApp solution where you can build any applications you want DeFi NFT or gaming on metaverse. And the next is the dev environment.
02:17:58.980 - 02:18:35.828, Speaker I: Here we can use all the SDKs and the libraries which you like. We also support Ethereum dev tools on Clayton. And the next part is the blockchain core which has two interface, if you see. So one is the Ethereum equivalent interface and the other one is the Clayton specific interface. So why we have two different interface is that in addition to the Clayton specific features like we saw before, we also support the Ethereum equivalent or Ethereum formatted transactions. So for example, let's say you're using ETH Get Balance or ETH sign in Ethereum network. You can use the same exact methods in Clayton network as well.
02:18:35.828 - 02:19:30.740, Speaker I: And you can use the same tools and same SDKs like Web Three JS and you just have to change the RPZ endpoints. So yeah, it's very easy for a DApp developer who is building on Ethereum to port to Clayton and for using the Clayton specific features like on chain multisig or feed allegation or role based access. So you can use the Clay namespace which is the interface for the Clayton specific features. And for this you have to use a Kwajs SDK which is very similar to the Web three JS. We support multiple interface as well to communicate with the clitor network. And yeah, we have pre compiled contracts for clitor network and we have a governance model with different rewarding mechanism and tokenomics. And below that we have the consensus layer and storage network.
02:19:30.740 - 02:20:24.500, Speaker I: So yeah, here are the tools which you can be using for developing your D app during the hackathon. So as a protocol, we don't want to be opinionated on what tools you should be using or what services you should be using. So we wanted to provide all the services and multiple options for you to build on. So we have a few of the tools which you can use for the hackathon today. So the first part, the wallet, we have Clip Kaikas Decent and Clayton Safe which is a multisig wallet on Clayton. So here you see all the green boxes has Clayton support and the ones in the green and blue has both Clayton and Ethereum support. We also support you can also use MetaMask on the D apps which you interact with Clayton.
02:20:24.500 - 02:21:01.216, Speaker I: And yeah, these ones in the orange we are developing and the team is working hard to release it in Q four, so it will be available soon. So the open source tools, we have a subgraph service. Subgraph service, this is like an indexer solution similar to the graph, so you can use the subgraph to fetch the data very efficiently. And this is free. So you can build some interesting dashboards on Clayton as part of this hackathon using this subgraph surface. And we also have dev sandbox. So this has all the boilerplate code for you to build something interesting.
02:21:01.216 - 02:21:35.944, Speaker I: So the thing is, we have the boilerplate code to import all the contract library and deploy on Clayton network. And we have also the front end boilerplate code which can connect to the MetaMask wallet or the in house Kaikas wallet. And we also have some boilerplate code to use the kver SDK and Web Three SDK. So you don't have to build everything from the scratch, you can just use the existing ones. And you can just have to think of some good use case for this hackathon. And we have contract library and open source decks and we also have IPFS in house integrated in Q Four. And we have SDKs.
02:21:35.944 - 02:22:02.560, Speaker I: Like I said, Caver, web3. And Web Three unity for gaming especially. And we have explorer similar to Ether scan clayton scope and Clayton finder. And we are also having an open source block Scout Explorer. So the good thing is you can download the code and if you want to propose a new feature, you can add it and get some Bounties. Or if you want, you can also build your own feature and run it on your own network. It's fully open source.
02:22:02.560 - 02:22:38.300, Speaker I: So this is a cool thing. And we have Oracles, we have integrated with Chainlink and Witnet. So even using the Oracle services you can build on the Clayton network. And we have workshops and demos on this Oracle service. In our repositories we had some workshops for all these how to use this on Clayton network, because that might take a long time, right? So 30 minutes is not enough to give a workshop on how to install and how to integrate with Clayton. So I'm just going to show all the tools available so that you can just go to the GitHub repository and just see the steps. It's very straightforward.
02:22:38.300 - 02:23:21.250, Speaker I: If you're a developer, you can just install and start integrating. And yeah, we also have RPZ API providers so you can find out some public RPC endpoints to interact with the Clayton network. And yeah, we have also bridges. So our goal is to provide the best building experience for the devs. So we tend to make all the tools as open source, like wallets and bridges and SDKs if you want to build a wallet. But since all the wallets are already in place, so you can just take the code. And if you can think of a new feature which can be integrated with the wallet, like Play to earn with wallet or anything interesting, so you can just use the code and you can integrate that feature and use it for your own.
02:23:21.250 - 02:24:10.956, Speaker I: And like I said, we have high performing main net so you can build applications which require low transaction latency and it can be easily interrupted with other networks because we have support for Bridge and Jxus, and the last is the community support. We provide KGF and KR funds. So if you have a very interesting use case. So we are also ready to support through funds and if you have some bounty programs as well, so you can contribute to the ecosystem. And yeah, so you know, now what is Clayton and how it looks like and how you can make use of the tools to build. But still, if you have some questions on why Clayton, I have so many other networks, right? So for this I'll give a very simple example. So let's take all the messaging applications.
02:24:10.956 - 02:24:57.788, Speaker I: So messaging is the same, but you have so many different applications for just the messaging, right, messaging protocol. But why do we have it? Because every messaging application has something unique to offer for you, right? And also based on the region, it has user adoption, different user adoption. For example, WeChat it's heavily adopted in China region and if you take Kakao Talk, it's adopted in South Korea. So it has a very huge user adoption as well as some unique thing to offer. Similarly, Clayton also has some unique things to offer and also it has a huge user adoption in Korean region. So first we have better usability through this transaction latency and its stability. And this on chain fee delegation, this is something interesting or something unique which you can build something interesting use case.
02:24:57.788 - 02:25:49.676, Speaker I: And we are EVM equivalent, meaning you can develop a D app and run it on Ethereum network and without much changes, just by changing the RPZ endpoint, you can deploy in Clayton as well. And regarding user adoption, since Clayton is well established in the South Korean market, so if you're developing an app, you can have more users, it's very obvious. And we have in house wallet. So this is the first wallet which is integrated with messaging applications called Cacao Talk, so which has 50 million users already. This is a custodial wallet. So even non crypto users can be onboarded very easily and they can start using your application, whichever you're building. And we also have a huge gaming company like Netmarble and Vmix running on our side chains, which is the service chain.
02:25:49.676 - 02:26:56.620, Speaker I: So, yeah, these are some reasons which you can build and run on Clayton. So now, using one of the feature, the fee delegation, let me show a quick demo. So I'm going to make a use case like having a gasless transaction on Clayton. Meaning if a user wants to deploy a contract, I'm just taking this example for today, but you can have any example you want or any use case you want to implement or to take advantage of fee delegation. So in this example, what I'll do is a user wants to deploy a contract, but he doesn't have to pay for the transaction. So I'm just starting the application and I'm just loading this. So, yeah, actually I have to connect to the wallet, which I forgot.
02:26:56.620 - 02:27:41.780, Speaker I: So this is the Kaikas wallet which I mentioned. So I connected to the wallet. So now we have a UI and here in the Kaikas wallet, what I want to show is I have a user and it has zero balance, but I'm going to deploy a smart contract with this user. So this is a sample abi and bytecode and you can have any smart contract and any use case using this fee delegation. So I've just used this because I want to show that he can do a transaction without paying fee. So now when a user initiates this transaction, he doesn't want to pay for the transaction so he can just sign it. So here you can see it's zero clay and now you got the signature.
02:27:41.780 - 02:28:36.580, Speaker I: Now I am deploying this contract. So this signature goes to the back end and the deployer who is the fee payer, he will sign the transaction and he'll deploy the transaction. So in the code, so you can just see the fee payer I have added in the env variable. So this is the transaction which we signed from the front end and here we are signing as a fee payer and then executing this transaction through the fee payer. So it's just like few lines of code. We were able to do fee delegation, meaning execute a transaction from an account which doesn't have balance at all. So if you look at the code, I mean, here we have the code for that.
02:28:36.580 - 02:29:22.978, Speaker I: So, yeah, some front end boilerplate code and some back end code on how to use the kver SDK and how to connect to the Clayton network. So you can just use this piece of code. I'll also give the resources to all these tools. So next, as part of the hackathon, you can build any of these use cases. We are mainly focusing on the MetaWars and gaming applications because we have very low transaction latency, which is good for that kind of applications. But still you can build any applications like Gamify Governance or DeFi NFT use case. But today's problem statement is you can build an implementation for any one of the following in the Clayton ecosystem.
02:29:22.978 - 02:30:23.930, Speaker I: Like you can build any tool for the core protocol and you can build any tool for the ecosystem using the subgraph service or any of the tools which I showed before. And you can also have a Dao or DeFi or NFT use case and you can also build some interactive applications using a low transaction latency because this is very much useful for interactive applications and it shows the advantage of using this Clayton network. And you can also build any mobile centric applications. So we would expect you to build on the Clayton infrastructure, be it mainnet or testnet or local Clayton node or the service chain. So now you might be thinking what you can build and what resources you might need in order to build and achieve what you want, right? So here I have given a very simple picture for a DApp developer. If you are a DApp developer and if you want to build on Clayton, here are the resources. So the front end, you can have it in React or next JS or anything you like.
02:30:23.930 - 02:30:59.378, Speaker I: It can be a web application or mobile application and it can have any of the wallet interaction like MetaMask or Kaikas or Webster Connect. So we have boilerplate code for all these to connect from the front end. And we also provide this public API endpoints. So you just need the wallet and you need a front end. And for the back end you can use any of the SDKs like Web Three SDK or KVR SDK. And this in turn will deploy the transactions in the blockchain. So for all these tools, we have the boilerplate code ready in our GitHub repositories.
02:30:59.378 - 02:31:49.990, Speaker I: So you just have to think of some interesting use case and use this to build. So if you want to build something other than the app, you can just scan this QR code which will lead to the GitHub repository of all the resources. And we also have Clayton Developer Hub website where you can look for the resources. And yeah, we have some attractive prize amount. And also all these winners will also get a biometric wallet, hardware wallet, and I'll also show the GitHub repository. This is too big, I can just yeah, so here if you see, we have some sample apps and examples for you to take it and build something on top of it. And we also have some starter kits.
02:31:49.990 - 02:32:19.760, Speaker I: So these are the API service and the public RPC endpoints, which you can use to interact with, and the SDKs which I mentioned, and the wallet code. So for all these, if you click on the specific repositories, you have the sample code and you can also integrate with Oracles. Even for Oracles we have a separate workshop in one of these links. You can just check it out. So yeah, that's it. Thank you.
02:32:44.760 - 02:32:46.176, Speaker D: Can I get an HD?
02:32:46.208 - 02:32:46.790, Speaker A: Nine.
02:32:47.720 - 02:32:48.630, Speaker D: It has.
02:32:55.480 - 02:32:58.580, Speaker C: I have HDMI, should be working directly.
02:33:45.000 - 02:34:24.880, Speaker G: One, two oh, wow, there's a cool. Hello. Welcome everyone. My name is Felix Lorpold. I'm here giving the talk that actually my colleague Nick was supposed to give. So apologies if it's not as smooth or rounded as he would have given it. And in particular, we are going to talk today about ERC or EIP 1271 and how we can leverage the smart contract order signature concept for building all kinds of really cool use cases on Cow Protocol.
02:34:24.880 - 02:35:01.932, Speaker G: I hope you guys are roughly familiar with Cow Protocol. We are a MetaDex aggregator where users place orders just by signing off chain messages. And then those off chain messages get batched together and sent off to a network of solvers that compete for that order flow and try. To find the best possible solution for the user orders, matching them together in what we call coincidence of wants, where the name Cow protocol comes from and protecting users from mev and giving a significantly better user experience. But that's kind of the background. Happy to talk also at the booth over the advantages of Cow swap. In particular today.
02:35:01.932 - 02:35:51.820, Speaker G: This talk will cover really ERC 1271 smart contract signatures. And we'll first cover a little bit the basics how Cow Protocol orders work usually and why this doesn't really work for smart contracts. We'll then talk about the easy case of smart contracts that just want to place trades on cowswap and then go one step further where we explore this concept of smart orders. So even more than just placing a boring old limit order, smart contracts can actually place really cool and advanced concepts. And there is a little demo at the end and there's some code in the GitHub repository if you're willing to hack. We have a $5,000 bounty on the best integration of a smart contract order into Cow Protocol for this hackathon. So might be worth your time to check out this repo at the end and start hacking.
02:35:51.820 - 02:36:13.728, Speaker G: So let's begin with the basics. How do orders in cow protocol work? Here you can see the general struct that describes an order. It's really like what you would expect when you're making a trade. You have to specify a sell token, a buy token. You can send the proceeds to some other receiver. You have a sell amount and a buy amount. That's basically your limit price.
02:36:13.728 - 02:37:03.120, Speaker G: You have an expiry date, you have a fee. It can be a sell or buy token. So you have a bunch of fields that represent an order on Cop Protocol. And then the way that it normally works with externally owned accounts, with your MetaMask is that the order that you are willing to sign gets hashed according to the EIP. I think 712 is the EIP gets hashed into a typed order hash. And then you, with your externally owned account, can go ahead and consign this commitment to the order that you're willing to place. And the way that signatures work with externally owned accounts is by using some fancy math elliptical curve cryptography.
02:37:03.120 - 02:37:55.524, Speaker G: You don't have to really understand it in detail, but basically you're taking two points on a curve and then have your private and your public key. And with your private key, you can basically prove that you're in possession of that private key without revealing it. And what ends up being generated is this triple RSV. It also doesn't really matter what this specifically means, just there is a way of how externally owned accounts can use their private key to attest that they are actually willing to make this trade. Now, the problem is that smart contracts cannot do that because smart contracts on Ethereum don't have a private key, so they cannot do any ECDSA, they cannot sign an order given elliptic curve signatures. So another signature scheme is needed. And that's why the Ethereum community has created what is known as EIP 1271.
02:37:55.524 - 02:38:43.312, Speaker G: I think Nick is really strict on that. It's technically an ERC and not an EIP because it doesn't need any protocol changes. But the basic way that smart contracts can prove that they are okay with something happening, the way that they prove that they are validating a signature is by just implementing this very simple method is valid signature. And that method takes a bytes 32 hash. This is basically the order hash we saw on slide three or four and then an arbitrary byte array of what can be interpreted as a signature. And that byte array can really be anything. It can be some EOA signature that maybe is the owner of the smart contract or maybe a delegate of the smart contract that is signing the hash on the smart contract's behalf.
02:38:43.312 - 02:39:49.688, Speaker G: It could be just more information that the smart contract needs to then maybe check an oracle or check some other state to decide if it's actually willing to accept the hash that is being passed into. But basically what you can think of this off is a boolean response am I okay with this hash or am I not okay with this hash? Now the return type is not boolean, it's some magic bytes four value which has some detailed history of why it's not just a boolean. But you can think of it, it's a method that says yes or no. Given a hash. Is the smart contract okay executing this signature? And so yeah, basically if we go back to the order struct we again take our concrete order that we want to sign, we compute the hash and then the thing that gets passed into our smart contract is we basically invoke signer is valid signature with that hash and whatever we decide to pass in as a signature. And so how do smart contract wallets implement this? So for example, Argent or Nosisafe, pick your favorite smart contract wallet. They don't have private keys so they also need to implement ERC 1271.
02:39:49.688 - 02:40:42.884, Speaker G: And the implementation can be specific to each individual wallet. Some wallets might use a might require the user to first send a transaction that says I am attesting that this hash is okay. So you might think of it as like a bitmap that for each hash you have a is signed or is not signed and then is valid signatures just checks for the hash if the bit is set to yes. You could also just blindly trust signatures from certain domains. So you could say if a certain, I guess member of an ENS community or whatever has signed this then I'm okay with it. Or the way that the nose is safe and I also think Arjun does it is you could because smart contracts usually have an owner, they have multiple signers. You could just use those signers as delegates and verify the signatures by just checking.
02:40:42.884 - 02:41:41.064, Speaker G: Have enough signers, have enough EOAS that own the smart contract wallet signed for the hash. And this is, for example, how the Nosasafe does it so concretely because Nosasafe is also a project very close to our hearts. We care a lot about having Kelswap work nicely with Nosasafe. The way that the signature verification on their end works is, again, you have this order, Struct, that gets compressed into a hash that you need to sign. And then the safe interface has like a certain again, named Struct for its signatures, where then each owner can basically use their externally owned account to create a good old 712 like a good old EOA signature, a good old Ecdsh signature. And then what the safe does, it basically waits for enough owners to have created their own individual signatures. So if you have a three out of five safe, for example, you need to collect signatures from at least three owners.
02:41:41.064 - 02:42:16.650, Speaker G: You concatenate all those three signatures together, and then the safe will say, is valid signature true if enough signers have signed for that hash. So this is again just a recap of how it works for the safe. You collect all the signatures, you encode them into bytes, you concatenate them together. Inside is valid signature. It just deconcatenates them and then checks for each signature. Are you an owner? If so, increment the count of owners that have signed. And if at the end, the number of signatures that have been signed by owners is greater than the threshold is valid signature returns true.
02:42:16.650 - 02:42:47.488, Speaker G: And this works in cowswap. Nick implemented a little script that you can use to actually place these gasless orders from your Nosusafe already today. Here's a proof on gurley that this works. So you can actually use Nosisafe today to place gasless or without having to pay gas orders into Cowswap. And that's already quite cool. That's a very good use case of ERC 1271, but there's even a sorry. Yeah, go ahead.
02:42:47.574 - 02:42:48.780, Speaker D: Why is it gasless?
02:42:48.940 - 02:43:32.346, Speaker G: So it's gasless because you can use your EOA to just sign the message and hand that message off to cowswap, and then cowswap will pay for the gas. Basically, you're just transferring. So you basically sign with your EOA that you want your Smart contract, your signosafe to trade one Ether for $1,300. And then you send this message off chain to our API, and our API will then send it to the solvers, and the solvers will take it and settle it on chain. And they will still take some fee from your sell amount. So it's not that you can trade on Cowswap and don't pay anything, right? Like you will still pay whatever the gas would be in ETH, but in US. Dollars from your sell amount.
02:43:32.346 - 02:44:21.458, Speaker G: It just means your EOA doesn't need to have any ETH in it. You can just use the signature. You don't need to fund your EOA. Okay, so this is already pretty cool to use your safe with a gasless. Manner to do trades, but then the real power comes when we I don't know how Nick planned to have this climax, but in the beginning you had Dex, then you had Dex aggregators, then you had Cowswap as the metadax aggregators. And today we're going to introduce smart orders, the next paradigm in this crazy climax. Okay, so the idea of smart orders is that you implement ERC 1271, similar how you just saw that the safe does it, but you can do it with arbitrary logic.
02:44:21.458 - 02:45:06.274, Speaker G: You don't actually have to check that there is some signer that has signed for it using an EOA. You can theoretically use arbitrary logic. You can check an oracle that you want to investigate that basically you're always okay to trade if the price is better than what chainlink reports or some other logic that is completely independent of any actual EOA signature. And so the way that these smart orders usually work is you create a smart contract, you deposit some tokens into it and then that smart contract implements this is valid signature method in some way or the other. So yeah, you have custom on chain logic and that's it. And so one example that we're going to go through today in this workshop is a good after time order. Good after time orders only become valid after a certain timestamp.
02:45:06.274 - 02:45:48.470, Speaker G: So you can basically place an order today that becomes valid tomorrow and you could place the second one today that becomes valid the day after. And so you could use good after time orders to implement something like a daily cost average strategy, for example. And right now in the very native cow protocol order format, this is not supported. We have an expiry date valid to, but we don't have a field valid from and so it would require to change the native cow order format, it would require to update the contracts. And so it's very painful to add this to cow protocol in its current form. But you can just write a smart contract order that basically implements this behavior. And the way you would do that is you just implement is valid signature in a way that it checks what is the current block timestamp.
02:45:48.470 - 02:46:28.562, Speaker G: And when that block timestamp is past a certain target block, you say is valid signature true? And if it's not, you say no, it's not yet valid. And so you can place this order into the order book. The order book will constantly try to check is this order now valid or not? And once it becomes valid, it will automatically take it into the current batch and ship it to the solvers and it will get matched automatically. So let's walk over the code. We'll also see it in real life in a minute, but let's just walk over the code that's required here. So this is like the construct for a good after time order. But at this point it doesn't do much.
02:46:28.562 - 02:47:20.580, Speaker G: At this point it just takes in the constructor an order hash that you want to be executing and then if is valid signature just checks that whatever the settlement contract is trying to execute is actually the thing that we have pre signed here. So this is not yet doing good after time. This is just the very basic format. You basically say here is an order hash that I'm okay executing and then it's valid signature just checks that we are indeed executing that. So now let's add cancellation because with good after time you also don't know maybe the price changes a lot from today to tomorrow and your order might no longer be satisfying its limit price. So you might need a way to actually cancel this order and get your funds back out. So here's just some random scaffolding or some small scaffolding to allow the owner of that contract to regain the tokens that they have deposited into it.
02:47:20.580 - 02:47:48.682, Speaker G: And then this is actually the part that adds the good after time into the smart contract. So we add this valid from field, we set it in the constructor saying that this order is only valid after a certain maturity date and then in the is valid from implementation, we just check that block timestamp is past valid from. If that's not the case we revert, and if it's the case we set this magic value which basically means we return.
02:47:48.736 - 02:47:49.340, Speaker A: True.
02:47:51.090 - 02:48:39.130, Speaker G: The other thing we need to remember is that the smart contract needs to have the Cow Protocol settlement contract approved. So the way that Cow Protocol works is it needs an approval from whoever is authoring the trade so that it can actually take the sell tokens from the author of the trade and then send it back the buy tokens. So we need to set an approval and then we're good to go. This is the entire code. I think it's like 30 or 35 lines of smart contract code and you have a good after time order implemented. The one thing that we added here is a factory. Because right now every user that wants to implement a good after time order needs to deploy their own instance of that order.
02:48:39.130 - 02:49:25.078, Speaker G: And so Nick also built a small factory contract that anyone can now call with basically a raw order struct and some salt just to make it not replayable. And then that factory contract will actually deploy the actual good after time contract and also do the transfer of the in amounts and basically return the order ID that has been created. Not super important. You don't have to implement this if you want to use smart orders. You could just deploy every order again and again and maybe some orders don't need to be deployed if you're looking into building an AMM or so, you just need to deploy it once. But if you have something that every user would have to redeploy, maybe a factory contract makes sense. All the code is in this GitHub repo.
02:49:25.078 - 02:50:00.440, Speaker G: We don't have to really go through it in depth, but yeah, so this is then the general flow. The trader would approve the good after time factory contract, call the place function which then does all the magic. Basically creates this good after time order instance, transfers all the tokens in, sets the valid from parameter and the order is ready. Then we just have to wait for the timestamp to be reached. So this okay, yeah. This is then the last step that is needed. Right now.
02:50:00.440 - 02:50:31.930, Speaker G: Our back end doesn't automatically identify when an order is placed on chain. So you also have to tell our back end separately. Hey, there exists an order. Please start tracking this order and please start checking. Once this order become valid, start settling it. We are working towards making this step obsolete and just having an event emitted inside the smart contract that our backend can automatically pick up. But right now you still need to call our API.
02:50:31.930 - 02:51:01.490, Speaker G: Here's how it will hopefully very soon look like you don't have to call our API anymore. Then you just emit an event and our backend will automatically pick up that there's a new order in the system that needs to be tracked. Okay, I think this is maybe now good for a demo. Yeah, this should be demo time now. So we have the repository here. I had to clone it just because it was made for Rinkabee and Rinkabee doesn't work anymore. So now it's made for girly.
02:51:01.490 - 02:52:00.090, Speaker G: So if you check out my GitHub and check for the Debcon 2022 Smart Orders repo, there is the README with the four steps you have to run. But basically what we are going to run is the place order script which does exactly what we discussed. So in this repo, you will find the good after time in the contracts repository here you'll find the good after time orders which has all the smart contract code that we showed. I'm happy to talk about the details of that also at the booth if you have specific questions. And then what we're going to do right now is we're going to place one of these orders. We're going to sell wet and we're going to buy cow on gurley and we're going to set the field valid from to be starting now plus two minutes. So basically when we place this order, it won't be valid, but two minutes later it will become valid.
02:52:00.090 - 02:52:22.954, Speaker G: Yeah, you can fork from it. You can start from scratch. Really. This is just one example. I'll have a few more examples on the last slide. But basically and we can also use the remaining time to brainstorm some ideas. I really think there's like an endless amount of design space that you can do with this.
02:52:22.954 - 02:53:11.606, Speaker G: Anything that's basically expressible in solidity. Okay, so we're going to place an order using some old account that I have that is going to create an instance of this good after time order. And then the script is going to print out the order ID of the good after time order so we can track it in our Cow Explorer. Okay, so this is the order, and we should check the time 153. So in here we can check the order. It's open, but it won't match right away because it's not yet valid. In fact, we can actually check our API and we can see that right now the auction is empty.
02:53:11.606 - 02:53:54.032, Speaker G: So that there is right now no orders that are allowed to be settled. And this is because Is Valid signature returns reverts in the current state because the block time hasn't advanced far enough yet. And so now we need to kill a minute and a half of time to see this become valid. Yeah. So the back end basically has a set of orders that it tracks and it just checks. Are these orders valid? Like, do the order creators have enough balance? Have they given allowance? In this smart contract order case, is the Is Valid signature, does it return?
02:53:54.086 - 02:53:54.448, Speaker C: True.
02:53:54.534 - 02:54:34.412, Speaker G: And so it builds periodically. Every 15 seconds, it builds an auction with all the valid orders that are currently in the system and sends it off to this network of solvers who would then go ahead and try to settle the current batch and the solvers return back, kind of their proposal of how they would settle the batch. And then the back end decides basically measures what is the best solution in terms of price improvement for the user. And the one that had the biggest price improvement gets the right to then execute that settlement on chain. And so let's start looking at the API. In a few seconds, we should start seeing the order here because it will have become there it is. So this is our order.
02:54:34.412 - 02:55:09.826, Speaker G: It's now valid so solvers can start trying to figure out how to settle it. And then hopefully this will turn into a field very soon. Suspense. 15 seconds. Never felt so long. No, this is in. So the order has been said.
02:55:09.826 - 02:55:35.482, Speaker G: Yeah, it hasn't filled. This ERC is five years old. It just got finalized this year or so. It had some minor changes, really annoying minor changes, which made it not backwards compatible, but still it didn't change fundamentally, but it got finalized this year. So we're now pretty certain that this is going to last for the future. And yeah, so basically here now, we can see the order got filled. We got a nice surplus.
02:55:35.482 - 02:56:10.758, Speaker G: This is like how normal cowswap orders would work. But yeah, basically you had this logic that made it good after time. Here's some other cool ideas. And just like just the tip of the iceberg of what we could implement with it. Stop loss orders is one other example. So stop loss orders means you're not buying when a certain minimum price is or sorry, you're not, you're not buying, you're not buying. So well, no, but you can always place it.
02:56:10.758 - 02:57:05.100, Speaker G: Basically you normally you're selling ETH when the price goes up, right? You're saying I want to sell Ether when it's like at 1500. That's a normal limit sell order. A stop loss order would be I want to exit my ETH position, I want to sell ETH if it goes below 1000 because then I think we're all doomed and we go to zero. So stop loss orders allows you to basically take the other side of like cut your losses and exit if you feel like, oh, now we're about to go to zero. And so you could use an onchain Oracle, say chain link or something to check what is the current price. Of course some trust in that price Oracle needs to be considered in the design and then decide I say is valid signature? Yes, if the price is below that and then I'm basically trying to exit my position and cut my losses. Advanced good after time use cases would be this daily cost average or time weighted average pricing where you basically allow for example, a Dow to sell or buy tokens little by little over the course of a month.
02:57:05.100 - 02:57:54.070, Speaker G: But you can also think of other cool ideas. You could, for example, implement an AMM in a smart contract order, where the smart contract has two balances, two tokens and then a constant. And you just allow trades as long as X times Y is still larger or equal to K. And this way you've built an AMM into Cowswap, which gets settled at the same uniform, clearing prices as all the other users. So you would have built an AMM that can actually capture surplus from trades unlike Uniswap where basically you get settled exactly on your X times Y equals K curve. In cowswap you would have AMMS that can actually capture price improvement and capture surplus. But yeah, basically most of these smart contracts don't require any special integration.
02:57:54.070 - 02:58:46.618, Speaker G: If the thing that you are expressing becomes a little bit too complex, you might also have to talk to one of those solvers so that they can actually understand what do I have to do in order to activate the smart contract order? But for the vast majority of use cases you don't even need that. You basically just have this on chain contract that follows ERC, 1271 and it will just work out of the box. So this is kind of the wrap up of the talk. I will go to the references. The first thing that we talked about of how to place gasless orders using Nosisafe is in the safe cow order repo from Nick and then the adjusted smart good after time order prototype is in my GitHub repository. And yeah, if you have any more questions as well, let's talk at the booth. And I think we have maybe a few minutes for questions.
02:58:46.618 - 02:59:43.530, Speaker G: Yeah, maybe like, I don't know, one or two questions if you have anything at the top of your head. But yeah, essentially, I mean yeah, so basically, I mean, Cowswap's main value contribution proposition is that it protects you from mev. So basically a Keeper, you have to pay the Keeper some fee that it basically takes your order and then it might take it still at your limit price. You're not guaranteed in the Keeper system necessarily that you're getting price improvement. Whereas on Cowswap you have everyone that is in the batch gets the same uniform clearing price. And by virtue of having the solver competition and the more price improvements a solver give to you, the more likely it is that they win. You have this guarantee that there's actually somebody fighting for you getting the best price.
02:59:43.530 - 03:00:21.120, Speaker G: But basically there's other concepts as well. We personally think that or we as a company think that cowswap is a very good way for DAOs to easily of course, somebody has to write this dow DCA order, but then it can be reused by many dows over and over again. And the dao can just say, okay, we want to build a position over the next month. Let's do it automatically. Whereas right now you have to build this. I looked at Buntek, did, a very nice example of such a Keeper contract, but you basically have to customize it for your company. You then have to find some flashboards miner or some searcher to actually execute it for you.
03:00:21.120 - 03:01:00.108, Speaker G: So I think there's some user experience benefits and then also this idea of benefiting from other retail traders that might take the other side. So basically, if you were urine and you wanted to do a buyback of YFI tokens, you shouldn't be doing necessarily the buyback against uniswap. You can just absorb sell pressure. Whenever a user wants to sell YFI, why don't you just buy it as a solver? So these are like some of the ideas. Cool. We are on the upper floor in the corner on the left. We'll have people on the booth most of the time and happy to also help people that are interested in hacking this.
03:01:00.108 - 03:01:23.730, Speaker G: We have again, two bounties, $5,000 for the best smart order or smart contract order integration, and then another $5,000 for the best UI integration built on Cowswap can be combined, of course, if you build a really nice smart contract order with a UI, then of course you can also have both bounties, which are $5,000 each. And yeah, happy hacking and hope to see you around. Thank you.
03:02:43.720 - 03:02:50.328, Speaker F: Hi everybody. Anna, am I good to go thumbs up? I think so.
03:02:50.414 - 03:02:50.920, Speaker A: All right.
03:02:50.990 - 03:03:23.908, Speaker F: Hi everybody, and welcome to our presentation on Snarky JS and the Mina Protocol. Thank you for being here. And I am Jack Servia. I'm a developer relations engineer at One Labs, which is the company that incubated the Mina Protocol. So you can kind of think of one as like consensus to ethereum, whereas Mina Foundation is ethereum foundation to ethereum. I'm based in Denver and here's kind of what we're going to go over today. So first we're going to talk about Snarky JS, which is the smart contract language for the Mina Protocol and kind of unique for a bunch of reasons we'll get into.
03:03:23.908 - 03:04:08.644, Speaker F: And then we're going to go through an example where we build a simple smart contract that verifies that the number you pass in as an argument is the correct next number in the Fibonacci sequence. Then we're going to make this recursive, which is something we'll kind of explain why that's cool later. But it basically allows you to do a lot of stuff off chain without any additional security assumptions. Then we'll talk about the Mina Protocol, which is sort of like a meta version of this. It's like a settlement layer for these zero knowledge applications and then we can talk about where to learn more and open up to questions and answers. So Snarky JS, it's a TypeScript library for defining zero knowledge proofs and it's also the smart contract language for the MENA Protocol. It looks like this, but don't worry too much about the code right now.
03:04:08.644 - 03:04:35.244, Speaker F: We'll get into it more in a minute. Everything is in TypeScript. So you can keep using the tools you're familiar with like prettier NPM vs. Code, ESLint, et cetera. And it's really easy to learn. It's actually so easy to learn that you can probably figure a lot of stuff out just with IntelliSense. If you look here we have an example of kind of a funky looking decorator and then a really good explanation of what this is.
03:04:35.244 - 03:05:05.652, Speaker F: So you can just dive straight into it and it's also extremely powerful. So this is for two reasons. One is our proof system, which is something that we've built in house. It's called Kimchi and it has a number of features that make it really well suited to a kind of application like this. It's fully trustless setup, so there's no ceremonies. We have custom constraints for poseidon, which is a hash function that's particularly efficient in zero knowledge proofs, elliptic curves and encryption. We also have constant proof size.
03:05:05.652 - 03:06:01.736, Speaker F: That's why OVone Labs is called OVone Labs and it's recursive, which means that we can generate a zero knowledge proof of something and then we can actually verify that zero knowledge proof inside of another zero knowledge proof. And so this opens the door to a whole bunch of new architectures for things that can increase scalability user experience and of course, also provide privacy. Finally, it's Plonkish, which means that we can add new features like dynamic array access, which is something we're working on. So Kimchi mostly should kind of not be something you have to worry about too much, but just sort of know that we've put as much horsepower as we can into Snarky JS and so the other side of what makes Snarky JS so powerful is actually the language itself. TypeScript method chaining allows developers to think through their programs in a very linear way, especially compared to other zero knowledge proof sort of paradigms. And so we can sort of see what this looks like. Here we have this Bool is correct color, we can just call and on it and pass in the thing that we want to and it with.
03:06:01.736 - 03:06:25.404, Speaker F: And what we get out is another Bool is white Peg and if we want to do something more complicated we just chain these methods together. And so this makes it very straightforward. Think about this is my data, this is what's going to happen to it and then this is sort of what's going to come out and it makes it easier to make sure that everything that you're doing is being sort of proved correctly, which makes it easier to write code that's secure.
03:06:25.452 - 03:06:26.050, Speaker E: Basically.
03:06:26.740 - 03:06:54.664, Speaker F: We also have custom circuit values and these have actually been we're in the process of possibly changing this to something called Struct. You can go look at the GitHub and read the RFC for this and leave comments if you want, but for now I'll explain how circuit value works. Struct is largely the same thing, just better. But even circuit values are very cool and so these provide a layer of abstraction that makes data much easier to think about than it might be otherwise. What this looks like is we can.
03:06:54.702 - 03:06:55.290, Speaker E: Take.
03:06:58.460 - 03:08:02.504, Speaker F: In zero knowledge truths. Everything fundamentally because of the cryptography has to be represented as something called a field element which is just sort of like a UN two five, six with some special properties but it's required by the underlying cryptography and so trying to represent more complicated data types in other zero knowledge proof languages can be quite hard. Snarky JS makes it fairly easy with this circuit value maybe soon to be struck, which allows you to basically describe a way to turn normal JavaScript values, normal JavaScript variables, numbers, strings, whatever into fields and then take them back from fields into something you can work with. And so in this case we have defined one called Pegs and this represents four Pegs in a board game and we can work with it sort of just the same as you'd expect. Finally, plenty of the stuff that you need is already implemented in Starkey JS. What we have today is support for a bunch of different types that are built on top of this field type. So the field type can be a little complicated to work with sometimes, but what we can do is we can actually compose field types into other things that are more familiar.
03:08:02.504 - 03:08:44.940, Speaker F: And so we have types for UN 64, UN 32, int 64, group Bool, scalar, public key, private key, signature and more coming soon, including hopefully string pretty quickly. We also have efficient Poseidon hash function, which means that we can do hash evaluations very efficiently in Snarky JS and this opens the door to things like big merkel trees and other kind of stuff like that. We have efficient encryption and decryption. So you can do things like take data well, actually we'll jump back to this in a second. We have signatures. Merkel trees are supported in the experimental API right now, which is just a namespace in the API that has stuff that's bleeding edge. And we have the Recursion API which is something we'll talk more about later in this presentation.
03:08:44.940 - 03:09:18.816, Speaker F: Signatures and encryption and decryption are unique. And I'll just sort of call them out now. Because what you can actually do with this is take a value from a trusted source, they can sign it, and then you can pass this value into a zero knowledge proof verify that it was signed by the trusted party, and then you can augment it in some way. So you could do something like prove I am not a citizen of the United States, I'm over the age of 21 and I'm not ofax sanctioned. Or you could prove the opposite. It's up to you. So why did we choose TypeScript? This is kind of a common question and the answer is because we're ecosystem focused.
03:09:18.816 - 03:10:13.064, Speaker F: So the idea is that people who want to work on tough cryptography can do this and they can put their stuff in NPM libraries very easily. And then people who want to build user facing products can import this and have access to a whole lot of power really quickly. We want to kind of get both of these groups of people working together in order to sort of really push forward a new class of applications. We're looking for code reuse that's as high as it is in the JavaScript ecosystem. The other thing that I think is worth calling out is that if TypeScript sounds a little bit like what would you say? Some people have maybe a problem with TypeScript if you're writing your front end. Writing a Snarky JS smart contract is only nominally more work. So how actually the smart contract works is actually I'm sorry, we'll dive into this a little bit more later.
03:10:13.064 - 03:10:39.424, Speaker F: I keep getting ahead of myself. For now, we'll just stick to this. So this is Snarky JS We've been through all this. How does it work? Well, here it is in five sentences. It's a TypeScript library. All the information is represented in one of the Snarky JS compatible types. So these are all composed of a field type ultimately, but like know we know how to turn that into field so everything is under the hood fields or an easier way to work with fields one of the circuit values that's composed of them.
03:10:39.424 - 03:11:16.990, Speaker F: Circuit JS provides classes and functions that are compatible with the field type or these circuit values that are composed of them. So we can do things like add two numbers together but not only can we add the numbers together, we can prove that we added numbers together correctly without revealing what they were. And this is sort of this next thing. So, Sharky JS, after we've written our program, it can represent any operations on the field. Type is what's called a Kimchi arithmetization, which is basically a math problem that represents the program that we wrote. And this is important because the zero knowledge proof system is itself kind of a math problem. And so we need to turn everything into math in order to be able to prove that we're doing what we say we are.
03:11:16.990 - 03:12:03.172, Speaker F: And then finally, a user that interacts with the Snarky JS program can generate a zero knowledge proof that their interaction was legal. And this opens the door to a lot of cool things. One of them is Snarkyjs smart contracts on MENA Protocol, which we'll dive more into in a little bit. So in this paradigm, developers write smart contracts in TypeScript and they deploy the verification key to a Zkapp account, which is just a specific kind of account on the Mina protocol. What this looks like is we write our application, we send a transaction with a verification key, which is just an artifact that's generated. You can think of it as sort of like a commitment to our code with extra features, which is that we can use this key to verify zero knowledge proofs that we generate for this code. And only this verification key lives on Mina.
03:12:03.172 - 03:12:43.784, Speaker F: So then the user will run the smart contract in their browser and they'll generate a zero knowledge proof of their know, proving that it was allowed. And then they'll send this proof to Mina. And if Mina will check it against the verification key that's stored on chain, and if it passes, then the transaction goes through. And if it doesn't, then it fails. If the transaction does go through, then it commits any of the relevant state updates that were associated with the proof. So when we do something with a Mina smart contract, the smart contract is sort of getting in as arguments, the arguments that the user passes in some smart contract state. This is the state of the smart contract prior to the user interacting with it and some values from this state of the world.
03:12:43.784 - 03:13:15.376, Speaker F: This could be like block height. And so the smart contract will actually run in the user's browser. The user will get all this information themselves, they'll pass it in and they get a proof out as well as the new state of whatever value they were interacting with. So if I want to send you money, I can literally just say I'm going to basically write to your token balance and here's a proof that I'm allowed to. And that's all that's needed. That's a rehash of that. So how do these ZK apps work? Well, you install your smart contract in your UI and then you.
03:13:15.376 - 03:13:35.876, Speaker F: Deploy it and that's all. And so, yeah, you can just publish your smart contract on NPM or GitHub or wherever. You can just NPM, install it, import it like you would anything else. And it's a part of your UI. It's very straightforward. So now we'll kind of get into an example. And this is hopefully everybody is familiar with the Fibonacci sequence.
03:13:35.876 - 03:14:05.644, Speaker F: If you're not, the last two numbers in the sequence added together equals the next number in the sequence. So one and one, two, two and one, three, so on and so on, three and two, five. So we'll write a smart contract that calculates the next number in the Fibonacci sequence. And also, don't worry if this goes a little bit, we'll be at the booth. We're upstairs on the second floor in the corner. And if this is sort of obfuscated at some point, come talk to us and we'll make it clearer. But the point is now just kind of broad strokes.
03:14:05.644 - 03:14:36.268, Speaker F: So we'll have two pieces of state that we store in the smart contract. This is going to be N minus two and N minus one. These represent the last two numbers in the sequence if we have a method. So we'll also add a method update which will let us update N minus one and N minus two if we pass in the correct number, the next number in the sequence. So in order to do this, all that we do is we extend this smart contract class into something called Fibonacci Sequence. And now we have a smart contract called Fibonacci Sequence. Then we add some state and we call it N minus one and N minus two.
03:14:36.268 - 03:15:17.272, Speaker F: We set it to the field type and we use the state decorator, which if you're not familiar with TypeScript decorators, again, come get us. They're not too hard to get your head around. But what this basically tells Snarky JS is, hey, when a user alters this value, figure out how to store it on chain and prove that we're updating it correctly. And so these numbers will be stored on chain. The next thing that we have is this deploy method. This is a method that gets called at the time that the smart contract is getting actually deployed to the chain, which is at the time we're calculating this verification key and bundling it up into a transaction and sending it off to the chain. You usually don't have to worry too much about this.
03:15:17.272 - 03:15:21.836, Speaker F: The defaults work nicely in most cases. But in this case we're going to.
03:15:21.858 - 03:15:22.430, Speaker D: Use.
03:15:24.240 - 03:15:54.550, Speaker F: This deploy space to initialize the values of our state variables. And you can do other things here too, like set permissions. Again, we won't dive into it too much, but all that we do is we call this N minus two and then we call the set method on it and we pass in a value. And in this case we're passing in field zero. Don't worry about this zero one you can also pass in field open parentheses, one closed parentheses. It does the same thing. This is a confusing kind of artifact that exists right now.
03:15:54.550 - 03:16:45.270, Speaker F: So next thing that we do is we define a method that users can use to interact with the smart contract and we just call it method. I'm sorry we call it update and we add the method decorator. And the method decorator basically says, hey, this is a thing that users are going to call when they do prove that they're doing it correctly. We can pass in an argument n, that will be the next number in the sequence. And what we do is we grab n minus one and N minus two from on chain state. We store them in local variables, then we add N minus two to n minus one and we check that the value that we passed in as an argument is equal to this addition of these last two numbers in the sequence. And so this assert equals it actually means that you will simply not be able to generate a valid zero knowledge proof if new state does not equal N.
03:16:45.270 - 03:17:32.004, Speaker F: And so there's no way for a user to call this unless they're passing in the correct argument. Now, what's really cool, and I don't know if this was sort of clear by now or not, but the value of the argument that the user passes in and all the computation that they do is private. They don't ever send it out of their browser unless they want to. So the only thing that is public is the on chain state. And you can build a lot of private applications very easily by storing a commitment to something private in the form of like, I don't know, hashing some private value and storing the hash on chain. So yeah, I guess it's not useful. In this case, we can prove that we know the next number in the Fibonacci sequence without well, in this case, I guess we do reveal what it is because it becomes n minus one.
03:17:32.004 - 03:18:21.700, Speaker F: But you get the picture. There's a lot of cool stuff you can do with this. Now the final thing that we do is we set these on chain states to we move n minus one to n minus two, and we move the new state to n minus one. This is pretty much the basic structure of the Smart Contract. We extend the Smart Contract method, we add our state definitions, deploy method, and then we add the user callable methods and add the method decorator to them. So what's really cool about this architecture is that we can actually make this recursive. And what this means is that right now, the current Fibonacci program that we just built, every time a user wants to interact with it, every time a user wants to do something, they basically have to create a transaction, send it to Mina, pay the fee and wait for it to be mined.
03:18:21.700 - 03:18:45.580, Speaker F: This is what's really cool about recursive zero knowledge proofs. They allow you to move away from this in really interesting ways. So we had smart contract, but we also have ZK program. And ZK program is what it sounds like. It's just a zero knowledge proof program as opposed to sort of a zero knowledge proof program. That's also a smart contract. And so what we can do is we can write a ZK program that actually takes proofs as inputs.
03:18:45.580 - 03:19:52.928, Speaker F: So the ZK program, we run it and we get a proof out. And that proves that we ran the ZK program correctly as well as the outputs, but we can actually also pass these proofs so we can pass proof that we ran a ZK program correctly into a ZK program. And this lets you scale in really cool ways. And so I won't dive too much into what this is now because I think we'll be a little bit short on time and I want to get to Mina, which is really the sort of important part of this. But to give you an idea of why this is useful, we can basically what would you say? We can prove that we have a number in the Fibonacci sequence, and we can take that proof and pass it into another proof that verifies it. And so this can be useful for something like, let's say we wanted to take a moving average of values over like, 20 years. What we could do is we could take the moving average for the last ten minutes, prove it, and then take the moving average for the next ten minutes, prove that.
03:19:52.928 - 03:20:28.204, Speaker F: But in that proof, we can also include the computation that verifies that the first proof is correct. And we can do this over and over and over again. And we can just keep one proof that attests to the fact that we've had been keeping a correct moving average for 20 years or something, and it stays very small. The other thing you can do is you can create like, well, we'll get into it in a second. So how does this work? Well, you write your ZK program, or, sorry, you wrap your ZK program inside of a proof class, and then you pass the proof as an input parameter to your ZK app to verify that it's correct. Again, this was kind of fast. We went over this really quickly.
03:20:28.204 - 03:21:16.460, Speaker F: But if you have any questions, seriously, come by the booth and stop us. We'll help you get started building something or just answer any questions you have. So this kind of brings us to the climax of the presentation, which is, what is Mina? And actually, wait, I'm sorry, I'm going to go back. I know this is very nonlinear, but another thing that we can do with recursion is we can build smart contracts that execute largely off chain. And so an example of this is like, let's say that we built a game and I don't know if anybody has heard of the game Mastermind, but this is a tutorial that we did a while ago. Sorry, not a tutorial, a workshop that we did a while ago and we have it recorded. And so at the end of this presentation there'll be a QR code that will take you to a bunch of relevant links and also that.
03:21:16.460 - 03:21:56.916, Speaker F: And so this is a game where it's limited information so I can't know what my opponent is doing, but I have to know that they're making legal moves. And so this is a game that would be very hard to build on a normal blockchain. It's very easy to build on Mina, but it goes a step further if you build it in the naive way. You have a game that you have to send a transaction to Mina every time a user wants to make a move. But using recursion we can take this and we can set the game up in such a way that I will make my move. I'll prove to you that it was correct and then you'll make your move, which will also verify the correctness of my move by verifying the proof and send your move to me proving that it was correct without revealing what it was. And we can do this back and forth, so on and so on, without ever having to pay fees or wait for a block to get mined.
03:21:56.916 - 03:22:41.544, Speaker F: So the user experience is literally like it would be in web two. And at the end we have a proof that attests to the correct computation of all of our whole game and then that can get settled on chain. So this is obviously really good for user experience and also really cool. Okay, now we're to the back to where we were with what is Mina protocol? Well, it's a layer one blockchain that proves its entire finalized state using recursive zero knowledge proofs. And because of that it stays small. You only need 22 verify basically that the current finalized chain state for an account is correct. And this is cool, but it's also.
03:22:41.582 - 03:22:42.520, Speaker G: Really useful.
03:22:44.300 - 03:23:20.310, Speaker F: For quite a few reasons. One is privacy. As we said, Ethereum smart contracts run on every node, so all the information is public. Here's what ethereum looks like. Mina smart contracts run in the browser and so arguments and intermediary values are private by default. Again, managing keeping the state private if you want to can in many cases be as simple as just hashing it. So what does this look like? We do the stuff we want to do in our browser, then we just send state updates and a proof that's it mina verifies the proof and updates the on chain state if it's correct.
03:23:20.310 - 03:23:49.832, Speaker F: Next, scalability. There's no gas model. ZK apps run off chain, which means that the amount of computation does not affect the transaction cost you can do, in theory, an unlimited amount of computation in a single Mina transaction. You can also do them asynchronously, which this presentation isn't about, but is another pretty cool feature. So, yeah, you can run smart contracts asynchronously on Mina again, come to the booth and ask if you're curious about that. So developers can use your cursion to build application specific rollups.
03:23:49.896 - 03:23:50.780, Speaker G: What are these?
03:23:50.930 - 03:24:29.560, Speaker F: Oh, well, they're what we talked about earlier. I think I kind of forgot the order of some of this. Yeah, these are applications where only the parts that need to be verified on chain are verified on chain. In many cases, you actually don't need the chain to sort of verify what you're doing. Like if you're just interacting with one other user in a game or something, really you only need to prove to the other person you're playing against that what you're doing is correct as long as you can eventually prove it to the chain. And so this is a door to some really interesting stuff. Decentralization, it's possible to validate the entire finalized minestate using only a small zero knowledge proof.
03:24:29.560 - 03:25:18.312, Speaker F: What that means is that there's no need to rely on trusted third party node operators like infura right now, ChainSafe is working on an implementation of a wallet that will basically be a full, you know, no additional security sort of concessions. And how it works is that it just uses the zero knowledge proof to verify the transaction history. Right. With Mina, we do some stuff, we prove that it was correct. So all the transactions are zero knowledge proofs. And then we take these zero knowledge proofs and we verify them inside of another zero knowledge proof. And inside of that zero knowledge proof, we also verify a zero knowledge proof that represents the last batch of transactions and that one verifies a zero knowledge proof that is also verifying the batch of transactions before that, and so on and so on.
03:25:18.312 - 03:26:14.540, Speaker F: And so what we're left with is 10 knowledge proof that represents the entire chain history and proves that it was legal for us to get to the place that we got to, basically. And so then a wallet can just, with this 22 kilobyte stub, verify that the proof is correct and know that things are right. It doesn't have to grab all the previous data and sum it all together like an ethereum node does. This is really cool also, because of bridging. So Smart contracts on other Chains can bridge the entire mean estate just by verifying the most recent proof. To get into what this means a little bit more, you can write a smart contract on another chain. And as long as that smart contract can do the math to verify the mina zero knowledge proof, then you can be sure from within that chain that whatever state route is associated with that zero knowledge proof is the legal mina state route for a given block.
03:26:14.540 - 03:26:53.880, Speaker F: So the Nil Foundation is working on one of these bridges right now? They have a demo working on one of the Ethereum testnets, but it really does work. You can go play with it here. And the result of this is that there's no quorum of, there's no multi sigs, there's none of the really confusing stuff, there's none of the really hackable stuff. There's just basically a smart contract. Anybody can interact with it. Anybody can go grab the mina state, anybody can send the mina state to the smart contract, pay the gas fees, and in one block you have got the whole most recent state bridged over. Finally Oracles.
03:26:53.880 - 03:27:21.740, Speaker F: We're working on a product called Ziki Oracles right now. And these will allow users to create TLS proofs that bridge data from any website onto the MENA blockchain. And so when you go to websites now, you get a little lock in the side of your browser. This means that we did this thing called a TLS handshake. It's like a thing that allows you to know that you're talking to Amazon and Amazon is talking to you and that nobody's in the middle listening to what you're saying. And the problem is that it's interactive. And so the protocol only really proves anything to you into Amazon.
03:27:21.740 - 03:28:20.150, Speaker F: You couldn't send it to Ethereum because it's interactive. Ethereum would have to sort of interact with Amazon for it to work that way. And so with zero knowledge proofs, we can use this interactive sort of protocol and make it non interactive. And the result is that I can prove that I went to my bank account's website or my bank's website and basically I can prove that the person@usbank.org sent whatever they sent to me and that nothing has been tampered with. And this is really cool because then we can take this information and we can do something like then augment it so I could get all this really personal information, prove that it really did come from US Bank and then just have a boolean that says, does Jack have more than $1? And get a proof that just says jack has more than $1 or Jack doesn't. And so you can make the information sort of as private as you need it to be and no more.
03:28:20.150 - 03:29:04.544, Speaker F: What else? Well, we actually don't really know everything that's possible yet. And this is what we're hoping that you guys here will help us figure out. There are so many new ways that we've found that we can do things that we would not have thought of even six months ago. And yeah, that's what we're hoping to get out of hackathons like this. We hope that you guys try new things and find new ways of doing things that leverage all of this sort of new flexibility. So what makes Mina protocol unique? All this stuff. Where to learn more? How do I get yeah, so yeah, how do I get started? Well, all you do is NPM install the Zkap CLI and ZK project.
03:29:04.544 - 03:29:32.696, Speaker F: It'll start up a repository with a scaffold code, a simple contract that will add two numbers together, and that's all that you need. The ZCAP CLI is our only piece of developer tooling. It's very simple, it's very straightforward to use, and it's very powerful. So if you want to get started, just do this. There's nothing more, really. It should take 1 minute. And you can even deploy to Berkeley Testnet, which is our testnet, I think.
03:29:32.696 - 03:29:58.484, Speaker F: We have cards at our booth that will explain how to do that. Again, should take no more than 15 minutes to get started. Where do you get involved? Well, Mina Foundation has a quarterly grants program. So you can get grants by building ZK apps, creating educational content, or mentoring. And so these are backward looking grants. So just do Google stuff and then maybe you'll get a bunch of money or some money. So here's a QR code.
03:29:58.484 - 03:30:30.460, Speaker F: If you scan it, we've got links to a bunch of the relevant stuff from this presentation. We also have our Docs website, which we just revamped like maybe a week ago. It's a lot better now. We have search and some other stuff that we'd been kind of putting off for a little bit. We have the ZCAP Developers channel in discord. This is a really great place to meet other people who are building stuff. Here's our Twitters and what else, if anybody else from Mina Foundation or Owen Labs has anything else I should add? Yeah, Yanni.
03:30:32.020 - 03:30:32.672, Speaker G: Awesome.
03:30:32.806 - 03:30:34.716, Speaker F: Yanni's got the cards. Yasin.
03:30:34.828 - 03:30:38.690, Speaker C: And we have also something called digital program.
03:30:44.740 - 03:30:57.560, Speaker A: We'Re able to build on. For example, we tested this and there were like grant Gerald also for two minutes.
03:30:57.630 - 03:31:03.910, Speaker F: I will help you. Awesome. All right, well, thank you so much, guys.
