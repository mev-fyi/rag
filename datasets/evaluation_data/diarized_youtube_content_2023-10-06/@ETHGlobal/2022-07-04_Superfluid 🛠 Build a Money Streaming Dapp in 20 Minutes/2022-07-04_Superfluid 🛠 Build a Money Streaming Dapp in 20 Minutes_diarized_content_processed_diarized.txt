00:00:06.170 - 00:00:44.460, Speaker A: Thank you guys for all being here. What's up guys? Today we'll go through what Superfluid is and then we'll walk through building a money streaming application on one of the just well known Ethereum testnets. So first and foremost, what is Superfluid? So Superfluid is a protocol which enables real time finance. Finance. So what that means is we allow you to build digital native programmable cash flows. And this includes things like streaming money with no capital lockups in a way that is 100% programmable and on chain. So one thing we think about a lot in this broader ecosystem, right? We think we're all building this Internet of value.
00:00:44.460 - 00:01:47.258, Speaker A: So what we believe is that the Internet is to information what blockchain is to value. And one place that we're trying to add value in this area is in real time finance, right? So in the traditional financial world, when you provide a service to somebody, I provide the service, and a lot of times that service is decoupled from the payment that I receive for that service. Right? So if I provide a service to you as an employee at your company, I get paid maybe once a month, when in reality, I'm providing value every single day that I work or every single hour that I work. So why shouldn't you be paid for every single second that you're working? Or if I'm providing a valuable service like I'm Netflix, or I'm providing computational services like AWS, why shouldn't I be getting paid every single second the service is being provided? Right? So that's one thing that we really help with and we really focus on. So the way that this manifests itself is through money streaming. So a money stream is a continuous payment that's native to Web three. So any recurring payment that you can think of, you can turn it into a money stream and send it on a second by second basis.
00:01:47.258 - 00:02:23.580, Speaker A: So these are like a connection between two existing accounts, be it an EOA or a smart contract address, where instead of deciding, hey, look, I'm going to send you 1000 USDC per month and send it in a single transaction once a month. I can instead take that amount, divide it essentially amongst the number of seconds in that time period, and the money will flow from my account into your account in real time. Just like what you're seeing right here. This is actually directly from our dashboard. We have like a stream details page you can pull up to see the stream flowing in real time. And this is an actual live money stream, sending real money from one account to another right now. So it's very cool stuff.
00:02:23.580 - 00:03:16.362, Speaker A: So how does this work? Right? Well, we built a protocol to enable this, and it's made up of three high level parts. We'll go through them at a high level right now and then go through how to actually build money streams using solidity and also using our SDK in a couple of minutes. So the protocol is really made up of three, like I said, high level parts. The first is the superfluid host contract, which serves as a kind of brain for the protocol, right? So things are plugged into the host contract and that helps to enable everything to kind of work together. And the other two are agreements and super tokens. So an agreement is a peer to peer financial relationship that defines how your token balance can change in real time. So the most commonly used agreement within superfluid is called the constant Flow agreement, which allows me to send you money linearly through time.
00:03:16.362 - 00:04:05.350, Speaker A: So I agree to send you a certain number of tokens per second and those tokens are just transferred to you per second. So that's cool in theory, but again, how does that work? Right? So many of you are probably used to sending native assets and also transferring ERC 20 tokens. If you're going to go back here and send money on a per second basis like this, right? How is this happening right, to you? If you're only used to ERC 20 transfers, you'd have to hit transfer every single second. That wouldn't be feasible. So what we built is an extension onto the ERC 20 standard that enables this real time balance to be calculated every second. So this new standard is called the super token, right? And like I said, it's an extension under the ERC 20 standard, so it is compatible with ERC 20s. All of the standard transfer and approval mechanisms that you're used to are all on super token contracts.
00:04:05.350 - 00:04:36.402, Speaker A: There are just extra features on these super tokens that plug them into those agreements that can modify balances in really custom and unique ways, right? Like the money streaming. So, like I said, these are plugged directly into the superfluid protocol. They're usable anywhere in Web Three, and we have two separate kinds of super tokens you can use. So one type is a native super token which just has no underlying address. This is just deployed directly as a super token. The other is a wrapper contract. So I mentioned it's usable anywhere in Web Three.
00:04:36.402 - 00:05:50.666, Speaker A: The reason for that is that we allow you to wrap any existing either native asset or ERC 20 token as a super token so that you can use it in other places as well. Right? So we wanted to value interoperability because that's so important to our space, and wrapper contracts let you do that. So, again, how does this real time balance actually work, though, right? So usually that's not quite enough to sell you on the fact that this actually is working in the way that you think it's working. And the idea here is what happens with these agreements is you define, like I said, a number of tokens you want to send per second. So all I have to do is send a single transaction to say, all right, I'm going to send Fran, for example, one token per second, right? What we can do there is calculate the amount of time that's passed before you make another state changing operation and always have this accounting in place that can make sure that you're only performing a new state changing operation with tokens that are in your balance. Right? So this is all made up of what we call a static balance. So just a token sitting in your wallet and a dynamic balance which is made up of something called a NetFlow, which is taken as the number of tokens that's either being sent to you or sent from your account every single second.
00:05:50.666 - 00:06:27.442, Speaker A: So that's the idea. If you have any more questions on that, feel free to just find me this weekend and we can walk through it. Okay? We've gone through agreements, super, tokens, real time balances. How about programmability? So you guys are all builders. We want to make cool stuff. Money streaming is cool, but you can do additional things with money streams that allow for lots of automation in really interesting applications. So you can build something called a super app, which is what we'll walk through in a couple of minutes, that allows you to implement callbacks that can react to events that are taken along with that individual contract.
00:06:27.442 - 00:07:01.374, Speaker A: Right? So let's say that you have a contract, you deploy that's a super app, and you send a stream into that contract. That stream can run any arbitrary logic as soon as the stream is created into that contract. Right? So the contract is able to react to these different actions. And the reason why this is able to happen is that it's all plugged in back to that host contract that I mentioned at the beginning. Right? So you register a super app with the host contract, which is able to then call these callbacks and react to specific events that are happening with superfluid. So again, I went through this a little bit. Super apps, these are reactive smart contracts.
00:07:01.374 - 00:07:34.622, Speaker A: We'll go a little bit deeper into this in a couple of minutes. But what this does is allows any of you here to build applications that are connecting cash flows together and building a really cool network. So what we expect to see is an explosion of these network cash flows. So this is a live depiction of a bunch of superfluid streams that are on Polygon right now. This is a live network. This is a fast growing network. And all of you here have the opportunity to build things that grow this network and ideally help connect cash flows in a really interesting way.
00:07:34.622 - 00:08:10.566, Speaker A: So we see a network effect starting to emerge here and we're very excited about it. So, yeah, I'm impressed that this worked within the keynote presentation. I was a little worried it wasn't going to buffer, but we got it okay, so that's the high level of how to build on Superfluid. Let's get into a more tactical example. So before we get into a contract that we'll walk through together, I do want to highlight a couple of developer tools that we've built. We really care about developer experience. It's hard to build good developer experience around technical products like this, but we do put a lot of effort into it.
00:08:10.566 - 00:08:43.506, Speaker A: And this is really what a lot of my day to day is built around. So one tool we'll go through is the Superfluid Developer console that lets you see any streams that are associated with your accounts. It'll let you check super token balances and it's just a really useful tool overall. We also have a dashboard that lets you create, update or delete streams without writing any code at all. It's just a good thing. If you want to open a stream to a friend to try it out, you can go to the dashboard and test that live there. We're deploying a new V two of our dashboard very soon, which is even cooler than the dashboard we have here.
00:08:43.506 - 00:09:21.230, Speaker A: But I just want to still mention it because it is important. And the final thing that you need to be aware of is that we have built some what I think are pretty good SDKs that lets you if you just know JavaScript or TypeScript and aren't maybe great with solidity yet, you can still interact with superfluid just using our SDKs. So we'll use that in just a second. But just wanted to highlight those three things. So let's build okay, what are we going to build? We're going to build a Tradable cash flow contract. So what's the tradable? Cash flow. The Tradable Cash Flow is a super app so it can react to these superfluid events and implement it does implement callbacks, which react to these events and do something.
00:09:21.230 - 00:09:57.498, Speaker A: And what it's going to do is send 100% of the inflows to the contract to the owner of the contract. And the contract is Tradable because it's an NFT. So this actually mirrors some real world financial assets. For example, if you have subscriptions, there are companies out there that let you go get revenue based financing against those subscriptions. So this is a kind of web3 native version of that where maybe you can tokenize a subscription revenue and sell it. Maybe you can bundle them together and sell it. We're not going to get into any of the more advanced futuristic things here today, but we are going to talk through the primitive of how this works.
00:09:57.498 - 00:10:31.590, Speaker A: So I'm going to zoom out here and I'll show you where you can get this exact example code in our repo and then we'll just kind of walk through it together. I'll show you how we can write some scripts to interact with the contract itself and we can move from there. So I might have to zoom in quite a bit here because I chose to mirror. But hang on, you zoom in here. Here's our repo. It's just superfluid finance protocol monorepo. And it's in our Examples folder.
00:10:31.590 - 00:10:59.726, Speaker A: You can fork it right here. You can fork it just from the main branch if you'd like. And this is our Examples folder. We're going to go into the Tradable cash flow section and the contracts we're going to be working with are going to be in here. We'll step through these two contracts in just a second. But I do also want to highlight that we have some scripts here too, that use our SDK. So you can go into the scripts folder and we're going to create, update, and delete a flow here in real time together using our SDK as well.
00:10:59.726 - 00:11:28.540, Speaker A: So you can see all this and follow along if you'd like. In this section of our repo. We also have the console up in a separate tab, which we'll show in a second. But this is really, really going to be useful for us when showing you how the streams are being created, updated, and deleted in real time. Okay, let's get into some code. So I have a cloned version of that repo right here. Let me zoom in quite a bit.
00:11:28.540 - 00:11:48.766, Speaker A: Do you guys see that? Okay, thumbs up. Good. Okay, exit out of this. Clear up some space. Okay, so we have this Tradable cash flow contract. And what is this? Right? So one, we know it's an NFT, it's Tradable. So it's going to inherit from the ERC 721 standard.
00:11:48.766 - 00:12:23.370, Speaker A: It's also going to inherit from this redirect all contract, which has a lot of this superfluid automation on that contract. We'll step through that in just a second. But in the constructor, what it's doing is it's, number one, minting an NFT to the owner that we pass. It's going to be the first argument to our constructor. It's also going to take a name and symbol standard ERC 721 stuff. And then it's also going to take the address of the superfluid host and it's going to take in the address of a super token. So we're going to keep this confined to only working with one token, but you could make this generalized and work with any super token you'd like.
00:12:23.370 - 00:13:05.190, Speaker A: Okay? And remember, the host contract is that what I compared it to is the brain of the protocol, right? So you will a lot of times when you're building on superfluid, need to pass in the host address to be able to initialize our libraries and access other things within the protocol as well. Okay. The only other piece of logic that I am implementing inside of the Tradable cash flow contract itself is this. Before token transfer hook, this is actually straight from the open Zeppelin API around ERC 721. If you guys don't know, you can also implement hooks and things that run automatically when you transfer NFTs. This is one of those things. So before the token's transferred, we're going to override the logic here.
00:13:05.190 - 00:13:41.038, Speaker A: Only take the address that it's being sent to and we're going to call this change receiver function and pass that address in here. Okay, so what this is going to do is anytime I transfer the NFT, I want the cash flows that are coming out of the NFT to go to the new owner, right. The cash flows should follow the NFT. Makes sense. So let's go into this redirect all contract because this has the meat of the logic. So what's happening here is I'm just importing a lot of the superfluid stuff we need for working with the protocol. The big one that I'm importing is the CFA library.
00:13:41.038 - 00:14:14.894, Speaker A: This is going to make it really easy for us to create, update and delete streams in solidity with really just a line of code. It abstracts some of the lower level stuff away and ideally makes it much easier for you. We also import this super app base contract, which will make this a super app. And the reason why that's important is because we need this to have those reactive elements to it. We need to be able to implement the callbacks that will run on certain events. That's the idea there. So at the top of this contract, we are going to initialize a library using this syntax here.
00:14:14.894 - 00:14:53.254, Speaker A: So using the using for stuff that you're probably used to with importing libraries. And then what we do inside the constructor is pass in the superfluid host address that token we want to use. And then the receiver which is just going to double as the owner of the NFT, it's going to be the initial owner that the NFT is minted to. So we run a couple of checks here to make sure that we're not passing in the zero address for any these things. We assign these variables like we should. We initialize the CFA library as this CFAV one lib variable. And this final thing we do here is register the super app contract with that superfluid host contract.
00:14:53.254 - 00:15:36.742, Speaker A: So this lets the superfluid host know, hey, look, there's a new super app being deployed. Call these callbacks on this contract whenever these events happen, right? And by default, there are six different callbacks that will run. One is the before agreement created, another is the after agreement created. And then the same thing is mirrored for after agreement is updated and after agreement is terminated. So there's a maximum of six callbacks you can implement. A lot of times we'll usually see just the after agreement created callbacks being implemented. What you do to specify which callbacks you want to run is just you specify that there are certain callbacks I don't want to run.
00:15:36.742 - 00:15:54.106, Speaker A: Right. So these are all no ops here. So we're not going to do any of the before stuff. The before agreement created stuff is useful in the case where maybe I want to reject a stream coming into the contract. If it's below a certain amount, maybe I want there to be like a minimum amount sent into the contract. Maybe it's a subscription of some kind. It's got to be a minimum.
00:15:54.106 - 00:16:30.306, Speaker A: I could do that kind of stuff in the before if I wanted to. So that's the setup. The first thing I'll show is not current this change receiver function and then I'll get into the redirection of cash flows. So remember, what's important with the change receiver is that we delete the streams going to the old owner and we create a stream to the new owner. That's the idea, right? We need to make sure that the cash flows are just following the NFT to the new owner. So we have a nice little getter function to get the current receiver, see who it is. And if I scroll down, we have the change receiver.
00:16:30.306 - 00:17:12.386, Speaker A: So we run a couple of checks at the top and then we check what the outflow rate is to the current owner using this logic here. So all we have to do is call this get flow function and we can get information about the flow. One of the parameters that's returned is what the flow rate is. We can check what that is if it's greater than zero, meaning that there's something that exists, we'll just delete that flow using this one line of code and create a new flow to the new receiver, right? So simple enough, deleting creating a new. Now let's get into the automation stuff, right? This is the most important stuff. You'll see at the bottom we have a few of these callbacks that are implemented. One is the after agreement created.
00:17:12.386 - 00:17:57.170, Speaker A: Another is the after agreement updated and the final one is the after agreement terminated. We run this update outflow function in each of them. So let's step through that function because it's going to be very important for this app. Okay? So the update outflow function, what it's going to do is it's going to check what the net flow rate is of the app and it's also going to check what the outflow rate is of the app. So the first thing we'll see is, okay, does the inflow rate now equal zero? Right. If the inflow rate now equals zero, it means that the flow that was being sent into this contract was deleted. So if that was deleted, what that means we need to also delete the stream going to the owner because there's no cash flows left, right? So we'll run this deletion.
00:17:57.170 - 00:18:46.980, Speaker A: The next thing we'll do is check if the outflow rate is not equal to zero. So if there's already a preexisting outflow and it's not equal to zero now it means that we need to update the flow because it means that the flow coming into the contract was changed. So we'll update it and make sure that the flow rate coming in just matches the flow rate coming out, that's all. Finally, if none of those two things are true, it means that there was no stream that was existing into the contract yet. So if there's no stream coming into the contract yet, what we need to do is just open a stream to the owner of the NFT, simple enough. The creation case, the update case, and the deletion case and all of that will run automatically whenever a stream is created into the contract, and then when that stream again is updated and then when it's deleted. So let's deploy this and test it live.
00:18:46.980 - 00:19:30.960, Speaker A: So what I've done is I'm using the Hard Hat Deploy library, which is a convenient way to deploy contracts. You can also use the standard Hard Hat scripts, but I have the Hard Hat Deploy library all set up here. So I have this all set for the Guerreli testnet just like this. And what I can do is just run MPX Hard Hat deploy, and we'll do this on, like I said, Guerreli. It'll compile here, I believe, just a second. And then it will deploy for us. All right, so it compiled successfully deploying any second now.
00:19:30.960 - 00:20:08.658, Speaker A: Mmhmm. So when this deploys, what we'll do is we'll take this here we go. We have their address. We'll take this, and then we'll write some scripts to send money into the contract, update that stream, and then delete that stream and just check to make sure that the contract is doing what we want it to do. Right, so it's been deployed. Let me just copy this address and I'll go into our Create Flow script. Okay, so we're going to use our SDK now to create a flow in JavaScript to show you I mean, we've already shown you how you can create streams using Solidity.
00:20:08.658 - 00:20:36.238, Speaker A: We can do the same thing in JavaScript, and the process looks very, very similar. So here in the Create Flow script, I'm just going to add the address to this variable that I have preset. And what we're doing here is just initializing the SDK using this framework, create syntax. Here we're passing in the chain ID we want to use. In our case, we're going to use the Guerreli testnet. So the chain ID is five. We're also going to just make sure that we have the URL we want to use.
00:20:36.238 - 00:21:04.290, Speaker A: In my case, I have an environment variable set up within an Alchemy URL, which is just going to allow me to deploy to Guerreli. And what we're also going to do is we're just going to set up a signer here which basically just mirrors what an Ethers signer is. I could also just use Ethers Get signers, and it would give me a signer that I can use as well. And we have those things set up right. We have a signer. We have the superfluid framework which allows us to use the SDK. Now what I need to do is get the address of the token that we want to use and then create the stream.
00:21:04.290 - 00:21:28.880, Speaker A: So the first thing I need to do is get the address of the token. In our case we're using Dix. This is the address that I passed in when I deployed the contract saying this was the accepted token I wanted to use for this contract. So I'll use this to get the token. You can just load it by symbol, which is pretty cool. On testnets, we put a little F in front of the tokens that have been deployed there just to note that it's fake money and not real money. It's not real.
00:21:28.880 - 00:21:54.102, Speaker A: Got to be careful with that. And then here what we do is we create the operation we want to execute and then we execute it and we sign the message with the signer. So here in this case, we are going to create a flow using this here. So SF CFAV, one create flow. We pass in the receiver which is the address of the Tradable cash flow. We're sending money into this contract. We pass in the address of the token which I can get through calling the address of this.
00:21:54.102 - 00:22:37.090, Speaker A: And then we pass in a flow rate as a string. And this is just the number of tokens I want to send per second, right? This is going to be a pretty small amount because it's all denominated in way, but it is some amount. So let's send a stream into the contract here by running our script. And then what I'm going to do actually first is go to the contract address on the superfluid console. Like I said, the console is very, very useful for these kinds of operations. The second the stream transaction propagates, I'll be able to just search this address more easily because it will automatically pop up in the console. So give me a second here.
00:22:37.090 - 00:23:08.228, Speaker A: Here we go. And we can see here that there's two streams. Now in relation to this contract. We just created a stream. And then remember that the expectation is that 100% of that stream value is sent out of that contract immediately, right? And that's what's happening, right? Money is being streamed in and money is being streamed out in the same amount, right? So it's that simple. Now you have a Tradable cash flow contract. You can do the same thing and have the scaffolding for a really, really interesting project this weekend.
00:23:08.228 - 00:23:36.930, Speaker A: If you fork this, I could go through and update the flow and delete the flow. But I think that would be a little bit tedious at this point because it is basically just the same thing. The syntax is just slightly different in the SDK. But that's the idea, right? If I were to trade this NFT, the cash flows are just going to follow the NFT holder and yeah, that's one very, very powerful thing you can build on superfluid. So if you have any questions on this please feel free to let me know. I'll go back into Keynote and just kind of finish out our presentation. But we'd love to engage with any of you guys on this if you're interested.
00:23:36.930 - 00:24:06.232, Speaker A: Cool. Let's go back in and we'll wrap this up. We left off on the Tradable cash flow, explaining it a little bit. Another thing I want to talk through is this program called Superfluid Reactor. So what we really value with Superfluid is becoming a developer platform. That's part of our strategy here. We want to integrate with existing Web Three projects that are used widely but also help you take whatever you're building to the next level.
00:24:06.232 - 00:24:33.236, Speaker A: So if you're aspiring to be an entrepreneur in the space or just build a really valuable project that's maybe open source, we want to talk to you. Right. We just rolled out a program called Superfluid Reactor. That the entire goal, is that right? We want to find people like yourself to launch, and if you get into the program, there's an application process. But if you get into the program, we'll provide the best mentorship we have. We will help you raise money. We will connect you to other talent in the space.
00:24:33.236 - 00:25:16.336, Speaker A: We will help you find your first thousand users. We allocate a lot of time to this, so we'd love to help you. We've had some success stories already in a less formalized way. I mean, the reactor program is very new, but we've had protocols like Ricochet Exchange, which is a dollar cost averaging application, come through our system. We've helped them quite a bit to get lots of users and get off the ground. Another is a protocol called Huma Finance that's allowing people like some of the people at Superfluid and maybe in this room to borrow money against their salary stream or earn passive yield using their salary stream. And we've also had a protocol for Web Three native subscriptions called Stripe also come through our program, who just raised a $2.5
00:25:16.336 - 00:25:40.056, Speaker A: million precede round a couple of months ago. So lots of success stories, and we'd love for you guys to also be your own success stories if you'd like. That's it for today. If you want to get in touch, you can find us this weekend. I'll probably be pull an all nighter or two this weekend, so if you're going to sleep here, I might also end up crashing here. We'll see. You can find me on Twitter at Esplini five and in discord at Sam F.
00:25:40.056 - 00:25:51.750, Speaker A: Superfluid. So if you're interested in Superfluid, please feel free to reach out. If you have any Web Three questions more broadly, let me know, and I'm happy to chat through anything and yeah, appreciate all of your time today. Thank you.
