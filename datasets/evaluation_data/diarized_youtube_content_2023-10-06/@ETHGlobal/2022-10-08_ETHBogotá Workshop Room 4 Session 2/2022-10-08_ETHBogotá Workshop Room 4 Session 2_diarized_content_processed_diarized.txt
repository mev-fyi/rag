00:02:05.930 - 00:02:18.906, Speaker A: All right. Hey, everyone. Can you hear me? Well, is everyone still awake? All right. So welcome, everyone. My name is Peter. I'm going to talk about scroll tonight. And first of all, thanks a lot for joining us tonight.
00:02:18.906 - 00:02:57.962, Speaker A: I know it's very late, and I know most of you are just as jet lagged as I am, so really appreciate that you joined. Also, before we start, to all of you who listened to the optimism introduction 1 hour ago, I want to make a public announcement. So scroll is, in fact, the only serious blockchain out there and the best L2 to Ethereum. So I just wanted to correct the optimism team there. So any questions? All right, so who heard about scroll? Hands up. Okay, quite a few. So today we're going to see how you can deploy contracts on scroll.
00:02:57.962 - 00:03:33.218, Speaker A: And I'm also going to go into some details about how scroll does what it does and what is it. So scroll is a L2 to Ethereum and it's a Zke EVM based L2. So our goal is to scale Ethereum. So we want to have more transactions, lower fees while we maintain the same level of security as layer one. So it's a ZK roll app. And why is it a ZK EVM? Basically, we want to maintain very high level of compatibility with layer one. So the idea is that when you develop on scroll, it feels exactly the same way as when you develop on Ethereum.
00:03:33.218 - 00:03:59.854, Speaker A: You don't need to learn a new language. You don't need to learn any other tools. You don't need to understand what Xero knowledge proofs are. Everything is done under the hood, and you just develop your DAP and it's fast and it works and it's safe. So that's the idea. So we're going to start by looking at how you can get started with our testnet. And the most interactive part of this workshop is hopefully you scanning this QR code, which you can use to sign on to our testnet.
00:03:59.854 - 00:04:25.142, Speaker A: So currently, we're in a permission testnet phase. So that means you have to sign up, you have to get on the whitelist. And once you get on the whitelist, you can get some tokens, you can deploy some contracts, et cetera. So you can either open Scroll IO early dev, or you can scan the QR code. It's the same thing. You fill it, and after a few hours, we will put you on the whitelist and then you can start building. We also want to encourage you to join our discord.
00:04:25.142 - 00:05:07.746, Speaker A: And then you can also ask technical questions there, give us some feedback, all that stuff. All right? So we're going to have a very simple live demo here, if it all works. Okay, so when you get started on scroll, once you get on our whitelist, the first thing that you want to go to or the first website, is prealpha Scroll IO. This is our so called Prealphateestnet and this has all the information and all the tools that you need. So MetaMask, configuration, faucet for getting funds and a breach to bridge from layer one to L2. So a bit about this testnet. So in mainnet, of course, layer one is going to be ethereum and L2 is scroll.
00:05:07.746 - 00:05:44.990, Speaker A: But in this testnet we are actually maintaining a simulated layer one. So we have scroll layer one testnet and scroll L2 testnet. They are both maintained by us. So first thing that you want to do is just simply add these networks to your MetaMask so that you can send transactions and query the blockchain on these two networks. So after this, you're going to have two new configurations in MetaMask and this automatically will configure the RPC address and also the chain ID. Okay, that should be pretty straightforward. And the next thing you want to do is get some funds.
00:05:44.990 - 00:06:14.586, Speaker A: So as I said, we're not operating yet on Ethereum. We're not operating on Ethereum testnet. We're maintaining our own layer one. So you need to get some test ethereum. And once you're on the testnet, you can just request some funds and you will get one test Ether and 100 test USDC tokens and then you should be good to go. So after that, you should have some test ETH. And before you can start deploying on scroll, the last thing that you want to do is move your funds to L2.
00:06:14.586 - 00:06:48.518, Speaker A: So currently from the faucet you get your funds on layer one. So you don't have any tokens on L2. So you need to use our bridge. And it's a very simple UX. You've probably used plenty of similar depths. You just enter the amount, send the transaction and under the hood we're maintaining this bridge from layer one to L2 and it's relaying tokens like ETH, ERC 20 tokens. You can also relay NFTs, which I think is kind of unique or not something that you see so often.
00:06:48.518 - 00:07:19.566, Speaker A: But actually this bridge is also an arbitrary message bridge. So if you want to build something using this bridge, then we're also open to that. So just reach out to us. So by the end of this onboarding process, you open your MetaMask and now you finally have some funds on L2. So it's time to start building. And I'm going to use this open Zeppelin wizard here, which some of you might have seen. This is just a very simple tool for putting like implementing tokens with no coding.
00:07:19.566 - 00:07:50.022, Speaker A: You can just choose the features that you want to have. So we want to implement an ERC seven to one NFT token and let's say it's a scrollers NFT. This is probably going to be one of the first NFTs on L2. So it's a historic NFT and the only feature that we want to add is that it's going to be mintable. So we're going to be able to mint new tokens. And that's about it. That's the coding part of this so called workshop.
00:07:50.022 - 00:08:27.800, Speaker A: And the next thing I want to show you is how to deploy on scroll. And I'm going to use Remix for that. But as I said, the main goal with scroll for us is that we maintain 100%, even though we are a zero knowledge proof roll up or a Zke EVM, we maintain 100% compatibility with Ethereum. So you can use Remix, you can use Hearthat, you can use Foundry, all the other tools that you're already familiar with. So here I just click on Open in Remix to open this code. And I'm just going to use Remix as I would use it on Ethereum. So notice that we don't have any scroll specific here.
00:08:27.800 - 00:09:08.818, Speaker A: Solidity is compiled into EVM bytecode as on other EVM chains. And then you can just simply go to the deployment part to deploy and scroll. So select Scroll Add to testnet and choose the injected provider MetaMask. And you see that I have my balance here and just click Deploy and then it should be deployed. So at this point, if this deployment fails for you when you're doing it, chances are that you either don't have enough funds or that you are not on the whitelist yet. So feel free to register or reach out to us and make sure that you're on the whitelist. And now we have a contract deployed on scroll.
00:09:08.818 - 00:09:39.978, Speaker A: It's actually fairly straightforward. And just as another example, I'm going to mint one token to my own address. So call this Safe Mint function again, just confirm the transaction. It's going to go through within a matter of seconds. And now we can see it on the blockchain explorer, I minted one token to my address. Thanks. So that's the example with Remix.
00:09:39.978 - 00:10:23.274, Speaker A: And for a more detailed tutorial, you can go to Guide Crawl IO, where we have all kinds of guides about our current testnet, including a contract development or deployment tutorial. And this is an example repo that we have. Again, it's just a very simple contract. I think if you've developed on Ethereum, this should all be very familiar to you. And you can either deploy with Hearthat or you can use Forge Create to deploy with Foundry as you would do on other chains. So back to the presentation. So you might ask me like, okay, so what is the point? What's going on, Peter? Why are you telling me stuff that I already know? And I would argue that if this is all boring to you, that's kind of the goal that we're aiming for.
00:10:23.274 - 00:10:45.726, Speaker A: So the goal with scroll is that you're building on Zke EVM, you're building on L2. But you don't have to learn a new language. You don't have to learn a new tooling, new ecosystem. You can just use your existing tools out of the box and it works exactly the same way. And when I say exactly. It's not actually 100% the same. So we have some slight modifications.
00:10:45.726 - 00:11:26.240, Speaker A: If you're familiar with the Vitalik's classification of Zkevms, we are aiming for Type 2.5, which means that there are some slight differences between layer one and L2. Like the gas cost might be different because some operations are more expensive in a ZK rollup. And the other thing is that some opcodes might not work as on layer one. For instance, self destruct is going to be disabled. But I think for most DApps that should not be an issue. So now that you understand that scroll works exactly the same way from your perspective as Ethereum, let's dive into some technical details of how we implement this Zkevm stuff.
00:11:26.240 - 00:11:59.210, Speaker A: So here you can see like a high level architecture. So we're operating on two chains, as you would imagine, layer one and L2. And in our case, layer one is the Ethereum Mainet and the two main components there are the roll up contract and the bridge contract. So the roll up contract is basically maintaining the state of the L2 chain. It maintains the data from the L2 chain. That's the data availability, the content of the data availability. And it also receives the zero knowledge proofs and maintains the state route of the L2 chain.
00:11:59.210 - 00:12:27.794, Speaker A: The bridge contracts, as you just saw in the example, it's for bridging assets from layer one to L2. As I said, it can bridge all kinds of contracts sorry, all kinds of assets. And this is pretty familiar, pretty similar to other chains. And now we get to the juicy part, which is actually the L2 implementation. It has, let's say, four major components. So one is the sequencer node, which is responsible. It's basically maintaining the blockchain.
00:12:27.794 - 00:13:04.714, Speaker A: So it's a fork of go ethereum. It's responsible for collecting transactions, creating blocks and just maintaining the blockchain itself. Then we have the relayer, which is strictly related to the bridge contract. So it's for relaying messages between layer one and L2 both ways. And then most crucially, we have this component called roller. So that is the prover in our system that is the component responsible for creating the zero knowledge proofs. So the way it works is that for each block, the roller receives this block or receives some data related or derived from this block.
00:13:04.714 - 00:13:41.350, Speaker A: And using the Zkevm circuits, it creates a proof for this block. So what does it actually mean? So you could imagine that currently we have state A. So state root is a now we get a new block and now we transition to state B by executing that block. So we have this state transition from A to B. Now what the Roller does is that it creates a proof for this execution of this block. And then using this proof, you can actually prove that this transition from A to B is correct. You can prove this or verify this without actually executing the transactions.
00:13:41.350 - 00:14:35.738, Speaker A: So that is the essential part. How zero knowledge proofs are used in all ZK rollups is that you create this proof of the state transition which the roll up contract on Ethereum can verify independently. So in our case, we have a decentralized network of rollers. So if you have a couple of spare GPUs and you want to earn some money you can actually during mainnet or the next testnet iteration you can actually join our testnet, you can spin up your GPUs, you can create some zero knowledge proofs and you can earn some rewards for this. And to maintain this connection between scroll and the rollers we have a coordinator. So coordinator is simply responsible for assigning blocks to the rollers receiving the zero noise proof and verifying it. Yeah, these are the main components and if we zoom into the roller itself, like what is the workflow of the roller? The input for the roller is the execution trace.
00:14:35.738 - 00:15:23.630, Speaker A: So for the block you could imagine that we generate all kinds of information about the execution of the block. So that includes all the opcodes that were executed, all the storage entries that were updated, all kinds of informations and that is the input for the circuits and the Zke EVM itself, which we are developing. Along with the Ethereum foundation is a collection of circuits for proving these different state transitions. So we have an EVM circuit that proves that the opcode was executed correctly. Then for instance, we have the storage circuit that proves that the storage updates were also executed correctly. And we have a whole bunch of different circuits proving different things. These all create different CK proofs that we aggregate into single proof and that is the output of the roller.
00:15:23.630 - 00:16:01.814, Speaker A: And just one final diagram of this whole process like how do we all put it together in terms of time. So on this diagram you have time as the axis and we see the process of the Zke EVM. So you can look at the sequencer. The sequencer is creating the L2 blockchain. So it's creating blocks 1234 and all these blocks are first of all committed to Ethereum. So we have the data available on Ethereum. At the same time the coordinator will assign these blocks to different rollers based on some algorithm and the rollers will start a proof generation session.
00:16:01.814 - 00:16:49.222, Speaker A: So this is a pretty expensive computation but this only has to be executed once and later we only just verify this proof that was created. So for each block we create a proof and then finally we can aggregate these proofs into a single proof and that is submitted to Ethereum to the rollup contract and that is verified independently by the contract. So that is how it all comes together. Hopefully to all of you who didn't know how Zkevms or ZK rollups work this kind of demystifies some of the main ideas. Zooming out a bit so again, our vision is to scale Ethereum. So it should be faster, it should be cheaper, and it should be just as secure as layer one. And that is what Zkevm does.
00:16:49.222 - 00:17:26.078, Speaker A: And in our case, so there are many different companies working on Zkevms and there are different design trade offs to be made. In our case, we aim for as much compatibility as we can. And that means that we're aiming for bytecode equivalent. So that means that you take the EVM bytecode, let's say from Remix or from heartet that you deployed on layer one and you can, in exactly the same way, deploy it on L2. And it works the same way. Then we have decentralization as a main design component. So, as I said, the provers or rollers are decentralized from day one, so decentralized during the main net launch.
00:17:26.078 - 00:18:01.834, Speaker A: And eventually the sequencer is also going to be decentralized. And finally, we are pretty much aligned with the Ethereum ecosystem. So we're aligned with Ethereum's Rollup centric Roadmap and we're also building the zkvm together with the Ethereum foundation. So there's a lot of very highly skilled ZK engineers working on this. If you're interested in ZK, all of this is open source, so I encourage you to look into it. I think it's pretty complex, but this should be a very interesting thing to you. And what can you do? So, we are a sponsor at this hackathon.
00:18:01.834 - 00:18:45.100, Speaker A: So we really would like to welcome you to build on scroll. As you see, if you've built on Ethereum before, then it's very seamless, very easy to move to scroll. And you can build all kinds of applications because scroll is general purpose. Layer two, for instance, you could build some more complex AMM DAXes that might not be feasible on layer one because of the computational burden. Or similarly some lending pools with some more complex borrowing computations. Or I think a very exciting idea is web3 social apps, which I think current systems cannot really support the user experience that we would expect from a social app. But L2 blockchains, especially ZK AVMs, might be an excellent fit for these.
00:18:45.100 - 00:19:13.750, Speaker A: Or you might want to just build some simple NFT projects. Or if you're interested in ZK, you can just build a ZK DAP on scroll. And the advantage here is that we have a lot of engineers that are super experienced with ZK. So if you choose this route, then we're more than happy to guide you and give some help. So we have two bounties. One is for the most innovative DAP and the other one is for the best ZK DAP. And all in all, you can get like $5,000.
00:19:13.750 - 00:19:45.342, Speaker A: So yeah, if you're interested, please join or please just find us. It's me. We have our team members sitting at the back, so feel free to reach out to us and ask some questions. And finally, some resources for you to get started. First of all, you should go to scroll IO early Dev again to get on the whitelist for our testnet. And then you should go to guide scroll IO to find all these tutorials on how to deploy it, scroll, how to get funds, all that kind of stuff. Yeah.
00:19:45.342 - 00:20:10.826, Speaker A: And finally, here is the most important resources. So on the right you get these slides so you can review all the links and everything. On the middle is the discord of scroll. Please feel free to join. And on the left is my telegram. So if you have any questions to me or you have any issues you didn't get on the whitelist, et cetera, please feel free to message me directly. Yeah, and we're also hiring, by the way.
00:20:10.826 - 00:20:36.200, Speaker A: So if you're a ZK engineer, if you're interested in infrastructure engineering, feel free to reach out to us as well. All right, that's our workshop for tonight. Thanks a lot for joining. Do you have any questions yeah, go ahead. About.
00:20:44.010 - 00:20:48.310, Speaker B: How people know that are generated. But I'm.
00:21:20.280 - 00:22:20.468, Speaker A: Yeah, thanks for the question. So the question was that how much is proof generation is reliant on GPUs? What is the specific requirements that we have here and how does this relate to ethereum after the merge becoming more and more green? So I think GPU accelerated ZK is a breakthrough in the last few years and that's what makes really Zkvm possible. So previously we had most stuff running on CPUs and that was not really practical for any practical purposes. Recently we have GPU acceleration and that makes it practical in terms of running time. And I think in the future we might have some ASIC hardware for this. So in terms of the environmental impact, there is some similarity here to mining for sure because we have a decentralized network of provers, they consume a lot of energy to create these proofs. I think there are some very interesting or very important differences though, because in proof of work you do like useless work.
00:22:20.468 - 00:23:21.450, Speaker A: I mean, it's useful in terms of proof of work but the computation that you execute doesn't have any useful results by itself. In our case, the computation that you're doing is actually useful because you're calculating these decay proofs that many people will use to verify the state transition in the future. So I think this is not really the same thing or the same concern as proof of work. And also there won't be so much of an arms race here because whether it's profitable of you to create proofs depends on the utilization of the system. Basically, the more blocks we have, the more transactions, the more rollers can join the system and contribute. But this is linearly directly related to the amount of usefulness of the network as opposed to proof of work where if your neighbor gets more computing power then you're also forced to get more computing power to remain competitive. I hope that answers the question.
00:23:21.450 - 00:23:24.250, Speaker A: Any other questions?
00:23:28.010 - 00:23:30.860, Speaker B: What happens if the coordinator at T two?
00:23:32.920 - 00:23:38.964, Speaker A: What happens if the coordinator makes a mistake? So what kind of mistake do you do you have in mind?
00:23:39.082 - 00:23:56.010, Speaker B: Or I guess maybe the sequence? Is it possible for the proof generation goes beyond the block time? So I think there's an error. If something goes wrong, how does it roll back?
00:23:57.680 - 00:24:36.212, Speaker A: Yeah, that's a good question. If something goes wrong, what happens? And also, given that some of these components are centralized on day one, is there any kind of cheating that scroll can do or the maintainer of the coordinator can do? So the way it works is that before we even do any ZK proof generation, we commit the block data on layer one. And this data is available for everyone to see on layer one. And at this point, it cannot be changed. And so this is the commit phase. And once we have the proof, that is what we call finalized. When we make it final, it cannot be reverted.
00:24:36.212 - 00:25:33.192, Speaker A: What's on layer one? What can go wrong? If we look at the coordinator, it cannot really fake any proofs because all the data is available on layer one. So only a correct proof will go through. And if the roller, let's say, fakes a proof, we can catch that at the coordinator level because it's fairly cheap to verify that the proof is correct. But even if we don't verify it at the coordinator level, the roll up contract will verify the zero noise proof and will revert the transaction if there's an issue with that. That said, I think there's an interesting question here of auditability or how can we make sure that the Zikavm is correct? Because it's an extremely complex set of circuits. There's not that many people with this kind of expertise who can review and audit them. So I think the most crucial part is to make sure that this component of the system is correct.
00:25:33.192 - 00:26:00.550, Speaker A: And for this, if any of you is ZK enthusiast, we would invite you to come learn about our circuits. And once you have a good understanding, start reviewing and start seeing if there's any errors. So there's going to be bounties for this. We also hire people just for this purpose to make sure that the circuits are correct. So that's the efforts that we do. Thanks for the questions. Maybe one last question if you guys have any more.
00:26:00.550 - 00:26:12.240, Speaker A: Okay, thanks again for joining at 10:00 P.m.. I really appreciate it and hope to see you around at the hackathon. So enjoy.
00:39:06.910 - 00:40:12.446, Speaker C: So this workshop is on Transaction Insights to give you a little background on what transaction Insights is. It's a feature that we've exposed to the MetaMask Snaps platform that allows snaps to render certain insights on transaction data. So we make unsigned transaction payloads available to snaps that have this transaction insight endowment to be able to make these insights. So I just wanted to show you guys some links that I have available that you guys can read into to learn more about the API. So we have something called Sips, which are snaps improvement proposals. And so this transaction insights feature was specked out in sip three. If you guys want to just take a moment to jot down the link or whatever you can do.
00:40:12.446 - 00:41:08.180, Speaker C: So, and these sips are open to discussion. So if you guys feel like the API can be improved upon or you'd like to see new things inside of it, you can join the discussion. And another link that I'm providing here is for Cape Two. So we use this standard to basically identify different chains with. So there's this whole concept of namespaces and chain IDs that we're using under Casa, which stands for Chain Agnostic Software Alliance. And so we're using this standard for our chain IDs. Now to get started on the actual workshop itself.
00:41:08.180 - 00:42:09.716, Speaker C: So I would like for you to clone down this repo first. This is the template TypeScript Snap repo. So the first thing we're going to do is just get the link here and we're just going to clone this down. There's a bit of a delay here. That's good. Cool. All right, so if you look on GitHub, it should be template TypeScript.
00:42:09.716 - 00:42:51.800, Speaker C: Snap is the repository if you guys just want to take a minute or two just to clone that down. And then there's also a certain build of MetaMask Flask, which I'll ask you guys to install into your Chrome extension. If you guys aren't familiar with Flask. Flask is basically our canary build of the MetaMask extension in which we've released the snaps platform. So I'll get you guys the link to that in a second.
00:43:09.550 - 00:43:10.010, Speaker B: Cool.
00:43:10.080 - 00:44:36.970, Speaker C: So if you go to this link here, you'll see this MetaMask snaps bullet guide, and it'll walk you through how to install Flask. So the build that you want to use is on this link here. If you just follow the steps. If you want to take a couple of minutes to do so, please do that. What's that? Oh, it's on discord. Okay, does everyone have this build installed already? Okay, so just take a couple of minutes to do that. What's that? Yeah, we have the transaction inside API available in this build.
00:44:36.970 - 00:46:51.510, Speaker C: We haven't cut a new release yet, so we're using this custom build. I'll give it another minute or two so people can catch up. So once you have Flask installed, please open up the repo that you just pulled down. So this is just a template, basic template TypeScript template for a Snap. And this is what we're going to work off of to create this transaction insight Snap. So what you first want to do is just run Yarn install to install the dependencies. Cool.
00:46:51.510 - 00:48:02.050, Speaker C: So you'll notice that we're importing an onrpc request handler. We have different handler types with the addition of this on transaction handler. So we're going to be pulling in that instead. And so the type of this will pull in a transaction and a chain ID. If you remember what I mentioned about Cape Two. This chain ID is a Cape Two chain ID. For demonstration purposes, we're not going to parse this chain ID or do anything special with it.
00:48:02.050 - 00:48:25.500, Speaker C: But I just wanted to let you guys know that this is the type of chain ID that you should be expecting when writing transaction insight snaps. So we want to be able to export on transaction so the.
00:48:42.330 - 00:48:43.078, Speaker B: Cool.
00:48:43.244 - 00:50:21.624, Speaker C: And then so we're just going to delete all this out of here. And so the return object is expected to be having an Insights key. And inside of this Insights object you can add in whatever sort of key value pairs you'd like. So for demonstration purposes, we're just going to spit back the transaction chain ID. So you basically need to just save this and then we need to add in the permission for transaction insights, which I just need to double check what it is exactly. It cool. So now you just save this and I think we should be pretty much there.
00:50:21.624 - 00:50:42.030, Speaker C: You don't need to touch this index HTML file. It's already good to go. So it picks up on this Snap ID. Since this is a locally hosted Snap, we're not deploying it. It's going to use this local prefix. So everything is set up for you already. You don't have to worry about touching this.
00:50:42.030 - 00:51:37.210, Speaker C: Now the next thing we need to do is basically just build and serve this Snap and we'll do that here. So we need to do yarn build and yarn serve. So this is starting the server on localhost 80 80. You can choose to change where the server is hosted in Snap config JS. So you would just change the port if you wanted to. So now we'll navigate to localhost 80 80.
00:51:42.130 - 00:51:42.542, Speaker B: Cool.
00:51:42.596 - 00:52:44.130, Speaker C: So you'll see this prompt here? We're only concerned with the connect button because there is no UI interaction within the DAP itself. So transaction Insights, they're displayed in the confirmation screen of MetaMask when interacting with contracts or even EOAS. So we'll first install the transaction insight Snap here and you can see that it's requesting certain permissions to be able to display a confirmation and then fetch and display transaction insights. So we're just going to approve and install it. And now it's good to go. Now we're going to test out this Snap and see if it works on uniswap.
00:53:00.120 - 00:53:00.532, Speaker B: Cool.
00:53:00.586 - 00:53:53.970, Speaker C: So you just connect your wallet and we'll do a simple ETH to wrapped ETH swap. Now if you notice, there's an extra tab here that you wouldn't see otherwise. It has the name of the transaction Insight Snap. Now the Snap only shows up because it has this endowment and it was able to do this because we gave permission to do so. Now if you click on it, you'll. See the transaction payload and the chain ID that was sent to the Snap, and it basically just spit it back. And this is pretty much it.
00:53:53.970 - 00:54:36.604, Speaker C: This demo was to illustrate how this works. You can do a lot more interesting things with transaction insight snaps. You can use services like Tenderly to run a transaction simulation and get more insights. That way you can write transaction insight snaps to maybe detect phishing on different DApps. The world is your oyster with transaction insights. Yeah, this is pretty much it. If you guys have any questions, let me know and I will open this document back up.
00:54:36.604 - 00:55:06.640, Speaker C: I have my telegram here, I have my discord here, and these links are here for you to follow if you need all it. I'll just leave this here for like a minute or two more.
