00:00:00.170 - 00:01:00.026, Speaker A: Sa good evening, everyone. My name is Alexandra. I'm part of developer relation team with Neil foundation. It's nice having you with us today on our joint tech talk by Neil foundation and Lida on accessing historical data on Ethereum. Before we start, let's see who we have with us here today. Say hi in the YouTube livestream chat. Tell us a little bit about you.
00:01:00.026 - 00:01:33.400, Speaker A: Like where are you from? Are you familiar with zero knowledge technology? And in the meantime, I will tell you a little bit about the technical side of this event. This event is planned for about an hour discussing the problem accessing historical data on Ethereum from two sites, the problem statement and our proposed solution. Today we have here with us Eugen from the lightest side, just a.
00:01:44.750 - 00:01:45.500, Speaker B: Hello.
00:01:45.870 - 00:01:57.434, Speaker A: Yeah, that's Eugene. And also Nick, developer advocate with new foundation, who will tell you more about the proposal.
00:01:57.562 - 00:02:01.040, Speaker C: Hey, folks, it's a pleasure being with you today.
00:02:07.250 - 00:02:41.020, Speaker A: Okay, I see that we have some listeners who are familiar with zero knowledge technology. That's cool. Okay, so this event consists of two parts, and after each part, we'll have time for questions and answers. So if you have anything on your mind, please post it in the streams, in this live streams channel in the chat on YouTube. And we're also having this event recorded. And I expect that we will post this video later on the news YouTube channel.
00:02:44.030 - 00:02:48.960, Speaker C: We certainly will. Let's start.
00:02:50.450 - 00:03:02.900, Speaker A: Yes, I believe we can start. And I present you Eugen from Lida Core protocol developer. Just a second.
00:03:07.480 - 00:03:59.910, Speaker B: Yeah. Hello, once again, thank you for having me here today. So I'd like to present you the project being approved and funded by the Lidar Lego committee for the development of the Lida validators balances ZK Oracle. The project aimed to access Ethereum historical data with ZK proofs. So let me start with a brief introduction. I'm Eugene from the Lida protocol contributors team. I've been participating in the protocol development for two years, I believe, and including the latest development of Lida V two protocol, our largest and most significant upgrade so far.
00:03:59.910 - 00:05:44.680, Speaker B: Okay, so here is my agenda for today. Firstly, I will tell you about a bit more details about what is Lida, what is liquid staking. Then I will proceed with our oracle structure and its committee. Then we will move to the second part, actually, the part about today's meeting. It's the k oracle as the next chapter for Lida, and we outline our roadmap. So I will show you how we want to implement trustless Oracle for Lida, how we can pave the way for it. Okay, so to recap liquid staking, it's software solution or protocol built to enable users stake directly on proof of stake networks such as Ethereum, but with significant advantage of being able to hold, transfer, store, trade, participate and defy with liquid stake token and Lida is a protocol built initially for Ethereum and actually Lida headquarters based on Ethereum as well, but also Lida software solutions available for Solana and Polygon and operating currently on those blockchains.
00:05:44.680 - 00:06:57.490, Speaker B: Okay, so the main problem for liquid staking protocol on Ethereum, that protocol knows nothing like what does it mean? So it means that protocol lives on execution layer. I mean protocol contracts while protocol validators participate in consensus, living on consensus layer. So there is a gap between them and protocol must learn validator state by externally provided data. And to provide this data actually trusted oracle is needed. So if we try to provide an illustration for this, it would look like this. So we have pretty sophisticated mechanics for the protocol. But to access Ethereum historical and consensus data, you still need some kind of oracle to provide this data.
00:06:57.490 - 00:08:19.370, Speaker B: Okay, and I would like to show what is the structure of this data. Actually, like I said, it's validator balances and the balance of all Lidar participating validators form the protocol TVL actually. However, we also need to understand how validators perform their duties, whether they active or exited or maybe they got slashed by the network. So this data also should be provided by oracles. And starting from Lida v two, Oracle also provides decision data for withdrawal finalizations. When someone decides to redeem liquid staked token for native Azure, Oracle decides who will be the next and how many requests should be fulfilled and also accounting. Oracle for Lidar delivers special vault balances to achieve full transparency and coherence for the tvl data.
00:08:19.370 - 00:10:07.630, Speaker B: Okay, so the main issue here, that data relate asynchronously both in trusted way. So there is a potential risk that Oracle committee members maybe have a software bug or they can collude or something unexpected should happen. So that's why Lida performs various activities to improve oracle robustness and endurance. At the beginning, Oracle committee members formed a quorum of three members, five members in the allow list, and starting from Lida V two, we have nine members and quorum of five members required to push forward with new data from beacon chain and execution layer historical data. So not only improving committee structure but also performing data sanity checks is required to mitigate the risks for improper data delivery. So data sanity checks basically provides boundaries for the data values based on consensus rules, heuristics and expectations. How the network should evolve since the previously learned state.
00:10:07.630 - 00:11:18.384, Speaker B: And like I said, we have clear purpose, mission and vision for Lida. And if you look at our mission, you should know that security is at the center of mission. So it's never enough to achieve more security and mitigating risks for the oracle is huge step forward for the protocol. Sorry. Okay yeah. Ethereum going forward with EAP 47 eightyap paves the way for ZK technology because it makes available beacon chain state route on the execution layer side. This allows basically to provide historical data about beacon chain state and prove that data in a trustless way.
00:11:18.384 - 00:13:01.040, Speaker B: So overall this EAP is crucial for liquid staking protocols and unlock trustless technology. But still it's the case. We have significant challenges because the technology isn't bottle tested yet for delivering such data on Ethereum. Maybe there is known performance issue and space for optimization and actually significant five players and auditors still hasn't achieved big level of expertise when verify and audit the case solutions. So like I said on one side we have the way to lower the trust. However, the technology is new, so we can't integrate and drive technology in the protocol from the get go. So that's why we looked over our architecture and encompassing on all of the options and actually we found a way how to build the roadmap for ZK inside the protocol.
00:13:01.040 - 00:14:01.190, Speaker B: And the first phase we would like to incorporate ZK provided data as a part of sanity checks for TVL components of the protocol. So the validator's balance is a great sign to check for this. And then we just came up with idea, let's mimic Yale and sale merge. Maybe you know that Ethereum launched consensus layer, a site of execution layer. Then consensus layer evolved in its own way. And finally consensus layer got merged with execution layer and Ethereum effectively switched from proof of work to proof of stake. So we were inspired by this idea and actually our roadmap mimics this process.
00:14:01.190 - 00:15:24.266, Speaker B: We want to incorporate the K technology as a part of scientific checks and then achieve parity with our current trusted oracle. And eventually, once technology is major enough, once it's battle tested and enough expertise appear across auditors and security specialists, we can substitute the old oracle with the new one that works trustlessly. That's it from my side. Actually, I would like to add some references here about lid approaches to security. Eugene Prenichny provided his vision during DeFi security summer this year. Please follow the link. It's a significant presentation showing that people centered culture in Lida is a part of a security process as well thank you, Alexandra.
00:15:24.266 - 00:15:25.440, Speaker B: I can't hear you.
00:15:27.110 - 00:15:46.760, Speaker A: So sorry. Well, thank you, Eugene. If anyone has questions about the Lidar site, feel free to post them in YouTube chat. Oh, I see Nick has one. Okay, give me a second. I'll put the presentation away. And here's our first question.
00:15:46.760 - 00:15:59.930, Speaker A: You can see it down. When the latest balancer oracle gets implemented, what could be the next step? What do you think, Eugen?
00:16:03.250 - 00:16:39.510, Speaker B: Yeah, there are multiple steps that could be implemented further. Amongst them are withdrawal finalization data, historical data for balances of the vaults that protocol need to form the complete avail, and maybe some deposits data as well. So there are plenty of options. But let's look how we deal with validators. Balances.
00:16:42.750 - 00:16:52.250, Speaker A: Sounds great. Can you maybe tell us something more about the plans? Like when do you expect ZK Oracle will be implemented?
00:16:57.320 - 00:17:14.970, Speaker B: The first oracle that performs data delivery for the protocol on Testnet, I suppose, should happen either this year or maybe at the very beginning of 2024.
00:17:18.220 - 00:17:19.610, Speaker A: That's really cool.
00:17:22.940 - 00:17:26.430, Speaker B: Yeah. Very excited to make it happen.
00:17:28.640 - 00:17:45.120, Speaker A: Okay, well, we don't have any questions right now, so maybe we'll call you again after the next part. Maybe you'll have some joint questions or even joint answers. Thank you, Eugene.
00:17:47.320 - 00:17:48.070, Speaker B: Okay.
00:17:49.880 - 00:17:59.928, Speaker A: Sorry about that. Okay, let me add Nick to the stream. And here he is. Are you ready to continue with our part?
00:18:00.094 - 00:18:58.570, Speaker C: Yes. Hello again. Let's continue. So we're talking about a particular solution, zero knowledge solution for accessing historical data on theorem. Today it's a project for Lida, but it will help us learn how implementation of a real zero knowledge application looks like, what it takes, and how the solution will work. So today I will talk about several things. First, I will just make a technical overview of the requirements to building a zero knowledge application.
00:18:58.570 - 00:19:55.332, Speaker C: There will be several parts, and I will tell how each of the parts of the solution works internally and what Neil foundation gives developers to make this part work to develop it. And then we shall have a look at how these things work together. So we've just heard about the product side of this solution, like why it makes sense to implement a zero knowledge oracle. Thank you, Eugene. Now let's have a look at the technical side, like what the requirements are and what tools we need to make it work. So we're on the execution layer. We're our contract.
00:19:55.332 - 00:20:36.570, Speaker C: This energy checker in this case is running. We want to get the validator's balance, which is historical data and available on the consensus layer. We could just get it from the API, run some computations in it and use the results. But we cannot trust it as it is, and we cannot rely on any trusted party to provide this data. Because we are implementing a check to secure against compromising trusted parties. We cannot use trusted parties in it. So we want a trustless or so called zero knowledge solution with access to historical data.
00:20:36.570 - 00:21:30.650, Speaker C: Let's now have a big picture of this solution. But first, I will tell you a few words about. Oh yes, I should have shown this before. So, midnil foundation. We are a company pioneering in zero knowledge technology and dedicated to make this technology accessible to developers. We're building an ecosystem of products that solve each subtask of building a zero knowledge application and work well together. And today I'll show you what tasks there are and which parts of the Neil tool chain you can use to implement them.
00:21:30.650 - 00:22:23.368, Speaker C: So what exactly do we have? We have some algorithm that will work on the data. Like in this case, we have validator balances received from the API serialized with SS algorithm. We need to deserialize the data, then make a merkel tree with the elements and count it completely, every hash up to the root. And at this moment, there are over 800,000 validators, and their number is growing constantly. So that's a lot of hashes to count. And as a result, we will have a root hash and compare it to the beacon state. Like, yeah, I'll just speak like this.
00:22:23.368 - 00:23:17.980, Speaker C: We get a root hash, we can compare it to the beacon state root hash that we get directly in EVM, or as Eugene has just mentioned it, we will get it when the improvement proposal 47 eightye gets implemented. Now, if we see that hashes match, we can use this data in some more computations and we will trust the result. We will have like a zero knowledge proof of the result. And, well, to get togethers zero knowledge proof, we'll need to execute this code in a way that will produce a zero knowledge proof. So we can just use any programming language and any tool, and we need some specialized tools. Hopefully we'll not have to learn a new language for that. Now, here's how the solution looks with Neil.
00:23:17.980 - 00:24:12.380, Speaker C: We'll use Zkll VM. It's a circuit compiler that allows developers to write circuits algorithms in mainstream languages like C Plus plus and rust. For example, in the lidovalidator balances, Zk Oracle, we're using C plus plus now for deserializing SSz and counting the hashes in the Merkel tree, we'll use cryptographic functions from crypto three. I don't have it on the slide. Why? I don't know. But there is the crypto three, the library with cryptographic primitives covering pretty much everything you need, and it's also developed and supported by Neil foundation. Now once we have this code, we'll build it with the compiler into two artifacts, each going to a specific place.
00:24:12.380 - 00:25:02.964, Speaker C: We'll make a circuit statement. It's like an executable form of the circuit, and it will go to the proof market. We'll speak about it later, and we will deploy another form that's executable on EVM, called gate arguments, and it is deployed on Ethereum. So this thing is done once for every version of the code. So you can see it basically as a release cycle of your application. You write the code, you compile it, you deploy it somewhere. Now that the job of the circuit developer is done, let's see how the zero knowledge app will work in EVM.
00:25:02.964 - 00:26:08.724, Speaker C: On the execution layer, we want to request the data accompanied with a zero knowledge proof. And here's what producing a zero knowledge proof actually means. We should have a particular circuit that implements our algorithm. Now we have it already. Someone should run the circuit with the requested historical data as input, and the circuit will return the result like it's an implementation of the algorithm, and it will return the result backed in a zero knowledge proof, which is a specific binary format. So someone, somewhere, it could be us, it could be not, should produce the zero knowledge proof for us. We don't want to run a dedicated server for producing proofs, because we will then need to hire a team to support it, and we will have to work on the efficiency and such.
00:26:08.724 - 00:27:21.340, Speaker C: We don't want to count it on our customers phones, for example, because, well, a phone will boil after counting a Merkel tree with a million lifts, and we'll probably not want to produce it in EVM because that's still a lot of computations. And besides the price, we have the time limit of 30 minutes. As Eugene mentioned, we need the proof in a specific period of time, except that we have other requirements, like we need this to be the provider of the proofs that we want. We need it to be reliable, so it should work all the time. And we also want it to be distributed and decentralized to mitigate security risks. So as a solution for that, we will use the Neil proof market. It's a decentralized marketplace for outsourcing ZK proofs generation.
00:27:21.340 - 00:27:42.690, Speaker C: On the supply side of the market, it has the proof producers, there are faults with hardware optimized for producing proofs, and our application sanity checker in this case will order the proof on Ethereum, on EVM, and.
00:27:46.120 - 00:27:46.870, Speaker A: Sorry.
00:27:51.960 - 00:28:49.930, Speaker C: Yeah, the application will order the proof on EVM, and the proof market will pass the order to one of the proof producers. Now, how do we order the proof for that? We have made the proof market endpoint. It's an EVM application that basically does the interaction with a proof market for us. It can request proofs, wait for them, receive them, verify them. That's an important part, which we'll speak about later. So why later? We'll speak about it now. So we see that we can use proof market endpoint, so we can just write native code in EVM and it will do all the work for us.
00:28:49.930 - 00:29:53.630, Speaker C: Once we have requested the proof. And after some time, one of the proof producers has produced this proof, the proof market received it, verified it internally. It's done to control the quality, but we still cannot trust this particular verification because it's not done by us. So we will return the proof to the proof market endpoint, and we need to trust it to make a decision based on it. We need to verify it. The verification means a check that the proof, the zero knowledge proof, is produced with a particular circuit. So it's the same algorithm that we meant, it's not forged, and it received the same input data and it returned exactly the same result.
00:29:53.630 - 00:31:22.552, Speaker C: And verifying a proof is much simpler computational task than producing it. However, we still need the tools to make it possible on chain. And for this purpose, yes, for this purpose, we have made another application called placeholder verifier. Placeholder is the general purpose proof system that we're developing. And placeholder verifier is made to verify proofs made with this proof system. So remember the gate arguments that we as a circuit developer have deployed on EVM, and here we will use them and the proof that we have just received, and the placeholder verifier will return like will verify the proof for us, it implements the verification algorithm, and then we can use this result in proof market endpoint, it's implemented there, or we can call it directly. And finally, that we see that our proof has been successfully verified, we can use the result in our application and we can, well, basically that's it.
00:31:22.552 - 00:32:24.408, Speaker C: We have requested, approved, it was produced, and we have now verified it. So we can trust it, we can use it in our contract. So here's how it all works together. Remember what we had first, we had an algorithm to work with data, and we had to implement it as a zero knowledge circuit specific form of the application, then our application, every time on each input data, it had to request a zero knowledge proof. Someone somewhere had to produce it, preferably in a reliable manner and in an economically feasible manner, and so on. And then we should receive and verify it back on chain. And here's how it works with Neo.
00:32:24.408 - 00:33:21.020, Speaker C: So we implement the algorithm in a mainstream language, c plus plus or rust, compile it, use crypto three library. If it's c plus plus, compile it with zkllvm. Then our application can use the proof market endpoint to request proofs to get them back and verify them, and we can rely on that result. Well, basically that's how it all works and that's what we. I'll bring you back for a second. That's what Neil foundation is devoted to building and improving for the developers to be able to build their zero knowledge applications now. Thank you for listening.
00:33:21.020 - 00:33:27.650, Speaker C: Please ask your questions and please join our discord. It's on the QR code.
00:33:30.820 - 00:33:55.460, Speaker A: Thank you, Nick. I'll let this QR code stay on the screen for a while and we'll let you catch your breath. And Eugene will be back right about now and he'll answer the ash's question. Okay, I think we can remove this. Hello again, Eugene.
00:33:55.540 - 00:33:56.730, Speaker B: What is the question?
00:33:57.500 - 00:34:11.630, Speaker A: Just a second. Here it is. It's about future developments and enhancements that we can expect relating to zero knowledge proofs, oracles and ethereum historical data.
00:34:14.340 - 00:34:41.880, Speaker B: Yeah. To answer this question, I would refer to AP 47 80, motivation part. So it was said that the data could be useful not only for staking solutions, but restaking bridges and mev mitigation projects. So basically it could be a good path forward for the whole industry, not only liquid staking pools.
00:34:46.700 - 00:35:17.520, Speaker A: Okay, sounds good to me. Ash, if you need any more details, please write them asking chat and we'll move on to the next question. Here it is. It's about potential use cases and application of the ZK oracle. And for that question I would like to bring a part of the Nils team. Well, not just a part, the part. Please meet Ilya, he's lead of the protocol.
00:35:20.600 - 00:36:30.908, Speaker D: Yes. Regarding broader cases of LZK oracles in general in blockchain data space, et cetera. Yes, if we say about something really similar to what we're talking about today, about this Ck Oracle slider thing. So it's most of all about transferring any data from consensus layer to execution layer, which is, well, by default is great. It's not related only, not only to, let's say, liquidity staking in general, but also for dexs, for instance, especially for historical data, for dexs to, well, define basically strategy changings and all that stuff. In general, I'd say the closest case is, well, historical data for financial things because, well, for now you cannot get anything past several hours from the current moment. So suspect that I'd say this is the main case here.
00:36:30.908 - 00:37:02.550, Speaker D: Regarding others. Well, regarding others, oracles in general, kind of really close to the idea of ZK bridges in general, because in general they do similar things. So I'd say if you look at the broader picture, we say, okay, it's actually evolving to this part, to moving data basically from other systems in the space.
00:37:08.150 - 00:37:28.860, Speaker A: Well, okay, thank you so much. I'm moving on to the next question, which is mine actually, and it's for you, Nick. So it's about outsourcing proof generation in our world, full of distrust and about checking the proofs that are generated by proof market.
00:37:30.030 - 00:38:22.780, Speaker C: That's the neat part. We don't trust them because we will verify every proof that we get. Like I said already, proof market internally verifies the proofs that it gets from the proof producers. Well, because it has internal mechanisms for rewarding and of course punishing producers depending on their performance. So they should not just generate random data and call it proofs. But it's a trustless system, it's a trustless word. So we will not trust anything except like the cryptography algorithms that we rely on.
00:38:22.780 - 00:38:27.600, Speaker C: So yeah, we'll just check everything.
00:38:29.410 - 00:38:41.614, Speaker A: Okay, so in tomorrow's newspapers, like Cointelegraph, Neil doesn't trust Lido and Lido doesn't trust Neil. Okay.
00:38:41.812 - 00:38:46.926, Speaker B: Yeah, I can come out with strategy safely.
00:38:46.958 - 00:38:51.160, Speaker C: Say that, yes, we are building a trustless solution and we are proud of it.
00:38:52.570 - 00:39:07.270, Speaker A: Okay, sounds great to me. Any more questions for us? So if you have trust issues, you know how to solve them?
00:39:07.880 - 00:39:08.292, Speaker C: Sure.
00:39:08.346 - 00:39:32.900, Speaker A: Okay, we have one more question from Ash. Okay, this is a question for Neil foundation. So I suppose Nick or Ilya should answer that about our part in this collaboration. And what's our contribution to the success of the ZK Oracle product?
00:39:38.410 - 00:40:21.460, Speaker C: Well, let me start. We are building the tools, the tool chain and ecosystem for building zero knowledge applications. And how does its expertise contribute to the success? Well, we have been building our expertise since two k 18, I think, and we are happy to share it with everyone. Building zero knowledge applications. Ilya, can you add?
00:40:22.310 - 00:40:57.120, Speaker D: Yeah, no, in general, yes. Well, as Nick, basically we are developing toolchain for ZK applications. It can be used for any ZK applications and yes, it's actually our part here for contribution of this project is mostly about the quality of this tool chain, the quality of the proof system behind of this stuff and all these things.
00:41:01.750 - 00:41:15.830, Speaker A: I think we can also ask Misha to add something. Let me give you Misha Kamarov, the CEO of new foundation, without a camera. Yes, sorry, I don't have a camera.
00:41:16.970 - 00:41:44.494, Speaker E: I don't have a camera today. Yeah, okay. Well, basically answering this question is, yeah, kind of built a tool. This oracle. This oracle is a very nice use case and a very nice demonstration of usability of this tool chain, of its usability of the fact that it can and it solves problems. That's basically what it is. And we obviously helped the fellas who built this.
00:41:44.494 - 00:42:11.800, Speaker E: And I mean, we got to admit that it wasn't, it wasn't Lido fellas, it wasn't us directly. But in the end of the day we obviously helped everybody in terms of how to put this properly, how to design this properly, how to integrate this properly. So this could actually solve the problem, not just do something. So. Yeah, that's what it, that's, I guess I hope that answers the question.
00:42:14.110 - 00:42:25.340, Speaker A: Well, okay, thank you. If we don't have any more questions, I suppose we can wrap it up slowly. Nick, do you want to add something?
00:42:30.130 - 00:43:07.420, Speaker C: That's basically it. So yes, we had this discord link. Let me show it for a few seconds more and then I'll pass the microphone to Eugene who will also. Yes, I will remove this one and Eugene will make another invitation. Welcome to the discord. Ask your questions, get to know about the next events. Just come chat with us, we'll be happy to have you there.
00:43:10.110 - 00:43:18.880, Speaker A: And here's Ash asking one more question. Exactly about event plan. So maybe you'll be kind to answer it.
00:43:23.410 - 00:43:32.110, Speaker C: Oh wow, that's a lot to talk about actually. Um.
00:43:33.990 - 00:44:10.942, Speaker E: Yeah. Everybody's waiting for somebody to take an accountability for this response. Right. It requires us to spoiler quite a lot. Okay, well, let's go for it. Some of those things we can talk currently is, well, let's say this way, we have recently finally got ZKML extension for the compiler in progress and we hopefully will get this announcement and all this work public. Maybe not this, maybe not this week already.
00:44:10.942 - 00:44:12.542, Speaker E: I mean the end of the week already.
00:44:12.596 - 00:44:12.910, Speaker B: Right.
00:44:12.980 - 00:44:26.660, Speaker E: But maybe next week. So it's going to become public. That's the first thing. The second thing is, as I already mentioned, I don't know, should we spoiler doom landing or something?
00:44:30.890 - 00:44:33.990, Speaker C: I don't know if you're in doubt. Ask the CEO.
00:44:36.330 - 00:44:38.040, Speaker A: Do you maybe know him?
00:44:38.410 - 00:44:55.820, Speaker E: Yeah, I got to ask him. Okay, I'll ask him. Yeah. All right. So anyway, I kind of spoiler. We kind of spoiled room thing already. That's the next thing.
00:44:55.820 - 00:45:16.100, Speaker E: Let's say this way. What else can we say right now? It's a good question. It's a good question. I can say explicitly later. Ask me explicitly later. It's like quite a lot of things. No.
00:45:17.830 - 00:45:38.460, Speaker C: Well, I have one thing that is certain, and that is certainly not a secret, is that we're going to have more public events, hopefully once every two weeks, maybe more if it goes well. So come and join us next time. And more and more.
00:45:39.310 - 00:46:01.460, Speaker A: Yes, we are actually planning a lot of cool stuff, so stay tuned for updates in our twitter and on our discord server. We'll post the announcement there. Okay, thank you, Daniel team, thanks to Misha, Ilya and Nick. Yes.
00:46:04.070 - 00:46:07.870, Speaker C: Eugene and his important invitation.
00:46:07.950 - 00:46:27.980, Speaker A: Yeah, sure. I would like to thank the new team and let them go if they want to be elsewhere. So thank you, Ilya. Thank you, Michelle. And yes, let's get back to Eugene because he has something else to tell us.
00:46:29.630 - 00:47:06.290, Speaker B: That's it. Yeah. I'd like to take my last word to say that Leide is always seeking for new projects, new cool ideas. That's why you can achieve us through research forum. So post your proposal and maybe you will be funded with Lego committee to build up your idea to implement your proof of concept. So it's a way to deliver not only changes for Lida, but also push forward public goods and many cool projects.
00:47:06.370 - 00:47:07.000, Speaker C: Yeah.
00:47:12.760 - 00:47:13.364, Speaker A: Okay.
00:47:13.482 - 00:47:14.052, Speaker B: Thank you.
00:47:14.106 - 00:47:15.270, Speaker A: Thank you so much.
00:47:15.640 - 00:47:16.710, Speaker B: That's it?
00:47:17.160 - 00:47:20.088, Speaker A: Yes, I think that's it for today.
00:47:20.254 - 00:47:25.304, Speaker C: Guess what? We have one more question. May I please answer it?
00:47:25.342 - 00:47:29.364, Speaker A: Bring it up. Yeah, sure. Let me put it up. Here it is.
00:47:29.422 - 00:48:12.250, Speaker C: So that's also a good one. That's what the whole event is about. Find some good implementations for zero knowledge technology and build zero knowledge apps on Neil tool chain. And we'll help you with advice, training and other things. Just build zero knowledge apps. That's the future. And we are building the tool chain for that future.
00:48:13.660 - 00:48:31.952, Speaker A: Yes. I think the biggest contribution you can make is to become the part of our community. Build your apps on our tech. Ask your questions. Maybe if you want to contribute into our projects. Well, most of them are open source. So come to us, be with us.
00:48:31.952 - 00:49:07.350, Speaker A: We'll be happy to walk through this journey with you together. I think that's it for today. We definitely have more to offer and more to show so please stay tuned for our dates in our Twitter. Also, subscribe to Lido's Twitter. They are pretty cool guys with nice tech. It was nice having you today. Nick and Eugene, thank you so much for joining and enlightening us.
00:49:09.600 - 00:49:13.116, Speaker C: Thanks. See you next time. Okay?
00:49:13.218 - 00:49:19.800, Speaker A: Thank you, everybody. Have a nice evening and a good weekend. Bye.
