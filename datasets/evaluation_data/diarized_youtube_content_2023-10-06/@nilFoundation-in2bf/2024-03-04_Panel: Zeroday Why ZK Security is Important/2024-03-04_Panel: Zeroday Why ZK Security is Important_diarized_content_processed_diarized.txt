00:00:00.250 - 00:00:21.150, Speaker A: Our final panel today delves into the critical topic of ZK security. Please welcome Grigory Rosu of PI Squared, Maro Tuscano from Lambda class, and Costas Ferles of Veradece. Moderating this discussion is Ibrahim Yusaf Ali of polychain. Please welcome them to the stage.
00:00:49.820 - 00:00:53.050, Speaker B: Hello. Hello. So, mine is working.
00:00:55.420 - 00:01:00.552, Speaker C: Yeah. Hello, guys. Yeah, I guess we can get started with this panel. It's going to be about zero day.
00:01:00.606 - 00:01:00.824, Speaker D: Why?
00:01:00.862 - 00:01:12.892, Speaker C: ZK security is important. Yeah, my name is Ibrahim Yusuf Ali. I'm a researcher at Polychain Capital, and. Yeah, just wanted to let you guys go on with intros, so.
00:01:12.946 - 00:01:27.650, Speaker B: Yes. Is it working? Yes. No. Okay. All right, I will just use this one. I'm marutoscano from Lambda class. Cryptography, engineering, yes, mostly working with cryptography on the play side.
00:01:31.940 - 00:01:56.860, Speaker E: Okay. So, hi, I'm Cosas Ferles. I'm the chief research officer at Verdes. We're a security firm, and we're kind of, like, specializing in ZK. And we also develop a lot of automated tooling. So my job is kind of know see the needs of our auditors and kind of steer our tool development towards kind of more useful automated tools.
00:01:59.500 - 00:02:12.060, Speaker D: Hi, I am Grigoria Rocho. I am a professor of computer science, also the founder and CEO of runtime verification and of PI Squared. And I'm interested in correctness in general of systems.
00:02:13.280 - 00:02:26.290, Speaker C: All right, guys, thank you for those intros. Yeah, I guess we can get started with the panel for the first question. This is tomorrow. Can you walk us through how a circuit bug could result to the loss of funds for a ZK roll up?
00:02:29.040 - 00:03:16.990, Speaker B: So, yes, ZK rollups use, of course, zero knowledge proofs to prove that they have done a correct computation. Usually this is done by the company running the road lab, if decentralized or something. So that's a way to say, okay, we are being honest, but if someone can manage to send a proof that maybe he did a transaction that they weren't allowed to, or they were managing funds that they were not theirs, they can, of course, try to steal the money from the roll up or from anybody, or do any other malicious activity. So the proverb is, like the heart of it. If you manage to crack the verifier, you can do whatever you want. I don't know if you want to add something more.
00:03:17.680 - 00:03:53.990, Speaker E: So, yeah, I guess. I think it's more or less the same as any ZKD app, right. If your verifier doesn't capture the semantics of your intended behavior. Precisely. Then that opens the door to an attack. So if you have a trace that transfer funds and then one of the opcodes is not modeled properly, then I can say that instead of transferring x, I transfer ten x and then exploit the roll up.
00:03:55.560 - 00:03:57.928, Speaker D: Now I have nothing else to add.
00:03:58.094 - 00:03:59.610, Speaker C: Let's move on to the next.
00:04:01.840 - 00:04:05.230, Speaker D: Yeah, can you speak closer to the mic? I can barely hear.
00:04:09.520 - 00:04:29.360, Speaker C: Yeah, I guess we can move on. So the ZK ecosystem is pretty nascent, but I'm wondering if you guys have any specific exploits that you wanted to talk about in the past. Yeah, I'll let you take it off from here if you want to detail any of the reasons why exploits happen and the projects involved.
00:04:29.440 - 00:05:12.690, Speaker E: Yeah, I can start with that. So I guess one interesting one was like the tornado cast people that hacked themselves. So there was like an issue in one of the hash functions in circumlib, there was like a missing constraint, and that opened the gate to kind of drain all the funds. Then they kind of moved them to a new contract and contact everybody to mitigate things. So I guess missing constraints is kind of more common thing that you'll see. So yeah, I guess that was kind of interesting because the protocol itself called it and mitigate everything.
00:05:19.410 - 00:05:57.450, Speaker B: Yeah, I could add some other ones, for example, that certain exploit on the constraint level. So probably some unconstrained value or something. There also have been exploits like on the layer below, for example, Ariel founds some exploits on ccash that allow you to print money. So that was really bad. The good thing is usually people who know this, they are kind of good actors and they report it. And nowadays it has actually happened for a while. I think maybe you have some counter examples, but the most critical ones I know they were solved without anybody losing boons.
00:05:57.450 - 00:06:23.640, Speaker B: And yes, then protocols that are widely implemented, for example frozen hard exploit, allow you to exploit the value implementation of Pierre Shamir. That's also on the low level. And then you have exploits on the high growth level, maybe on the protocol, how you reach consensus, how the nodes operate. So yeah, for me those are like the three points you can actually exploit, and you will see things done.
00:06:27.700 - 00:07:13.340, Speaker D: Yeah, so I have not run specifically in any ZK errors directly. Compilers have errors, lots of errors. Right. And we are taking a big risk already with compilers. And then additionally we have all the problems with the ZK circuits for the vms. It's a huge trust base that we build everything up on. So we simply have to trust millions of lines of code in order to verify correctness.
00:07:13.340 - 00:07:18.080, Speaker D: So it's a serious challenge.
00:07:20.740 - 00:07:56.910, Speaker C: No? Yeah, thank you guys for that. So this is a good primer on why ZK security is important. And so we've dived into a couple of examples of ZK security exploits. But before this, I guess it's important to dive into advice for current ZK projects about how they can prevent exploits. And I guess a good question to get us started on that is how do we know if circuits improving systems are secure? I'm sure you guys'experience within that field. What advice would you give to starting CK companies?
00:08:01.540 - 00:08:48.692, Speaker E: Okay, I can start. The short answer is, of course, if you have been audited and well tested by someone credible. The best case scenario is if you have formally verified something. So the longer answer involves several security checks. You have to make sure that you have avoided overflows and fields, that you have instantiated cryptographic primitives correctly. That mostly applies for the proving side of things like the back end of ZK systems. And another thing that I personally think is important is if the projects and the circuits have been open source.
00:08:48.692 - 00:08:53.890, Speaker E: So the more pair of eyes on the code, the better.
00:08:57.170 - 00:09:26.700, Speaker B: I totally agree with the open source part. It's really important for people to be able to understand the code base and see if they. The more eyes you have on the code, the more chances you have to find a bug. So that's really useful. I like the definition that gave some other cryptography. I don't remember the name right now, but probably your system is secure if enough people try to break it during a long time. But that's not really satisfying because it's like, okay, I can't do anything.
00:09:26.700 - 00:09:37.360, Speaker B: All these kind of things like having really clear code, open source, that's probably important.
00:09:39.730 - 00:10:59.414, Speaker D: Yeah, so there are many facets to security starting with basic correctness. Many security issues are because of lack of correctness, and you don't really know unless you formally verify it. And even then you make lots of assumptions about the environment, about the formal verification tools, about the language, about the specification. The deeper you get into this, the more you realize how fragile everything is, to a point where it's almost scary, actually how fragile everything is. So I think we may actually need to rethink the whole approach. That's why I firmly believe in verifiable computing in general. Because mixing the complexity of the programming language or computing environment with the complexity of the zero noise circuits, and with lack of specifications, and with programmers who do not have a background in formal verification or analysis even, and with auditors who are in high demand but not enough right.
00:10:59.414 - 00:11:22.110, Speaker D: So I think there are lots of problems that we have to worry about. And I don't have a solution. I'm just noticing that this is a very complex field that accumulates all the problems we had already in the programming language and software engineering field. And now on top of it, we also put all the ZKE complexity.
00:11:23.970 - 00:12:02.694, Speaker E: Yeah. And I guess ZK also is kind of like a new paradigm, right. Where people have to think like as two different entities. Right. You have to think from the side of the prover and then the side of the verifier, and you have to define kind of sufficient and necessary conditions that kind of guarantee the correctness of your system. And I think that's kind of one of the most common things we've seen in our audits. And another thing, maybe moving to the advice part that you asked, what advice you would give to new CK developers.
00:12:02.694 - 00:12:33.110, Speaker E: I would say target correctness first and then efficiency, because we have seen a lot of cases where kind of like premature optimizations kind of lead to very messy situations. And then if your code has been kind of focused on optimization first, it's hard to kind of refactor it to make it correct. Right. Because you are already into the weeds.
00:12:34.730 - 00:12:52.780, Speaker B: An alternative that might be interesting is like to simply have more provers amplifier deployed. So the probability of finding the same exploit in many proving systems, in many circuits is lower. So that might add some kind of extra resilience. That might be.
00:12:57.930 - 00:13:21.840, Speaker C: Yeah, it's something downstream of this is what would you have seen as the most common know, I guess cost us with your experience as an auditor. Gregor, as somebody who's seen a lot of audits before, and Mara, as somebody who's written a lot of circuits, what would you identify as the most common mistakes that you've seen cryptographers make that they can.
00:13:24.370 - 00:13:59.706, Speaker E: Know? Number one should be things around the field, arithmetic. Because now you have languages where the overflow is not like c, where it's undefined behavior like the overflow. Now you know exactly where the wraparound is going to end up. Right. So attackers can leverage that pretty often. Can you hear me? Yeah. Another class is kind of like missing constraints.
00:13:59.706 - 00:14:54.000, Speaker E: We have seen a lot of systems that are essentially are nonderministic. For example, you can prove that you have two balances, and then if that's the case, people will always choose the guess. Like, you know, that's kind of like the big cases that are kind of like ZK, then the other kind of big class of errors that we've seen is kind of like the ones that in the intersection of the ZK and defi component. Right. Because the two usually have to interact. And we have seen several cases where the ZK developer thinks that the check will be performed on the defi side, and then the defi side believes that the tech will be done on the ZK side, and nobody does the tech.
00:15:00.820 - 00:15:25.630, Speaker C: Yeah, I think also we touched on the frigility of the ZK ecosystem, and something that's been talked about recently is the composability within the ZK space that's proliferated within the traditional programming languages of leveraging off of audited modular code. But yeah, us. If you guys have any specific takes on that.
00:15:29.520 - 00:15:44.396, Speaker D: Ideally we should not write ZK circuits, we should not craft them, we should not custom made them for applications. We should have tools that generate them for us. Right. Directly.
00:15:44.428 - 00:15:44.624, Speaker B: Correct.
00:15:44.662 - 00:16:29.296, Speaker D: By construction. Like the ZkllvM approach is a great approach in that direction. So once we know what we want the circuit for, let's have machines generate the circuit for us. Because if we can generate code, that's common knowledge in program verification, that the best way to, or the alternative to formal verification is program synthesis. Generate the programs directly from their specifications, and then you don't have to verify them. They are correct by construction. To be nice to have something similar with ZK circuits, because sometimes even the business logic of the contract is complex enough that we mess it up.
00:16:29.296 - 00:17:08.540, Speaker D: Right. So if on top of that, we combine it with designing a circuit, with how many polynomials, how many parameters, there are lots of ad hoc choices made that can be in conflict with the business logic decisions that you make. So I just think the ideal, if we are to dream about an ideal world, it would be nice to generate all these circuits automatically from the security properties, maybe even, or correctness properties. Is that too much to ask? I don't know.
00:17:08.610 - 00:18:20.058, Speaker E: No, I'll check on that. And I think right now, most of the languages are kind of like writing assembly in the traditional kind of programming style. And that also not only complicates the life of developers, it also complicates the life of auditors, because you need auditors that kind of are familiar with several languages, or they have to learn a specific DSL, or they have to learn an API of ZK framework that uses rust, for example. Really well. And even in that case, as an auditor, you have to essentially run a compiler in your head, right, to kind of see what are the generated constraints and how the ZK system behaves. So, yeah, even if we had this pipeline that kind of spits out something from a higher level. It will also make the life of security analysts easier.
00:18:20.058 - 00:18:54.020, Speaker E: Plus, talking from Verita's perspective will also make the life of creating automated tooling for security. Because right now we kind of have to try to support several different frameworks and ecosystems, each of which kind of makes their own design decision. And it's kind of like tough.
00:18:57.920 - 00:19:11.440, Speaker C: Honing in to what you mentioned, costas, about languages and dsls within the Zk ecosystem. Can the language or framework used to write a Zk system affect the type of bugs that might be introduced?
00:19:12.820 - 00:20:25.640, Speaker E: So definitely. So I think there's a split between dsls that are kind of used only to run to write ZK components or languages are Zk centric, and then you have frameworks that are written in a general purpose language, like rust, and then developers have to use an API to generate circuits, and then these circuits participate in the whole protocol. So in the first case of the ZK specific frameworks, there we see more kind of like Zk type of bugs, like overflows in the fields, like unconstrained signals and so on and so forth. So for the latter case we kind of see those as well. But then you also see more traditional bugs, right? That if their values kind of flow into the ZK API will also affect the generated circuits.
00:20:30.340 - 00:21:16.396, Speaker B: So another difference we can make is between universal circuits and non universal circuits. So let's say you are writing, trying to prove a vm, like it could be maiden, kaido or CkE Vm, or that kind of vms. Then your circuit is going to be unique no matter the program. That's what we call a universal circuit. So in that case, the probability of programmer that's trying to write its own program of adding an unconstrained value, it doesn't exist because the programmer is not actually allowed to change the constraints of the systems. So maybe that's another difference you can make. In universal circuits.
00:21:16.396 - 00:21:57.740, Speaker B: The user can of course add security backs because it's their program. They might do something wrong. They might use non deterministic memory. That means they might hint something that might be wrong. But usually there won't be any mistakes on the constraints. And of course the other examples that were given before, when you are trying to, if you are the one writing manually, constraints, the probability of making a mistake, of having an under constraint value is really high. And then you have intermediate cases, maybe things that compile into circuits so they are more higher level, but not that higher level as to have a universal constraint.
00:22:02.380 - 00:22:35.590, Speaker C: Yeah, Gregor, if you want to jump in here, but, yeah, happy to move into the next question. Yeah, I guess talking more about the future now, about the future of ZK security, what do you see as the biggest challenges that you see in the ZK security space in the near future? I think we've talked about a couple of them, fragility dsls. Or alternatively, what would you interpret as the thing that you're most excited about in the coming year as innovations within the ZK security space? Happy for you guys to take the question wherever you guys want to take it.
00:22:39.030 - 00:23:35.730, Speaker D: Well, I can start. I can tell you what I'm really excited about, and I think that is the marriage of two important domains that are both concerned with correctness, but they lived separate lives until now. One is the formal verification community and formal semantics community, and the other one is the verifiable computing community. Mathematicians and logicians versus cryptographers. And they don't talk to each other enough. They don't talk to each other almost at all, probably. Veridice is one of the few companies that will try to use formal verification to analyze cryptography, but I believe that we can do more than that, more than just using formal verification to analyze cryptography, but to put them together in a way that they are more than the sum of the parts.
00:23:35.730 - 00:24:38.646, Speaker D: I know I'm unfolding my own agenda now, but I truly believe that we should go through mathematical proofs. So computation is mathematical proof, so why mix it with ZK? So let's leave the computation in its world to produce mathematical proofs, and then let's use cryptography to verify mathematical proofs. Because if we do that, then we get end to end verifiable computing. But going through the rigor of mathematics by construction forces us to do it right. It doesn't mean that we will not have security leaks or that we'll not have other problems, because the program itself may be buggy. But at least we don't take the additional risk that we mix the complexity of cryptography with the complexity of the programming language implementation. That's what I believe could help us innovate, actually even more, both on the ZK front and the programming language front.
00:24:38.646 - 00:25:10.318, Speaker D: Imagine that you want to invent a DSL for a particular kind of chain or upchain. You have a perfect DSL for your application, and then you'd like to have ZK. That's a nightmare. Now you have to hire a team of cryptographers and a team of programming language people and come up with a circuit for the DSL. Right. That's a huge effort which is not reusable by others. I think to me that would be really how I see the future.
00:25:10.318 - 00:25:22.870, Speaker D: That what would make the future exciting? I think where we put together two important domains that, you know, lots of years of research has been done in a way that is more than the sum of the parts.
00:25:29.230 - 00:27:03.500, Speaker E: So, yeah, I mean, like, I kind of agree. And then going back to what we're saying earlier, right, higher level abstractions where you kind of specify what you want to kind of achieve with your privacy preserving application and then you have a layer that automatically translates to something that you know will run correctly. That's kind of like an exciting kind of future to me. But to come back to the silence part of the question then the challenge is there is kind of like, okay, now your trust base becomes like this compiler or synthesizer or call it whatever you want. So that will be the next big challenge if we go down that road and then touching upon kind of another challenge that I think it's kind of like a challenge even now navigating the alternatives like one has when picking with ZK framework or language to pick is going to become harder and harder. And I think byproduct here is that we will need more kind of education for developers to make sure that they pick the framework that fits their needs and they just don't pick something just because it's currently kind of like the hot thing to use.
00:27:07.970 - 00:28:10.718, Speaker B: So there are a lot of things I'm waiting for, Cam, that I expect we can do in the future. I think moving to some higher level language, maybe starting to code just in Ras or whatever language people know, make the proofs that will probably make system safer. If we get the proving systems to go fast enough. Maybe we can dream of not even using one proverb, then code just one time code, one time in ras or whatever, use many different provers, have many verifiers and that's going to be much, much more secure. And the other thing I'm quite excited about is that more people are training the space every day we have more and more people. So at the beginning maybe you have like 1050 people that could really say if there was a problem. Now we have a lot more of eyes on these things and combining this with open source projects will make that in the long term our projects are going to be much more secure.
00:28:10.718 - 00:28:14.740, Speaker B: Much so I'm quite optimistic on all of this.
00:28:17.110 - 00:28:37.260, Speaker C: Yeah. Related to the future of ZK and the things that we're excited about. Although there is a lot of things to build towards. It is also our responsibility to build towards this future responsibly. Right. And balancing the trade off between ZK security and the pace of innovation. Just to set the scene here also.
00:28:37.260 - 00:28:59.650, Speaker C: Yeah, ZK rollups started almost four years ago, or the ZK space kind of even at large. And a lot of our code is finally going to mainnet after years of development inside house. And so yeah, I'm curious about you guys'perspective on balancing this tension.
00:29:05.480 - 00:29:25.550, Speaker B: I think this tension is not something special in CK. Happened a lot in web two and traditional computing. There's always maybe a tension of people wanting new stuff and people wanting things to be secure. And if you want things really fast, maybe you want to, hey, let's push these changes. I want this new feature. I want this to go really fast. I need this.
00:29:25.550 - 00:29:38.930, Speaker B: That generates a tension between change and moving forward and having something stable and secure. I don't have the best answer on how to handle that, but think it's a challenge we'll have to deal with.
00:29:41.540 - 00:30:14.990, Speaker E: Yeah, I guess I agree that this is not kind of like a ZK specific problem. It's kind of like you always have this mentality of move fast and break thick type of thing. I think what's a bit scarier about the case, we have to be a bit more careful because especially for privacy preserving applications. Right. There might be like an exploit out there that we don't know about it yet. Right. Because things are encrypted most of the time.
00:30:14.990 - 00:31:18.050, Speaker E: So I guess maybe to balance things, I would say if we kind of as community, kind of decide on a set of primitives that we are interested in kind of using to build things moving forward and have these kind of primitives be well tested and well audited or security analyzed and being open source, I think that kind of will open the door to kind of building more secure things into the future a bit faster. So I think, for example, Polygon started some sort of initiative to that front with plonky three. Sorry. Where they have gathered a set of primities for implementing polynomial iops more efficiently. So I think things like that will kind of help us kind of balance the tension between the two.
00:31:25.570 - 00:31:42.980, Speaker C: Yeah, related to that, about how do we build sustainably and move quicker into the future. What about security checks for ZK circuits and automating? That I know Costas, you might have some specific thoughts on.
00:31:47.790 - 00:33:08.070, Speaker E: Mean like, you know, similar to any other kind of know at veridice we kind of develop tools to help us during our audits. So for ZK specifically, we do have static analyzers that will help us kind of cut the low hanging fruits on a system that we are about to audit. And there we kind of look for specific patterns. Now, these patterns are a bit different, so we kind of adapted and kind of developed new kind of detectors for ZK specifically. And then you move to kind of more exotic stuff where you formally verify properties for your circuits and then do have a tool that kind of proves that your circuit is at least deterministic, right? Whatever it calculates is a function, it's not a relation. You cannot have cases where you prove you have, for example. So that's kind of like one step forward to kind of more sophisticated.
00:33:08.070 - 00:33:37.700, Speaker E: So yeah, the next step after that will be to kind of verify arbitrary properties, which I think people do work on it. We have done some work in very nice as well. So yeah, I think that opens to ZK has a lot of opportunities for automating security.
00:33:39.690 - 00:34:36.214, Speaker D: So Costas answers the question so thoroughly that there is nothing left for me to add. I just want to emphasize that formal verification is the only way to assure correctness. No matter how much analysis, static analysis you do, or template or template detection, error programming patterns, you will never be sure unless you formally verify. And even then, even when you formally verify, then you are still not sure. I know this is not a positive answer, it's just that it's very hard. I personally believe that we need to rethink the whole problem going through rigor, through mathematical proofs. People have done that already in the programming language community.
00:34:36.214 - 00:35:28.970, Speaker D: Initially programming languages were just compilers, interpreters, and that's it. What is c? Well, whatever GCC implements, that's the definition of c. But then things evolved and we have formal semantics of languages, and those define what the language does. So similarly, I think we should take the problem at least equally seriously with ZK. Yes, Zk is mathematics polynomials, yes, but it's a different kind of mathematics, right? Yeah, I don't have a clear solution, more like a belief that we need to go through mathematical rigor between computation ZK and not mix them.
00:35:29.340 - 00:35:51.680, Speaker C: Yeah. How do you think moving forward, we should reframe that problem that you mentioned for the new age. Is there some kind of shift in thinking that needs to happen? What are your thoughts on the role of formal semantics in CK security moving forward? I guess even overall the role of formal verification.
00:35:53.060 - 00:36:50.912, Speaker D: So formal semantics and formal verification are different beasts. So formal semantics is the enabler for formal verification. We cannot do formal verification if you don't have a formal semantics, because you cannot define the problem of correctness unless you have formal semantics of the programming language. It's not clear how you can define that this program is correct or that it does anything rigorously unless you have a formal semantics. But the same formal semantics can be used to verify or to enable verifiable computing, where use the formal semantics to generate mathematical proofs of execution and then verify those with ZK circuits. And this way you don't have to worry about the implementation of the programming language itself, whether you capture the right semantics. And that at least eliminates some headaches.
00:36:50.912 - 00:37:28.320, Speaker D: At least now you have to worry about the program. Only. The program may have security problems, but at least I eliminated the programming language and the compiler from the picture. Yeah, in order to do that, we need a formal semantics. Right, and many languages don't have formal semantics, unfortunately, but many also have formal semantics, including the popular languages. But again, without formal Semantics, we cannot claim anything about correctness. It's just the best effort.
00:37:31.820 - 00:37:41.996, Speaker C: Great. Yeah. I'll also leave it to the panelists. If there are any certain questions that you want to push back with each other, or you want to talk about anything in specific in particular, feel free.
00:37:42.018 - 00:37:45.852, Speaker D: To also the audience, if they have questions.
00:37:45.986 - 00:37:54.210, Speaker C: Oh yeah, let's open up to the audience. Yeah, happy to feel. Oh, we have one over there.
00:38:05.280 - 00:38:05.932, Speaker E: Sorry.
00:38:06.066 - 00:38:13.170, Speaker A: Hi. What's the security vulnerability for ZK that keeps you up at night? You're most scared of.
00:38:18.440 - 00:38:35.450, Speaker B: The ones we don't know about. If we know about them, we can probably fix them before. You usually don't have any clue of what can come. We have the areas that maybe they will be attacked, but you never know.
00:38:41.170 - 00:38:44.900, Speaker E: No, you read my mind. That's what I was going to say as well.
00:38:48.750 - 00:39:47.766, Speaker D: Well, in the world of formal verification, there was a case where the same question was asked about interactive theory improvers like cock lean and so on. And the main fear was that maybe I can prove false with an empty theory. So if you can prove false, starting with an empty theory, it means that you can prove everything. So the whole thing doesn't make any sense whatsoever. And people prove false using coke the first time, and then they fix the problem, and then somebody proved again false. So that's the nightmare of formal verification. And if you do what I suggested to go through mathematical proofs, if you have a framework where you can prove false in an empty theory, a logical foundation, you can prove false from an empty theory, then the whole thing collapses.
00:39:47.766 - 00:40:13.030, Speaker D: You can prove that factorial of three equals one. You can prove that sum of numbers up to ten is minus three. You can prove everything. And that's scary. That's the ultimate worry that I have, that I have a proof system, logical proof system that can prove false. That's inconsistent and that's not obvious. It's very hard to prove things mathematically consistent.
00:40:14.250 - 00:40:33.130, Speaker A: I just had one follow up question based on your answer. If you sort of were to observe the boundary of known and unknown, what boundary is most blurry, so to speak, that maybe keeps you up at night or gives you some fear?
00:40:35.790 - 00:41:14.658, Speaker B: So not sure if I completely understand the question, but I would answer to do tell me if this doesn't answer. I agree with what has been said. Probably you can qualify the possible exploits in different things. I think, for example, the lowest kind of exploit usually is denial of service. That is not related to constraints and probably doesn't worry us that much. The worst thing is breaking the whole proven system. And as they said before, proving whatever you want, no matter the statement.
00:41:14.658 - 00:41:36.798, Speaker B: And in the middle maybe just breaking one individual circuit. When you say, okay, this application is broken, but the rest is good. So maybe at least the damage is more localized, not affecting the whole system. So maybe that's the categorization of the unknowns. We probably fear more the unknown of something that breaks everything.
00:41:36.964 - 00:41:52.020, Speaker A: Yeah, just to maybe rephrase my question. I guess what I'm getting at is I want to get an understanding of your intuition for where security vulnerabilities may lie, even though you don't have empirical evidence to prove that they're there.
00:41:54.390 - 00:42:23.054, Speaker B: Okay. We have seen vulnerabilities in underlayers. To be honest. We have seen papers that claim a proof and the proof was wrong and they have been hacked. I think that's probably not the most common things. Then. There are a lot of implementation mistakes when people think they are implementing a protocol, but they make this little change or the code is not doing what they think they do.
00:42:23.054 - 00:43:05.820, Speaker B: So that's probably more related to format verification. So maybe that's a way to solve those kind of implementation issues. Then maybe as we keep adding things and adding more and more and more things and building things on top of the other things, picking all the teams are picking something that someone else made and tweaking it a bit and changing and adding some changes, those changes can also lead to mistakes because maybe the original author had a really good idea and the next one comes and just copy them and doesn't understand something and it gets changed and it gets exploit. Maybe that's the area I'm not sure if that answers a bit the question.
00:43:07.550 - 00:43:12.560, Speaker D: But what keeps you at night and how can we help you?
00:43:13.490 - 00:43:14.046, Speaker E: I don't know.
00:43:14.068 - 00:43:15.680, Speaker A: The stuff that you guys are doing.
00:43:17.170 - 00:43:18.554, Speaker D: We try to find solutions.
00:43:18.602 - 00:43:29.010, Speaker A: Right, right. But you're finding solutions at the edges, so to speak. So, yeah, it's really what you guys discover.
00:43:30.070 - 00:43:36.260, Speaker D: I mean, it's truly scary. If you can prove everything, right, then it means that you cannot trust the proofs. Why do we have them?
00:43:38.150 - 00:44:36.200, Speaker E: To answer again, like your previous question with the more specificity that you wanted from the second one, I guess, to me, are kind of like very deep, logical bugs that typically as either developers or security analysts or whatever title you want to put on someone, we have kind of like a very limited buffer on how far ahead we can think in terms of how an attack might play out. Right. So at the end of the day, the most critical bugs are like logical bugs. Right. So if there is a bug that requires, I don't know, like ten steps to be exploited, and then that will drain the whole protocol, that will keep me up at night for sure.
00:44:41.410 - 00:45:07.400, Speaker C: Yeah, I guess that's the zero days that we're talking about. So, yeah, thank you so much for elaborating on that. If there's any more questions, is happy to field them. But, yeah, feel free to come up to us and ask us any questions after the panel. But, yeah, thank you guys so much for listening in and, yeah, hope you guys enjoy the rest of the event.
