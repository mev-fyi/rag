00:00:00.840 - 00:01:08.324, Speaker A: So hi everyone, hope you see some familiar people from our discord presentation. So today I will explain you a bit about Ziki, Shardin and Shardapp's architecture. So first of all, let's start from Sharding, because I noted that Sriram community sometimes misunderstand schroding from from Ethereum and sharing from general database systems. And first of all, I would like to explain that sharing from database management systems sometimes refer to the idea of splitting some data, or in our case, splitting the networks. So if you have a single blockchain, this is just a single single chain network. Sharding means that you can have multiple chain that running in parallel, but they share same execution environments. So like on the picture, you can see that we have several shards that absolutely different networks they have in common.
00:01:08.324 - 00:01:54.368, Speaker A: Main shard used for synchronization and they operate in parallel. So they have their own state, they have their own execution pipeline, but at the same time they stay as a single chain. And later I will explain what does it mean. So, but first of all, let's understand why ZK, sharding and general, why do we need this idea of sharing when you split your network into subchains. So first of all, you reduce a fragmentation of liquidity from l one. Imagine that you have a lot of networks like carpet from optimism, Ziki sync. They all have their own liquidity.
00:01:54.368 - 00:02:40.394, Speaker A: So people bring money to these networks. But when you go to the decentralized network based on, for example, proof of state liquidity, most of the cases mean security. So when you split this liquidity between these chains, you potentially make them weaker to the attacks. So with sharding, your lack of this disadvantage, because you don't have this fragmentation. A common liquidity is shared between all chains, but they stay as a single environment. And all this money in a single environment. Also you have seamless execution environment.
00:02:40.394 - 00:03:43.744, Speaker A: What I mentioned, what does it mean? If you want to make communication between the key sync and target room, it will require you utilizing bridges. And it's not very cheap, it's quite long time and in general not very convenient. You cannot build so easily cross sharp across chain application. So it's not as easy. You can have a look, for example for cross network landings, it's not quite easy. While for sharding, when your crosshair communication is built into the protocol, your seamless execution environment is quite strength and also unlimited scaling. In general, you can add as many chains as you would like to, because you don't have any physical limitations other than building l two for example like adding another l two to Ethereum.
00:03:43.744 - 00:04:48.588, Speaker A: It will end up to some time when for example, your basic fees exceed the price that you can pay on this l two. So for the key sharding, it's not a problem because it's like a single chain as I already mentioned. So if we go to bird's eye view of the overall schema, you'll start from some PBS. PBS also known as proposal builder separation. This is a special kind of sequence that allows you to split builders people who can built in bundles. Bundles is just a set of transactions and proposers, people who validate these transactions and propose new block. So they quite interesting utilization in z keychart in that PPS is built with l one and l two.
00:04:48.588 - 00:05:48.556, Speaker A: So we have our own builders and proposals, while we can also have builders from the l one, because compatibility with Ethereum transactions. And in general this is very beneficial for builders and searchers from l one because the utilization rate that they use with Ethereum is quite limited because Ethereum is not quite fast network as far as you know. So they have a lot of expertise and not utilized, let's say power. So that can be used on l two and for our network. And in general, every single shard has its own memory pool and its own set of transactions dedicated to this pool. So if you would like to send transaction, you send a transaction for a specific shard. So to a specific pool.
00:05:48.556 - 00:06:43.354, Speaker A: But these shards has communication between each other using first shard communication and also submit their latest state to a main chart where it has own proven network for ziki proof or state transition ziki proof. And also the transactions goes through Ethereum as part of data availability and state transition proof correctness of main chart. So we go to sharding. And as I already mentioned, sharding is just splitting data into parts. But it also can be noticed that you split your processing to some independent subset of peers. In general for the treason we have a single validator set between all shards. But each shard has its own subset of validators.
00:06:43.354 - 00:07:35.574, Speaker A: That's defined after so called rotation event. So after some rotation subset of validators chosen and dedicated to a specific shot. And leaving this idea. In general you can have parallel execution, parallel states, but they are binding common and your computation going parallel. But it goes like pure parallel. So it's not like in Solana, you can have true parallelization because your states are not intersect and parallel. But at the same time you have a global, let's call it global state in main chart called consensus chart.
00:07:35.574 - 00:08:27.366, Speaker A: So what is the benefit of our roll up centric approach that's now used on Ethereum. So as was already mentioned, this is horizontal scalability and lack of fragmentation of liquidity. This is first major benefit. Also, it was said single application and consensus layer between these shards. So it's not like let's take a bunch of existing solutions, existing l two networks and find a way to unite them on some execution layer. Now it's more deep on protocol level, so you have even common consensus layer. It's like two levels of consensus that will be mentioned later, but it's also on a protocol level stuff.
00:08:27.366 - 00:09:31.178, Speaker A: Also low cost and high speed of transactions. Yeah, low cost is depend on the specific chart you're working on. But in most of the cases, by simple mathematical proofs, you can show that your cost, transaction costs will be quite spread around the charts. So you at any time, you will not suffer from high transaction costs. Because even if the load is too high, new network like new chain can be introduced and part of the load will be distributed to a newly raised chain and also multiple finalization levels. So it's like the idea when you can have not just a soft and hard finalization, but finalization on l two, several levels of finalization on l two. So like for example, when you send state transition proof to a consensus shard, this is one finalization.
00:09:31.178 - 00:10:26.004, Speaker A: For example, you proved on l two that your state transition is correct and your state can be used on other shards, while at the same time you can have a classic finalization on l one when consensus shard sends state transition proof to l one. So you can find the proper finalizations that you would like to use and you consider reliable one for your needs. So I mentioned about two types of consensus used. First of all, it's called local consensus and it's quite straightforward. It's one used on a single chain, on a single shard. So which Shard is decentralized network and it's, it has its own consensus, so it's quite straightforward. By some hot stuff, it's classic one PBFT a model.
00:10:26.004 - 00:11:14.456, Speaker A: So mass is specific, but the pipeline is quite simple, mass is very difficult. So just for those who know, it's just the current view. Selection leader selection commitment proposition block. And after that you vote for the proposed block and replicate the data. After every committee voted for this blog and also global, global consensus or global state synchronization also. So when every block, every shard has to send its latest state to a consensus shard. So it's used for several reasons.
00:11:14.456 - 00:12:45.200, Speaker A: You can imagine that when you have a lot of networks running in parallel and you want to send a message to some other chain, you have to know the latest state of the chain. For example, you want to send money and you want to know what is the latest state for the ERC 20 contract state of this account. So to understand this, you can take the latest state from the consensus chart that was sent previously by this target chain target chart and understand ok I know this state was the latest one. They can be already few blocks ahead, but you care only on the proven one so that you can see there already saved already correct and proved with CTA proof. And this cancens your shard also has confirmation as Bob mentioned, auto soft analyzation and also it's used for address resolution. So what does it mean? Imagine that you would like to send money to some contract and you have no idea about which shard this contract located. So for that reason the transaction goes or request special request goes to consensus shard where it's like mapping address to shard.
00:12:45.200 - 00:13:41.114, Speaker A: So like you have some address, you understand what is the shard id for this address and send transaction data. So this is quite simple for the this consensus chart and global state synchronization works on the diagram on your screen. So first of all, each herd sends transactions to sandblock m, let's say for time k. So you can imagine time k and you can see on the screen, I'm not sure, can you see my mouse? Probably this is update state rule for sometime k and here for transaction two. So for chart also some transaction k. Yeah, in general it differs, but we say same like k here and a time here. So in practice that will be different time.
00:13:41.114 - 00:14:56.524, Speaker A: And you have also state proof for some block that happened to be k minus ten. So that means that you prove the state that was sent to consensus chart ten t ago, let's say like 10 seconds ago, we consider that we have each block 1 second. So at the time t will be sent a proof for the block t minus ten. Yeah, because proof generation is quite complicated task first complicated because of time and because the computations are very hard. So it's quite unrealistic to send a proof at the same time when you have your latest state hook, so you send your proof like for the blog before and in general it goes like that. So you have k, you send a proof for k minus ten. And for example other charts can consider block k minus ten is finalized on l two and we can consider that it's true finalized.
00:14:56.524 - 00:15:48.654, Speaker A: But if I want, for some reason latest state in general submitted consensus sharp. You can use also this one that it can be used for some applications that maybe not require strict finalization. Maybe, I don't know, something not related to money. Yeah, and you can see like after analogs you will have the proof for block a that was submitted 1020 ago. So quite, quite simple. And what about sequencing? So sequencing the part of every decentralized network that tells you, okay, how you process your transactions, so how you work with them. And as was already mentioned, we utilize PBS model.
00:15:48.654 - 00:16:49.276, Speaker A: And for the PBS model in general, we also allow one network to handle multiple transactions. And it benefits us because first of all we have more decentralized and reliable searcher builder network. And also we have some sort of competition between native builders and searchers and from builders and searchers from L1 that in general will benefit the protocol. And it also introduces liveness. So at any point of time we can be pretty sure that our model boards and yeah, we also like have additional network support. And this is how sequencing schema works on a high level. So in general, as was said, mempool actually shared.
00:16:49.276 - 00:17:42.744, Speaker A: It's not actually shared. That means that l one searches and builders just have access to the mempool of charting through those shards and they just select transactions for searchers and builders and build the blocks and sends relayers on l two while proposers are only ours. So we don't share proposals with l one. Yeah, because definitely it's quite impossible for all for that system. So let's talk about data availability. So data availability are first to a few concepts. First of all to concept of sending data to Ethereum.
00:17:42.744 - 00:18:31.694, Speaker A: Needed or sufficient to prove the correctness of your state on l two. And sometimes it also refers to the idea of rebuilding your tool state from a one submitted transactions. In general, it consists of two possible solutions. First of all, this is sending a compressed transaction from l two to l one. So you can just execute transactions and get back your state of l two. Our second option is sending state divs. So you send to a one state if between some time t and let's say t minus k.
00:18:31.694 - 00:19:19.814, Speaker A: So in general, second, options considered more efficient because especially for the networks with high load. Yeah, because your accounts are quite limited. So like you have quite limited accounts, number of accounts and storage cells. While transactions may be old and let's say you have trading for some for one account. So you change your balance like 1000 times. You have 1000 transactions, but at the same time you just change a single cell like a single memory cell. So it's more efficient for such high rolled system.
00:19:19.814 - 00:19:53.558, Speaker A: So state is submitted as call data. Now it's one like blobs l one. So we will utilize new EIP 4844. But for the proofs that is submitted to l one, they will be submitted as call data. It's part of call data on the l one transaction and verification will happen on l one using class executes. So state transition proof. And yeah, so these commitments are stored in no one as a chain.
00:19:53.558 - 00:20:31.350, Speaker A: So what that means. So you can restore from these statives any change that you submitted to. So you can go like chain by step by step like from there and to the beginning and restore the whole state of your l two at any time. And simple example of such a preservation starts. It's quite classic signature period. Whereas data zk proof and verification passed. And this is just the quick idea of state state.
00:20:31.350 - 00:21:43.944, Speaker A: If, yeah, just everyone understand this is a simple picture that shows like if you have some state at time n and time n plus one, you can see that at time n plus one you have some red state root. So you will have finally it at the top of your tree. So it will be not changed. So you can like replace your state n root with state n plus one. But that means what I mentioned, we have this replacement with high load. So if you have like let's say most left corner cell, red cell, if you just have a lot of transactions that change a single chain, a single cell memory cell, it will be more efficient to store your state these because you will only keep only sends the latest state of this cell. And that's all you are not cared about states before, only the latest one.
00:21:43.944 - 00:22:45.434, Speaker A: So and let's talk about this cost. So we're interested about the cost of data availability in general. Target of the key churning is 60,000 tps one block per second. And we consider that we have six blocks. That means like you pick static between state n and state n plus six and your numerical stake tri depths is just average three. Yeah, it's quite easily can be shown that the possibility to have something worse is just less than 1%. And using just simple calculations, you will receive that with this price 2900 you will have data availability transaction cost these $3 it's not including actually proof verification and proof.
00:22:45.434 - 00:23:40.234, Speaker A: And considering like six blocks Div that will have a price additional price for two transactions on data availability just very miserable. Like 14 times ten over minus five, it's too low price. But you should keep in mind that this is just additional price for data availability. This is not final cost. But in general such an idea will keep very low price for data availability. And in general, some researchers show that data availability cost for l two at like 50% to 80% of the l two cost. So we have to understand that in general data availability price is like major part of your total transaction cost.
00:23:40.234 - 00:24:49.580, Speaker A: Okay, so let's talk about how we build applications on such system. As you already noticed, this is not a classic single chain blockchain like arbitrum or ethereum. This is a bit more complicated system. And first of all I would like to mention that in general development experience will quite likely similar to what you have now, like compatibility with AVM. We will have facility language, hard HUD and any other tools that you're familiar with, metamask or any other. So nothing very specific other than asynchronous environment execution. So what does it mean for you as a developer? You have to understand when you send a message from one chart to another, this is a bit more complicated than just call the function like function on same chart.
00:24:49.580 - 00:25:28.834, Speaker A: It's a bit more complicated because you have to send it as a special message. And here simple example of such a message. It's quite intuitive and it's shown like sending just a band on theory. Oh sorry, on solidity so quite simple you have some topic and topic is just depends on what you would like to have. Like send in message sending data sending whatever you would like to. It's defined by the developers target Shard ID. So quite intuitive.
00:25:28.834 - 00:26:27.604, Speaker A: This is ideal the target shard you would like to send this message to also target address. So this is address of smart contract on the target shard and function selector. So who is familiar with solidity, understand what does it mean? If you're not familiar you can consider function selector is just a kind of API, but function selector used to proper select the function in some smart contract. And you just need a simple event. So you can see an event like topic, target shunt id, target address functions later and definitely arguments you would like to send. Very simple and you can be sure that this message will be delivered to the target shard and when it will be delivered. Let's define when.
00:26:27.604 - 00:27:09.146, Speaker A: So when you send cross message across shard message, it can be delivered in two ways using oracles or routing. With oracles it's quite simple. So oracles is just let's say third party that takes your message like event and sends us a special message to a target shard. It's fast and quite simple, but for the verification and correctness you use also routing. Routing used like it's shown on the picture. You have some source message shard and target shard. You have an intermediate shard connected.
00:27:09.146 - 00:28:04.784, Speaker A: So you should understand that if you have, let's say, thousand shards, it doesn't mean that every shard will be connected directly to any other shark. It will be some kind of network, like, I mean like network, like Internet IP network. And they will be connected in some sparse way. So you don't know whether like your target shard will be within two shards or three shards in distance. But routing allows you to direct your message to a target shard. So like, you send a message to a connected shard and these shards, see, okay, if this message is for me or not. If not, they just directed message further and it goes until it's reached the target.
00:28:04.784 - 00:29:09.434, Speaker A: And it will not have such code problem when it will send everyone and create such rubbish on the network, because you will have some routing table. So this is like network above the network. And when your message will be delivered, for that reason, we have some global stabilization time. You can imagine this like a time barrier by the time we try to synchronize the latest state of the system. So we try to keep all the shards updated with the messages that were sent and sign point of t. And if this t is sent between JST and GST plus one, we try to guarantee that your message will be delivered at time GST plus one at least. So it means that your message will not take much time to reach the target.
00:29:09.434 - 00:29:48.020, Speaker A: Yeah. Otherwise your network will be like not partition tolerance, but we have partition tolerance network. So let's go with a bit more complicated examples. And this is complicated example with context saving. This is one of the most common patterns in asynchronous execution patterns. If you familiar with, let's say JavaScript, you can be familiar with it or C. So you can be familiar with such a pattern.
00:29:48.020 - 00:31:09.696, Speaker A: So this pattern means that, okay, if you have a request to send the process some data to a destination shard, you have to receive some reply. And depending on this reply, you would like to whether continue process or stop the process. So how it works, let's say you have some execute function that just update the counter and you just go from top to bottom and follow me. So first of all, you have your counter and save like temporary counter and try to understand, okay, so if update required. So okay, you update your counter if you have some response, if you require update, you can send a message to a target contract that is located on other chart and actually just respond to with the same message. Let's say for example here, it's just send message back to the execution contract and how this call looks like. So as you remember, you have some topic, you have target id, you have target address and you have function selector.
00:31:09.696 - 00:31:58.294, Speaker A: Here we see how function selector calculated. This is classic from the solidity. Yeah, I showed it just to explicitly introduce how it works. So you have your API get context and actually you have your search shard id source address and you send this context request. So when this message comes to get context, you just send it back target to this becomes two target shared target shared id topic. So everything is quite simple, you just send it back. And here again, what happens? The message goes again to execute function and goes over again.
00:31:58.294 - 00:32:15.914, Speaker A: Okay, you ask when it stops. Yeah, it stops when require update function comes true. Oh, sorry. Becomes false. And when the function becomes false, you just amaze that. Okay, we're done. We calculated it.
00:32:15.914 - 00:33:05.494, Speaker A: So, okay, I believe that it's quite complicated, but let's have a look at such pipeline, it will be more understandable. So you go from left to right, you have some execution code execution. And you understand in the code that, okay, cross chart call needed, you save your context. Yeah. What data you would like to save at the moment to restore later. You save this data, invoke the function to call the cross shard and stop execution. So your message goes to Shardk and invoke target contract that you quote from your shard.
00:33:05.494 - 00:34:06.826, Speaker A: So it executes some code and prepare message with results. So these results invoke your function again and you continue your function with restore the context that you previously saved. You restore this context, continue execution with the received results. And if you understand that, okay, you need another curl, you need another crosshart function call to, let's say sharp t, sharp f, you go like here, understand the cross shard coding and repeat this again. But you see this important part in the middle that you don't have execution between. So as was said, you stop execution when you save context and create cross article. You should understand that this is just a pattern.
00:34:06.826 - 00:35:03.542, Speaker A: This is not just how the protocol will look, but this is how pattern can work for such a system. And with such system you can achieve arbitrary cross sharp communication calls with feedbacks in fully asynchronous environment in EVM. And here is the final example of ERC 20 token transfer. And here example is very simple. Here it's very simple because as far as you know, your C 20 builds around the idea of message sender, a general message sender is restored using signature that you signed a transaction with. But the uniqueness of the situation that the messages between cross shards is not just a simple transaction. It's a sort of message.
00:35:03.542 - 00:36:08.244, Speaker A: And this message restores your context in this. This means context like message sender, message value, message bounds, etcetera, restored as it would be on the source shard. So when you send message to a target shark, the data that you fulfill, it will be added with some metadata, like message sender, message value, balance, whatever, and sends to target, and it will be restored by. By virtual machine. So you can be sure that when you send a message from, let's say here, like spending on other shard. So if you would like to spend money on other shard, you just simply create this simple cross sharp transaction. You call transfer address and amount, classic ERC 20.
00:36:08.244 - 00:37:16.182, Speaker A: And you can see that you don't have message sender in any parameters because it will be saved by protocol, by the person who will create this message for you and send it to target ERC 20. And when this transfer function will be called message sender will be restored from your. Sorry, from your spender on the other sharp. So it's quite, quite tricky, but it allows you to create some sort of solutions that will not differ from the synchronous contract. So this is quite simple, by the way, but in general, it allows you to build a lot of applications that in general, even in synchronous execution, is not very simple, by the way. So this is all. Thank you.
00:37:16.182 - 00:37:24.514, Speaker A: Thank you very much. Please, if you have any questions, I will be glad to answer.
00:37:28.134 - 00:38:17.224, Speaker B: Thank you, Ilya. Thank you for the awesome workshop. And everyone. If you have any questions at all, just drop us a message here and Ilya will be able to answer you. Also, if you, if you feel like speaking using your microphone, just let us know and we'll, we'll give that. Okay, I think there's no questions. Oh, there we have one area just popped in the chat.
00:38:17.224 - 00:38:22.524, Speaker B: Now Mohammed is asking us how to scale up.
00:38:23.844 - 00:39:11.384, Speaker A: So, yeah, in general, if you refer to how to scale up the network, general. So as I was mentioned, it's scaling using additional chains. So if you have too many, if you have too high load, currently, you can add another chain that will be running in parallel. So, like, imagine, let's get back to some. Yeah. For example, in here, you have three shards. So if you experience high load, permanently high load, there can be added another shard or shard, and it can be just embedded to the whole system.
00:39:11.384 - 00:40:02.724, Speaker A: So you can see that you will not have any changes to the protocol itself. Like running a new chain is very simple. So it's just running a new chart, like you just run a new shard from the very beginning, allocating new subset of validators and that's all. So, and you will have a fourth shard. And for example, new users, new applications can be deployed there to reduce the load on the other shards or some, some applications or users can be distributed there. It will be like not mandatory, but it can be done like this. So that's why the scaling is horizontal.
00:40:02.724 - 00:40:23.984, Speaker A: You don't need any changes, you don't need any fixes to the existing solution, to the existing code, let's say simple. So you just run a new chain and that's all. I hope I answered. Yeah, we have some hand.
00:40:27.364 - 00:40:28.564, Speaker B: Yeah, thank you for that.
00:40:28.604 - 00:41:15.054, Speaker A: So I will read so how the tokens are different and how will it affect the migration of current contracts. A short number have to be included. Yeah, very good question. In general, standard of token will not differ. Yeah, this is one of the important things that we try to keep to have full compatibility with Ethereum standards and Ethereum infrastructure and ecosystem. But yeah, definitely it will require some changes and let's say simple. So if you have your smart contract, ERc 20, let's say for example, smart contract on shared one, there will be no changes at all.
00:41:15.054 - 00:41:51.624, Speaker A: But okay, you have shard two for example. So, okay, but the contract is on shard one. For that reason used cross shard communication using some proxies. For example, proxy is just a skeleton of your c 20 contract. You can call it interface, that just redirect request to shard one. And as you probably, okay, just a second, I show once again on this example. So you have classic ERC 20 and here you have request from the different chart.
00:41:51.624 - 00:42:46.122, Speaker A: So you call it as a proxy. So you send a message and this spender on the Azure shard contract will be just replaced to ERC 20, token proxy for example, and it knows the shard id, the contract is deployed and it will just send a request to the target contract. That's all. There will be a very simple situation when you just have a proxy that sends messages for you, but you will see it just in ordinary, let's say transfer for you. There will be no difference, you will don't experience any changes. So something like an internal routine. Yeah, so yeah, this is a draft example.
00:42:46.122 - 00:43:26.494, Speaker A: Yeah, in general it's possible to have some internal routing, but it's yet not understandable if the system will be static. Codynamic we are working currently on that. If the system will be dynamic, it will be a bit more complicated to handle for the static system. So static means like when you have pretty predefined number of shards and in general, in that system. Yeah. Quite likely that will be hidden behind the protocol logic. Yeah, you won't need.
00:43:26.494 - 00:43:53.026, Speaker A: This is just example. Yeah. You have to understand that examples of these smart contracts is just examples. This is not like it will look like. Finally, this is to explicitly show how it will look like in general. Is there a way. Is there a way for me to get a copy of the presentation? I believe, or be.
00:43:53.026 - 00:43:58.574, Speaker A: Maybe we'll share later in Twitter or right now.
00:43:59.554 - 00:44:36.744, Speaker B: Yeah, the presentation is being recorded and we're going to upload it onto our discord, uh, the educational channel. So you guys will be able to have the presentation and everything over there very soon. Are there any more questions? If there aren't any, we'll be closing it off here. Thank you, Ilya, for the wonderful workshop presentation. And thank you, everyone, for participating up until now.
00:44:37.044 - 00:44:51.984, Speaker A: Yeah, so, yeah, thank you very much. Yeah. If you will have any technical questions and you would like to know more, some technical details, you can reach me, discord or Twitter. So direct question to me. I will try to answer it.
00:44:55.124 - 00:45:03.304, Speaker B: Awesome. Thank you, everyone for participating. We'll hopefully see you in the next one as well. Have a great day over there.
