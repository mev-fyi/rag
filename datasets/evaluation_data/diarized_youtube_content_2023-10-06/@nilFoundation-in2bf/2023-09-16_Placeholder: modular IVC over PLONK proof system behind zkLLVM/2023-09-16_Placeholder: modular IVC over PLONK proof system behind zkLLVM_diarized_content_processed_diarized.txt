00:00:03.290 - 00:00:30.280, Speaker A: Hello and welcome to this tech talk. I'm Nick, developer advocate at Neil foundation. And today with us in the studio is Alisa Charnayeva, head of the research team at Neil foundation too. Alisa will tell us about the placeholder, the modular system, the modular proof system. But we've. But before. Sorry.
00:00:30.280 - 00:00:58.030, Speaker A: Turn. Okay. Something strange with the sound. Okay. Things happen. While everybody is still joining us, let me tell you a few things. First, please tell us a few words about yourself in the comments.
00:00:58.030 - 00:01:57.452, Speaker A: What projects are you building right now? What programming languages do you use? Are you using zero knowledge technology in any way? What do you know in general about ZK proofs and proof systems? Second, while Elisa speaks, feel free to ask your comments in the chat. We'll answer them during the Q A sessions. There will be two sessions and finally join our discord to stay in touch and be the first to get to know about the new events. The link is in the description and in the comments in the YouTube chat. Come on, I want to see at least one comment from someone who is here with us. I see. Ash.
00:01:57.452 - 00:02:18.660, Speaker A: Yes. Hello Ash. Hello Brian. Hi Alexandra. It's a pleasure to have you all here. Anyone else? Fine. Well, let's start then.
00:02:18.660 - 00:02:22.900, Speaker A: Alisa, I'm passing you with the microphone. Please welcome Alisa.
00:02:23.900 - 00:02:54.130, Speaker B: Hi everyone. Yeah. Firstly, I just want to add one question to nix. I'm really, really interested what exactly you want to get from all ZK technology. Why you here, what you want to achieve. I would be very happy if you waste a little bit time and bright towards it. Thank you.
00:02:54.130 - 00:03:39.456, Speaker B: Okay, now we can start. I wanted to discuss a little bit more about placeholder, about our modular design and all of this. So how did we speak? Firstly, we will discuss about modularity. Afterwards I give you some real use example and we try to understand how we can build a shortcut. After this we will be discussed a little bit more about placeholder parameters, how we can tune it with one. So let's go to the first topic. It's about modularity and it's just why we call it modular pro system, why other pro system is modular as well.
00:03:39.456 - 00:04:26.164, Speaker B: Yeah, I have some simple answers. It's just because other pro system has one security assumption, one field, one commitment scheme, one lookup technique, or maybe it hasn't any lookup technique at all. And one approach, how we can generate gates. So in placeholder we have another thing and let's just look at my examples. It's here, it's real application for all Newcastle. And firstly it's Mina and Stellana state verification. It's an example of ZK bridges and it's based on elliptic cursor arithmetics and ZK Doom.
00:04:26.164 - 00:05:03.500, Speaker B: It's example of ZK gaming. It contains no usual game dev logic inside. So why I combined it together, it's just because it has firstly it's some big input and secondly it has some different calculation insides. So what could be set up for our placeholder? It would be custom plon cache gates, it would be big field not trusted setup. It would be hash input verification. Because how I said it, big input and lookup technique not dependent comparing friendly scurves. And let's look to another setup.
00:05:03.500 - 00:05:44.116, Speaker B: It's an example of ZK Oracle Lida. We can prove how we can transfer information from consensus layer to smart contracts and ZKVM together. It's just not so big input because we can get it from some public ledger. And for more important, it's repeatable creation insights. So we can use IBC planned cash arithmetization. We have small field not trusted setup, direct input verification. And again, lookup technique which doesn't depend on parent friendly curves.
00:05:44.116 - 00:06:23.012, Speaker B: So how we can see it's a different setup and for now we need different proof system. Or maybe we need to take one proof system and modify it, but it's not so easy to just take and modify it. So for our placeholder we just get it, you just run it with desired parameters. So something like that. And yeah, I think it's enough presentation for now. We will return to it. But now I just want to give you some real example how we can build circuit from the source of code.
00:06:23.012 - 00:06:49.310, Speaker B: We just take for example, for now it would be mina state verification. Yeah, let's look at this. Okay, you can see it's a kimchi verifier. It's not all Mina state verification. Yes, because we have a pickles as well. But it's enough for today. Let's look at this.
00:06:49.310 - 00:07:23.850, Speaker B: What I try to do now, I try to find which circuits we need to build so we don't need it. And we start with oracle function. What we have inside. Let's look at this. We have inside absorbed function. It means what we need to Poseidon component because insights, it's generally just hash function. And for simplicity we just call it Poseidon for now and absorb commitment as well.
00:07:23.850 - 00:07:59.590, Speaker B: And we would have some challenge function. It's Poseidon too. Yeah, we have another one function. It for example would be, let's look at this. It would be po function. Look, it's po function. It would be a multiplication component, because we need multiplication and let's go further and it would be addition component here look.
00:07:59.590 - 00:09:29.940, Speaker B: And it would be subtraction component. It's here. So yes we need to build all these components to create some handy grid and circuits. But if we go here we can see what we have some different linear combination here and here we have another one here we have another one and here and I'm sure what we have and some evaluation function, another function, another combination of just simple multiplication and addition. And really if we try to build it on ourselves it would be not so easy, it takes much time, it can take months and it's not good thing. It's just because we have VKM we can just build some simple building blocks. And not to go to some handicrafted circuits.
00:09:29.940 - 00:10:41.950, Speaker B: We just need to find what exactly would be building blocks and from which building blocks we can create overall circuits. So how I said before it would be Poseidon, it would be pole component, it would be more easier multiplication, addition, subtraction components and I'm sure we need inverse component. Also let me look a little bit more to this because I'm sure we would need something else here. Let's look at this. We have multiscalar multiplication. Inside it would be divided on variable based multiplication and end of variable based multiplication. But for simplicity let's think about it, let's just variable based multiplication, yes, so let's say washed all file just to be sure what we didn't miss anything.
00:10:41.950 - 00:11:32.390, Speaker B: Yes, it's okay. That's all. Now let's recap. Always thinks you just start what we have like a building blocks for compiler. Always remember it's Poseidon component. Second, we have pO component and for really b components we have variable base multiplication. And for more simple components we have multiplication, we have addition, we have subtraction and the inverse component.
00:11:32.390 - 00:12:29.126, Speaker B: So it's just seven components. And we can express all this big file just from these seven components and get overall circuits just in, I don't know, just in minutes. If we try to do it on ourselves it would be months. So yes, I really like this thing and our compiler, it's just a way to get it more quickly. But it's a question now for now would be with circuits as much powerful like just human created. Yeah, let's think about it. I for now wanted to return to our presentation and think about circus parameters.
00:12:29.126 - 00:12:59.410, Speaker B: What we think about it. Firstly it's columns, it's rows. Because it's just a table with columns rows. We care about total amounts of gates we care about gate degree and lookup option. Turn on, turn off. Yeah. So for now we would focus it more on the columns parameter and about total amount of gates.
00:12:59.410 - 00:13:28.140, Speaker B: Just remember it. And let's return to our drawing. Yeah. So we have minestate verification for these free components. And it have some complex computation inside. So let's imagine what we created for 15 columns. Just example.
00:13:28.140 - 00:14:16.730, Speaker B: And it's pretty obvious what it would be three columns. And for inverse it would be four columns. Yeah. So let's try think like if we would use some naive compiler approach, how would be looks our assignment table. Let's take some shape and let it would be. It would be a block for Poseidon for Po and variable based Multiplication. Because it has the same number of columns.
00:14:16.730 - 00:14:52.262, Speaker B: Another block would be for multiplication addition, subtraction and a little bit more for our inverse. Something like this. Yeah. Good. So it would be better. It would be boring if we just take for one of the subconscious. Let's think about like it would be x three and x two.
00:14:52.262 - 00:15:29.460, Speaker B: Yeah. Okay. Here we have Poseidon component. We need to have pole component. And the last one it would be variable base. It would be better for multiplication component here. And knife approach would be just looks like this.
00:15:29.460 - 00:16:09.930, Speaker B: Multiplication, multiplication, multiplication after with addition and addition, addition, subtraction, subtraction and subtraction. 12312 free. One, two, three. Okay. And for true inverse control. Inverse. And the last one inverse.
00:16:09.930 - 00:16:50.674, Speaker B: And just look at this things how it would be assignment table looks inside. It would be just. It would be the same like Poseidon components. And here we would have empty spaces. And it's just little shortcut for now. But just imagine if we would take it, I don't know, 1000 times and we would have many empty cells inside assignment table. So it means we would have bigger polynomials.
00:16:50.674 - 00:17:31.830, Speaker B: Bigger polynomials would be influenced in gate argument. So how we know it gate arguments it's biggest part of proof of performance. And if we take just take with one component, with one result circuit. It takes much time to generate a proof. Yeah. I think you could say what we can create it in another way. Let's say what it's just like smart approach for compiler.
00:17:31.830 - 00:18:03.614, Speaker B: It would be the same for Poseidon Po and variable based component. Just because we designed it specially for Mina. So it's the best components handicraft. So the same beginning. And look at this part. So what happens? Multiplication another one. Multiplication and class.
00:18:03.614 - 00:18:56.592, Speaker B: Multiplication, subtraction, subtraction and class subtraction, addition, addition and addition. And we have three columns and we cannot to get it inside our inverse component. So we need locate it in another row. So it would be like that. And here overall assignment table will be like this. Here still empty spaces, but it's much less than before. But let's look at this.
00:18:56.592 - 00:19:43.124, Speaker B: Each component it's different gate. Each different gate generate their own selector column. So really it would be another one selector column, another one selector column, another one and last selector column. So for each new gate which we create. And honestly it's a not smart approach for compiler. It just has drawbacks, but it's a different site. So in the end we have much worse circuits when just human can design it.
00:19:43.124 - 00:20:46.120, Speaker B: But for now I suggest you to use flexible gates technique. If I tried to explain it in some simple way, it would be just avoid all intermediate variables and push it into one gate. Let's look how it would look like. So take the same beginning how I said it just was created especially from mina the best components and last one. So how I said we try to remove all intermediate variables. What does it mean in multiplication? Addition, subtraction, inverse components. We need to delete two sorry, we need to delete two variables.
00:20:46.120 - 00:21:29.370, Speaker B: Also we need to use two inputs and one output. For simplicity, let's think about like a sequential calculations. So let's try to write it. It would be two inputs. And these two inputs would be just for first multiplication. After this we have multiplication, multiplication, addition addition addition subtraction subtraction, subtraction inverse inverse in output. So let's try to calculate it.
00:21:29.370 - 00:22:13.860, Speaker B: 1234-5678 910 1214 15 it's the same size. And how I said we need to push it into one gate. No empty spaces. Just one gate. Yeah it's like example. And in this example we get in result just one gate. And in this example it would be much more, it would be four gates and in this example it would be eleven gates additional.
00:22:13.860 - 00:23:17.800, Speaker B: But you can just imagine the human would be created with circuit with one and flexible gates would be created automatically and just in few seconds. So let's return to our presentation and I just want to go more formally about flexible circuits technique. So what would be first? Firstly we have some metric function which evaluates all gate assignments. And it's really a matter of what parameters we get inside. We get in result from this metric function. When it's evaluated, we return to compiler work and it create overall circuits. And with circuits insights will be request to our building blocks like poseidon, pole components, all this thing.
00:23:17.800 - 00:24:00.200, Speaker B: And they will adapt to chosen parameters like here and another one interesting detail. Just return you please to my drawing. Yeah. Thank you. And let's return to our list of components and let's think about for example doom state verification. How I said, it's just a usual game dev logic. So we would have arrange check component.
00:24:00.200 - 00:24:45.750, Speaker B: We would definitely have some boolean components. We would have for example shift component and pole component. We can take from another circuit designer who created for example phone I'm columns. And we don't need to take the pole component and create it again. We just take it from our minostate verification. And it would be with our flexible gates just compress into nine columns. This circus would be as much powerful how it can be.
00:24:45.750 - 00:25:07.420, Speaker B: Yeah. Yes, I think it's time for a little bit break and I see your questions and I will answer for them after this break. I will return with another part of presentation.
00:25:12.480 - 00:25:41.930, Speaker A: Ah, so yes, a small break. Thanks for being with us. Um, let's, let's just look at the questions that we have so far. I see that. Oh yes, the discussion is already going on, so people are helping each other in the comments. Just look at that. That's beautiful.
00:25:41.930 - 00:26:47.730, Speaker A: We have questions from Vivek and Sergey is answering it. I'm sure Alisa will come back and give more elaborate answer, but yes. Great. While we are there, is it not the first Neil event for any one of you? I remember Ash in the comments. So has anyone else been with us already? Okay, I don't see any comments yet. Well, yes, and another one from Ilya, from Neil. He's also secretly here with us today.
00:26:47.730 - 00:27:23.290, Speaker A: So let's get to our first Q a session. Welcome back, Alisa. And I think we'll join in yard, just in case. Hey, he's the head of the protocol. Well, let's start with this one. So Alisa, could you please tell us more about the assignment tables? What's it you can draw if you want?
00:27:25.820 - 00:27:49.268, Speaker B: Yeah, it's Sergey says always. Right. It's just like a witness in circum. But we have not only witness, we have another type of columns. It's like public and some constant columns. So it's just some trace of all calculations. I hope you understand me.
00:27:49.434 - 00:28:00.488, Speaker A: Okay. What if people are not familiar with the notion of witness? Just the basic what's an assignment table used in place.
00:28:00.574 - 00:28:23.120, Speaker B: Yes. So it's separated into parts. One of it is just prover, not about it. And another one, I say it about like public input columns, like constant columns, selector columns with type of columns. It's improver and verified, know everything about it. So it's just values.
00:28:25.780 - 00:28:26.530, Speaker A: Great.
00:28:28.340 - 00:28:46.630, Speaker B: If you mind. Yes, basically, yes. It contains all intermediate calculation results. So each step then we are going through the algorithm. We just put one value by an hour into this table to check it later.
00:28:52.570 - 00:29:15.440, Speaker A: Great, thanks. Now that's another one question from ash. Thanks. What are the key takeaways or benefits that developer and the blockchain community can gain from using placeholder? I think that's a very general one, yes.
00:29:16.210 - 00:29:23.600, Speaker B: Could we return it after the second part of my presentation? Because I will have some answer for this.
00:29:24.530 - 00:29:47.190, Speaker A: Return to this question after. Okay, I've noted we will return to it. There's another one about working examples, and I think it also goes after because you will be talking about particular use cases.
00:29:48.730 - 00:30:00.540, Speaker B: No, I can answer it now, because I just wanted to clarify one thing. You mean you want to see some examples of flexible circuits? Yes.
00:30:06.210 - 00:30:09.840, Speaker A: Well, let's answer both questions.
00:30:10.690 - 00:30:42.780, Speaker B: Yeah, because if you mean some reddle circuits, you can go to and watch for mina state verification and Salana state verification. We have already have it. And for example, for flexible gates circuits. And it would be really interesting for you, but it's all circuits for ZK gaming. It's a shift. It's boolean components, pole components, all of the sync we have already. It's in flexible way.
00:30:46.420 - 00:31:41.046, Speaker A: Great. There is a. For the KLVM. Do you guys need to extend LLVM's IR in any way or just use LLVM extrinsic. Well, let me try to answer this. So ZK, LLVM is based on LLVM and using its own internal representation. I think we have to make some extensions to make special syntax for circuits parsed by the compiler.
00:31:41.046 - 00:32:22.704, Speaker A: But the most work goes in well on the other side where we compile the code into circuits. That's, that's. Yeah, we have very helpful viewers today. Sergey is answering, so yes means we need to extend it, I guess. What else do we have?
00:32:22.742 - 00:32:31.426, Speaker B: Here's.
00:32:31.558 - 00:32:44.000, Speaker A: Okay, well, I think that's all. I have a few questions myself, but I will save them for the next session. Are you ready to continue?
00:32:45.350 - 00:32:46.100, Speaker B: Yeah.
00:32:46.550 - 00:32:54.802, Speaker A: Okay, fine. Let's go. Slides or picture, Alice? Slides or.
00:32:54.936 - 00:33:08.280, Speaker B: Yes. Okay, fine. Really. Here would be answers for question. What I said for later. So you can just hear it about now. Yeah.
00:33:08.280 - 00:33:59.400, Speaker B: What we can tune inside the placeholder parameter, because flexibility in just in building circuits, it's not enough for us. We try to make flexible placeholder. So first of all, if you remember, we have something about big field and small field. And what I mean about it. For example, sometimes we have elliptic curve arithmetics and we need the big field. And another case when we just work with integers we can use some small fields. It would be the second option and our circuits will adapt to chosen option.
00:33:59.400 - 00:34:42.790, Speaker B: And if it was just one element, just one cell in assignment table, it would be just array of cells. Or it switch back and it would be just one cell. It's okay, our components can do it as a second option it would be choice of lookup techniques. And all approaches now is divided on two. One of them is depend of the main table size and the second one doesn't depend of the main table size. Yeah, it sounds better when it doesn't depend of maintable. For example it's a fork up balloon.
00:34:42.790 - 00:35:18.740, Speaker B: But we have some drawback here. We need to use field of parent friendly curves and it doesn't good sometimes for us. For example, it doesn't suit for Mina, it doesn't suit for Solana and even doom. Yeah, and the second approach which depend on maintable, it's a little bit worse. But we can use it always. So it's just like plunk up lookup and halo to lookup arguments. Maybe you hear something about it.
00:35:18.740 - 00:36:22.258, Speaker B: Also we offer some flexibility inside lookup tables. Okay, we have some result circuits from our compiler. If it would be big circuits and we would have some small lookup tables, we can compress it into one physical columns, several lookup tables, and another case when we get some small result circuit we can just can split it into several columns. So our lookup constraints would be like would be with value contains in first column or second column or n column. It doesn't get some overhead for proverbial work. So it's just some inner option. Okay, after this.
00:36:22.258 - 00:36:59.410, Speaker B: Yes of course we have a choice of commitment scheme. If you don't like trusted setup you would use LPC option and it would be frying site. Yeah, it has not so cheap verification, but if you don't care so much about Proverb walk, you can switch on green link option and it would be better. Also we have some universal trusted setup. It would be option KCG. It have chip verification. But yes you need just make your choice.
00:36:59.410 - 00:37:42.270, Speaker B: Also we have some flexibility inside choice how we can generate gates. First of all we have IVC plankish constraints about IVC. You can hear when you read about something Nova supernova hypernova. Maybe it would be cryptostar, but I really doesn't like just take r one cs and Nova. I think it would be better to use like in Protostar IVC plus blonde cache constraints. So it's now work in progress, but I believe to the end of year. We have implemented it.
00:37:42.270 - 00:38:05.266, Speaker B: We implemented it. So is the second option. It's a constant blonde cache gates. And of course also we have recursion support if you need it. And event verifier. Okay, let's give you some examples about it. How we can choose with parameters.
00:38:05.266 - 00:38:33.818, Speaker B: Firstly, we look at the Mina circuit. We build mina shortcuts. So just try think about how we can prove what we would be tuned in over alumina state verification. Inside mina use pasta curve fields. So we need to separate it into two parts. First of one would be on the palace field and second one would be on vesta field. Palace vesta.
00:38:33.818 - 00:39:04.714, Speaker B: It's a curves, pasta curves. We don't need any lookups, we don't need trusted setup. And how you can see in the source of code. It wouldn't be repeatable calculations. So we need to use custom plon cache gates. And we don't need any recursion because it fits to two in power 23 table. So it just would be one table and another site you can see.
00:39:04.714 - 00:39:43.282, Speaker B: Salana state verification. Yeah, salana use yeda field and it's not good even for kisig. No, for fry. So we need to have non native arithmetics. And as we have non native arithmetic, we can choose what we like. And in our case, let it put the pallet field because models of pallet fields would be bigger than models of udem. How I use non native arithmetics.
00:39:43.282 - 00:40:18.542, Speaker B: Also we use hash function, which is not circuit friendly. We need to have several lookups tables and it would be better to use general lookup technique. We don't need trusted setup. We would be used custom gates. Why we will use custom gates. Yes, we have some repeatable blocks because we have 1000 polydatters, but it's big block and 1000 it's not so big amount of repetitions. So it would be better in this case to use custom gates.
00:40:18.542 - 00:40:53.794, Speaker B: And how I said in the ladder case we have just a Merkel tree and 5 million of hash function. So in this case better to use AVC approach. And how I said it would be 1000 valid data. Each has their own signature and the signature with non native arithmetics. So we need recursion support to separate it into two circuits and bring them together. And it also give us one detail. We avoid lookup argument verification.
00:40:53.794 - 00:41:15.380, Speaker B: So we get cheap verification. Like for minostate verification. Yeah. Yes, I think I told everything what I want. Thank you for listening. And I'd like to ask for your question again.
00:41:19.370 - 00:41:44.890, Speaker A: Hello again. On the screen is a QR code. Guess what's there. The link to our discord. Please join us. And we have a few more questions. Now, the one that we saved for later is from ash.
00:41:47.250 - 00:42:15.640, Speaker B: Yeah. How you can see it, we have many options to build application on the top of this holder. You don't need to modify anyhow another pro systems. So it will be benefits. You don't need to think about another setup. It just could be easily. You just tick one option, another option, and you get a result.
00:42:18.010 - 00:43:28.458, Speaker A: Yeah. So I think this question has two levels, two layers of answer. First, one is about ZK technology overall. Like, what are the benefits of using anything? Zero knowledge in the blockchain. And the answer is generally, well, it's the future of the blockchain, and it can solve many problems which are not solvable with the current technology relying on trusted oracles and such and, well, among other proof systems. The reason for picking placeholder is, like Alice just said, that it's modular, and you get to pick the variables, I mean, the parameters, to flexibly build your application to its business requirements. And when they change, you can then change the setup.
00:43:28.458 - 00:43:36.780, Speaker A: Am I right, Alisa?
00:43:37.520 - 00:43:38.270, Speaker B: Yeah.
00:43:39.620 - 00:44:25.790, Speaker A: Okay. And that leads to my question. I will abuse the power of being the host to ask my own question. So if I build an application and I pick certain configuration parameters, how difficult will it be to change them in the future when the business requirements change? Like, I need more security, or I need to reduce the time, increase the speed, or anything else, what will I do? How complex will it be?
00:44:26.720 - 00:45:12.110, Speaker B: So it would be, firstly, you just need to think about what you need to get in results. And often it would be for first one goal, you need to know trust setup. You take LPC, you take some custom blunt cache gates. It works good for now, but after you understand, you don't need trusted setup. I mean, you can use some light trusted setup. You can afford yourself with one. So you just switch in the KCG option and, I don't know, it maybe takes five minutes, maybe more.
00:45:12.110 - 00:45:17.112, Speaker B: You just need to rebuild your setup precision.
00:45:17.176 - 00:45:24.610, Speaker A: I mean, just recompile it with Zikela. Don't I have to rewrite the.
00:45:25.620 - 00:45:26.528, Speaker B: No. No.
00:45:26.614 - 00:45:46.810, Speaker A: Okay. Indeed. Wow. Any more questions? We have one from Sergey. It's more of idea.
00:45:51.100 - 00:46:00.910, Speaker B: It's not so easy question, because I need to think about it and try to mention what I can say for now.
00:46:04.960 - 00:46:53.052, Speaker A: If you help me while you're thinking, I have one quite general idea. As always, it's bad to do premature optimization. So placeholder allows you to flexibly change parameters. And it would be a bad practice to abuse this. I know that security is good. I want super top absolute maximum security. I want, I don't know, the bits of complexity above anything that my application will ever need for security.
00:46:53.052 - 00:46:57.980, Speaker A: And then I will have very proofs that are very heavy.
00:47:00.820 - 00:48:19.370, Speaker B: We don't have some bad example really, but we can have bad ZK developer and it's just, I don't know, want to create some application with what we have inside. I don't know, just multiplication and something like kichak let it would be kichak and some design of kichak which would be used. I don't know, maybe it would be use 150 columns and in this case we get some good assignment table. But it would be best because we would have definitely much more witness column that we want. But yes, it's just some inner components. It's about some real use application. If I remember something, I will write you definitely.
00:48:19.820 - 00:49:17.050, Speaker A: Cool, thank you. But please don't call developers bad. I mean, they can make mistakes, but our job here is to help them not make these mistakes. So like, don't go over optimizing one of the parameters. And when you're in doubt, just come and talk to us in our discord, in our telegram. We will be happy to help review your architecture and the technical decisions that you're going to make. Ah, well, what else do we have? Come on folks, one time for one last question.
00:49:24.500 - 00:49:25.260, Speaker B: It.
00:49:25.430 - 00:49:32.890, Speaker A: Oh yes, this one. Didn't we skip it?
00:49:34.380 - 00:49:37.130, Speaker B: Yeah, I already answered for this question.
00:49:38.940 - 00:50:44.830, Speaker A: Okay. Yes, we just can remind that we have this. What? We have this in the implementation Mina State, Solana State. We have the project with Lida Zke Oracle going on. So stay tuned and get to know when things get released. Well, maybe now it's time to say thank you to everyone who has been with us today. Thanks, Alisa, for this journey into the depths of placeholder proof system.
00:50:44.830 - 00:50:56.770, Speaker A: It's been very enlightening, although hard sometimes. We hope to see you again.
00:51:00.820 - 00:51:08.164, Speaker B: Nick. Nick, stop. We have another one questions and I think you could answer for them.
00:51:08.362 - 00:52:33.772, Speaker A: Yeah, I like this. Well, what were the primary motivations behind the development of placeholder and how does it fit in the broader goals of the new foundation? Well, yes, a nice one. So we are building an infrastructure and ecosystem of products for building ZK applications. And we have everything ZK developers need on every stage, from developing and testing applications to launching them into production. Just picking some available proof system or just while implementing something that wouldn't require research from us, would make our ecosystem inflexible, not suitable for building all the ZK applications that can be made. And that's opposite to what we are going to do, what we are building. We want our tools to be applicable to practically any ZK solution.
00:52:33.772 - 00:53:15.470, Speaker A: So we need flexible modular system and it means that we need to do our own research to have the team which does this research. And alice here is the head of this team and we have worked on placeholder for a few years already and still continuing the work. All that to give you the best tools for your up. Just like that. Yeah. Thanks for the question. Well, it's been a pleasure to have you all here today.
00:53:15.470 - 00:53:21.160, Speaker A: Thanks again and goodbye. Goodbye.
