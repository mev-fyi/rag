00:00:00.730 - 00:00:57.070, Speaker A: Welcome back. In this lecture we're going to look at how to find profitable trading opportunities in DeFi. So you can think of DeFi as being this graph of financial products that's completely open, you can see everything, and hence you basically need to find the optimal path along this graph of financial products and you might discover profitable opportunities. Note that sometimes these profitable opportunities might be attacks, so you can even identify attacks with such tools. So let's dive in. All right, so how can we detect arbitrage or profitable opportunities in DeFi? In this lecture we'll be looking at mainly two methods. The first one is the Bellman Ford algorithm and the second one is the Ethereum solver, also typically referenced as an Smt solver in the literature.
00:00:57.070 - 00:01:56.706, Speaker A: The Bellman Ford algorithm is something that allows you to find negative cycles in a graph. So it allows you to basically identify whether you can do an arbitrage trade, a circular arbitrage trait. The beauty is it works among multiple markets, so multiple assets. So a market typically has two assets and you can chain several markets, as we will see in a later slide. So this algorithm is really extensively used in traditional finance and we show how you can actually use it in DeFi. The Smt solver on the other hand, needs to encode the DeFi models in a particular model. So while the Bellman Ford algorithm can be applied quite easily to a DeFi graph of markets, the Smt solver needs a DeFi model that's manually encoded, which is quite a lot of manual work.
00:01:56.706 - 00:02:47.970, Speaker A: However, the Smt solver can give you then a satisfiable path, which can be very rewarding depending on the solution that you find. So in order to reduce the search base of the Smt solver, you might want to apply some heuristics for path pruning, as we will show in a bit. And let's look into the specific systems that use those two methods. So they are both called DeFi poser, with ARP being the Bellman Ford algorithm and Smt the Smt solver version. So both depart here from a block I. So this is really the blockchain state or represents the blockchain state that you're looking at everything. Basically the past blockchain history here defines how we got to this particular state.
00:02:47.970 - 00:03:25.550, Speaker A: But for the sake of this example here, we're looking at this particular block i. So if the blockchain state changed to the previous state, which typically happens right in DeFi, people are performing trades on the market, then the state changed. Then we can call either the Smt version or the ARP version. So let's go first with the ARP version or the Bellman Ford DeFi postal. So we basically can build the DeFi graph of the various markets, which we will do in the next slide. And I will show you really in detail how this works. And then we have a negative cycle detection.
00:03:25.550 - 00:04:07.814, Speaker A: This is what the Bellman Ford algorithm can do. So the algorithm can tell you whether there is a negative cycle and there might be one or there might be not one. Sometimes you don't find any. Then we perform what's called a greedy search, right? So we can search additionally in the cycle detection, maybe you find several cycles and you take the one that's the most profitable for you. So we continue and repeat this process here. So the Smt solver, on the other hand, is a little bit more complex. It involves like several different steps, but in the end it reaches the same goal.
00:04:07.814 - 00:04:47.110, Speaker A: So in the first place, we have to perform a manual modeling of the DeFi protocol. So for example, we take uniswap and we write a model, a new model that represents how uniswap works. We do this with curve and with any other DeFi protocol that we want to capture. Then we apply a few heuristics path, trimming heuristics. For example, if we don't want to capture some paths in the stefi graph, then we can trim this here. So this might be sometimes interesting in order to reduce the search space. But we also have to be aware that these heuristics, they might cut some of our revenue.
00:04:47.110 - 00:05:53.498, Speaker A: And unfortunately, trimming heuristics is necessary because often the theorem provers are quite limited in their ability to solve problems. So depending on the Smt solver, obviously, but that's what we found to be to be useful here. And then you can basically plug this all in in the theorem prover and let the theorem prover run. So there are various theorem improvers out there, like z three is a potential one, Suflay is another one. So you can look into those yourself if you're interested. Everything that we get out here of this particular market should then be a particular trade that we should do, right? So for example, it might be we have to go to Uniswap, exchange ether to Dai, then we go to SushiSwap, change Dai to Ether. And this is a circle already, right? So this is a very simple arbitrage circle that these tools might have found, but they're also much more complex traits that can be found through these automated tools.
00:05:53.498 - 00:06:49.230, Speaker A: So you really get like this strategy or the transaction. And what you can do before you broadcast this transaction, you can execute it locally. So you perform a validation through concrete execution. So concrete execution basically means that you're executing a particular transaction locally on a particular block height and you don't broadcast it yet. And if you find it's actually profitable, then you might broadcast that transaction and you will try to mine this transaction at the top of the next block or at some position in the next block. I'm referring here to the top of the next block because you don't want others to front run your transaction and to take away the opportunities that you identified, obviously. Now this is basically the entire model, right? And the entire state here.
00:06:49.230 - 00:07:57.330, Speaker A: As far as I'm aware, this is the first tool that does this for you in an automated state in real time. So if you have here a block interval time of like, whatever, about 12 seconds, for example, in Ethereum, then DFI poser is actually able to give you a solution rather quickly in a few seconds. And you shouldn't wait too long. You should probably not wait 6 seconds even before you broadcast a transaction because the transaction also needs to propagate in the network, needs to reach miners, et cetera. But yeah, we think that it's really like a first step towards finding profitable opportunities in a DeFi graph based on a blockchain state and a DeFi state, because some applications might be sometimes vulnerable depending on their state. So these are not traditional vulnerabilities, but rather state dependent issues that might arise. And so we certainly need more such tools that allow us to reason about the security of the composable DeFi protocols.
00:07:57.330 - 00:08:29.466, Speaker A: Very well. Now let's look at the DeFi graph, like a particular example, at least of the DeFi graph here. For the sake of this example, we're looking at DeFi poser ARP so the Bellman Ford version of DeFi Poser, we have a blockchain state with four markets. Here we have the assets A and B. And here we have B-A-B and C and C. A. And if you look at these markets, we can already see that the red and the blue markets, they actually have both the same assets.
00:08:29.466 - 00:09:30.610, Speaker A: Our objective is we have an input which is here, one element of asset A. And we would like to input this particular element and get basically back out more, right? So we want to get out more than we put in initially. So this is what we basically visualize here with this particular example. Now, if you just look at this particular state, you already see, well, I mean, I could just go into the first market where I can trade A to B, and then I go to the third market here where I can trade B back to A. And my objective is that I get something back that's P one times PA right? Because these are the two prices on these two markets. And the profitable condition for my trade is that P one times P four is superior to one. If that's true, then I can perform a trade among these two markets.
00:09:30.610 - 00:10:49.238, Speaker A: Now, we can also perform a trade across three markets. So we could go again into the red market at the very beginning, right? So we go here into A over B, then we go to the second, to the yellow market here we swap B to C, and then we go to the green market here, where we finally swap C to A. So those two solutions that I just shown you are both cyclic arbitrage and they're both possible in this particular market state configuration. Again, just like the example, before, we have to make sure that the product here of the different prices is beyond one because we want the exchange to be profitable. And as such, we have this profitable condition that this is superior to one. Now, if we basically model this as a graph, right, then you can look at this really like here, like a traditional Bellman Ford graph. In order to apply the Bellman Ford algorithm, we need to find, I mean, the Bellman Ford algorithm can find for you negative cycles, so it has a negative cycle detection mechanism.
00:10:49.238 - 00:11:37.740, Speaker A: And for doing that, we need to translate it into this particular form that's expressed here. Okay, so we basically do this conversion, right, from this from the product of the prices superior to one to this particular sum. And we then apply the Bellman Ford Moore algorithm, which has the following complexity. So the number of nodes in the graph is n, and the number of edges in the graph is denoted as E. And so here, this is a particular node. An edge in the graph is this particular edge, for example. So the complexity of this algorithm is o n square times e.
00:11:37.740 - 00:12:36.000, Speaker A: So DeFi poser Smt is the other solution that we discussed earlier, right? So here we can basically see that. What we do is we have a model. In the very first state, we want to create a model that can be represented, that represents the DeFi actions and basically the actions of a particular DeFi platform. So we formulate it in the model. So for example, you can take uniswap, you can take curve, and then you really need to translate it. It's a translation process from one language, from, for example, solidity language to the symbolic model language that these Smt servers can operate on. Then we perform a path Pruning process where we can apply heuristics to reduce the search space.
00:12:36.000 - 00:13:18.634, Speaker A: So it's important that the path must not include any loops. For instance, we don't want to cycle indefinitely, so we want to find a finite solution. And then we can input all this into an Smt solver. So the Smt solver has an objective constraint so that the final profit is greater than the target value. So, for example, we can set a target value as being one ether. And then we can try to solve this and also perform optimization through binary search, for example, to find the optimal value. So the Smt solver will tell us whether there's a solution given that particular target value.
00:13:18.634 - 00:13:58.778, Speaker A: And if there's no solution, obviously we need to decrease. For example, we can go to 0.5, ether, et cetera, until we find close to optimal value with this approach. So when we evaluate default poser, we can actually compare the Bellman Ford variant and the Smt variant quite objectively. So in this plot here, on the x axis, you have the block number, which represents the time. So this is the blockchain time. So we evaluated this from beginning of 2020 until May 2020.
00:13:58.778 - 00:15:26.200, Speaker A: And in this particular example, you can see here the DFI Poser ARP, right, is this one here is actually found the highest revenue, right? So this is the cumulative revenue in Ether, as we express here on the plot. And you can see that the DeFi Poser ARP transaction fee is a little bit higher than the DeFi Poser Smt transaction fee, most likely because the ARP version found simply more potential sources. Okay, so then we have basically, as part of our evaluation, we had 96 actions on the uniswap banker MakerDAO markets, and we covered a total of 25 assets. So while this might sound like something, it's not really like a lot, right, in D five terms. So there are many more markets, there are many, many more assets out there that you could include in such evaluation. But it's quite, from an empirical perspective, it's really intense to model all these markets in, for example, the Smt version. So it wouldn't scale easily to perform such evaluation on any kind of market, at least if you consider the Smt market.
00:15:26.200 - 00:16:27.400, Speaker A: What's quite important, however, if you perform such experiment, is to perform concrete execution. So you want to verify whether what your models tell you is valid, right? So the models are obviously a representation of reality. They might not always represent reality. So that's something quite to be to be aware of and to be careful about. So overall, we found that the Deferposa ARP really generates significant higher revenue. I would like to note, however, that the Smt solver so we modeled actually the Bzigs platform in the Smt solver and found that DeFi Poser Smt was able to detect the BZX attack. So that's something that the DeFi Poser app is not able to do because there was no cycle in this particular attack.
00:16:27.400 - 00:17:04.610, Speaker A: So sometimes the more complicated tools, if you really model your victim platforms, you might find attacks, while, for example, the Bellman Ford algorithm might not be able to capture those. So finally, to just give you like, an overall comparison. So we have various methods to perform a path generation for finding profitable DeFi transactions. We have various path selection mechanisms. Some tools require manual modeling, some don't. So ideally, you don't want to have manual modeling because it doesn't scale. Otherwise.
00:17:04.610 - 00:17:56.950, Speaker A: However, you must or you should at least capture non cyclic strategies because most of the attacks that we are aware of are non cyclic. Finally, you might want to look at what parameters you choose and if they are optimal. And last but not least, certainly the complexity of your solution is important. So here you can see default boza ARP has only about 300 lines of code in Python, while the Smt version is almost an order of magnitude more complex. So thank you very much for your attention. I hope that you're quite excited now to jump on coding your own DeFi poser or new tool, next generation tool to find profitable opportunities. Whether these are arbitrage attacks or is all the ideas that you might have.
00:17:56.950 - 00:18:01.570, Speaker A: So try and get creative. I hope this was very helpful. Bye.
