00:00:00.410 - 00:00:54.298, Speaker A: Welcome back to the DeFi MOOC. Today we're going to discuss DeFi security. Security is probably one of the most important qualities, properties of a financial ecosystem. If you can't securely transfer or exchange value, likely not that many people will use the system or it won't be very sustainable in the long run. So let's dive into defi security. So when looking at DeFi, you can look at it as an ecosystem that's technically composed of the following layers. So at the very bottom, which I have not visualized here in this very slide, you can imagine the hardware layer, right? And the hardware layer is where your cpu, your computer, your hardware is running, and for example, verifying signatures.
00:00:54.298 - 00:02:09.720, Speaker A: So this layer, this very layer needs to be secure such that all the layers that build on top of the hardware layer can function in an integrity protected way. Then there is, for example, the network layer, right? You have here the network services, such as the domain name services IP, the Internet protocol BGP, and the peer to peer overlay of permissionless blockchains, for instance, then you have the blockchain layer. The blockchain layer needs to be secure in terms of consensus protocols, for example, the longest chain rule in proof of work, the incentive mechanisms have to be intact, the block reward needs to be paid, the transaction fees have to be plentiful. For miners to be incentivized to extend the chain. On the smart contract layer, the blocks need to be well formed, transactions need to be properly signed, and contracts should have, ideally no bugs. But as you have already seen in this lecture, there are obviously plenty full of opportunities for something to go wrong. Then there's the virtual machine, so there may be bugs in the virtual machine itself.
00:02:09.720 - 00:03:04.786, Speaker A: State transitions might go wrong, et cetera. On the default application layer, there are plenty of opportunities for things to go wrong as well. So we do have fungible and non fungible tokens, for instance, ERC 20 tokens, as you might have already been exposed to. But there might be ERC 20 tokens that are bogus or do have bugs, which again might cause issues in composable DFI protocols such as exchanges, loans, et cetera. On the third party layer, DFI is interacting with the very traditional UI or website components of the Internet of Web 2.0, if you will. So here, this is really the connection between web three and the traditional Internet.
00:03:04.786 - 00:04:12.910, Speaker A: And these components naturally have to be secure in order for DFI to function properly at the same time, if you're using oracles. So we have had an extensive lecture, a very nice lecture on oracles here, then these as well should be safe and secure. Otherwise the underlying DeFI protocols, for instance, might make the wrong assumptions. So if you look at an adversary here, this adversary can really attack on any layer, right? He can propose to try to, for example, block the transaction fee reward scheme, or he might disable through some eclipse attacks, for instance the peer discovery. He might mess with a DNS service so that peers can no longer find other nodes in the system. He might perform selfish mining. So this is for maybe here on the block and data layer.
00:04:12.910 - 00:05:19.220, Speaker A: He might, for example, serve a wrong website, serve just plain wrong Javascript HTML code to a client that's then being tricked into signing data or transactions that he doesn't want it to sign. So there's plentiful opportunities where an entracer can attack. And the goal today is that we really dive into these different layers and we discuss on each of them what are the possible attacks, or what are at least the subset of possible attacks. Obviously, we can't cover everything today. It's going to be otherwise a very long night or long day, depending on your time zone, and this is certainly not a feasible endeavor, but we're going to do our best into diving into these different types of security relevant items and explain various attacks along the way. So come on in and jump into the DeFi security lecture. Network layer security.
00:05:19.220 - 00:06:28.306, Speaker A: Every blockchain we're aware of, at least the permissionless ones, use some sort of data transmission network, like a peer to peer network in most cases, in some cases, additional private peering agreements among nodes. And as such, it's really important that every peer is kind of up to date with the data that's being distributed in this permissionless network. So in this segment of the lecture, we'll be looking at network layer security and what are the different things that potentially could go wrong? Right. Naturally, this is not an exhaustive list of all the possible network layer attacks, but it should give you a good icebreaker on what's possible there. So if you look at the network layer, we might ask, so why does the network layer matter? Well, we have all the information, like the information about blocks and transactions and even peers. It's being disseminated over the network layer, and this dissemination and propagation is happening in an asynchronous manner. Asynchronous, meaning that not all the nodes receive all the information at the same time.
00:06:28.306 - 00:07:27.420, Speaker A: And there's also often no guarantee on the bound on the time delay at which a particular node receives data. If the network propagation is based on IP, the Internet protocol, then the data transmission is really just the best efforts protocol. So there's no guarantee that your packet arrives. Even so, that's why we often use something like TCP, so that you have data packet retransmission in order to guarantee that the recipient actually receives some data. In some cases we might have UDP if there's a need for a quick burst of transmission. And in general, there are also more recent Internet protocols like quick, that might be applicable. So I really would like to encourage you to check basically what the latest blockchain protocols are proposing and whether there might be improvements that can be done, which may be a nice research project.
00:07:27.420 - 00:08:21.390, Speaker A: So naturally latency matters. So latency among the peers is really crucial. So if you have a rather larger network, like thousands of nodes, then the latency among those peers matter. So if you're having here one node that's then transmitting a transaction to another node, and this, which is connected to a third or then maybe a fourth node. So the latency, the transmission latency at every hop here really doesn't matter, right? So you want these latencies to be maybe on the order of 50 milliseconds or lower. But sometimes, for example, between Europe and Australia, there might be latencies beyond 200 milliseconds, which naturally then will delay the propagation of this very transaction. So there's an inherent propagation delay from the originator to, let's say, the last recipient of that transaction.
00:08:21.390 - 00:09:17.354, Speaker A: Now you might ask, well, how many nodes are there really in these networks? Well, if you look at bitcoin, there's a beautiful website called bitnotes where you can see a geographical distribution of the IP addresses of the full reachable nodes. When I say reachable, I mean nodes that have exposed the TCP port 853. This is the default bitcoin peer to peer port, and they're about 100,000. So this does fluctuate, right, because it's permissionless, you can just spin up your node or shut it down whenever you want. But over the years, over the last, I'd say four or five years, it's been actually quite consistent at about 10,000 nodes. So these are naturally just the reachable nodes. Reachable meaning, as I said, right, they have an open port, it's highly likely.
00:09:17.354 - 00:09:45.190, Speaker A: So if this is, for example here, reachable node, that there's maybe a light client. So let's assume this is here a mobile phone. So there are light clients with mobile phones, for example, that may connect to this full node. And these light clients, obviously they don't expose any port right. They don't service other nodes. So it's really just here, these full reachable nodes that have a full copy of the blockchain, by the way. So we call them full nodes.
00:09:45.190 - 00:10:45.930, Speaker A: And these nodes are responsible to serving kind of like a deeper network of, for example, SPV clients, simple payment verification clients. Now the tricky part is we don't really know how many of these, let's say lightweight clients there are. And obviously there can also be full nodes that are not exposing their ip. They can still be connected here to these different nodes. But let's assume I draw them here like in a shallow circle. So let's assume these are here nodes, they're connected somehow in this graph, maybe like this, and they are not exposing any TCP port, right? So no open port. And for these nodes, there are some techniques actually that may infer that there are these nodes.
00:10:45.930 - 00:11:52.880, Speaker A: There's for example a paper called TX probe that I can recommend you to read, which is quite cool. It's a cool technique to also infer a topology like which node is connected to which node, right? So there's a lot of work basically on the network layer of identifying who's connected to who, et cetera. But what we know is, well, long talk, short conclusion, we just know these number of publicly reachable node that you can look at. So I'll leave it to you as an exercise to check out the number of publicly reachable node, for example for ethereum or your favorite blockchain such as dogecoin or whatever, to see what's your number of full node. Notice that this number of full node doesn't really imply anything on the sense of decentralization. These nodes are not doing any mining or not necessarily doing any mining, so it doesn't immediately affect the security of the network. But obviously there shouldn't be just like three.
00:11:52.880 - 00:12:47.870, Speaker A: Well, three being just here, a magic number, which doesn't mean anything per se, but I hope you understand what I mean. You want this number to be reasonably high, that there is enough redundancy. But now whether we have 10,000 or 20,000, I'm not sure it does make a big difference on the decentralization of the network. There are likely other factors that are more crucial. So I already answered this question here to some degree. So we do have these full nodes, right? These are full nodes that host basically the entirety of the blockchain and light nodes that might, for example just host the chain of headers, just the block headers, while omitting the transaction content. A header in bitcoin is about 80 bytes in size, so that's a rather small amount times the number of blocks.
00:12:47.870 - 00:13:34.986, Speaker A: And you can calculate how big that would be. And then in order to verify whether a transaction is included in a block, you can run the SPV protocol that we discussed earlier in the lecture to verify whether there's a transaction actually in the block. And so these light nodes here often communicate with the full nodes, and they're really dependent on them. Right? So you have the light nodes, depending on your client, connecting to between five to ten full nodes and requesting data from those. So you might ask now. Good. Okay, I got a high level understanding of what this network looks like, but how do transactions propagate? Well, let's assume here we have this world map of just like two miners and a few nodes.
00:13:34.986 - 00:13:53.766, Speaker A: A few full nodes. That's just a few. Assume we have full nodes. So no lightweight clients here in this particular figure. And we have a trader. He issues a transaction, and he's willing to pay a transaction fee of five. So for the time being, we ignore what value that five represents or what unit this is.
00:13:53.766 - 00:14:24.702, Speaker A: It's just like an absolute number five here. So then this transaction propagates because it somehow propagates to one of those miners. And this miner has an internal queue. So it's called the mem pool or memory pool. It's basically a term stemming from bitcoin and other blockchains adopted that one where you have the list of unconfirmed transaction. Unconfirmed, meaning this transaction was not yet mined in a block. Right.
00:14:24.702 - 00:15:21.122, Speaker A: So you do have, for example, here already two transactions in this memory pool. One is paying a fee of one, the other one is paying a fee of ten. So if we add this third transaction, then the order in the final block that the miner would be mining could be the following, right? So the transaction that gets executed first is the one that pays the highest fee. So the execution order here would be then along this, basically in this direction. Right? So you have here transaction number one, which pays ten fees, transaction number two, which pays five, and transaction three, which pays transaction fee of one only. So we've looked actually at the Ethereum blockchain a few months back, and this is rough. Back then, roughly what, 80% of the miners were adhering to.
00:15:21.122 - 00:16:19.282, Speaker A: Right. This is the transaction fee order or transaction gas fee order. There are naturally other agreements, private agreements, other ways to pay miners that are where miners have become and community has become really creative recently, which is amazing to see. But in essence, at the end of the day, it's likely always the transaction that pays or rewards the miners the most will have the highest chance of being executed first. So what does that mean? Well, from a security perspective, because this is the security lecture we have to look at here, an attacker. So what could an attacker do given this knowledge? Right. Well, the attacker could create so called spy node, meaning a node that's connected to as many peers as possible, being here, these full nodes as well as miners.
00:16:19.282 - 00:17:37.870, Speaker A: If the attacker can identify the IP addresses of the miners and nodes of the miners net, obviously, but the attacker can really try to connect to every node, and we have seen dedicated clients doing that. So things they do is basically optimizing the Internet connectivity in terms of the latency, in terms of the upload and download bandwidth, in terms of the colocation to minus. So it might not even be only one physical spy node, but several physical spy nodes. For example, what we've seen is that the AWS networks are a really popular place to host, for example, ethereum nodes. And naturally, if you as an adversary, you're being co located in the AWS data center, and you're connecting to the nodes in that data center, you will have the quickest connectivity to those. So the attacker will certainly need to deploy basically several high frequency peers, spy nodes, if you will, globally, to have a complete picture of what's going on on the network. This is just a network layer, right? We are not yet at the blockchain layer where data is actually written into the blocks.
00:17:37.870 - 00:19:08.442, Speaker A: All right, so given this knowledge now, so let's assume we have here an adversary with a spy node, and naturally, because the adversary is so well connected, he will receive, or he will get notice of this transaction that's being sent with a transaction fee of five. Now, we have earlier discussed that we have here a mempool, right, the pool of unconfirmed transactions of the miner and what the adversary can do, because the adversary has a direct connection to the miner, so he can actually probably speed up the propagation of the victim transaction here of the five, of the blue, of the blue transaction with transaction fees. Five, by simply creating a transaction that pays, like one element more of transaction fees. And the adversary can even ship the victim transaction to the miner. Why would he ship the victim transaction as well? Well, it could be that the victim transaction is being stuck somewhere, but it's important for the adversary that the victim transaction remains close to the adversarial transaction. Here, the red one. So let's assume these two packets beautifully arrive at the minor, and then what you see here is this order, right? So you see, all right, so there's a transaction fee, ten, six, five, and one.
00:19:08.442 - 00:20:09.120, Speaker A: So the execution order will be the following. And we just said that this here is the adversary transaction and this here is the victim. So we can see here that the adversary is front running, the victim front running in the sense of attempting to be executed before the victim while basically acting on the information that this victim transaction is propagating in the network. So there are different definitions of front running, which may also have different legal implications. I guess I'm not an expert in that field, but the SEC, for instance, defines front running as an act of operating on private information in many cases, as far as I've understood. So here you might say, well, the knowledge that there's a victim transaction propagating isn't really like private knowledge, right? I mean, this is a public peer to d peer network. Everybody can connect to it.
00:20:09.120 - 00:21:11.642, Speaker A: So some might argue that this is maybe not a definition of front running according to some legal understanding. But I'll leave this to the regulators and lawyer to fully understand and capture. And I just want to show you here that there's certainly the possibility of replay of altering the order at which transactions are executed on chain, which has a significant impact on DeFi, as we will see in later sections, specifically when we speak about sandwich attacks. So front running is really like an important property. I can recommend you check out the paper Flash Boys flashboys 2.0. So flash Boys was a high frequency trading book many years back, and Flashboys 2.0 is kind of the, it's kind of the first paper that discusses.
00:21:11.642 - 00:22:09.142, Speaker A: One of the first papers that discusses front running in the and the public permissionless p to p networks of blockchains. Similarly, we have front running, but we do have back running, right? Back running is basically the same process as front running. However, the adversary tries to be executed right after the victim. So, for example, if there's a price oracle update, and you want your transaction to be executed right after the price Oracle update, you might backrun the price Oracle update because you're aware that there will be a state change upon the successful completion execution of the oracle transaction, and hence you can immediately, for example, liquidate a lending position. So the process is again the same. Right. So here there's a victim issues a transaction with transaction fee five.
00:22:09.142 - 00:22:52.594, Speaker A: The adversary visualizes or finds this victim transaction. Let's say it's a price oracle update. Then the adversary will issue an adversarial transaction paying the same gas fee or same fee, depending on your chain, obviously. So, same fee. And then what matters here is the order at which these two transactions arrive in the mempool of the miner. So if the adversary makes sure that the victim transaction is sent first, and then the adversary transaction is sent to the miner. In that case, as far as I have understood, Geth is currently ordering transactions in the following way.
00:22:52.594 - 00:23:57.910, Speaker A: So for transactions that pay the same gas fee in Ethereum, the one that is received first gets executed first. So you could obviously also pay a fee of four if you'd like to. However, if there's another transaction that pays five and arrives later, it might get executed before your back running transaction, which you maybe don't want to. So in a sense, the order of transaction execution is again the following. And here we have this time the victim first and then the adversary transaction afterwards. So yeah, as I mentioned here, this can be a liquidation, while the adversary transaction, the victim transaction, can be an oracle price update, for instance, right? Because based on this price oracle update, you can infer, well, I know that this depth position will be liquidated after the execution of this price oracle update. Hence I want to be the first liquidator and grab the liquidation profit.
00:23:57.910 - 00:24:39.270, Speaker A: So you've seen, right? I mean, there's so many things going on on the network layer. You have can front run, you can back run transactions. You have to consider with which nodes you peer with, which nodes you do not peer with, maybe even how to colocate in which data center to colocate. How do you manage your TCP connections? I mean, think of setting up like 10,000 of TCP connections. You probably need to increase the file descriptor size on your Linux machine. So there are really like a lot of network layer security aspects that you need to consider when doing front running or back running, or in general blockchain security. So very exciting.
00:24:39.270 - 00:25:27.122, Speaker A: Welcome back. One of the most dangerous network layer attacks are eclipse attacks. An eclipse attack is in essence something where you exclude a peer or a group of peers from the entire network communication. So it's really dangerous partitioning attack, in essence, where some peers might no longer receive the latest transactions, they may no longer know what's going on in the network. Did I receive transactions or not? So it's a very impactful attack with a lot of consequences down the line. So let's jump into it. So if you're looking at eclipse attacks, it's always easy or easier, let's say, to visualize the network.
00:25:27.122 - 00:26:50.426, Speaker A: How does the network look like? How do peers communicate to each other, and how does the information propagate to the peers. So let's assume we have here the leftmost node, and it's propagating a transaction or block along this network. And, well, it seems like one of these peers is actually malicious, right? So turns out that's our bad guy today. Now, this bad guy chooses to not forward a transaction or block to the rightmost victim here, and hence this victim is really eclipsed, right? This is very much the definition of an eclipse attack. So, eclipse attacks and permissionless blockchains in particular bitcoin, were first introduced by Heilman et al at Usenix in 2015, which was a similar paper that describes eclipse attacks in general. But to carry out this attack, there were like a lot of requirements, right? I mean, the adversary had to monopolize all the connections, as is the case here, right? So our victim here is only connected to one node, which is, well, bad luck, an adversary. And there were also the requirement that the adversary here spams the IP address information, so spams the number of addresses that the victim can connect to, so that the victim would only connect to the adversary.
00:26:50.426 - 00:27:48.222, Speaker A: The node had to restart, which is quite a strong assumptions. And obviously because of this construct, it required many bots, so many IP addresses that the adversary would control later. Quite shortly after, actually, there were more attacks coming by, eclipse attacks in particular, which have shown that it's actually enough if there's just one connection to the victim, and we don't require the victim to restart. So there are actually ways to perform eclipse attacks by exploiting the network propagation mechanism. So how data is propagated, right? Because here, for example, you need to have some communication protocol of how this transmission is done. So by exploiting this communication protocol itself, we can perform eclipse attacks. So eclipse attacks in general have dire consequences on a security perspective.
00:27:48.222 - 00:28:41.758, Speaker A: So one is a danger of denial of service because this node is no longer receiving here transactions from the network, so it cannot process or receive any payments. As such, it's no longer able to service. So that's why it's a dos. And the other problem is that it allows us to create double spending attacks where the adversary can trick the victim into accepting a transaction that might be conflicting with another transactions or n other transactions in the network. Hence the term double spending. All right, but let's first look into how we can create eclipse attacks based on the exploitation of the network propagation protocol. So, as I've mentioned at the beginning of the lecture, information is mostly propagated over the Internet protocol.
00:28:41.758 - 00:29:59.530, Speaker A: It's a best effort protocol, and as such, there's no guarantee that data is received at a given time, and therefore most blockchain p to p protocols that I'm aware of have so called request timeouts. So how long do you wait for peer to actually send you data? And these request timeouts can be static, which is most often the cases I've seen, but they could be technically also dynamic, and it would probably be quite beneficial for some of these protocols. But let's assume now we have here an adversary, and the adversary is advertising the hash of a transactional block to the victim. So in bitcoin, this is a common way to advertise to the victim. I have a transactional block, and this transactional block, they have the following hash. Now, the victim here in this case, will then request the data from this adversary. And even if there's another peer that at the same time advertises, or shortly after advertises the same transaction or the block, the victim will, in the first step, request this transaction or block from the adversary, and only if the adversary doesn't reply, given a certain request timeout, then the victim will request the data from another hopefully benign peer.
00:29:59.530 - 00:31:18.310, Speaker A: So in bitcoin, we have a block timeout of about 20 minutes and a transaction timeout of about 2 minutes. So as an exercise for yourself, I leave it obviously up to you to check out other chains, how they are propagating data, what are their request timeouts? I think this is quite an intriguing exercise for you, and then I'm almost guaranteeing you that you will find some security relevant issues there. So what are the security implications if we have these timeouts here specifically in bitcoin? Well, there was the possibility to blind a victim from blocks and transactions for more than 20 minutes in bitcoin. I've done an experimental validation, so this was actually tested in a local test network. And the impact from these eclipse attacks that are really purely based on the propagation medium is that you can perform easier double spending transactions, you can exercise aggravated selfish mining, and even network wide linear of service attacks were possible at some point. Luckily, this did not happen. So there are a few mitigation techniques that we can also discuss, but basically there are hardening measures that are possible.
00:31:18.310 - 00:32:24.342, Speaker A: For example, you can make the timeouts dynamic depending on the latency with your peers. You can request data from multiple peers, and you can basically estimate then how long you have to wait in order to be relatively certain. So, which you can quantify in probabilities that you have received a transaction. But let's dive into the eclipse requirements of these attacks, in particular, to fully understand the attack. So, the very first requirement is that the victim must receive an advertisement from the adversary first, so that the adversary is really the first peer that advertises a transaction or a block. So, for example, if the network here is advertising a block to the adversary, then the adversary will advertise this block or transaction to the victim, and the victim will say, okay, great, thank you. I will wait for you to send me the object that corresponds to this hash.
00:32:24.342 - 00:33:35.074, Speaker A: By object, I mean now the transactional block, for instance. And naturally, at some later point in time, the peer to peer network or the other connections of the victim to the peer to peer network, will advertise the very same transaction or block. However, the victim will, in most cases, or at least when following the protocol, will wait for the adversary to transmit that data. So, ideally, in order to perform an eclipse attack on the network, propagation protocol through the network propagation protocol would be by having a timeout, ideally, as was in bitcoin the case, a 20 minutes block timeout and a two minute transaction timeout. So now, how likely can we be the first node on the network? I mean, what's the likelihood of achieving that at all? So what we've done is a little experiment. So we have spun up a node in Zurich that is highly connected specifically to the bitcoin network, and then also to our victim nodes in California, Singapore, and Frankfurt. And we changed the number of connections that the adversary was running.
00:33:35.074 - 00:34:42.434, Speaker A: So we had 40 connections, 80 connections, 200, and then 800 connections. Right? So we had the adversary basically operating a variety of different connections here. So naturally, you might think, well, if we're running 800 connections, that's quite a lot. That's much more than the default average that we found at the time to be roughly 40. And so we've also seen that if you're operating that many connections at the time, you had a nearly 90% chance of being the first node in being able to advertise a hash. Right? So here, the bitcoin network basically advertise an object to our Zurich node, and then we would advertise this object to our victim nodes, which have all 40 connections in this example. And if the adversary had 800 connections in the network, then we had a roughly 90% chance of being the first to advertise the transaction or the block.
00:34:42.434 - 00:35:43.078, Speaker A: So that's great, right? This is the first requirement. So if we are playing well on the network layer, then we're having a good chance to be the first node there. And obviously, later on these transactions are being advertised to our peers, but that doesn't matter anymore because now the peers are just waiting for the adversary to transmit that data. Very good. So now we have on the network layer, we need the timeouts, right? So what happens if we are the first to advertise a particular transaction or block? So on the transaction layer in bitcoin, there's a first in, first out queue FiFO. So what an adversary was able to do, I haven't verified now recently, but this was possible, and we verified in practice that you can send transaction has Mahesh multiple times to the victim. And here in this case, if it's sent three times, there will be already a six minute timeout.
00:35:43.078 - 00:37:04.398, Speaker A: So you can basically stall the victim completely from receiving a transaction because of this relatively bad or unfortunate design of a five or q. So for all the versions of bitcoin. So luckily this was fixed after we published this attack. So for all the versions of bitcoins, it was possible that after 20 minutes there's a disconnect of the node and it does nothing. And so we've actually shown in the past how it's possible to do indefinite block eclipse attacks in bitcoin, because due to the network propagation protocol, I will spare you the details because luckily this is fixed by now. But this is just an example to show you that the security on the network propagation layer is really tricky to get right, and later on it might have dire consequences on the security of the underlying chain and the users as a whole. So I hope you like this lecture on eclipse attacks that work both by just basically brute forcing your connections on a peer, or by exploiting in a very nifty and clever way the propagation mechanism.
00:37:04.398 - 00:37:52.434, Speaker A: That might not be that ideal. So as a homework, you might ask yourself, why would a peer only request data from one peer at a time, right? Why would the node not, for example, request the data from multiple peers at a time? What's the rationale behind that? So if you have an answer, please leave a comment down below or give us an answer in the chat would be very much appreciated. Welcome back. We're going to now discuss blockchain layer security. So this is the layer where you have blocks and how you chain blocks. So you have a blockchain. So how you build this very chain is basically the topic of this segment today.
00:37:52.434 - 00:38:26.270, Speaker A: So the interesting aspect, and pay close attention to this, is that the previous lectures, for example, the eclipse attacks, can actually be combined with attacks on the blockchain layer. So let's dive into that. So you might ask why attacks on the blockchain layer? And, well, I will tell you, it's because they're really interesting. You can do particularly, for example, double spending attacks. Maybe you've already heard of it. You can also call them n spending attacks if you can spend a coin n times. Right.
00:38:26.270 - 00:39:08.778, Speaker A: In essence, bitcoin really solved double spending issue on an Internet cash basis. Then there's selfish mining. It's a really brilliant idea that was presented a few years back. There's undercutting and there's bribery as well. So we won't go into all details, but I would just want to basically give you a little bit of an icebreaker for you to understand. What are the implications of blockchain layer security? So the first example that we dive into today is double spending. So double spending is a process whereby the adversary is able to spend a coin more than once.
00:39:08.778 - 00:40:27.394, Speaker A: So this is, for example, possible if an adversary is creating a transaction that looks legitimate to a vendor. So we have here the victim or the vendor v, and the adversary is sending a transaction to this particular vendor. At the same time, the adversary might be sending a double spend transaction to the public peer to peer network, where miners then pick up this very transaction. So if the vendor is accepting so called zero confirmation transactions, so transactions that were not confirmed in the block, but just basically delivers the goods or services to the adversary here, upon the reception of the legitimate transaction, then the victim is susceptible to double spending attacks. So naturally the vendor will try to forward the legitimate transaction to the network. But since there's an inherent time delay between the adversary's double spend propagation and the legitimate transaction propagation, it's highly likely that the legitimate transaction will be invalidated by the majority of the network. And that's because the legitimate transaction and the double spend transaction are conflicting, so they cannot be mined both at the same time.
00:40:27.394 - 00:41:11.170, Speaker A: And this is really just the process of double spending. Right. I pretend that I have a coin here that I can spend on a good or services, and in reality, I actually do spend this coin elsewhere. For example, I do send it to my own address. So a very traditional double spend and eclipse attacks are at the very core of how you can perform such double spending attacks, which we've seen in the previous lecture. So you kind of have here samey or partial eclipse attacks, because the vendor doesn't know about double spend transactions. So it's kind of like eclipsed for a period of time from this real network where the actual transactions are being spent.
00:41:11.170 - 00:42:07.410, Speaker A: So another blockchain layer security issue is selfish mining and we will look at selfish mining also with an eclipse attack. But let's first discuss what selfish mining itself is. So that's an idea from a dial, really similar paper and similar idea that basically explains how to publish or not publish a block. So to keep a block private in order to gain a financial advantage in the network, or specifically in order to increase the mining power in the network. So the goal is that other miners will perform wasteful computations. So you can look here at this state transition function, or state transition graph that we have. We denote by alpha the hashing power of the adversary, and by gamma, a network layer propagation parameter.
00:42:07.410 - 00:42:54.082, Speaker A: So the stronger the parameter, the better you can propagate data. So, for example, right? So we have the probability one minus alpha that the honest network is mining a block. So this means that the adversary will have an advantage of zero blocks over the honest network. However, if the adversary has hashing power of alpha, then with probability alpha, he will mine one block, which is not yet public. So that's a block that the miner will just keep to itself. It will be private in essence. And then there is a likelihood one minus alpha, that the honest network will find a block, right? So in essence, you can look at the blockchain as such.
00:42:54.082 - 00:43:31.006, Speaker A: So this is here, the first block. And then let's say the adversary is mining one block, right? So this is probably alpha. And then the honest network is also mining a block at the very same height, because the adversarial block, right. This one here is not public. So the honest network doesn't know that this block exists. So now we're in the state zero prime because we are at the same height, right? So here there is like just one block kind of distance. And then it really depends what the adversary is going to do.
00:43:31.006 - 00:44:31.458, Speaker A: So if the adversary is mining a block with likelihood alpha, so that would correspond to this case here, then the adversary can publish those two blocks and effectively kill this prior block. So then the honest network will continue mining on this one and the adversary as well. So we are back to square one, to the first start. But there's also the likelihood that the honest network will find a block, right? And depending on the propagation parameter alpha, which is the network propagation, it's unclear on which chain the honest network will mine. So let's start again from the beginning here. So we have this block, right? So we have the adversary, he is mining this particular block here. And then there's the probability one minus alpha, that the honest network finds a block, right? So this is this particular block here.
00:44:31.458 - 00:45:20.690, Speaker A: And at this very moment in time, this block will start propagating the network. So the adversary has a choice. Well, he could just choose to publish his currently private block. Right? And therefore, the propagation parameter here of the honest network, how this block will propagate influences the likelihood of which block will win. Right, whether this is the adversary block or the honest network block. So hence the two cases. Right, there's one's the override case where two blocks override one, and there's the other case where the network propagation parameter will decide on which block will win eventually.
00:45:20.690 - 00:45:47.260, Speaker A: The race, the mining race here. Good. So we did cover now, all these cases here and the remaining cases, they are rather simple. So here, Alpha is the probability that an adversary finds a block. So he's one block ahead in his private chain. Another alpha here would bring him to two private blocks, et cetera. Right.
00:45:47.260 - 00:46:27.758, Speaker A: So this one minus alpha indicates, for instance, if the honest network finds a block, one minus alpha. Well, the adversary could publish both of his private blocks to override this public network block. But once we are here at three or four blocks, we can actually jump back, just like by one block if we want to override that particular victim block. So we don't have to jump back to zero if we don't want to. So this is a rather interesting state machine here that we have. Right. Just for clarity again and for repetition.
00:46:27.758 - 00:47:04.770, Speaker A: So this number here, 0123, et cetera, quantifies the number of private blocks that the selfish minor is currently having. Right. That the selfish minor has amassed. Note that alpha is always assumed to be smaller than 0.5. Hence the likelihood that you will get four or more private blocks in a row is quite small. But, yeah, the probability is not zero. And it depends really on the hash rate and kind of luck in that case, of the selfish miner.
00:47:04.770 - 00:47:33.134, Speaker A: Very good. So we have come quite far. So really good job. So continue, continue on grasping the details here of selfish mining. It's a really super exciting topic, and we're going to go a little bit higher on the level of complexity. Now we're going to combine selfish mining with an eclipse attack. And what you can see here is we have the very same state transition as before.
00:47:33.134 - 00:48:26.350, Speaker A: Right, if you remember from the previous slide. But now we're going to add another variable, P. And P is a probability to eclipse a block to a minor. So basically to hide a block towards a specific minor in the network. And we're not going to go into the full details here, but I really would like you to understand the intuition that once you can combine an eclipse attack with selfish mining here, in this particular case, you can kind of create different realities. Right. You can have some fraction of the network being on one side and some other fraction of the network being on another side of reality, really? Because by partitioning the network, by creating eclipse attacks, you're preventing peers from receiving data.
00:48:26.350 - 00:49:28.270, Speaker A: Hence, for them, the reality looks different than to other peers. Right. And this is at the very core of security or basically fraud in distributed, decentralized ledgers when it comes to miners. So you might ask, well, I mean, in practice, do we observe selfish mining at all? And there's, so far, as far as I know, no scientific work that has proven that selfish mining was, in fact, practiced by miners. I think an empirical study might show the statistical significance of the block generation times and might give indications of whether there is a change over time on the habit of miners or how they publish blocks. But I haven't seen any study on this, and this would be certainly very valuable future work. And even then, I think it's really hard to find a proof.
00:49:28.270 - 00:50:24.834, Speaker A: So to find an irrefutable proof that selfish mining is being performed just due to the fact that this is an attack, that's possible by hiding data and just publishing it selectively when it fits best. And there's no way to prove that a miner found a block early on. So it's a tricky thing to prove, basically, that a minor performs selfish mining, while eclipse attacks obviously are more visible as an attack. But, yeah, maybe some of you will perform in the future or have some ideas in the future on how to prove that selfish mining was performed. So, really looking forward to that. So now we want to look into the implications of selfish mining. So what is selfish mining? What's the result of selfish mining? So, on the x axis here, we have the pool size.
00:50:24.834 - 00:51:00.186, Speaker A: This is the hash rate, or alpha, that we had previously. On the y axis, we have the relative pool revenue. So this is the revenue that the miner receives based on the pool size and based on the eclipse attacks or selfish mining strategies that the miner performs. So let's assume here, let's look just as honest mining at the very beginning. So honest mining is this green line. So this is the best case scenario, right? Nobody is malicious. Everybody basically follows the honest protocol.
00:51:00.186 - 00:51:43.170, Speaker A: So, for instance, if you have 40% of the hash rate, so you can read the chart as follows, you go here, up 40% of the hash rate, well, then I get 40% of the revenue. Right? Sounds fair. Right? So it's a linear relationship. Now, if you start to perform selfish mining and the propagation parameter is set to zero. So this means the honest network has a bad propagation parameter. Then you can see that the revenue is all right. But we can see here that the revenue here is actually below the honest mining revenue.
00:51:43.170 - 00:53:03.880, Speaker A: But we can see there's a threshold like maybe roughly 33% of the hash rate, at which, well, I mean, if we have 40% of the hash rate, we're here nearly at 50%. So maybe 48, 49% of the entire hash rate, which is quite alarming, I would say, because this means we have made a plus, roughly 8% increase in the revenue. It's not an increase in revenue, but we have 48% revenue despite only owning 40% of the network, which is super dangerous. And as you might know, once we go beyond 50% of the relative pool revenue, we basically own the chain, right, because we have a majority voting rights, and so we can double, spend and outrun basically any honest player. So if the propagation parameter here is one we can see that even at, we basically only need about, this is, let's say 38% roughly. So I haven't checked the number specifically, 37% to 38%. Basically, we own the chain 50%.
00:53:03.880 - 00:53:55.800, Speaker A: So this is quite alarming. So obviously we know that propagation parameter matters to increase the likelihood of an eclipse attack or selfish mining attack in this particular case. But now if we go beyond the standard selfish mining attack and we add an eclipse attack, so we have the 50% chance to consecutively deny two blocks to a minor. So this is p. In that case, we can even lower the threshold. So we're here now at maybe 34%. If we get 34% of the hash rate, then we can own the chain because the relative pool revenue will be 50 or above 50%.
00:53:55.800 - 00:55:12.000, Speaker A: And this is very core blockchain security and a parameter that we really have to understand where the blockchain starts to become insecure. So certainly the threshold for secure blockchain is not 50% of the hash rate, as many assume, but significantly lower, probably on the order of 30% to 40%, as we can see in this very chart. So I hope you like this intuition on blockchain security and especially this subtle notion of how we can combine various attacks, right? So we combine this attack on the network layer with the blockchain layer, so the eclipse attacks and plus the selfish mining attack. And if you're an adversary, you can have fun and you can poke at decentralized blockchains by doing so yourself, right? You can do a selfish mining attack, an eclipse attack and probably a DeFi flash loan attack on top. So it's really just like how DeFi is a Lego, where you can plug in a different finance concept. Well, on the security side, it's the same. It's really just a Lego, and you can play around.
00:55:12.000 - 00:55:49.734, Speaker A: Welcome back. We're going to now discuss smart contract layer security. And as you already realize, right, we are going slowly up the different layers in distributed ledgers and hopefully soon arriving at the Defi layer. So the smart contract layer is the layer where you write smart contracts. Like for example, the following here is a contract written in solidity. It's a contract called a wallet. It does have a state variable, which is called a balance.
00:55:49.734 - 00:56:52.990, Speaker A: It's an unsigned integer and it's initialized here with the value ten. This smart contract also has a function, it's a function called withdraw, and it can perform, apparently a withdrawal if the balance is bigger than one. So then it can basically send a value to the message sender, which is the address that is actually calling this very function. And it will send a value which is the. I mean, it will basically send the entire value that is written here in this variable state variable balance. Afterwards, once this is sent, the balance is zeroed out, set to zero. Well, I mean, you already know that smart contracts are programs that handle money executed on the blockchain, written in this high level solidity language, and then compiled to VM code, for example, EVM code for the Ethereum virtual machine.
00:56:52.990 - 00:57:49.120, Speaker A: The smart contracts can typically be trusted in a way that it's not possible to patch them after release, but you can still have functionality that obviously changes its logic. So, yeah, what can go wrong, right? We have code handling billions of us dollars. Not much can go wrong, I guess. Right? Well, as you have already seen here, there are the ways to basically transfer money to a caller, right? And this caller can be anyone. And this being anyone really sounds like a bad idea. And as you have already seen in other lectures, that security, getting security right is really challenging endeavor in DeFi or decentralized ledgers in general. So we have witnessed a variety of DAO attacks, of attacks in general, actually.
00:57:49.120 - 00:58:30.314, Speaker A: But the DAO attack was probably one of the most famous attacks where there were a significant number of funds stolen. Etherdice, which was one of the very popular gambling sites, was down for maintenance as it had issues and security issues. The ether throne had issues. And the list is going on. I think we've counted at least in 20 or 2021, over 90 or probably wide. Over 100 DFI incidents itself in itself in those two years. So they're literally like millions and millions of us that were stolen.
00:58:30.314 - 00:59:10.860, Speaker A: So getting security right, especially in the smart contract layer or in the DFI layer, is very challenging. So let's look at one of the most famous security attacks, which is called the reentrancy attack. We do have here a wallet contract. The wallet contract is the one that we've just discussed in the earlier slide. And let's assume now we have a user contract. So the user contract is the contract that will call the wallet contract. And specifically, the user contract has a function, move balance, which will call wallet withdraw, which is this very function here.
00:59:10.860 - 01:00:32.006, Speaker A: So technically, we just want to call this withdraw once and get, for example, the ten ether back. And there's a value of ten here, right? So that shouldn't be that complicated, right? But what about later? So if later we call withdraw again, there should be no transfer, right? Like the balance should be zero. There should not be any additional funds that are coming out of the contract. Well, the question is really here, can the user contract withdraw more than ten ether of the wallet contract? So I would like you to pause maybe the video quickly, or think about this, or maybe you can comment in the chat. So is it possible, yes or no? And please also mention why it might be possible, or why it might not be possible. You okay, so if you look here at this very call function here, right, we have message sender core, which transmits the value that's specified in the balance state variable. Well, this very function here may implicitly call the so called fallback function in the user contract here.
01:00:32.006 - 01:01:28.234, Speaker A: This is the fallback function. And in this callback function, you can execute some code, right? And only after this very code, the balance will be set to zero. And that's naturally quite an issue, right, when you code smart contracts, because this fallback function here might call again the very same contract. So let's look at how this works. So here, basically, in this, you explicitly now define the fallback function in the user contract. And in that fallback function, you basically call wallet withdraw again. So this very function here will be called again and again and again, and this will be executed, but the balance will not be set to zero because the execution is still running.
01:01:28.234 - 01:02:20.330, Speaker A: And an adversary stole, with this type of attack, over 3.6 million ether in a particular attack. So reentrancy was and still is a major instance of smart contract vulnerabilities. So let's look at the security bug number two, which we call unprivileged rights to storage we do have a wallet contract here with a function in it wallet and a function withdraw. So the init wallet function allows you to set the owner. Here owner is an address and it's a state variable in the contract. And the function withdraw is basically the function where you can send the amount, the amount of money, for example, that this contract has in this very smart contract.
01:02:20.330 - 01:03:13.420, Speaker A: Now, what is wrong here? Can you tell me what do you think is bogus about this contract? So again, please pause the video quickly or answer in the chat with any ideas that you might have. So if you look at this particular line here, only the owner can send ether, right? So there's a security check, access control check. Very good. However, here, any user may actually change the wallet's owner, because any user can call the function in it wallet. There is no check on who is eligible to call the function in it wallet. Hence you can basically just set yourself as owner and then withdraw the entire amount in this contract. You see, getting smart contract security, right, is not an easy feast.
01:03:13.420 - 01:04:00.920, Speaker A: So an attacker basically used this or similar bug to steal over 32 million us dollar at the time. So let's move now on to another smart contract bug exercise. So we have here a contract which is called example, and we do have two state variables. We have an address, it's called the owner. And we do have another state variable which is called my secret, and this one is private. Right? We do have a constructor in this very smart contract, which is good because it sets the owner to the one deploying this very smart contract. We have a function set secret and we have a function gets secret.
01:04:00.920 - 01:05:10.812, Speaker A: So again, can you tell me what is conceptually wrong about this smart contract? Right? Why is this not a good idea? Okay, I'll give you a little hint. Right? So who do you think would be able to read my secret? Absolutely. So any variable is basically readable on the public ethereum blockchain. Whether it's called private or public, it doesn't matter, it will be readable. So declaring a variable as private only restricts the automatic creation of getter functions for that variable, but it does not hide the content. So please don't be fooled by these keywords, these solidity keywords that are certainly not implying that this my secret value here will not be shown or somehow occluded or somehow encrypted. There's no encryption going on here.
01:05:10.812 - 01:05:56.380, Speaker A: This is literally just an access control parameter or a visibility parameter when you look at the smart contract. But it has nothing to do with the confidentiality of this my secret variable. So really be careful regarding those statements. Obviously you could argue that's not a bug, it's just how solidity is defined. But we understand here a bug meaning that the programmer understood that my secret is actually a private variable, while it's not. Let's move on to smart contract bug exercise number two. So here we have a contract called vulnerable.
01:05:56.380 - 01:06:44.220, Speaker A: Now we do have here two state variables, one authorized, one balance, which are mappings from an address to bool to boolean, and from address to an unsigned integer. We do have a function called refund and we can specify here an amount that's an unsigned, there are a few security checks. So here it requires that you are basically authorized. And so the message that send is authorized or part of this authorized mapping. And it's required here that the amount is small or equal to the balance of the sender. So you cannot withdraw more than your balance currently amounts to. And then there's a message call value.
01:06:44.220 - 01:07:16.560, Speaker A: So we've seen, this is an example that we've seen. And afterwards the balance is deducted from the amount that you withdraw. Right. So would sound quite normal. So what's wrong with this exercise here? What isn't very clear, please write in the chat or think to yourself. And you can also write comments down below. Okay, I'll give you a few more seconds.
01:07:16.560 - 01:08:47.284, Speaker A: You all right, so I give you a little hint. So who can be message sender really, when calling the smart contract? Well, anyone can be message sender, right? But the bigger picture here is that the code is again vulnerable to a reentrancy attack, right? So the balance of messages send is only updated at the very after we have actually transferred the amounts, right after the transfer is made, which is a really bad design. So if the message sender is a contract, so it's a user contract as we've seen before, and has a fallback function that calls again in the refund function here of this vulnerable contract, then message sender can actually deplete the contract of the funds. Very good. So how would you exploit this very smart contract? Can you pause the video quickly or propose basically where you coach? I mean what code you should write? So specifically it's here and here's, so the hint is please check the previous message. And naturally here, right, we have v, which is the vulnerable contract. We are the exploit contract or user contract.
01:08:47.284 - 01:09:50.780, Speaker A: If you go back to the previous exercise and we have here the exploit function that will call the refund and we define a fallback function where we do the same v refund the same amount. And given that we can simply drain this very smart contract, I would like to focus. I mean, basically also clarify here that these balances here are state variables, right? Because the smart contract itself has a balance that's specified by the EVM. And these variables here are custom balance variables, right? These are not given by the EVM. So there's a clear difference between the EVM balance of a smart contract and the balance of a smart contract as defined by its state variables. Okay, very good. There are many more smart contract security bugs that you can find, and maybe some of you might even find new types of bugs or security issues.
01:09:50.780 - 01:10:45.660, Speaker A: So there's unexpected ether flows, insecure coding, unsafe inputs, et cetera. So I can also recommend you to look a bit online in the various resources that you can find. For example, here, consensus has a great document on explaining various types. And you might still ask me, well, how can we prevent or how can we identify where smart contract security issues exist? Well, the issue is that if these are all the possible contract behaviors, if you map this on, this might be a few bugs in there which we might not see. So these are kind of security bugs that might be relevant from a financials perspective. So the underlying problem is we cannot enumerate all possible contract behaviors. So we need somehow a clever way of finding those security bugs.
01:10:45.660 - 01:11:32.920, Speaker A: On a very high level, the three main methodologies on finding bugs is testing. There's a lot of manual testing involved. In particular, auditing companies are doing this quite well nowadays, but naturally they don't find everything. There's the dynamic analyzers or symbolic execution, and there's also the static analyzer, formal verification even. And you could say on a very high level that testing is like finding or trying to find a few things, and might find a few bucks here and there. So it's easy to implement. It's just a lot of time and resource intensive, but might yield only very limited guarantees.
01:11:32.920 - 01:12:18.412, Speaker A: The dynamic analyzers might yield some better coverage, I would say, of the contract, so it's certainly better than testing, but it can still miss vulnerabilities. And static analysis or formal verification might provide stronger guarantees, but it also suffers from many, many false positives. So it might be actually tricky to identify a bug in the reports that you find. And naturally, if your formal model is wrong, then you also have an issue here. So I hope you liked this lecture on smart contract vulnerabilities. Go out maybe on ether scan, and try to find a few smart contracts and their associated code. Go look in there.
01:12:18.412 - 01:13:05.836, Speaker A: Maybe they do have some issues on the authorization side, so they don't require the owner, or you can set the owner if they're basically mismodifiers. Or maybe they do have some vulnerabilities, some reentrancy vulnerabilities if they use the call function to transfer assets, and only later on update the balance. So go out there and start hunting. Welcome back. We're going to now discuss DeFi attacks and focus, in particular of flash loans, or how flash loans can be used to carry out attacks. Notice that a flash loan is really just a tool. The attack is not just a flash loan attack, it's an inherent issue of the design of a DeFi platform.
01:13:05.836 - 01:14:10.640, Speaker A: But a flash loan makes the attack execution particularly simple and cheap. Please, if you're unfamiliar with DeFi flash loans, look at the previous lectures where we discuss how flash loans operate. That's certainly necessary knowledge required to understand the attacks that we're discussing here. So what can go wrong? Right? You have access to billions of capital by just paying for a little bit of transaction fees and minor percentage of interest rates. So what can possibly go wrong? So we've seen that many DeFi attacks are really kind of using flesh loans, these instantaneous loans of significant size, to carry out attacks. A particular flash loan attack is the pump and arbitrage attack in February 2020. So this is a particular attack where there was a flesh loan transaction in a given block.
01:14:10.640 - 01:14:58.444, Speaker A: The input to this attack was only 130 us dollar worth of gas. So this was basically the capital that the adversary had to collect and use to carry out this attack. And the output of this attack was about 350,000 us dollar, quite a sizable amount. So we will not go into all the details of this attack. We will discuss the second attack in a bit, but just want to show you the general pattern of how a flash loan attack looks like. So we have here, in the first step, there's a flash loan, right? So here, the adversary took a flash loan on the platform, Dydx. So the flash loan is actually free there, more or less free.
01:14:58.444 - 01:15:40.856, Speaker A: It just cost like one way in fees to lend to get this flash loan there. And then there are a few operations, so we don't have to dive into details for this one, which obviously, if you want, as a homework, you can do. But here I really just would like to show you that there are a few Defi actions that are being carried out. For example, there's a lending action, there's a margin trade, there's an exchange, another exchange. And finally, in this transaction, the flash loan is being paid back. So what you notice here is that there are various platforms that are involved, right? So there's compound, there's uniswap. Again, uniswap.
01:15:40.856 - 01:16:48.252, Speaker A: There's BZX for the margin trading, and there's DydX for the flash loan itself. You might also notice here that there are some pools, like amm pools, in particular, the eth wrapped bitcoin pool where prices are being dumped here, for instance. And there's another Uniswap pool here where, I mean, the same Uniswap pool that's also affected here. So there is a second stage to this attack where there is an amount of ether that's converted to wrapped bitcoin, which is being done on compound. So again, Kyber is involved here. So you see there are quite a few DeFi platforms involved. So the high level message that I just would like you to gather from this particular example is that these types of deFi attacks do basically involve multiple deFi platforms in an atomic transaction.
01:16:48.252 - 01:17:45.344, Speaker A: So this first transaction here is atomic, meaning that the actions 1234 and five, they all execute either collectively or they fail. And this very atomic property among different platforms is really something super exciting, super new, something we've not seen in traditional finance domain, just for the sake of this particular attack. So we looked at this attack in detail, and we found that the adversary could have chosen better parameters to carry out the attack. So by parameters, I mean parameters, for example here, 10,000 ether, could we have taken more and made more money? We don't know. Right. So there are a few parameters that could have changed. For example here, how much do we collateralize? How much do we borrow, how much do we convert here, et cetera.
01:17:45.344 - 01:19:01.456, Speaker A: Right? So the idea is that given that you see such an attack on chain, you can model this attack, and you can find out whether with an optimization framework, as we will discuss in a bit, you can find out whether the attack is executed in an optimal manner or whether the adversary left money on the table. So the second attack that we are looking at today is the BZX oracle manipulation attack. So this was actually the second attack that was carried out on BZX in February 2020. So the first step of this attack is an adversary taking a flash loan on BZX. So, BZX we had in the earlier example is a margin trade provider, but also performs or allows performing or allows borrowing a flash loan. So with the 7500 us dollar, the adversary basically takes 540 of this ether, and he exchanges this on Uniswap and he exchanges this to Sus dollar. So this is the previous market price of Eth Su SD.
01:19:01.456 - 01:19:39.160, Speaker A: And this is the market price after the adversary performs the trade. So you can see here that the liquidity in this uniswap pool is not that high. Right? So the exchange rate is significantly affected because we are adding here 540. So here, 880 plus 540 is roughly this 1420 ether. So the price certainly drops. Right? So we have the initial exchange rate here as follows. And the price is clearly dropping here to 106 SUSD per ether.
01:19:39.160 - 01:20:34.410, Speaker A: Then, in the second step, what the adversary does is he goes to the Kyber reserve, which is another exchange. And in the Kyber reserve, he sells or she sells 360 ether for S US dollar. So, again, we can see here the Kyber reserve had actually very little ether at the time and quite a lot SUSD, so very imbalanced, which is generally not very healthy either. But we can see here, this is the change of price. So we can see here as well that the asset price was dumped quite significantly to 108.44 SUSD per ether. So now we know, okay, in this atomic transaction, given the flash loan, the adversary dumped the price of SUSD on the Uniswap and on the Kyber reserve market.
01:20:34.410 - 01:21:18.504, Speaker A: So now what the adversary does is the adversary would like to mint SUSD. And the thing is, the adversary still has quite some ether available. So the adversary uses 3500 ether to create SUSD. And we can see here that now the adversary has quite some sus dollar. The adversary can now go to BZX, which is a margin trading platform. And given this SUSD, the adversary can lend now ether at this platform. So we have about 1.1
01:21:18.504 - 01:22:25.500, Speaker A: million s us dollar, which will give us almost 6800 ether. So quite a significant amount in terms of ether. If you remember, we took roughly this amount at the beginning in the flash loan. The very important insight here is that BZX is using the Uniswap and the Kyber reserve markets as an oracle as a price oracle, the BZX on chain market, somehow has to know what is the price of SUSD to ether. And because the adversary dumped the price of SUSD to ether on the Uniswap and carbon reserve pool, which act as an oracle in the BZ platform, we naturally get a really good price for an S US dollar. So you notice here that the adversary ends up with 9800 ether, which is an incredible amount. And initially, the adversary literally took.
01:22:25.500 - 01:23:27.436, Speaker A: So if you go back here in the slides, only took 7500 ether. So the idea of this attack was really this oracle manipulation. And naturally, the adversary can then pay back the flash loan to Bz, which is minus the 7500 ether, and we end up with over 2000 ether in profit. So you might ask now, how do we optimize such an attack? So how do we find out what the optimal parameters are to execute such a defi attack? Well, what we can do is we can formulate the defi actions in models, right? I mean, we know that a constant product, amm, for example, can be expressed in this way here. And given the model, we can construct a constraint optimization problem based on the attack vector. I'll give you an example just in the next slide. So, the objective function that we want to maximize is the outcome profit.
01:23:27.436 - 01:23:59.580, Speaker A: So what we do is we fetch the onchain state that the attack is expected to be executed on. And then given the onchain state, we can optimize the parameters. So let's look at how this would work for the BZX attack. Two that we just discussed. So we have an initial borrowing, right, and an end repay. So we have a borrow flash loan and a repay flash loan at the end. If we don't pay back the flash loan, the transaction would fail.
01:23:59.580 - 01:25:00.480, Speaker A: Hence we have to naturally pay back. So what's being done in the first step is that we have a parameter, one, we don't know how many ether we want to provide to uniswap, right? So there's a certain function of this p one of SuSD that we want. The second parameter here is how much ether are we going to contribute to Kyber. So you remember Uniswap and Kyber together are the price oracle for BZX. The third parameter that we are looking at is how much do we put into synthetics to mint sus dollar? And then how much z sus dollar should we borrow? Should be used to borrow g of z ether on Bzx itself. Right? You remember this was the last step. So Bzx here, this is BZX.
01:25:00.480 - 01:25:51.524, Speaker A: BZX is basically using Kyber and Uniswap as a price oracle. So we can exploit, in a sense, the fact that Bzx relies on this on chain markets that we can so easily manipulate. So, putting all together, we have here this function, and we have the following objective here that we want to maximize, right? And naturally, p one plus p two plus p three has to be smaller than x ether. So that's the maximum amount of ether that we can lend. That we can borrow, borrow as a flash loan from the BZx platform. Naturally we can choose any other type of flash loan platform. Doesn't have to be BZX.
01:25:51.524 - 01:26:52.976, Speaker A: I just followed in this particular example what the adversary has done before, so you can basically throw it into an optimization algorithm. So we have used the sequential least square programming algorithm, which is available in ScipI. We have executed this on an Ubuntu 1816 cpu cores, 32 gigs of ram, rather small machine, and we then validated this by concrete execution on the real blockchain. So if you would like to do this yourself, you can use, for example, hardhat to fork the chain at a particular height. So I hope this gave you a good introduction how a flash loan attack is possible. Recall, flash loans are really just a tool for you to carry out the attack. Maybe think for a little exercise of how would you prevent such an attack? So this was an oracle manipulation.
01:26:52.976 - 01:27:53.688, Speaker A: Well, if your defi app is relying on a market where the price can be easily manipulated through a flash loan, then maybe that's not the safest. So you might want to use additional oracle sources. Uniswap also now provides a time weighted average price, which should be less manipulable by an adversary. But this remains a rather difficult kind of challenge to secure a DeFi protocol, because the state of other protocols might be dependent on yours, and an adversary might be able to create such a market manipulation attack. Welcome back. We're now going to discuss sandwich attacks. Sandwich attacks are one of the really predatory trading techniques whereby you front and backrun a victim and the victim is in the middle.
01:27:53.688 - 01:28:40.208, Speaker A: It's a juicy transaction, victim transaction, hence sandwich. Let's dive into it. So, sandwich attacks are particularly applicable to automated market makers. So we've covered automated market makers short amm in an extensive lecture, just a very brief recall. You have, for example, in the constant product Amm, you have an asset quantity of x, and you have an asset quantity of y. The product of those needs to remain constant while you're trading with the Amm market. A sandwich attack is then really literally a sandwich, whereby you have a victim transaction.
01:28:40.208 - 01:29:30.372, Speaker A: The victim transaction is exchanging as an asset x for an asset y. And we have here on the x axis the time appearance on the blockchain network. So after a victim transaction was observed on the network. Right? So here the victim transaction started propagating. An adversary is creating an adversary transaction, one that should be front running the victim, and an adversary transaction two that should be back running the victim. So hence here, this is the victim, and this is a one, the adversary one and adversary two transaction. So the idea of this transaction is that the adversary transaction, a one, will manipulate the onchain market that the victim transaction will transact on.
01:29:30.372 - 01:30:20.740, Speaker A: So the adversarial transaction will try to squeeze as much financial profit out of this victim transaction as possible. So let's look at how this works and why and how much technically could be extracted from a victim transaction. To fully understand sandwich attacks, we need to go back to the very basics of a constant product formula, or amm in general. So on the x axis here, we have the amount x of asset x, and on the y axis, we have the amount y of asset y. I hope you remember. So if we have a state before, that's, for example, ten and 30. So ten units of asset x and 30 units of asset y.
01:30:20.740 - 01:30:55.120, Speaker A: So our constant k would amount to 300 in this particular example. So now we're going to trade. So we're going to remove here minus ten assets. So basically, we want to retrieve from the pool ten assets. So the curve we're going to be here. So now the question is, how many assets do we have to provide to this pool here? Somebody remembers or maybe recalculates based on these examples. Please leave a message in the chat.
01:30:55.120 - 01:31:49.840, Speaker A: Very right. So we have plus five here, right. So we need to provide the pool five assets in order to be able five assets of x in order to be able to take out ten units of asset y, because the constant k remains constant. And that's the constant product formula. So now the number of coins here that we get back, basically the exchange rate is really determined here by this curve, by the points on this curve. So every coin that we get is basically not precisely the same price. So obviously there's an average price that we get, but the more we trade, the more expensive the trade becomes.
01:31:49.840 - 01:32:54.116, Speaker A: So here there's basically an expected increase or decrease in price based on the trade volume and available liquidity in particular. So the curve here is describing the expected increase in price. So the longer you go along this curve, right, the more you will pay per coin that you purchase. So the idea is that the pool should not be easily drainable, but you should always have instant liquidity. That's one of the properties of an amm. Now, what can happen is that you can have some transaction that front runs you, whether it's a benign front run or malicious front running, and your transaction is executed here at this point, or starts to be executed at this point of the curve, instead of the other point at the curve that you anticipated earlier. So what can happen is that if you execute here, you would certainly get a worse execution price also.
01:32:54.116 - 01:33:50.072, Speaker A: On the other hand, if you're front run by a benign transaction that goes trades in the other direction, you could end up getting a better price, right? So it goes both ways really. What's really important, however, is that you want to configure a slippage protection to prevent any unacceptable slippage that you might be exposed to. So this goes. Or I mean, I guess the closest analogy would be a limit order. So in a limit order book, you say, I'm willing to pay atmosphere the following price, right? So the slippage protection in essence is really similar. However, the way you specify it, for example, on Uniswap, is by clicking on this little icon here, currently in the UI, and then you can for example, specify 1% or 0.1% or.
01:33:50.072 - 01:34:48.440, Speaker A: Uniswap also has an auto setting. So I'm not actually quite curious of how this auto setting works. So if you have any ideas, or if you have maybe checked this out, please leave a comment in the chat, because it's quite crucial how this automated slippage setting works, because the more open you are to slippage, the more likely you will be a victim of a sandwich attack. So I would much rather prefer this to be a static and smaller number. But it's true that if this number is too small, then if given the volatile market, it could happen that your transaction keep failing because the price just changed inherently in the market. Hence you do need some slack in the slippage setting. Now let's go back to the slippage protection and when it actually triggers.
01:34:48.440 - 01:35:45.180, Speaker A: So here you can see that we have somehow a transaction that was front running us and we wanted to purchase this amount of liquidity. Now, it turns out we actually crossed the slippage protection threshold. So no luck here. And basically this means that the transaction failed or will fail because we crossed the limit that we specified earlier. So we will be liable to gas fees or transaction fees to the miners, but at least we won't overpay on the asset price because we don't go over a price limit. Okay, and here again, you can specify the limit in the uniswap Ui. So now let's put all the elements together, right, for the sandwich attack.
01:35:45.180 - 01:36:31.816, Speaker A: So we do have victim, and we do have an adversarial transaction that's front running the victim. So in this visualization here, you should see very beautifully that here, this very point, right, the victim is really being pushed very closely to the slippage protection threshold, but not beyond. If the victim is pushed beyond the protection, it would fail. We don't want the victim to fail. We want the victim to execute. But we want to kind of squeeze out here this amount of, or push back the price to the worst possible price that the victim is willing to accept. And in the second step, the adversary can cash out by basically doing the reverse trade.
01:36:31.816 - 01:37:25.176, Speaker A: So the idea is really to maximize the victim slippage during execution. So this is the unexpected slippage that the victim will suffer from. So to execute such a slippage attack, we look here at the following architecture, let's say adversarial architecture. So we have here the victim v, right? It just creates transactions, broadcasts in the network, and then we have an adversary with a spy node. So, remember, spy node is a node that is very well connected in the network, and it receives data really early on. So it just sees most of the transactions very early on. Based on the transaction data, it can find out what's the slippage protection threshold.
01:37:25.176 - 01:38:18.972, Speaker A: Hence it can calculate whether it's profitable to execute a sandwich attack. And if it is profitable, then the adversary will create a front running and a back running transaction, broadcast these in the network, which will be added to the miner's memory pool, hopefully before the victim is mined. And if the adversary is lucky, he will get all the three transactions included in the same block, ideally very close to each other. And this is one of the possible ways to perform sandwich attacks. There are a variety of variations of these attacks. We will show you in one of the following slides. But this is really the very gist of it, right? You act on public information that you see in the, for example, the PDP network.
01:38:18.972 - 01:39:06.568, Speaker A: You push a transaction to the limit and then cash out back on it. So you might ask, is this attack always profitable? Well, the good news is that it's not. So here you have a plot that we derived. So you have here on the x axis, you have, for example, the ether transacted by a victim. So this is on a particular uniswap market that we took, actually as an example from Uniswap. And obviously, these numbers may change at any point in time, depending on the market state. But let's assume here we have the number of ether transacted by the victim, and here we have the ether transacted by the adversary.
01:39:06.568 - 01:39:44.948, Speaker A: Right? So you see a victim transaction. For example, you observe a victim transaction that trades 20 ether. You have set a slippage protection of, let's say, 1%, which seems to be one of the default options in the Uniswap market. In the Uniswap Ui, then you can see here that the adversary would need a little bit more than 22.5, probably 23 ether to attack the victim. And what's interesting is here we are in the green area. The green area represents the revenue that the adversary can extract.
01:39:44.948 - 01:40:33.690, Speaker A: And you can see here we are roughly on the area of 0.2 ether, which is not bad for a single sandwich attack. So keep in mind, if you have here, for example, a slippage setting of 0.1 ether, then we're just about here, then the adversary has almost no chance of extracting any significant revenue here. So, so far, we have only looked at one particular adversary attacking a victim. But naturally, the blockchain environment is an environment where we have many adversaries, and it's a very competitive endeavor there. So if you've tried to understand if we have multiple adversaries, and they will basically try to outcompete each other.
01:40:33.690 - 01:41:19.610, Speaker A: So the longer the victim transaction is pending in seconds, here in the ethereum network, up to 30 seconds and up to ten adversaries, we try to simulate what's the gas price that will revolve. Right, and what's the breakeven, I mean, how hard the breakeven becomes. So we can really see here that the gas price becomes incredibly high in terms of gigaway. So this is a counterreactive biding. So means basically, I see a victim, then I perform a sandwich attack, then another adversary sees my sandwich attack. I perform a sandwich attack by bidding higher prices. So it gets very competitive very quickly.
01:41:19.610 - 01:42:00.790, Speaker A: A particular advanced sandwich attack would be where a liquidity provider attacks a taker. So, so far, what we've looked at is that a taker attacks the taker. So a trader attacks another trader. But in an amm, we do have liquidity to providers, or lps for short. Right. So they add and they remove liquidity. So there may be settings where an LP can actually here, for example, remove liquidity or add liquidity, and then do the reverse operation just to squeeze the victim into a worse price.
01:42:00.790 - 01:42:50.150, Speaker A: These are settings that are certainly interesting to explore, and we haven't seen much quantitative analysis being done on this angle so far. So I hope you really liked sandwich attacks. These are very juicy burgers, in essence, with juicy victim transactions that can be exploited, very creative attacks. Also, the liquidity providers can probably attack the liquidity takers, or maybe a liquidity provider can attack a liquidity provider. So I will leave it up for an exercise for you to find out maybe some more varieties on the different attacks. Welcome back. We're going to now discuss blockchain extractable value.
01:42:50.150 - 01:44:00.760, Speaker A: What is blockchain or minor extractable value? Well, let's look at a concrete example. So if the price of the collateral of an asset drops below a health factor, as you maybe recall from our lending lecture, then there is the event, there's possible event of a liquidation that a third party can trigger. Now, the question is, who will liquidate? Is it the miners? Is it just a regular user? Or is it some kind of an adversary that tries to front run other users? So there are variety of sources on how to measure minor extractable value. So you can, for example, check out flashbots net. They have a dashboard and their own data and their own metrics on how to extract data. We have also come up with our own metrics and heuristics on how to extract a value. And in particular, we have done this for, for example, sandwich attacks.
01:44:00.760 - 01:45:14.420, Speaker A: So we have looked at the monthly profit and the number of sandwich attacks here starting in December 2018, going back until almost here, August 2021. So over quite some time frame, we've tried to, based on the blockchain data, we've tried to understand how are the different, or how much sandwich attacks are happening, are actually happening in the real world. So keep in mind that the y axis here is a lock scale. So a small increase in particular here might correspond to quite a significant financial amount. So you can see what's interesting is here that uniswap version three, for example, was just introduced here. And then in the month after the Uniswap sentry attack amount already was rather significant and has been growing since then. You can see here, we have basically looked into Banco Uniswap version one, two and three, as well as sushi swap.
01:45:14.420 - 01:46:24.372, Speaker A: The number of sandwich stacks have also significantly increased, as you can see here. This is just the very raw number, with attacks hitting as much as 100,000 sandwich attacks per month on a particular market, on a particular exchange, not a market. So this is basically taking into account thousands of onchain markets. Another source of minor extractable value is liquid, are liquidations. Right? So liquidations is the event whereby if you have collateral, that the price of a collateral which drops below health factor, then you do have the liquidation event. So here again, we looked from 2019 until August 2021 at the most important lending platforms on Ethereum, and we have found here that are quite a variety of liquidation events. So keep in mind, we have only looked here at the fixed spread liquidation.
01:46:24.372 - 01:47:08.280, Speaker A: So these can be done atomically in one transactions, for example, the Makerdao liquidation mechanism, at least in the past, was based on an auction setting. So this was not an instant liquidation. So we captured here those that can be performed in an instant atomic transaction. Hence these are things that miners can actually extract. Right? So a minor can reorder transactions and hence extract liquidation revenue. And finally, the third category of minor extractable value that we try to quantify is just plain old arbitrage. So again here, this is from 2018 until August 2021.
01:47:08.280 - 01:47:55.892, Speaker A: So we have here as well, the number of arbitrage attempts are slightly higher than sandwich attacks. And also the revenue here you seek has been growing quite significantly. So notice that we have included additional markets such as curve and swerve in this particular evaluation, as well as one inch. So arbitrage is naturally seen as a very benign trading strategy to help the markets become more efficient. But there's certainly a type of cost associated to perform arbitrage, like on chain overhead. And it is certainly something that miners can extract if they would like to. Thank you very much for listening.
01:47:55.892 - 01:48:39.904, Speaker A: So I've introduced a variety of sources of minor extractable value because miners have the authority to instantaneously and single handedly order transactions within a particular block that they mine. So they technically have access to all this additional revenue that you can source from the blockchain. So traditionally you had only the block reward, the transaction fees. Nowadays, on top of this, you have the minor extractable value. Welcome back. We're going to now discuss transaction replay attack, or more specifically generalized transaction replay attacks. The idea of a replay is really to create kind of a copycat of an existing transaction.
01:48:39.904 - 01:49:33.256, Speaker A: So replay is a term, technical term, from a traditional network security environment. And the idea is to observe a transaction on the network layer. Then you do replace certain data, you sign it with your own private key, and you broadcast the copy. So it's really just a copycat behavior. So the potential profit that we identified is about 35 million us dollar over 32 months, over a 32 month period. Naturally, what we have ignored here is the possibility that others will front run you or front run your copycat, or defend against being a front run. So we have gathered about 188,000 profitable transactions over these 32 months of historical blockchain data.
01:49:33.256 - 01:50:07.312, Speaker A: And this represents about 0.2 of the entirety of the Ethereum blockchain transactions that we have seen. We've developed in a real time algorithm, which is not very much optimized and which could even be paralyzed. But we basically can replay a transaction in less than 0.2 seconds, as we report here. So I'm sure you're quite curious now. And how does this algorithm look like? Well, it's really very simple.
01:50:07.312 - 01:50:45.550, Speaker A: So what we have here is we have a potential victim transaction that you can see here, this is being basically injected into this algorithm. And we have here an adversarial address, right? So a victim transaction. Adversarial address. And the adversarial address is replacing the sender address at the same time in the transaction input. We are searching whether the victim sender address is present anywhere in the input. And if it is, then we do replace the input with the adversarial transaction. And that's really it.
01:50:45.550 - 01:52:04.760, Speaker A: So what we do find is that here on the x axis we have the timeline that we evaluated this on the Ethereum blockchain, and on the y axis we have the accumulative profit in ether. So you can see here that the block top replayable. So for those blocks where if we replay it on the top block, then we can get probably over 50,000 ether within those 32 months period. So naturally the amount of us dollar that I reported earlier is based on the ether price at the time of the measurement. So what we can basically observe is that the accumulated profit that can be extracted by replay attack is really significant. And the number of replayable transactions remained more or less constant while still being rather volatile. So we can see here there's some coarse grained volatility on the number of replay transactions, but we do observe about 15,000 transactions at most per month that can be replayed.
01:52:04.760 - 01:52:56.600, Speaker A: So that's certainly also a common issue in trying to secure DeFi protocols. So Sam, for instance, might have told you that ways on how he tries to protect his transactions from being replayed by automated or generalized front running bots. So this particular algorithm here that we show you is really a very simple one. I'm sure there are tons of much more sophisticated algorithms out there, but I just wanted to show you that even with this simple algorithm, if we do evaluate it on past blockchain data, we can find quite some significant value extraction. Very good. I hope that you enjoyed this replay algorithm. So please be aware if you're issuing a transaction and this might extract some value that others could copycat.
01:52:56.600 - 01:53:51.160, Speaker A: Well, try to protect yourself, right? There are a variety of different ideas on how to do that. You can create more complicated smart contracts that can't be replaced as simple as easily as through the algorithm I've shown you, you could have private peering agreements with miners to let them help you to extract the value that you want without being replayed. But at the same time, you will have to trust the miner not to replay you. So, it's a tricky game, but it's fun. Welcome back. While we have discussed very extensively what Mev is previously, I might have not been crystal clear with you of why it matters to security. And in this segment of the lecture, we'll be discussing Bev forking or minor extractable value, forking and chain reorganizations.
01:53:51.160 - 01:54:24.276, Speaker A: So the dangers of naively maximizing mev, or basically extracting mev, is the following. So let's assume we have here a block b one, right? So this is a particular block. And let's assume that there's an honest miner. He or she mines block b two. And there's an mev opportunity in this very block. There might also be a malicious miner, and this malicious miner would like to extract this mev opportunity. Right.
01:54:24.276 - 01:54:55.756, Speaker A: So now the question is for the honest miner. Well, the honest miner would like to continue mining on b three. So this is certainly one case. But this means that the malicious miner will basically for fight the previous mev opportunity. And why would the miner do that? Why would the adversary just give this mev opportunity to this honest miner of this other block? Doesn't make much financial sense. It's not very rational. It's not a very rational thing to do.
01:54:55.756 - 01:56:12.544, Speaker A: Well, depends at least on the value of the mev opportunity. So, naturally, here, it might happen that the adversary keep mining and keeps mining on block c two, because this is the rational thing to do in order to attract the most value out of the block mined. So you can see here the mev minor or the adversary minor, basically extending c three instead of continuing on the honest chain, b two. And then again, there might be the case. Well, the malicious miner could mine on c four to continue increasing, basically its chain, and the honest minor could continue on b four or on c four. So that's really up to the honest minor. But overall, the message, the high level message here is that this mev opportunity, this opportunity here, creates competition among miners to include this very opportunity, because it could be mined in any block, but it can only be mined in a single block, not in multiple blocks at the same time.
01:56:12.544 - 01:57:21.070, Speaker A: So what we observe is there's a potential waste of computational power, which then increases the stale block rate, and this increases the risks of double spending and selfish mining to very security relevant concepts that we have discussed in this lecture already. Now, what you can do is to quantify how important this threat of minor extractable value actually is. You can quantify the optimal addressivity strategy in, for example, a NACA motor coin census blockchain. So what related work has done is to instantiate a proof of work blockchain with various network and consensus layer parameters to extract the stale block rate. So, as you might know, the stale block rate in bitcoin is on the order of a percent, depending on the state. Obviously, in Ethereum, the state block rate was measured between, I think, five and 7% so far, but please don't quote me on that. So this is roughly the order of magnitude that I'm aware of.
01:57:21.070 - 01:58:09.020, Speaker A: And what we can then do is we can model the blockchain as a Markov decision process. So a Markov decision process is a special instance of a Markov chain, but with an added action and state space. And there we can instantiate a few attacks, for example, the selfish mining or the double spending attacks that we've discussed earlier. And the Markov decision process. When you solve this process, you'll get a set of optimal strategies to perform depending on the state. So this is the output, basically, of the Markov decision process. So what I would like to show you is really how to model a blockchain in an MDP in the Markov decision process.
01:58:09.020 - 01:59:06.808, Speaker A: I think this is probably the most interesting takeaway message for this segment of the lecture. So let's assume here we have an honest chain, right? So this is just a regular honest chain where a transaction pays a vendor. And let's assume that in parallel, an adversary is mining a secret chain here, this red one, which is not public yet. And there's a transaction that pays the adversary. And this transaction is a double spend transaction, which is in conflict with the green transaction, right? So these two transactions here, they cannot be mined together at the same time in the blockchain because they're conflicting each other. So in an MDP, what we can now do is we can model the adversarial chain here as the length three and the honest chain as the length one. So three is the architecture.
01:59:06.808 - 01:59:40.584, Speaker A: Chain one is the honest chain, and the adversary now can choose an action. So the adversary can choose what to do. So let's assume that the adversary will override the honest chain. Overriding means the adversary will publish two blocks. So B one and B two prime, right? And because B one and B two prime are longer chain than b one, this will override the main chain. So the main chain is now this construct here. And it's no longer this one.
01:59:40.584 - 02:00:10.480, Speaker A: Right. This is overridden. It's no longer a valid, longest chain. And naturally, now the honest network will continue mining on b two prime. But the adversary got a profit, right. The adversary got the block reward for these two blocks, plus the double spend reward for this very transaction. Well, at least as long as the miner accepted here the transaction after one block confirmation.
02:00:10.480 - 02:00:40.968, Speaker A: But what you can see is here we have a state space, right? This is like three one. In this particular case, we have an action space. So we had the action override, for instance, the adversary could have also waited. This is another action. And we got a reward that we can specify. So the reward was two block rewards plus a double spending value. So I think this is really quite a cool tool to model how a blockchain would operate.
02:00:40.968 - 02:02:20.700, Speaker A: And once you have this model, you can always plug in additional parameters, additional rewards. And we try to quantify to what degree minor extractable value would affect the security of a chain. So what would be the optimal strategy for a miner to perform mining in the presence of a minor extractable value reward? So, we have done this quantitatively, which you can see in this particular paper. But what we have seen, so, just to give you an example, is that given a 10% hash rate minor, right, which is a big minor, but it's not like the biggest, right, if there's a four x average block reward, I mean, if there's an MEv opportunity that's four x the average block reward, then this 10% hash rate miner will be incentivized to fork the chain. And this is dangerous because we will see through. I mean, if the miners are getting more aware that this can be performed on the mining level. If you can basically design an algorithm, for example, with ZMDP, you could design an algorithm that selects your optimal adversary strategies, and you automate this in the mining software, for example, in gath, then we might see many more state blocks, and the chain security will significantly deteriorate.
02:02:20.700 - 02:03:08.664, Speaker A: And this example is just like a small minor with 10% and a four x block reward. Mev opportunity. And alarmingly, what we have seen is like MEV opportunities beyond 800 x, the block reward. So you can imagine what would happen. Thank you very much. I don't want it to make you afraid, but MeV is a security concern, and it's not wise to ignore the dire consequences of rationality, especially once miners have potentially access to automated forking software that is optimally designed. So an MDP might be one avenue towards this goal.
02:03:08.664 - 02:04:25.700, Speaker A: It's certainly not flawless, but, yeah, we should be on the lookout and try to minimize Mav and prevent security dangers on our, well, advancing DeFi ecosystem. Welcome back. We're going to now discuss the new emergence of minor extractable or BEV relayers. So these are centralized front running as a service infrastructure given by variety community members. And we're going to discuss also possible options of how to mitigate MEV, which is such an important topic, to increase blockchain security and make our entire defi ecosystem more sustainable. So BEV relayers are really these centralized entities, mostly servers, actually run by individuals or companies that attract, on the one hand, so called searchers. So these are third parties that are crawling the blockchain and the network layer for minor extractable or blockchain extractable valued opportunities.
02:04:25.700 - 02:05:16.820, Speaker A: Basically, they look at the blockchain or look at the network layer and they create these extracting transactions. And what they do is they do bribe miners. So they pay a fraction of their revenue and they do pay them to miners. So we've looked at a little bit of data and some of them pay like over 90% of the extractable value to miners. And this BV relayer, which is just a centralized service receiving these transactions, is then forwarding them to miners. And the miners are running a custom geth client to sort basically these transactions and then mine the transactions that are the most profitable. So they will basically be put in the first block positions.
02:05:16.820 - 02:06:19.050, Speaker A: So it's quite important to note that this BV relayer may mitigate DNN of service attacks against the miners. But technically you could have like a direct link here to a minor instead. Right. And why have middleman in a blockchain environment if all that we do is really to strive towards eliminating the middleman? So I would advocate for more decentralized approaches where the searchers, for instance, would directly speak to the miners. Instead. The other issue is that the existing BV relayers that I'm aware of, they can censor, reorder transactions and they can actually mine the transaction information about what these searches are doing. So these searchers are, in most cases really smart individuals, creating very nifty strategies on how to extract financial value.
02:06:19.050 - 02:07:20.220, Speaker A: While we don't really know what the agenda of these BEV relayers is, I would also encourage you to ask these BV relayers, what are their terms and conditions, what are their privacy policy, et cetera? Right. So I've tried to understand this domain a little bit, but there doesn't seem to be much transparency, to be honest, which is quite an issue, I think, especially in a decentralized system. So please be aware of these possible concerns. So I've written them down here for you to digest in detail. So we have seen that miner extractable value, or BEV, probably incentivizes miners to fork. So this was published at security and privacy this year. It's a real security concerns we're seeing that the BEV relayer server centralized a peer to peer network.
02:07:20.220 - 02:08:31.704, Speaker A: We don't know what these relayers do. They may resell the profit from searcher strategies, or they may not actually necessarily reduce any peer to peer overhead. Although I've seen this being advertised as one of the main sources of why BEV relayers are useful. It may also be a concern that the for profit company that is running these relay services distributes a geth client to over 50% of the miner. So the geth client development should ideally be decentralized. But if we have a centralized company creating the relay server as well as patching the GEF client, then the GEF client is being provided to miners from a single source, which is a danger on the decentralization aspects. And last but probably the most important, is that these BEV relayers maximize meV, so they maximize the extraction from, for example, sandwich attacks.
02:08:31.704 - 02:09:23.872, Speaker A: And this means that whenever you trade they will try to extract the maximum slippage they can from your trade. And I doubt that's something that's aligned with your incentives. So what can we do to protect ourselves against meV? What's the anti MEV solution space? So there are a variety of great ideas, but it's still a long way to go, I believe, to really protect users as a whole. So there's quite an emerging and really interesting body of work going into the fair ordering on the blockchain layer. So this is by Ari Jules, who gave the oracle lecture. I can really recommend you to look into the Equitas protocol family. We might be able to fix mev at least partially on existing dapps.
02:09:23.872 - 02:10:31.960, Speaker A: So what we can do is we can merge amm dexes into one. So we can build an on chain aggregator. As we discussed in the Dex lecture, we can design mev mindful daps, so we can try to minimize the mev by design. For example, if there's a price oracle update in a liquidation platform, maybe this oracle update immediately performs a liquidation instead of leaving that opportunity to others, and the liquidation proceeds can then be distributed to some, for example token holders or something. I believe there's quite some interesting design space to protect from MEV, but the entire story gets certainly more complicated with crosschain MEV, so we are effectively living already in a reality with multiple chains where crosschain MEV can be observed already. And certainly this is even more challenging than to fix. So even a fair ordering on one blockchain layer might not help fix cross chain mev opportunities.
02:10:31.960 - 02:11:45.052, Speaker A: So just to dive a little bit again into the application specific mev mitigation techniques. So I would like to show you here this particular example where we have two markets of the same coin, x and y. So if we have a trader who then swaps X for Y on that market, well naturally the price of X declines right on that market because we're selling X. And now we have multiple adversaries that actually observe this particular transaction, probably already on the network layer, and they will anticipate then to arbitrage out this very market change. Because this market here needs obviously to be synchronized after the user has performed a swap on that market. And if there are multiple adversaries or arbitrage entities performing this synchronization, then there's certainly an overhead in terms of network congestion. So we have observed background flooding on the network layer, we have observed price gas auctions, and overall then the transaction fees gets increased for the users.
02:11:45.052 - 02:12:45.230, Speaker A: And moreover, the user itself foregoes an arbitrage opportunity, right? So wouldn't it make just more sense if the user instead goes through a smart contract that performs optimal routing and arbitrage and naturally divides the assets among those markets instead of leaving the profits to third parties that will anyways increase the overhead on the chain? Well, it's still to be seen. I believe there are many opportunities in order to build a more sustainable and safe blockchain defi blockchain environment. Thank you so much for listening. This was really exciting to dive into the variety of security related topics for defi. Please don't hesitate to ask any question, whether it's in the chat, in the group forums, or in the discords, etc. We're here to help you understand defi security in and outside.
