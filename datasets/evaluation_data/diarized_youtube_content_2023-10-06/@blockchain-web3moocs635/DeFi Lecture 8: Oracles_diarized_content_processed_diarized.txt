00:00:00.090 - 00:00:49.740, Speaker A: You. Hello. I'm Ari Jules, a faculty member at Cornell Tech and Codirector of the Initiative for Cryptocurrencies and Contracts, or IC Three. I'm giving this lecture my academic role, but I should also mention that I'm chief scientist at Chainlink Labs, a company focused on Oracle technologies. I'm going to talk to you today about blockchain Oracles, what what they are, what role they play now and can play in the future of DeFi, what technical challenges arise in their construction and use, and how we can go about solving or at least addressing these challenges. This lecture consists of six parts. First, in an introductory section, I'll offer a basic explanation of what an Oracle is.
00:00:49.740 - 00:01:45.166, Speaker A: As you'll see, it seems on the face of it that building an Oracle system should be easy. But in the following two sections, I'll explain why this isn't necessarily so. I'll talk about some of the fundamental technical obstacles. I'll then discuss a couple of technically advanced Oracle use cases to illustrate interesting and perhaps unexpected things that Oracle systems do today. Finally, I'll talk about Oracle Privacy, a useful feature for some of the DeFi applications that I expect will come about in the future. Armed with this tool, we'll explore three different, slightly futuristic DeFi applications that Oracle privacy can help enable. Okay, now let's talk about what Oracles are to do.
00:01:45.166 - 00:02:33.390, Speaker A: So it's helpful to consider a few different types of smart contracts, or DApps, all of them arguably DFI contracts. There are token management contracts. These are contracts that enable tokens, like ERC 20 tokens, standard type of fungible token to be distributed to users or transferred between users. There are decentralized exchange contracts or Dex contracts, which allow users to trade tokens or digital assets against one another. A popular example is uniswap. There are NFT games. These are contracts, multiplayer games in which the characters or game pieces take the form of non fungible or unique tokens, so called NFTs.
00:02:33.390 - 00:03:43.140, Speaker A: For example, in the popular CryptoKitties game, players buy and sell and breed cats whose DNA is encoded in a cat specific token. Then there are lending contracts, collateralized lending contracts like MakerDAO, which you're already familiar with. These allow users to borrow against cryptocurrency if they deposit in the contract. And finally, another example here there are insurance contracts that allow users to buy policies and receive compensation if some bad event happens. A flight insurance contract, for instance, pays out if your flight is delayed or canceled. Now, I've intentionally partitioned these examples into two columns because there's an important difference between the examples on the left and the examples on the right. The contracts enumerated on the left don't need external data, data from outside the blockchain in order to function correctly, while the ones on the right do need external data.
00:03:43.140 - 00:04:32.100, Speaker A: For example, a token contract, as I suggested, just moves tokens among accounts. It really doesn't need to know anything about the outside or off chain world. The same is true of many DEXs of automated market maker DEXes, for instance, and some NFT games like CryptoKitties as well. In contrast, a lending contract like MakerDAO, as we'll see, does need data from the outside world, specifically data about the value of the collateral users are borrowing against. And the same goes for insurance contracts. They need to know about the events they're insuring against. We'll also discuss insurance contracts in just a moment.
00:04:32.100 - 00:05:49.450, Speaker A: It turns out, actually as sort of an interesting aside, that even some NFT games make use of external data. Typically, they'll obtain a source of randomness from outside the blockchain in order to distribute new game elements in a fair way, it's interesting to know that randomness can be treated as an external resource. To understand how external data comes into play, let's briefly review how collateralized lending contracts work. You'll recall that to take out a loan, a borrower must first deposit some collateral, say $300 worth of ETH in what's called a vault. The borrower then gets to withdraw a loan in stablecoins. So, for example, the borrower might withdraw $100 worth of stablecoins 100 stablecoins if each stablecoin is worth a dollar. Now, if the value of the collateral on deposit relative to the loan drops below some threshold, usually called the liquidation ratio, and typically around 150%, then what happens is that the contract liquidates the debt.
00:05:49.450 - 00:07:00.978, Speaker A: In other words, the contract will auction off the ETH in order to repay the loan taken out by the borrower. So in this example, if ETH, for instance, drops in value by more than a factor of two, making the collateral worth less than $150, then the ETH will be auctioned off in order to cover the loan. But here's the thing. In order to know whether the value of the collateral relative to the stablecoins being withdrawn or the stablecoins that have been withdrawn is below the liquidation ratio, the contract needs to know the value of ETH in dollars. And that's something that can best be determined, or only be determined with reference to data from exchanges that allow trading in ETH against dollars. In other words, the contract needs what's known as an ETH USD price feed. That price feed reflects activity taking place in exchanges, off chain exchanges where people can buy ETH, for instance, for fiat dollars.
00:07:00.978 - 00:07:54.340, Speaker A: Now, there are other approaches to getting these price feats. As I mentioned, I'll talk about one toward the end of the lecture, but the natural approach would be to make use of external data. Now, let's talk about flight insurance. A flight insurance contract might work in the following way a user who is taking a flight that she worries might be delayed or canceled sends a request to the contract that specifies the flight she's on and indicates the size of the policy she wants. Now, of course, for the right to be indemnified, in this case, our user is asking for $100 policy. So for the right to be indemnified $100. If her flight is canceled or is delayed, the user needs to pay a small premium, so she pays the contract something like $2.
00:07:54.340 - 00:08:40.210, Speaker A: The contract then keeps track of the status of the flight that the user here has specified. And if the flight is indeed delayed or canceled, of course pays out to the user. The beauty of buying flight insurance from a smart contract is that the contract of course, will pay out immediately and unconditionally. You don't have to worry about an insurance company dragging its feet. The question though is how does the contract keep track of the user's flight here? How does the contract know whether to pay the user? Well, clearly it needs flight data. And flight data doesn't arise spontaneously on a blockchain. It has to come from some external system like a web server.
00:08:40.210 - 00:09:34.970, Speaker A: There are lots of other DeFi applications that need data, as you can imagine. A betting contract, if you want to think of that as a DeFi application, say a sports betting contract, of course needs to know the outcome of the events that users are betting on. The user is betting on a baseball game. The contract needs to know who won the game, which team won the game. There's a notion called wrapped cryptocurrency. This is a representation of a currency on what I'll call a source chain on some different chain called a target chain. So for example, someone might want to represent bitcoin on the ethereum blockchain because the ethereum blockchain has a much richer smart contract functionality than the bitcoin blockchain.
00:09:34.970 - 00:10:29.990, Speaker A: How do you do this? Well, some service takes custody of bitcoin on the bitcoin blockchain and then tokens wrapped bitcoin, as they're called, are issued on the target chain, the ethereum blockchain. For instance. How does the contract on the ethereum blockchain know that bitcoin was placed in custody, appropriate custody on the bitcoin blockchain? Well, somehow that contract needs insight into the state of the bitcoin blockchain. There's no direct connection between the ethereum blockchain and the bitcoin blockchain. Somehow the ethereum blockchain needs access to external data in the form of bitcoin blockchain state. There are synthetics. These are DeFi assets that are meant to represent real world assets.
00:10:29.990 - 00:11:29.850, Speaker A: For example, Sau is a form of synthetic gold. In order for a DeFi contract to manage synthetic gold tokens, it needs to know the real world price of gold. And finally, there are forms of lending other than the MakerDAO variety, so called collateralized lending. There are forms of contract emerging in which loans are made to users on the basis of their trustworthiness. How does a contract know whether a user is trustworthy? Well, it needs access to some form of external data. That external data could, for instance, be a credit report on the user who wants to take out a loan. There are many, many more examples, but these illustrate the wide variety of contracts that need external data to function correctly.
00:11:29.850 - 00:12:34.434, Speaker A: The problem and challenge is that, for various reasons I'll explain shortly blockchains don't have Internet Connections a smart contract, for all its smarts, can't get an answer to a simple question like what is the market price of Bitcoin in US. Dollars at this very minute, the way that you or I could? The obvious way, of course, to get such data would be to do what you would do or any other person would do look it up on the Internet. So why not have a blockchain simply do this? It turns out that things are not quite as easy as they seem. This relaying of data from web servers and other sources onto a blockchain to a smart contract. This job is the task of what's called an Oracle in the blockchain world. This is basically what an Oracle does. Oracle networks need very careful design.
00:12:34.434 - 00:13:13.670, Speaker A: We're going to spend a fair amount of this lecture delving to the reasons why it's not as straightforward to design an Oracle as it may seem from this picture. The reason for discussing Oracles in this course is that they play an absolutely critical role in the DFI system. If you go to DFI Pulse and you take a look at, say, the top ten DFI DApps there, you can see them on this slide. It turns out that nearly all of them make use of Oracles. The only exceptions are the DEXs, the automated market makers. Here. You see curve uniswap and SushiSwap.
00:13:13.670 - 00:14:04.520, Speaker A: But as I'll discuss later, it turns out that DEXs themselves can actually serve as Oracles, although there are some important caveats. I'll talk about this idea toward the end of the lecture. I've given you now a strong hint about what an Oracle is, but let me wrap up this module by giving you a couple of definitions. First, a narrow definition that applies to most Oracle systems today. You can define an Oracle as an off chain platform that relays data on chain. And more specifically, if you want to capture most of what's going on in Oracles today, an off chain platform that relays data from web servers to smart contracts. That's most of the time what's happening.
00:14:04.520 - 00:15:14.380, Speaker A: But as we're going to see in this lecture, oracles can do an awful lot more. So I think it's helpful to keep in mind a more general definition and think of an Oracle as an off chain platform whose job is to connect blockchains with other systems, be they web servers, other blockchains, Internet of things, devices, or something else. Now that we know what an Oracle is, let's talk about how to build one. We'll do this in an incremental way, starting with a basic design and surfacing problems as our design grows more complex. As I've suggested, when you need a piece of data like, say, a flight status, you can of course, just look it up on the Internet. So why do we need to bother with Oracles at all? Why not just have blockchains do what you or I would do and query web servers directly. Specifically, we could imagine building Oracle functionality directly into the block production mechanism.
00:15:14.380 - 00:16:13.040, Speaker A: Some Miner has to assemble a block, processing the transactions in it, and executing the smart contracts that get invoked, and so on and so forth. So why not just have the miner look up any data those contracts need? For example, when you see a flight insurance contract in the most recently mined block, why not just have the miner look up the flight data it needs and do that directly? Unfortunately, this approach won't work. The reason is that although the consensus protocol is decentralized, the construction of a block is actually temporarily centralized. It's in the hands of a single miner. Now, normally this isn't a problem from the standpoint of block validity. The whole network checks blocks to be sure that they're valid and discards them if they're not. So a cheating Miner can't produce an invalid block.
00:16:13.040 - 00:17:07.250, Speaker A: But that's not going to work if the Miner is fetching external data. You can tell whether a block is valid by making sure that it conforms to the rules of the blockchain, because there's no ambiguity in those rules and all that's required is internal consistency. But there is ambiguity in web data in the sense that you can't simply look at it and be assured that it's correct. Suppose, for instance, that a minor lies. The miner here says flight number 1215 was on time when the flight was actually late. Well, there's simply no way to tell that the miner lied simply by looking at the block. So, given the way that blockchains operate today, this naive approach, if you will, isn't going to work.
00:17:07.250 - 00:17:58.908, Speaker A: There are other complications here too, of course. If the website that the contract uses goes down for an hour, then it's unclear what we should do. Do we hold back the block for an hour? Clearly we don't want to do that because that would stall the progress made by the blockchain. But this problems of this type, of course, also make things a bit messy. So let's consider a different approach. Rather than putting responsibility for fetching data in the hands of a single Miner centralizing it, let's instead have a committee fetch and agree upon the data. By committee here, I mean, as the slide suggests, a collection of nodes or servers that are run by a diverse set of entities.
00:17:58.908 - 00:18:48.032, Speaker A: So maybe there are five nodes, each run by a different organization. Now, each of these nodes can query some authoritative source of data. Some website they agree, for instance, provides high quality data. And the nodes in the committee can communicate with the other nodes until they reach consensus on the value of the data to be sent to the contract, in this case, flight status. Now, they don't all need to agree, but perhaps rely on a value asserted by majority or some threshold number of nodes. Once they've done this, one of the nodes can send whatever value they've agreed upon to the contract. And this piece of data, incidentally, is often called a report, as shown in the slide here.
00:18:48.032 - 00:19:33.410, Speaker A: So I'll refer to it in many cases using that term. Well, now the process of deciding on the value relayed to the contract is no longer centralized. This seems good, but unfortunately there's still a problem. What's the problem? The problem is that the node that's sending this report that the committee has agreed upon could lie. Maybe the committee decides that the flight was delayed and this one rogue node that's transmitting the report claims that it was on time. The problem is, we've again got some form of centralization here. We've got one node that's responsible for relaying the report.
00:19:33.410 - 00:20:25.356, Speaker A: One way to get around this, of course, is to have all nodes send data independently to the contract. And that's not an unreasonable approach, but it's an inexpensive one. There's a big overhead in terms of gas. You'd pay essentially five times the gas cost of transmission of a report by single node. Also, the contract would need to do some kind of computation to make sense of the multiple values it receives, and that also incurs a gas cost and complexity. An alternative is to have all of the nodes digitally sign the report before it's sent. Now the receiving contract just needs to check the signatures and make sure that the report it's received has been signed by majority of nodes in the committee.
00:20:25.356 - 00:20:56.670, Speaker A: If that's the rule. You can even use various tricks to make this approach more efficient. Using, for instance, what's called a threshold signature to compress the five signatures into a single signature. This saves gas cost and makes the report more concise. Now we have a truly decentralized system for delivering a report. Now a report can't be corrupted by a single node. So it seems like we're done right.
00:20:56.670 - 00:21:36.250, Speaker A: Well, not quite. We may still have a problem. The problem is that the node that's responsible for sending the report could go down. Then the report may be correct, but it's not going to get delivered. This is just as bad for the user as an erroneous report, in the sense that she may not get paid for her delayed flight. If no report is delivered, then the contract is not going to reimburse her. So what do we do about this? Well, we can solve this problem by allowing other nodes to take over if the designated node fails to deliver the report.
00:21:36.250 - 00:22:19.190, Speaker A: For example, if node one has failed, gone down and doesn't deliver the report, node two could take over. And similarly, if node two fails to deliver the report, node three could take over. This kind of redundancy is the way that this problem is dealt with in practice in Oracle systems today. But still, there are complications remaining. In particular, nodes aren't the only thing that can go down. It is also possible, of course, that the website goes down or that the website provides incorrect data, not necessarily even out of malice. There may just be a bug on the site.
00:22:19.190 - 00:23:06.230, Speaker A: So what do we do about this? Well, you may already have some idea based on how we dealt with the problem of nodes going down. We dealt with that problem through redundancy. Similarly, we can deal with the problem of a website going down by using redundancy. In fact, you can look at a solution to this problem. The solution I'm going to propose as yet another form of decentralization. If we're relying on a single data source, relying on a single website, that's a form of centralization means that that one website dictates the data sent to the contract. And reliability for the system as a whole depends on that one site.
00:23:06.230 - 00:24:13.240, Speaker A: But if instead the nodes of the committee are querying multiple sites, querying, say, three websites, then we're in a position to deal with website outages and potentially even corruption of data in websites. If one website serves incorrect data, but the other two websites are serving correct data, and nodes take the majority response from the websites across all three websites, then the committee is still going to produce a correct report. We've arrived now at an oracle architecture that seems as though it solves all of the big problems we might naturally encounter in practice. But I've already promised a second half to this part of the lecture. So, as you may have guessed, there are yet more complications to consider at this point. We've considered how to ensure that no one node has full control of the contents of a report or the delivery of a report. We've also considered how to protect against website failures.
00:24:13.240 - 00:25:22.444, Speaker A: But what happens if the nodes in our committee have different views of the world? Or if some of them even choose to lie? What happens, for instance, if some of the nodes say that the flight in our example is on time, but other nodes say that it was delayed? What do we do if there's a disagreement of this type among the nodes in the committee? Well, I've already suggested the answer when I talked about the use of digital signatures. We can simply take the majority value asserted by the nodes. If at least three nodes say that the flight was on time, then the report sent to the flight insurance contract says exactly that. The situation in this particular example is actually fairly simple because the value reported on, at least as I've presented it, is binary. Either the flight was on time or the flight was delayed. Things could get more complicated if nodes report numerical values, and the values they report are different across nodes. This isn't uncommon.
00:25:22.444 - 00:26:30.100, Speaker A: For instance, when it comes to price data, there's actually no such thing as a definitive price at a given time for a cryptocurrency. Cryptocurrencies are generally traded in multiple exchanges. And prices will vary a bit from exchange to exchange. So one Ether may be trading for, say, $2,000 on one exchange, but trading at the very same time for only $1,990 on a different exchange. So different nodes query different exchanges or even query the same exchange at slightly different times, and then you'll end up seeing different asset prices. To add to the complexity here, often systems rely not on the prices reported directly by exchanges, but reported by middle services, if you will, known as price aggregators. Price aggregators combine prices across exchanges according to formulas that are secret and proprietary in many cases.
00:26:30.100 - 00:27:24.728, Speaker A: So things are complicated. And all this is to say that nodes could, for perfectly legitimate reasons, end up seeing and reporting different asset prices. In this setting, we can't of course, rely on a majority value because there may be no majority value. Let's say, for instance, that there are seven nodes in the committee, each reporting a different value. You can see the different values they report on the right hand side of the slide here. How do we combine these values into a single report for a relying DeFi contract, for a contract that's going to consume price data? Your first thought might be that we should take the average, and indeed this is what we want to do, but we need to be a little careful. There are different types of average, of course.
00:27:24.728 - 00:28:23.400, Speaker A: We could, for instance, take the mean in the example I'm showing here. This seems to yield a reasonable result. But suppose one of these nodes decided to go completely rogue and report a wildly incorrect value. Suppose one of these nodes said that the current price of Ether in US dollars is 40,000, while the others are reporting something around 2000. In this case, the mean is itself wildly incorrect, over $7,000. The problem here, you can see, is that computing the mean is not a good idea because it empowers just one bad node to skew the value reported by the committee as a whole. To avoid this problem, the type of average we could take, and probably should take is instead the median.
00:28:23.400 - 00:29:01.764, Speaker A: This is, you'll recall, the middle value if we have an odd number of values, or the average of two middle values. Otherwise. So in our example here, the median is $2,000 and this is what we would report to the DFI contract. This is what the committee would report. Medianizing is what's done in practice. And medianizing, this process of taking the median has some very nice properties. Specifically, it provides good protection against the scenario we saw in the case of the mean.
00:29:01.764 - 00:29:45.830, Speaker A: It protects against erroneous, corrupted or maliciously reported values. Suppose, for example, that not one node but three different nodes decide to go rogue and report incorrect values. Now, here I'm showing only subtly skewed values. But let's imagine that the ones in red are incorrect, which is to say reported dishonestly in some way. As you can see, the median in this case is still a value reported by an honest node. So the value reported to the DeFi contract is relayed directly by a node that we might deem trustworthy. And that's good.
00:29:45.830 - 00:30:28.620, Speaker A: The same is true if all of these nodes to the left go rogue and happen to report extremely low values. The value that gets reported to the contract, again, is reasonable. It's reported by an honest node and it looks essentially correct for some meaningful notion of correct. Another situation that could arise is that the median value itself is reported by a rogue node. You see that in the slide I'm showing here. Now this would seem, on the face of it to be a very bad thing. The value that's being reported to the contract was provided by a bad node.
00:30:28.620 - 00:31:36.920, Speaker A: This seems like something we don't want. But in fact you'll see in this example that although the median value is reported by a rogue node, it actually lies between two values reported by honest nodes the node on the left and the node on the right. So in fact, it's actually quite reasonable to treat that value as trustworthy or authoritative. If it's bounded by values reported by honest nodes, and there's some differences in the values reported by honest nodes, then it falls roughly within the range of values that we would consider correct. In general, the property we get with the median is that as long as most nodes are honest, the median is trustworthy. I mean trustworthy in the sense that it's reported by an honest node or lies between values reported by honest nodes. So medianizing provides a form of security or resilience against the participation of a minority, at least of malicious nodes.
00:31:36.920 - 00:32:37.836, Speaker A: If all nodes are bad, or a majority of nodes are bad, then essentially all bets are off. But as long as a minority of nodes at most are incorrect skewing values, the value that's ultimately reported to the DeFi contract by the Oracle system is going to be reasonable. It's going to be trustworthy. Now, when you first look at the problem that Oracles are designed to solve, which is to say, relaying data from off chain systems on chain systems specifically of course, to smart contracts, it seems like building an Oracle system should be straightforward, as I'm hoping you see now, it isn't straightforward. One of my goals in this lecture has been to give you a flavor of the challenges that arise in Oracle architecture. But even the challenges I've mentioned are really just the tip of the iceberg. There are plenty of other technical challenges I'm not going to cover today, but I do want to mention a few others.
00:32:37.836 - 00:33:33.896, Speaker A: First, there's payment. Billing is often a tricky operation in just about any system. It's particularly challenging though, in decentralized systems. Not only do you want to be sure that nodes are paid for their services, but you want to be sure that they're paid in a way that incentivizes good behavior and reliability. You also have to figure out how much to charge the users of an Oracle system to deliver a report. An Oracle system needs to cover gas costs or whatever you call the fees in the blockchain on which the Oracle system is operating. When these costs spike, the question is, should the added expense be passed along to users or not? If you're not careful and don't, for instance, charge enough, the Oracle system could be attacked by somebody who pays a small fee to get a report delivered and causes the system to burn a lot of gas.
00:33:33.896 - 00:34:28.460, Speaker A: And in fact, attacks like this have arisen in the wild. There's also the question of how you get reports to contracts in a timely way. Now, it may be true of many parts of life, but it's especially true in finance that time is money. So how do we ensure that the Oracle gets reports on chain to a smart contract as fast as possible? If the only thing we cared about was speed, we could just use a single node and things would be faster because then nodes wouldn't need to intercommunicate to agree on a report value. We've seen how a committee needs to come to consensus on such a value before a report is generated. We could dispense with all that by just using a single node. The reason we don't, of course, is that then we would lose decentralization.
00:34:28.460 - 00:35:43.600, Speaker A: Now this is just to point out that there are a number of considerations and trade offs when it comes to speed, and obviously I'm not going to get into those in this lecture. Finally, I've suggested that we can solve many of our problems by assuming that a majority of nodes are honest. But how do we do that? How do we ensure that a majority of nodes are going to report correct values? For example, if the Oracle committee were permissionless? In other words, if we allowed just anyone to contribute a node to the Oracle committee, then one bad actor could spawn a lot of nodes and gain majority control, potentially of the committee powering. An Oracle, on the other hand, if just one organization is running all the nodes, in other words, if we have really, really strict permissioning, we lose many of the benefits of decentralization. So again, there's a tricky balance to be struck here. These are all challenging questions that I'm not going to explore in this lecture. And as you can imagine, there's a whole host of others.
00:35:43.600 - 00:36:14.396, Speaker A: Some of them you'll see later in this lecture. But I think the important thing is to point out that in general, designing Oracle systems is a hard problem. Now, I do want to point out that I'm simplifying things quite a bit. I'm ignoring the use of proxy contracts. Oracles generally don't send reports directly to relying contracts. I'm also glossing over. How nodes in a committee communicate, how nodes get selected for a committee, I've alluded to that challenge, and so on and so forth.
00:36:14.396 - 00:37:09.600, Speaker A: So even with this gross simplification, you can see that things are tricky at this point. We've talked about the basic architecture for Oracle systems that relay data from websites. Now, let's briefly explore some advanced Oracle technologies and how they're used in practice today. Just as a quick reminder, DEXs or decentralized exchanges are smart contracts that allow users to trade assets on chain. The most popular type today are automated market makers, or AMMS. Those are contracts that allow users to trade against assets, so called liquidity held by the contract itself rather than, say, another user. Uniswap is a popular example of such a contract.
00:37:09.600 - 00:38:07.750, Speaker A: One side effect of trading on any platform, Dex or otherwise, is a collective assessment, if you will, of the value of an asset by buyers and sellers. To put this another way, the trading price in a system like Uniswap should reflect the prevailing price of an asset across the market as a whole. If it doesn't, if an asset is mispriced, then there's an arbitrage opportunity. What I mean is that if an asset is mispriced, then someone can make money. For example, suppose that the price of ether on uniswap is $3,000. This would be denoted in a stable coin, but I'll just refer to the value in terms of dollars. So price on Uniswap is $3,000, but on some other exchange it's only 2900.
00:38:07.750 - 00:39:01.376, Speaker A: Well, you can see easily a way to make money. Now, what you do is you go to the other exchange, you buy a whole lot of ETH, and then you turn around and you sell it on uniswap, where the price is $3,000. As trades of this type happen, the price on Uniswap will drop until it reaches the prevailing market price, assuming that volumes are higher on other exchanges. The upshot of all this is that it's possible to use a Dex as a price. Oracle, assuming a benign environment, at least, the price reflected on a Dex should be that of the market at large. And this is very convenient. Use of a Dex in this way is sometimes referred to as a crypto economic Oracle.
00:39:01.376 - 00:39:35.388, Speaker A: And crypto economic Oracles have some very nice features. One is that they respond instantly to queries from other smart contracts. For instance, there's no need to push data on chain. The data in some sense has already been pushed on chain as a function of the trading that's happened in the Dex. This means that they are composable with other smart contracts. They can be queried directly and instantaneously by other smart contracts. It is possible within the course of a single smart contract transaction.
00:39:35.388 - 00:40:29.280, Speaker A: And such transactions, as you've seen, can involve multiple smart contracts. It's possible in the course of such a transaction, to query a Dex to get a current price. Another nice feature in principle of crypto economic oracles is that they come with an economic assurance of correctness. An adversary that wants to induce an incorrect price that's going to say, will lose money on the decks. By doing so, such an adversary is pushing the decks away from the market price and therefore introducing opportunities for other arbitragers to push it back in the correct direction. Shoveling against the tide, as it were. And such shoveling against the tide carries a financial expense or penalty.
00:40:29.280 - 00:41:11.760, Speaker A: But crypto economic oracles also have some drawbacks. To begin with, they're only useful for getting price data. They're only useful for getting data about the assets that are traded in the DEXes that serve as these oracles. They're obviously not going to tell you, for instance, whether or not a flight has been delayed. Additionally, as I said, there's an economic assurance of correctness, but I didn't say that they're absolutely guaranteed to be correct. An adversary may need to pay a penalty in order to manipulate a price, but it can still be done. And this, as we'll see in a moment, can have devastating consequences.
00:41:11.760 - 00:42:19.270, Speaker A: Let me describe an attack that happened back in February of 2020. On the 18 February 2020, this was an attack against a platform known as BZX. BZX is a decentralized trading and lending platform that was using Kyber, which is a Dex, as a price oracle to enable borrowing using synthetic US dollars synthetic stablecoins as collateral. What an attacker did was manipulate the SUSD those are the stablecoins SUSD ETH price in Kyber. By selling ETH on Kyber. Selling ETH on Kyber drove down the apparent price of ETH, drove down the price of ETH artificially on that particular platform. And this caused the Kyber oracle consequently to underreport the ETH price.
00:42:19.270 - 00:43:17.812, Speaker A: What the attacker did then is borrow ETH cheaply on BZX cheaply because the Kyber oracle was reporting a low ETH price. So the attacker didn't have to use very much in the way of stablecoins to borrow ETH and then basically ran away with a loan. The result was that this attacker managed in a single transaction, multistep transaction that invoked multiple smart contracts, but managed in this single transaction to make a profit of almost $700,000. Here are some more details on the attack. Attacks of this kind were mentioned in an earlier lecture by Arthur Gervais, and the figure on this slide is from an assigned paper he co authored. The attack was fairly sophisticated and involved several steps. First, the attacker borrowed some ETH from BZX.
00:43:17.812 - 00:43:55.668, Speaker A: Remember, BZX is a lending platform. Among other things, borrowed some ETH using a flash loan, which you have heard about in a previous lecture. Then the adversary bought some stablecoins using the ETH. The adversary took some of the ETH, though, and used it to drive down the price of ETH on BZX. The adversary manipulated the Kyber price Oracle by selling off ETH on the Kyber exchange. This drove down the ETH price as expressed in terms of US. Dollars.
00:43:55.668 - 00:44:43.316, Speaker A: SUSD. The attacker then borrowed dollars using ETH, borrowed more dollars using ETH, and then borrowed some ETH using SUSD. And here's the critical thing. Because the adversary had manipulated the Kyber price Oracle and driven down the price of ETH, the adversary was able to borrow ETH cheaply, was able to borrow lots of ETH. Then the adversary paid back the flash loan. And the result, thanks to the super cheap borrowing, was a profit of thousands of ETH. At the time, those ETH were worth almost $700,000.
00:44:43.316 - 00:45:38.140, Speaker A: As I mentioned before today, that much ETH would be worth millions. As you can see, this was a sophisticated attack, and the essence of the attack was manipulation of this price oracle. A countermeasure to attacks of this kind that cryptoeconomic oracles now employ regularly is reporting not the current price of an asset, but what's called the TWAP, or the time weighted average price. As the name suggests, this is an average of prices over some period of time. An adversary can't manipulate TWAP the way that the BZX attacker did because price manipulation gets averaged out, largely averaged out. An adversary would have to manipulate the price over a sustained period of time. And that's just not feasible.
00:45:38.140 - 00:46:21.124, Speaker A: This is a good countermeasure. It makes an attack like the BZX attack infeasible, but it carries a significant drawback. So I've actually listed it here as a con or drawback to crypto economic oracles. And the drawback here is that if you're averaging the price over time and not reporting the current price, then the price that you're reporting is less accurate. It may not match the current price perfectly because it also reflects past prices. Now, this isn't to say that cryptoeconomic oracles aren't useful. I think they're actually quite useful as a backstop.
00:46:21.124 - 00:47:15.630, Speaker A: For instance, for conventional oracles, for instance, if a conventional oracle, I mean, an oracle relaying data from off chain, from exchanges off chain. If a conventional oracle price differs wildly from the crypto economic Oracle price, something may have gone amiss and you may want to sound an alarm. Additionally, crypto economic oracles can be used in principle as a fallback if a conventional oracle fails, if the oracle just fails completely, you've got this other oracle you can rely upon. But the limitations of crypto economic oracles mean that they're not really a perfect replacement for conventional Oracles. Let me switch gears a bit now and talk about two applications of oracles that don't involve relaying data from websites. I mentioned earlier in the lecture that some NFT games use oracles as a source of randomness. Let me explain.
00:47:15.630 - 00:47:53.636, Speaker A: Recall that NFT stands for non fungible token. In NFT games, the pieces or characters are NFTs. You recall that NFTs are unique, unique on a per token basis. These are tokens that generally adhere to a standard known as ERC 721. In NFT games, the pieces or characters are themselves NFTs. I mentioned CryptoKitties, which is the best known example. But there are lots of other NFT games.
00:47:53.636 - 00:48:51.770, Speaker A: Axio Infinity, for instance, is a sort of Pokemon like game that also involves storage of characters'data and NFTs. There are fantasy football games, card games and so on and so forth. Often these games involve random generation of new characters or NFTs random generation cryptokitty's DNA and thus its phenotypic characteristics. These are the characteristics that are expressed in terms of the function of the cat or the appearance of the cat. These phenotypic characteristics, which are known as catributes, are determined at random. And the way that cats are bred is also controlled by randomness. The question is, where does this randomness come from? This turns out to be an important question.
00:48:51.770 - 00:49:36.040, Speaker A: A crypto kitty with important rare cat tributes can fetch a lot of money. In some cases, an individual CryptoKitty has fetched over $1,000 on the market. So if you can predict the randomness used by the CryptoKitties contract, you can profit from it. CryptoKitties uses randomness derived directly from the blockchain, which turns out to be hard to use. Well, if you use block hashes, for instance, miners can manipulate them. So trustworthy randomness is essential for fairness. You want to avoid the use of randomness that can be manipulated or randomness that can be predicted.
00:49:36.040 - 00:50:32.540, Speaker A: This is the motivation for the use of something known as a verifiable random function. I won't get into the details too much here, but the Oracle uses a secret key to generate randomness in a deterministic way. The fact that the randomness is deterministic actually means that it's not true randomness, which would mean bits generated by an unpredictable physical process like rolling dice. Instead, it's something known as pseudorandomness. So I'll use the term randomness here, but I really mean pseudorandomness. A VRF involves computing this pseudorandomness in a way that is almost like, but not exactly like, a deterministic digital signature. And it takes as input block hash or other data provided by a contract.
00:50:32.540 - 00:51:38.560, Speaker A: Now this value produced by VRF looks random for all intents and purposes, but it has one nice special feature, which is that the correctness of the randomness it outputs is publicly verifiable, just like a digital signature is publicly verifiable. Everyone can check that a claimed output from the VRF is in fact correct in the sense that it was computed using a secret key with a corresponding public key, again, very much like a digital signature. In consequence, you kind of get the best of both worlds. The output of the VRF is random in appearance, meaning that it's unpredictable. So you get fairness for applications like NFT games. At the same time, the public verifiability of the VRF means that the Oracle computing the VRF can't cheat. Everyone can check that it's doing its job correctly.
00:51:38.560 - 00:52:54.090, Speaker A: The final advanced Oracle application I want to discuss is what's known as wrapping of cryptocurrency. Suppose you have bitcoin and you'd like to hold onto it, but you'd like to do things with it that require the rich functionality of a smart contract system like Ethereum or some other blockchain. What can you do? What you can do is what's called wrapping it. You can transfer your bitcoin to Ethereum using a connector between the two systems. To do this, you do the following you send your bitcoin to a special address controlled by a committee of nodes, and this committee can basically be identical with those in an Oracle system. You also let the committee know somehow your address on Ethereum, the address on which you want to receive your wrapped bitcoin. The committee then, when your bitcoin transfer has been confirmed on the bitcoin blockchain, instructs a special contract in Ethereum to send a token to your Ethereum address.
00:52:54.090 - 00:53:51.948, Speaker A: This token is in essence a fully backed bitcoin representation on Ethereum, and it's what we refer to as a wrapped bitcoin. Now you can do whatever you like with this token. In the Ethereum ecosystem, it's a standard token, can be an ERC 20 token. For instance, if you want your bitcoin back, you can simply burn a wrapped bitcoin token in Ethereum and the committee then sends you your bitcoin on the bitcoin blockchain. You'll notice that the committee here is doing a few things, but among them is actually a fairly standard Oracle role. The committee is sending off chain data to the wrapping contract in Ethereum. In this case, the data doesn't come from a web server, it comes from another blockchain, but it's still off chain data.
00:53:51.948 - 00:54:39.640, Speaker A: And the idea is very similar to that of relaying data from a web server. This specific type of Oracle functionality is called a cross chain bridge. Cross chain bridges can be used to transfer assets across chains, but in principle they're much more general. They can transmit messages across blockchains and in general kind of stitch blockchains together. So I think we'll see many more applications of cross chain bridges in the future. DeFi privacy is a broad topic. I'm now going to talk specifically about the privacy issues that the use of Oracles naturally raises, as well as the role that Oracles can play in enforcing privacy.
00:54:39.640 - 00:55:47.730, Speaker A: I want to emphasize that privacy preserving Oracles aren't really in use today, but I think they will be in the near future. I'm going to talk about ways to enforce privacy in Oracles, and then in the next part of the lecture, I'll discuss a few compelling applications that leverage privacy preserving Oracles. So the remaining material in this lecture is a little futuristic, but I think it will start to materialize in the next several years, not the distant future. Let's return to our flight insurance contract example. Recall that our user here, I'll refer to her now as Alice, is buying an insurance policy for a flight she's about to take. She sends the flight details to the insurance contract along with her premium and is now guaranteed payment if her flight is delayed or canceled, even if everything functions correctly. Can you see a problem with this scenario in particular, since we're talking about Oracle privacy? Can you see a privacy problem? I'll pause for just a second so you can think about it.
00:55:47.730 - 00:56:40.290, Speaker A: As you've probably observed, the problem is that Alice is sending her flight details to the smart contract and therefore to the blockchain. That means she's broadcasting a key piece of her, travel itinerary to the entire world. Even if she doesn't make her identity public and keeps her account pseudonymous, this could still be a problem. If she makes a habit of broadcasting her travel plans to the world, it could even be possible to use those details to de anonymize her. What may seem especially discouraging here is that the problem appears to be unavoidable. After all, blockchains, and therefore smart contracts, are designed for transparency, not for privacy. But there's actually a fairly simple solution to this problem.
00:56:40.290 - 00:57:23.980, Speaker A: It's a partial solution, but maybe adequate in some or even most settings. The idea is that Alice doesn't send her flight details to the contract. Instead, she only indicates to the contract the size of the policy she wants, and she also sends it her premium. I'm going to assume for simplicity here that premiums are uniform across policies, across flights. The actual flight details, though, Alice sends to the Oracle, to the committee. Now, the Oracle still reports to the contract on whether or not Alice's flight was delayed. But the contract never learns which flight Alice insured.
00:57:23.980 - 00:58:37.636, Speaker A: This is much better in terms of privacy than the previous naive approach, right? The flight data isn't revealed on the blockchain, but it's still possible that not everyone will be happy with it, because it still means that Alice is revealing flight details to all of the Oracle nodes. To achieve what I'll call strong privacy, meaning that no one learns Alice's flight details, we can make use of a relatively new technology known as a Trusted Execution environment, or Tee for short. Tes are already available in some models of Intel CPUs as a technology called Intel Software Guard Extensions, or SGX. SGX realizes a Te using special hardware capabilities, basically an extension of the security capabilities of the CPU. A te enables code. Some application, X, I'll call it, to be run in a protected environment called an enclave. The Te.
00:58:37.636 - 00:59:14.320, Speaker A: The enclave provides two key properties. The first is integrity. Roughly stated, an application in a Te is immutable. Even the owner of the physical platform on which it's running can't change it. Now, this integrity assurance should sound roughly familiar. It's quite similar to the property that blockchains confer on smart contracts, right? Smart contract code can't be modified after it's placed on chain. The second property is confidentiality.
00:59:14.320 - 01:00:05.840, Speaker A: The application can run on data that is hidden from the world, including even the owner of the computer on which the application is running, which is kind of remarkable. This property is basically exactly the opposite of the blockchain property of transparency. Now there's a catch here, which is the reason for the stars. You see, Teas have had some serious security weaknesses, so not everyone likes them. SGX in particular has had some flaws uncovered by researchers over the past few years. But they're improving, and it's helpful to think of them as an extra layer of security, what cybersecurity specialists often refer to as defense in depth. Even if they're not perfect, they're still useful.
01:00:05.840 - 01:00:59.700, Speaker A: Now, these two te properties can be achieved to some extent by other means, such as cryptography. And I'll mention one cryptographic tool a little later that achieves much of the same functionality. But tes are very powerful and it's relatively easy to understand what they do. Of course, I'm glossing over a lot of details here about how tes work, but conceptually, all you really need to know about are the two properties I've just discussed. With the use of a te, we can refine our flight insurance contract architecture. Instead of using ordinary Oracle nodes, we can instead use nodes with tes. Or better yet, we can have each Oracle node run essentially an identical te to ensure against node outages.
01:00:59.700 - 01:01:51.750, Speaker A: Now, we get very strong privacy. The tes hide Alice's flight data from node operators, and of course, from everyone else. This idea of using a te to build an Oracle system was first proposed in a 2016 paper by my academic group describing a system called Town Crier. Here's another interesting application of te based Oracles. Let's suppose that Alice wants to sell a game she's purchased online to Bob for cryptocurrency, and also assume that the game platform allows games to be transferred among users. Well, there's a problem here. If Alice and Bob don't have a good reason to trust one another, if Alice sends the game to Bob and waits for him to pay her, he could just run off at the game.
01:01:51.750 - 01:02:32.690, Speaker A: Conversely, if Bob sends Alice the money and then waits for her to transfer the game, she could run off at the money. In other words, the first mover here is at a disadvantage. This is known as the problem of fair exchange. Well, smart contracts are an excellent solution to the fair exchange problem in many settings. And it seems like we should be able to use a smart contract. I'll call it the Game trader contract. Seems like we should be able to use this game trader contract to enable Alice and Bob to safely affect the sale of the game.
01:02:32.690 - 01:03:27.030, Speaker A: First Bob sends his money to the contract, then Alice sends the game to Bob. If Bob receives the game, then the contract releases the funds that Bob provided the money he pays for the game to Alice. But there's a little problem here. The problem is that somehow game trader needs to know whether Alice actually sent the game to Bob. It needs to be able to verify delivery. And the only way to do this is through the Game platform, such as the Steam marketplace, if we're talking about a Steam game. So it seems like the contract needs Alice's Steam credentials, her username and password, or Bob's credentials to check that the transfer had happened.
01:03:27.030 - 01:04:27.270, Speaker A: But there's no way for the contract to take custody of those credentials securely. Remember, smart contracts provide transparency, not privacy. So if a password is sent to Game Trader, it's going to be visible to everyone, including adversaries like the little guy in the lower left hand part of the slide. And this is setting aside the problem that GameTrader has no way to log into the Steam platform in any case. So it's clear that we're not going to be able to use GameTrader, as I've just described it, to facilitate this swap between Alice and Bob to achieve fair exchange. We've just talked about a tool that can address these problems though, namely a tee. One way to enable GameTrader to check that the transfer has happened is for Alice to entrust her credentials not to GameTrader, but to the te.
01:04:27.270 - 01:05:41.230, Speaker A: Now, the te can log into Alice's account and check that the Game was indeed delivered to Bob, and the te can inform GameTrader that the transfer occurred successfully. Then GameTrader can release the money that Bob has paid to Alice. As we've discussed, the te can keep secrets securely, and it can establish a secure connection to a web server. So the te can preserve Alice's credentials while logging into her account, and it can also provide privacy for her account information. The privacy a te provides, just to remind you, is with respect even to the owner of the node, the hardware in which the te resides, as well as everyone else. Of course, I've already mentioned that there have been some technical problems with tes and with the most popular te, Intel SGX in particular. But the technology is still in its infancy and like other security technologies, is likely to improve to evolve over time.
01:05:41.230 - 01:06:20.344, Speaker A: That said, it is nice to have alternatives. So let me briefly mention one also developed by my academic group. This alternative is called deco. Deco stands for decentralized oracle. Deco uses cryptographic techniques that's to say mathematics to gather and prove things about information in a privacy preserving way. So to be clear, it doesn't rely on hardware like a te based system such as Town Crier. Deco can't do everything that a te based Oracle can do.
01:06:20.344 - 01:07:21.950, Speaker A: What it does allow for is a user to prove facts in a trustworthy, privacy preserving way to an Oracle system. Specifically, it allows a user who's connected to a web server on a secure channel using TLS, in particular for those of you who are familiar with it to prove facts about her communication with the server. Deco uses zero knowledge proofs for this purpose. That's a technology you'll be hearing about in this course. For example, in our previous discussion of Game trader. We could imagine Alice using deco to prove to an Oracle system and therefore to the game trader contract, that she did actually transfer the game to Bob. And she could do this in deco, as in town crier, as in a Te based system, without revealing her password or account information to anyone.
01:07:21.950 - 01:08:19.200, Speaker A: Very briefly, here's a schematic showing the differences between an Oracle based Te and deco. The Te based Oracle can communicate with the game platform on Alice's behalf and generate a proof of game transfer directly for game Trader, directly for the smart contract, that is. In contrast, deco requires that Alice log in herself. Remember, I said that deco is able to generate proofs regarding the communication, the transcript of communication between a user and a web server. The deco requires that the user, Alice here log in herself. And then it enables Alice to use cryptographic techniques to prove, in the case of game trader, that she has transferred the game to Bob. She proves this to the Oracle system.
01:08:19.200 - 01:09:13.090, Speaker A: The Oracle system then generates an Attestation, saying, yes, Alice transferred the game to Bob. So now you've seen two distinct ways in which to construct Oracles with powerful privacy preserving properties. We'll now explore some other interesting applications that use these capabilities. We've just explored how it's possible to design and use privacy preserving Oracles. Now, we're going to wind up this lecture by talking about some more sophisticated applications of such Oracles. I want to reiterate that privacy preserving Oracles aren't yet a part of the DeFi infrastructure in any meaningful way. So what I'm going to discuss here is also not about the present, but about a possible and maybe probable near future.
01:09:13.090 - 01:09:56.064, Speaker A: I'll discuss three applications. The first is the use of Oracles to tokenize digital assets, specifically those that aren't present on chain. The second is private DeFi. I'll talk about how to construct a very basic DeFi contract in a privacy preserving way. And then finally, the third application I'll discuss is decentralized identity. And I'll give an example of how it can be used. We've just talked about how privacy preserving Oracles can be used to prove that ownership of a game has changed hands.
01:09:56.064 - 01:10:52.930, Speaker A: We can carry this concept further in some interesting ways. For instance, it's possible in principle to associate Alice's game license with a token represented in a smart contract. To do this, we can have Tee essentially simulate a user and take custody of the game license, or take custody even of Alice's account, a contract which I'll just call game token. Here then issues a token representing the game license. Instance, the token can now be exchanged as a means of trading the game license in a trustworthy way. And this token would take the form of an NFT. Now, we've already mentioned NFTs, but let me remind you of what they are and say a little bit more about them.
01:10:52.930 - 01:11:27.832, Speaker A: Recall that NFT stands for non fungible token. This is in contrast to fungible tokens, the kind that are analogous to cryptocurrency. All fungible tokens of a given type are identical. They're essentially like currency. For example, Stablecoins take the form of fungible tokens. For a given Stablecoin like USDT or USDC, each token has identical value, essentially a dollar. In the case of a dollar Stablecoin.
01:11:27.832 - 01:12:28.960, Speaker A: To put it another way, you don't care which token or tokens you have, only how many. Tokens are also subdividable into fractional tokens, which function like smaller versions of a full token. And some examples of fungible tokens beyond Stablecoins include tokens for maker, uniswap tokens, and there are a whole bunch of others. Now, NFTs, as we've discussed, are unique on a per token basis. In principle, no one token looks like, or at least need look like, any other. Another feature of NFTs is that they can't be straightforwardly fractionalized. What would it mean to hold one 10th of a token corresponding to a work of art, for instance? They can be fractionalized through joint ownership arrangements, but this can take any of a number of different forms, and in general is more complicated than fractional ownership of a fungible token.
01:12:28.960 - 01:13:17.808, Speaker A: NFTs are most popular as a way to represent a kind of ownership of digital artworks or game pieces. For NFT games, which we talked about. For example, an artist named Beeple recently sold a work called Everydays for $69 million, and he sold it as an NFT. There are also efforts afoot to represent ownership of real world goods such as real estate, in the form of NFTs. In principle, any digital object whose ownership is easily transferable can be turned into an NFT. So we could imagine undertaking an effort to turn everything that can be turned into an NFT into an NFT. Exactly.
01:13:17.808 - 01:14:06.300, Speaker A: The process I described for a game license, for example, could be applied to all kinds of things. It could be applied to any of a variety of in game objects magic swords, for instance, or magic armor or whatever else you like. A Te could take custody of a magic sword and issue an NFT representing it. And of course, the same could be done for various other in game items, as well as for non game software licenses, and so on and so forth. Of course, I'm glossing over the limitations of service agreements and various other possible hiccups. I'm just describing technical possibilities. Let's proceed to the second application private DeFi.
01:14:06.300 - 01:14:46.844, Speaker A: To show what's possible here, I'd like to consider a very simple instrument called a binary option. I'll just refer to it as a binary bet with the contract named accordingly. Let's suppose that Alice and Bob want to bet on whether the price of Bitcoin will reach $1 million by 2024. Each of them bets $1 on the BTC price. Alice bets in the yes direction. What I mean is that if the price of bitcoin reaches this target, she wins and gets $2. The dollar she.
01:14:46.844 - 01:15:37.416, Speaker A: Bet, plus Bob's dollar, which he forfeits. And I'm ignoring details like gas fees. Of course, Bob bets in the no direction, which is to say that he wins $2 if the bitcoin price doesn't reach the target. The bet is resolved, of course, by having an oracle report at the very end of 2023 on what the maximum bitcoin price was. If it was at least a million dollars, Alice wins. Otherwise, Bob does. Now, what's the problem here? Well, it's clear to the whole world from inspecting the contract code exactly what Alice and Bob are betting on as a CoinDesk article declared DeFi without privacy is predatory.
01:15:37.416 - 01:16:48.416, Speaker A: What they mean by this and it's a somewhat extreme word, but what they mean by this is that existing systems have sacrificed users privacy in the name of monetary gain, and this article advocates for a reclaiming of lost privacy. We can solve this problem using essentially the same techniques we considered for the flight insurance contract. A partial solution, therefore, you'll recall, is to have the oracle simply report a bit, whose meaning Alice and Bob randomize when they invoke the binary bet contract. This is good, because now somebody observing the contract, observing the blockchain, will just see a meaningless bit sent to the contract and will have no idea what Alice and Bob bet on. But it's still not truly privacy preserving, you'll recall. Because the oracle learns what binary bet does, we can invoke a te as a stronger solution, of course. And here we see yet another useful application of privacy preserving oracles.
01:16:48.416 - 01:17:45.552, Speaker A: But in this case, they don't completely solve the problem. That's because if we construct the contract naively, it may not be clear what was bet upon by the two players, but you can easily see who got the money and who won the bet. So we need something more. We could use sophisticated techniques like zero knowledge proofs, but happily, there's a relatively simple solution here. Alice and Bob can each contribute an independently generated fresh address, one that hasn't been used yet, but to which they have access to the corresponding private key. And they contribute these in a random order, meaning that the first address could belong to either Alice or Bob. Now, all anyone sees, including the oracle, is that the money is sent to one of the prespecified addresses.
01:17:45.552 - 01:18:39.910, Speaker A: If it's sent to P zero, for instance, an observer can't say whether it was Alice who won or it was Bob who won. Either would be a valid or could be validly instantiated in that address. The final application I'd like to discuss for privacy preserving oracle systems is decentralized identity. Decentralized identity is the idea of enabling users to generate and manage their own credentials on blockchains. For example, suppose that Alice would like to generate a trustworthy credential stating that she's over 18, so she can participate in a financial opportunity like an ICO, an initial Coin offering. You can see how this might be done. Using the Oracle tools we've discussed, and you can see why privacy preservation is important.
01:18:39.910 - 01:19:44.920, Speaker A: A Te based Oracle system could log into authoritative websites that know Alice's birthday, perhaps multiple sites to hedge against errors or website failures, and can then generate a statement or attestation on a blockchain saying that it inspected Alice's birth date, and indeed, she's over 18 years of age. Alice can use this credential plus, say, a credential showing her income to qualify her as what's called an accredited investor. This is a special designation that allows for participation in certain financial opportunities in the United States. And note that Alice can do this without having to reveal her identity. So an important privacy goal is met. She can provide the credentials, provide cryptocurrency to participate in the coin offering, and receive the coins without indicating that it is Alice who purchased the coins or tokens.
