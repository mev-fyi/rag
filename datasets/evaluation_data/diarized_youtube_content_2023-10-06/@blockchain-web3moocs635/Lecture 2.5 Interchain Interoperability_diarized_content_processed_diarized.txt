00:00:01.210 - 00:00:47.206, Speaker A: Welcome back, everyone. This last segment is going to be relatively short, and we're going to talk about how to do interoperability between different blockchains. So, the state of the world today is that we really have a whole bunch of blockchains out there, and they're sort of isolated islands in some sense, right? So we have the ethereum world. We have the bitcoin world, solana, polkadot flow, and many, many others that are out there. Now, the problem is, we might have a user on polka dot who owns, say, 20 dots, and he all of a sudden hears of a wonderful exchange that happens to live on salana. So serum is an exchange, an order book based exchange on salana that's very fast and relatively cheap to use. And bob wants to use serum to possibly trade away some of his 20 dots for some other assets.
00:00:47.206 - 00:01:26.690, Speaker A: The problem is, his dots are stuck on polka dot, and serum runs on salana. So there's no way for bob to actually move his assets natively onto the salana chain, so he can actually trade those assets on solana. So what do we do? This is what's called the interchain interoperability problem. We'd like to enable bob to move his assets from polkadot to solana so then he can actually trade them on solana. So, as we said, our goal is twofold. We'd like to enable someone who owns assets on one chain to move those assets to a different chain, so then he can interact with the entire ecosystem on this other chain. These could be funds or coins or maybe even NFTs that are stored on one chain.
00:01:26.690 - 00:02:18.006, Speaker A: We'd like to be able to move them to another chain. The other goal of interoperability is what we call composability of DApps, right? So remember, these DApps are the programs running on top of a blockchain. What we'd like to enable is basically a program running on one blockchain should be able to call another program running on a different blockchain, right? And that program that DAP could call yet a third DAP that runs on a third blockchain, and so on and so forth. So, in fact, we get composability not just across DApps on a single blockchain, but we would get composability for DApps across the entire blockchain ecosystem. So that's kind of our goal. Of course, if everybody was using ethereum, this would be pretty easy because DApps and ethereum already compose quite easily with one another. But what do we do if one DAP runs on one chain and another DAP runs on another chain? So there are already some attempts at solving this.
00:02:18.006 - 00:02:56.370, Speaker A: There are a couple of cross chain protocols, like xcmp and IBC. If you're interested, you can go google those and look at how they work. What I want to tell you about is one particular technique for moving assets from one chain to another using what's called a bridge. Okay? In particular, we will look at one type of bridge called the Federated bridge, and we'll see how that works. So the example I want to give you is moving assets from the bitcoin blockchain to the Ethereum blockchain. So then you can use your bitcoin assets in the entire Ethereum DeFi ecosystem as if bitcoin was native to Ethereum them. That's our goal.
00:02:56.370 - 00:03:24.582, Speaker A: Okay? So let's see how this is done. And I'm only going to again give you the high level idea. There are a lot of details that go into building a bridge. I'm just going to give you the high level idea for how to build what's called a Federated bridge. So first we're going to introduce these validators. So these validators are staked, so they have to put up some funds that get locked up and they would get penalized slashed if they ever misbehaved. So we'll have a group of validators that are going to be responsible for the correct operation of the bridge.
00:03:24.582 - 00:03:54.566, Speaker A: Now the bridge is going to have an address on the bitcoin network so people can send funds to this address. And similarly, the bridge has a contract running on the Ethereum network as well. So the bridge itself actually implements a DAP on Ethereum. So now let's imagine we have a particular user who wants to transfer one bitcoin from the bitcoin network to the Ethereum network. What that user will do is they will send their bitcoin to the bridge address. So now they don't have the bitcoin anymore. That bitcoin is now stored in the bridge address.
00:03:54.566 - 00:04:42.946, Speaker A: Now the validators, what they'll do is they'll look at the bridge address and they'll realize, ha, there's a new bitcoin that was just added to our bridge address and it came from this particular user address. What they will do is they validate the fact that the bitcoin was actually moved into the bridge address. So now the bridge owns one more bitcoin, and then they'll instruct the Ethereum contract to go ahead and mint a new what's called a pegged bitcoin. Yeah, so they'll mint a new pegged bitcoin. Sometimes this is called a wrapped bitcoin. And they'll send this wrapped or pegs bitcoin to the user's address on the Ethereum network. So now the user basically has one wrapped bitcoin on the Ethereum network that's basically worth one bitcoin, and he can use it in any of the DeFi systems available on Ethereum.
00:04:42.946 - 00:05:19.374, Speaker A: Okay, so that's one way. That was an easy way to move a bitcoin from the bitcoin network over to the Ethereum network and use it as if it's actually a bitcoin that's native to Ethereum. Now let's talk about what happens the other way. So suppose the user is done interacting with the Ethereum DeFi ecosystem and he wants to move his pegged bitcoin back to the bitcoin network. What he will do is he will actually send his pegged bitcoin back to the contract. Okay? So now he doesn't have the pegged bitcoin anymore. It went into the Ethereum contract that implements the bridge.
00:05:19.374 - 00:05:59.150, Speaker A: And what the contract will do is actually burn this pegged bitcoin so it simply ceases to exist. All right? The validators will look at the Ethereum contract and say, AHA, this one pegged bitcoin came from the user's Ethereum address. It was actually burned. So then we're going to issue a signed transaction on our behalf. So we're all going to agree that this bitcoin really was burned and it needs to be paid back to the user. We're going to issue a signed transaction to the bitcoin network and we're going to instruct, basically bitcoin to move one bitcoin from the bridge address back to the user. So now the user got his bitcoin back.
00:05:59.150 - 00:06:30.786, Speaker A: All right, now you can see why we need a group of validators because lots of things can go wrong. If the validators misbehave, they could refuse to send money back to the user. They could just try to run away with the treasury of the bridge and so on. So basically we have a group of validators and we require sort of a majority of them, to be honest. So that's basically what maintains the correct operation of the bridge. So this is what's called a Federated bridge. Again, at a very high level, there are a lot of additional details that go into implementing a Federated bridge.
00:06:30.786 - 00:07:24.678, Speaker A: One thing that you might be wondering about is why do we need these validators? It would be pretty cool if we could just have a bridge that operates without validators, right, so just operates entirely on the blockchain so that we have what's called a trustless bridge. So in fact, in some cases this is possible. Technically, it's a little bit difficult to do with the bitcoin network because somebody has to sign a transaction to tell the bitcoin network to send the bitcoin from the bridge address to the user address. That instruction requires a secret key. And so really the secret key would have to be sort of stored on the bridge contract if the validators did not exist. Yeah, the bridge contract would have to store a signing key that would tell the bitcoin network to move a bitcoin out of the bridge address. Unfortunately, this is actually one of the big open problems in blockchain contracts.
00:07:24.678 - 00:08:23.218, Speaker A: How do we store secrets in an Ethereum contract where everybody can look at the Ethereum contract, everybody knows the state of the contract, everybody knows the code of the contract and so it's not clear. How do we hide a secret key inside of an Ethereum smart contract in a way that no one can steal that secret key and abuse it? So because this is sort of a non trivial thing to do, we typically rely on validators. And these validators basically will verify that the coin was burnt on the Ethereum side and then they'll move it out and give it to the user on the bitcoin side. Let me say that if both sides support a powerful smart contracting language. For example, one side might be ethereum and the other side might be solana. Then, in fact, it's not too difficult to build a trustless bridge without validators. And in fact, that would also be done quite easily using snarks, where using a snark, one side can prove to the other side that in fact the coin was burned and therefore the other side should release the coin from its own treasury.
00:08:23.218 - 00:09:09.946, Speaker A: I will leave it as a homework problem for you to design a trustless bridge where snark proofs are used basically to convince each side that a token was burned on one side and therefore it should be issued on the other side. This is sort of a cute exercise in seeing how to design trustless bridges. All right, so this brings us to the end of the lecture. This was just a quick overview of how federated bridges work. So during this lecture, we saw a whole bunch of stuff, right? We looked at cryptographic primitives like hash functions that allow us to commit to something on the blockchain. We post a hash of a whole bunch of data to a blockchain that commits us to that data, and then later on we can show that data to anyone and they're convinced that's the data that we actually committed to. So we looked at committing to large amounts of data using a hash function.
00:09:09.946 - 00:09:41.474, Speaker A: We looked at merkel trees for even committing to a large amount of data and then proving that a small segment of it actually is part of the commitment. We looked at digital signatures and how to use them to authorize various actions on the blockchain. We looked at scaling the blockchain using either payment channels or the roll up mechanism. Again, I really like these ideas. Very, very clever and pretty ideas. And finally, we looked at interoperability very briefly just to see how federated bridges work as well as pegged or wrapped coins. So this brings us to the end of the lecture.
00:09:41.474 - 00:09:45.300, Speaker A: I hope you enjoyed it and I look forward to seeing you in a future lecture. Goodbye, everyone.
