00:00:00.570 - 00:00:38.810, Speaker A: Welcome back. This is the decentralized finance lecture. Today we'll be speaking about decentralized exchanges. My name is Arthur and I welcome you. Financial exchanges are ubiquitous services all over the world on all different continents. We have these centralized entities that are creating financial value by bringing together all types of traders and brokers and participants. Whenever you perform a trade, whenever you want to actually exchange financial value, whether you're paying in your home currency or another currency, there's likely an exchange involved in your purchase.
00:00:38.810 - 00:01:34.870, Speaker A: So how do financial exchanges actually function? What is the architecture? What are their components? So let's break them down. So a financial exchange typically has a trade matching engine. So trade matching means that if you have two participants, two or more participants, you want them to find a matching trade, something that they agree on in terms of quantity of assets and in terms of price of assets. So once you found a few trades that are matchable, you do forward them to the trade settlement engine. And this is the place where the assets actually becomes actually get swapped. So these are the traditionally main components. So we'll be seeing later that the trade matching also contains something like a price finding mechanism.
00:01:34.870 - 00:02:05.310, Speaker A: So that's typically in the trade matching encapsulated. So let's look further here at how this particular mechanism works. So this is really the entire exchange, right? But let's assume now that we have here Alice and Bob, they have each coin on the trade settlement layer. So this is their current possession. These are the current values that they own. So Alice has a black coin and Bob has a white coin. And it seems like they want to trade this.
00:02:05.310 - 00:02:50.046, Speaker A: So Alice will put in an order. An order means she would like to execute an exchange. So she would like to exchange her black coin against a white coin. It so happens in this example that Bob does the same, but in reverse. So he has a white coin and he would like to purchase a black coin. Ideally, here we can see that the quantities are the same, right? Alice and Bob each have one coin and they would like to exchange it to another coin of another color, and the quantities in both cases equal. So the exchange rate that they are both okay with, that they both agree to, would be one black coin for one white coin.
00:02:50.046 - 00:03:32.110, Speaker A: So one to one. So the price is basically one to one. Now, once these two orders are matched through the trade matching engine, they're forwarded to the trade settlement layer. So the trade settlement here will perform the swap. So you will see this. Now then, at some point whenever the trade settlement layer settles, the various trades that it's aggregating, the actual assets become swapped in the accounts of the respective traders. So this was the trade matching, right? This was the entire exchange engine basically in full operation.
00:03:32.110 - 00:04:25.838, Speaker A: Let's go into bit more details on the trade matching. So the trade matching functions for example through an order book. So an order book is a very traditional way of aggregating orders. So what you can see here is basically that you have on the left side you have for example, Alice and she's like putting in an order and you can see here that this is quite a significant order, right? And you can also see here that this is on the visual chart of the order book. This is quite a significant amount. So the price that she's willing to here purchase in this case, this asset is at a price of 418 $0.40. So in the 418 dollarsforteen cents.
00:04:25.838 - 00:05:25.902, Speaker A: So in the other case we have here Bob, who is willing to sell a few of these coins, it's a bit less, it's only a quantity of 9.5 but he's willing to sell it at a price of 418.41. So these two orders are currently not matching, so they cannot execute because there's no agreement between the bids and the asks or between the selling and the buying order of what should be the price at which we actually perform a trade. And this is also something that you can basically call the spread. So the difference here between the bids and the ask is referred to as the financial spread in an order book, a term that you will also often encounter is the lob or limit order book. The limit here comes from the fact that the seller or the buyer specifies a limit. So price X at which the buyer or seller is willing to purchase or sell an asset.
00:05:25.902 - 00:06:48.122, Speaker A: And that's the kind of the upper bound, the limit that the buyer or seller is willing to agree to. Now, if you look a bit deeper into this order book so you can see here the quantities on the sell side here are rather small compared to at least the prices close to the spread. So if you consider basically for example this here in isolation, you could sum up the price and you can sum up the quantities and this will give you a certain sum, a certain amount of value that you can extract or that you're able to trade on this particular market, the more deep the order book is. So by depth we are understanding the quantity here times the price, right? This is basically accumulative quantity. Times the price is referred to as an order book debt. The deeper an order book is, the better because the more liquid a market is, meaning the more money this market can provide to you as a trader. So typically we're looking for rather liquid markets because these are efficient and you pay less fees.
00:06:48.122 - 00:07:57.890, Speaker A: So just for you to understand these terms that are being used interchangeably also in the traditional finance world. So what are the two order book models? In a blockchain that we can think of, there might be further ones. But let's just discuss here two basic components. So you have the server order book and you have an onchain order book model. So what are the advantages? So on the server side, if you just operate an order book, on the server side, you have a fast matching, which is great because speed matters. In financial trading, there are no fees for canceled orders, which is great because you can just put in orders, you can cancel them at any point in time and you're not incurring any fees. Now, the drawback, however, is that there's no clear censorship resilience if you have an order book on the server and you can also not prevent the exchange from actually front running your orders, right? So if you put in an order and the server then decides to front run you to put an order in front of your order, then well, first of all, you don't see it, it's not transparent.
00:07:57.890 - 00:08:56.950, Speaker A: And second, the adversary might financially profit from your order, which is executed at a later stage. So here it's always important. We're discussing or thinking about what is the threat model, right? What is the adversarial model, what can the adversary do? Always ask yourself, if you look at a solution, what can possibly go wrong? Right? This is like always something that you should ask yourself. So then we have the onchain model. So in the on chain model, we have quite a few interesting characteristics. So first of all, we have a censorship resilience, right? So this is at least if the smart contract is written in a way that nobody else can censor the protocol, there are no admin keys and so on, then there's a relatively strong censorship resilience because the blockchain is running possibly much more reliably than a server. It's relatively robust.
00:08:56.950 - 00:10:13.386, Speaker A: Obviously you will have some higher fees in exchange for that. So there are few drawbacks which presumably slow matching, right? So the faster or the slower the confirmation latency of your blockchain is, the slower the entire system works. And naturally, for on chain transactions, you must pay a fee to the miners, even if you just want to cancel your order, right? So you can create an order, you can cancel it, you will pay twice the transaction fee. So that's quite significant depending on how active your blockchain is and how low the fees are. So you're also not immune from front running. So again, right, I mean, we are looking at the adversary model here and we can see, well, another minor, basically a blockchain miner or a blockchain trader or both of them, they could collude even to front run your trades. And this is happening, this is wide practice on existing blockchains already and it's a major issue which is extracting hundreds of millions of US dollars per year from innocent users.
00:10:13.386 - 00:11:24.390, Speaker A: So this is certainly something that you should be aware of and that can happen. So I would like to draw your attention to Ether Delta, which was one of the pioneers in this space. So I think this was one of the first, maybe the first, but let's say one of the first decentralized exchanges with an onchain model. There was still a server that kind of helped the exchange to coordinate trades. But in order to participate in this exchange, the first thing you had to do is here to deposit some amount at the very beginning, right? So you couldn't basically start trading right away from your wallet as you may be used from uniswap or similar AMMS that we will discuss much later. But basically here you're really required to deposit some coins into a contract at the very beginning and you can later trade and then finally you can withdraw these coins again. So this is initial step of depositing assets into a contract and only once they're deposited you can create a buy or sell order.
00:11:24.390 - 00:12:26.540, Speaker A: So here you specify the amount, you specify the price and it will calculate you the total costs that this particular order will create. Similarly, here you have the visualization of the order book as we discussed in a previous example. It's a slightly different visual representation, but in essence it explains the same. So in the middle you have the price, here we have the spread, right? So the spreads between this price and this price represents the spread of this particular limit order book and the quantities are denoted here in this PPT coin for this particular market. In addition, there's some candle bar chart here that you can see and the price to Ether. So it's just an example. What's also interesting is you get here the last executor trades that are helpful obviously to look into.
00:12:26.540 - 00:13:34.340, Speaker A: So overall, I mean, Ether Delta was quite a successful exchange. It was one of the most actively used DEXes, but still it didn't get to the same popularity I would say, as for example, binance or centralized exchanges in general. So what are the lessons learned? So what are the advantages of limit order book decks and what are its disadvantages? So the good, bad and ugly things. So well, some of the advantages certainly was at the time there was no KYC AML requirement when these exchanges existed in the very early stages because these were really new technologies and no regulators had any clear vision of how they should be regulated. To my understanding there were fees pages to exchange. So the market makers who are actually filling the order book, so market makers are putting in orders and taking out orders to serve the market. That's called market making.
00:13:34.340 - 00:14:37.106, Speaker A: They are gaining from the fees from the exchange, but there were no fees paid directly to the exchange. An advantage of a limit order book is that there's at least no direct impermanent loss if you just put in an order with a certain limit because you're not a liquidity provider you're not a market maker, so you're just trying to execute a particular trade and impermanent loss in AMMS will be discussed later in this lecture. So the disadvantages of this model are the following. So certainly we have fees, like an excessive amount of fees for every deposit, withdrawal, trade creation and cancellation. And this is unfortunately affecting a blockchain quite significantly. In particular if blockchain doesn't have a strong transaction throughput. Right? So that's certainly a problem and something that needs to be addressed somehow.
00:14:37.106 - 00:15:08.000, Speaker A: The slow execution is not great either. It reduces competitiveness of these exchanges. So arbitrage will be slower, like if you want to synchronize the price with different other exchanges. And centralized exchanges are just much faster than such a limit order book. Dex. Although they're called dex, they may still not be fully decentralized. So this is something I would recommend you to be a bit careful about.
00:15:08.000 - 00:16:01.626, Speaker A: If a project, or like in general a protocol, claims to be decentralized, then there might be different definitions of what is decentralized or what particular components are decentralized. So please always be a critical mind of asking the right questions about what is decentralized and what does that actually mean. Very good. So we went over the trade matching in more details and now let's go into the noncustodial trade settlement layer. So noncustodial means to repeat, it just means that you are in control of your assets. So you are the one that actually controls whatever is happening with your coins and nobody else is supposed to be able to take away your funds. So why do we need dex? So imagine you have, for example, Alice.
00:16:01.626 - 00:17:09.286, Speaker A: She's rich, so she wants to provide her money for other traders and in that process she would like to earn some fees, but she doesn't want to trust anyone. So she doesn't want to give control about her money to anyone as she has some trust concerns, which is very reasonable in this particular case. On the other side we have Bob, which is an intelligent trader and he would like to buy the latest coins and he struggles to find a trusted source to buy mean once he provides some funds, he wants to make sure that the funds are actually being exchanged against something that he wanted to purchase. So DEXs or decentralized exchanges really the underlying idea is that you have a price discovery and a trade matching engine. So this is the trade matching part that we discussed earlier and a trade clearing, all defined in a smart contract. So this is the underlying architecture, as I mentioned earlier. So here we are.
00:17:09.286 - 00:18:09.554, Speaker A: Now a bit more specific how this works on a blockchain based decentralized exchange. So naturally the price discovery and the trade matching can happen in a limit order book. But as we will see in the following sections, there are also so called automated market makers which basically operate in this way and they have a few advantages in terms of transaction creation costs, transaction canceling costs, et cetera. So just to give you a bit of an intuition of how important DEXes actually are. So this part here is the part of 2021, and you can see that the monthly Dex volume grew significantly, which is a great indicator. So if you compare the daily volume of the Dex, we are here at about 3.5 billion US dollar, whereas the Nasdaq is still at about $244,000,000,000.
00:18:09.554 - 00:18:50.882, Speaker A: So clearly, DEXes are still lagging behind centralized traditional stock exchanges such as the Nasdaq. But they're getting there. They are not negligible any longer, which is really promising. And another amazing sign, I feel, is that a lot of centralized exchanges, especially in the crypto space, were prone to wash trading. So wash trading is the process whereby you create fake volume on an exchange in order to artificially increase the trade volume. So on a Dex, you need to pay transaction fees. So the process of wash trading is much more expensive.
00:18:50.882 - 00:19:23.460, Speaker A: And therefore, I believe that the numbers that we are seeing here for the daily volume on DEXes is likely more accurate than the accuracy of numbers reported by centralized exchanges. So I invite you to perform some research on finding wash trading on chain. There are some papers already out there, but things can always be improved. All right, thank you very much for listening to this first part of a lecture. I hope you liked it and looking forward to see you in the next part.
00:19:25.430 - 00:19:26.580, Speaker B: Welcome back.
00:19:27.030 - 00:19:38.226, Speaker A: Now, we'll be discussing automated market maker, or short AMMS. These are the most popular form of decentralized exchanges on DeFi.
00:19:38.338 - 00:19:40.470, Speaker B: And they've really helped DeFi to grow.
00:19:40.540 - 00:20:31.366, Speaker A: Significantly in size due to their ideal design for the low throughput blockchains as well as for the higher throughput blockchains. In order to understand what an AMM is and what it does, we would like to introduce basically the concept of a liquidity pool. So the idea is really to let a smart contract do the so called market making. So market making or Mm here, this is the process of serving the markets. Maybe you remember from the last lecture in the order book model, you have these different orders on the bit and the ask side, and they have to somehow match right in the middle. There must be a match. So the more orders there are in the market and the bigger or the deeper the liquidity is in this market, the better for the overall efficiency, financial efficiency of this market.
00:20:31.366 - 00:21:16.920, Speaker A: Now, instead of having actors, external actors, putting in orders, like manually, why don't we have a smart contract that does everything? And this is exactly what's the basis of an AMM. So you have here the rich and wealthy actor Alice She's, adding liquidity X and Y into this smart contract pool. And then you have Bob the Nifty trader. He wants to exchange X for Y. And because he likes this very service that he's using. He's also paying a fee to Alice to make Alice happy and Alice earns an interest on her assets in that regard. So that's the very basic idea.
00:21:16.920 - 00:22:26.682, Speaker A: Now, how can we perform such a market making or such a liquidity provision through a mathematical formula that we can program into a smart contract? Well, the most common way of doing this is the so called constant product formula, which is here the following. So we have an asset X and a certain quantity of this asset, and we have an asset Y and a certain quantity of this very asset. So the product of these two assets must remain constant according to a constant as long as there is no additional quantity of asset X and Y. That's added, if we do add whether I mean either X or Y to this pool, to this liquidity pool, then obviously the constant will change. But as long as we simply trade. So we trade X four Y or asset Y four asset X, the constant K should remain constant. So the inherent properties of an AMM is that we have instant liquidity, meaning we can exchange at any point in time.
00:22:26.682 - 00:23:37.966, Speaker A: So we don't have to wait until there's another order coming in, as you may remember from the limit order book, where we might need another order from another entity in order to fulfill our request of an exchange. So we have instant liquidity, irrespective of the trade size, however, with the disadvantage that there's a certain slippage, meaning there's a price change while we're executing the trade and we'll be looking at the bonding curve in the next slide. So naturally and intuitively, so if you purchase an asset X, this will increase the price of this asset X as well. And because there are two assets in this very market and K is constant, the price of the asset Y has to decrease. What's very intuitive and simple here is that the ratio of the quantity of asset X and Y define the price in this very market. So you remember the architecture of an exchange. We have a price finding mechanism, right? This is the very price finding mechanism while also doing market making, while also doing trade matching.
00:23:37.966 - 00:24:28.018, Speaker A: So everything is really condensed in this very simple formula. Some people you might be aware of refer to this as a constant product AMM. And they're also more sophisticated formulas where you can have multiple assets, more than two assets in the market. You can have different parameters to kind of configure the automated market maker curve. So I've been speaking about this curve or this bonding curve for a while now. And let's look into it, how this actually works. Now, here on the X axis, we have an amount of X assets in the pool, right? So on this part of the chart and on the Y axis, we have an amount Y of asset Y in the pool, the current state.
00:24:28.018 - 00:25:48.220, Speaker A: So this is the AMM state that we're having before a trade execution, is that we have quantity of ten of the asset X, a quantity of 30 of the asset Y. So ten times 30 is 300. So the constant in this very state is 300. Now, what do you think will happen if we want to remove here if the trader wants to get minus ten assets? So the trader wants to retrieve ten coins from the market, right? How many assets does he need to provide here to the market in order to satisfy the constant product formula? So we have a constant 300. We know that we want to remove ten assets out of the pool, so we'll be ending up at 20 here. How many do we have to add? So how many coins we need to provide to the pool in order to get, in return, ten coins of Y? So I'll let you ponder about it. You can pause the video and think about it for a while and then we can continue together on it.
00:25:48.220 - 00:27:10.790, Speaker A: So the answer here is five. So here, if you want to get minus ten out of the pool, you have to add plus five here on the X asset to the X asset of the pool, such that the state after the execution of the trade, right after the trade, we have a state of 1520 and we still have the same constant. So this is how a bonding curve functions and this is how you can create, how you can basically specify how many funds you would like to purchase or sell given a certain state of the market. Very good. So now we have seen that the price is actually changing while you move on this bonding curve, right? So the initial price here at the very top is different from here, is different from here, et cetera. So the price basically only gets worse the bigger the liquidity of your trade is. And obviously this is a continuous spectrum, so it's not discrete, as I just explained, but it's a rather continuous spectrum at which you get every coin of Y that you get has a slightly different price of a coin, X, as long as you move along this curve.
00:27:10.790 - 00:28:29.626, Speaker A: And the expected slippage is basically defined as the increase or decrease in price based on a trading volume and available liquidity. So the more liquidity this pool has, so the more money this pool actually holds and the smaller the trade is that you want to execute on this pool, the smaller the expected slippage becomes. And this is called expected because that's something that you can calculate, right? Based on the pool state, as we just have done in the previous slide, based on the pool state, you can estimate how much slippage you will get, right? You can basically calculate the decrease in price. So contrary to the expected slippage, we also have an unexpected slippage. And this mostly involves other transactions. So if your transaction is TC, if there's another transaction TD that executes before your transaction, then you might have thought that you would execute on this very point in the curve. But your real execution happens only at the second point because there's another transaction that was executed before yours.
00:28:29.626 - 00:29:20.350, Speaker A: And this could mean that you will receive a much worse price than you anticipated. So in this particular example, you get a worse execution price. On the other hand, you can be lucky, so you can have an unexpected slippage that will provide you a better execution price. So if, for example, just you were thinking to execute here, but in the end there was another transaction before you and you start executing here, you might actually get a better price. So this really depends on the asynchronous nature of the blockchain networks that you're operating on. So you can't really tell whether you will be exactly executing at a given blockchain state. So certainly this results in quite some interesting attack vectors that we will be speaking in the security lecture further.
00:29:20.350 - 00:30:24.494, Speaker A: So what about slippage protections? How can you protect yourself? I mean, you don't want to be pushed along this curve indefinitely by a third adversary, right? So you want to protect yourself to some degree, and that's where the slippage protection comes into play. So it's basically a threshold that you can specify, for example, on the uniswap UI or Sushi swap UI, you can specify, I'm willing to pay at most 1% slippage. And then you know that in the worst case, the price that you get is 1% worse than what you thought you would get. So and this is certainly very helpful to set an unacceptable slippage rate. And if in this very case somebody will execute in front of you, which might happen here in this particular image, then your transaction will hit here the slippage limit, and then it will basically not execute. So it will fail. You'll still be liable to pay transaction fees to the miners to try to execute this transaction of yours.
00:30:24.494 - 00:31:34.220, Speaker A: However, you will not lose any additional funds due to an excessive slippage that you were not ready to basically pay here in this particular case, good. So what are the good, bad, and evil things of AMMS? Let's look at the list. So the great thing is there's no order book maintenance, right? So we don't have to add new orders, cancel orders. Every trade that's happening is actually a trade because people would like to perform a particular trade, or it's a trade that's necessary because there's another exchange that has a higher, lower price and then there's arbitrage between those two states. Now, another advantage is that it is relatively simple to implement constant product imms. So the execution of a single trade is relatively low, so the gas costs are rather small. The danger of an AMM is the danger of an impermanent loss that we'll be discussing later.
00:31:34.220 - 00:32:35.482, Speaker A: So there might be actually the possibility of a total loss of funds, which is possible if, for example, one of the two coins grows significantly in value in relationship to the other, and a so called coin DPEG is relevant for stable coins. So if you have coins that trade one to one and then suddenly one of them Dpegs, then Arbitragers will take out the healthy coin and you as a liquidity provider, you'll be left with a worthless coin. So I might want to add, so this here, this only affects liquidity provider. So Alice, in our example, who is actually providing liquidity, this does not affect immediately here. Liquidity takers such as Bob, who is just a trader in an AMM. So this is not something that you need to worry as long as you're not providing liquidity to an AMM. So another disadvantage of AMMS is the high slippage for low liquidity markets.
00:32:35.482 - 00:33:10.380, Speaker A: I believe in general, it's quite hard to not have high slippage for low liquidity markets. They're always quite challenging to maneuver. But always, if you trade on these exchanges, please do observe your slippage tolerance, set your percentage to whatever 0.1% or whatever you're comfortable with and calculate your expected loss. Okay. Users are vulnerable as well to sandwich attacks. That's certainly an issue.
00:33:10.380 - 00:33:50.514, Speaker A: We will discuss this more in the security lecture. The underlying idea is if you do have a trade here that goes along this bonding curve, you have an adversarial trade, ta one and ta two, that will try to squeeze you. So this is you, the victim TV. So you kind of have like a sandwich here that will squeeze you into extracting all the slippage that you've got. So thank you for listening. I hope you liked this lecture on AMMS. These are certainly very exciting products on DeFi.
00:33:50.514 - 00:34:20.558, Speaker A: Go ahead, try them yourself on chain with small amounts. First try to play with the slippage and see what it means. See what you get out of it, see what you don't get out of it, and remain curious. Welcome back. In this lecture, we'll be discussing what affects the transaction propagation. So, as you may know, a blockchain is, or permissionless blockchains are typically built out of permissionless peer to peer networks. So any peer can join and leave at any point in time.
00:34:20.558 - 00:35:02.554, Speaker A: And we'll be discussing now how this impacts financial transactions in DeFi. So you can think of a peer to peer network here as really a global peer to peer network among many peers. And naturally, some of those peers are miners. So you can see here we have this world map with a set of miners here distributed across the globe. And we can think of this peer here having, for example, connections to other peers that are non miners. And so once you create a transaction, it actually propagates in this permissionless network, there's a relatively high amount of churn. That's being recorded in these networks.
00:35:02.554 - 00:35:28.630, Speaker A: Churn is a technical term for nodes leaving and joining the network at any point in time. Because it's permissionless. There's no guarantee that a node that's been there 5 seconds ago is still there in the next minute. So as such, this is really a best effort protocol. There's no guarantee. So that's what's called an asynchronous network. So there's no guarantee of a transmission delay.
00:35:28.630 - 00:36:15.866, Speaker A: So, contrary to a synchronous network, we don't know when, like a peer, for example, here in Australia will receive a transaction that's being issued by a node in North America. Now, you can see here that this peer in North America is setting a transaction fee of unit five. So we just keep this as a generic unit. We're not specifying what value that is. Let's just assume this is an absolute value. So this transaction fee here specifies how much this peer is willing to spend on this particular transaction and the revenue. So the transaction fee is being basically taken by miners once they include this transaction in the block.
00:36:15.866 - 00:37:34.170, Speaker A: So naturally, the higher the transaction fee that you pay, the higher your priority of your transaction is of being included in the blockchain by a particular miner. It's basically a form of bribing or a priority bidding, if you would. So if this peer here is now propagating its transaction, eventually it might arrive at a minor node and the miner will then choose to order the transactions that it's mining in its blocks, depending on the fee that's being paid. So, for example, if the miner already knows about two transactions here that both pay each ten and one unit of transaction fees, then this transaction with five fees will be likely put into the middle. So it will be squeezed here in between those two transactions. And if the block has enough space to accommodate three transactions, then a final block of a minor might look as follows. So here you can see that if the execution order in this block, let's assume the execution order is in this direction, then the transaction with the highest fee.
00:37:34.170 - 00:38:17.466, Speaker A: So the ten transaction fee transaction will be executed first. Afterwards there will be the next transaction with five. And finally the cheapest transaction with respect to its fees, which only pays one transaction fee. Now, what's important to note is that this execution is sequential. So it's really being performed in this order. So you can imagine that you have like a previous block here and there are a few transactions in there. And by the end of the execution, let's say here is the end of the execution, we will get a blockchain state one.
00:38:17.466 - 00:39:19.710, Speaker A: Let's assume this is a blockchain state by state. What I mean is that we have a variety of different peers. We have a variety of different contracts, smart contracts. They're specifying, for example, the balance of a user or the size of a pool, right? I mean, you remember we have these AMM pools with x and y. So x and y here the quantity of x and Y, for example, is a state. So basically at this point in time there's a particular state that's being calculated and everybody agrees because that is the current head of the chain. Now if you want to execute a transaction on top of this very state then you have to make sure that in occurrence you're at the very front of the next block which implies that you have to pay the highest gas fee or the highest transaction fee than everybody else.
00:39:19.710 - 00:40:28.482, Speaker A: So I just mentioned gas fee because for example in EVM based blockchain the transaction fee is referred to as gas as well. So this is basically the idea. If you want to execute on the latest blockchain state you must front run, so called front run everybody else by putting your transactions here at the very front of this block. If you do not care about a particular position in the block but you still want to make sure that you include it in the block, then you should pay a transaction fee that's at least as high as the likely smallest includable transaction. Because keep in mind you have here limited space in the block, right? In this particular example we have only space for three transactions. So in bitcoin the space is measured in actually bytes or kilobytes whereas in Ethereum for example, the space is measured in gas due to the Turing completeness or pseudo Turing completeness of the smart contracts. So there are different ways of measuring how many transactions or how much computation can fit into a block.
00:40:28.482 - 00:41:54.366, Speaker A: And if you are keen that your transaction is executed swiftly but not necessarily on a specific block state or previous block state, you may want to adapt your strategy of setting your transaction fee. And because all this here is kind of transparent you should always be aware, right? If there's here like an evil adversary he may be able to observe what you're propagating in the network. He may even have a faster connection to the miners, right, this adversary. But we will be discussing this further in the security lecture. So summarizing the exchange transaction propagation or in general blockchain transaction propagations occur on an asynchronous blockchain peer to peer network there is a best effort propagation so you don't get any guarantees of in what time delay a transaction is received by a particular peer. You have quite a significant amount of transparency as the transactions are publicly visible. You can also try to infer through side channels whether a transaction is originating from a particular peer or particular IP address by having significant number of connections in the peer to peer network.
00:41:54.366 - 00:43:21.050, Speaker A: So privacy is, I would say, a major concern and due to the peer to peer nature a node with a higher connection number or basically more connections in the network will always have an advantage to peers that are less well connected. So the number of TCP connections in the network matter, as well as the up and download bandwidth as well as the latency of your internet connection. I'm aware of various efforts to build dedicated high frequency blockchain clients that depart from the traditional and official, I would say software client software. So you can imagine how various DeFi actors want to optimize their connectivity in order to increase their information asymmetry advantages. Regarding the inclusion of transactions, we mostly are based on an inclusion on a fee auction model and there are two prevalent design mechanisms, which is first, the price gas auction. So this is what I just mentioned on the public peer to peer network here, this one. And there's also the sealed bit gas auction.
00:43:21.050 - 00:44:09.610, Speaker A: So this is, for example, a miner. Let's say this is a miner, he is connected to a centralized server. So let's say this is a centralized server and then you have a trader. So the trader is sending a transaction here to the particular centralized server or relayer. And multiple traders actually do this, they send their transactions and then there's a sealed bid auction. So sealed in a sense it's not public, right? It's a private auction and only the winning bit is then forwarded to the miner, for instance. So this is another method of performing transaction propagation, which we discuss more in the security lecture.
00:44:09.610 - 00:44:38.310, Speaker A: Thank you very much for your attention. I hope you enjoyed truly this lecture about blockchain peer to peer networks in DeFi and I think it should have given you a really glimpse of why the underlying communication network is so important to any financial applications on top of consensus layers and application layers, like smart contract layers. So if you are building your own high frequency trading bot, make sure to optimize your network layer.
00:44:38.650 - 00:44:39.670, Speaker B: Welcome back.
00:44:39.820 - 00:45:25.934, Speaker A: In this lecture we'll be discussing pact and stablecoin AMMS. If you remember from the previous lecture, we discussed general purpose AMMS x times y equals k. But this formula isn't really that optimal for some of those coins that might be correlated in prices. So let's dive deep into this. So a packed stablecoin, and you may want to refer to the stablecoin lecture for much further details, is basically, for example, a coin that is based on the US dollar, right? So we have USDT, USDT or Dai, but they're also packed coins. So basically just representations or derivatives of existing assets. So wrap bitcoin is an example rembtc seether st ether.
00:45:25.934 - 00:46:18.534, Speaker A: So these are really packed coins to their base coin and they're just a representation or derivative that you can transfer in any different way. For example, what's quite interesting is any synth can be exchanged to another synth without any slippage. That's because the synths are all based on some based on the synth collateral. So since they have the same underlying collateral, a swap is basically just a change in the name and there's not actually even a proper exchange needed. So this is a really interesting property of the synthetic protocol. Similarly or differently, wrap bitcoin is a so called reserve based stablecoin. So this is one of the first types of stablecoins that we could classify here.
00:46:18.534 - 00:47:31.674, Speaker A: So you have a company or an entity that operates a reserve and that holds a certain amount of bitcoin, for example in a vault, and it then can issue wrapped bitcoin. Another type of stablecoin is for example, a collateral based stablecoin, which would be an example would be Dai. So in Dai, for example, you collateralize let's say 100 ETH, or let's say 150 ETH. To make it simple, 150 US dollar worth of ETH and then you can mint 100 die, right? So this is 150 USD worth of ETH and then you can mint from there 100 die. So this is a particular example of a collateral based stablecoin. If the collateral itself is not if the collateral here would not be able to cover the debt in this particular case, which is Dai, then this might be prone to liquidation, which we will be discussing quite in depth in the liquidation lecture. The third type of stablecoin is an algorithmic stablecoin.
00:47:31.674 - 00:48:20.938, Speaker A: So these are really rather newer stablecoins. They are based on how, for example, they can adjust the supply of a coin ad hoc, which then adjusts the or, which should at least adjust the price. So, speaking of price, let's have a look at the following charts here. So on the x axis we have a time series. So this spans from January 2001 until about June 2021. And we have five different coins that we are looking at. So two reserve based stablecoins, USDC, USDT, one collateral based stablecoin, Dai, and two algorithmic stablecoins, Ample and ESD.
00:48:20.938 - 00:49:14.046, Speaker A: And you can see that be careful with the y axis here. The price in US dollar, the scale is quite different on the various charts here. So always keep an eye, look for the scale. And what you will see is that at least here in this particular example, for these algorithmic stablecoins, the algorithmic ones are quite more volatile and might even deepak, as the example here in ESD shows. All right, so that's enough of the basics for stablecoins in general, right? So overall their prices are expected to move together. So the exchange rate should ideally remain one to one and therefore default. Constant product AMM is not optimized for such a case.
00:49:14.046 - 00:50:27.190, Speaker A: So the constant product AMM really works rather on non correlated or non packed coins. So we would like to build a stable coin or would like to have a stable coin that's basically dedicated for AMMS. So what would be an advantage of such an AMM? Well, the clear advantage would be to have better prices for bigger volumes. So if you want to perform significant trades, you will have a better liquidity and therefore less slippage due to their potential complexity of their underlying formula. There might however be higher transaction fees associated to swaps on such stablecoin AMMS and therefore this would result in higher gas costs. There's also the danger of a DPEG of a stablecoin which actually exists for any AMM, whether it's a constant product AMM or a stablecoin AMM. That risk remains if you're a liquidity provider and you provide stable coins to stablecoin pools such as curve.
00:50:27.190 - 00:51:32.854, Speaker A: If one of those assets loses its pack then arbitragers will basically buy out the other coins out of this pool and you will be left with this worthless coin. It's kind of equivalent to a bank run in centralized finance, whereas in DeFi a DeFi bank run really shows that you get initial value back. But the later you come in the game the less you get. So it's basically a first come first serve basis if you happen to be a victim of a DPAC which is a likely significant event. So, let's look at some packed coin or stablecoin swaps and compare them to more traditional AMMS. So on the left side you have curve here, this is a stablecoin swap protocol. So it's specialized in the swapping of stable assets or packed assets.
00:51:32.854 - 00:52:11.058, Speaker A: And on the right side you have a traditional uniswap model. In this particular example it's V two. And so what you can see here is that we are exchanging here quite a significant amount of value, right. So these are here 100 million US dollar worth of die into USDC or vice versa. And the exchange rate is the one that you can see here. This is the exchange rate that you would be getting and you can specify your max slippage here. Always look at this parameter.
00:52:11.058 - 00:53:01.970, Speaker A: It's really important to be careful about this. So the exchange rate is rather good, right there's not an overly excessive slippage here on the curve side. And this although we are trading like 100 million US dollar which is not an insignificant amount. Now, if you do the same on the right side. So again here we're trading 100 million die into USDC. So it's the same coin on the other side we will end up with only 22.7 million US dollar that means we'll have a slippage of -77% so that's certainly not a trade that you would like to do unless you feel generous and you want to provide quite some funds to the liquidity providers of this pool.
00:53:01.970 - 00:53:51.746, Speaker A: So this is certainly not a great exchange rate that you want to take. And this is one of the motivations why we really need packed coins, I mean stablecoin swap protocols and formulas. So, let's look into one example of how such a formula looks like. So this here is the example of the stable swap also known as curve finance curve. So on the x axis here again we have an asset x and on the y axis we have an asset Y we can have initial distribution of this pool or value in the pool. And based on this value, we can then plot the curve. For example, this x times Y equals constant, right? This is the uniswap variant.
00:53:51.746 - 00:55:25.990, Speaker A: It's the one that we've seen earlier in the lecture already. Now, what's critical is we compare this uniswap invariant first to actually the constant price. So here you can see this line here would be a constant price, right? So if we're exchanging one to one, right, then we'd basically be walking along this very line here. Now, this would be optimal, right? But a middle approach would be to, I mean, this line actually we cannot take it because otherwise this would be detrimental for the liquidity providers, right? So we need some kind of a compromise where we can have like, for some area, maybe this area, roughly this area, right. For some area under the curve, it's almost like a linear relationship between the prices. But as we perform more and more extreme trades here, the slippage here and here grows, right? So depending on the liquidity of the pool, we can't obviously remove too many assets out of this pool. So the pool kind of wants to be equilibrated, so the pool wants to also incentivize people to equilibrate the pool.
00:55:25.990 - 00:56:43.710, Speaker A: So this is basically the underlying idea on how to build a stablecoin AMM, right? You try to fit a curve that's somehow not too computationally expensive to execute. And curve at the moment at least, is relatively more expensive than uniswap, but which has these properties of being more stable around a certain threshold of liquidity, which heavily depends on the overall liquidity in the market. So how is the slippage looking like? So I think this is basically the same figure just plotted in a bit a different way. You're on the Y axis here with the price of the asset, and here we have the difference. And you can basically see that the slippage remains rather small for a long time, but it starts to be really big afterwards. Right? And this is basically where you want to be careful. If you trade like significant amounts on stablecoin pools, you want to not cross a particular line where the slippage then starts to increase significantly.
00:56:43.710 - 00:57:24.698, Speaker A: However, you can really see that you have quite some advantage here. In this area, you're suffering from much less slippage or in a dedicated stable coin or packed coin AMM than uniswap. So finally, I would like to draw your attention to the respective white papers of curve and uniswap. These are, I believe, really interesting further works that you can research. So please check out these white papers. Be careful. I mean, take a note that these are not peer reviewed academic works.
00:57:24.698 - 00:58:02.870, Speaker A: So be aware of possible missing items, nuances, missing assumptions, trust assumptions, et cetera. And we have seen that these projects, they do not always disclose the full details or the full drawbacks of their respective solutions. So a critical mindset is always welcome. Thank you very much for your attention. I hope you truly enjoyed this lecture about AMM swaps for stablecoins and packed assets. They really lie at the heart of DeFi exchanging hundreds of millions of US dollars every day. So please make sure to check them out in practice.
00:58:02.870 - 00:58:43.038, Speaker A: Welcome back. Next lecture is on am arbitrage. Arbitrage is the practice by which different prices on various exchanges, various markets, become synchronized. And we'll dive into the details how this is actually possible on various AMMS. So if you look at arbitrage, you have an example here of different markets. These markets are all selling or I mean, they all offer you the possibility to sell or buy a specific asset. For example, here, bitcoin and the US dollar.
00:58:43.038 - 00:59:27.714, Speaker A: And we have in total one, two, three different markets. So the price of Bitcoin to a US dollar might be, for example, one to one here. It might be two to one here. It might be three to one here. So naturally, if you see those prices, what you intuitively would like to do is to, for example, you can purchase a bitcoin on this market because it only costs $1. And then you can go to this market and you can sell it because $1 gives you three bitcoin. So this is basically a very easy example of an arbitrage here.
00:59:27.714 - 01:00:47.210, Speaker A: In this particular instance, we have three markets. So you might be able to do like a cyclic arbitrage. So basically here form a cycle among these exchanges and calculate the optimal distribution of how many coins you should buy where. And this naturally depends also on the liquidity that you find at each of these exchanges. So the deeper the liquidity, the more you can swap, the more you can exchange. If you have very little liquidity, for example, on this market here, then this discrepancy in price or the arbitrage opportunity might not be as big as you would like it to be. So this is quite an interesting problem where basically every exchange that somehow is exchanging the similar or an overlapping asset with another market will need to deal with, in particular AMMS, where we don't have the order book, right? If you remember, we don't have this order, this order book of bits and asks that meet at some middle price because these orders here are being removed and added ad hoc by market makers.
01:00:47.210 - 01:02:00.734, Speaker A: There's less arbitrage necessary. However, in an AMM, there's no such thing as an order book. So we only have a liquidity pool, as you remember, with asset X and Y. So arbitrage is essential to keep the price because the ratio of asset X of the quantity of asset X over the quantity of asset Y defines the price of this market, right? So this is basically the price that's defined over these assets. And therefore arbitrage is one of the reasons why most of the trading volume, likely most of the trading volume on AMMS nowadays is arbitrage, just the effect of synchronizing prices among various exchanges. So, as I just mentioned, if we have multiple markets with the same asset, x and Y, or different markets with various assets, and they can form like a cycle, and we have different prices for X and Y, then there's an arbitrage opportunity. So prices are synchronized by so called arbitragers.
01:02:00.734 - 01:03:22.362, Speaker A: These are the actors that create transactions to benefit from an arbitrage opportunity. And they do this because they incentivize to do so because they basically profit from the price difference among these markets, right? Among these, for example, three markets here, and similar to the difference in a limit order book between bits and ask, this is referred to as a spread. So the arbitragers can benefit from the spread. So naturally, this requires to perform at least one transaction, right? You could think that you only want to perform an arbitrage transaction on this market, but this is under the assumption that you already own some of the coins x and Y, and maybe you want to replenish your portfolio. But typically an arbitrage is done by having like, one transaction that either purchases an asset on one market and sells a market on another. So in these two actions, these are swap actions, they can be all done in a single transaction, ideally. So in particular, in blockchain based exchanges, what you do is you do the three or N swap transactions.
01:03:22.362 - 01:04:33.490, Speaker A: You do them within one transaction. So in this case here, we have three transactions. So swap one, swap two, swap three. And if these are all executing Atomically, then you're guaranteed that you get a certain price at the certain execution price, right? Because if you modify the price on this market, then on this market, then on the third market, you're guaranteed that intermittently. So between your actions, between your swap actions, there won't be any state change. So you're not certain about the initial state that your transaction will execute on, but you're certain that once the action number one is executed, action number two and three can execute immediately based on action number one. So Atomicity or the Atomicity of blockchain transactions, here again, is a very important property, allowing arbitragers to profit in a reasonable manner while being able to, let's say, calculate or estimate the expected revenue.
01:04:33.490 - 01:05:20.094, Speaker A: So let's dive into a specific example. So here we have an arbitrage on two markets. So the two markets are the curve Y pool and the curve SUSD pool. So these pools, they host both the same assets. They might host several further assets, but these are not important for this particular detail, for this particular example here. So most importantly, they host USDC and die, right? So we can do on both exchanges, we can both sell and purchase USDC and die. Now, the first action of the arbitrage transaction.
01:05:20.094 - 01:05:49.580, Speaker A: So there are two actions in this one arbitrage transaction that the arbitrage is performing is that he's exchanging 2.48 million USDC for 2.28 million die. Okay? So it's a stable coin swap. So the exchange rate between those two coins is nearly one, but it's not one. And here we're speaking about relatively significant volumes on the order of millions of US. Dollars.
01:05:49.580 - 01:06:20.102, Speaker A: So the price here is 1.1 USDC per die. And interestingly, the price of USDC over die is higher. It's higher by 0.8 USDC over die when compared to the other market, when compared to the curve y pool market. So, and this discrepancy here, this eight discrepancy, creates an arbitrage opportunity. And that's what the arbitrage is basically aiming for.
01:06:20.102 - 01:07:11.590, Speaker A: So he started his arbitrage with USDC, he exchanged it for die. Now he has die, and he's exchanging it back to USDC on this other market. So what he end up, he ends up with is 2.64 million USDC, which is higher than his initial capital. So the overall profit that he gains from this particular arbitrage is a bit more than 16,000 USDC, equivalent to about $16,000. That's a very basic example of an arbitrage and with only two markets, and naturally, you can extend this to N markets. The more markets you're arbitraging out, the higher the gas fees of these transactions naturally become.
01:07:11.590 - 01:08:19.126, Speaker A: So there's a certain upper limit based on the blockchain that you're operating on. So now you might ask, where does this arbitrage actually find? Or how does this arbitrage, how come this arbitrage has access to 2 million USDC? It's a non negligible amount of capital deployed in a particular stable coin. And this is where so called flash loans come into play that we'll be discussing in another lecture in more details. But basically, what a flash loan allows you is that you have a pool of liquidity here that is given by a flash loan provider. And you can borrow two point something million USDC from this pool. Then you can perform the two arbitrage exchange transactions that actions that we have earlier discussed. And by the end of that transaction, you can repay the loan.
01:08:19.126 - 01:08:52.680, Speaker A: And in particular here, this dYdX provider is only requiring one way of fee for a flash loan. So it's nearly free. So this is like about zero US. Dollar. And you can see here it's sufficient to pay back the initial amount that you lent and the arbitrator can realize the profits. So this particular example here that I'm showing is not a fictive example. It's one that we took from the ethereum blockchain in particular.
01:08:52.680 - 01:09:39.618, Speaker A: And so this basically should help you to answer your question how to achieve or how to gain access to initial capital to perform arbitrage. And what's probably the most interesting and intriguing aspect here of DeFi is that anyone can really take this flash loan and perform this arbitrage. So anyone, any one of you who are listening to this lecture is able to basically perform these types of arbitrage. All you have to do is to understand how the DeFi space operates, how to write a smart contract that can perform these two atomic actions within a transaction, and borrow the flash loan initially from a flash loan provider.
01:09:39.794 - 01:09:41.030, Speaker B: So, thank you very much.
01:09:41.100 - 01:09:42.886, Speaker A: I hope you enjoyed listening to this.
01:09:42.908 - 01:09:45.558, Speaker B: Lecture and you're quite keen now and.
01:09:45.724 - 01:10:10.880, Speaker A: Excited to jump in and code up your own arbitrage bot. Try it out. It is a very competitive game. There are a lot of nuances. Be aware of front running, of being frontrunner or backrun even by other traders. Some might replay your transactions which we will dive into further further lectures. It's a very competitive game, but also a very rewarding game if you get it right.
01:10:10.880 - 01:11:07.650, Speaker A: Welcome back. In this lecture we'll be looking at AMM liquidity mining. Note that liquidity mining can be applied to any type of DeFi protocol, but it's quite prevalent on AMMS. So what is liquidity mining and where does this term mining comes from? So liquidity, as we established earlier, is basically monetary value or monetary amount, right? So this is basically a financial value. Mining you're quite familiar by now with is the process of creating something, for example, extending the blockchain with blocks. In this particular context, it's referred to as generating financial revenue. So as such, liquidity mining can be seen as being equal to an incentive that's created for participants to participate in a particular DeFi protocol.
01:11:07.650 - 01:12:33.018, Speaker A: So there are two types of rewards in DeFi protocols and they are mainly trading fees. So if you're a liquidity provider or also called LP, and you provide assets into a pool, right? So there's a pool of assets, X and Y, and you provide some assets in there. You remember the example of Alice and then there's Bob, who's trading here and who will then provide a small fee to the liquidity pool. This is an incentive, right? So here, these are the trading fees that are being paid by traders to the liquidity providers. And the way that this works, these trading fees is that this value, this fee here is directly added into the pool, right? So it's being paid either X or Y that's in this pool. So as such, the liquidity providers, they have an LP coin which represents the share of their allocation in this pool. And because this pool is growing through trading fees, the percentage, the share of the pool remains the same, relatively speaking, right? But the absolute value of the pool obviously grows and therefore the LP coins grow in value through the addition of trading fees.
01:12:33.018 - 01:13:10.934, Speaker A: So an example in curve is that the LPs, they get 0.3% of the trading fees from the users. So in essence, if you're participating as an LP, as a liquidity provider in a pool, you're gaining interest based on the user behavior. So the more users trade, the more financial value you will receive. The second type of reward. Is the so called liquidity mining rewards. So these are rewards that any protocol, DeFi protocol can manually specify.
01:13:10.934 - 01:14:19.962, Speaker A: So they can, for example, say if you provide a certain amount of liquidity to a pool, then the protocol so this is actually in the DeFi protocol, instructors or developers or so they will basically say, okay, here, there's Alice. She provided that much liquidity, we will give her as a reward, we will give her some token C. Right? So this is a liquidity mining reward. And this incentive exists in order to incentivize liquidity providers to deposit more and more assets into a pool, hence attracting more liquidity, hence attracting more traders because the slippage becomes lower because the trading volume grows and volume attracts volume in the exchange businesses. So these are the two prevalent types of rewards that DeFi protocols are currently exerting. They may be further down the road. It would be amazing if you build a new DeFi protocol with maybe a different reward structure, a new type of reward.
01:14:19.962 - 01:15:29.320, Speaker A: So try to get creative here and in general. So here I have a small summary of what liquidity mining is, right? It's really incentive to provide liquidity to a pool. So liquidity providers should be incentivized. The reward is proportional. That's very important. It's proportional in terms of amounts of liquidity that you provide and also in terms of time, right? So if this is a chart with a time and the overall US dollar that you provide in liquidity and the liquidity changes over time that you provide, so then the rewards will basically be proportional to the individual amounts that you had at any point in time, and always in comparison to the other liquidity providers that are providing liquidity. What's great about liquidity pools in general is that you can remove and add your assets at any point in time, but this also holds for liquidity mining benefits.
01:15:29.320 - 01:16:26.226, Speaker A: So most of the time liquidity mining benefits are set for fixed amount of time. So for example, you can think of Bitcoin as actually one of the earliest, maybe liquidity mining proposals where, well, you get incentivized for your hash rate, not for your monetary amount, but there's a fixed release schedule at how many tokens or how many coins are being distributed over time. And in some protocols it might be removed anytime. So be aware that the incentive structures changes significantly once there's less liquidity mining rewards. So what's very interesting is that there are retrospective airdrops that are possible. So I guess uniswap is a famous example. Uniswap did not have a token in the early days of its protocol.
01:16:26.226 - 01:17:47.826, Speaker A: Then at some point in time, uniswap introduced a token and rewarded the previous liquidity providers as well as the liquidity takers. So those that actually trade given the liquidity provided by liquidity providers. So both liquidity providers and liquidity takers got incentivized to participate in this pool retrospectively. So that's the funny fact because this basically implies if you have a blockchain address that performed some interaction with some DeFi protocols then the address history in itself is a valuable element. So keep that in mind. Instead of selling a wallet, maybe just transfer some coins to another wallet, but keep the wallet if that's necessary. Or as well, if you're, for example, running a business and your employees are managing your private keys and they send the funds later back to some company owned account, keep in mind that the address history of a wallet is valuable and this wallet might receive airdrops later on.
01:17:47.826 - 01:18:22.970, Speaker A: So it's very important to keep here a clean tab of what is owned by whom as history matters. To give you a few examples, I plotted here screenshots of Curve and alpha Homora. So let's go into these a bit more in detail. So you can see here in Curve. The first example is the tree crypto pool which has three assets. Right? There's the UCT, the wrapped bitcoin and the wrapped ether. So basically this pool has three assets.
01:18:22.970 - 01:19:06.550, Speaker A: And this is actually one of the few pools in Curve that has non correlated or non packed assets. There's a base APY. So API stands for annual percentage yield APY of 3.73%, right? So this is at this very point in time, if we keep this state for a year and if you deposit some of your coins you will get this interest rate. This is the Base APY based on the trading fees. This is calculated on the expected trading fees that happened in a past time frame. And in addition you get a reward API APY.
01:19:06.550 - 01:20:06.090, Speaker A: So this can be between two and 5% and this is being paid out in Curve. So the Base APY is paid out in LP tokens of the respective pool while the reward APY is paid out in Curve. Right. So these are exactly these two type of rewards that we discussed in the earlier slide. Now, why does the reward here change from two to five? Well, this basically it's due to the Curve model because Curve incentivizes its users to lock Curve tokens in their platform. The more Curve you lock over a particular time frame and depending on the pool states you might get between two and 5% API. Here the trade volume is basically the amounts of US dollar of daily trade volume that's going through this pool.
01:20:06.090 - 01:20:50.010, Speaker A: So you can see some of these pools are quite higher with 120,000,000 while the Base API is relatively small. So you might ask why that's the case. So this basically depends also on the size of the pool. So the free pool is in particular relatively large. I'm not aware of the exact numbers there at this particular stage but the Base API doesn't necessarily have to correlate to the volume. So if the pool is very small. So it basically depends on the volume on the pool size and also on the fee settings that are set for the default pool.
01:20:50.010 - 01:21:31.782, Speaker A: So an additional interesting element that you can see here is that for the SUSD market, there's an incentive mechanism paid in SNX. So there is no range because SNX will not be locked in this system here. So it's just a fixed liquidity mining reward. So the overall API APY that you get is 0.5 plus whatever you get in between this range, plus these 1.78. So this is your overall APY that you get for this particular case. Now, some of these pools have a significantly higher APY.
01:21:31.782 - 01:22:09.240, Speaker A: So here you can see the TBTC pool goes up to 34% paid out in curve tokens. So you might want to be careful. So ideally the market is balancing out the importance or the danger, the risks of a pool. So I haven't seen yet any study being performed on the efficiency of these liquidity mining allocations. Based on the risk profile of the particular pool. I think that would be quite excellent future work. So feel free to propose this also in the MOOC, maybe as a project or something.
01:22:09.240 - 01:22:46.978, Speaker A: That's really an interesting future avenue. And then we have on the right side we have alpha Homora. Alpha Homora is actually a leverage platform. So it's quite different from curve. It's operating very differently. And here you have an interesting you have several actually APIs that you can get. So you get some yield farming API, you get trading fees, you get token release as well.
01:22:46.978 - 01:23:16.410, Speaker A: And you have to pay because you are taking leverage in this particular platform. So you have to pay a borrow API. So it's basically the sum of all these three sums then up to your particular APY that you may get if you extend the instantaneous APY over a year. So I hope this helps you to get some insight into yield farming or liquidity mining protocols.
01:23:17.790 - 01:23:48.150, Speaker B: Thank you very much for your attention. As before, feel free to try it out in practice. Just be aware that if you set a leverage multiplier on these liquidity mining platforms that might be too high, you might get liquidated very easily. We'll discuss this in detail in the lending and borrowing lecture. Welcome back. We're going to discuss now Dex aggregators. While in the previous lectures we have looked at DEXs or decentralized exchanges in isolation.
01:23:48.150 - 01:24:51.210, Speaker B: Now we're going to look at how to aggregate them. So how to merge them together. So what is the dex aggregator? Well, users may ask where do I get the best price for a particular trade? So if you think of this picture here as this being a particular exchange like this one, and this is another exchange. So users could directly go there and trade assets. But instead, why don't we build here this aggregator who sources liquidity from all these different exchanges and merges them so that the user is basically going here telling to the exchange aggregator would like to exchange those assets. And then the exchange aggregator finds the best routes, finds the best liquidity, the lowest prices, the lowest commissions, et cetera. So users really are interested in the deepest liquidity in order to pay the lowest slippage on their trades.
01:24:51.210 - 01:25:49.690, Speaker B: So there are overall two types of aggregators that are currently prevalent. They're so called off chain aggregators like One Inch and Paraswap. So these are websites where you can go and you have your browser wallet or your crypto wallet in your browser activated and they're quite flexible. So you can do trades across multiple chains and they're very quick also in determining your optimal trade. So the disadvantage of such aggregators is that operators can front run users because the operator is a trusted third person here, which is in the middle between the exchange and the user. And the off chain aggregation is typically performed off chain, as the name suggests. So the computation of the trade with the optimal parameters is not performed on chain and can therefore not always be optimal.
01:25:49.690 - 01:26:31.290, Speaker B: Then there are on chain aggregators like Swapswap is an example of this. They are much less famous at the moment than off chain aggregators, but they do have some key advantages. For example, they allow you to perform atomic routing and arbitrage which is provably optimal on chain. So the smart contract basically does everything for you. You don't have a middleman there. There's basically a very small likelihood of being front run, so it's technically a little bit safer. However, they don't scale as much as the off chain variants, so they're unlikely to efficiently cover like many more exchanges in parallel.
01:26:31.290 - 01:27:36.800, Speaker B: So what about one inch? So One Inch here you can see a web interface here on One inch, right? This explains to you where you can, for example, exchange Ether and I on this particular market you basically input the amount that you would like to exchange. So in this particular example, we are asking to exchange one ether at market order. So that's not limit order, but there's the support for some limit order. So let's look here into the market order and One Inch tells you that we are getting about 2300 die back for this particular trade. Now it will also show you here a list of the various exchanges where you can perform this trade. So you, for example, have here the indicator that One Inch is apparently the best source for this particular trade. If you go to uniswap version three, you get the same exact conversion rate.
01:27:36.800 - 01:28:07.154, Speaker B: But if you go to uniswap version two, you do have a minus zero point 15% worse exchange rate for this particular swap at this particular liquidity. Obviously you always have to take into account the amount of coins that you want to swap. So the UI of one inch is really beautifully verbose. You can see a lot of data. You can analyze which markets might be better for you. You can also choose to go directly.
01:28:07.202 - 01:28:08.474, Speaker A: To these websites, right?
01:28:08.512 - 01:29:01.314, Speaker B: If you want to pay less gas price, for instance. So it's quite intuitive, quite flexible, gives you a lot of power to understand what you're doing. What I also quite like about this is it actually explains you which route is taken, right? So, you know, here, for example, this is the particular route that's being taken for your swap. There might be more complicated routes that emerge depending on the swap that you're enacting. And yeah, feel free to try it out yourself and to just play with some numbers and you will see what one inch proposes to you. So one thing that we kind of see here is that there's no arbitrage being performed. So your trade might open up an arbitrage opportunity since you're swapping assets and you're changing liquidity on one exchange.
01:29:01.314 - 01:29:16.426, Speaker B: So another exchange might therefore basically create or there will be another market where there's an arbitrage opportunity created due to your swap. So this is something that you might want to take into account because you're.
01:29:16.458 - 01:29:20.110, Speaker A: Not taking the arbitrage opportunity with you.
01:29:20.260 - 01:30:06.522, Speaker B: So this aggregator does help you to do some aggregation, but it might not actually ARP everything out. So you might leave some money on the table in the stricter sense. Swapswap is a recent emerging on chain aggregator which aggregates two DEXes. So that's not much, but it's a beginning. So you have Uniswap and SushiSwap that's being aggregated, there's no particular UI change for the user. So you have here a standard uniswap UI. So you do not really see at the moment what advantages you get, what financial advantage you get out of this aggregator.
01:30:06.522 - 01:30:51.978, Speaker B: But in theory you should get better prices than on uniswap and SushiSwap since you're aggregating the liquidity together. So the beautiful thing is that it basically routes swap if there's a smart contract. If the smart contract deems this to be profitable. So the smart contract will decide on execution at execution time, whether this should be now routed or not. And it does perform arbitrage with flash loans, so it does not leave money on the table. So if profitable, it will create even a flash loan for you on the fly, transparently in the background and perform all this in the smart contract. Thank you very much for your attention.
01:30:51.978 - 01:31:43.120, Speaker B: So next time you hit an exchange, think about maybe visiting some aggregators, checking the prices there, maybe they're cheaper, maybe not, and just try around a little bit, especially if you want to exchange larger amounts. Welcome back. In this lecture we're going to look at how to find profitable trading opportunities in DeFi. So you can think of DeFi as being this graph of financial products that's completely open, you can see everything and hence you basically need to find the optimal path along this graph of financial products and you might discover profitable opportunities. Note that sometimes these profitable opportunities might be a tax. So you can even identify a tax with such tools. So let's dive in.
01:31:43.120 - 01:32:36.670, Speaker B: All right, so how can we detect arbitrage or profitable opportunities in DeFi? In this lecture, we'll be looking at mainly two methods. The first one is the Bellman Ford algorithm and the second one is the ethereum solver, also typically referenced as an Smt solver in the literature. The Bellman Ford algorithm is something that allows you to find negative cycles in a graph. So it allows you to basically identify whether you can do an arbitrage trade, a circular arbitrage trade. The beauty is it works among multiple markets, so multiple assets. So a market typically has two assets and you can chain several markets, as we will see in a later slide. So this algorithm is really extensively used in traditional finance, and we show how you can actually use it in DeFi.
01:32:36.670 - 01:33:41.538, Speaker B: The Smt solver, on the other hand, needs to encode the DeFi models in a particular model. So while the Bellman Ford algorithm can be applied quite easily to a DeFi graph of markets, the Smt solver needs a DeFi model that's manually encoded, which is quite a lot of manual work. However, the Smt solver can give you then a satisfyable path, which can be very rewarding depending on the solution that you find. So in order to reduce the search base of the Smt solver, you might want to apply some heuristics for path pruning, as we will show in a bit. And let's look into the specific systems that use those two methods. So they are both called DeFi poser, with ARP being the Bellman Ford algorithm and Smt the Smt solver version. So both depart here from a block I.
01:33:41.538 - 01:34:24.790, Speaker B: So this is really the blockchain state or represents the blockchain state that you're looking at everything. Basically, the past blockchain history here defines how we got to this particular state. But for the sake of this example here, we're looking at this particular block i. So if the blockchain state changed to the previous state, which typically happens right in DeFi, people are performing trades on the market, then the state changed. Then we can call either the Smt version or the ARP version. So let's go first with the ARP version or the Bellman Ford DeFi proposal. So we basically can build the DeFi graph of the various markets, which we will do in the next slide.
01:34:24.790 - 01:35:03.280, Speaker B: And I will show you really in detail how this works. And then we have a negative cycle detection. This is what the Bellman Ford algorithm can do. So the algorithm can tell you whether there is a negative cycle and there might be one, or there might be not one. Sometimes you don't find any. Then we perform what's called a greedy search, so we can search additionally in the cycle detection, maybe you find several cycles and you take the one that's the most profitable for you. So we continue and repeat this process here.
01:35:03.280 - 01:35:43.354, Speaker B: So the Smt solver, on the other hand, is a little bit more complex. It involves like several different steps, but in the end it reaches the same goal. So in the first place, we have to perform a manual modeling of the DeFi protocol. So for example, we take uniswap and we write a model, a new model that represents how uniswap works. We do this with curve and with any other DeFi protocol that we want to capture. Then we apply a few heuristics path trimming heuristics. For example, if we don't want to capture some paths in this DeFi graph, then we can trim this here.
01:35:43.354 - 01:36:24.280, Speaker B: So this might be sometimes interesting in order to reduce search space. But we also have to be aware that these heuristics, they might cut some of our revenue. And unfortunately, trimming heuristics is necessary because often the theorem provers are quite limited in the ability to solve problems. So depending on the Smt solver, obviously, but that's what we found to be useful here. And then you can basically plug this all in in the theory improver and let the theorem prover run. So there are various theorem provers out there, like z three is a potential one, sufley is another one. So you can look into those yourself if you're interested.
01:36:24.280 - 01:37:37.550, Speaker B: Everything that we get out here of this particular market should then be a particular trade that we should do, right? So for example, it might be we have to go to Uniswap, exchange Ether to Dai, then we go to SushiSwap, change Dai to Ether. And this is a circle already, right? So this is a very simple arbitrage circle that these tools might have found, but they're also much more complex trades that can be found through these automated tools. So you really get like this strategy or the transaction. And what you can do before you broadcast this transaction, you can execute it locally. So you perform a validation through concrete execution. So concrete execution basically means that you're executing a particular transaction locally on a particular block height and you don't broadcast it yet. And if you find it's actually profitable, then you might broadcast that transaction and you will try to mine this transaction at the top of the next block or at some position in the next block.
01:37:37.550 - 01:38:53.910, Speaker B: I'm referring here to the top of the next block because you don't want others to front run your transaction and to take away the opportunities that you identified, obviously. Now this is basically the entire model, right? And the entire state here, as far as I'm aware, this is the first tool that does this for you in an automated state in real time. So if you have here a block interval time of like whatever, about 12 seconds for example, in Ethereum, then DFI poser is actually able to give you a solution rather quickly in a few seconds. And you shouldn't wait too long. You should probably not wait 6 seconds even before you broadcast a transaction because the transaction also needs to propagate in the network, needs to reach miners, et cetera. But yeah, we think that it's really like a first step towards finding profitable opportunities in a DeFi graph based on a blockchain state and a DeFi state, because some applications might be sometimes vulnerable depending on their state. So these are not traditional vulnerabilities, but rather state dependent issues that might arise.
01:38:53.910 - 01:39:27.678, Speaker B: And so we certainly need more such tools that allow us to reason about the security of the composable DeFi protocols. Very well. Now let's look at the DeFi graph like a particular example, at least of the DeFi graph here. For the sake of this example, we're looking at DeFi poser ARP. So the Bellman Ford version of DeFi poser, we have a blockchain state with four markets. Here we have the assets A and B. And here we have B-A-B and C and CNA.
01:39:27.678 - 01:40:31.782, Speaker B: And if you look at these markets, we can already see that the red and the blue markets, they actually have both the same assets. Our objective is we have an input which is here, one element of asset A. And we would like to input this particular element and get basically back out more, right? So we want to get out more than we put in initially. So this is what we basically visualize here with this particular example. Now, if you just look at this particular state, you already see, well, I mean, I could just go into the first market where I can trade A to B, and then I go to the third market here, where I can trade B back to A. And my objective is that I get something back that's P one times PA right? Because these are the two prices on these two markets. And the profitable condition for my trade is that P one times P four is superior to one.
01:40:31.782 - 01:41:32.860, Speaker B: If that's true, then I can perform a trade among these two markets. Now, we can also perform a trade across three markets. So we could go again into the red market at the very beginning, right? So we go here into A over B, then we go to the second, to the yellow market here. We swap B to C, and then we go to the green market here, where we finally swap C to A. So those two solutions that I just shown you are both cyclic arbitrage and they're both possible in this particular market state configuration. Again, just like the example before, we have to make sure that the product here of the different prices is beyond one because we want the exchange to be profitable. And as such, we have this profitable condition that this is superior to one.
01:41:32.860 - 01:42:32.026, Speaker B: Now, if we basically model this as a graph, right, then you can look at this really like here, like a traditional Bellman Ford graph. In order to apply the Bellman Ford algorithm, we need to find, I mean, the Bellman ford algorithm can find for you negative cycles. So it has a negative cycle detection mechanism. And for doing that, we need to translate it into this particular form that's expressed here. Okay, so we basically do this conversion, right, from this, from the product of the prices superior to one to this particular sum. And we then apply the Bellman Ford Moore algorithm, which has the following complexity. So, the number of nodes in the graph is n, and the number of edges in the graph is denoted as E.
01:42:32.026 - 01:42:34.854, Speaker B: And so here, this is a particular node.
01:42:34.982 - 01:42:37.102, Speaker A: An edge in the graph is this.
01:42:37.156 - 01:43:02.520, Speaker B: Particular edge, for example. So the complexity of this algorithm is o n square times e. So DeFi poser Smt is the other solution that we discussed earlier, right? So here we can basically see that what we do is we have a model in the very first state, we want to create a model.
01:43:04.810 - 01:43:05.334, Speaker A: That can.
01:43:05.372 - 01:43:56.550, Speaker B: Be represented, that represents the DeFi actions and basically the actions of a particular DeFi platform. So we formulate it in the model. So, for example, you can take uniswap, you can take curve, and then you really need to translate it. It's a translation process from one language, from, for example, solidity language, to the symbolic model language that these Smt servers can operate on. Then we perform a path pruning process where we can apply heuristics to reduce the search space. So it's important that the path must not include any loops. For instance, we don't want to cycle indefinitely, so we want to find a finite solution.
01:43:56.550 - 01:44:07.322, Speaker B: And then we can input all this into an Smt solver. So the Smt solver has an objective constraint so that the final profit is greater than the target value.
01:44:07.376 - 01:44:08.618, Speaker A: So, for example, we can set a.
01:44:08.624 - 01:44:48.754, Speaker B: Target value as being one ether. And then we can try to solve this and also perform optimization through binary search, for example, to find the optimal value. So the Smt solver will tell us whether there's a solution given that particular target value. And if there's no solution, obviously we need to decrease. For example, we can go to 0.5, ether, et cetera, until we find close to optimal value with this approach. So when we evaluate DeFi poser, we can actually compare the Bellman Ford variant and the Smt variant quite objectively.
01:44:48.754 - 01:46:06.882, Speaker B: So in this plot here, on the x axis, you have the block number which represents the time. So this is the blockchain time. So we evaluated this from beginning of 2020 until May 2020. And in this particular example, you can see here the DFI posa ARP, right? This one here is actually found the highest revenue, right? So this is the cumulative revenue in Ether, as we express here on the plot. And you can see that the DeFi poser ARP transaction fee is a little bit higher than the DeFi poser SMP transaction fee, most likely because the ARP version found simply more potential sources. Okay, so then we have basically, as part of our evaluation, we had 96 actions on the uniswap banker mechadao markets, and we covered a total of 25 assets. So while this might sound like something, it's not really like a lot, right, in D five terms.
01:46:06.882 - 01:47:00.180, Speaker B: So there are many more markets, there are many, many more assets out there that you could include in such evaluation. But it's quite from an empirical perspective, it's really intense to model all these markets in, for example, the Smt version. So it wouldn't scale easily to perform such evaluation on any kind of market, at least if you consider the Smt market. What's quite important, however, if you perform such experiment, is to perform concrete execution. So you want to verify whether what your models tell you is valid, right? So the models are obviously a representation of reality. They might not always represent reality. So that's something quite to be aware of and to be careful about.
01:47:00.180 - 01:48:01.510, Speaker B: So overall, we found that the defoposa ARP really generates significant higher revenue. I would like to note, however, that the Smt solver so we modeled actually the Bzigs platform in the Smt solver and found that DeFi Poser Smt was able to detect the Bzix attack. So that's something that the DeFi Poser app is not able to do because there was no cycle in this particular attack. So sometimes the more complicated tools, if you really model your victim platforms, you might find attacks, while, for example, the Bellman Ford algorithm might not be able to capture those. So finally, to just give you, like, an overall comparison. So we have various methods to perform a path generation for finding profitable DeFi transactions. We have various path selection mechanisms.
01:48:01.510 - 01:48:46.230, Speaker B: Some tools require manual modeling, some don't. So ideally, you don't want to have manual modeling because it doesn't scale otherwise. However, you must or you should at least capture non cyclic strategies because most of the attacks that we are aware of are non cyclic. Finally, you might want to look at what parameters you choose and if they are optimal. And last but not least, certainly, the complexity of your solution is important. So here you can see default bozer ARP has only about 300 lines of code in Python, while the Smt version is almost an order of magnitude more complex. So thank you very much for your attention.
01:48:46.230 - 01:49:07.130, Speaker B: I hope that you're quite excited now to jump on coding your own DeFi Poser or new tool, next generation tool to find profitable opportunities, whether these are Arbitrage attacks or various other ideas that you might have. So try and get creative. I hope this was very helpful.
01:49:07.950 - 01:49:28.862, Speaker A: Welcome back. Impermanent loss is an often overlooked risks when providing liquidity to an AMM. But it's not rocket science. It's rather simple. Let's dive into it. So in the following example here we have an ETH Die pool, right? There's a liquidity pool. And we do have Alice.
01:49:28.862 - 01:49:53.286, Speaker A: Who can basically add liquidity to this pool. So at the current state, the exchange rate between Ethai is one to 100 die. So she's doing an add liquidity operation. So she's adding one ether and 100 die. So in equal proportions. So in total, it's $200. So she's owning 10% of the pool.
01:49:53.286 - 01:50:38.762, Speaker A: So now at this current state, she's owning 10% as a liquidity provider. Now let's assume that there's now a price change. So the price increase of ether. So now the new price is one ether is worth 400 die. So ether basically increased a fourfold in value here in this particular example, which is obviously a significant event. Now Bob comes and he's performing arbitrage, right, because in the liquidity pool, the liquidity was rather unbalanced. So he's balancing it out.
01:50:38.762 - 01:51:28.778, Speaker A: So now there are like five ether and 2000 die remain in this pool. And finally, in the third step, we assume that Alice is now withdrawing her liquidity, right? So she has access to 10% of the pool. 10% of the pool are equivalent to 0.5 ether and 200 die, meaning she gets $400 out of the pool. Initially, she had access to 200 US dollar. Now she has access to 400 US dollar. I mean, there's a realization of an impermanent loss here, right, because she basically had before she had one ether and $1, which would now be worth $500.
01:51:28.778 - 01:52:29.850, Speaker A: So effectively, instead of having 500, she has $400 only. So this is basically Alice who lost potential revenue because the ether price increased a fourth X, but she only made $100 here in this particular example. She only made $200 in this particular example, but she lost $100. So this implement loss is really an example of just the market dynamics of an automated market pool. And it's something that every liquidity provider can be exposed to naturally if you provide assets like Dai or USDC. So stablecoin assets here instead of ether to a pool. So if you have USDC and Dai in this pool, then the likelihood that these will diverge significantly is not that big.
01:52:29.850 - 01:53:27.470, Speaker A: But it still can happen if, for example, Dai would Depack or lose its pack. So an impermanent loss is called impermanent because it's not permanent. So it's only realized when you actually take out your liquidity. So if in the previous example Alice would have stayed in the pool, this loss would not have materialized. So you can think of the initial position being basically here, right? If we're here initially and then there's a price change of the initial price, then you can see that there's a change in total value. So, for example, it can go down or can go down also this way. So basically, whenever you have two or diverging assets in a pool, the impermanent loss may materialize.
01:53:27.470 - 01:54:16.320, Speaker A: So the impermanent loss can result in a total loss of funds. So trading fees might compensate this, but they may not. And liquidity mining can also help potentially and implement loss is similar to a DPAC, but I would say it's not as significant to a significant DPAC of a stable coin. So to find potential solutions is not simple. You basically would need to have to change the bonding curve. You remember the curve that governs the AMM liquidity. Feel free to also check out various possible impermanent loss calculators such that you can anticipate how significant the impermanent loss will be for you and for your particular position.
01:54:16.320 - 01:54:43.670, Speaker A: So there are some calculators online. This is just one example. I'm not sure if it's the best, so feel free to search around yourself. So here you have an initial price and you have your future price, and then it can calculate for you the amount of impermanent loss. But please do verify those numbers yourself. So, impermanent loss is a danger that exists both in AMMS and therefore also.
01:54:43.740 - 01:54:47.574, Speaker B: In leverage or lending pools whenever you.
01:54:47.612 - 01:54:57.830, Speaker A: Basically have a pool of assets that you're dealing with. So keep this into mind if you're calculating your risk, profile your risk models.
01:54:58.650 - 01:55:03.646, Speaker B: Nevertheless, stay excited about finding potential solutions to it.
01:55:03.668 - 01:55:06.414, Speaker A: If you're a math wizard, maybe think.
01:55:06.452 - 01:55:07.914, Speaker B: Of a new bonding curve.
01:55:08.042 - 01:55:14.570, Speaker A: Feel free to propose this in the chat or in the forum, and we are looking forward to hear your suggestions. Bye.
