00:00:00.490 - 00:00:48.954, Speaker A: Hi, I'm Dan Robinson from Paradigm, and I'm here to give a guest lecture with a case study on Uniswap. Uniswap is a decentralized exchange on Ethereum. It's one of the best known examples of an automated market maker. And it's also, I think, a pretty good example of a DeFi application, one that demonstrates a lot of what makes DeFi interesting and so compelling. Chain uniswap is a decentralized exchange on Ethereum, meaning it's a protocol implemented as a set of smart contracts on the Ethereum blockchain. It's one of the most popular applications on Ethereum, with over $10 billion traded per week. I think Uniswap is an interesting example of a DFI protocol because it really embodies some of the principles that make DFI interesting in a very pure way.
00:00:48.954 - 00:01:55.234, Speaker A: For example, unlike a centralized exchange, where typically you have to petition the exchange to add a support for trading a token on Uniswap, anybody can start trading tokens as soon as they exist. And as a result, Uniswap is often one of the first places where these kinds of tokens are traded. Uniswap smart contracts are fully non custodial, meaning there's no way for somebody to steal funds that somebody is holding and using to provide liquidity on Uniswap, or for somebody to cheat a trader who's trying to trade assets on it. Of course, this depends on the Ethereum blockchain itself continuing to be secure and depends on the Uniswap contracts themselves not having a bug. Finally, and relatedly, Uniswap is central tier resistant. If you can use Ethereum, if you can create transactions on it, you can provide liquidity or on or trade on Uniswap. Now, I'm going to talk a little about how Uniswap works.
00:01:55.234 - 00:02:38.014, Speaker A: Uniswap. V One and V Two were implementations of the Constant product market maker, which Arthur talked about in a previous lecture. 5.2 if you haven't seen that lecture, I recommend you go back and watch it in order to understand the core idea behind Uniswap and its early versions. The core functionality of any decentralized exchange, of course, is trading. The solidity function definition on the screen there is taken from the Uniswap V Two source code. You can trade with this contract by sending in the green token calling this function and then cause the contract to basically send you the orange token back.
00:02:38.014 - 00:03:05.794, Speaker A: Now, note that when Alice is trading with this pool, she's not trading with a specific counterparty, Bob. She's trading with the contract. If Bob comes along, he also trades with the contract he sends in. The other asset wants to do the opposite trade. But in both cases, Alice and Bob are interacting with the contract directly. This is what this looks like for the end user. Now, this is one example of a web interface for trading with the Uniswap contracts.
00:03:05.794 - 00:03:58.920, Speaker A: And if you go to this page and you connect your Ethereum wallet, you can use it to create transactions that trade on the Uniswap protocol on Ethereum. Now, when we say Alice and Bob are trading with the contract. Who are they actually trading against? They're trading against a large set of other users called liquidity providers. If Linda Say wants to provide liquidity to uniswap, she deposits some of both assets. Actually, she deposits an exactly balanced 50 50 portfolio of both assets into the pool, and then in return, she gets minted liquidity tokens. When she wants to withdraw liquidity, she burns her liquidity tokens, sends them back to the pool contract, and pulls out the assets. And she does that by calling the burn function that's shown on the screen.
00:03:58.920 - 00:04:47.894, Speaker A: Now, we're going to do a refresher on the math behind the constant product market maker, which is the basis for uniswap v one and v two. We start by plotting the reserves of the pool on a cartesian plane, with the Xaxis representing the amount of ETH and the y axis representing the amount of USD in the contract. So here we have a point that represents the state of the AMM, where it has four USD and one ETH from this state. Uniswap allows any trade that preserves the constant product invariant. X times y equals K. So all these points are the points that are reachable by a trade. A single trade on uniswap this invariant is enforced in the code.
00:04:47.894 - 00:05:57.006, Speaker A: This is the most important line of code in uniswap v two, which directly enforces this invariant. That X times y must be greater than or equal to K. So the way that a trade works is someone sends in some amount of ETH, and then the pool sends out as much USD as is needed to return to that curve. If we draw a line between the start and endpoints on the curve, we can see that the slope of that line is equal to the execution price of the trade, the amount of y that the user got out, divided by the amount of X that they had to send in to get it. If you did a bigger trade, then you'd end up pushing the price further down, represented here by a shallower slope. If you do a really tiny trade, then the price of the execution price of the trade ends up looking like the tangent line at that point, and in fact, the marginal price at any given point. The price of an infinitesimal trade is the tangent line at that point, which can also be considered the derivative of the curve itself.
00:05:57.006 - 00:06:47.274, Speaker A: We use this fact a lot in AMM research, where we're often trying to take the derivatives or solve a differential equation in order to find a curve that matches some property that we're looking for. Now, a lot of this should be familiar to you from the AMM lecture. These are the basic mechanics of a constant product market maker, and uniswap v two implements them pretty straightforwardly. We'll get to uniswap v three later. There's one more interesting feature of uniswap that I want to talk about before moving on to the much more mindbendy Uniswap V Three and that's price Oracles. There are a lot of DFI applications whose logic depends on knowing the price of some token. Later talks are going to cover some of these applications, like stablecoins and lending, and I think there's going to even be an entire lecture on Oracles.
00:06:47.274 - 00:07:41.118, Speaker A: But suffice it to say, Oracles are a really key building block in DeFi. So Uniswap, in order to help out these other applications, has a price Oracle built in. The basic idea is that if you want to know the price of a token, you can just take a look at what price it's trading on on an exchange. And the advantage of doing this, of looking at a decentralized exchange, is that this is available directly and trustlessly because contracts on the same blockchain can make calls to each other. This is just a big advantage over centralized exchanges since smart contracts can't make Http calls to hit those APIs. But there's a problem with this naive approach. If you just look at the current price, then someone might manipulate the observed price by trading with the dex immediately before the Oracle is called.
00:07:41.118 - 00:08:14.918, Speaker A: They can actually lower the cost of manipulation by just making the opposite trade immediately afterward. They might even be able to do this atomically or do it with a flash loan. These other tricks for doing it, suffice it to say, do not use the spot price on Uniswap as a price Oracle. So to protect against this, Uniswap has built in support for what's called a time weighted average. Price Oracle. Twaps are somewhat harder, but not necessarily impossible to manipulate. The way this works is that in Uniswap V two, the contract track, and this is a feature that was added in Uniswap V two, it wasn't.
00:08:14.918 - 00:09:19.870, Speaker A: In Uniswap V one, the contract tracks an accumulator that gets updated at the start of each block. And so if you the user checkpoint the value of that accumulator at the start and end of a period, you can use the difference in those values to calculate the TWAP over that time period. Now that's a little inconvenient to have to ping the contract twice at the exact right times that you want to get the price Oracle over. So uniswap v three added automatic checkpointing of this accumulator you can call the contract and get the value of the accumulator at any point in recent history. So this eliminates the need, at least for recent reads, eliminates the need to call it at the exact beginning and the exact end of the time period in order to checkpoint it, which makes it a little more convenient for some other applications to use as an Oracle. Now we're going to get to the really fun stuff. The math behind uniswap v three.
00:09:19.870 - 00:09:58.886, Speaker A: Uniswap V Three is based on the constant product market maker, but it extends it with a very powerful feature concentrated liquidity. The implementation is pretty complicated, but the basic idea isn't too hard to understand. Let's start with the constant product curve. Note that when the price changes, the point moves up and down along the curve, and the AMM provides some amount of liquidity at every possible price. This means that the curve has to maintain reserves for every price, even ones that are really far away from the current price. In most cases, those reserves aren't even going to be needed. Uniswap v three allows users to provide liquidity only within a specified price range.
00:09:58.886 - 00:10:44.294, Speaker A: This allows them to deposit fewer assets but still provide the same amount of liquidity and earn the same amount of fees while their liquidity is in range. This is equivalent to taking that same liquidity curve and translating it down into the left. If you look at the points where the curve meets the axis, that's where this curve runs out of one asset or the other. And the slopes of those points are the upper and lower prices of the range. Now, this chart only shows a single liquidity provider, but a single pool might have many liquidity providers, and Uniswap v three allows them to each have their own unique range. Here's what that looks like. Each color is a different liquidity provider providing liquidity in a different range.
00:10:44.294 - 00:11:37.580, Speaker A: Together, they add up to one weirdly shaped reserves curve. Now, I want to talk about one of the sacrifices that uniswap v three has to make in order to support concentrated liquidity. Recall that in uniswap V two, liquidity could be represented as liquidity tokens, an ERC 20 token something fungible. That where everyone's liquidity was represented as just a balance of particular token. In uniswap v three, every position is potentially different because it has a different range and has accumulated a different amount of fees. And so in uniswap V three, liquidity is not a near C 20 token, it's an NFT, a non fungible token. Now, the bright side of the sacrifice is that every uniswap liquidity position has its own cool rendering, which you can see on the right here.
00:11:37.580 - 00:12:13.780, Speaker A: But it does mean that you have to work a little harder to compose uniswap liquidity provision with other applications, as people have begun to do with uniswap V two liquidity tokens. I hope this demonstrates why I find uniswap so fascinating and how I think it demonstrates a lot of what makes DFI fascinating. If you want to learn more about uniswap, you can find the V Two and V Three white papers@uniswap.org. In addition, every graph from this presentation is actually an interactive visualization on desmos, and you can find links to that in the Uniswap docs. Thanks for watching.
