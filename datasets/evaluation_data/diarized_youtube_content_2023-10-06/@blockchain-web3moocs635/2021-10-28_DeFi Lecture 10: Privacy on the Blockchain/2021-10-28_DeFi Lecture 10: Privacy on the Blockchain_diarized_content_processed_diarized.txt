00:00:00.730 - 00:00:45.398, Speaker A: Welcome back, everyone. My name is Dan Bonet, and in this lecture we're going to talk about privacy on the blockchain. So the basic problem we're going to look at is, can we actually have private transactions on a public blockchain? Remember that one of the basic properties of a blockchain is that we have universal Verifiability. Anyone can verify that the rules of the blockchain are being followed and only valid transactions are posted to the blockchain. Well, so naively, you would think if we want to support universal Verifiability, that means that all transaction data must be public. Otherwise, if it's not public, how do we verify that the transactions are valid? However, it turns out this reasoning is not correct. And it turns out we actually can have private transactions on a public blockchain with universal Verifiability.
00:00:45.398 - 00:01:28.594, Speaker A: And the way we do that is using some crypto magic, which is what I want to tell you about in this lecture. Yeah, so using this crypto magic, we actually can have private transactions on a publicly Verifiable blockchain. And the way we do this is using cryptographic tools, primarily using what are called zero knowledge proofs. But we're also going to need commitments which kind of work together with zero knowledge proofs. Okay? So we'll see how all that works later on in the lecture. Just to give you a hint for where we're headed, the way we're going to achieve private transactions with universal Verifiability on a public blockchain is basically by committing to everything rather than putting everything in the clear on the blockchain. For example, the blockchain will only hold a commitment to the current state of the blockchain.
00:01:28.594 - 00:02:21.078, Speaker A: And this is what's called a hiding commitment, which means that it reveals nothing about the actual state of the chain. Now, I need to stress that this is a very short commitment. So actually, what actually gets written here is a very short string, possibly only 32 bytes long, and it's a hiding commitment to the state. So the state cannot be changed, but the public cannot really tell what the state is. Now, when a transaction gets posted again, we're going to post only a commitment, a hiding commitment to the transaction data, and then we're going to post a hiding commitment to the updated blockchain state. So now the question is, well, if everything is committed and nothing is visible, how do we verify that this is a valid transaction? And this is exactly the role of this proof pi, this little red proof pi, which is what's called a succinct zero knowledge proof. So it's a very short proof that's fast to verify.
00:02:21.078 - 00:03:19.910, Speaker A: And what this proof proves is that in fact, the committed transaction data is consistent with a committed current state. In other words, the committed transaction is a valid transaction and the committed updated state is actually a correct result of applying the transaction to the old committed state. The point is that this proof can be verified by anyone. So anyone who verifies that the proof is correct will be convinced that this transaction was valid and that the updated committed state is in fact a correct result of applying the transaction to the previous commitments committed state. And the interesting thing is that this proof actually reveals nothing about the transaction data or the state. So that's how we're going to achieve privacy with universal Verifiability on a public blockchain. Now, you may be wondering, like, why do we need privacy on the blockchain in the first place? And more generally, why do we need privacy in the financial system? And it turns out, basically, businesses without privacy simply cannot use the blockchain.
00:03:19.910 - 00:04:22.878, Speaker A: So just to give a simple example, a car company that wants to build a car, it has to pay its suppliers for various parts. If it wants to pay its suppliers using a cryptocurrency, it has to make sure that those payments remain private so that its competitors can't tell how much it's paying for the tires, the wipers, and so on. So without privacy, supply chain applications simply can't use the blockchain. Even on a personal level, if a company pays its employees in a cryptocurrency, there's a need to keep employee salaries private, and so we wouldn't like that payment to be made public to the whole world. Similarly, when people pay their rent, when they pay donations purchases, they have a preference for keeping that information private. What's more interesting is that smart contracts generally encode business logic. And so it's a really interesting question on whether there's a way to post smart contracts to the blockchain, execute those smart contracts on the blockchain, but do so while keeping the smart contract code private and not visible to anyone other than the company that owns that code.
00:04:22.878 - 00:05:02.202, Speaker A: Yeah, so this is a very interesting question. There's a lot of work on how to make that possible. Now, there are lots of types of privacy out there in various systems. Let me mention two of them. The first one we would call pseudonymity, which is often called weak privacy, where basically every user has a pseudonym and all the user's transactions are affiliated with that pseudonym. For example, on Reddit, all my posts might be connected to my pseudonym, but hopefully people don't have a connection from my pseudonym to the physical entity, which is me. The nice thing about pseudonym systems is it's very easy to implement reputation, right? If I make a lot of useful posts, my reputation will go up.
00:05:02.202 - 00:05:49.340, Speaker A: However, there is a risk to privacy in that if any of those posts become linked to me, then basically all the posts are linked to me, right? So it's very difficult to maintain the separation between the physical entity and the pseudonym. This is why pseudonym systems usually are considered to only provide weak privacy. Now, other systems provide full anonymity, where basically all the transactions are unlinkable, which means that even if you post two transactions nobody can tell that those two transactions are from you. Yeah. So your transactions that are unlinkable as a result, it's much harder to maintain a reputation because there's no record of what you did. Over time, it turns out there are reputation systems in full anonymity systems. However, they're much more complex than just in a pseudonymous system.
00:05:49.340 - 00:06:20.658, Speaker A: So given that we understand now the different levels of privacy, the question is what kind of privacy is offered by Ethereum, for example. So the basic unit in Ethereum is an account. And the interesting thing is that every account has a public balance. You can see here we're looking at a particular address. We can see exactly what that address balance is. All the transactions associated with that address are actually linked together. So really the address functions as a pseudonym where all transactions on that address basically are linked to that pseudonym.
00:06:20.658 - 00:07:10.306, Speaker A: Ethereum is kind of a classic example of a pseudonym system, and it's nontrivial to make sure that there's a physical separation between the account address and the physical entity that owns the account. The same thing in bitcoin. So in Bitcoin transactions, every transaction has the form addresses written in the transactions. The amounts are written in a transaction, the two addresses are in the transactions, and the amounts to those addresses received are also written in the transaction. So again, we have a form of pseudonymity where these addresses would belong to a single entity, but the connection might not be obvious. Nevertheless, if you look at a transaction log in Bitcoin, you can see that here we have two inputs coming from likely the same entity going to two outputs. One of those outputs is the change address, which also likely belongs to the entity that provided the inputs.
00:07:10.306 - 00:08:09.302, Speaker A: The other address is actually the recipient's address. And so you can kind of slowly build a graph of all transactions and by scanning transaction data, you can very quickly link all the addresses that belong to a single user to that single user. And if one of those addresses ever transacts with a physical entity that actually knows the physical entity that's associated with the address, then basically all the addresses become connected to one physical entity. And in fact, there are companies like Chainalysis that do this sort of thing for a living, where they basically connect Bitcoin addresses to physical entities. So with that, we can kind of see that there is like different levels of privacy offered in the financial system. For example, in Bitcoin and Ethereum today, all payments are publicly visible and they're all linkable to at least a pseudonym. What's interesting is, if you look at a traditional financial system like the credit card system, their payments are visible to the bank, but not so much to the outside world.
00:08:09.302 - 00:08:49.570, Speaker A: So that's a different level of privacy. And in fact, it turns out, using a blockchain, we can build a fully private system as we'll see using tornado cache and Zcash such that even the operators of the system will not know who's transacting with who. Okay, so this is coming later in the lecture. Now, just to get started, I wanted to show you a simple example of an anonymity mechanism on the blockchain using simple mixing. Okay? So imagine we find a mixer that provides this mixing service, and it's located at address m. So our three friends, alice, Bob, and Carol, what they would do is they would send one ETH to the mixer and record that on the blockchain. The mixer now has three ETH on the blockchain.
00:08:49.570 - 00:09:34.580, Speaker A: Now, privately, they're going to send fresh addresses to the mixer. So Alice, for example, sends a fresh address x to the mixer. And only the mixer knows that Alice's new address is going to be x, and Bob and Carol do the same thing. And then the mixer basically sends one ETH to x, one E to y, and one E to Z. And the interesting thing is, now an observer who's just looking at the blockchain knows that y belongs address y belongs to one of Alice, Bob and Carol, but it doesn't know which one of Alice, Bob or Carol owns address y. So we say that the anonymity set is a size three. Of course, we could have done this with hundreds of entities if we wanted to, to get a larger anonymity set.
00:09:34.580 - 00:10:06.446, Speaker A: Or alternatively, Bob can basically take his address y and then mix it with other parties, and that will increase the anonymity set quite quickly. So that's how kind of very simple mixing works. However, there are kind of obvious problems with this design. First of all, the mixer knows the exact connection between the output addresses and the input addresses. So that's a problem. We'd like to build a system where nobody knows the connection. And more seriously, even the mixer could just abscond with the three ETH that was given to it, right? It doesn't have to pay this out.
00:10:06.446 - 00:10:37.670, Speaker A: Once the funds were given to the mixer, it should just keep them and never give them to the parties. It turns out there are very, very cute solutions to this problem. So the question is, can we mix without a trusted mixer? And it turns out, on bitcoin, there's what's called the coin join protocol that allows us to mix without a trusted mixer. This is implemented in the wasabi wallet. And on ethereum, there's tornado cash, which is a trustless mix, which we'll see how it works later on in the lecture. Now, before we end this segment, I did want to emphasize it. Privacy is not all good.
00:10:37.670 - 00:11:27.410, Speaker A: There are negative aspects to privacy in the financial system as well. For example, privacy could be used for tax evasion. It could be used for ransomware. Here's an example of the WannaCry user interface, where basically it asks victims to pay a ransom in bitcoin, hoping that would hide the identity of the ransomware author. So there are negative applications to privacy. And sort of the real question is, can we support all the positive applications of private payments, like privately paying a salary, privacy in the supply chain, private charity and so on, but prevent the negative ones more generally? We can ask, like, can we ensure legal compliance in the payment system while preserving privacy for compliant folks? And the answer is yes, we can absolutely do this. And this is done using proper use of zero knowledge proofs, as we will see later on in the lecture.
00:11:27.410 - 00:11:52.938, Speaker A: So this is the end of this segment. In the next segment, we're going to talk about commitments, which is an important tool for zero knowledge proofs. And so we'll see how those work. See you in a few minutes. Welcome back, everyone. In this segment, we're going to continue working our way towards zero knowledge proofs, and we're going to introduce an important cryptographic primitive called a cryptographic commitment. So what is a cryptographic commitment? Well, really, a cryptographic commitment just emulates what in the physical world we would call an envelope.
00:11:52.938 - 00:12:36.874, Speaker A: Here we have our friends Alice and Bob. Bob can put some data inside of an envelope so that the envelope hides what the data is, and he can send the envelope over to Alice. Because the data is inside of an envelope, alice actually doesn't know what the data is. However, later on, Bob can simply open the envelope and convince Alice that what was in the envelope is in fact, the data that was intended. So this allows Bob to commit to some data to Alice and later on convince Alice what that data was. This has many applications in the area of DApps, for example, you can use this to build what's called a sealed bid auction, where every participant commits to its bid. Nobody knows what the bids were, but everybody's now committed to their bids.
00:12:36.874 - 00:13:07.538, Speaker A: Later on, once all the bids are in, everyone can be asked to open their commitments and the highest bid wins. And if somebody doesn't open their commitment, it's as if they did not participate in the auction. Yeah, so cryptographic commitments actually have many, many applications in cryptography. It's a very important primitive, and I want to show you two constructions for it. So first of all, let's define more precisely what is a cryptographic commitment. So the syntax for a commitment is basically two algorithms. There's a commit algorithm and a verify algorithm.
00:13:07.538 - 00:13:46.542, Speaker A: The commit algorithm takes the data to commit to we'll call that a message and some randomness R that's selected from some randomness space capital R. Okay? So the commit algorithm basically runs on the message and the randomness and produces the commitment string. This commitment string is the value that can be sent over to Alice. Later on, when Bob wants to open the Commitment, he can send the message and the string R over to Alice, and then Alice can run the verify algorithm to make sure that the message is really an opening of the Commitment. With respect to the randomness r yes. The verify algorithm says either accept or reject. Meaning either the message is a correct opening or it's not a correct opening.
00:13:46.542 - 00:14:40.520, Speaker A: And the point is that once a commitment is opened, anyone can verify that the commitment was actually opened correctly. Okay, so there are two important security properties for commitment schemes. The first one is what's called the binding property, which says that once Bob sends over a commitment, he can no longer change his mind about the data inside of the commitment. So, more precisely, Bob is not able to come up with a single commitment string that can be opened in two different ways. You see, M one R one is one opening and M two R two is another opening, and he should not be able to come up with M one R one, M two R two, such that the verify algorithm accepts both, but M one is not equal to M two. Yeah. So if no efficient adversary can do this, then we say that the scheme is a binding commitment scheme because once the commitment string is fixed, the committer can no longer change its value about the committed data.
00:14:40.520 - 00:15:22.126, Speaker A: The second property is what's called a hiding the hiding property, which says that the commitment should reveal nothing about the committed data. In particular, if we look at the commitment string that comes out of a message M in a random sampling of the string R, that commitment string should basically be what's called statistically independent of M. Yeah, it should reveal absolutely no information about M in a statistical sense. So this is sometimes called an unconditionally hiding commitment. Okay, and what I do want you to remember is that the string R, that's the random string R that's used to create the commitment is in fact sampled at random from the random space capital R. So now we can look at two examples of commitments. Both of them are based on hash functions.
00:15:22.126 - 00:15:49.034, Speaker A: So let's fix a hash function from the message space and the randomness space onto our commitment space. And a typical example would be like shot 256. And the only property I'm going to require is that H is a collision resistant hash. Yeah. And in fact, I would want the randomness space to be much, much larger than the commitment space. And we'll see why I need that in just a second. So now the way I'm going to commit to a message M is I'm going to sample a random string R from the set capital R.
00:15:49.034 - 00:16:21.286, Speaker A: Yeah. This arrow typically denotes a random sampling of little R from the space capital R. And the commitment string is simply going to be the hash of M comma R. Okay, so that's my commitment. And then the verification algorithm is obvious given the message M and the randomness R, the verifier accepts. If in fact, the commitment string is in fact a Hashing of M and R. So why is this commitment scheme binding? Well, first of all, it's not that difficult to see that the binding property follows from the collision resistance property of H.
00:16:21.286 - 00:17:16.146, Speaker A: In other words, if you can find one commitment string that could be opened up in two different ways m one, R one and M two R two that effectively corresponds to a collision on the function H, because H of M one R one is equal to H of m two R two. Yeah. So collision resistance, if you cannot find collisions of H, this commitment scheme must be a binding commitment scheme. Why is it a hiding commitment scheme? It turns out it's actually statistically hiding, assuming some randomness assumptions about the function h. So the function h we're going to assume if we assume that it behaves sort of like a random function, then the fact that the randomness space is so much bigger than the commitment space means that in fact, given h of M comma r, that commitment value is actually independent of M. And I'm just going to let you maybe think about that and try to argue that yourself. Okay? So that's a very simple example of a commitment scheme.
00:17:16.146 - 00:17:50.030, Speaker A: Basically commitments from sort of random looking, collision resistant Hash functions. And we're going to be using this commitment scheme a lot. So I do want you to remember that this is how this commitment scheme works. Basically, we hash the message with some random string and that gives us a random commitment value that commits the committer to the message M. The second example I want to give you is a more structured commitment scheme, and this is called a Pedersen commitment, which again, has really fantastic properties. This commitment scheme comes from an algebraic Hash function. So we have to introduce a little bit of algebra, but it's very, very little algebra.
00:17:50.030 - 00:18:27.818, Speaker A: So even if you are not familiar with the actual algebraic terms, you should still be able to follow with no problem. Okay? So the group, we're going to use a group G, which is a finite cyclic group. Now, if you don't know what a finite cyclic group is, it doesn't really matter. Just think of it as a collection of elements where there's a generator G, and all the elements in the group are simply powers of this generator. So G G squared, G cubed, G to the fourth, up to some element, G to the Q minus one. And as usual, we have the usual rules of exponentiation, which means that G to the I times G to the J is equal to G to the I plus J. We take it mod Q because of possible wraparound.
00:18:27.818 - 00:19:00.294, Speaker A: Okay? So that's kind of the way we can multiply two of these group elements. So just to introduce a little bit of terminology, we will say that Q is the number of elements in the group is going to be called the order of G. And we're going to assume that this Q is prime. So we are going to fix two elements GH in the group G. And as usual, we're going to let our randomness space be the numbers zero to Q minus one. Now for some values m and R, we're going to define the following hash function. The hash of M and R is simply going to be G to the M times H to the R.
00:19:00.294 - 00:19:55.386, Speaker A: And that's basically just one element in the group. Okay? So we do one exponentiation, multiply it by another exponentiation. That gives us the hash value, which is another element in the group. Now, there's a very basic fact from cryptography which says that if the group G is what's called a cryptographic group, and for those who know what I mean, basically we just need to assume that the discrete log problem is hard in the group G, then it's actually well known that this particular hash function actually is collision resistant. Okay? So if you can find a collision on this hash function that would allow you to break a problem in the group G which is believed to be difficult, namely the discrete log problem. So now that we have a collision resistant hash functions, we basically get a commitment scheme, right? So the way we commit to a message M using some randomness R is we hash M and R and we use our definition of the hash function to do it. Okay? So we get a commitment scheme exactly as an example one.
00:19:55.386 - 00:20:30.054, Speaker A: It's binding and hiding for exactly the same reasons as in example one. So this is just a way to instantiate the commitment scheme from example one using this particular hash function. So why do I tell you about this particular commitment scheme? Well, it turns out it has a very interesting property. This is called a homomorphic property. And let me explain what this property is. So here I just wrote the definition of the commitment scheme just as a reminder, right? So commitment to M is basically G to the M times H to the R. So now suppose I give you two commitments, commitment to commitment one and commitment two.
00:20:30.054 - 00:21:10.958, Speaker A: Commitment one is a commitment to M one. Commitment two is a commitment to M two. I give you two of these commitment strings. Then the remarkable property is that if I multiply these two commitment strings, yeah, these are just group elements so I can multiply them. If I multiply these two commitment strings, I get a group element which is actually just G to the M one plus M two, to the power of H to the R one plus R two, which magically is the commitment to the sum M one plus M two. Yeah, using the randomness R one plus R two. So what's interesting about this is now anyone can take two commitment strings, they have no idea what data is committed to in these commitment strings.
00:21:10.958 - 00:21:53.050, Speaker A: But by multiplying them, they can construct the commitment to the sum of the Committed values, even though they don't know what the Committed values are. Okay? So this is an important property of pettison commitment. This is this homomorphic property that lets you compute uncommitted values without knowing what the Committed values actually are. Okay? So we're going to need these properties in just a minute. So the main thing to take away from here is what commitment schemes are. The fact that we can construct commitment schemes from random looking, collision resistant hash functions and that some commitment schemes have additional properties like, for example, computing uncommitted values. So that's basically all I wanted to say here about commitment strings.
00:21:53.050 - 00:22:24.010, Speaker A: In the next segment we're going to talk about zero knowledge proofs, which is, like I said, a very, very important privacy tool. And then we'll see how to put zero knowledge proofs with commitments together to construct private transactions on a public blockchain. Okay? So again, see you in a few minutes. In the last segment, we looked at cryptographic commitments. In this segment we're going to look at another very important cryptographic primitive called a ZK Snark. A Snark stands for a succinct noninteractive argument of knowledge. So ZK Snarks have a tremendous number of applications in the blockchain space.
00:22:24.010 - 00:23:25.226, Speaker A: When we talked about scalability, we talked about rollups systems that use Snarks and it turns out ZK Snarks, that is, Zero Knowledge Snarks, actually can provide further privacy in the case of a roll up system. When we talk about privacy for transaction data, ZK Snarks are extremely useful and we're going to look at a number of systems that provide privacy for transaction data, like confidential transactions, tornado cache, which we will see later on in the lecture. And I also wanted to mention that in fact, using ZK Snarks, we can even keep the code of a smart contract hidden so that no one can see the business logic of a company that's trying to deploy a particular smart contract. And in fact, there's a company called Aleo that's deploying this which allows you to deploy DApps to a blockchain without actually revealing how the DAP code works. So all that is possible using zkSNARKs. And it turns out ZK Snarks are even useful in compliance applications. For example, an exchange might want to prove that it's solvent in zero knowledge.
00:23:25.226 - 00:24:14.910, Speaker A: What that means is that the exchange can prove that it has more assets than obligations and it does it in zero knowledge, meaning that it reveals nothing about its assets or its obligations. But the public is convinced that the exchange is solvent. So this is quite remarkable that ZK Snarks can be used to do this very efficiently. Similarly, we can use ZK Snarks to do what we call Zero knowledge taxes, where anyone can prove to the tax authority that they paid the correct amount of taxes without actually revealing anything else about their financial data. So this sounds kind of like a science fiction application, but in fact, ZK snarks and blockchains make that possible, at least in principle. Okay? In this lecture, we're actually going to focus on using zkSNARKs for keeping transaction data private. So private transactions on a public blockchain.
00:24:14.910 - 00:24:54.250, Speaker A: So to explain what is a ZK snark, let's start at the beginning. The first thing we have to do is explain what is an arithmetic circuit. So let's fix some finite field F. And if you're not comfortable with the term finite field, don't worry about it. Just think of F as a set of integers 0123 up to p minus one, where addition and multiplication is done modulo p for some prime p that's bigger than two. Okay? So F is just this set of p integers where all arithmetic is done modulop. So what is an arithmetic circuit? Well, an arithmetic circuit takes as inputs and a list of n elements in the field and produces one element in the field.
00:24:54.250 - 00:25:41.994, Speaker A: So here I wrote an example of an arithmetic circuit. It takes two inputs, x one and x two. It also takes the constant one as an input, and then it does some arithmetic operations on them, which basically mean that this circuit, this arithmetic circuit is evaluating this multivariate polynomial. Okay? So really what the arithmetic circuit is, it is something that defines a multivariate polynomial along with a recipe for how to evaluate the polynomial more generally. An arithmetic circuit is what's called a directed acyclic graph, where the internal nodes of the graph are labeled with operations plus minus or multiplication, namely these arithmetic operations. And the inputs at the bottom are labeled with the variables x one to x n. And we also allow the constant one.
00:25:41.994 - 00:26:29.458, Speaker A: And as I said, an arithmetic circuit defines an invariate polynomial along with a particular way to evaluate that polynomial given the inputs to the graph. Now, we'll use this notation, bar c, to denote the size of the circuit c, which refers to the number of gates in the circuit. So in our case, the size of the circuit is three because it contains three arithmetic gates. Now, it turns out that arithmetic circuits are a fairly powerful computing model. We can do almost anything we want using arithmetic circuits. And so let me give you two examples of interesting arithmetic circuits. The first one is what I would call the hashing circuit, which takes as input a hash value h and a message m, and it's going to output zero if in fact Sha 256 of M is equal to H, and it's going to output nonzero otherwise.
00:26:29.458 - 00:26:53.582, Speaker A: Yeah. So here is how we would write this circuit. So c of h comma M is simply going to be H minus Sha of M. Yeah. So you can see that if H is equal to Sha to 56 of M, this will be zero. Otherwise it will be nonzero. Now, implementing this as an arithmetic circuit takes about 20,000 gates because of the specific definition of the hash function shot to 56.
00:26:53.582 - 00:27:25.654, Speaker A: So 20,000 gates is not a particularly small circuit, but it's also not a very large circuit. Yeah. So you can see that we can implement this hashing circuit using an arithmetic circuit of kind of relatively medium size. An arithmetic circuit can also be used to verify signatures. So here's an arithmetic circuit that will take as input a public key, a message and a signature. It would output zero if the signature is valid for the given message with respect to the given public key, and it would output nonzero otherwise. So we can also write an arithmetic circuit that implements a signature checker.
00:27:25.654 - 00:28:04.982, Speaker A: Yeah, and similarly, we can implement very complex arithmetic circuits that kind of combine these operations in arbitrary ways. And as I said, more generally, arithmetic circuits can be used to almost implement anything we want in the blockchain space. Okay, so now that we understand what an arithmetic circuit is, let's dive in and kind of explain what is an argument system. So an argument system involves two parties approver and a verifier, which will often denote by P and V. Now we're going to fix a particular circuit, C, which takes two inputs x and W. X happens to be a list of N elements in the field. W happens to be a list of M elements in the field.
00:28:04.982 - 00:29:02.118, Speaker A: But what's more important is that we're going to refer to X as a statement that we're trying to prove and we're going to refer to W as a witness, typically a secret witness that the prover is trying to prove knowledge of to the verifier. So in these settings, the prover is going to be given the statement X and the witness W, and the verifier is only going to be given the witness X. The verifier does not know what the witness W is. What the prover is trying to do is convince the verifier that there exists some witness such that C of XW is equal to zero. Okay, so again, the verifier doesn't know what the W is, but the prover is trying to convince the verifier that such a W exists. How are they going to do that? Well, they're going to send messages to one another where the verifier actually is going to be sending a whole bunch of challenges to the prover. And finally, the verifier is going to check the prover's responses and based on those responses, it's going to decide whether to accept or reject the proof from the prover.
00:29:02.118 - 00:29:29.662, Speaker A: So that's what an argument system is. And what's important to understand is that there are two types of argument systems. One is called an interactive argument system and the other one is called non interactive. In an interactive argument system, the prover and the verifier can have many rounds of interaction. Yeah. So they send messages to one another and finally, after all these rounds are over, the Verifier decides to accept or reject. This turns out to be quite useful if there's only a single Verifier.
00:29:29.662 - 00:30:28.046, Speaker A: For example, maybe there's a compliance auditor that I'm trying to prove something to, in which case it's fine to have an interactive protocol. Like, for example, in our zero knowledge taxes example, I might want to prove to the tax authority that I paid the right amount of taxes, and it's fine if that's an interactive protocol at the end of which the tax authority either accepts the interaction or rejects it. The other types of argument system is a non interactive argument system where here the prover sends a single message to the Verifier. This single message is going to be called a proof. Okay, so just one message goes to the proof from the prover to the Verifier, and now the Verifier has to decide whether it's convinced that W exists or not, just based on that single message. Yeah, this is particularly useful when there are many Verifiers involved. For example, in roll up systems that we discussed at an earlier lecture, the roll up server sends a proof to the blockchain, and now all the miners on the blockchain have to verify that proof.
00:30:28.046 - 00:31:10.446, Speaker A: So there are many Verifiers that need to verify that proof, in which case we would like the proof to be non interactive so that the roll up server doesn't have to do an interactive protocol with each one of these Verifiers. Now, we can make even more demands of non interactive argument systems. In particular, we can demand that the proof be very short, which is what we would like if the proof is going to be posted on the blockchain so as not to take up space on the blockchain. And we could also demand that the proof is very fast to verify so the miners who are verifying the proof don't have to work very hard. If we have a short proof that's fast to verify. We call the argument system a Snark. As I said, a Snark stands for a succinct noninteractive argument of knowledge.
00:31:10.446 - 00:31:54.798, Speaker A: And in this lecture, we're going to focus on noninteractive argument systems because those are the ones that are most relevant in the blockchain environment. Okay? So let's focus on a particular type of non interactive argument system, in particular, what's called a preprocessing argument system. So what's a preprocessing argument system? Again, we have our friends, the Prover and the Verifier, and we have our fixed circuit C that takes as input x and W. Remember, X is called the Statement and W is called the Witness. Now, in a preprocessing argument system, what happens is we first preprocess the circuit. Yeah, so there's a setup algorithm called S that takes the circuit as input and produces these parameters that we call SP and SV. SP is for the prover and SV is for the Verifier.
00:31:54.798 - 00:32:41.342, Speaker A: Now, in this argument system, the prover takes SPX and W, and the Verifier takes SV and X. As usual, the Verifier does not know W. The prover is going to send a proof over to the Verifier, and now the Verifier is going to use the proof Pi, SV and X to decide whether to accept or reject the proof. So, in more detail, a preprocessing argument system is a triple of algorithms SP and V, where S of C basically outputs the public parameters SP and SV. The prover takes his input, SPX and W produces a proof, the Verifier takes SVX and the proof, the Verifier does not know the witness, and then it outputs accept or reject. Now, we want the preprocessing argument system to satisfy a number of requirements. So let's see what these requirements are.
00:32:41.342 - 00:33:37.090, Speaker A: The first one is called Completeness, which basically says that if W is a correct witness for X, so C of XW is equal to zero, then the honest prover will always convince the honest Verifier to accept the proof. You can see here the probability that the Verifier accepts the proof that was produced by the prover is equal to one. So the Verifier basically always accepts the proof produced by the prover. The other requirement is that the argument system be what's called an argument of knowledge. In other words, if V accepts the proof from the prover, then it must be the case that the prover actually knows the witness, for which CXW is equal to zero. Now, what does it mean for the prover to know the witness W? We'll define that more precisely a little bit later. But here we'll say that in particular, if a malicious prover who does not know the witness W is trying to convince the Verifier that it knows W, the Verifier will basically accept that proof with negligible probability.
00:33:37.090 - 00:34:28.162, Speaker A: So those are two requirements for an argument system, and those two requirements are already quite interesting. However, we can also require a third property, which is what's called the zero knowledge property. So the zero knowledge property means that the proof pi reveals nothing about the witness W. So not only is the Verifier convinced that the prover knows W, the Verifier actually learns nothing about the prover's witness. Okay? And again, we'll define zero knowledge a little bit later. So, in addition to the three properties that we just saw completeness argument of knowledge and zero knowledge, we can require yet a third property from the preprocessing argument system, namely that that argument system is succinct. So what does it mean to be a succinct argument system? Well, succinct means that the prover generates short proofs and the Verifier runs in very little time.
00:34:28.162 - 00:34:57.802, Speaker A: So what do we mean by that? So we'll say that the proof is short if in fact the length of the proof is only logarithmic in the size of the circuit. Yeah, so logarithmic in the number of gates in the circuit. The proof size can depend on a security parameter lambda. But the important thing is that it's only logarithmic in the size of the circuit. So it's very, very short. Even for very, very large circuits containing millions of gates, the proof is going to be very short. The other requirement is that the Verifier is very fast.
00:34:57.802 - 00:35:50.594, Speaker A: And what do we mean by that? Well, again, we'd like the Verifier to run in its most logarithmic time in the size of the circuit. The Verifier, of course, can run in linear time in the size of the statement because the Verifier at least has to read the statement that it's verifying. But its running time as a function of the size of the circuit should be at most logarithmic. So again, the circuit could have millions of gates and yet the Verifier would run in very, very little time. So now we can see actually why we needed to introduce the setup procedure. The problem is that the Verifier has to be so fast that it doesn't even have time to read the circuit, the circuit C. Yeah, well, if the Verifier doesn't have time to read the circuit C, how is it going to verify that C of XW is equal to zero? And that's where the setup procedure comes in, right? So the reason we need to preprocess is exactly because of this timing constraint on the Verifier.
00:35:50.594 - 00:36:39.526, Speaker A: And so the Setup procedure is helping the Verifier verify such large circuits by basically summarizing the circuit in the parameters SV. So really, SV is some sort of a short summary of the circuit that's being verified. This SV needs to be short so that the Verifier can actually read it. So again, the purpose of the setup procedure is basically to summarize the circuit for the Verifier so the Verifier can be very, very fast and run in only logarithmic time in the size of the circuit. Now, the last thing I'll say is if the argument system SPV is both succinct and is zero knowledge, then we say that it's a ZK snark. Okay? So a Snark just has to be a succinct argument system. A ZK snark has to be a succinct argument system that's also zero knowledge.
00:36:39.526 - 00:37:24.762, Speaker A: In other words, the Verifier learns nothing about the witness W from the proof pi. All right, so by now you're probably wondering, why can't we just use the trivial argument system, right? The prover has this witness W. It's trying to convince the Verifier that it knows W. So why can't I just send W to the Verifier and have the Verifier check that CXW is equal to zero and accept if so? Yeah, this is what we would call the trivial argument system. However, there are lots of problems with this. First of all, W might be secret, and the prover might not want to reveal anything to the Verifier about W, in which case they would have to use a zero knowledge argument system to make sure W reveals nothing w might also be very long. Right? We wanted a proof system where the proof is very short.
00:37:24.762 - 00:37:53.298, Speaker A: Here, if the proof is W, the proof might be very long. And so that would not be a succinct proof at all. And finally, computing CXW might take quite a long time, but we wanted a very fast Verifier. And you notice that here the Verifier has to evaluate cu of XW itself. Well, if running the circuit C takes a long time, the Verifier just can't do it. And so this would not correspond to a fast Verifier. And so that's another reason why the trivial proof system doesn't work.
00:37:53.298 - 00:38:22.810, Speaker A: So we need to do something more clever than just sending, just having the prover send W over to the Verifier. So let's look at a quick example. Suppose there's a public value Y, and the prover knows some tuple, x one to x n such that the hash of x one to x n happens to be equal to Y. The prover wants to prove to the verifier that it knows X one to x n. Right? So in this case, the statement is Y. Yeah, that's the public statement that's also given to the verifier. The witness is x one to x n.
00:38:22.810 - 00:38:59.782, Speaker A: And the prover would like to prove that it knows x one to x n such that the hash of x one to x n is equal to Y. So using a snark or even a ZK snark, the prover would be able to send this proof over to the Verifier. And the remarkable thing is A, this proof is only logarithmic in N. So this is a tiny, tiny proof compared to the size of the witness. And the verifier's time to verify this proof is also logarithmic in N. Even though what needs to be done here is to hash N different elements, the Verifier's time is actually much, much smaller than the time it will take to hash N elements. Yeah.
00:38:59.782 - 00:39:32.638, Speaker A: So this is what a Snark or a ZK snark is capable of doing. And you're probably wondering, how is this possible? And again, it turns out this is kind of the magic of what Snarks can do. Yeah, so we'll talk more about that in just a minute. Now, before we go any further, any further, I want to say that there are actually multiple types of setup procedures. Right? We said that the setup procedure is going to help the Verifier by summarizing the circuit for the Verifier. So it outputs these public parameters SP and SV. And it turns out there are three types of setup procedures.
00:39:32.638 - 00:40:08.858, Speaker A: The first one is what we call a trusted setup, where in fact, the setup algorithm uses some secret data that only it knows. Usually that secret data is just some random bits that it generates for itself. But those random bits have to be kept secret. And when the setup procedure is done running, they're erased so that nobody ever knows what those random bits are. So, in the simplest case, the trusted Setup procedure actually has to be run once per circuit. Yeah. So S of C uses data that has to be kept secret and is specific to the circuit C that's being processed.
00:40:08.858 - 00:40:59.226, Speaker A: What's important to remember is if the secret randomness that's used by the Setup procedure, if that ever becomes public, that will be disastrous for the blockchain environment because it would allow the prover to prove false statements. That would allow the prover then to kind of generate money out of thin air and all sorts of other bad things that will happen. Yeah. So we have to make sure that the secret randomness used by the Setup procedure is always, always kept secret and is destroyed when the Setup procedure is done. So that's a bit disturbing, but we can do better. So, a better Setup procedure still uses trusted randomness, but it's universal for all circuits. So, in other words, we can think of the Setup procedure as being divided into two separate algorithms, an init and a preprocessing algorithm, where the init algorithm, when it runs, it actually needs to generate secret randomness that has to be destroyed.
00:40:59.226 - 00:41:51.934, Speaker A: When it's done, it will generate some string U, and then the preprocessing algorithm will basically use this universal string U with a given circuit to generate SP and SV. Now, this procedure here is completely deterministic, and anyone can verify that it did its job correctly. Yeah. So once the init procedure is run, the S preprocess procedure actually is completely deterministic. Anyone can run it for themselves and be convinced that SP and SV were actually constructed correctly. So this is better than the first Setup paradigm in that we only have to run the trusted setup once, and then we can pre process as many circuits as we want. The third one, which is kind of our ultimate goal, is what's called a transparent setup, where the pre processing algorithm doesn't actually need any secret data at all.
00:41:51.934 - 00:42:27.066, Speaker A: Yeah. So basically, it will generate SP and SV given the circuit, and anyone can verify that SP and SV were computed correctly. So we have Snarks that use transparent setup, but as we'll see, they're not as efficient as the ones that can either use trusted Setup or Circuit or a universal Trusted Setup. So really, sort of the hierarchy goes from top to bottom, where transparent setup is our ultimate goal. And we'd like to make transparent setup snarks as efficient as possible. So there's been tremendous progress on building Snarks. In fact, the first Snarks were designed back in the early 1990s.
00:42:27.066 - 00:43:19.914, Speaker A: They were based on something called the PCP Theorem. They were very short, they were transparent, they had very fast verifiers. However, the problem is that the proverbs time was just so long that it would be impractical to deploy these Snarks today. So these early snarks, even though they are very good, from a verifier's point of view the proverbs time, make them impractical. So in 2013 an important idea came out by Gennaro, Gentry, Parno and Reykova and this was improved somewhat in 2016 by Groth, which actually constructed a Snark with a linear time prover and a constant size proof. So very, very short proofs and linear or actually quasilinear provers. Yeah, this construction required a trusted setup for every circuit, which again I remind you, means that if the setup is compromised, the prover can prove false statements, which is kind of a disaster for us.
00:43:19.914 - 00:44:05.994, Speaker A: But as long as the setup is run correctly, we have a secure Snark or a ZK Snark. And in fact, Gross 16 is a very, very popular Snark and ZK Snark that in fact most of the systems that we're going to be talking about in this lecture use actually GRA 16. We also have universal trusted setup Snarks. So Sonic, Marlin, Plonk are examples of trust of Snarks with a universal trusted setup. So you only have to run the trusted setup procedure once and then you can preprocess as many circuits as you want. And we also have transparent snarks like Dark and Halo and Stark. But these are either produce slightly longer proofs than the other systems or they might take a little bit longer for the prover to run.
00:44:05.994 - 00:44:46.498, Speaker A: So I kind of put these all in a table. This is a very partial list of all the Snarks out there, but you can see, for example, graph 16 has very short proofs, has very fast verifier, but does require a trusted setup per circuit. Plunk and Marlin sort of have roughly the same parameters of GRA 16, but they're universal. Then we get into Snark systems that have a transparent setup like Bulletproofs, Stark and Dark. Bulletproofs are an interesting example. They have very short proofs among the transparent setup Snarks, so the constants in the big O are relatively short. However, as you can see, they have a linear time verifier, so they're very short proofs, but they take a while to verify.
00:44:46.498 - 00:45:28.430, Speaker A: Stark and Dark actually have slightly longer proofs but are much, much faster to verify. And all three of those support a transparent setup. So that's a quick rundown through a couple of Snark systems out there. There are many others, but we'll leave it at that for now. So I wanted to quickly show you how to use a Snark software system and so let's quickly go through the components of a Snark software system. First of all, people have now written sort of high level languages that compile into circuits to which the Snark system actually applies. So there are languages like Circom and Zocrates and so on where you can actually write the program that you want to convert to a circuit.
00:45:28.430 - 00:46:01.726, Speaker A: Then later you kind of run a compiler to convert this into an arithmetic circuit or something, some format that's equivalent to an arithmetic circuit. I wrote a few examples here, but really you should be thinking of these as sort of arithmetic circuits. So we take our high level language program, compile it into an arithmetic circuit. Now we can run the Snark backend. So we give it the statement and the witness, we run the actual Snark algorithm and that produces a proof for us. And then later we can run the Verifier, giving it the statement and the proof and the Verifier will output, accept or reject. Yeah.
00:46:01.726 - 00:46:40.710, Speaker A: So arrows here correspond to algorithms. And I should say that kind of the computational intensive part is actually producing this proof. So the algorithm that actually produces the proof pi is fairly computationally intense and that's kind of the bottleneck of Snark production. You should ask me where are the parameters SP and SV? Well, of course, there's also the setup procedure that takes the arithmetic circuit, produces SP and SV and gives it to the Verifier and the Snark backend algorithms. Yeah. So this is sort of a summary of what a Snark system looks like. There are these four algorithms, the compiler, the setup, the prover, and the Verifier.
00:46:40.710 - 00:47:19.890, Speaker A: And that's how these Snark software systems work. So just to look at an example, let's look at a program written in Socrates here. The goal is to convince the Verifier that the prover knows a pre image of some image x under Shaw 256. So the prover wants to prove that it knows a witness W such that Sha of W is equal to x. Okay, so how do we do this? Well, here is a simple Socrates program that does this right. So it says the statement is basically two elements in our field. So really what happens? The reason we need to do two elements is because Zocrates breaks it down into 2128 bit values.
00:47:19.890 - 00:47:39.838, Speaker A: So that's what it takes to represent a 256 bit value. So we'll write it as two different elements. The witness is marked as private. That's the thing we want to keep secret. And then here's the program. We just compute a hash of the witness and check that the least significant bits and the most significant bits are equal to the value of the statement. And if so, we return one.
00:47:39.838 - 00:48:25.790, Speaker A: So that's the Zocrates program to verify that we have a pre image of some image x. And the next thing that happens is we compile this into an arithmetic circuit. In this case, the arithmetic circuit is expressed as what's called an R one CS program. But this is just a format that's equivalent to an arithmetic circuit. And then we can feed this R one CS program to the prover to produce an actual proof that we know a W that happens to map to x. Okay? So that's how these Snark systems are used in the real world. And so the last thing I want to do in this segment is just very briefly show you how to actually define the concepts of an argument of knowledge and zero knowledge, just so that you know how these formal definitions actually work.
00:48:25.790 - 00:48:54.418, Speaker A: So let's start with an argument of knowledge. So, remember, the goal was to make sure that the verifier accepts only if the prover knows a witness. That makes the circuit evaluate to zero. But what does it mean for an algorithm P to know a witness? So, informally, we'll say the prover knows W if this w can be extracted from the prover. And I always think of sort of torturing the prover until it gives us the witness. And so that's kind of exactly what we're going to do. Yeah, the goal is to kind of extract this witness from the prover.
00:48:54.418 - 00:49:33.730, Speaker A: And if we can extract such a witness, then we say that the prover actually knows W, and that the argument system is a proof of knowledge from W, because the witness can be extracted from the prover. Formally, the definition goes like this. So we'll say that an argument system SPV is an argument of knowledge for a circuit C, if basically for every malicious prover. Yeah. So the malicious prover is going to be an adversary, which is going to be composed of two parts, a zero and a one. So this adversary A is going to act like a malicious prover. Now, what does this adversary A do? Well, we run the setup procedure as normal.
00:49:33.730 - 00:50:13.978, Speaker A: We run algorithm A zero to produce a statement X. So the adversary chooses the statement X, where it's going to try to forge a proof, and then we run a one to actually produce the proof. Pi all right. And suppose that the verifier actually accepts this proof with non negligible probability, with, like, even probability one in a million. So what we have here is an adversary that behaves like a prover and is able to convince the verifier that it knows the witness W. Okay, that's what this says. Now, what we're saying is if we have such an adversary, then there must exist another algorithm called an extractor.
00:50:13.978 - 00:50:53.566, Speaker A: This extractor E, is going to use the adversary as a black box. But what the extractor does is basically, again, this notation here means that the extractor interacts with the adversary A one. And what it does is it's able to extract the witness w that's a valid witness for x. In other words, it makes the circuit evaluate to zero, and it does so also with non negligible probability. So, to summarize in words, what this says is if there is a malicious prover that's able to convince the verifier with non negligible probability, then there's an extractor that's able to extract a valid witness from this malicious prover. That's what this definition says. Yeah.
00:50:53.566 - 00:51:40.060, Speaker A: And how the extractor works is basically dependent on how the actual argument system works. Now, what I'll say is that here we only restricted ourselves to adversaries that run in polynomial time. Polynomial time in the security parameter. In fact, in some proof systems, the proof of knowledge property will hold for all adversaries, not just ones that are efficient and run in polynomial time. If this knowledge statement holds for all adversaries, we'll say that the proof system in fact is a proof of knowledge, not just an argument of knowledge. So argument means that it's secure against efficient adversaries. A proof of knowledge means that it's secure against any adversary, even one that might run in exponential time.
00:51:40.060 - 00:52:19.942, Speaker A: So this is how we define an argument of knowledge. The next thing I'd like to do is explain how we define zero knowledge. Remember that an argument system SPV is zero knowledge. If basically for every statement x, the proof pi should reveal nothing at all about the witness W, other than the fact that the witness exists. But otherwise it should reveal nothing at all about the witness W. So the question is what does it mean to reveal nothing? What does it mean that pi reveals nothing about W? Let's try to understand that better. So, intuitively, the way we require that Pi reveals nothing about W is to say that the Verifier could have generated the proof pi by itself, without knowing W at all.
00:52:19.942 - 00:53:24.954, Speaker A: So really, if it could have generated Pi by itself, it learns nothing at all from Pi. So really, what the proof provides to the Verifier is confidence in the fact that W exists, but it tells the verifier nothing new that it couldn't have generated already by itself. So what does it mean that the verifier could have generated the proof by itself? Well, we'll say that an argument system SPV is your knowledge. If there's an efficient algorithm, which we call SIM, stands for a simulator, the simulator is only going to take the public x as input, and the output of the simulator, namely SPSV and Pi, should look like the real parameters from the setup algorithm and the real proof from the prover in the real system. So this is a pretty important idea in cryptography to say that you learn nothing from the proof pi if you could have generated the proof pi on your own without anybody's help. And the way we prove that you can generate the proof pi on your own is through the existence of the simulator that's able to generate the proof pi and the parameters given only the statement x and nothing else. Formally, we state this using distributions.
00:53:24.954 - 00:54:18.202, Speaker A: So we'll say that an argument system SPV is honest verifier zero knowledge for circuit C. If there's an efficient simulator SIM such that for all statements if there exists a witness that makes the circuit zero, then in fact, if we look at the distribution over parameters produced by the Setup algorithm and distribution over proofs produced by the prover So we look at SP, SV, X and Pi. This distribution, this distribution is basically indistinguishable from the same distribution that is generated by the simulator, right? The simulator only takes x as. Input. It also is able to produce Sbsv and Pi. And these two distributions should be indistinguishable, which means that the simulator generated something that looks identical to what the real prover would have done. And since this can all be done without knowledge of the witness, it means that the proof Pi does not reveal anything about the witness.
00:54:18.202 - 00:54:49.218, Speaker A: So this was just a quick, very quick overview about how these things are actually defined. And so the next question that you probably have in mind is, how do we build a ZK snark? Yeah, it's a very good question. Right. So, again, we'd like to build a zero knowledge preprocessing argument system where the proofs are short and the proofs are very fast to verify. So how do we build this magical ZK snark? And I have to say, this is a beautiful, beautiful topic. The ZK snark constructions use very, very pretty math. It's quite elegant.
00:54:49.218 - 00:55:26.110, Speaker A: But unfortunately, I don't have time to do that in this lecture. If you're interested in seeing how ZK snarks work, there's a lot of material online. In particular, I would point you to my course on blockchains CS 251. And in the course materials, we devote an entire lecture to construct to showing how ZK snarks work. Yeah, so you can see exactly how they're built there. Okay, so this is what I wanted to say about what ZK snarks are, how we define them formally. And what I'd like to discuss in the remaining part of the lecture is basically how to use zkSNARKs to provide private transactions on a public blockchain.
00:55:26.110 - 00:55:57.806, Speaker A: So, yeah, see you in a few minutes. Now that we know about zero knowledge, proofs and commitment schemes, I want to take the first step towards private transactions on a public blockchain. And I want to tell you about something called confidential transactions. So let's think back to the Bitcoin blockchain. And as you remember, in Bitcoin, every transaction reveals the complete payment details in the transaction. So here is an example transaction for you, and you can see exactly what are the source addresses into this transaction. You can see exactly how much each address is paying.
00:55:57.806 - 00:56:39.734, Speaker A: You can see what the destination addresses are, and you can see exactly how much each address will receive. And this information is public for the whole world to see. This, unfortunately, means that business will find it difficult to use Bitcoin for business transactions. For example, if they want to pay their suppliers in a cryptocurrency like this, that would mean that the whole world would see how much they're paying their suppliers for parts and businesses in general would prefer to keep this information private. Similarly, if a company wants to pay its employees in a cryptocurrency like this, it would mean that the whole world would see the employee's salary. And again, this is information that we'd like to keep private. So the goal for this segment is basically to modify Bitcoin transaction structure.
00:56:39.734 - 00:57:18.770, Speaker A: A little bit so that the addresses where the funds are coming from and going to will remain public, but the amounts that are being transacted will become secret. So, for example, if Alice works at a particular company, everybody knows that she's going to be paid her salary once a month. So there'll be a transaction from the company to Alice, but the exact salary will be hidden and not known to the entire world. Only the company and Alice will know what Alice's salary is. Yeah. So our goal is to hide the amounts in Bitcoin transactions, but not the addresses. We're going to talk about how to provide privacy for sources and destinations in the next segment.
00:57:18.770 - 00:57:53.358, Speaker A: One thing I want to point out is that even though we're going to be hiding transaction amounts, we're not going to be hiding the transaction fees. And the reason for this is because miners are the ones that receive the transaction fees and they need to see those amounts in the clear. So our goal is just to hide the core transaction amounts, but not the transaction fees. So how are we going to do this? Let's look at one example Bitcoin transaction. Suppose the Acme company has a UTXO worth 30 coins. It sends one coin to Alice, and then it sends 29 coins back to itself. This would be an example Bitcoin transaction.
00:57:53.358 - 00:58:22.714, Speaker A: The idea in confidential transactions in CT is that we're going to replace the actual amounts in the transaction by commitments to those amounts. Okay? So rather than writing the amounts in the clear, we're going to write commitments into the transactions. So here you can see commitment number one is a commitment to the number 30. Commitment number two is a commitment to the number one. And commitment number three is a commitment to the number 29. Yeah. So you can see that rather than writing the numbers in a clear, we're actually writing commitments into the transactions.
00:58:22.714 - 00:59:04.474, Speaker A: So now if you look at the transaction structure, the actual transaction amounts are just commitments which reveal nothing about the actual amounts that were transferred. And again, I stress that the fees themselves are still kept in the clear. Yeah. So that's kind of the idea of confidential transactions CT. We're going to replace transaction values in the clear with commitments to those transaction values. So now you're probably wondering, well, if the miners can't see the transaction amounts, how are they going to verify the transaction? How do they know that the amount of funds that was put into that transaction is equal to the amount of funds that's being taken out of the transaction, right? So that no money is being created and no money is being lost. So let's see how we do this.
00:59:04.474 - 00:59:42.162, Speaker A: So again, here we have our commitments. Commitment one, commitment two, and commitment three. You can see commitment one is a commitment to the number 30. Commitment two is a commitment to the number one, and so on and so forth. I'm going to refer to these numbers as M one, M Two, and M three, just to be a little bit more general. So the idea in CT is that whoever creates this transaction is also going to create a zero knowledge proof that the transaction is well formed. So this is an example of a general ZK snark, although, as we'll see in a minute, there are special purpose zero knowledge proofs just for proving this type of statement, namely that the transaction is valid that are actually a little simpler and more efficient than general purpose ZK snarks.
00:59:42.162 - 01:00:19.138, Speaker A: But let's see how we might use a ZK snark here to prove that the transaction is valid. So what the Acme company will do is it will send the commitment to R two to Alice. So Alice will know the amount of funds that it received. It will know that it actually received one bitcoin in this case, and then it will construct a succinct zero knowledge proof pi for the following statement. Okay, so the public value is the three commitments and the fees. Yeah, that's the statement we're proving. The witness for the statement are the actual private amounts that are being transacted and the opening of these commitments r One, R Two, R three.
01:00:19.138 - 01:00:58.314, Speaker A: And what is it that we're proving? We're proving that there's a circuit that evaluates to zero on the statement X and the witness W. So what is this circuit checking for? Well, first of all, we check that commitment one, commitment two, and commitment Three really are commitments to M one, R One, M Two, R Two, and M Three. R three, just as the witness claims. Okay. So the commitments are well structured that, in fact, the sum of the outputs plus the fees is equal to the inputs to the transaction. So no funds were created in this transaction and no funds were lost in this transaction. And third, and actually, very importantly, is that M two and M three are both positives.
01:00:58.314 - 01:01:24.182, Speaker A: Right. So these UTXOs that we're creating here are UTXOs to positive values. The reason this is so important is if it so happens that M three was negative, then M two could be much bigger than the input amount, in which case condition two might still be satisfied. But we'll now have a UTXO that's worth more than the input to the transaction. So money was created out of thin air. Yeah. So condition three here is actually very, very important to prove as well.
01:01:24.182 - 01:01:53.902, Speaker A: So that's kind of the idea. So whoever creates the transaction is going to create this ZK snark proof to say that these three conditions are actually satisfied by the transaction. So really? Right. So we're going to send R two to Alice. So Alice will be able to open her own commitment. The Acme company will construct the zero knowledge proof, as we just said, and then it's going to embed the proof into the transaction. And this is actually why we want a succinct zero knowledge proof, because we'd like the transactions to be as short as possible.
01:01:53.902 - 01:02:45.970, Speaker A: So we want the proofs to be as short as possible, and we want them also to be easy to verify so that the miners don't have to work too hard in order to verify these proofs. Okay? So now the new transaction format is going to include the proof Pi, the Snark proof Pi, and it's going to include the three commitments and the corresponding addresses. The miners, what they will do is they will accept a transaction if the zero knowledge proof is valid. Okay? And this is why we want fast verification so they don't have to work too hard. The interesting thing is that now the miners and the rest of the world learn that the transaction is valid, but they learn nothing at all about the amounts that are being exchanged in this transaction. That's kind of the idea. So it's kind of clever that we can replace clear text values by commitments and then just prove that the commitments are valid so that the transaction overall must be valid.
01:02:45.970 - 01:03:28.442, Speaker A: Now, it turns out that for the CT arithmetic circuit in question here, we can actually produce a ZK Snark proof more efficiently than going through the general ZK Snark machinery. So let's see how. So, in our discussion of commitments, we talked about Pedersen commitments, which, as you may remember, allow us to compute uncommitted data. So what we're going to do here is we're going to use Pederson commitments to commit to the amounts m one, M two, and M three. And now we're going to compute on the committed data. So we're going to compute this expression here, comm one divided by comm two times, comms three times due to the fees. And this actually gives us a commitment to the value m one minus m two minus M three minus fees.
01:03:28.442 - 01:04:04.886, Speaker A: Yeah. So now we get a commitment to this quantity, which we just computed from the commitment in the transaction. And then what the Acme company will do is just prove that this commitment is, in fact, a commitment to zero, and that will prove that condition two holds. So condition two is quite easy to check just by using the homomorphic property of Peterson commitments. And so really, we don't need to include condition two in our ZK Snark proof. And it turns out the rest of the proof is actually quite short, proving statement one. And statement three can be done using a relatively short proof.
01:04:04.886 - 01:04:34.638, Speaker A: That's about 400 bytes. And that means that really, the additional data that's embedded in the transaction is just 400 more bytes. Yeah. So this is pretty interesting. And in fact, I'll tell you that confidential transactions CT is the beginning of a mechanism called Mimble Wimble, which is a general optimization on Bitcoin, which also provides some level of privacy. And this is actually implemented in the Grin blockchain. So in this segment, we saw how to provide privacy for the transaction amounts embedded in transactions.
01:04:34.638 - 01:05:01.302, Speaker A: In the next segment, we're actually going to look at how to provide anonymous payments, where even the sources and the destinations of the amounts remain private. So I'll see you in a few minutes. In this segment, I want to show you how fully anonymous payment systems work. In particular, I want to show you how the Tornado Cash system works. And we'll also talk about Zcash and Ironfish. So let's begin with Tornado Cache, which is a zero knowledge based mixer. Tornado cache runs on the ethereum blockchain.
01:05:01.302 - 01:05:34.662, Speaker A: It was launched in May of 2020, and it's gotten a fair amount of use since then. And I want to show you how it works. So Tornado Cash is basically an address on the Ethereum blockchain. And imagine Alice has her own account on the Ethereum blockchain. At any point in time, she could send funds to the Tornado Cash contract. So in this case, she sends 3000 die to the contract in three separate transactions, each one worth 1000 die. Now, she can keep her funds in the Tornado Cash contract for as long as she wants.
01:05:34.662 - 01:06:18.014, Speaker A: And in the meantime, other people might send their own funds to the contract. Now, let's say sometime later, maybe a week, a month, a year later, alice decides to withdraw her funds from the Tornado Cash contract. She'll prove to the contract that she owns 3000 die in the contract, and she'll provide an address where to deposit those funds. The Tornado Cash contract will send her 3000 die to the address that she provided. But the point is that now nobody knows that this address actually is affiliated with Alice. So she now has 3000 die sitting in this address that she controls, but nobody knows who this address belongs to. Alice can then use those funds, for example, to interact with an NFT market and privately buy an NFT.
01:06:18.014 - 01:06:45.470, Speaker A: She'll own the NFT, but nobody will know who actually owns this NFT. Yeah, so that's what Tornado Cash allows you to do. And one thing that I wanted to point out is the reason all these transactions are for the same amount. They're all say for 1000 die. The reason for that is for privacy reasons. And the reason it's necessary is if Alice was allowed to send 1005.3 die to the contract and later she would withdraw 1003.5
01:06:45.470 - 01:07:22.742, Speaker A: die from the contract, then those transaction values would create a link between the fresh address and Alice's original address. And so to make sure that there's no link between the original address and the fresh address, we make sure that all the transaction amounts in and out of the contract are for the same amount. In this case, 1000 die. Okay, so now let's see how the Tornado Cash contract actually works. So Tornado Cash actually has a pool for different denominations. Here we'll look at the 100 die pool so all deposits and withdrawals into this pool are going to be for 100 die. Now, the Tornado cash contracts shown over here, of course it maintains its own balance.
01:07:22.742 - 01:07:53.794, Speaker A: So let's say that it has a treasury. And let's say that right now the treasury contains 300 die, which means that three coins were deposited into the contract, right? Each coin is worth 100 die. So if the treasury is 300 die, then three coins were deposited. Now, in addition, the Tornado cash contract is going to manage a merkel route. We call this the coins Merkel routes. And what this merkel tree contains is basically the list of coins in the contract so far. So these coins are basically inserted from left to right.
01:07:53.794 - 01:08:19.894, Speaker A: So the first coin goes in the leftmost leaf of the tree. And then we keep expanding from left to right as coins are added. This tree has height 20, which means that there are two to the 20 total leaves in the tree. And as new coins get added, they get sequentially added to the leaves of this tree. Now we compute the merkel hash of the current state of the tree. This gives us the coin's merkel root. And this coin's merkel root is stored in the state of the Tornado cache contract.
01:08:19.894 - 01:08:52.182, Speaker A: It's only 32 bytes, so it takes very little space. In addition, the Tornado cache contract maintains a little bit more state. It maintains a variable called Next, which is where the next coin is going to be inserted into the tree. In this case, the next coin will be inserted into position four, and it also contains the Merkel proof for position four. Right? So if you remember, a Merkel proof basically contains the list of hashes from this leaf to the root. And so the contract also stores this merkel proof. This merkel proof contains 20 hashes and they're stored in the contract state.
01:08:52.182 - 01:09:11.766, Speaker A: In addition, the contract actually maintains a list of nullifiers. We'll see what these nullifiers are for in just a minute. So to summarize, there are currently three coins in the pool. The contract has 300 dies. And as you can see, currently there are two nullifiers inside the contract. So that's the state of the contract. Now, for what's coming, we're going to need two hash functions.
01:09:11.766 - 01:09:34.702, Speaker A: We'll denote them by h one and h two. They map some randomness space to 256 bits. In other words, they take some value in R and output a 32 byte value. So just remember, we'll be using these h one and h two from now on. So now let's talk about the deposit process. So suppose Alice wants to deposit 100 die into the Tornado cash contract. What she'll do is the following.
01:09:34.702 - 01:10:01.002, Speaker A: First of all, she'll choose a random key K and the random nonce R from the randomness space R. So both K and R live in R. Then she'll compute the new coin C four. And this new coin is simply just the hash of K and R. So it's H one of K concatenated with R. Okay, so C four is a simple 32 byte value. She's going to write the value C four into the fourth leaf in the tree where it's supposed to go.
01:10:01.002 - 01:10:41.366, Speaker A: This is the next open slot, so that's where the coin will go. And then she's going to compute the merkel proof for the next slot for position five in the tree. Again, remember, the merkel proof for slot number five is simply the list of hashes from slot number five all the way to the root. Okay? So again, this proof pi contains 20 hashes that Alice computes. So you can see that she writes C four into this tree, computes the updated merkel root and computes the merkel proof for slot number five relative to this new tree. Then she goes ahead and sends her 100 die to the contract. In addition, she sends the new coin C four to the contract as well as the merkel proof for position five.
01:10:41.366 - 01:11:21.670, Speaker A: Now let's see what the contract does with this data. So here again, we can see the 100 dies that she sends in. She sends in the coin C four and she sends in the merkel proof pi. What does the contract do? So here we're focusing on just the relevant part of the Tornado contract state. Well, the contract is going to use C four and the merkel proof that it has stored in the contract state basically to compute the updated merkel roots. It's not that difficult to see that given the proof for position four, which the contract actually has, as well as the new value C four, it's quite easy to compute the updated merkel root. Then it's going to verify that the merkel proof that Alice provided for position five is correct.
01:11:21.670 - 01:11:54.382, Speaker A: So it's consistent with the updated merkel route. And if everything is valid, the contract is going to update its own state. So let's look at the new updated state for the contract. So first of all, the treasury now is worth 400 die. It went up from 300 to 400 because Alice deposited 100 die. Second of all, it stores the updated merkel route that the contract computed using the previous merkel proof of position four that was stored in the contract and C four. And finally, it updates the value of next to five and stores the merkel proof of position five that Alice sent to it.
01:11:54.382 - 01:12:19.734, Speaker A: And now you can see that the contract is in a perfect state to receive the next coin. It has the updated merkle root, the value next is pointing to five and it has the merkel proof for position five. So it's all ready to receive the next coin. However, Alice needs to do one more thing. Alice stores the values K and R that she generated secretly. Remember, K and R each was 32 bytes. So overall this note is 64 bytes total.
01:12:19.734 - 01:13:00.514, Speaker A: So it's relatively little data that Alice needs to keep, but she does need to keep the secret. And this is called the note that corresponds to the 100 die that she just deposited. And I want to emphasize that there's one note per coin. So every time she deposits 100 die, she'll generate a new note for those hundred dies. So to summarize, you can see that for every deposit into the contract, we create a new coin on the tree and these coins are added sequentially to the tree. And what's important is that an observer who looks at the state of the contract can easily tell which coin belongs to who, right? The observer saw that Alice added c four to the contract. And so the observer knows that c four actually belongs to Alice.
01:13:00.514 - 01:13:33.962, Speaker A: So I want you to remember, observer knows exactly which coin belongs to which user. So now let's talk about the withdrawal process. So Bob comes along and let's just say that Bob owns coin number three in the tree. Okay? So he has a note for coin number three which will denote by k prime and R prime. And let's see how he uses this note to withdraw his 100 die that correspond to coin C three. The first thing he does is he's going to compute what's called the nullifier. So the nullifier is basically the hash function h two applied to the key k prime.
01:13:33.962 - 01:14:15.402, Speaker A: Next, Bob is going to prove to the contract that it has a note, k prime, R prime for some leaf in the coins tree. And the nullifier for that leaf is the value NF that we just computed over here. The important thing is this proof is not going to reveal which coin. So Bob proves I have a note for some coin in the tree without saying anything about which coin in the tree belongs to Bob. And moreover, Bob will prove that the nullifier for the coin that he owns is in fact this value NF, which is going to become public. Yeah, this value NF is going to be sent to the contract and is going to be added to the list of nullifiers so it will become public. So let's see how Bob constructs this zero knowledge proof that it owns a coin in the tree.
01:14:15.402 - 01:15:00.954, Speaker A: So here he has his note, k prime, R prime. Here's the nullifier that Bob computed. Now he's going to produce a ZK snark for the following statement. So the public element in the statement is the root of the merkel tree which is stored in the state of the contract, the nullifier NF that Bob just computed, and an address A, where Bob wants the hundred die to be sent. So this address A is this fresh address that's not supposed to be associated with Bob in any way. So that's the public statement. The secret witness that Bob is going to use to prove the statement is his note, k prime, R prime, the value of the coin C three, and then a merkel proof to prove that c three really is part of the tree relative to the current state of the root that's stored in the contract state.
01:15:00.954 - 01:15:52.102, Speaker A: Okay? So the circuit that's used to verify the statement and the witness will check the following facts. First of all, it will check that c three really is leaf number three in the root. In other words, the circuit will check that the provided merkel proof and the witness really is a valid merkel proof for coin number three. So now, once this condition is verified, we know that the secret c three really is part of the coin's merkel tree. Next, we verify that the note that Bob has really is a note for C three, namely that c three is equal to the hash of K prime concatenated with R prime. And finally, we verify that the nullifier was computed correctly, namely, it's the hash of K prime. All right? So the circuit will check these three things, and what Bob will do is it will produce a zero knowledge proof pi that, in fact, it has a witness that satisfies this circuit relative to this public statement.
01:15:52.102 - 01:16:39.386, Speaker A: One thing I want to point out is the address A that Bob provided is in fact part of the statement. But you notice that the circuit never used the address A. So why do we put the address A in here? And the reason we do that is to make sure that no one can modify the address to which the 100 die will be sent by the contract. So just to reiterate, the address A is part of the statement to ensure that the miners cannot change the address where the funds will be sent. But this actually assumes an interesting property of a Snark that we haven't seen before. This property is called non malleability. We are basically assuming that if I give you a proof pi for a statement X, namely the statement X here is containing the address that Bob supplied, no one can build a proof a valid proof pi prime for some other statement X prime that's not equal to X.
01:16:39.386 - 01:17:11.654, Speaker A: For example, a statement X prime where A is replaced by the miner's address. So this property is called a non malleability. And in fact, the Snark that Tornado Cash uses is non malleable. So this property actually holds. So now that Bob constructed this ZK snark proof, he's going to send the nullifier, the proof and the address over to the contract, and he's going to have to do this over Tor so as not to reveal his identity. Yeah, so it's very important that Bob's identity and the coin c three that's being spent are not revealed. And this is why we needed a zero knowledge proof so that the proof pi doesn't reveal anything about c three.
01:17:11.654 - 01:17:55.694, Speaker A: And we need to send this over Tor so that nobody learns that this is Bob that's asking for the coin to be spent. What does the contract do? The contract checks that the proof pi is valid relative to this statement. And very importantly, the contract also verifies that the nullifier that was supplied is not already in the nullifier list. This proves basically that this coin that's being spent has not been spent before. So even though we don't know what coin is being spent, the fact that the nullifier is not currently on the nullifier list means that the coin has not been previously spent. Now, what does the contract do? Now it's convinced that Bob owns some coin that has not been spent before. So it goes ahead and sends the 100 die to the address that Bob provided.
01:17:55.694 - 01:18:45.698, Speaker A: So therefore now you can see the treasury now is reduced to only 300 die and the contract goes ahead and adds the nullifier to the nullifier list. So what just happened here is that the nullifier and the proof reveal nothing about which coin was spent. However, coin number three can never be spent again before because if somebody does try to spend coin number three again, they'll compute the nullifier as a hash of K prime. But this nullifier is now nullified because it's on the nullifiers list. So it's kind of cool that we don't know which coin was spent but we know that it can never be spent again. I do want to stress that the function h one is a collision resistant hash function and that means that we can only ever know one pre image of the coin C three. So we can only know one K prime R prime that will hash to C three.
01:18:45.698 - 01:19:41.410, Speaker A: And that ensures that in fact if anyone tries to spend the coin C three again they will necessarily end up with the same nullifier that Bob just obtained and therefore they cannot spend the coin C three again because the nullifier is now included in the nullifier list. So to summarize, it's pretty interesting what's happening here in that we have a list of public coins. The whole world knows which coin belongs to which user. However, an observer can't tell which coins are active and which coins are spent. So when you withdraw one of your coins, nobody knows that it's you who withdrew the coin and nobody knows which coin you actually withdrew. And therefore the address a where the funds were spent could have belonged to anyone who has ever deposited funds into the Tornado cash contract. So the anonymity set for Bob is basically equal to the number of people who deposited funds to the Tornado Cash contract.
01:19:41.410 - 01:20:13.706, Speaker A: And it's worth pointing out that there is an upper limit here of ten to the 20. So about a million people. Now, there's one more problem we have to deal with and that's the question of who pays the gas for the withdrawal transaction, right? Every transaction with an ethereum contract requires gas. So. The question is, who pays for that gas? If Bob paid for the gas from his own account, that would create a link between the new address and Bob's account, which is exactly what we don't want. So we cannot have Bob pay for the gas. We need somebody else to pay for the gas.
01:20:13.706 - 01:20:44.442, Speaker A: And Tornado solution is to use what's called a relay. So here's how the relay system works. Bob is not going to send his message to the contract. Instead, he's going to send his message to a relay server, just somebody who's providing service out there. And again, he's going to do this over Tor so he doesn't reveal who he is. The relay is actually the one that's going to send the message to the Tornado contract, and the relay is going to pay for the gas for this transaction. So now the relay actually paid for something, so he needs to be refunded for that.
01:20:44.442 - 01:21:28.454, Speaker A: And the way we refund the relay is through the withdrawal transaction. So what Bob will actually get into address A is 100 die minus the gas that the relay had to pay for, and the relay will get his gas costs back. Okay, so this is a simple way in which Bob can receive his funds into this address A. Nobody knows that this address A is associated with Bob and the relay got paid. Of course, one should note that there are always service fees involved here. So actually the amount that's actually deposited into address A will be slightly less than 100 minus the gas, because both the relay and the Tornado contract will charge a small fee for the service they provided. So that's basically how the Tornado Cash contract works.
01:21:28.454 - 01:21:58.606, Speaker A: Next, let's look at the Tornado cache user interface. So you can choose which token to send Tornado Cash. In this case, we chose die. You can choose which pool to contribute to. In this case, we chose the 1000 die pool. And once a deposit is made, you basically get a note to say, yes, the deposit is made and this note will let you withdraw it. At a later time, you can enter your note into the UI, specify the address where you want the deposit to be sent, and the Tornado Cash contract will send 1000 I to the address that you specified.
01:21:58.606 - 01:22:31.434, Speaker A: Presumably it's a fresh address, and so nobody will know that that address is associated with you. One thing that's important to remember is if someone deposits funds into the Tornado Cash contract and immediately withdraws them, that creates a strong connection between the recipient address and the depositor. So depositing an amount and immediately withdrawing it would basically destroy the privacy properties provided by the contract. So now you can see that the Tornado Cash contract is fairly active. There are currently about 88,000 leaves occupied. There are about $3 billion deposited into the contract. People can deposit more.
01:22:31.434 - 01:23:12.182, Speaker A: People can withdraw their deposits, and presumably if there's enough gap between the deposit time and the withdrawal time, then there's privacy for the people withdrawing those funds. Now, the Tornado Cash contract also provides a very interesting compliance tool. So suppose you withdrew your funds into an anonymous ethereum address and then you wanted to take those funds and deposit them into an exchange, like deposit them into Coinbase. Well, Coinbase has to abide by financial regulations like Know Your Customer or the travel Rule. So it can't accept funds that are coming from an anonymous address. It has to know where the funds are coming from. So Tornado Cash built a compliance tool that works as follows.
01:23:12.182 - 01:24:13.182, Speaker A: After you have withdrawn your Coin from Tornado Cash, you can go to the compliance tool and enter your notes, your secret note, which is no longer secret because the coin was withdrawn, but you can enter your note into this tool. And what the tool will do is it will basically de anonymize the address where the funds were sent. So it will produce a report that says, here's where the funds came from, here's where the funds went to, and now you can go and present that to Coinbase and then they will ah, now we understand where the funds that you're depositing into our exchange came from, so we can accept those funds. So that's a compliance tool, basically that allows you to de anonymize an address if you need to deposit the funds into a regulated exchange. Of course, if you want to simply go and buy an NFT and do so privately, you don't have to do this. You can just interact with one of the smart contracts that implements an NFT marketplace and buy the NFT privately without revealing who you are. So that's all I wanted to say about Tornado Cash.
01:24:13.182 - 01:24:49.670, Speaker A: I also wanted to mention two other systems called Zcash and Ironfish. They're very similar to one another. These are layer one blockchains that extend the bitcoin blockchain Sapling, which is basically Zcash. Version two was launched in August 2018 and it's been active ever since. The goal of Ironfish is to reimplement Sapling and provide a very easy to user interface. It's currently in testnet and hopefully will launch soon. Now, these systems basically make use of the same idea of nullifiers that we just saw where nullifiers are published and prevent double spending of a coin, but they don't reveal which coin was actually spent.
01:24:49.670 - 01:25:26.658, Speaker A: These systems are slightly more complicated. So I think I'm actually going to skip the detailed description of how they work, although the description is in the slide deck in case any of you want to see the details of how they work. So this brings us to the end of our lecture on privacy. Let's do a quick review of what we discussed. So the main tool for privacy on the blockchain is called a Zksnarc. It's a fantastic tool. It's really quite magical that this is possible, basically given a public statement X, a prover can produce a proof pi that convinces the verifier that the prover knows a witness w that causes the circuit to output zero.
01:25:26.658 - 01:26:02.810, Speaker A: And the amazing thing is, the proof pi is really short and it's really fast to verify, no matter how complicated the circuit C is. We can convince the verifier of very complicated statements using very short proofs that are very fast to verify. And this has been a tremendously important tool for providing privacy on the blockchain. We saw that it can be used for providing private payments. It turns out it can also be used for providing privacy for business logic. We also mentioned that Zksnard can be used for private compliance. I gave a couple of examples early on in the lecture, and I'll also mention that it can be used for L2 scalability.
01:26:02.810 - 01:26:44.282, Speaker A: In particular, in the context of ZK rollups, we can use ZK snarks to build ZK rollups with better privacy. There are a couple of thoughts I'd like to leave you with. During the course, we talked about decentralized organizations, and one question is, could we have private participation in a Dao? Similarly, many of the DeFi projects we talked about have a governance mechanism. And the question is, could you participate in the governance mechanism privately without actually revealing who you are? So these are kind of interesting topics to think about for possible future work or maybe even future research. Now, the world of blockchain privacy, and ZK snarks in particular, is fairly large. And we really only covered the tip of the iceberg here. There are many further topics that you can study in this area.
01:26:44.282 - 01:27:15.362, Speaker A: There's a lot of information about this online, so I just wanted to let you know about a few more things that you can look up in case you want to learn more. The first one, of course, is how to actually build a ZK snark and how they actually operate. As I mentioned earlier, there's really beautiful mathematics involved. So I encourage all of you to go and look at how ZK snarks actually work. Another idea is a variation of ZK snarks called a recursive snark. In a recursive snark, what we do is we don't prove knowledge of a witness. We prove knowledge of a proof of knowledge of a witness.
01:27:15.362 - 01:27:55.300, Speaker A: And it turns out these recursive snarks actually are quite useful. They have a lot of applications, in particular in the area of keeping business logic private. The last topic I'll mention in the area of privacy is this question of how do you privately communicate with the blockchain? And in particular, if you're going to be using proxies for relaying your traffic, how do you pay those proxies to relay your traffic without revealing who you are? And so, if you're interested in private interaction with a blockchain, there's a system called NIM that actually looks at private compensation. And so I would suggest looking at how NIM actually works. All right, so I'll stop here. I hope you enjoyed the lecture, and I hope you enjoy the rest of the course. So good bye, everyone.
