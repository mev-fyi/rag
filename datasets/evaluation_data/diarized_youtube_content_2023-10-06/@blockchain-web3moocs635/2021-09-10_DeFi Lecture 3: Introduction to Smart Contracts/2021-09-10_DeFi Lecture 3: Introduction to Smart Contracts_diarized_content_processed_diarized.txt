00:00:01.290 - 00:00:43.158, Speaker A: Welcome back to the DeFi MOOC. My name is Andrew Miller and I'm going to be giving the lecture on an introduction to smart contracts. So the outline for what this lecture is going to be is the following. We're going to start by talking about smart contracts from a high level point of view and focusing on them as the programming framework that programmers would see when they are trying to build programs to run on the blockchain. The main idea here is that you shouldn't even think about smart contracts as contracts. They're neither smart nor are they contracts. Instead, just think of smart contracts as the program objects that live on the blockchain.
00:00:43.158 - 00:01:30.490, Speaker A: Or to use Dan's notion from the last lecture, smart contracts are the programs that run on the blockchain computer. After the high level conceptual overview, we'll talk about the basics of solidity programming in Ethereum. We're not going to go very deep into how the solidity programming language works. Instead, we're just going to be focusing on giving you enough about it that you can follow the DeFi examples that we'll see later on in the course. We'll go into some detail on making a case study out of the CryptoKitties auction mechanism. So if you're interested in the current craze around NFTs, then you'll want to know about how this works. Because CryptoKitties were probably the first successful NFT on a blockchain.
00:01:30.490 - 00:01:48.014, Speaker A: We'll talk a little bit about how you could think of a comparison between smart contracts and legal contracts. And finally, we'll delve into one of the most important kinds of smart contracts, which are tokens. We'll talk about fungible tokens and non fungible tokens as well.
00:01:48.212 - 00:02:54.290, Speaker B: First, we're going to look at a high level view of smart contracts conceptually from the programmer's point of view. So from the opening segments on blockchain technology, you should have an understanding of the digital asset or cryptocurrency applications. You can build on top of a blockchain, where the blockchain is a consensus system that is keeping track of account balances for all of the different user accounts in the system. And the users can interact with this public consensus system by transferring portions of their digital asset money amongst themselves according to the rules of the application. Now, to think about smart contracts, the way to think about them is that it is a generalization of this digital asset application. And it's a generalization because you can now make instead of keeping track of accounts, the blockchain is keeping track of user defined program objects called contracts. So what we call smart contracts are really program objects that live on the blockchain.
00:02:54.290 - 00:03:56.070, Speaker B: And each program object consists of two parts. It consists of some code describing what to do when users interact with it and it contains or it describes storage, like a file or a memory space. Sometimes we call it the state. But anyway, it's some persistent data that is stored for the contract and kept track of by the blockchain. Now, in addition to transferring digital assets between users in the systems, users can also interact with these contract objects by passing them input data and invoking functions or methods defined in the code for these contract objects. So you can think of this as like an operating system where the processes in the operating system are the smart contracts and the objects in this operating system can interact with each other and they can take input from users and they can provide output to users. And their code describes how they process the inputs and how they will update their storage.
00:03:56.070 - 00:04:03.578, Speaker B: Now, it's helpful to go straight to an example of a fragment of Smart contract code.
00:04:03.664 - 00:04:06.134, Speaker A: So this is in solidity.
00:04:06.182 - 00:04:37.640, Speaker B: We'll talk more about that later. It's defining one contract called my registry. So that's defining an object in this. It's defining one program object that will run on this blockchain operating system. And what we said is that every contract object consists of some storage. So here the code is defining a registry file. So it's a mapping from strings like domain names to addresses like the account of who's going to own that name.
00:04:37.640 - 00:05:23.954, Speaker B: And in addition to the storage, the smart contract also defines the code for methods that handle input from users. So in this case, this registry contract has a single method called register domain. And you can call it passing in a string as a parameter. And you call register domain with the string domain in order to register that domain to take it for yourself. Now, in the body of this function, what it is describing it's doing is first of all, it's going to check that the domain you're trying to register is currently not assigned to anyone. So by default, everything in this registry will be mapped to zero, meaning no one owns it. And so this is going to be checking that that's the case.
00:05:23.954 - 00:06:21.190, Speaker B: No one owns this domain yet. And then the next line of this program code is that it is going to update the storage file. It's going to update that registry variable by assigning the entry in this registry for domain to message sender, which stands for whoever is calling this register domain function. So in this way, when you call register domain, it's going to update the storage of this contract to say that you are now the owner of that domain. Now, just to give a depiction of what this looks like graphically, the contract object lives on the blockchain. It has registry as its storage and it has the register domain method. Someone who wants to go register the domain, say they're registering DFI IO, they will invoke the register domain method of that smart contract, passing that string in as a parameter.
00:06:21.190 - 00:07:05.966, Speaker B: And once this register domain function has been invoked, anyone in the network either looking at a Block Explorer or running their own full node, they can query the registry to look up who is the current owner of a given domain name they're interested in. So next, what I want to do is show you what an instance of the Smart Contract Object Domain Name Registry example would look like on the test network. So I have already previously compiled and put onto the blockchain an instance of this, my Registry object, and it lives on the Covan test network, which I can view in the Etherscan Block Explorer here. I could also view it by connecting a full node directly to the Covan test network.
00:07:06.078 - 00:07:07.174, Speaker A: But I'm just going to show you.
00:07:07.212 - 00:07:43.610, Speaker B: Here what it looks like on the test network through the Block Explorer. So what you can see is that there's a contract created with this address. It was created a couple of weeks ago to prepare for this course. And you can see the high level solidity source code for this Contract Object. It looks essentially the same as what I just showed you on the slide there. Now you can see the events that are associated with this Contract Object. So basically, I'm recording an event every time a domain has been registered.
00:07:43.610 - 00:07:54.530, Speaker B: And I can see it in this events tab of Etherscan. And I have to go adjust all of these. Essentially, this is showing me an event for who's registered which domain.
00:07:55.290 - 00:07:56.726, Speaker A: And you can see here that I.
00:07:56.748 - 00:09:06.870, Speaker B: Have registered with my address. I have registered the Berkeleydefi GitHub IO address in this little example domain name registry. So here the Block Explorer for the test network is showing me the state that has been changed associated with the Smart Contract Object as a result of invoking the register domain method on it. The next concept to talk about is interaction between contracts. So not only can a user go and invoke a method of a Contract object, but the code of the Contract object can also describe how to send messages and invoke methods of other contracts. So a common pattern that shows up is the idea of a multisig account where a few different users are jointly in control over the money held by this Contract Object. So there would be a Contract object describing their jointly held account, it would have some amount of money that it stores, and it would define a method that the owners of this account can use to approve a request.
00:09:06.870 - 00:10:05.630, Speaker B: So in order to approve a transaction request on this jointly held account, two or more of the owners of the account would have to invoke the Sign request method. Then the code for this Sign request method could in turn call a method of another contract that they want to interact with. So here the joint account contract is calling the Place bid method of some auction contract. And this had to be authorized by, say, two or more of those users who are the owners of it. Now, this auction contract in turn may further invoke methods of other contracts. So, for example, if these users jointly holding an account won an auction, they place the winning bid to buy an NFT digital asset. Well, then the auction contract might invoke the transfer token method of the digital asset contract in order to accept their money for the bid, but transfer them the NFT that they had won in the auction.
00:10:05.630 - 00:10:09.674, Speaker B: So this is really powerful. You can write code in the smart.
00:10:09.722 - 00:10:12.602, Speaker A: Contracts that not only update the local.
00:10:12.676 - 00:10:31.126, Speaker B: Storage associated with that smart contract, but that also invoke methods of other contracts that are all existing together, coexisting on this blockchain network. And this kind of ability to build up systems of smart contract objects that all interact with each other, this is.
00:10:31.148 - 00:10:32.678, Speaker A: One of the really important ways in.
00:10:32.684 - 00:11:21.160, Speaker B: Which the smart contract programming model is so flexible. And we'll see more examples of this later on as we build up to DeFi smart contracts. So, let's recap what we've talked about so far. We have talked about the high level idea that smart contracts are program objects living on the blockchain. And each program object is defined by a smart contract class in smart contract code. And it's defining both the storage that the smart contract stores that the blockchain is keeping track of for that smart contract. And this contract class also defines the program code that describes how the contract object reacts to inputs and method invocations made either by users or by other smart contracts on the system.
00:11:21.160 - 00:11:49.278, Speaker B: We have looked at how to define storage fields and functions and methods. We'll look at more syntax examples a little bit later on. We've also seen this concept of access control. So we saw a require method that checked that some conditions were met and it would cancel the transaction. It would not reserve the domain name in our example if it was already reserved. And in general, we saw how you can look at the sender, whoever it.
00:11:49.284 - 00:11:50.350, Speaker A: Is, you can look at the address.
00:11:50.420 - 00:12:10.920, Speaker B: Of who invoked a method which is also used in access control to, for example, make it so that only the owner of a domain name could transfer it to someone else. We've also talked about composition, basically how smart contract objects can interact with each other by invoking methods on each other. And we'll see more examples of this later on.
00:12:12.330 - 00:12:16.514, Speaker A: So let's leave with a short quiz.
00:12:16.562 - 00:12:59.042, Speaker B: Before the next section. So, here is the same registry example code and what I want you to think about is what could go wrong. I've given you this domain name example and even shown you a testnet instance of it. And it's a really simple domain name system. It just has that one register domain method which in turn only has two lines of code in it. So even if you don't fully understand every aspect of the smart contract programming language, maybe you can see enough and use your knowledge of blockchain systems from the earlier segments to think about what might go wrong. So there is at least one problem with this one vulnerability that this smart contract has.
00:12:59.042 - 00:13:02.166, Speaker B: So can you think about what would be the problem and what you might.
00:13:02.188 - 00:13:03.030, Speaker A: Do to fix it?
00:13:03.100 - 00:13:39.666, Speaker B: And in general also think about what is missing. This is a really simplistic domain name system. How could you imagine making this more useful? What other features would you expect a real domain name system to have? Now, what we're going to do is talk a bit about smart contract programming in Ethereum and in the Solidity smart contract programming language that goes with Ethereum. Now, this is just going to be an example. We'll go into some detail on Ethereum specifically, but all of the concepts and a lot of the developing experience will still carry over to other smart contract blockchain systems as well.
00:13:39.848 - 00:13:41.474, Speaker A: Now, the goal of this is just.
00:13:41.512 - 00:13:54.454, Speaker B: To give you enough information about Solidity programming that you can follow our discussions about the DeFi mechanisms and DeFi gadgets that we'll explain later. So the goal of this segment is.
00:13:54.492 - 00:13:58.086, Speaker A: To give you something useful to understand the examples, even if you don't have.
00:13:58.108 - 00:14:24.466, Speaker B: Any other programming experience. But if you do have prior programming experience, it might make it a little easier to understand some of the parts of Solidity that we're going to go through. The focus here is just going to be on talking about the unique parts of Solidity. So even if you're familiar with other programming languages like Java or Python, this should still have something useful for you. If you don't know that much about Solidity. The outline is going to be first.
00:14:24.488 - 00:14:26.574, Speaker A: We'Re going to talk about Solidity versus.
00:14:26.622 - 00:14:52.250, Speaker B: The Ethereum virtual machine. Then we're going to talk about data types and how you define function signatures and constructors in Solidity. Then we'll talk about some Solidity specific details including visibility and mutability modifiers, as well as how you can access blockchain metadata. We'll also look at how you can use Solidity to send and receive and transfer the built in Ethereum currency.
00:14:52.910 - 00:14:57.034, Speaker A: And finally we'll look at events for.
00:14:57.072 - 00:15:20.574, Speaker B: Logging and interaction between contracts in Solidity. After that we are going to go through an auction example from CryptoKitties. And later we'll go into some detail on the gas mechanism in Solidity. All of these are still not going to be enough for you to be an expert Solidity programmer. Again, the goal here is just to give you enough to be able to follow the examples.
00:15:20.622 - 00:15:22.258, Speaker A: So I'll give you a pointer to.
00:15:22.424 - 00:15:54.126, Speaker B: The documentation that you can use to understand this a bit better. So for now, first let's talk about something at a high level. So I've already shown you a couple of fragments of this high level programming language that's Solidity. And what happens is this high level language, Solidity, gets compiled down to something called Bytecode for the Ethereum virtual machine or EVM. And so you'll sometimes see both of these. We're mostly going to be looking at the solidity code like the one here. But sometimes we might be referring to.
00:15:54.148 - 00:15:56.814, Speaker A: Things that only make sense because they.
00:15:56.852 - 00:16:05.582, Speaker B: Are the Ethereum Virtual Machine bytecode. So what actually is on the Ethereum blockchain is compiled programs in the Ethereum Virtual Machine bytecode.
00:16:05.726 - 00:16:08.206, Speaker A: It is a lot like JVM bytecode.
00:16:08.398 - 00:16:22.818, Speaker B: Versus solidity corresponds to the Java high level programming language, the way that EVM bytecode corresponds to compiled JVM Java bytecode. So if you're familiar with Java, then that analogy might be a little bit helpful.
00:16:22.914 - 00:16:24.166, Speaker A: For now, just realize that if you.
00:16:24.188 - 00:17:12.758, Speaker B: See a bunch of code that has Jumpdest or Hex encoded numbers like this, you might be looking at bytecode for the Ethereum Virtual machine. And the Ethereum bytecode is what's actually kept on the Ethereum blockchain and what is actually executed by Ethereum validators and miners. But we're going to be looking mostly at the high level solidity code that gets compiled down. So the first observation about Solidity programming language is that it's statically typed. This is similar to Java, C, Rust, other languages like that, but unlike Python or JavaScript or other scripting languages that don't have static types. So what it means is that every expression and every variable in solidity is associated with a data type. It's again most helpful to go straight to an example.
00:17:12.758 - 00:17:20.490, Speaker B: So we'll look at an example of integer data types. There are more than two really, but.
00:17:20.560 - 00:17:23.254, Speaker A: At least these two Integer data types.
00:17:23.302 - 00:18:05.446, Speaker B: In Solidity, there's uint for an unsigned integer that's 256 bit large, and the signed integer also 256 bits. So this fragment of solidity code is a for loop and in this for loop is a variable declaration. So this is declaring the variable I and it's declaring it to be of the unsigned integer type. So unsigned integers are appropriate for counters things that don't go negative but might start at zero. So that makes sense that I is declared as an iterator value. In this for loop, it'll range from zero through nine. And in the body of this loop you can see it's initializing the balance of several users, ten of them.
00:18:05.446 - 00:18:24.000, Speaker B: You can't tell yet just from this code whether this user I balance is an unsigned integer or a signed integer. If it's a balance, maybe it's appropriate to be an unsigned integer if the balance can't go negative. But you can't tell what it is just by looking at this code. Here.
00:18:25.970 - 00:18:28.000, Speaker A: We'll talk about one other data type.
00:18:28.530 - 00:18:34.062, Speaker B: Although there are many other data types, we'll talk about one more here and we will talk about the mapping data type.
00:18:34.116 - 00:18:36.946, Speaker A: This one's really useful. So we're just going to talk about.
00:18:36.968 - 00:19:10.038, Speaker B: It a bit here. So this is similar to a dictionary or a hash table data type like you see in other programming languages. One difference here is that every key is initially mapped to zero. So when you declare a variable of a mapping type, you have to specify the key type and the value type. So the key type is to the left of this little arrow glyph. So here we're defining a registry that maps strings to addresses. So the keys are strings and the values are addresses.
00:19:10.038 - 00:19:33.634, Speaker B: And this makes sense for our domain name example because we were mapping domain names which were strings to an address, that is the public key address of the owner of that domain name. Now, because every key is initially mapped to zero, what that means is that this mapping doesn't have any notion of the number of mappings or the size.
00:19:33.752 - 00:19:37.814, Speaker A: Of the data structure. You can think of it as a.
00:19:37.852 - 00:19:45.000, Speaker B: Default dictionary like you might use in Python. Basically every key is initially mapped to the zero value.
00:19:46.090 - 00:19:48.440, Speaker A: And so the only way that you.
00:19:49.130 - 00:20:33.414, Speaker B: Add to this data structure is by setting some value from zero to a nonzero value. If you wanted to keep track of the nonzero values or the number of nonzero values in this mapping data structure, you would want to hold a separate variable that you increment every time you set an entry in this mapping from a zero value to a nonzero value. Next we're going to look at functions in Solidity. So zooming out from statements and for loops, other code fragments. The code of smart contract objects are always contained within functions or methods. And this should look fairly similar if you're familiar with functions in Java or.
00:20:33.452 - 00:20:35.410, Speaker A: Python, lots of other languages.
00:20:35.570 - 00:21:19.654, Speaker B: The function definition has several components, most of which are probably familiar to you. So this is a function with the name Get current price and you can see it takes an argument list. This is taking a sliding window size and an integer. This would be some financial average price computing gadget. Now, a solidity specific component of this function signature is the public visibility modifier. So we'll talk about visibility modifiers in a moment, but this is basically indicating who is allowed to call this method of the object. Is it anyone or is it only other methods within this contract? You'll also see this view or pure, something like that.
00:21:19.654 - 00:21:53.374, Speaker B: These are mutability modifiers and we'll talk more about those in a moment as well. These are basically annotating whether or not the function can modify state, whether it needs to actually be committed as a transaction, or whether it's something you could compute just from your local copy of the blockchain without actually having to change anything on the blockchain to compute it. In addition to those modifiers, you will also see a return type. Now, this is a little bit different than the syntax of C or Java because Solidity supports multiple return type values.
00:21:53.502 - 00:21:55.714, Speaker A: So here it's showing that this get.
00:21:55.752 - 00:22:44.522, Speaker B: Current price function is returning a price presumably computed using some sliding window calculation. And in addition to the price, it's also including a return value. That's some confidence field. Maybe it's indicating how much volatility there is, how much uncertainty there is in the sliding window computation. Okay? And we'll go into the modifiers in a little bit. You can define methods with any name in general in a contract, a contract typically has one special function which is called its constructor which is invoked whenever you are first creating this contract object. It is typically used to pass in parameters or initial value settings for the variables of the contract.
00:22:44.522 - 00:23:02.306, Speaker B: So here I have a board smart contract that keeps track of a president and a vice president of this board of directors. And so the constructor for the smart contract object takes in the address of the initial president, the address of the initial vice president and assigns them accordingly.
00:23:02.338 - 00:23:04.806, Speaker A: And maybe these would evolve, maybe other.
00:23:04.828 - 00:23:29.630, Speaker B: Methods in the contract would change these later. This constructor is saying what values these instance fields will initially take on. So let's talk about visibility modifiers. We'll first talk about functions and then about instance variables. They work a little bit differently for each of those. So a function can be labeled as public. This means that anyone can invoke that method.
00:23:29.630 - 00:24:10.614, Speaker B: The alternative is internal, which means that the only way that you can invoke this method is by calling this function from within other program code of the smart contract. So internal means it can only be called by other functions. Public means it can be called by other functions in the smart contract or by someone another contract other than this contract. Or it can be called directly by a user. For instance variables, they're a little bit different. Public here means that this instance variable is going to have a getter method automatically created.
00:24:10.742 - 00:24:12.634, Speaker A: So if I declare an int public.
00:24:12.752 - 00:25:07.870, Speaker B: My public field, there will be a method for this contract, my public field that returns the current value. It acts like a getter function and anyone will be able to call that getter function. It'll be a public method of the contract. If I label instead a member field as private, what it means is that no getter method is going to be provided. I'll still be able to access this member field from code defined within my smart contract, but I am not going to be able to access it from outside. Now, here's a question for you to think about based on what you know of blockchain so far. If I label this my private field as private, does this mean that the value that this takes is going to be secret? What do you think about that? Let's go on to talk about mutability modifiers.
00:25:07.870 - 00:25:48.214, Speaker B: So an ordinary method won't have any mutability modifier. And what this means is that it's allowed to modify the state of the variables in the contract. It can modify the local storage, it can modify the local mapping types, it can change overwrite any of the instance variables of the contract. It can also transfer money from the contract account. It can also invoke methods of other contracts that it has access to. So this is like an ordinary method. If you have instead a method that's labeled as View, then what this means is that it's like a read only method.
00:25:48.214 - 00:26:27.970, Speaker B: It doesn't actually have any effect when you call this method. It could return a value, but what it won't do is make any side effects. It won't modify any of the storage variables and it won't make any function calls that themselves are non view, meaning it can't call any methods that have a side effect. The significance of this is that View basically gives you a readonly view of a Smart Contract. You can invoke this function just with your own local cached copy of the blockchain to learn something about the Smart Contract. Getter methods are views. Methods like Get current price are typically views.
00:26:27.970 - 00:26:56.370, Speaker B: You don't actually need to make a transaction and put it on the blockchain in order to invoke this. It's just code that lets you interpret the data that's already stored on the blockchain. So it's really a read only method. Now, besides View, there's an even stricter mutability modifier called Pure. And what Pure means is that this method doesn't even read any state. It doesn't even depend what the state of the blockchain is. It's just like a calculator function.
00:26:56.370 - 00:27:28.826, Speaker B: It only is a function of the input arguments if there are any. It can compute on any input arguments and return an output value. But it doesn't matter when you calculate it, it'll always be the same. It doesn't depend in any way on the blockchain data. You don't even need to connect to the network to be able to evaluate one of these functions. A really important syntax in Solidity is events. So events are one of the main ways that you can interact with the.
00:27:28.848 - 00:27:32.366, Speaker A: Outside world in Ethereum, basically, it is.
00:27:32.388 - 00:27:46.750, Speaker B: Easy for nodes on the network to be able to subscribe to events. And when an event is emitted by some Smart Contract code, any node that has subscribed to hear about this event will get notified when this event occurs.
00:27:46.910 - 00:27:48.642, Speaker A: This is actually one of the ways.
00:27:48.696 - 00:28:16.954, Speaker B: That you can do print debugging if you're used to printf debugging in other programming languages. Events are the best way to do print debugging in Solidity Smart Contracts. So there's two parts to using events. First, you have to declare an event. So here I'm declaring an event for when I've registered a domain and the parameters to this event will be the address of who did the registering and.
00:28:16.992 - 00:28:20.646, Speaker A: The string of who of which domain.
00:28:20.678 - 00:29:11.710, Speaker B: It is that they registered. Now, once I've declared an event like this in a Smart Contract, when I want to create an instance of this event in my Smart Contract code, I will use an Emit statement. And when a transaction is committed that invokes this method and emits this event, well, this event will be stored in this logs area. When we looked at this example contract on the Etherscan Block Explorer, you could see the list of log events that have occurred. And again, anyone who has subscribed to receive this event would get notified when a transaction emitting this event has occurred. Next we'll talk about how you can call methods of another contract from your Smart Contract code. So first of all, here I have defined an interface for an external contract.
00:29:11.710 - 00:29:31.054, Speaker B: This is an interface for a token contract. And this interface defines a single method transfer from which takes in a few parameters who's the current owner, who I am transferring it to and how much of the token I'm intending to transfer. And virtual here just means that this is just an interface.
00:29:31.102 - 00:29:36.582, Speaker A: It's not actually a function where I'm providing the body of the function code.
00:29:36.636 - 00:29:41.400, Speaker B: I'm just saying what the name of the function is and what its parameters are.
00:29:42.490 - 00:29:44.982, Speaker A: Now the next thing in order to.
00:29:45.116 - 00:30:04.030, Speaker B: Write Smart Contract code that invokes a method of a token contract, I have to have an address of the token contract. Now, the way that I can do this is by taking the name of that contract type token and creating an instance of it by passing in an address as a parameter.
00:30:04.610 - 00:30:05.886, Speaker A: Now, one way to do this is.
00:30:05.908 - 00:30:11.578, Speaker B: Simply by hard coding the address of the contract that already exists.
00:30:11.674 - 00:30:13.134, Speaker A: It would also be possible to pass.
00:30:13.172 - 00:30:19.582, Speaker B: This in as a parameter somehow. But here I'm just indicating a hard coded address and in reality the address wouldn't be zeros.
00:30:19.646 - 00:30:20.642, Speaker A: I would have to have the real.
00:30:20.696 - 00:30:58.426, Speaker B: Address and paste it there. So what I'm illustrating here is a contract called Exchanger, which is aware of two external contracts called Tokens, token A and Token B. And in my exchanger contract, what I have is a single method swap takes in two addresses, alice and Bob. And what you can see here is that I am invoking the Transfer From method of token A to transfer a token from Alice to Bob. And then I'm also invoking the method transfer from of token B. And there I'm transferring one token from Bob to Alice.
00:30:58.618 - 00:31:01.038, Speaker A: So here is how I have program.
00:31:01.124 - 00:31:39.894, Speaker B: Code for one contract object Exchanger. That in turn is going to invoke two methods of the external contracts token A and Token B. This is very useful. This is the way that you can build up systems of Smart contracts that all interact with each other. Next we're going to talk about how in solidity you can send and receive the native currency, which is the ether currency. So here I have a function that is intended to accept exactly two ether. So first of all, there is another modifier called payable.
00:31:39.894 - 00:32:14.054, Speaker B: If I didn't have this payable here and you tried to send ether to this function, then it would fail with an exception. By default, functions reject any ether that they're sent. If they're marked as Payable, then it can accept Ether. Now, the next thing that I have here is a require statement. And here I'm looking at message value. So message value is telling you how much Ether is sent along with this method call. So this method call will fail unless it comes along with at least 2.0
00:32:14.054 - 00:32:25.354, Speaker B: Ether. Now, message value is also used when calculating the refund. Here, it's whatever was sent minus the 2.0 Ether that the method is supposed.
00:32:25.392 - 00:32:26.540, Speaker A: To be called with.
00:32:27.390 - 00:33:03.970, Speaker B: Now, the next thing that I'm going to do is transfer an amount of Ether to an address. So here you can see I had to use Payable to cast message sender. I would get a compiler warning if I didn't include this Payable cast. It would say that message descender isn't Payable and I can only call transfer of a Payable address. This is just there to try to help prevent you from accidentally transferring Ether out to some address that wasn't intending to receive it anyway. So you can cast message sender as Payable and then transfer an amount of Ether to it. So here I'm transferring a refund.
00:33:03.970 - 00:33:16.102, Speaker B: If you called this method with three Ether, it would keep two Ether and it would transfer you a one Ether refund. And the last thing that this example is showing you about interacting with Ether.
00:33:16.166 - 00:33:17.580, Speaker A: Is the.
00:33:20.270 - 00:33:31.310, Speaker B: Balance getter method. So here, if I have an address, I can look up the balance of that address. Now, here I am looking at this. This means the current contract.
00:33:31.730 - 00:33:34.320, Speaker A: So what this would be doing is.
00:33:35.010 - 00:34:06.474, Speaker B: Returning whatever is the total amount of value that this contract has received. That's what's going to be passed along as the return value for this method. So again, to summarize this method, it will only work if you invoke it by passing in at least two Ether, it will send you back. However much is the difference between what you sent it and two Ether, the refund, and it'll return the total amount of Ether that this contract is currently storing in its account. Next, you might notice something that looks.
00:34:06.512 - 00:34:10.474, Speaker A: A little unusual to other programming languages. This 2.0 ether.
00:34:10.522 - 00:34:49.170, Speaker B: The way this is written so what's happening here is that Ether is provided as a convenience unit. Because in Ethereum, an Ether is not the smallest indivisible unit. You can actually represent one Ether as one times ten to the 15 way, where way is the true smallest indivisible unit, like a Satoshi in Bitcoin. And this is clearly a lot of zeros to keep track of. So instead of writing out one in this many zeros, you can just write it as 1.0 Ether and the compiler will keep track of that unit for you. So these are just convenience units.
00:34:49.170 - 00:35:26.670, Speaker B: Ether and Way are some of the ones you see the most. There are other units as well for smaller amounts like milliether and nano Ether and so on. Next, we'll just look at one short example of reading metadata in Ethereum. So here I have a place bid function and I want to be able to check that the current time when the bid is placed is valid. Like that I'm placing a bid early enough before a deadline. So I have this instruction block timestamp which is letting me access the current timestamp reported in the block in which this transaction occurs.
00:35:26.830 - 00:35:28.566, Speaker A: So this is the syntax I would.
00:35:28.588 - 00:35:39.800, Speaker B: Use to check that this bid is being placed before a deadline has elapsed. Now there are many more examples of metadata about the current block or about the current transaction that you can access.
00:35:40.330 - 00:35:44.138, Speaker A: We won't be able to go into them there, but I'll point you to.
00:35:44.144 - 00:36:13.662, Speaker B: The Solidity documentation where you can see a lot more and we might mention some others as we encounter them. This has really just been scratching the surface. I just wanted to give you some flavor of Solidity syntax so you can appreciate all of the examples of DeFi gadgets that will come later. There's quite a lot of other interesting quirks and important things to know in Solidity programming. These include the different kinds of storage and memory variables. You'll encounter these when working with arrays and strings.
00:36:13.726 - 00:36:17.538, Speaker A: Especially often if you see compiler errors.
00:36:17.554 - 00:36:36.570, Speaker B: In Solidity, you can follow the guidelines suggested by the compiler and that might help you a lot. Some other examples are creating contracts programmatically that can be really useful when building factory contract objects and dealing with upgradability. You will also frequently see modifier macros like only owner.
00:36:37.870 - 00:36:40.634, Speaker A: There are some really interesting methods that.
00:36:40.672 - 00:37:11.862, Speaker B: Are especially useful in keeping gas costs low. We'll talk about more a little bit later, but you can just access the program code of another contract and call it. There's this delicate call method in Ethereum which is really interesting, but it's going to be out of scope for what we're talking about. Now. If you're familiar with Java or other object oriented languages, you might wonder about inheritance and interfaces and Solidity does have support for those. There are many more. This isn't even an exhaustive list.
00:37:11.996 - 00:37:14.726, Speaker A: So really what you should be able to do is go look at the.
00:37:14.748 - 00:37:19.482, Speaker B: Solidity documentation to learn more about it. Anyway, next what we're going to do.
00:37:19.536 - 00:37:23.514, Speaker A: Is give a walkthrough of actually using.
00:37:23.552 - 00:37:31.206, Speaker B: The remix developer environment and a public test network to show you what Hello World looks like when writing and deploying a smart contract.
00:37:31.318 - 00:37:32.846, Speaker A: This will be intended to give you.
00:37:32.868 - 00:37:37.934, Speaker B: Some hands on experience and encourage you to go try out smart contract programming on your own.
00:37:38.052 - 00:38:33.822, Speaker A: In the past couple of segments we have looked at giving you a mental model of how to think about smart contracts from a programmer's point of view as objects with storage and code on a blockchain. And we've seen a couple of examples to get you used to the syntax of Solidity. The smart contract language we're using as a running example. And we've looked at the Dutch auction as a sample application that you could implement as a smart contract. Now, before we get into more details in the upcoming segments on how gas works and thinking about contracts, smart contracts versus legal contracts, for now, the point of this segment is going to be to encourage you to try out writing smart contracts on your own. So it's going to be a walkthrough or demonstration of a Hello World approach to writing smart contracts, just to get you off the ground with your first one. So I am going to be starting from scratch here.
00:38:33.822 - 00:39:21.610, Speaker A: All I've got pulled up is my remix code editor, and I have an empty file here, except for the Pragma at the top telling you which solidity version to use. So to build this contract, I'm going to create a new contract object. That's the first thing I'm going to give it a name. The idea behind the contract I'm going to build here is going to be something where there's one method to ring the bell, and it's just going to be a counter that keeps track of how many times you've invoked the ring the bell method. So my contract name will be Bell Tower. And you should remember from the Mental model smart Contract concepts segment that you should think of a smart contract as just some data and some code describing how to operate on that data. So I'm going to want to have a counter.
00:39:21.610 - 00:39:54.262, Speaker A: A uint is appropriate for that, an unsigned int. So I will call this UN. Bell Rung will be a counter of how many times has been rung. Now, I intend for this to have just one function ring the bell. This would be public. Anyone's going to be able to ring this bell. And the basic function of it is just going to be to increment the bell counter.
00:39:54.262 - 00:40:08.314, Speaker A: It's really just about that simple. There's no visibility or the visibility modifier here is public. There's no mutability modifier, so it's allowed to change the instance value. This is automatically going to be initialized.
00:40:08.362 - 00:40:09.834, Speaker B: To zero by default.
00:40:09.962 - 00:40:56.640, Speaker A: So I can leave it how it is. I could write it like that, too, but that wouldn't be changing anything. Put comment here, not too important. One more thing that I want to add to this. I'm going to want to add an event so that I can see anytime I ring the bell, I can see who rang it as something that shows up in the event log. All right, I will declare a new event, call it Bell Rung. Now, I can put a number here rang for the Nth time.
00:40:56.640 - 00:41:26.950, Speaker A: So the event will say, what's the current counter? And I will also include who rang it. These are going to be the fields that I have for the event. So then, in addition to ringing the bell, incrementing that counter, it's also going to emit this event. So I'll have it emit bellrung. I'll have the new value of the counter and I will have message sender. So this will tell me the address of whoever called this ring the bell function. So this should be enough.
00:41:26.950 - 00:41:54.160, Speaker A: Now I've been looking at the file browser view and remix, but I can click on these other ones here to the compiler tab. Now I have autocompiler turned on in the compiler tab. So it's been compiling this program all along. If I made mistakes, probably you saw this while I was typing. Like if I leave something off there, I'll get some kind of warning from the compiler and I can go follow what it does. Anyway, this is a very simple contract. So it's compiling now.
00:41:54.160 - 00:42:26.858, Speaker A: Now the next thing that I'm going to do is try this out by running it in the local JavaScript virtual machine. So I go to this tab, this deploy and run transactions, and my environment is going to be the JavaScript one. So it's just going to run a test instance of this contract in my browser. Okay, so I should be able to deploy this. It shows transactions recorded one. So it simulated creating the contract with a transaction. It shows this little object here, bell tower at an address.
00:42:26.858 - 00:42:45.070, Speaker A: And I see this. Well, I was expecting to see two methods. I forgot to make Bell rung public. So I'm going to fix that. Now, autocompiler it's, already recompiled it. I do need to get rid of my old instances of that older contract. So now I'm going to deploy the new contract.
00:42:45.070 - 00:42:56.150, Speaker A: Now when I look at it, okay, this is what I'd expect to see. I can see. Bell, rung. This is my getter method. It gives me zero. Now ring the bell. It's a different color there.
00:42:56.150 - 00:43:17.820, Speaker A: That is a potentially mutable transaction. You can see that this set of transactions recorded. It may not be very clear that when I click this, it's simulating adding the transaction. I think that if I go to this little console view here and turn on listen and network and maybe I just need to scroll down to the bottom here.
00:43:18.350 - 00:43:21.114, Speaker B: Whenever I click ring the bell, it.
00:43:21.152 - 00:43:36.980, Speaker A: Updates the transaction year. I don't want to go look in this transaction view. All I'll do is I'll click on this bell rung field again. You can see it now says four because I've rung the bell four times. All right? So every time I hit ring the bell and hit Bell Rung, you can see it updates that number. Now it's six.
00:43:37.350 - 00:43:38.594, Speaker B: Now I should be able to see.
00:43:38.632 - 00:44:11.040, Speaker A: The event log here as well. So if I do click the little down arrow to expand this simulated transaction and I scroll down, it's showing me two. That's the name of this locally simulated contract. Bell Rung is the method that I call. So after you've run it locally and you're satisfied that it does roughly what you want it to with local interaction. I like to next go to the testnet. So the way that I do this is by changing the environment from JavaScript VM to injected web three.
00:44:11.040 - 00:45:03.962, Speaker A: And that is going to link this to my MetaMask instance. You can see it loaded my address from loaded my address from MetaMask here, filled that in here. And so now when I do deploy, it's going to give me a MetaMask request to create this transaction on the Covan test network. That's what I've set my MetaMask up pointing to. So when I hit confirm, I'm waiting for it know, it gives me a pop up. You might not see the pop up, but it does show that the contract deployment transaction has been committed and it now shows the transaction recorded here. So here it's actually showing me a view of the contract on the test network.
00:45:04.106 - 00:45:05.358, Speaker B: A better way of looking at the.
00:45:05.364 - 00:45:43.194, Speaker A: Contract on the test network, though, is through a Block Explorer, so I can copy this address. And if I go to testnet maybe Covan, Etherscan IO and I paste this address that I got from remix. This is showing me the same transaction and the same contract creation that you can see through remix. So here's the address of the contract. If I click on contract, you can see this bytecode. This is the compiled bytecode for the contract. Now I can interact with the testnet contract from here.
00:45:43.194 - 00:46:16.066, Speaker A: So if I go and click ring the bell, it's going to give me a MetaMask pop up. I have to approve this transaction. I'll go ahead and approve it. Now if I go and look at transactions involving this contract, I should see a new transaction show up in a moment, as soon as it gets confirmed. Okay? And there it goes. Here's the confirmed transaction that interacted with it.
00:46:16.248 - 00:46:17.746, Speaker B: Now you can tell that it emitted.
00:46:17.778 - 00:46:34.346, Speaker A: A log event, but you're not being able to see exactly what information is in the log. So you can see that it's the number one there. So what's happening is that we haven't told Etherscan about the high level source code. So on the Ethereum blockchain on the.
00:46:34.368 - 00:46:37.718, Speaker B: Test network, all that's there right now is the Ethereum bytecode.
00:46:37.894 - 00:46:40.146, Speaker A: In order to make the Blockchain Explorer.
00:46:40.198 - 00:46:41.854, Speaker B: Give me a little bit more information.
00:46:42.052 - 00:47:19.690, Speaker A: What I will do is go and copy my source code for this contract. When I look at the contract page on Ether scan, I'll see an option for verify and publish. Now I have to go to single file compiler version should be 8.4. Going to pick no license. And what this is going to do is it's going to be asking Etherscan to verify the source code by recompiling it themselves with that compiler. Oh no, I'm stuck by a captcha.
00:47:25.090 - 00:47:26.190, Speaker B: Tractors.
00:47:29.490 - 00:47:42.414, Speaker A: All right, that was a great captcha. Now if all goes well, they're going to run the compiler on it it's going to match exactly. They're looking for an exact match. Like they want to compile this solidity code and get exactly the same bytecode.
00:47:42.462 - 00:47:45.006, Speaker B: As shows up on the Ethereum testnet.
00:47:45.198 - 00:48:07.254, Speaker A: And it's going to say Success. So that's good. When I now go back to the contract page, you'll see that there's a little bit more information about the contract there. It shows the source code there. It also shows all of the getter fields. So here I can see bell rung. It shows one that'll correspond exactly to when I click Bell rung in Remix.
00:48:07.254 - 00:48:39.022, Speaker A: It's showing me the same information there. I can go here and ring the bell again that'll contact me via MetaMask auto approve it. And now the same thing is going to happen here. If I wait for this transaction to be confirmed, I might have to wait a minute for it to be confirmed and to show up on Etherscan. Okay, there it goes. And I click read contract. It's seeing all of the updates.
00:48:39.022 - 00:49:10.202, Speaker A: Now I can also use. So what's happening is that Etherscan is looking at the names of the variables and the names of the functions here. Really, it's looking at the Abi interface, which is just the function signatures and the descriptions of the variables. And what it's doing is showing me that information. In this Read Contract info, it's showing me all the view transaction or all the view methods. In this case, the getter for Bell Rung. It also shows me the Mutable methods with write contract.
00:49:10.202 - 00:49:46.650, Speaker A: So here I have to go connect it to my MetaMask. And now I can even use Etherscan as an alternative interface in order to call this method. So I go write, it's also going to give me another MetaMask prompt with a transaction to approve. I go ahead and prove it and it'll let me view it and it'll show me when this transaction is confirmed. There, it's already been confirmed. And sure enough, if I go back to Read Contract and reset it there, it's three. Because now I've rung the bell a total of three times.
00:49:46.800 - 00:49:48.586, Speaker B: I also get more information now when.
00:49:48.608 - 00:50:07.780, Speaker A: I go to the events tab in Etherscan. So here it shows me all three events. It shows me the name of the method I called. It shows me the name of the event Bell Rung. The names of the parameters are there as well. And now I can also see these. I can interpret them as a number, as an address.
00:50:07.780 - 00:50:36.074, Speaker A: I think it should be filling in this address and number for me automatically. But okay, Ether scan is not perfect. Anyway, you can see this is the address I'm using. I'm the one that's rung the bell that many times. So again, I like to know that I'm seeing the same kind of information whether I'm looking at a third party block explorer like Etherscan, or whether I'm seeing the same thing through my development environment remix. Here either way, you're getting the same view.
00:50:36.112 - 00:50:38.886, Speaker B: If I ran a full node and connected it to the test network, I'd.
00:50:38.918 - 00:50:55.458, Speaker A: Be able to go inspect this address. The same way you could go take this contract once you've created it and you want to show it to someone, you could go copy this address and send it to your friend. Anyone who's able to go access the MetaMask test network would be able to see or who's able to access the.
00:50:55.464 - 00:50:57.026, Speaker B: Covan test network would be able to.
00:50:57.048 - 00:51:21.450, Speaker A: See exactly the same information about your smart contract. Okay, so there you go. That is a quick walkthrough of how to use Solidity and the remix development environment to write a contract and put it onto the covan public test network and then go interact with that contract and observe it through Etherscan.
00:51:22.830 - 00:51:50.766, Speaker B: We've now looked at some introductory examples of Solidity program code. So now we're going to look at an interesting mechanism. It's going to be an auction mechanism, and in particular, it's going to be the Dutch auction, which is popular in CryptoKitties. Now, you may have heard of CryptoKitties as the first big NFT on Ethereum. This was a really exciting application. It was kind of the first of its kind. It was one of the first applications on Ethereum that became really, really popular.
00:51:50.766 - 00:52:46.610, Speaker B: And if you're interested in NFTs now, then you should definitely know about CryptoKitties because this is really how it all began. And these CryptoKitties are collectibles on the Ethereum network. You could collect and trade them and there was even a breeding game where you could breed these digital cats. Now, the feature that really made CryptoKitties exciting, and that makes it a good example of smart contract programming and a good intro to DeFi, is that CryptoKitties was built on an auction mechanism, in particular a Dutch auction. So the way a Dutch auction works is that you start with a buy it now price, which is initially at its highest value, that you're offering it for. And what happens is that as time goes on, the item up for sale starts at its highest price and it gradually lowers as time goes on. So the price is lowering and lowering as time goes towards the right.
00:52:46.610 - 00:53:05.946, Speaker B: At any time, you can buy the cat at the current price. So if you want to wait for the value of it to go down, you could wait longer. But as soon as someone else goes to buy it, they'll get it at whatever the price is at. So the best strategy for playing in this auction is to wait until the.
00:53:05.968 - 00:53:08.266, Speaker A: Price reaches the largest, you're willing to.
00:53:08.288 - 00:53:11.110, Speaker B: Pay for it, and then you should hit buy it now, because if you.
00:53:11.120 - 00:53:19.950, Speaker A: Don'T, someone else might. So now we will look at the.
00:53:20.020 - 00:53:27.570, Speaker B: Dutch auction from CryptoKitties implemented in just a few lines of Solidity code. So there are a few parameters for this auction.
00:53:27.910 - 00:53:30.066, Speaker A: There is the initial price that's the.
00:53:30.088 - 00:54:07.360, Speaker B: Maximum price that the kitty will be for sale at at the beginning there's bidding period. That's how long the auction is going to last for in seconds. Offer price decrement is how much less the kitty is sold for as each second goes by. So this will be in units of ether per second or way per second. There will also be a timestamp that's the beginning of the auction, the auction will last for start time plus bidding period will be the end of the auction. Kitty token here is an external contract. This is going to be the NFT token that represents this cat.
00:54:07.810 - 00:54:08.894, Speaker A: So this is going to be the.
00:54:08.932 - 00:54:31.026, Speaker B: Address of the kitty token instance that we have up for sale. There's also an address for the seller. They're going to get the money at the end of. They're going to get whatever someone buys it for. So it's marked as payable. There's also a value that's not going to be a parameter. It's going to initially be zero and it's going to be the address of the winner.
00:54:31.026 - 00:55:03.834, Speaker B: So whoever is the first person to make a winning bid, they're the one who have bought the cat. Now winner address will store their value and initially this will be zero. Now the Dutch auction has only a single method for bidding and it's called Buy Now. Whoever is the first person to call this Buy Now method and provide enough money to pay the price, they're going to win the cat. So the logic of Buy Now is as follows. First of all, we have to figure out what the current price is. So the current price is going to depend on how much time has elapsed since the start of the auction.
00:55:03.834 - 00:55:19.714, Speaker B: So here time elapsed is going to be the current block timestamp minus the start time at the beginning of the auction. The current price is going to be the starting price, minus this price decrement times the number of seconds that have elapsed.
00:55:19.842 - 00:55:21.062, Speaker A: So that's going to be the current.
00:55:21.116 - 00:55:27.030, Speaker B: Price that'll always be counting down. User bid is going to be message value.
00:55:27.100 - 00:55:29.286, Speaker A: So the bid is basically whatever the.
00:55:29.308 - 00:55:37.082, Speaker B: User is providing when they call this method. Now these require statements, these are going to do the checks necessary to check.
00:55:37.136 - 00:55:39.510, Speaker A: That the bid here is valid.
00:55:39.590 - 00:55:51.806, Speaker B: So first of all, we're going to check that the winner address is zero, meaning that no one has yet claimed this cat. The first person to call Buy Now is going to have their address placed in winner address.
00:55:51.988 - 00:55:53.278, Speaker A: The only way that this will be.
00:55:53.284 - 00:55:56.320, Speaker B: Set to zero is if no one has bought the cat yet.
00:55:57.250 - 00:55:58.658, Speaker A: So this is going to check that.
00:55:58.664 - 00:56:38.766, Speaker B: The auction hasn't already been won by someone. The next require statement is going to check that the bid is timely. It shows up before the deadline, meaning the time elapsed since the start is less than the biding period. Finally, we are going to check that the user has provided enough money in their bid to exceed the current price, in which case they have enough money to pay for the cat. Now, if all of these conditions these require statements are passed, then it means that this bid is valid and we have to carry out the conclusion of the auction. So the winner address variable that is going to be set to the current sender. Whoever's invoked this buy now method, we.
00:56:38.788 - 00:56:43.102, Speaker A: Are going to transfer the winner the.
00:56:43.236 - 00:57:06.434, Speaker B: Difference between what they sent in Ether and the current price. So they get a refund and the current price is going to be transferred to the seller. So they sold it for a current price. This is what they receive in exchange for the cat. And finally, we invoke the transfer ownership method of this cat token and we are transferring it from the current owner.
00:57:06.482 - 00:57:12.570, Speaker A: To whoever the winner is. Okay, so here you can see basically.
00:57:12.640 - 00:57:52.034, Speaker B: How a simple auction mechanism can be implemented in solidity smart contract code. Next we're going to talk about the gas mechanism in Ethereum. Gas is one of the most important concepts in Ethereum and it's something that's unique to smart contract programming. So it's worth talking about. So the basic idea is that every transaction in a smart contract system has to pay a fee. And the way this works is that the more complicated the smart contract code you run, the more gas your transaction consumes. And your transactions have to pay a fee in the native currency.
00:57:52.034 - 00:58:47.234, Speaker B: So in Ethereum, they have to pay a gas fee in Ether. And so the idea is that the more complicated a transaction is in terms of the smart contract code it runs, the more in Ether it has to pay. There are a variety of sites like Ethereumgastation Info that give you information on the current status of the Ethereum network. Basically, the more that you're willing to pay for gas, the faster your transaction gets included. And there is a limit to how much gas can be consumed in a single block. So there are some pressures for you to try to keep the gas costs of the smart contracts you write and the contracts you interact with as low as possible because it will help you to get your transaction committed early and it will keep your costs down. So as I mentioned, there's a limit on the amount of gas that can be consumed in each block.
00:58:47.234 - 00:58:55.142, Speaker B: This effectively means there's a limit on how many smart contract program code instructions can be evaluated in each block.
00:58:55.286 - 00:58:57.702, Speaker A: So this chart is showing the average.
00:58:57.766 - 00:59:38.642, Speaker B: Gas limit of Ethereum per block since 2016. So what you can see is that the amount of gas allowed per block has been gradually increasing over time. But at any given time, there's a limit. And this is setting a limit on how many transactions can be included in each block. And also how much program execution can occur in each block. So this limit can be a very big constraint or a very important constraint on what kinds of program code you can effectively run. So, how does gas work? Well, the basic idea is that there is a counter of how much gas you have available when the smart contract is executing.
00:59:38.642 - 01:00:15.822, Speaker B: So, back to this registry domain example. If there are two lines of code in the register domain function, then if I looked at it in a debugger, what I would see is that when my program cursor is on this line of code, maybe I have this much gas remaining. And as I execute that line and move on to the next one, I've consumed some amount of gas depending on how much computational work I've had to do in the previous line of code. When I now move down to this line, I only have 8000 gas remaining. So as the program is executing, I'm consuming from this amount of gas remaining.
01:00:15.886 - 01:00:16.866, Speaker A: And I need to make sure that.
01:00:16.888 - 01:00:45.098, Speaker B: I don't run out of gas if I want the function to complete successfully. Now, what happens if I have more gas available than I need? Well, what happens is that when I create a transaction, I specify a gas limit. That's a maximum amount of gas that I'm willing to pay for. I also get to say what price I'm willing to buy the gas at. You get to name your price. It's not like there's a fixed gas price. You get to offer one like a bid.
01:00:45.098 - 01:00:49.274, Speaker B: So I say I'm willing to spend this much per gas and a maximum.
01:00:49.322 - 01:00:51.450, Speaker A: Of this much gas.
01:00:51.610 - 01:00:59.666, Speaker B: And what happens is, when I create this transaction, I actually have to provide up front an amount of ether that's equal to this product, the amount of.
01:00:59.688 - 01:01:02.386, Speaker A: Gas I'm setting as my limit and.
01:01:02.488 - 01:01:44.810, Speaker B: Times this price of ether per gas that I'm willing to pay for it. Now, what happens is that as the contract executes, it counts down from my gas limit counter. And if I have any gas left over at the end of my transaction execution, then my account will get a refund of the ether corresponding to the gas I haven't used yet. So any difference between the gas limit and how much I actually use, that goes back to me as a refund. But I had to provide enough ether up front. My account had to have enough ether in it in order to pay for the full amount of the gas limit times the gas price. Now, how do I know how much gas is being consumed by a given smart contract?
01:01:44.890 - 01:01:46.066, Speaker A: Well, the way that this works is.
01:01:46.088 - 01:01:55.220, Speaker B: That there is a big lookup table for every opcode in the ethereum virtual machine. There is some amount of gas used associated with it.
01:01:55.590 - 01:01:57.186, Speaker A: You can see in this table, it's.
01:01:57.218 - 01:02:22.262, Speaker B: Like five gas for a mod operation, eight gas for an addition. Modular arithmetic. Some of the methods have a formula. And this basically means that there is some non constant amount of gas. Maybe the amount of gas that exponentiate takes depends on how large of a value I provide to it. So it can be variable depending on the runtime value of the arguments.
01:02:22.406 - 01:02:23.886, Speaker A: But anyway, there's a big table that.
01:02:23.908 - 01:03:21.920, Speaker B: Says exactly how much gas each Opcode takes. Now, you might wonder what happens when you run out of gas. Well, if you run out of gas like your function hasn't finished executing before your gas counter reaches zero, then what happens is that it throws an out of gas exception. And the effect of this exception is as follows any changes that you've made to the storage, to the state of the blockchain, such as modifications to the instance member variables of a smart contract, any account transfers you've made, these are all reverted to whatever the state was before this method call began that ran out of gas. And something that's important is that you're still charged the gas fee. So even though the side effects like storage updates and account transfers are reverted, the gas was still consumed. And so you're still charged the gas fee for every instruction leading up to this.
01:03:21.920 - 01:04:06.110, Speaker B: Now, something that you can do because it's an exception. Just like exceptions in other programming languages like Java or Python, you can catch the out of gas exception. And so this is useful because you can invoke methods by providing just a portion of the available gas. You don't have to provide all of the gas you have available in the transaction. You can call a method with just a portion of the gas available. This way, if you call a method that runs out of gas and you planned ahead in your code, you can catch that exception and save some reserve of gas that you can use to clean up or handle the exception. But in general, when you run out of gas, all of the side effects are reverted, except you are still charged the gas fee for everything that you consumed.
01:04:06.110 - 01:04:13.230, Speaker B: Now, you'll encounter out of gas exceptions potentially in two ways.
01:04:13.300 - 01:04:14.846, Speaker A: So this is what it looks like.
01:04:14.868 - 01:05:23.622, Speaker B: On a Block Explorer where a transaction invoked a method on a contract and it didn't provide enough gas for that contract to finish executing. So the Block Explorer shows you the sad face and the out of gas exception, and it still charged the transaction fee, which corresponds to the gas limit of the transaction times the gas price that the transaction offered. So this actually charged someone money, actually charged them ether, even though whatever they intended to accomplish with this contract was unsuccessful because it ran out of gas and threw an exception. Now, another thing that can happen is that when trying to confirm a transaction, you may see an alert which says that MetaMask or whatever client you're using has determined that if you ran this transaction, it probably would fail. This can be an indication that you haven't provided enough gas. And your client can tell, because when it runs a local simulation of the contract, a simulation of your transaction, it can tell that you haven't provided enough gas. So here you're getting a warning, but you haven't actually lost any money yet.
01:05:23.622 - 01:06:10.494, Speaker B: If you reject it at this point anyway, it won't have ever made it to the blockchain. Your client is preventing you from committing this transaction that would fail because it would run out of gas. So let's recap a bit about the gas mechanism. The main idea is that you are paying for the computation that you use and you pay in the form of this gas fee that you pay upfront at the beginning of your transaction because you are paying for the computation you use in Ethereum, it gives you a really direct reason why you should optimize your code. Now, in every programming language, in every computing system, you want it to run faster and to be as efficient as possible. But in smart contracts especially, you directly pay per instruction that you have executed. So you want to interact with contracts that are gas efficient.
01:06:10.494 - 01:07:05.990, Speaker B: And when you're writing contracts, you want to write them in a way that they use the least amount of gas possible. So far we've looked at smart contracts from the programmer's perspective and gone into a little bit of detail into the programming experience in Solidity and looked at some examples of Dutch auction in particular. Now, we're going to back up a little bit and talk again at a high level and we're going to draw a comparison between smart contracts and ordinary real world contracts in the legally enforceable world. So in the world of contracts, there are a few basic elements that are considered the essential ingredients of an ordinary legally enforceable contract. So you're used to thinking of a contract as written down on paper, specifying some terms and having some kind of signature from the parties involved. Well, the basic elements of a contract are that, first of all, there has to be an offer in acceptance. The contract has to be between two parties.
01:07:05.990 - 01:07:27.722, Speaker B: Someone has to deliberately intend to offer the terms of the contract to the other, and the other party has to intend to accept the contract. They both have to opt into it and the signature is often provided as evidence of this. But it could be a contract, even if it's just on a handshake, there has to be a consideration for the contract.
01:07:27.786 - 01:07:35.138, Speaker A: It actually has to describe something of value taking place, exchanged in return for.
01:07:35.224 - 01:07:56.774, Speaker B: Whatever is offered by the contract. So here in this example, this is a contract describing some Ether payment offered to Alice in exchange for some cat tokens. So that's the payment, in exchange for a cat token, there has to be a mutual agreement, meaning for a contract to be valid in the ordinary world.
01:07:56.812 - 01:08:00.386, Speaker A: Both parties have to have a meeting of the minds.
01:08:00.418 - 01:09:05.274, Speaker B: They have to agree on what it is that they are intending to agree to. As for this contract, usually this kind of corresponds to the contract being written in a very clear language where it's unambiguous what each of the parties is expected to do in exchange for what the other party is expected to do in the real world. For a contract to be enforceable, the contract has to be legal and the parties have to be they have to have the capacity to enter into this contract. So, for example, you can't write a contract with a five year old and expect to enforce it. In a court, they would say, that five year old signing a contract that doesn't make any sense. The five year old lacks the capacity to agree to a contract, so we're not going to enforce your contract. So a question is, how can you make a smart contract that resembles a legal contract? And what can we get by analyzing a smart contract in terms of the elements of an ordinary contract? Well, a way of modeling that example in solidity code would be as follows.
01:09:05.274 - 01:09:45.450, Speaker B: I have here a solidity contract representing this particular offer. I have the hard coded public key addresses for Alice and Bob. I have an external contract interface for the Cat Token that's being exchanged for Ether. And I have a method in this contract that corresponds to accepting the offer. So this method can only be called by Bob. Bob's the one accepting it, alice is the person who's offering it. This contract method is going to expect that Bob pays at least one Ether and there's some timestamp that is going to ensure that this offer is only valid up through a certain deadline.
01:09:45.450 - 01:10:27.286, Speaker B: And if all of these conditions are met, and if Bob has called this method to accept the offer, then it is going to transfer the 1.0 Ether that Bob provided to Alice and it is going to transfer the Cat Token from Alice to Bob. So let's talk about this contract in terms of those contract elements. So, first, offer and acceptance. So the basic idea is that for Bob to accept this offer, he actually has to sign a transaction with his public key, or rather with his secret key that approves the transaction. And invokes this method, there's no way for him to accidentally agree to it.
01:10:27.308 - 01:10:28.998, Speaker A: As long as he's keeping track of.
01:10:29.004 - 01:11:17.510, Speaker B: His private key and only signing methods that he has looked at what they do. Only Bob is calling this method. So, Alice, what did Alice have to do to put the Cat on offer? Alice would have had to initially make this offer by transferring her Cat Token so that this contract itself is the owner of the object. This might have been done at the constructor time or after the contract's constructed. Alice would have had to transfer ownership of the Cat token to this contract. So both Alice would have opted into this contract by transferring the Cat token to it, and Bob is accepting the offer by invoking this method. Now, for the consideration, you can see the payments and the exchange that are occurring here.
01:11:17.510 - 01:12:21.740, Speaker B: So Alice is directly being transferred the Ether that Bob is providing as consideration here and likewise the execution of the contract, the Cat is actually being automatically transferred from Alice to Bob. So, for mutuality, what makes us think that both parties here, alice and Bob, have had a meeting of the Mines? Well, the smart contract binary code is always on the blockchain. It might be difficult for Bob to look at that smart contract code and know exactly what it does. So that's why typically the high level solidity code would be published somewhere like on Etherscan verified source code. So that Alice should only transfer her Cat token to this contract if she's looked at this contract code and knows that it's going to only transfer the Cat token away if she receives payment. And Bob should only accept this offer if he's inspected this contract code and knows that it will execute accordingly and transfer him the Cat token in exchange for his payment if he chooses to accept it.
01:12:22.510 - 01:12:24.390, Speaker A: So what enforces the agreement of the.
01:12:24.400 - 01:12:27.934, Speaker B: Mines is just making sure that the contract code is available and anyone can.
01:12:27.972 - 01:12:30.382, Speaker A: Check that the high level code does.
01:12:30.436 - 01:13:09.450, Speaker B: Correspond to the compiled program binary on the blockchain. Now, the legality and capacity part is usually the most interesting kind of correspondence here. So there's nothing about the smart contract that checks that Alice and Bob have to be allowed to use the smart contract. And there's pretty much no way for the blockchain to nullify the contract by refusing to enforce it. The only thing the contract code provides in its program code is exactly these instructions that carry out automatically the transfer of the Ether to Alice and the token to Bob.
01:13:11.490 - 01:13:14.430, Speaker A: The code will basically be executed automatically.
01:13:14.850 - 01:13:28.786, Speaker B: With no humans in the loop needed to scrutinize the contract. Which also means that there's very little ability for a judge to intervene and redirect any terms of this contract to cancel them.
01:13:28.968 - 01:13:31.266, Speaker A: Once put on the blockchain, all you.
01:13:31.288 - 01:14:26.210, Speaker B: Need to interact with it is your public keys or the secret keys corresponding to your address. Everything else is taken care of automatically. Now, the term smart contracts originates from an essay from Nick Jabo in 1994, and his view of the smart contract was that it's a computerized protocol that executes the terms of a contract. And he outlined a bunch of benefits that smart contracts might have compared to ordinary legal contracts. The general objectives are to satisfy the conditions of the contract, like payments and enforcement of the contract to minimize the exception cases, like failing to fulfill the terms of the contract, perhaps because you weren't sure what they are or they were ambiguous. Minimizing those is one of the goals of a smart contract. Another goal of the smart contract is to minimize the need for trusted intermediaries.
01:14:26.210 - 01:15:29.346, Speaker B: Often in a legal contract you need trustees or executors of the contract or something like an escrow agent. And the goal of a smart contract is often to avoid the need for third parties to fulfill those roles. Additionally, smart contracts might reduce losses and transaction costs associated with fraud or arbitration or court enforcement. So because the smart contracts are executed just automatically according to their program code, there's no external enforcement or arbitration typically available except for just running the code exactly to the terms as they're described. So you can think of this as a very short framework for explaining the potential benefits that a smart contract might have compared with its ordinary legal contract analog. So let's wrap up with a couple of open ended questions that we can talk about later. So I've described the simple offer smart contract example in this segment.
01:15:29.346 - 01:15:57.300, Speaker B: But let's think back to the Dutch auction mechanism from one of the previous segments. How would you analyze the Dutch auction of a CryptoKitty in terms of the elements of an ordinary legally enforceable contract? Alternatively, how could you describe the benefits of the Dutch auction contract in terms of Nick Jabo's benefits of smart contracts as opposed to ordinary contracts? And we'll talk about these a little bit later after the break.
01:15:58.390 - 01:16:01.442, Speaker A: In this last segment, we're going to talk about two of the most important.
01:16:01.496 - 01:16:03.794, Speaker B: Kinds of smart contracts that you'll see.
01:16:03.832 - 01:16:25.894, Speaker A: Used in DeFi, which are fungible and non fungible tokens. So we've already shown examples of cryptocurrency transactions that transfer the native underlying currency of the blockchain, like ether and ethereum. And we've also been looking in this segment in smart contracts as a programming.
01:16:25.942 - 01:16:31.318, Speaker B: Model where you can define program objects, including their data structures and their code methods.
01:16:31.494 - 01:16:32.714, Speaker A: Well, so what's a token?
01:16:32.762 - 01:16:36.686, Speaker B: A token is just a kind of smart contract where the choice of the.
01:16:36.708 - 01:17:13.500, Speaker A: Data structures and methods are meant to provide the same kind of functionality that the underlying digital asset does. It provides methods to transfer quantities or units of your digital asset. It allows you to check your balance, how much of the digital asset you own. Basically, it's a smart contract that behaves effectively like a digital asset. We're going to talk mainly about two different kinds of token contracts. There's fungible and nonfungible. We'll talk about nonfungible first.
01:17:13.500 - 01:17:30.846, Speaker A: So we've already seen some examples of nonfungible tokens. We've looked at CryptoKitties, and CryptoKitties are a good example of nonfungible tokens. What nonfungible token means is that you have a smart contract which defines an.
01:17:30.868 - 01:17:33.086, Speaker B: Array of records and each one of.
01:17:33.108 - 01:17:50.242, Speaker A: Those records describes a single individual digital asset. So here's a CryptoKitties smart contract. It'll have a list of all of these individual CryptoKitties tokens and each one of them is just a memory cell in the CryptoKitties contract.
01:17:50.306 - 01:17:52.294, Speaker B: So it's one contract that keeps track.
01:17:52.332 - 01:18:28.146, Speaker A: Of all of the individual cats. And what makes these non fungible is that each one of them has its own distinct identity and attributes and owner. And you interact by transferring or putting up for sale one distinct cat at a time. You can't just add two cats together and you can't transfer a half of a cat. They're all distinct and each one of them is tracked by the smart contract. Now, what's useful about following a standard is that it means that you get.
01:18:28.168 - 01:18:32.210, Speaker B: Some interoperability with tools that can work with this smart contract.
01:18:33.270 - 01:18:40.726, Speaker A: So the main function of a nonfungible token is the transfer function. And one of the main events that.
01:18:40.748 - 01:18:43.750, Speaker B: It emits is a standardized transfer event.
01:18:43.900 - 01:18:48.054, Speaker A: And what I'm showing you here is the view of Etherscan, which knows to.
01:18:48.092 - 01:18:53.834, Speaker B: Look for the transfer event emitted by a smart contract. And whenever it sees it, it's able.
01:18:53.872 - 01:18:57.766, Speaker A: To interpret that this was a non.
01:18:57.798 - 01:19:02.842, Speaker B: Fungible token that was transferred in this transaction. So it's able to generate this view.
01:19:02.896 - 01:19:12.110, Speaker A: For you of showing you all of the non fungible tokens and it's sorting them in order of how many transfer events they've all had.
01:19:12.260 - 01:19:15.838, Speaker B: And this is entirely automatic. If you created your own smart contract.
01:19:15.934 - 01:19:23.346, Speaker A: That had this standard, it could show up on this list all automatically. Similarly, any wallet software that knows how.
01:19:23.368 - 01:19:25.378, Speaker B: To work with nonfungible tokens is going.
01:19:25.384 - 01:19:28.246, Speaker A: To know how to transfer or check.
01:19:28.268 - 01:19:33.894, Speaker B: The balance of your account for these standardized tokens. Now, we're going to look at a.
01:19:33.932 - 01:19:43.834, Speaker A: Simple code demo of a simple non fungible token. This isn't exactly compliant with the commonly used NFT standard, but it's pretty close.
01:19:43.872 - 01:19:45.258, Speaker B: And should give you the idea.
01:19:45.424 - 01:19:59.914, Speaker A: So let's go through this. First of all, this defines a data type, a record Struct, which is going to have one of these. For each one of the digital assets tracked in this token contract, the main field that each one's going to have is a string description.
01:20:00.042 - 01:20:05.394, Speaker B: This could be text describing the asset. It could be a URL that points to a JPEG or points to more.
01:20:05.432 - 01:20:21.574, Speaker A: Information about the asset, anything, really. And this will be fixed for the lifetime of the asset. We also have an address field pointing to the owner. And this isn't really necessary. But just as an example, I'll have a little flag that indicates whether this.
01:20:21.612 - 01:20:23.400, Speaker B: Has been minted yet.
01:20:24.170 - 01:20:27.846, Speaker A: Now, the main data member in the.
01:20:27.868 - 01:20:30.954, Speaker B: Contract is this table, this mapping, which.
01:20:30.992 - 01:20:41.014, Speaker A: Is going to map IDs, they're just counter values starting at zero and counting up. And those IDs are going to map to that record struct for each digital.
01:20:41.062 - 01:20:42.830, Speaker B: Asset tracked by this contract.
01:20:47.010 - 01:20:48.890, Speaker A: The way that new assets are created.
01:20:48.970 - 01:20:50.606, Speaker B: This will initially be empty, but the.
01:20:50.628 - 01:20:52.366, Speaker A: Way that you mint new assets will.
01:20:52.388 - 01:20:53.866, Speaker B: Be using this mint method.
01:20:53.978 - 01:20:58.402, Speaker A: I have this set so that only the administrator, the person who created this.
01:20:58.456 - 01:21:01.938, Speaker B: Contract is allowed to mint new assets here.
01:21:02.104 - 01:21:08.114, Speaker A: And what it's going to do is take the next available ID and initialize.
01:21:08.162 - 01:21:16.390, Speaker B: It with the text description passed in as an argument. And that's all the initial owner of it will be the administrator of the contract.
01:21:17.050 - 01:21:20.662, Speaker A: Now, the standards methods that are here.
01:21:20.716 - 01:21:22.614, Speaker B: Are owner of which when you give.
01:21:22.652 - 01:21:24.486, Speaker A: It an ID, it'll tell you who's.
01:21:24.518 - 01:21:26.390, Speaker B: The current owner of that asset.
01:21:26.550 - 01:21:36.926, Speaker A: And then we also have transfer. And what transfer is going to do is you tell it which asset you want to transfer and who you want to send it to. It checks that you are actually the.
01:21:36.948 - 01:21:39.246, Speaker B: Owner of that asset, so it's yours to transfer.
01:21:39.348 - 01:21:46.578, Speaker A: And if so, it carries out the transfer. And if this were more of a complete standards compliant contract, it would probably.
01:21:46.664 - 01:21:48.398, Speaker B: Emit an event here so that tools.
01:21:48.414 - 01:22:04.226, Speaker A: Like Etherscan could pick it up. Now, instead of nonfungible tokens, we can also talk about fungible tokens. So fungible tokens resemble dollars or they resemble Bitcoin and ether, where there isn't.
01:22:04.258 - 01:22:08.486, Speaker B: Really any meaning to each individual unit. It doesn't have its own distinct ID.
01:22:08.588 - 01:22:17.178, Speaker A: Each individual unit of the currency. Instead you just treat it as a quantity. Like I have eleven and a half dollars. If I have five more, now I.
01:22:17.184 - 01:22:21.174, Speaker B: Have 16 and a half dollars. You track the total amount, not each.
01:22:21.232 - 01:23:06.060, Speaker A: Individual penny or each individual unit of the currency. So this is an illustration of what Etherscan can show you for a fungible token. It's showing you a pie chart of which account holders have how much of this token. So what you can see here is that this token, this is just a test token. It was created for a course just used in a classroom. But what it's showing you is that there are a bunch of account holders, all who have roughly the same amount, and then one user, probably the instructor, has the majority of all of the tokens. And again, this is just showing you a pie chart of the quantity that add up to 100%.
01:23:06.060 - 01:23:54.458, Speaker A: It's not keeping track of the identities of each individual unit. So that's the difference between fungible and non fungible. Now, for the fungible standard, there are a bunch of different other function methods that are defined in the standard. This is just a sample, but you could go look up ERC 20 to see more. But some of these include checking the balance of a given owner address, checking how many total tokens are available in total, and of course, transfer where. Now you're not giving the idea of which item to transfer, like with an NFT. Instead you're saying how much of the ERC 20 token are you going to transfer? There's quite many additional methods besides just these that are defined in the standard.
01:23:54.458 - 01:24:19.246, Speaker A: In particular, they have this notion of transfer from and an approval mechanism. And this is actually really important for how Wallet smart contracts and other advanced functionality like DEXes are able to work. But we're not going to go into those more. Just for now. So to sum up, tokens are just a kind of smart contract. But they're a smart contract that's designed.
01:24:19.278 - 01:24:21.470, Speaker B: To behave like a digital asset.
01:24:21.630 - 01:25:10.000, Speaker A: And we talked about the difference between fungible and nonfungible tokens, where nonfungible, it's defining a series of assets, each one of which has its own unique identifier and attributes. And We Talked about fungible tokens, which Are Just treated as a quantity of some asset type, which can be Summed up and sent in fractional parts. And the main idea of these token standards is that they stick to some standardized interfaces. And The Point of this is that it Helps interoperability between different tools in the ethereum Ecosystem. ERC 20 and ERC 721 are the Most commonly used standards for Nonfungible or fungible and nonfungible tokens, respectively, and they have A Bunch more other features than that besides just transfer. But that's the main idea.
