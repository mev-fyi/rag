00:00:00.490 - 00:00:48.326, Speaker A: Hello everyone and welcome to the second lecture in our DeFi MOOC. My name is Dan Bonet and I'm a professor at Stanford University. And in this lecture we're going to talk about an introduction to blockchain technology. Before we get started, I want to quickly reiterate something that we talked about in the previous lecture, which is basically what are blockchains for? So abstractly, a blockchain provides a way for multiple parties to coordinate when there is no single trusted party. Yeah, they basically use the blockchain to perform older coordination activities and they don't need to rely on any single trusted party. One thing that I'd like you to remember is in any environment where there does exist a party that everyone trusts, typically there is no need for a blockchain. You can basically rely on that trusted party to carry out all the synchronization operations.
00:00:48.326 - 00:01:36.374, Speaker A: Yeah, so blockchains are primarily useful in situations where there is not just a single party that everybody trusts. And of course, that's very common in a financial system where there is nobody that we trust in the financial system, everybody's kind of out looking for themselves and as a result, it's better to design systems that don't assume that there is one particular trusted party. Okay, so let's talk about what a blockchain is. And in my mind, a blockchain is sort of made up of four separate layers. Maybe I'll call them levels instead of layers, but there are basically four components to them. So the bottom layer is what's called the consensus layer and this is what's used for the parties to coordinate and agree on the current stage of the chain. Yeah, we'll talk about this in more detail in just a minute.
00:01:36.374 - 00:02:12.658, Speaker A: The next layer is what we call the compute layer. This is basically once you've established a base layer of consensus. Now it turns out you can define abstract computations on top of this layer. And yeah, this is what sometimes is called a blockchain computer. I kind of like this term. So we'll talk about applications that run on top of a blockchain computer and it turns out that in fact, often these two layers are sort of merged together and people sometimes think of the core blockchain as both a consensus layer and the compute layer together. But I like to keep those two concepts separate.
00:02:12.658 - 00:02:42.798, Speaker A: The third layer is basically now that we have something, a computer on which we can run applications. The third layer is basically the applications themselves. These are sometimes called decentralized applications, DApps. Sometimes they're called smart contracts. But these are basically the applications that we run on the blockchain. And finally, the fourth layer consists of user facing tools, which is basically how the public actually interacts with these programs. Okay, so we're going to talk about each one of these four layers in turn.
00:02:42.798 - 00:03:20.186, Speaker A: Let's start with the consensus layer. So consensus actually is not the topic of this course. So I'm going to go through this very, very fast. And basically we're just going to assume that a consensus mechanism exists and then we're going to put it to use. Okay, and so what is consensus actually buys us? Well, if you think about it, at a core level, consensus really is about building a new capability that we didn't actually have before, which is what's called an append only data structure. Okay, so it's basically a data structure that anyone can write to, but once something is written to it, that information can never be removed. Yeah.
00:03:20.186 - 00:03:50.280, Speaker A: So let's just summarize that more carefully. So there are sort of four properties that we talk about when we talk about consensus. The first one is what's called persistence, which is once you write something onto the blockchain, it can never be removed. Yeah. This is a property provided by the consensus layer. And by the way, the reason there is a star at the end of that sentence is that there's a caveat to that, which is assuming the adversary doesn't control more than half of our network yeah. So there's no 51% attack.
00:03:50.280 - 00:04:19.230, Speaker A: If the adversary controls a minority of the network, then persistence is guaranteed. And the way we achieve persistence is by replication. Yeah. We replicate data all over the world, across many, many different machines. And as long as the adversary doesn't control more than half of those machines, it can never remove data that has been written to the chain. Okay. The second property is actually what's called consensus, which says that basically all the participants, all the honest participants in the network, actually agree on the same data.
00:04:19.230 - 00:05:03.978, Speaker A: Okay, so they all have consensus, meaning they all agree on what's on the chain. It's not the case that one party thinks one thing is on the chain and another party thinks something else is on the chain. And the reason I have a double star at the end of that sentence is because this is true, but perhaps it's not quite true for the most recently added blocks. Yeah. So maybe for the last five or six blocks maybe are still stabilizing and we don't quite have consensus for those. But all blocks that came earlier, there should be consensus, and all the honest participants should agree what they are. Finally, there's a very important property called Liveness, which means that the chain doesn't get stuck, which means that the honest participants can always add new transactions, they can always write new data to the blockchain.
00:05:03.978 - 00:05:29.258, Speaker A: Yeah, it doesn't actually get stuck. And finally, the fourth property is what we call openness, which says that in fact, anyone can add data. It's not just registered and authorized participants that can write data. And some chains actually are open, like the Bitcoin and Ethereum networks are open. Anyone can write data. Anyone can mine and create blocks. Some other networks are not as open, and in fact, there's a whole spectrum of openness.
00:05:29.258 - 00:05:57.962, Speaker A: So that's why, as I say, some chains actually are open and some are not. Okay, so that's, I think, at a high level, what I want to say about the properties of a consensus. Let's quickly take a look at how blocks are added to the blockchain. So this will kind of illustrate how the consensus mechanism works in practice. Okay, so we have our set of participants here. Let's call them Alice, Bob, and okay. And so each one of them has a secret key that they're going to be using to sign transactions.
00:05:57.962 - 00:06:43.786, Speaker A: Yeah, we'll see how digital signatures work later on in the lecture, but for now, just think of these as secret keys that are used to authorize transactions. Now, Alice, Bob, and Carol, they each create a transaction on their own. They sign it using their secret key, and they send their transactions to the network, to the blockchain network, which is basically just a collection of miners. So they have, like, an address of a few miners. They send those transactions to those miners, and then there's a gossip protocol that replicates that propagates all these transactions throughout the network. Then there's a leader election mechanism where one of the miners gets elected. In this case, the top guy got elected, and he's the one who's going to be creating the next block.
00:06:43.786 - 00:07:20.930, Speaker A: So what he does is he takes the current pending transactions sometimes this is called the transactions in the mempool, the current pending transactions, he creates a block out of them. Namely, he kind of puts them together and does some more things to them that we'll see in just a minute. And then he posts this block onto the blockchain. And now, because he was the leader and he did the work to create the block, he's actually rewarded, and he's getting what's called the block reward. On ethereum. This would be, for example, two ethers that are given to the miner for creating the block. So you can imagine everybody wants to be elected as the leader, because every time they are elected as a leader, they actually get to get paid.
00:07:20.930 - 00:08:03.954, Speaker A: Yeah, so there's some competition about that. And one of the issues with building consensus is how do we make sure that the leader election mechanism cannot be subverted? But now we have one block on our chain, and all the other miners look at that block, and they verify that that block is valid. If the block turns out to be invalid, it's simply discarded and as if it was never posted to the chain. The next thing that happens is now we move to the next block. So now our friends Alice, Bob, and Carol again have a new set of transactions that they want to post to the chain. These transactions basically indicate who's paying who or maybe some more complicated data that needs to be posted onto the chain. Again, they sign these transactions, they send them to the network.
00:08:03.954 - 00:08:32.554, Speaker A: They send them to the miner, and a new leader gets elected. In this case, the second guy got elected again, he gets to form the block. He posts the block on the blockchain, and he gets his two E three. And this process continues again and again and again, and that's how the blockchain evolves. All right, so I think this is all I want to say about consensus in this course. Consensus, of course, is a very big topic, but it's actually not a topic of our DeFi course. So I will just leave it at that and let's move on to the next layer.
00:08:32.554 - 00:09:37.950, Speaker A: So the next layer I want to talk about is the compute layer, what we call the blockchain computer, which allows us to run applications on top of a consensus layer. Okay? So the idea here is that once we have consensus, we have a way to write information so that it can never be removed. We can use that to actually implement a program, right? So the program basically moves from one state to another to another to another, and all those state transitions are written to the blockchain, and everyone can verify that those state transitions are valid, right? So, again, programs basically are manipulating states, and all those manipulations of state are written to the blockchain, and everyone can verify that they're valid. So, again, the DAP logic, the program logic, is encoded in some program that runs on the blockchain. What that means is that the rules are enforced basically by the public program, right? So anyone can inspect the program that's running on the chain. This is why this area, by the way, is such a wonderful area to work in. All the code that's running on the blockchain is completely public for the whole world to see.
00:09:37.950 - 00:10:17.474, Speaker A: Yeah, so there's no proprietary code, no secret code. The code that runs on the blockchain is completely public. Everyone can verify that it does what it's supposed to do. So in that sense, we have transparency in that we are guaranteed that these programs actually do what they're supposed to do. We can look at their code and verify that it's correct. And then that program itself is executed basically by whoever's writing new blocks to the chain. Every time a new block gets written, that block might contain a few instructions that were executed by this DAP program.
00:10:17.474 - 00:10:51.814, Speaker A: So that's how programs execute on the blockchain. The interesting thing about that is we actually have what's called public verifiability, where anyone can look at the chain and verify that actually the program is executing correctly. So the source code for the program is public. And in fact, all the state transitions, all the execution of the program is public as well. So everyone can verify that the program is correct and that it's being executed correctly. So this is kind of the beauty of running programs on the blockchain. You don't have to trust anyone to run your program correctly.
00:10:51.814 - 00:11:35.626, Speaker A: You can just look at the data that was posted to the chain and make sure that the program is running correctly. By the way, we'll see what these programs do in just a minute. But basically that's kind of what this compute layer does. And in fact there are lots and lots of programs that have already been written to the blockchain. Here we have some examples like MakerDAO and others that we'll see in just a minute. These are programs that are several hundred lines long. They capture various business logic and they react to commands from the public, right? So people can issue transactions to these send messages rather to these applications and these messages cause these applications to process and maybe send funds from one person to another.
00:11:35.626 - 00:12:18.774, Speaker A: That's a state transition. But all those transitions are recorded on the blockchain and anyone can verify that they're actually correct. Okay, so that's kind of the third layer which consists of the actual applications running on top of the blockchain computer. So in this course you'll be writing some of these applications yourself so that you'll see exactly how they operate and how they execute on a blockchain. It's very interesting because it's actually a new way of writing programs and as you'll see, it requires new languages and it's actually quite different from traditional programming. So it's really kind of fun to learn how to write these applications. And then finally, the fourth layer is the layer that interacts with end users, right? So we can see you have our consensus layer here.
00:12:18.774 - 00:12:58.390, Speaker A: On the bottom we have the blockchain computer on which the programs are executing. So this blockchain computer typically is what's called a virtual machine emulator. So it's running a virtual machine. These DApps themselves are programs that run on top of the virtual machine and then the public basically here we have our end user. The public is interacting with various cloud servers that then themselves interact with these programs running on chain. Yeah, so the last layer, the fourth layer is basically the layer that actually takes commands from the users and actually reads and writes data to the blockchain. Okay, very good.
00:12:58.390 - 00:13:28.926, Speaker A: So those are the layers and I want to kind of stress that this ecosystem is an extremely active ecosystem. Yeah, this is just one graph that shows all the DeFi projects out there. This is way out of debt at this point. There are many, many more DeFi projects out there but nevertheless, I want to call out a few of the main ones that I'm really excited about. So for example, compound is a lending protocol. It's very, very interesting in how it does its lending. We're going to talk about compound at length during the course.
00:13:28.926 - 00:14:08.154, Speaker A: But that's an example of a program that's running on top of the blockchain computer. In this case it's running on top of the ethereum blockchain computer. Another one is Uniswap, which is basically an exchange. It allows you to exchange one type of currency for another type of currency. Again, this is a program that's running on top of the blockchain computer and anyone can interact with it and use it to exchange one asset for another. So that's another example of a DAP. And by the way, the way you interact with it is you interact with the uniswap cloud servers, which then interact with adapt itself, or you can choose to interact with adapt directly from your laptop if you want to.
00:14:08.154 - 00:14:40.534, Speaker A: So it's sort of up to you how you actually interact with the application itself, either directly or through some cloud service provider. Another thing I want to call out is a whole bunch of custodial services that emerged. So custodial services basically help you protect your assets when they're stored on the chain. You want to make sure that your key, the key that authorizes transactions. You want to make sure that key is safe and secure and these custodial services will help you basically secure the key. Yeah. So again, very interesting area of how to build custodial services.
00:14:40.534 - 00:15:33.938, Speaker A: And finally I'll call out MakerDAO and their Dai currency, which is a stablecoin. We'll talk about stablecoins again at length during the course, which is basically a program that tries to build a currency that's stable even though it's built on top of an unstable infrastructure. Stable in the sense that its value doesn't change dramatically from day to day, even though the underlying assets like Bitcoin and ethereum or other assets might actually fluctuate quite wildly. Dai is meant to be a stable currency that does not fluctuate as much. Yeah, and again, we'll talk about how this works later in the course. So the interesting thing is there are lots and lots of experiments happening in the space, lots and lots of DeFi projects that are running and managing billions of dollars in assets. It's really quite remarkable to see these programs actually manage a huge amount of funds.
00:15:33.938 - 00:16:19.634, Speaker A: And so obviously it's really important that these programs don't have bugs in them and that the public trusts them. So again, this is why it's so important that the code for these programs is public, so anyone can inspect it and that their execution is public, so anyone can make sure that these programs are running the way they're supposed to be running. Yeah, so all this is happening all around us quite successfully and it's an ever growing space, which is again, exactly what this course is about. Okay, so let's get started. So this was just my quick introduction. The next segment is going to be we're going to dive right in and the next segment is going to be about cryptographic background, basically the cryptographic primitives that are needed to understand how a blockchain works. Okay, so we'll see you in just a minute.
00:16:19.634 - 00:16:47.662, Speaker A: Welcome back everyone. In this segment we're going to look at the cryptographic primitives that are needed to make a blockchain work. So let's dive right in. The first cryptographic primitive I want to tell you about is what's called the cryptographic hash function. So a hash function basically is an efficiently computable function that maps a large domain into a small range. So you can see here the domain M is much, much larger than the range T. The picture you should have in mind is that we might be hashing megabytes of data.
00:16:47.662 - 00:17:17.494, Speaker A: So very, very large amounts of data that are provided as input to the hash function, they get hashed. But no matter how much data is provided, the hash function always only outputs 32 bytes in this case. Yeah. So large amounts of data come in, a fixed amount of data comes out. Very short, 32 byte digest, 32 bytes is 256 bits. And so we say that in this case, the range is zero one to the 256, which means all 256 bit binary strings. Yeah.
00:17:17.494 - 00:18:02.806, Speaker A: And again, 256 bits is 32 bytes. So we'll be thinking of these hash functions as outputting 32 bytes for the rest of this segment. Now, a key concept in studying cryptographic hash function is what's called collision resistance. So to explain collision resistance, let's first of all understand what is a collision. So a collision for a hash function, H from M to T is basically a pair of distinct inputs, x and Y, such that H of X is equal to H of Y. So we say that X collided with Y because H of X is equal to H of Y. Now, because the domain is so much larger than the range, there are many, many more messages in the input space than in the output space.
00:18:02.806 - 00:18:55.240, Speaker A: Clearly, by the pigeonhole principle, there are going to be many collisions, right? There are going to be many inputs X and Y that happen to collide just because the range is so much smaller than the domain. The point of a collision resistant hash function is that even though there is a huge number of possible collisions, it's hard to point to even one explicit collision. Yeah, it's hard to find even a single pair XY that happens to collide for the hash function H. So if that's true, if the hash function H has this property, we say that H is collision resistant, and we'll write that H is a CRH. CRH just stands for collision resistant hash. So you might be wondering, well, what's an example of a collision resistant hash function? And the canonical example is this hash function called Shot of 56. This is a fixed hash function that's actually specified in a federal standard.
00:18:55.240 - 00:19:49.778, Speaker A: What it does is it takes an arbitrary amount of data well up to two to 64 bytes. So potentially megabytes, even petabytes of data, and it always mapped them to a 256 bit output, which again means 32 bytes. Okay? So again, huge amounts of data come in, 32 bytes come out, and the function is collision resistant, which means that it's difficult to find two distinct messages that happen to map to the same 32 byte digest. Now, if you want to see how collision resistance is built and how shot 356 works, I'm not going to describe that here, but I would refer you to my cryptomu. You can take a look at the lecture on collision resistance. And there's a lot of information there on why the hash function is built the way it is, and how these collision resistant hash functions actually operate. But for now, we'll take shot 256 as a given, and we'll assume it's collision resistant.
00:19:49.778 - 00:20:21.934, Speaker A: So there are many applications for cryptographic hash functions. They're useful in proof of work consensus, which we're not going to talk about here. Instead, I want to talk about an application for collision resistance that has to do with committing to large amounts of data. Okay? So imagine Alice has a file or maybe a message which will denote by M. So she has a fairly large amount of data. And what she will do is she will commit to this data by publishing a hash of the message M. So the hash is only 32 bytes.
00:20:21.934 - 00:21:16.738, Speaker A: So it's a very, very short commitment to possibly megabytes of data. And we want to say that this little digest H actually commits her to the message that she just committed to. So what does that mean? Suppose Bob actually has the commitment. So Bob has the little H output of the hash function, and then later Alice sends to Bob the message M Prime, claiming that this is the message that she actually committed to. Okay, well, Bob can check that H of M Prime is equal to little H. And the claim is that if the hash function is collision resistant, then if this equality holds, then Bob is convinced that the message M Prime really is the message that Alice committed to. Let's say that more precisely, if H is a collision resistant hash and H of M Prime is equal to little H, then Bob is convinced that M Prime is equal to M.
00:21:16.738 - 00:22:05.762, Speaker A: Yeah. And why is that true? If somehow Alice was able to find M and M Prime such that H of M is equal to H of M Prime, but M is not equal to M prime. Well, that would be a collision for the hash function H. But because we assumed H is collision resistant, that's going to be difficult for her to do. So what this means is again, that if Alice publishes a collision resistant hash of her message, m, then that little h, that little hash value, little h, is committing her to the message, m. And the only way that she can find an M prime that maps to little H is if M prime is equal to M. Okay, so we say that this is what's called a binding commitment to the message M because once Alice publishes little h, she can no longer change her mind about little M.
00:22:05.762 - 00:22:43.402, Speaker A: Now, one thing that I want to point out is that this sort of commitment is not a hiding commitment in the sense that the hash of the message M might actually leak information about M. Yeah. And so this is not a hiding commitment. It's not hiding the message, but it is binding in the sense that once Alice commits, she can no longer change her mind about the contents of the message. So let's look at a more interesting application, which is committing to not just a single message, but in fact, a list of messages. And just looking ahead, the list of messages we're going to be interested in committing to is going to be a list of transactions in a block. So suppose we have M one to MN.
00:22:43.402 - 00:23:24.538, Speaker A: These are N different messages that let's say they form a list, and we'll call this list S. Now, our goal is to build a commitment scheme with the following property. So Alice is going to publish a short, binding commitment to S, okay? So once she publishes the commitment, she can no longer change her mind about the committed messages. And this commitment is going to be this short digest. So it again has to be just 32 bytes. Now, again, as before, bob is going to obtain this commitment value, so he's going to obtain little H. And then later on, Alice would like to prove that the message at position I is equal to Mi.
00:23:24.538 - 00:24:12.630, Speaker A: And to do that, she's going to send to Bob the message Mi, along with some sort of a proof, which we'll call pi I. Pi stands for proof that this proof, Pi I, will convince Bob that the message at position I, the committed message at position I is really Mi. Yeah. So s of I is equal to mi. To do that, Bob is going to run through some verification algorithm. The verification algorithm is going to take the commitment, the index, the candidate message Mi, and the proof, and is either going to accept or reject that proof. From a security point of view, we'd like to say that an adversary cannot find a list S, an index I, a message M, and a proof Pi, such that M is not equal to S of I, and yet the proof is accepted by the verification algorithm.
00:24:12.630 - 00:24:43.494, Speaker A: Yep. This should be hard. And if that's true, then we say that this is a valid commitment to a set that allows opening of elements in this set. So how do we do this? So how do we commit to a set and then later open up only one element in the set using a very short proof? So the trick to do this is what's called a Merkel tree. Okay? This is due to Ralph Merkel already back in 1989. So it's an old idea, but this idea is so important that it's now used everywhere in the blockchain space. So let's see how this works.
00:24:43.494 - 00:25:16.758, Speaker A: So we're going to commit to a list of size n. Here we'll assume we have only eight elements, so N is equal to eight. We want to commit to these eight messages and then we want to be able to later prove that entry number I in the list is equal to mi. So the way we're going to do that is by committing, by forming a merkel tree. And we're going to produce this short commitment, h, which is again, just 32 bytes, nothing more. Very, very short commitments. Even though we might be committing to a million elements where each element is a megabyte long, the commitment overall is just 32 bytes.
00:25:16.758 - 00:25:44.518, Speaker A: And the way we do that is basically by forming this merkel tree. So a merkel tree is basically a tree of hashes where we can see that we're hashing all bottom pairs, then we're hashing all hashes. Yes. So that's how we get the second layer of hashes. Then we hash again all hashes. And then finally, once we're done to a single hash, that's going to be the final commitment that we're going to send over to Bob. Okay? So let's just give names to wires.
00:25:44.518 - 00:26:15.182, Speaker A: So we'll call them y one, y two, up to y six. These are the internal hash values in the merkel tree. And now let's suppose that we want to prove that S four is equal to M four, okay? So we want to open up the fourth element in our list and then provide a proof that in fact, m four really is the thing that we committed to at position four. Well, the way we're going to do that is using the following proof. The proof is going to consist of the element m three, y one, and y six. So let me show you what they are. So here are the elements.
00:26:15.182 - 00:26:58.622, Speaker A: And what they are is really you look at the path from m four all the way to the root, and for each element along this path you provide the sibling of that element. So for m four we provide a sibling, namely m three. For y two, we provided sibling, namely m one, and for y five we provided sibling, namely namely y six. So the proof consists of these three elements. More generally, if we had a tree with N leaves, the depth of the tree would be log base two of N. So the proof would consist of log base two of N hashes, which is really quite remarkable because that means it's a really short proof. Think about a tree that contains a million elements.
00:26:58.622 - 00:27:29.802, Speaker A: So imagine we're committing to a million elements. Well, log base two of a million is around 20. So that means that the proof for proving that m four is really what it's claimed to be. The proof would only contain 20 hashes because a log of a million is around 20. Okay? So using a very short proof, we can prove that m four. Is the value that's claimed. And now how does Bob actually verify the proof? So, again, we want to prove that S four is equal to m four.
00:27:29.802 - 00:27:52.062, Speaker A: Well, what Bob would do is the following. It's kind of basically following up the path. So he would take the claimed m four along with the element m three from the proof and hash those together. That would give it a candidate for y two. Then it will take y two and hash it along with the element y one from the proof. That would give it a candidate for y five. It would take y five and hash it along with y six from the proof.
00:27:52.062 - 00:28:37.582, Speaker A: And then y five and y six together will give it a candidate h prime for the merkel output, and then it will check if H is equal to H prime, it will accept. Otherwise it will reject. Okay, so not only is the proof contains only log n hash values, the verifier Bob can verify that the proof is correct by literally computing only log n hashes. So, very, very fast verification of these merkel proofs. So, again, very easy way to prove that a particular element in the committed set is what we claim it to be. So in this case, m four is the m four that we claim it to be. The proof contains only login elements, and it also only takes login hash operations to verify this proof.
00:28:37.582 - 00:29:11.840, Speaker A: Okay, so one last time. So, Alice committed to a list of a million values, well, in this case, eight values, but in general, a very large list of values. And then she can later open up any element in that list and prove that that element is consistent with the public commitment to the entire list. Yeah, again, in this case, H was the public commitment to the entire list. And Alice can prove that m four is in fact the fourth element in the list that she committed to. And the proof is really short. It only contains three values, and that's it.
00:29:11.840 - 00:29:55.580, Speaker A: So you can prove a security theorem that shows that this scheme, in fact, is secure. In particular, if H is a collision resistant hash, it's fairly easy to prove that, in fact, the adversary cannot come up with a list s, an index i, a candidate m and a proof pi such that m is not the ith element in the list. And yet this verification procedure will accept m as if it were the ith element. This is actually a good exercise to try and prove yourself. If you want to prove this, try to prove the contrapositive. Namely, if Alice could come up with such a fortuple, then she would be able to break collision resistance of H. Yeah, it's a good, cute exercise to do, and I recommend that you try to prove this yourself.
00:29:55.580 - 00:30:52.010, Speaker A: So what is this all useful for? So, we're able to commit to a large list of values and then later open a particular element in the list and prove that that element was opened correctly. Why is this useful? Well, it turns out it comes up all over the place. Yeah. So for example, when writing a block of transactions we're going to keep, the only thing we're going to write to the actual blockchain is going to be a commitment to the block of transactions. But later on anyone can prove that any particular transaction is in the block by simply providing a merkel proof that that transaction is included in that commitment. Okay? So it's an easy way to commit to a large list of transactions in a block using a very short commitment. And then if you're interested in a particular commitment in that block, you can actually prove that that commitment was included in that block.
00:30:52.010 - 00:31:38.474, Speaker A: So really when you think about what a blockchain is, it really is just a bunch of merkel root commitments. Okay, so really a blockchain contains a bunch of block headers. So here you can see that there's a merkel root commitment to a tree of transactions that are committed to in this block, but the block header really just includes the merkel root. There's some other data which we won't get into, but that's not important. The main important thing here is that the block header contains a merkel commitment to a list of transactions. The next block basically contains a hash of the previous block header, just a block header, and then there's a merkel route to another set of transactions and so on and so forth. Right.
00:31:38.474 - 00:32:19.698, Speaker A: The next block contains a hash of the previous block header. This hash chain is what forms the actual blockchain. But the point is that every block header contains basically a merkel commitment to its transactions. And then if at any point in time I want to show that transaction two is really on the blockchain, all I need to do is just provide a merkel proof to this merkel route that transaction two is in fact the value that I claim that it is. Yeah, so as it says here, merkel proofs are used to prove that a transaction is on the blockchain. All right, so this is kind of the abstract view you should have of what a blockchain is. And so this is all I wanted to say about cryptographic hash functions.
00:32:19.698 - 00:32:48.834, Speaker A: In the next segment we're going to talk about digital signatures and we're going to see how they're used to authorize transactions. Okay, see you in a few minutes. In the last segment we looked at cryptographic hash functions and how to use them to commit to data on the blockchain. In this segment we're going to look at digital signatures and how they're used to approve transactions. So let's get started. In the physical world, a signature is used to bind an author to a particular document. For example, I might sign a check for $1 and that binds and the signature binds me to that check.
00:32:48.834 - 00:33:42.542, Speaker A: The problem is that when we try to move this idea to the digital world, we immediately run into a problem, right? If my signature was simply just some sort of a picture of my name, then it's quite easy for someone to take that picture and simply copy it onto a different document that has the same picture on it, the same signature. But now the document says something completely different, right? This document would be a check for $100. So the idea of taking physical signatures and moving them to the digital world as is simply doesn't work. It's very easy to copy a signature and therefore we cannot just use pictures as a way to sign a document. So the question is what to do? And so the solution is basically to make it so that the signature itself depends on the document being signed. Okay? So the signature that we're going to attach to authenticate a document will depend on the content of the document. So the way a signature scheme works is as follows.
00:33:42.542 - 00:34:38.174, Speaker A: We have, again, we have the data that we want to sign. So a check for $1 in this case and then basically the signer Bob here is going to have a secret signing key that's going to feed into a signing algorithm, okay? So the data to be signed along with the secret signing key is going to be given as input to a signing algorithm. The signing algorithm is going to produce a signature and that signature will be attached to the document that's about to be signed. Now the Verifier who wants to verify that the signature is legitimate, all what they need is basically the corresponding public verification key. So this public verification key is derived from the signing key and basically the signature and the data are used basically to verify that the signature is valid. And the Verifier basically either accepts or rejects the signature as a valid signature on the document. So in more detail, let's look at the syntax of a digital signature scheme.
00:34:38.174 - 00:35:11.114, Speaker A: Again, these schemes are used everywhere in the blockchain space, so I want to make sure you understand how to interact with them. And so there are three algorithms. Basically. There's a key generation algorithm which we'll call Gen, which outputs the signing key, the secret signing key, and the public verification key. So we'll denote them by SK and PK. There's a signature algorithm that takes the signing key and the message to be signed and outputs a signature sigma. And finally there's a verification algorithm that takes the public verification key, the message that was supposedly signed, and the signature.
00:35:11.114 - 00:35:42.250, Speaker A: And the algorithm either accepts or rejects the signature. Okay, so that's it. That's what a signature scheme is. It's just these three algorithms. And informally, we can define what the security property for a signature scheme needs to be, which basically sees that it says that an adversary who sees many signatures on many messages of her choice from the signer. So she can ask the signer to sign many, many messages of the adversary's choice. Still, that adversary cannot forge a signature on any new message.
00:35:42.250 - 00:36:17.662, Speaker A: So that's the security property. This is often called existential unforgerability under a chosen message attack. But we won't define that formally, we'll just leave it at this informal level for now. But the thing that I want you to remember is even though you might see many signatures on many different messages, that still makes it very difficult to forge a signature on some new message. Okay, so there are lots of constructions for digital signature schemes here. I'm going to focus on three that are primarily used in the blockchain space. And so let's talk about the three families.
00:36:17.662 - 00:36:50.846, Speaker A: The first one is called RSA, which actually is not used in the blockchain space. It's just a classic signature scheme, so I wanted to mention it. So the RSA signatures, primarily the reason they're not used in the world of blockchains is because they generate relatively long signatures. And also the public keys happen to be relatively long. So over 256 bytes. The benefit of RSA signatures, which is why they're often used for certificates on the web, is that they're quite fast to verify. So once a signature is issued, the Verifier can verify a signature quite quickly.
00:36:50.846 - 00:37:24.870, Speaker A: But because signatures tend to be relatively large, over 256 bytes, if we had to write these signatures to the blockchain, that would be a lot of extra space on the blockchain. So we'd rather use signatures that signature schemes that produce much, much shorter signatures. The next family I want to mention is what's called a discrete log signature. And there are two that are used in the blockchain space. One is called Schnor and the other one is called ECDSA. The world is slowly moving towards Schnorr signatures. They have a lot of benefits for blockchain applications.
00:37:24.870 - 00:37:59.430, Speaker A: In particular, the bitcoin is about to move to using Schnorr signatures as part of their next updates. The nice thing about discrete log signatures is that they produce relatively short signatures, either 48 or 64 bytes, depending on exactly what type of signature you're using. So much shorter than RSA. And the public keys also tend to be relatively short, around 32 bytes. And that's it. Okay? So again, every time you sign a message that produces a signature, that's either 48 or 64 bytes. And the Verifier needs to have 32 bytes in order to verify that signature using the public key.
00:37:59.430 - 00:38:43.794, Speaker A: The third category of signatures I want to mention are called BLS signatures. So BLS signatures also produce relatively short signatures. There are about 48 bytes. But the interesting thing about BLS signatures is they have additional properties which make them quite amenable to blockchain applications. The first property is what we call aggregation, which means that you can take many signatures from many different signers on many different messages and compress all those signatures into a single 48 byte short signature. Okay? So if you have many transactions with many signatures embedded in them, in fact, you can compress all those signatures into a single signature and just write one signature onto the blockchain. So this actually saves quite a lot of space on the blockchain itself.
00:38:43.794 - 00:39:21.370, Speaker A: This property, by the way, is the reason why Ethereum 2.0 is using BLS signatures for their consensus protocol there. What happens is you have potentially thousands of people signing a particular message, and this aggregation property allows anyone to take those thousands of signatures, compress them all into a single signature, and write that on the blockchain. So we save space on the blockchain. And it's also quite easy to verify this aggregate signature with very little work. So not only does it provide compression on the blockchain, it also simplifies the Verifier's work. The other nice property of these signatures is they support a very easy threshold mechanism.
00:39:21.370 - 00:39:53.050, Speaker A: So you can build, for example, a three out of five signature scheme with very little work using BLS signatures. It's actually quite straightforward. And for this reason, as I said, ethereum 2.0 uses it, the Chia network uses it, affinity uses it, and so on. So one issue with these three families of signatures is that none of them are resistant to quantum attacks. So if somebody is able to build a quantum computer many years from now, then these signatures would become insecure and we would need to move to something else. Fortunately, we know exactly what to move to.
00:39:53.050 - 00:40:18.862, Speaker A: So a quantum computer is not really a threat to the blockchain. It just means that the signature mechanism would have to be updated. What's interesting is actually that there are a couple of post quantum secure signatures. These are signature schemes that are secure even if the adversary has access to a quantum computer. The one downside of these signatures is they tend to be relatively long. Yeah. So the reason we haven't moved already to post quantum signatures is because there's some cost involved.
00:40:18.862 - 00:40:49.542, Speaker A: But if the situation arises, and again, many decades from now, we would have a quantum computer, then in fact we know exactly what to do. We know what signatures can use to move to. It would just make the blockchain a little bit bigger than what it is today. Okay? So that's kind of the situation when it comes to signature families that we can use. And as I said, signatures are used everywhere on the blockchain. They're used to basically authorized transactions. So if Alice wants to pay Bob, she would sign that transaction.
00:40:49.542 - 00:41:32.262, Speaker A: That transaction would go onto the blockchain and would only get posted if Alice's signature is valid on that transaction. Okay? So we use it to authorize transactions. Signatures are also used in governance votes. If we want to change the rules of a particular DeFi project, the voters, people who own governance tokens, will vote by issuing a signature for or against a particular proposal. So they're often used in governance, and as I said earlier, they're also used in consensus to basically make sure that a large fraction of the population agrees with a particular block that's being proposed. Okay, so again, if we look at transaction authorization, you can see that we have, say, a bunch of people who issue transactions here. We see the transaction that they generate.
00:41:32.262 - 00:42:06.750, Speaker A: It turns out the transaction data alice pays Bob, say, five E is actually relatively short. Most of the transaction data is being taken up by the digital signature. Yeah, which is kind of interesting that the authorization data is bigger than the transaction data itself. We'll see the importance of that actually in the next segment when we talk about scaling. So all the people who are issuing transactions will sign their transactions. They'll post these signed transactions to the blockchain. The miners will verify that the transactions themselves are valid and that they're properly signed, and if so, they'll put them in a block and post them on the blockchain.
00:42:06.750 - 00:42:56.274, Speaker A: Okay? So that's how transaction authorization happens, using digital signatures. So that's actually all I'm going to say about digital signatures here to keep it short. That's really all we need for a high level DeFi class. So to summarize the primitives that we looked at so far, if you recall in the last segment, we looked at collision resistant Hash functions and merkel trees and how they're used to commit to data on the blockchain. We just looked at how digital signatures are used to authorize transactions and how they could be used in governance and consensus. There's one third important cryptographic primitive that I want to mention that's also quite useful in the blockchain space, and that's what's called a Snark proof, which allows Alice to prove to Bob that a certain fact is true, using a very short proof that's also very easy for Bob to verify. Okay? So I'm not going to talk about Snark proofs here.
00:42:56.274 - 00:43:27.726, Speaker A: I'll just say that they're used quite heavily for scaling the blockchain and for privacy applications on the blockchain. We're going to talk about Snark proofs in quite a lot of detail, actually, when we come back to talk about privacy on the blockchain. And so be patient, and we will cover Snarks in much more detail when we talk about privacy on the blockchain. Okay? So that brings us to the end of this segment. In the next segment, we'll talk about scaling techniques. And basically the question is, can we make the blockchain fast and cheap? Okay, so we'll see you then. Welcome back, everyone.
00:43:27.726 - 00:43:58.038, Speaker A: In this segment, we're going to talk about scaling the blockchain. There's a lot to cover here, so let's get started. So traditional blockchains like Bitcoin and Ethereum have a relatively low transaction rate. For example, the Bitcoin network can handle between five and ten transactions a second. The Ethereum network can handle between 20 and 30 transactions a second. But not only are the transaction rates relatively low transaction fees also tend to be quite high. For example, in moments of contention ethereum transaction rates can go as high as $60 or even more.
00:43:58.038 - 00:44:48.150, Speaker A: Just to show you a recent graph of this, here are the Ethereum transaction fees, also known as gas prices over time. And you can see there are moments like earlier this year where transaction rates went up to almost $70 for a simple transaction. And you can see that there are many, in fact points in time where transaction rates are actually quite high. So that's quite a problem with these blockchain systems especially when you compare them to more traditional transaction processing systems. For example, the Visa network can handle way more transactions a second than Bitcoin and Ethereum. It can handle tens of thousands of transactions a second with relatively lower transaction fees. So the question we want to study in this segment is basically can we scale the blockchain to visa speeds and do it in such a way that we also maintain very lower transaction fees? Yeah, so that's the question.
00:44:48.150 - 00:45:23.054, Speaker A: Now, this is a very, very active area of research and there are lots of ideas for how to do this. In fact, there are many, many developments in the space and many deployments that are coming online. So let me quickly run through a couple of approaches and then we'll focus on two particular ones. Yeah, so there are many, many approaches for scaling the blockchain. One approach is basically to use basically a faster consensus algorithm. One of the reasons that Bitcoin and Ethereum have a relatively low transaction rate is because of the particular choice of consensus algorithm they use. So, in fact, more modern blockchains use different consensus algorithms that are faster.
00:45:23.054 - 00:45:40.482, Speaker A: For example. Solana polkadot. Avalanche. These are faster consensus algorithms. As a result, they can handle many more transactions a second than Bitcoin and Ethereum. And in fact, some of these are even EVM compatible. So literally, you can take Ethereum contracts and simply move them to these networks.
00:45:40.482 - 00:46:10.674, Speaker A: So that's one idea. Basically use a faster consensus algorithm. But we really like Ethereum and we'd like to stay with it and we'd like to make it better. And so there have been a number of ideas just to try and speed up Bitcoin and Ethereum to make them handle more transactions per second. So one idea is called payment channels, which we'll talk about in a second. Basically, what it allows us to do is process many, many thousands of transactions a second. But in fact, most transactions don't have to touch the blockchain at all.
00:46:10.674 - 00:46:38.822, Speaker A: Yeah, most transactions happen only peer to peer. And the classic example of this is the Lightning network as we'll see in just a minute. Another approach for scaling up Ethereum is called roll up. And this is a really beautiful idea that we'll talk about more in just a minute. And in fact, there are two types of rollup systems. One is called ZK rollup and the other one is called optimistic rollup. And the idea here is, again, to batch many transactions from users into a single transaction that's going to get written to the blockchain.
00:46:38.822 - 00:47:15.686, Speaker A: As a result, transaction fees are much lower. And also the fact that the chain is slow doesn't matter because each transaction that gets written to Ethereum actually represents thousands of transactions that are being processed. So again, this is a very, very pretty idea that we'll talk about. And then there are other ideas like sidechains, and there are many, many other proposals as well. The two that I want to focus on here are basically payment channels and roll up. Yeah, so we'll talk about those in a minute. One thing that I do want to say is that there are a lot of details that go into making payment channels and roll ups work in the allotted time.
00:47:15.686 - 00:47:51.794, Speaker A: I won't be able to go into all the details. So I'm going to focus on sort of the high level ideas of how these systems work. And then the reading materials for this week have a lot more information about the specific details of how both payment channels and roll up systems work. Okay? So let's get started. And the first thing I want to tell you about is payment channels. Okay? So again, a very elegant idea that allows you to speed up either Bitcoin or Ethereum to handle many more transactions by basically keeping most transactions off of the blockchain. So to give one example for how payment channels could be used, let's consider our friends Alice and Bob here.
00:47:51.794 - 00:48:27.450, Speaker A: And let's imagine Bob is a coffee shop, and Alice wants to buy coffee every morning at Bob's coffee shop. What Alice could do, naively, is she would pay a few dollars for coffee every morning. And each one of those transactions would have to be written separately to the blockchain, which is very inefficient, very expensive and very slow. A better way to do it is to basically establish what's called a payment channel. Okay? So Alice is going to create a payment channel to Bob, and she's going to deposit $100 into this channel. Now, when she creates the channel, she actually has to write this data to the blockchain. So this, in fact, is expensive and slow, involves transaction fees.
00:48:27.450 - 00:49:06.886, Speaker A: But as we'll see, this is a one time thing that she has to do. Okay? So the channel itself could be represented on the Bitcoin network as what's called a UTXO. An unspent transaction output could be represented on the Ethereum network inside of a smart contract, a decentralized application. But how it's actually represented is not so relevant to us here. The point is, she created a channel that contains $100 and that's recorded on the blockchain. Now what's interesting about this channel is the logic that needs to be satisfied in order to spend those $100. Okay, so this logic is what's called an HGLC logic, which stands for hashed time lock contract.
00:49:06.886 - 00:49:35.390, Speaker A: So what does that mean? Basically, it means that there are two ways to spend the funds in the channel. Yeah, there is two ways to close the channel. One way is Alice can issue a transaction herself using her own signature. So a transaction using only Alice's signature. And then she can close this channel and pay all the $100 back to herself. However, there is a limitation here in that she can only issue those transactions 30 days after the contract was created. So 30 days after the channel was opened.
00:49:35.390 - 00:49:53.722, Speaker A: All right. So basically, she deposits $100 into the channel. 30 days later, she can actually get those $100 back if she so wants. So that's one way to close the channel. And by the way, this is why it's called a time lock. Because she has a time lock of 30 days before she can get her money back. However, there's another way to close the channel.
00:49:53.722 - 00:50:20.194, Speaker A: And that is that anyone can submit a transaction with both Alice's signature and Bob's signature on that transaction. So both of them are authorizing this transaction. And it turns out that allows you to close the channel right away. And we'll see how that's used in just a minute. Okay, so this is what's called HTLC logic, where there's a time lock way to close the channel. Or there's a way to close the channel if both sides actually approve closure of the channel. Okay.
00:50:20.194 - 00:51:02.926, Speaker A: And then Bob of course, Bob, the coffee shop verifies that the channel was created correctly and that in fact, Alice can pay Bob up to $100. Okay, what happens next is now say Alice wants to pay Bob $5. What she'll do is she's going to do it without ever touching the blockchain? What she'll do is she'll create a transaction that says distribute the funds in the channel as $95 go back to Alice and $5 go back to Bob. And here is Alice's signature on this transaction. Notice that this transaction was sent completely off chain. We didn't touch the blockchain at all for this transaction to go through. Now, this transaction by itself is not useful for anything because it's only got Alice's signature on it.
00:51:02.926 - 00:51:28.822, Speaker A: However, if Bob wants to, he can sign this transaction as well. So now this transaction would have both Alice's signature and Bob's signature. And then, if he wants to, he can go ahead and close the channel. And then $95 will be paid to Alice and $5 will be paid to Bob. However, it's in Bob's interest to wait, not to do anything. He's just going to store this signed transaction from Alice. He's going to keep it in his memory and not do anything with it.
00:51:28.822 - 00:52:23.834, Speaker A: At least not until 30 days have gone by. If he waits more than 30 days, alice could then take all the money in the channel back, but say 29 days after the channel was created, he might actually use this transaction by signing it himself, close the channel, and get his $5. Okay? So basically, by Alice sending Bob this transaction, effectively, she's enabling Bob to get $5 at any time that he wants up to 30 days after the channel was created. So Bob can now give Alice her cup of coffee, and he's assured that he's going to be paid the $5 if he deposits the transaction before the 30 day period is over. And now Alice can pay again. So say she wants to pay him now $15. What she'll do is she'll sign another transaction that says, well, now Alice is going to get $80, and Bob is going to get 20, right? So remember the $5 from yesterday and the $15 from now.
00:52:23.834 - 00:53:00.374, Speaker A: And now Bob has this other transaction, which, if he wants to, he can sign and close the channel, and he would be paid $20, and Alice would be paid $80 and so on and so forth. You can pay him another $10. And again, now Bob would get $30 if he uses this transaction to close the channel. And you notice that all these payment transactions are happening peer to peer. We never touch the blockchain for transferring these funds from Alice to Bob. Now, let's suppose at some point they do want to close the channel. So let's say 29 days have gone by, and now Bob actually wants to close the channel before Alice can take all the money back.
00:53:00.374 - 00:53:42.030, Speaker A: So what Bob would do is he would sign the latest transaction from Alice, which says that Alice gets 70 and Bob gets 30. And then he would submit that transaction with both Alice's signature and Bob's signature to the blockchain. And what the blockchain does is basically distribute the funds so the channel gets closed, and the funds get distributed according to the rules of the transaction. So now Bob got paid $30. And you notice, even though Alice made potentially many, many payments to Bob, all of those payments didn't touch the blockchain. The only thing that touched the blockchain is the creation of the channel and the closing of the channel when the time lock is about to expire. So this is a pretty cool way to scale up transaction rates on a blockchain.
00:53:42.030 - 00:54:06.714, Speaker A: So that even though the blockchain might be very slow, most of the time, we never need to touch the blockchain. Most of the transactions are simply handled peer to peer. Now, it turns out there's a lot more to these payment channels. So far, the only thing we described is a payment channel that allows Alice to periodically pay Bob. It turns out you can also build bi directional channels. It's not that hard. In fact, it's a good exercise to see how to do that.
00:54:06.714 - 00:54:36.786, Speaker A: If you give up, then go ahead and look at the reading materials. There's a description there on. How to build a bi directional channel. So a bi directional channel would allow Alice to send money to Bob over and over and over, and it would also allow Bob to send money to Alice over and over and over, as long as they don't exceed more than Alice spending more than $100 with Bob, or Bob spending more than $100 with Alice. If they both open a bi directional channel of worth $100, everything happens off chain. Yeah. So they can send funds to one another over and over.
00:54:36.786 - 00:55:02.026, Speaker A: As long as the chain funds are not exhausted, they can keep doing that without ever touching the blockchain. Yeah, it's, again, a very, very cute idea how bi directional channels work. I'm going to refer you to the reading materials. We won't have time to cover that here. But again, it's kind of a good homework exercise to try and figure out how to build a bi directional channel yourself. And if you can't, you can look it up in the reading materials. Once we have bi directional channels, things become really interesting.
00:55:02.026 - 00:55:41.066, Speaker A: Now we can build what's called a payment network. Okay, so a payment network works basically by Alice setting up a bi directional channel with some entity, not necessarily with Bob, but with some entity, which in the real world typically would be called a bank. Right? And then these banks could also set up bi directional channels among themselves. And finally, Bob would actually have a bi directional channel with his bank. So now we have what's called a payment network. And in fact, if you look at a lightning network today, there are something like 25,000 nodes in that network. So 25,000 of these intermediate entities that people have set up bi directional channels with.
00:55:41.066 - 00:56:25.282, Speaker A: And now when Alice wants to pay Bob, what she would do is actually she would find the cheapest route through this network. Cheapest in the sense that the lowest transaction fees. So, of course, if you want to move funds using this bi directional channel, the bank is going to take some cuts, right? They're going to take a transaction fee because they're not going to move funds for free. And so what Alice could do is she could basically find the path in the network that is the cheapest one to go through, and then that's how she would send funds to Bob. Yeah. So it's very interesting in that we're kind of replicating using these payment channels. We're replicating a traditional payment network where you basically route funds through potentially a number of intermediaries until the funds reach their destination.
00:56:25.282 - 00:57:03.010, Speaker A: And in fact, there's even some work that's also in the reading materials about making it so that the funds actually follow multiple paths. So that increases the chance of the funds actually getting to the recipient. Okay, so there's a lot of work on how to actually route funds inside of a large network. The bottom line is that basically, as long as these channels are open. All these transactions happen between Alice and her bank and Bob and his bank, and really, nothing touches the blockchain. The only time we need to touch the blockchain is either if there's a dispute or channels need to be opened or closed. Yeah, so that's pretty interesting.
00:57:03.010 - 00:57:58.246, Speaker A: And you see that once we have this network working, the rate of the lower level blockchain doesn't really matter because we hardly ever touch it. So, again, that's a very important lesson to remember. So many of you may have heard of this recent exciting news that the entire country of El Salvador is making Bitcoin legal tender in the country, right? So literally, people can walk to a grocery store and buy groceries with a cryptocurrency. Specifically, for now, they chose Bitcoin, but it's likely that they will expand to other cryptocurrencies as well. So as of September 7, 2021, people will be able to use their cryptocurrencies to actually buy goods at any vendor in the country. So the thing is that the Bitcoin network by itself is not fast enough to support all these countrywide transactions. If we can only handle five to ten transactions a second, that's not going to support the transactions in an entire country.
00:57:58.246 - 00:58:34.330, Speaker A: And so this Lightning Network idea, this idea of payment channels, is really critical for making this work. And just to be clear, lightning Network is an implementation of payment channels. And so payment channels are necessary to make this possible. And in fact, there's a wallet that's called a strike wallet that connects clients to the Bitcoin Lightning network. And it's very likely that in El Salvador, basically, this is how transactions will actually happen, using a wallet that actually connects people to the Lightning Network. And most transactions will just happen peer to peer. Okay, so this is all I wanted to say about payment channels.
00:58:34.330 - 00:59:18.206, Speaker A: Like I said, there's a lot more to say about payment channels, but I'm going to leave this to the reading materials, and we're going to move on to the next idea. So the next idea is how to scale the ethereum blockchain using a very pretty idea called rollup. So to explain how a rollup system works, I first have to tell you a little bit more about Snarks. We talked about Snarks at an earlier segment, and we're going to talk about them in much greater detail in a later lecture. When we talk about privacy on the blockchain in this segment, we're going to look at how Snarks are going to be used for scalability. So A Snark stands for a succinct, non interactive argument of knowledge. And what that means is basically it allows one party, which we call approver, to prove to a verifier that a certain statement is true.
00:59:18.206 - 00:59:46.850, Speaker A: So to make that more concrete, let's think of a program. And the only thing that we know about this program is that it always terminates in a fixed number of steps. So it always terminates for all possible inputs and at most capital B steps. Now, I'm going to use the letter C to denote this program. The reason I use the letter C is because typically we think of these things as circuits. But for simplicity, let's just talk about programs. And the only assumption is that the program terminates in a fixed number of steps.
00:59:46.850 - 01:00:14.458, Speaker A: Now, this program C takes two inputs. The first input is a public input, which will denote by X. And the second input is a private input which will denote by W. Sometimes we call this private input the witness, which is why we use the letter W to denote it. Now, in a Snark system there is a prover and a verifier. The prover knows the program, the public input, and the private input W. The Verifier only knows the program and the public input.
01:00:14.458 - 01:01:07.970, Speaker A: Now, what the prover is going to do is basically produce some sort of a proof that it knows a witness W that makes the program output one. Okay? So it's going to produce a proof and it's going to send this very short proof. This short proof is just a few hundred bytes to the Verifier. The Verifier is going to be able to run some sort of a verification procedure and effectively be convinced that the prover knows a witness W such that the program outputs one on input X comma W. So when you look at this, you would think, well, wait a minute, there's a really simple solution here. Why don't we just send W over to the Verifier? The Verifier can run the program C and verify that it outputs one on input X and W. The point of a Snark is that actually the Verifier's running time is going to be much, much less than running the program C itself.
01:01:07.970 - 01:01:48.490, Speaker A: So the proof itself is going to be just a couple of hundred bytes, no matter how big the witness is. And the Verifier's time is also going to be very, very short, even if the program C is somewhat complex. So this is why sending the witness simply in the clear and having the Verifier run the program C itself is sort of not the point. The point is that the prover is able to convince the Verifier that it knows a valid witness W one for which the program outputs one. But the Verifier's work is much, much less than actually running the program C. And also the proof, like we said, is very short. Okay, so you might already have some ideas for how this could be used for scaling the blockchain, but let's dive into the details.
01:01:48.490 - 01:02:37.082, Speaker A: So if you look at a traditional layer, one network, like Ethereum, basically every miner in that network has to verify every posted transaction, right? So we might have multiple people posting transactions to the network, but all the miners have to verify that all these transactions are valid. So all the transactions are properly signed, all the transactions are properly covered. So there's enough funding in the account that the transactions are applied to and so on and so forth. Now the idea of roll up is to kind of move away from that model. The idea of roll up is basically to introduce another party, which we're going to call the Roll Up Coordinator. And instead of the user sending transactions to the network directly, the users are going to send their transactions to the Roll up Coordinator. What the roll Up Coordinator will do is it will verify that all the transactions are valid.
01:02:37.082 - 01:03:16.934, Speaker A: So it will verify that they're all properly signed, that there are enough funds in the account, and so on and so forth. And what it will do is it will produce a short proof that all these transactions are valid and then it will send this proof over to the miners. Yeah. Now it also includes, along with the proof that all the transactions are valid, it also includes a short transaction summary. We'll see what this transaction summary is in just a minute. But the point is, all the miners have to do now is just verify that the short proof is correct. And we said that you can actually prove that like 1000 transactions are all valid, they're all properly signed, and they all have enough funds in the account using a very short proof.
01:03:16.934 - 01:03:51.218, Speaker A: That's very easy to verify. So the miners work now is just verifying a single proof, a single short proof. And that actually convinces them that all thousand transactions that were just processed by the coordinator are actually valid. So we get like 1000 X increase in Ethereum's processing speed thanks to these very fast to verify snark proofs. So let's look at this a bit more detail. And so let's see what the rollup coordinator actually does. So the rollup coordinator is going to be managing accounts for potentially millions of users, right? So here we have Alice and Bob all the way up to Zoe.
01:03:51.218 - 01:04:21.722, Speaker A: And you can see that the Roll up Coordinator is managing the account balances for each one of these users. So, for example, Alice has five Dai in her account and three Ethers in her account and so on and so forth. The coordinator is going to create a merkel tree of these accounts. Yes, the accounts basically live in the roots of a merkel tree. And the merkel tree is basically a tree of hashes such that the root, if you remember, is only 32 bytes long. It's a very short route. And the coordinator is going to write this route to the layer one network.
01:04:21.722 - 01:04:57.882, Speaker A: Okay? So at this point, the net miners in the Ethereum network need to do nothing. All they have to do is just remember this 32 byte route that commits to everybody's account balances, okay? Now a bunch of users come along and they want to transact, right? So, for example, Alice wants to send two ETH to Bob, and she signs this transaction using her secret key. Bob wants to do an atomic swap with Zoe. So Bob sends to Zoe one ETH. And Zoe sends to Bob two bat. And this transaction is signed by both Bob and Zoe. So that's called an atomic swap because both exchanges happen at the same time.
01:04:57.882 - 01:05:23.134, Speaker A: So either they both happen or neither one of them happens. So that's an atomic swap. And Carol also has a transaction that she wants to process. And there could be thousands of people who are submitting their transactions to the coordinator at this particular epoch. What the coordinator will do is basically update everybody's account balances. So you remember here, Alice has three ETH, but she's sending two ETH to Bob. So after the update, she only has one ETH.
01:05:23.134 - 01:06:26.834, Speaker A: Yeah. And similarly, the coordinator updates everybody's account balances according to the transaction that they just received, assuming all these transactions are valid. So, again, they all have to be properly signed, and everybody has to have enough balance in their accounts to cover these transactions. Now, what the Royal Coordinator obtains as a result is basically a new route to a merkel tree that contains a commitment to everybody's updated balances. All right? Now what the coordinator is going to do is it has the old route, it has the new route. It has to construct a Snark proof that the new root is, in fact the result of applying a sequence of valid transactions to the old route. Well, so we can write a Program C that checks exactly for that, right? So the public input to the Program C is going to be the old route, the new route, and all these in the public transaction summary, just the fact that Alice sent to Bob two ETH, bob sent to Zoe, one ETH, and so on and so forth, right? Just a public transaction summary.
01:06:26.834 - 01:07:22.870, Speaker A: So, again, the public input to the Program C is the old route, the new route, and the transaction summaries. Now, the private inputs to the program C is going to be the account balances of all the accounts that changed as a result of the received transactions. Okay? So again, the Program C will take as its private input, it will take the account balances for accounts that changed the old account balances and the updated account balances. And it will also take as input the signatures that were given along with the transactions. Okay? So that's the private input to the program C. Now, the program C, what it will do is it will verify that all the transactions are properly signed, so all these signatures are valid, that all the accounts have enough. Balance in them according to the old balances and that the new balances that were computed actually were correctly computed according to all these transactions that were submitted.
01:07:22.870 - 01:08:07.250, Speaker A: Okay? So basically, what the Program C is checking here is that the new route is consistent with the old route after the set of transactions that was received was applied. Yeah. So that the coordinator correctly applied the set of transactions that it received from the users to the old set of account balances, and the new route really does represent the new set of account balances. Okay, so now the coordinator has all this information. All that it does now is it just posts the updated merkel route to the blockchain along with the Snark proof that the new route is consistent with the old route relative to the transactions that the coordinator received. Yeah. And again, it sends the transaction data along with the proof.
01:08:07.250 - 01:08:40.098, Speaker A: So if you think about the amount of data that gets posted to the blockchain, it's actually quite small. It's just a short merkel route, it's a short Snark proof, and it's just a summary of the transaction data. So without the signatures, if you remember, I told you before that the signatures actually are quite large. They take quite a lot of space on the blockchain here. All these transactions are removed, and we're just sending a summary of the transaction data to the blockchain. All the miners have to do is just record the numerkel route and verify that the Snark proof is valid. That's it.
01:08:40.098 - 01:09:24.106, Speaker A: So the miners do very little work here, but in doing so, they've actually approved thousands of transactions. So this is why we get this massive scaling in performance using our roll up server. Now, again, if you think about who has to do all the hard work here, well, it's actually the roll up coordinator who has to verify that all the transactions are valid. So the coordinator has to verify that all the signatures are correct, and it has to construct a Snark proof to say that the new route is consistent with the old route. Yeah, those are all computationally intensive operations. And so the coordinator actually it needs to be a fairly substantial machine or collection of machines in order to do that. And of course, the coordinator is going to collect transaction fees to fund its operation for this purpose.
01:09:24.106 - 01:09:55.402, Speaker A: So that's kind of how a roll up system works at a high level. So now I want to talk a little bit about some more issues with how to use a rollup system. So, first of all, let's talk about moving assets in and out of the rollup system. So if a transaction happens to be among two users inside the rollup system, that is very cheap. That's exactly what rollup is for. So if Alice wants to send funds to Bob, and both Alice and Bob live, they have accounts in the same roll up system. That's just what we saw, and it's very cheap and very efficient using roll up.
01:09:55.402 - 01:11:03.802, Speaker A: Now the question is, what happens when Alice wants to move funds from her Ethereum address onto the roll up system or she wants to move funds from the roll up system? Outside of it into her Ethereum address. So we call these L One to L2 transactions because we're either moving funds from the roll up layer two onto the Ethereum layer one, or vice versa. That's actually more expensive because now in those transactions, the roll up coordinator actually has to include not just the numerical route in a transaction. It also has to include information that says transfer such and such amount of Ether for my own reserves, my own roll up coordinator reserves into Alice's account. Right? So the data that gets written to the blockchain is larger in that case. And the miners have to do a bit more work, and now they have to move funds from the roll up coordinator's account into Alice's account. Okay, so as a result, this is all possible, but transactions that move assets from layer two to layer one or vice versa are more expensive, have higher transaction fees because of the additional data that needs to be written to the layer one blockchain.
01:11:03.802 - 01:11:42.010, Speaker A: So that's one case moving l One from l One to l Two. Another interesting case is what happens when there are multiple roll up systems, right? There isn't going to be just one. There are going to be multiple roll up systems out there. In fact, there already are multiple roll up systems out there. And so the question is, what happens if Alice has an account with roll up system A and Bob has an account with roll up system B? Now, Alice wants to pay Bob, but they're on different roll up systems. So the naive solution would be for Alice to move her funds out of the rollup system back into Ethereum and then from Ethereum onto the new roll up system to pay Bob. Yeah.
01:11:42.010 - 01:12:19.382, Speaker A: So that's kind of a V shaped transaction where funds move from layer two to layer one and then back to the other layer two system. However, it turns out there are actually bridges being constructed. So if you have two roll up systems, let's say roll up A and roll up B, and you want to move funds directly from roll up A to roll up B without actually touching the underlying blockchain, there's actually bridges that are being built to do that very cheaply. We're going to talk about bridges in the next segment. So just hang on and you'll see how that works. Okay, so all sorts of funds transfers are supported by the roll up system. Some of them are more expensive than others.
01:12:19.382 - 01:13:01.926, Speaker A: Like I said, moving from L2 to L One from the roll up system back to Ethereum or in the other direction is more expensive than moving inside the roll up system. But that's how these systems operate. Okay, very good. So that's kind of the idea of the basic idea of roll up transactions. I want to talk about sort of a recent development that's really quite exciting to me and to others, actually, which is what's called the Zke EVM. Yeah. So this is basically a way to use these proof system, these Snarks, to not just do basic transactions among users in the rollup system, but in fact to run entire solidity programs inside the roll up system.
01:13:01.926 - 01:13:58.418, Speaker A: Yeah. And that's made possible by something called a Zke EVM, which is producing proofs not just for simple transactions, but it's producing proofs for the correct execution of an entire program running inside the rollup system. Okay, so the way this works is basically every DAP that runs in the rollup system think of moving uniswap and compound into rollup. Every DAP inside of the rollup system is going to have a leaf of the merkel tree associated with it. And rather than simply storing balances in that leaf, that leaf is also going to contain the entire state of the DAP. So various data structures and all that, all those would be written to the leaf of the roll up merkel tree. Now, when someone calls a DAP running inside of a roll up, well, basically what the coordinator will do is it will execute the program that is associated with that DAP.
01:13:58.418 - 01:14:37.334, Speaker A: And as a result, the data in that leaf, the data in the leaf that corresponds to that DAP will change from the old states to the new state. And what the coordinator will do is then produce a proof that that state transition was valid. Yeah. So, in fact, the coordinator is not only able to produce proofs that simple exchanges were done, but in fact, it's able to produce a proof that an entire program ran correctly on the old state. And the new state is, in fact, what's written in the numerical root. Well, what's written in the numerical tree that became the numerical root. Okay, so that's all done using a much heavier weight, zero knowledge proof system.
01:14:37.334 - 01:15:29.510, Speaker A: Again. A type of snark that's called a zke EVM. And the reason this is possible is because Snark technology has advanced so much to the point where we can actually produce proofs that an entire program ran correctly. Okay, so that's what this says here, that the coordinator can produce a Snark proof at execution of a short, solidity program. What this means is, at least in principle, it's fairly easy to migrate a DAP that's running on the L One Ethereum network onto an L2 ZK roll up system. And then, of course, now when you want to interact with that DAP program, with that decentralized application, transaction fees are reduced. The transaction rate is much higher because the roll up coordinator is batching thousands of DAP applications together into a single merkleroots update that's written to the ethereum blockchain.
01:15:29.510 - 01:16:13.518, Speaker A: Okay, so that's kind of a new development in this space. This is actually coming online probably later this year. So hopefully migration into rollups would actually be easier as well. Now I want to switch gears and talk about a slightly different implementation of rollup, which is called optimistic rollup and is already being deployed by optimism and Arbitrum. And so optimistic rollups, kind of, they operate in the same principle as a ZK Rollup. However, you remember that the complicated part of a ZK roll up was actually having the coordinator generate a Snark proof for every epoch where it processed a whole bunch of transactions. The idea of an optimistic roll up is to actually do exactly the same, but without producing a Snark proof.
01:16:13.518 - 01:17:17.014, Speaker A: Okay? So the coordinator is going to post all the transaction data and the updated Merkel route to the blockchain, but it's not going to include a Snark proof in that update. So now you should ask yourself, well, wait a minute. If there's no Snark proof, then how do we know that all the transactions are valid, right? Maybe the coordinator is literally stealing Alice's funds and Updating and posting a new Merkel route where the Leaf now says that Alice's account balance is zero and all the funds were transferred into the coordinator's account. Right? So something has to ensure that the coordinator is not adding fake transactions to its state updates in a ZK rollup. This is the whole purpose of the Snark proof to ensure that the transactions are all valid. So, again, it's really important to understand that in a ZK Rollup system, the coordinator is not a trusted entity, right? The coordinator, in fact, could be malicious, but because it has to produce a Snark proof that everything, this data is valid, it cannot lie. Yeah.
01:17:17.014 - 01:18:13.450, Speaker A: It cannot issue transactions that are actually not valid. Now, if we take away the proof, well, now all of a sudden, the coordinator can start lying about transactions. So the question is, what do we do about that? And so optimistic Roll Up introduced this beautiful idea that relies on external validators, right? So the external validators can look at the transactions that the coordinator posted to the blockchain. They can verify those transactions themselves, and if they ever see that the state change that the coordinator posted to the blockchain is invalid, these external validators can produce a fraud proof to say, hey, this coordinator actually cheated. It actually introduced a transaction that is invalid. Now, so what happens is when a validator finds the coordinator cheated, it posts a fraud proof to the blockchain. The miners can verify that the fraud proof is correct.
01:18:13.450 - 01:18:42.226, Speaker A: And in fact, if it is correct, two things happen. First of all, the transaction gets rolled back. So whatever transaction invalid transactions the coordinator was trying to add, they all get rolled back, so no harm was done. And second of all, the coordinator gets slashed. So what that means is the coordinator had to commit up front to a bunch of funds just so that it could act as a coordinator. And if it ever posts an invalid transaction, it would actually lose those funds or a portion of those funds. Yeah.
01:18:42.226 - 01:19:39.730, Speaker A: So as a result, the coordinator has a very strong incentive to never lie, because A, if it lied, it'll be caught, and then it will get nothing out of that lie, and B, if it's caught, it would lose its staked funds. And as a result, it has a strong incentive to always post valid transactions. So this is why it's called optimistic roll up, where we don't check that the coordinator did its job correctly. We just incentivize the coordinators to do its job correctly because if it doesn't, then it gets penalized. Now, so here the coordinator has to work much less hard than in a ZK roll up because it doesn't have to produce these Snark proofs. However, because we have to give the validators time to actually complain about invalid transactions, the transactions only get finalized a few days after they get posted. Okay? So there's a bit of a delay between the time that a transaction is posted to an optimistic roll up system versus the time that the transaction is actually finalized.
01:19:39.730 - 01:20:22.654, Speaker A: Now, there are lots of ways around this in which users can actually get access to their funds relatively quickly after transactions are posted, basically by having third party providers provide liquidity in the interim between the time that the transaction is posted and the time that validators are no longer allowed to complain. So there are ways to make optimistic rollup as efficient as ZK rollup. But fundamentally, optimistic rollup depends on validators validating the transactions. Yeah. So there's kind of a fundamental difference between optimistic rollup and ZK rollup. In optimistic rollup, the prover has to work much less hard. So, in fact, it's much easier to run entire programs inside of an optimistic rollup.
01:20:22.654 - 01:20:53.120, Speaker A: You can take existing DAP projects and move them onto optimistic rollup, actually, relatively simply. Yeah. Because the coordinator, all it would do is just run the program, compute a numerical tree, and that's it. The difference is that in a ZK roll up, there's nothing the coordinator can do to cheat the users. It has to produce a proof. And the only way it can produce a Snark proof is if all the transactions are valid. In optimistic roll up, we rely on these validators to do their job.
01:20:53.120 - 01:21:24.338, Speaker A: Otherwise, bad transactions could actually sneak through. So we do rely on these external validators to validate that everything the coordinator did is correct. So the last thing that I want to talk about roll up, whether it's optimistic rollup or ZK rollup, is the question of data availability. Yeah. So one thing that you should be wondering about is once we've introduced this coordinator, it sounds like we've lost all decentralization. This coordinator is sort of a central point of failure. If it dies, the whole system dies.
01:21:24.338 - 01:22:07.960, Speaker A: So have we just reintroduced centralization into the blockchain? And the answer is no. A roll up system actually does not introduce centralization for the very simple reason that the coordinator is an untrusted entity that doesn't keep any. Secrets. If the coordinator fails, it's actually quite easy for the users to find a new coordinator and that new coordinator will go ahead and produce snark proofs for them. Yeah, all it needs is the data that the old coordinator had and then it's just able to spin up and produce new proofs as needed to process new transactions. So that introduces an interesting complication. If we need to spin up a new coordinator that will produce new proofs, somehow this new coordinator needs all the current account information.
01:22:07.960 - 01:22:42.218, Speaker A: So how do we get the current state of the roll up system if the old coordinator is dead? Yeah, and that's exactly why we write transaction data to the blockchain. So there's two ways in which the new coordinator can get the state of the world from the old coordinator, even though the old coordinator is dead. These two methods are called ZK Sync and ZK Porter. So let's explain how they work. So ZK Sync works the same way that I just described in the previous slides. Yeah. So in ZKsync, basically all transaction summaries are stored on the layer one blockchain, for example, in Ethereum.
01:22:42.218 - 01:23:36.094, Speaker A: So if you want to spin up a new coordinator, the new coordinator can simply read all the transaction data that the old coordinator processed and basically reconstruct the state of the world from all these transactions. And once it's done reading all the transactions, basically it now knows what everybody's account balances are and it's ready to produce proofs by itself. Yes. So other coordinators that are running the roll up system basically can reconstruct the entire account balances for everyone from the data that's on the layer one network and then they can just start producing new proofs for everyone. So we have quite a bit of redundancy in this network, such that if one coordinator stops working, we simply use a different coordinator. And all the coordinators are coordinated with one another because they're all using data that was posted to the Ethereum network. So this is actually quite a nice way to do this.
01:23:36.094 - 01:24:08.410, Speaker A: The problem is we have to write quite a lot of data to the Ethereum network. We have to write transaction summaries to the Ethereum network. So this introduces transaction fees. But there's a lot of safety in this because people trust the Ethereum network. Data on it is not going to be removed. And so this is actually quite good for high value assets. Like if you buy an expensive NFT, you might want to store this NFT in a roll up system, but you would like to use ZKsync for this so that the fact that you bought the NFT is actually recorded on the Ethereum blockchain.
01:24:08.410 - 01:24:56.378, Speaker A: The other way to do it is called ZK Porter, which is much cheaper to run. So here the idea is we're not going to store transaction data on the blockchain on the layer one blockchain. Instead, we're going to create a whole new blockchain just for storing transaction data. So the new blockchain is going to be a proof of stake blockchain among a set of Coordinators? Yes. And rather than writing transaction summaries to the Ethereum blockchain, we're going to write transaction summaries just to these set of Coordinators. So basically, we're relying on the set of Coordinators to keep track of all transaction summaries such that if there's ever a need to reconstruct the state of the world, these Coordinators will provide transaction summaries and we can reconstruct the state of the world from scratch. Right.
01:24:56.378 - 01:25:48.202, Speaker A: Basically what the account balances are for everybody just given the transaction summaries from these Coordinators. So the interesting thing here is this provides actually cheap off chain storage. We're storing all transaction summaries in the memories of many Coordinators rather than storing them on Ethereum blockchains. But as a result, the guarantee that we have that the transaction data will be available when we need it is potentially not as strong as when the transaction data is written to Ethereum. The nice thing about this is that basically as a customer of the rollup system, you can choose yourself. Do you want to store it on the ZK Sync side or do you want to store it on the ZK Porter side? If you store it on ZK Sync, your transaction summaries are recorded to the blockchain, but you have to pay higher fees. In ZK Porter, transaction summaries are only recorded among participating Coordinators, but you pay lower transaction fees as a result.
01:25:48.202 - 01:26:13.214, Speaker A: So for high value assets, you want to use one. For lower value assets, you want to use the other. And it's very interesting that it's actually up to the user to decide which of these systems it wants to use. They both run in parallel in a single roll up system. Okay, so that's all I wanted to say about roll up. It's actually a pretty clever set of techniques, whether it's ZK roll up or optimistic roll up. Very clever set of techniques.
01:26:13.214 - 01:26:40.380, Speaker A: We are going to start seeing a lot of assets moving into roll up systems. We're going to be seeing entire DOP projects moving into roll ups. It's a growing area. There's probably a lot more work to do here. And for sure, there's many more interesting research projects to do around roll ups, but in the allotted time, that's all I have to say. Our next segment will be on interoperability among blockchains and that will be the last segment in this lecture. So see you in a few minutes.
01:26:40.380 - 01:27:32.086, Speaker A: Welcome back, everyone. This last segment is going to be relatively short and we're going to talk about how to do interoperability between different blockchains. So the state of the world today is that we really have a whole bunch of blockchains out there and they're sort of isolated islands in some sense, right? So we have the Ethereum world, we have the Bitcoin world, solana, polka dot flow, and many, many others that are out there. Now, the problem is we might have a user on polka dot who owns, say, 20 Dots, and he all of a sudden hears of a wonderful exchange that happens to live on salana. So serum is an exchange, an order book based exchange on salana that's very fast and relatively cheap to use. And Bob wants to use serum to possibly trade away some of his 20 Dots for some other assets. The problem is his dots are stuck on polka dot and serum runs on salana.
01:27:32.086 - 01:28:10.310, Speaker A: So there's no way for Bob to actually move his assets natively onto the solana chain so he can actually trade those assets on solana. So what do we do? This is what's called the interchain interoperability problem. We'd like to enable Bob to move his assets from polkadot to solana so then he can actually trade them on solana. So as we said, our goal is twofold. We'd like to enable someone who owns assets on one chain to move those assets to a different chain, so then he can interact with the entire ecosystem on this other chain. These could be funds or coins or maybe even NFTs that are stored on one chain. We'd like to be able to move them to another chain.
01:28:10.310 - 01:29:02.758, Speaker A: The other goal of interoperability is what we call composability of DApps, right? So remember, these DApps are the programs running on top of a blockchain. What we'd like to enable is basically a program running on one blockchain should be able to call another program running on a different blockchain, right? And that program that DAP could call yet a third DAP that runs on a third blockchain, and so on and so forth. So in fact, we get composability not just across DApps on a single blockchain, but we would get composability for DApps across the entire blockchain ecosystem. So that's kind of our goal. Of course, if everybody was using ethereum, this would be pretty easy because DApps and ethereum already compose quite easily with one another. But what do we do if one DAP runs on one chain and another DAP runs on another chain? So there are already some attempts at solving this. There are a couple of cross chain protocols like Xcmp and IBC.
01:29:02.758 - 01:29:38.806, Speaker A: If you're interested, you can go Google those and look at how they work. What I want to tell you about is one particular technique for moving assets from one chain to another using what's called a bridge. Okay? In particular, we will look at one type of bridge called the Federated Bridge, and we'll see how that works. So the example I want to give you is moving assets from the bitcoin blockchain to the ethereum blockchain. So then you can use your bitcoin assets in the entire ethereum DeFi ecosystem, as if bitcoin was native to ethereum. That's our goal. Okay? So let's see how this is done.
01:29:38.806 - 01:30:10.446, Speaker A: And I'm only going to again give you the high level idea. There are a lot of details that go into building a bridge. I'm just going to give you the high level idea for how to build what's called a Federated bridge. So first we're going to introduce these validators. So these validators are staked, so they have to put up some funds that get locked up and they would get penalized slashed if they ever misbehaved. So we'll have a group of validators that are going to be responsible for the correct operation of the bridge. Now, the bridge is going to have an address on the bitcoin network so people can send funds to this address.
01:30:10.446 - 01:30:46.410, Speaker A: And similarly, the bridge has a contract running on the Ethereum network as well. So the bridge itself actually implements a DAP on Ethereum. So now let's imagine we have a particular user who wants to transfer one bitcoin from the bitcoin network to the Ethereum network. What that user will do is they will send their bitcoin to the bridge address. So now they don't have the bitcoin anymore. That bitcoin is now stored in the bridge address. Now the validators, what they'll do is they'll look at the bridge address and they'll realize, ha, there's a new bitcoin that was just added to our bridge address and it came from this particular user address.
01:30:46.410 - 01:31:35.046, Speaker A: What they will do is they validate the fact that the bitcoin was actually moved into the bridge address. So now the bridge owns one more bitcoin and then they'll instruct the Ethereum contract to go ahead and mint a new what's called a pegged bitcoin. Yeah, so they'll mint a new pegged bitcoin. Sometimes this is called a wrapped bitcoin. And they'll send this wrapped or pegged bitcoin to the user's address on the Ethereum network. So now the user basically has one wrapped bitcoin on the Ethereum network that's basically worth one bitcoin, and he can use it in any of the DeFi systems available on Ethereum. Okay, so that's one way that was an easy way to move a bitcoin from the bitcoin network over to the Ethereum network and use it as if it's actually a bitcoin that's native to Ethereum.
01:31:35.046 - 01:32:14.918, Speaker A: Now let's talk about what happens the other way. So suppose the user is done interacting with the Ethereum DeFi ecosystem and he wants to move his pegged bitcoin back to the bitcoin network. What he will do is he will actually send his pegged bitcoin back to the contract. Okay? So now he doesn't have the pegged bitcoin anymore. It went into the Ethereum contract that implements the bridge. And what the contract will do is actually burn this pegged bitcoin so it simply ceases to exist. All right? The validators will look at the Ethereum contract and say, AHA, this one pegged bitcoin came from the user's Ethereum address.
01:32:14.918 - 01:32:53.954, Speaker A: It was actually burned. So then we're going to issue a signed transaction on our behalf. So we're all going to agree that this bitcoin really was burned and it needs to be paid back to the user. We're going to issue a signed transaction to the bitcoin network and we're going to instruct basically bitcoin to move one bitcoin from the bridge address back to the user. So now the user got his bitcoin back. All right, now you can see why we need a group of validators because lots of things can go wrong. If the validators misbehave, they could refuse to send money back to the user, they could just try to run away with the treasury of the bridge and so on.
01:32:53.954 - 01:33:40.914, Speaker A: So basically we have a group of validators and we require sort of a majority of them to be honest. So that's basically what maintains the correct operation of the bridge. So this is what's called a Federated bridge. Again at a very high level there are a lot of additional details that go into implementing a Federated bridge. One thing that you might be wondering about is why do we need these validators? It would be pretty cool if we could just have a bridge that operates without validators, right, so just operates entirely on the blockchain so that we have what's called a trustless bridge. So in fact in some cases this is possible. Technically it's a little bit difficult to do with the bitcoin network because somebody has to sign a transaction to tell the bitcoin network to send the bitcoin from the bridge address to the user address.
01:33:40.914 - 01:34:29.182, Speaker A: That instruction requires a secret key and so really the secret key would have to be sort of stored on the bridge contract if the validators did not exist. Yeah, the bridge contract would have to store a signing key that would tell the bitcoin network to move a bitcoin out of the bridge address. Unfortunately, this is actually one of the big open problems in blockchain contract. How do we store secrets in an Ethereum contract where everybody can look at the Ethereum contract? Everybody knows the state of the contract. Everybody knows the code of the contract. And so it's not clear. How do we hide a secret key inside of an Ethereum smart contract in a way that no one can steal that secret key and abuse it? So because this is sort of a non trivial thing to do, we typically rely on validators.
01:34:29.182 - 01:35:28.402, Speaker A: And these validators basically will verify that the coin was burnt on the Ethereum side and then they'll move it out and give it to the user on the bitcoin side. Let me say that if both sides support a powerful smart contracting language, for example, one side might be Ethereum and the other side might be solana, then in fact it's not too difficult to build a trustless bridge without validators. And in fact, that would also be done quite easily using Snarks where using a snark one side can prove to the other side that in fact the coin was burned and therefore the other side should release the coin from its own treasury. I will leave it as a homework problem for you to design a trustless bridge where Snark proofs are used basically to convince each side that a token was burned on one side and therefore it should be issued on the other side. This is sort of a cute exercise in seeing how to design trustless bridges. All right, so this brings us to the end of the lecture. This was just a quick overview of how federated bridges work.
01:35:28.402 - 01:36:10.266, Speaker A: So during this lecture, we saw a whole bunch of stuff, right? We looked at cryptographic primitives like hash functions that allow us to commit to something on the blockchain. We post a hash of a whole bunch of data to a blockchain that commits us to that data, and then later on, we can show that data to anyone, and they're convinced that that's the data that we actually committed to. So we looked at committing to large amounts of data using a hash function. We looked at merkel trees for even committing to a large amount of data and then proving that a small segment of it actually is part of the commitment. We looked at digital signatures and how to use them to authorize various actions on the blockchain. We looked at scaling the blockchain using either payment channels or the roll up mechanism. Again, I really like these ideas.
01:36:10.266 - 01:36:26.340, Speaker A: Very, very clever and pretty ideas. And finally, we looked at interoperability very briefly just to see how federated bridges work as well as pegged or wrapped coins. So this brings us to the end of the lecture. I hope you enjoyed it, and I look forward to seeing you in a future lecture. Goodbye, everyone.
