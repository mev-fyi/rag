00:00:21.570 - 00:01:07.480, Speaker A: My name is ye. Today I'd like to talk about the halo transmission and if we have more time we can quickly go through the pruning process so that that everyone can have a sense of how to generate proof from those circuits. So this is outline for today. So there will be three parts. Firstly, I will quickly introduce a high level, like how you are generally improved for a program. And the second I will focusing on this Halo Torre optimization like how you are writing constraints for program and what kind of toolings you can use in your circuit with some examples. And finally, if we have some time, I will quickly go through this prover, how you convert this constraint to polynomials and finally commit and open for wifi to verify that.
00:01:07.480 - 00:01:50.710, Speaker A: Okay, so let's start with the high level intro. So the idea of doing a proof is that you want to generate very single proof for any program. So I take an arbitrary computational program here written a proof is that you want to generate a very small proof for any computational program. For example, I take an arbitrary program here, writing in high level language, and you want to use a proof saying that this program executes correctly. And for our case we want to prove that, use one proof to prove that every execution step for EVM is correct. So this computation or this program can be like arbitrary type. And how you are going to do that is that you firstly need to represent your program.
00:01:50.710 - 00:02:41.702, Speaker A: Reimplement this program using something like intuitively some vacate language where you reimplement your program, which initially it might be in any high level language. This step is called circular relation. You basically need to write a bunch of mathematical constraints and using those assertions, like for example, this is a very simple example, saying that x times x equal to variable one and all those math assertions. And using those assertions, you can prove that this program is correct if you have a valid assignment for those constraints. So this is the most important step, especially for auditors. Basically, auditor need to be careful that when you are writing those constraints, it's equivalent to the initial program. You are not missing any constraints, you are not missing any information.
00:02:41.702 - 00:03:33.506, Speaker A: And then after you get this circuit, those constraints, you run some proving algorithm, and which is you use this prover hello to prover to generate proof. So there are two separate things. One is on the front end where you use this circuitization to represent your program, and on the back end you use some proving algorithm for generating a proof. And now let's dive into the halo tourismization. So to start with, I know many auditors have experience auditing some RNCs circuits, especially written in circum. So I take many random pieces from circum code. So basically in circum or in r one cs, you can write some constraints like this, you can multiply two linear combinations and assign or connect that to a different value or wire.
00:03:33.506 - 00:04:18.530, Speaker A: So it's note that all the constraints in circum or r one cs is degree two. So you can only allow one multiplication in each constraint. Like either it's here, this a poly come from some linear combination from variables. And also like this bracket you have multiple variables here. So r one says, and circum has this format of degree two constraints, but on each side there's a linear combination. And in general, in r one says you have all those unvariables. And for each constraint, like each row of constraints, you can write arbitrary combination for those variables times arbitrary combination for those variables, equal to some combination for variables.
00:04:18.530 - 00:05:09.906, Speaker A: So either look like this or this, but only so one constraint can only contain one custom gate. And after defining those constraints for a program, your statement will be, I know a concrete assignment for those witness like input, va, vb and vc that satisfies all those constraints. If proverb can prove this, then it can prove that this program can actually do correctly to get the output you want. So this is like we start with circum and rnCs. And for planckish translation it's actually quite different. So you are not layouting all your variables and all the intermediate values in a vector, but instead you use a table. So you can configure this table to have, for example like this has multiple columns and we divide that into witness and some table column.
00:05:09.906 - 00:06:18.660, Speaker A: And then you can put all your values like you use during this computing, this program here, like you can put your input here and you. Sorry, I'm in coroutine hotel so the network is pretty bad.
00:06:23.050 - 00:06:33.800, Speaker B: Do you want me to. Sorry, if you want me to do the presentation, maybe while you're fixing I'm. Okay, just let me know.
00:06:34.830 - 00:06:39.322, Speaker A: Okay, maybe I can still try and I switch to my hot stop.
00:06:39.376 - 00:06:40.860, Speaker B: So let's try again. Okay.
00:06:43.230 - 00:07:39.514, Speaker A: Is this last slide where I miss or. Okay yeah, I turn off my video try. Is this the last slide which I talked about, I don't know where. Okay, yeah, so in plank srmonization differently, you are not layouting all your witness in vector, but you can configure how many columns you are using for this table. You can configure for example this is like five columns and some table columns, and then you can put all your input, output and some intermediate values in this table. And then you can define something called custom gate, which is not limited to the form of this rnCs, which is linear combination times linear combination. But you can define something which is more customized.
00:07:39.514 - 00:08:28.650, Speaker A: For example, you can define any shape, like you can define this very regular shape. And you can define the relationship for the variables within this ship. Like three times v three times v c three minus v four equal to zero. So using this cosmic gate, you get two benefits. One is that you can represent some higher degree constraints. So for example, like they say, you can include two multiplications in one constraint, but in rncs you can only include one. And so it's also more customized because for example, if your program use some pattern frequently, and then you can abstract this pattern and represent it using some custom gate and you can get some more customized for your program.
00:08:28.650 - 00:09:15.430, Speaker A: It's not only limited to this linear combination form. And more specifically, when we are defining a custom gate, we are actually defining a ship for this custom gate. But we didn't specify which specific position it is. For example, it want to constrain v three, vb three, v c three and vb four at this specific position. Then we need to multiply with another value called selector, which the other values will be zero and only be one and or be turned on at a certain position. But for simplicity, I just write this wave three, wave three at the custom gate. But basically when you are defining the custom gate, you are defining a ship.
00:09:15.430 - 00:09:42.962, Speaker A: And this ship can be reused across the whole column. For example, if you select it to be open at this place, this place, this place, it can be reused. The same shape can be applied to the whole table. So this is how you define custom gate. And you can define random shape, as I mentioned. Like you can define this shape or you can define very regular shape like this. So this is the flexibility that klo two can give you when you are writing your program.
00:09:42.962 - 00:10:17.258, Speaker A: And another thing you can also use is called permutation. Because as I mentioned, you can define multiple gates, but those gates are still independent. You can connect the output for one gate to the input of the other gate by making this cell to be equal. So for example, you can define a sequence of value that they are equal. Like wave four equal to vase a six equal to wave six equal to v six. And so this is something called permutation. This is another optimization you can using for this plankish optimization.
00:10:17.258 - 00:11:18.510, Speaker A: And to give you an example how you are using this custom gate and permutation in practice, let's take a look at some fibonacci example so you can configure your table to be four column and then you fill up all the witness values like one, one two and one two three here, two three, two plus three equal to five here, three plus five equal to eight here. And you can fill up all this table and the relationship. You need to prove that for each row the value in the first column plus the value in the second column equal to the value in the third column. So you can have some as my relationship like this, and it can be reused for all those rows. And besides that, you also need to prove that this one and two the input for the next gate. So you need to prove for some permutation relationship for the first and second row for a second and third row and you can define some permutation relationship. So this example demonstrates like how you are using this custom gate and permutation in practice.
00:11:18.510 - 00:12:22.982, Speaker A: And Hyen will introduce more how you implement this program in hello two in the next session. And besides the custom gate and the permutation, another thing you can also use for plant dish optimization is called lookup. So this lookup is some membership relationship where you can define a tuple which is like way seven, way b seven, vg seven. This is a tuple and you can prove that it belongs to a table. So what does that mean? And why this is useful is that I can give you an example. So for example, if you want to prove that Vc seven belongs to the range between zero to 15, right, in RNCs, what you use to do is that you can decompose this Vc seven to four bit and you prove that those four bit actually bit, which is like you use four constraints to constrain that it's either zero or either one. And then you can linear combine those values using this binary format to get Vc seven to prove that VC seven can be referenced in this form.
00:12:22.982 - 00:13:40.646, Speaker A: And it's all beat, so it's within this range. But with this lookup argument, you just need to use one constraint which you prove that we see seven belongs to this table table column and this table column will iterate from the 15. And you just need to prove that if this belongs to this table, then it's definitely within this range. And similarly for a tuple, you can prove that if you want to prove that v seven, v seven equal to Vc seven, instead of decomposing all the variables into bit and doing bitwise operations, you can instead have fixed table preprocessed table, storing all the possible relationship for ignore and prove that this tuple belongs to this table and that's it. And this is also especially very important in our Ziki and circuits because you can also use this lookup to do some verifiable Ram operation because it's a virtual machine. So every time you need to write to your memory stack or storage, so you can put that into a table row, and then next time when you're reading from the same row, then you just prove that it belongs to this table, this ram table, and that's it. And Hai chin can introduce more in the QM session.
00:13:40.646 - 00:14:21.210, Speaker A: But this is very important when you are writing the QM circuit. And now just a quick summary. Like for plunkettialization, you can write three different type of constraints. One is custom gate, where you define some ship and then you define the relationship for this gate, within this gate, something like this, or this or this. And you can define permutation which will link those gates together. It's basically a sequence of fill equation like v four equal to V C six and something like this. And also you can define some lookup arguments.
00:14:21.210 - 00:15:09.310, Speaker A: For example, this tuple belongs to this table column. And even more flexible, like you can define something even more flexible than this seven. Is that in hello to each element in this tuple can be some expression. So by saying expression, instead of putting like wave seven here, you can maybe put like wave four plus wave four plus wave four as one element in this tuple. And so by saying expression, I mean it's an expression of the variables in this table and as your elements. And you can look up this expression tuple and belong to whether it belongs to a table or not. So those are like three different constraints you can write in hello two circuit.
00:15:09.310 - 00:16:01.214, Speaker A: So, any questions here? So why do you have table one and table two? I mean why the columns are combined into two tables? Because from your description it looks like that each column is separate thing. What is table, table one and table two? Yes, for example, table one can be proof for igor operation. So you can iterate all the host boy door entries like in table one. And for example in table two you can prepare some other logic, like you can put some range or storage table. So it's just different table. Columns are used for different functionalities and so it's different areas, right. You can't put like when you're approving for range, you approve for ignore it.
00:16:01.214 - 00:16:48.700, Speaker A: Definitely need different functionalities for tables, right? So that's why I mentioned it's different columns. Okay, do all the columns have to have the same height? Yeah, that's a good question. So within one circuit, it need to have the same height. You can pad the same elements for the same as the last element and here. Yeah, but, and also maybe you can stack different tables together just with some different index to distinguish different tables. So there are some way to compress different tables, but in a circuit, usually the tables are the same length. Does that answer a question or any more questions?
00:16:53.140 - 00:16:57.236, Speaker B: How would you compress these? Because you say they all have the.
00:16:57.258 - 00:17:51.300, Speaker A: Same height and you're saying compress, but how do you. Yeah, so if you are not stacking two tables together, then you just pad to the same height and that's it. But I mean, if two tables are very short, you can just put them in the same column and then add another column as index for different tables. But that's just optimization on the poorer side and how you are optimizing the, for example, if this table one only have three rows, table two only have five rows, but your circuit had maybe like two powers, 18 rows, then you can definitely put the two tables together and stack in the same column, and then add another extra column to use as index to distinguish different table. If that makes sense. That's an optimization. That's not something that you are doing automatically.
00:17:51.300 - 00:18:35.130, Speaker A: Yeah, thanks. Okay, any more questions? Okay, so those are the optimizations you can use for halo two. Basically custom gate lookup and permutation. And finally, we can go through this halo two prover and the whole province process very quickly. So when you are writing a custom gate, as I mentioned. So for example, you want to constrain that wave five times, wave five times, wave five minus wave b six equal to zero. You are not like when you write out those constraints and on the back hand side, you are resulting a polynomial.
00:18:35.130 - 00:19:22.430, Speaker A: So, each of those custom gates will result in a polynomial, and those polynomials define relationship between columns. For example, if wave five belongs to this column, then this column is a one column. So you can interpret all the values in a one column and get this column polynomial called a one x. And they say a two x, they say a three x, you can get polynomial for all the columns. And then when you are writing all those constraints, you are actually constraining that a one x times a two x times a three x minus a two, like omega x. So, because vb six is on the next row. So when you are using, accessing the next row, you are using something called rotation in hello two, and which on the back end will transfer to this omega x.
00:19:22.430 - 00:20:06.330, Speaker A: So if you want to access vb seven, it will be like h two omega square x. So this is like on the back end, what's happening. But from this polynomial, you can see that it doesn't specify that it's wave five ab five vc five v six. It can be arbitrary, like arbitrary position, but just you need to keep the shape to be the same. So if you want to simplify this specific area, as I mentioned, you need to multiply with some selector, which is all zero, but only open here. And then after multiplying this selector polynomial, you can get your constraint. So this selector polynomial tell you that if x belong to those rows, it's zero.
00:20:06.330 - 00:21:06.842, Speaker A: So you don't need to constrain this relationship, but if it's one, then on this specific row this cascade will function. So this is how from each cascade you will result in a different polynomial. And for different rotations you will have this like omega x, omega square x, or different rotations, and you can reuse the same shape of custom gate across all the many different rows. For example, you can open at this place, this place and this place at the same time. So this is how you like what's happening on the custom gate. In short, for each custom gate, it will result in one unique polynomial. And for lookup, without going into too much detail, it's also each belonging relationship will convert to some polynomial identity relationships, but different from cascade, it will generate four different polynomial constraints like this log range polynomial.
00:21:06.842 - 00:21:42.250, Speaker A: And this is some zx. And because for custom gate you are only defining over column over the cells in this table. So all the polynomials you need here are from your table column. But for lookup, the argument that using halo two will introduce some other additional polynomial, this a prime x, t prime x and zx. So you need to compute like three different polynomials for your lookup arguments and also generate four different polynomial constraints. So this is for this tuple relationship. And also, as I mentioned, you can define even more flexible relationship.
00:21:42.250 - 00:22:26.950, Speaker A: You can replace all the values in this tuple with some expression. And similarly, you also use four different polynomial identities to constrain this belonging relationship. So this is just high level intuition is that for each lookup constraint, it will be converted into four polynomials. And for this permutation relationship, the only thing that matters is how many columns is involved in this permutation. Like for example, those are three different cells, like way zero equal to wave one equal to wave a three. And it involves three columns. And for a way five equal to vb five, it also involves the same two column.
00:22:26.950 - 00:23:25.580, Speaker A: So the permutation only matters for where your cell is and how many column it involves. So for example, for this area, it will only involve those first three permutation columns. So you can generate, you need to use two polynomial constraints to constrain this relationship. So you can define arbitrary permutation relationship as far as they are within the first three columns, and you can have multiple permutation arguments for different columns. And so from high level, each permutation relationship will convert to two constraints, polynomial constraints. So at the end of the day, after expressing your program using this custom gate like lookup and permutation, you will result in a bunch of polynomial identities. So each shades are just some polynomial times polynomial minus polynomial equal to zero.
00:23:25.580 - 00:24:11.050, Speaker A: And each cascade will introduce one polynomial. Each permutation will introduce two polynomial, each lookup will introduce four different polynomial polynomial equations. And for custom gate, they won't introduce any extra polynomial. It's just table column. The polynomial for table column and for lookup it will introduce three different polynomials, like more polynomials. And for permutation it also need to introduce two different polynomials. And so this is like at the end of the day, what the proverb will give you is that it will interpret the table to some polynomials and your constraints will be converted to this polynomial identities.
00:24:11.050 - 00:25:19.850, Speaker A: Any questions here? Okay, and then the pro I need to prove is that I know a bunch of polynomial that satisfy all those relationships. So what prover need to do is that prover need to commit to all the polynomials. Here we are using a polynomial commitment scheme called KDG. So, because the focus for auditor will be more on how you are writing constraints and how you are writing circuit size. So I won't go into too much detail, but basically KDG is a polynomial commitment where you can commit to a polynomial and then later prove to the verifier that the polynomial evaluation at a random point is this. For example, I'm approver, I commit to the polynomial Fx, and later verifier want to get this alpha, the evasion of f alpha. And without reviewing Fx, then prover can send this f alpha evaluation to the verifier with some opening proof to prove that this fx opens at fr five correctly.
00:25:19.850 - 00:26:16.446, Speaker A: So this is what polynomial commitment can do. It basically can tell you that a polynomial opens correctly at a random point and we are using KDG. So this is the biggest difference between the hello two we are using and the initial zcache team, because they are using some inner product argument for their hello two version. And we use a forecast of that version, which we replace this inner product argument with KDG because we want more efficient wirefire and also we want that to be efficiently verified on ethereum. So the proverb need to commit to all those polynomials and later prove that all those polynomials open at random points will be zero. So what PRA is doing is that for efficiency, it will linear combine all the polynomial identities using gamma, because it need to prove that all those polynomial identities vanish over the same set of points. So it can use this gamma to linear combine all those polynomials.
00:26:16.446 - 00:27:16.482, Speaker A: Like this is polynomial identities. You use gamma to linear combine all those polynomial relationships and divide by this vanishing argument. So this vanishing argument tell you that it vanished at the rows you selected, because for example, for this polynomial it won't be always zero, it will only be zero at the row number you give at the table row number. So that's why we need to divide by this vanishing argument. So they prove I need to linear combine all those polynomial identities. You need this gamma and later open this polynomial at a random point alpha. So this is how you prove that those openings are correct, and then this opening crack will prove that those polynomial identities are equal, and then it will prove those constraints are satisfied.
00:27:16.482 - 00:28:02.302, Speaker A: So this is the whole pooling process. Just a quick summary. So you start with some initial program, and your statement will be I know a secret input of program p such that the output will be zero. So this is your initial program and your initial statement. And next, after writing these constraints, so this constraint will constrain the computation logic in this circuit, and you can use cascade permutation and lookup to represent those relationship. And your statement becomes I know an assignment of the witness table that satisfy all those constraints, and your circuit, those equations will be public. And that's exactly the part that auditors need to audit.
00:28:02.302 - 00:29:15.030, Speaker A: They need to audit that all those constraints is sound for proving that your computation logic. So the proverb need to prove that I know an assignment for this constraint system and then it will be these constraints at the prover side proverb will interpret this table into some polynomial and prove that certain relationship hold between those polynomials. So those are running by the prover after the circular arithmetic. And finally, the prover need to linear combine all those polynomial identities into one polynomial that vanish over some set. And then the proverb prove that the openness of those polynomials at a random point satisfies those relationships. Because previously, what proverb I need to prove is that I know a polynomial that satisfies this relationship, but it needs verified to do a bunch of computations for polynomials like divide so the relationship of polynomials can be converted to just one random point due to some 3.0 lama.
00:29:15.030 - 00:29:54.006, Speaker A: And then the proof only need to prove that those polynomials at a random point alpha. The evaluation satisfies this relationship and that's it. And your proof will only contain the commitment to the polynomials. The pooler will commit to the polynomials ahead of time, and the openings, which is the evaluation for those polynomials. And a multi open proof to prove that the evaluations of those polynomials are correct. And the verifier can check this multi open proof to know that all the openings are correctly to the committed polynomial. And then it will check this final equation like it.
00:29:54.006 - 00:30:37.012, Speaker A: Just check the evaluations have those relationship to know that those polynomials have this relationship to know that those relationship holds to know the constraints are satisfied. To know the program are correct. So that's basically a quick go through for the proving process. Any more questions here? Okay, I think that's pretty much for the prunk stuff and the Hoover. Any more questions for the permutation argument?
00:30:37.156 - 00:30:39.252, Speaker B: Is it necessary that all the elements.
00:30:39.316 - 00:30:40.756, Speaker A: Have to be like in different columns.
00:30:40.788 - 00:30:42.600, Speaker B: Or can they be in the same column?
00:30:43.660 - 00:31:22.010, Speaker A: They can be in the same column. For example, for one permutation, you just need to specify the max number of columns involved in one permutation argument. For example, one permutation can handle three columns and then you can define arbitrary values to be equal within the first three columns. And that's it. You just need to specify a column relationship. All right, thank you. Any other questions? Okay, I think maybe I can hand over to Jordan.
00:31:27.580 - 00:32:23.830, Speaker B: Okay, let me share the screen presentation here. So, can you see my presentation? Yes. Okay, perfect. Well, I'm going to explain a little bit the same how we do it in polygon. We are doing it not using hello two, this idea of custom gates, at least directly, we're using what we call pill and what we call, what we call create a processor. And then we just run a processor on top of that. First of all, I'm not going to explain a little bit how roll up works.
00:32:23.830 - 00:32:52.158, Speaker B: I'm going to jump directly to the approver. The approver is the most important. So it's what we were very focused on at the end. We want to have many transactions, many ethereum transactions. We have an auto state route and we want to compute a newer state route. And we want to prove that actually when we want to prove that this newer state route is computed in the right way without having to execute all the transactions again, and we want to do that on chain. So that's the main idea of the rollouts.
00:32:52.158 - 00:33:24.074, Speaker B: These transactions are Ethereum transactions with everything in there. So we are talking here to a ZKVM, to a fully compatible ZKVM. That means that all the opcodes are so all the transactions are exactly the same that ethereum transactions. You can do transfer transactions, you can do deployment transactions, you can do call transactions between one contract to the. Exactly. So you sign these transactions with metamask and it's exactly the same transactions that you see in Ethereum. So you need to process.
00:33:24.074 - 00:34:04.786, Speaker B: So here, this deterministic program, this process at the end needs to emulate ethereum, needs to do. Exactly, needs to compute the new state exactly the same way that ethereum, that ethereum does. Okay, so this is a bit the difficulty of the system. So to do that, well, one first option is to use circum or this one r one cs kind language. But this is quite unbearable and it's quite difficult to do. So the approach that we do is we use mainly peel. The idea here of Peel is that circum can be understand as an electronic circuit.
00:34:04.786 - 00:34:39.406, Speaker B: So we have a set of gates that you put some values at the beginning and then these gates compute new values, put more gates values, values, values. And at the end you have value. But when you're using peel here, mainly what you are introducing is this concept of a clock. Instead of having a big circuit that computes everything linear on roll it, you can do that with a program. So you can have a state machine. So you can have a small electronics, you have a small gates. And then the output, you connect it to the input and then you are processing.
00:34:39.406 - 00:35:31.394, Speaker B: So you have this concept of this state machine. So state machine at the end, the only thing that you need to define in the state machine is the relationship between one state and the next state. If we have a state machine, then if we have a state machines data is that you can build a processor. And then on top of this processor we are going to run a program that's actually computing, just doing what ethereum does. So this is the full strategy that we are following. So the idea is that the arithmeticization is quite simple because in arithmetization we need to arithmeticize only a processor. If you own a small processor with some few instructions, then it's going to be a program that's going to run on this processor.
00:35:31.394 - 00:36:17.218, Speaker B: So the arithmeticization in our case is probably quite simple in the constraints itself, BEcause Most of the Logic is implemented on Top of that with many instructions in here. So let's talk a little bit about this array Meditation, how we are doing this Meditation. It has some similarities with hello too, but conceptually it's different. So to do that. Well, here, I want to start with. Well, here is an example. I think that tomorrow we have a planner to do this example.
00:36:17.218 - 00:36:54.110, Speaker B: But I'm going to run to this example fast because I think the best way to understand how the armenization works is just by doing a simple example. In this case is Fibonacci celias here in this hello world example, what we want to do is we're working with a finite field here. Notice that this finite field is a small finite field. It's a 64 bits finite field. And this means that the other imitation is done in this field, which is very fast to compute all the witness computation. And everything is really fast because we work in these 64 bits. And in this case, what we want to do is we want to have like a number.
00:36:54.110 - 00:37:29.430, Speaker B: And I want to prove that I have two numbers that when I compute the fibonacci series 1024 times, it gives this number. Okay, if you do it in circum, that would be quite easy. So you just create these relationships between signals. So maybe you have the one signal, and then you just compute the next signal as the addition of the last two ones. Okay, you create these 1024, or in this case, these n intermediate signals. And the output of this you just assign to the last one. This is how you would do it in circle.
00:37:29.430 - 00:37:59.694, Speaker B: But here you would have potentially end gates. Here. If we do it in, the idea is that we can do that in parallel. So the idea is that all these operations that are like the same, the same way that have a state machine. So every transition you are doing exactly the same. So this is how we are building with pills. So here the idea is that we can have a state machine.
00:37:59.694 - 00:38:35.294, Speaker B: In this case, a state machine is of two estates. In this case, it's the before last and a last. And here the state transition, the important part of the state transition. See, what's the relationship that needs to fulfill between one line and the next line, or between even the numbers, but just in between two lines, you would do this way. So the before last is the last. So in the next line, this is the double e wax. Compared to the x is, the next line is the last, and the last is just the addition of the last two.
00:38:35.294 - 00:39:10.070, Speaker B: So here, what we are doing here is we are defining a state transition. Here. This is the condition. So how we put that in a polynomial relationship so that we can check that this relationship is computing parallel. Well, the idea is that we have a polynomial of degree, in this case to 1023, less than 1024. So we have a polynomial. And the idea is that this polynomial can be expressed with 1024 evaluations.
00:39:10.070 - 00:39:40.850, Speaker B: So we are representing this polynomial at evaluations, at what we call roots of unity. Roots of unity are just some specific numbers in the field, actually are the roots of unity. You take this number and you exponentiate that to 1024, then it will give you one for each of them. So these specific numbers in the field. So when you evaluate a polynomial, so I can define a polynomial here day before last, that when at one, it's equal to one. At w, which is a specific number, it's two. At w, two is three.
00:39:40.850 - 00:40:13.902, Speaker B: At w, three is five. And here, this defines a polynomial itself. So this is the polynomial a before last, of x. These are not the coefficients of the polynomial, are the evaluations at these specific numbers. Okay, the same way, the same thing for a last x. Okay, and here the expression, you can see the polynomial relationship here. Wx means that, because wx means that this is the next one.
00:40:13.902 - 00:40:51.260, Speaker B: So it's like when you are multiplying by w, you are going to the next value. This polynomial to awx is equal to a of x. Okay, so here is how we express this state machine with these polynomials, and this is the polynomial identities. So what we can do here in the system, in this problem is we are just committing to a. Before last. We are committing to a last, and then we prove that these polynomial relationships fulfill after committing the commit, and then we prove that these polynomials fulfill. Okay, so this is the main idea that we are doing.
00:40:51.260 - 00:41:26.134, Speaker B: So here we see the idea of this state machine. Okay, so how we write that in pill? Well, here is, before going, well, before going, before going forward here, we have a slight problem here. Okay, so this relationship fulfills, but the problem is the last one. So the last one and the first one. So w to 123. This is the root of unity. So if multiplied by w is 124, and this is by definition of roots of unity, this is going to be one.
00:41:26.134 - 00:41:53.866, Speaker B: So this is cyclic. So this relationship to here must be equal to here. So I need to modify these relationships just to take in account that this last row with the first row combines. So it fulfills this relationship. So here the trick that we are doing is we are defining another polynomial. In this case is last x. This is a constant polynomial.
00:41:53.866 - 00:42:22.422, Speaker B: This is not a committed polynomial. It's a polynomial that's known by the proverb and the verifier. And it's a polynomial that's zero in all the roots of unity, except the last one. That's one. And then we write the pill this way. So actually, this a before last prime, this prime means the next one is equal to the last one. So this must be zero when his last is zero, because if his last is one, this is already going to be zero.
00:42:22.422 - 00:42:56.238, Speaker B: So I can put any value here. So here you see that with this multiplication here, I'm avoiding the last row, the connection of the last row to the first row. Okay, the same here. So I'm saying that a last prime must be equal to before last plus a last. So this is the same relationship, but only when its last is zero. Okay, so when this last is one, then this term is zero. So this will be fulfilled no matter which values are in a last and a last prime.
00:42:56.238 - 00:43:12.550, Speaker B: Okay, so that's it. So here in this case, I am also defining the output. This is the public output, because this is a problem. So I need to define the public output of the circuit. In this case, it's a single public output. In the public output. What I'm saying is that I'm adding this relationship here.
00:43:12.550 - 00:43:37.674, Speaker B: I'm saying that when is last is one. So if it's zero, this will fulfill always. But when is last is one, alas, must be equal to the out zero. Okay, this part here is not part of the constraint. This is just to tell to the proverb where they can extract the public value, but here does not define any relationship. It's just a convenience here. So you can see here that we have the pill.
00:43:37.674 - 00:44:16.090, Speaker B: So here we define it. Two polynomials, two committed polynomials, one constant polynomial, and then all these relationships. So what I need to do to define a full circuit here, well, I need to do three things. First, define the pill, and then I need to compute the constant polynomials. This is something that I'm going to do once in the setup time. So once per circuit at the beginning. And then I will need to create a program that, given two values, so it computes all the trace, or it computes all these committed polynomials.
00:44:16.090 - 00:44:50.962, Speaker B: Actually, it computes all the committed polynomials there. And with these three things, I'm already half. Well, I have the polynomials, and then all these three things I will plug to a polynomial commitment schema. That's going to go after that. But for writing a circle, the only thing that I need to do is writing these three things, the pill. So that defines the relationship between polynomials, the constant polynomials, evaluation. So that's the setup something that you are evaluating at the beginning of the setup and the program that actually computes this trace, computes these committed polynomials.
00:44:50.962 - 00:45:19.742, Speaker B: Okay, so with this, you see this is an example, but this is an example. So here what you see the example here, you will go to this tomorrow. But here is the days that you have the build constants. Here you see that this build constant is quite easy. The only thing that you are doing is that, well, is last is going to be zero everywhere, except when in the last one it is one. So I'm just setting this here, and here I'm executing. So given an input, I just compute the pulling the before last to all the steps and just setting this up.
00:45:19.742 - 00:46:02.234, Speaker B: Okay, and that's it. That's the only thing that I need with this I can already connect to Pillowstark. Pillowstark is the backend, is the cryptographic schema that actually do all this polynomial commitment. And everything is translated automatically in Pillspark. So this is pill, you see, it's quite easy. You define committed polynomials or constant polynomials, and then you define the relationship of these polynomials. But you can do more things in pill, you can define some special relationships of the polynomial that you can look at the end, this is going to be converted to basic committed polynomials.
00:46:02.234 - 00:46:38.602, Speaker B: But you can do for example, a permutation check. What means in a permutation check? Permutation check means that you have two polynomials and you say that, well, this polynomial is exactly the same that this, but the only thing is that switching. So the permutation is different. Okay, but all the values here, the values here and the values here are exactly the same. So how can I define that in pill? Well, I'm just saying a is b, so that's as easy as that. So I can commit to two polynomials and then I just can prove that all this. So when I generate a proof, what I would prove is that these polynomials are, one is the permutation of the other.
00:46:38.602 - 00:47:28.154, Speaker B: Okay, I can do a permutation check, but in multicolumns, for example, here you see for example, a one and a two must be equal to b one and b two, but in different order, and with only some selectors, only in the columns that were select, a is one, sorry, in these rows, on the rows that selected here, I want that this being here. Okay, so in this case, the three three is three three is here, the four four is four four is here, and the one one is here. And no matter what are the other values that are here. So this is what I want to enforce that. This relationship follows. Okay, and how you write that in pill? Well, you write this way, selector a. Here you have the columns that you want, and is selector b one and b two.
00:47:28.154 - 00:48:01.234, Speaker B: So, defining these polynomials, so defining these relationships, simple, is very straightforward, very easy. You have all these relationships here, okay, so it's in specific language. It's a language that's built for that. And all the CkVM you can read and you can see all the pills. So all the pill files are in the Vm. Okay, what else you can do? You can do block ups. For example, you can see that all the values in a must be in b.
00:48:01.234 - 00:48:25.066, Speaker B: Maybe it's possible that there are some values here that are repeated or some values in b that are not in a. Okay, but this is just an inclusion set. Inclusion, it's a block up. Okay, so I can do this polynomial. And here, what I'm saying is a in b instead of easily. Okay, I can do also with multicolumns and with selectors the same way. So here is the 33 must be included here.
00:48:25.066 - 00:48:48.290, Speaker B: You see here, for example, that 33 is two times, but this is correct because it broke up. The four four is here and the one one is here. Here I have the two two that we have no representation. But this is okay. And you can have a selector in the left and in the right. So in the inclusion and the no inclusions. Okay, so what else you can do in pill? In pill you can do the connections.
00:48:48.290 - 00:49:29.390, Speaker B: For example, in this column, I want to force that the first evaluation, the fourth evaluation, the fifth and the 6th are exactly the same. Or I want to force that the second evaluation and the 7th evaluation are exactly the same. So how do I do that? Well, here I define a polynomial. In general, it's going to be a constant polynomial. That can be anything, but it's going to be a constant polynomial. That actually is the identity polynomial. But with these permutations, okay, for example, the first, 4th, fifth and 6th or so is one w three, w four, w five.
00:49:29.390 - 00:50:00.700, Speaker B: What I'm doing is I'm doing a rotation, okay? So I'm just putting this, but in a different rotation. It's w five, one w three w four. So it's a cycle. It's a cycle. So what I'm saying here with defining this cycle is that these evaluations must be the same, the same with the second and seven. So the w and w six here is w six w just do the rotation. And the same w two, w seven, w seven w two.
00:50:00.700 - 00:50:32.530, Speaker B: And I can do that also with multiple columns. So I want to connect, so in this case, I want to connect the first with the third. So how I do that, I'm defining. Well, in this case, in this case of having one identity polynomial, I have three identity polynomials. Is this k one, e this and k two, this. And then I'm switching, for example, this number five, and this number five. So I'm just switching, this would be the k two w, and this is the k one w two.
00:50:32.530 - 00:51:14.610, Speaker B: But I'm just switching one by the other. In this case, it's doing this cycle of rotation. Okay, how do I write that in pill? What I'm just saying in this case is aa connects s, or if I have multiple columns, I'm just saying that a one, a two, a three connect with s one according to s one, s two and s three. So I'm forcing that. This is a copy constraint. This is copy constraints for the people that know splunk, actually, you can write easily plonk imperial. So in this case, you define well the committed polynomials, ABC, plonk, you have the SASVSC, this is the connection, the copy constraints polynomial.
00:51:14.610 - 00:51:54.518, Speaker B: Then you have the plunge q left q right q multiplication, q output, and q constant. And then I'm defining here what this is the relationship that these polynomials must fulfill. And then here you have the connect a, b and c is connects to that. In this case, I am also defining a public input that's in a zero, and defining the constant l one, which is a polynomial, that's one in the first and zero to all the remaining rows. And then I'm just saying that at l one, I'm forcing that a is the public input. So this is an example of plonk with one public input. But you can see that you can write any kind of plonk.
00:51:54.518 - 00:52:41.226, Speaker B: So plonk is just an example of, of p. Okay, but all that, that's great. But how you write a processor, because this is very good because this is a state machine, but actually how you write the processor. So let's create a processor for this, because this is a simplified version of the processor that we have. But it's very simple. So conceptually it's exactly the same that we are doing. Okay, so the idea of a processor is in a processor, actually we have a set of registers.
00:52:41.226 - 00:53:06.322, Speaker B: In this case, we have registers ABCD and E. These are going to be committed polynomials, the state of each register. And then we need to define here. In each step, we need to compute a prime, b prime. So the register will evolve. For example, if I'm doing a move between a and b. So I need to copy a to b in an instruction, and in each step I am executing an instruction.
00:53:06.322 - 00:54:07.066, Speaker B: An instruction in our case is defined by a set of multiple, so it's a set of multiple polynomials. Here, in these polynomials is the instruction that I am executing. Okay, so there's going to be a polynomial. That is saying which instruction I'm executing at each clock. So at each row in this case, okay, and the instruction in our case, for example, can be in a, in b, in c, indent free, in free, in all these things that you see in white. This is part of the instruction. So the instruction, every instruction in a can be zero or one, in b can be zero or one or number const can be, you can understand this as a single polynomial, okay? And this is how I'm defining the relationship.
00:54:07.066 - 00:54:41.714, Speaker B: So how I'm computing a prime, b prime. So I'm computing the next step, okay? So in this case, well, I'm defining here intermediate polynomial. In this case, you see, Paul, op, this is just a calculus. So I'm just taking some polynomials and computing an intermediate value. In this case, what I'm doing here, op, is I'm just selecting somehow some of the registers. Actually, I'm adding the registers. Imagine that in a is one and in b, in c, in d, in e, everything is zero, okay? So here is a times in one, b times in b.
00:54:41.714 - 00:55:13.854, Speaker B: So in this case, in one is going to be one. So op is going to be a, and the remaining are going to be zero. Okay, I can also, const is also part of the instruction. Well, all const is also part of the instruction. So for example, op can be a specific value here. Okay? And in this op, then with this op, what I'm doing is I'm assigning to a prime. So how I'm computing a prime? Well, if set a, if the instruction have the set a bit set to one, then this is going to be op minus a plus a.
00:55:13.854 - 00:55:53.162, Speaker B: So this is going to be op. So I'm going to set the value of op to a. If set a is zero, then I'm just going to keep the last value of a. Okay? So a move instruction will be an instruction where, for example, if I want to move from a to b, then in a, it's going to be one, set b is going to be one, and in b in c d in e and set a set b, set c, set d, and set d is going to be zero. Okay? So set b is going to be one. So I'm going to just move the value of a, I'm going to put to the b. This is going to be a move from a to b.
00:55:53.162 - 00:56:19.650, Speaker B: If I want to check out, for example, an immediate value. Imagine that I want to put a four in register c. Okay, here const, so in a and b in c and d is going to be zero. Const is going to be a number four. This is the immediate value. So op is going to be the constant, is it going to be this constant value? And then I'm going to put the set c is going to be one and the others are going to be zero. So I'm going to put a four in the number c.
00:56:19.650 - 00:57:01.726, Speaker B: Okay, you see here that you have registers, and here you have a processor that have registers, and in this case it's executing only instructions that are doing moves. But I can move any value of any register to any value of any other register. And I can also have this constant disimediate values. Here I have another important polynomial is a free. So there are some instructions that is going to allow us to put any value to op. This is because in general, this processor is not going to really compute anything. Actually what it's going to do is going to verify things.
00:57:01.726 - 00:57:49.706, Speaker B: So it's quite typical and it's quite useful. For example, you do a division, then what you do is you put the result of the division, and then you are checking that the result that you put in the division times the question is equal to the dividend. Then you will have another instruction that's actually checking this operation between registers. Okay, so it's quite common, not all of them. So this is free in but some instructions. And sometimes it's interesting to pass this to allow the system to introduce a specific value, probably, well, because you're probably going to check this value later on. Okay, well, here, the other thing is, sometimes you want to have conditional jumps.
00:57:49.706 - 00:58:28.250, Speaker B: I'm not going to enter too in detail here, but the idea is that, for example, I can have op, I can check if this is zero or it's not zero. And according if it's zero, it's not zero. I have a program counter that actually saying which instruction of the program should I be running? And then in general, if it's not a jump, I'm going to just go to the next one, next instruction. But if actually the jump happens, then I'm going to jump to an address. An address. This may be maybe, for example, it's part of the instruction. Okay, so here, well, here is the e zero, and at the end is the pc jump.
00:58:28.250 - 00:58:56.342, Speaker B: If it's jump, then I'm going to the address minus pc plus in plus pc plusing. So I'm going to the address, and if it's jump is zero, then I'm going to pc plus. Ink is one, is the next instruction. Okay, so with this you have a processor. But the thing is here we have a problem because we commit to the instructions. So the instructions are committed polynomial. So I can execute any instruction that I want, but which program I'm running.
00:58:56.342 - 00:59:25.546, Speaker B: So here I can set up instructions. If I put a specific instruction, the processor is going to execute that instruction. It cannot execute anything else, just that instruction. But here I could put why. In the first clock I execute a jump. In the second I am executing an Addition, or in the third I'm executing a move and not something else. Okay, so here is how I link, and the idea is I can have a RoM.
00:59:25.546 - 00:59:50.360, Speaker B: A ROM is a constant polynomial. Actually, it's the program that I'm running. This is constant. And here you will have the instruction you can read here. This is going to be a set of polynomials. In this case, this is going to be all the polynomials in a, in b, in c, set a, set b, set c, set d. So here are all the polynomials that compose the instruction itself.
00:59:50.360 - 01:00:26.210, Speaker B: And here the only thing that I'm adding, an extra polynomial, which is the row line, and this is constant. So I can create a program, a specific program that's going to start from the beginning. And this is a program that I want to run to my processor. Here the instruction is a set of polynomials that have a specific polynomial. That's the line and in my trace. So in my mainstay machine, I will have the instruction that I'm executing. This is a committed, this is a committed polynomial.
01:00:26.210 - 01:00:45.270, Speaker B: Here I can put whatever I want. I can execute in the first line in a net, and I'll jump or whatever. Okay. And here I have the program counter. The program counter is the line that I supposed to be executing. So if I start from the zero, that means that the program counter must be zero because it's an app. Then this program container must be a one.
01:00:45.270 - 01:01:11.410, Speaker B: In this case, I jump to five. That means that the program counter, I jump, and I need to execute the line five. The five is the mole. So I'm executing a mole here. Okay, so how do I check? How can I force that I'm executing this specific program? Well, I'm just doing a block up. I'm just doing a block up of the program counter, and all the instructions must be included in the program line. And these instructions, that means that because there is only one line, one.
01:01:11.410 - 01:01:50.926, Speaker B: So if the program counter is one, that means that all the instruction must be exactly the instruction that's in the line one. Okay, and with this way, so having the constant, so the program itself, what we call it the ROM, the program that we are executing, and we have the instructions, the committed instructions, it's actually the instruction that I want to execute is when I'm forcing that, I'm executing that program, but the program is fixed, it's a RoM, so I cannot change, it's hard coded, it's a constant polynomial. The proverb already. Now the ROM. But how you execute the program is going to change. Maybe sometimes there's going to be an if. That's going to be one way and the other way.
01:01:50.926 - 01:02:55.038, Speaker B: So the instruction that I'm executing at the specific clock is going to be different. So that's why I have this instruction that's in the main, the instruction that committed, it changed for every iteration, and I have the instruction that's executed so that the instruction on the program, on the rom, okay, so this is changes. And then with this simple block up, I'm just forcing that I'm executing this program. Okay, so you see here, this is the basics, but you see that with pill, I can define easily, processor have registers, we have a program counter, we have conditional jumps here I can have instructions and well, I can add things on top of that. But then at the end I have a program, and I'm executing a program. So now I need to just do this processor richer, just to build the CKVM. So for example, I want to add memory to this processor.
01:02:55.038 - 01:03:36.400, Speaker B: How do I do memory? Okay, so the idea is that I'm going to have instructions that are reads and writes. So in this case, for example, in the clock one, maybe I'm executing a write instruction to memory, to the address five and the value two. And in the two, I'm doing a write address three and eight. Okay, and I will have a set, this program will have a set of reads and writes. When I'm reading, I'm just putting the value, but I want to verify that these reads and writes are okay, correct according to memory. So I'm just reading. If I write a three in the position four, the next time that I'm reading it, I need to read three.
01:03:36.400 - 01:04:08.630, Speaker B: I cannot read a five. That's the thing that I want to check. So in order to check that all these reads and writes are, okay, what I'm doing is I'm just creating another state machine. This state machine, I'm just putting all the instructions, but order it by address. Instead of ordering by the code. I'm just ordering by address and by the clock number if you want the code. Okay, so because all these addresses are packed, then I can do these reads and writes in a single register.
01:04:08.630 - 01:05:00.598, Speaker B: So here in the memory state machine, I can just put the conditions first to force that the address is forced, is sorted. I'm just forcing that machine is sorted, and also that the reads and writes are done in the right way. So if I'm putting a write of an eight, then when I'm reading, I'm reading an eight, I'm just reading the value, I'm just changing the value of this register when I'm doing override. Okay, and then here with a single permutation check. So I'm just permutation check, of course, selecting only the memory operations so the ones that you see here. Okay, so only that, I'm just doing this permutation check with the memory operations here. So with this simple permutation check, you can prove, so you can have already memory.
01:05:00.598 - 01:05:54.730, Speaker B: So we have a state machine, we call it memory, that's actually doing this. And then it's a link between the main state machine and the memory state machine in order to force to have memory, okay, we have, for example, another state machine that's actually computing arithmetic state machines. For example, it's doing multiplications of 256 bits, which is a complex thing. So we have a stain machine, but it's very specialized just for building multiplications of 256 bits. Or if you want arithmetic operations on 256 bits. And the idea is that in the mainstream machine, we just want to prove. So we put ABCD and, well, in this case, op, okay, so we want to force, for example, we want to force that, for example, a times v plus c equals d two times to 256 plus op.
01:05:54.730 - 01:06:44.186, Speaker B: So there is a 256 bits relationship that needs to be fulfilled here. I want to force that. So how can I force that? This relationship here is, okay, well, what I'm doing is I'm computing, I have this arithmetic estate machine, where I compute all the operations that I'm using, the type of operations that I'm doing in the mainstream machine. And with a single, this case, the permutation check, okay, I'm just checking that all the operations that I am doing here in the main state machine are also done here in the rhythmatic estate machine. Permutation check or a plug up. Actually, we started with a plug up and now it's a permutation check because it's easy. Here is the other idea of the system.
01:06:44.186 - 01:07:30.586, Speaker B: We have secondary state machines, so we have other coprocessors that are doing specific operations. And in the main state machine we are just connecting via plokup or via permutation check for doing these operations. All these relationships are, this is defined in. So what's the system? So what's the CKBM? So what's the CKBM? What's composed of? So we have the processor, so we have the main processor, we have the RAm. We already see this ram. This RAM in the EVM has some specific things. For example, some have some pagination, some context and things just to work.
01:07:30.586 - 01:07:57.182, Speaker B: For example, that works well in the ZKVM because when you're just doing, when the smart contract is scaling another smart contract, you have like a new ram. So in this case you have a new context. So we have this memory. Passionate. And then also we have a super state machine. It's like another state machine to handle all this misalignment. The problem of the EVM is that 256 words, but the memory is byte aligned.
01:07:57.182 - 01:08:36.134, Speaker B: So you can read something that's between words. Just you can start at position seven and go until position seven plus 32. And then you need to read maybe from memory in the different places. So to do these joins and to do these separations for the read from rights of memory, we have a special state machine that we call align state machine. It's a very small state machine, but specific for optimizing this part of the ABM we have the ROM. We already talked about the ROM. This ROM is actually what, it's ethereum.
01:08:36.134 - 01:09:15.258, Speaker B: So it's implemented all ethereum. In the rom we have a storage. So the storage that we're using here is a sparse Merkel tree, very optimized for the Goddelox field. But at the end it's a sparse Merkel tree is key value. So it's a key value database that you can hash for a given set of key value. You have a hash, then you can do reads or writes to this storage, actually, this storage is the way it's implemented is another processor, same way that we have the main processor, we have this storage processor. And in this processor you can set to zero.
01:09:15.258 - 01:09:55.830, Speaker B: And sometimes in the sparse micro tree there are some different conditions and some logic of the sparse micro tree. So this is done like another program that's doing all these operations, but the technique is exactly the same that I explained. In this state machine. What else will you have? We have an important same machine is the binary. In this binary, we are solving all the instructions that, for example, for doing add soup, less than sign and less than equal answer and exhaust. This is for the normal operations in the VM. So this estate machine is doing these operations on the 256 bits.
01:09:55.830 - 01:11:15.182, Speaker B: So in the mainstream machine, when you need to execute XOR of code, mainly it's going to do is going to call this binary state machine derived state machine. I already explained it a little bit how it works, but the idea is that you can do 256 bits operations. So we have one operation every 32 clocks, and is doing their specific 256 operation. And here in this estate machine, it's not only doing this basic 256 operation, it's also doing some ECDSA, doubling, addition and doubling operations. So, to check the ECDSA of the transactions, actually it's a program in the main, but is using this specific function for doing all these elliptical curve operations as a special instructions of the arithmetic state machine. And then we have the ketchup, the ketchup and all the hashes. But the ketchup at the end is we have a specific state machine that computes ketchups.
01:11:15.182 - 01:12:16.786, Speaker B: It's not only ketchups, it's ketchups and all the paddings and so on. All the hashes are some specific state machines that are quite probably, maybe a little bit complex, but they are handling all these paddings for ketchup, or paddings. So, for example, all the codes, all the source code, we are hashing it with positon because it's much more optimal. But we need to implement ketchup for the CDSA verification, and also because the EVM also hosts ketchup. So this is a little bit processor. So you see that the processor, it has some basic instructions, but then there is the real program, that's the program that actually is running on top of this processor. But this is not derived methodization anymore.
01:12:16.786 - 01:13:02.750, Speaker B: So you see that deriveation here is quite simple. The constraints are defined in pill. The pill is divided in very concrete state machines, and each state machine is not. Some of them are a little bit complex, but there is no state machine that's bigger than 100 or 200 lines of code. Okay? So it's quite easy to check, to validate, to audit, and to check that all these constraints, these polynomial identities, are okay. This is the idea of one of the parts of the auditing part from the ROM perspective here. So now it's a program, it's a hardware design, so it is still design.
01:13:02.750 - 01:13:43.442, Speaker B: And then we have another domain that's the program design. Of course you need to understand how the processor works because at the end you are programming in assembly, but you see a program, okay? And the best thing here is just to take a look and how this program looks like. Okay, so this is the program, and I want to explain a little bit what's the structure of this family. So you can just go here and see a little bit what we see. Okay, so in the first part, what we see here is, for example, we have some places that there is an arrow, okay? And here at the left is a selection. In general, it's an addition. Here is just gas plus b.
01:13:43.442 - 01:14:11.114, Speaker B: So here in general you are selecting something and then you are assigning to something. Let me just have some example here. So here for example, in this case is the move a to b. So what I'm doing is I'm selecting a and I'm setting to b. So when I have this instruction in assembly, what it means is that I'm going from a to b. Here, for example, this is the immediate value. I'm just putting a zero to a and b.
01:14:11.114 - 01:14:39.780, Speaker B: I can put here three to a and b here in the same instruction. This means that set a and set b are one. So this processor allows me to set two registers at a time or setting a register to at a time. So I can do this with this way, okay. Or I can for example, do an addition. It's not 256 bit addition, it's a field addition. But I'm just adding a and b and just setting the value, the result to a.
01:14:39.780 - 01:15:21.026, Speaker B: Okay, when in the left side I see a dollar, that means that's a free input, but a free input, but, okay, but it's a free input. So the system allows me to put anything in there but what I should put here in there. So in order to indicate to the executor the program that's executing this, that's executing this program, what value needs to put. Here I have like a soup language, that's this dollar. And here for example, here I'm putting part of the transaction as an example. Or I can put maybe an operation, I can put maybe five plus a. So here I have a soup language here just to tell to the executor what I need to put.
01:15:21.026 - 01:15:47.270, Speaker B: But here, actually I can put anything in here. Okay. Sometimes there is this dollar without these brackets, and that means that's implicit. So in this case, for example, I am executing a memory load. So I don't need to tell if I'm executing a memory load. What I'm going to do is here, the executor already knows that's going to put the value that's stored in this position. So there is these implicit values.
01:15:47.270 - 01:16:21.922, Speaker B: So when there is no dollar, it means that it's an implicit value here. Okay. And here in the left it's a column. Sometimes I'm going to have the instruction, except here I can have added or less than or maybe a jump or envelope. Here I have the actual instruction that I'm executing or checking or validating. Here I can have here levels just for the jumps. I can have variables, I have two kinds of variables, global variables that are in system variables.
01:16:21.922 - 01:17:07.890, Speaker B: And then I have variables that are context specific, so can define, and this is save it in a specific place in the memory for context on that. Okay? And there is something that, this is not an instruction itself, it's just an indicator to the executor to do something, to do some command in there. There are things that you don't need to execute anything in the program, but you need to tell the executor maybe to increment a variable or maybe to lock something. For example, all the traces are done via this way. So every time that you finish an opcode, you are just notifying the executor that this opcode is executed. So the executor can do other things. Okay.
01:17:07.890 - 01:17:57.940, Speaker B: But here you see, this is the example of the language. If you go to the, you can run to the Rom and well here is here for example, you have all the opcodes implemented. Actually the system is already finished. So you can check this, for example, this is the RLP of the transactions. So here how you process the transactions. You have here for example, the process of the transactions itself. You can just run to the, see, this is all the IBM, this is like if you are reading gas that's running the theorem here you can read exactly the same.
01:17:57.940 - 01:18:39.700, Speaker B: And actually this is, well, here there are some instructions that you can do in the assembly. You can do memory load, memory store storage, load storage store. You can do all the, for all the hash management hash ketchup and hash Poseidon to hashes that we have in the system for managing hashes. You have the arithmetic, you have an assert if you want to just invalidate the proof or something like that. You have the memory aligned things. You have all these ad soup. So all these binary operations, you have one instruction for each binary operation that you have there.
01:18:39.700 - 01:19:06.870, Speaker B: That's it. Okay, so this is the arithmetization. This is how we are building the ZKDM, of course, here, the processor, actually, it has five registers. Has more and more registers. Registers actually are 256 bits registers. That means that are really eight polynomials of the Dolby locks. And each polynomial is a chunk of 32 bits.
01:19:06.870 - 01:19:29.266, Speaker B: So this is eight times five registers here. And we have a bunch. Well, you can see the pill. And you have all the instructions there. So you have some other special registers for gas management, for memory management. But there are three or four more. But it's not much more than that.
01:19:29.266 - 01:19:45.300, Speaker B: Okay, so it's a little bit that, but when you go deep, you can go to the details. But it's very much. This is the main stem machine. In the other side, you have the rom. Okay.
01:19:47.130 - 01:19:48.120, Speaker A: What else?
01:19:49.850 - 01:20:05.754, Speaker B: Yeah. Okay. Once we finish that, at the end, we have a set of polynomials. Actually, this is automatically done. But actually, what's doing what we do here. So here we are using a polynomial commitment schema. Very similar to what scroll is doing.
01:20:05.754 - 01:20:34.194, Speaker B: But instead of doing the K commitment here, we are using a fry like commitment. So fry is just for. It's not really a polynomial schema, but can be converted easily to opening polynomial schema for that. Okay, well, just commit to the polynomials. Actually, this is all three steps, actually. And then just get the values each step. And then you just do the openings.
01:20:34.194 - 01:20:51.062, Speaker B: So you just evaluate to a specific value. And then you just verify that these polynomial relationships are okay. So this is the typical of the polynomial equivalent, of course, here, Shamir. And then the other thing. So this is. We have a proof. Okay, so this approve actually is a stark.
01:20:51.062 - 01:21:17.794, Speaker B: It's actually around 600 polynomials or something like that. We're reducing it a little bit right now. But it's around 600 polynomials and of two to 23 degree of two to 23. It is the main proof. Okay. And each proof here. So it validates a batch, actually, in each proof for 2023, more or less.
01:21:17.794 - 01:21:44.250, Speaker B: It's an average, but more or less is about 4 million gas. Equivalent to 4 million gas ethereum. Okay, so actually, this is the more updated stroke of the proof. So here what we are doing is for each batch, we are creating a proof. This proof is a big proof. It's a proof that just here only because this proof needs to go fast. This is just a blow up factor of two only.
01:21:44.250 - 01:22:13.174, Speaker B: So it's 128 queries. So this proof is quite big. It's a big proof for itself. And validating, verifying this is costly. So here we have a compressor circuit, we call it c twelve a. But this is actually converting this proof to another proof that's just much smaller and just much manageable. So instead of 128 queries, here is just 64 queries with much less polynomials each one.
01:22:13.174 - 01:23:00.190, Speaker B: Okay, here we have like, this is like an adapter, we have another siguid, we call it recursive one that actually converts to a proof of a batch, to a proof of a segment that's a segment of just one batch segment of a blockchain. And then actually we have a recursive circuit that takes two segments, no matter if it's of one or if it's of ten. And they just join together to a new proof segment of both. It adds two segments, it needs to be consecutive segments. But I can for example aggregate the proof of that proof from three to six. With the one that proof from seven to 18. I can join them together and I just create a new segment.
01:23:00.190 - 01:23:41.066, Speaker B: And this is iterable. So I can do this as many times as I want. So at the end I can generate a proof of 30 batches, or 1000 batches, or 1 million batches. It's just a matter of just aggregating it. Okay, we have a single proof. And then here we have another circuit that's mainly commercial stark, but instead of we're using the godilocks as a hash function, is using the poseidon, but for the BN 128. And we have a final circuit that's a circumcise, regular circumcise that generates a plunk proof.
01:23:41.066 - 01:24:06.300, Speaker B: Plunk or glossy proof. And this is actually what's validated in the blockchain. So this is the schema for the recursion schema. So a degradation schema for the system. Actually this is not in the testnet yet. Let's see if maybe next week we can put that in testnet. Let's see if everything works.
01:24:06.300 - 01:24:36.802, Speaker B: We are testing it internally at this point. So at this point in the testnet, it's just validating each batch, one proof per batch. But now in the next week we will have this aggregate on this aggregated, aggregated proof system. That's very much the thing. So, proof cost. But this is more technical things. Right now we are getting this very low.
01:24:36.802 - 01:25:01.370, Speaker B: So we are eight minutes. But with gpus and so on, I think we can be just below five minutes for sure. So we are doing very good work in this for testing. This is important. So we are running all the Ethereum test suites, we are getting all the tests, and we are passing all the ethereum test. Okay. And there are things.
01:25:01.370 - 01:25:34.870, Speaker B: So actually we are implementing almost everything. Things that we are not implementing in this first version are going to be the shadow 56 Blake padings. These are the pre compiled smart contracts. And mainly that's it. Mainly all the remaining things, all the opcodes and everything else is implemented. There are some slight difference, but very few things normal users should not notice at all. This.
01:25:34.870 - 01:25:59.360, Speaker B: Okay. And yeah, here is all the repos just for you to take a look. You can go at zero x polygon Hermes. And here you can check all the proofs. So that's very much my presentation. Of course there is a testnet, so if you want to test also, testnet is here. I'm sure you already know, but you can take a look how the system works.
01:25:59.360 - 01:26:10.660, Speaker B: Okay, so that's it. Maybe it's not October 13, November or something, but yeah, that's my presentation. I don't know if there are questions.
01:26:11.990 - 01:26:28.680, Speaker C: Or processors like for example, the memory, the memory one and the main one. I'm assuming that you basically need to recomit the table if you're doing it via lookups, right? Because the order of the things might not be the same.
01:26:29.930 - 01:26:52.026, Speaker B: Yeah. So there is two state machines. There are the polynomials in one state machine, another polynomial in the other state machine. And then we are, in general, you have two polynomials and then we just check the relationship. But polynomials in one state machine are ones. And polynomials in the other state machines are others. They are not shared.
01:26:52.026 - 01:27:20.834, Speaker B: They are just compared. So yeah, that means that sometimes, especially the results, we have this twice. We have two polynomials. One in the main estate machine and the other in the mainstream machine. In general, the other registers, for example, for the rhythmatic estate machine, the polynomials are the registers. But you need to have some kind of a replica. In the arithmetic estimate machine machine you need to output.
01:27:20.834 - 01:27:47.630, Speaker B: So you need to create the latch because this is a result that's generating the arithmetic estimate machine. Dan is generating statements saying this number times this number. Plus this number is equal to this number. And these four registers are a, B and C and D in the main state machine. And then you do the blue cap or permutation check between one table, one state machine and the other state machine.
01:27:48.790 - 01:28:26.718, Speaker C: Okay, makes sense. Thank you. And the other thing was regarding what you basically said at the end with the segment proofs and the recursion stuff, which is what I'm assuming, maybe I'm wrong, but is that you basically want to lose the link in between a proof per block, basically so that you can constantly feed whatever proof that you have. And it might be getting things in between blocks or it might be verifying. Sorry, proving like whatever it is. You can just throw stuff at him. Right?
01:28:26.804 - 01:28:44.740, Speaker B: We are not proving blocks, we are proving segments, which is a set of blocks. A segment can be of one block, but in general it's going to be a segment between batch or block 25 and block 63. Exactly.
01:28:45.910 - 01:29:07.082, Speaker C: So kind of my point here is, do you need in between those segments? Like how is it possible to not need to commit data of the state in between one segment and the other? So for example, if you are in one block and you have done some reads and some writes, and in the next one, you need to have this information available. So how do you manage that?
01:29:07.136 - 01:29:50.466, Speaker B: The idea is that the sequencer is just putting transactions in the layer one. And these transactions are deterministically generate a state. Okay? So at the end, everybody can deterministically. If you have a state and you have a set of transactions of maybe of ten batches, you deterministically know what's the next state. Anybody can compute. The only thing that you are doing with the proof is you are putting this new estate explicit. You are putting this new estate on chain when it's on chain.
01:29:50.466 - 01:30:07.078, Speaker B: Then it's when you, for example, you can withdraw because chain already knows that this is the real state. That's a big point. But before that, the transactions are already final. So the state. And the state is known. You need to compute it. But it can be computed.
01:30:07.078 - 01:30:10.170, Speaker B: So anybody can compute because it's on chain.
01:30:10.750 - 01:30:11.500, Speaker C: Okay.
01:30:13.390 - 01:30:53.206, Speaker B: Thank you. The interesting thing here is that, and this is important, all the transactions are deterministically executed, okay? And we have also this concept of forced transactions. So any user, so in general, the user will send the transactions to a sequencer. But if the sequencer, for example, is censoring the transactions of a user, the user can always send these transactions on chain. They will have to pay the gas, but they will put on chain and then the sequencer will be forced to include these transactions. If not, he will not be able to sequence any other batch. So the sequencer will have to put those transactions.
01:30:53.206 - 01:31:39.130, Speaker B: And these transactions can be any random string. So it can be anything wrong. So it can be anything that you can imagine there. It can be a transaction with an invalid nons, or it can be a transaction with an invalid signature, or maybe with a loop of catch acts that doesn't fit in a proof. Okay, here the proverb needs to the prover warranties that it's going to be possible always to compute approved, no matter what's the transaction that you are inserting there. Okay. And this is probably one of the difficult things, but this is warrantied in our system, at least theoretically.
01:31:39.630 - 01:31:41.930, Speaker C: Okay, thank you, Julie.
01:31:44.850 - 01:31:45.760, Speaker B: More questions?
01:31:48.370 - 01:31:52.874, Speaker A: You said about gas calculations, so does it mean that your EVM also calculates.
01:31:52.922 - 01:31:58.830, Speaker B: Gas costs of execution exactly the same that ethereum.
01:31:59.410 - 01:32:02.930, Speaker A: Why do you need this if you don't actually charge?
01:32:03.910 - 01:32:22.066, Speaker B: We need this because we want to be 100% compatible with Ethereum and program user. So adapt should not notice any difference between deploying or using a smart contract in ZKVM or deploying smart contract in layer one, et cetera.
01:32:22.178 - 01:32:26.666, Speaker A: So you need this to make the gas upcode work properly, right?
01:32:26.768 - 01:33:20.330, Speaker B: I mean the program should, well, the gas code and that works everything exactly the same here. It's interesting to notice here that the gas, so that the cost of the EVM and the gas cost of the EVM, the ZiGBM and the EVM is not that different. There are some exceptions. Ketchup is one of those and so, but it's not that bad. So that means that the deviations. So in normal use cases, users should not have any issue on that. And if you go to extreme cases, well maybe there is some transaction that maybe is not going to be processed in the ZKBM, but it's going to be very extreme cases.
01:33:20.330 - 01:34:05.402, Speaker B: This is a loop of ketchups or something that is going to be difficult. Could be a loop of maybe arithmetic operations, but it's difficult to, to get this. So you need to be very good at defining this setting and constructing these operations because they are very special. Most of the operations are running right now. For example, we deploy uniswap B three without recompiling anything. Runs perfectly. Just throw the compiled smart contract, same that and it's running.
01:34:05.402 - 01:34:27.502, Speaker B: And Uniswap B three, for example, is a quite complex set of smart contracts, or truffle or hardhat or any other tooling you have how to use metamask and you use anything and everything works. You don't need to worry about. I think this is nice.
01:34:27.636 - 01:34:38.580, Speaker A: No, I mean you are trying to preserve compatibility at high extent and ethereum itself preserves it. Right, because every hard fork can break compatibility and could in theory affect old contracts. Right?
01:34:39.830 - 01:35:22.770, Speaker B: Yeah, we will follow hard fork. So we will follow hard forks of ethereum somehow. But we need to see this is, you are talking on something. Maybe it's going to take a while. I think the first is just being quite 100% compatible and meaning and having a warranty that the system is not going to change for a while. In general, hard forks of Ethereum, they don't used to break too much because the tooling would not working. So we need to see case by case and see what's adding and see if this is included or not included.
01:35:22.770 - 01:35:45.420, Speaker B: I believe that we need to follow a little bit, but this is something that we need to manage. But in any case, at some point, what's clear, and this is important to know, is that at some point the EVM will have the warranty that the EVM is going to be frozen. And at that point it's going to be also the time to froze the roll ups. But maybe it's going to take some years.
01:35:52.780 - 01:36:13.004, Speaker C: Jordy, if I can ask. One of the cases that I believe can be a problem, at least is for us, is instructions like Xcode size or Xcode hash, which force you to copy a lot of code to the memory, well, from the memory, and then count it, hash it, do a bunch of stuff.
01:36:13.042 - 01:36:27.140, Speaker B: And it's pretty cheap in our case for this, for example, what we are doing is when you are deploying the smart contract, at that point, you know what is easy, what's the hash and the sites, and then we store that on the storage.
01:36:27.480 - 01:36:28.230, Speaker C: Okay.
01:36:29.880 - 01:36:59.464, Speaker B: In those cases is quite relatively fast. There are some things read code itself, but we are using this. So for storing the code, we are not using ketchup, we are using this Poseidon. So it's quite fast. It's quite fast for loading the code and executing. And this is quite fast here. Well, any question, just, I don't know where.
01:36:59.464 - 01:37:13.820, Speaker B: Maybe probably grace or somebody will send some link, but here, me and all the team is open to any questions you may have. We continue, I think we continue sessions tomorrow. Bye.
