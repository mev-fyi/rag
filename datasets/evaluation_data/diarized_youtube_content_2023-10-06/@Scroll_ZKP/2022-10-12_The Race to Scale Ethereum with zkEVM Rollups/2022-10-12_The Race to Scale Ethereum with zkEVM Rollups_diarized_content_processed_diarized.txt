00:00:03.400 - 00:00:03.756, Speaker A: Great.
00:00:03.858 - 00:00:10.668, Speaker B: Sale will also introduce herself. She's dialing in all the way from. Where are you now?
00:00:10.754 - 00:00:11.736, Speaker A: From Berlin.
00:00:11.848 - 00:00:33.968, Speaker B: From Berlin. That's great. And then we have prepared some questions, of course, for the team. And I know a lot of you are here to learn about scroll, so we want you to have an opportunity to ask questions as well. At the we start. Are we starting with Leah or are we starting with Leah? Right, so, leah, I want to introduce.
00:00:34.064 - 00:01:17.570, Speaker A: Yeah, yeah, I wanted to sort of give a little bit of the framing, if that works. Cool. Yeah. I just briefly wanted to introduce the two of us real quick. We're Leah and Raheet, and I'm leading partnerships at scroll. And just for a little bit of context, I have been working in the space since 2018, and before working on infrastructure, I have been working in DFI. So more on the DAP level, and basically have been experiencing firsthand with our users together what scaling issues come with Ethereum at times.
00:01:17.570 - 00:02:15.924, Speaker A: So whenever there was a spike in usage, whether it was DFI summer 2020 that I think we all remember, probably all farmed a little bit, or the NFT craze beginning of this year, it became really problematic for our users. And whenever the transaction cost just spiked uncontrollably. And being able to counterbalance the spikes have proved to be quite tricky. And a few years ago, when we started out, the scaling landscape was a completely different picture than it is now. There were not a lot of options available, and this is very different now. And especially when it comes to ZK, there have been a lot of breakthroughs recently, both in research, but also in hardware, that just allowed ZK rollups to enter the playing field. And maybe Raheed can also say a little bit more about himself later.
00:02:15.924 - 00:03:15.440, Speaker A: But just to give some context, he is one of our engineers at scroll, and he will be giving an overview of the scroll architecture. And Asad, he's an engineer, he works on the ZkavM team, and he designs and builds the circuits for the Zkavm architecture. What that means, he will explain. He's also not new to crypto. He has been working in the space for a while, has been working on a protocol called Ren, and also contributes to a lot of other open source Ethereum projects. And maybe we can just skip to the next slide just to give a little bit of a framing, sort of a few pointers that I want to give you before diving in. Yeah, we'll give an overview of what scroll is.
00:03:15.440 - 00:04:35.784, Speaker A: And in one sentence, it's a native ZkevM layer. Two solution for Ethereum and if you go to the next slide, I want to spend just like 1 minute on our vision or what things are important for us. So overall, basically what we're working towards is to scale Ethereum to make it faster and cheaper for users to make transactions. And there's just a few components that are important for us or that guide, I guess all our architecture design and what's special or unique to scroll is that we're working on EVM equivalents and basically what that means is that you will have the exact same developer experience on scroll that you have on Ethereum. Layer one another thing that's very important to us is we care a lot about decentralization and we're planning on achieving decentralization step by step. And that includes decentralizing all components, such as our approving and sequencer network. And third, we're building in the open and especially the ZK part.
00:04:35.784 - 00:05:28.016, Speaker A: We have been building with the community. And I don't necessarily want to speak for Rohit, but that was one of the reasons I got really excited when I learned about scroll. And one also a contributing factor for me to join the team is the close connection of the founding team and the engineering team to the same foundation. Scroll has been closely developed with the PSE team from EF and we really do share the values of open source and open innovation and a tiny bit of housekeeping. Before going into the details, maybe you can move on to the next slide. So just a quick overview of where we are. Currently we have a testnet out, but this is still permissioned.
00:05:28.016 - 00:06:33.490, Speaker A: But very soon. In a couple of weeks we'll be able to open it up more to the community and we'll launch the permissionless testnet very soon. So stay tuned. About updates one thing that we're also working on is always working on new ideas, on new use cases that become feasible now on l two, and if you have ideas or want to ping pong ideas, so feel free to reach out anytime. Our contact details are at the beginning of this presentation, but maybe we can also share it afterwards. In the telegram group that we set up on the left side you will find the QR code or the link to the Telegram group here for Singapore. We plan on doing more of these types of events, just really working closely together with the Ethereum community there as well.
00:06:33.490 - 00:07:22.880, Speaker A: And maybe some of you might be coming to Defcon to Bogota as well. And if yes, then please come hang out with us on Monday the 10th. It's one day before the conference starts. We'll have a day event roll up day where we'll have speakers from the entire ecosystem. So also optimistic roll ups will be there, CRM foundation will be speaking there, and obviously like also other CK projects. So come join us and we'll have time for some questions later on. And yeah, then I'll just hand over to Reid and wish everyone a good time when learning about CK stuff on a Friday evening.
00:07:26.420 - 00:08:35.190, Speaker C: Hello all. Thanks Leah for the introduction and I'll move on to my first slide, which mean we all feel sorry for this user. And if you saw this tweet on Twitter, you'd wonder, is Ethereum broken because someone pays $300 for a single transaction? That's like unheard of. But if you think about the important properties that we require in a decentralized network, then firstly it's decentralization, then security and censorship resistance. And once you focus on all these problems, then in a way you are trying to give up on scalability to some extent. And Ethereum's scalability problems were based on them. Prioritizing two of these components, which is decentralization and security, and scalability was never really a problem they were thinking about designing a solution for early on.
00:08:35.190 - 00:09:14.156, Speaker C: And why does this happen? Because every transaction is replicated across all nodes in the network. The state is replicated across the entire network, and this basically limits the transaction throughput. So whenever there's a lot of congestion in the network, someone will try to frontrun you and pay more. And then of course the gas fees shoot up. So what do we need? We need scalability. At the same time, we don't want to give up on security. So during the years 20, 19, 20, there were a lot of alternate l ones that came up.
00:09:14.156 - 00:09:51.708, Speaker C: There were a lot of side chains that came up which promised lower fees, which promised lower latency. So faster transactions, a lot of throughput. But they all came with some or the other downside. For example, there were some layer ones which faced constant downtimes. There were some side chains which relied on, not necessarily a small number of validators, but let's say most of the validators were also controlled by the same entity. So there's a lot of centralization involved over there. And of course you must have heard about so many bridge hacks that happened recently.
00:09:51.708 - 00:10:35.100, Speaker C: And all of that is basically scalability, but with some downside. So we want secure scaling. And this is what led to Ethereum coming up with its roll up centric roadmap. So you have two different types of rollups, optimistic rollups and Zk rollups. We already have optimism and arbitrum, which are optimistic roll ups live on their main nets as of now. But I don't think there's any Zk roll up, which is a general purpose Zk roll up live as of now. The first Zk roll up which launched on Mainnet was loop ring, I guess.
00:10:35.100 - 00:12:12.252, Speaker C: And loop ring is an application specific Zk roll up, which means that on this Zk roll up, the only interactions you could do is basically swap assets on loop ring decks. But then what we need is scalability through general purpose ZK rollups, which means as a developer, I should be able to deploy whatever smart contract I write, be it in solidity or wiper or any other language which Ethereum supports. As of now, both these types of rollups have some differences in how they finalize the transaction. With respect to layer one, optimistic roll ups use a delay period, and they rely on an optimistic strategy, which means that they think there will be some public user who's watching for any fraud which is happening on layer two, and we'll give them seven days, which is the period during which they can submit this fraud proof to layer one, saying that, oh, I've noticed some fraud, and the sequencer should be penalized for this. And there are these crypto economic ways of achieving security. In this kind of setup for Zk roll ups, we have a cryptographic proof, which in crypto native terminology, we call them as validity proofs. So validity proof basically is a snark, or a proof which says that given the starting state a and given a set of transactions that happened on layer two, we arrive at state b.
00:12:12.252 - 00:13:06.856, Speaker C: And this is a proof, a cryptographic proof that the state transition was done correctly. And once this proof is verified on layer one, then as a layer two user, you are sort of sure that, okay, my transaction has been included in layer two, and it has been confirmed and verified on layer one. So it's finalized from perspective of layer one. Both have different scaling potentials, and Zk roll ups can provide better scalability in the future as the crypto primitives improve and hardware computational efforts improve. So why are we building an EVM equivalent Zk roll up? I'll come to that later. But we use Ethereum as our base layer, which provides us security and data availability. And this is also the consensus layer.
00:13:06.856 - 00:13:59.900, Speaker C: So whenever we post our validity proofs back to layer one. It is on Ethereum. And Scroll is the layer two, where as a user, you do fast transactions, you get lower fees, and it's EVM equivalent because we want more developers and make life easier for users and developers, which I will go through later as well. So before I dive deeper into the different flavors of ZKE EVM itself, here's a small overview of what happens when you write a smart contract and how it gets compiled and executed in the EVM runtime. So there are several different high level languages in which you can write smart contracts. The most popular is solidity, but there are a few more like wiper. And these days there's another language which is really popular called Huff.
00:13:59.900 - 00:15:03.144, Speaker C: And each of those languages have their own compilers which are able to compile this high level language code into EVM compatible bytecode. So what you have at the end of this is a list of EVM opcodes. And these opcodes are basically run one by one in the EVM runtime. This is basically what happens under the hood. So ZkevM, which is a really popular word today, there are different flavors of achieving ZkEVM, and there are different levels of compatibility. So the first and the loosest compatibility is language level compatibility, where you say that as a layer two, I'm going to have a custom virtual machine, not the EVM, not the ethereum virtual machine. My custom VM will be much more friendly to these snark proofs.
00:15:03.144 - 00:15:24.370, Speaker C: So proving verification, all of that becomes a bit easier. But I will only support certain languages, let's say solidity. And I'll transpile that. Hello? Hello. Yeah, and then I'll.
00:15:29.260 - 00:15:30.010, Speaker A: Yeah.
00:15:32.540 - 00:16:49.220, Speaker C: It'S downtime. And, and I'll transpile that solidity code into another language, which, for example, if you've heard about stockware, so they have this language called Cairo. So you write code in Cairo, and then Cairo gets compiled down to Cairo VM. I'll discuss that later as well. So this is language level compatibility because you are, as a layer two, you're allowing developers to write programs in a certain language which gets transpiled into something else, which gets compiled down into a custom VM, which is not EVM. Bytecode level compatibility is where scroll lies in, which basically means that Scroll's Zke EVM architecture is able to interpret the EVM bytecode itself directly. So we don't really limit developers to using a particular language or something as long as your code, be it solidity or wiper or huff, as long as it can be compiled down to EVM bytecode, then it can be supported on scroll.
00:16:49.220 - 00:17:49.440, Speaker C: And this is a comparison of how each of these different ZK rollups are sort of whether they are closer to Ethereum, or whether they are farther apart from Ethereum in terms of compatibility. So if you look at the leftmost side, which is stockware and Zksync, it comes with its own advantages. For example, the prover costs are low. But the downside is that you need developers to learn a different kind of technology. You need developers to learn how to write their programs in Cairo. You need to build certain transpilers so that solidity code can be transpiled into their own custom vm. And as you approach closer to Ethereum, then you have bytecode level compatibility, which means that it doesn't depend how you write your code or which language you write your code in.
00:17:49.440 - 00:18:35.860, Speaker C: As long as it's EVM compatible, then scroll can support it. Polygon Hermes also lies in the same category. There are certain minute differences in how they achieve EVM compatibility differences between scroll and Polygon. But at the end of the day, for a developer, it would be a similar kind of experience. So I'll briefly go through the ZKVM based architecture of scroll. So as you can see that on the layer one side, which is Ethereum, we have a set of contracts mainly categorized into roll up contract and bridge contract. The bridge contract is basically what a user uses to interact with when they want to bridge from Ethereum to scroll bridge back from scroll to Ethereum.
00:18:35.860 - 00:19:40.358, Speaker C: And the roll up contract is something that stores the layer two state. So for example, it'll store the state roots, and it'll also be the way to prove the validity of the validity proof. And it's also a way for users from scroll to force exit. If they don't want to be a part of layer two and they want to force exit without their transaction going through layer two itself, then they can force exit through layer one. All of that happens through the Roll up contract. Can I go down to the next slide? On the left side, you see the sequencer. Okay, so the sequencer is a geth folk, which is basically the node, which as a user, you would interact with.
00:19:40.358 - 00:20:23.714, Speaker C: The sequencer is responsible for batching transactions and posting the transaction data to layer one. And it's also responsible for then. So think about this. The sequencer is a geth node. There are certain differences which we have added from geth, which are basically to suit what scroll needs. Let's say you have a scroll block, which is a layer two block. That block consists of a set of transactions, and each transaction is a set of opcodes which were executed in EVM, right? So you get an entire execution trace for that block.
00:20:23.714 - 00:21:15.506, Speaker C: So this execution trace would have everything, like all the opcodes which were executed and one by one. And this execution trace is then sent from the sequencer. The sequencer basically schedules the roller to generate a proof for this execution trace. And the roller is composed of a lot of components and we have a lot of subsurcuits. We have the EVM circuit, the state circuit, transaction circuit, ketchak circuit, bytecode circuit, and the roller is responsible for creating proofs for each of those circuits. So it goes through the trace, converts it into witness data for our ZKEVM circuits, and generates proofs for each of those circuits. And those set of proofs then go through another circuit, which is called the aggregation circuit.
00:21:15.506 - 00:22:27.130, Speaker C: And this circuit aggregates all those set of proofs into one single proof, which is the validity proof for that particular block. Once that proof reaches back to the sequencer, then it can publish that validity proof to layer one. And at that point in time, as a layer two user, you know that your transaction has been finalized from the perspective of layer one. So why are we taking this approach of building a Zke EVM based ZK roll up? The first and the most important benefit of our approach is that we don't want developers to spend time on moving to a different kind of infrastructure. We don't want them to spend more time on learning new things. We want scalability now, and which means we want developers to use whatever knowledge they have and implement DApps, which are probably not possible today on ethereum because of some scalability limitations. And we want them to move and migrate seamlessly to scroll and deploy their smart contracts.
00:22:27.130 - 00:23:14.838, Speaker C: The entire circuits and proving part is quite complex. There's a lot of cryptographic moving parts that are going on around there, but we've tried to encapsulate all of that away from a user who just wants to deploy their smart contract on scroll at the same time. EVM has been battle tested for a long time. There are many audit firms which are well versed with the EVM, and there's a lot of fuzzing techniques, a lot of testing infrastructure which is built around that. So we know that the EVM execution model is secure and we want to stick to it while providing scalability. So let's quickly go through where we are at the moment. We've already launched the pre Alpha Testnet.
00:23:14.838 - 00:24:35.314, Speaker C: On this testnet you can basically mint certain tokens, bridge them to scroll, and we have deployed a folk of Uniswap where you could swap ETH to USDC, USDCs to ETH and this pre alpha testnet already has the proving part live. So as soon as you do your transaction on layer two and there's a layer two block, then there's a validity proof which gets submitted to layer one which finalizes your transaction. Moving on, the next phase for us will be a more permissionless testnet where as a developer you can deploy your own smart contracts and the next part after that is proof outsourcing. So we want a decentralized prover network where as a public user you could simply join the prover network, plug in your gpus and start generating proofs which makes the prover network decentralized. And beyond that comes our main net. And then there are certain more things in our roadmap like decentralizing the sequencer itself, but that's down the line. So if you want to be a part of the pre alpha testnet and if you want to use it, see how the layer two experience feels like and you can go to signup, scroll, IO or scan this QR code and you can become a tester.
00:24:35.314 - 00:25:23.470, Speaker C: You could report certain UI issues or bugs if you notice, be a part of this community and I think it'll be a lot of fun. Next, if you want to build with us, if you want to integrate with us, if you want to build applications on top of our layer two solution, then you can reach out to us and we are here to help you and work with you. And lastly we are hiring. There are multiple open positions in the engineering department as well as other departments. Just reach out to us and we are happy to speak to you. Thank you. So if there are any questions, happy to take them.
00:25:29.620 - 00:25:48.580, Speaker D: Hi, sorry so loud. Thanks guys for coming. I think this is the first time I see this space. So know to the rafters with this. And I was going around just now to talk to people and many big brains in this room, right? Especially Rohit as well. Anyone has any questions for Rohit after the presentation?
00:25:53.580 - 00:25:54.612, Speaker C: Thanks for the presentation.
00:25:54.676 - 00:26:05.870, Speaker E: I got a question. You just mentioned that there's a method to bypass to trade race, send the data to the layer one. Is that something that I misheard or is that something you actually mentioned?
00:26:09.920 - 00:27:04.712, Speaker C: Okay, yeah. So actually it's a very important part of being able to call yourself a roll up, right? Because it provides you censorship resistance. So let's say I'm a layer two solution where you're not allowed to exit via layer one, then you are relying on me to include your transaction, right? And if I am in control of the sequencer and if I know your address. I can censor your transactions, which is something as a user you don't want. So because we post transaction data on layer one, then the contract is able to verify that, let's say you're trying to exit the layer two and you have, let's say a balance of 100. So the layer one contract is able to verify that you have a balance of 100 so you don't need to withdraw and exit through layer two. That's the basic solution.
00:27:04.712 - 00:27:18.948, Speaker C: You can do that. But in case you feel that your transaction is being censored, you can exit via layer one as well, which is a very important property for roll ups. There are certain projects which call themselves roll ups, but then they don't really exhibit this property.
00:27:19.034 - 00:27:21.460, Speaker E: So that's more like an escape hatch, is that what you're trying to say?
00:27:21.530 - 00:27:26.036, Speaker C: It's an emergency exit which provides you censorship resistance it.
00:27:26.058 - 00:27:27.190, Speaker E: Got it? Yeah, got it.
00:27:31.180 - 00:28:47.420, Speaker C: Thanks Rohit. So you mentioned about decentralizing the prover and sequencer, right? How do you plan to achieve decentralization for prover given that it requires special hardware? Yeah, so it looks something very similar to how proof of work used to be in Ethereum, right? You have your own gpus and you join the network and you start mining. So similarly you would join the network and start proving instead of mining. And the way we haven't yet figured out the algorithm for randomized scheduling, as of now we are just using something very simple like round robin method too, because in the pre alpha testnet, scroll itself is running like four prover networks, four prover nodes. So we are using a simple round robin method. But in the future when it's a decentralized prover network, then we'll use something more complicated like a randomized scheduling. So that given some sort of parameters which make you a good prover or a more powerful prover or something like that, in a randomized way, you would receive tasks from the sequencer to generate proofs.
00:28:47.580 - 00:28:47.904, Speaker E: Right?
00:28:47.942 - 00:29:38.050, Speaker C: I have three follow up question on that. Okay, so does you only need gpu? Secondly, but sequencer, could it use pos? And thirdly, does it mean that currently you are running centralized sequencer in the pre alpha testnet? Currently we run our own sequencer. We run our own provers. It's a centralized setup as of now for the pre alpha testnet. Our goal to reach a permissionless testnet is not to fix this part as of now because we want to support full EVM compatibility as well as smart contract deployment. So this part of decentralizing the prover and sequencer comes before the main net, so it's down the line after the testnet. Got it, thanks.
00:29:38.050 - 00:30:36.124, Speaker C: Sorry. So for the approver, yes, you need a gpu. You can't do it on a cpu, you need a gpu. In the future there could be some hardware developments where. So it's hard to come up with a very specialized hardware like an ASIC miner for this, because for ASIC miners, let's say bitcoin, you have ASIC miners, right? It's because they do the same computation so you can specialize the hardware for it. But let's say we have a live scroll network and then there are certain changes in the EVM, there's a new opcode which has been added and let's say we want to build a separate circuit for it. Then there has to be some change in the ZKVM architecture and to incorporate those changes you can't go and start building another specialized hardware for it.
00:30:36.124 - 00:31:01.400, Speaker C: So as of now, because GPU provides general purpose programmability and scalability, like parallel computation, then as of now, gpus are much more the right approach. In the future, that might change. If we have an approach which doesn't really change for two years or three years or something like that, people could consider building specialized hardware, but as of now it's gpus.
00:31:04.000 - 00:31:06.910, Speaker D: Any more questions? Guys, thank you.
00:31:11.040 - 00:31:23.200, Speaker F: How will you handle MeV at layer two? Will you split the role of sequencer with other actors, with some kind of PBS?
00:31:23.540 - 00:32:05.520, Speaker C: Okay, so with a centralized sequencer, handling MeV is not really something we can promise because it's a centralized sequencer, right. It has all the MEV. When we decentralize the network, it's still something that we are researching on. It's really in the introductory phase of research, but we are picking up some research work from the proposer builder separation model. And in case we want to decentralize, like when we decentralize the sequencer, we'll take inspiration from that research which is being done in the ethereum space as of now, because that's also to limit MEV.
00:32:06.660 - 00:32:20.820, Speaker F: What's your plan when you decentralize your sequencer? How many sequences are you looking at? And then how do you prevent the trade off of performance and latency when you have a decentralized sequencer?
00:32:21.160 - 00:33:04.784, Speaker C: So this is something we have not really dig deeper into as of now, because as of now we are trying to achieve full compatibility with Ethereum EVM, but it's something that a couple of our researchers are working on at the moment. And I don't have a very good answer as to what heuristics we are looking at and what sort of parameters we are looking at and what's the optimal sort of sequencer decentralization would look like. I don't have an exact answer for that because I'm not very well versed with that.
00:33:04.822 - 00:33:05.488, Speaker F: Final question.
00:33:05.574 - 00:33:06.210, Speaker C: Yeah.
00:33:07.480 - 00:33:19.190, Speaker F: When will you all release metrics like, what is your proof generation time? What is your proof size based on how many TPS? What's your verification of the l one?
00:33:20.700 - 00:34:04.624, Speaker C: Right now we have a pretty basic kind of proof generation algorithm, and it takes a little less than 1 million gas to verify on layer one. Like the proof to be verified on layer one, it takes less than 1 million gas. There are certain optimizations that we can do to make it more efficient so that the verification cost could go down, which is good for us proof generation time wise. Right now we are running Nvidia eight ns, and it takes around, I think around twelve minutes or something to generate proof for one block. It takes a long time, but we have certain optimization.
00:34:04.672 - 00:34:06.340, Speaker F: One block have how many transactions?
00:34:09.400 - 00:34:54.310, Speaker C: It doesn't matter a lot how many transactions, because the circuit size remains the same. So the proving time depends on the proving cost, or the proving time depends on how big your circuit is. So as long as we can fill that circuit with, let's say, one transaction or five transactions, or even 100 transactions, because the circuit size doesn't change, then the proving cost also doesn't change the proof size. The proof size depends on the number of columns we have in the circuit. So let's say I want to build a bigger circuit with more columns. Then the proof size becomes bigger, which also takes more time to, also takes more gas to verify. So the way we build our circuits is to optimize for this itself.
00:34:54.310 - 00:35:11.790, Speaker C: So I wouldn't use, let's say, 50 or 100 columns, if I can achieve that same sort of constraints using ten columns, so that I'm limiting the proof generation time as well. So, yeah, it.
00:35:20.240 - 00:35:21.950, Speaker D: Anyone else has any questions?
00:35:23.040 - 00:35:31.970, Speaker E: Okay, I noticed I mentioned that the proof size increases with more transactions. So I'm really curious, like, what proving systems are you guys using?
00:35:32.740 - 00:35:33.712, Speaker C: Can you repeat that?
00:35:33.766 - 00:35:37.860, Speaker D: What proving systems? Sorry, what proving system is scroll based on?
00:35:37.930 - 00:35:40.020, Speaker C: Oh, scroll uses halo two.
00:35:40.090 - 00:35:42.212, Speaker E: So that means there's some recursiveness going on over there.
00:35:42.266 - 00:35:55.720, Speaker C: Yeah. So Halo two scrolls ZKVM is based on halo two, and we've built our own aggregation circuit which makes use of recursive snarks.
00:35:56.380 - 00:36:00.824, Speaker E: Is it the EFS version of hello two? Or is it like the original Zcash version of hello two?
00:36:00.862 - 00:36:07.720, Speaker C: No, it's the PSE version of because we work in collaboration with the privacy scalable.
00:36:09.520 - 00:36:11.784, Speaker E: The one that uses KZG instead of like the bulletproof.
00:36:11.832 - 00:36:17.250, Speaker C: Yeah, so we use the polynomial commitment scheme, which is the carte polynomial commitment. Thank you.
00:36:22.820 - 00:37:03.350, Speaker D: Any more questions? Anyone from the back? Any questions there? Or the site? If not, I think. Thank you, Rohit. Thanks for the presentation. Thank you. So, yeah, before you leave your seats, I mean, those who just came in, there's some seats here if you want to fill them up, because I think there'll be a demonstration by Spartan Labs team after this. Just some introduction, right? My name is Derek and I head the research unit at Spartan Labs. Today we have here the Spartan Labs tech team as well, who are going to do a demonstration of how we can implement ZK into SBTs.
00:37:03.350 - 00:37:05.698, Speaker D: So Chin Hao and Yong Kang Yon.
00:37:05.734 - 00:37:06.894, Speaker E: Take it away once again.
00:37:06.932 - 00:37:09.440, Speaker D: There are seats here if you want to populate it.
00:37:15.250 - 00:37:15.998, Speaker C: Hi everyone.
00:37:16.084 - 00:38:20.030, Speaker E: So I'm Jin Hao and I lead all things tech in know. Our mission at Spartan has always been to help the best entrepreneurs and builders thrive in the space. And that also means inspiring builders such as yourself towards onboarding the next billion users into web3. So that also means that recently we have been pushing out thought leadership in the web3 space tech thought leadership. And one distinct trait of our work is that when we talk about ideas, we make sure that we come with actual working code, actual working demos, or actual working proof of concepts, right? We want to show and inspire all of you builders, entrepreneurs that some of this technology, like zero knowledge, is ready and things can be built on top of it. So if you look at the screen, we talk about things like NFT smart contract vesting. So over here, we apply the concept of token vesting, whether it's linear, exponential interval vesting, and we apply them onto NFTs.
00:38:20.030 - 00:39:04.750, Speaker E: There's a lot of other information on the article, so I encourage you to go and read it when you have time. Secondly, we also talk about sobound tokens. Can we go on to the construction? So we talk about sobound tokens as well. And we dive into what the vision of what sobound tokens look like to Spartans, the kind of composability that it allows in the web3 space. And we also talk about if we do the kind of naive implementations, the kind of issues that we can have, whether it's privacy related or we kind of push the computation on chain, and you have very high gas costs. So some of these things, if it's too naive, we can actually use them in production. So it's quite timely today that we have a builders focused event on zero knowledge.
00:39:04.750 - 00:39:52.350, Speaker E: Because the next few parts of our tech thought leadership is exactly that, applying zero knowledge onto sobound tokens so that we enable privacy enabled composability in the defi space. So we are actually two weeks away from pushing this out into public. So the demo that you're about to see is life to thank you all for coming here today. It's Friday night and you are spending a Friday night with us. So if there's any sponsor bugs and all that, please forgive us, all right? Okay, so I would like to give the airtime to Yongkang. Yongkang here is our resident ZK expert at Spartan, so he's going to show you a demo on applying zero knowledge onto swan tokens. Yong Kang.
00:39:52.870 - 00:40:42.894, Speaker G: Hi everyone, I'm Yongkang. So actually, this is a very trivial example of showing how we can apply zero knowledge to sobound token. So, as you guys might know, sobound token is a concept where you want to have some data about the user on chain, but you want to mask that if it's a sensitive information. And that's where zero knowledge is very, very important. So in this example, assume that it's an undercollaterized lending protocol that has ability to KYC users credit score and have them posted on chain. But as we know, we don't want credit score to be publicly viewable on chain because that can pose a lot of risk doxing and things like that. So for instance, that's why we will use the concept of zero knowledge to generate a proof.
00:40:42.894 - 00:40:52.310, Speaker G: And because everyone can easily verify the proof, you can verify if this user has above x amount of credit score.
00:40:52.890 - 00:41:38.210, Speaker H: Hi guys. Welcome to the zero knowledge sobound token min demo by Spartan Labs. So what this demo does is essentially show you how sobound token can be integrated with zero knowledge tech. So we start with connecting our wallets. So once your wallet is connected, you can go ahead and get some testnet Eve from the goalie faucet. Next, you can select a credit score. This is arbitrary representative of a protocol issuing credit score, but having ZK proof to mask the actual value of the credit score.
00:41:38.210 - 00:42:27.346, Speaker H: So after you select a credit score, you can go ahead and mint it, and the mint window will pop up. So once you accepted the minting, the minting will continue. But in this case, the credit score will be used to generate a proof. And this proof will be attached to your sobound token. Nobody else except for yourself know what the actual value of the credit score is. There is almost no way to deconstruct it. And you can view the details of your minted sobound token over here.
00:42:27.346 - 00:43:44.066, Speaker H: And if you would like to verify whether someone or address has sobound token that fulfills a certain criteria for in this case, where their credit score is above five, you can go ahead and input the address as here. In this case, Mike just minted sobound token, then I can verify that hey, my credit score does not have a value above five, even though the value is not known to the public. But if I were to use a different address that has minted with a credit score above five, then this will be a success indication. So to show these in action, I will now change my wallet. In this case, it's a fresh wallet and I'll meet with a credit score of twelve. And once this transaction is minted, you can see the different details on the sobound token as well. And right now, this is the address that I meet with the credit score above five.
00:43:44.066 - 00:44:11.834, Speaker H: It is almost impossible to find out what exactly is the data behind this, but anyone can verify and see that the address has a sobound token with a credit score above five. So in this context, it may be a very trivial example, but this can be used in other contexts like proving attribute about yourself without revealing what it is and potential are limitless. Thank you.
00:44:11.952 - 00:44:44.726, Speaker E: All right. Thank you for Yongkang, for the demo. Right? So as you can imagine, if we take this concept a bit further, there's a lot more composability that we can build into the web3 space. So I hope that inspires you. All right. Anyway, it's a live demo, so I think it's a bit stressed right now. Okay, so I guess I'm just kind of holding, hoddling everybody back from food, drinks and networking, right? So I'm just going to wrap up really quickly.
00:44:44.726 - 00:45:34.166, Speaker E: Just three things. First, if you're interested to hear more from us about the kind of these kind of thoughts that we have in the space and all, please follow us on Twitter and check out our newest website of Spartan Group. And secondly, if you have any interesting topics that you like to collaborate with us on, tech thought leadership, and if you just have any interesting pressing concerns in the space that you like to hear our opinions on, feel free to approach anyone here because you see a lot of people in spartan apparels that are spartan group team, just talk to us and suggest them to us. And finally, if you have interest in using any of our code, like you want to discuss with us about our open source code, you want to extend them, you want to use them. They are mit open source, so you can feel free to just use them. And if you'd like to geek out with any of our technical team, I'm going to introduce you to the spartan group technical team. Come and geek out with us.
00:45:34.166 - 00:45:46.694, Speaker E: All right, so that's Yong Kang. He just gave us the tech demo. Tristan, Dominic. Dominic's over there in a green shirt. It's from the tech team. Can gig out with us. And Tristan over there.
00:45:46.694 - 00:46:07.440, Speaker E: Tristan, can you raise your hand? The white shirt over there, he's raising his hand. So if you want to talk about anything tech related, zero knowledge with us, feel free to as well. All right, how are we going to wrap up? Someone wants to give a closing speech. Hey, Sean. Sorry, not prepared for this.
00:46:08.850 - 00:46:34.500, Speaker F: Yeah, I think, like what Jin Hao mentioned, we don't hold you guys up anymore, but just one last word. I think this is really the first ever builder networking event that we want to set for spartan group itself. Going forward, we will have more events happening within this compound or other event spaces itself. So do follow us on Twitter. Do follow us on any social media accounts, and yeah, hope to see you guys again. Thank you.
