00:00:26.100 - 00:01:14.984, Speaker A: High level design architecture of the ZkEv. Like different modules functions and then maybe like different circuits from both our team, like scroll and also as well as Polygon. Herman, like how do we design our ZKe vms so we can go like a bit longer time for today's session so that we can cover a little more details into that. But I was expect maybe still a very high level architecture designs for the ZKE events. And also by the way, I also uploaded the recordings for the day one, day two here. So you should have access to this notion page, which the link is provided in the calendar invite. So you will be able to open this link and then check out the schedules and as well as the recordings.
00:01:14.984 - 00:01:38.288, Speaker A: And then we're also collecting the slides very soon to share it here so you can have some early access if you want to review anything that you want to go over in the previous sessions. Okay, so with that probably we can get started. So today I'm going to present the scroll Zkevent designs first. And then after that, Carlos and Jordi.
00:01:38.304 - 00:01:51.310, Speaker B: Will talk about Kermit ZKVM design and some coke.
00:01:51.390 - 00:02:46.354, Speaker A: Welcome to today's sessions. So today I'm going to talk about scroll ZKVM designs. So before that, I think the first things I want to cover in the topics is what does the ZKEvM need to prove. So for those who may be not very familiar with the EVM Ethereum and how EVM works. So initially at the every timestamp t, so you will have a worst state with merkle purchase tree and then have a root of the state, which is the current snapshot of your worst state. And then at this time you receive a new transaction trying to either do some transfers from one account to another account, or call a smart contract to execute some bytecode. So what you're going to do is you're going to pass the worst date, the current worst state, and then the transaction into the Ethereum virtual machine.
00:02:46.354 - 00:03:30.898, Speaker A: So this is the runtime or the executor for the ethereum. So I'm going to process the transactions given the current world state, and then the output is that it ends up with a new war state at a t plus one with a new state root here. So this is the root prime. So if you look more into details like how EVM works internally. So inside the EVM, this is a virtual machine. So you have an executor that going to execute every opcode as a stack and memory. Those are transient storage that you're going to push and pop from the stack and then load and save certain things into the memory which were going to disappear after each execution.
00:03:30.898 - 00:04:43.190, Speaker A: And also you can access two external persistent storage. One is the bytecode database. So you're going to know which contract you're going to execute by loading the bytecode, the contract bytecode from the storage, and another is the storage which corresponding to this state tree here. So every time if you want to write anything persistent, it will also reflect some changes into this merkle trees and they will modify some paths and adding some more nodes here and then so on and so forth. So if you look into more into details during the execution, what we're going to happen is that you go iterate over through this bytecode defined inside the smart contract. You are first at a step like the error step, you're going to execute some bytecode and then you may be going to some loop inside your bytecode or you maybe also call some other, you may be called some other smart contract inside that. So end up like it's like after you execute EVM, given the transaction and a state route, you are resulting a unique, like the execution trace here which step by step iterates like each transaction.
00:04:43.190 - 00:05:56.158, Speaker A: Each of code are defined in a smart contract. So what the ZKE event is trying to do is taking the spec of the Ethereum virtual machine like defined in the yellow paper of the Ethereum and then taking all of specs of each opcode. How you're going to process certain things, how you're going to model the stack and memories, and then how to load certain information from the public input, from the transaction core data and from the storage. So you're taking that spec and then that ends up with the Zkevm. And then when you're trying to invoke the Zkevm to generate certain proof, what you're going to prove is that you will use the current world state route as the input data and then the transaction as like another part of the input data and passing to the ZKEvM, they're going to instantiate a ZKeVM proof instance. And what you're trying to prove for the Zkevm is trying to prove this execution trace is correct and it's unique here. It means like given this current world state and then the current transaction, like the transaction you're going to input to the ZKVM.
00:05:56.158 - 00:06:35.958, Speaker A: This is the valid execution trace you can execute by using the EVM spec. So to be more specific, so what does the ZkevM want to prove. Exactly. So first they want to prove that this execution trace is correct and unique. And then the second is that the global state can transit from the old route to the new route. So these are the two things like the most important things that Zkeven trying to prove. So how should we prove this correctness of these two things? So I listed here four things I think that would be important that they need to cover inside the DkVM.
00:06:35.958 - 00:07:26.890, Speaker A: The first is that the program executes the correct contract bytecode. That means you're not executing an arbitrary code, you're adding into the trace, into the witness. So executing the correct contract bytecode from the bytecode database, the contract database. And then second, the program can load the correct input data, including the transaction code data, state root, and then some block information like into the block header information. And then the third is that the execution of each opcode behaves exactly the same as the EVM spec wrote here. So all of the computation, like the arithmetic computation of each opcode, is executed correctly inside a circuit. And that could be only the case in the circuit unit constraint.
00:07:26.890 - 00:08:09.578, Speaker A: And also that also implies that the stack and memory operations like those are modeled correctly. And then those corner cases in the opcodes, one pole, different gas computation, like some hot and cold storage you're going to load. So all considered inside the circuit. And then there are things like different error cases need to be handled correctly. For example, sometimes if you run into the EVM range to certain error cases, is also a valid trace from execution perspective. So that means you also need to handle those error cases correctly inside the circuit. So for like you went into insufficient balance, you went into the out of gas arrow.
00:08:09.578 - 00:08:55.038, Speaker A: So those kind of arrow also need to have a corresponding state inside the ZKVM. And the fourth is that the storage reads, the write will update the root correctly. So that means that you can prove the state route transits from the old route and then to the new route by applying all of the storage reads and writes and they can update it correctly. Okay, so next I'm going to go through, that is first I'll talk about how we constrain the execution trace by starting from the scratch. That can be easy. We could go a little bit from easier cases and then to more advanced into more complicated cases. So we see how we can going to do that.
00:08:55.038 - 00:09:42.202, Speaker A: So initially, as we showed before, after you execute some transaction with the current state route, you end up with an execution trace. So then you can expand those execution trace and then fitting into a circuit like we call, like EVM circuit, which is the main processors that are going to process and approve that state. Like each opcode that's inside the execution trace is executed correctly inside the EVM circuit. So remember in the hello two or actually in the pew, it's also similar. You have a two dimensional matrix. They have different rows and different columns. So here the columns can be prefixed, but the rows is like you can allocate different rows for each step.
00:09:42.202 - 00:10:38.458, Speaker A: So you can think like we can allocate a slot inside the EVM circuit for each step you execute inside execution trace. So the difference is probably, I guess that inside the hello two we allow each step can contain multiple rows. Each step can access use the cells inside those multiple rows to constitute to row these constraints and then putting to the width into your step slot. And here the number of rows inside each step can vary depending on the actual opcodes executed. So for example in the push opcode it could be slightly easier to verify so that you have fewer rows. You need to allocate it for this slot. And then if you have the example for more complicated like add or multiply, those more complicated opcodes can end up with more rows inside a step inside each step slot.
00:10:38.458 - 00:11:38.130, Speaker A: So this can be depending on how many constraints and how many witness data you need to put into each associated with each opcode. By the way, if you have any questions like feel free to ask me, interrupt me, just unmute yourself. Or you can also put into a chat so that I can also address any questions you have. Okay, so if you're looking to more details into each slot, what constitutes has three sections inside each step slot. So first like the slot is that the first section is the staff context which you think of like it's a context register. It's going to keep certain information, for example stack pointers like program counter. Those kind of information is going to keep inside your stack context so that you can know what opcode you're going to execute and what step we are at.
00:11:38.130 - 00:12:42.562, Speaker A: And then second is the case switch. So here the case switch is an array of selectors, but here the selector is more like the advice selector so that it's not a fixed selector. If you think of like in the hello two columns, the selector usually to be a fixed column, but here the case switches like they are all configurable selectors. And then each selector can be only like each cell inside of this case switch can be only one or zero. So that once you turn on certain selectors it will assume the search action like of course specifics witness were put into certain values in a certain layout, and then it will also trigger turn down those constraints to constrain this opcode specific constraints as well. So that's why the search section will be opcode specific witness. Okay, so let's look at what we put into the step context registers.
00:12:42.562 - 00:13:23.138, Speaker A: So these are all the fields we put inside the staff context. So first we have adobe counter. So this is a global counter that we're going to use to count for how many stack memory and storage operations have did inside these transactions. Or if you have multiple transactions will be shared uniquely, growing across all of the transactions. So this is like a unique counter for all of the state operations you did any reads or writes to the stack memory and the storage will be increased. This RW counter for one and a second. This is core id, which is also a unique id to identify the current call.
00:13:23.138 - 00:14:19.640, Speaker A: So the reason we need to have this call id is because inside of one transaction, like when you execute one smart contract, potentially you can call other smart contract. So inside one transaction, you potentially can still have multiple call id. So this co id can help us to distinguish the stack of memory across different, multiple different calls inside your transaction, inside the one transaction executing trace. And the third is the co hash. Basically that's the current executed executing bytecode, the cohash of the current executed smart contract. And then the fourth is the program counter, the pc, and then the stack pointer, which means how many items you have inside your stack. And then the gas left is basically the gas that going to left inside your transactions if you go below zero.
00:14:19.640 - 00:15:02.766, Speaker A: If you don't have enough gas to execute the next subcode, then we'll end up within the auto gas arrow here. And then the next one is the memory wall size. So it means we need to count the current memory size. And then that's like the memory size is counted in terms of the number of EVM words, 256 bits. And so this can be used to help to calculate the gas cost when you expand the memory to a larger size. And then the last one is the reversible write counter. So this is actually a snapshot with the adobe counter that's going to use to revert the rights to the storage.
00:15:02.766 - 00:15:51.970, Speaker A: So what means when you call into another smart contract and it failed internally, then you need to revert the writing to inside like anything like it did within that range. Then you use this reversible write counter to revert the changes you write to the storage. Any question to this? Okay, I'll go. And then the second section is the case switch as I explained a little bit before. So it constitutes a bunch of binary selectors corresponding to all of the EVM opcodes and the arrow cases you have. And then you need to constrain that exactly. Only one selector is turned on, switched on.
00:15:51.970 - 00:16:44.606, Speaker A: That means you cannot execute constraint multiple opcodes or multiple arrows within each step. So in order to if you put into the constraint to that it's quite simple. So you first add a constraint for every selectors here to be like only one or zero and then you say all of them adds up to two one. So like only one is turned on. And then we actually did some optimizations by actually it's like fewer states than the number of opcodes exist inside the ECM virtual machines because we found like the certain opcodes they have very similar behavior. So that you can use one single logic inside a circuit to constrain different opcodes. So here I list like a few examples there could be like a little bit more inside the actual circuit.
00:16:44.606 - 00:18:25.838, Speaker A: So for example you can think the add and sub you can combine them into one single execution state. So on the left side so here is the opcodes and then the right side is the corresponding execution state name. So for example like add and sub you can just swap the operands sequence so that you can then turn into a subtract into addition and then the multiply division and the mod so they can be like a construct constitute with a simple same part of logic inside the constraints inside the step. So you just only need to differentiate like if you can use a simple gadget called like a times b plus c equals to d that's going to constitute for all of the cases for multiply division in the MoD and then similarly for the shift left and shift right you can also combine to one single state and then the sine division and the sine mod you can also combine them into one single executive state. And then there's some other example like the comparison can all compare put into one single executing state and a slot and then there's certain memory operations you can combine them into a single execution state. So each execution state will correspond it to a simple like a gadget that going to constraint them altogether. Okay so the last things that we're going to talk about is the opcode specific constraints the witness, the last sections.
00:18:25.838 - 00:19:16.770, Speaker A: So here inside these sections you're going to have like the. So those witness are very specific to each opcode going to use to prove the crack case of this specific opcode. So here for example for this add opcode examples so we can break down an EVM word into high and low which each one with 128 bit. So you can represent a even word into a high 128 bit and a low 128 bit. And then you basically want to prove like a plus b equal to c. And then you add like the two more cells to record the carries that are going to overflow by adding the low part and adding the high part. So you have like two auxiliary cells you allocated specific to this add opcode.
00:19:16.770 - 00:20:02.130, Speaker A: So the constraint is also fairly simple. So you're seeing when asset is turned on. So here you see there's a selector where we multiply all of the constraints that associated with this add op code. So see like a low plus below minus C low and minus carry zero times the two to 128 will be equal to zero and then a high plus b high plus carry zero which carry over from the low part. And the minus C high minus carry one times two to the 128 equal to zero. So basically you have two constraints here that is only specific to this add up code. I was going to constrain, the calculation of this add up code is done correctly.
00:20:02.130 - 00:21:16.618, Speaker A: So this is all you need to constrain that. And then for other opcodes, for example, let's say if we're going to the multiply, maybe you need more cells and you need more auxiliary cells to help you to prove like a multiply b equal to c when you mod two to the 256. So you have the additional cells but that will be going to only, and also you have other constraints but that will be all multiplied by this s more more selectors that's going to constrain for the multiplication related constraints. Okay, so this is a few things like you need to do inside the step. So what else you need to constrain inside the step because for the previous part those constraints are not enough to constrain all the behavior inside a step. So the first step is going to constraint that you need to constrain the context transition from the current step to the next step. So what does that mean that you need to constrain the program counter will increase correctly, the step pointer will behave things correctly, and then the gas left.
00:21:16.618 - 00:22:06.106, Speaker A: So into constraint the step context between the current step to the next step. What you're going to constrain is here is that for example when you do execute the ad inside this step. So in the next step the code hash will still remain the same because you are not calling another smart contract. And then the program contour will increase by one so like the pc prime will minus pc minus one will equal to zero. Then the stack pointer is going to stack pointer will be equals to SP plus one. That means actually because we use the stack pointer starting from 1024, we're just going to reversely. If you increase the stack pointer that means the stack is shrinked by size one.
00:22:06.106 - 00:22:49.382, Speaker A: So because inside the add up code you pop two elements from the stack and push one back. So the stack actually shrink by size one. So that the next step pointer will be equal to the stack pointer plus one. And then the gas left will actually equals to the gas. The next step, like gas left will be decreased by three from the current gas left here. And also you notice that this here we need to also multiply the s add here because the context transition will be also specific to every opcode you executed. So for different opcodes the step pointer may have different changes and also the gas cost for different opcodes will be different.
00:22:49.382 - 00:23:32.130, Speaker A: That's why you need to multiply the current selector for this opcode as well for those constraints for the context transition. Okay, the second step is we need to verify the opcode is actually read from the contract and correctly and execute that. That means that you cannot execute arbitrary opcode at current step. It must be given the current program counter and given the code hash you must execute the opcode add. You cannot execute the opcode multiply here. So this is the second thing to verify the opcode. So how we are going to do that is that we're going to introduce a lookup table.
00:23:32.130 - 00:23:34.546, Speaker A: We call it a bytecode lookup table.
00:23:34.738 - 00:23:37.366, Speaker B: So let's take a look at the.
00:23:37.388 - 00:24:15.534, Speaker A: Wood inside this bytecode lookup table. Your first column you have the code hash, and second you have a tag which indicates whether this row will be the lens or the actual byte from your bytecode. And then there's an index to differentiate the different index inside your smart contract. And then the value will be the actual value that you have inside or the lens here. And then there's one more column. It's called is opcode. So that indicates whether it's an opcode or it's the data that you're going to push.
00:24:15.534 - 00:24:52.074, Speaker A: Let's say push one so that then you push one byte into your stack. So the next byte will become a data you're going to push to that. So this is opcode that's going to indicate whether it's an opcode or not. So we're going to load. For example, let's see, we have two smart contract here with different code hash. So for the first, a few rows will be corresponding to the first smart contract, and the second part will be like another smart contract here. So you're going to load all of the contracts that are executed inside of one transaction or inside of one block or a batch of blocks.
00:24:52.074 - 00:25:39.082, Speaker A: So all need to be loaded into these tables. So if you given like you have this table, that means let's assume this table is a ground truth so that it's correctly loaded inside this table. After that, then you can putting back the event circuit. So what is going to do? Constraint that opcode is executed correctly is by doing a lookup given the code hash, the current program counter, and then the current execution state you're going to execute. So you're going to find the correct entries here. So basically you look up a tuple into your lookup table by adding like co hash inside the context register, the byte, it indicates like we are loading the byte, not the lens. And then the program counter the current opcode you're executing.
00:25:39.082 - 00:25:55.460, Speaker A: And then the one it means like we're executing an opcode, not a data here. So basically you can look into that. And if you find a match inside a bytecode lookup table, that means you are executing the correct opcode at the current step. Any questions so far?
00:25:57.190 - 00:26:04.646, Speaker C: So in this case, the address of the contract that's executing does not matter at all. It's only that the hash of the.
00:26:04.668 - 00:26:06.600, Speaker B: Bytecode of that contract, right?
00:26:07.050 - 00:26:22.154, Speaker A: Yeah, that's a very good question. Yeah. So at the current step. Yes, that's correct. We only need to care about the code hash here. So in fact there's like one more step I haven't added here. It's like before you're executing the transactions, there will be a step zero.
00:26:22.154 - 00:27:08.942, Speaker A: I'm going to initialize, say like I'm executing an address. Like this is the Callie address. And then you're going to see inside of this Callie address, I'm going to some constraint that asserts that the co hash is actually loaded from that account object corresponding to the colleague address. Okay, so if there's no more questions, like I will then continue. Okay, the third things you need to constrain inside the step is that you're going to handle the stack memory and storage operations correctly. So this is like more complicated cases here. But the approach is quite similar to when you're constraining the bytecode.
00:27:08.942 - 00:27:54.094, Speaker A: The opcode is correctly is that you introduce another lookup table. So here we call the RW lookup table for all the read and writes you happen inside the execution. So this is like what the RW lookup table looks like here. So first in the first column, as we say, this is RW counter, which already see that inside the step register, step context here. So it is like a unique counter for every operations. So this means it's grow like by one each time. So although I'm not sorting by the other counter here, basically if you sort that it will be c, like this should be one, two, c, four, up to all of operations you have inside the execution trace.
00:27:54.094 - 00:28:29.006, Speaker A: And then second is attack. So they're going to indicate whether it's a stack operations, memory operations, or account operations or account storage. You're going to read and write for the stack and memory. You're going to differentiate them by the co id, as I mentioned before. But in the multiple different calls you can use the same address, but they will be corresponding to the different values. And then the address will be like the similar things. And for the transactions, sorry, for the account things like you are going to have the transaction id to differentiate what's the initial value.
00:28:29.006 - 00:29:04.474, Speaker A: Because before you execute one transactions, you're not going to permanently write those into the storage as they could be reverted in the future. When you indicate the transaction id, that means you know what's the initial value you have inside the storage. And then the next column will be address. So for the address in the stack, it'll be like just a stack pointer. So the maximum value would be 1023. Actually, if it's 1024, that means the stack is empty. So the first element you can write into the stack is 1023.
00:29:04.474 - 00:29:36.994, Speaker A: And then the next element you can write into is like 1022, so on and so forth. And then for the memory, it's like a memory address you have. It's similar to the definition. It's like a byte addressable memory address here. And then for the account, you have this account address here for that, and then for the storage part it's a little bit more complicated. So for each address you actually have a few tag associated with that. It can be nouns, the balance, the co hash, like I remove some of the things because of space.
00:29:36.994 - 00:30:13.310, Speaker A: So there could be like the co hash and then the storage root, they all can be read from, associated with this account here. And then for the account storage, then it'll be a little bit more complicated. You have a storage key, which is 256 bits value you have and then so that you break down into two part, like the key high and the key low. So each will represent for 128 bits they're going to use for the storage key column. Actually that's two columns. And then the next column will be a reader write. So indicates whether this is a read operations or it's a write operations.
00:30:13.310 - 00:30:57.066, Speaker A: And then the last part will be the value here. So the value for the stack and the storage value, it could be 256 bits. So you need to break down into a high and low representation for that. And for the memory, actually it's a byte here you're going to put into the associated with a memory. So this is like what you have inside lookup tables. So if you look into that, each row here inside Ada lookout table correspond to a stack memory or storage read and write operations. And then, so after we have this, say, like if say we trust this table is construct correctly.
00:30:57.066 - 00:31:54.282, Speaker A: So that means like inside the EVM circuit, if we find a matching record inside the other table, then we can assume that the stack memory and storage operations are done correctly inside the EVM circuit. So let's simplify this other lookup table a little bit and then just illustrate here how we did inside the EVM circuit. So basically you're going to do a lookup, say I have this current stack pointer and then the current value. And basically you're going to see I do a lookup and then I find a map which pop the word a from the stack at the 1022 stack pointer. That means I pop up the correct stack value from the stack. And similarly, after we did the calculation here, we calculate the a Plus B will be into the c word. Then I'm going to use the stack pointer and then you can add actually some operations.
00:31:54.282 - 00:32:30.060, Speaker A: You can see like I push the word c into the stack pointer as an SP plus one. So assuming the SP initially is equal to 1022, and then you can see like I do a lookup with the word c and then at the stack pointer at the address of SP plus one from this register. And then it's a write operation here. So basically you say I did a writing to the stack and then that going to also match to a record inside your adaptive lookup table. Any question for this part?
00:32:31.410 - 00:32:37.470, Speaker B: Yeah, I have a question. So how do you build this lookup table?
00:32:38.930 - 00:32:40.922, Speaker A: How do I prove this lookup table?
00:32:41.066 - 00:32:50.930, Speaker B: How do you build it? So you get some traces and you translate those traces to the lookup table and then you verify those traces based on the lookup table.
00:32:51.990 - 00:33:53.910, Speaker A: Yeah, that's a good question. So how do we build this lookup table? It's basically actually when you're executing the executing trace. So our executor is a fork of the gosm. So inside the GOECM you have a debug trace module, basically going to do like the record, a lot of things, including the current opcode are executing and then the stack you are going to do. So we're going to basically the first step when we fitting into the witness, into this Zkevm circuit. So you're going to parse the executing trace from the debug transaction inside the gosm, and then you're going to parse them into each opcode, what operation it does into the stack of memory or storage, and it will create a records and they're going to match to a row here inside the rwlockup table. So that's how we like when you pass the execution trace from goy Sam, you can basically create those records and fit into the rwlockup table.
00:33:55.770 - 00:34:01.100, Speaker B: Okay, cool. Okay, any other questions?
00:34:02.350 - 00:34:07.434, Speaker C: Yeah, how did you prove that this table is exhaustive? I mean, there is no way to.
00:34:07.472 - 00:34:12.410, Speaker B: Basically create an opcode that bypasses those rules.
00:34:13.150 - 00:34:58.986, Speaker A: Yeah, I think that's a very good question. First of all, the next step I'm going to say how we constrain those lookup tables as those lookups are constrained by us. So if you're taking example here for the other lookup table, I just briefly answer your question and then we can talk a little bit more. When I finish the constraint, the lookup tables, you can think the zkeram here also does some part of the constraint into the lookout tables. For example, it constrained that if you want to pass the check for your proof. So it means like the writing to the stack here. Actually the word c has some relationship between the word a and b with the word c.
00:34:58.986 - 00:35:19.730, Speaker A: That means you need to add these two words and then write back to the word c here. So the EVM circuit does some of the relationship between different read and writes. So that means if you don't find a match, it can be either wrong inside the eVM circuit or could be something wrong inside the other lookup tables.
00:35:20.870 - 00:35:24.900, Speaker B: That means, sorry, go on, go.
00:35:26.390 - 00:35:54.442, Speaker A: Okay. Yeah, and also like the stack pointer here. So if you add a different address, like I say, I modified the word c here in the adobe cap table, then that means the event circuit is not going to find a match inside the ada lookup table. Then it means like the proof is failed. Or like if you modify the address here, then inside event circuit. When you do lookup, it has to be the current stack pointer plus one. When you do the lookup.
00:35:54.442 - 00:36:49.950, Speaker A: So if we modify this, it's not going to find a match here. So that means the EVM circuit alone adds some constraint into the lookup table as well. And then another thing, additional things that we're going to do, is we're going to also add extra constraint onto the lookup tables, because these are not fixed columns. So these are all advised columns, which means you're feeling like themselves by the approvers. We also need to add certain constraint to constraint that the lookup tables cannot be constrained arbitrarily. And then one last thing we're going to do is, since we have the global counter, we are going to check all of the rows you have inside the other table has been covered by the lookup inside the event circuit. That means you cannot have an additional rows here inside the other lookup table that is not queried by the EVM circuit.
00:36:49.950 - 00:37:23.050, Speaker A: So, we think by combining all of these constraints, you can prove that the other lookup table. You cannot have another way to build the rwcup table, although you can definitely can change the sequence of the rows. Those should be like the. No, actually, this constraint. Actually constraint. The sorting of those rows inside the constraint associated with this rwcup table. So, actually, you can prove, like, this is the only way you can build this blockup table.
00:37:23.050 - 00:37:27.180, Speaker A: Does that answer your question?
00:37:29.070 - 00:37:30.314, Speaker C: Yeah, more or less.
00:37:30.352 - 00:37:30.858, Speaker B: Thank you.
00:37:30.944 - 00:37:35.180, Speaker C: I need to go back to it, I think, just a bit more about it.
00:37:35.970 - 00:38:02.440, Speaker A: Yeah, I think this is, like, a very tricky part, I think, when constraining the ZKVM. So there's a lot of different relationships between different circuits. And then are this, like, a constraint sound enough to cover to prove that those lookup tables can be uniquely constructed and cannot be put into any invited records inside that.
00:38:04.570 - 00:38:05.800, Speaker B: Sure. Thank you.
00:38:07.050 - 00:38:40.254, Speaker A: Okay, so let's just jump into the next section. We already say like that because those lookup tables are constructed by the proverb. So we need to constrain those lookup tables cannot be constrained arbitrary. So let's think back to take a bico table as an example. So what assumption. When we do the lookup into the bicode tables, we make certain assumptions that the bicode table is constructed correctly. So the first thing is the bytes loaded into table are the same as the bytes, like, stored in the smart contract.
00:38:40.254 - 00:39:42.710, Speaker A: And the second is like, this is opcode is correctly indicates whether a byte is an opcode and then opcode or not. So let's take back this bytecode table examples. So we want to prove, like, this table is constructed correctly, cannot be like do something wrong. So what you're going to do is you're going to add additional advice columns that are going to help you to prove this lookup table is correctly constructed. So basically turning into a lookup table into a Bico circuit by adding like a few additional auxiliary advice columns are going to help you to prove that. So what prove we're going to do? For example, let's say we need to prove the code size is correct. So basically you need to have a reverse index inside the lens for all of the bytes here and approve like the number of rows you have for the byte is the same as you write into your lens row here for this bytecode.
00:39:42.710 - 00:40:19.860, Speaker A: And then second, we want to prove that it's opcode as construct correctly. So firstly, just say when this opcode is a push opcode, then we have an additional column called a push r index. It's meaning like how many bytes left going to have for the next few rows will be the data. Like it's non opcode, it's actually the data. So you're going to first constrain this push index is set correctly of corresponding to like it's push one. Then this value will equal to one. If it's push 32, then this value will be 32.
00:40:19.860 - 00:41:02.720, Speaker A: And then given like you have this push I index column here, then you're seeing like this is all quotient has to be zero. If the previous row inside the push I index is not zero, then you can construct, you can say like this is correctly proved, like this row should be not an opcode. And then also into constraint like this push I index, the reverse index is reduced by one. If it's nonzero here. If the previous row is non zero, then the previous row minus the current row will be equals to one. Or if it's zero, then it can be always zero. Like copy along.
00:41:02.720 - 00:41:50.922, Speaker A: Okay, so with these reconstraint combined together, then we prove this opcode column is constructed correctly. And then how do we constrain the last pieces? We need to prove this bycode table is when to constrain the co hash. So this will be a little bit more complicated. So we're going to have another lookup table to help us prove that. And here inside our Zkevm, like the designs, we also replace this co hash into the from catch to poseidon so that it can reduce a lot of overhead you have with the catch. Because catch is really complicated when you're writing to the Zk circuits. If you have everything to construct to build inside the user cache circuit, it becomes a bottleneck to the whole ZK.
00:41:50.922 - 00:42:35.806, Speaker A: So actually replace that with the poseidon hash table. Poseidon hash. So basically you're going to do like you construct Poseidon hash tables and then you're going to break down into the trunks and then do the lookup to that. So each row will do like you taking two inputs and then the hash is not the current output, it's the final output that match with the final output. And then you have indicator like how many bytes left inside that and here, because each value here is a byte. But for us the value can be up to 254 bits. So we're combining actually multiple bytes here and then do a lookup into the value one and then the next I feel like, and then matching to the next value like value two.
00:42:35.806 - 00:43:17.580, Speaker A: And then the hashes indicate it's matching with one certain hash here. And then the bytes left is meaning like how many bytes you're going to do like the hash inside the Poseidon lookup table. So basically you do a lot of lookups into the poseidon hash until you prove that, until you finish up to the zero ones. And then that means you put all of those things into the bico hash, sorry, into the Poseidon hash tables. Then you can prove this hash is actually correctly calculated from all of those values, bytes you listed here associated with this contract here.
00:43:19.870 - 00:43:20.394, Speaker B: And then.
00:43:20.432 - 00:43:48.120, Speaker A: So for this Poseidon hash tables, you also need to add additional columns later to constrain that this hash are actually calculated correctly by using apply all of the value you have inside your Poseidon hash circuit. So basically there's some additional columns here to help you to prove the Poseidon hash is calculated correctly. Any questions so far for this step?
00:43:50.010 - 00:43:58.470, Speaker C: Can you explain why I don't get, what is the point of input one and input two? Is this just to have more amounts hashed per row?
00:43:59.290 - 00:44:21.280, Speaker A: So this is actually the definition of the Poseidon hashes. You can take in multiple inputs and then apply that. It can be like two to one hash or like, it can be like 41, like 81. So we're choosing like two to one. Like taking two inputs once and then update the hash. And then next time you can squeeze in another two inputs here.
00:44:24.290 - 00:44:30.500, Speaker C: So are you like hashing all of the bytecode or only parts of it?
00:44:33.190 - 00:45:01.654, Speaker A: Actually this hash will be, there'll be some accumulating hash like this, like the current hash, there'll be some state stored inside that. But this hash here is only to help you to address corresponding to the output here. So it's the final output hash. So that doesn't mean this hash is equal to, when you're hashing two value equal to this hash, but it is like a unique identifier for a bunch of hash happens associated with a single hash block.
00:45:01.702 - 00:45:02.442, Speaker B: You can see.
00:45:02.576 - 00:45:09.118, Speaker C: So then there should be another constraint that checks that all of those hashes are the same as the accumulated one at the end.
00:45:09.284 - 00:45:31.830, Speaker A: Yes. So you see, like, for example, these rows could be all the same, and then there's accumulated hash, and then you're constraining at the last step. It'll be like the same in the bottom. So I make sure the hashed here is calculated correctly. And then for this part, if the best life is not zero, then it should be equal to the previous row.
00:45:33.370 - 00:45:34.680, Speaker B: All right, thank you.
00:45:42.580 - 00:46:38.284, Speaker A: Okay, so let's also jump into the other table, which address a little bit of problem. So adapt table is actually more complicated than the bytecode that's we made, like the multiple assumptions, I think, to the other table here. I think there's three assumptions we made. So, first of, remember, when we do look up for the event circuit, we just only assume that all the values are pushed and then write and read correctly into a certain records inside adobe table. But we assume, like, we make assumptions that the values that we read from an address is actually the same as the previous value you wrote into this address. So that is, we only assume like there are single records here inside the adobe table, but we didn't assume the kind of the continuity inside the adavit table. So this is like one assumption you need to check for this adobe table.
00:46:38.284 - 00:47:32.580, Speaker A: Then second thing is like, when we expand the EVM memory into a larger size, the memory will be all initialized to zero like that. So that means if you want to read to a memory like the first time, you should be always read to the zero. And then the third thing assumption we made is like, the initial value read from the storage slot is correctly loaded from the global state tree. That means this is like some assumption, like, you won't be checked from the event circuit side. So event circuit side is like after you read certain value into the memory or into the stack, then you do some calculations, and then you write back to the stack or memory authority. So it just only proves the relationship between a transition from the current read and then the next write. But it doesn't like some initial value, it doesn't constrain inside the EVM circuit.
00:47:32.580 - 00:48:28.192, Speaker A: So let's bring back the adobe table, which is also a little bit simplified so that's be easier to just illustrate, but actually circuit will be more complicated. So the first one, when you create this RW lookup tables, basically this is the records you're parsing. When you parse from your goy same execution trace, you're getting like a record, say like I do some of the write the stack and read something or write something to the memory. And then you have a bunch of records. When you're passing through your execution trace. This is like the trace records you have. And then the first thing when we fitting into the RW circuit or RW lookup tables, you're going to sort it them by a certain rules.
00:48:28.192 - 00:49:09.008, Speaker A: For example, we want to sort first by different tags, by different sections. If we say all the stack, all the memory, all the search will be sorted into different sections. And the second thing you want to sort is like sorting the address. And then the third thing is sorted by sorting the RW counter here. That means then you can prove that the value you read is the same as the previous write here value. When you sorting those rows, it's just going to help you to prove this read after write property from those other lookup tables. And remember that because we are using the lookup argument.
00:49:09.008 - 00:50:01.350, Speaker A: So the order inside the lookup tables or inside the circuit, it doesn't matter, it just only see like if I can find a matching records inside the table, they can be like in the first row, it can be like under 100 rows, it doesn't matter. It doesn't need to say like I find a record, I'm action record inside the lookup table. So after you sorting that, then you can constrain this read after write property is that if the current is a read operations, that means that the value you read should be the same as the previous rows. This also makes simplify a little bit. It means it's not the first row for this address. If it's the first row, then have like a separate logic. So for example, for the memory, the first row, if it's a read, then it has to be the zero.
00:50:01.350 - 00:50:37.696, Speaker A: The memory is correctly initialized to the zero. But for the stack, if the first row is zero, then it means like it's an invalid trace. You need to say like the first row to the stack. It must be a right because you cannot pop from a current one stack address without pushing a value previously to this stack address. There are certain constraints associated with the first row inside each address. And also the next things they're going to check is like the certain columns are valid. For example the RW can be only one or zero.
00:50:37.696 - 00:51:23.016, Speaker A: The tag here can be only like certain tags. Like stack memory storage can be like only certain tags. And also when it's a stack, the address can be only like amount zero to 1024. You do a range check if tag is zero, if tag is stack, and then the last things you're going to constrain is like if the sorting is done correctly. Because when we constrain this read author writes property we rely on, all the rows are sorted correctly. So you also need to constrain that all the rows are sorted according to the lexical graphic order that you define. With this tuple here, that means like tag need to be less equal to tag.
00:51:23.016 - 00:52:20.424, Speaker A: Next, if they are same, then the address has certain property. If address are same, then adapt counter need to be strictly smaller than the next group. So with these things then you can constrain those things. And also, I forgot to mention, if it's a storage, if it's an initial read, then you need to also do a lookup into the Merko Patricia sheet table called MPT table. They're going to look into the MPT table. They're going to constrain that this is actually the correct value you read from at a certain snapshot of your state tree. Okay, so any questions up to this point? Okay, if not the next section, I'm going to talk about how we constrain the input here.
00:52:20.424 - 00:53:06.900, Speaker A: So previously we all talk about constraint, the tables, the EVM executions, but we didn't say how we load those input correctly from the public input. So this is, I think almost like the last part I'm going to cover inside this talk. So first of all, I'm going to talk about what's the public input we're going to put into the l one smart contract. So we're going to put like, actually, I think I forgot to add one thing. The data we roll up is the old route, the new route, the block header, and all of the transaction data. But for the transaction data, for each transaction you're not going to put everything into the catch check and then use the final hash result as input. So basically you first do the catch on the transactions.
00:53:06.900 - 00:53:30.640, Speaker A: You can calculate the transaction hash for all of transactions inside this batch. And then you can hash them like all with different transaction zero, transaction hash one. And then you calculate all of the transaction hash and then you concatenate them together and then do a big catch up here. So using this final public input as the catch, as the results.
00:53:32.900 - 00:53:33.890, Speaker B: And then.
00:53:34.260 - 00:54:10.476, Speaker A: Inside the ZKM circuit. So we have like a special circuit called a pop input circuit. They're going to import this pop input hash and verify. So first you're going to do is verify the catcher hash is done correctly. And the second, you also need to expand this like the backing to those fields and then provide those inputs to the block header, block tables and then transaction tables. You can provide the block headers and some other information and then new route and then the transaction hashes. So let me show you what this public infosec looks like.
00:54:10.476 - 00:54:52.312, Speaker A: It'll be like one instance column. That's basically the public input you have. So using the catch a hash, so it's 256 bits, you have hash high and hash low, two elements here. And then the next column will be like all the values you're going to use to hash those hash to derive this hash output. So you have like O root uroot, the block headers and all of transaction hash. And then what you're going to do is in the public circuit you're going to basically hash those values. So here, actually I simplify a lot of things because when you do the lookup in the catchack table or catch up circuit, you also need to expand them into the bytes.
00:54:52.312 - 00:55:42.596, Speaker A: So here we're assuming like these are the direct values, but actually when you do the hash you need to break down into the bytes. So it'll be like additional advice column here will be the expansion of those values into the bytes. And then you use the bytes like the array to look up into the catch table so that you can prove this hash is calculated correctly. So actually the public input is derived from, by hashing these values here. So for the block things, it will be simply quite simple. You basically do some permutation check, copy those values into a block lookup tables. I'm going to construct a small block lookup table and then those block lookup tables can be then used by the EVM circuit when you're trying to load certain information from your block.
00:55:42.596 - 00:56:42.812, Speaker A: So if you want to load block hash or you want to load timestamp or those numbers, it can be provided by this block header here. But for the transaction it will be a little bit more complicated because we make like we only include a transaction hash here, so we need to expand them into more like the detailed transaction data. So I'm going to have this transaction table and the circuit. So first thing to do within the transaction table is that we can copy this transaction hash from the pop input circuit. So this is like what a transaction table looks like the transaction you have four columns. First column will be the transaction id, and then second, you have a certain tax. So you have the nouns inside this transaction, the gas cost, and then some other things like the gas tips or other data you have from your transaction when you're encoding your transaction, and also along with the signatures.
00:56:42.812 - 00:57:23.192, Speaker A: And then these two are actually the additional things that is not including inside of your transaction data, but transaction signature hash and transaction hash. And then the last part. And then second, you're going to first load certain, like the transaction header here. And then the last part will be the transaction actual transaction core data, which you're going to differentiate them by using the index column here. If it's the first transaction, the call data, what is the first byte of the inside? The first transaction is called data. So basically then you need to build a relationship between the pop info circuit to your TX table. Basically you need to do a permutation check, like a copy constraint.
00:57:23.192 - 00:58:07.320, Speaker A: Say like this transaction hash. Sorry, it's not this one. It should be this cells because this cell is the actual value. Basically you copy the transaction hash into this cell here it is imported from the popping input circuit. Then the second thing is here we only import the transaction hash you have from the pop input circuit. Now we need to prove the next thing you need to prove from the transaction table to the transaction circuit. I need to prove the transaction hash is actually calculated by using all the fields you have inside your transaction table from this part.
00:58:07.320 - 00:58:58.792, Speaker A: Basically, and you say after I do the RP encoding of this part of data and I do a catch hash, it'll actually derive this hash value here so that I can be sure that this value I put here is a correct value you have inside the transactions. So that's why the next step for the transaction circuit is you need to connect to an RP table. That's going to help you to verify the RP encoding of the transactions and then the transaction hash. So now we have another additional table here, or the table of circuit. So you have a type is like all you can do for this RRP encoding is you're going to encode for the transaction hash. So first of all you have the id. Basically this is the transaction id corresponding to the same transaction id.
00:58:58.792 - 00:59:48.644, Speaker A: And then you have this specific RP tag that going to say if this is like a prefix, going to encode some of the lens of your RP lens. And then certain part will be like tx nouns, the next part will be txnounce. So basically you have some auxiliary data here for RP tag encoding. And then the next column will be the bytes, like every row will be a byte. But what you have here inside your TX table is the value, which is by combining the multiple bytes here into consider the value. That's why here you have an accumulated value by accumulating multiple rows of bytes into a single value here. So that the TX table can do lookup into the RP table to prove that actually this is encoded correctly from this RP table and the RP table.
00:59:48.644 - 01:00:57.184, Speaker A: Definitely we're going to add other constraints to constraint that this RP encoding are. Follow the RP encoding rules to do that. And then another thing RP table is going to do is you are going to take all of the bytes, you expand it from the RP encoding, and I do a lookup into the catch table to prove that this transaction hash final row here is actually the correct hash results. And then you can then connect them from the TX table into your RP table, saying that, okay, now I need to connect this connection, one nouns tag, and then with the nouns value into this row, which we have here. It's like the accumulated value of those different few bytes which constitutes this nouns here you have, and then for the rest of things you also need to do, it's the similar things. And also, don't forget that we also need to constrain all of the byte. All of the core data bytes are also appeared correctly inside the RP table here.
01:00:57.184 - 01:01:57.176, Speaker A: And then finally, then you can say this transaction hash by looking up, like into this RP table, you find the matching hash here. So that's why we can know that the transaction hash is actually correctly derived by hashing those values you have from all of these fields you have inside a transaction table. Any question in this part? Yeah, this is a little bit complicated, but I think I'll just move on. So the first things you need to verify inside the transaction circuit is actually the signature is calculated correctly inside the transaction. So you're going to verify the transaction sick. Hash the signature hash, and then you actually need to verify the signature derived correctly. That means that we also need to introduce one more section inside the RP encoding.
01:01:57.288 - 01:02:00.690, Speaker B: So let me explain a little bit.
01:02:01.620 - 01:02:32.616, Speaker A: How you calculate the hash here if you're not familiar with the EVM. So basically you're going to do RP encoding on all of a part without the signature part. You need to encode all of the value here and then the core data value here. And then you do RP encoding, and then you calculate a catch, a cache of all of the bytes you have inside RP encoding here and then use that to sign, and then you can get the signature vrs here. That means similarly is that we need.
01:02:32.638 - 01:02:36.200, Speaker B: To copy, like to check the value.
01:02:36.350 - 01:04:01.312, Speaker A: You need to expand those encoding of this signature part of RP encoding here by having those values copying to this part of the signature hash part and also copy the core data here. Actually not copy, actually this is lookup into here. And then finally inside the RP encoding table, you can look up into the catch up, and then you can check whether the hash, the tx six hash is constructed correctly by applying all of RP encoded bytes here. So the next thing inside RP table is you also need to have all of those bytes and then do a lookup into the catchack and then do a output check, the hashes calculated correctly. And then the last part is that given you already proved the transaction sick hash is calculated correctly and then you have all the signature you have. So you basically need to do a lookup into the VRS and a hash and you can do a recover your caller address so that you can make sure that this is actually invoked by a certain caller. Actually there will be additional entry inside your TX table, which is the caller address that is not going to participate inside all of your TX transaction RP encodings.
01:04:01.312 - 01:05:11.912, Speaker A: That's like some additional data we can have inside the TX table, but we also need to constrain that the caller address is correctly calculated by using the ECGSC things to recover the caller address. Okay, yeah, so any question up to this part? Okay, so if there's no more question, like I will move on to the final last piece. Let's say we're putting all of the things like we mentioned previously, putting all of them together, and then we'll have to show you what's the ZKe event architecture we have from the school side. So first of all, in the beginning we have the event circuit as I described previously. Sorry, there's one question from the chat. Do you support multiple transaction types? Yes. So we're going to support multiple transaction types, but right now in the circuit we're only having DARP encoding for the legacy transaction type.
01:05:11.912 - 01:05:57.198, Speaker A: We're going to adding like to support this dynamic fee EIP 1559 transaction type. So we're going to support all different transaction types. Okay, let's take a look at the ZK event architecture. So first of all, you have the event circuit that's going to constrain your step states and some basic opcodes. I say like add you can directly constrain that inside your step slot and also need to constrain the transaction from the current step to the next step. And all of the stack read and write operations. Then there are certain opcodes that not going to be ZK friendly.
01:05:57.198 - 01:06:38.638, Speaker A: So for example those are bitwise opcodes, the end all things. So that's going to do is this is the fixed lookup tables. You basically pre compile some of the possibility for doing the and all and XR opcode and you encode them into lookup tables. So when you trying to constrain inside even circuit can just do lookup into those fixed lookup table. And the second there are some complicated offcodes. You're going to also offload to some size circuit here, a lookup table here for the exponential and then the cat check. So these two will be also offloaded.
01:06:38.638 - 01:06:54.642, Speaker A: So it's too complicated if you include everything inside the EVM circuit here. So you're basically relying on opcodes and having some other circuit to constrain those lookup tables here. And then you want to handle the stack memory and storage operations.
01:06:54.706 - 01:06:57.446, Speaker B: You have the adapt lookup table and.
01:06:57.468 - 01:07:35.122, Speaker A: Then you also need to constrain like when inside the evm you want to load certain things like from the bytecode, from the transaction call data and the front of block information. So you have like three additional lookup tables. You have to load from that. Now we need to constrain the lookup tables. For example the exponential lookup table, you have exponential circuit to constrain the value here is correct. And then for the RW lookup table you have the state circuit or RW circuit to constrain here. But RW circuit, as we mentioned before, we need to look up into this MPT lookup table to constrain the first read.
01:07:35.122 - 01:08:24.690, Speaker A: And then the right will be updating your state route here, your Merkle Patricia tree correctly. So you also need to do a lookup into a Merko Patricia tree table. And then, so you have like a merchant tree circuit to constrain this lookup tables. And then we also modify a little bit of the existing EVM state tree. We change into a sparse binary moko projector tree and then with the poseidon hash. So going to reduce some overhead by using all of them in catch up. So that's why the Merko projection tree circuit need to constrain this lookout table by also relying on the Poseidon lookout table which will be constrained by the Poseidon circuit.
01:08:24.690 - 01:09:24.390, Speaker A: And then next is going to constrain the pop inputs. So the pop input circuit will provide the transaction hash to the transaction lookout tables and also provide that into the block lookout tables. And I also going to constrain the old route and then the final new route is the exactly same matching inside your Merkel Patricia tree table here. So constraint provide these values from this public input circuit and then you'll have this catch act circuit going to constrain the catch up tables. Bico circuit constraining the Bico tables transaction circuit will constrain the transaction, but rely on the RP tables, which are constrained by the RP circuit, and also relying on the signature tables which are going to be constrained by the ECDSA circuit. So with that, this is constitute of the entire DKE VM architecture.
01:09:26.650 - 01:09:29.720, Speaker B: Do you have any question for that?
01:09:30.110 - 01:09:33.578, Speaker C: Do you guys support create two or no?
01:09:33.744 - 01:09:35.834, Speaker A: Yes, we support create and create.
01:09:36.032 - 01:09:36.780, Speaker B: Okay.
01:09:45.390 - 01:10:30.490, Speaker A: And then all of this work actually we are doing in the open source, collaborating with the PSE group from the Ethernet foundation and also other many more open source community members as well as the halo two. It's also an open source proof systems. It's like a bunch of the guys who are contributing from the ECC team, CCash team, they contribute and roll this very great halo two libraries. So these are all the people? Not all the people, there's many more here. And then actually the members are still growing. So I want to credit all of things to the community members and thank you. That's all from today's presentation.
01:10:30.490 - 01:10:43.210, Speaker A: Do you have any other questions? Maybe in general, like the general question.
01:10:44.060 - 01:10:46.776, Speaker B: A bit of a high level question. So what's the right way to think.
01:10:46.798 - 01:10:48.744, Speaker C: About the sizes as you go through.
01:10:48.782 - 01:11:00.460, Speaker B: Sort of the different stages of expansion? Like what's the different way to think about the size of the input program, the size of the phrase, the size of the circuit, those kinds of parameters.
01:11:03.040 - 01:11:35.972, Speaker A: So you're seeing what's the size of the circuit. So the size of circuit actually are constraint. The size of circuit are constrained like the prefix. So I'll say like the, if you're going to say so, for example, all of the circuits you have, all of circuits you have here, they're all going to be pilot to the same size. So same size of the rows inside each circuit are all lockup tables. They will be all pilot to the same things. So it'll be easier to constrain and connect between different circuits and tables.
01:11:35.972 - 01:12:15.556, Speaker A: And then the size of circuits is also configurable depending on, I guess a trade off. If you have a larger circuit, then you can support more gas costs. You have inside your transaction, inside your layer two blocks. If you have larger circuits, then it means your approving time will be larger. So right now, we're considering like the farm for all of the circuits here. It's like two to the 18 or two to the 22 to 20, like the circuits, which can support like a few million gas costs inside the layer two blocks. But we're also still doing some playing with the trade off.
01:12:15.556 - 01:12:23.370, Speaker A: If we have more better optimization, maybe we can have larger circuits. Does that answer your question?
01:12:27.850 - 01:12:33.046, Speaker B: I mean, I think it does. I guess I'm sort of trying to ask about the kinds of bottlenecks that.
01:12:33.068 - 01:12:42.300, Speaker C: I like to write. Variety of bottlenecks. What do you typically think about?
01:12:42.830 - 01:13:31.706, Speaker A: Yeah, I think that the bottleneck is first things I think would be the inside EVM circuit, because the EVM circuit is the main processor circuit, so it use most of rows you have if you do some working on some larger blocks. And then we found the event circuit is the most constrained circuits. And the second could be the catch check, and some of the ECDSA circuit, which going to have more constraints associated with that. So this is like our current cycle of the most constrained circuits inside this. Okay, so if there's no more questions, I'll give the time to Jordy and Carlos, and they can present their designs for the polygon Hermit Zikavm design.
01:13:31.808 - 01:13:32.700, Speaker B: Thank you.
01:13:36.020 - 01:13:58.696, Speaker C: Hi, everyone. My name is Carlos Matagostinard. I'm a member of the protocol integration team. I'm the team lead at Polyonermeth. Our team basically is in charge of writing the smart contracts, writing the ROM, which is basically an interpreter of the ABM, and also writing the specification that.
01:13:58.718 - 01:14:02.200, Speaker B: The CTVM follows and implementing.
01:14:02.560 - 01:14:51.556, Speaker C: So today we're going to see the language that we use in order to implement the zkron. And this language is called Zkasm, Zk assembly. And based on this language, we implement the zkron, which is the ABM interpreter. Later on, first we'll explain a little bit the Zkasm, and later on we will explain and we will see some snippet code of how we implement the ABM. So this mainly all the sections that we're going to cover in this talk. At the very beginning, we're going to talk about the differences between the EVM and the ZQBM that Polygon has. One of the most important will be is the state tree.
01:14:51.556 - 01:15:05.996, Speaker C: Also we will see the difference between the memory of regions that we can handle. Then I will introduce this new brand language, which is the Zkasm. Just to remind you that the Zkasm.
01:15:06.028 - 01:15:09.744, Speaker B: Is a general purpose language that you.
01:15:09.782 - 01:15:17.240, Speaker C: Can use to write anything. In that case, we use it in order to write the ZKBM.
01:15:17.420 - 01:15:26.150, Speaker B: But any developer could take this language and write the code that they want.
01:15:27.240 - 01:15:43.640, Speaker C: We're going through all the registers that are implemented and later on we see some small example. This small example will be basically an introduction in order to see how we implement the Zkram afterwards.
01:15:45.680 - 01:15:47.150, Speaker B: So let's start.
01:15:48.560 - 01:16:17.620, Speaker C: If you are familiar with Ethereum, you may know that the merchant tree that Ethereum uses is a modified partition mercury. The main properties that we have is for each level, they have two childs and the user function, which is the pickup 256. And there is one important thing here, which are the values that are inside and leaf in the market.
01:16:17.770 - 01:16:19.030, Speaker B: And they are basically.
01:16:20.840 - 01:16:29.076, Speaker C: The value is in fact a kick out of the LP of an ethereum account. And an Ethereum account is composed by the nons, the balance, the storage route.
01:16:29.108 - 01:16:30.440, Speaker B: And the code hash.
01:16:31.200 - 01:17:07.792, Speaker C: And the storage route is basically on all the storage that has and is coded into another modified Patricia market tree. This is how the tree looks in the AVM, but how the tree looks in the ZQVM. We have small differences over here because our tree is a binary tree. It's a spatchmaker tree, it's binary. We have two choice for each level. We use a different hash function. As we saw it, EVM uses a keycad and we use positive.
01:17:07.792 - 01:17:12.680, Speaker C: We use positron because it fits better with the thermo knowledge.
01:17:13.260 - 01:17:14.056, Speaker B: Okay.
01:17:14.238 - 01:17:20.408, Speaker C: And regarding the value, and this is very important, notice that we do not.
01:17:20.494 - 01:17:24.456, Speaker B: Add all the parameters in one leaf.
01:17:24.488 - 01:17:32.700, Speaker C: In the mercantile tree. We separate the parameters in different lips in the merkin tree because it's more convenient to us in order to perform fastest computations.
01:17:35.140 - 01:17:50.870, Speaker B: Notice also that the value inside the leaf, it's composed. It's an array of eight values, and each value is Goldilock prime field number.
01:17:51.640 - 01:18:22.344, Speaker C: Which is basically this number here. This is very important, we will see afterwards because of the registers of the CD assembly that it's using. Since we need to deal with EVM numbers, and EVM numbers occupies basically 256 bits, we need these eight field elements and we take only the less significant part of this print field number. So at the very end we're dealing.
01:18:22.392 - 01:18:27.120, Speaker B: With 256 bits, but internally are eight.
01:18:27.190 - 01:18:33.520, Speaker C: Elements of a voldelog spread field number. And we use the lesson, the 32 lesson mechanometers.
01:18:37.060 - 01:18:44.820, Speaker B: Regarding the memory, we use context based memory, as you may know, in ethereum.
01:18:45.480 - 01:18:50.010, Speaker C: Every time that you perform call, delegate, call.
01:18:51.900 - 01:18:54.744, Speaker B: Create two, you need to create.
01:18:54.862 - 01:19:18.684, Speaker C: A new context with its new stack and its new memory, and you fulfill it depending on the call that has been done. In order to handle that, we are going to implement a CKDM memory but with different context. And you can switch the context very easily with just a register, and you can move inside the different memory versions.
01:19:18.732 - 01:19:24.880, Speaker B: Of bin context very easily, again with just a few registers.
01:19:26.920 - 01:20:25.110, Speaker C: What are the difference between the memory regarding the ZKBM and regarding the ABM? Well, basically the memory and the ABM are slots and the slots occupies eight bits. What we have in the ZPVM are memory slots that occupies basically 256 bits. So we kind of need a mapping between the ABM and the ZKBN that we need to handle and also in order to handle that, because if the bytes are aligned in 32 bytes, it's really straightforward to take 32 bytes of the EVM memory and then put it in the ZKBM. But what happens if there is some misalignment over there? What happens if we need to take the first part of the slot in the ZKBM, write some number over there, and at the same time take the second slot and write some number over there?
01:20:25.640 - 01:20:28.224, Speaker B: This is a little bit tricky and.
01:20:28.282 - 01:20:34.010, Speaker C: We have a special state machine in order to deal with that, which is the memory line.
01:20:36.460 - 01:20:40.056, Speaker B: And regarding the stack, the stack in.
01:20:40.078 - 01:21:01.280, Speaker C: The EVM will be exactly the same that we have in the CPVM. Since the stack in the ABM, it occupies 256 bits. We mimic this kind of stack in the ZKBM because we also have 256 bits.
01:21:02.340 - 01:21:05.504, Speaker B: But also since we have a lot.
01:21:05.542 - 01:21:23.530, Speaker C: Of step pace in the stack, I would say that the first 1022 slots of the stack will be used in order to mimic the stack of the EVM. The rest will be used in order to store the call data. And we'll read the call data from there and we'll put the call data from there.
01:21:26.380 - 01:21:31.176, Speaker B: Okay, so now we're going to introduce.
01:21:31.208 - 01:22:17.940, Speaker C: A little bit this assembly language. We're going to see what is available in the language, what is available for us in the language. Basically we're going to see which are the available resistors that we can use, and we're going to see what are the available instructions that we can use. This language is called ZK assembly because at the very end it's like writing assembly at low level in a cpu. But here later on this assembly is compared to polynomials. And that's why we put the GK assembly. So first of all, I'm going to go one by one through the register.
01:22:17.940 - 01:22:28.040, Speaker C: I'm going to comment. It's important to make sure we have two kind of registers. Two types of registers. There is one registers that are composed.
01:22:28.120 - 01:22:32.444, Speaker B: By eight elements, and each of one.
01:22:32.482 - 01:22:59.200, Speaker C: Of these elements is a goddess prime field number. As you may remember, when I mentioned the ZKBN state tree, I told you that in the value we are inserting 256 bits, but they are divided in eight elements. So that's why we have this kind of resistors. So first of all, we have generic resistors that you can play around, which is ABCD and E and all of.
01:22:59.210 - 01:23:04.180, Speaker B: Them, they have this kind of array of eight elements.
01:23:04.340 - 01:23:16.372, Speaker C: We have the state root, which basically will be the state root of the method tree of the state tree. And we have the rotately chip, which is, I would say a useful register.
01:23:16.436 - 01:23:21.100, Speaker B: Known to avoid to use state machines afterwards.
01:23:21.680 - 01:23:24.430, Speaker C: It's a register that optimizes a little bit of code.
01:23:25.780 - 01:23:27.584, Speaker B: We're going to see now the rest.
01:23:27.622 - 01:24:00.100, Speaker C: Of the registers, and basically the rest of the registers are just only one field table. The first ones are the ZK counters. What is the meaning of the ZK counters? The ZK counters are basically the resources that the proverb has available. I mean we cannot waste all these resources, otherwise the proof will not be generated. And you can see this kind of resources as the gas in Ethereum.
01:24:00.180 - 01:24:02.936, Speaker B: So instead of we also have the.
01:24:02.958 - 01:24:08.730, Speaker C: Gas, of course, in order to mimic the VM, but also we have this kind of GK gas, you could say.
01:24:09.580 - 01:24:11.256, Speaker B: We have another resistor, which is the.
01:24:11.278 - 01:24:18.240, Speaker C: Context I already mentioned that when I enter use the ZQVM and basically it.
01:24:18.310 - 01:24:23.084, Speaker B: Helps us to move from the numeric regions.
01:24:23.212 - 01:24:42.676, Speaker C: We have the stack pointer, which also helps us to move in the numeric regions. We have the program counter. The program counter is register that will tell us in which position of the smart contract bytecode we are going to read the following bytes.
01:24:42.788 - 01:24:45.624, Speaker B: It's important to notice here the program.
01:24:45.662 - 01:25:24.176, Speaker C: Counter is regarding the smart contract that we are reading. The car register is available gas in a transaction. The ZK program counter the ZK program counter is the prompt counter of the current program that we are running. The ZK program. We could say, okay, so just notice the difference this between the program counter and the ZK program. Also we have the register which is basically utility. It's a useful register in order to perform some jumps and returns.
01:25:24.176 - 01:25:48.876, Speaker C: In assembly, we have the step register which is basically all the instructions that we are. I mean it has all the counts of the instructions that we are running much memory, which basically tracks the maximum memory that we have and hash position. We will see later on how the.
01:25:48.898 - 01:25:53.980, Speaker B: Register is using, okay.
01:25:55.730 - 01:25:56.640, Speaker C: Which is.
01:25:58.450 - 01:25:58.862, Speaker B: The.
01:25:58.916 - 01:26:19.262, Speaker C: Process of using this resistor. So basically what we could do with the resistors, what we could do is we can add, we can multiply, we can move the resistors to another one. And basically this is a simplified diagram.
01:26:19.326 - 01:26:21.666, Speaker B: Of what the processor can do.
01:26:21.848 - 01:26:51.038, Speaker C: So at the left you have the input, at the right you have the output. This is just like a state machine. So you have an initial state and you have a final state. And depending on the flux, the final state will change. So for example, if I want to move a into b, so I will have activated the flag in a. So the a will be to this intermediate value which is up. And this is very important.
01:26:51.038 - 01:27:01.042, Speaker C: This kind of is an intermediate value. And later on, if I have the set beer register set to one, then.
01:27:01.096 - 01:27:04.660, Speaker B: This op will be loaded into b.
01:27:05.750 - 01:27:09.860, Speaker C: And it happens the same with all the registers that I mentioned before.
01:27:12.710 - 01:27:15.694, Speaker B: Okay, now that we know the meaning.
01:27:15.742 - 01:27:19.830, Speaker C: And all the resistor that we have available in the assembly, I'm going to.
01:27:19.900 - 01:27:23.802, Speaker B: Explain all the instructions that we have available.
01:27:23.936 - 01:27:32.582, Speaker C: As I mentioned at the very beginning, the CK assembly is a general purpose language, but we use it to build the ZKBI.
01:27:32.646 - 01:27:39.530, Speaker B: So some instructions, I would say, that are thought to be used for the ZKBI.
01:27:41.170 - 01:27:50.110, Speaker C: So the first instruction is the memory lot is quite straightforward. You took some value, plumbing memory, and you load that into this middle register.
01:27:50.530 - 01:27:52.130, Speaker B: Okay, the upper register.
01:27:55.510 - 01:28:11.654, Speaker C: We will see afterwards that we use this free in that you can put whatever value you want. But later on there is a steel machine behind that assures that this value is okay. So for example, in the Mlot, what.
01:28:11.692 - 01:28:14.134, Speaker B: We are doing is we are loading.
01:28:14.182 - 01:28:16.362, Speaker C: Any value that we want into this.
01:28:16.496 - 01:28:18.220, Speaker B: Op through the free in.
01:28:18.750 - 01:28:34.286, Speaker C: But there is a state machine, which is the memory that ensures that this value belongs to this address of the memory. And this happens with all the frequency that we are using.
01:28:34.388 - 01:28:37.098, Speaker B: We can put whatever we want, but.
01:28:37.204 - 01:28:47.182, Speaker C: Also we check what is this value memory load, just to load some memory.
01:28:47.246 - 01:28:52.466, Speaker B: Vision to this Internet value up memory store.
01:28:52.648 - 01:29:06.570, Speaker C: We just store the Internet value into memory. Hash k, hash Klen and hash k digest. Those three instructions are used in order to perform kicak hashes.
01:29:07.790 - 01:29:11.562, Speaker B: We will see in the slide later.
01:29:11.616 - 01:29:17.438, Speaker C: On a diagram how this structure works in more in detail.
01:29:17.524 - 01:29:27.018, Speaker B: But basically with hash k you are adding all the bytes that you want to hash. The hash klem is to close the.
01:29:27.044 - 01:29:29.346, Speaker C: Hash and hash k digest is in.
01:29:29.368 - 01:29:38.770, Speaker B: Order to retrieve the hash, exactly the same instructions are used to perform the posture on hash.
01:29:40.870 - 01:30:14.874, Speaker C: And then we have jumps as language, I would say. And basically this jumps helps you to jump to a different regions of the code depending on some parameters. In that case, we have this direct jump. You just put the address that you want to jump and then you jump this jump, negative. It depends on the value, on the alternative value, which is the op. If it's negative, it jumps, otherwise it just increment by one encounter. And also we have another one which is the jump.
01:30:14.922 - 01:30:21.220, Speaker B: Careful, depending on the op, in fact.
01:30:22.470 - 01:30:27.214, Speaker C: We are jumping or not to the next. Well, depending on the carry.
01:30:27.262 - 01:30:30.802, Speaker B: So the carry, you will see afterwards.
01:30:30.866 - 01:30:38.662, Speaker C: That depending on the instruction that we perform, it could have a carry so.
01:30:38.716 - 01:30:50.380, Speaker B: We can jump easily to this address. Depending on the result of the instruction, I would say it's a helper job.
01:30:52.430 - 01:31:00.734, Speaker C: Okay, we have these two instructions, call and return. Well, they are very useful because it.
01:31:00.772 - 01:31:02.480, Speaker B: Performs some.
01:31:04.770 - 01:31:24.280, Speaker C: Computations and you don't notice regarding these computations, they are basically saving the Zk program counter when you perform the call. And when you perform the return, in returns to the previous GK program counter that you face when you did the call. Okay, these are very useful. You have to navigate through the code.
01:31:24.890 - 01:31:27.510, Speaker B: We have this assert which is basically.
01:31:27.580 - 01:31:33.500, Speaker C: Takes the register and compare it if it's equal to the terminal value, up.
01:31:34.430 - 01:31:36.026, Speaker B: And here we can see one of.
01:31:36.048 - 01:31:39.770, Speaker C: The most important instructions, which is basically the storage.
01:31:41.790 - 01:31:43.174, Speaker B: The storage load.
01:31:43.302 - 01:31:49.114, Speaker C: And later on the storage store, they.
01:31:49.152 - 01:31:53.226, Speaker B: Are basically breeding leaves from the mercantry.
01:31:53.258 - 01:31:54.762, Speaker C: That I show at the very beginning.
01:31:54.906 - 01:31:58.510, Speaker B: And writing leaves to the mercantry.
01:31:59.350 - 01:32:10.434, Speaker C: But this is very important because it modifies the ZPDM state. Just what I want to mention here is that in order to use these.
01:32:10.472 - 01:32:16.454, Speaker B: Instruments beforehand, you need to provide some.
01:32:16.492 - 01:32:20.646, Speaker C: Data in order to compute, in the.
01:32:20.668 - 01:32:23.094, Speaker B: Case of the load, the key that.
01:32:23.132 - 01:32:31.754, Speaker C: We are going to navigate through mercury in order to retrieve the value. And regarding the store, we're going to compute the key, but we also need.
01:32:31.792 - 01:32:36.478, Speaker B: To provide the value. So we need to be aware that.
01:32:36.644 - 01:32:47.680, Speaker C: Before calling these instructions, we have been set all these registers accordingly in order to write or read the value.
01:33:00.100 - 01:33:00.960, Speaker B: Machine.
01:33:03.240 - 01:34:09.400, Speaker C: Machine. What it does is it basically, okay, it will be used every time that we need to perform some multiplication, some division, some addition, whatever it needs. And basically for sample addition, you just put the value that you think division will have. You check it with this arithmetic statement. So you don't compute the division, okay, you just put the value of the division and then you check that value if it matches, but you check it with a multiplication. The next state machines are less than basically trigger the binary state machine. As you remember from these talks, the binary state machine basically takes two registers and it compares its result to the intermediate comparison.
01:34:09.400 - 01:34:43.408, Speaker C: It enforces that the intermediate value is indeed the register. R plus b in case of an addition. It enforces that the operator is indeed r minus b. Same with less than sine or less than equal. Equal. Okay, and last instructions. As I mentioned when I explained these memory differences, they are the memory line instructions.
01:34:43.408 - 01:35:36.230, Speaker C: The memory line instructions basically activates the memory line state machines. And we did it in a way that they are very similar. So we have read memory and write and memory align, write eight in order to be kind of similar to. They have almost exactly the same opcodes, I would say. Well, the machine basically, just to summarize, I will not go into details, but it takes two slots and it compares the value that you write. It's the value that you want to add. And in case of drip, it basically takes it to a slot, takes one part of the slot or part of the slot, they join it together and use the value that you want.
01:35:37.880 - 01:35:38.820, Speaker B: Checks.
01:35:39.740 - 01:35:56.940, Speaker C: What is misalignment? There is some tricky things. Okay, now we know a little bit which are the registers and instructions that this zkasm had.
01:35:57.090 - 01:36:00.044, Speaker B: We're going to see a small example.
01:36:00.242 - 01:36:22.790, Speaker C: Of how to use it. And this example, we first start from an initial point. And this point means that we have an initial memory and this initial memory in the context one. Inside the stack of the context one, we have the two first value are two and three.
01:36:23.800 - 01:36:27.764, Speaker B: So we need to the program, what.
01:36:27.802 - 01:36:30.824, Speaker C: It does is it reads these two.
01:36:30.862 - 01:36:43.080, Speaker B: Values, they add together and the result, it is written again in this specific address in memory.
01:36:43.160 - 01:37:10.724, Speaker C: Okay, and what we're going to see, and we're going to go step by step, line by line, in order to see what this program does. This is the initial condition, the initial memory. This is the program. And the result, the final state will be that we write in the start this file here.
01:37:10.842 - 01:37:13.030, Speaker B: So, okay, let's start. First.
01:37:14.840 - 01:37:45.272, Speaker C: You saw the initial state, the initial memory. So what we want at the very first is to read these two and this three. So what I need to do is to set all the resistors necessary in order to compute the address that I want to access. And in that case I want to set the context one. That would be the first instruction. Then I want to set the stack pointer to one.
01:37:45.426 - 01:37:50.610, Speaker B: Then I will read the second number, the three.
01:37:51.140 - 01:38:14.104, Speaker C: So now I have here, I would say the address of the memory. So what we're going to do now is to read that, to read that with. So I'm going to perform memory load and what is the value of the context and the stack point there? One.
01:38:14.142 - 01:38:14.728, Speaker B: One.
01:38:14.894 - 01:38:26.604, Speaker C: So we're going to the context one and take the second value of the stack, which is the three. And I will load that in the.
01:38:26.642 - 01:38:30.424, Speaker B: Three in and the memory state machine.
01:38:30.472 - 01:38:35.650, Speaker C: Will ensure that this value is indeed three.
01:38:36.500 - 01:38:37.250, Speaker B: Okay.
01:38:39.300 - 01:38:56.800, Speaker C: We are loading this intermediate value up in a. So we have the flag set a set to one and this value will be loaded in the a. This is what this structure does. It takes one value from the stack.
01:38:56.960 - 01:39:03.384, Speaker B: And it loads it in register eight. Also, at the same time we are.
01:39:03.502 - 01:39:37.504, Speaker C: Decreasing the stack pointer. This is for convenience as well. In order to not put this line in another structure line, we are doing exact all the computations, we are doing just to one line. So at the very end of this structure, the stack pointer is decreased one. And this allow us to do this structure. This allow us to read then the two value. So here we have stack pointed is zero.
01:39:37.504 - 01:39:57.864, Speaker C: So we are going to read the top value of stack regarding the context one, which is basically two, and this two, we are going to load it into the field. And this is assured that we are loading field. We are loading the two because the memory state machine sources ask to load these two to the three.
01:39:58.062 - 01:40:01.704, Speaker B: And in that case the op the.
01:40:01.742 - 01:40:26.272, Speaker C: Field value, we're going to load it into a register bit. So the flag should be set to one and then we add it into this. Okay, so basically now we have read two values from memory. What we're going to do now is.
01:40:26.326 - 01:40:28.660, Speaker B: To add those values.
01:40:29.240 - 01:41:15.410, Speaker C: So use the binary state machine in the addition mode. As you remember, the instruction of the addition in the state machine is basically taking register a, register b, and it computes the result that it computes. It is loaded in this intermediate value. And to mention again, you can put all the value that you want using terminal value in the up in the free. But in that case the binary state machine will enforce that this value is a plus b. So we are checking that value. We are not computing the value, we are checking the value.
01:41:15.410 - 01:41:21.376, Speaker C: Okay, so we add a plus b and we set it to the resistor.
01:41:21.408 - 01:41:27.856, Speaker B: C. And the last step is basically write the memory.
01:41:27.968 - 01:41:33.528, Speaker C: And in this case we are going to overwrite, for example, the first position.
01:41:33.614 - 01:41:36.280, Speaker B: In the stack regarding the context.
01:41:36.620 - 01:41:53.788, Speaker C: So we are basically moving the resistor which will have the result of the writing into memory with the MS store instruction. And remember that the stack pointer was and remember that the context was one.
01:41:53.874 - 01:42:00.320, Speaker B: So we wanted to write that value in that specific area of the memory.
01:42:04.500 - 01:43:05.780, Speaker C: Okay, so we have seen the ZK assembly code, the resistors and all storages that we can use. We have seen also I would say a small piece of code that will be very similar to the zkrom. In order to show a little bit the syntaxes here, I just want to show all the files that we have in the Zkrom. So this is basically the name of the files, the current name of the files that we have in the ZK room and all its dependencies. In case that you enter into your repository and check it's all open source in GitHub, you will have an idea on all the dependencies and you will have the entry point is the main. We have this contest bar loading reception IP will go over these files in the column.
01:43:07.880 - 01:43:11.450, Speaker B: Okay, now we are going to see.
01:43:12.700 - 01:43:20.516, Speaker C: How to process a batch. We're going to see the implementation of the ROM, the interpreter of the EVM.
01:43:20.628 - 01:43:24.090, Speaker B: But before doing that, I think.
01:43:28.140 - 01:44:05.610, Speaker C: It'S very needed an introduction of how we use the data and which data are we using when we process a batch and how this data is enforced. In this case, it's enforced by the smart contract. Okay. As you may know, roll up basically works that you need to send some data to a smart contract, which is the availability. In that case, we have one entity, which is the sequencer, that calls smart contract function, which is the sequence batches with the transaction data.
01:44:08.540 - 01:44:12.912, Speaker B: First of all is in which format.
01:44:12.996 - 01:44:44.900, Speaker C: These transactions are loaded into the smart contract, which is the data, that is the data validity, which is on chain. And we can see here that we use kind of, I would say special transaction encoding. And basically the transaction coding is the LP of the transaction, but it's not the transaction hash, but it's the, I would say, transaction message that is used afterwards in order to verify the signal.
01:44:45.480 - 01:44:50.580, Speaker B: And concatenated with this data, we attach the signal.
01:44:54.360 - 01:45:03.320, Speaker C: So notice that the ls and B are not inside the other tip, but they are outside. And this is basically for convenience in order to not to pass it later.
01:45:03.390 - 01:45:04.970, Speaker B: On inside the line.
01:45:05.680 - 01:45:09.148, Speaker C: So we call this data the transaction data.
01:45:09.234 - 01:45:15.840, Speaker B: We hash it with a kicat and we call it batch hash.
01:45:16.420 - 01:45:19.664, Speaker C: And with the batch hash data, we.
01:45:19.702 - 01:45:28.850, Speaker B: Also has the global exit route, which is basically the route that the breach has.
01:45:30.100 - 01:45:37.844, Speaker C: We also the timestamp and the message channel. When this sequence batches call has been.
01:45:37.882 - 01:45:40.250, Speaker B: Made in the smartphone okay?
01:45:41.660 - 01:46:26.960, Speaker C: And also we have at the very beginning, this all accumulated, those all values are hashed together. And then I compute what we call the new accumulated put hash. You can see it here, there is like, I would say chain, a concatenation of the old accumulated put hash. New accumulated. The new accumulated input hash will be the new accumulated put hash, will be the alt accumulated put hash of the next batch. So here we create a table of hashes. And this is very useful in order to prove our sequence of batches, not just one batch.
01:46:27.120 - 01:46:30.356, Speaker B: I just want to mention that the.
01:46:30.378 - 01:46:46.120, Speaker C: Global exit route is a very important parameter, because basically here what we are doing is forwarding the root of the exit tree in layer one to the layer two. And we enforce that by circuit.
01:46:46.280 - 01:46:47.036, Speaker B: Okay?
01:46:47.218 - 01:46:58.540, Speaker C: And this is very important because it allows to perform the claims of the posit that has been performative layer.
01:47:00.420 - 01:47:01.170, Speaker B: So.
01:47:02.980 - 01:47:12.310, Speaker C: What are the inputs and what are the outputs of the batch? The inputs are basically what we saw.
01:47:14.520 - 01:47:16.180, Speaker B: In the previous slide.
01:47:18.520 - 01:47:34.984, Speaker C: And also we add here the chain id, which is hard coded in the smart contract. And I wanted also to add here this kind of get transactions. And we will see afterwards inside the batch.
01:47:35.032 - 01:47:39.612, Speaker B: But basically this get transactions is add.
01:47:39.666 - 01:48:12.730, Speaker C: Me all regarding the batch is add me all the transactions that you want. Add me all the data that you want. But at the very end, inside the Zkrom, we will hash it as the smart contract does. And this hash needs to match. Okay? So it means that you are forced to put exactly the same data that has been hashed in the smart contract. Otherwise the hash will not match.
01:48:14.620 - 01:48:15.812, Speaker B: At the batch.
01:48:15.956 - 01:49:04.756, Speaker C: When we process all the transactions, they have some output, which is basically if we change the state route because it has been some setting structure or contract or whatever. It has a new state route, we have a new accumulated hash, we have a new numbat and a new local exit route. Just very briefly to mention that the local exit route is basically the exit tree in layer two. And we are forwarded this layer two exit route to the layer one. So, in case that anyone wants to transfer some asset from layer two to layer one. Of course, in layer two, we have the breach and the root of this bridge is forward layer one. Through this new lock.
01:49:04.756 - 01:49:06.010, Speaker C: We will see how.
01:49:08.940 - 01:49:12.250, Speaker B: Okay, so let's process.
01:49:13.200 - 01:49:24.884, Speaker C: Let's start in the processing of a watch. This is the initial, I would say the main entry point to a rom.
01:49:24.952 - 01:49:25.472, Speaker B: Okay?
01:49:25.606 - 01:50:08.812, Speaker C: And this is basically just loading register into memory, in that case, into variables. We are just storing the auto state root. The community has the unknown batch. I just want to mention that here we are storing the lexi group, for example. But here we use the dollar. It means that it used the op interval value. And you can put here whatever, you can put the value that you want.
01:50:08.866 - 01:50:11.404, Speaker B: Here, but later on it will be.
01:50:11.442 - 01:50:43.558, Speaker C: Checkered, in that case, with the hash that the smart contract performed. So it needs to be exactly the same. So you are forced to use some value here, but you can put the value that you want. If you don't put exactly the same value, basically the proof will be okay. Before going on to the second step of processing a batch, I'm going to show a little bit example of how the hash works.
01:50:43.644 - 01:50:46.406, Speaker B: Basically, as I mentioned at the very.
01:50:46.428 - 01:51:08.606, Speaker C: Beginning, we have three different instructions for hash, which is hash p, hash killer, and hash digest. So here, basically, this is an example of how to use it. Basically, what we need to do is when we want to start the hash, we need to have an id for.
01:51:08.628 - 01:51:17.934, Speaker B: That hash, what we call the address. Okay, so imagine that the address is.
01:51:17.972 - 01:51:20.340, Speaker C: The registered it and it's zero.
01:51:20.790 - 01:51:24.850, Speaker B: Okay? And I want to add some bytes.
01:51:25.670 - 01:51:52.246, Speaker C: How many bytes do we want to add to the hash? This is determined by the resistor v. The d determines how many hash, how many bytes I want to add to the hash. And the resistor hash post is basically the offset where I want to add those bytes. It's like the offset size, typical offset size. Okay, so I'm adding bytes to the hash.
01:51:52.438 - 01:51:57.414, Speaker B: Once those bytes are added and generalized.
01:51:57.542 - 01:52:31.400, Speaker C: I will just close the batch with the structure of hashcalen. And also hashcalen takes this ear register. So I need to assure that I'm closing the hash in this specific address. And if I want to retrieve the result of the hash, then I will perform instruction of the hash characters. And this is very useful because here we're going to see how to.
01:52:34.490 - 01:52:34.854, Speaker B: Set.
01:52:34.892 - 01:52:35.874, Speaker C: A mapping in solidity.
01:52:35.922 - 01:52:39.022, Speaker B: But call it in the SDK route.
01:52:39.186 - 01:53:08.162, Speaker C: Very straightforward. How to set a mapping in solidity. So first I want to explain that. So if you have a mapping in a smart contract in solidity, if you want to add a value to this, a key value, you first need to compute the key. And in solidity, basically the key of a mapping is the kicker of the value that you want to add and.
01:53:08.296 - 01:53:10.690, Speaker B: The position of the mapping in the smart contract.
01:53:11.030 - 01:53:19.800, Speaker C: In this case, imagine that the smart contract just only have one mapping at the very top of the smart contract. So the position will be zero.
01:53:21.370 - 01:53:23.930, Speaker B: And in order to complete the key.
01:53:24.000 - 01:53:28.266, Speaker C: You need to kick out the value that you want to add in the.
01:53:28.288 - 01:53:28.860, Speaker B: Position.
01:53:30.670 - 01:53:33.786, Speaker C: Okay, so what do we need.
01:53:33.808 - 01:53:38.122, Speaker B: To do now is to perform this hash.
01:53:38.266 - 01:53:52.626, Speaker C: Okay, so first of all, I'm going to load the global sheet root into the register a. We saw before that we are accessing a specific region of memory. We are getting that value and we.
01:53:52.648 - 01:54:06.438, Speaker B: Are putting the value into the register a. Okay, here, since the hash that I'm going to do, the offset, I will start at zero.
01:54:06.524 - 01:54:15.594, Speaker C: That's why we put here zero to the register of the hash patch. The two next lines are basically the.
01:54:15.632 - 01:54:21.754, Speaker B: Identifier of the hash, what we call before this address.
01:54:21.872 - 01:54:26.634, Speaker C: Okay, so we are generating like a new address for the hash that I'm going to use.
01:54:26.832 - 01:54:27.514, Speaker B: That's it.
01:54:27.552 - 01:54:39.970, Speaker C: So I lost some variable that it's in memo. I increase it by one and this will be the others that I'm going to use. And then I store the last id user because later on I will perform.
01:54:40.040 - 01:54:42.526, Speaker B: Another hash and then I will increase.
01:54:42.558 - 01:55:00.470, Speaker C: This variable by one and so on in order to not overwrite any hash that I already did. Okay, how many bytes are we going to insert to the hash? In that case, I'm going to set 32 bytes.
01:55:00.810 - 01:55:05.626, Speaker B: And here I'm doing the action of.
01:55:05.728 - 01:55:11.174, Speaker C: Adding these bytes to the hash. So here, basically I'm doing the hash.
01:55:11.222 - 01:55:15.610, Speaker B: K instruction at the address of e.
01:55:15.760 - 01:55:17.662, Speaker C: Which we can assume that it's zero.
01:55:17.716 - 01:55:21.066, Speaker B: For example, and I'm going to add 32 bytes.
01:55:21.258 - 01:55:27.150, Speaker C: And these 32 bytes are the op, the intermediate value.
01:55:27.220 - 01:55:29.970, Speaker B: And what is the op register a.
01:55:30.120 - 01:55:34.260, Speaker C: So here I'm going to add to the hash the global executive, basically.
01:55:37.410 - 01:55:38.160, Speaker B: Okay.
01:55:38.930 - 01:55:41.840, Speaker C: Then when you perform the hash k.
01:55:42.870 - 01:55:46.594, Speaker B: Notice that the offset that we set.
01:55:46.632 - 01:55:57.140, Speaker C: It here at zero position, it is moved automatically all the bytes that you have. So basically the offset is moved from zero to 31.
01:55:58.010 - 01:56:01.558, Speaker B: Now the hash cost register has a.
01:56:01.564 - 01:56:09.670, Speaker C: Value of 31, but you do not notice that because it's done automatically behind the curve.
01:56:12.190 - 01:56:25.600, Speaker B: Okay, I add 32 bytes, which is basically the flow, et cetera. Now I need to add this zero here in order to compute the storage position.
01:56:26.850 - 01:56:57.526, Speaker C: Basically this zero is this percentage global exchange group storage position, which is basically a constant. We have a five, I show it in the diagram that are basically system constant, okay? And basically this constant is equal. If you put here zero, it will say. So here we are adding 32 bytes to the hash. And so we have the global exit row 32 bytes and we have the.
01:56:57.548 - 01:57:04.746, Speaker B: 00:32 bytes and then we have the hash complete. So we need to close it and.
01:57:04.768 - 01:57:33.810, Speaker C: We need to retrieve the value. So we're going to close it with the hash guy length instruction. And we are going to retrieve it with the hash Guy. Notice it's very important, notice that we are using always the same address, the e. Imagine that there is a zero here. So address zero, zero. So we are performing the substruction on the hash in the address zero, not another hash.
01:57:33.810 - 01:57:57.340, Speaker C: Okay, so here we are getting the value of the hash and this value of the hash. We are moving to the resistor c. So you see, now we have the storage position. What do we need to do? Now what we need to do is to.
01:58:00.750 - 01:58:04.934, Speaker B: Store the value of the mapping.
01:58:05.062 - 01:58:06.694, Speaker C: And what is the value of the mapping.
01:58:06.742 - 01:58:13.220, Speaker B: In that case, we put the timestamp in the value.
01:58:14.150 - 01:58:38.242, Speaker C: And in order to store, we need to use the instruction of the SSD, which basically will navigate through the GKBM state tree and add some value to a leaf. What do we need to confuse in the resistors in order to go specifically.
01:58:38.306 - 01:58:41.070, Speaker B: To that leaf in the state mercury.
01:58:41.090 - 01:58:56.414, Speaker C: Tree in order to store that value. What we need to save in the register previously is the storage position that we already have in the register seed. We need to stretch the address and.
01:58:56.452 - 01:59:00.058, Speaker B: The address will be loaded in the a register.
01:59:00.154 - 01:59:11.246, Speaker C: And this is also a constant. So imagine here an ethereum address of our smart contract. And also we will add the lift type, okay, in our case, the lift.
01:59:11.278 - 01:59:14.338, Speaker B: Type, when we write a storage in.
01:59:14.344 - 01:59:20.470, Speaker C: The mercantile, lift type is three. But also, again, this is a constant.
01:59:22.570 - 01:59:24.310, Speaker B: In the system constant.
01:59:24.650 - 01:59:26.470, Speaker C: So you can imagine here, for example.
01:59:26.540 - 01:59:28.280, Speaker B: Of three, okay.
01:59:30.730 - 01:59:49.278, Speaker C: Which is the value that we want to store. It's the timestamp. So we are reading here the time is up from memory and we load it into register b. So we have other register set in order to perform the SSR instruction. So we perform the sister instruction and then the state route is changed. And then we save it into the.
01:59:49.284 - 01:59:56.286, Speaker B: Register of the state route. Okay, this is basically moving from layer.
01:59:56.318 - 01:59:59.982, Speaker C: One, the exit route of the bridge.
02:00:00.046 - 02:00:04.146, Speaker B: To the layer two. This is a very important action in.
02:00:04.168 - 02:00:09.890, Speaker C: Order to perform some claims in layer two, you have performed at a positive layer.
02:00:12.650 - 02:00:13.110, Speaker B: Okay?
02:00:13.180 - 02:00:20.040, Speaker C: So we load all the initial variables we set, we forward the exit box.
02:00:21.070 - 02:00:26.486, Speaker B: And now we're going to interpret all the transactions.
02:00:26.598 - 02:00:42.750, Speaker C: And in order to do so, we need to decode the transaction. And as I mentioned, the transactions in the call data are supposed to be lp encoding. So what we're going to do is to take one for one each transaction.
02:00:42.830 - 02:00:44.658, Speaker B: And try to decode it.
02:00:44.824 - 02:00:58.630, Speaker C: Why I say try? Because in the call data, it could be any data over there. It could be a transaction or it could be garbage bytes.
02:00:59.690 - 02:01:04.002, Speaker B: So when we are going to decode.
02:01:04.066 - 02:01:20.794, Speaker C: The transaction, we will realize if the transaction is well done. If it's not well done, basically we are not going to process that transaction. And in fact, if the call data.
02:01:20.992 - 02:01:26.446, Speaker B: Are not all valid ethereum transactions, I.
02:01:26.468 - 02:02:00.474, Speaker C: Would say they are not valid encoding LLP transactions. We are basically going to not process any transaction or we're going to discard the batch. And when I say discard the batch, it means finish the batch without processing any transaction. We're going to see a snippet of this decoding transaction because I think it's a little bit interesting. I don't know if you are familiar with the RLP encoding, I don't know if you are familiar with the other.
02:02:00.512 - 02:02:04.890, Speaker B: P and Covid, but basically the very.
02:02:04.960 - 02:02:24.226, Speaker C: First byte of says to you if there is just a single value, how the length is this single value, or if you have a list. So what we expect is a list. If we don't read that we have.
02:02:24.248 - 02:02:30.900, Speaker B: A list, then we're going to discuss all this transaction data.
02:02:31.750 - 02:03:06.462, Speaker C: Okay, so imagine that we have a list and then we start reading. The first parameter will be the nons, which is six four bits maximum. So according to the LPS specification, if you have a value between, I think it's one byte four, then you need to read first the length of the value. Okay, so here we expect to read this number till exit one or till PD 89, which is the number of bytes that they are recording. ErLP, if there is more data over.
02:03:06.516 - 02:03:10.046, Speaker B: There, we will discard the whole data.
02:03:10.148 - 02:03:28.726, Speaker C: Because it's not what we expect. And we finish the batch, but without processing prospection. So here we read the nons, the gas price, the gas limit, the tool, all the parameters of an at the.
02:03:28.748 - 02:03:34.086, Speaker B: Very end, without being lp encoding, we.
02:03:34.108 - 02:03:41.210, Speaker C: Are reading the signature parameters, which is the l, the s and the b.
02:03:41.360 - 02:03:44.646, Speaker B: And then we finish the passes.
02:03:44.678 - 02:04:03.280, Speaker C: This is one of the models that needs to be audited, for example. And it's very important because here we decide if later on we are going to process the transaction. Okay, so once all the transaction data.
02:04:03.350 - 02:04:06.564, Speaker B: Is processed, what we are going to.
02:04:06.602 - 02:04:13.488, Speaker C: Do, sorry, once all the transaction data is decoded, what we are going to do is to process these transactions.
02:04:13.584 - 02:04:19.352, Speaker B: And processing the transaction does not mean.
02:04:19.486 - 02:04:40.620, Speaker C: Only to call the smart contract and go of code by your code and interpreting these codes, but it also adds some, we need to perform some checks at the very beginning, which is basically the intricate checks that you can find in the Europe paper, because as I mentioned at the very beginning.
02:04:42.800 - 02:04:43.324, Speaker A: We are.
02:04:43.362 - 02:05:21.656, Speaker C: Processing not just only the EBM, but we are processing non compatible code to the EBM. So here we can expect some sequencer to add data regarding a transaction with different nodes that the sender has in comparison to the one in the state tree. So we need to check that indeed this transaction has exactly the same nodes. Otherwise this transaction could not be processed. So we skip it and we go to the next transaction. So here at the very beginning we are doing these intrinsic checks. We are verifying the signature.
02:05:21.656 - 02:06:21.470, Speaker C: We are verifying that the sender has not any deployed. Smart contract is a specific API and specific check that we need to do. We are verifying of course that the chain id is exactly the same that the one that we have in the smart contract, that while the chain id, it's an input of the batch and it comes from the smart contract. We're going to verify the nonch, we are going to verify that the sender has enough funds in order to pay the transaction. I would say that basically those are the intrinsic checks. Once all the requirements are met, what we are going to do is to execute, we're going to the transaction. Okay, so what I'm going to do is to go to the piece of code in which we are interpreting the eVm, the smart contract by code, I would say.
02:06:21.470 - 02:06:25.952, Speaker C: So basically, once all the checks are.
02:06:26.006 - 02:06:31.520, Speaker B: Met, we are going to call the contract.
02:06:32.100 - 02:06:52.376, Speaker C: Okay, here, as you may know, ethereum, there are different transaction types. There is a deployment, transaction type, ethereum transfer or a call contract. So in that case I assume that we have a call contract because I think it's the more code to see. And when smart contract, first we are.
02:06:52.398 - 02:07:06.110, Speaker B: Going to move the balance and later on here it's an important piece. We need to be assured that the.
02:07:06.560 - 02:07:16.224, Speaker C: Bytecode that we are going to interpret is indeed the bytecode of the smart contract that we want. So in order to do that, what.
02:07:16.262 - 02:07:17.584, Speaker B: Are we going to do?
02:07:17.782 - 02:07:24.664, Speaker C: What we're going to do is to, we're going to create a new identifier.
02:07:24.732 - 02:07:40.404, Speaker B: For the hash, which is basically here. And we're going to fill this hash. Okay? And here, as we saw when we.
02:07:40.442 - 02:07:41.976, Speaker C: Set the global executive from layer one.
02:07:41.998 - 02:07:46.440, Speaker B: To layer two, we are putting the offset in zero.
02:07:46.510 - 02:07:48.228, Speaker C: And here I'm going to add byte.
02:07:48.244 - 02:07:55.736, Speaker B: Byte of the smart contract. Okay, so here I'm basically adding one byte.
02:07:55.768 - 02:08:05.410, Speaker C: So here I put the offset to zero, I put the size to one, which is the d. And here I perform the hash p, which is basically.
02:08:05.780 - 02:08:10.690, Speaker B: Adding one byte to the hash and.
02:08:11.060 - 02:08:13.520, Speaker C: What is the byte that I'm adding?
02:08:13.860 - 02:08:16.644, Speaker B: And I mentioned previously, if we found.
02:08:16.762 - 02:08:22.612, Speaker C: This dollar with this kind of brackets, you can put whatever you want.
02:08:22.666 - 02:08:24.916, Speaker B: Here you can put whatever you want.
02:08:24.938 - 02:08:30.136, Speaker C: You can put any byte. So we are adding just bytes to.
02:08:30.158 - 02:08:36.440, Speaker B: A possible hash one after the other. And once we finish, we close the batch.
02:08:38.300 - 02:08:48.956, Speaker C: We retrieve the result of the batch at what we're going to check. And here this service, very important, what.
02:08:48.978 - 02:09:04.476, Speaker B: We'Re going to check is that the result of this hash matches exactly the byte contract hash that we have in the state method. So here I'm assuring that the bytecode.
02:09:04.508 - 02:09:09.856, Speaker C: That we are going to interpret now is the bytecode that this smart contract.
02:09:09.888 - 02:09:12.550, Speaker B: Is supposed to have. Okay.
02:09:15.570 - 02:09:29.860, Speaker C: So here I'm going to read now and interpret the bytecode here read bytecode. And basically here we are just.
02:09:31.590 - 02:09:32.002, Speaker B: From.
02:09:32.056 - 02:10:24.080, Speaker C: The, you remember that I said that we are just adding byte byte, the smart contract bytecode into this hash. So from this exactly bytecode that we add here, we are reading all the bytecodes that we are going to interpret using this functionality. So the hash p is not just for only writing into the hash, but also for retrieving from the hash. So here we are retrieving byte byte. And basically we have a table with all the opcodes. And this table will release you to the opcode that you. Okay, so imagine we have a smart contract that interprets one opcode and this opcode is the addition.
02:10:24.080 - 02:10:43.984, Speaker C: So we're going to check now the implementation of the ad opcode. At the very beginning of the ad, we're going to perform some checks. One of them is regarding the ZK gas. And in this case it's the ZK counters.
02:10:44.112 - 02:10:48.020, Speaker B: And it's basically we have gone out of counters.
02:10:48.700 - 02:11:13.596, Speaker C: Afterwards we'll perform exactly the same checks as the EVM does. So we need to check that. For example, in this vision op app, in this opcode, we need to read two values from stack. So we need to be assured that indeed there are two values in the stack. Otherwise we will jump to a special routine which is underflow, which handles whatever. Also we need to check that we have enough gas in order to perform this opcode.
02:11:13.708 - 02:11:16.336, Speaker B: And later on, what we're going to.
02:11:16.358 - 02:11:38.472, Speaker C: Do is to read two values from the stack. And this is pretty much the same that we did. The example that I showed at the very beginning. At the end of the a, we are adding using the machine and we.
02:11:38.526 - 02:11:39.130, Speaker B: Store.
02:11:41.340 - 02:11:52.750, Speaker C: The bytecode in the stack. And what we do when we finish, let's interpret the next bytecode. In the smart contract platform.
02:11:54.880 - 02:11:55.436, Speaker B: I would.
02:11:55.458 - 02:12:39.930, Speaker C: Say that this is a very straightforward opcode, which is the addition. But for example, if we go to the multiplication, it will be also a little bit straightforward. But we will see that we use here the arithmetic state machine as well. So in the multiplication, as you may know from VDM, we are also reading two values from stack. Okay, we need to multiply them. In order to multiply them, we're going to use utility that we built, which is called most array. I will show you, let me find it.
02:12:39.930 - 02:13:30.990, Speaker C: Okay, and basically what it does is it performs the multiplication, but it performs the multiplication using, I mean you can put whatever you want here using this dollar. Dollar, okay, so we are putting here the result of the multiplication. We could say later on using the Arith state machine, we are checking that indeed the value, the result of the multiplication is indeed that value that you perform. So is this thing that you add whatever you want and later on we check it. Okay, it happens the same in this state machine, in the.
02:13:37.600 - 02:13:39.916, Speaker B: Okay, so in.
02:13:39.938 - 02:14:41.650, Speaker C: Order to finish once all the transactions has been processed, in order to finish the vast, what we need to do, we need to basically compute exactly the same thing that the smart contract did. As you remember in previous slides, I show you what the smart contract hash does. It does basically a kick out of the alt accumulated put hash, all the transactions hash it all together, which is the batch hash data, the global exit route, the message center. So in the rom we need to perform exactly the same in order to assure that we use this data. Basically, here we are, just while we did the lp recovery, where we add all of this data into the hash. So here we are closing that hash. So we are computing the batch hash data, and here, basically, as you see, the offset is set to zero.
02:14:41.650 - 02:14:45.740, Speaker C: We are adding 32 bytes and we are adding the altar correlate input hash.
02:14:45.820 - 02:14:46.450, Speaker B: Perfect.
02:14:47.060 - 02:14:58.388, Speaker C: Here we are, 32 bytes and what we are adding data. Here we are in the global data, and here we are closing the hatch, and here we are retrieving the result.
02:14:58.474 - 02:15:04.456, Speaker B: Of the hatch of the hash will must be exactly the same as the.
02:15:04.478 - 02:15:08.280, Speaker C: One that we compute in the smart contract. So here is the new accumulating.
02:15:10.700 - 02:15:17.680, Speaker B: And just to finish, remember that when Jordan.
02:15:17.700 - 02:16:16.790, Speaker C: And Jose explained the state machines, they explained that the state machines need to be sickly. So in order to finalize the execution, we need to be sure that the resistors that were set at the very beginning, they need to be exactly the same at the very very end. Okay, so here I would say we're just like finishing this execution. Okay, so here you have links of sources that you can check. As I mentioned, all the code is open source and it's available on GitHub. I also mentioned very briefly at the very beginning the difference between the state tree of the EBM, of the ZQBM, if you want to look further of the specification, and how to build, how we build the key of the mercury tree and so on. I give a talk last summer and you have the slides here if you want to check it.
02:16:16.790 - 02:16:21.190, Speaker C: Okay, that will be all.
02:16:21.560 - 02:16:23.924, Speaker B: Thank you very much.
02:16:23.962 - 02:16:25.600, Speaker C: I hope you enjoyed this session.
02:16:25.680 - 02:16:26.470, Speaker B: Thank you.
02:16:28.620 - 02:16:52.492, Speaker D: If nobody has any question, I would like to just to summarize, what we have seen today is just a language that's running on top of the ZK processor where we implement all the ZKVM. This language is an assembly language. It's quite specific. It has like, actually it's a language.
02:16:52.556 - 02:16:54.752, Speaker B: That does not compute things.
02:16:54.806 - 02:17:10.948, Speaker D: What it does is, well, it moves registers in a very low level and it ensures things when it's doing an operation. Actually, it's checking that the operation is valid. It's checking things.
02:17:11.034 - 02:17:11.524, Speaker B: Okay.
02:17:11.642 - 02:17:39.672, Speaker D: The language is a little bit different of the typical assembly languages, especially this beginning. This is because these registers, how you do the moves between the registers and how you load. The most important thing is this op register. This is an intermediary register. This is something that in each instruction you load. Okay, so you load something to this op and then you store what this op to some of the other registers. Okay, the other important thing is the hashing.
02:17:39.672 - 02:18:27.992, Speaker D: The hashing, the idea is quite a little bit the same. The idea is that you have a table of hashes. It's like another memory where you have all the hashes, and then you are just checking that a portion of this table matches with the other table. So for example, with this hash, with this string that has a string that can be variable size, with a few given hash, you can check that at a specific point as many bytes matches to this value. So you can check with the batches. So this is the way we have to compute hashes inside the program. The other instructions are quite trivial arithmetic operations.
02:18:27.992 - 02:19:12.404, Speaker D: Memory reads memory writes, storage reads, storage writes of the most typical unsourced, normal operations. And with this, we built all the ZKBM here, the starting and the ending. At the beginning you have all the, what is the public inputs of the circuit. Carlos said that they are already stored in the beginning. Actually, this is checked in the peel, in the pill. We are checking that the public inputs are set at these registers at the beginning and the public outputs are set at the end of the register. And from here we just compute, just don't know what exactly the same that geth does or that any ethereum client does just processing these transactions.
02:19:12.404 - 02:19:29.984, Speaker D: We are building this hash and this hash is what public input. What's a public output? And then we just match that. This hash is correct. Okay so yeah, just maybe going through the code is probably the easiest way here. You don't have to deal with just.
02:19:30.022 - 02:19:34.544, Speaker C: A code that's very explicit to that. But yeah, this is a little bit.
02:19:34.582 - 02:19:37.760, Speaker D: How we are building the ZKN.
02:19:38.120 - 02:19:39.364, Speaker C: I would say that's a little bit.
02:19:39.402 - 02:19:46.836, Speaker D: Different of how the scroll people does, but at the end we are doing more or less the same.
02:19:46.858 - 02:19:47.430, Speaker C: So.
02:19:50.040 - 02:20:01.960, Speaker D: At the end we are computing somehow the same in a different way but we're just emulating the ZKVM. Okay, so that's very much the summary.
