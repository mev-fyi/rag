00:00:21.830 - 00:00:28.394, Speaker A: So I guess we could get started. It's great to see you all here.
00:00:28.592 - 00:01:18.484, Speaker B: Bye. Okay, let me share the screen. I'm going to share. Okay, should I start grace or hechen? Are you seeing the screen by the way?
00:01:18.602 - 00:01:20.792, Speaker A: Yeah, I can see your screen. Yeah.
00:01:20.846 - 00:01:25.908, Speaker B: Okay, we should start recording or it is already recording.
00:01:26.084 - 00:01:27.928, Speaker A: Yeah, the recording already started.
00:01:28.094 - 00:02:09.110, Speaker B: Okay, nice. Then let me introduce myself. I am Jose Luis Munov. In fact, I am an associate professor at Polytechnical University of Catalonia, UPC, and an old friend of Jordy Valina, let's say. And currently I am collaborating with the Zeke IBM project. We have a project between the university and the polygon, by the way, here. There are also some of the people that is in the team at the university, like ector, I think is here.
00:02:09.110 - 00:03:18.860, Speaker B: And essentially we are a team that we are supporting the project by writing technical documentation, writing papers, and doing like pre audits and checking that everything is okay. So this is our main tasks today. I'm going to explain you how the system, some of the pieces that build our system, and we agree to use a common example between scroll and us, that is a Fibonacci series. And we're going to see essentially how to prove that computation about a Fibonacci series is correct with our model, which is mainly based on a state machine. And I'm going to explain what is a state machine in a minute. And then high Chen will do like the same, but for a circuit model based in hallow two. Okay, so I will try to do the explanation and then highlight whenever possible, the differences.
00:03:18.860 - 00:04:15.090, Speaker B: I would like to say also that you can interrupt at me at any time and ask a question live if you want. And I will also leave a little bit of room for questions after some explanations. Okay, so, yeah, let's go. And this is like, what I'm going to explain today is like the hello world example of proving something that is built in the model of a state machine. And if I knew I was the first, maybe I would put some differences, but maybe you are more used to the. Or, I don't know your background, but maybe you are used to the circuit model in which you have inputs and then gates, and then these gates are half outputs, which are the inputs of other gates and so on. Okay, so, yeah, this is like the circuit model.
00:04:15.090 - 00:05:18.108, Speaker B: And in the circuit model, you have several values at each stage of the circuit. And we can have more or more values here, less values here and less values here, and more values here. Well, the circuit is tailored to the computation that we want to do. Okay. Circuits are really nice and a very powerful way of proving stuff, but they have also, I mean, there are trade offs, obviously. Well, when circuits suffer more is when there are a lot of branches, because in the circuit, in general, you have to, or maybe hn can provide more insights about this, but in general, you have to unroll all the branches. And managing branches, ifs, force and so on, is more complex than in a state machine.
00:05:18.108 - 00:06:13.456, Speaker B: In a state machine, the state machine model is this model that you see here in which we have, like, in each step of the computation, we have the same number always of rows of values per row. Okay? And essentially the state machine. In a state machine, you change from one state to the next one and to the next one. And you always follow the same rules to change from one state to the next one. And in a pure state machine, in fact, we are modifying a little bit the paradigm. But in the basic paradigm of a state machine, you have only relationships between consecutive rows. Okay? You don't go farther.
00:06:13.456 - 00:06:56.888, Speaker B: Okay, well, this simplifies a little bit the way of building the constraints between these rows. Okay? So, yeah, this is the general idea of a state machine. And this slide is very important because it summarizes what we are going to see today. Today we're going to see how to prove the execution of a fibonacci. In particular, I choose the multiplicative fibonacci. Okay. Well, to prove the execution of this Fibonacci series, we need to build an execution trace.
00:06:56.888 - 00:07:31.464, Speaker B: The execution trace is a matrix. It's a matrix of values. These values belong to a field. It's a finite field. It's a number that's a finite number. And as I said, we have relationships between one row and the next one, or between each pair of rows, okay? And we can have, like, relationships between, for example, we have here a relationship between this value and this other value. And here we have a relationship between these three values.
00:07:31.464 - 00:08:12.772, Speaker B: I mean, the relationship can be between values of the same row or with the previous row, for example. And these relationships are repeated all over the time. We will see later that at the end, we have to do something to make this relationship also hold between the last and the first. I mean, the next row for the last is the first, in fact. Okay? So, yeah, we will see how to manage this. And then essentially we have the piece of code that generates the execution trace. In our case, we call it the executor.
00:08:12.772 - 00:09:05.160, Speaker B: Okay? The executor is the piece of software that builds the execution trace. And the executor can build different execution traces. I mean, the executor is building the execution trace of some computation, but we can do this computation using different inputs. If we change the inputs, then we have another execution trace of the same computation. Changing the inputs, some columns of the execution trace will change. Okay, so this type of columns are what? Sorry, what we call committed columns. Okay, these committed columns change from one execution to another execution of the same computation.
00:09:05.160 - 00:10:04.628, Speaker B: And the executions are different because we're providing different inputs. We have also some constant columns which do not depend on the input. I mean, they are always the same and these are constant columns. Or in the literature, probably you are going to find the name preprocessed. Okay, so we have also preprocessed columns, and our constraints or relations between these values can involve both committed and constant columns. Okay, in many solutions, the identities that the trace must fulfill, they are hard coded in the code. But in our solution, in the Polygon Sikaibm solution, we have a domain specific language which is called pill to define these identities.
00:10:04.628 - 00:10:55.884, Speaker B: So in fact, we are building one computation. We are building all the system for one computation, which is Zika. EBM is a state machine that is able to prove executions of the Ethereum virtual machine. But in general, the tools that we are developing could be used for other purposes and you could generate other types of computations beyond an EVM. It is true that we are building all the pieces to prove the EVM, in fact, but pill in fact is a general tool that you can use to build anything you want. As I said, we are building the sikh IBM. Okay, so yeah, these are the main pieces.
00:10:55.884 - 00:11:42.460, Speaker B: Here we have some inputs, we have an executor. The executor will create the execution trace, reading some inputs when needed. In the trace, we have constant columns and committed columns or variable columns. Okay, then what is next? We take the execution trace, take the pill, which are the relationships that this execution trace must fulfill. And then we put this inside of one of the other tools that we have developed, which is called Pillstark. Pillstark essentially takes the execution trace, takes the relationships that the trace must fulfill, and generates a proof, okay? Generates a proof that in general is succeed. I mean, it's small and fast to verify.
00:11:42.460 - 00:12:24.910, Speaker B: Well, we will talk about this. Talk is about giving more details about this process. Okay, but the takeaway is just if you want to take this slide, this is the summary. Okay, so then we need to start somewhere. And the typical way in which you start is the core of everything is designing the execution trace. We need to design our execution trace, how many columns we are going to have and which are the relationships between these columns. Okay, so this is the beginning of the process.
00:12:24.910 - 00:13:04.232, Speaker B: And then we build an executor, and then we put all this stuff into the pill start. Okay, so let's start creating this execution trace or defining this execution trace, which, by the way, is not going to be extremely difficult because the multiplicative Fibonacci is very friendly with the execution trace. I mean, yeah, we have, for other types of computations, we had bigger challenges, but. Okay, well, this is not going to be a big challenge. So, in fact, we are going to build the. You can build in many ways. In fact, I mean, this is an open.
00:13:04.232 - 00:13:41.670, Speaker B: The design can be very different. I think that in the first day I saw ye doing the Fibonacci with three columns, but in this case, I'm going to do it with just two at the moment. Later, we will see that we will need another one. Okay, so the idea is to create, to use a state machine. The state is defined by two columns or by two registries, and I call them a and b. Okay. And then I always have these two registries and they are evolving from one state to the other.
00:13:41.670 - 00:14:52.700, Speaker B: Okay, so then what we're going to put on a and what we're going to put in b, as you may imagine, since the Fibonacci, I mean, well, I didn't say anything about the Fibonacci, but a certain term of the Fibonacci, term x, I don't know, is always the term I of the Fibonacci is the multiplication in this case, because it's the multiplicative one of the previous two terms. Okay, I minus one times I minus minus two. Okay, so I need to do this multiplication. So I'm going to store here the values of the in a and B. In the initial state, I'm going to store the initial conditions of my multiplicative fibonacci. And then what I'm going to do is, okay, I'm going to move this value here because I need the previous, I mean, I'm going to multiply these two and store the multiplication here in b plus here. And then I'm going to move this here because I will need the multiplication again of these two.
00:14:52.700 - 00:15:40.888, Speaker B: Okay, so this is essentially the trick. So in state zero, I'm starting with two initial values, let's say two and one. And then what I do is I need to copy. And this is going to be a relationship appeal that we're going to in our case, we're going to describe this with pill. So, one pill relationship will say that the value of this registry in the previous state should be the same as the value in registry a in the next state. And the other relationship is essentially that the value of v is the multiplication of the two. Okay? So as you see, v is two because two times one is two.
00:15:40.888 - 00:16:45.300, Speaker B: So here, I don't know, b is four because two times two is four. So I copy here, and then here I store the multiplication. Okay, if you see, the relationships that we are using are this one. So the value of the a registry in the next state is the value of the b registry in the previous one, and the next value of the b registry in the next state. Better set is the multiplication of the two values of the previous state. Okay, then we have a bunch of values here, and we need to prove them. And in order to do the proof, and in a succinct way, we're going to do the proofs instead of relationships between values, we're going to do relationships between polynomials.
00:16:45.300 - 00:18:00.772, Speaker B: And we are going to interpolate these columns into a polynomial, let's say a of x. And then this is going to be b of x, and the values that we are going, I mean, a of x is a polynomial that is going to have some value, let's say value two, and this is the y, or the value of the polynomial is going to be two. This is the first value that I'm interpolating. And I'm going to interpolate in a special group, which is the famous group of root is a group of roots of unity, which essentially is a group of values. These values form a group and it's a cyclic group. So you start with some value, and then it's a modular operation all the time you are multiplying a main modulo, and then you go back to this one here. Okay, so it's a cyclic group, and we are going to interpolate in this cyclic group that has order or size is a power of two, because then we can do the interpolations in a very fast way using the FFT.
00:18:00.772 - 00:18:59.640, Speaker B: Okay, well, these are technical details about saying that we're going to take this column and create a polynomial from this column. Okay? And the procedure is to, we need to find, in our field, we need to find a group of roots of unity that is a power of two. And we do the interpolation in this group. Okay? So we are transforming our setting instead of values, we operate with polynomials. Okay? And we can express these are the constraints or the relationships that I have in my multiplicative Fibonacci series with. Yeah, let me, let me close the letter. I'm sorry, it's disturbing a little bit.
00:18:59.640 - 00:19:52.344, Speaker B: Okay, so here I am. This is the relationships between values, and then this is the relationship we're using these polynomials. Okay, I'm saying here that the polynomial v of x, it will be the same as the polynomial a of x, but, well, a of x but multiplied by omega omega, which is the root of unity, is the next root of unity. I mean, I am interpolating this value in omega zero, omega to the zero, which is one. I am interpolating this value in omega. I'm interpolating this value in omega square and so on. Okay, so remember that what I wanted to say is that this one is this one.
00:19:52.344 - 00:20:47.630, Speaker B: I mean, in all the rows, okay, this is this, this is this and so on. Okay, so this is a specialized data. I'm saying that a of x times omega, the next value of a of x, the next interpolated value of a of x is equal to b of x. Okay? And this is only valid at x equal to values of the group of roots of unity. Okay, so, well, this is the relationship expressed in our setting, which was an interpolation of these values in a group of roots of unity. And my other expression is this one here is the next value of b is the multiplication of the previous values of a and b. Okay, this is what we are saying.
00:20:47.630 - 00:21:34.476, Speaker B: Okay? And maybe when we are here, there is a special case. I don't know if everybody is seeing this special case. I want, for example, the first polynomial identity. This is going to be described in pill, by the way, in our first polynomial identity, I'm describing this relationship. I suppose that you see that there is a problem here, which is, well, this should be equal to, I mean, the group of root of unity is cyclic. So I should be the same as this one here. Okay? The next a is the previous is the first one.
00:21:34.476 - 00:22:15.720, Speaker B: But this is not true. I mean, this number is not this number. Okay? So we need to fix this. And we say that our state machine is not cyclic. In circuits in general, you don't need to enforce this cyclic behavior. I mean, you have your circuit and you enforce the relationship between all the gates and wires and so on, and that's it. But in a state machine, the identities should hold from one state to the next one, and the next state after the last one is the first one.
00:22:15.720 - 00:23:09.770, Speaker B: So we need to modify our identity so that this row here fulfills. Well, I mean, the identities should allow me to go from the last row to the previous to the first row to the first row, which is the next row of this one here. So we have a problem here. And because our state machine is not cyclic, okay, it's something that is a problem in state machines. It is not a problem in circuit based approaches. Well, for this we are going to use a trick that in fact everybody uses, which is introduce a new polynomial that it will act as a selector. In fact, okay, this is similar to how scroll and hello two, do this stuff.
00:23:09.770 - 00:24:15.410, Speaker B: To achieve the cyclic behavior, I'm going to introduce this new column, which is column c. And it will be zero everywhere except in the last row. And we will allow the cyclic behavior by modifying a little bit our equations. And essentially I'm saying here that, okay, this should be, this one if c is zero. But in the last one, we don't need to check this, okay? In fact, what I'm going to say is that the next value of a should be a zero, for example. Okay? And this is the modification of, this is how I need to modify my identity, okay? I will say, okay, the next value of a is going to be the previous value of b if c of x is zero, because then one minus zero is one. So these things whole.
00:24:15.410 - 00:25:08.924, Speaker B: And this is when z of x is zero. This part here cancels and we are not taking into account, but when z of x is one, then we are not going to check this. I mean, we are not going to check this thing. What we're going to check is that the next value of a is a zero, okay? So in the last row, what I'm going to say is that the next value of a is going to be a zero, which is two. In this case is the initial condition, okay? So we arrange our identity so that we achieve this cyclic behavior and the same for the other one. Okay? This part here is our previous identity. And then this part here is changed.
00:25:08.924 - 00:26:32.390, Speaker B: I mean, this part here is when z of x is one, then we enforce that the next value of b is the initial condition v zero. Okay, now everything works, okay? Yeah. So we have our constraints here. For example, these two constraints that I'm defining here, they are defining how we go from one state to the next one. So these are called transition constraints, okay? By the way, this is defined by the people from Star wars, okay? This is the jargon that they use for these type of constraints. And we can also enforce some other constraints, which in this case would be that the initial conditions, they're going to be 23 and 46. So here when I enforce the initial value to 23 and 46, we, I need to put it here on, on the, on the identities.
00:26:32.390 - 00:27:28.490, Speaker B: And then I have like these identities which are half transition, half boundary constraint. A boundary constraint, by the way, is a constraint that enforces that one of the values is one of the squares of my execution trace has a certain value. So in this case, if I put a 23 and a 00:23 and b 00:46 I'm enforcing the initial values of a and b. So these constraints are like half transaction, half boundary. Okay, we're going to see how to, in fact, we are going to change this setting a little bit in just a moment. Okay, so I can have like pure transaction, pure transition constraints, which are just defining the transition from one state to the next one. I can have pure boundary.
00:27:28.490 - 00:28:44.946, Speaker B: And our previous constraint, in fact, were like transition plus boundary because we were defining the two things as you see here. Okay, in general, we don't have this type of transitions of constraints or identities because in the general settings, you only need to define transition constraints and some specific boundary constraints. The problem here is that, okay, in my identity, I am defining the initial values of the fibonacci. But in general, you will not prove something like that. I mean, the initial values of our fibonacci, I mean, this is not really important. In general, what you will prove is that the fibonacci of a certain term is a certain value. So typically we will not give these initial conditions, but we will check is that the value of a certain row and column is a particular value, like here.
00:28:44.946 - 00:29:56.122, Speaker B: Okay, so essentially we are not going to include the initial conditions in our constraints. So we remove the part of the identity that fixes the initial values. So if we remove this part, you can go to whichever initial condition you want, and we're going to remove this one here. And now these are pure transaction, pure, pure transition constraints, which is more typical. And then we are going to put a boundary constraint saying the value of a certain row should be whatever. For example, I would say that the value of a at this root of unity, which is the, I mean, in, in my trace is the value 1024, because it starts in zero. I want to enforce that this value is, well, I computed, by the way, starting with some inputs, I computed this value.
00:29:56.122 - 00:30:41.170, Speaker B: Okay, well, I want to enforce that. I want to check these three constraints, which means, okay, you have computed a multiplicative Fibonacci series. I don't know which initial values you choose. But you have computed this Fibonacci series and the value of 2000 in this root of unity is this one. Okay, I want to create a proof for you about this. By the way, all my operations are in certain field. The field that we are using is a Goldilocks like field with a prime of, it's about 64 bits.
00:30:41.170 - 00:31:55.818, Speaker B: Okay? So this is the field that we are using in the Zik ibm of polygon is with this prime. Okay, we borrow this field from our friends of polygon, zero. Okay, so this is the prime that we are using. Okay, so all my polynomials will have, and all my execution trays will have values in this field. Okay, so the operation that I'm doing is multiplication and then modulo this field, this prime, and then multiplying and modulo this prime, and this is the number after doing 1023 operations, multiplications, and a model of p, starting with some conditions that I'm not showing here. Okay? In fact, I will show you later which were these conditions, okay? And these are the three constraints. Now, what we define is a language which is the pill.
00:31:55.818 - 00:33:02.790, Speaker B: The polynomial identity language is just for describing these three identities, okay? So in fact, you are not going to write this identity. It's not written like this. We write this equation or this identity like this, okay? All our identities should be our expressions equal to zero, and they are equal to zero in the roots of unity. Okay? So here I'm saying that a of x minus, this value should be zero. This should be zero when x is equal to omega to the 2023. Okay, well, it's technical stuff, but we write this like this. Oh, sorry.
00:33:02.790 - 00:34:20.892, Speaker B: Okay, so now I should perform my computation. Well, in fact, the previous number that you saw is just doing the multiplicative fibonacci using these two values, okay? If you start multiplying these two 1024 times and doing modulop, you will get the number that we saw before. I am putting you here, a little bit of a small javascript program to do this. Okay? Okay, so up to now it's a fast explanation of how these things work. Maybe we should, but I think it's enough to understand that we need to define the identities in our trace. So our trace was simpler. It had like three columns, the column a, the column b, and the column c, the column a and b.
00:34:20.892 - 00:34:56.740, Speaker B: These two are committed, the column z, remember, that is zero everywhere and one in the last one. And C is not going to change whichever input values I put. So this is a constant or preprocessed column. So in my execution trace I just have three columns. Okay. And the first thing is that I need to prove the computation. I need an executor that creates, in the case of the Fibonacci, is just these three columns.
00:34:56.740 - 00:35:25.600, Speaker B: And depending on the inputs, the executor will need to recompute a and b each time. But C is going to be always the same. Okay, so this is the executor. Well, this is the code of the executor is very simple, essentially. Okay. It's just creating a, b and C is going to be fixed. I mean, it's going to be zeros everywhere, and one, and the last.
00:35:25.600 - 00:36:16.850, Speaker B: Okay, by the way, I'm going to provide you a repo with the software with some test that you can do and test everything that I'm going to explain today. Okay, so, perfect. Then I started my process defining the trace, which is the shape of the trace. How many columns, these columns are committed constant. Okay. Then I defined the pill, the relationships between these columns. And then I created a piece of software that creates this trace, this execution trace, which in our project, we call it executor, and then starts the process of proving, proving the stuff.
00:36:16.850 - 00:36:53.540, Speaker B: So the executor essentially gives me a matrix of values. Let's say that we have this execution tracer with these four columns, by the way, before starting the proving process, this is a good moment to maybe ask you if you have any questions. Let me see if I can see the chat or whatever. Grace, is there any question in the chat or something like that?
00:36:55.270 - 00:37:01.134, Speaker A: Yeah, I'm here, but we haven't received any questions in the chat.
00:37:01.182 - 00:37:01.890, Speaker B: Okay, perfect.
00:37:01.960 - 00:37:06.980, Speaker A: I don't know if anyone wants to unmute and ask a question.
00:37:08.550 - 00:37:11.810, Speaker B: If not, essentially, we're going to prove now the system.
00:37:11.880 - 00:37:16.330, Speaker A: Yeah, thank you, Jose. He has been very clear so far.
00:37:16.480 - 00:38:13.526, Speaker B: Okay. I had to explain a little bit past all this stuff of the roots of unity, the cyclicity and so on. But yeah, you can check it, maybe after. Okay, so then how the process of proving this execution trace works? As I said, we've developed this tool here, which is called Pillstark. In Pillstark, you provide an execution trace, you provide a pill definition. The pill definition contains several things, mainly some names, names for the columns, that each column is going to be transformed in a polynomial. But yeah, we need to provide names for these polynomials, in this case, AbCde.
00:38:13.526 - 00:38:52.934, Speaker B: But in the real CKBN, you will see other more meaningful names. So it provides also some name spacing. I mean, you can create several namespaces and polynomials can belong to different namespaces. We provide the execution trace, the pill. This can be more complex. We can provide even different pieces of the execution trace and so on. But in this simplified example, in this simplified example, I'm just providing an execution trace with just three columns, while in fact, the one that is constant is this one here.
00:38:52.934 - 00:39:49.130, Speaker B: So I'm providing this execution trace. To some extent, the process of generating the proof is quite automatic. With Billstark, this process is automatic, but we're going to see how it works. But as a software tool, your main work as a developer, let's say, is just define the execution trace, define the peel, implement your executor, and then you provide this to the pillstarg, and then this process is quite automatic. Okay, but let's see what happens inside. The first thing is that the pill, Stark, it will create polynomials from each column, okay. By interpolating in the roots of unity.
00:39:49.130 - 00:40:29.542, Speaker B: Well, in fact, yeah, interpolating in the roots of unity in some domain, in fact, that we are going to call it G. Okay. In fact, well, it is not exactly roots of unity, but doesn't matter. It's just a technical detail. But we are interpolating our values over an interpolation domain and getting polynomials. Okay, then the next step is that for each polynomial, we create a cryptographic representative of each of these polynomials. Okay? Yeah.
00:40:29.542 - 00:41:54.222, Speaker B: I know that people that are from cryptographers will say, what do you mean cryptographic representative? It's a commitment. Okay, so we create a thing that is smaller than the polynomial, and it is a perfect cryptographic representative of this polynomial. Okay, so we create these representatives, which are going to be polynomial commitments, and then we prove, this is, yeah, the first day said more or less the same. And then we're going to prove our identities with these representatives in a random point. And if you prove an identity in a random point of a big field, this means if the identity holds in a random point of a big field, it means it holds everywhere, because the probability that this doesn't happen is overwhelmingly small. Okay, so this is the strategy that everybody uses, by the way. So the representatives are created with some polynomial commitment scheme, and then, as I said, the verifier will provide some random number in the field and say, okay, provide me the evaluation of your polynomials.
00:41:54.222 - 00:42:23.482, Speaker B: And then I check, well, I have a proof of that. The values at this random point are okay. And then I check my identities. Okay, here, the two projects that you are going to see in these talks, we are using different approaches. Scroll is using Kate or key. Gc is better say. I mean, Kate is the first one, but there are other people.
00:42:23.482 - 00:42:44.146, Speaker B: So let's say then. But we're using a fry based approach. Okay. We are using a different polynomial commitment scheme. Okay, and then, well, let me show you a little bit. Well, let's finish this. And then I will show.
00:42:44.146 - 00:43:18.300, Speaker B: You better say. I will show you a little bit about how fry works in a high level. Okay, well, this is the lemma that says that checking a random point is enough. And then I check in my random point that all the identities hold. Okay, well, we still have a minor technical problem. That is that. Okay, my identities are only valid in the interpolation domain in H.
00:43:18.300 - 00:43:52.690, Speaker B: But I want to check in a random point of all the field. Well, ye also talked about this the first day. And. Yeah, essentially, what we need is to check these identities. But I need to check that these identities can be divided by Z of H. Well, I use C of H as the polynomial. That is zero in all the roots of unity.
00:43:52.690 - 00:44:24.770, Speaker B: So. Well, it's a technical stuff to just be able to use the polynomial commitment scheme. Okay, you have to check this, divided by this polynomial. Okay, so I need to divide all my equations, or set in another way. I have to multiply all the identities by, say, of h. And then this check is done in any value of the field. Okay, so x belonging to fp.
00:44:24.770 - 00:45:03.246, Speaker B: So then the verifier takes one random value. And then gives me all the values of the polynomials that I need to check to do the checks on a random point. And if there the questions hold, then it means it's okay. Okay. Yeah. As I said, again, this is a very quick talk, and it's a high level talk. Okay, so then, which proving system do we have? I mean, we have many.
00:45:03.246 - 00:45:37.190, Speaker B: Here I put the proving systems that are more related with our setting. Well, essentially, we are using fry. Okay, let's jump this one, and let's explain how fry works. Okay, for people that doesn't. I mean, maybe some of, you know, Kate or Kate was explained a little bit the first day. So I'm going to explain in a high level how fry works. Okay, so I have here my polynomial.
00:45:37.190 - 00:46:00.630, Speaker B: My polynomial evaluated. I mean, my polynomial is just a set of values of the computational trace. Okay, and then how fry works. Well, the first thing is that I have my polynomial in coefficients. I mean. Sorry. I have my polynomials in evaluations.
00:46:00.630 - 00:46:30.970, Speaker B: I have evaluations of the polynomial. Of my polynomial. The first thing is that I need to interpolate this into. These are values. I need to obtain a polynomial in coefficients. So I interpolate the polynomial of the trace that is expressed as a set of values, as a column, and I interpolate this. And then once I have it on coefficients, then I expand.
00:46:30.970 - 00:47:11.666, Speaker B: The first step of fry is expanding this in our case, by the way, we expand by two. So we have more values describing my polynomial. Okay? And then, in fry, what we do is merkelize. We create a Merkel root. We create a hash tree with all the values. And I obtain, like, the first root. Okay? And then I start a process of doing what is called random faults of the polynomials.
00:47:11.666 - 00:48:21.626, Speaker B: I mean, I take this polynomial, and then, using not too many technical details here, but doing an fft like equation, I just create, like, a smaller version of the polynomial that has half of the size, and the evaluation domain is also half. Okay? And to create this polynomial, this smaller polynomial, the verifier sends me one randomness, and then I commit to this root here. And then the verifier again sends me another randomness, and then I create another smaller polynomial, and so on. Okay? And this is the way, what we're doing here is committing to a big polynomial, and then to a smaller polynomial. Smaller polynomials that are related. All of them are related. And this is what it is going to provide us, the soundness of the system, because then this is the first phase, which is the commitment of the polynomial.
00:48:21.626 - 00:49:14.590, Speaker B: And then in another phase, when I need to check that the polynomial is correct, then we create some. I mean, we have to pass some random queries here. And it says, okay, give me the value of this value here, this value here, and this value here. And I need to check that these three values are consistent with other three values here and with other values here and so on. Okay? This is a very high level, but we check the consistency here, and then we are proving that. In fact, now I realize I didn't say what we're going to prove. We're going to prove that the degree of the polynomial is less than a certain number.
00:49:14.590 - 00:50:00.000, Speaker B: Okay? And this can be translated into a setting of opening, of obtaining the value of the polynomial in this value. Okay? The nice thing of this system of Fry is that we just need to do hashes. I mean, the only primitive, cryptographic primitive that we use is a hash. And this is easy to creating. This doesn't have any trusted setup or any strange primitive that it is easy. It's difficult to implement. This is just a hash function, and it has benefits.
00:50:00.000 - 00:51:11.250, Speaker B: The main problem is that proofs are bigger and big compared to Kate or plunk. Or compared to Kate, essentially. Okay, so I will tell you later what we're going to do. Yeah, I'm going to tell you here, by the way. Okay, so the pill start, essentially does this process of taking the computation trace, interpolating the polynomials, then evaluating these polynomials in a bigger domain, then creating some other polynomials that are related with this bigger one, and then check that all the stuff is consistent. And this finally can be used to prove that the polynomial has the evaluation of the polynomial at a certain random point is some value. And then checking our identities in this random point, we are checking that the computation is well done.
00:51:11.250 - 00:51:53.550, Speaker B: Okay, this is the high level of all the process. Well, all this stuff missing, maybe in this high level description, is that to do the proof, I mean, the fry creates quite big proofs. Okay, so here, as George explained the first day, we are using recursion techniques. Okay? So, in fact, our state machines. In fact, we have several. Our state machines generate like, quite a big proof. But this proof is verified.
00:51:53.550 - 00:52:36.602, Speaker B: The verifier of the fry verifier is doing these queries and checking these Merkel proofs. And it's doing all this stuff. What we do is create a circuit. Well, in fact, we create a circuit that validates this proof. And then we prove that this is proving this one correct. And we use recursion here so that the final proof is much smaller. Okay, in the, in this talk, in fact, I'm going to give you some repo.
00:52:36.602 - 00:53:27.120, Speaker B: Here you have the repo. In this directory of the Zika, IBM, Docsoft repo, you can find this example that we were talking about, the MM multiplicative Fibonacci state machine, the non recursive version, it generates just a fry proof for everything. Okay, I'm going to quickly show you the software so you can play a little bit, and I'm going to run it to see how it works. But essentially, you will see not much. You can take a look at the software, which is a nice way to learn. And what else? Because from now, okay, we prove a fibonacci. But this is like a hello world example.
00:53:27.120 - 00:54:27.810, Speaker B: It is quite far from the EVM. So which are the next steps? The next steps is that the transition between one state and the next one is going to be driven or it is going to be done according to an instruction. Okay? So here we have some instructions that say how to change from one state to the next one. Okay? And we are going to go from this simple executor that all the logic of the Fibonacci is inside the executor. Okay, we're going to move to this other paradigm in which the executor in fact creates the execution trace according to some instructions that are given by a program. And this program is what it is. Program in our assembly language, it is called Zikaiyasm.
00:54:27.810 - 00:55:27.126, Speaker B: In the first day that Jordy did like a general overview of everything, he show a little bit of this assembly. Okay, this assembly is just a program that the executor is reading. And as it is reading each line, it reads a line of an instruction and then creates one row of the execution trace and so on. Okay. And from time to time it needs inputs. So then it reads the inputs and completes the row. Okay, on the next session, which is going to be Monday, from Polygon, Carlos, which is here, by the way, Carlos Matayana will come and he will explain you more about this part here, about how it is built, this program.
00:55:27.126 - 00:56:04.260, Speaker B: And essentially this program, what it does is interpret all the transactions and execute all the opcodes. I mean, generate an execution trace that proves the correct execution of each code of each opcode of each transaction. Okay. Okay, so now let me. Yeah, let me just run the example. Okay. We're not going to have much more time than running the example.
00:56:04.260 - 00:56:22.670, Speaker B: Let me stop sharing this one and share this one. Okay, Grace, you're seeing the screen.
00:56:23.840 - 00:56:25.644, Speaker A: I see it all.
00:56:25.682 - 00:56:59.972, Speaker B: Good. Nice. If you go to the link that I, by the way, I will provide all these slides, you will have them available. And if you go to the link, which is essentially the Zikibm docsoft. If you go there, inside you will find the multiplicative Fibonacci state machine with the non recursive proof, which is the simplest possible proof using fry. And you will find all these files here. Which are these files? Well, let's start with the pill.
00:56:59.972 - 00:57:53.220, Speaker B: So, this is the pill for our Fibonacci state machine. So it's just a constant polynomial, that is last instead of c, I call it here is last, which is and one when it is last, then we have two polynomials, a and b. Well, the pill enforces that. Well, we create an intermediate definition here called ab, which is the multiplication of a and b. And then our transition constraints, which should be familiar to you, which is the next value of a should be the previous value of b, except in the is last. Here we are not checking anything. And the next value of b should be the multiplication of a and b, except in the last row.
00:57:53.220 - 00:58:43.704, Speaker B: Okay? Yeah. Currently the pill doesn't allow you to multiply three polynomials. You can only multiply two polynomials. So here I just create this intermediate definition, and then I define the boundary constraint, saying that the value of a, this is the way in which, instead of putting here a number, instead here of putting a certain number that I want to prove, what I say is okay. In the trace, you will find the value of a. So, put here the last value of polynomial a, as the boundary constraint. That is, checking that a, at the last value will have this value here.
00:58:43.704 - 00:59:27.124, Speaker B: So this is the pill, essentially descriptions about which are the relationships that the execution trace must fulfill. And also, we are giving here the size, the number of rows of the execution trace. Well, this is like a DSL, a domain specific language that you can compile with pilcom. I just provide you the compiled version of this. But if you see, this is much easier to be read by the prover. Okay, so we compile this to this JSON parsed version. Then what else? We provide the input for our Fibonacci computation.
00:59:27.124 - 00:59:51.410, Speaker B: So these are the initial values of our fibonacci. And then before going to the. Well, the executor. The executor is just creating the constant polynomials and the execution trace. I mean, it's building all the values of a and b, multiplying, essentially. Okay, so, well, we are doing these multiplications model op. So we are doing these operations in the Goldilocks field.
00:59:51.410 - 01:00:22.968, Speaker B: And then, well, the proving stuff is configurable in fry. You can configure many things. You can configure. How big is going to be the expansion of the first polynomial? How many steps do you want to. I mean, in the example, I just half each polynomial. But you can do steps with bigger compression, let's say. I mean, you can configure many stuff.
01:00:22.968 - 01:00:51.280, Speaker B: And this is configured here. Okay, this is the number of bits of my polynomial in the trace. As I said, I'm expanding by tools and the valuation. These are the number of queries, these random queries, to check that the opening is correct. And, well, I'm doing the hash, which type of hash I'm doing. In fact, it says here, goldilocks. But what we are doing here are Poseidon hashes.
01:00:51.280 - 01:01:22.504, Speaker B: And then how many steps, in fact, we do like three. We are commit three roots of three different polynomials. Okay, well, essentially, this is stuff for the fry. Okay. And then the big one, and I'm finishing is this one that essentially reads all the configuration here. All the configuration and essentially generates. It's doing everything here.
01:01:22.504 - 01:02:01.680, Speaker B: It's calling the executor to generate the trace. And then it's doing the setup which is creating the Merkel trees and evaluations of the constant stuff. And then here we're generating the proof, and here we're validating the proof, and if everything goes okay, we should see valid proof. And well, this is what I expect to see. So you can do this with NPM run proof. Wow. Let's see a little bit the output and with this I'm going to finish.
01:02:01.680 - 01:02:39.470, Speaker B: I think there's no space here. Here, bad thing here. Yeah, you need to install. I don't have installed here, sorry. Oh, it's a Javascript mini project. So yeah, you have to install and I have node models here. And then NPM run proof.
01:02:39.470 - 01:03:19.680, Speaker B: And here you will see how it starts generating the trace, then it's creating all these Merkel roots and then doing the queries. And then it checks that everything is okay and says okay, the proof is valid. Okay, well the thing here is that you take a look at this code with some comments and some nice names for the variables. So I hope that you could understand all this. Okay, well, this is just an hour. It's just like all the system in a general way, but I hope that gives you the picture of how it works internally. Okay.
01:03:19.680 - 01:03:36.420, Speaker B: And now, sorry hitchen, I don't know if we have a little bit of time for questions. I'm five minutes seven minutes late, but we started five minutes seven minutes late anyway, so it's just an hour, I think. Okay, any questions?
01:03:38.390 - 01:03:57.094, Speaker A: I put a message to see if anyone had questions, but I think we can then go to hajin immediately because I don't think anyone put it if we have time. I do have one question. So regarding the, you said basically that.
01:03:57.132 - 01:04:06.846, Speaker B: Peel doesn't allow to multiply more than two polynomials together at once. So this means that you cannot have.
01:04:06.868 - 01:04:20.498, Speaker A: Any polynomial with an expression degree bigger than two, or you can then in another constraint, multiply, multiply the resulting polynomial by another one and keep pushing the degree until you extend it to, I.
01:04:20.504 - 01:04:47.178, Speaker B: Don'T know, whatever you. Yeah, it's the second thing that you say. I mean, we can have expressions with more than three polynomials, but then we need to split them in the current version. By the way of pill, we are thinking in changing this. Okay. It's a matter of if you let your identities grow in degree, probably, I don't know. How are you doing this in a scroll? Maybe you are letting your expression grow.
01:04:47.178 - 01:05:18.440, Speaker B: And then at the final step, since you need to commit to polynomials of degree n and if your expression is three n, then you cut this in several polynomials there. In the current version of pill, we cut this at this stage. At pill stage. But this is something that is in discussion. Maybe we are going to change it. It has pros and cons. But currently, if you need a degree three expression, you need an extra constraint, basically.
01:05:18.440 - 01:05:20.840, Speaker B: You need an extra constraint, basically.
01:05:21.290 - 01:05:23.814, Speaker A: Okay, thank you.
01:05:23.852 - 01:05:28.118, Speaker B: Thank you very much. You're welcome. Yeah.
01:05:28.204 - 01:05:44.030, Speaker A: Thank you. That was excellent. And how does it compare to. Hello. I think this is very similar, besides the polynomial commitments. But what is opened by the polynomial commitment? That is the same. It's a vanishing argument.
01:05:46.690 - 01:06:12.386, Speaker B: Let me see if I understood your questions. You're asking first how this solution is different from Hallow two. Well, in fact, it is different because our computation model is a state machine. If I'm not wrong, Halo two is more secret based. Halo two, the commitment scheme is based on. Based on bulletproofs and this inner product. And we are using fry.
01:06:12.386 - 01:06:30.300, Speaker B: So this is another difference. And what else did you ask me? Sorry, the other question was. I mean, these are different. Scroll is a hello tool, but they are changing the inner product by Kate. Yes, but it is also.
01:06:33.330 - 01:06:50.900, Speaker A: The question, what is opened from the polynomial? You have one polynomial per commitment, and then you have one vanishing agreement. And you open all the columns and open the vanishing agreement once. That's how it works.
01:06:51.430 - 01:07:32.286, Speaker B: Yeah. We open just at one random point. And we do like a general polynomial with everything, mixing all the polynomials. We mix all the polynomials, identity as usual, with some randomness and powers of the randomness. And we open just in one point. But to open in just one point, we need to do several queries in Fry to check that the opening is correct. In fact, since we are doubling, since our polynomial is expanding to twice, we are doing currently 128 queries, which makes the proof quite big.
01:07:32.286 - 01:07:41.300, Speaker B: And then it is already implemented some recursion step to decrease the size of the proof. I answer you?
01:07:42.150 - 01:07:54.120, Speaker A: Yeah, I think so. With twice expansion. It's because you can do only a multiplication between two polynomials. No, it's different.
01:07:55.130 - 01:08:30.082, Speaker B: The twice is configurable, but you can configure it. We don't have a clear idea of. The thing is that if you expand more your polynomial, it means you have more points. We are doing like the smaller possible. Because if we expand too much, then we have to deal with a lot of values. And we prefer to expand the minimum, which is twice, and then do more queries. But there are some trade offs that we still need to check.
01:08:30.082 - 01:09:00.406, Speaker B: Okay, here I'm saying that you have a polynomial. In this case, I have a polynomial of two to the ten. So 1024. And the extension is twice because now we are going to 2048. But you can configure it anyway. But to be secured, then you need to do more queries. Okay, this is just a simple example, but these are the trade offs of fry.
01:09:00.406 - 01:09:01.020, Speaker B: Okay.
01:09:04.850 - 01:09:06.030, Speaker A: Thank you, Jose.
01:09:10.930 - 01:09:25.810, Speaker B: Thank you, Ektor. Okay, give me the floor. Yeah, let's give the floor to Haichen and. Okay, thank you so much. And you can contact me for any question or whatever. Let me stop sharing.
01:09:28.470 - 01:09:35.878, Speaker A: Okay, thank you. I'm sure Hai Chen is going to put everyone very clear about all these differences as well.
01:09:36.044 - 01:09:41.500, Speaker B: This is stopping the sharing, I think. I cannot. Yeah.
01:09:43.550 - 01:09:44.406, Speaker A: Okay. It stopped.
01:09:44.438 - 01:09:45.660, Speaker B: Yes. Okay.
01:09:48.270 - 01:09:57.638, Speaker A: So you guys can see my screen, is that right? That's right. Okay, cool. Good. Okay, cool. Thank you. Hello, everyone. I'm Hai Chen.
01:09:57.638 - 01:10:31.830, Speaker A: Franco. So today I'm going to, on the other side, talking about how to build a Fibonacci circuit in the halo two. So last time, I think year talked about the halo two or the plunker arithmetization. So you have in the front end is a big giant, like the two dimensional matrix where you have different columns and then you have different rows. So in each column there are four different types of columns. In the hello two. In the first color is.
01:10:31.830 - 01:11:07.534, Speaker A: The first type is advice column. So that you can use these columns to put in any private inputs all of the witness data like you want to put. These are all the advice columns you're going to put. And then the second type of the column is called instance columns where you use to put any public inputs. You can have the one public input column or like multiple. All of the number of columns are all configurable in the hello tube. And then the third one is the fixed columns where you have the constants.
01:11:07.534 - 01:11:58.858, Speaker A: You could put any constant numbers into those fixed columns. And then the lookup tables, usually it's a fixed value, like a pre compiled lookup table. So you can then all put into the fixed columns. And then the last type of the columns are the selector columns, which are usually used to control any custom gates. And then all the lockups, you can all use those selector columns to control those things. So as you can see, the first two types of columns, they are going to vary over each proof and each proof instance. So every time you have like, if you have different pop inputs and output, then you will generate a different advice column like the witness in the advice columns for the last two type of the columns.
01:11:58.858 - 01:13:11.094, Speaker A: These are part of determined, so it's part of the circuit configuration can be preprocessed and then storing the verification key or proving key so there's not going to change over the different circuit instance. So when writing the circuit in the hello two right now, hello two doesn't have any DSL front end language, dsls for writing the circuit. So everything you're going to write the circuit is using the hello two APIs, and it's all defined in the rust like it's a rust framework. And you can use the data structures and API provided by the hello two to configure your circuit and then to filling your witness, and then also calling the proverb to generate proof and then also to verify your proof if it's correct or not. So that's like everything is going to be in the rust. So here a few different data structure concepts, which we have is that this is like a few data structures you're going to use to define the different type of columns, as I mentioned before. So it's all done with the column, but with different types.
01:13:11.094 - 01:14:08.190, Speaker A: And you can see like if you put advice into here and then this is an advice column, and then if you put an instance here, then it becomes an instant column and so on and so forth. The selector is like a subtype of the fixed column, but you have a syntax sugar called selector. And then the table column is also kind of a syntax sugar. It's still like a part of the subtype of the fixed column, but it have a different name called a table column. So to create a column in the halo two, it's mainly you're going to interact with this struct called constraint system, and it provides a bunch of the APIs you can use. Example, if you call the advice column, then it will give you create a column with advice, and then fixed column to create a fixed column, and so on and so forth. So I can see this is quite straightforward.
01:14:08.190 - 01:15:14.798, Speaker A: And then here there's slightly like the nuanced APIs, one is called selector and one is called a complex selector. So there's some small difference between the selector and the complex selector. So the selector means like it can be only associated with one custom grade and they're not going to be shared across different custom grades. And also it cannot be participated into the lookup argument. But the complex director is a more general way, like you can use that in any expressions, any constraint cascades or lookup argument inside that. So usually most of the cases in the ZKE event when we develop the ZK event circuits becomes a little bit more complicated. So most of the time we're using the compact selector, but the selector, why the halo two still have the selector API? Because there's like one small optimization did in the Halo two prover is like if you're only using this is kind of simple selector, then it can combine multiple selector into a single column.
01:15:14.798 - 01:16:08.850, Speaker A: So I can save a few number of columns. So you can use like a tax system to replace the selector. And then there's a few things like the other APIs provided also by this constraint system struct inside the halo two. The first one is like you want to enable the permutation check. As I remember, the permutation check helps you to connect between different wires, like they can connect from one row to another row. So you're going to enable some permutation check across different cells that you're going to copy from one place to another place in the circuit. So what you're going to do is you need to explicitly call the enable equality this API and apply another input to this API is a column.
01:16:08.850 - 01:16:59.486, Speaker A: So that means once some column is going to participate into this permutation check, when you configure your circuit, you need to explicitly call that enable equality on this column so that it knows certain values in this column will be copied from other columns or maybe copied to some other column. So this is like the one thing that you need to call this API to call. And then the second thing is how to add a custom gate. So this is also another API provided by the constraint system called the create a gate. So here you only need to provide two things to this API. One is the name of this gate, so that can be used for debugging to know which gate. If certain things like this constraint doesn't satisfy, you know the name of this custom gate.
01:16:59.486 - 01:17:43.906, Speaker A: And then the second thing, which is a function like a customized function, you are going to define yourself. This function only need to return a list of constraints that include inside this custom gate the constraint. Here you can just think of like as a polynomial identities, which is kind of similar to pew. But here every custom gate you can have a list of number of the constraints polynomial identity. Here it could be one, or it could be many, like the constraints associated with one single custom gate. And then here also the halo two doesn't limit the degree of those constraints or polynomial identities. It's kind of basically a trade off.
01:17:43.906 - 01:18:25.680, Speaker A: If you use like a lower degree of those constraints, then the blowout factor in the extended field will be smaller. But if you're using higher degrees then the broad factor for your extended field will be higher. And then in the final, the quotient polynomial, you then need to truncate them into multiple, if you like truncate farm for four and degree polynomial identity. In the final end you need to truncate into four n degree like degree of n polynomial identities. So you're basically ending with four like the final polynomial constraints in the end. So this is kind of like trade off. You can all play with the halo two.
01:18:25.680 - 01:19:28.846, Speaker A: And in fact we realized when we're developing the ZKVM, sometimes the lower degree can lead to smaller memory usage and also faster proving time. Because sometimes if the degree is too high, then you need to use a very large ifft on the extended field so that it causing significantly slower the proving time. So we will sometimes break down higher degree polynomials into multiple lower degree polynomials to automatically reduce the degree of those constraints. And then the last API I'm going to introduce is add the lookout argument. So here, this is also one API provided by the constraint system I mentioned in the beginning. So you can call this lookup and then you also give like a name and also like a table map. So here this function is that, it's also another function you need to define.
01:19:28.846 - 01:20:12.094, Speaker A: It returns a list of tuples of the query expression and then the table column. So why it's a vector. So if you're thinking like if you're looking up like one column, like one expression to a single column, for example, let's say ring check, you only check a cell. If you want to check like a cell. Let me see if I can enable. If you want to check like inside one column, there's one column. If you want to check one cell like that, and then there's like a range table, say like it's a, this is a, I don't have a pencil, so it's a range table.
01:20:12.094 - 01:21:07.374, Speaker A: Like if want to check if it's belongs within to this range, then just return this cell with this range column here. So this is like a very simple lookup. So just check like the range, check for this cell. But in certain cases, if we want to do some binary operations like the XL operations, then you have the three inputs, you have like three columns, you have at least three expressions. So you have a b and then axor B and you want to check if this is correct. So what you're going to do is you also pre compile an excel table, also with three columns. So this is an excel table, right? So you also have three columns, which is all possible, like the input of a and all possible input of b.
01:21:07.374 - 01:22:01.022, Speaker A: And then this is the result you pre compile, which is a, x or b. Now, like what you're going to do, this is column a. Let's put a CA and a CB, and this is called a c out. So now inside this API, what I'm going to do is you need to provide a vector of the a cell. This is a cell will be corresponding to the column a inside the lookup tables. And then the next tuple will be the b cell with column b, and then also the c cell with the column output. So you are going to, so this is like a tuple, allows you to do multiple elements.
01:22:01.022 - 01:23:04.202, Speaker A: Like you can look up a tuple within multiple columns inside the lookup tables. That's why you can return a vector of this tuple here. Sorry. Now, okay, so this is like the, so, but notice like here, one thing we notice here is that this table column, like you can only provide the fixed values. So the table column, remember the table column is a subtype of the fixed column. But when we design the ZKe EVM, sometimes we found like we not only want to look up into a fixed column, we want to also look up into an advice column, which you can also vary over the time of proof. Example, the memory operations can be all put into lookup tables, so that inside your main circuit you can easily check whether a stack or memory operation exists in certain lookup tables.
01:23:04.202 - 01:24:16.570, Speaker A: So those lookup tables cannot be predetermined before you know your inputs of your circuit. That's why we added another API inside hello tube called Lookup Annie, which here looks almost identical to the previous API. But only thing difference is here that we replace this table column into another expression that allows you to look up into an advice column. Or even you can use multiple columns to calculate a virtual lookup tables that is constructed with the expressions that allows you to look up into any columns or expressions. So give us more flexibility when we configure the zkevm to do that. But in today's Fibonacci example, we are going to only show you how to use this lookup APIs because we don't really necessarily need to use the lookup any inside the financial examples. But if you're going to audit the zkem circuit, or if you check out the Zkem circuit repo, you'll see most of the time we're using the lookup any because it gives more flexibility to configure the lookup tables.
01:24:16.570 - 01:25:03.878, Speaker A: Okay, so any questions so far? By the way, if you have any questions, you can stop and then stop me and ask me questions. Or you can type in the chat so I can keep an eye on the chat, see if anyone has any questions. Okay, so if there's no questions, I will continue. So now this is a few steps for how to implement a circuit in the halo two. So this is like for the basic minimum step, you need to do like the basic simple circuit. So first you need to define a config struct that includes all of the columns you are going to use inside your circuit. So this like there is a very simple struct inside the rust.
01:25:03.878 - 01:25:52.278, Speaker A: So only you need to include what columns you need to going to use, but you can also include some other things like inside a config, but at least they're going to provide type of columns you're going to use. And then secondly, you need to find a chip structure that going to configure the circuit. Basically config the constraints, the custom gains or lockup arguments you're going to use inside your circuit. And also you can also provide assignment functions. It's like how given certain input, how you're going to fitting into this witness table, like the giant matrix I showed before. Like how are you going to fill those values into those functions. So this is like two things, usually a chip is going to provide, and then the third step is going to define a circuit struct.
01:25:52.278 - 01:26:23.998, Speaker A: For this circuit struct, you need to have a requirement is that you need to implement this circuit trait that defined inside halo two. And then this circuit is going to be instantiate at last given some input. And then that's going to be feeding to the provers. The approver is going to call the circuit and the circuit inside. I will show you in the next slide what the circuit trait is. So the circuit basically need to config the circuit also provide like a synthesize function. Okay, so let's just look at the circuit trait.
01:26:23.998 - 01:27:11.970, Speaker A: What does it contain? So the circuitry need to define what is like a config you're going to use. So this config is basically this config structure defined in the step one. And then the floor planner, I was going to explain the next slide. I'll just leave it here. And then the next step is you need to implement a function that says without witness, how you're going to generate a circuit. So this is like the function is going to use to generate your proving key, verification key, so that without even a real instance like input to this circuit, you can still synthesize an empty circuit with some random data, but you still know how the circuit is configured, so you can still generate your proving key or verification key. And then the next step is configure.
01:27:11.970 - 01:28:05.754, Speaker A: So configure is here is that you need to really config the circuits using the constraint system it provided here. So that's here you need to define all your custom gates like a lookup arguments, like anything you're going to use here. But finally, we'll just only return a config here, which is originally the sum, like the columns you're going to use. Then this config will be going to then pass into this synthesize function. And then this synthesize function is going to have two input. One is the config you generate when you're doing the configure circuit, and second is the layouter help you to fit in into the witness inside your circuit. So now let's take a look at what happens actually inside the synthesis functions.
01:28:05.754 - 01:28:47.314, Speaker A: What do you really need to do and what is this layout is going to participate during the circuit? Synthesize. So every time when you synthesize, you can synthesize a region. So this is a region. It could be a single row inside a circuit, or it can be like multiple rows or even the entire circuit. It can have only one region, or it can be some very irregular shape or even non continuous area for these regions. So every time you call the synthesize inside synthesizer, it can be like the step by step. So every step here is not every time.
01:28:47.314 - 01:29:36.386, Speaker A: I think it should be more to be more like the clearest, it should be every step inside the synthesize function. You can assign a single region and then you can have many more regions when you do the synthesize. And then after every time you put value into a single region, you define a region, then you will use like a predefined, or you can even customize a layouter in the halo two to place the region inside the circuit tables. So right now there are two predefined layouters in the halo two. One is called a simple floor planner, which I will explain a little bit how it works. So it's a greedy planner. It is trying to find the first place you can find can fit these regions and then try to just put this region into that area.
01:29:36.386 - 01:30:20.954, Speaker A: And then there's another layouter inside halo two called the v one. It's a dual pass planner which is going to do some preprocessing and then try to find what's the best way to lay out those regions to use as fewer rows as possible. But inside ZKE event, actually we're only using the simple floor planner. This is because all the regions we define inside the Zkeven circuits, we only have the regular shapes, it's just the rectangular matrix shape. So basically it's very easy. Whatever the floor planner is going to do, they just only assign each one row by row or by rectangular. That's very regular.
01:30:20.954 - 01:31:06.186, Speaker A: So we only need to use that. There's not really some optimization to do with this layout here. So let's see how the layouter really works inside here. So here, inside a layout, usually a region doesn't need to have the same shape as your custom gate. For example here I had defined one custom gate enable, like the example, let's say if we enable this s zero selector, it will use these three cells inside the advice columns and it will put some certain constraints, say like for example a zero plus a one equal to a zero. Next. So it could be like this simple custom gate, but the region doesn't need to has the same shape.
01:31:06.186 - 01:31:47.706, Speaker A: When you do like circuit synthesize, it doesn't need to have the same shape as your custom gate, but it has to be a superset of your custom gate. Say if this region cover this selectors here and then the selector is enabled here, then you must cover these three cells. So this is like a valid region here. But if you only cover the single row here, if you want to say like I want to assign row by row, then basically the hello tube will give us an arrow. Say like you have invalid region, the certain cells, it should be synthesized, but it's not a cover inside this region. So it just basically gives you some arrows. So now just give some simple example like how the simple floor planner works.
01:31:47.706 - 01:32:28.220, Speaker A: So let's say for the region one it's only like using three cells, then you can easily find like say okay, so the first row can fit this region one, then just put into that. And for the second region it's also quite simple. Like if it's just this l shaped region area, then it just also cover until the second row here. But for the third region, if you say the region three. So if I like the region three using the column a zero, a one and s one. And I realized that the a zero is already using the first three rows. So the region three can only start at row four.
01:32:28.220 - 01:33:03.842, Speaker A: And then for the region four, this is kind of interesting things here, although this doesn't happen just illustration here. But usually you don't have such irregular shape. But if the region four only using the column a one, a two. So inside a simple floor panel, it just only check. For the a one, you already use the row up to the cell like it already used the row up to the fourth row. So that's the first available row is like the fifth row. So that's going to say.
01:33:03.842 - 01:33:49.938, Speaker A: And then even though the a two only used first two rows, and even though the row three for the a one column is empty. But the simple floor planner doesn't just ignore that. I just see like, okay, the largest row used inside the column a one is the row four. So that's going to just start placing the region four in the fifth row here. But if you're using the v one floor panel, probably we're going to just be doing some smarter things and place the region four here and then just put the value here. So this is basically how a floor panel works. Although I think during the auditing or reading the circuit, this doesn't really matter.
01:33:49.938 - 01:34:27.920, Speaker A: But it's some concept we can understand what happens when you do the circuit synthesize. Okay, now let's go jump into circuit Fibonacci. Circuit examples inside the halo two. So I have a few multiple examples for halo two, for the Fibonacci. And then you can see, you can define different layouts for this Fibonacci circuit, even though it's just a simple Fibonacci functions. So the problem here inside the fibonacci is like we given the f zero is equal to x, f one is equal to y. And we want to prove that, say f nine is equal to z here.
01:34:27.920 - 01:35:30.654, Speaker A: So how are you going to define your circuit? So how are you going to design the circuit? The very intuitive, naive way you see is that every row is kind of similar to what pew does. It's like every row is an execution state and they only apply one execution here and then, so it's kind of like an execution trace. So each time you say like a plus b were equal to c, and then you copy the next two cells into the next row and then say like, and then continue this addition here. So one plus two were equal to three, and then copy the next Bnc into the next row, and so on and so forth. So you can continue your trace until you reach the index nine. And you can stop here because you need to have the selector here in the end of the bottom of the circuit. So the circuit size can be like the fun for you predefined a circuit size, let's say 1000 rows, but you're only going to use, let's say first ten rows.
01:35:30.654 - 01:36:03.360, Speaker A: Then you say like I only put a selector which control the custom gate on certain rows. So you only set the selector to be one in the first ten rows and for the rest of rows it can be zero. So the value in the rest of rows doesn't really matter to your circuit. So this is like a very simple design. And then there's one last column here is the public input. Let's say the input x and y is equal to one. Then f nine want to prove is equal to 55.
01:36:03.360 - 01:36:44.246, Speaker A: Okay, so when you want to say like we designed the circuit as this way. So now we first need to define, the first step is define the circuit config which we see like because we know there are three advice columns. So you see like that there's three advice column, one selector and then one instance column. So this is all you need for your config here. And then inside that it's a function inside your chip, it's called configure. It's basically going to generate the columns here by using this meta, which is the constraint systems. You can call like advice column by creating like one advice column.
01:36:44.246 - 01:37:36.138, Speaker A: And then you can create like the column b, column c, select a column instance column, and then finally you will return this Fibonacci config here from this config function. Now what inside this part is that you need to add constraints into your constraint inside your circuits, like how you want to define the relationship the polynomial identities between this column a, B and c. So because this example is very simple. So it's only going to say we're only going to use a single addition here. So that's why we only have one single selector. So this selector here is like we can call like an add selector, sorry, an add custom gate. And then what are you going to say? First we say that we're going to enable a selector here.
01:37:36.138 - 01:38:11.078, Speaker A: The selector can be any rows. So any row. Like if the selector is set to one, that means that this custom gate is going to be enabled. So that's why the selector doesn't have a rotation here. So first I can say I going to enable this selector, it's going to associate with this custom gate. And then we also going to query a cell inside the column a, column b and column c with the rotation here as the current means that it has to stay at the same row as this selector rows. So let's say this selector at the row two, the selector is set to one.
01:38:11.078 - 01:38:49.582, Speaker A: Then this custom gator is going to constrain this a two, b two and c two here. Now what's the constraint you're going to put onto the a, b and c is that you use s to multiply the a plus b minus c should equal to zero. That means like here, when selector is set to one, then a plus b need to equal to c. But when selector is equal to zero, then it doesn't matter what value you put into the abncs. That's like how you define a very simple custom like addition custom gate inside using the halo tune. And this is like the polynomial identity. Actually you associated with this custom gate.
01:38:49.582 - 01:39:38.364, Speaker A: It's basically after you do like FFT, commit this like convert this column into a polynomial, become like Sx and the same like for a and b and c. So basically the polynomial identity here is like Sx multiply ax plus bx minus cx equal to zero. So this is like the polynomial identity you're going to put here. Any questions so far? Okay, so next step is that we're going to enable the permutation check. So what we're going to do the copy constraints. So see what cells we need to copy front. So for each row you need to copy from previous row, you need to copy the value b into the next row, the column into the column a, and then the column c.
01:39:38.364 - 01:40:13.780, Speaker A: You also need to copy the column c from previous row into the current row, column b and so on and so forth. You need to do like for every row. That means also there's one last thing you need to do is need to constrain here. The output in the last row you're going to hear is equal to your public input, which is that you want to constrain. This is equal to 55 example. And also here, similarly you also need to copy the first row is like f zero into column a and f one into column b. Here I just omit that inside the slide.
01:40:13.780 - 01:40:59.716, Speaker A: But also you need to do the copy constraint on these two cells as well. So that means like the column ABC and the column I, the instance column, need to participate into this permutation check. So that's why inside, when you configure the circuit, you also need to call the meta enable quality column a, column b and column c and the instance column. So these four columns are going to participate inside this permutation check. But here you notice inside this function you only define, say like these columns need to participate in the equality check permutation check. But it doesn't say like how you want to copy your cells. But actually that could be very complicated because you can have.
01:40:59.716 - 01:42:03.236, Speaker A: So in the Fibonacci it's very regular, but in some other complicated cases it can be very irregular pattern when you copy certain cells from one row to another row. So actually when you define the actual permutation, like how you want to permutate these cells, it's inside the circuit synthesize functions. Let's say I will show you the inside of the code. It will be probably easier to take a look at how we define that. But when you say I want to do the assignment for the row two, instead of directly filling the values, I will say like I will copy the value from previous row here, previous cell b here, and then copy that value due to whatever here. So during the circumstances, you basically provide a permutation function for all of the columns with the index here and basically the offset inside each column and which column to copy to another column at a different offset. You will define this like permutation functions inside during the synthesize the circuit.
01:42:03.236 - 01:42:44.288, Speaker A: Synthesize. Okay, so let's just take a look at the code. Okay, so let me just copy this example here. So you can also just directly read the, basically you need to remove the space here. Yeah, I copied the link here to the code, but I will also show you inside here. So this is like the whole code for the example one, the Fibonacci circuit. So this is already go over, which is a Fibonacci config with different columns.
01:42:44.288 - 01:43:27.796, Speaker A: And then the Fibonacci chip. Basically you need to contain a Fibonacci config here. It has a few functions. So you need to construct, like how do you construct a fibonacci chip? That's basically simple. And then this is like the part we mostly go over through is like the configure function is how you define the constraint inside the circuit. And if you create those columns and create a selector, create the instances and enable the permutation check on column ABC and instance column, and you create a custom gate here using certain query. And yeah, I think I probably forgot to tell you what the query does.
01:43:27.796 - 01:43:59.704, Speaker A: So when query selector, you'll basically convert that into expressions. And then when you query advice column, and then you will need to provide a permutation that is going to relative to these selectors. So this is all written inside it will return to you as an expression. And then so you can do certain arithmetic things on those expressions. You can do multiply addition or minus. So you can see like you can s times like a plus b minus c. And then this is basically an expression.
01:43:59.704 - 01:44:48.888, Speaker A: And then that's the constraint. Like the only constraint that we added into this custom gate. Add and then lastly in this configure we're going to return this Fibonacci config. Now in these functions it also provides two additional functions which is called assigned first row and then assigned row. So assigned first row will be a little bit different. It's like when we trying to say we're going to synthesize the first row, we need to copy like the a and b on the instance column, which is our property input. So let's say how we do implement this assign first row is that you also want to enable the selector in the first row.
01:44:48.888 - 01:45:30.044, Speaker A: This is because you also want to do like an addition check on the first row here. So you also check one plus one equals to two. So this is like the unique. You enable the selector here and then the a cell basically is copy from to the column a is that you assign the advice from the instance column and then this is basically annotation is like this is f zero. You copy from the instance column here. So the config is here is like the instance column and this is like the absolute index inside the instance column. You copy from the row zero from the instance column into your column a with the offset zero.
01:45:30.044 - 01:46:23.852, Speaker A: So here this is an offset, this is kind of offset related to the selector here. So that means if we want to save the first row we don't going to use copy that. You can still copy the popping point into the second row here if you enable the selector at the second row. So similarly for the b cell, you also do like the assigned advice for an instance. So basically these APIs here is also not only doing this assignment for these cells, it also adding to the permutation check permutation function. So it knows that for the instance column row zero will be equal to this column a at the offset zero. So that's basically you added this permutation check into associated with this API here.
01:46:23.852 - 01:46:57.108, Speaker A: And for the last one you're going to just assign the vice for the column c. So basically that's a plus b for like a cell, plus b cell. So it's going to do like you use the column here and then offset is zero like the same row as a and b. So you'll be using the a cell, the value added, the b cells, the value inside the b cell. So this is like how you fit into the cell c here. And then you can return a cell b cell c cell so I can copy to the next row. So this is basically what happens inside assign first row.
01:46:57.108 - 01:47:44.148, Speaker A: So the next rows can be similar, can be slightly different but very similar. So the similar here is like when you assign the row, you're going to give two assigned cells. It's basically return from assigned first row or assigned rows. It's like I need to know the previous b and previous c from the previous rows. And then what you're going to do, you're going to assign into your previous b the value inside the previous b cell into this column a here. So you basically call like a previous b copy advice and then copy into the column a here at offset zero. And also you need to copy the previous c into the column b here at the current row.
01:47:44.148 - 01:48:37.180, Speaker A: And then finally you can assign the c cell here. It's basically the value b and value c, the previous row like value b and the previous value c added together into the new c cell, new column c here and then you can return the c cell. Any question from this part? Okay, so let's see what a circuit does then. You can now define a circuit here. The circuit will basically define, say I'm going to use the Fibonacci config and then use the simple floor planner. And then the config here is basically very simple. So you just call this Fibonacci chip to config the circuit and then return the config here.
01:48:37.180 - 01:49:23.194, Speaker A: And then during the synthesize you can then use this chip. It will give you like a config here. You can use this config to construct a Fibonacci chip. And this Fibonacci chip will help you to assign synthesis. So here you can see, you can first call this assign the first row, basically calling the chip assign first row and given this region name, region name here the first row and for next a few rows. What you're going to do is you're going to call the chip assign row and then given the previous b and the previous c here as an input to the assign x rows. And then you know, because we know we are going to compute the f nine.
01:49:23.194 - 01:50:06.626, Speaker A: So it's going to be like this. Here we compute in the first row, we compute f two. So now we need to iterate this I from three to zero to nine, which are going to say like we are going to compute f nine at the last. And then one last thing is like after you compute everything, after you synthesize row by row in the last row inside the circuit, inside the circuit synthesize, you need to expose the previous c into the public cells. Sorry. Connect the last output from the last row into your public input instance. So there's like one more API inside the Fibonacci chip.
01:50:06.626 - 01:50:39.540, Speaker A: It's basically called expose public. It basically does very simple things. Say like we just constrained the instance given the cell you already assign. And you say like these two, you just assert the last output row, the output of the last row, you are equal to the second instance at a certain, like the absolute offset inside of the instance row, which is the row number two. So this line basically is adding this copy constraint for the last row here.
01:50:40.970 - 01:50:41.526, Speaker B: Okay.
01:50:41.628 - 01:51:25.198, Speaker A: Then inside examples here, you define the k equal to four means that our circuit means like our circuit is the size of the number of rows inside circuit is two to the four with equal to 16. And then you can define the a and b and output, which is the public input. And then you create this circuit, and then you provide this circuit here into a mock prover and then the public input. So the mock prover is not the real proverb. It's going to basically synthesize the circuit and check all the constraint you define inside the circuit and make sure it can satisfy or not. So this is kind of very simple. This is not the real proverbs.
01:51:25.198 - 01:52:21.372, Speaker A: It doesn't really do the polynomial commitment, although do other things like here. But this is an easy way, you can check if your circuit is correct or not. And if you say, then the prover should hear satisfied, should be satisfied. But if you're going to modify the pop input a little bit, then if you uncommon this, if your circuit is sound and complete, then it means like here, if you uncommon this column, then this assert will fail. Okay, so this is like the example of the Fibonacci example one. So anyone has any questions so far? Okay, so if no more questions, I can go to a little bit, I know, like this have like five minutes later. So five more minutes.
01:52:21.372 - 01:53:08.984, Speaker A: So the problem we noticed inside example one is that there are basically too many duplicate cells. So every time you need copy two cells from previous row to next row, there's a lot of duplicate cells. Not efficient. So a better solution is that we can use the rotation to access to the multiple rows. That means that you no longer need to do the execution traits row by row, but you can across row to do the execution. So why not we just do a single advice column and then you put a single Fibonacci trace here and you just define the relationship across different rows inside this single advice columns here. And other things are very similar, the selectors, the instance, but only like you reduce from three advice column into one advice column.
01:53:08.984 - 01:54:23.908, Speaker A: So now only thing you're going to change here is that when you generate a custom gate, you first define similarly, you query selectors, and then now you are going to say a, b and c is basically the rotation of the current row as the same as the selector, and then the next row of the selector, and then the next second row relative to the selector rows. So now your a, b and c is from the single advice column, but with the different rotation here. And then you can still define the expression polynomial identity. Here it's the same, it's like s times the a plus b minus c equal to zero as your constraint associated with this add custom gate. Now here, the things that will be a little bit different in the polynomial identity is that it becomes like sx times ax plus a omega x, which is the next row inside your a, and then minus the a omega square x is basically this cell, like the next second row inside the column A. So this is like the polynomial identity actually associated with this custom gate. So there's also like a code here.
01:54:23.908 - 01:55:07.020, Speaker A: So I'll just quickly show you. It basically looks very similar. The only thing, the gate is a little bit different. Now the assignment we also did, I guess a little bit different. So now notice the problem with if you want to assign, if you want to do this region, by reaching the circuit synthesize, you're entering to some questions like the different regions may have overlapped because it's an l shape. If want to cover this cascade, you need to cover this l shape here. That means if want to synthesize the next things like you also need to have overlap between different regions.
01:55:07.020 - 01:55:50.396, Speaker A: So actually inside the hello two, it doesn't allow different region has overlap. So what we are going to do is we are going to do a single region assignment. Basically we see like this region will cover the entire Fibonacci tables, but you can still do that. You can say enable the first two rows of the selectors and then I will still do the similar things. You copy the instance now into the first row and into the second row here. And then for the rest of rows you can add from previous two rows here into the next row. So basically you calculate this row, although as an offset row.
01:55:50.396 - 01:57:01.732, Speaker A: But basically if you only have a single region, so this is the absolute number of the row inside your circuit. And then remember, this is a little bit careful here is that once a selector is enabled, you're always going to check the next three rows inside the column a. So that means if we are for the last two rows inside the region, the selector cannot be enabled because you are not going to fit into the values onto the next rows. That means if row equals is smaller than the number of rows minus two, we are going to enable the selector here. Otherwise we are not going to enable the selector and then the rest of things will be quite similar. So only things like inside my circuit here is that it's going to call one single assignment here and then this assignment will be configuring like putting the witness into the entire circuit table. And then finally you also need to expose the output into the assert it's equal to the public instance.
01:57:01.732 - 01:57:43.648, Speaker A: Public input. Okay, so that's like a simple example, like a difference between the fibonacci one and the fibonacci two. Like example two. Any questions? Okay, I have to see what would go wrong if you didn't enable the selectors into the original Fibonacci circuit. Could you have the agate return vector a plus b minus c instead of vector? Yeah, that's a good question. I think you can still do that. But the question is it means you are going to enable this custom gate for every rows.
01:57:43.648 - 01:58:32.582, Speaker A: That means even you're not going to use the rest of rows. Let's say the circuit, sometimes it doesn't have perfect shape like the number of rows you need to going to use inside the circuit. So definitely you have some rows which are the padding rows. So if you're not going to enable that, then if certain people put it into different numbers here, you're also going to check on this custom gate here so that we usually always associate a custom gate with certain selectors here. Does that answer your question? Yeah. Okay, thank you. If no more questions.
01:58:32.582 - 01:59:03.010, Speaker A: I got going to last examples. So this example is going to show you a little bit. See how to use the lookup argument inside the hello two. So in order to use the lookup table, we need to make the Fibonacci transition function a little bit more complicated. Let's say we want to do like if we want to define two different relations. Like if it's like on the even index here, we're going to add the previous two elements inside the sequence. But if it's an OD index.
01:59:03.010 - 01:59:41.294, Speaker A: We're going to x all of the previous two elements. So you will get like a different Fibonacci sequence. Let's say like I still have the one and one in the zero and one positions two like you basically add them together. But when you calculate f three and it becomes like you need to do like the xor between one and two and give you the three. And then you add two and three to five and do an XOR between three and five and it becomes six. It's like a slightly different things. So as we know when we trying to write the XL, define Xor inside a circuit, it's very complicated to do that.
01:59:41.294 - 02:00:35.040, Speaker A: So in order to reduce. So usually when you do inside a circum or rncs circuit, you're going to break down into the, you need to bitfire the numbers and then you do like bitwise operations for the XL. So it requires a lot of custom gates to do that, or constraint to do that. So inside the plank or hello, two or maybe inside pu, you can use the lookup syncs to do that. Which say like we pre compile a lookup table here, which have like the list is all of the possibility for say like a and b can be zero to 31 and then zero to 31. And they take the combination of this a and b and you pre compile the output of the ax or b here. So that means this table has two to the ten like 1024 rows to put into this single table here.
02:00:35.040 - 02:01:01.510, Speaker A: So you pre compile these tables. So every time when you want to do the Xor here. So you also like now you need to have two selectors. Oops. So you need to have like the two selectors. So select add. It's going to say like in this row I'm going to do the addition here.
02:01:01.510 - 02:01:35.086, Speaker A: This is like one plus one equal to two for the next row, which is the OD index here, we're going to do the Xor here. So basically you're going to configure the selector like 1010 and for the selector XoR. And then so inside the config here. Now you have a little bit more things. You still have three advice column like a, b and c. You can also do like a single column. But for the simplicity, I just show you extension from example one, but you can also do from example two, have like a, one single column.
02:01:35.086 - 02:02:21.118, Speaker A: You can still make this circuit works. So right now we still use three advice columns. And you can do like one selector for the addition gate and one selector for the XL gate. And also you have three table columns which will contain the pre compiled XL results for within the range of the 32 here. And then you also still have the instance column here. So now the only thing different is that inside your circuit you will do like a called meta lookup that's going to initialize a lookup argument. And then similarly you enable a selectors and you query the column a with the same rotations and then column b with the same rotation and then column c with the same rotations.
02:02:21.118 - 02:03:23.318, Speaker A: Now you return a vector of tuples, but here it says I'm going to multiply the selector with the column a with value a and then we're going to map this value into the first column inside the excel tables. And then s multiply the b here, the RHS right hand value, and then you're going to check mapping to the second column inside the excel tables. And finally the output, the s multiply output will map to the third column inside your lookup tables. So basically this is like your lookup argument for the XL operations inside the lookup. And if you look at the code, which this is example four because previously we use this like the material for some other tutorials. So it's actually the example four. So the example four here you can see we configured the Excel column and then you also need to enable the quality.
02:03:23.318 - 02:03:59.226, Speaker A: Here you configure ads ad custom gate. But here you need to just query the selector for s ad and then for the lookup which is the Xl parts, you need to query for the XL selector here. And this is basically the same things you can see. So now inside the circuit synthesize there's like one more step. So this is like one assigned for the entire circuit region, which is similar to the example two. But now you have one additional function provided inside this chip. It's called a load table.
02:03:59.226 - 02:04:50.470, Speaker A: So this is like how you're going to fit in your Excel table here. So basically you iterate between for the left hand value and the right hand value like the from zero to 310 to 31. And then you iterate all possibilities and you assign the table here, say like into the first column at a certain index. You put like this value here and rhs here into the second row. And then you compute them like yourselves here. And then what's the result of the XOR between the a and b? And then put into the third column inside the lookup tables. And then what happens inside the circuit is that you will call first also in the synthesize your first deal like is loaded your tables, load your lookup tables.
02:04:50.470 - 02:05:16.200, Speaker A: And then you're going to assign the rest of things, like, which is all the other things. And finally you will assert the result is correct by comparing to the public input. And then that's like how you're going to do that. The rest of things will be similar. Yeah. And then you can check out this code. You can just do like the.
02:05:16.200 - 02:05:41.220, Speaker A: Yeah, you can, you can do like the cargo views. And then you can go like cargo test, like Fibonacci example one. That's going to say, okay, the test has been checked. Example two. So basically that doesn't give you much of intermediate outputs here. So it's just going to check whether it passed or not. That's like how you're going to run that.
02:05:41.220 - 02:06:32.910, Speaker A: Okay, that's all of the presentation I have for today, like for the Fibonacci examples. Now if you have any questions, I can accept any answer any questions if you have. And thank you everyone. Do we have any questions? Yeah, I think no one has questions. So I think if no one has questions. So we can end today's sessions. And then the next session will be talking about the ZKE EVM circuit design, more like a high level overview.
02:06:32.910 - 02:07:01.010, Speaker A: Monday next week, and then the last session will be on Tuesday. It's going to have some lessons learned when developing the ZKVM circuits and also like general circuit designs. And thank you everyone for hearing, and we hope to see you on Monday. Yeah, it's getting better every day, these lessons. So thank you. Thank you, Heichen. That was really insightful.
02:07:01.010 - 02:07:09.182, Speaker A: Thank you. Thank you, Jose. And next session three, see you then. Cool.
02:07:09.236 - 02:07:09.454, Speaker B: Yeah.
02:07:09.492 - 02:07:11.210, Speaker A: Thank you, Chris. And thank you everyone for attending.
