00:00:04.860 - 00:00:48.030, Speaker A: You. Okay, so let's do the live demo of that. Let me see. Okay, so inside we have the prerequisite school IO. So if you are included inside the wireless, you can be accessed to that you can go to like a guide which give you some instructions of how to use the test and how to play with us step by step. And then, so before when the first time you join the tax net, you need to going to add all of these configurations to your metamask so that you can be able to switch between different scroll layer one and scroll layer two. And then we have some example USDC tokens like deployed on the layer one both side layer two.
00:00:48.030 - 00:01:29.128, Speaker A: And then the first thing you're going to do is going to open this faucet application. Let me see. Okay, so you can just request one ethereum and 100 USDC token on the layer ones and it will just show up to transaction hash that is going to issue those tokens from the faucet account. So here we already have some of the requests or something like that. It will show up after about 15 seconds. I'll just receive a new one ethereum and 100 USDC token and then that request only. You can only request once like every 24 hours.
00:01:29.128 - 00:02:25.616, Speaker A: If you do that again, I could just shove some arrow and then the next thing you can do is trying to, so that token is issued on the escrow layer one. So the next thing you need to do is you want to experience the layer two. So you just should deposit transfer that token you receive on the layer one to the layer two which you can use this bridge application that going to see, you can see like I want to transfer two ethereum to ethereum to the scroll layer twos and then click on send. Oh, so I'm not using the correct, so now I'm on the scroll layer one. So you can send the ether to the layer two, then click on send and then confirm. So we're going to see a pending transactions here like after a few seconds. Okay, so you can now see this channel has been confirmed which you can view on the block explorer.
00:02:25.616 - 00:03:09.850, Speaker A: Sometimes the block explorer just takes a few seconds to show up on the block explorer. So you can see now this transaction has been confirmed by one block. And after you see that this number goes up to six blocks, then that means the fund you transfer from layer one to layer two will be showed up on your school layer two address account. So I previously transferred two Easter tokens that should have not been show up on the layer two. So currently I only have 1.3 easter here on the layer two account. But probably after probably two, two, three more minutes and then it will just show up like, it will becomes like three tokens, three eases on my layer two account.
00:03:09.850 - 00:03:43.990, Speaker A: So let's now wait for that time and then we can go back so we can just play with the swap. It's also quite straightforward. You already have some ease and you just swap, sorry. You select a token USDC so I can swap one ether for the USDC. That would be kind of standard as what you do on the unit swaps. So now I will just submit that transaction here. It'll probably show another pending transaction here.
00:03:43.990 - 00:04:10.504, Speaker A: Okay. I think next thing that you can play with, you can see is the Rob explorer. So there's a few more transactions. Actually the people are still playing with the testnet. So you can see how many transactions here. For the latest blocks there will be the transaction. So you can see the latest two transaction, probably those two blocks which I was just submitted.
00:04:10.504 - 00:04:43.050, Speaker A: So they'll be still at the pre committed status and then there will be relayer. It's going to keep updating like sending the new transaction, the commit transaction to the layer ones. And after that transaction has been confirmed, then you can see it becomes committed after a while. So probably it's still waiting for the layer one to be confirmed, those transactions. So these are some transactions already. Send it to the layer one because we don't have, oh, there's a lot of transactions. Okay.
00:04:43.050 - 00:05:18.230, Speaker A: I think right now we don't have enough provers on the back end. So there are probably a few, yeah, you can see like there's a few blocks has been finalized. So that you can see this finalized both finalized transaction hash and then the commit transaction hash and that will be switched to the finalized data. And because right now at the testnet we don't have enough freeing power so that we selectively just prove wine array two blocks, that one block will be skipped. Skip. I just mean like we just pounce on the, generating the decay proof for that. Okay.
00:05:18.230 - 00:05:57.200, Speaker A: Yeah, there's probably like one more demo I can show. I don't have time. Actually very soon we're going to support the arbitrary, like the contract deployment. So right now we still have only a few pre deployed contracts, but very soon we have the new functionality support to allow you to deploy any contracts you can. So right now I can show you some examples. So I'm actually modifying a little bit on the scaffold east, which is a great tutorial that by the Austin did like that. So actually I was running this scaffold east on my own laptop and connect to the school layer too, which means you can deploy contracts.
00:05:57.200 - 00:06:38.700, Speaker A: So what you can do, like you just do yarn start in the scaffold east. So I did that some modification in a new branch so that it's connected not to the local node but to our layer two node. So now you can see it will just initialize a website which you can deploy, debug things. I previously tried that. So you can call like the yarn deploy. So currently, like just the original example have inside the scaffold ease which have like a very simple example of contract you can interact with. So now you can call yarn deploy.
00:06:38.700 - 00:07:33.646, Speaker A: Okay, so you first compile the contract you have inside the sync and then it's deploying the smart contract. And then waiting for the contract has been confirmed. Okay, now it's deployed. So if we copy this transaction hash and open inside the layer two scans, scroll IO, and then you can search for that transaction. Yeah, it'll probably take a few seconds to actually the sports card usually has some delay to shop the latest transactions. Okay, yeah, see this is the latest contract creation I just deployed on the score layer two, which is like already success. And then if you go back to this, and then, so you can see this new contract has been deployed on the layer two.
00:07:33.646 - 00:08:06.486, Speaker A: And then which you can also interact with this contract. You just deploy on the Scolaya two, which you can say I can spot like the, oh, scroller two. Okay, now I can just call send and I'll just interact with the, see like I connect to the Scolia two. Now just sending this transaction through my metamask and I click on confirm. So I just say like, okay, this transaction has been sent. And then let's just refresh. Yeah, so you can see like this transaction has been already updated this purpose like the string inside your smart contract.
00:08:06.486 - 00:08:33.666, Speaker A: And then later I'll probably show up after the proof of catching up on this. You can then see those blocks will be finalized and then generate some ck proof too around all of those blocks we just generated. Okay, with that, that's all of the demo I have. And then thank you very much. If you have any questions, actually feel free to ask. I can have probably one or two questions if you have questions. Yeah.
00:08:33.848 - 00:08:38.530, Speaker B: Have you tested the case where verification fails and you need a rollback?
00:08:40.330 - 00:08:44.870, Speaker A: Usually I think that means there are some bug inside ZKMA circuit.
00:08:45.530 - 00:08:54.140, Speaker B: Someone just made your block producer did something malicious or something.
00:08:55.790 - 00:09:36.440, Speaker A: Yeah. So I think right now we are still operating under the assumption we have centralized sequences, that means we are not malicious ourselves. But I think in the future, if something has been malicious, then I think we are going to have this proof generation part where we work inside the proverb, so that prover doesn't need to trust the trace that generated by the sequencers, so that you just need to operate on the transaction data like people send out, and then you generate the trace by the proof itself, so that if the sequence is correct, then you should be able to generate a validity proof for that. That makes sense. Okay.
00:09:36.810 - 00:09:38.710, Speaker C: Is there any economic incentive?
00:09:42.730 - 00:09:51.850, Speaker A: We're still working on some more details, so we're just like keep updating on that. So I haven't finalized all of the details of the incentives.
00:09:54.670 - 00:10:07.326, Speaker C: So for the bridging, I guess from l one to l two have a trusted relayer, and then from l two to l one, have you set it up so that you have to merkel proof to withdraw from?
00:10:07.428 - 00:10:10.990, Speaker A: Yeah, there will be some Merkel proof associated with the layer two assets.
00:10:12.310 - 00:10:15.442, Speaker C: Do you have a plan for what you're going to do from layer one to layer two?
00:10:15.496 - 00:10:39.340, Speaker A: Yeah, I think I will also probably do that. Once you have the decentralized sequences, you probably cannot trust anything like that. So you should have some proof from layer one to layer two deposit. Yeah, it could be like a little bit tricky because you need to have some data like you have. You think of some proof like the state from the layer one to layer two. But I think I was just considering the research about that.
00:10:39.710 - 00:10:43.990, Speaker C: Does grow have plan to do the recruiting?
00:10:44.330 - 00:11:17.458, Speaker A: Yeah, the aggregation is kind of like one way people call for the recursive. So basically recursive is basically you verify your proof inside the circuit. Just people have kind of different naming for that. Batches, actually. So right now it's processing on the block level like this. So each block you can have a block could have multiple transactions. Sorry, what?
00:11:17.544 - 00:11:19.990, Speaker C: The coordinator just likes a set of transactions.
00:11:20.570 - 00:11:38.540, Speaker A: The coordinator will just basically receiving the new executive trace from the sequencer. So once the sequencer generates a new block, it will also generate some execution trace, and they will just send to the coordinator l two.
00:11:39.150 - 00:11:41.050, Speaker C: L two to l one bridging.
00:11:41.470 - 00:12:06.526, Speaker A: L two to l one bridging. Okay. Yeah. Can switch back a little bit. So the l two to l one is like someone just send a transaction to the l two bridge contract, and that bridge contract will just emit an event, and then also it will send some proof associated with that transaction. And then the relayer basically already received this event from the block contract. The bridge contract.
00:12:06.526 - 00:13:04.340, Speaker A: Sorry, the bridge contract and I will wait for it will know the result transaction will be show up in which block. And we're waiting until that block has been finalized on the layer ones. And then it will send all of the withdrawal transaction like withdrawal messages to the layer one bridge contract along with some of the proof associated with each withdrawal. And then the layer one bridge contract will verify the proof with all of the withdrawals. And then actually for all of multiple, if there's multiple withdrawals within the single block, it will just call multiple transactions to transfer the fund from the bridges to users account. Yes, I think that would have a better user experience, but we need to estimate some fees. When you call the withdrawals, estimate like how much fee were associated on the layer ones to do the transfer.
00:13:04.950 - 00:13:12.200, Speaker C: The commit frequency from l two to l one determined by time or by amount of transactions.
00:13:13.600 - 00:13:41.910, Speaker A: Sorry, l two to l one, the frequency. No, it's just like the waiting. Once the block has been confirmed for that contain. If a block in the layer two block contains a withdrawal transactions, you'll wait until that block has been finalized on the layer one so that the relayer can send out all of the withdrawal events inside that block to the layer one.
00:13:43.000 - 00:13:44.950, Speaker C: Is the block size in layer two?
00:13:46.920 - 00:14:09.100, Speaker A: That's a good question. Actually, the layer two blocks, the limit is not on the gas. It's usually limited by the circuit size, how many transaction or how many steps we can include in the circuit. So if you have a larger circuit, that means that you have higher gas limit. But if I have smaller circuit, then you have smaller gas limit you can process inside the block.
00:14:11.880 - 00:14:23.192, Speaker C: Since your limit is given by the size of the circuit, your pricing of gas is a little bit different, right? It's determined differently than for l one.
00:14:23.326 - 00:14:50.050, Speaker A: Yeah, that's also another great question. So yeah, there will be something like. So we probably still take most of the gas model from the exchange, but with some minor tricks, for example, some certain simple offcodes, that could be resulting a great overhead inside the circuits. You'll probably tune up a little bit on the gas cost for that offcode, but usually I think like that the existing gas cost model is pretty good enough for most of the operations you have.
00:14:51.060 - 00:14:54.800, Speaker C: Have you done any analysis of what repricing?
00:15:00.300 - 00:15:35.760, Speaker A: Yes, so it's still kind of like inside of the research. We have some initial analysis from some of the shastry catch of code could be a little bit cheaper in perspective of the decay proofs. And then there will be some external code size of code hash could be like, a bit cheaper. So you need processing all of the contract code you have and then do some hashing on top of that. But I haven't kind of fully. Definitely will be some security concern. We just also need to think about all of those different aspects.
00:15:35.760 - 00:15:52.650, Speaker A: Okay. So I think I'll just end up now it's really a little overtime. We can have a ten minute break, and then we can come back to the second session where in tongue is going to talk about hello two. And Mason is going to talk about ZKum architecture. All right, thank you, everyone.
