00:00:01.370 - 00:00:05.086, Speaker A: Properly. Can you share your screen, Razal, so we can have that on screen as.
00:00:05.268 - 00:00:06.000, Speaker B: Yeah.
00:00:14.360 - 00:00:48.600, Speaker A: Yeah. Okay, great. Yeah, I have you. Okay, great. So I do have you guys on YouTube now. You removed your screen though, right?
00:00:48.750 - 00:00:54.350, Speaker C: Yeah, I removed my screen. Idris will be sharing his.
00:00:55.520 - 00:00:56.232, Speaker A: Idris.
00:00:56.296 - 00:00:57.196, Speaker B: Okay. Okay.
00:00:57.378 - 00:00:58.110, Speaker C: Yeah.
00:01:03.500 - 00:01:13.110, Speaker A: All right, Idris, you want to share your screen so we can have that set up? You're muted.
00:01:13.610 - 00:01:19.366, Speaker B: Yeah, I just shared. Now I'm currently sharing my screen. I don't know if you can see.
00:01:19.548 - 00:01:20.280, Speaker A: Great.
00:01:20.650 - 00:01:22.850, Speaker B: Okay, perfect. All right.
00:01:22.940 - 00:01:41.770, Speaker A: Have you guys in YouTube? It's live? Yep. Awesome. So there's some delay in YouTube. Just don't go in YouTube. Don't pay attention to YouTube. Don't pay attention to discord. Just stay here.
00:01:42.220 - 00:01:44.472, Speaker B: Okay, cool. Okay.
00:01:44.526 - 00:01:50.590, Speaker A: If there are any questions, I'll drop them here in the chat where it says everyone and then you guys hear it here.
00:01:51.040 - 00:01:51.500, Speaker B: Okay.
00:01:51.570 - 00:01:55.836, Speaker C: I'm going to be back in 2 minutes. I just need to go to my kids for 2 minutes and I'll be right back.
00:01:55.858 - 00:02:07.660, Speaker B: Yeah, it's all goodbye.
00:02:08.260 - 00:02:09.968, Speaker A: I'm going to go get some water, too.
00:02:10.054 - 00:04:50.110, Speaker B: I'll be right back. All right. It. Oh, man. Sorry. Is it very healthy for you?
00:04:50.960 - 00:04:58.930, Speaker A: No, it's 10:00 a.m. For so many meetings. It's crazy.
00:05:25.560 - 00:05:29.700, Speaker B: So, like, is he actually live on YouTube or just like backstage?
00:05:31.580 - 00:05:35.290, Speaker A: I am only producing so you cannot see me on the actually.
00:05:36.060 - 00:05:37.130, Speaker B: Oh, ok.
00:05:38.700 - 00:05:42.570, Speaker A: But yeah, it's live on YouTube. When you go to YouTube, you'll find.
00:05:43.500 - 00:05:51.740, Speaker B: Oh, ok. No, I just wanted to confirm because when you go live, it's like when the entire thing starts. That's fine. Yeah.
00:05:51.890 - 00:05:59.810, Speaker A: Let me share the link on our group. I'm already starting the discord stage as well.
00:06:06.510 - 00:06:11.098, Speaker C: All right. Are we already live, Juan?
00:06:11.194 - 00:06:12.720, Speaker A: Yeah, you're good to go.
00:06:13.170 - 00:06:15.614, Speaker C: Okay, I will do the kickoff then.
00:06:15.732 - 00:06:30.700, Speaker A: Give me just a second. Let me stream it on discord and I'll let you know. Okay. Yeah, you're on screen. You're good.
00:06:31.630 - 00:06:54.260, Speaker C: All right, GM, JM, everyone. Welcome to this workshop together with Idris, my man, my buddy from XLR, who will show us how to build a full stack interchange dap on scroll. I'm super stoked for this. He has a lot of exciting stuff for you to show. I can't wait to get into it. Idris, how are you doing, my man?
00:06:54.630 - 00:06:58.580, Speaker B: Yeah, I'm doing great. Really happy to be here.
00:06:59.350 - 00:07:00.900, Speaker C: Awesome. Take us away.
00:07:01.910 - 00:07:34.026, Speaker B: All right. Thank you very much, Raza. And I'm really excited to be here. So in this workshop, we're talking about building a full stack interchange decentralized application on scroll. And then we'll see how all of these things happen with Acceler. And then how easy it is for you to build your smart contracts, compile them and then deploy it on scroll. And after that we go ahead to talk about building a front end application to test out our smart contracts that we just deployed.
00:07:34.026 - 00:08:04.394, Speaker B: So let's get right into it. My name is Idris Olubisi. I am a software engineer and a technical writer. I currently work as a developer advocate at Acceler and you can find me on all platforms. My name of course, and also at Olanestoft. So let's talk about what exactly are we going to be doing during this workshop. First we take a step back to talk about the brief history of blockchain, how everything started in the space and then where we are currently.
00:08:04.394 - 00:09:02.502, Speaker B: And also what are some of the expectations or things we expect in the nearest future. Then we talk about exploring the accelerate tech stack and also acceler GMP, which will be utilizing during the demo for sending messages cross chain and also using it to facilitate this cross chain interaction within our decentralized application. And then we move on to the demo part where we see all of these things live. And then we try to code things out and then follow along. So now let's start from the beginning, which is the history of blockchain, where everything started from. So I know you're already familiar with some of this logo on my screen right now. But then just to take a quick recap about how everything started in 2009 when bitcoin was launched and then which was introduced by the anonymous Satoshi Nakamoto.
00:09:02.502 - 00:09:51.734, Speaker B: And it is used to utilize a network on its own, which is the first cryptocurrency that is built on the proof of work consensus. And then during this period, we see the likes of empty gods as a den, which became the largest exchange by 2010. And then they kind of handled the large portion, the substantial portion of bitcoin transactions as at this period. But then it didn't stop there. We began to see the like of Maker, the likes of compound. And then in 2014, Ethereum was announced or proposed by Vitalik Bulletring, sorry, butterin. And then this introduces smart contracts and enabling decentralized application on the blockchain.
00:09:51.734 - 00:11:17.586, Speaker B: So what if you can extend what we currently know within the bitcoin ecosystem where it is utilized to replace the existing traditional finance or improve on what we currently have? And then what if we can find a way to leverage blockchain technology itself to build decentralized applications to allow developers customize different software application on the network. So this is what Ethereum proposes. And then since then, we've seen the blockchain ecosystem, both private and public, gaining traction. And as organizations start to explore them, the default ecosystem, the supply chain, the healthcare system, voting system, and many more. But it didn't still stop. Here we proceed during the era of 2017 to 2019, began to see several issues around scalability, transaction throughput with the existing blockchains we have. And then we began to see more layer two solutions like Scroll Avalanche and alongside other layer two solutions where the crypto market, the cryptocurrency market saw unprecedented boom and subsequent corrections from late 2017 to 2018 on what we currently have in the existing blockchain ecosystem.
00:11:17.586 - 00:13:43.414, Speaker B: So we got to also see research focused on improving scalability, improving interoperability, privacy through layer two solutions. And also we also see the rise of the entire ecosystem talking about stable coins where central bank, digital currency image to address volatility, and also integrate digital assets into the mainstream finance. So during this period, we have all of these solutions working really hard to solve the problem of throughput that I mentioned earlier, scaling existing layer one solution and also creating privacy through the existing layer two protocols. Right? But having all of these solutions, all of this protocol, means that we tend to see more decentralized application, because more chains just means more decentralized application. But then how do we add? Or how do we scale? When we get to add more and more protocols with capabilities and more features, how do we scale? How do we make this process seamless for new developers and enthusiasts to get onboarded quickly into the space and then start building from day one? What are some of the users needs that we want to prioritize? Are we talking about privacy? Are we talking about cost? Are we talking about security? What are some of these users need? Because, of course, every DAP with different use cases and then more chains literally means that there will be more daps building on that particular network. So this didn't stop here, because this question is something critical to how we can proceed, or like what the future looks like in the blockchain ecosystem. So what exactly would make us take advantage of this new world where we want to scale? What if you didn't care about the chain you're currently on, and all you just want to do is to interact with that particular decentralized application and then proceed? What if you took advantage of chain differences where you could connect to literally any DAP with a single click, with your assets on your preferred blockchain and you'll be able to interact, swap and then do things online.
00:13:43.414 - 00:14:15.200, Speaker B: What if you could be where your users is? This is specifically for builders, where you're building a particular application and then you're focusing on a particular network or ecosystem. What if you can be closer to where your users are on other ecosystem? So you relieve them the hassle of going through different processes before they could interact, or make use of your native token on your network, or interact with your decentralized application that you have pushed out there.
00:14:18.210 - 00:14:26.482, Speaker C: I'm not sure if you touched upon it yet, but the main problem that's being solved is that blockchains are isolated networks, right?
00:14:26.616 - 00:14:27.300, Speaker B: Exactly.
00:14:27.830 - 00:14:31.894, Speaker C: That's the bridge you're going to gap, right?
00:14:32.092 - 00:15:19.780, Speaker B: Yes, exactly. That's correct. Thank you for that. So the idea here is, like I mentioned earlier, we have different ecosystem, different chains coming up, different protocols, and then what if we have a solution that can connect all of this ecosystem together as they completely work in silos, right? Just like Raza mentioned. So what is that thing that can connect everyone together? And how can we even connect it in such a way that it's connected in a fully decentralized manner and also with a very good security and at the same time very simple to use. This is where Axela comes in. Acceler help you connect all of this ecosystem together.
00:15:19.780 - 00:16:53.730, Speaker B: And Axela itself is a decentralized interoperability network that securely connects all of these different blockchain, allowing assets and applications and users on various chain to seamlessly interact with each other. So this actually solved the main pain point I mentioned just now about the blockchain ecosystem working in silos and also increasing the blockchain adoption. So the network itself, the accelerator network, is blockchain agnostic and then it currently connects all major chains and also allowing you to move or communicate with different protocols at any point in time. So now this is the tool. But what exactly I mentioned, it's a decentralized interoperability network. But what exactly is it? And then where is it sitting on? So, to summarize the entire discussion about what exactly Axela is, is, number one, it's security and decentralized focus, because Axela serves a proof of stake blockchain network that is built on the cosmos SDK dynamic SDK and is built with the mindset of enabling crosschain communication between those blockchain. So it uses validators to securely process and validate crosschain messages by collectively voting on their validity.
00:16:53.730 - 00:18:21.870, Speaker B: And also it's integrated as integrated over 55 plus chain, which means that the ecosystem continue to grow and then continue to feel safe and secure using the network itself. And one last thing I also want to share is that it's very simple to use when I mean simple function call, you'll be able to send assets from one protocol to the other, or interact from one protocol to the other. But now we know it's security and decentralized focus, it's integrated into 55 plus chains and then it's simple to use. How exactly does the acceleration shows the entire flow of the accelerate tech stack where we have the application layer and then we have the layer one gateways, and then we have the acceler network itself. So the application layer, as you can see on the screen right now, showcases like the different ecosystem. Where we have the EVM ecosystem, we have the avalanche, we have the cosmos, and then the picado ecosystem, and then in between them we have the accelerate APIs connected to gateway that is deployed for this different ecosystem. So this API help developer to incorporate the crushing capability into their decentralized application directly.
00:18:21.870 - 00:19:42.374, Speaker B: And again, this gateway ecosystem, like this gateway I mentioned, helps to serve as an entry point for all the crushing messages coming from a source chain. An example here, if you want to send message from scroll to Ethereum, so the gateway serves as an entry point to help you pick up that message, receive that message from source chain, make it get validated on acceler network, and then get routed to the destination chain, which in this example is Ethereum. And also when a message, for example, when a message comes in from the application layer through the gateway, it gets sent directly to the network where it gets verified and then reach consensus. After it gets verified and then validated by 75 plus validators that we currently have, then your message gets routed to the destination chain. So this is exactly how the acceler works behind the scene, like the entire test stack works. And also how you can move, send message, or like move assets from one protocol to the other with just one function call moving on. We have different things.
00:19:42.374 - 00:20:10.160, Speaker B: There are a few things I want to talk about about transferring assets. One of them is sent to kings. So send tokens is something that we have like two different features available for you as a developer. Sorry about that. So we have three different features available. The first one is deposit addresses, the second one is send token, and then the third one is interchange tokens. So I'll go through them one after the other real quick.
00:20:10.160 - 00:21:18.514, Speaker B: The first one is deposit address. You might be wondering what exactly is deposit address? So a deposit address is just a temporary special address that is created and monitored by accelerator service on behalf of the requester. Say for example, I want to send assets from scroll to maybe any other layer two solution. What I just need to do is to use the acceler SDK, create an instant of the accelerates transfer and then set the environment testnet or mainnet and then do it. Call the function get deposit address on the SDK specifying the front chain, the two chain, which is the destination chain that you want to send the assets to, and then the destination address that you want to send the asset to on destination chain and then finally the assets that you want to transfer. So making this function call returns an address for you that can receive assets. So it means that if I'm trying to send assets from scroll to any other protocol after generating deposit address, I can share with anyone that wants to transfer the assets.
00:21:18.514 - 00:22:18.810, Speaker B: And then once that address receives that asset, it gets routed automatically to the destination chain by acceler immediately. So you see all of these things in action during the demo. Hopefully we have more time to go through all of them. But then during the demo we'll be exploring how you can send all of these things between chain and also how fast you can do it. The next one is send token which I mentioned earlier. This is different from the deposit address I mentioned because deposit address is just the SDK that I utilize on front end. But then what if you want to do it on the smart contract itself? So this is where sendoking comes in, right? This is a function that is in the acceler gateway EVM contract that helps you facilitate this token transfer on chain between EVM ecosystem and also the cosmos ecosystem.
00:22:18.810 - 00:23:20.320, Speaker B: So this function call is very simple. Calling send token on your contract and then specifying the definition chain. Like you can see, as you can see on my screen right now with this example where I'm trying to send token to avalanche and then I specify my destination address, I specify the asset symbol and then the amount I want to send. So with this function call, you can be able to bridge this token on chain from the current source chain to the destination chain. And in this case it's avalanche. Then last on token transfer is interchange token. So interchange token allow you to send tokens, crosschain and also build your own asset bridge and also building like asset transfer into your interchange dap with many more custom functionality that you might want to put into your decentralized application.
00:23:20.320 - 00:24:31.650, Speaker B: But then how is this different from the two other features I mentioned is that with its interchange token service or interchange token like you mentioned right now is first you have a portal to do this if you don't want to do this programmatically. So you can just go straight to the portal to create a standardized token and then deploy that token on multiple chain via the interchange portal. I'll show what it looks like in the next slide. And then you also have the ability to build a custom token on every chain with built in method for transfers any way you want to customize it, and for existing token that you might have deployed. If you want to deploy, if you want to upgrade it and then deploy a wrapper of that particular chain on any other remote chain, you can also do it with interchange token. And then last but not the least, is making your interchange tokens executable alongside messages that you want to send from one protocol to the other for enhanced functionality. So this is exactly what the interchange token portal I mentioned in the last slide looks like.
00:24:31.650 - 00:25:22.690, Speaker B: So going through this portal you don't have to know how to code, you don't need to do anything programmatically. If you already have your existing token and you want to upgrade our existing token and then deploy it into any other chains that's currently supported, you can just paste in your address here and you'll be redirected to where you can fill in every other details and also deploy your token remotely to other chains that you prefer. And the other option is to create your fresh interchange token directly on this portal. If you are doing it for the first time, you create it and then you can also select the source chain, you can select the remote chains that you want. So this is the main net version. You can see at the bottom left, it shows like go to testnet. We have both main net and then testnet that you can test things out on your own and you can feel free to scan.
00:25:22.690 - 00:26:43.642, Speaker B: This QR code takes you directly to the platform and then the URL is just interchange testnet, interchange axela dev but this QR code just help you redirect you to the portal for you to start utilizing the portal immediately. So that's it for token transfers. And then one last thing I want to talk about before we go into the demo is the axela general message person. We have two functions available for you when you utilize the axela GMP number one. One of them is core contract and then the other is called contract with. Ok, so now core contract, what exactly does core contract mean? Core contract allow you to, sorry, the accelerate general messaging, general message passing utilizing the core contract allow you to call one function from another protocol. So in this case, if I want to send message from chain a to chain b calling this, and then I deploy this contract on both chain calling this function on chain a where I specify the destination chain and in this case it's chain b and then the contract address and also the payload.
00:26:43.642 - 00:27:50.340, Speaker B: So payload here could be a string, an array integer, or in fact it could even be adjacent that you want to encode. And then the other function here which is underscore execute is the function that gets run automatically on the destination chain, which also takes in the source chain, the source address and also the payload. You see all of this in action during the demo. Don't worry where I would even go in depth on how we can pass this function and then what this function is doing under the hood. And then the second one is call contract with token, which is also another function call utilizing the astral general message passing feature where you also do the same function call. But yeah, in this case you are calling call contract with token on your contract, on your smart contract, and then you are specifying destination chain contract address and then the payload. But the difference here is that if you notice this parameter, we have symbol and then we have the amount.
00:27:50.340 - 00:28:34.770, Speaker B: So you can specify aside specifying like message. You can also specify assets that you want to transfer. And then the same thing happened on the other side, which is the underscore execute function that gets run automatically on the destination chain have similar parameters. So now to just do a recap of what I explained on core contract and then core contract token after. It's like this very simple flow where it takes you directly from the source chain to the destination chain. An example here is I want to send message from ethereum to scope. First what I'm doing for my decentralized application.
00:28:34.770 - 00:29:51.946, Speaker B: I'm making that function call which is called contract and then directly interact with the gateway deployed for the network. And then an event is emitted which a relayer service picks up and then send it directly to the acceler network for validation and then verification. So after it's validated, and then the validator and processors is reached on the gateway, it gets sent directly to the gateway on the destination chain where an event for approved contract call is emitted and after approver, the underscore execute function that I mentioned during the previous slide, which the first one is underscore execute running on the core contract example. And then for the core contract token example is underscore execute like underscore execute contract token. So this is the flow of how you move from chain a to chain b and also the role of acceler validating this call in a decentralized manner from chain a to chain b. I hope you get that clearly. So of course feel free to stop me here.
00:29:51.946 - 00:30:39.066, Speaker B: If you have any question, you can drop them. I will attend to them as we proceed during this presentation. So moving on, let's do the demo. Now that we've covered what is happening behind the scene and some of the things you need to understand about Acceler and then what Axela is doing, the problem that it's solving and also how you can be a part of the entire ecosystem building interchange decentralized application. So in this demo I prepared this URL where you can just go through scroll workshop with Taxela. It's case sensitive. So once you access this URL, it takes you directly to the full project for you to check out.
00:30:39.066 - 00:31:30.530, Speaker B: And then I've also created this QR code for you to quickly take a screenshot and then it takes you to the same URL which is a GitHub repository. So in this demo what we'll be doing is to clone a simple next JS UI. And then we write the smart contract. We develop and compile the, we compile and deploy the smart contract on scroll and then we connect the smart contract to the front end and then we test our application. Excuse me. So yeah, let's get right into it. All right, so I'll be switching to my vs code now, but then I've already cloned the project.
00:31:30.530 - 00:31:53.512, Speaker B: Can you confirm you can see my screen please? Yes. Is it clear enough? All right, thank you. Thank you very much. All right, so let me show you what the repository looks like. This is the repository here. Let me zoom in a little bit. So this is what the repository looks like.
00:31:53.512 - 00:32:48.190, Speaker B: You find a step by step guide on the reading for you to follow along. And also if you want to do this on your own, you can just take a look at it and then clone the project, navigate into the project directly and then install the dependency, install dependency on the hard hat project. So the first thing we're supposed to do here after cloning the project is to do NPN install in the root project. I've done that already, I don't need to do that again so that we can just quickly move faster. Another one here is to navigate into the hard hat directory, which we can do with hard heart CD into hard hat directory and then do the same NPM install. So this would install packages, you might be wondering what exactly are you installing? But then I will go through all the project directory in a second. Let's just keep going.
00:32:48.190 - 00:33:23.610, Speaker B: So we have, after navigating into the directory, we run this command NPN install. We set up variables to deploy the smart contract. So in this case, what exactly are we creating? We are creating a EM file in the hard hide directory and then we're specifying our private keys. So now let's go into the project and see what the project looks like, why this is still installing. Let me see if it's done. Okay, yeah, we're good to go. So we're done installing, now we need to set up our private key.
00:33:23.610 - 00:34:07.056, Speaker B: So in this, my example, if you clone this project, you're also going to see something similar to this, right? So exactly like this. The only difference is that mine, let me show you what my contract looks like. My contract is now empty because I'm trying to go through the entire thing from scratch on this call. But then when you clone the project, you find a complete contract code there that you can check out. In fact, if you are trying to code along and then you get stuck, you can just check out the finished project on GitHub. So in the project we have the hard hat directory and then we have the react application. So this is an SJS application and then plus the smart contract.
00:34:07.056 - 00:34:58.656, Speaker B: So the hard hat contains the contract, the script to deploy the contract, our environment variable, and then some other hard ad configurations that you need. All of these things have already been configured on the project. You just need to go through them and then deploy to your preferred network. So in this example, what we'll be building is a crossing bounty dap that allow you to send token from chain a to chain b. But in this example we'll be sending token from scroll sepulia to it sepulia. So now the first thing first we need to write the smart contracts. So as you can see on my screen, I've imported a few things here from Acceler.
00:34:58.656 - 00:36:04.488, Speaker B: So the first thing we are doing here is, let me zoom in a little bit. So the first thing we are doing here is to specify the compiler version and then we are importing the acceler executable from the accelerate, which will allow the contract to run the underscore security function automatically on the destination chain. And then we are also importing the interface, the gateway interface directly from the same Axela GMP SDK solidity and also the gas service. So there's one thing about the gas service here and then why it is important. I will talk about that during once we start implementing descend token functionality. And then lastly we are also importing the interface for ERC 20 token because this is the token we'll be sending from scroll to its sepulia. So now what do we have on the contract? We've created the contract called bounty and then it's inheriting from the axelized executable.
00:36:04.488 - 00:37:23.540, Speaker B: So first thing we defined here was the gas service. So we created an immutable variable for the gas service using the interface we imported at the top and then we defined these two function, which is the amount received and then the bounty recipient. So this is important when we want to display on our front end the amount that was sent to the destination chain, in this case like the amount received on the destination chain and then the bounty recipients who are those who receive the bounties on the destination chain. So this is why we are creating this two state variable to store those data and then in the constructor, what do we need to do? We need to initialize the actualized executable with the gateway. If you remember during the presentation I mentioned that for different ecosystem we have like gateway deployed for different need to. In this contract we need to specify which gateway and then the gas service that we are using. So the gas service here is a contract that is already deployed by acceler and then help you with paying gas and then paying gas on the source chain, paying gas on the network and also in the destination chain.
00:37:23.540 - 00:38:07.024, Speaker B: So these two variable, I'll show you how we get that when we want to compile and deploy. But then let's just move on. So now these are the things we need to get started with. And then we have other three to dos here. The first one is to send bounty to the recipient which is one function that we are going to create. Another one is view function to get the list of bounty recipients which will be showcasing on our front end application at the end of the day. And then the last one here is the underscore execute function that we are going to create that would help us execute this token transfer on the destination chain directly.
00:38:07.024 - 00:38:51.270, Speaker B: So to start with I will quickly come in trying to navigate. Um. Okay. All right, let's go. So the first thing first, what we are going to do is to define a send to many function. But because we have quite a lot of things to cover, I'll just do that real quick here. So first thing first, what we are doing is to create a function that allow you to send, that will allow us to send this token to our specified destination addresses.
00:38:51.270 - 00:39:53.470, Speaker B: Right. So first thing here that I'm defining, I'm defining the destination address, exactly what you saw during the presentation when I was giving the example of core contract and then core contract, it's okay if you specify destination chain, texting the destination chain the destination address and then the destination addresses. So this destination address here is the destination that the recipient will receive the token on, while this other one destination addresses is the addresses that we want to send the token to on the destination chain. And then the symbol of the token and finally the amount. So moving on. First thing we need to do is to get the token address. So we get the token address using the provided symbol, and then we approve the gateway to spend the bounty amount.
00:39:53.470 - 00:40:45.790, Speaker B: So what we are doing, before we approve, we need to transfer the token from the contract from the user and then transfer it into our contract. And then after that, we cannot approve the accelerate the gateway to spend that particular amount that was transferred. So this is two different things that we are doing right now. So the first year, as you can see here, first one here, we are transferring the amount from token address from descender to this particular contract address. And then we are specifying the amount. And then the second step is for us to approve the gateway here, the gateway that we defined here to use to spend this amount that was approved. So now, sorry, we're done with that.
00:40:45.790 - 00:41:27.066, Speaker B: And then the next thing we want to do is since we are going to have different destination chain addresses and then we want to send the bounty to both addresses, then what we need to do is to encode the addresses. So we just specify the payload, like I mentioned earlier during the presentation, that it could be anything. But in this case, we're specifying an array. So we are encoding that array here. And then what are we going to do next is to pay native gas for this contract call. But there's something I want to explain here. You know that if you want to interact with any blockchain, you pay gas, of course.
00:41:27.066 - 00:42:08.520, Speaker B: But then in this case you are paying gas. You're doing a cross chain call. How can you pay gas for? Gas is required for the source chain that you're sending the transaction for, and then the acceler network itself and then the gas on the destination chain. So this is the gas we are paying. And then we are just calling the Axela gas service contract that was deployed to pay this gas. So now it means that when you pay native, you pay a gas in the native currency of that particular chain. That you're currently interacting with or your source chain and then acceler handles the rest.
00:42:08.520 - 00:42:50.870, Speaker B: So let me quickly show you how you can pay gas directly from the gas service interface that we just imported. So the first thing we are doing here is to call the function call pay native gas for contract call with token. And then we are specifying the value. But it's important here that because this is a question call, we need to pay the gas here. We need to now require, we need to go back and make sure that gas is paid. We need to make sure gas is paid for this so that the transaction won't fail on the contract. So if it's greater than zero then we can say bounty.
00:42:50.870 - 00:44:12.444, Speaker B: Let me just say, let me call it that payment is required. So if it is zero, it needs to be greater than zero so that there will be a valid value that you're sending when you are calling this function here. So now moving on, the first thing we are specifying here is the address which is this contract, and then the second one is the destination chain that we're supplying from the function. And then the third one is the destination address and also specifying the payload, the symbol, the amount. So you might be wondering what exactly is message or sender doing here? So for example, if you are trying to send message from scroll to eat sepulia, from scroll sepulia to eat sepulia in this example, and then you pay gas, let's say you pay 0.1 worth of gas and then after the end to end crushing call and the transaction gets executed successfully, the gas utilized is just around, let me say 0.1, which is way lower than the amount you pay.
00:44:12.444 - 00:45:10.272, Speaker B: So that remaining gas, the leftover gas will be refunded back to the address that is specified here. So in this case we are specifying the sender, the person that called this particular function here. Right. So now that we've triggered, we can go ahead to now do the actual gateway call contract with token call, which does the actual transfer that we want to do from one blockchain to the other. So here we are calling on the gateway, we are calling the core contract with token, and then we are specifying the destination chain decision address, the payload and the amount, all of this data and data that is already available within this function. And then that's it for, okay, let me try and install. All right, sorry about that.
00:45:10.272 - 00:45:47.084, Speaker B: I just wanted to confirm I have everything set. So now we've created, let me zoom out a little bit. So we've created this function that allow you to send to many. And then we specify all of these things. So what are we doing next is to retrieve, to create a very simple function to retrieve the bounty addresses. So we are creating this function so that we can reuse it on the front end to see those that received this amount directly. So we are doing a function call here.
00:45:47.084 - 00:46:33.990, Speaker B: It's also a view function call. It's a public view that returns the amount. So it's a public view function that returns the recipient or the entire recipient and then return, of course, in an array of addresses. And then the last one we are doing on this contract is the underscore execute with token that gets run automatically. This is where we do the actual disbursement of the assets that was sent from the source chain to the destination chain. So it's pretty straightforward. I will just get this here so that we can move real quick.
00:46:33.990 - 00:47:12.830, Speaker B: All right, so this is what I just mentioned right now, the das function. So this first parameter, you might decide to specify it. Maybe the first one is the source chain and then the source address. If not, you can just leave it here. And then the next one is the payload that was sent from the source chain. And then the token symbol, then the amount. So what this is doing is first we are decoding the payload that we sent on the source chain.
00:47:12.830 - 00:48:05.646, Speaker B: And then after decoding it, we use the token symbol that was sent to get the exact token address for this particular token. And we are saving the amount that was sent from the source chain and then the recipient into this bounty recipient and the amount received that we created at the top earlier on. And then moving on, we have where we distributing the token. So we are just doing a very simple mark by getting the cent amount. So by creating a cent amount variable where we get the amount and then divide it by the number, the length of the recipient. For each recipient, we transfer the amount. After division, we transfer the sent amount to those recipients individually.
00:48:05.646 - 00:49:01.422, Speaker B: So this is where we dispose the actual token that was sent from the source chain to the destination chain. And then this function gets called automatically. So once you just send, and then the end to end crushing gets executed, you should expect this amount to get sent to be sent from that address, that is sending to those specified destination addresses. So now we are completely done with the contract building the send many token, send to many token and then the get recipient function and also underscore execute the token. So now we're done with the contract. Let's compile and deploy the contract. So I've already created a script that can help you to do this, a very simple way for you to deploy any hard hat contract.
00:49:01.422 - 00:49:45.058, Speaker B: But then you need to specify, remember in the contract here we have in this constructor we have the gateway and the gas receiver. So in this case we are deploying on scroll and also it's sepulia. So scroll, sepulia and its sepulia. So what we need to get is the gateway address and then the gas service address for these two network and then we deploy it and then we use the contract address on the front end application. So now let's get the gas service address. So you can just head over to docs the acceler here and then testnet. Under testnet you find all the addresses that we need.
00:49:45.058 - 00:50:17.974, Speaker B: So in this case the first one we are deploying to is to scroll. Yeah this is it, scroll. And then this is the gateway contract. We just come back here and then enter the gateway contract. And then the other one is save this so that it's more clearer. All right, so the other one here is the address, the gas service address, come back here and then deploy. So I can decide.
00:50:17.974 - 00:50:54.838, Speaker B: Let me just try to clean this up. All right, so I can do the deployment directly by running the script I specify here. If you remember like all of this step. I already detailed it here and then you can just follow through one after the other. So we are currently here where we want to compile and deploy the smart contract. So we can just copy this and then go to our terminal. Remember that you need to be in the hard hat directory because this is where we want to deploy our smart compile and deploy our smart contract from.
00:50:54.838 - 00:52:20.470, Speaker B: So now let me, all right, so go back here and then paste and then the network, yeah, for you to know which network you can check the hard hat config. So in this case we are deploying to scroll sepulia. So once you just specify, scroll sepulia here, you can go back here and then just enter scroll sepulia and then click deploy. So clicking deploy here should deploy this contract to score shepherd for us. So compile, compilation completed and then we're waiting for the contract to deploy. Okay, let me just retry this, let me try to redeploy and see. If not, we might just change the RPC URL we are using.
00:52:20.470 - 00:52:32.324, Speaker B: Okay. She's strange. Are you there?
00:52:32.522 - 00:52:34.710, Speaker C: Yeah, that one actually should work.
00:52:39.310 - 00:52:40.074, Speaker B: Was that what?
00:52:40.112 - 00:52:46.522, Speaker C: Sorry, no, I think I saw the correct RPC URL. Let me pull another one.
00:52:46.576 - 00:52:51.420, Speaker B: Oh, ok. All right, thank you. This actually works before now.
00:52:51.970 - 00:52:54.560, Speaker C: Yeah. Was it an RPC issue?
00:52:57.890 - 00:53:02.190, Speaker B: I think so. If not it should work as expected.
00:53:06.610 - 00:53:09.566, Speaker C: I dropped a new one in the chat, maybe you cannot pass that one.
00:53:09.668 - 00:54:04.120, Speaker B: Okay, maybe let me just open up the terminal here and then bring the deployment trying to deploy. Nah, I don't think it's pc issue. I'm just getting like different error message. Okay, wait a second, let me try to use what you just sent. K 1 second. All right, everything should be fine now. Save, let it.
00:54:04.120 - 00:55:04.150, Speaker B: Yes, I think it's the RPC issue. So it deployed like almost 2 seconds immediately. Things we see during demos. So we can save this sepulia with sepulia address? Yeah, we're just saving it here because we are going to do the same for its sepulia. So let me go back to accelerate documentation. Scroll up a little bit to where we have the Ethereum sepulia and then we can also copy the gateway contract address and update this and go back here to copy the get service for that. So now we're good.
00:55:04.150 - 00:55:32.080, Speaker B: So the next thing we just need to do is to go back to our terminal. Instead of specifying this course Apollo network, we just specify its network and then that should deploy on ethereum. Okay. Yes. So I think all my RPC have decided to fill me, let me just get a new one.
00:55:57.190 - 00:55:59.010, Speaker C: Are you searching for sepolia?
00:56:00.070 - 00:56:02.190, Speaker B: Yes, Sepolia.
00:56:02.270 - 00:56:05.098, Speaker C: I think it's best just type out sepolia.
00:56:05.134 - 00:57:11.580, Speaker B: Yeah, I think I found the stable one in case you're trying this yourself. Also when you try to deploy. I've experienced this quite a lot different times. For some reason the RPC is working in the next minute is no longer working. Or if you have like inferior accounts, you can just directly use the RPC on your referral account. Okay. Oh yeah, I got this error which is why I settled with Claire.
00:57:11.580 - 00:58:06.270, Speaker B: Try this again. Let, yes, successful now. All right, so now we can just note that again deploy file. So I'm saving it here because it's easier for us to get where we need it. So now we've successfully compiled our contract and then deploy on scroll sepulia and also ethereum sepulia. That means we are completely done with the contract side of things. And then now we can now proceed to front end.
00:58:06.270 - 00:58:37.876, Speaker B: Let me close all of this. Yes. So now we have the contract to do this. So let's just quickly look at, so the front end application contains a lot of styling, but because of time we just go straight to the functionality on where we are interacting, how we are interacting and what are the variable or like data points or argument that we are passing. So that is going to be our focus. So here, let's open up. So this is what the index JS file looks like.
00:58:37.876 - 00:59:39.096, Speaker B: So we're just doing a few importations and also importing our school contract address and then school sepulia contract address and also the IT sepulia contract address. But first thing before we start here, if you take a look at this indigenous js, we are importing them directly from our environment variable. So the two addresses that we copied right now, give me a second. When you go to your M local environment, you can see it's already specified, it's here. So in your own case that you're following along or that you just cloned this project fresh, you need to create local on the root directory and then specify the Nesco sepulia contract address variable. Same thing for Ethereum school contract address and also sepulia RPC URL. So in our own case let me just disable the struggling and then go back to so this is what it looks like.
00:59:39.096 - 01:00:43.500, Speaker B: But now since we have deployed a new address, I will just use that instead so that you see how we do this from scratch in a second kid and save this somewhere so that we can be able to get it back. I'll tell you where it's going to be useful later on. So let's go back to the hard hat project where I saved my previous contract address. You can copy the one for scroll, go back to and then paste for scroll and then go back and paste for it's a pullia. So coming back here I can place for it's a pullia. And now we have our local environment variable sorted right. So we can go back to our front end application, there's a JS file and then let me close this.
01:00:43.500 - 01:01:51.940, Speaker B: So this is what we are doing, we are just importing here and then what we're doing next is we're setting a couple of variables, press to get to hold our amount and also addresses also that we get from the address that you supply which are the receiver of the bounty. And we are also doing some state visibility. These are just typical react application to set state and then remove approved button set visibility of test area which will be seeing all of these things when I spin up this application right now. And then most importantly we are using the accelerator to get the gas price estimate because if you want to send a crosschain transaction you don't know how much gas it will require for that transaction to go through. So you might want to hard code it but the recommended way of doing this is to use the SDK and then when you specify all the required data, the SDK will help you to estimate the gas price, the exact gas price that will be required for that transaction to go through. And then this is what we are doing here. Yes.
01:01:51.940 - 01:02:09.672, Speaker B: So this is where we are importing the accelerator query API and we are also creating a state variable to save the gas fee and then set the gas fee. So now moving on, we also created another, sorry, I can hear you.
01:02:09.806 - 01:02:23.070, Speaker C: Yeah. Perhaps also good to mention because the risk of not setting the gas fees properly is that on one blockchain the transaction will revert and that actually messes up everything, right? Yeah, because you have exactly assets if you don't do that.
01:02:23.600 - 01:03:03.424, Speaker B: Yeah, exactly. Yes, exactly. That's correct. And another thing, we even try if you're trying to make a cross chain call and for some reason if you send insufficient gas fee because of this issue of getting where gas fee gets lost and all of that, we've also made it easier that you can call another function, SDK to add gas to that existing gas amount that you paid and then it will add enough gas for that transaction to go through. That's option a, doing it programmatically. If you want to also do it from the Asella scan Ui. Let me just go to the testnet so you see about this testnet.
01:03:03.424 - 01:03:43.530, Speaker B: Okay. Let me go to the home page and then check GMP so you can also do it directly from the testnet. I'm trying to see if I can get a transaction that the gas filled. This part is very important like you mentioned. So contrary token. Okay yeah, not enough gas. So let's search for not enough gas and see if you could get like a particular one that requires gas to be paid.
01:03:43.530 - 01:04:35.380, Speaker B: This is very important to talk about. 1 second, looks like I can't find any gas feed but anyways I can't find any. But ideally when you have let me click on this UI so you can see what I'm talking about. So when you have like any. Oh yeah, perfect. This is one of them, right? So this is a transaction that is coming from polygon to base and then enough gas was in pay. You can see I say switch network because I'm not currently connected to polygon, I'm currently connected to score sepulia.
01:04:35.380 - 01:04:57.390, Speaker B: So ideally I'll just switch my network here and then the button for pay gas, let me even try it so you can see it shows add gas. I can just pay gas directly here and then it will restart the process, like continue the process and then make the transaction go through right. Because I don't know who owns this.
01:04:57.920 - 01:05:54.860, Speaker C: But how does that work then? So for instance, let's say traditionally speaking, two networks are isolated, right? So let's say I send wrapped eth back. So I have on the destination chain wrapped ETH and I want to send back to the source chain where there is ETh. So from scroll to, let's say, sepolia. Then in that case, if I initiate the transaction from scroll, there's not enough gas fees for sepolia. How does it work with XLR? Because in a more traditional setup, it means that your wrapped eth is burned on the destination chain and on the source. In this case, the destination is actually, you know what I mean? So the wrapped eth is actually burned, but then it's not unlocked on l one, and then it's gone forever.
01:05:55.840 - 01:06:52.556, Speaker B: Yes. So this is how hacksala is handling it. So if you pay, for example, a gas and then it's not sufficient for that particular end to end transaction from scroll, from scroll, sepolia to its sepulia, then ideally the gas you are paying caters for the transaction from scroll, the pays confirmation fee on accelerator and then pays for the destination chain. So what we're doing basically is that if you don't pay enough, you can see the status here. The process is hot in this status before it gets confirmed on the source chain. So if there is not enough gas to cover the entire transaction, the fund is still made available, it's not lost. But then the transaction won't go through until you add enough sufficient gas fee.
01:06:52.556 - 01:07:37.650, Speaker B: And then after adding it, the gas fee phase is different from the confirmation phase. So the confirmation happens on the source chain, but before it happens on the source chain, if the gas paid is not enough, the transaction is stock like this one until you now add gas to now go through, like until you have a sufficient gas that will allow you to go through get confirmed on the source chain, on the axela network, and then the destination chain. It's just like a process of halting the flow until all promises or like all requirements are fulfilled for that transaction to go through. And then you'll be able to send it. That transaction will be able to go through at the end of the day. How? That answers your question.
01:07:38.020 - 01:07:42.080, Speaker C: Yeah. So XLR is more like a safety mechanism built in.
01:07:42.150 - 01:07:45.216, Speaker B: Exactly. In this case, yeah.
01:07:45.318 - 01:07:53.936, Speaker C: Because traditionally in a bridge contract, your funds are just lost. So with XLR, it's kind of like warning. You have an option to add gas.
01:07:54.128 - 01:08:10.132, Speaker B: Add gas, exactly. So you can add it programmatically. In case you're not dealing with uis. And then if you've already sent the transaction and then you can just come to accelerate scan and then click on this button to add sufficient gas that's required for that transaction to go through.
01:08:10.286 - 01:08:11.260, Speaker C: Gotcha.
01:08:11.680 - 01:08:45.200, Speaker B: Yeah. So now this is an example. So this is what we are trying to avoid here by using the SDK so that our transaction doesn't get stuck. And then we have, oh yeah, so we have some other stuff. So here, this is where we are approving USDC to be spent. So it's important that the token we are sending from scroll sepulia to each sepulia is AUSDC. So what we are doing first is we are approving AUSDC to be spent by this contract.
01:08:45.200 - 01:09:23.740, Speaker B: And then we are just calling the approve function on the AUSDC contract. And we are specifying our contract address and then the amount. So this amount is gotten from the variable, any amount entered like on the UI, we approve the amount I'm using here. In this demo, we're using Wagme. So we're using that to listing for the transaction once it goes through. I also created this function here. Might not be really useful, but then it's also good for you to track if it has actually been allowed, like if the allowance is available before you proceed.
01:09:23.740 - 01:10:16.624, Speaker B: This is also another step for you on your application to avoid errors and all of that. So after we're done setting up this function, this is where we are calling the estimate gas fee dimension. And then we are able to specify where the transaction is coming from, which is the source chain, and then where it is going through, which is sepulia in this case. And then we are specifying the gas token type, which is in this case crow. And then all other parameters for us to get a particular estimate for this gas, for this gas value. And then we move on to descend bounty. So this is where we are calling the actual function that we created on the smart contract, which is the send to many function.
01:10:16.624 - 01:10:51.500, Speaker B: And then what are we specifying? Remember that we have, okay, let me just show you so that you can see, let me show this side by side so you can see where this value comes from. And then let's put this. All right, sorry, I need to close one of these. All right. Yeah. So this is the value that we are specifying here. If you check the send to many function, this is what we are specifying here.
01:10:51.500 - 01:11:14.884, Speaker B: The destination chain, destination chain. Here is Ethereum sepulia destination address is ethereum sepulia contract address. And then we're also specifying the addresses in this case. This is the address area that we have and also the symbol. I'm specifying AUSDC. Then the amount. I'm specifying the amount here that is passed from the front end.
01:11:14.884 - 01:11:48.188, Speaker B: So this is what we are sending when we call the send to many function. I remember that we are also validating gas value which is the value we specified here on the left hand side. So let me just close this. I hope we all understand how we can specify those value individually and then call this function from the front end, from any of your front end application. In this case we are using NSGS application. So we wait for the transaction. Once it goes through we can call the wait mansion.
01:11:48.188 - 01:12:39.212, Speaker B: I'm also doing some validation here to be sure that the address that you're trying to send font to is a valid address here. These are just like front end validation that is nice to have on your decentralized application. And then this is the actual send button function that we are calling. So whenever you enter the addresses and then you click send after approving and then you click send, there are a couple of validation to make sure that you enter amount and address. This is invalid to make sure that the address we entered is valid. And also I'm also checking to be sure that you have already allowed that amount to be spent. And then we call right writes is the function that actually does the call on chain and then it shows this toast notification.
01:12:39.212 - 01:13:10.984, Speaker B: So if you are doing on your own you can decide not to use toast. You can just console log and just make things faster. But I believe like toast just specify the entire thing and also helps you to track individual steps. And this is the function we created to call the approve function. Here we are just calling the function that we define at top level. And then we are sending a notification to let user know what is currently happening. And then finally we are reading data from the destination chain variable.
01:13:10.984 - 01:13:55.304, Speaker B: Remember that we saved the amount received, the recipient and all of that. So this is where we are calling the function on the contract to retrieve the amount received and also to get all the recipients. And also we are now setting the amount to the state variable that we created earlier on and every other thing that you can find here. So these are just like tracking what is happening. And yeah, you can find every other thing on the UI. So if you scroll down here, you see that we have like send function, handle send bounty. We have the array that is looping through the total amount sent and the length of the recipient and all of that.
01:13:55.304 - 01:14:29.750, Speaker B: So enough of this UI thing. Let me go back to the project and then just Claire, Claire. And then we can just do NPM run there to start up this project. So now we have the project up and running. I'm just allowed it to load. Exactly. So here we go.
01:14:29.750 - 01:14:59.676, Speaker B: This is what we have, a crushing bounty dap on scroll with acceler. And then we are currently connected to Mumbai. But Mumbai is not where we want to be connected to. So let's switch back to school sepulia. And now we are on school sepulia, so should in case of course I have my faucet. If you don't have faucet, I would encourage you to go to the school documentation and get your faucet. If you need sepulia faucets, you can click on any of this link to get your faucets.
01:14:59.676 - 01:15:33.870, Speaker B: It's free. And also for school sepulia faucets, you can get yours here. This is actually where I got mine before this presentation. So it's tested and trusted. So the other one here, if you want to bridge, maybe you have existing, it's faucet that you want to breed to scroll sepulia, you can also do that here. So now going back to our application here we have the UI, we have the interface, all the code that you saw earlier on that is kind of Ui related. This is what it looks like at the end of the day.
01:15:33.870 - 01:16:01.340, Speaker B: Sorry, I can't find mine. Okay. All right, so this is what we have here. We have the function here. So in this case I want to send, let me show you what the balance looks like first. So I have 489.5 a USDC.
01:16:01.340 - 01:16:29.328, Speaker B: So I want to send 20 out of this balance to two different addresses. Right. So I need to specify the amount. So in this case I'm specifying 20 and then I will click on approve. So we are approving the amount, this amount to be spent. And then you can now click next and it takes you back to the application. So it shows approving.
01:16:29.328 - 01:17:15.924, Speaker B: And then once approval is completed, we see a notification that says AUSDC approved for spending. And now you can see there's a chain in the UI here where we now have the addresses, the impute fee to enter your addresses. So now let me quickly just copy two of my account address. Okay, let me copy this address, this address one and then separated by comma, very important. And then let me use the second one. I think I already have two accounts here, so let me just use the second one for the sake of demo and then click send. So when you click send, it says sending bounty and then you need to approve this amount.
01:17:15.924 - 01:17:39.630, Speaker B: So now I'm approving. We are on scroll. Sepulia, right, says sending bounty. Need to wait for a few seconds so we get it. Okay. Yes, I know why we are getting this error. This is because you're trying to read from.
01:17:39.630 - 01:18:06.888, Speaker B: So let me just comment out this for a second and then we'll be back. Yes, so we don't want to read yet. We just sent the transaction. So now let's take a look at the transaction, what it looks like, where it's currently at. So if you check, you can see, I just confirmed this, I can copy the transaction id and then go back to accelerate. Accelerate. It's just accelerating.
01:18:06.888 - 01:18:38.744, Speaker B: So we can see what is happening to our transaction still loading. So you can see that sent successfully and then you can see what we are sending from the source chain. Gas has been paid. Of course we utilize the SDK to estimate gas so it's very sure that it's not going to get stuck. And then where we are right now, we are waiting for finality. And then this finality is based on the time confirmed on scroll. And then after that it gets to the approval stage and then gets executed.
01:18:38.744 - 01:19:32.000, Speaker B: So because of time, we are running out of time already. In fact, I think we are out of time. So what I'm going to do here is while this is running, we can go back to our application and then I'll go back to the EMV that I used earlier on and I can just switch back to a transaction that already tested. And then I've gone through end to end and at the same time I'll go back to the index JS file, I'll go back to the index JS file to comment, to read variable. So reading variable here, what we are doing is we are reading those details from the destination chain. So now that I've updated this, we should see something different. So going back to our application, let me refresh the page and then switch my network to Sepolia.
01:19:32.000 - 01:20:10.424, Speaker B: So let's wait for a second for you to retrieve this information. And then we should see this. Right during the demo we sent 20 USDC, but for this one that I'm using to showcase, I sent ten USDC AUSDC. And then the total address, you see these two information is what we saved on chain the other time. And then the total addresses is two in this case. So you can see the first address and then the second address. The first address, the amount received is five a USDC and then the second one is five a us.
01:20:10.424 - 01:20:47.956, Speaker B: So it's splitting accordingly. This is to adhere to what we wrote on our smart contract to split based on the length and then equal amount. So voila. This is how you can build a full stack application from front end and also building your smart contract compiling and deploying on scroll and then sending it. So let's take a look at, let's take a look at first back to the presentation. Let's take a look at the transaction. This is the transaction for what we currently have on the react application.
01:20:47.956 - 01:21:30.876, Speaker B: You can see everything goes through and then one good thing that you can also take advantage of is to track different stage and then what is happening. If you scroll down here you see at every stage what happened. And then there's also a transaction reference that happens on chain that you can check out at every level during this execution. And if you take a look at this last step, it shows refunded. Refunded here means that we were charged 0.9008 gas, but at the end of the day the gas that was used was 0.87 114.
01:21:30.876 - 01:22:13.546, Speaker B: And then we have some leftovers. So that leftover is what was refunded back to the sender account, which is my account. So that's another good thing. So even if you decide not to use the SDK to estimate and then you overpay, you'll be refunded the amount that is remaining. And then yes, that's it. So to finalize, to just end the entire presentation and also to see if you have any question, I just want to talk about one more thing. Yes, now what I just showcased is building a full stack decentralized application.
01:22:13.546 - 01:23:35.986, Speaker B: And then we specifically utilize just the core contract with token and then with the front end application. But we have other examples that you can check out or benefit from where we example specifically for core contracts, for contracts with token, for send acknowledgments like sending two way communication on contracts and also sending NFT cross chain and all of quite a number of examples available on this repository that we have prepared for you. And you can check, you see the smart contract, you see how to test them directly locally on your system, like on your own local environment. Once you clone this project you'll be able to follow through. And then we have a detailed readme that you can go through on your own to test out things and see how you can leverage accelerate cross chain transaction like any cross chain communication calls. So this is number one and number two for foundry funds. We also have a dedicated repository for foundry acceler, GMP, example where you can also find example for contrast token, but now doing it in a foundry with the first one utilizes adhart and then this one strictly utilize foundry.
01:23:35.986 - 01:24:51.022, Speaker B: First of all those that want to test things out, you can check out this project and then you'll be able to build your application, compile them, deploy it to any of your preferred network and then test directly on your local environment. So what next? Now that you know how to do the end to end test and all of that, it's important we know how important it is to support developers and also that at some point you have questions, clarification or know fixes or clarity on what you are currently working on. We have a dedicated repository which is the acceler. If you go to the acceleration support you would see this repository, you can create an issue and they will be happy to help and help you fix and make you successful as a developer. So last but not the least, yeah, this is a very short QR code and I'll be glad if you all can scan or go to Olaniso survey to give feedback and tell me how this session have been beneficial to you. If there are anything to improve on and I'll be happy to get all of those feedback. Thank you very much.
01:24:51.022 - 01:24:51.870, Speaker B: Raza.
01:24:52.370 - 01:25:14.470, Speaker C: Yeah man, that was amazing. I especially know the UI. I think bridging can be scary. I think it also has like because of the security and attack factors, it's sensitive. So it's pretty cool to see that. First of all, love the gas estimator. Then second, I think it's very important.
01:25:14.470 - 01:25:26.042, Speaker C: What you mentioned at the end is that you get any overspent on gas, you get it back, because that can be very confusing when you see it in metamask. So that's also really cool that you can.
01:25:26.096 - 01:25:26.940, Speaker B: Yeah, exactly.
01:25:27.950 - 01:25:57.620, Speaker C: But most importantly, when I was diving into bridges, the one thing that scared really the hell out of me was the risk of losing your funds. Especially because like you said at the start, blockchains are isolated networks, but that means that they don't really talk to each other. Transactions are atomic, which means either everything happens or it reverts. And if the initial transaction burns your assets, you really have a problem.
01:25:58.070 - 01:26:33.726, Speaker B: Exactly. So I think that's why we have this. So we try to simplify things for you. And also considering the developer experience, this is our top priority. So not just for the end user like they said, but also for developers that want to build application. How can we abstract a lot of things that you need to think on our start from scratch, how can we make life very easy for you. And also not just doing it because we want to do it, but doing it in a decentralized manner that you can see as everything move from one chain to the other.
01:26:33.726 - 01:27:12.970, Speaker B: And also within the accelerator network, you can see what is happening under the hood. And we have different documentation. In fact, on our YouTube channel you see different specific videos to specific things that we currently do. And some of these features that you can take a deeper look at what is happening under the hood and of course, the documentation that provides full details on how you can safely do on chain bridging and also other things that we currently offer like deposit addresses, the interchange token service and GMP. Generally.
01:27:16.280 - 01:27:16.980, Speaker C: Yeah.
01:27:17.130 - 01:27:17.830, Speaker B: Yes.
01:27:18.140 - 01:27:32.430, Speaker C: Okay. I don't think we have any questions in the chat. Okay, thanks a lot, Idris. I really enjoyed the workshop. I think it was very clear. It's pretty cool that you guys have started templates. I'm a huge fan of that from a devex point of view.
01:27:32.430 - 01:27:51.880, Speaker C: And yeah, I hope everyone enjoyed this workshop. We'll be definitely aiming to give you more so we provide more exposure to the ecosystem and everything that developers can build. We're going to cut the session here and hope you guys will see the next one. And Adris, again, thanks a lot for your workshop.
01:27:51.960 - 01:28:00.570, Speaker B: Yes, thank you. Thank you guys for joining. Bye for now. Bye.
