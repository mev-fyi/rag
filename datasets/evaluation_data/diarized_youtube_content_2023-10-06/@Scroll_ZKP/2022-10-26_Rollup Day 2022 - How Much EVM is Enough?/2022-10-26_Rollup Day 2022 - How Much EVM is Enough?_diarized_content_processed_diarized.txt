00:00:16.570 - 00:00:45.434, Speaker A: Thank you very much. Thank you, everyone, and welcome to one of the three panels that we've got today. We've got a little competition. Which panel is going to be the spiciest? So we'll see how we go about this one. And I'm Bartek Kipushevsky. I work for makeadao. I'm primarily responsible for the multi chain strategy at the Mercadao, and I'm literally the client of all these four teams, more or less.
00:00:45.434 - 00:01:09.460, Speaker A: Right. So they need to convince me that it makes sense to deploy Mercado on their system, I hope. And so maybe let everybody kind of introduce themselves. Which projects do you work for, obviously, and I want one sentence stance on how important is the EVM equivalence to your particular project?
00:01:10.630 - 00:01:12.180, Speaker B: The importance of what?
00:01:12.710 - 00:01:18.534, Speaker A: How important is the EVM equivalence to your particular project? Just one sentence stance. Right.
00:01:18.572 - 00:01:31.990, Speaker B: And we're going to go deep for us, developers should not notice the difference between deploying or working in Ethereum or working in ZigVM.
00:01:33.710 - 00:01:43.600, Speaker C: Okay. For us, I think we sacrifice a lot of efficiency just for developer experience to achieve EVM by co level equivalency. So we sacrifice a lot. So just for this.
00:01:44.610 - 00:01:52.880, Speaker D: Hey, my name is Mark and I work at optimism, and I believe that if you don't have even equivalents, you're not going to make it.
00:01:57.190 - 00:02:11.720, Speaker E: Hey, everyone, my name is John, one of the co founders of fuel labs. Contribute to the fuel project on occasion with some peer reviews for fuel. If you have EVM equivalents, then you're not going to make it.
00:02:13.690 - 00:02:42.286, Speaker A: All right? So I think it's a good start. So again, this is not a space. Here we have two Zk EVM projects, right? Polygon and scroll. We've got optimistic EVM equivalent project and we've got like really not EVM equivalent, right? So it's almost like three against one. And yeah, we're going to see. So maybe let me start then. Let me help John a little bit.
00:02:42.286 - 00:03:25.070, Speaker A: I'm going to start with the quote from Nick Dawson, who's probably somewhere here sitting from fuel Labs CEO. Well, he said in one of his tweets that execution layers built on top of Ethereum don't need to be backward compatible and in fact can do whatever is necessary to deliver global throughput and adoption. For Ethereum, the continued use of the EVM SL one or L two will create an expansive and highly constrained design space for blockchain applications, restricting global accessibility to only a select few who can afford it. So, guys, I mean, how do you respond to such a strong critique.
00:03:27.810 - 00:04:15.280, Speaker B: We have a huge ecosystem, so we have a lot of applications. A lot of people that's building on top of that has happened since the EBM was launched in 2015, seven years since now. And there is a lot of work done on that side. I'm not saying that things cannot be improved, but there is a huge ecosystem that's comfortable in how this works and the tooling and is working on that space. They're doing it from scratch, may have sense. I fully respect it's an option. And sometimes these things you have to do it, but it's hard.
00:04:15.280 - 00:05:10.800, Speaker B: It's really hard. And maybe when you finish to redoing it again, maybe the EBM is three days, so it's much farther on that. And the thing is why we want to change that. It works, it's okay, we feel comfortable. Maybe there are things that we can be fixed, but maybe done small things at the EBM level. If this works, what's the problem? Can we move forward? Maybe we have a motivation for changing that, implementing the EBM in a ZK, this is tough, it's hard, but it's done, we did it. So no, I don't see motivation just to switch that and to restart over again.
00:05:10.800 - 00:05:12.990, Speaker B: Cool.
00:05:13.140 - 00:05:57.326, Speaker C: I think from my point, I remember holiday that definitely we need EVM equivalency, especially on layer two. Because when you think back why we are building layer two, we are scaling ethereum, right? Because Ethereum is conjectured and it has so many dapps already deployed there. So there need to be some places where you need to safely migrate those apps to some layer two. And you need the security, you need a very good developer experience. So that's why you have to build something which for the existing ecosystem. And it doesn't make too much sense for saying, okay, so it's already congested there on EVM, but let's just build something new as an execution layer and just leave it there. So it doesn't make any sense to talk with any decentralized application teams and saying oh, just try to learn a new language and redevelop everything.
00:05:57.326 - 00:06:55.178, Speaker C: And also because as Jordy said, eVM is a model which has secured billions of dollars and which, for example, a new virtual machine might take years or another very long period of time for being really secure. And also, as I mentioned, there is ecosystem, there is tooling around. But another thing which is really interesting is that Ethereum as a community, it has a lot of researchers and they are proposing eips around all that. And so if you build something which is more equivalent, you can easily apply those eips to layer two and even some eips ahead of time to do something which maybe current Ethereum cannot do because it's driven by your community and you can reuse a lot of work from there. And also just hours ago, like in Vitalik talk, hey, even want to use the KVM for layer one. So which in this sense we are actually cobbing the future of Ethereum. It's not only for us specifically, but we are cobbling the same code base for the whole Ethereum ecosystem.
00:06:55.178 - 00:07:41.790, Speaker C: I think one last point is that the target for EVM is not building just for parallelization or execution efficiency, it's actually built for a very small code size. It's simple. And so that you don't, for example, if you have very complex virtual machine, if you have multiple teams implementing the virtual machine, you don't know whether each team is implementing that correctly. There might be bugs in this very complex virtual machine implementation, there might be bugs in the compiler, which makes things less secure. And so that's the reason why we choose Ethereum, because we want decentralization, want security. So I think that's similar reason for layer two. So that's why I think and all the past experience for all the layer ones, because many layer ones, they start with, oh, we want to find with Ethereum, we want to beat Ethereum.
00:07:41.790 - 00:08:00.790, Speaker C: But still at some point they become EVM compatible. They just accept this existing community. So the past experience already told that it's very hard to build your community from scratch, but you should just build something which is equivalent. And yeah, that's my opinion.
00:08:02.570 - 00:08:32.686, Speaker D: So the thing about alternative VMs is just let me know when you have foundry for your altVM. The developer tooling for the EVM is just years and years ahead of anything else. And I will admit the EVM is not perfect. There's a lot of things that we need to fix with it. And I do have a lot of respect for the fuel team and what they're building. I think it's really cool. But we love the EVM and we're going to continue contributing to it and making it better.
00:08:32.686 - 00:09:07.900, Speaker D: There's actually a lot of cool eips coming up. Hopefully they get into Shanghai or like Cancun after that. That can really make the EVM a lot better. And at this point, the strategy for a lot of applications is to deploy multi chain, and they want that to be as easy as possible. And if you want to get all these applications deployed to your chain you pretty much need to be EVM equivalent or else it's going to require a lot more work from these teams to actually get them to deploy to your system.
00:09:11.870 - 00:10:00.374, Speaker E: Well, the other people have disagreed with Nick, but I agree with any. There's not really any countering of his points here. I mean, I agree with him wholeheartedly. I will say that to the point that if you start with Ethereum and the EVM, that allows you the opportunity for doing things like improving the layer two, adding parallelism, implementing a bunch of eips that people have wanted for years, right, things like security related. There's address space extension. I don't know if you guys have followed the news last year, before all the merge hype took over, but there was security concerns last year, which means they're even more of a concern now that 20 bytes is not sufficient for security. For addresses, people were suggesting 32 bytes.
00:10:00.374 - 00:10:27.330, Speaker E: But it's really hard to do in the EVM because of backwards compatibility, right? There's also a lot of instructions and so on that can't really be tweaked because of backwards compatibility concerns. And these things aren't just for fun. They're like, if your 20 byte addresses get hacked, all of Ethereum is going to die, right? There's a very significant security concern. Other eips are things like account abstraction. EIP 30 74 by Sam Wilson. Please check it out if you're not familiar with EIP 30 74. Other things like that.
00:10:27.330 - 00:10:40.170, Speaker E: Guess what that is fuel what you're describing there, that thing. If we are going to work on these improvements in the future, fuel has been working on for the past year and a half, we are literally plural, years ahead of any of these protocols.
00:10:42.910 - 00:12:07.350, Speaker A: So I think from what I'm hearing is that the main reason is really the backward compatibility developers experience very mature tooling and whatnot. But don't we actually build that stuff, what we're building for users and not for the dev? So I'm kind of curious, maybe let's pick one specific example that you've just mentioned. The account abstraction, right? This is something that we all know that makes really hard, I mean, the lack of account abstraction to use Ethereum for the retail, right? Using Ethereum is scary. You have to protect your private keys and whatnot. And account abstraction gives you a nice way to actually build all sorts of very interesting infrastructure that would really allow potentially millions of users to actually use Defi and roll ups such as Zksync and Starknet. They don't aim for the equivalence and they literally have launched with account abstraction, and my understanding is the fuel is going to launch with account abstraction as well. So do you guys think that this is some sort of constraint for you, like constraining factor to sort of follow EVM and lose on all those new things that you could have done, but now you kind of cannot?
00:12:08.730 - 00:12:48.740, Speaker D: I don't think so at all. I think that for us, we want to contribute to proposals that get into l one before they get into l two and even potentially spin up, say, l three s that have proposals and figure out ways to incentivize usage of those chains to test them out and kind of prove them out. So yeah, I don't think that sticking with l one is a problem at all. Also, as you add more features to your chain, we can see there may be security problems with them. There's also unknown second order effects. So actually I'm really happy that different chains are experimenting in different ways so we can kind of learn from them as a community.
00:12:50.390 - 00:13:42.718, Speaker C: I think for now our focus is still like EVM equivalency with just the same as ECM. We don't have that feature, but I think there are many proposals which you don't need to change your base layer, you don't need to change your whole chain to add that feature, because our mission is to onboard the next billion of users for Ethereum, which they can really easy to use all the applications, and metamask is much easier to use than any account abstraction based wallet. So that's why we want to make this and introduce more users, because they can keep their even just for metamask. There are so many users, they just don't know how to use that. I can't imagine how many users will be stopped by just installing this abstraction wallet. And so that's the first reason, and second reason is that it doesn't need to be a base layer change. It might be implemented through some smart contract and some additional feature.
00:13:42.718 - 00:13:46.180, Speaker C: So we can definitely support that. But maybe in some other ways.
00:13:48.730 - 00:14:24.478, Speaker B: I would say it's a matter of specifications, if you want. Look, building approver for ZkVM is a hard topic. It's complex. That's enough. This is the problem that I want to. That's of course there are a lot of topics in the space that needs to be solved, and account abstraction is something really interesting, something to talk about. It's nice that there is proposals and ways to go, compatible or not compatible.
00:14:24.478 - 00:14:57.930, Speaker B: But he says, in our case, we're kind of followers in this case. So our goal is to implement the Ethereum as it is. We want to scale Ethereum. That's our goal. We want to bring Ethereum to as many people as possible. And Ethereum, what it is Ethereum at this point is this. If Ethereum goes to an account abstraction, we will implement account abstraction in the roll up.
00:14:57.930 - 00:15:24.290, Speaker B: If Ethereum implements addresses, 32 bytes addresses or whatever new kind of quantum resistance addresses, we'll try to do our best to follow. But this is our dna of the project. We want to be as compatible as possible to Ethereum because our goal is to scale Ethereum.
00:15:26.170 - 00:15:44.060, Speaker A: Okay, so maybe let's sort of move back to why we're doing all this, which is essentially scaling. It's one of the primary reasons. So maybe, John, the question for you, how much moving away from EVM gives you the edge in the scaling wall?
00:15:47.390 - 00:16:27.014, Speaker E: It depends on your exact configuration, right? There's no single answer to this. It depends on your configuration of what is the node that you're running, right. What assumptions do you make around security and so on. But it can be very substantial because large parts of the Ethereum virtual machine and also the Ethereum transaction processing model weren't built for performance. They were built for, I don't even want to say simplicity, because it's not exactly simple. They were built because it was the simplest thing that could have been built at the time, because nothing like Ethereum existed. And it was a great, valiant effort when people didn't know better.
00:16:27.014 - 00:16:41.290, Speaker E: But since then, we do know better. And you can eke out many additional zeros of performance if you design a virtual machine from the ground up to be performant, in addition to having all the nice features of the EVM?
00:16:42.670 - 00:16:55.730, Speaker A: So what about you guys? I mean, do you kind of feel that sticking to EVM on the other side gives you kind of a theoretical bottleneck that will be constraining for future scaling?
00:16:58.790 - 00:17:49.854, Speaker D: Yeah, that's a good question. I think that maybe we can talk about it in two ways. There's kind of the technical scaling of the actual technology itself, and then there's kind of the social side, like the social scalability. And we believe in Ethereum, we want to scale Ethereum both from the technical side and the social side. And we think that sticking with exactly what Ethereum is doing and trying to embody the Ethereum community as closely as possible is a way to scale the social side of Ethereum. Technically, we want to work with the core devs and researchers to figure out ways to technically improve the EVM and work on things like parallelism. There's a bunch of other eips, I mentioned this earlier, that there's like EOF, right, like a new typed bytecode.
00:17:49.854 - 00:18:15.770, Speaker D: And this would be really helpful, because then you could potentially get around the need to be backwards compatible, things like that. So yeah, we don't think that it's a problem. It may take a little bit longer, but we already have a head start with all this value locked up in Ethereum and all these developers that already understand solidity and want to keep using solidity.
00:18:16.350 - 00:18:39.620, Speaker A: So for ZK, the problem is probably slightly different, or not really. I mean, my understanding frankly was always that it's the proving time, that it's a bit of a constraint, but otherwise, since the cost of validation is so much lower, then maybe it doesn't really matter for you. But I'm very interested in your take.
00:18:40.390 - 00:19:12.094, Speaker C: Yeah, I think at the Vicky project I can confidently answer that it's not a big bottleneck, especially for pooler. Currently I think also Jody has a number. Our pool time is pretty good actually for our current circuit and setup. We can handle 1 million gas in 60 minutes just using one prover. And we can actually scale the prover massively. Like anyone can just run the proverb and we predict that it may be less than 1% of the Ethereum mining machine. You can just run the whole proof network with a significant improvement on the TPS side.
00:19:12.094 - 00:20:08.094, Speaker C: So we don't think that's a huge problem on the proverb side. But it's just definitely very difficult to build something which is very secure and it's very complicated code, and you need very strong expertise to build that. And secondly, besides the prover thing, I think another interesting thing is that just different execution layer or any other thing which is not EVM equivalent, they can just be our layer three, because we do believe that layer two should provide exactly the same experience to be the most secure and most safe. And if you want additional features, you can just build some layer three on top of us and we can verify approved or whatever. So you can massively improve anything you can do arbitrary on layer three. But if you do that reversely, you use a non EVM equivalent chain at your layer two. And like us, maybe at layer three, it doesn't make sense, because sometimes layer three sacrifice your levelness because you have to pass through the layer two and then maybe to layer one.
00:20:08.094 - 00:20:44.006, Speaker C: So sometimes it influences your security. So we want this direct scaling layer to be the most, or even exactly the same as ethereum. And then other execution environment can definitely build on top of that. And also I don't think if you change EVM to another virtual machine will really improve the current situation for later. Because if you take at the real TPS, even on Lavalaunch or some other real chains, it's not really bottomatic by okay, so this chain is like five k tps or this chain is just one k TPS. The real world TPS is just so low. I don't think we really reach that limit.
00:20:44.006 - 00:20:51.962, Speaker C: If we really reach that limit, then you can build something like some fractal scaling and on top of that, just me.
00:20:52.016 - 00:21:22.850, Speaker B: Just to be clear, the prover is not a limitation at all. Prover is a parallel process and you can run as many provers as you want. So you can run as many transactions as you want. So prover is not a problem at all. The only thing of the prover is the proverb is costly and then the parameter that you need to check is how much fee. So you have to build the proof. So how much part of the fee that you are paying in the transaction you need to compute the proof.
00:21:22.850 - 00:22:19.350, Speaker B: Okay, at this point with cpu prover, currently the prover that we have at this point the cost in AWS, which is probably the most expensive cloud service in the world, basic transactions twenty one k. The cost is zero risk, at least one or two orders of magnitude of margin. To improve that proverb is not protocol. The scalability limitations comes exactly. They are exactly the same that the optimistic roll apps have. It's processing transactions in a sequential manner. There are things that you cannot parallelize easily.
00:22:19.350 - 00:23:08.746, Speaker B: So you have some limitations in that site. Of course we have data availability, which is another topic and things I think that at this point we are far away to reaching the points. The other important thing about for scalability is that there is margin. So if you see Geth, for example, Geth is designed to run in a laptop, which is great, but in a roll up system you don't necessarily need a laptop. So you can use different techniques, different computing techniques, you can have a bigger computers and you can have supercomputers, you can have different techniques to work on.
00:23:08.768 - 00:23:09.340, Speaker F: That.
00:23:12.270 - 00:23:30.638, Speaker B: You can do a lot of things in there. Of course you can always do better. So I agree with John that maybe if you design the things in a different way, it can be a little bit more efficient. But I'm not sure if we have this need yet.
00:23:30.724 - 00:23:31.360, Speaker F: No.
00:23:33.970 - 00:23:35.360, Speaker A: Any comments? John?
00:23:40.210 - 00:24:27.202, Speaker E: Other than a bit of confusion around the fact that it's pretty common understanding that Ethereum's bottleneck today at 15 transactions per second is really the execution. It's not the consensus. That's why if you take Geth and you just fork it, when you change the consensus protocol to something like avalanche, you're still going to be running at the same TPS. This is common knowledge. So we are currently bottlenecked by the execution of given a particular cost to run a full node, given a particular specs of hardware, this particular implantation, which happens to be guess, can do this much. That is the bottleneck. It's not consensus or anything else.
00:24:27.202 - 00:25:23.330, Speaker E: So it should be obvious that if we want to go beyond 15 tps, we need to do something. It could be improving the implementation. It could be a whole new architecture, which is conducive to having a more efficient implementation. It could just be increasing the cost to run a full node, something along those lines. So fuel is tackling the fundamental hard problem of rearchitecting the system without increasing the cost to run a full node, so that you can get much more TPS without turning into Solana, basically, where it costs thousands and thousands of dollars to run a full node. No, fuel is embodying the ethos of Ethereum that users should be able to have sovereignty over their money and over their applications, and that they can self verify the chain themselves without having to resort to supernodes or slana style, super expensive nodes.
00:25:25.210 - 00:25:26.680, Speaker A: You wanted to add something?
00:25:29.690 - 00:25:44.278, Speaker D: Yeah. John raises good points. I think that it goes to show that there are things that the EVM needs, and as a community, I think that we need to come together and add those things to the EVM.
00:25:44.454 - 00:25:45.690, Speaker E: That's called fuel.
00:25:48.750 - 00:26:14.290, Speaker D: Tell me when you have foundry. Soon, of course. No, but for real, developing with foundry is the most pleasant thing ever. I really like writing solidity. Yeah, we got some foundry people out here who's written foundry, or written solidity with foundry. See who has written anything for the fuel.
00:26:17.770 - 00:26:47.406, Speaker E: I'll counterpoint because there's a few hands raised. Thank you, Cammy. For anyone who's tried foundry, instead of listening to me, go to fork, go to sway, and try using fork, which is the fuel orchestrator, which is our equivalent of foundry. Try using that. Try adding some dependencies, try using the built in formatter. Try building some stuff. And then you'll see the difference between foundry and fork, and you'll see that fork is ahead of foundry even today.
00:26:47.406 - 00:26:52.480, Speaker E: And that gap is only going to continue to grow into the future. Try it yourself. Don't believe me?
00:26:55.030 - 00:26:56.610, Speaker D: That is a challenge.
00:26:59.110 - 00:28:35.442, Speaker A: Okay, guys, so let's again shift gears a little bit one of the very important topics for us at Makerdal is what we essentially, I mean, what everybody calls censorship, resistance of the bridges. What we found, and this is literally one of the reasons why Makeadao helped funding l two b is that we had to look very very deep into every single roll up and ask them really hard questions. Because we want to make sure the dai, wherever it is, stays censorship resistant, right? So we don't want any sequencers to censor l two transactions. We want to make sure that if you deposit die to a roll up, you will always have this option of taking out if things go like super wrong. Right? And our understanding is that not every single roll up is ready in this regard. And it's actually a tougher problem that most people realize to the point that starknet for example, they're going through a very major upgrade to make sure that you can prove that your transaction failed on l two, which is apparently from the Zk point of view a very hard problem. And other systems like Zk sync, they're introducing special opcodes so that you can actually prove that something didn't work on l two.
00:28:35.442 - 00:28:54.760, Speaker A: And they call it extensibility, right? And they need those special opcodes. So again, question for you guys, if you stick with being like 100% EVM equivalent, are you going to build bridges that are sensor resistant and will we be able to use them with no problems?
00:28:55.290 - 00:29:49.234, Speaker B: We are censorship resistant from a scratch. And let me answer the questions there, because we have very specific ways to handle those things. First, for proving a nonprovable transaction, which is something that's contradictory by itself, we have a kind of accounters, so we have a set of resources in the proof. And the idea is that we are taking account and if we want to execute something that we don't have enough resources, then we just say that this proof is not executable. So that will be a no operation on that side. So this is the way we are solving currently in the current CKBM censorship resistance. Here is one of the ways to do is for example, we have the proof of efficiency proofiency.
00:29:49.234 - 00:30:47.862, Speaker B: The idea is that anybody can be a sequencer and the transactions get sequenced when they get in layer one. This is from the theoretical perspective is fully decentralized because anybody can sequence that. The problem is that it's hard. The problem is when the projects want to have better, or if you want different functionality or better functionality than the layer one. So you cannot get better in layer two, that in layer one, if you want to have a high finality in layer two, unless you create a new consensus mechanism, you are not going to get better than what you have in layer one. So you have this limitation, and this is where the sequencer comes to. The sequencer at the end is a consensus layer that you are adding in front of the system, so that temporary, you get a different consensus until this transaction is sequenced.
00:30:47.862 - 00:31:35.974, Speaker B: This consensus mechanism can be centralized system. It's a consensus, it's whatever the centralized sequencer says. This is one way to do it. Another way to do it is just putting another chain, another consensus mechanism, a pos or something with different blockchain, trilemma if you want, with different parameters that you want. And this is a consensus that you get temporary. So this is the idea of how we build the consensus in the case of the centralized sequencer, which is probably the one that you first implement because you get the best of the centralized part. In our case, we have what we call forced transactions.
00:31:35.974 - 00:32:13.398, Speaker B: Force transactions are transactions that all the users have the right to send a transaction in layer one. So they pay the layer one, and those transactions are going to be forced to be included in the next batch with some rules in the next batch. In layer two. This forced transaction can be any transaction. In general, it's going to be an exit transaction and a withdrawal transaction. But with this, we solve part of the censorship resistance, because there is two kind of censorship resistance here. One thing is nobody can steal your money or nobody can block your money.
00:32:13.398 - 00:32:42.030, Speaker B: That's what you solve. The other thing is that somebody can censor you to use the system so they can remove your funds, but they cannot let you do to normally operate on the system. I think this is, maybe it's less important, but it's also a kind of censorship that needs to be solved. And this is harder to solve with a centralized sequencer.
00:32:43.330 - 00:33:52.870, Speaker C: Yeah, I think we have some very similar design where users can just enforce the transaction order, like through layer one, and so that your transaction won't be sensor like, won't include, or you can enforce that into the next batch. And also we are in parallel exploring the design space for decentralized our sequencer, because our order is that we want to decentralize pro first, because we want to scale the proving network. You want to reuse, for example, some mining machines, some gpus, and to run our proverb to provide enough efficiency. And then strategically we will move to this decentralized sequencer. And the reason why, how we are thinking of this is that sequencer and prover might be like different community, like prover needs very special hardware, like maybe GPUs, or even in the future, maybe ASICs or IPJs. But for sequencer, they might run some different mechanism to reach the consensus. And different from Polygon's proof of efficiency, we are not actually even under the decentralized sequencer setting, like everyone submitting some batch, we are not incentivizing the fast approver who submit the proof first will win, because we think it might introduce some.
00:33:52.870 - 00:34:24.046, Speaker C: Because you rely on the fast prover. And if one day this proverb go, then your system become more vulnerable. But we are incentivizing more like the parallelization between different provers. Like we can use some randomness to select the approver. And then different provers can compute for different batch and with less redundancy. And also you don't rely on one proverb, because for example, if you are running approver, and there will always be some very strong mining machine who will always ring and always just make proof for every batch. And then they just go away because they don't earn anything.
00:34:24.046 - 00:34:39.000, Speaker C: So you want to try to avoid this. So that's part of the design problem. When we are thinking of this and how we are decentralized sequencer. And we believe that adding this part and some enforcing the transaction order, we might be more censorship reason.
00:34:41.290 - 00:35:54.430, Speaker D: Okay, so, censorship resistance, sorry to break it to you all, but I think that there's not a single roll up in production today, that is actually censorship resistant, except for fuel v one. So what are some preconditions for censorship resistance? For censorship resistance, you need permissionless leader election, right? If the block producers are censoring, you need to have new block producers be able to permissionlessly join the set and be able to start including these transactions that are being censored. No roll up, to my knowledge, has leader election. I think that it's a really interesting research problem. If it's something that you're interested in thinking about, come talk to me. So, another thing that you need for censorship resistance is you need the contracts that are deployed to l one to be not upgradable. To my knowledge, all of the roll ups are using upgradable contracts.
00:35:54.430 - 00:37:02.754, Speaker D: So even if you have this l one to l two kind of forced transaction, if your bridge on l one, that you're sending this forced transaction through is upgradable, then whoever has the owner key can just upgrade that contract and prevent you from sending your transaction to l two. And I am sorry for being the bearer of bad news, but this is just the reality of where we are right now. And I think that it's really important to be very explicit with what the actual security properties of these systems are. I think that we need to, as a community, be a lot stronger on ourselves and hold ourselves to higher, more accountability, higher standards. There's this weird incentive where we don't want to call out the roll ups because we'd rather have people using ethereum things instead of say, avalanche things or Solana things. But I think that the reality is we have some way to go before we actually are censorship resistant. And I do think that we can get there.
00:37:02.754 - 00:37:04.020, Speaker D: We just have to work together.
00:37:05.030 - 00:37:31.690, Speaker E: I do have one question for you, actually. I remember chatting with you about this on Twitter a while back. But what's your view on the long term? And I guess also the other panelists, what's your view on the long term? How it's going to evolve with upgrade keys? Is there actually a nice, robust way of removing them despite the very complex nature of roll up bridges?
00:37:33.550 - 00:37:47.762, Speaker C: I think something like Ziki thinks secure console, where you have this delayed time as far as it's long enough for you to upgrade, and I think it will be enough, at least for most case we have to remove it at some point.
00:37:47.816 - 00:38:13.530, Speaker B: Yes, we want to decentralize. If we want to decentralize at some point, the system should not be controlled by anybody. And yeah, this is hard. And bootstrapping systems, it's a compromise. That's why we do these trick things. And I agree that we need to be very transparent on that. That's another story.
00:38:13.530 - 00:38:53.110, Speaker B: But at some point, all the decentralized systems, this is not only exclusive from the roll ups, all the decentralized systems. So I can understand that at the beginning there is some bootstrap phase where there is some upgradability if you want some things that you can tweak somehow, but at some point you need to close the doors, just burn the keys, call it whatever you want. There is a decentralized system. There is a common good. Everybody can use it. It's not yours anymore. It's just community stuff.
00:38:53.110 - 00:38:57.430, Speaker B: And this is hard, but we need to think that this is the goal.
00:38:58.490 - 00:39:05.100, Speaker C: One question, what if the key circuit has some bug and you don't have any application key? And what will happen there?
00:39:07.790 - 00:39:09.450, Speaker B: That's quite the brakes.
00:39:09.790 - 00:39:11.120, Speaker C: It's very hard.
00:39:14.130 - 00:40:07.854, Speaker D: I think that projects with upgrade keys are going to outcompete projects without upgrade keys in the long term. I think that realistically upgrade keys for some parts of the system are just going to be necessary. And I think that it kind of just comes down to what is your political philosophy around this? Right. Do you lean more towards the bitcoiner side of the spectrum or do you lean more towards say like a web three kind of spectrum where you're trying to iterate and make your protocol better over time. So there's like a wide trade off design space here. And I do think that having say governance or some organization that is able to upgrade parts of the system, I do think that it's really good given that there are sufficient checks and balances on the ability to make changes to.
00:40:07.892 - 00:40:54.190, Speaker B: The system if you can avoid it better. So if you can avoid having some governance based parameters, something that's upgradable. So if you can avoid these things, I think it's a parameter of quality of the system. So a system that bitcoin does not have a key that you can do upgrade something, of course, but these systems should be clean. If you are able to design a system that doesn't need governance, it's a better system than a system that requires governance.
00:40:55.410 - 00:41:02.846, Speaker A: Guys, we're slowly running out of time. One last very quick question to all of you. When Mainnet and for you guys, when.
00:41:02.868 - 00:41:41.520, Speaker D: Bedrock Mainnet, when bedrock. Right now we're kind of in the final stages of just testing and kind of adding a few new little features that we need to feel ready to go to production. So we're thinking within a few months to basically upgrade our current system to bedrock. And with bedrock, I think that bedrock is kind of. I personally think that bedrock is going to be the standard for how you design an EVM equivalent. Optimistic roll up and we're designing in a modular way so that it's really easy to kind of use the exact same code and spin up your own roll up. So yeah, a few months.
00:41:44.370 - 00:41:56.434, Speaker E: We launched a closed testnet like six months ago I think, and an open testnet last month. So I guess just extrapolate from there for now.
00:41:56.552 - 00:42:13.110, Speaker C: We have built a permission testnet where users can do interaction and a register like developer can deploy arbitrary smart contract. We already done that yesterday, East Global, there are several teams building on top of that. And we already enabled hard hat and fungi especially. And people can already use those toolings.
00:42:14.170 - 00:42:16.006, Speaker F: It's also a closed testnet but we.
00:42:16.028 - 00:42:21.100, Speaker C: Still need to wrap up some rest circuit part and do more secure auditing. But still.
00:42:24.350 - 00:42:27.146, Speaker F: We just stopped public testnet this morning.
00:42:27.248 - 00:42:45.826, Speaker B: We made the announcement so anybody can test it and it's open, maybe it's already down because it's just very new on that. But the problem of saying why commitments. And we are not going to do.
00:42:45.848 - 00:42:52.190, Speaker F: Any commitment when there is some security risk in here. So we are not going to launch.
00:42:52.270 - 00:42:55.654, Speaker B: This day or that day. So we will launch when we think.
00:42:55.692 - 00:42:58.130, Speaker F: It'S ready and it's special. Safe.
00:42:58.210 - 00:42:58.886, Speaker B: Okay.
00:42:59.068 - 00:43:03.650, Speaker F: And safe, or I would say never 100% safe.
00:43:03.810 - 00:43:17.290, Speaker B: But we feel enough comfortably safe to launch these things. We are starting the auditing process at this point. Waiting here with Ethereum foundation with scroll guys. And it's an effort.
00:43:19.230 - 00:43:28.270, Speaker F: For auditing this, which is complex. And let's see the beginning of next year.
00:43:28.340 - 00:43:34.494, Speaker B: We can, if it's in one year, it's going to be one year.
00:43:34.532 - 00:43:36.242, Speaker F: If it's in, it's going to be ten years.
00:43:36.296 - 00:43:38.430, Speaker B: We are going to launch it when it's comfortable.
00:43:38.510 - 00:43:41.202, Speaker F: The only running and we are working.
00:43:41.256 - 00:43:43.380, Speaker B: Really hard this to be as soon as possible.
00:43:44.630 - 00:43:52.338, Speaker E: First of all, congratulations on launching the first open source ZKe EVM equipment testnet. It's a very big achievement.
00:43:52.434 - 00:44:00.626, Speaker F: I'm wondering what is it licensed under? It's the what of the open source.
00:44:00.738 - 00:44:02.946, Speaker E: Testnet or the open source prover.
00:44:02.978 - 00:44:08.034, Speaker F: Sorry. So the prover there is a version.
00:44:08.082 - 00:44:14.474, Speaker B: That you can choose between MIT or Apache.
00:44:14.602 - 00:44:21.518, Speaker F: An ODM itself at this point does not have license. And when we do one of those two license too.
00:44:21.604 - 00:44:22.110, Speaker E: Thank you.
00:44:22.180 - 00:44:25.134, Speaker F: We have permission actually developed by the.
00:44:25.172 - 00:44:27.390, Speaker C: Community and anyone can just contribute.
00:44:28.450 - 00:44:28.926, Speaker A: Thank you.
00:44:28.948 - 00:44:32.700, Speaker F: Very big round of applause to everyone and thank you.
