00:00:05.320 - 00:00:47.445, Speaker A: Hey everyone, welcome back to another session of protocol symposium. Today we have Max Resnick as somewhat polarizing figure in the crypto Twitter lately. But he's from a special mechanism group working on protocol designs about mechanisms designs and censorship resistance and all that sort of good stuff. So it's the perfect kind of talk for this, the goal of this protocol symposium. So thanks for being here, Max. It's a really cool topic to multiple proposer, multiple current and concurrent proposers to solve some issues around MEV and censorship resistance. So whenever you're ready, the floor is yours.
00:00:47.825 - 00:01:22.905, Speaker B: Yeah, thanks for having me. I hope today will be less controversial than usual, but no promises. Oh, hold on. My, my zoom is making noise. Can you guys hear like an echo from the audio or no?
00:01:23.245 - 00:01:26.905, Speaker A: No, we just hear you. I don't think there's any audio issues.
00:01:27.365 - 00:02:04.959, Speaker B: Awesome. Sorry about that. So I will basically start in a different way than I have. This started this talk before. I usually start this talk from kind of first principles of censorship resistance. But today I'll start from what I'd like to see and what I think might be the way to build kind of a better market structure than the New York Stock Exchange and then transition into why we need multi proposer and censorship resistance to achieve that. So that's kind of the framework.
00:02:04.959 - 00:03:01.135, Speaker B: So let me get started by telling you about this mechanism which I call a priority order book. And this is kind of a modification of a traditional central limit order book, which is designed to run on a priority ordered chain. So what is a priority ordered chain? The chain is this kind of black box. We have transactions coming in. We'll talk about how that happens later. We end up with an unordered set of transactions. And then the way we execute those transactions is determined by the priority order.
00:03:01.135 - 00:03:44.095, Speaker B: So we're going to apply this deterministic function O, which is going to kind of sort these in descending order of priority. And we'll end up with TX1, TX2, and so on down to TXN. And there's multiple ways to break ties. But for now let's assume we break ties based on Randall. So we're just going to randomly break ties. There's a few other ways that we can talk about later. Okay, so that's kind of the view of like a priority ordered chain.
00:03:44.095 - 00:04:32.807, Speaker B: Let's talk about what we can do with this. So first let's talk about the kind of flaws with a standard central limit order book. So we're going to have like kind of our bids here and our asks here and at the Initial time, the fair price. Let's just say this is the fair price at time zero. This is the midpoint between the bid and the ask. And this is the spread, this kind of window here. And one measure of efficiency of an exchange is basically the size of this spread.
00:04:32.807 - 00:05:20.375, Speaker B: So however much this is, that's the kind of the efficiency metric. And there are a few other metrics that are similar, like, you know, certain amount of depth, how much can you trade and how much does the slippage push. But for now let's like focus on the simplest metric and, and see how we might optimize that. So, so why does a spread exist? The major reason is because the price isn't fixed. And so you may have people changing their, basically you may have the price change and not an opportunity to cancel the orders. So let's look at how that might arise. Say at T1, the price jumps over to here.
00:05:20.375 - 00:06:19.885, Speaker B: So now all these orders here are stale, which means that they're offering to basically sell the item for less than it's worth. And so an arbitrage can come in, they can take all of these orders and they can make a profit that's represented by like this triangle here. And that means since they're making a profit, the market maker, the, the maker who put the order on the book is taking a loss. And so when you set your quotes, you need to basically adjust your quote so that in expectation, when you get filled, you're making money. So when would you make money? Well, you lose money when the trader's informed. But there might be some, some noise traders coming in. So we assume these kind of, these noise traders have an urgent inelastic need to trade and they're willing to eat the spread.
00:06:19.885 - 00:07:18.425, Speaker B: And so those noise traders are how you make money as a market maker. But since anybody can be a market maker, the spread tends to be kind of forced to be as small as possible by competition. But it can never be too small because then you would be losing more money to being picked off than you would be to noise traders. So in a standard central limit order book we have, where does the, the fair price come from? It's more of an abstract concept, but it's basically the, I mean, basically there's a model of the world. All models are wrong, some are useful. It comes from all of the information that people know about the world. So I guess, like, it's hard to say exactly.
00:07:18.425 - 00:08:10.495, Speaker B: It's the midpoint of the prices on. You can think of it as basically the midpoint of the prices on Binance in this world. But even in like the way that they would measure it in a traditional finance context, even in a context where there's only one exchange, they would use the mark out from two seconds into the future and average that. And that would be their kind of metric for what the fair price is right now. So a lot of people would say, I think mistakenly, that there's a, basically a fair price on Binance and if all of the price discovery happened on chain, then there would be no lvr. That's wrong. So here's an example of why that's wrong.
00:08:10.495 - 00:08:59.738, Speaker B: Like, suppose that like the Fed share raises rates. All price discovery in this world is happening on Uniswap V5, okay? But the Fed chair raises rates in between blocks. They raise rates 50bps. You should expect the prices to jump, right? Because that's a bunch of uncertainty getting resolved. And so like, you know, ETH is just going to move based on that because it's a risk, risk asset, okay? Regardless of whether the price discovery is happening on chain or on Binance, the LPs on chain are going to get picked off or at least they're going to have stale quotes. So I would say for now, just assume that there is a fair price. But, but the fair price is kind of generated by the information that we know.
00:08:59.738 - 00:10:08.475, Speaker B: So that includes maybe where things are trading on other exchanges, but also other information about the world. Is there a hurricane about to hit Florida? Is the Fed chair raising rates? All of this stuff goes into the fair price Anyway, so what's the problem with a central limit order book? It's that whoever goes first, whoever is first to the exchange gets to take the order. And there's no competition on price necessarily because whoever's fastest gets to take all the profit. So you have all these high frequency races going on. Some people would argue that this is kind of deadweight loss from these HFT races, although that's debatable. But basically these people are investing a ton of money in microwave powers connecting New York City and Chicago to get 2 milliseconds off the travel time. And they're spending tons and tons of money on this.
00:10:08.475 - 00:11:15.057, Speaker B: And this is kind of, in some people's view, a deadly loss. But the real problem is that the adverse selection that we're looking at here still exists. And so the spreads have to be wider and that means retail has to pay more when they trade. So that's the basic idea of like kind of what's wrong with a central limit order book? Let's talk about what's wrong with like an automated market maker on chain? So there's a similar issue with the automated market maker which is that you instead of having the person who is fastest get to take the stale quote off the book, let's look at an AMM here. So the price kind of starts here and then ends up here at the end. So this area is all stale and there's some profit that looks like this that's available. Instead of having the fastest person get to take this, you have the person who bribes the proposer most gets to take it.
00:11:15.057 - 00:12:04.625, Speaker B: And either way it doesn't go back to the market maker. So it's still just eating a bunch of adverse selection risk. And so that's like kind of what is canonically known as LVR in the theory of automated market makers. But it's very similar to kind of stale quote sniping in central limit order books. Okay, I've said enough about that. Let me, let me kind of propose a potential solution to this which is the priority order book. So the priority order book is just a standard central limit order book, but there's kind of call it 200 millisecond batches and the 200 millisecond batches are priority ordered within them.
00:12:04.625 - 00:13:24.015, Speaker B: And so everybody can kind of submit their transactions. And let's look at the example where there's a stale quote again and you can start to see what we're going to do with these priority order books. So we have a stale quote here, we have some arbitrage opportunity available and since it's priority ordered, everybody is going to bid priority fees to try and win this. So it's going to be kind of like an all pay auction to try and win this pot of money. But the interesting thing that we can do as the exchange is we can kind of look at the transactions. So tx1 pays priority fee 1, tx2 pays priority fee 2 and we can kind of inspect this priority fee and then we can change the behavior of the order book based on that priority fee. And I think Dan in his post called this MEV taxes.
00:13:24.015 - 00:14:04.619, Speaker B: But I don't really know if that's like a great way to describe it because taxes is kind of a bad word and I hate paying taxes. But this is more just adjusting the behavior of my order book based on the priority fee. So it's not a tax that's getting paid, it's just I'm going to adjust my quote. Why? Because if I see a high priority fee I know somebody probably has information. So if I See, a high priority fee I think I'm getting, you know, somebody who's trading against me has more information than me. And what should I do if somebody is trading against me, has more information? I should pull my quote back. So my quote isn't just going to be a static quote at some price.
00:14:04.619 - 00:14:43.155, Speaker B: It's actually going to be a quote that's a function of the priority fee. And so if the priority fee is high, I will pull my quote back and I will lose less money this way. And we could get into like kind of the math of how that works out. It depends on the function. But I think even just this description of it, like has a pretty clean intuition for people who've thought about this a little bit. And so that's kind of the ideal market structure that I'd like to see on chain. And I think it's potentially like even better than central limit order book because there aren't a bunch of cancels that need to happen.
00:14:43.155 - 00:15:45.085, Speaker B: And you can do this like in a blockchain setting with fewer transactions than you would need for a central limit order book because you don't need as many cancels and you have like pretty good properties for this adverse selection. So why can't we do that today? Well, we could do it if we had a trusted centralized sequencer. Why? Because we can trust the centralized sequencer to kind of run whatever program we give it the priority fees. So the question in the chat is, is the proportion of priority fees that goes to LPs in MEV taxes. So the priority fee doesn't go to LPs. The priority fee goes to the protocol or the sequencer. This is collected by the sequencer or the protocol.
00:15:45.085 - 00:16:43.271, Speaker B: But what's happening is you're moving the quote back so you're repricing the quote so you're losing less money due to adverse selection. Like say that at time zero the price was 100 and then at time one it moved to 102 and you had a quote that was kind of sitting at 101 was your quote. Okay, so now there's kind of, let's say it's for one unit. There's $1 of arbitrage opportunity available. But because there's $1 of arbitrage opportunity available, there's going to be kind of a competition for that arbitrage opportunity and people are going to be paying higher priority fees to do that. So what I should do is given that people are paying high priority fees, I should actually move my quote towards 102 and so eventually you kind of do the math out and figure out where this is going to end up. Clearing.
00:16:43.271 - 00:17:43.155, Speaker B: It's closer to 102 than it is to 101, depending on how, how you do that. So it's not really a tax, it's just an adjustment given we, we've kind of elicited information from the trader through the mechanism that says the trader is informed. So given that they're informed, you should pull your quote back. And if you're not informed, then then there should be, you know, enough liquidity for you and you can just set a priority fee of 0 and, and take the order as is. And so we should expect in this mechanism that the spread, which again is what we care about, goes down because, because informed traders have to pay more fees than uninformed traders. There's still going to be adverse selection, but it's going to be less adverse selection. And I guess the other thing to say is that the priority fee can be quite small relative to the change.
00:17:43.155 - 00:18:21.465, Speaker B: So the priority fee could be like 1% of the change in the price or something like that. So it could be a negligible priority fee. And the real auction is actually at what price you're taking rather than, but it's just kind of denominated in priority fee. And the priority fee is kind of negligible and small. Does that answer your question, Elias? So it is an auction. It just happens to be priority ordered. So it's fully backwards compatible with all.
00:18:21.465 - 00:19:29.275, Speaker B: I mean, it basically is an auction. It just has this kind of slight denomination and priority fee, but it's fully backwards compatible with all apps, basically. Okay, let's talk about like, can we actually do this in a decentralized way? Because if we have a trusted centralized sequencer, we can just trust them to include all the transactions and run this honestly and give us the mechanism that we just described. But what happens when we don't trust the sequencer? So the sequencer is just dishonest or like profit maximizing. Say there's, you know, $100 opportunity and then there's a bunch of transactions that come in from different people that are like, hey, I want to, I want to take the opportunity. Here's my priority fee, right? So what, what the centralized or, sorry, what the, what the untrusted sequencer can do is say, oh, there's $100 opportunity. I didn't see any of these guys.
00:19:29.275 - 00:20:08.895, Speaker B: Oops, oops. My ports weren't open. I didn't see them. You guys didn't send them in time But I did see TX3 with priority fee three where P3 is, you know, epsilon as small as possible or zero, basically for clarity. So it's basically roughly zero priority fee. And now I take the $100 opportunity for myself and we're kind of right back where we started with the PBS version of today. So that's kind of why we can't do this.
00:20:08.895 - 00:21:02.795, Speaker B: And maybe we can talk about this a little more formally in terms of censorship resistance. So formally, for censorship resistance, we kind of need to define an abstract version of what can be censorship resistant. So we have this abstract idea of a, a public bulletin. A public bulletin has two operations. The first one is right, and the right operation takes two arguments, a message M and a tip T. The second argument, and notice I'm using T here, I'm not using P because, because priority fees and inclusion tips are going to be different in this architecture. Just to clarify that now, because that's often a question that people have.
00:21:02.795 - 00:21:30.405, Speaker B: So we have this write operation, then we have a read operation, this write operation. It can either succeed or it can fail. And in particular can fail if the adversary wants to make it fail for a price. And that price is going to depend on T. The read operation always succeeds and it returns everything that's been successfully written. So a public bulletin. Now we can define the censorship resistance of a public bulletin board.
00:21:30.405 - 00:22:57.177, Speaker B: So the censorship resistance is a function phi, which takes as input T and it maps to the kind of minimum price it would cost a motivated adversary to make the write operation with some arbitrary message and tip T fail. Okay, why does this matter? Why is this the right definition? Most definitions of censorship resistance don't include the tip. But of course it's much harder to censor a hundred dollar tip transaction than it is to censor a $0.01 tip transaction. So of course the definition should involve this. And moreover, I think one thing to note is that the public bulletin board can be defined in like timelines. So if you look at a blockchain, there's kind of multiple timelines that you might care about.
00:22:57.177 - 00:24:07.695, Speaker B: You might care about long term censorship resistance, or 1 block censorship resistance, or 10 block censorship resistance. And then basically we can care about all of those and we can write the sequence of censorship resistance functions. So we have a blockchain, we, we have like the one block censorship resistance, the two block censorship resistance, the three block censorship resistance. And on a single leader protocol, that sequence of censorship resistance functions is basically phi sub k, where K is the number of blocks of look ahead of T is equal to kt because you kind of have to bribe all of the proposers that have a say. There's a question in the chat. Does the priority order book exist in reality? Has any EVM EIP 1559 ordered chain implemented this protocol? I guess EIP 1559 isn't how the chain is ordered. That's an inclusion transaction fee mechanism.
00:24:07.695 - 00:24:55.065, Speaker B: But OP stack is priority ordered and I believe they're working on making it so that the apps can read the priority ordering right now. So right now the app is priority ordered, but the. My understanding is that you can't read the priority fee. So Tarun asked a new math question. I'll. I'll get your question at the end, Turin, because I feel like what happens if it's not monotone? It is monotone. Like it's just like this linear function in most cases.
00:24:55.065 - 00:25:25.505, Speaker B: It's like, I don't know, we can chat about that at some point. So yeah, just to clarify this, on op, the chain is priority ordered with a centralized sequencer, but my understanding is that the apps like the order book right now could not read the priority fee of the transaction, although they're working on potentially implementing that, by the way. Dom, how much time do we have?
00:25:27.605 - 00:25:30.933, Speaker A: We usually aim for an hour. So you have like half an hour left.
00:25:31.029 - 00:26:32.549, Speaker B: Awesome, thanks. Okay, so that's basically the idea behind this censorship resistance function. So now I'm going to talk about how multiproposer fits into this. So I just told you we can get like K K times T censorship resistance from K blocks. But is there a way to do that in a fast manner, like in the same block, so that it can be useful for financial applications, and so that we can replicate the kind of strong censorship resistance within a single block that you get with a trusted sequencer. And the way that we suggest doing that is through multiple concurrent proposers. So why does this work? For the same reason that in the K block case, there are K people who have a chance to write and you have to bribe them all.
00:26:32.549 - 00:27:20.785, Speaker B: In the multiproposer case, there are K people who have. If there's K proposers, there are K people who have to write there and you have to bribe all of them. And so you can get a similar. If you solve the kind of complexity of this multiple concurrent proposer consensus, which is not an easy problem, and we'll get into some details on that as well. If you can solve that issue, then you can get kind of the same censorship resistance that Ethereum currently has in the long term, in the short term. And that's extremely useful for financial applications like the priority order book. Okay, so let's talk about how to implement multiple concurrent proposers or maybe, yeah, let's talk about how to implement it.
00:27:20.785 - 00:27:55.203, Speaker B: So we have some time for questions. So we have this idea that we're working on. It's, it's called Braid. Kind of a interesting experiment in research across different specialties. So it's kind of me, Malesh Pie, who works also at smg, who's a professor at Rice in game theory. And we have two consensus experts. Alberto Sunino, who's one of the researchers at Mistin Labs and is one of the authors of Mr.
00:27:55.203 - 00:28:56.737, Speaker B: Seti which is kind of a multi proposer DAG based design. We have Okeem Nu, who's just graduated from Stanford with his PhD. He's currently doing a postdoc at a 16Z. He's one of the people who's kind of a consensus expert on the Sleepy model, which is the model that we use for basically understanding Ethereum consensus and what they were trying to do with LMD Ghost. So we have the kind of game theory, we have consensus, we have. Somebody just joined us, Joe Bono, who is a professor at NYU and also at a 16Z as well, who's a cryptographer. And you kind of need all of these three things in my view, plus like extremely talented engineers in order to do any kind of important work.
00:28:56.737 - 00:29:46.985, Speaker B: And we're at the stage of like the research stage. So we've kind of have these three types of people working on it. But then we're going to end up having to involve the engineers as well too, once it's time. And anyway, we've kind of had interesting moments just kind of having high bandwidth between these groups and seeing what we can come up with. Here's the basic framework that we started with, which is what happens if we just kind of do the stupid thing and we just run multiple instances of LMD Ghost in parallel. So the advantages of LMD Ghost is it's eventually consistent. It has an unfinalized header and then a finalized ledger as well, which kind of lags the unfinalized part.
00:29:46.985 - 00:30:52.925, Speaker B: And it also has slot times. So each of these are, each of these dots are supposed to be blocks. Here we have some blocks that are unfinalized and some that are finalized. And then the question is like can we just try and do something where we just run multiple of these and try to zip them together? And that's basically what Braid is, is. Let's just run Say two of these, and then this block is at slot one, this block is at slot one, this block is at slot two, this block is at slot two. These are the genesis blocks on the respective chains. And we can just kind of like look across both chains, run the consensus on both, eat the overhead of that, and then we're going to take all of the transactions in each of these blocks.
00:30:52.925 - 00:31:00.005, Speaker B: So in block one, on chain one, we have some set of transactions.
00:31:02.385 - 00:31:02.673, Speaker A: And.
00:31:02.689 - 00:31:46.893, Speaker B: On block one, on chain two, we have some set of transactions. And we're just going to like take the union of these. So take the union and then apply a deterministic ordering rule on that unordered set of transactions. That will determine. So now we have transactions in priority order and that will basically determine the execution. So execution now is not part of the block. No matter how we switch these orderings within the block, it doesn't matter.
00:31:46.893 - 00:32:46.265, Speaker B: What matters is basically the, the priority fees and whether you made it in or not. So it kind of simplifies the active block building. Right now we have this kind of super complicated knapsack problem of how to pack a block. And actually this would turn it into just, do you include a transaction or do you not include a transaction? So if you kind of have eventual consistency, which means eventually everybody concludes a shared view of the chain, which is a property that LMD Ghost has, then eventually you have consistency of all of these at the pace of the slowest chain. And your worst case bounds in fact are the same because the worst case on any one chain is the worst case on all of them. Right. So you can move at the space the pace of the slowest chain and you can basically finalize when you, you achieve consistency with something similar to LMD Ghost.
00:32:46.265 - 00:33:28.595, Speaker B: Sorry, with, with something similar to Gasper. And in fact, you don't necessarily need to just use LMD Ghost. You can use. The way we're kind of framing in the paper is you can just kind of take an abstract consensus protocol with the following properties and then we can build these multiple chains, zip them together using Braid. So Braid is not necessarily a protocol agnostic or like consensus or. Sorry, it's not, it doesn't, doesn't assume LMD Ghost or Goldfish or any other consensus protocol. It just kind of assumes a set of abstract properties of that consensus protocol and tries to go from there, basically.
00:33:28.595 - 00:34:24.955, Speaker B: So that's the basic idea. Let's talk about a little bit of like kind of the hairy stuff and what the criticisms of this design have been. So the majority issue that has been raised is this thing called last look. Now we have multiple proposers. We don't want one proposer to act much later than another proposer. There's a question in the chat. Yeah, so the question is about the average case properties.
00:34:24.955 - 00:35:36.955, Speaker B: I think you basically, this is like a question that is a little bit out of my wheelhouse, but I think you basically have kind of logged k worse convergence in the average case, because if you kind of look at each chain as a geometric random variable in terms of how fast it converges and you do the math out, you end up with kind of order log k worse convergence. Okay, I'll look at the archive paper after turn. Anyway, let's talk about last look. Basically, what if we have two proposers and one of them sees a hundred milliseconds more information. Okay, there's like kind of two things that might happen here. One of them is that they might look at the other guy's block. So just to be clear, these are kind of both in the same slot.
00:35:36.955 - 00:36:18.599, Speaker B: Just that one of these guys is better networked or has. Is playing timing games and they release their block later. So what if you can look at B1? Well, if you can look at B1, you can see which priority fee everybody paid for the opportunity. And you can penny them or dime them, which means you just kind of take their bid and add epsilon to it. And this is extremely bad for the equilibrium because it means that there's this, this bad adverse selection effect when the trade goes well for you. If you submit in block one, you kind of always get outbid in block two. And when the trade goes poorly for you in block one, you.
00:36:18.599 - 00:36:55.635, Speaker B: You don't get out bid. And so there's this unraveling where you no longer want to bid in block one, because you always get outbid when the trade is good and you always get. You always don't get outbid when the trade is bad. And so you like basically always take a bad trade. So this is, this is very bad. And we'll talk about how to kind of address that. There's another thing that might happen, which is even if you don't get to look at block one when you're submitting to block two, maybe you get to like, look at binance for another for like another 100 milliseconds.
00:36:55.635 - 00:38:04.315, Speaker B: And so like, you might think that the same kind of thing happens here, but actually we have some, some results that, that Malesh is working on that are basically like, it's not quite a full unraveling. You actually get this weird Bayesian Nash equilibrium. Let me give a little bit of intuition for why it doesn't completely unravel in the second case where you, you can't look at the other guy's block, but you can look at binance for an extra 100 milliseconds. If it did completely unravel, then the only bids would be submitted to B2. That's kind of the definition of completely unraveling. And if the only bids were submitted to block 2, then it's as if we are back to a single proposer case. But if we're back to a single proposer case, remember that in the, in the single proposer case, with the kind of untrusted sequencer, they can censor all of the bids, submit one that pays epsilon priority fee and win the auction for zero or epsilon dollars.
00:38:04.315 - 00:38:40.993, Speaker B: And that would mean that you would probably want to submit in block one now. But we just said that you're not submitting anything in block one, so. So now we've ended up at a contradiction. So this is kind of an argument for why it doesn't completely unravel. We're going to have a more detailed argument in the paper about what it does unravel to where the information rents are and how much they are and how much goes to each proposer. But that's kind of a proof sketch of why it at least doesn't degenerate all of the way if you don't get to look at block one. But.
00:38:40.993 - 00:39:13.335, Speaker B: But it does. Like there is still some information, right? Because you have 100 milliseconds of extra binance price data. So. So you do have some information, right? You just don't have a full unraveling. Okay, that's kind of that. So, like, what should we do about this? We basically want it to be the case that even if B1 gets submitted before B2, B2 cannot know the contents of B1. So there's three kind of ways to achieve this property.
00:39:13.335 - 00:39:57.445, Speaker B: The first one is something like a commit reveal scheme. So in commit reveal, I commit to the hash, the digest of my block and then in the next consensus period I reveal. So I reveal block one, you know, in the next period and we kind of come to consensus on the hashes and then we have another step to reveal them. So it's similar to how EP epbs is also going to work. I'll talk about some. I think commit has two M's in it. I'm very bad at spelling anyway.
00:39:57.445 - 00:40:53.185, Speaker B: So you have commit reveal, you have threshold Threshold cryptography. Oops. And that would be like, hey, we take my, take the block and then we encrypt it in such a way that if, you know, 2/3 or 2F plus one of the validators release their, their piece of it, then everybody can see it. So that's threshold cryptography. And then the third possibility is time lock. And this is not vdf by the way. Time lock and VDF are not the same.
00:40:53.185 - 00:41:50.763, Speaker B: Time lock is easier than vdf, but time lock is basically I encrypt something and then if you solve a puzzle that's not parallelizable, then you can open it up. So let me talk about the potential issues with this. So for commit reveal, there's kind of this major problem that you might not reveal. So you can commit to your block, you can commit to a large trade and then observe some price action. And then if it doesn't go the way you wanted it to go, you just don't reveal it. And this is kind of a major problem. So what do we want to do? We want to penalize you, but we can only penalize you up to the point at which like you're gonna have some failures due to the network as well or just like random issues.
00:41:50.763 - 00:43:03.145, Speaker B: So we want to like force reveal, but we can't like do it in any way other than making you pay when you don't do it. But then there's some probability of failure that's exogenous, that's outside of your control. And so we can't make you pay a million dollars if you don't reveal because you might have just like had some network fault or your ISP turned off the Internet. Right? So, so like we, we have some fundamental constraints and when, when opportunities are long tail, you might have certain blocks where you're just doing like a 1 million trade on 10 pools. And so you have 10 million of notional exposure and the price just wicks back. And I've actually posted some blocks that, that look like this where like the price just kind of goes, goes one way and then very quickly retraces. And if you have like a commit reveal timing, you might actually just not reveal even with kind of a hefty penalty because the trade size is so large and the kind of cap on the penalty is not enough to deal with these fat tailed situations.
00:43:03.145 - 00:43:51.961, Speaker B: So anyway, we want to be able to force reveal, but we kind of like can't do that. And it requires people to put up a bunch of money which they already have to put up 32 ether they want to be a solo staker and like you kind of would have to make them commit even more money and have like this slashing risk of their ISP turns off. So that's kind of a problem with one, so with two. I think the problem is some of these threshold schemes. It's not clear that like you can do them without trusted ceremony and like trusted setup. Although there's some like interesting work on this that Dan shared with me that I haven't had a chance to read yet. But there's some trusted setup problems.
00:43:51.961 - 00:44:40.645, Speaker B: There's potentially some message complexity problems. Okay, so that's kind of threshold. And the third one is time lock. And the problem with time lock is we kind of, we kind of know how to do time lock except we, we don't know how to do it in a way that the ASIC isn't like a million times faster than the non ASIC. So the problem with time lock is the ASICs. And so we can either like require everyone to get an ASIC and then we don't really have a theoretical guarantee that somebody won't have a faster asic. But like practically speaking we could have everybody get an asic which might not be like the best.
00:44:40.645 - 00:45:35.045, Speaker B: We'd kind of like everybody to be able to run this on any hardware. But here, here's like a, the fourth possibility which is kind of a hybrid of two of these. What if we do commit reveal and then force open? So we're going to take commit reveal and then the problem that we had with with commit reveal where like you didn't have to reveal, we're going to have an option to force open. So how are we going to do that? You're going to commit the VDF of your block. So you're going to commit the VD or sorry, not the vdf. The time lock. You're going to encrypt with the time lock on your block and then in the happy path you'll just reveal it in the next period.
00:45:35.045 - 00:47:02.995, Speaker B: But if you don't reveal it for whatever reason, then there's going to be some like watchdogs in the network who have the asics. So they have the asics, watch dogs have an ASIC and they can, they can compute the decryption of your like time lock and they can send it to the network. So that's like the basic idea is now you can't get away with doing a trade that, that you want to like have preserve some optionality on by not revealing. Because if you don't Reveal, the watchdogs are going to compute what you actually put in with their asic, send it to the network and your block is going to be revealed anyway. And most of the time we have the happy path so we don't have to eat the latency and like rely on these AS six and watchdogs. But like sometimes we do want to rely on it and it's more like a kind of hopefully we are in this happy path scenario where we're just committing and revealing. But if not we can decrypt you with the time lock and ASIC and just like make you run the transaction that you didn't want to run anyway.
00:47:02.995 - 00:47:28.175, Speaker B: And so there's no reason to, to try and play any games around this basically. So commit, reveal, force open. That's the basic idea that we have. I have like 10 minutes left, so wanted to just leave time for any questions, especially about this last part, which is kind of a new development that we've been thinking about lately.
00:47:33.075 - 00:47:48.175, Speaker A: I have a question about the non happy path where you just described like is there any guarantees that you're actually committed to like a valid block when you like publish your commitment or is there like fancy CK stuff?
00:47:48.715 - 00:48:26.523, Speaker B: So if you, if you propose an invalid block, like if you propose an invalid block and commit reveal. We don't know whether it was invalid. You just like didn't reveal it maybe. Right, yeah. Here. Like if you propose an invalid block, eventually it gets revealed no matter what because the watchdogs are going to find it. And like, like if we, if we lock on your encrypted block and then, and later a watchdog like decrypts it whenever you, whenever you propose the encryption, it's either like a valid block or non invalid or not a valid block.
00:48:26.523 - 00:48:34.203, Speaker B: And so like it doesn't matter whether you reveal it or not, that doesn't change whether it's valid or not. Does that make sense?
00:48:34.299 - 00:48:43.935, Speaker A: So whenever encrypted block is like proposed by the proposer, like is there any guarantees that they actually have the key, the proper key that's in the timeline?
00:48:44.515 - 00:48:57.283, Speaker B: Well if they, if they, if they don't, then they propose an invalid block and they get slashed. All right, but there's no, there's no like financial reason that they would propose an invalid block because it's just never valid. Like in any, it's not like you.
00:48:57.299 - 00:48:58.735, Speaker A: Can'T grieve, let's say.
00:48:59.075 - 00:49:02.275, Speaker B: Right, but you can propose an invalid block right now if you want to grief.
00:49:02.315 - 00:49:03.615, Speaker A: Yeah, true.
00:49:04.595 - 00:49:06.575, Speaker B: So it's the same, same idea.
00:49:09.285 - 00:49:09.549, Speaker C: Or.
00:49:09.557 - 00:49:33.265, Speaker B: You can just not propose a block. I mean proposing an invalid block is worse because you have, you propose an invalid block and you like can get slashed and there's no like, there's nothing different than not proposing a block at all. Ani, did you have your hand up?
00:49:34.125 - 00:50:02.655, Speaker C: Yeah. I've two questions for this. Commit, reveal, force, open path. I don't really understand how this solves the issue of if someone has faster asics. It seems like it inherits the downsides of the time lock, which is if someone gets access to faster hardware, they can reveal this to themselves and then they have an advantage.
00:50:03.155 - 00:50:27.055, Speaker B: So I, I guess the, the problem with the ASIC is that if you don't have the hardware, you're way, way slower. So basically require like that everybody, the pure time lock version, everybody has to have the ASIC and everybody has to decrypt. So it saves like a communication round of the reveal, but it, it makes like everybody run their own ASIC basically.
00:50:27.365 - 00:51:09.515, Speaker C: Right. So the disadvantage of that too is there's a new hardware requirement that's prohibitively expensive or something to the network. But in the combined version, rather than it being best of both worlds, it also seems like it inherits the downsides, which is like if someone is able to run the VDF faster than they actually get access to the information that's supposed to be secret. And then also I guess like people still need, there needs to be enough people who can run like the VDF in order to like in case someone doesn't reveal in order to force open it. So you still have that constraint. Right?
00:51:09.895 - 00:52:19.895, Speaker B: Well, the whole point of these time lock constructions, and let me just reiterate, the VDF is not equal to time lock. Time lock is a weaker thing because VDF implies the existence of random beacons and time lock doesn't. But there are these kind of constructions where the problem we think is non parallelizable. And so you basically have to do a certain amount of operations, like you just have to do a certain amount of flops to do this, like a number of repeated squarings and there's no way to parallelize it. So it's just, you have to at least do that many operations and there's kind of a bound on like how fast even an ASIC can do that, which is just like the physical limits of the technology that we have. Like it's not like we're going to have an ASIC that just comes along and is like a thousand times faster than the current ASIC because it's still the same number of operations. It's just like if you think about the fastest CPU versus the, the slowest CPU from 10 years ago that was a commercial CPU, it's like not that much of a difference.
00:52:19.895 - 00:52:59.065, Speaker B: And Obviously it's an ASIC, but it's kind of like they're all ASICs, they're all designed for the same operation and they all have a certain, like, at a certain point it's just like you have to do a million operations or you have to do a billion operations in a row and so you can't like get so much faster, which is where the non parallelization comes in. So I don't, I don't think it's that big of a risk. That's kind of what these. I mean it's not my area of expertise, but my understanding from, from talking to Joe about it is the, the difference in performance between the asics is not the issue, but more. Just having everybody run the ASIC is, is more of a cost on the network.
00:53:00.885 - 00:53:01.221, Speaker C: Right.
00:53:01.253 - 00:53:03.101, Speaker B: So I don't think it's that big a deal.
00:53:03.293 - 00:53:14.207, Speaker C: Makes sense on that disadvantage. But you still need enough network participants to have the hardware to run this in order to like force the, like to force open. Right?
00:53:14.351 - 00:53:25.911, Speaker B: Yeah, but it's, it's more of like just a few watchdogs that can submit like the, the opening to the network rather than like everybody needed to run it.
00:53:26.023 - 00:54:07.135, Speaker C: I mean in that case like you're, you're trusting a smaller set than like there's still some. Yeah, okay, I think I understand. Sorry, can I ask a simpler question on something you wrote above, if you scroll up a little bit, I think to the previous page. Yeah, yeah, right here. Apologies. I came in like right at this time, so I might have missed something in the initial part that might answer this, but as like a, just like maybe a dumb question. When you zip together multiple different block, multiple different chains.
00:54:07.135 - 00:54:29.935, Speaker C: Like it's possible that like you have a transaction in like chain two, for example, that is valid given let's say all of the transactions in chain one. But like does something unexpected or like does something unintended via like the consensus that was set up in chain two. Like how does this address that?
00:54:30.275 - 00:55:21.715, Speaker B: Right. So we need to make sure to solve. I think what you're getting at is the free DA problem. And basically what you need to do is hold in escrow enough fees to pay for inclusion on all key chains. So like if you have a transaction that has a max fee of like 5 cents, you need to hold an Escrow at least K times 5 cents. You don't necessarily need to charge them that, but at least in order to include them in your block. The validity condition is, you know, the balance of that account is at least K times whatever the max fee that that transaction could pay is.
00:55:21.715 - 00:55:52.935, Speaker B: And so it is a little bit of like a UX degradation, but hopefully the fees are low enough that this isn't too high. And again it's not like necessarily an increase in the paid transaction fees unless you try to include a bunch of stuff. But this kind of can, can deal with the free DA problem of you have one transaction that transfers all the money out of the account and then it can no longer pay pay fees because you, you know, in the inclusion step you, you enforce this check. Whereas right now it just be like.
00:55:54.835 - 00:56:32.498, Speaker C: Mike, my question is I think even simpler which is like let's say that like you have a, like maybe I'll give you a simple example like a, a toy example. Like let's say you have a program that or like a contract that if its balance is above like one native token 1 ETH, then calling a certain method does. Does action X. Whereas if the balance is below 1e, calling that same method does something different. And these two things are like. It's important to distinguish between these. In like chain 2 let's say the balance is always below 1 ETH and in BAL.
00:56:32.498 - 00:57:04.855, Speaker C: In chain 1 the balance is always above 1 ethical. So if you called the method on these two different chains they would do something different. Like if you had that like method call in a later block in chain two and then when you zip them together you actually got the conditions for state one for chain one to make the balance, you know, go higher. Then like the person who included this transaction in chain two will see unintended consequences in like the zip together version. Does that make sense or.
00:57:09.875 - 00:57:51.825, Speaker B: Yeah, I guess it's. In this case the. I'm not sure how you could do an operation on one chain or the other because the whole thing is the execution is actually running on the inputs from all of the chains. And so like that. I, I guess I maybe I don't understand the question but like each chain doesn't have his own execution environment. The execution environment is, is on all of them. I actually have a, another meeting I think right now, but is there a write up on braid? We're working on it.
00:57:51.825 - 00:58:05.955, Speaker B: We're working on it. There's as you can see, many, many details but we're, we're working on it. Hopefully I'm trying to get it out before devcon. That's kind of my internal goal. Yeah.
00:58:07.015 - 00:58:14.823, Speaker A: All right, well, I guess we can wrap it up then. And free free up everyone. Thanks, Max, for this presentation. It's really interesting stuff.
00:58:14.959 - 00:58:37.605, Speaker B: One more question in the chat, which was I don't understand why Multiproposer solves censorship risks in the first place. There's a paper Censorship Resistance in on Chain Auctions, which goes into into detail about how Multiproposer solves this and and goes through all the game theory. It's on our website, mechanism.org if you want to check it out. But that should answer the question.
00:58:39.785 - 00:58:42.285, Speaker A: All right, thanks, Max, and thanks, everyone.
00:58:43.065 - 00:58:43.465, Speaker B: Thanks for.
