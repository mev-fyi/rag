00:00:12.890 - 00:01:15.822, Speaker A: Hello everyone. There's been a lot of talks today. My goal simply is if by the end you don't follow the meme which says bin, listen, I'm either happy for you or sorry for you, then I've achieved my goals. But I'm here to talk about Aztec, which is a ZK roll up or a public private roll up, or many other names that we've been given in the past six years of our existence. The TLDR is ASeC is trying to make a roll up such that you have privacy inbuilt on the network. Because of that, some people have called us the actual ZK roll up because existing ZK roll ups don't have privacy as such, and because of the way we do it, we don't just believe in privacy because the real world is actually quite private, whereas Ethereum and existing blockchains are completely public. We realized that unlike other private projects, there isn't much value to be fully private.
00:01:15.822 - 00:02:13.830, Speaker A: For example, if you think about Makerdao and liquidations, you need something. You need to know how much money you put in in public to be able to liquidate someone. Or during the recent FTX Luna problems, it was so cool to see everything transparent. But at the same time, much like the real world where things are private, we do need a layer of privacy inbuilt. So I'm going to talk about how aztec will enable not just fully private, not just fully public, but a spectrum where you could start in private, go to public, go back to private, and not just for states, but also functions. So not just for knowing what assets you do or do not have, but also what execution you are or you aren't running. To achieve this, however, we had to break compatibility with the EVM, which enables us to create a lot of super cool features, things that just weren't possible on blockchains before Astac.
00:02:13.830 - 00:02:44.694, Speaker A: But how does that actually work? So, if you're familiar with Ethereum architecture, it's like you have a giant Merkel tree, and all the data is stored into that Merkel tree. And we call it account model, where as soon as transactions happens, it gets updated. You have the exact same thing for Aztec's public sites. If there's giant Merkel tree, things keep getting updated. When you do, the transaction goes to the sequencer. But what happens in the private state? We have yet another surprise. Surprise Merkel tree.
00:02:44.694 - 00:03:10.230, Speaker A: But this time it's all utxos, like bitcoin or fuel if you're familiar with them. They enable a bunch of super interesting things that I want to talk about today. For example, you have this composability between public and private. You also have something that we call, which is my favorite feature. We call them portals. Portals are super interesting. If anyone's familiar with aztec connect.
00:03:10.230 - 00:04:06.982, Speaker A: Here you saw the first time you have a composability between layer one apps and L2 apps. We all are used to seeing DFI Legos in layer one. We all are used to also seeing the same DFI legos, copycating the contracts in l two seeing l two legos. But we never see a mix of both of them. For example, how cool would it be if you could deposit ETH on l one on maker and just get dai straight up on L two? How cool would it be if you had die on l two and just swap it on ETH on l one? Because liquidity fragmentation is happening. But l one will always have the most liquidity, right? And how cool would it be if you could do that all on l one with privacy, even though you're not actually using l one under the hood. And because it's the biggest buzword of the last few months, we also enable account abstraction, which means there are no externally owned accounts, there are no private keys.
00:04:06.982 - 00:04:46.738, Speaker A: You kind of decide how you want to do it. You could make it such that you use your face id as your signature scheme. You could be old school and use your seed phrase, or you could be djen extra dgen and just not have any verification scheme and just let your account do anything without any security. But anyway, this talk is not about all of that. This talk is about this new paradigm that Aztec is going to create around public state, private state and our two different kinds of functions. So how do they exactly work right on the private. The way we keep things private is all the functions.
00:04:46.738 - 00:05:38.950, Speaker A: Ethereum. When you create a transaction, you don't actually execute the transaction. You kind of give your intents to the sequencer and then the sequencer kind of executes these transactions for you, right? And that's why you pay all the gas to the sequencer, because they're doing work for you. How do we make things? Prague we do instead is you execute everything locally on your own machine, and then whatever outputs that happen, new utxos that you created, utxos that you destroyed, new contracts that you created, or l one to l two messages that you sent, you kind of just send that to the sequencer along with the proof that, hey, man, I promise I'm not lying. If you execute this private function that you don't need to know about. These are the outputs. And all I want you to do is update it on the Merkel Creek that I showed earlier.
00:05:38.950 - 00:06:04.400, Speaker A: So no one actually ends up learning the sequencer. Even though we'll add your outputs, it doesn't actually learn what functions will execute. On the public side, you have something exactly like Ethereum. You send your call data to the transaction sequencer, executes everything, and then it creates proof. We're a zk roll up. This side is exactly like a Zk roll up. Create a proof, send it to l one.
00:06:04.400 - 00:06:41.850, Speaker A: Okay, that's great. I kind of get how it works, but what do I do with this? Rahul? Well, why would you use private function more generally, why would you need private execution? Why would I want a state where I don't want anyone to know what I'm doing? Many things. For example, if you're working with private state, for example, as a company, I don't want everyone to know how much I'm paying all of my employees. I kind of want to do this privately. Private state, private functions. Good idea. We can finally do salaries on chain without people knowing what it is.
00:06:41.850 - 00:07:10.834, Speaker A: Kind of similar to the real world. The other idea is when you're working with sensitive data that can be on or off chain. We all have heard you shouldn't put your passports on chain. This is why digital identity hasn't caught up yet, because you can't put anything personal on chain. Well, asset kind of changes all of that because here you don't need to put things on chain. Everything's like private stored for you. And you can just create proofs that, hey, I promise I'm above 18 without you needing to know that I'm above 18.
00:07:10.834 - 00:08:13.850, Speaker A: This could open a whole sleuth of apps that want to be more regulatory focused, that want KYC without having to create a whole off chain component to them. If you're a hedge fund or someone who wants to really make sure that no one knows what I'm doing right, function is a great idea because the sequencer will add all your outputs, but no one will know what you actually were doing. Were you transferring ETH? Were you creating a contract? We'll never know. Additionally, one of the really interesting use cases is airdrops. And everyone's going to listen to me. Now, basically, airdrops are interesting because currently the way you do it is you're on this public blockchain and everyone creates a SQL database of everyone that tried, and then you get listed on the SQL database or GitHub list saying, hey, you're eligible, go claim. But instead, you could do something like proving that you owned an NFT or interacted with the application at a random block X.
00:08:13.850 - 00:08:40.974, Speaker A: And so now, as an app developer, you don't need to create all these fancy SQL like queries. Anyone can just come create a proof, and voila, you're kind of done. Yeah, and as I said, it's not like we just have private state and only public function. And they're two different worlds. You kind of mix things up. You could have a private function, private state, and you sometimes want to interact in public. For example, uniswap.
00:08:40.974 - 00:09:25.642, Speaker A: Before I swap, I kind of want to know how much volume there is, how much liquidity there is. So I know I'm not getting rubbed. All of that stuff is public, which means I need to go to the public domain to kind of swap my assets. Another beautiful thing. So one liner answer to what's private about it is someone did something to some state in some function of some contract, or something happened. What's next? Public function, similar to Ethereum. We don't need to go into too much depth, but something interesting to note is in the private function, you kind of don't have access to the head of the state.
00:09:25.642 - 00:10:02.590, Speaker A: And that's because everything's happening locally on the user's devices, so we can't trust the user to run a full node because that's bizarre and know everything that's happening at the end. So if you want, like, current timestamps, current block numbers, you use public functions. And if you're thinking, hold on, Rahul, all of DFI uses public, like current block stamps and stuff. Well, remember, in private, you kind of can create proof of historic data. So liquidity mining looks kind of different. You just prove that you had put in data into a pool at block X, and that's it. You don't need to create like, complex time related algorithms anymore.
00:10:02.590 - 00:10:59.134, Speaker A: So exactly like theorem, you ask a sequencer to execute a function, and they kind of prove to a theorem that they did it correctly. But as I said, the real genius behind Aztec is that you can compose, you could do public calls to private, you could private from public, you could do whatever you want. But how does that actually work in the zk world of circuits, where I'm saying that private functions execute on user's device? Well, basically you write a smart contract, as you always do. It's private functions, public functions. We'll go through some code examples, maybe. And basically, first on the user's device, you kind of execute all of your private functions, right? And then you just tell the sequencer hey, here are some public functions for you to execute. The sequencer would just find the contract address and the parameters for the public side.
00:10:59.134 - 00:11:46.080, Speaker A: Remember, we can do cross contract calls, so it doesn't necessarily would even know which contract the original private call even started from. We'll go through some actual examples to make it more obvious what's happening. The TLDR is the sequencer does public, user does private, and that way you kind of can have a mix of both current time Samsung private and do the seamless composability of state and functions. But all of this sounds quite abstract. Will this ever be live? What are the trade offs? Can this even happen? What does this even mean? So here's a beautiful example. Let's say you have some tokens that you have in the private state. For whatever reason, you want to now make them public, to interact with uniswap, to interact with a random public function or whatever.
00:11:46.080 - 00:12:07.910, Speaker A: So we call that unshielding. Because you had assets and now you want to unshield. You want to make sure everyone sees them, right. Notice that you kind of, let's ignore the first few lines like the if and else, and just notice you have a new two address. That means you don't need to give it to the same current address. You can give it to anyone you want. That's how we increase our privacy and automation.
00:12:07.910 - 00:12:37.966, Speaker A: And then all you do is you kind of remove your balance from your private storage. And then at the end, notice how you call a public function called increase public balance. So private storage and public storage are quite different to each other. You can't talk to them in the same function. So if you want to talk to public storage, you do it in a public function. This way reduces like mistakes from app developers. You also reduce the chances of leaking privacy when you don't want to.
00:12:37.966 - 00:13:10.854, Speaker A: And notice the things we actually send to the public function is just the two address and the amount. So the sequencer, when executing this, does not even know where it started from. Like who message sender was. If you're familiar with solidity, it doesn't know who from was. It just knows who deserves the balance and how much. Which is exactly what we want to do in this function, right? We want to tell that this address now has this much amount. The way we do this under the hood, if people are curious, is we have different marker trees for everything.
00:13:10.854 - 00:13:36.942, Speaker A: We have a different tree for public, we have different tree for private. We call it the note hash tree, because commitments, Utxos and our notes. And then we have a nullifier tree, which is like zk jargon for basically saying anytime you create Utxos, you create new ones. Those are notes, you destroy some. Those are nullifiers. By keeping nullifiers separate from the notes. If you just look at the note tree, you don't know which ones are actually valid anymore.
00:13:36.942 - 00:14:11.306, Speaker A: We really increase our privacy set this way. So the more people use Aztec, the more privacy. But even if only one person uses it, you still have insane privacy because you don't know which nodes they actually have. And all of these are hashes, so you still don't know the pre images or the data within them. But if they are indifferent trees, does it mean that I cannot talk to them? We just saw private can talk to public, but can we do the reverse? Public can talk to private. So let's do that. You have tokens in the public domain and you kind of want to shield them.
00:14:11.306 - 00:14:39.170, Speaker A: You want to make them private. I don't want people to know how much I have. Let's ignore the first if else statement for now. But basically what you do is you take your public balance. Notice how the public balance, called storage public balance, and the previous one was storage balance, clear separation between what's private and what's public. So anyway, you read your public balance, anyone can do this, it's public. And then you try to create a Utxo for private.
00:14:39.170 - 00:15:26.018, Speaker A: We call it transparent node, because anyone can see the creation of this Utxo. But notice what we put into this Utxo. We put in the amount that's not leaking any privacy, because everyone knew you had that balance, and you put in a secret hash. Why is the secret hash interesting? The secret hash is interesting because basically when I want to redeem the shield at a later time, I just put in the secret. And this code computes the hash of the secret and then checks if this transparent node actually existed in the pending shields map. And then it sees that it existed and then removes the node and adds it to a private storage. So remember that private functions are executed first, public are done later.
00:15:26.018 - 00:15:58.062, Speaker A: Here we're going from private, from public to private. That means the user first does one transaction for public, and then at a later time they can do it in private. Right? This creates like a whole new set like here. You need two transactions, but it's really interesting because you can now do private to public, but also public to private. Notice in the private domain you are passing the two address as well. But it doesn't matter, it's all private. The sequencer doesn't know who's actually getting it.
00:15:58.062 - 00:16:56.080, Speaker A: But the two address is still nice, because here you can see who the message sender is, the person who actually has the balance, but you cannot know if it's the same address that will receive the balance. Again, one of our nifty tricks to increase the privacy set. By the way, I want to say that this is not something that's possible 500 years from now when we eventually launch our code. Because we are an EZK research company, two months back, we launched our sandbox. Sandbox is a fancy word for a local developer environment, a Grenache, an annual or truffle, if you will. In the last two months, we've seen hundreds of developers, hundreds of companies actually building on top of Aztec and experimenting with our unique execution environment, our unique features, and our new smart contract language. So if anyone has worked in ZK, they would know about Noir, which is our own custom language that Aztec has created to make it easier to write all this CK stuff without knowing any of the CK stuff.
00:16:56.080 - 00:17:24.794, Speaker A: Two months back, we announced that we added a framework on build Noir to make it a smart contract language. So the same noir, all of this is actually a zk circuit, but it reads kind of like solidity. And our point is to make it super easy to onboard zk devs. Our point is make it super easy to onboard solidity devs into ZK just so you can do that. So all of this stuff is actually live. We will be launching fully decentralized on day one when we do mainnet. So there's a lot of work to be done.
00:17:24.794 - 00:18:11.240, Speaker A: We have to launch decentralized sequencing from day one. We have to do decentralized proving from day one. We have to do upgrades with minimal multi set capabilities, things that no roll ups have done to them. So we have a lot of super interesting things, even things as obvious as fees, which we take for granted because of 1559 doesn't quite work exactly in the private domain. What I mean by that is, for example, in 1559 you can get refunds if you overpay. How do you do refunds in the private domain? More importantly, if the user is executing private functions locally, the sequencer doesn't do much. Does that mean that for private, the fees will be much lower compared to public? And therefore, because the sequencer can make more money in public, it will always prioritize public.
00:18:11.240 - 00:18:25.900, Speaker A: We'll find out. We're doing a lot of thinking about this. Those are our documentations if you want to try out aztec through GitHub. And if you want to talk to me, that's my Twitter on my way to the moon. Not literally. Like, to stay on earth for a while. Thank you for having me.
