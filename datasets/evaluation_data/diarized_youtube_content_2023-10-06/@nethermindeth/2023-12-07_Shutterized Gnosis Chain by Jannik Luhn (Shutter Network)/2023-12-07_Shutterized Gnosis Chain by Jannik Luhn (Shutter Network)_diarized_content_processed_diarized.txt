00:00:04.330 - 00:00:47.498, Speaker A: Thank you. Also have a very nice logo. Maybe you can play that. So yeah, I'm going to talk about chatterized closer chain, which is a project that I work on where we're trying to make dosage chain a little bit more secure and user friendly. This is actually a collaborative effort between Nosachain, of course, shutter network, which is where I'm from, and anothermind team, which is maintaining the main client of noschain. So they have to implement a lot of that stuff that I'm going to talk about. Yeah, maybe as an intro a little bit about noschain, if you are not familiar with it.
00:00:47.498 - 00:01:15.166, Speaker A: It's an Ethereum like chain. It uses kind of the same protocol, also supports the same clients, just a different configuration parameters, but it means it's maximally compatible to Ethereum. It's basically the same thing, just as a different state. Of course, different from Ethereum. It's much cheaper to use. Typical transaction costs less than 0.1 cents, and it's also a little bit faster.
00:01:15.166 - 00:02:20.060, Speaker A: So the block time, 5 seconds instead of twelve of ethereum. This does not come at a great cost of decentralization. Node chain is very decentralized, has about 2000 nodes, typically in 1712 countries, which is like one metric you can use to measure decentralization. And maybe in the future it could act as kind of a test bed for future changes to changes to ethereum. So since it is very similar technologically and also value line with Ethereum, it's very much possible that changes that are going to be rolled out in Ethereum will be kind of implemented first on most chain because it comes with lots like less risk, basically because there's much less space. And yeah, from personal experience I can say it's a very nice place to be. I do a lot of side projects sometimes and deploying them on those chains, always very easy and fun.
00:02:20.060 - 00:03:26.714, Speaker A: All right, so the problem that we're trying to solve is called front running. The main problem, if you don't know how it works, I can give you an example. Say there's Alice and she wants to buy something on a decentralized something you typically do. What you have to do is you have to make this transaction that you want to send public in the mempool, and it will only be included later, which means lots of people will see it on the way into a block, including the block proposal. And other people who see this transaction can now react on that transaction and send transactions depending on that. For example, Bob could try to send a transaction the same transaction, buying the same token on the same exchange before Alice and then selling the token after Alice. Why would Bob want to do this? Usually because Alice buying the token means that the price will go up, and by buying before and selling afterwards, Bob can make risk free profit.
00:03:26.714 - 00:03:50.120, Speaker A: So that's very nice for Bob, but it's very bad for Alice because Alice gets a worse price. Basically, it's a value transfer from Alice to Bob. We don't really want this. Yeah, it's kind of a general problem. Lots of blockchains have this. And I would say it's actually one of the most significant limitations that blockchains today still have. And it's one problem that we're trying to solve here.
00:03:50.120 - 00:04:44.200, Speaker A: How do we do this? Using an encrypted map rule. So same thing. Say that Alice wants to buy something on the exchange. Now, she will encrypt that per transaction. Now in principle, Bob will still see this transaction and Bob will be able to another transaction front and after. But since Bob doesn't know if Alice is buying a token on which exchange she's buying it or she's selling it, or if it's just a value transfer, Bob effectively can't extract any value from that, which means the attack is not possible anymore. And as kind of a nice side effect, this also increases censorship resistance, because for example, if the block proposer tries to censor Alice or censor a certain application on the chain, he will not be able to do this if he doesn't know what the transaction does.
00:04:44.200 - 00:05:39.114, Speaker A: Now the transaction is encrypted in the chain. It's not very helpful. At some point we have to decrypt it in order to execute it. And there's multiple ways what we could do this, kind of the most natural would be to ask Alice to send an encryption key later to do this. Unfortunately, that would be very simple to implement, but kind of annoying to use for Elish, because in order to do one thing, buy something, she would have to send two transactions or two messages to the chain with like a time delay in between, so she would go offline. In the meantime, this would fail and it generates not a very nice user experience. And the other problem is that Alice could decide later, depending on what happened in the chain, if she wants to send this transaction all or not.
00:05:39.114 - 00:06:25.170, Speaker A: So in a way she could cancel transactions she wanted to do earlier. And this would break. Like many applications, we can't really do that. Instead, what we're proposing here with Shutter and what we are providing to this project is a threshold committee. So what's that? Basically? A set of notes in the network that whose job it is to collectively produce this person encryption key that will be public, that anyone can use to encrypt their transaction. And then on a request by the protocol, when it's time to decrypt, this committee will also produce the corresponding decryption keys. There's an honesty assumption.
00:06:25.170 - 00:07:47.896, Speaker A: So we need to trust that this committee does not produce keys too early because then they will be able to front run. And we also need to trust that they actually produce them eventually because otherwise the protocol would kind of fault and would be unable to decrypt the transactions and the number of nodes of that committee. So we don't have to trust every individual, we only have to trust them collectively, usually like two or third of them, which is like a parameter we can choose. And how do we make sure that this set is actually trusted? We have a Dow that kind of hand selects them. So the job of the Dow is to make sure that they come from diverse backgrounds, from different regions, different jurisdictions, and they're just different entities altogether, so that there's not one entity that can take over the whole set. All right, that was kind of the theory, how it works in theory. Now the question is how do we actually implement this in the context of nostal chain? And first to start off, kind of the guiding principle that we had when we kind of designed the protocol was to minimize risks and minimize complexity and also minimize the UX impact.
00:07:47.896 - 00:08:55.044, Speaker A: So nostril is already light. We don't want to break it, of course, and we want to kind of roll it out as slowly as possible, or not as slowly, but as safely as possible without breaking things that already exist, including breaking the kind of UX flow that users already have. This means for the first version that we are actually preferring having trust assumptions over protocol changes, which means we don't have to afford the network as a whole in the first version. But once we have this implemented, then from there we can go iteratively, step by step, improve it, go from reduce the trust assumptions, but at the cost of actually changing the rules of the protocol and requiring a fork if the community wants this, of course. All right, so this is kind of the sequence diagram, how the flow would work. We have the keepers here. They start by producing this master encryption key that I mentioned.
00:08:55.044 - 00:09:37.504, Speaker A: We call it the eon key, and they have to send it somehow to the users. They need to have this key for that. We use this kind of a key broadcast contract. So it's a normal contract deployed on those chain that the keeper sent this key to, then the users can fetch it from the contract, use it to encrypt their transactions and send it to another contract called the sequencer contract. The sequencer contract. Now the job of that contract is to include those transactions, filter them, potentially like according to whatever rules this contract wants to implement, for example based on the fee that they pay. And another job of that contract is also to order them in the first version.
00:09:37.504 - 00:10:19.200, Speaker A: Simplest version, probably also ideal version, is just first cut, first server. Now the keepers will watch this sequencer contract and once the time comes to decrypt these transactions, they will produce the corresponding decryption keys. They will then send it via PSP network to the proposer. The proposer's job is to build a block. So they will take the decryption keys, check the encrypted transactions and decrypt them and put them in the block. And that's basically how the protocol works. As you can see, this is mostly added components.
00:10:19.200 - 00:11:14.476, Speaker A: The only component that doesn't exist yet is the proposer. And we can see that already exists is the proposer. We can see that we add like additional duties that this proposer now has. But in the spirit of these guiding principles that I mentioned earlier, not breaking things, not requiring a hard fork, we make these additional duties opt in. So we will have a registry contract where proposers can opt in if they want to support this effort. They can register and say I will do this job and let everyone else know that they do this job and then they fulfill these duties, hopefully. But at the moment we don't really have, there's no enforcement of these duties.
00:11:14.476 - 00:11:50.140, Speaker A: That's the trust assumption that I mentioned. We trust that they actually do this. If they don't, I mean the project doesn't work anymore. At least the chain continues working. One thing to note here, this is these trust assumptions are like basically what I said. It's not like we are adding trust assumptions to this existing protocol, it's just trust assumptions for this added functionality. In the worst case we fall back to existing, to the existing protocol.
00:11:50.140 - 00:12:41.740, Speaker A: In the future, we will make this, hopefully more, we will enforce this more strongly. In the first place, we will make participation mandatory. So all validators will have to participate. Then we will at some point slash them if they produce blocks that do not fulfill these rules. So if they decide to produce a block but don't include the encrypted transactions for example, or front run their transactions in this encrypted part, then we will slash them for that so that they lose some money and at the last step, but this would now require an actual hard fork, we will make these blocks actually invalid. So this is something we can check that the order of transactions in the sequencer contract matches the transactions in the block. If that doesn't match, then the network will just reject the block and ignore it.
00:12:41.740 - 00:13:11.132, Speaker A: So it will basically be impossible to not follow this rule of neat. And that's basically then the ideal and strongest enforcement of these rules. User experience that's another thing we want to keep as simple as possible. Normal transactions. Nothing changes. Users will still be able to send plaintext transactions as they do now. But if they want to use this additional feature of using encrypted transactions, that would be front rank protective and more sensory resistance.
00:13:11.132 - 00:14:14.168, Speaker A: They start off by creating and signing transactions as normal, but now they will fetch this eon key from the broadcast contract and use it to encrypt the transaction, and then wrap it in another transaction that sends it to the sequencer contract. These last two steps will likely be done by the app front and whatever they use. Of course the user will not go to etherscan and copy and paste the key. It will be done by some script in the background of the application that they use. If the DAP does not integrate this functionality yet, but users still want to use it, we will provide what we call the encrypting RC server, which is just a normal JSON RPC server that users can configure in their wallet. And then this RC server, whenever you send a transaction to it, will perform these last two steps for the user. This means you have to trust them to not front run you, but at least you don't have to trust anyone else to not do this.
00:14:14.168 - 00:15:02.396, Speaker A: So it's kind of a stepping stone that makes transitioning to this very easy without anyone else, in particular the DAP, requiring to. Yeah, that's basically all I have to summarize. Shutter and nose chain, kind of this collaborative effort between three teams at Nosis, shutter and nethermite to make nosy chain more secure and user friendly because front running will not be possible and also more censorship resistant. And yeah, you can check out this pack. We have two versions of this pack, one high level, one low level. The high level also includes like a discussion of different failure scenarios, which might be interesting to read. And yeah, you can also follow us on Twitter if you're still using that.
00:15:02.396 - 00:15:03.050, Speaker A: Thank you.
