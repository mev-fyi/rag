00:00:00.170 - 00:00:18.480, Speaker A: All right, this should be an excellent talk here. We're going to talk a little bit about client diversity on the execution layer. And many of the room might know already that there's a supermajority client on the execution layer. I probably, no surprise we'll start talking about this, but let me get into it by introducing our panelists here.
00:00:19.650 - 00:00:33.640, Speaker B: Hey, I'm Marius. I'm from the supermajority. I'm probably going to get all of the hard questions. Yeah, I'm from get.
00:00:34.650 - 00:00:42.010, Speaker C: Hi, I'm Gary. I'm from Hyperledger, Beisu and consensus. We are a minority client.
00:00:46.110 - 00:00:48.860, Speaker D: Hi, I'm Mike from the undermining team.
00:00:50.610 - 00:00:54.880, Speaker E: I'm Michael. I actually work on a consensus layer client, but I'm here because I do.
00:00:59.730 - 00:01:05.150, Speaker A: Well, that was my first question, Michael, which is, why is lighthouse up here on this panel for it?
00:01:05.220 - 00:01:05.466, Speaker E: But.
00:01:05.508 - 00:01:20.390, Speaker A: Excellent. I'm glad to see you here. But let me get to the first question, which is back over here to Gath. Does Gath want to remain a supermajority client? What's your opinion? Are you willing to self commit to 22% of the network?
00:01:23.850 - 00:02:12.550, Speaker B: It's a difficult question. I think in general, we really like client diversity, and we think it's great that we have other clients coming up, also other clients that have maybe, like, slightly different outlooks on the network and how it should be and have new ideas and stuff. And I think it breeds a lot of creativity, a lot of discussion. But in general, yeah, I think we support client diversity very much, and everyone should, if they're in the position, they should run a different client than gas. But gas has been here forever.
00:02:14.250 - 00:02:14.614, Speaker E: Since.
00:02:14.652 - 00:02:20.460, Speaker B: The beginning of the network. And I think the gas team.
00:02:22.590 - 00:02:23.046, Speaker E: Feels.
00:02:23.078 - 00:03:13.690, Speaker B: A lot of responsibility for Ethereum and for the security of Ethereum. And so, for example, we do a lot of testing that we also share with other client teams, and we try to always be the responsible one in the room. And I think some of the other clients are playing faster and looser with the rules. And so, yeah, we're happy to have less share in the network, but it's also like we're giving up a lot of power right now. Sometimes we feel like the adults, and it's hard to give that power away to some of the newcomers.
00:03:14.990 - 00:03:37.010, Speaker A: Excellent. Thank you. I appreciate that candid response there. Let me do a speed round, and I'll pass the mic through in one word. And then, Michael, when it gets to you, if you can, then ask the second question. And coming back here, but just first, as the mic goes one way, in one word, what is the biggest benefit for client diversity? And then when the mic comes back, can you expand upon all the benefits.
00:03:37.080 - 00:03:40.930, Speaker B: Of client diversity in one word?
00:03:41.000 - 00:03:43.330, Speaker A: One word or a short sentence?
00:03:46.090 - 00:03:50.040, Speaker B: I think testing, that would be my word.
00:03:51.130 - 00:03:53.830, Speaker C: I would say antifragility.
00:03:55.770 - 00:03:56.520, Speaker D: Security.
00:03:57.930 - 00:04:36.950, Speaker E: I was going to say resilience, but that's just the same thing. All the benefits, I guess. Yeah, the testing thing is a good, that's a bit of a different angle. We end up with a network, that is, we end up with basically a better spec for how the network should behave if we have multiple implementations of that spec, and it's not just a consensus, which is obviously very important, but these other features, if we get pushback from get saying, hey, you guys aren't implementing the snapsync server, it becomes clear that's an important thing for the other execution.
00:04:41.690 - 00:05:19.780, Speaker D: I think there are lots of benefits. So as Mario mentioned, testing. So thanks to that we can compare results between different clients and this is very effective way of testing. Any changes? Do puzling stuff. What else? Client diversity allowed us to attract many core developers skills in different programming languages. But for me the most important are security benefits. So for example, if we have any vulnerability in one client, it means that one client is vulnerable but not the entire network, right?
00:05:21.990 - 00:05:22.546, Speaker E: Yeah.
00:05:22.648 - 00:05:30.594, Speaker C: So to expand on anti fragility, I would say that the ability to echo.
00:05:30.642 - 00:05:31.954, Speaker A: What Merrick said a little closer.
00:05:32.002 - 00:06:34.170, Speaker C: Sorry to echo what Merrick said, having multiple different clients, multiple different developers, and multiple different interpretations of spec allow you to encounter these things early. Like when we're in test networks, we discover these things earlier, can tend to make things take a little longer. But the net effect is that we discover problems, problems in spec and problems in implementation early. And it also just kind of frees other clients up and hopefully could free up Geth from a bit of the responsibility of being a supermajority, because you probably want to sleep at night knowing that what you wrote last night isn't going to crash the network. So I think that's a huge benefit, is to be able to take that weight off while still maintaining a conservative approach that allows the values of the network to kind of shine through. Because Geth has been here the whole time for the whole of Ethereum. So there's got to strike a balance.
00:06:34.170 - 00:06:43.680, Speaker C: But I think fundamentally having these minority clients or non supermajority clients gives you the ability to experiment more.
00:06:45.570 - 00:08:31.600, Speaker B: Yeah, I think you guys already extended on testing, so I'm going to touch on two other points that I thought one thing that I really like about this is that I don't know, if you're working in a team, it can quite easily happen that you fall into some kind of group thing, and if you have different teams, you always have to discuss with them. And so some ideas that we have might not be feasible to implement or not good to implement for other clients. So having different client teams just increases the amount of people that understand this network, that can contribute to it, that can form ideas and think about proposals way more than like a single team would. And I think we see this in other ecosystems where there's only a single core development team and they produce the stuff that they produce and they never really get challenged on it. And so I think from a decentralization perspective, just having different teams with different ideas is already like a huge factor. And it's also a thing if really push comes to shop and one client team would say we are not going to do this, or we don't want to implement whatever, then there are still enough skilled developers to push changes forward and to keep maintaining the network. I think that is one important point.
00:08:31.600 - 00:08:47.080, Speaker B: I have one more. It's always the problem at these panels that you have these interesting ideas. Forget about them. Let me think for a bit.
00:08:48.010 - 00:08:50.934, Speaker A: Well, maybe I can ask the question in a different way now.
00:08:50.972 - 00:08:51.366, Speaker E: Right.
00:08:51.468 - 00:09:08.090, Speaker A: We've heard the benefits of the client diversity on the execution layer, but it's certainly not easy. There's got to be some challenges. What are some of the drawbacks of client diversity or implementing client diversity?
00:09:09.470 - 00:09:11.120, Speaker B: One word answers again.
00:09:11.570 - 00:09:13.550, Speaker A: No, you can expand.
00:09:15.090 - 00:10:04.800, Speaker B: I think the biggest problem is probably the overhead of coordinating. We have so many people, so many teams, and I don't know, if we launch just a test network, then we need to have implementations of ten different clients. All of them have to implement it at the same point, the same version of the spec. And even if we might have already improvements to the spec, we might not be able to start the test network with these improvements because some of the clients haven't implemented them yet. And so we might be stuck for longer on an older version just because everyone needs to be there.
00:10:05.810 - 00:11:08.770, Speaker C: Yeah, I would say that upgrades move kind of at the speed of those lowest teams. I would put that succinctly in that way. I think an additional drawback is that it's constraining to have to implement only ideas that are applicable to all of the tech stacks. Like, there's probably a lot of ideas, a lot of things that different teams in different stacks could do that not all teams can right. And I think one further thing is that there's always wiggle room around spec and you end up with kind of bespoke or maybe ad hoc type of like RPC endpoints are a great example where we have parity style tracing and we have guest style tracing and we have these endpoints that a supermajority client, their RPC endpoints just kind of end up being the spec regardless of whether they're specified or not. So I think that's probably what it is. It's almost in some ways get is the spec in cases.
00:11:11.030 - 00:11:51.280, Speaker D: I wanted to say basically the same thing. So development overhead, because developers are working more or less on the same thing, same EIPs, but in different clients, in different technologies. So if we had one implementation and the same number of developers, we could deliver more EIPs in the same time. And yeah, as Gary also said about standardization, JSON Rpc. So for Dapp developers, for example, integrating can be complex because they have to handle all possible options from different clients, or we have to adjust as a minority clients to get these kind of things.
00:11:53.250 - 00:12:59.080, Speaker E: I was going to say one of the things that's hard from the consensus side as well is that client diversity is sort of quite a fragile setup, even once you do achieve it. So on the CL side, we've had diversity improve a lot, but then there's still sort of situations where the large clients can sort of call the shots in what happens on the network and drag the other clients along with them. And I'm guilty of doing this with lighthouse where there was a change I wanted to make to the spec to reorglate blocks. So we just implemented it in Lighthouse and then Prism copied us and we had 70% of the network doing this thing that was not really to spec. And the minority clients were going, hey guys, can you get this in the spec? And I feel kind of bad that we did that, but it was also, there were reasons from a security point of view that that was beneficial. But it's sort of like even once you have diversity, there's these kind of like economies of scale and a network effect around a particular client, and you kind of have to do weird things to restore the balance, even if you're trying to.
00:13:02.250 - 00:14:13.594, Speaker B: I actually remember my other advantage that I wanted to talk about, and I think it's because we have these different clients in different languages, we have developer tooling that is great if you are working in, I don't know, JavaScript and you want to have an EVM implementation, you just use the libraries provided by Ethereum Js that they use in their clients that is guaranteed to follow the spec. If you're working in go, you can just pick the go. The guest libraries. If you're working in C sharp and this is your favorite language and you want to build a project in it, then you take the Nethermyt code. And so we have a lot of libraries for most of the languages. And so you can just pick the language that you are interested in, that you're interested in, that you are proficient in, and you have the tooling to interact with the network, to interact with smart contracts. And this tooling is provided by the client teams.
00:14:13.594 - 00:14:32.420, Speaker B: And so I think that also increases the amount of developers that want to interact with Ethereum because they might want to learn a new language, so they pick the tooling in that language. And so that is also a huge advantage in my.
00:14:34.300 - 00:14:47.740, Speaker A: Okay, I want to follow up on a question, maybe a derivative of what Michael was saying previously about client diversity. Has there ever been an example of client diversity on the execution layer that has helped Ethereum?
00:14:50.720 - 00:14:51.420, Speaker E: Go ahead.
00:14:51.490 - 00:15:08.916, Speaker B: Yeah. Okay. Yes, there have been a few. One immediately comes to mind were the Shanghai attacks, which is very early ethereum history. I think it's earlier than all of.
00:15:08.938 - 00:15:10.580, Speaker D: Us on the panel.
00:15:11.480 - 00:16:16.192, Speaker B: So, yeah, back then, it was these guys who fixed it. Basically, there was a DOS attack in Geth, and an attacker found it and started sending transactions that would trigger it. But because parity implemented it differently, the network didn't went down. So gas couldn't verify the blocks in time, but parity could. And so this was the first big example of where client diversity helped keep the network alive. And I think there was recently another example with Nethermind where Gat had an issue in the transaction pool where you could send weird transactions and they would throw out other transactions. And because Nethermind has implemented the transaction pool differently, they were not affected.
00:16:16.192 - 00:17:30.000, Speaker B: And so we had enough transactions going on, and it gave us enough time to fix the gas transaction pool. Fortunately, other than those instances, I don't know of that many where something really happened on Mainet, but we found a ton of bugs just fuzzing different clients against each other. So for that, we create some input, we execute it on the different clients. We log out what they are doing, like what the opcodes that they produce and how much gas they cost and whatever, and then we verify that they do exactly the same thing. And this is called differential fuzzing. And this found a ton of issues in most of the clients where something was implemented slightly different, which could have led to a consensus issue, but fortunately we caught it before it hit mainly. So this is also where client diversity really shine.
00:17:33.540 - 00:18:04.430, Speaker D: So I'm thinking about premerge issues. And for example we had Kitsuki testnet, pre merge testnet. And on this testnet Nethermind produced bad block. And I think Bezu and Nethermind accepted that block while get rejected. And because of that we started to thinking more about other possible edge cases and we improved the specification of Ethereum and engine API. So another example.
00:18:07.760 - 00:18:21.890, Speaker A: Okay, one interesting thing I'm kind of curious of is how are we actually monitoring or determining client diversity? How do we actually know what the percentages are right now? Can you guys expand upon that?
00:18:23.880 - 00:18:24.630, Speaker E: Sure.
00:18:25.960 - 00:19:16.048, Speaker C: That's a difficult problem. We're doing it poorly I think is the answer. There's a variety of some case post source tools that are tracking client execution, client diversity. It's just especially at post merge, it's really difficult to measure this accurately. So this is really an open problem that we need to solve is the ability to accurately fingerprint execution clients, not only in the context of validator nodes, but participating nodes and so forth. There's different, probably different measures we should be taking. Like bot producers are one case validating and testing nodes, or another case and then just participating nodes themselves that are just connected to the network.
00:19:16.048 - 00:19:37.080, Speaker C: And we don't really have a way of separating those different cases. I think clientdiversity.org is they're using basically self reported information from staking pools, which is a big portion of the network. It's a large section of stake, but it's not reliable. It's self reported and it doesn't really have a full picture.
00:19:38.140 - 00:19:38.552, Speaker B: Yeah.
00:19:38.606 - 00:19:41.470, Speaker C: So I think it's just an open problem, really.
00:19:43.790 - 00:20:31.500, Speaker E: I was just going to add that from a consensus safety point of view, similar to the CL, I think maybe the most important one is which clients validators are like what the breakdown there is, because the situation we really, really don't want to get into is where a supermajority client thinks that an invalid block is valid and then attests to it. And then we finalize that block and then that's basically game over. For everyone that staked with that client. They are either losing all their ETH through a slashing or through the leak, because basically there's no way back from that. And I think in practice, if that happened, it would create a difficult political situation because the people who staked with that client would be wanting a bailout. Right. There'd be talk of, do we hard talk and allow this? And it would just be a mess.
00:20:31.500 - 00:21:07.220, Speaker E: And I think, yeah, unfortunately, because we have builders building model blocks, we can't just fingerprint execution layer blocks like we do on the consensus layer. And we have these network crawlers, which will show us the number of nodes. I think we should improve the network crawlers. And there's work that the get team and other teams are doing on that at the moment, which is great. But yeah, there's also, like we talked about in the client diversity panel, in my talk, there's this balance between privacy and openness, where we want data, but we don't want to dox what clients people are running.
00:21:11.050 - 00:21:51.294, Speaker A: Maybe we could expand upon that a little bit. I mean, I guess I never really thought that when you start profiling, right, you're looking at a fingerprint, a certain attribute of signatures, even if it's just a self disclosure or I'm a gap client, I'm another mine client, that there's really maybe three sets of players in this industry, right? There's the block producers. We think there's about maybe 20 to 40 very successful block producers that work with the relays, right? There's the number of nodes or validators that are running. Right. And then there are maybe a small set but unforgotten amount of individuals that run a full node at home but aren't a validating node.
00:21:51.342 - 00:21:52.034, Speaker E: Right.
00:21:52.232 - 00:22:01.574, Speaker A: And I'm understanding from the panel here that it probably matters most, the validating or a testing node to make certain that they have quite diversity in here.
00:22:01.612 - 00:22:02.054, Speaker E: Right.
00:22:02.172 - 00:22:34.480, Speaker A: Not to belittle the diversity of the block producers, but that's probably the more critical group. And I wonder, just as a question I like to hear all the panels kind of members talk about here, is if we start creating these probing methods, these fingerprinting methods, these scrapers that go out and start trying to determine who's who on the Internet, is there a risk to identifying who a node operator is and what clients they're running? And if so, can you share with the audience what that risk is?
00:22:36.230 - 00:23:47.400, Speaker B: I think there's definitely a risk. Some of you guys can expand on it, but I think if you like, there are people out there that have that data already. And I'm pretty sure this data is being scraped already. And so I think it just makes sense for us to also have an insight into it, because if you want to attack the network, then it's kind of easy for you to build. It's not easy, but it's possible for you to build these tools, to find, to scrape these networks. And I think it's always better to have that in an open, transparent way and provide the tools ourselves to make sure we can also guard against it. Maybe instead of just ignoring the problem and having some outside people like building closed source tools that we don't know about that we suspect are there.
00:23:51.310 - 00:23:51.626, Speaker A: We.
00:23:51.648 - 00:23:56.300, Speaker B: Shouldn'T just sit there and ignore the problem. We should tackle that head on.
00:23:59.470 - 00:24:23.940, Speaker C: I think there's probably room, there's probably solution space where we can use zero knowledge to identify, to fingerprint self report, and then maybe at least make it difficult to falsely self report. I think is probably a solution space we might be able to look at there. But yeah, it's still an open question.
00:24:25.350 - 00:24:46.170, Speaker D: So for example, we could provide these statistics by putting it to, for example, CL graffiti. But as Marius said, for example, it's connected with some risks. But on the other hand, ZPA technology might be connected with complexity of the client. So we need to find trade offs.
00:24:48.270 - 00:25:23.590, Speaker E: I would think that putting any sort of secret signing key, like Gary said, in the client is like. I think that has to be the method of last resort, because from a privacy point of view, it's kind of terrible to have this. It's kind of like a DRM thing in your binary that you're trying to put something in there that's hard to remove or hard to tamper with. I think that's kind of against the ethos of open source privacy, privacy preserving software. So I think if we can somehow get better data without having to resort to these things, I think that would be preferable.
00:25:25.050 - 00:25:37.340, Speaker C: Obviously, I definitely not want to go down the route of DRM, but I think certainly we can make it nontrivial to falsely self report, I think is what.
00:25:40.570 - 00:26:09.040, Speaker B: Yeah, I think there's a trade off between privacy and usefulness and security. The solutions that we have right now are not that great, and I think we can improve on it, definitely. After this panel, we sit down.
00:26:12.050 - 00:26:12.846, Speaker E: Okay.
00:26:13.028 - 00:26:48.170, Speaker A: As we get to the concluding questions here, I guess so. We've learned so far that client diversity does matter on the execution layer. We don't have good client diversity. It certainly has shown benefits both in the history of Ethereum, and we need to do much better at having a very robust and kind of accurate way to measure that client diversity. But now what do we do? How do we fix this? How do we get a good diversity among a testing, validating nodes in client diversity? What are some of the solutions? How do we do it? Let me start this way on the panel.
00:26:49.630 - 00:27:25.826, Speaker E: Sure. Thank you. So something that I've been thinking about, when you come to one of these events and there's all everyone together, you start to have strange. And even though the rest team aren't here, we have the possibility now of a monolithic rust client. If we were to combine lighthouse with RAM sake and this, while it might help execution layer diversity to have, say, a monolithic rust client, it's easy to use. Maybe it has some very, very marginal performance benefit from avoiding the interprocess communication. Mostly, I think the advantage would be in usability.
00:27:25.826 - 00:28:07.046, Speaker E: But then the question becomes we have to balance not just execution layer client diversity, but also consensus layer client diversity. If we're going to bring people across to this monolithic rust client, we're going to increase Lighthouse's effective share, and we're already too large on the consensus side. So it could be that if we did this, we would maybe help execution diversity a little bit, while harming consensus based diversity. And it's something that we can do without sort of any. Obviously, it's the engineering work there, but without any sort of incentives or anything like this, that's sort of trying to meddle with how the protocol works. It would just be a distinct advantage. But I'm undecided as to whether we should do this.
00:28:07.046 - 00:28:19.510, Speaker E: I think it would probably be better if, say, beta merged into a one on a thick client and then boosted both of those clients. But something I've just been thinking about recently.
00:28:20.810 - 00:28:41.678, Speaker D: So what we could do to improve the situation, I think, first of all, of course, we need to find better way to find data about execution client diversity. What else? We need to improve minority clients, of course. Yeah, that's it.
00:28:41.844 - 00:28:42.560, Speaker E: Yeah.
00:28:43.330 - 00:29:44.100, Speaker C: I think we probably need to do better communication, because I think, like Dr. Ed did in March of 2022, he had a blog post about run the supermajority client at your own risk. Those penalties and anticorrelation penalties, they already exist, but I think they're largely ignored. So I think just doing a better job of education would go a long way. But I think that's kind of more of a fear based thing. I think it's probably more advantageous to compete on features like Michael was saying, if we lower the friction for having a Teku Besu combo, for example, or have a different storage format that leads itself to take less space, having something be operationally less complex, I think competing on features is probably the right answer, but education about the existing incentives, I think, is a more near term thing.
00:29:45.510 - 00:30:45.158, Speaker B: Yeah. Wanted to talk about two things. One thing that I think is really important, and it's being tackled right now, is just how to set up your client. So it's very easy to find a tutorial online or like ten tutorials on how to set up gap. And it's not so easy to find for the average homestaker to find a tutorial on how to set up the newest version of BIso or the newest version of Nevermind. So I think there's a lot of value in just the community creating documentation, creating all of these Grafana charts that work with the clients that you can just download and have your charts or like the depth node tools. Depth node, right.
00:30:45.324 - 00:30:45.702, Speaker E: Yeah.
00:30:45.756 - 00:32:02.862, Speaker B: Where you can just one click install the clients and run them. So there's a lot of. So another thing that we always, as the gas team, always try to do is we try to make our testing that we do internally available to other clients. So we've been maintaining hive, we've been providing a lot of stuff to the Ethereum tests and now the execution spec tests in order to take some of the work that needs to be done in testing away from smaller client teams. And I think that has been very beneficial. So smaller client teams can focus on improving their client, working on the stuff that needs to be done and just run out. Like, sure, it will never eliminate the testing that they need to do, but it can help them in just having some tests that we know are good.
00:32:02.862 - 00:33:03.460, Speaker B: And especially around the merge. I try to always be the first one to implement the specification and provide test vectors so that other clients could take them, implement the spec on their own, and then check against the test vectors. And it was oftentimes that at some point our implementation was wrong and the test vectors were wrong. And it only occurred because Marek implemented it in Nethermind and saw that they get a different result and why do we get a different result than them? And then we discussed and then we figured out, okay, it's like one of our implementations is wrong. And so I think this is one way that the bigger teams can help the smaller teams in just being more active in testing, being more active in writing the specifications and writing documentation and stuff.
00:33:05.540 - 00:33:13.700, Speaker A: Well, let me pause my questions here and just reach out to the audience here to see if anybody in the audience has questions over any of the topics that were covered.
00:33:18.680 - 00:33:29.848, Speaker F: Yeah, this is really not actually a question. It's more like the comments that would, like, make. And I think Michael has touched upon this and Gary touched upon this. Maybe I'll touch upon it a little bit.
00:33:30.014 - 00:33:31.532, Speaker B: But as I did.
00:33:31.586 - 00:34:04.950, Speaker F: The minority client bad block acceptance, that is a network event which is self healing and forgotten the next day and has no repercussions effectively. Whereas a majority client bad block being accepted by the network is such a shit storm that it could haunt us for years on a technical level and an organizational level, governance level, and a general winter of Ethereum could be caused by such an event nowadays, I think.
00:34:06.040 - 00:34:08.352, Speaker A: Can you expand upon that and just explain it?
00:34:08.426 - 00:34:55.540, Speaker F: So, as Michael mentioned, that could lead to people wanting to revert blocks and go back on finality, because there will be otherwise an inactivity leak causing basically full loss of more or less all the assets by a majority of validators, and they would rather want the wrong block to be accepted. There would be this governance discussion that would be basically worse than the Dow. So it would be on all levels a huge event. For me, that's the kind of easy answer why time diversity matters. And I know there's a lot of other answers.
00:34:56.760 - 00:34:57.510, Speaker E: Yeah.
00:34:59.880 - 00:35:01.380, Speaker F: That'S just my concept.
00:35:04.460 - 00:36:00.120, Speaker B: And I think we also kind of saw this with the imperial bug. So there was an issue in gap that was fixed, and like 0.1% of the nodes were still running this old version that had this bug, and someone deliberately triggered that bug and took down the 0.1% of the nodes, which is like not much of the network, but those were the nodes that impura ran. And so for I think like 6 hours, 7 hours, all of the infuria nodes were dead. And this event, even though it was a buck and gap and it was like only 0.1% of the nodes, is already caused such a shit storm that I had trouble opening Twitter.
00:36:00.120 - 00:36:13.980, Speaker B: If you care about my mental health, you should consider running a minority clinic.
00:36:16.740 - 00:36:20.690, Speaker A: Excellent. As I look out to the audience here, I know. Oh, there is one more there.
00:36:27.000 - 00:36:45.224, Speaker E: Thank you. Do you know any other layer one that have client diversity model? I don't know any. And why do you think is the main reason why they don't have this kind of model? Just to double check.
00:36:45.262 - 00:36:47.112, Speaker F: It's the question whether do they know.
00:36:47.166 - 00:36:51.336, Speaker D: Any other layer one where client diversity matters, and if not, why that is.
00:36:51.358 - 00:37:04.380, Speaker E: The case, I was going to say. So the maric points out that the obvious one is gnosis chain, because they inherit a lot of clients from Ethereum.
00:37:05.040 - 00:37:05.790, Speaker C: But.
00:37:10.260 - 00:37:11.152, Speaker B: I don't know.
00:37:11.286 - 00:37:38.792, Speaker E: But the better answer is that I think, yeah, other people are seeing the benefit of this model. Filecoin, for example, has multiple implementations. There's a go client, there's a rust client. I think there's maybe a third one. Someone here in the front are always motioning and yeah, I think it's a lot more work, as we were saying. Right. Like there's a coordination problem, but I think that the end product is better.
00:37:38.792 - 00:38:06.790, Speaker E: So I think some companies maybe don't have the resources, they don't have the enormous developer community that Ethereum has to maintain. All of these clients. Like how many core developers does Ethereum have just working on clients? It's probably on the order of 150. That's a lot of people. If you're a single company, you're trying to employ that many people and get them to make multiple bits of software. It's a bit weird. I think it's only because we have this position as quite a large ecosystem that we're able to do this.
00:38:08.920 - 00:38:33.624, Speaker B: I know that Solana is also looking into building a second client, but in general, a client is always like, it's a cost center. You don't make money with a client most of the time. It's a black hole that you pour money into. And the benefit is that you have a client.
00:38:33.752 - 00:38:34.430, Speaker E: But.
00:38:39.200 - 00:39:29.150, Speaker B: Yeah, I think it's hard for other smaller chains to justify the cost of that, of having more than one client. Most of the way I see it, most, most of the other l ones don't even have one functioning client. They just take like gas and fork it and apply some changes on top. And it's like they're struggling to maintain even that. Because if you know that much about clients and about the core Ethereum clients, you can also just work for a Corey Ethereum team. And I think that is one of our advantages that we can capture so much like Mindshare and developer share.
00:39:31.600 - 00:39:31.964, Speaker E: And.
00:39:32.002 - 00:39:50.290, Speaker B: It'S also very fun to work on Ethereum clients. But Peter asked me beforehand to mention that gas is currently not hiring. But I heard there's a really nice internship program at Netherland that you should check.
00:39:52.040 - 00:39:52.864, Speaker E: Excellent.
00:39:52.992 - 00:40:25.770, Speaker A: Well, I for one have certainly learned a lot about execution layer client diversity and the reasons for it. I believe strongly we need to have a very proactive educational and advocacy campaign because the risks of a supermajority execution client causing damage to the Ethereum blockchain is going to affect all of us, whether or not we're testing validators, whether we're running minority clients, whether or not it does have potentially large impacts. So on behalf of everybody, please give a round of applause for our panelists here.
