00:00:00.250 - 00:00:34.242, Speaker A: I think that actually ALP and Gregoria work in, I guess, very different areas. Firstly, I mean, they're mostly working on the application side of decay for the moment. Right. And so it's not so much about the cryptographic techniques as the applications and what you can do with these new technologies, but actually they work in very, very different areas. Whereas ALP is focused mostly on the security and proving, like formally trying to formally verify certain properties in the ZK circuits. Grigade is working on some applications that he's going to tell you about a little bit about in a second. But, yeah, let me start off with some intros.
00:00:34.242 - 00:01:16.918, Speaker A: So, Gregarde is the CEO of runtime verification, a company that has historically worked on the kprover and a lot of other cool form verification techniques, but also auditing. And now they're going into a new foray, working on some ZK stuff, which is going to tell you about. And, oh yeah, you're also professor of formal methods at the University of Illinois at Obama champagne. Important. And ALP is a formal verification engineer at veridice and also, I believe, holds a PhD in. So anything else you guys want to add intro wise, or does that cover most of the things? Okay, so I'll just hand over the floor to you guys to talk a little bit about the individual projects that.
00:01:16.924 - 00:01:17.846, Speaker B: You'Re working on a little bit.
00:01:17.868 - 00:01:19.414, Speaker A: So, regarding, would you like to start?
00:01:19.532 - 00:01:21.240, Speaker C: Yeah, perfect.
00:01:21.690 - 00:01:23.000, Speaker B: All right, thank you.
00:01:26.090 - 00:01:26.840, Speaker C: So.
00:01:30.030 - 00:02:34.618, Speaker B: Traditionally, we runtime verification, do runtime verification and formal verification, and make sure that programs do what they are supposed to do mathematically, rigorously. But recently, we became interested in combining that with zero knowledge technology. Because in the end, if you think about formal verification and zero knowledge, or verifiable computing, let's say more generally as a concept, verifiable computing, they both attack the same problem from different angles. They both attempt to prove correctness of computational claims. Some of them are very concrete claims, like this program evaluates to 42. Others are a bit more complex. Claims, like this bytecode implements an ERC 20 token, but in the end, they are both mathematical statements or theorems, how we call them, and they admit mathematical proofs.
00:02:34.618 - 00:03:30.746, Speaker B: And now if we can verify those mathematical proofs, then in particular we can verify computations. So we became very interested recently into combining these two different approaches to correctness that were developed by almost disjoint communities. These were done by former verification, former methods people, mathematicians, and these were done by cryptographers, and they follow different paths. But now we believe it's time to bring it together and have one approach to correctness that goes through mathematical proofs. So in both of them, in the end, you can generate mathematical proofs, mathematical proof of correct execution of the program, mathematical proof of the requirements that the program satisfies, and then generate a verifiable computing argument. Zk proof or a certificate. Cryptographic evidence.
00:03:30.746 - 00:03:39.780, Speaker B: Cryptographic proof that the mathematical proof exists for the claim. So the claim is true, and that's what we are doing now.
00:03:42.710 - 00:04:36.502, Speaker C: So, I'm Arp, I'm a research scientist at Veridice. Veradice is a blockchain security auditing company. So I myself come from more mathematical background. I used to do research in number theory and algebraic geometry and applications to cryptography for a long time. But now at veridice, what we do is veridice comes also from kind of academic background. The founders are researchers mainly in formal methods, and the aim is kind of to use formal methods in auditing. What we do is how it evolved basically was there were many auditing projects, and of course, we do lots of manual audits, but there's a big need for tools, and we had some in house tools that we used to use a lot.
00:04:36.502 - 00:05:34.680, Speaker C: And since many people come from formal methods background, they were based on various levels of sophistication coming from formal methods, like some basic simple fuzzing methods, some static analysis, or more like SMT based methods, and so on, with the whole hierarchy. And then since we had developed those tools in house, and we were using them very nicely, we thought, let's make them available. So now veradice is also offering these auditing tools as a service. Some of them are open already, you can use and experiment them, and we do workshops about them, and from those workshops, people can use them directly, and we get feedback, which we again, feed into the tools themselves. And it's kind of like a loop going back and forth, but that's basically what we're doing.
00:05:36.810 - 00:05:43.302, Speaker A: Great, thank you so much for the intro, guys. And by the way, Jugana, you didn't mention the name of the project. Is it okay to do so?
00:05:43.356 - 00:05:43.682, Speaker B: Yes.
00:05:43.756 - 00:06:03.694, Speaker A: So the project is called PI squared. I think it's important to. So thanks for the interest of your project, guys. And yeah, I know, incidentally, for both of you, the pain when you're working in formal methods, but also zk stuff, the word proof is highly overloaded. So we use the term cryptographic and mathematical proof to try.
00:06:03.812 - 00:06:06.570, Speaker B: PI squared comes from proof of proof.
00:06:06.730 - 00:06:08.320, Speaker A: Oh, I like that.
00:06:08.850 - 00:06:10.310, Speaker B: Cryptographic proof of math.
00:06:10.410 - 00:06:12.514, Speaker A: You want to say that so it can be heard sorry.
00:06:12.712 - 00:06:13.842, Speaker C: So the name of the project.
00:06:13.896 - 00:06:23.990, Speaker B: Yes, it's PI squared, and PI squared comes from proof of proof, because you have a cryptographic proof of a mathematical proof, the ultimate evidence of correctness.
00:06:26.170 - 00:07:08.114, Speaker A: That's a great tagline. The ultimate evidence of trade. I love. Next, the next question I wanted to ask you guys, and I think it was meant to be more so for Grigore and Misha, but Misha isn't here, so you're really going to have to carry this one, Grigore, because I imagine Alp, that you heard, I was going to ask, basically, when did you first hear about ZKPs, and did you immediately see the potential of the technology? And I imagine, Alp, you've heard about CKPs quite some time ago, given your area of work. Okay. You can feel free to answer the question, of course, but, yeah, I'll hand that over to both directions.
00:07:08.162 - 00:07:08.326, Speaker B: Yeah.
00:07:08.348 - 00:07:47.246, Speaker C: So, I mean, for me, it was kind of interesting. I mean, I was doing initially research on the arithmetic of. So at some point, Ronald Kramer from the CWI approached me. He said, okay, I'm working on secret sharing schemes, multiparty computation, which are kind of a basic primitive for most of CK. And he had some very hands on question on algebraic curves. And that's kind of the first time, basically because of elliptic curve cryptography. I was kind of aware of many applications of algebraic geometry in cryptography, but this was a very novel thing.
00:07:47.246 - 00:08:52.120, Speaker C: And that was the first time when I first. That was while I was a postdoc, still the first time I was kind of when I saw the concept of zero knowledge, proof and so on. And that's kind of, for me, it was kind of quite interesting to see, because with most cryptographic constructions that you have around there, they are based on some contradiction. In some sense. There's something that intuitively you think should not be possible, but it is possible, and that's kind of the surprising side of it. Zero knowledge should not be possible if you ask someone on the street, and if you look, it's used everywhere, so it is possible in the end. And that contradiction I found very intriguing, and I think that's also something that shows that it has a lot of kind of future, because if something is not so intuitive, you really need some time for people to come up with ideas of using those things after some point, because it's not immediately apparent how you could use something that is not intuitive at all.
00:08:52.120 - 00:08:56.230, Speaker C: So that was my first encounter with DK.
00:08:58.990 - 00:09:36.430, Speaker B: All right. Yeah, I guess I heard lots of people talking about it, and I was intrigued what it is zero knowledge. In fact, there is a lot of knowledge. And yes, it looked impossible. Once I understood the problem that was solving, I said, that's impossible. And I started reading, and I remember I read Tar's book, and I was so fascinated by the whole concept. And then how you can combine different witnesses into one witness, and all that became like an obsession.
00:09:36.430 - 00:10:23.630, Speaker B: It's very addictive once you get into it. And I don't know when it happened, but at some point I said, wait a minute, actually, we can do exactly the same with mathematical proofs. We can generate sort of, the mathematical proof of the theorem is the witness why the theorem is correct. And now I can generate a succinct argument that I have such a mathematical proof. And then I became obsessed with it. I said, okay, we really have to understand this very well, go deep into the rabbit hole and understand everything. And then we discovered the different implementations around, particularly of ZKVMs, like the ZkeVM.
00:10:23.710 - 00:10:25.266, Speaker C: And we tried to understand what is.
00:10:25.288 - 00:11:39.222, Speaker B: The trust base of that, because this is such a complicated monster, and we doing formal verification, we are of course obsessed with correctness. Why should I trust 1 million lines of code? Basically, that's so complicated. And I don't know if anybody verified CKE EVM, but I would not do it, no matter how much they would pay us. I would not take verification. Maybe verified, I don't know, but definitely. And then maybe now I should answer a bit on Misha's behalf. Now I'misha, I'm very, you know, the next thought that comes to mind is, why not to generate correct by construction? Ideally, all these VMs give me your program, in particular, an implementation of EVM of a VM, be it EVM or ISC five or whatever, and I'm going to generate for you from the implementation a zk variant of your VM.
00:11:39.222 - 00:12:09.126, Speaker B: It's a wonderful thought, but now you have another problem. Why is the compiler correct? Maybe you can do translation validation. You can take for each instance, you can generate a proof, but then you still have to first say what the proof is for, which means that you need the semantics of the programming language, the semantics of the target language. It's a very complicated problem, even then. And then I put my back, my.
00:12:09.228 - 00:12:09.880, Speaker A: Head.
00:12:16.250 - 00:13:21.034, Speaker B: And then he said, wait a minute, maybe if we go through mathematics, maybe we don't need a VM at all for a programming language, because when you have a formal semantics of a language or of a VM, you actually have a mathematical theory. And now, whenever I make any claim about that programming language, in particular, the program evaluation 42, or the bytecode is ERC 20 compliant code that has a mathematical proof. So now if I can verify mathematical proofs, I get exactly the same guarantee that I would get if I had a ZKVM. Right. And then the next challenge is, well, how difficult would it be to verify mathematical proofs? And it turns out that that's a much, much simpler problem, and that's what brought us into this. So there is a proof checker, for example, for mathematical proofs, that has, like, 200 lines of code. That's it.
00:13:21.034 - 00:13:58.150, Speaker B: That's the only trust page, 200 lines of code. And now if we can implement that as a ZK circuit and prove it correct, actually, I think that is feasible to take 200 lines of code and have a circuit for them and prove it correct completely, I would take that project, actually. Yes, I heard of ZKPs for a long time. That answer your question now. But I became interested in it about one year ago, and I became obsessed with it about six months ago. And now we want to do this PI square project.
00:13:58.300 - 00:14:35.042, Speaker A: Awesome. Thanks so much for your answers. Just in response to some of the things that you said. The first thing is, Alp, I really empathize with you saying that, hey, you were aware of these cryptographic primitives and that, I remember I wanted to do my master's thesis on modular forms with a number theorist at my university when I was studying maths, and I told him, oh, yeah, I've heard there are some cryptographic applications to this. And he said, yeah, I write those on grants sometimes. Anyways, so thanks for your answers on this. That's been very interesting.
00:14:35.042 - 00:14:48.466, Speaker A: And, yeah, specifically, these 200 lines of code are the verifier for what's a very simple proof? Proof assistant called that I can't remember. Metamask. Yeah, metamath.
00:14:48.498 - 00:14:48.646, Speaker B: Yeah.
00:14:48.668 - 00:15:21.042, Speaker A: So this is a metamask proof checker, right? Yeah. But I think in the end, you're going for a slightly different direction. Right. But still, yeah, it's quite feasible to do this in a very succinct way and then actually verify the underlying circuits against the spec of the proof language. Yeah, that's quite amazing. Okay, so I think my next question is going to be, and once again, you're going to have radically different answers, I expect will be essentially what have been significant technological, what do you call it? What's the word that I'm looking for? Like, difficulties that you've had. Right.
00:15:21.042 - 00:15:40.860, Speaker A: So I assume you will say something to do with SMT solvers. I might be wrong, but I feel like I'm likely to be right here. And Gregora, your answer will be more to do with cryptographic primitives perhaps, or maybe the compilation process or something like that. But let me, let you answer my question, so I'll hand it to Gregora first. Thank you.
00:15:43.390 - 00:16:10.962, Speaker B: So our first challenge was to understand ZK, the mathematics and everything. And Eartha, we are mathematically trained, all of us, mostly PhDs and former mathematical background. We started questioning everything. And that's the problem with people like us. Whenever we did something takes us like ten times longer than it should, because we've seen it before somewhere. It didn't work, and why should it work here? And so on. That was one step.
00:16:10.962 - 00:16:49.898, Speaker B: Another was to actually decide how to implement these 200 lines of code as a circuit. Right? So we tried all the existing solutions, right? Cairo risk, zero, ZkLDM, and now we're also playing with blurk. And actually, if Misha were here, he knows we communicate almost every other day where we get stuck with something. So it was quite tough to make these systems work. There is a lot of enthusiasm around about these systems, but when you try them out, they are not that easy. Right. So we had only 200 lines of code to implement, and we are all experts in programming languages and software engineering.
00:16:49.898 - 00:16:53.162, Speaker B: And compiler should have been easy. Julian knows, he tries to implement.
00:16:53.226 - 00:16:55.770, Speaker A: I tried to write a mathematical.
00:16:55.930 - 00:17:02.482, Speaker B: You spent two or three days with a super strong form of verification person. Right. They tried to implement and they gave up.
00:17:02.536 - 00:17:10.114, Speaker A: Right. We got some nice parts of the core proof checker working, but in the end, yeah, we completely fell prey to some issues with.
00:17:10.312 - 00:17:12.874, Speaker B: We keep discovering bugs in these tools.
00:17:12.942 - 00:17:14.326, Speaker A: In the compiler and then they tell.
00:17:14.348 - 00:17:36.510, Speaker B: Us, oh yeah, we want to fix that, then we will fix it, we will have it in two days. Then one week later, hey, how is going on? Two more days and so on. I mean, it's the way things are. It's a very difficult process to do. Yes. So that was a challenge for us and it's still a challenge. We are working in parallel with four different implementations, and when they work, they are extremely slow.
00:17:36.510 - 00:17:54.210, Speaker B: Of course, everybody has this problem. Yeah, the performance. So now we are thinking of implementing a custom circuit, going down to the basics specifically for mathematics and see how it goes. And then we have very nice audited for us, happily.
00:17:56.870 - 00:17:57.940, Speaker A: There you go.
00:17:58.550 - 00:18:03.030, Speaker C: Yeah, I mean, you mentioned already the keywords are difficulties with SMT.
00:18:03.450 - 00:18:10.520, Speaker A: We've had some fun with that too. Getting them to model finite fields is not super fun. No, it's okay.
00:18:12.250 - 00:18:53.714, Speaker C: It's just a very nice promise that SMT gives. Okay, I'll prove it to you. I'll do this, of course. But then there's a bottleneck, because at the end, it boils down to polynomial equations solving them. And so mean, basically, in some of our tools, just to give some background. What we do is, for instance, if you want to look for a particular bug, like want to check if your circuits are under constraints or something like that, you can express that as a logical formula, and then all you have to see is whether that formula is satisfiable. It's not just the usual boolean satisfiability, where you look for some interpretation where you just assign fruit values to the variables.
00:18:53.714 - 00:19:42.566, Speaker C: There's some other theory involved. So that's why it's called SMT. So, satisfiability, modular theory, in this case, it will be the theory of finite fields and, like, polynomial equations over finite fields and so on. But then you can ask similar problems given some statement in this theory. Can I kind of decide whether it is true or false? If it's satisfiable, can I find the model if it is not satisfyable, can I kind of convey that in a simple way? And what happens at the end? I mean, if you use most of the SMT solvers, especially if you do satisfy deltimot theory, where the theory is finite fields, you boil down everything to solving polynomial equations over finite fields. And that is an inherently difficult problem. That's something.
00:19:42.566 - 00:20:05.498, Speaker C: For decades, people in computer algebra and competitive algebra have been working on. They're very nice algorithms. They work very nice. Theoretically, they're extremely powerful. But then when it comes to practice, when you implement it, small examples, they work. So you get the feeling, oh, it's wonderful. If your examples grow a bit, they have doubly exponential worst time performance.
00:20:05.498 - 00:20:33.320, Speaker C: They get stuck. And that was our biggest problem. One of our biggest problems, at least, that I have been working on, was how to make those faster. That's kind of basically a question in algebraic geometry. Basically, you have these polynomial equations. Can you solve them, or can you show that they have no solutions? And that's kind of what has caused us some sleepless nights. But I think we did quite some improvement there.
00:20:36.090 - 00:20:56.266, Speaker B: I guess the arithmetization part, that should be easier to prove, right? That a certain arithmetization is correct, right. Because this is pure SMT, in some sense, the polynomial part is difficult, but you need to solve the polynomials, or you just need to check that something is a solution for a polynomial.
00:20:56.378 - 00:21:05.426, Speaker C: You need to solve them. Yeah, I mean, if you have a solution that will, for instance, show you that it's under constraints.
00:21:05.458 - 00:21:05.750, Speaker B: Yes.
00:21:05.820 - 00:21:15.980, Speaker C: And then the solution will tell you, okay, like this input gives two different outputs, or for this circuit, there are two different proofs, or those kind of things.
00:21:17.550 - 00:21:28.298, Speaker A: In particular, you want to find two satisfying assignments of a circuit, where in particular. And you want to assert them that they're not equal, essentially. Right? And you want to then show that that's not satisfiable.
00:21:28.394 - 00:21:53.270, Speaker C: Sorry, exactly. And in fact, that's a very nice trick. If you want to show that two things are not equal, that's yet another. You can express that as yet another equality, that as another equality. And then you take two copies of the same circuit, and then you say these two should be different, which you then translate into equality, which will be yet another equality. So it's basically solving polynomial equations.
00:21:55.470 - 00:22:19.054, Speaker A: Thank you. Obviously, nethermind developed. I'll talk a little bit from my experience, if that's okay. We developed a tool for reasoning about Cairo. Right? Which obviously required Cairo zero, specifically, which obviously required reasoning about finite fields. And our trick was that we just restricted the set of theories we use in an SMT solver as heavily as possible. So we only use nonlinear integer arithmetic.
00:22:19.054 - 00:22:42.810, Speaker A: And under very restricted conditions, we had higher order nonlinear integer arithmetic. But I believe that you guys have actually developed, what do you call it, a new SMT theory, in fact, specifically for finite fields. Right. Can you tell us a little bit about. And do you actually use this in the tool currently? And can you tell us a little bit about. I think it uses, like, Montgomery representations. Right.
00:22:42.810 - 00:22:45.930, Speaker A: Can you tell us a little bit about how they improve the solving.
00:22:49.550 - 00:23:36.698, Speaker C: Mean? So what we did was the first step that was helpful was to not rely only on SMT. I mean, there's like, the static analysis tools that you can use that kind of just looks at the syntax and looks for particular vulnerabilities, for instance. And that's very fast, but it's not so reliable because it can give you many false positives, for instance, and you look for very particular things there. And then there's the SMT, which is kind of much stronger. You get guarantees and you get proofs out of it, but it's very slow. We first developed one tool that we call Picus. It's also available open.
00:23:36.698 - 00:24:17.658, Speaker C: You can download it and experiment with it, which kind of combines the two. So it's kind of an interactive loop between the static analysis phase and this SMT phase, where whenever one of them gets into trouble. It passes it on to the other and says, oh, can you say something? And sometimes they both get into trouble. And that's usually the case when the SMT phase just is kind of confronted with a very difficult polynomial system. At the end, the bottleneck was how to solve difficult polynomial equations. And difficult means like those circuits can be huge. They can have many variables and many equations and so on.
00:24:17.658 - 00:25:02.306, Speaker C: We are talking in the thousands sometimes. And that's beyond anything that normal computer algebra systems would really care about, because those computer algebra systems that are around, they were done mainly by people working on competitive algebra and algebraic geometry. And they never write down equations with thousands of equation polynomial equations. Usually there are, of course, but that's not their initial goal. So then we had to kind of see how to solve those, because relying on the tools that were available did not help. But then, what's not interesting is that the circuits that one deals with in decay applications, they have a very particular form. They're very sparse.
00:25:02.306 - 00:25:46.630, Speaker C: So if you take one equation, it will only involve very few of the variables, right? And they will have, for instance, if you have r one, cs constraints and so on, you will have bounds on the degree. Still, it's just quadratic equation. So it's not just random. If you take an arbitrary, like, random polynomial equation, whatever that means, that's not going to be how a polynomial equation coming from a circuit will look like. So they'll be very sparse, they'll have a lot of structure. And what we wanted to do then, is to exploit the structure. So, to that polynomial equation, we attached some graphs that kind of showed us how the polynomials, how the variables appearing in those polynomials are related to each other.
00:25:46.630 - 00:26:01.910, Speaker C: And from that, we could push things way further. I mean, just to give a very simple example, in many ZK applications, we have some range checks, which says, for instance, that the variable x is between zero and two to the 14, for instance.
00:26:01.990 - 00:26:02.330, Speaker A: Right?
00:26:02.400 - 00:26:37.270, Speaker C: And if you express this as a polynomial, you would have to write down a polynomial whose roots are all the numbers between zero and two to the 14, which would have then degree two to the 14. And that's a huge number. So range checks appear a lot, but they are not things that you should express in polynomials. But SMT solvers do express them in polynomials. That's, for instance, just one example that's kind of using just the methods as they are. Given. SMT solvers the big promise, if you use it without thinking, it will be a big disaster.
00:26:39.530 - 00:26:41.942, Speaker A: Thank you so much. Do we have two minutes left?
00:26:41.996 - 00:26:42.934, Speaker B: We do. Okay.
00:26:42.972 - 00:27:05.600, Speaker A: Two minutes. So I wanted to ask one last question, but, yeah, if you could keep it relatively short, just given the time constraints, which was essentially, do you see problem, upcoming problems that you're going to solve? So what are the next problems you guys are going to face, and how do you think you're going to solve them? I know it's 1 minute each is a bit tough for that question, but, hey, let's give it a try.
00:27:06.850 - 00:27:24.562, Speaker B: I think the problem will be to parallelize the ZKP generation. If we don't find embarrassingly parallel algorithms to generate ZKPs, at least in our case, we'll never be as efficient as we need to. That will be the challenge.
00:27:24.626 - 00:27:26.118, Speaker A: Okay, thank you.
00:27:26.284 - 00:27:52.460, Speaker C: I mean, for me, I'll just use the easy way out. I'll say it will depend on which problems we'll see. I mean, because, like our tools, we use them on audits, and then we see where the bottlenecks are, and that gives us a nice feedback of which parts we have to improve where we have the problem. So it depends on which projects want audits at the end, and then what's the problem? What our tools have issues with them. That's what we.
00:27:54.480 - 00:27:57.564, Speaker A: Great. Thank you very much. We did keep it to two minutes, I believe.
00:27:57.762 - 00:27:58.220, Speaker B: Perfect.
00:27:58.290 - 00:27:59.310, Speaker C: Thank you so much.
00:27:59.920 - 00:28:07.650, Speaker A: Thank you so much to both panelists. Thank you, Gilgalis, and thank you, Alf. And, yeah, looking forward to hear how both of your projects keep going. Thank you so much.
