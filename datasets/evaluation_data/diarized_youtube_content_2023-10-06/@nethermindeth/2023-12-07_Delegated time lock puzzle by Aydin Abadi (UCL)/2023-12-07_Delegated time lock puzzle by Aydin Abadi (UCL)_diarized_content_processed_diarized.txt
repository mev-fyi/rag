00:00:01.450 - 00:00:44.390, Speaker A: Here's your pointer. If you get let me the idea of. So it's more about cryptography. The primitive has got some application in blockchain as well. So the idea of sending information to the future was proposed by Timothy May in 1993. So the idea was to somehow encrypt. The initial idea was to somehow involve a third party to encrypt a message such that the message can be decrypted after a certain period of time.
00:00:44.390 - 00:01:42.340, Speaker A: The idea was cool but it involved some trusted third party. Later on, a few years later rivers and Shamir proposed time lock puzzle or timelock encryption where you don't need any trust a third party. So it relies on the idea of sequential squaring. So you encrypt the value and then send it to decryptor. Then after a certain period of time the decryptor can decrypt. So this talk about is in this context and we will show that this idea was cool but still requires some work. And we identified a set of gaps.
00:01:42.340 - 00:02:53.256, Speaker A: So it is a joint work with Dan Rich, the PhD student and Stephen Merdoch. From going to I've already given you a background on timelock puzzle. I'm going to give a short background on timelock puzzle and then three questions that I think is worth thinking about and then I'll propose our ideas if I have time. I can also talk about the attack we found in one of the papers in this area that was published in CCS recently. So timelog puzzle allows a client to create a puzzle. In the setup phase it generates some parameters. In the puzzle generation phase it creates puzzle and then sends the puzzle that encodes message m to solver.
00:02:53.256 - 00:03:58.780, Speaker A: Then solver continuously works on it. If the time parameter is for one year then it works for one year until it finds the secret key and decrypt the message to get the plain text message m. This is the algorithm, the setup is setup algorithm of reverse. As you can see that there is a parameter t which is the product of two parameters s and delta. Delta is the time within which a message should remain secret. One year, two years and s, which is the most important part is the maximum number of squaring modulo m. That is required that the strongest server in the world can do the squaring.
00:03:58.780 - 00:04:41.584, Speaker A: Okay, this parameter is important. I'm going to get back to it a bit later. And then based on the parameter t we calculate a blinding factor a which is two to the power of T modular phi of n. Thank you. So it's not complicated but the main focus is on s. So out of the ratio in this slide, I said it is for the strongest server. But in the literature up to this date, before our paper, nobody said that.
00:04:41.584 - 00:05:34.336, Speaker A: They said it is for a server. Our observation is that s the parameter s is the lower band. It's for a strongest server. By lower band, I mean the earliest time that the strongest server in the world can find the solution of the puzzle. If that's the case, which we think is the case, then we don't have upper bands. So what is the latest time that a regular server with average computation power can find a solution? If we are wrong, then that refers to the upper bound, the parameter. Then we don't have lower band again.
00:05:34.336 - 00:06:44.200, Speaker A: But in cryptography, usually we focus on the strongest server. We don't usually focus on a specific server. Thus we think that S is for lower band, the strongest server. So the first question is, what about the upper bands? How do we define the latest time that regular server can find the solution? So I'm going to give you background and then raise the second question. So, as I mentioned earlier, in general, in time lock puzzle, we have got three phases, setup and puzzle generation and solving. Puzle solving puzzle obviously requires, by definition, requires time and resources. The server needs to allocate certain time and certain computational resources.
00:06:44.200 - 00:07:55.670, Speaker A: That means not every server can do that. If they allocate time and resources, they cannot complete other tasks delegated to them. Also, the client who generates the puzzle needs to bear some computational cost as well. So again, I'm referring here to the original time lock puzzle of reverse. As you can see in the set of phase we are on step five, we have a, which is two to the power of t modify n. Of course, v n is smaller than n, but Steve needs to do some modular computation, exponentiation, which is costly. Also, in generating puzzle, the client needs to do some exponentiation again, r to the power of a mod n, which is costly.
00:07:55.670 - 00:09:37.800, Speaker A: So the question is, what if these two parties, server and client, don't have enough computational power? Then does it mean that they can't engage in this kind of protocol, can't use it? So the third question again, backer. We have a setting called multiple puzzle or multiple or multi instance. We proposed it in 2021. So it considers the case where a server is given many puzzles by one client at once, and it needs to solve all of them and needs to find each solution at different point in time. So if we use knife solution, the original scheme of reverse, then the client generates all the puzle p one to pz and sends it to the solver. As you can see here, the solver needs to deal with each individual puzzle in parallel. So if the number of puddles are higher than the number of CPUs or cores it has got, then it needs to park some of the puzzles, solve some puzzles, and then get back to the rest of it, which delays the process of finding solutions on time.
00:09:37.800 - 00:10:52.686, Speaker A: There are some mechanism to deal with this situation, including our previous solution. So the idea is to change the puzzles. So instead of letting the server to deal with all of them sequentially, in parallel, we can create the puzzle in a way that it can deal with the puzzle sequentially. So we embed some information needed to find the next puzzle into the previous puzzle. So it needs to find the first puzzle in order to find enough information to find the second puzzle, and so on, so forth. This is very helpful and they can save some cost. However, in this scheme, including our own solution, previous solution, the time intervals between two puzzles in a row has to be equal, has to be identical, so all of the time intervals are delta and for verification, to ensure that the puzzles are correct.
00:10:52.686 - 00:12:42.050, Speaker A: Some of the solutions impose very high computational costs, and some of them include events and large groups, so it's not cheaper as well. So, third question is, how can we design a mechanism that deals with multiple puzzles, but it imposes low verification cost, and also it doesn't require the server to deal with all of the puzzles in parallel. So, three questions again, to recap, what about the upper bounds? What if the client and server don't have enough computational power? And also how to design a system that deals with multiple puzzle efficient? To answer this question, this set of questions, we propose the idea of delegated sandwich. It allows end to end delegation both the server and the client can delegate and their task, which is computationally expensive to some helpers. Please recall that the main idea of timelap puzzle, the main goal is to let the server to find the solution after some period of time. The rest is kind of marginal. So we want to achieve this goal, but without requiring too much from the server and the client.
00:12:42.050 - 00:14:22.702, Speaker A: And the verification in our system is efficient. So we developed a protocol that realizes this notion of delegated time deposit. As I mentioned, it supports end to end delegation, and doesn't require the time intervals between two different intervals to be identical. They can be different size and for verification, it only involves implication of hash function, which is very cheap compared to zero proofs or other mechanisms. So, to design this protocol, we used the original term lock puzzle. And also hash based commitments, symmetric encryption, smart contracts and a few other things that we developed such as a function called customized extra delay generating and also a fair payment algorithm and a modified multi instance tablet puzle chain. So to give you some brief background on the function, we defined this customized extra delay generating or CETG.
00:14:22.702 - 00:15:41.962, Speaker A: So the definition is quite generic, it's not specific to our time laposity can be used in other mechanisms including the verifiable delay function. Verifiable delay function is an interesting research line. The function itself allows someone to generate some random values after a certain period of time. Mostly they rely on the sequential scaling and time like puzzle as a core. So another mechanism can use this generic definition as well. So the function itself takes as inputs type of computation. In this context it can be sequential squaring s parameter s, which is the maximum number of exponentiation that the strongest server can perform per second, the time periods for each puzzle to remain private, and some auxiliary information about specific server.
00:15:41.962 - 00:16:55.320, Speaker A: The output of this function is the extra delay that the server requires to find the solution, extra delay compared to the strongest server. And also we equipped the protocol with fair payment system. So in order to design fair payment, we define upper bound using this function. And also we design an algorithm to ensure that the server or the helpers get paid only if they provide valid solution. Because again, so in the literature, in the context of time like puzzle, there's no guarantee. If we want to delegate the computation of solution to third party, there's no guarantee that someone can get the results. Even if they find the plaintiff's text message, there's no guarantee that they provide it.
00:16:55.320 - 00:17:55.242, Speaker A: So we needed to ensure that and incentivize them to provide the result. The approach was standard. So as long as you have efficient verification mechanics in place, and that can be done by smart contract, then you can deposit certain amount of coins. And then if the solver or helper provides the valid solution and the smart contract approves it, then it can get paid. Of course the smart contract needs to make sure that they provide a solution on time with regard to upper bound and of course the lower band. So there are three types of parties involved in this protocol. Client is a standard client who wants to create a puzzle and wants to release the message after a certain period of time.
00:17:55.242 - 00:20:00.470, Speaker A: We have a server who is interested in getting the result on time and we have got two helpers. One helps the client, the other one helps the server. So very briefly, the protocol works as false. First, the clients generate some parameters based on the plaintext message, a vector of plaintext message m one to m z and some time parameters delta generous key and then encrypts each individual messages and sends the key for symmetric encryption and sometimes parameter to the server and then sends the cipher text to helper number one. The solver based on these parameters generates the extra delay and creates a smart contract, deposits some coins in the smart contract, then helper creates puzzles based on the cycle text that it receives from the client and then sends all the public parameters and puzzles to the helper number two who solves the puzzles individually and sends the proof of correctness and the solution to the puzzle which are still ciphertext, to a smart contract which verifies the correctness of the solution and verifies the proof. And then solver can learn from the smart contract the plain text itself by decrypting, parsing and decrypting the solution. Then of course the smart contract pays the helper number two if it provides valid solution.
00:20:00.470 - 00:21:48.824, Speaker A: So we have done both asymptotic and also concrete cost evaluation of the protocol in terms of asymptotic cost. As you can see here, the setup the first row is our efficient delegated convert puzzle, so the client doesn't need to do anything, and this task is delegated to the helper number one. In terms of delegation, it requires to perform only symmetric encryption, whereas the other schemes don't need to that this extra computation that RSK imposes. However it is cheap and if I summarize, the overall computation complexity remains more or less the same as our generic chain conduct puzzle, but it deals with multiple puzzles efficiently and it is linear with a number of puzzles. So if I compare them three schemes, one is reverse the original Tamlock puzzle and our previous word also is crime one. The top one doesn't support multiple puzzles and it supports it nicely, so it's very inefficient. The second scheme do support multiple puzzles, but the timing turbos need to be identical.
00:21:48.824 - 00:23:25.930, Speaker A: But the third one supports efficient multiple puzles and the timing intervals can be different. So in terms of features, our efficient delegated timeline puzzle supports multiple puzzles, failed size, time intervals, efficient verification, delegation and exact time delivery. Of course it also has fairness payment feature that other schemes do not have. We have implemented these protocols and also previous work like the original term lock puzzle by previous and Shami, and you can access the code on GitHub using the QR code. Also we have done the analysis and the implementation in those two boxes. You can see the summary for instance for the client side comparison. So RSK can save client by up to 1000 times compared to the original request scheme, and for the server side computation, it can save cost by 5000 times.
00:23:25.930 - 00:24:54.340, Speaker A: Again, it doesn't mean that our overall computation cost is less. Our goal was to allow parties to delegate the computation to different parties to lower the cost, and they managed to do that right. So as I mentioned in CCS 2021 in CCS 2021, a paper appeared to allow parties to delegate the computation of sequential squaring to some parties. However, we realized that this scheme has a problem. We identified an attack and showed that if these servers collaborate with each other and design an enforceable collusion smart contract, then they can get paid without doing the job. So we released a paper regarding this attack as well on a separate paper. And the reason they can do that is nowadays we have got smart contracts and it's not just for good guys, it can be used for bad guys.
00:24:54.340 - 00:25:46.240, Speaker A: They can enforce misbehavior so they can deposit certain amount and they agree to provide some incorrect computation result to a different smart contract. If they do that. If they misbehave honestly, then they can get rewarded. Otherwise they lose their deposit. If they don't misbehave honestly. We contacted the authors and then we let them know about the problem and asking. So I'm happy to answer questions and this is the link for the paperwork.
