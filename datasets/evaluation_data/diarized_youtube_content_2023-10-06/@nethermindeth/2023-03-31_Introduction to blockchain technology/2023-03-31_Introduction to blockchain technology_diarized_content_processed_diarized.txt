00:00:00.410 - 00:00:03.566, Speaker A: You okay?
00:00:03.668 - 00:00:54.250, Speaker B: So hello everyone. Thank you for joining us. Welcome to Nethermind Nigeria Online event Series 2023. My name is Edrio and I'm an operations mapping coordinator from the project management office here at Nethermind. I love engaging people and of conversations that lead to proper planning and management of project and staffing related activities. I'm going to give a brief introduction of Nethermind to talk about summary of what we do here at Nethermind. Now Nevermind is a blockchain research and software engineering company that specializes in developing solutions for decentralized systems.
00:00:54.250 - 00:02:23.020, Speaker B: Our teams here in Nethermind conduct research and build high quality tools for the blockchain ecosystem. Now, each team focuses on specific areas of the blockchain problem space and consists of specialists and experienced developers who work alongside interns in the Nethermind system. We actively contribute to Ethereum core development network upgrades in collaboration with the Ethereum foundation and frequently partner with renowned companies such as Stackware, Gnosis, Chain Ave, Flashbots, Openzeppelin, Quarter protocol, energy web and many more. Essentially, our mission here is to gather passionate talent from around the world and tackle some of the blockchain's most complex problems. Now I'm going to talk about the topics that we are going to be talking on today. We have different speakers who will be talking about different topics ranging from introduction to distributed systems and blockchain technology, data analysis, smart contract auditing and tools, building decentralized DAP on Stacknet, and internship at Nevermind. I hope you do enjoy this few hours.
00:02:23.020 - 00:02:52.040, Speaker B: We are going to be having this talk with you and we hope you learn a lot from this talk. We are going to start with our first speaker. I'm going to hand it over to Jellat Anofu, who is going to be discussing introduction to distributed systems and blockchain technology. Jellilat, over to you. Right.
00:02:52.110 - 00:02:58.350, Speaker A: Thanks a lot, Adrian. Hi everyone. I'm going to be sharing my screen very quickly.
00:03:00.960 - 00:03:01.710, Speaker B: Yeah.
00:03:06.300 - 00:03:54.472, Speaker A: So, yeah, hi everyone. My name is Jelly Lat and I'm a software engineer at Netamide and today I'll be giving an introduction into distributed systems and blockchain technology. So yeah, today I'll be going through what distributed systems are and how they work and also going to talking about advantages of distributed systems. Why do we distribute a system, what blockchain is and how it works, and also a brief intro into how to run a blockchain node. So first things first. What is a distributed system? So a distributed system is a network of computers that work together as a single system. To solve a computing problem.
00:03:54.472 - 00:04:22.652, Speaker A: So this could range from a very simple computing problem, like two plus two, to something very complex or any kind of problem, basically. So in a different system, each computer and network is called a node. So like we have in this picture, let's say we have a network of computers. These are all computers, right? And each of these computers are nodes. So this is a node. This is a node. A node and called a node.
00:04:22.652 - 00:05:05.916, Speaker A: And this nodes communicate with each other by passing messages over a network. You can see that all these nodes, they are connected to each other. So if we kind of think about a scenario whereby we have six questions that we need to solve, probably six mathematical problems we need to solve, we could share these questions among all of these computers. Since there are six computers, each take a problem, they solve the problem, and they share it among themselves, right? So at the end of the day, they all have the answers to this question. So when you talk about distributed system, since they all communicate with each other, that means they can actually share answers amongst themselves. Just an example of how distributed system works. So this is how, like an illustration that shows what distributed system is.
00:05:05.916 - 00:05:59.116, Speaker A: So for a normal system, you have a user, let's say you have a database, and probably you upload a picture to a database and you want to get a picture back, request for the picture back. Just as a normal system and for a distributed system, something different happens, right? So you have like a couple of systems, like say these three systems, they are distributed, and each of this system, they communicate with each other. So what that means is that if I upload a picture to the database one, I could actually request for that picture from database three, because all of the systems communicate, they literally gossip with each other. If I send the data to this, it's going to gossip the data to these two guys. And if it's, this is going to gossip the data to these two guys. So in the system, I can upload the data to one of the system. At the end of the day, I can get it from any of the other systems.
00:05:59.116 - 00:06:58.048, Speaker A: So now why distribute a system? Right? So you might want to ask, why do I need a distress system? And I just have a normal system? So one of the things is scalability, right? So distress systems can scale horizontally by adding more nodes to the network, which allows them to process large amounts of data and support many users without overloading a single node. So you might want to ask what's scaling horizontally. So we have scaling horizontally and vertically. So for vertical scaling, what it means is that you're actually improving the power of the system. Let's say, for instance, you have a computer that is like maybe 16 gig RAM and you need like a 32 gigram computer to run an application, for instance. So what scaling vertically means is that I will replace that 16 gigram computer, two gigram computer, just because I need a better system that's scaling vertically. But scaling horizontally means I don't really have to replace my computer.
00:06:58.048 - 00:07:36.976, Speaker A: I could just probably add another connect on the computer to it. I can actually probably connect another computer to that system to be able to make up my Tetsu gigram. Probably adding an external hard drive. At the end of the day, I'm able to just put everything together and get my Tetsu Gigram. That's what k horizontally means. So it allows you to process large amounts of data, right? So let's say, for instance, you have Instagram. For instance, when you upload a picture to Instagram and that person is uploading a video, somebody is trying to go through their feed, there are like multiple requests happening at the same time.
00:07:36.976 - 00:08:34.572, Speaker A: So what scalability or scaling horizontally means? If Instagram has probably 100 databases, that means if one person is uploading a picture via one of the database, another person can be fetching a picture, another person can be uploading a video on that database. So you don't have to stress only one single node and you are able to share the workload, right? Basically. So under thin with distress system is fault tolerance. So in the distress system, if one node fails, the other nodes can continue to process. So if you have multiple nodes, for instance, if one fails, your system doesn't have to go down, right? So you can easily switch, the other systems are running anyways. So even if one goes down, two goes down, you have multiple systems to fall back on. And another thing is decentralization, right? These rest systems can be decentralized mean that there is no single point of control of failure.
00:08:34.572 - 00:09:20.544, Speaker A: So decentralization makes it a good choice for applications that require transparency, security and trust, such as blockchain based systems. So this rest system, whereby I can have multiple systems, that means we can literally share the system amongst ourselves, right? So maybe there are ten people, I could take one of the system. You take one and everybody shares the system amongst themselves. At the end of the day, you're able to have a decentralized system. It's transparent. So for like, if you have a bank app now and they tell you you have like 20K in your account, what they said is literally it. But if it's a decentralized system, I can say, oh, many people have a copy of that database, right? If you want to cheat me, there are like, multiple copies of it.
00:09:20.544 - 00:10:12.476, Speaker A: And it is not very easy to actually give false data. So blockchain as a distributed system, like, speaking of decentralization, we talk about blockchain, right? So blockchain technology is a type of distributed system that was originally designed for secure financial transactions. Here we talk about bitcoin, right? And it is a decentralized ledger that records transactions and stores them in blocks that are linked together cryptographically. So initially, we had bitcoin just for financial transactions. We now have Ethereum and other blockchain systems that allows you to perform smart contracts or other transactions besides financial transactions. So it is a decentralized ledger. A ledger is just what we used to keep records, right? So it keeps records and stores them in blocks that are linked together cryptographically.
00:10:12.476 - 00:10:58.368, Speaker A: So for a normal ledger, so each block contains the ash of the previous block, creating an invisible chain of data. So for a normal ledger, probably a book or something that I'm writing, like a record of everyone. Let's say I'm writing a record of everyone who joins the score, for instance, right? Without ledger, I could literally tear the book in the middle or do something like that, and I lose the data. But for a decentralized ledger, for blockchain, right? You can't tear a book in the middle and probably add or lose a data, or probably. Or maybe change the data or something like that. It's not possible because each of those blocks in a blockchain, they are linked together. So for a block, we have different things, like audit transactions that happen in the system.
00:10:58.368 - 00:11:28.452, Speaker A: Like a couple of transactions, they are put together in a block. So the ash of all the transactions is called a macro root. The previous block hash, and the nons of the block timestamp and some other data, we ash them together. And the interesting thing is a one way ash, right? The ash cannot be reversed. So when you ash it one way, you cannot reverse the ash and get what data was used to ash it. So when you actually ash it and you get a block hash, you use that previous block hash to ash some other data. So everything is linked.
00:11:28.452 - 00:11:33.630, Speaker A: So if at the end of the day, I try to change something that is here, I try to change one data.
00:11:35.120 - 00:11:35.870, Speaker B: Sorry.
00:11:36.320 - 00:12:04.496, Speaker A: So if I try to change a data that is. And I try to ask them to get. I won't get this value here. Right here. It is very easy to know that something has been changed, right? That is what makes like the blockchain secure? So now let's go into how blockchain data is stored. So we talk about dispute system and storing data. So how is this stored for a blockchain? So, blockchain data is stored in a disputed database that is maintained by a network of nodes, also known as a disregard ledger.
00:12:04.496 - 00:12:32.184, Speaker A: Right? So in a blockchain network, each node stores a copy of the entire blockchain, which contains a record of all transactions that have taken place on the network. So we have like a blockchain installed like we have nodes. These are computers. Like we said earlier, each of these computers are nodes and they are connected to each other. So each of these computers contain a copy of the blockchain. They store the entire blockchain. Transactions that happen in the blockchain, everything is stored in these computers.
00:12:32.184 - 00:12:53.664, Speaker A: It records everything. And all of these nodes, they are linked together. So that is how the blockchain data is stored. Right? So I have a copy, anybody can run a node. I could actually run a node and have a copy of the blockchain. This person runs in it and we all communicate with each other. So now let's go to how this data come about and how everything goes in the background.
00:12:53.664 - 00:14:10.940, Speaker A: So let's say we have Alice trying to send one ETH, one ETH to bob for instance, right? So what you see is that you sign your wallet and you just know that, oh, one ETH have gone from Alice to Bob like that. So what happens in the background is Alice goes to our wallet, she signs the transaction. After signing a transaction, she sends the request. So if you're a developer or someone that actually very familiar with infura or chemi and all of that stuff, right? If you're a developer that build like Dapps, if you want to check the balance of a wallet and stuff like that, you create like json RPC request to a request, for instance, right? So what happens is in the background, in your metamask wallet, there is a JSON RPC endpoint that when you actually sign a transaction and say, oh, I want to send one ETH to Bob, the request is going to a node. So Inferra alchemy, and all of these RPC providers, they all have a node, each of them have a node, right? So when you use metamask and you send a request to Inferra's node. So what Inferra node does is that it takes that transaction, it checks. Oh, does Halle usually have one ETH to send to Bob? Is a balance enough? Does she have enough to cover gas fees.
00:14:10.940 - 00:14:37.872, Speaker A: It pulls this transaction impending and it propagates or it gossips. Like you said. In the system, each of the computers or nodes, they all share information among each other. So what it does is it communicates all the data to all of the nodes it's connected with. They all do the same thing. You check if it's valid. They put impending and they all broadcast the information, right? Each of them broadcast, broadcast, broadcast.
00:14:37.872 - 00:15:38.132, Speaker A: To get to the block proposal or minor. In a proof of work we have miners. But in a proof of stake like Ethereum is currently we have block proposals. The block proposal is the one that will decide, oh, which transactions is actually going into a block, right? So the block proposal will check that. Is Alice's transaction valid? If it is valid, then the person decides, do I want to add this transaction to the block or not? If the person says yes and the person adds the transaction to the block, when the block is finalized, Bob receives one ETH, then Alice loses one ETH, basically loses the money and the gas, it got deducted and you have the minus and plus here. So when that happens, the block proposal or miner is going to tell the other guys that, oh, I've approved or I've added Alice's transaction to the block, then this person is going to, okay, yes, as added, then this will go from pending to approved or success, depending. This has been approved, then all of them propagates.
00:15:38.132 - 00:16:08.188, Speaker A: Propagates. Propagates and it gets to the original guy. So that's basically how everything goes in the background when you try to send one ETH to Bob and stuff like that. So now the interesting thing is, I've been talking about, okay, Netamind runs a node. Now you can. So we have like Netamind runs a node. So now you can decide that you are talking about node.
00:16:08.188 - 00:16:57.276, Speaker A: Now you can decide that you want to run a node for yourself, right? You can decide to run a node for yourself. And probably instead of using infra or chemi, you can easily run a node for yourself to use, or you can actually run a service for other people. So if you want to run an ethereum node, it's very easy to use like nettermind. And if it is Stacknet node, you can easily use Juno, right? So if you are not really familiar with stacknets, there are other people, some other speakers are going to be talking about Stacknet, giving an insight into what Stacknet is and how you can actually run stacknet work with. So that's basically everything. Thank you everyone. Yeah, so if you really want to contact netamind.
00:16:57.276 - 00:17:02.790, Speaker A: These are like you can easily reach out to netamind, follow netamind on Twitter and basically. Thank you everyone.
00:17:07.230 - 00:17:41.830, Speaker B: Thank you. Thank you so much, jelly that for very interesting presentation, definitely learnt a lot. Okay, so there are a few questions that I'm sure people want to ask or people have regarding your speech. So I'm going to start with the first question I can see which is which other sector is distributed systems used besides blockchain?
00:17:44.010 - 00:18:08.862, Speaker A: Yeah, you could actually use this system in any sector that actually give you data. Like I said earlier, let's say Instagram for Instance. Right? Instagram has actually stores a lot of data from people uploading pictures and all of that. Right. So any sector where you have to store a lot of data, you have to request any data. Instagram, an example, social media, cloud computing sectors or maybe gaming sectors. Right.
00:18:08.862 - 00:18:14.110, Speaker A: Any software that actually deals with data, especially a lot of it uses distributed systems.
00:18:15.090 - 00:18:42.410, Speaker B: Okay, thank you so much. So we are going to remaining questions to the end of the presentations where we have the time for the Q A. We're going to move on to the next speaker of the day, who is. We have Bisala, who is going to be talking about data analysis, essentially how to analyze blockchain data. So Bisala, the floor is yours.
00:19:00.240 - 00:19:01.550, Speaker C: The next one is.
00:19:04.960 - 00:19:23.108, Speaker B: The next speaker. The next. The next speaker we have is Uchena, who is going to be talking about modularized smart contract development. Uchena, please, can we have you? Thank you.
00:19:23.194 - 00:19:26.790, Speaker C: Hello, how is my audio? Good.
00:19:28.600 - 00:19:30.820, Speaker B: Great. I can hear you. Thank you.
00:19:30.970 - 00:19:46.416, Speaker C: Awesome. Good afternoon everyone. My name is David. Don't mind me. I go by the Internet by developer. So I'm a blockchain engineer. I'm impending currently at Nethermine.
00:19:46.416 - 00:20:01.010, Speaker C: So I'll be talking about modularized smart contract development and a little bit about continuous integration when building smart contract. So I will share my screen. Right.
00:20:13.960 - 00:20:14.710, Speaker D: Awesome.
00:20:18.760 - 00:21:22.696, Speaker C: So the aim of this talk is not so, so long, it's just first of all, we would just get a small brainstorm what smart contract is. Talk about upgradability. When you deal with smart contract, talk about the diamond standard because that's one of the most efficient tool used to modularize smart contracts. Next up, we explore kind of a modularized diamond standard pattern, just more like a code base to arrange stuff the way we web two or previously web two engineers could understand. I'm talking about controller services and just a much more structured database, a much more structured code base to work with. And lastly, we just talk a bit about continuous integration as related to smart contract development. IBN defines smart contract as a program stored on the blockchain that runs whenever a predetermined condition is met.
00:21:22.696 - 00:22:17.500, Speaker C: So in a much more layman term. So I'm uche, your David, and we have an agreement that I'll be paying you $50 by the end of every month. And we push this kind of contract to the blockchain and deposit the money that is to be paying to your address, David, every month. So as far as all this condition is met, condition being end of the month, receive your payment, that contract will keep on paying, David, as far as this condition is met. So that's pretty much what a smart contract is, more like a contract controlled by the blockchain. And there are rules that this must abide with and these rules cannot be altered under normal circumstances. So yeah, smart contracts are immutable.
00:22:17.500 - 00:23:00.580, Speaker C: You know, when Speaker Delia spoke, we talk about trust and distributed system much more specific on the blockchain. Now, the blockchain, it's used to be immutable to kind of house trust. And smart contracts should be immutable. So they always do what they are programmed to do. So which you won't just wake up one morning and say, all right, David, I don't want to pay you any longer, get up. So that's part of trust and that's what smart contract was built for. So naturally smart contracts are immutable.
00:23:00.580 - 00:23:54.636, Speaker C: So I think this should be one of them. It takes notes, but somehow smart contracts are editable. And I would like to put it in a much more context manner, upgradable. So if you are building smart contract in certain patterns, you can be able to update the logic and make it do something else. And interestingly, one of the most unique stuff about the blockchain I really appreciate is transparency. So whenever something like this happened, like altering the logic of the smart contract, everybody knows smart contract is upgradable. Next up is more like once understand, which I said, this is what smart contract is.
00:23:54.636 - 00:24:32.536, Speaker C: This is what smart contract is. You just said on smart contract is immutable and now I'm contracting to myself. So we'll just look a bit technically how this upgradability works. So what you see now is more like a rough sketch of a smart contract when it's not yet upgraded. So you are just looking at the version one. So this is the user, the user wants to, let's say this is a bank contract, wants to deposit some tokens. So the user is going to contact the main.
00:24:32.536 - 00:25:12.628, Speaker C: So this is the only thing the user knows and the only thing the user trusts. So whenever I want to make my deposits, I'll talk to the main. Whenever I want to withdraw my tokens back, I still talk to the main. Now behind the scene, the main is going to like, all right, I got the request from the user. User said he wants to deposit some money. Okay, the main is then going to proxy or relay this call to another contract, which is mostly called implementation or logic. So this contract holds the implementation that is going to take out this token from this user and store it.
00:25:12.628 - 00:26:17.352, Speaker C: But this main, which the user interacts with, holds the token and holds any data that is being sent by this user. So that's kind of the first thing you need to know. The user talks to the main and they may release logic, calls up another contract called implementation or logic, and the main will just store everything needed to be stored in its context. So the main does not lose any storage or any data along the line. So now the banking system wants to add insurance, so they need some logic to house insurance. Now they are going to create another logic contract which holds the banking logic and also the insurance corporation logic. Now the user still talks to the same main, and the main is going to proxy this call to not logic one any longer, but logic two.
00:26:17.352 - 00:27:03.466, Speaker C: So now the user can now perform insurance based, insurance based request or operations. So that's how updability it's achieved. So for context reason, if you see none of these contracts, the main. Sorry about that. Yeah, my bad. All right, apologies again. So none of these contracts was edited.
00:27:03.466 - 00:27:56.218, Speaker C: The main remains the main, still possessing the same address. The logic remains the logic, still holding the same address or possessing the same address. Logic two still remains the same logic two holding the same address. But what happened is just that whenever domain needs some certain logic, instead of going to logic one, it goes to logic two. So this is how the upgradability was achieved. So before we dive into diamond standard, I just want to walk you through how back end in the web two, what is built, and I feel it's a bit efficient talking from the programming perspective. So let's say this is a sales back end system having two modules.
00:27:56.218 - 00:28:35.786, Speaker C: So one module is to authenticate and authorization. The other module is to handle the sales operation. So now this module is going to have things called controllers, services and other operations to make this module work. So for example, in this controller, there could be something like login, logout, admin, login, admin, logout. So all this logic would then be handled by the service. And this service, for instance, is the database service. So it's going to query from the password, from the password table, get the hash and compare with other coming in, all those logic stuff.
00:28:35.786 - 00:29:26.442, Speaker C: So now, if you observe, this system looks clean and not so. So similar to what we normally see when working with a complicated smart contrast system. You just see contrast scattered around. So now the way the system is organized, now there are two modules and other microservices. So I could firmly call this system a much more modularized system. And with demo standard, we want to try to kind of achieve that in that, let's say for the bank, instead of writing that same bank contract inside the same contract and deploying it again, why not? There should be a module for the bank and a module for insurance. Then you just plug and play.
00:29:26.442 - 00:30:20.222, Speaker C: Whenever you want to add new instruments or new logic, just plug the module. So, looking confusing now, but Diamondstander is going to tell us how this can be implemented from the technical view. So, introduction to diamond standard. Diamond is an upgrade pattern that will allow a contract, that's the main contract, to delegate call, proxy, relay call, to more than one implementation. So if you recall from the last example, whenever the bank needs some certain logic, it proceeds to logic one. And after the upgrade, now logic two, there is no instance where it can proceed to either logic one or logic two. But diamond standard pattern would allow you to do that.
00:30:20.222 - 00:31:12.314, Speaker C: So this is a little bit not so complex, just a bank kind of a bank example. So later on, there are code base that are written down for this, for foundry had that ink, if you use Ross and just hadard. So this is how it works. So the user talks to the main, as the user always know, because the main address does not change. So now there are two modules. So now look at the way I am kind of calling this context coming from the web two kind of system. So instead of all this logic being in one, we break them down into modules.
00:31:12.314 - 00:31:59.694, Speaker C: So in the EIP 2535, written by Nick Modch, it was referred to as facets, a diamond having many facets. So that's what was referred to as. But in this code base, because of the architectural changes, I refer to them as modules because they are having services, controllers and other things you are familiar with in the web two development perspective. So there are two modules, access control and bank. So let's say a bank manager wants to deposit or withdraw, he has to have the role of a bank manager. So all those are going to be done with this assets control. And as you can see, all modules can communicate with each other.
00:31:59.694 - 00:32:40.134, Speaker C: And also the main can talk to more than one module at a time. So that is kind of the interesting thing about the diamond standard. So more like from a user's perspective, a user wants to deposit. So it tells a diamond the main contract I want to deposit. The main is going to check through all the modules it has, which of you has the function called deposit. So bank would just say, I am, here, I am. And this main contract is then going to, all right, this is, I want to deposit, do the logic and give me the data so I can store it properly.
00:32:40.134 - 00:33:22.150, Speaker C: So the main is going to then proxy this call to the bank module. The bank module processes, it returns any data, if a data should be returned to the user or for storage. And the main is going to handle that. So that's how the diamond standard works. So I said earlier that there are code business that have done or prepared down this bank scenario. And also the assets control module also I find it very helpful whenever I'm in it, in a diamond standard code base in modularized pattern. So that would be helpful.
00:33:22.150 - 00:34:02.998, Speaker C: Yeah. So talking about continuous integration, so seeing that the diamond standard gives you the flexibility of upgradability and it's now possible to systematically or programmatically perform continuous integration where you've added a new module. Okay, let's see. You want to diversify from just being a bank. Now you are now going to investment banking and you are going to be handling the stocks, bonds of your clients. So now you are adding new logic. So it's more like you plug this module into this system and everything is just fine.
00:34:02.998 - 00:35:01.910, Speaker C: So now why should you do it in a CI continuous integration manner? From the web two experience, you always enjoy seeing that you've added a new function. You push it to the developer after it's been meshed, it run a test on all the logic you've done so far, and if everything is good, it's going to do an automatic upgrade to the production service or production server. So that is exactly what could happen in this scenario. So after adding the investment banking logic, the test for that investment banking module is going to run. So after that has been done, it will then be automatically done. It's going to be automatically upgraded with the system. So the way this is possible is the one that I find most useful to me and most comfortable with.
00:35:01.910 - 00:35:48.920, Speaker C: I guess the other tools that could be used just scripting issues that would just need to be solved is using docker for the continuation and also docker pipelining and using kids pockets. So this is how the pool system works together. And after pushing this container or the docker container, everything just synchronizes seamlessly. Whenever you want to make your upgrade, you just push the module and merge to the main or the master branch and everything goes fine. So I guess, yeah, that's it from me and this presentation. Thank you very much. So these are the contacts for Nethermind reach out and it's going to be very helpful and yeah, thank you.
00:35:50.490 - 00:36:52.580, Speaker B: Thank you so much for that insightful presentation. Awesome. Our next speaker is going to be Prosper, who is going to be taking us through smart contract auditing and tools. Prosper. Thank you, Prosper. You're muted. Your mic is on mute.
00:36:56.900 - 00:37:51.520, Speaker E: Yeah, so I believe we are good now. Yeah. Sorry about that, guys. So as based on introduction, I said my name is Prosper and I'm a security engineer. So I joined the industry that was year 2019 before transitioning into becoming a smart contract auditor. So basically, what I'm going to be walking you through at this presentation is what is smart contract auditing? So, as a way of introduction, smart contract auditing is a process of analyzing and testing smart contracts to identify the potential security vulnerabilities and to ensure that the functions are actually working as intended. So in order to break it down a bit, when the smart contract developers, when they are done with developing their smart contract, the next thing they have to do is to look for an auditor that can actually help them to audit their contract.
00:37:51.520 - 00:38:33.100, Speaker E: So that's basically what we do. We tend to check for security vulnerabilities and expect a function to actually work as expected. So this process actually includes reviewing the codes and testing various method and fixing any issue that the contracts might actually have. Basically, the goal of smart contract auditing is to ensure that we prevent an attacker, an external attacker, from exploiting any security weakness that the contracts might actually have. So secondly, the next thing I'm going to be talking about is why do we audit smart contract?
00:38:33.180 - 00:38:36.130, Speaker C: Yeah, can you share your screen, please?
00:38:36.500 - 00:38:50.630, Speaker E: Okay. Yeah, sorry. I think we should be good to go now.
00:38:51.320 - 00:38:52.070, Speaker B: Perfect.
00:38:52.520 - 00:38:54.390, Speaker D: Yeah, sorry about that.
00:38:55.400 - 00:40:16.460, Speaker E: So basically, the first thing I was discussing about is what smart contract auditing is and the process at which we actually audit smart contract. So the goal, just to summarize, is the goal of auditing a smart contract is to prevent an attacker from exploiting security weaknesses and to ensure the proper functioning of the contract. So secondly, why do, you might want to be asking, why do I have to audit my smart contract? Since I trust my smart contract developers? One thing you just take note is we tend to actually audit smart contracts to identify bugs and security vulnerabilities in the code. And also audits can help you to prevent some financial loss due to hack or an attack. Also, I think we tend to audit smart contracts to help ensure that the code and compliances are actually as intended by industry standard. Then lastly, I will say we audit smart contract and also in order to address some security issues so that we can actually help you to actually build trust between you and your clients and also between your stakeholders too. So what are the reasons and why do contracts actually have bugs? Before coming up with this, we tend to go through, deep down into looking for in software development process.
00:40:16.460 - 00:41:25.968, Speaker E: So what causes security issues in smart contract or in software developments entirely? So we've come up with what we call code errors. And for code errors, when it comes to smart contract auditing, we've recorded a loss of $19 million that was in November 2022 to Pinku Finance and also compound actually lost 18 million in August 2021. Then we have BZX that lost $10 million in September 2021 also. So in order for you to actually prevent your protocol from actually losing this sum of money, that's the reason why we actually propose or a proposal for smart contract auditing is actually necessary. So the next thing we are going to be discussing is design flow. What are designs flow? Designs flow acts actually refers to the security breaches that arises due to inherent design weakness in the architecture implementation of operating a smart contract. We have the use case of reentrancy attack just to break it down with bits.
00:41:25.968 - 00:42:10.324, Speaker E: Reentrancy attack actually means when you sent someone to the store and the person went to the store to purchase a goods that was possibly $100, for instance. So the store keeper did not actually take the funds from the person that actually came to purchase the goods. And expect that once you go back to go and verify that this good is fine, you can actually come back to come and pay me my money. So on return of the person that actually came to this store to actually purchase those goods, the person was like, I never collected any goods from you because you never updated the state of the person that actually came to this store to purchase any goods. And second, that was what we call reentrancy attack. In a layman explanation, I would say. And secondly, we have what we call access control issues.
00:42:10.324 - 00:43:26.600, Speaker E: And what assess control issues actually mean is in every organization we tend to have some groups or some offices that are highly restricted for some particular users or for some particular management. So assets contractually signify that you actually ensure, when you are designing your smart contract, that only the people that are eligible can actually enter those kind of offices or those kind of places. So whenever we are checking for your smart contract, what we tend to do is to ensure that only the people that has the key can actually have access to such kind of room. And secondly, we discuss about external factors and what external factors mean when it comes to security auditing. It refers to the system of operation, of interaction between a smart contract and external component. In the wisdom of how ethereum is actually being built, it doesn't communicate outside its environments, and in that essence, it rely heavily on what we call oracles to be able to get information from outside the world into the system by itself. So in this term, the process at which the information is actually being brought from outside the world into the system, we need to actually ensure that that process is verified and it doesn't have any security rates.
00:43:26.600 - 00:44:21.352, Speaker E: Let's take for instance, every religion tends to have what they call priests that it tends to listen to, and probably the priest have to get an information from the gods that they think the God deserved. And at the long run, the priest can now come back to come and share the information with their followers. So the trust pattern there is, the followers have to trust that the priest is coming with an information that their gods actually provided. So if the priest can actually have tamper with the information that was provided, that shows that he's going to be misleading the followers. That's what we call oracle when it comes to blockchain development and ethereum ecosystem at large. So we tend to check for the validity of the information that this oracle are bringing, and to ensure that information that this oracle is going to be bringing are not being tampered with. We have what we call timestamp dependency vulnerabilities.
00:44:21.352 - 00:45:17.256, Speaker E: Also because of time, we have gas attack vulnerabilities. Also that has to do with gas price that you pay whenever you are performing a transaction. So after knowing all this fully well, you might tends to be asking, how do we actually perform smart contract security audits? Anytime we are reached out to, the first thing we tend to take notice. We do what we call code review, and what that code review actually means is we review the process and we analyze the code line by line, checking common programming error and verifying that the code had helped to establish best practice. And secondly, we perform what we call formal verification. Formal verification is when you see a security engineer going out carrying a pen and a paper, or possibly any writing material, trying to analyze every details and every information that is inside the code. We do what we call security testing and access control that I explained recently.
00:45:17.256 - 00:46:07.432, Speaker E: And what are the tools, we might want to ask, what are the tools that we actually use for doing our smart contract? Security audit primarily? I would definitely advise you, we take cognizance of all these tools, and we use some. Primarily, we have what we call Mitrell Mitril is a fooling tool. What that actually does is we just put in the smart contract that you gave us into the tool, and it falls through the process of the smart contract, and it generates an output. So the output that is being generated is what we are now going to be analyzing. We have slitter, where we used to test your smart has been provided by the developer. We have the foundry tool also, as mentioned by Jalilad, the previous speaker, that we used to actually test the smart contract that was actually given to us. Then lastly, we have slitter.
00:46:07.432 - 00:46:48.380, Speaker E: These are most of the tools that we kind of use on a daily basis anytime we are auditing a smart contract. So I have a simple smart contract here. And what this contract actually does is, I would like to break it down. The first line is to actually mint. And what this function actually did primarily is, let's take, for instance, you have a central bank in ignition. And the central bank now requests that all other banks can actually have access to mint a particular amount of money. And what the security actually ensure is any bank that is coming must not have minted before.
00:46:48.380 - 00:47:29.512, Speaker E: So that shows that the balance of the bank that is coming must be zero. That's the first line on line two. Then secondly, we have on line three that there must be public sale, which means that the central bank of that nation must said, okay, sale is ongoing at this point. So any bank that has not minted before can now come and mince the new currency. And there is line four here that we have that checks that total supply, that the total amount that has been minted by all the banks must be less than the supply limits. So let's take, for instance, that all the banks have actually mint $100,000. Then the maximum supply, which is the supply limit, is $1 million.
00:47:29.512 - 00:48:11.504, Speaker E: So there's no way all the banks can actually mint to get to $1 million. So once it gets to $1 million, it just revert and said, there is no stock at the moment. And when all these processes have been checked, it just allow you to just mint freely. So this contract actually works quite all right normally. But what we now do as security engineers that we have is to analyze this contract to check how an attacker can actually come on board to come and attack this contract and mint more than the expected amount that is supposed to mean. So the first thing a security engineer will first of all do is to check is to start from the first line. And he said a bank, let's say we have Stalin bank.
00:48:11.504 - 00:48:39.552, Speaker E: Let's say Stalin bank interests their address and they said they want to mint. So we check that the function actually takes in a signature. We check into inside the signature. We notice that the function is not actually making use of any signature within itself. So the first issue that we kind of alert is you are declaring a variable that you are not actually using within this function. And that's not the best practice. You must actually make use of everything that you are declaring within a function.
00:48:39.552 - 00:49:11.236, Speaker E: And also it's a payable function. A payable function mean you must bring in some money before we actually give you new money. And we check for the usage of this payable implementation. We notice that the payable is not used within the function. So for best practices, any function, any variable that you are not using within a function, you are not supposed to declare it. So let's say, for instance, the central bank never intend that this bank must bring the previous currency before they come and mince a new currency. That was not the intention.
00:49:11.236 - 00:49:53.700, Speaker E: So why are you adding a signature and a payable functionality? So that actually helps us to proceed, because what we want to do is to attack this function and ensure that a bank can mint above what is actually specified for that bank. The first thing it now does is just to check the balance of the person that is coming to command mint, and the balance is being checked in the wrong way. For instance, I said, I want to come and mint from central bank. So when I get to the central bank, immediately, I minted, I can just give the funds that I minted to Edo, for instance, and said, ed me to keep this phone, I'm coming back. So that shows that the fund is no longer with me, it's now with Edo. So if I come back to this place, I will still be able to mint. That shows that I will be able to.
00:49:53.700 - 00:50:29.776, Speaker E: The first check, which is line two, will be passed. Then we have the line three also that check for public sales. So it said public sales must be true. And for standardization, we said public sale must actually be a camel case. Camel case is when you actually, from what I actually signify, this is how you actually write camel case, which is not done that way. And also it said that it must be equals to true, which is line three. You notice you can just say public sale instead of saying it must equals to true, because every boolean variable actually is actually false at instance until they are letter change.
00:50:29.776 - 00:51:10.612, Speaker E: So we proceed again to check what is within this function. We said, instead of saying public sale, you could as well say public sale started, which is past tense, just to ensure that you have a right value that actually trying to tell your users so you could have, as first said, public sale has started. Then next we have what we call means can be looked just as what I've mentioned. The only check, once we get to this point, the only check that has actually happened is to ensure that a particular address is always zero. And we broke that gap actually already. So the next thing is now said, total supply must be less than supply limits. Maximum supply limits.
00:51:10.612 - 00:52:03.312, Speaker E: And you can as well just say total supply plus one is less than supply limits, instead of just saying total supply because it tends to be much more cheaper. Why will you add plus one? So this is how we as an auditor tends to actually approach every function or every contract that is given to us. We have total supply total means here, which is much more semantic than to use the word total supply. And also in order to actually reduce gas usage, you should have as well used what we call custom arrow, which is kind of cheaper than the required statement that is being declared here. So we have what we call safe means that leads to reentrancy. And we have what we call safe means, and it does not look at this code. So because of time, I would just like to just summarize and say as a user that I'm coming, I can now come and mint, because it's only checking as an attacker, it's only checking that I never hold any of this currency before.
00:52:03.312 - 00:53:02.764, Speaker E: So anything that makes me to come, I can just come here and come and mint new currency and just add the need currency that I minted to someone else to help me to hold and come back again. And I'll see command mint so I can do this over and over and over again until I drain everything that is inside this contract. So this is how we smart contract auditors actually approach contract that is being given to us by a developer. And that's the reason why you tend to see most contract that are not audited currently being act. And we can actually assure you that any of your contract that has been audited, we have 90% to 95% of assurance that you are kind of safe at the moment. So in knowing all this and how we think and how we actually approach every contract or every protocol that is given to us by a smart contract developer. So what are the steps to actually become a smart contract auditor? If you want to ask, I will say first thing you have to do because every contract is actually being built with solidity.
00:53:02.764 - 00:53:54.656, Speaker E: So just as you've seen, the mint function here is being built with is being written with solidity. So what are we advise is the first thing you have to do is to understand solidity and Yule. Also, Yule is an assembly language just like an advanced solidity in Ethereum virtual machine. So what you first of all need to do is to understand what solidity is and Yule then lend common smart contract vulnerabilities. You could be wondering how I got to analyze all the functionality between the mint function is because we've actually been checking, we've actually been making research of the previous act that has actually happened to some of these protocols and also the future act that is likely going to be happening. So it require us to actually lend most of these smart contract vulnerabilities that has actually happened to most of these protocols. So in doing that, you could actually understand what you should be checking for next time you're actually auditing.
00:53:54.656 - 00:54:39.932, Speaker E: Then you need to gain experience with smart contracts by contributing to open source. This might not be very relevant, but it's definitely going to help you in the long so. And also you have to seek out a mentorship or internship opportunity. Just like the avenue that mind I've actually created for everyone that is watching or anybody that would like to join an internship opportunity, just like how I utilize my own. Also where you can actually learn with most experienced developers or most experienced security engineer in the industry also. Then you can now proceed to build a network within the blockchain ecosystem where you can now reach out to people, you can now mingle with people and you guys can now keep discussing about security things that is actually happening. These are steps that you can actually take in order for you to become a smart contract auditor.
00:54:39.932 - 00:54:59.480, Speaker E: This is not all quite all right, but this is definitely going to help you and going a long way. So we welcome you to come and join us at Nethermind where you can actually brochure up your skills in order for you to become a security engineer if you really want to. And yeah, I think that's all I have to say for now. Thank you very much. My name is Prosper.
00:55:01.740 - 00:55:19.490, Speaker B: Thank you so much prosper, for that awesome presentation. Now we'll be moving ahead to our next speaker, who is Ademola, and he's going to be talking about building decentralized app on Bisola. Over to you.
00:55:24.340 - 00:55:24.944, Speaker D: Hello everyone.
00:55:24.982 - 00:55:26.050, Speaker C: Can you hear me?
00:55:29.320 - 00:55:30.790, Speaker F: Can you guys hear me?
00:55:33.640 - 00:55:34.870, Speaker B: Yeah, we can.
00:55:35.880 - 00:55:58.430, Speaker F: All right, good day everybody. My name is Adimala Kervin. I am a software engineer currently at Web three bridge and also a former Internet Nethermind. And today's presentation will be about layer two, some building on Stacknet. So share my screen. Now, can we all see my screen?
00:56:00.800 - 00:56:02.030, Speaker B: Yeah, we can.
00:56:03.200 - 00:56:42.970, Speaker F: All right, so basically we'll be touching on some concepts such as layer roll ups, zero knowledge, zk proofs, and also the static architecture. So what are layer twos? Layer twos are framework or protocols that are built on existing blockchain, which is the layer one. And why do we need layer twos? Basically, let's borrow some concepts from the presentation that jelly lad gave us about building distributed systems. Blockchain is basically distributed system and it's an.
00:56:44.780 - 00:56:45.384, Speaker D: Sorry.
00:56:45.502 - 00:58:32.990, Speaker F: So blockchain is a distributed system. And then like Jelly lad said, you have to have collection of nodes that store records, right? And we know that computation you make on the ethereum has to go through some process of validation before it is accepted into, before it is accepted and then broadcasted to other networks, right? So if you're having aggregation of like thousands or more than 1000 nodes, kind of slows down the rate at which computation is being performed, basically. So this is one of the reasons why we need layer twos. And for every blockchain system, right, you have this concept called the trilemma issue, where the system can be decentralized, it has to be secure and also scalable. But then the blockchain deterrent blockchain in this case is able to achieve just two out of this three, whereby it is decentralized, you have quite a number of nodes participating in the network and then it is also secure. But then how do we go about scalability? Scalability in the sense of how do we increase transaction finality and also reduce gas fee? Because as early as the age of Ethereum, we have people paying transaction fee as IAS, $100, $50 just to have their computation processed, which is bad and which is like a flaw to adoption of more users to the blockchain. So this is where layer two is kind of coming to play.
00:58:32.990 - 00:59:55.048, Speaker F: So there are different ways in which we can approach scalability solutions for the blockchain. And some example of these are using channels using plasma sidechain and also roll up. But then the focus here will be on roll ups. So the idea behind roll ups is basically that you have some sort of computation, your computation, which you do on Ethereum, is done off chain and then the competition, once the computation is done, then some sort of proof is submitted to the layer one blockchain to verify that, okay, this transaction, this execution is actually true. So an example would be say, an example would be say you compute some sort of 1000 transaction off chain and then you have to submit some sort of proof to layer on, okay, this transaction has been carried out successfully. So looking at this now, the roll up is broken down into two. We have the optimistic roll up and then we have the Zk roll up.
00:59:55.048 - 01:01:09.516, Speaker F: And the ZK roll up is the approach taken by Stacknet to solve this problem. Stacknet is a permissionless, decentralized zk validity roll ups which is built on top of Ethereum. So Stacknet utilizes zero knowledge and the concept of roll ups to scale Ethereum. And while building scaling solution for Ethereum, it's good to also note that there are solutions that are built towards compatibility with EVM, right? And whereas when it comes to the concept of ZK and Stacknet, in this case they kind of sort of branch off looking at compatibility with EVM such that they have to come up with their own VM. And also which brings about the introduction of a new language called Cairo. And as you can see, Cairo is a special purpose programming language for creating probable programs for general computation. So let's take a look at what zero knowledge proof is, what zero knowledge is, and then we'll look at zero knowledge proofs.
01:01:09.516 - 01:02:30.200, Speaker F: So zero knowledge proof, simply divine, is simply like a way by which approver convinces a verifier that some statement holds true without revealing too much sensitive information. So the simplest example of this is you're trying to prove to someone that you know a particular secret without revealing too much information. An example would be say you have an image which says you should prove that, let's say Waldo is present in the image. What you do normally is to show the full picture to the person you're trying to verify to that, okay, Wildo is present here, but then to allow for zero knowledge such that the verifier doesn't have a full information of what you're trying to prove, you can just draw a circle just to show the presence of Wildo is present in that picture. So that's like the simplest explanation I can give for that. So looking at that now, there are two types of proof. You have the ZK snark you have the CK stack and the ZK snack basically stands for zero knowledge, succinct, non interactive argument of knowledge.
01:02:30.200 - 01:04:07.380, Speaker F: Why zk stack stands for zero knowledge scalable, transparent argument of knowledge. And you see why Stacknet is using stacks instead of snaps. Sorry, so I forgot to touch on this, talking about roll ups, right, I made mention that we have roll ups where you have the optimistic roll up and then you have the ZK roll up which is being used by the stacknet ecosystem. But then looking at this to what differentiates them, right? So basically zk rolo uses zero knowledge proof, where optimistic roll up assumes, uses the concept called false proof, whereby transaction that are computed off chain, when it is sent to you verify it takes quite a number of the transaction is assumed to be valid, right? And it takes some couple of days to verify the validity of that transaction. And it has its own architecture. The simplest explanation is during that couple of days the challenges in the system have to challenge the proof being submitted, basically. And this has some sort of downsides in terms of withdrawing and then deposition, such that during this process, why this process is taking place, you can't make withdrawals, neither make deposition.
01:04:07.380 - 01:05:04.248, Speaker F: So unlike ZTA roll up which utilizes validity proof, basically. So there are no need to wait for the proof to be valid. It doesn't take days to do that, it is instant basically. So why zk stack? Zk snacks and zk stack are both non interactive zero knowledge, while zk snacks have advantage when it comes to proof size and throughput. What this is saying basically is talking about snacks, snacks, proof size are small, right? But then they have two major weaknesses, they require trusted setup and they are not quantum resistant to attack. I would have loved to dive into this concept, but then beyond the scope of what we're talking about, basically. So ZK stocks solve this problem.
01:05:04.248 - 01:06:42.356, Speaker F: So zk stock are quantum resistance, right? And then the proof are quite large, but then they are faster to generate proof and sometimes faster to verify. So the high level architecture of the stack ecosystem is you have two parties involved, you have a prover and then you have a verifier. So on the prover, like on the off chain, to do the off chain computation, the proverb has to sort of batch some transactions together, right? Which we can see as TXA, then submit that to the sequencer, which the sequencer sort of generic execution traces. And these execution traces is submitted to the shop prover that generates a proof and then the proof is submitted to the L one contract. So what I mean by L one is ethereum in this case such that you have some sort of contract off chain and once computation is done and the proof is generated, you then submit that to the L one contract to validate and check that. Okay, this competition is actually true. So looking at the architecture, basically we have the stacknet components, we have the profile, we have the stacknet Os and then the Stacknet state and then the stacknet core contract.
01:06:42.356 - 01:07:41.710, Speaker F: And also another advantage of this is such that you can have back and forth communication between the layer one and the layer two, and then you can have interaction between the layer two and also layer one. So in essence, basically stack enables you to build with Cairo to build applications. That helps kill Ethereum, that helps you to verify your transaction easily using the validity proofs. And you can have interaction between your l one contract and also the L two layer. Yeah, that is it for me. I would have loved to do a demo of Cairo contract, but.
01:07:44.480 - 01:07:45.004, Speaker C: With the.
01:07:45.042 - 01:08:53.114, Speaker F: Current ecosystem Cairo 1.0 just came out and there are still some back and forth regarding writing the latest Cairo contract and its deployment. But you can reach out to me if you want to learn about Cairo via my Twitter. And also I have added some link where you can learn about its architecture and also get started with building with Cairo. And also importantly you can join our community, which is the stacknet Africa, to get a hang of what the stacknet ecosystem is and how to build on. Thank you, that'll be all from my end. Can you guys hear me?
01:08:53.312 - 01:09:07.610, Speaker C: Yeah. Thank you so much. And we have a quick question from YouTube asking, in the context of the slide you just showed in the start architecture, what specifically is Juno implementing?
01:09:10.230 - 01:09:34.850, Speaker F: It's.
01:09:36.110 - 01:09:39.290, Speaker C: Maybe you can just tell a little bit about Juno.
01:09:41.150 - 01:09:53.340, Speaker F: I think Jayila can share more light on that. Yeah, sure.
01:10:00.020 - 01:10:13.704, Speaker C: Maybe we take it to the end and we have Pashir next, and then afterwards we address all the questions that came up in kind of like a Q A session. Then go ahead, Pashir. All right, sure.
01:10:13.742 - 01:10:35.760, Speaker D: Thanks a lot, Stefan. Let me share my screen. All right. Hi everyone. I'm here to talk about the internship program at Nethermind. I'm Bashir. I'm the internship program coordinator.
01:10:35.760 - 01:11:35.064, Speaker D: So I know at the beginning Edgar did share a bit about what Nethermind does. Basically, Nethermind is a blockchain research and software engineering company, and we empower enterprises and developers worldwide to access and build upon the decentralized web. Basically web Nelline was bootstrapped in 2017 and received Ethereum foundation grant around 2018. Sorry. And it has actually served as the key infrastructure builder, provider for the Ethereum and Stacknet ecosystem. And the internship program for Nethermind was launched sometime in 2021, January to 2021 the internship program at Nethermind is one of a kind, as most people will describe it. One of the key things that most interns do talk about and do approve of is the culture Nethermind.
01:11:35.064 - 01:12:52.030, Speaker D: Basically, as an intern at Nethermind, you have complete freedom, you have a complete will to do whatever or choose whatever project you would like to participate in. Basically, the program is here to empower people into the blockchain space and also basically assist with your learning process, research and cooperation amongst people in the industry. The program basically aims to give back to the crypto community and to also support the growth and future of blockchain engineers and researchers. So during the internship, you basically have complete control to choose whatever project you want. You can basically take a project today and drop it tomorrow if you feel like it doesn't align your interest. The reason why that is because Nethermind has so many projects and we want our interns to explore as many projects as possible or to basically find what it is that they are so passionate about and basically build upon that. So this freedom allows them to just move and test different projects and eventually find which it is that their interest most aligned with.
01:12:52.030 - 01:14:11.684, Speaker D: So some of the quick starts about the program, it was kicked off in January 21 as mentioned before, and it is open to everyone worldwide basically. And anyone interested in the blockchain, technology, computer science, software, engineering, or any related fields and network. Provides world class technical capacities, leadership qualifications and hiring. And during the exit interviews, an estimated 98% of interns from September 22 to February 22, this was the period within which we did of survey, all exclaimed, gave back positive feedback about the internship program, which is pretty high, I would say, in terms of satisfaction. So what's the internship program like? So every single hour, every hour that your intern at Nettlemind is paid, regardless of the type of work you do, basically you can actually just join the internship to sort of learn without even needing to contribute to any of the projects. And you will still be paid for that because you're basically learning and upskilling. So this is actually the main goal of the internship, and each intern is free to contribute to any area of the business.
01:14:11.684 - 01:15:01.408, Speaker D: We have interns that also decided to contribute to marketing. We have interns that decided to contribute to business development or even within projects. They decided to contribute to whatever aspect of the projects they found interesting. And it's highly encouraged to network while at Nethermind. Nethermine has such an open culture where you could literally speak to anyone, regardless of, should I say, their level in the company, whether it's the CEO or CFO or fellow interns or project leads, you could literally freely speak with anyone and ask them any questions you would like to find answers to. And that's one other aspect that most interns really do like about Nevermind. And the internship basically lasts three months and working hours are flexible.
01:15:01.408 - 01:15:39.116, Speaker D: So we have interns who were going to school while doing their internship somewhere. Some had full time roles and we're still basically interning at Nethermine. So it's very flexible. You just choose the hours which work for you for you to make most out of the internship. And after the internship you may apply for full time roles at nevermind, depending on the open positions available for you. Some interns are converted directly from the internship without having a break in between. So there are actually lots of opportunities to provided to interns.
01:15:39.116 - 01:16:43.252, Speaker D: And interns do stay in touch after the internship via LinkedIn or via email some of the contact or relationships they form during the internship. So when it comes to Nigerians, in total we've had about 274 interns and netherminds from all around the world, and out of those, 26 of those have actually been Nigerians. In the peak average of the internship at a point, we had about 66 interns at a time, sometimes in 22, and that made for 1% of the total headcount at Nevermind. So far we've had people from over 50 countries, 26 of those were Nigerians. So some of the features of the internship program include. So this is just a brief summary of what it's like when you are accepted or admitted into the internship. Never mind.
01:16:43.252 - 01:17:33.108, Speaker D: First you go through the onboarding. We have an onboarding call with myself and sometimes Tomash, who's the CEO, another mine of biotech, who's the project manager. And basically this call is basically for you to tell us about yourself. And we also give you a brief summary of what it is like or how best to assimilate into the company and also discuss some of your interests, especially project interests. And each engine has a dedicated intern support channel on Slack where we share ideas, questions, challenges and do frequent check ins. And we have a general intern slack channel. This is where all the interns currently in Nethermind are added to, where there's free flow of information and ideas and any updates relating to the program are posted on that channel.
01:17:33.108 - 01:18:29.096, Speaker D: And we have a list of intern friendly projects. Because Nethermind has a whole lot of projects, but there are some projects that are specifically curated which are intern friendly, which are easy to onboard to, even if you do not have a lot of blockchain experience or technical experience in the required fields. And recently we introduced the intern development plan. This was to enable each intern to sort of map out or map out their goals for the internship and collaborate better with the internship program management team to ensure that the interns are making the best out of their internship check ins. I personally do check ins for each intern to catch up, discuss progress and challenges either weekly or bi weekly and any other related matters. And then we have an ame session with the CEO. That's the ask me anything session once a month.
01:18:29.096 - 01:19:37.832, Speaker D: This is where the CEO actually takes time to answer any question at all that interns might have. And it's usually very fun because interns get to explore their curiosity and ask questions that they might not have previously had the opportunity or was comfortable asking. So the program success statistics so far, 82% of past interns have gotten full time jobs in the ecosystem. 25% of those are actually hired by another mind, while the remaining 57 of those were hired by other companies and then 10% of those went on to do internship at other companies. And some of the job titles of the full time include software engineer, blockchain engineer, Defi analyst, Ethereum code developer and we even have some founders and co founders and these developers security engineers. So the project, never mind cover a whole lot. As you can see from Ethereum protocol, engineering node, infra management, smart contract audits, formal verification, governance.
01:19:37.832 - 01:20:24.172, Speaker D: Basically I'll say the full spectrum. So if you are really interested in exploring the blockchain space, this internship is a very great opportunity for you to do so just based on the fact that there are so many projects covering almost every aspect of the industry. And these are some of the testimonials from some of our nigerian interns. Some of them are actually here on the call, have spoken. We have Kelvin and Prosper who gave really sound testimonials of their three months intern in another mind. And so far this has been the trend with all our other interns because most interns give really positive feedback about their experience here. So I think that's all for me.
01:20:24.172 - 01:20:31.730, Speaker D: If you do want to contact us, you can visit any of those links and if you do have any questions, please feel free to drop. Thank you very much.
01:20:40.740 - 01:21:10.540, Speaker B: Thank you so much Bashir for that presentation. That was awesome. I think right about now we've had all our speakers give their presentations. I hope we've learned a lot. We right now have a lot of questions so we can move ahead to the Q a section. Yeah, we have a couple of questions. I'm going to start with questions for Delilah.
01:21:10.540 - 01:21:22.850, Speaker B: So the first question is Delilah. So when running a distributed database, how do you decide on which server to send requests to?
01:21:30.360 - 01:22:00.774, Speaker A: Yeah, thanks, AJ. So you have a load balancer. A lot of systems usually have a load balancer and depending on the algorithms that it decides to use. So a load balancer can use different kind of things. You could check the database that has the least request. A server that doesn't have like maybe only had zero request or one request compared to a server that has like maybe 100 requests coming to it. Right.
01:22:00.774 - 01:22:16.860, Speaker A: So we decide based on the one with the least request, then how. Then you could decide to go with that instead. Right. So we just balance the load depending on the number of requests. This one has the one with the lighter request and you decide on that.
01:22:20.780 - 01:22:50.750, Speaker B: Okay, awesome. Thank you for that. So the second question is basically differentiate between genosis and Stacknet. So Jalila, do you have anything to expand on that difference between genosis and.
01:22:51.360 - 01:23:26.344, Speaker A: Oh, okay. There was a very good explanation dropped in the chat. But basically gnosis is a side chain to Ethereum, right? So side chain is just walks alongside Ethereum. While Stacknet is not a side chain, it is an L two, literally. Its security is based on Ethereum. So what happens with Stacknet is zk is a zero knowledge proof system. What happens is because Ethereum had a lot of transactions and it is very hard scalability, having to run multiple transactions at the same time.
01:23:26.344 - 01:23:59.970, Speaker A: It is actually very, usually makes transactions take a long time to get processed and also increase gas fees, basically. So what Stacknet does in this case is it allows you to send transactions on its own l two chain. And it uses a sequencer to bond all of those transactions together and puts it on Ethereum. Right. So it is cheaper for you to send transaction on stocknet than to go to Ethereum directly to process transactions, basically.
01:24:00.980 - 01:24:26.350, Speaker B: Okay, thank you. Thank you so much for that. So I'm going to move on to the next series of questions, which are directed to Uche. Now, the first question will be what is the security measure taken when handling continuous integration using this system design? Does the system design you spoke about?
01:24:28.080 - 01:25:12.590, Speaker C: All right, so the best security measure that I've seen and have been proven to be trusted is by using an assets control system instead of the default images of sender equals to owner kind of system. So using the asset system is going to make it. A manager or an admin can make this upgrade with this key just once. And after this road is going to take away from this key. So that's the best approach for running the continuous integration using this system. So just for the more the script I've been written for that, and hopefully you should be on GitHub already.
01:25:15.520 - 01:25:28.320, Speaker B: Thank you so much. So the next question will be, what do you think is the most important thing to take note of when working with the diamond standard? Smart contract development pattern.
01:25:30.260 - 01:26:12.290, Speaker C: All right, so the most important thing when working with the diamond standard or any other upgrade pattern is your storage, because the storage is what value to you as a user, investor or developer. So you make sure whenever you're making upgrades, you don't alter the storage system in that everything is now nipse or fabricated. So you have to follow the standard and the most secure way of handling your storage, making sure everything does not just go haywire. That is the most important thing when working with an object and like diamond standard.
01:26:13.700 - 01:26:37.344, Speaker B: Okay. All right, thank you so much. So the next set of questions are for, the first question is, what is the significance of oracle vulnerabilities? Is this solved by chain? Is this solved by chain link? Do n s don't.
01:26:37.392 - 01:26:37.990, Speaker C: Or.
01:26:40.200 - 01:26:42.310, Speaker B: Is there more to that? Sorry.
01:26:43.340 - 01:27:32.552, Speaker E: All right, thank you for that. When it comes to Oracle, I think most issues that we usually have is getting information into the Ethereum ecosystem. So we need to actually ensure that the process at which the information actually gets to the EVM or the contract is actually reliable. For Chainlink, I think they tend to solve one of these issues because what they do is actually a decentralized way of getting information from different nodes. So once they get information from different nodes, they can now verify it on the contract. So what if we have a scenario where we have above 70% actually voted for a wrong information? So Ethereum and the EVM itself doesn't know anything about prices of an asset. Like Ethereum price.
01:27:32.552 - 01:28:14.420, Speaker E: The EVM doesn't know anything about price of an asset. So what we do is sending the price of an asset from off chain into the network. So the mode at which the price is actually being computed into the network are to be determined and we have to ensure that it's very secure. So this is one of the things that Chainlink actually tends to solve that is very important. But if you are looking forward to actually build your own oracle, which is very possible where you want to supply information like weather information or probably, let's say political information into the ecosystem, we have to actually ensure that the process that you're actually using is well secure. So that's what auditing actually comes to solve.
01:28:15.820 - 01:28:24.330, Speaker B: Thank you so much. The next question will be how auditing performed. Are there any frameworks or tools used?
01:28:25.660 - 01:28:50.256, Speaker E: Yeah, for that. Thank you for that. For auditing and frameworks. There are frameworks that are being used for auditing. One thing is these are software or these are framework that are built by human, just like me and you. And you can't assume that the framework is going to be perfect. So that's the reason why we consider manual review much more.
01:28:50.256 - 01:29:29.950, Speaker E: So if I should greatly rate at which you should actually ensure a trust on any framework that you are using, we tend to put manual review first. So there are frameworks that I've mentioned. We have this Lita, we have the maestri, we have Oriente, we have echidna, we have foundry. These are framework that you can actually use to actually verify that everything is working fine. But the one with the cognizance of more, or the one that is highly recommended is manual review where you as a security engineer, you have to check into it a bit by bit just to ensure that you are not actually heavily relying on the framework that you are using.
01:29:33.300 - 01:29:40.480, Speaker B: Okay, awesome. We have another question. How long will it take to become a smart contract auditor?
01:29:41.620 - 01:30:35.396, Speaker E: Well, I will say it kind of depend on you as an individual, but let's say if you have been in the industry before, probably a smart contract developer, it's much more easier for you to easily, let's say, redirect into becoming a smart contract auditor. But it still takes you some few while because there are ways where auditors, there are how auditors actually think. And because most time we tend to think as if we want to actually break the protocol that is actually guiding the laws, that is actually guiding your code. So there are human mind, how you think and how you place your focus. There are tools that you also need to know and also there are approaches that you are going to be using. So these are things, as a smart contract developer that wants to migrate into becoming an auditor, these are things you need to take cognizance of. I will say probably in less than a month.
01:30:35.396 - 01:30:51.588, Speaker E: I didn't catch that. Let's say 24 weeks, let's say before six months. Three to six months should be okay for you if you are starting from onset, because you need to actually follow the process that was actually scheduled.
01:30:51.684 - 01:30:52.984, Speaker D: Yeah, thank you very much.
01:30:53.022 - 01:30:59.790, Speaker E: But still heavily, it depends on how diligent you are in putting things to work in your learning process.
01:31:00.400 - 01:31:40.088, Speaker B: Okay. All right, thank you so much for that. So here's another question, and I believe this is directed to Jalila. Can you comment on the resource requirements for running starknet clients like Juno? Plus, can I just run it on top of an existing layer? Okay, plus can I just run it on top of an existing layer one ethereum setup? Or will it require too much additional CPU and disk space to keep it all together? You're right.
01:31:40.174 - 01:32:20.996, Speaker A: The resource requirements for running Juno is actually, you can actually run it on your normal computer. Like if you have a computer that is maybe twelve gig RAM, you can actually run it very easily. And you can also use like a raspberry PI as well. But what you just need is just make sure you have Golang installed and you have like a C compiler installed and you should be good to go. As for whether you can run into an existing layer one setup, it depends on, I don't know, how heavy your setup is, right. Because having more actually cause a glitch. But currently Juno actually doesn't require much power for you to run.
01:32:20.996 - 01:32:30.250, Speaker A: It's actually very smooth. So depending on how your setup is, if it's actually a very large system that could actually accommodate something. Okay, I think you should be good to go.
01:32:32.220 - 01:32:45.390, Speaker B: Okay, thank you. So this question goes to Bashir. Bashir, are there extensions for the internship after the initial three months? I believe you've answered that one. Yes.
01:32:47.600 - 01:32:53.500, Speaker D: So there are no extensions after the internship program, but you could apply for a full time role.
01:32:53.660 - 01:32:57.170, Speaker B: Okay, so another question. Can I get hired after?
01:33:00.420 - 01:33:14.390, Speaker D: Yes, definitely. You can get. Once you send your application, our talent team is going to review your application and if you're a great fit, you will probably get hired. Although I have to say that it's very competitive. We're all the best.
01:33:15.320 - 01:33:33.530, Speaker B: Okay, thank you. Thank you all so much for this. I believe we've had a very informative time talking and that will be all for the questions. Yeah, I'm going to hand it over to Stefan. Stefan, is there anything you want to add?
01:33:35.980 - 01:33:36.776, Speaker E: No, that's it.
01:33:36.798 - 01:33:48.370, Speaker C: Thank you very much. Thank you everybody in chat. Thank you guys here. And it's been, it's been really good. And I hope all of you have a nice rest of the day.
01:33:50.580 - 01:33:55.196, Speaker B: Thank you everyone for joining. Enjoy the rest of your day. Bye.
