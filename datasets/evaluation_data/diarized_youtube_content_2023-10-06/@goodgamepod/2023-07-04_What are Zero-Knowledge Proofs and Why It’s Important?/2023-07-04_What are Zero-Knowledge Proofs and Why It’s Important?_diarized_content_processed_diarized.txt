00:00:00.320 - 00:00:04.074, Speaker A: Welcome to good game. Your no B's insights for crypto founders.
00:00:07.534 - 00:00:28.844, Speaker B: I always consider ZK as a web three technology, which some people disagree with saying, no, that's a general technology. It was existed before way web three. I think most of the interesting advantages in ZK happened when you actually started monetizing this technology, right? And people started, oh, there is money to be made in here, so let's develop this further. Right?
00:00:28.974 - 00:00:46.800, Speaker C: Yeah, I think crypto used to be like, oh, about privacy and stuff, and then the word crypto got taken away from the cryptographers and crypto meant like, oh, blockchain. Right. But with the ZK stuff, I think the word crypto kind of got back into where it belongs.
00:00:46.912 - 00:01:10.860, Speaker A: Looking for your next startup idea in crypto? Check out our request for startups list and get inspired at Alliance XYz ideas. Welcome to good game. Today we're going to be talking about zero knowledge proofs and some of the startups and ideas that we're seeing that could be brought to the market and some of the ideas that we think could be brought to the market in the next couple years. We have David again from our team that's joining us along with Buddha and Chow.
00:01:10.972 - 00:01:12.036, Speaker D: And so maybe I'll throw out a.
00:01:12.060 - 00:01:23.622, Speaker A: Question to you guys, which is, what are zero knowledge proofs? And I know we've talked about this previously in some of our past episodes, but those that are newly tuning in, what are zero knowledge proofs and what do you think can bring to the market?
00:01:23.758 - 00:01:27.654, Speaker C: We're getting right in. No, right in. No chit chat, no chitchat.
00:01:27.694 - 00:01:30.714, Speaker A: Unless you want to do some chitchat. I'm also open to that idea.
00:01:32.734 - 00:02:01.950, Speaker C: All right. Zero knowledge proofs. Succinctly, a zero knowledge proof is the ability to say a fact about something that, you know without revealing the fact itself and being able to convince another person that, you know, the fact that let that sink in a little bit. At first it seems kind of impossible, but there are actually a lot of easy ways that you can see out there in the world out there.
00:02:02.022 - 00:02:02.270, Speaker D: Sorry.
00:02:02.302 - 00:02:10.150, Speaker A: Why is this such a big problem to solve? Because obviously it took decades of research to get to where we are today. Was there knowledge proofs? So why is this such a big deal?
00:02:10.262 - 00:02:23.388, Speaker C: It's a big deal because it's a technology that allows asymmetry between an attacker and a defender. You know, so, like, there's a lot of technologies prior to this that are not asymmetric.
00:02:23.436 - 00:02:23.620, Speaker D: Right.
00:02:23.652 - 00:02:35.468, Speaker C: Like here you discover fire, you discover guns, and then, like, it's very easy to destroy, whereas, like, this is one of the technologies that allow you to defend easier than to attack.
00:02:35.596 - 00:02:36.220, Speaker D: Right.
00:02:36.372 - 00:02:38.076, Speaker C: And that's what makes it exciting.
00:02:38.220 - 00:03:06.904, Speaker B: Yeah, I can add some color to that. Like, the concept is not really new. The concept has been around, like, that you can do encryption to hide some information, and, like, only one person would know. And the zero knowledge proof is that the concept of it, as David said, is that you can do something that have private information, but the proof is public. So, like, anyone can prove in public what you know in private. And this is a different concept. Encryption doesn't do that.
00:03:06.904 - 00:03:45.446, Speaker B: On the technology development side, there was actually versions older than what we know in 2016, Zcash. But there are some features that were very new. These features are something like non interactivity. What is that? Like, you can prove something like that, like zero knowledge if you are interactive. I ask a question, you answer this question, I ask another question, you answer again. So, this requires interaction between us, and this can be done mathematically, but it requires both parties to be online at the same time. The new concept that came with Zcash is non interactive component that we don't have to interact, we don't have to keep communicating.
00:03:45.446 - 00:04:32.134, Speaker B: So this non interactive part was interesting because you can do the proof separately, and then I can verify it later without us communicating at all. So this took a lot of kind of moon math to achieve. The other advantage, I would say, is that finding new ways to make this computationally possible, you can do this by many computations that will take a lot of computing power, a lot of time. The trick here is to make this competition smaller in size, more suitable for consumer hardware, for random, for people like us who have, like, desktops or whatever, who can do it. So, I think this what made it, like, take a long time to develop, and funnily enough, like, most of the development happened in the last, I would say five years, or like now eight years since 2016.
00:04:32.794 - 00:04:36.344, Speaker A: Do we want to go down the rabbit hole of the moon math behind it?
00:04:36.424 - 00:04:43.856, Speaker C: Well, I think the moon math is definitely beyond the scope of this podcast. And my knowledge, I don't even know how to do it.
00:04:43.880 - 00:04:48.484, Speaker B: But I think the best guy to touch on the math is like our mathematician.
00:04:51.344 - 00:04:53.088, Speaker A: It was an Elu for chow.
00:04:53.136 - 00:04:56.744, Speaker C: Really good examples of ZK proofs without the math.
00:04:56.824 - 00:04:57.160, Speaker D: Right.
00:04:57.232 - 00:05:28.466, Speaker C: Just like to show what the concepts are. And for that, I have prepared some slides. Okay, let's do it. So, I think the most simple to understand is the Alibaba cave. Okay, so this is the slide that shows the Alibaba cave example, the problem setup goes like this. Peggy wants to prove to Victor that Peggy knows the secret code to this magic door. So if you know the secret code, that's magic door.
00:05:28.466 - 00:05:32.874, Speaker C: The magic door can open, but if you don't, then it just does not open.
00:05:32.954 - 00:05:33.170, Speaker D: Right.
00:05:33.202 - 00:06:36.208, Speaker C: But Peggy wants to show Victor that she knows the code without revealing the code. So a zero knowledge proof of how this could happen is for Peggy to go into this cave, and this cave has this two paths that are connected by the magic door. And Peggy will choose either a or b and get stuck behind one of these paths, and then, and then shout out to Victor, hey, like, you can come in. And then Victor would. Would come into this area, and then Victor would say, please come out from path a or please come out from path b. And since Peggy knows the code, she can go through the magic door and come out either by path a or path b. But if Peggy did not know the code to the magic door, then Peggy would, you know, can only come out of either path a or path b, the one that she initially committed to.
00:06:36.208 - 00:07:00.764, Speaker C: So this is an example of a ck proof. And what a ZK proof does is three things. The first is if the person who knows the thing actually does know the thing, then they can, like, always produce the correct answer, as in, like, come out from a or b, whatever Victor chooses. If Peggy does not know the thing, then she cannot lie. She will get caught at some point.
00:07:00.884 - 00:07:01.428, Speaker D: Right?
00:07:01.556 - 00:07:22.974, Speaker C: And lastly, nothing is revealed to Victor. Victor doesn't know what the magic code is. So this is like a very simple example of a, of a Zk proof. And if. If you do this multiple, many, many, many times, then the chances that Peggy would never get caught if she does not know the code, approaches one.
00:07:23.594 - 00:07:43.574, Speaker E: You actually brought up a really interesting point, which people don't usually talk about, which is that the zero knowledge proof is actually a probabilistic proof. There is a small chance that you can cheat and provide the right proof, but if you do this long enough and often enough, then at some point, you're going to fail.
00:07:43.694 - 00:07:52.782, Speaker C: Right, and you can generate a random hash and land on somebody's stash of bitcoin, too.
00:07:52.878 - 00:07:53.834, Speaker E: Yeah, exactly.
00:07:54.574 - 00:08:00.634, Speaker B: So, actually, I have often aside here, do you know why they are called Biggie and Victor, especially for you, Imran?
00:08:00.974 - 00:08:02.194, Speaker C: I don't know, actually.
00:08:02.954 - 00:08:21.574, Speaker B: Okay. Mathematicians are nerds, right? So, like, they want to use real names that relates to the actual thing. So Peggy starts with a p for proverbs. Welcome to the nerd party, guys.
00:08:22.514 - 00:08:24.882, Speaker C: Gotcha. Gotcha. That's great.
00:08:25.058 - 00:08:33.750, Speaker A: So we have a high level understanding of, like, what this could enable. Right. Being able to share information without revealing the underlying data.
00:08:33.822 - 00:08:34.434, Speaker D: Right.
00:08:34.814 - 00:08:39.518, Speaker A: What are things that it can enable? What are we thinking about here in terms of startups?
00:08:39.606 - 00:08:47.446, Speaker C: Well, I think. Do you want to talk about how we went from this sort of basic thing to something that's more general?
00:08:47.630 - 00:08:51.782, Speaker A: Yeah, maybe general. And then we could talk about what it can bring out to the market.
00:08:51.878 - 00:08:52.670, Speaker D: Right? Yeah.
00:08:52.702 - 00:09:33.544, Speaker C: So that example was a very specific ZK proof, and for a long time we didn't have a general way to be able to prove any statement about the world. So for a long time, the holy grail was to be able to prove, like, with any function f. Like, I know something that goes into the function f that produces this output, y for any f. And I guess for a long time. Well, okay, so at some point they found a problem that's NP complete, called like, the r1 cs, the rank one constraint system of polynomials.
00:09:33.624 - 00:09:42.124, Speaker E: You were debating in your head whether or not you should go into this. I can tell why you hesitated. This is a whole new rabbit hole.
00:09:44.264 - 00:09:59.924, Speaker C: We'Re going to jump through because I can't explain it well enough, but there is this set of problems called the rank one constraint system, like a polynomial, where you have to, like, find integer solutions to it in like a mod prime field.
00:10:00.084 - 00:10:04.064, Speaker E: Imran is lost. Go ahead, I'm still following so far.
00:10:05.124 - 00:10:17.544, Speaker B: I read this, and it took me a while to, like, understand what is the field actually, to begin with, and, like, what the movie feels like. This is like, probably Imran and like, anyone, like, what the heck is that?
00:10:17.924 - 00:10:21.712, Speaker C: Yeah, I'm just gonna show like a visual. Just a visual. Right. Visuals are great.
00:10:21.828 - 00:10:24.504, Speaker E: This is first year honor grad math.
00:10:24.544 - 00:10:42.484, Speaker C: Course, by the way. Yeah, so this is a rank one constraint system. So you have these x's that add together to get other things. You can multiply them to get some other things. And all these things are integers.
00:10:44.584 - 00:10:44.896, Speaker D: That.
00:10:44.920 - 00:11:02.034, Speaker C: Are smaller than some p, which is a prime. And, you know, in practice it looks, you know, some, something like that. You know, you have these lots of x's and they add up and they multiply and they equal to other things. So that's just how it looks, right? It doesn't matter.
00:11:03.174 - 00:11:06.914, Speaker E: Imran was hoping for visualization, but you give him a bunch of.
00:11:09.254 - 00:11:10.750, Speaker C: You made it worse, David.
00:11:10.942 - 00:11:17.082, Speaker A: Yeah, no, this was. I mean, I got the concept, but yeah, it was still, like, we're trying to.
00:11:17.098 - 00:11:19.214, Speaker B: Just to shake your confidence, like, you.
00:11:22.874 - 00:12:00.106, Speaker C: This turns out that this problem. I mean, this function has nice properties that we're not going to go into. And people can prove, they have a way to prove that they know a solution to this without revealing what the solution actually is. And it turns out that this problem is NP complete, and every other np complete problem can be translated into this one. So that's why this is useful, because you can translate any sort of function that you want to come up with. There's like an easy way to translate to this problem, and then this problem has a way to generate a ZK proof.
00:12:00.170 - 00:12:39.748, Speaker B: So can I, can I try to rephrase this in more language? So the idea here is that you can take a general problem that you need to prove, like running a code. If you are running a code, how can you prove that this code has run right or not? That's a really hard problem. So the trick actually, or the magic trick, is to convert this general kind of problem into a mathematical representation that you can actually work on paper to find the solution. So what the R one Cs system is, it's a mathematical representation that can be solved mathematically to show that we have good probability that I can do something without cheating.
00:12:39.916 - 00:12:40.484, Speaker D: Right.
00:12:40.604 - 00:13:03.708, Speaker B: The trick here is that this r1 cs is so easy that you can actually convert it, convert any problem to it. You can prove that you have run some code by representing it. In R one cs, you can prove identity, which is harder to prove, but you can convert it again to r one cs. And once you get there, the rest is just math. So the trick is this conversion step.
00:13:03.796 - 00:13:05.044, Speaker D: Is that accurate enough?
00:13:05.084 - 00:13:31.776, Speaker C: David, there's like different ways of converting a general problem to this r1 cs, and I think those are called arithmetizations. And that's why you'll see in ZK proving systems there's different languages and different arithmetizations, and they all have different properties that ultimately will, you might have to balance out when building an app.
00:13:31.960 - 00:13:56.656, Speaker B: Yeah, just for completeness here, R one Cs was kind of one of the first, but now actually major protocols don't use it anymore. Like there is starknet uses something like called ethereum for the data. Blobs will use something called KZG. So like, there are different approaches of this, but r1 Cs was kind of the first, or like the easiest to start with.
00:13:56.720 - 00:14:05.442, Speaker E: I suppose it's probably not clear enough what r one Cs is to most of the audience. Is it a polynomial function that you can solve?
00:14:05.578 - 00:14:06.946, Speaker D: Yes. Okay.
00:14:07.050 - 00:14:10.506, Speaker E: I think most people understand polynomials, right? Or.
00:14:10.530 - 00:14:11.682, Speaker D: No, I'm sure.
00:14:11.818 - 00:14:36.682, Speaker A: Or we can go deeper into that. But you know, before we go to polynomials, you know, we need to like bring it down a little bit lower, right. In regards to what it was, rc one s, one cs, I don't even know it. See, so I probably represent the average audience. So let's just put it that way. So is this the math behind what makes zero knowledge proofs work?
00:14:36.778 - 00:14:39.378, Speaker D: Is that the idea? Yeah. Okay.
00:14:39.506 - 00:14:54.070, Speaker A: And why is this important now? Why are we discussing this now? Is this like, are we laying down the foundation for what types of math we're using moving forward for how we prove out different systems, like on Ethereum and others?
00:14:54.202 - 00:15:13.182, Speaker B: It actually may be good to go slightly into history, like why this actually came to this space. And I think most people were initially interested in the privacy aspect of this kind of math, that you can prove something without revealing it. And the first actually project that got used that it was zcash.
00:15:13.278 - 00:15:13.606, Speaker D: Right?
00:15:13.670 - 00:16:07.034, Speaker B: Zcash wanted to implement private payments using blocky chain. Blocky chains are great, bitcoin was great, but everything is transparent. Everyone sees that this address, send this address, this amount, right. And this is necessary for the network as a whole to come to consensus that this person actually has amount of money so they can spend it to someone else. So all of a sudden, like the idea of zero knowledge to prove that you have some asset and you can spend it without revealing how much asset you have or without even revealing who do you spend, who are you sending this amount to? Or even without revealing how much money you will send, are you sending the whole balance, half of it, a part of it. So Zcash came with this idea that you can prove some computation. This computation, I have 100 tokens, I want to spend 50 to another address without anyone on the network knowing what the details.
00:16:07.034 - 00:16:28.548, Speaker B: But everyone can know one fact, that this transaction is valid, that I had this balance, I can spend part of it and I can send it to this address. So that is the story that what started actually brought this moon math into our world, which is blockage chain that you can prove this computation without revealing the details. And Zcash actually started with, with that.
00:16:28.636 - 00:16:30.652, Speaker D: And from there that opens the door.
00:16:30.708 - 00:16:40.676, Speaker B: So me so to so many applications after that. Like we will probably dive into this application in detail. But the most major application now by far is rollups.
00:16:40.820 - 00:16:41.428, Speaker C: Yeah.
00:16:41.556 - 00:17:00.952, Speaker B: Which for the fun fit doesn't use any privacy. So like it's at all, you don't use privacy. But we are seeing more applications that use privacy like identity and bridges and stuff like that. So we will touch on that. But I just wanted to give a brief history why we care for that. Okay, David, you can go.
00:17:01.088 - 00:17:45.460, Speaker C: Another thing to add is that in 2016, when Zcash came along, they had to improve and build the tools and do some math to even be able to get this into production. And over the years, as these tools and things got more standardized, it is now kind of possible for generalists like me to do something with ZK. Maybe even one or two years ago, there wouldn't have been the tools for me to come in and do anything with it. So that's why it's interesting now, because more and more people, exponentially more people can actually play around with these tools.
00:17:45.572 - 00:17:50.940, Speaker B: So would it be fair actually to say that web three or crypto led actually to the development of ZK?
00:17:51.092 - 00:17:57.956, Speaker C: Absolutely. Yeah. It's a lot of, like, the, you know, the blockchain uses that pushed the development of this stuff.
00:17:58.060 - 00:18:14.472, Speaker B: So because I always consider ZK as a web three technology, which some people disagree with, they're saying, no, that's a general technology. It was existed before wayward three. I think most of the interesting adventures in Ziki happened when you actually started monetizing this technology. Right?
00:18:14.608 - 00:18:14.880, Speaker D: Yeah.
00:18:14.912 - 00:18:19.848, Speaker B: And people started, oh, there is money to be made in here, so let's develop this further. Right?
00:18:19.976 - 00:18:38.510, Speaker C: Yeah, I think, like, crypto used to be like, oh, about privacy and stuff, and then the word crypto got, like, taken away from the cryptographers, and crypto meant, like, oh, blockchain. Right. But with the ZK stuff, like, I think the word crypto kind of got back into where it belongs.
00:18:38.662 - 00:18:39.430, Speaker D: Very interesting.
00:18:39.462 - 00:18:40.958, Speaker B: Yeah, I feel like a lot of.
00:18:40.966 - 00:18:42.638, Speaker A: The funding also helped.
00:18:42.686 - 00:18:43.038, Speaker D: Right.
00:18:43.126 - 00:18:51.394, Speaker A: So VC funding into, like, starkware and others, that helped push the development of some of the ZK proving systems, starting with zcash.
00:18:51.894 - 00:19:16.870, Speaker B: So I remember vaguely, like, there was a really intense debate in Twitter when people called it, like, crypto Twitter. And people, like, were, like, cryptographers were, like, really offended by saying that crypto is not a word for, like, shitcoins, it's a word for cryptography, which is like, a very disciplined science that is only being done in prestigious schools like Harvard and MIT and stuff like that.
00:19:17.022 - 00:19:56.930, Speaker E: David, so about what you said earlier, that sometime during the last one or two years, people finally are able to do something with this technology. Generalists are finally able to do something with this technology. I've observed two trends. One is that people are overestimating how much you can do now, because everyone just slaps the word ZK into their project nowadays. Nowadays, it's all ZK and AI. It's ridiculous. So, number one, people are overestimating how much you can do with ZK, but two, people are underestimating how fast the rate of change is happening in the ZK space, because one or two years ago, this thing was not even possible for generalists.
00:19:56.930 - 00:20:10.396, Speaker E: But now you can do stuff with it. You can build some basic identity stuff. So the thing I'm most curious about is, what is the actual current state of things? What is practical today? What is realistic today?
00:20:10.540 - 00:20:10.908, Speaker D: Yeah.
00:20:10.956 - 00:20:54.788, Speaker C: So I just came back from a class offered by Xerox ParC, and I'm definitely not at the forefront of this technology, but I can give, like some, I can repeat some of the statements they had. So, in terms of optimism, right. One number they gave was that this stuff was improving, like 32, 64 x per year. So every year you would be able to do create ZK proofs that are 64 times bigger. And that has been happening for the last four or five years. And that's an extremely fast rate of improvement. But at the same time, this rate of improvement is, it's really at the edge.
00:20:54.788 - 00:21:43.602, Speaker C: People are working on things like ZKML, you know, that's like a lot of computation to put into a ZK proof, but it's like, for very specific things. And they have to do a lot of research and optimize problem specific optimizations just to get that thing working. So the progress is not uniform. You can't summarize all of it in one number, and there's different dimensions in which it. Which you characterize secret proofs, too. Like, there's the time it takes to generate the proof, or the time it takes to verify the proof. The memory size and, like, the proof size and all these things will have to be balanced in order to fit, like, your applications, for example, if you want your proof to be verified on chain, it has to be small enough.
00:21:43.602 - 00:21:56.306, Speaker C: It has to be, has to run fast enough. But if you don't need that, then you can, like, you know, have those things be bigger, but like, have the proverb be run faster. So if it's like a in browser application.
00:21:56.450 - 00:22:06.698, Speaker A: So should we kind of dive deeper into the proving types of proving systems that are available that give you the trade offs that builders need? Like there's airstar, pickles, starks.
00:22:06.826 - 00:22:07.274, Speaker D: Yeah.
00:22:07.354 - 00:22:55.434, Speaker C: To be honest, I don't have a good sense of what are the trade offs that each proving system will give. But I can give an example of something that seems easy, but turns out to be pretty hard. So let's say I want to prove that I own an address on Ethereum that is part of a group with a normal computer. You do that in milliseconds, you say you generate a private key, you get the address out of it, and then you check if that address is part of this group. It takes like one millisecond, I don't know, something like that. Right. But right now, the fastest way to do that takes around 40 seconds on consumer hardware, like on my laptop.
00:22:55.514 - 00:23:06.998, Speaker E: You mean proving that your address belongs to certain list of addresses without revealing your address itself? This thing using ZKP takes 40 seconds to generate the proof?
00:23:07.086 - 00:23:07.846, Speaker D: That's right.
00:23:07.990 - 00:23:13.598, Speaker C: And that's like the optimized. And that's like stuff that came out within the last year.
00:23:13.686 - 00:23:14.198, Speaker D: Right?
00:23:14.326 - 00:23:24.174, Speaker B: Okay, so this is what they call inclusion proof. That your proof, is it that your address is part of a group or included in a group? Is that, is that correct?
00:23:24.294 - 00:23:26.302, Speaker C: You can call it inclusion proof, I don't mind.
00:23:26.398 - 00:23:58.522, Speaker B: Okay, yeah, like, so just to prove something simple as that, like that my address maybe owns like an app. Like you can do this very quickly if everything is transparent and you don't need to prove it. But if you want to prove it, then it will take a while, right? You have a list of all the addresses who have an app, and you don't want to reveal your address, but you just want to prove that you have an ape. This task alone will take 40 seconds to prove. How much time will it take to verify on a chain, if you want.
00:23:58.538 - 00:24:49.614, Speaker C: To verify it much faster, like on the order of a second or something on consumer hardware, not, I think, less than a second on consumer hardware. So one of the application of this. So if you've heard of Noun Dao, one of their funded apps is called heya noun. And what you can do is like if you own one of these noun nfts, you're able to post a message into that forum anonymously. So on your computer, you will generate a proof that you belong to that group. And the server will, like, nobody else will know who posted that message, but it will be posted on hey. And now the group that enabled this is Persona labs, and they're the one that really optimized this specific ZK proof.
00:24:50.314 - 00:24:53.990, Speaker E: And it takes 40 seconds on a consumer computer.
00:24:54.142 - 00:25:26.262, Speaker C: Okay, there's a little start. So it takes 40 seconds if the group of addresses have never sent a transaction. So it turns out if you want to prove that your public key belongs to a group of addresses, like Ethereum addresses, it takes 40 seconds. But if you want to prove that your public key belongs to a group of private public keys, not addresses, public keys, then it takes about 4 seconds.
00:25:26.358 - 00:25:26.822, Speaker D: Okay?
00:25:26.878 - 00:25:46.754, Speaker B: So the first time, kind of to post a message is like 40 seconds because you are proving that your address is part of the larger Ethereum set or set of Ethereum addresses. But next time, second time, because you already published something on this high anime, it takes only 4 seconds because you just need to prove that you are one of these private keys.
00:25:48.294 - 00:26:30.534, Speaker C: There's a difference between an address and a public key, okay? Because like once you've posted a transaction, then your public key becomes, is revealed to the world. And it just turns out that the math, the ZK math that translates between a public key and an address just takes a lot more work. So it's kind of hard, like if you, as an outsider, it's hard to tell what is going to take a lot of time because all of the inclusion and the elliptic curve stuff takes 4 seconds, and then you have that other 36 seconds. That's just to turn the public key into an address.
00:26:31.194 - 00:27:05.814, Speaker B: I can give a little bit more light into that. Actually, some of the operations that can be done very, very easily on hardware are really, really hard to do in ZK, and the opposite is true. So for example, multiplication and addition, this used to be kind of complex for hardware. Hardware can take a little bit of time to do. But in ZK math, multiplication and additions are piece of cake. Like you really can do it very quickly. Something like that can be done very efficiently in hardware are logic operations and or xors.
00:27:05.814 - 00:27:23.054, Speaker B: You know this chao, right, this, like when you take single bits and then you add undo and or logical operation on them. This bitwise operations are really efficient in hardware, but they are really, really annoying when you want to do a zero knowledge proofs.
00:27:23.754 - 00:27:29.754, Speaker E: When you say hardware, do you mean something like ASIC, FPGA or even single transistor?
00:27:29.834 - 00:28:17.032, Speaker B: Like single transistors? Like not even. You don't need a very complicated circuit to do this bitwise operations and, and, or the literary gates. So these are very simple primitive hardware and, and or, and they are the most efficient elements that you can do in hardware. But to prove them in Zkmat, it takes a lot of effort and time and like really takes a lot of computation. And back to David's point, there are simple operations that you can do in, in compute that you, oh, this will be easy to do in ZK. It's not like ZK is very good for multiplication and addition, really bad for other stuff. Digital signature, for example, when you sign a message on Ethereum or bitcoin, depending on the type of digital signature, this signature can be efficient for ZK or not.
00:28:17.032 - 00:28:20.752, Speaker B: And this is actually one of the areas that have evolved a lot over the last few years.
00:28:20.848 - 00:29:05.704, Speaker C: Yeah, it's ultimately like the hash function that Ethereum chose at the beginning turned out to not be ZK friendly. The hash it chose is the ketchak 256, like the weirdest word. But because Ethereum was built prior to all this ZK stuff, it turned out to be a bad hash function for ZK. Just to give an order of magnitude of how much it takes from normal computation to ZK computation, the number that I kind of hear is on the low end it's about 100,000 x, and on the high end it's like 100 million x.
00:29:06.364 - 00:29:23.986, Speaker B: So, yeah, you give an example. You said, like, if you want to do what I call the inclusion in set proof in computation, that will take one millisecond. But if you are doing in ZK, it takes 40 seconds. So divide 40 seconds by one millisecond, that's a 40,000 multiplier.
00:29:24.090 - 00:29:24.810, Speaker D: Right.
00:29:25.002 - 00:29:28.786, Speaker C: And that's like, on the low end, because it was optimized. Yeah.
00:29:28.890 - 00:29:29.578, Speaker B: Okay.
00:29:29.706 - 00:29:42.858, Speaker C: On the high end, you have like these general, like these general, naive translation of general compute to ZK compute. Then you get like this, 100 million x.
00:29:42.946 - 00:29:43.362, Speaker D: Right?
00:29:43.458 - 00:30:09.324, Speaker E: Wait, so speaking of the computational efficiency, does it even make sense to build hardware accelerators for ZK proofs today? Because what I'm hearing is zero knowledge proofs are extremely specialized today. Like, they need to tweak that proof for a specific problem. But then if you try to build a hardware accelerator, can it even be generalizable enough? Am I thinking this right? Like, is this a right problem to think about or. No.
00:30:09.444 - 00:30:38.794, Speaker C: So definitely not a specialist in general, like, getting things into the GPU, which is like a general compute, will give you like an, like a speed of 100 x. And it's not like 100 x is not, does not solve everything. So there still needs to be like algorithmic improvements to get things working. But it is a 100 x that you can get at some point whenever, you know, you feel like investing the time in.
00:30:39.374 - 00:31:11.710, Speaker B: So, like, how do. It is my specialty. So, like, I can kinda dive deeper into that. So zero knowledge proofs are like, have to be optimized on both software and hardware. So I would just. Software is what people are doing. So, Branova, all these people are optimizing, really, the software and the libraries, how to build libraries that are fast on the hardware, like, it boils down that this old proofing systems that people are creating since growth 16 and like, even the new ones like stars and Halo or whatever, like that, and blanc and all this.
00:31:11.710 - 00:31:52.702, Speaker B: Algorithms depend on two basic mathematical operations. One is called numerical theoretical numerical transfer, or like, or we would call it fully transformed. That's to make it simple, fast, fully transformed. And the other one is called multiscalar multiplication msms. So there are, let's say there are two operations. One, like these two operations can be actually really optimized by hardware, because you need, especially for transform, they can be parallelized, you can have multiple components, more components do the same thing. In a GPU, you have some of them, you have 100, but in specialized, you can put a thousand on the same chip area.
00:31:52.702 - 00:33:04.060, Speaker B: So you can actually have more of the components you need and have less of the components you don't need often. So the whole idea about acceleration is that on the hardware level, you don't put everything, you don't bought a general processor, you don't put even a GPU, you just put specialized hardware component from the components that you need the most. And this tend to be like fully transforming engines and memory you need for proofing systems, you need a ton of memory, you need like terabytes of memory sometimes. See, if you create a specific ASIC, or like a specialized ASIC for proofs, you can have a lot of memory and a lot of FFT engine that can give you between ten x to 100 x. But given that threshold, that was a barrier that we need to climb. It's the barrier in David's term is four orders of magnitude 10,000 times, or you said 100,000, right, David? So that's five orders of magnitude. So from five orders magnitude, you can take only two orders by hardware, you still have three orders of magnitude, or 1000 multipliers that you need to figure out by other methods, which is software optimization, improving the algorithm itself, stuff like that.
00:33:04.172 - 00:33:27.184, Speaker A: So maybe going back to your nouns dao idea where they're verifying identity. So it seems like this is primarily a gateway for proving identity without revealing either your assets, your net worth, what are some of the applications, do you think that could come out of identity? ZK identity. And I know chow always throughout the startup, which is like a tinder for net worth.
00:33:29.214 - 00:33:30.806, Speaker B: I was going to say API.
00:33:30.990 - 00:33:46.634, Speaker A: And so maybe we can talk about, I think we could dive deep into many areas, but the first one I think is identity, which I think could be pretty big Kycml for exchanges as an example, tinder for net worth, et cetera.
00:33:47.094 - 00:33:47.494, Speaker D: Yeah.
00:33:47.534 - 00:34:19.374, Speaker C: So the way you would do Tinder with net worth, with crypto net worth, right now, you would gather all of the addresses that have high net worth and you just build the list. And anybody could verify that. You could say, okay, yeah, check this address, look at their on chain assets, has like a million dollars. I don't know if that's enough for you, 1 million. And you can generate a ZK proof that you own this address. And that would be where you would send that to your match on Tinder and be like, hey, look, I'm rich.
00:34:20.914 - 00:34:39.820, Speaker E: Okay, so in this method, you precompile a list of high net worth addresses, and then you prove that you belong to the address. What about an alternative way where you just look at the balance in this address and try to prove that this balance is above certain threshold? Is that even practical? Realistic.
00:34:39.852 - 00:34:40.428, Speaker D: Today.
00:34:40.596 - 00:35:01.098, Speaker C: So that goes into zkevms or state proofing. So there's a startup called succinct. No, sorry, Axiom xyz that wants to generate ZK proofs on any state of any function, on any state of an eVM.
00:35:01.226 - 00:35:03.186, Speaker A: And do they do this automatically or is this.
00:35:03.330 - 00:35:04.698, Speaker C: What do you mean by automatically?
00:35:04.826 - 00:35:14.498, Speaker A: Meaning do they precompile all of the state that's ready within axiom? So if somebody wants to pull some data, it's already readily available.
00:35:14.666 - 00:35:21.668, Speaker C: No, right now you probably have to work with them to write some sort of proof for it. Okay.
00:35:21.756 - 00:35:50.674, Speaker B: They have actually a public demo on their website that you can prove some features like the age of the address. Like is this, is this address new? Has transacted since like one year, five years. So they have actually implemented a circuit that can prove that using, from there maybe also how much you transact or how much you want something like that. But like it's not general yet. You cannot prove everything that you, you cannot get an arbitrary proof for whatever function you need.
00:35:50.714 - 00:35:52.722, Speaker C: There is, there's still some work that.
00:35:52.738 - 00:35:53.634, Speaker A: Needs to be done to get there.
00:35:53.674 - 00:35:56.066, Speaker B: Yeah, yeah.
00:35:56.090 - 00:36:01.482, Speaker C: They're making it easier for, for somebody to come in and like take a new state and use that as a proof.
00:36:01.538 - 00:36:01.962, Speaker D: Yeah.
00:36:02.058 - 00:36:04.370, Speaker E: Do you have a sense of how long it takes to generate that proof?
00:36:04.442 - 00:36:10.426, Speaker C: The one that, like the way you said about proving net worth, both the.
00:36:10.450 - 00:36:16.334, Speaker E: Axiom, the axiom way, and also the your way, which is checking that an address belongs to a list.
00:36:16.454 - 00:36:16.782, Speaker D: Right.
00:36:16.838 - 00:36:35.926, Speaker C: So checking an address we talked about earlier, which is either 4 seconds or 40 seconds on consumer hardware, once you have compiled the list, so you know you have to like, somebody has to like compile the list first and the other way, I don't have a, I can't say what it.
00:36:35.950 - 00:36:58.982, Speaker B: So like for that part, they do the proof on their servers and you have only, you can do only an API call to their servers. So like you, you can get a response within like maybe 30 seconds. But that's not a clear indication of how much of that actually the times you use to do generate a proof, but it gives you an upper limit. Like it's not more than 30 seconds, it's a simple proof, kinda, for identity.
00:36:59.038 - 00:37:19.546, Speaker E: Proofs you don't need to generate a proof on a continuous basis, you just need to prove it once because it's an identity and it rarely changes, right? Unlike the ZK roll up stuff where you have to generate proofs upon every block and shit like that. With identity, even if it takes 40 seconds to generate the proof, it's not that bad from a consumer point of view, right?
00:37:19.650 - 00:37:47.904, Speaker C: It depends. So like if you want the messages that you sign to be signed with your identity, with your group identity, then you need, you do need to make a proof every time because like if you just make a proof once, somebody could intercept that proof and reuse it to say like oh, I am part of this group. So in practice you do need to like sign new messages with that group identity to.
00:37:48.484 - 00:37:50.092, Speaker E: There's also a time component.
00:37:50.188 - 00:37:51.092, Speaker D: There's a time component.
00:37:51.108 - 00:38:01.550, Speaker E: You need to prove that you belong to that group at this point in time. But 5 seconds later things could change completely. So yeah, okay, you're right, it's a bad experience. 40 seconds to generate a proven good experience.
00:38:01.732 - 00:38:41.184, Speaker B: But like just to give context, like when Zcash started for you to send a simple transaction like just as a shielded transaction back then, it took actually 60 seconds on your computer to generate the signature. But with some improvement on the hash functions and the proofing mechanism, they got this to 2 seconds, right? So like this kind of, to David's point, like you can actually improve like by 40 x or 50 x or what's in one year. So yes, what can take 40 seconds this year maybe become a couple seconds in a couple of years? It's not out of the realm of possibilities.
00:38:41.484 - 00:38:53.744, Speaker C: I would say that most addresses have sent out a transaction. So you can use the other version, the public key version of that group inclusion algorithm, which is like 4 seconds.
00:38:55.144 - 00:39:02.592, Speaker A: So identity is one. What are some others? And then we, yeah, I mean there's a bunch of lists that we made, but like I'm curious on like some.
00:39:02.608 - 00:40:08.802, Speaker B: Of the, let's start with the list and then maybe a few to discuss. Like as we mentioned, the most obvious application is roll ups. But actually let's generalize roll ups of a chain compute that you can take the compute that you are doing today on a chain, which costs a lot of gas and a lot of congestion on a chain, and take all of this compute and execute off a chain, and then generate a proof for this off chain compute and bring and validate only the proof on each chain. So I would say off each in compute is one big one, similar to that is, or like a subset of that is actually bridging between different blockages, which people call state proofs. State proof that I will prove that the state of blockchain one and generate a proof of it, and validate this proof on blockchain B. And then, or two, and then I can actually spend this or wrap, or create a wrap token that represents whatever happened on block. So NSYNC sovereign is building state proofs and they are really focused on bridging between the roll ups.
00:40:08.802 - 00:40:25.454, Speaker B: And again, back to the main starting of this, the whole thing, which is privacy, I think still we are not there yet in terms of privacy using ZK proofs. We have seen astic try and ZQ connect, which was trying just to hide assets.
00:40:26.554 - 00:40:36.298, Speaker A: Why is privacy, is it primarily regulatory, do you think? Or is it, is there, what are some of the reasons for privacy not being at scale?
00:40:36.386 - 00:41:17.148, Speaker B: Okay, obviously after tornado cash, it becomes a legal issue, right? Because people, if it's an open and permissionless, you are giving a tool for bad actor or malicious actors to loan their money and like ransomware and stuff like that. So, but let's, let's get over this. Let's say that you are actually using a permission list of actors. You, after you validate the identity, you give them access to this private pool of capital that can be done. And I still think like private ZK proofs are really step, still really hard. And that's what I will just use, a simple data point astic itself. The vision for Astic to begin with was to complete, to have a roll up.
00:41:17.236 - 00:41:18.412, Speaker D: A ZK square roll up.
00:41:18.468 - 00:41:26.012, Speaker B: A Zk Sql roll up means it's a ZK roll up. It's similar to everyone else, but it's also private. And the first iteration didn't work this way.
00:41:26.068 - 00:41:29.012, Speaker E: Did you say, did you say ZK squared roll up?
00:41:29.068 - 00:41:29.516, Speaker B: Yes.
00:41:29.620 - 00:41:34.724, Speaker E: So, privacy plus scalability, that's the squared, that's what you mean by squared.
00:41:34.764 - 00:42:06.558, Speaker B: Okay, yeah, so, yeah, it was a, it has a hype term, actually, because the term is z. Yeah, actually. Like it was like a couple years back when they came out of this term. But with this goal, when they launched the first version, Astic couldn't do both. They could do some kind of it, which means that they could do scalability because they are, they grow up and on the privacy, they couldn't do much functionality. They just had transfers. I can transfer from my address to this address.
00:42:06.686 - 00:42:07.382, Speaker C: That's it.
00:42:07.478 - 00:42:10.662, Speaker B: You couldn't do much, you couldn't do programmable stuff.
00:42:10.798 - 00:42:13.554, Speaker A: You're talking like ZK money or shielded transactions, right?
00:42:14.734 - 00:42:16.294, Speaker B: Yes, shielded transaction.
00:42:16.414 - 00:42:20.238, Speaker E: You couldn't do these things because the proof is too expensive or too long.
00:42:20.286 - 00:42:41.920, Speaker B: Too generate, because scalability is easier. Like the. Actually, it's okay, let's do a disclosure. When we use the term ZK for scalability, that's abuse. Okay? That's overuse. Okay? Scalability solutions have nothing to do with zero knowledge. They are just using the one element of this technology, which is called succinctness.
00:42:41.920 - 00:43:18.380, Speaker B: You compress stuff, okay? Yeah, but we are just using ZK for scalability now. Okay? Just this disclosure, if you go out, if you want actual ZK, which means that you have to deal with private information and private details. This actually complicates the math even further, and it makes it even harder to scale and make this functionality. And it limits one important aspect. It limits programmability. Once you go to privacy, you can prove that I own this asset and I can transfer it. But it becomes way harder to have a global private state.
00:43:18.380 - 00:43:45.130, Speaker B: What's a global private state? Let's assume that you have a uniswap pool, right? A Uniswap pool is a shared state. All of us can see it and all of us can change it, right? By executing trades against the pool. The pool has some USDC, for example, and some ETH. Now we need to keep this private. And then anyone can come and execute trade against this pool and change it. And this exchange has to be private. Now this becomes a way bigger problem.
00:43:45.130 - 00:44:29.950, Speaker B: You are not just changing your own state like payments, you are, you are changing a global state. And this is a bigger and more complicated problem. There are like courageous team out there trying to solve this penumbra, like renegade railgun, like, there are people who are trying to do this, but it's still harder problems. That's why if you want to create a ZK squared roll up, a roll up that is do both scalability and privacy. It's a massive task. And that's why Aztec themselves said we cannot do this while we are maintaining ZK money. So let's shut ZK money down and let's focus all our resources, all our team efforts into creating this new paradigm where we have this k ZK squared roll up.
00:44:29.950 - 00:44:36.854, Speaker B: So privacy is still hard. That's why I still think it's not solved yet. No one has kind of figured it out yet.
00:44:36.974 - 00:44:51.684, Speaker A: I've seen some iterations of this for wallets. I forgot the name of the startup, but what they do is they take your assets and then they put it into some sort of like vault that has its own like assets where you can trade in and out of.
00:44:51.724 - 00:44:54.908, Speaker C: Do you remember that sort of nocturne?
00:44:55.036 - 00:45:08.820, Speaker A: Yeah, nocturne. So there are some interesting implementations of privacy, but I feel like that it isn't like ZK native per se, like, you know, ZK money and others. It's more like using it as an off chain type of compute.
00:45:08.892 - 00:45:28.284, Speaker E: So it's not a coincidence that the Zcash people have been talking about working on smart contracts for Zcash, but they never managed to do it because it's really difficult. So far they've only done zero knowledge proofs for basic transfers. But if you want to support smart contract functionality with privacy, has anyone done it?
00:45:28.364 - 00:45:38.624, Speaker B: Aleo is working on it. Alio is another l one, private l one that their goal is to allow both privacy and the programmability. So like you have private smart contract.
00:45:38.964 - 00:45:53.724, Speaker E: Okay, so Aleo is trying to do two of the three, which is privacy smart contract. But then previously Aztec was trying to do three things, which is privacy, smart contracts and scalability becoming a layer two becoming.
00:45:53.804 - 00:46:40.388, Speaker B: Yeah, becoming building. And by the way, building Ethereum is an issue. It's on. That's why because Ethereum use the account model which is harder to deal with when you are doing privacy. That's why Zcash, and even by the way, astic the new direction, they are using a hybrid model like Utxos or like the unspent transaction outputs model which is used by bitcoin is more similar to use when it comes to privacy. That's why by the way, Zcash is also a Utxo based system. And many protocols that are attacking privacy are also trying to build on Utxo, but they create a hybrid that you have actually both systems, Utxo and account based, and you can switch between both.
00:46:40.388 - 00:46:47.556, Speaker B: And I think that is a direction that Findora tried first and I think Astec is trying to move in the same direction.
00:46:47.660 - 00:46:53.944, Speaker E: So identity scaling and privacy. Is there anything else, or should we dive deeper into?
00:46:56.924 - 00:47:00.716, Speaker A: I mean, I think there are some. We did talk about bridging a bit, too.
00:47:00.860 - 00:47:05.984, Speaker B: Like, the only problem that ZK cannot solve is Ux. So sorry, you cannot solve ux for you.
00:47:06.644 - 00:47:15.268, Speaker E: For me, bridging is a special type of off chain compute, because you're looking at a different chain, which by definition is off chain from your chain.
00:47:15.316 - 00:47:15.788, Speaker D: Right?
00:47:15.916 - 00:47:16.596, Speaker B: Yeah, yeah.
00:47:16.660 - 00:47:24.825, Speaker E: Like for me, Zkrollup, ZKML, in the case of modulus or ZK bridges, these are all special types of off chain computer.
00:47:24.825 - 00:47:25.762, Speaker D: Yeah, agree.
00:47:25.938 - 00:47:36.434, Speaker C: ZK bridges are not, I think, like, it's pretty established now. Like, there are ways to pass messages around. But the only problem with ZK bridges is that they're expensive.
00:47:36.594 - 00:47:37.154, Speaker D: Right?
00:47:37.274 - 00:47:55.694, Speaker C: Because you have to verify, because you have to verify a ZK proof on each side. And if you don't batch enough transactions in there, then you pay a big cost. And that's why a lot of bridges now are still not using it, even though it's like the most secure way of doing it. It's just cheaper to not use ZK.
00:47:55.814 - 00:48:37.660, Speaker B: Yeah, yeah. Another special type of offaching compute that I like, and I think it may find actually application even outside web three, is ZK functions. A ZK function is like when you define some computing that has to run, but you don't want to trust the operator, like you don't want to trust AWS to run this function for you, or trust Azure or whatever. So you give them the code to run and they run it for you, and they give the output of the function with a proof that the function has been run correctly. So I think the concept of ZK functions, of course, it will find the application first in web three, but I think the concept in general can be generalized to web two once we overcome the computational overhead problem.
00:48:37.812 - 00:48:56.324, Speaker E: But this is, what you said here is, it feels fundamentally at odds with what David, like said earlier, which is that ZK proofs are extremely specialized. But you're saying you can take any generic food, that you're saying you can take any generic function and do a generic proof on it.
00:48:56.784 - 00:48:57.744, Speaker D: Here's the trick.
00:48:57.864 - 00:49:02.504, Speaker B: Yeah, now you can, David, if you want to answer this, go for it.
00:49:02.624 - 00:49:29.842, Speaker C: So the way I understand your question is that, yes, it is possible. Like Huda is correct that it is possible. But to optimize, like, very specific applications of it, to make it practical, it's still very specialized. It depends on what you want to do. So if you just want like, generalized things, then you're going to get that hundred million, that 100 million x factor factor.
00:49:29.938 - 00:49:59.624, Speaker B: Yeah. So let me actually answer this more detailed, okay. You can today run any function and create a Zkubrew for it. And the trick here is that you don't create a specific circuit for this function. Instead you go build a virtual machine and you implement the circuit that executes the virtual machine. So we call it ZKVM. And this is a bigger umbrella that under it you have ZKE EVM, when you have this virtual machine, is specific to be compatible with EVM.
00:49:59.624 - 00:51:01.746, Speaker B: So there are so many projects today that actually offer you a generalized ZKVM. You have ZK wasm, you have obviously zkvm. And even risk Zero, which is a startup in this domain, they are creating a technology where you can write any code that complies to a certain architecture in computer architecture called RiSC five. Risk five is a certain architecture that you can compile programs to. And if you can write it to RISC five, they will take this code and create approve for it using, by building a ZkVM for risk zero for sorry, for risk five architecture. So the concept of ZkVm is very, very powerful because it implements a base computational layer that you can go and build any code on top it obviously because of this ease of use that it's very generic, anyone can use it, but it's not optimized. It can be, as David mentioned, it can be a hundred to 1000 x worse than going and implementing a specialized ZK circuit to do this functionality.
00:51:01.850 - 00:51:18.546, Speaker E: And fundamentally, there is a motivation for this, because there's a motivation for general ZKVM, because the EVM is very unfriendly to zero knowledge proofs. It makes proving and verification very expensive.
00:51:18.690 - 00:52:02.412, Speaker B: Yeah, it's very unfriendly that the most performant ZCO roll ups are not implementing ZKVM, sorry, Zke EvM natively. They went and built a different circuit completely that is not necessarily compatible with EVM. And they just use a translator layer or a translation layer to accept solidity code. So from the developer point of view, the developer doesn't know anything but writing the same solidity code. And it runs both in Ethereum native and on Zksync, for example. But ZK sync era in reality is not Zkevm compatible. Vitalik is a term for that which we use often between us, which is type four ZKVM.
00:52:02.508 - 00:52:04.516, Speaker A: And you're talking about the different equivalencies, right?
00:52:04.620 - 00:53:00.620, Speaker B: Yeah, that's like the topic of equivalency to how much are you compatible or relatively compatible to the ZKVM architecture? And some people are building that scroll, for example, like say, no, we want to be ZKV equivalent, not compatible like we want to be exactly like EVM. Other projects like Startnet and Zikisenk era are not natively compatible to like EVM. They build their own circuit and just, they are just trying to make it easy for developers to use this solidity, the same code. They don't want the developers to go and write new code. Of course, Zikisenk succeeded in that. Starknet is still trying because he has their own language, which is Cairo, and then Polygon ZkVM Polygon ZVM also uses a trick to convert, but it's, it's in, it's in between. It's not completely Zika sync era style or scroll style Fuda.
00:53:00.652 - 00:53:06.516, Speaker E: So a few months ago we wrote about a bunch of applications of ZK. I think we should critique it knowing.
00:53:06.540 - 00:53:08.252, Speaker D: What we know today in terms of.
00:53:08.308 - 00:53:11.210, Speaker E: What is exactly realistic and practical today.
00:53:11.322 - 00:53:12.202, Speaker D: Do you want to go through some.
00:53:12.218 - 00:53:41.438, Speaker B: Of the ideas, some of the ideas that I had with ZKML? It's not ZKMl in the sense that Modulus is doing. Modulus is building something that is very specific to web three, that if you want to do a functionality using machine learning as off a chain compute, you can do it off chain compute and verify it on a chain. Is that suitable for maybe smaller models, maybe models that in the tens of millions of parameters, not billions yet. One of the ideas that I had is that this concept can actually scale.
00:53:41.606 - 00:53:44.078, Speaker D: To web two, which means that now.
00:53:44.126 - 00:54:29.198, Speaker B: You connect to a chat GBT or you connect to OpenAI to run CHGPT and you trust OpenAI. Whatever output you come, you get, you trust them that they have run GPT four at the back end, or GBT 3.5 turbo, or whatever model they said they run for you. You have to trust them. You have no way to other than to trust them. Like one idea that I had that possibly in the future we can actually have OpenAI give you the output of the model along with a proof that they actually have run the model for you. But given what we know now that we still limited by the computation and like this five to eight orders of magnitude complexity, I don't think this is gonna happen anytime soon.
00:54:29.376 - 00:55:21.568, Speaker C: Yeah, I can give some colors on that front. So I heard about a project called Ezekiel, but it's written Ezkl Easy zero knowledge proof in ML. Anyways, Ezkl anyways, and they're like at the bleeding edge of trying to put ML into ZK proofs. And the approximate size that they seem to be at right now is like 2016 size ML models. So you can run some gans, you can run some simple, like, convolutional networks like that in ZK and prove the input or the output, or hide the weights and stuff like that. But that's like bleeding edge stuff. You can try to use that software.
00:55:21.568 - 00:55:27.520, Speaker C: If you get stuck, you'll have to message the guy who's working on it, the professor that's working on it.
00:55:27.632 - 00:55:27.936, Speaker B: Hold on.
00:55:27.960 - 00:55:31.896, Speaker E: So in that case, what is exactly the use case? What do you prove?
00:55:32.000 - 00:55:32.912, Speaker D: There's a few things you can do.
00:55:32.928 - 00:56:10.822, Speaker C: You can prove that something has run according to the algo that you wrote. That's the validity proof. You can offset the compute, somebody does it and then returns you the result and you can verify that the result was not tampered with. So that's like not zero knowledge, but it's like verifiable. Verifiable, yeah. You can also hide the input and say, I have a picture of a hot dog. I'm gonna have to show you the picture of the hot dog, but I can prove to you that it's a picture of hot dog according to this neural net.
00:56:10.958 - 00:56:11.634, Speaker D: Right.
00:56:13.374 - 00:56:16.782, Speaker C: Is that useful? Uh, okay, maybe not. I think that's a good question.
00:56:16.798 - 00:56:19.366, Speaker E: No, no, I think that's extremely useful. I don't know what it is.
00:56:19.430 - 00:56:19.950, Speaker B: Hold on.
00:56:20.022 - 00:56:21.006, Speaker E: I'm trying to think.
00:56:21.150 - 00:56:27.754, Speaker C: I'm really nudes. I'm trying to sell you nudes. Exactly.
00:56:28.094 - 00:56:34.966, Speaker E: Like I have a piece of information. I'm not going to tell you what, what it is. I know some piece of information that's really important about the world.
00:56:35.070 - 00:56:35.566, Speaker D: Yeah.
00:56:35.670 - 00:56:45.424, Speaker E: About what Putin wants to do next or something. And then I'm not going to tell you what it is, but I can prove to you that this will happen. I mean, that's. That feels extremely powerful.
00:56:45.544 - 00:56:47.884, Speaker C: Yes, yes, yes. Blackmailing.
00:56:49.784 - 00:57:01.136, Speaker B: That is the only use case that can come to mind. Like, I saw you, like, doing something you shouldn't be doing. So. And I have a proof of it and I will not show it to you. But you know what? You are doing something like that. Yeah.
00:57:01.280 - 00:57:19.526, Speaker E: Or like, if you have a piece of information you want to sell to a journalist, but you don't trust the other person, the two people don't. The two counterparties don't trust each other. And you want money first. Well, if the journalist also doesn't trust you. Why would they give you money for your information? Well, you can prove to the journalist that you're in the possession of that information.
00:57:19.670 - 00:57:20.134, Speaker D: Yeah.
00:57:20.214 - 00:57:24.514, Speaker E: And then they give you money, and then in exchange you give them the information.
00:57:25.214 - 00:57:48.692, Speaker B: For example, I think the complexity here is that the model have to be trained on a specific kind of information. Like if it's a computer vision model, it has to be trained for that. If it's like text based, like information, it has to, like, the complexity here is more in the machine learning side. And for each machine learning model, you will have to have its own specialized circuit to be efficient. So I think that is like still hard.
00:57:48.828 - 00:57:49.076, Speaker D: Yeah.
00:57:49.100 - 00:57:59.892, Speaker C: So Ezkl translates Pytorch models into ZK circuits. That's like the goal that becomes general.
00:57:59.988 - 00:58:06.764, Speaker B: It's similar to the z key. VM analogy by torch is kind of the basis for anyone who touches AI.
00:58:07.144 - 00:58:26.064, Speaker C: I wouldn't say it's general because it's all about matrix multiplication. So easy. Hill will have done a lot of optimizations for matrix, like recursive matrix multiplications. And the way they do that, I don't know, but it's specialized for ML.
00:58:26.184 - 00:58:45.690, Speaker B: I don't think they will have enough 100% coverage of all the functions or methods in Bytewatch. But if they can get to the majority of them, the stuff that can be used to describe like convolutional neural networks or something like that, I think they will cover actually pretty big ground of the machine learning models that can be implemented.
00:58:45.802 - 00:58:46.474, Speaker D: That's interesting.
00:58:46.514 - 00:58:49.122, Speaker B: I didn't, I didn't look into that before, so that's very interesting.
00:58:49.178 - 00:58:49.794, Speaker D: Yeah.
00:58:49.954 - 00:58:57.234, Speaker E: This is completely orthogonal to blockchain. Like, this has nothing to do with the blockchain. This is just pure ZK stuff.
00:58:57.354 - 00:58:59.614, Speaker D: Yeah, they are very.
00:59:00.364 - 00:59:05.732, Speaker C: Yeah, they're very complementary. But we can talk about like non blockchain things, right?
00:59:05.868 - 00:59:53.176, Speaker B: Yeah, non blockchain thing. I think one of the ideas that I still believe it's doable today and not very complicated, but no one is doing it for some reason, is authenticity of transformations of videos or images or stuff like that, that we agree that we can prove a video, the authenticity of a video or a picture by digital signature. Right. You create this podcast episode after it's edited, you Imran or you chow takes a full video, create a hash for the video, you sign it from your wallet down, the video to authentic. Now what if I won't just take 1 minute clip of this video and want to prove that this 1 minute video is indeed a subset of the original authentic video. There is no way to do this now. And I don't think the transformation or the code to do this transformation is so complex that it cannot be proven with DK.
00:59:53.176 - 01:00:14.368, Speaker B: But so far I have seen very few projects that are trying to do this, whether it's for audio or video or images. So. But I think this is still a low hanging fruit. And it has massive use cases within with three and outside with three. It's actually a web two use case, but no one is doing it that yet.
01:00:14.536 - 01:01:32.518, Speaker C: Yeah, that does seem like a lot of research work. So that's like for media, right? So let me give you an example of the same thing you said, but like for something else, right? Emails are signed and they're like. And if you trust the sign, like the signature that came from some DNS server is valid, then you can create a ZK proof about this email that you got and say something that is truthful and people will believe you. So another example of the net worth thing, you can have your bank send you a statement of your net worth, create a ZK proof hiding the actual net worth, hiding maybe some other details that you don't want to see, but the other person that receives this proof will see that, oh, bank of America has signed this message. And three, this number was larger than a million. That's with email. Another thing you can do is theoretically is have a ZK browser where everything that you receive from the web, web pages, stuff are signed.
01:01:32.518 - 01:02:11.108, Speaker C: And you could take all that data and generate statements about things that you see on the web. So you can, like if, if your, if your bank doesn't send you statements about your, your thing because like it, you know, it's unsecure, you could log into the bank website and from, from the HTTP requests, you could technically like find a subset of that, turn it into a ZK proof about whatever you want to say about yourself, right? You could say you own, you're the owner of, uh, of this anon account on Twitter. You can say things about your bank statement and you can do whatever, I.
01:02:11.116 - 01:02:12.020, Speaker B: Just want to be able to do.
01:02:12.052 - 01:02:18.544, Speaker E: All that KYC bullshit without having to download my bank statement every single time and reveal the money in my bank.
01:02:19.204 - 01:02:45.944, Speaker B: Or even something like blood. Blood is like, have to get connection to your bank account and you have the ability to see all your transactions, whatever you spend, just to get one information, which is a balance, because they want to do this deposit just by the balance. So like, can we have a company that creates a ZK blad that they only will get access to this piece of information. They don't see your whole transaction history by getting access to your bank account.
01:02:46.364 - 01:02:57.468, Speaker C: So the thing here is that, is that you do not need a plaid to prove about things like that anymore. Once the ZK infrastructure has been built, you can go and browse it yourself.
01:02:57.636 - 01:02:58.940, Speaker D: And create these decay proofs.
01:02:59.012 - 01:03:04.304, Speaker C: You're like eliminating the trusted party in the middle. Does that make sense?
01:03:04.884 - 01:03:06.412, Speaker B: It's perfect sense actually.
01:03:06.548 - 01:03:31.110, Speaker C: And also once you have generated this proof, this proof exists on its own. You don't need anybody to serve this proof or anything like that. It's a piece of document that can convince anybody of the statement that you made. You don't need an API to query, you don't need anything like that. So you can imagine it as like these pieces of information kind of floating around the web having truth statements about the world.
01:03:31.222 - 01:03:31.510, Speaker D: Yeah.
01:03:31.542 - 01:03:49.310, Speaker B: And this kind of proofs have an element of privacy as well because these proofs are verifiable as is, right. As a standalone proof, you don't need input on them. Like if they are true then proof something and that's it. So this is a very powerful concept. I think it has a name for it, right David?
01:03:49.342 - 01:04:17.598, Speaker C: Like well it doesn't have a name yet, but there is a project that is working on trying to standardize the production and distribution of these proofs so that people can plug into this system more easily. It's like a protocol for people to work together with these proofs more easily. And they call it the proof carrying data, a PCD. And it's another Xerox Parc endeavor.
01:04:17.726 - 01:04:38.142, Speaker B: So I think the use cases for this PCB is that they have way more use cases in width two in general than even with three because you can use it in everyday life, right? You can use a KYC financial transaction. There is a lot of use cases here. You can use it for Tinder, for high idea as well.
01:04:38.238 - 01:04:57.724, Speaker A: So I guess closing it out, there are incredible amount of startups that can build on some of the infrastructure that's being built with ZK. It seems like we're still in the early phases, right? Because proving times take, let's say 40 seconds and the infrastructure is still being built out from a developer perspective, right?
01:04:58.024 - 01:04:58.360, Speaker D: Yeah.
01:04:58.392 - 01:05:23.412, Speaker C: I would suggest although it is still performance is still a problem, it is possible for developers to come in and do something like proof of concepts. And once you have proof of concepts, you can go and talk to someone that's more specialized than you and they will work with you to optimize your circuits or anything like that. So the door is opening and now is the time to experiment.
01:05:23.548 - 01:05:24.196, Speaker D: Nice.
01:05:24.340 - 01:05:28.620, Speaker A: Well, any other final thoughts before we close out?
01:05:28.692 - 01:05:53.688, Speaker B: I have a thought that, and it comes back to my question to David. That z key is a native web three technology. The concept of web three is that you minimize trust between parties. And the first version for that was actually blocky chain. And it seemed that many people are like just tying the web three sector or this kind of technologies to block a chain. If it doesn't block a chain, it doesn't use crypto or something like that. And I disagree with that.
01:05:53.688 - 01:06:23.318, Speaker B: I think ZK is a prime example of this trend of web three that actually have way more implications outside web three. And if nothing comes from the web three other than the ZK technology, and that this sector has actually given birth and promoted develop this technology to the world, I will be happy with what web three have achieved. I still have high hopes beyond that. But kind of Ziki is our web three gift to the wallet, essentially. So this is kind of my high level folks.
01:06:23.406 - 01:06:26.554, Speaker C: I like it because it's less cryptic than blockchain.
01:06:28.894 - 01:06:34.550, Speaker B: Okay, this is like this sentence can be unpacked for a whole episode. Why? Why do you feel this way, David?
01:06:34.582 - 01:06:44.946, Speaker C: So, I mean, like blockchain has made it very easy to anybody to launch a coin and attract investors or people who are hoping for a. I'm sure.
01:06:44.970 - 01:06:47.106, Speaker B: ZK will allow many people to launch a coin as well.
01:06:47.130 - 01:06:48.506, Speaker C: Like, it's nice.
01:06:48.570 - 01:07:04.220, Speaker B: Is that easy for next time? So I feel that we have a lot more to say, but like, we are limited by time. Like, I feel like one and a half hour is still too little to discuss. So we need to do more episodes than ZK.
01:07:04.332 - 01:07:04.916, Speaker D: Agreed.
01:07:05.020 - 01:07:06.164, Speaker C: Well, ciao.
01:07:06.204 - 01:07:07.028, Speaker A: Any final thoughts?
01:07:07.116 - 01:07:11.584, Speaker E: I just think polynomials and primes are great. They're the most beautiful things in the world.
01:07:14.284 - 01:07:18.236, Speaker C: It's kind of a miracle that this has happened, but, you know, great.
01:07:18.340 - 01:07:32.624, Speaker A: For founders that are looking to learn more, feel free to check out our crypto ideas site on Alliance XYZ. Otherwise, we'll see you guys in the next episode. Thanks. Thanks for listening to good game. Don't forget to subscribe. We'll see you next week.
