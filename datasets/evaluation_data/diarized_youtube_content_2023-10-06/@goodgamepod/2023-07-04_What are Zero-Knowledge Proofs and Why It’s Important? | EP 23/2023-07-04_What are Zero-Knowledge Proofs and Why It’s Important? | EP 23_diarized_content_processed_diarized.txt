00:00:00.400 - 00:00:04.085, Speaker A: Welcome to GoodGame. Your no BS insights for crypto founders.
00:00:07.505 - 00:00:23.425, Speaker B: I always consider ZK as a Web3 technology, which some people disagree with saying, no, that's a general technology. It was existed before wayward 3. I think most of the interesting advantages in ZK happened when you actually started monetizing this technology. Right?
00:00:23.545 - 00:00:23.873, Speaker C: Yeah.
00:00:23.929 - 00:00:28.869, Speaker B: And people started, oh, there is money to be made in here, so let's develop this further. Right?
00:00:28.997 - 00:00:46.805, Speaker C: Yeah. I think like crypto used to be like, oh, about privacy and stuff. And then the word crypto got like taken away from the cryptographers and crypto meant like, oh, blockchain. Right. But with the ZK stuff, like, I think the word crypto kind of got back into where it belongs.
00:00:46.925 - 00:01:23.633, Speaker A: Looking for your next startup idea in crypto? Check out our request for Startups list and get inspired at Alliance XYZ or welcome to Good Game. Today we're going to be talking about zero knowledge proofs and some of the startups and ideas that we're seeing that could be brought to the market and some of the ideas that we think could be brought to the market in the next couple of years. We have David again from our team that's joining us along with Buddha and Chow. And so maybe I'll throw out a question to you guys, which is, what are zero knowledge proofs? And I know we've talked about this previously in some of our past episodes, but those that are newly tuning in, what are zero knowledge proofs and what do you think can bring to the market?
00:01:23.769 - 00:01:27.025, Speaker C: We're getting right in. No right in. No chit chats.
00:01:27.105 - 00:01:30.725, Speaker A: No chit chat. Unless you want to do some chit chat. I'm also open to that idea.
00:01:32.745 - 00:02:01.961, Speaker C: All right. Zero knowledge proofs. Succinctly, a zero knowledge proof is the ability to say a fact about something that you know without revealing the fact itself. And being able to convince another person that you know the fact let that sink in a little bit, Right. At first it seems kind of impossible, but there are actually a lot of easy ways that you can see out there in the world out there.
00:02:02.033 - 00:02:10.185, Speaker A: Sorry, why is this such a big problem to solve? Because obviously it took decades of research to get to where we are today with zero knowledge proofs. So why is this such a big deal?
00:02:10.305 - 00:02:38.103, Speaker C: It's a big deal because it's a technology that allows asymmetry between an attacker and a defender. You know, so like, there's a lot of technologies prior to this that are not asymmetric. Right. Like you, you discover fire, you discover guns, and then like it's very easy to destroy. Whereas, like, this is one of the technologies that allow you to defend easier than to attack. Right. And that's what makes it exciting.
00:02:38.239 - 00:03:06.895, Speaker B: Yeah, I can add some color to that. Like, the concept is not really new. The concept has been around like that you can do encryption to hide some information and like only one person would know. And the zero knowledge proof is that the concept of it, as David said, is that you can do something that is have private information, but the proof is public. So like anyone can prove in public what you know in private. And this is a different concept. Encryption doesn't do that.
00:03:06.895 - 00:03:27.951, Speaker B: On the technology development side, there was actually versions older than what we know in 2016, Zcash. But there are some features that were very new. These features are something like non interactivity. What is that? Like you can prove something like that. Like a zero knowledge if you are interactive. I ask a question, you answer this question. I ask another question, you answer again.
00:03:27.951 - 00:04:20.771, Speaker B: So this requires interaction between us. So and this can be done mathematically and but it requires both parties to be online at the same time. The new concept that came with zcash is an interactive component that we don't have to interact, we don't have to keep communicating. So this non interactive part was interesting because you can do the proof separately and then I can verify it later without us communicating at all. So this took a lot of kind of moon math to achieve. The other advantage I would say is that finding new ways to make this computationally possible, you can do this by many computations that will take a lot of computing power, a lot of time. The trick here is to make this competition smaller in size, more suitable for consumer hardware, for random, for people like us who have like desktops or whatever, who can do it.
00:04:20.771 - 00:04:32.175, Speaker B: So I think this what made it like take a long time to develop and funnily enough, like most of the development happened in the last, I would say five years or like now eight years since 2016.
00:04:32.795 - 00:04:36.379, Speaker A: Do we want to go down the rabbit hole of the moon math behind it?
00:04:36.467 - 00:04:44.291, Speaker C: Well, I think the moon math is definitely beyond the scope of this podcast. And my knowledge, I don't even know how to do it, but I can.
00:04:44.323 - 00:04:49.695, Speaker B: I think the best guy to touch on the math is like our mathematician. Ciao.
00:04:52.475 - 00:04:53.139, Speaker A: For Chow.
00:04:53.227 - 00:05:04.211, Speaker C: Good examples of like ZK proofs like without the math. Right. Just like to show the what the concepts are. And for that I have prepared some slides. So. Okay, let's. Let's do it.
00:05:04.211 - 00:05:35.293, Speaker C: So I think the most simple to understand is the Alibaba cave. Okay, so this is the slide that shows the Alibaba cave example. The problem setup goes like this. Peggy wants to prove to Victor that Peggy knows the secret code to this magic door. Right? So if you know the secret code of this magic door, the magic door can open, but if you don't, then it just does not open. Right, but. And Peggy wants to show that.
00:05:35.293 - 00:06:16.327, Speaker C: Sorry, Peggy wants to show Victor that she knows the code without revealing the code. So a zero knowledge proof of how this could happen is for Peggy to go into this cave. And this cave has this two paths that are connected by the magic door. And Peggy will choose either A or B and get stuck behind one of these paths. And then, and then shout out to Victor, hey, like you can come in. And then Victor would, would come into this area. And then Victor would say, please come out from path A or please come out from path B.
00:06:16.327 - 00:07:00.985, Speaker C: And since Peggy knows the code, she can go through the magic door and come out either by path A or path B. But if Peggy did not know the code to the magic door, then Peggy can only come out of either path A or path B, the one that she initially committed to. So this is an example of a ZK proof. And what a ZK proof does is three things. The first is if the person who knows the thing actually does know the thing, then they can always produce the correct answer, as in come out from A or B, whatever Victor chooses. If Peggy does not know the thing, then she cannot lie. She will get caught at some point.
00:07:00.985 - 00:07:22.965, Speaker C: And lastly, nothing is revealed to Victor. Victor doesn't know what the magic code is. So this is a very simple example of a ZK proof. And if you do this multiple, many, many, many times, then the chances that Peggy would never get caught if she does not know the the code approaches one.
00:07:23.465 - 00:07:42.681, Speaker D: So you actually brought up a really interesting point which people don't usually talk about, which is that the zero knowledge proof is actually a probabilistic proof. There is a small chance that you can cheat and provide the right proof. But if you do this long enough and often enough, then at some point.
00:07:42.713 - 00:07:52.765, Speaker C: You'Re going to fail and you can generate a random hash and. And land on somebody's stash of Bitcoin too.
00:07:52.845 - 00:07:53.825, Speaker D: Yeah, exactly.
00:07:54.565 - 00:08:00.625, Speaker B: So actually I have a fun aside here. Do you know why they are called Biggie and Victor especially for you, Imran?
00:08:00.965 - 00:08:02.185, Speaker C: I don't know, actually.
00:08:02.965 - 00:08:21.565, Speaker B: Okay. Mathematicians are nerds, right? So they want to use real names that relates to the actual thing. So Biggie starts With a P for prover vectors, starts with a V for welcome to the nerd party, guys.
00:08:22.585 - 00:08:23.841, Speaker C: Gotcha, gotcha.
00:08:23.993 - 00:08:39.537, Speaker A: That's great. So we have a high level understanding of what this could enable. Right. Being able to share information without revealing the underlying data. Right. What are things that it can enable? What are we thinking about here in terms of startups?
00:08:39.641 - 00:08:47.459, Speaker C: Well, I think. Do you want to talk about how we went from this sort of basic thing to something that's more general?
00:08:47.627 - 00:08:51.803, Speaker A: Yeah, maybe general. And then we could talk about what it can bring out to the market.
00:08:51.899 - 00:09:21.153, Speaker C: Right? Yeah. So that example was a very specific ZK proof. And for a long time we didn't have a general way to be able to prove any statements about the world. So for a long time the holy grail was to be able to prove with any function F. Like I know something that goes into the function F that produces this output Y for any F. Right. And I guess for a long time.
00:09:21.153 - 00:09:33.489, Speaker C: Well, okay, so at some point they found a problem that's NP complete called like the R1Cs, the rank one constraint system of polynomial.
00:09:33.577 - 00:09:42.045, Speaker D: You were debating in your head whether or not you should go into this NP problem. I can't tell why you hesitated. This is a whole new rabbit, Hol.
00:09:44.245 - 00:09:59.933, Speaker C: We'Re going to jump through because I can't explain it well enough. But there is this set of problems called the Rank 1 constraint system. It's like a polynomial where you have to find integer solutions to it in a mod prime field.
00:10:00.069 - 00:10:04.065, Speaker D: Imran is lost. I'm still following so far.
00:10:05.045 - 00:10:17.555, Speaker B: I read this and it took me a while to understand what is the field actually to begin with and what's the moving field. Or like he's like probably Imran and like anyone? Like what the heck is that?
00:10:17.895 - 00:10:20.799, Speaker C: Yeah, I'm just going to show like a visual. Just a visual. Right.
00:10:20.847 - 00:10:21.751, Speaker A: Visuals are great.
00:10:21.863 - 00:10:26.231, Speaker D: This is first year honor grad math course, by the way.
00:10:26.423 - 00:11:00.653, Speaker C: So this is a rank one constraint system. So you have these X's that add together to get other things. Some you can multiply them to get some other things. And all these things are integers that are smaller than some p which is a prime. And in practice it looks something like that. You have these lots of X's and they add up and they multiply and they're equal to other things. So that's just how it looks.
00:11:00.653 - 00:11:02.065, Speaker C: Right? It doesn't matter.
00:11:03.125 - 00:11:06.905, Speaker D: Imran was hoping for visualization, but you give him a bunch of.
00:11:09.245 - 00:11:16.917, Speaker A: You made it worse, David. Yeah, no, this was. I mean I got the concept but yeah, it was still like we're trying.
00:11:16.941 - 00:11:19.145, Speaker B: To just to check your confidence, like you.
00:11:22.445 - 00:12:00.141, Speaker C: It just turns out that this problem, I mean this function has nice properties that we're not going to go into. And people can prove they have a way to prove that they know a solution to this without revealing what the solution actually is. And it turns out that this problem is NP complete and every other NP complete problem can be translated into this one. So that's why this is useful, because you can translate any sort of function that you want to come up with. There's like an easy way to translate to this problem and then this problem has a way to generate a ZK proof.
00:12:00.213 - 00:13:01.507, Speaker B: So can I try to rephrase this in more language? So the idea here is that you can take a general problem that you need to prove, right? Like running a code. If you are running a code, how can you prove that this code has run right or not? That's a really hard problem. So the trick actually, or the magic trick is to convert this general kind of problem into a mathematical representation that you can actually work on paper to find the solution. So what the R1CS system is, it's a mathematical representation that can be solved mathematically to show that we have good probability that I can do something without cheating. Right? The trick here is that this R1Cs is so easy that you can actually convert it, convert any problem to it. You can prove that you have run some code by representing it in R1Cs. You can prove identity, which is harder to prove, but you can convert it again to R1Cs and once you get there, the rest is just math.
00:13:01.507 - 00:13:05.059, Speaker B: So the trick is this conversion step, is that accurate enough?
00:13:05.107 - 00:13:31.743, Speaker C: David, there's different ways of converting a general problem to this R1Cs and I think those are called arithmetizations. And that's why you'll see in ZK proving systems there's different languages and different arithmetizations and there's. And they all have different properties that ultimately will. You might have to balance out when building an app.
00:13:31.919 - 00:13:56.647, Speaker B: Yeah, just for completeness here, like R1Cs was kind of one of the first, but now actually major protocols don't use it anymore. Like there is Stark Connect uses something like, called AIR representation error arithmetization, Ethereum for the data blobs will use something called KZG. So like there are different approaches of this, but R1CS was kind of the first or like the easiest to start with.
00:13:56.711 - 00:14:05.487, Speaker D: I suppose it's probably not clear enough what R1Cs is to most of the audience. Is it a polynomial function that you can solve?
00:14:05.631 - 00:14:06.951, Speaker C: Yes. Okay.
00:14:07.063 - 00:14:11.679, Speaker D: I think most people understand polynomials, right? Or no, I'm sure.
00:14:11.807 - 00:14:31.847, Speaker A: Or we can go deeper into that. But before we go to polynomials, we need to bring it down a little bit. Lore, right. In regards to what it was RC1s. See, I don't even know it, see. So I probably represent the average audience. So let's just put it that way.
00:14:31.847 - 00:14:37.727, Speaker A: So is this the math behind what makes zero knowledge proofs work? Is that the idea?
00:14:37.831 - 00:14:38.503, Speaker C: Yeah.
00:14:38.679 - 00:14:54.089, Speaker A: Okay. And why is this important now? Why are we discussing this now? Is this like, are we laying down the. The foundation for what types of math we're using moving forward, for how we prove out different systems, like on Ethereum and others?
00:14:54.217 - 00:15:20.919, Speaker B: It actually may be good to go slightly into history, like why this actually came to this space. And I think most people were initially interested in the privacy aspect of this kind of math, that you can prove something without revealing it. And the first actually project that God used that it was zcash. Right. Zcash wanted to implement private payments using blockchain. Blockchains are great. Bitcoin was great.
00:15:20.919 - 00:16:23.465, Speaker B: But everything is transparent. Everyone sees that this address sends this address, this amount, right? And this is necessary for the network as a whole to come to consensus that this person actually has amount of money, so they can spend it to someone else. So all of a sudden like the idea of zero knowledge to prove that you have some asset and you can spend it without revealing how much asset you have, or without even revealing who do you spend, who are you sending this amount to? Or even without revealing how much money you will send, are you sending the whole balance, half of it abortive. So zcash came with this idea that you can prove some computation. This computation, I have 100 tokens, I want to spend 50 to another address without anyone on the network knowing what the details. But everyone can know one fact that this transaction is valid, that I had this balance, I can spend part of it and I can send it to this address. So that is the story that what started actually brought this moon math into our wallet, which is blockchain.
00:16:23.465 - 00:16:40.697, Speaker B: That you can prove this competition without revealing the details. And zcash actually started with that. And from there that opens the door to so many applications after that. Like we will probably dive into this application verdict in detail. But the most major application now by far is rollups.
00:16:40.841 - 00:16:41.473, Speaker C: Yeah.
00:16:41.609 - 00:17:00.953, Speaker B: Which for the fun of it, doesn't use any privacy. So like it's at all. You don't Use privacy. But we are seeing more applications that use privacy, like identity and, like, bridges and stuff like that. So we will touch on that. But I just wanted to give a brief history why we care for that. Okay, David, you can go.
00:17:01.089 - 00:17:45.475, Speaker C: Another thing to add is that, you know, in 2016, when Zcash came along, they had to improve and build the tools and do some math to even be able to get this into production. And over the years, as these tools and things got more standardized, like, it is now kind of possible for generalists like me to do something with zk. You know, like, maybe even one or two years ago, there wouldn't have been the tools for me to come in and do anything with it. So that's why it's interesting now because, like, more and more people, like, exponentially more people can actually play around with these tools.
00:17:45.595 - 00:17:50.979, Speaker B: So would it be fair actually to say that Web3 or crypto led actually to the development of ZK?
00:17:51.147 - 00:17:57.981, Speaker C: Absolutely. Yeah. It's a lot of, like, the, you know, the blockchain uses that. That pushed the development of this stuff.
00:17:58.093 - 00:18:19.845, Speaker B: So because I always consider ZK as a Web3 technology, which some people disagree with, they're saying, no, that's a general technology. It was existed before. Wayward3. I think most of the interesting advantages in ZK happened when you actually started monetizing this technology. Right. And people started, oh, there is money to be made in here, so let's develop this further. Right.
00:18:19.965 - 00:18:38.515, Speaker C: Yeah. I think crypto used to be like, oh, about privacy and stuff. And then the word crypto got, like, taken away from the cryptographers. And crypto meant, like, oh, blockchain. Right. But with the ZK stuff, I think the word crypto kind of got back into where it belongs.
00:18:38.675 - 00:18:40.051, Speaker B: Very interesting. Yeah.
00:18:40.203 - 00:18:51.395, Speaker A: I feel like a lot of the funding also helped. Right. So VC funding into, like, starkware and others that helped push the development of some of the ZK proving systems, starting with zcash.
00:18:51.935 - 00:19:16.549, Speaker B: So I remember vaguely there was a really intense debate in Twitter when people called it, like, crypto Twitter. And people, cryptographers were really offended by saying that crypto is not a word for shitcoins. It's a word for cryptography, which is a very disciplined science that is only being done in prestigious schools like Harvard, MIT and stuff like that.
00:19:16.597 - 00:19:46.001, Speaker D: So, David, so about what you said earlier, that sometime during the last one or two years, people finally are able to do something with this technology. Generalists are finally able to do something with this technology. I've observed two trends. One is that people are overestimating how much you can do now because everyone just slaps the word ZK into their project nowadays. Nowadays it's all ZK and AI. It's ridiculous. So number one, people are overestimating how much you can do with zk.
00:19:46.001 - 00:20:10.445, Speaker D: But two, people are underestimating how fast the rate of change is happening in the ZK space. Because one or two years ago this thing was not even possible for generalists, but now you can do stuff with it. You can build some basic identity stuff. So the thing I'm most curious about is what is the actual current state of things? What is practical today? What is realistic today?
00:20:10.565 - 00:20:54.803, Speaker C: Yeah, so I just came back from a class offered by Zero X Park and I'm definitely not at the forefront of this technology, but I can give like some, I can repeat some of the statements they had. So in terms of optimism, right. One number they gave was that this stuff was improving like 32, 64x per year. So every year you would be able to create ZK proofs that are 64 times bigger. And that has been happening for the last four or five years. And that's an extremely fast rate of improvement. But at the same time, this rate of improvement, it's really at the edge.
00:20:54.803 - 00:21:29.551, Speaker C: People are working on things like zkml. That's a lot of computation to put into ZK proof. But it's like for very specific things and they have to do a lot of research and optimize problem specific optimizations just to get that thing working. So the progress is not uniform. You can't summarize all of it in one number. And there's different dimensions in which you characterize CK proofs too. There's the time it takes to generate the proof or the time it takes to verify the proof.
00:21:29.551 - 00:21:56.529, Speaker C: The memory, the memory size and like the proof size and all these things will have to be balanced in order to fit. Like your applications for example, if you want your proof to be verified on chain, it has to be small enough. It has to be, it has to run fast enough. But if you don't need that then you can like, you know, have those things be bigger but have the proverbial run faster. So if it's like a in browser application. Right.
00:21:56.577 - 00:22:06.689, Speaker A: So should we kind of dive deeper into the proving types of proving systems that are available that give you the trade offs that you know, builders need? Like there's, you know, airstark, Pickles, Starks.
00:22:06.817 - 00:22:46.279, Speaker C: Yeah, to be honest, I like, I don't have a good sense of what are the trade Offs that each proving system will give. But I can give an example of something that seems easy but turns out to be pretty hard. So let's say I want to prove that I own an address on Ethereum that is part of a group. Right? So you know with a, with a normal computer, you do that in like milliseconds, right? You say like you, you generate a private key, you get the address out of it, and then you check if that address is part of this group. It takes like one millisecond. I don't know, something like that. Right.
00:22:46.279 - 00:22:55.431, Speaker C: But right now the fastest way to do that takes around 40 seconds on consumer hardware, like on my laptop.
00:22:55.503 - 00:23:07.023, Speaker D: You mean proving that your address belongs to a certain list of addresses without revealing your address itself? This thing using ZKP takes 40 seconds to generate the proof.
00:23:07.119 - 00:23:14.235, Speaker C: That's right. And that's like the optimized and that's stuff that came out within the last year. Right.
00:23:14.355 - 00:23:24.171, Speaker B: Okay, so this is what they call inclusion proof that your proof is it that your address is part of a group or included in a group. Is that. Is that correct?
00:23:24.283 - 00:23:26.323, Speaker C: You can call it inclusion proof. I don't mind.
00:23:26.419 - 00:23:59.781, Speaker B: Okay, yeah, like, so just to prove something simple as that, like that my address maybe owns like an ap. Like you can do this very quickly if everything is transparent and you don't need to prove it. But if you want to prove it, then it will take a while. Right? You have a list of all the addresses who have an ape and you don't want to reveal your address, but you just want to prove that you have an ape. This task alone will take 40 seconds to prove. How much time will it take to verify on a chain? If you want to verify it much.
00:23:59.813 - 00:24:49.655, Speaker C: Faster, like on the order of a second or something on consumer hardware? Not, I think less than a second in consumer hardware. So one of the application of this. So if you've heard of a noun dao, one of their funded apps is called a heyanown. And what you can do is like, if you own one of these noun NFTs, you're able to post a message into that forum anonymously. So like on your computer, you will generate a proof that you belong to that group and the server will like, nobody else will know who posted that message, but it will be posted on hey now. And the group that enabled this is Persona Labs. And they're the one that really like optimized this specific ZK proof.
00:24:50.315 - 00:24:53.955, Speaker D: And it takes 40 seconds on a consumer computer.
00:24:54.115 - 00:25:26.257, Speaker C: Okay, there's a little start here. So it takes 40 seconds if the group of addresses have never sent a transaction. So it turns out like if you want to prove that your public key belongs to a group of addresses, like Ethereum addresses, it takes 40 seconds. But if you want to prove that your public key belongs to a group of public keys, not addresses, public keys, then it takes about four seconds.
00:25:26.361 - 00:25:47.685, Speaker B: Okay, so the first time kind of to post a message is like 40 seconds because you are proving that your address is part of the larger Ethereum set or set of Ethereum addresses. But next time, second time, because you already published something on this higher now and it takes only four seconds because you just need to prove that you are one of these private keys, right? Oh, sorry.
00:25:48.305 - 00:26:30.623, Speaker C: There's a difference between an address and a public key because like once you've posted a transaction, then your public key becomes is revealed to the world and it just turns out that the math, the ZK math that translates between a public key and an address just takes a lot more work. So it's kind of hard like if you as an outsider, it's like hard to tell what is going to take a lot of time, right? Because all of the inclusion and the elliptic curve stuff takes four seconds and then you have that other 36 seconds that's just to turn a public key into an address.
00:26:30.799 - 00:27:05.763, Speaker B: So I can give a little bit more light into that. Actually some of the operations that can be done very, very easily on hardware are really, really hard to do in ZK and the opposite is true. So for example multiplication and addition. This used to be kind of complex for hardware. Hardware can take a bit of time to do, but in ZK math multiplication and additions are piece of cake. Like you really can do it very quickly. Something like that can be done very efficiently in hardware are logic operations and, or XORs.
00:27:05.763 - 00:27:23.065, Speaker B: You know this chow, right? This like when you take single bits and then you add do an and or logical operation on them. This bitwise operations are really efficient in hardware, but they are really really annoying when you want to do a zero knowledge proofs.
00:27:23.725 - 00:27:29.773, Speaker D: When you say hardware, do you mean something like asic, FPGA or even single transistor?
00:27:29.869 - 00:28:07.391, Speaker B: Like single transistors. Like not even you don't need a very complicated circuit to do this bitwise operations and and, or the literary gates. So these are very simple primitive hardware and, and, or, and they are the most efficient element that you can do in hardware. But to prove them in ZK math it takes a lot of effort and time and like really takes a lot of computation and Back to David's point, there are simple operations that you can do in in compute that you send. Oh, this will be easy to do in zk. It's not like ZK is very good for multiplication and addition. Really bad for other stuff.
00:28:07.391 - 00:28:20.727, Speaker B: Digital signature, for example, when you sign a message on Ethereum or Bitcoin, depending on the type of digital signature, this signature can be efficient for ZK or not. And this is actually one of the areas that have evolved a lot over the last few years.
00:28:20.831 - 00:29:05.715, Speaker C: Yeah, it's ultimately like the hash function that Ethereum chose at the beginning turned out to not be ZK friendly. Right. The hash it chose is the Ketchak 256. Like the weirdest word. But because Ethereum was built prior to all this ZK stuff, it turned out to be a bad hash function for zk. Just to give an order of magnitude of how much it takes from normal computation to ZK computation, the number that I kind of here is on the low end it's about 100,000x and on the high end it's like 100 millionx.
00:29:06.455 - 00:29:24.841, Speaker B: So yeah, you gave an example. You said like, if you want to do what I call the inclusion in set proof in computation, that will take one millisecond. But if you are doing in ZK, it takes 40 seconds. So divide 40 seconds by one millisecond. That's a 40,000 multiplier. Right.
00:29:25.033 - 00:29:28.777, Speaker C: And that's like on the low end because it was optimized. Yeah.
00:29:28.881 - 00:29:29.529, Speaker B: Okay.
00:29:29.657 - 00:29:43.353, Speaker C: On the high end you have like these general, like these general naive translation of general compute to zk compute. Then you get like this 100 million x. Right.
00:29:43.449 - 00:30:09.389, Speaker D: Wait, so speaking of computational efficiency, does it even make sense to build hardware accelerators for ZK proofs today? Because what I'm hearing is zero knowledge proofs are extremely specialized today. You need to tweak that proof for a specific problem. But then if you try to build a hardware accelerator, can it even be generalizable enough? Am I thinking this right? Is this a right problem to think about or no?
00:30:09.517 - 00:30:38.805, Speaker C: So definitely not a specialist. In general, getting things into the gpu, which is a general compute, will give you a speed up of 100x. And 100x does not solve everything. So there still needs to be algorithmic improvements to get things working. But it is a 100x that you can get at some point whenever you feel like investing the time in.
00:30:39.425 - 00:31:16.165, Speaker B: So hardware is my specialty, so I can kind of dive deeper into that. So zero knowledge proofs are like, have to be Optimized on both software and hardware. So I was just. Software is what people are doing. So br all these people are optimizing really the software and the libraries, how to build libraries that are fast on the hardware. Like it boils down that this old proofing systems that people are creating since growth 16 and like the. Even the new ones like stars and Halo or whatever like that and Planck and all this algorithm depend on two basic mathematical operations.
00:31:16.165 - 00:31:48.453, Speaker B: One is called numerical theoretical numerical transfer or like or people call it fully transformed. That's to make it simple, fast, fully transform. And the other one is called Multiscalar Multiplication MSMs. So let's say there are two operations. One like these two operations can be actually really optimized by hardware because you need especially for your transform, they can be parallelized. You can have multiple components, more components do the same thing. In a GPU you have some of them, you have 100.
00:31:48.453 - 00:32:45.943, Speaker B: But in specialized you can put a thousand on the same chip area. So you can actually have more of the components you need and have less of the components you don't need often. So the whole idea about acceleration is that on the hardware level you don't put everything. You don't bought a general processor, you don't put even a gpu. You just put specialized hardware component from the components that you need the most. And this tend to be like for transforming engines and memory you need for proofing systems you need a ton of memory, you need like terabytes of memory sometimes see if you can eat a specific ASIC or like a specialized ASIC for proofs you can have a lot of memory and a lot of FFT engine that can give you between 10x to 100x. But given that threshold or the barrier that we need to climb, it's the barrier in David's term is four orders of magnitude 10,000 times or maybe you said 100,000, right David.
00:32:45.943 - 00:33:04.099, Speaker B: So that's five orders of magnitude. So from five orders magnitude you can take only two orders by hardware you still have three orders of magnitude or a thousand multiplier that you need to figure out by other methods, which is software optimization, improving the algorithm itself, stuff like that.
00:33:04.227 - 00:33:27.035, Speaker A: So maybe going back to your nouns dao idea where they're verifying identity. So it seems like this is primarily a gateway for proving identity without revealing either your assets, your net worth. What are some of the applications do you think that could come out of Identity ZK Identity. And I know Chao always threw out the the startup which is like a tinder for network.
00:33:29.215 - 00:33:30.355, Speaker B: I was going to say.
00:33:31.015 - 00:33:46.635, Speaker A: And so maybe we can talk about, you know, I think we could dive deep into many areas, but the first one I think is identity, which I think could be pretty big. Kycml for exchanges as an example, you know, Tinder for net worth, et cetera.
00:33:47.095 - 00:34:19.395, Speaker C: Yeah. So the way you would do Tinder with net worth, with crypto net worth right now, you would gather all of the addresses that have a high net worth and you just build a list and anybody could verify that. You could say, okay, yeah, check this address. Look at their on chain assets has like a million dollars. I don't know if that's enough for you. 1 million and you can generate a ZK proof that you own this address. And that would be where you would send that to your match on Tinder and be like, hey look, I'm rich.
00:34:20.895 - 00:34:40.503, Speaker D: Okay, so but this method, in this method you pre compile a list of high net worth addresses and then you prove that you belong to the address. What about an alternative way where you just look at the balance in this address and try to prove that this balance is above certain threshold? Is that even practical realistic today?
00:34:40.679 - 00:35:01.055, Speaker C: So that goes into ZKEVMs or state proving. So there's like, there's a startup called Succinct. No, sorry, Axiom. Axiom XYZ that wants to generate ZK proofs on any state of any function, on any state of an evm.
00:35:01.175 - 00:35:02.583, Speaker A: And do they do this automatically or.
00:35:02.599 - 00:35:04.719, Speaker C: Is this, what do you mean by automatically?
00:35:04.847 - 00:35:14.619, Speaker A: Meaning like do they pre compile all of the state that's ready within Axiom? So like if somebody wants to pull some data, it's already readily available.
00:35:14.807 - 00:35:21.251, Speaker C: No, it's, you have to, right now you probably have to work with them to write some sort of proof for it.
00:35:21.283 - 00:35:21.659, Speaker A: Okay.
00:35:21.747 - 00:35:50.693, Speaker B: They have actually a public demo on their website that you can prove some features like the age of the address. Like is this address new? Has transacted since like one year, five years. So they have actually implemented a circuit that can prove that using from the app. Maybe also how much you transact or how much you want something like that. But like it's not general yet. You cannot prove everything that you, you cannot get an arbitrary proof for whatever function you need.
00:35:50.749 - 00:35:53.605, Speaker A: There is specifically, there's still some work that needs to be done to get there.
00:35:53.645 - 00:36:01.509, Speaker C: Yeah, yeah, yeah. They're making it easier for, for somebody to come in and like take a new state and use that as a proof.
00:36:01.557 - 00:36:01.949, Speaker B: Yeah.
00:36:02.037 - 00:36:04.357, Speaker D: Do you have a sense of how long it takes to generate that proof?
00:36:04.421 - 00:36:08.845, Speaker C: The One that, like the way you said about proving net worth.
00:36:10.785 - 00:36:16.841, Speaker D: The axiom way. And also your way which is checking that an address belongs to a list, right?
00:36:16.913 - 00:36:35.425, Speaker C: So checking an address we talked about earlier, which is either 4 seconds or 40 seconds on consumer hardware once you have compiled the list. So somebody has to compile the list first. And the other way, I can't say what.
00:36:35.805 - 00:36:58.173, Speaker B: So like for, for that part they do the proof on their servers and you have only, you can do only an API call to the server. So like you can get a response within like maybe 30 seconds. But you, that's not a clear indication of how much of that actually the times you use to do to generate proof, but it gives you an upper limit. Like it's not more than, not more than 30 seconds. It's a, it's a simple proof kind of.
00:36:58.229 - 00:37:19.605, Speaker D: For identity proofs, you don't need to generate the proof on a continuous basis, you just need to prove it once because it's an identity and it rarely changes, right? Unlike the ZK rollup stuff where you have to generate proofs upon every block and shit like that. With identity, even if it takes 40 seconds to generate the proof, it's not that bad from a consumer point of view, right?
00:37:19.725 - 00:37:47.955, Speaker C: It depends. So like if you want the messages that you sign to be signed with your identity, with your group identity, then you need, you do need to make a proof every time. Because like if you just make a proof once, somebody could intercept that proof and reuse it to say like, oh, I am part of this group. So in practice you do need to like sign new messages with that group identity to.
00:37:48.455 - 00:38:01.617, Speaker D: There's also a time component. There's a time component. You need to prove that you belong to that group at this point in time, but five seconds later things could change completely. So yeah, okay, you're right, it's a bad experience. 40 seconds to generate approvals, long time experience.
00:38:01.801 - 00:38:41.215, Speaker B: But like just to give context, like when zcash started for you to send a simple transaction, like just a shielded transaction back then it took actually 60 seconds on your computer to generate the signature. But with some improvement on the hash functions and the proofing mechanism, they go to this, to two seconds, right? So like this kind of, to David's point, like you can actually improve like by 40x or 50x or what's in one year. So yes, what can take 40 seconds this year maybe become a couple seconds in a couple of years. It's not out of the realm of possibilities.
00:38:41.375 - 00:38:53.725, Speaker C: And I would say that like most addresses have sent out a transaction. So like you can use the other version, the public key version of that group inclusion algorithm, which is like four seconds.
00:38:55.225 - 00:39:02.737, Speaker A: So identity is one, what are some others? And then yeah, I mean there's a bunch of lists that we made. But like I'm curious on like some of these.
00:39:02.761 - 00:40:15.213, Speaker B: Let's start with the list and then maybe a few to discuss like. So as we mentioned, the most obvious application is roll ups. But actually let's generalize roll ups off a chain compute that you can pick the compute that you are doing today on a chain which costs a lot of gas and a lot of congestion on a chain and take all of this compute and execute off a chain and then generate a proof for this off chain compute and bring and validate only the proof on a chain. So I would say off chain compute is one big one similar to that is or like a subset of that is actually bridging between different blockchains which people call state proofs. State proves that I will prove that the state of blockchain 1 and generate a proof of it and validate this proof on blockchain B and then or two and then I can actually spend this or wrap or create a wrap token that represents whatever happened on block. So NSync Sovereign is building state proofs and they are really focused on bridging between ZK rollups. And again back to the main starting of this whole thing which is privacy.
00:40:15.213 - 00:40:25.465, Speaker B: I think still we are not there yet in terms of privacy using ZK proofs. We have seen ASTIC try and ZK connect which was trying just to hide assets.
00:40:26.605 - 00:40:36.351, Speaker A: Why is privacy, is it primarily regulatory do you think? Or is there what are some of the reasons for privacy not being at scale?
00:40:36.453 - 00:41:12.763, Speaker B: Okay, obviously after tornado cash it becomes a legal issue, right? Because people if it's an open and permissionless, you are giving a tool for bad actor or malicious actors to launder money and like ransomware and stuff like that. So but let's, let's get over this. Let's say that you are actually using a permission list of actors. You, after you validate the identity, you give them access to this private pool of capital. That can be done. And I still think like private ZKE proofs are really still really hard. And that's what I will just use a simple data point Aztec itself.
00:41:12.763 - 00:41:26.295, Speaker B: The vision for ASTIC to begin with was to complete to have a roll up ASIC square roll up a ZK score roll up means it's a ZK rollup. It's similar to Everyone else, but it's also private. And the first iteration didn't work this way.
00:41:26.875 - 00:41:29.063, Speaker D: Did you say ZK squared roll up?
00:41:29.119 - 00:41:29.591, Speaker B: Yes.
00:41:29.703 - 00:41:34.735, Speaker D: So privacy plus scalability. That's the squared. That's what you mean by squared.
00:41:34.775 - 00:41:35.231, Speaker C: Okay.
00:41:35.343 - 00:41:40.711, Speaker B: Yeah. So yeah, it was a hype term actually because the term is Z. Good term.
00:41:40.743 - 00:41:41.495, Speaker D: I like it.
00:41:41.655 - 00:42:07.349, Speaker B: Yeah. Actually it was like a couple years back when they came out of this term, but with this goal, when they launched the first version, ASTIC couldn't do both. They could do some kind of it, which means that they could do scalability because they are ZQ roll up. And on the privacy, they couldn't do much functionality. They just had transfers. I can transfer from my address to this address. That's it.
00:42:07.349 - 00:42:10.653, Speaker B: You couldn't do much. You couldn't do programmable stuff.
00:42:10.789 - 00:42:13.405, Speaker A: We're talking like ZK Money or shielded transactions, right?
00:42:13.525 - 00:42:16.285, Speaker B: ZK Money. ZK Money, yes. Shielded transaction.
00:42:16.405 - 00:42:20.999, Speaker D: You couldn't do these things because the proof is too expensive or too long to generate.
00:42:21.117 - 00:42:33.891, Speaker B: Because scalability is easier. Like the. Actually it's. Okay, let's do a disclosure. When we use the term ZK for scalability, that's abuse. Okay? That's overuse. Okay.
00:42:33.891 - 00:43:09.025, Speaker B: Scalability solutions have nothing to do with zero knowledge. They are just using one element of this technology which is called succinctness. You compress stuff. Okay, but we are just using ZK for scalability now. Okay, Just this disclosure, if you go out, if you want actual zk, which means that you have to deal with private information and private details, this actually complicates the mass even further and it makes it even harder to scale or make this functionality. And it limits one important aspect. It limits programmability.
00:43:09.025 - 00:43:43.289, Speaker B: Once you go to privacy, you can prove that I own this asset and I can transfer it. But it becomes way harder to have a global private state. What's a global private state? Let's assume that you have a uniswap pool, right? A uniswap pool is a shared state. All of us can see it and all of us can change it, right? By executing trades against the pool. The pool has some usdc, for example, and some eth. Now we need to keep this private and then anyone can come and execute trade against this pool and change it. And this change has to be private.
00:43:43.289 - 00:44:18.775, Speaker B: Now this becomes a way bigger problem. You are not just changing your own state like payments, you are. You are changing a global state. And this is a bigger and more much complicated problem. There are like courageous team out there trying to solve this penumbra like renegade railgun, like there are people who are trying to do this, but it's still a harder problem. That's why if you want to create a ZK Square door lab, a roll up that is do both scalability and privacy, it's a massive task. And that's why ASTEC themselves said we cannot do this while we are maintaining ZK Money.
00:44:18.775 - 00:44:36.883, Speaker B: So let's shut ZK Money down and let's focus all our resources, all our team efforts into creating this new paradigm, whether we have this K ZK squared roll up. So privacy is still hard. That's why I still think it's not solved yet. No one has kind of figured it out yet.
00:44:36.979 - 00:44:52.815, Speaker A: I've seen some iterations of this for wallets. I forgot the name of the startup, but what they do is they take your assets and then they put it into some sort of vault that has its own assets where you can trade in and out of. Do you remember that startup?
00:44:53.395 - 00:44:54.075, Speaker B: Which one was it?
00:44:54.115 - 00:44:54.891, Speaker D: Nocturne.
00:44:55.003 - 00:45:08.831, Speaker A: Yeah, Nocturne. So there are some interesting implementations of Privacy but I feel like that it isn't like ZK native per se, like ZK Money and others. It's more like using it as an off chain type of compute.
00:45:08.903 - 00:45:28.257, Speaker D: So it's not a coincidence that the zcash people have been talking about working on smart contracts for zcash but they never managed to do it because it's really difficult. So far they've only done zero knowledge proofs for basic transfers. But if you want to support smart contract functionality with privacy, has anyone done it?
00:45:28.321 - 00:45:38.685, Speaker B: Aleo is working on it. Aleo is another L1 private L1 that their goal is to allow both privacy and the programmability. So like you have private smart contract.
00:45:39.585 - 00:45:51.881, Speaker D: So Aleo is trying to do two of the three which is privacy smart contract. But then previously Aztec was trying to do three things which is privacy, smart contracts and scalability.
00:45:51.953 - 00:46:47.599, Speaker B: Becoming a layer, two becoming building Ethereum and by the way building loop Ethereum is an issue mis own that's why because Ethereum use the account model which is harder to deal with when you are doing privacy. That's why zcash and even by the way Astic the new direction they are using a hybrid model like utxos or like the unspent transaction outputs model which is used by Bitcoin is more similar to use when it comes to privacy. That's why by the way, zcash is also a utxo based system and many protocols that are attacking privacy are also trying to build on utxo, but they create a hybrid that you have actually both systems, UTXO and account based, and you can switch between both. And I think that is a direction that Findora tried first and I think Aztec is trying to move in the same direction.
00:46:47.727 - 00:46:53.915, Speaker D: So identity scaling and privacy. Is there anything else or should we dive deeper into?
00:46:56.935 - 00:47:00.727, Speaker A: I mean, I think there were some. We did talk about bridging a bit too.
00:47:00.871 - 00:47:05.955, Speaker B: Like the only problem that ZK cannot solve is ux. So sorry, you cannot solve UX for you.
00:47:06.615 - 00:47:15.799, Speaker D: For me, bridging is a special type of off chain compute because you're looking at a different chain, which by definition is off chain from your chain, right?
00:47:15.927 - 00:47:16.519, Speaker B: Yeah.
00:47:16.647 - 00:47:24.519, Speaker D: Like for me, ZKrollup, ZKML in the case of Modulus or ZK bridges. These are all special types of off chain compute.
00:47:24.607 - 00:47:25.775, Speaker B: Yeah, I agree.
00:47:25.935 - 00:47:53.481, Speaker C: ZK bridges are not. I think it's pretty established now. There are ways to pass messages around. But the only problem with ZK bridges is that they're expensive. Right. Because you have to verify, because you have to verify a ZK proof on each side and if you don't batch enough transactions in there, then you pay a big cost. And that's why a lot of bridges now are still not using it, even though it's the most secure way of doing it.
00:47:53.481 - 00:47:55.845, Speaker C: It's just cheaper to not use zk.
00:47:56.225 - 00:48:37.717, Speaker B: Yeah. Another special type of off chain compute that I like, and I think it may find actually application even outside web 3, is ZK functions. A ZK function is like when you define some computing that has to run, but you don't want to trust the operator. Like you don't want to trust AWS to run this function for you or trust Azure or whatever. So you give them the code to run and they run it for you and they give the output of the function with a proof that the function has been run correctly. So I think the concept of ZK functions, of course it will find the application first in Web3, but I think the concept in general can be generalized to web2 once we overcome the computational overhead problem.
00:48:37.861 - 00:48:56.305, Speaker D: But this is what you said here, is it feels fundamentally at odds with what David said earlier, which is that ZK proofs are extremely specialized. But you're saying you can take any generic futa. You're saying you can take any generic function and do a generic proof on it.
00:48:56.725 - 00:48:58.545, Speaker C: Here is a trick. Yeah.
00:48:58.915 - 00:49:02.515, Speaker B: Now you can. David, if you want to answer this, go for it.
00:49:02.635 - 00:49:29.853, Speaker C: So the way I understand your question is that yes, it is possible, like Futa is correct that it is possible, but to optimize like very specific applications of it to make it practical, it's still very specialized. It depends on what you want to do. So if you just want like generalized things, then you're going to get that 100 million, that 100 million X factor. Factor.
00:49:29.949 - 00:49:50.755, Speaker B: Yeah. So let me actually answer this more detailed. Okay. You can today run any function and create a ZQ proof for it. And the trick here is that you don't create a specific circuit for this function. Instead you go and build a virtual machine and you implement the circuit that executes the virtual machine. So we call it jkvm.
00:49:50.755 - 00:51:01.741, Speaker B: And this is a bigger umbrella that under it you have ZKE evm, when you have this virtual machine is specific to be compatible with the evm. So there are so many projects today that actually offer you a generalized ZKE VM. You have ZK WASM, you have obviously ZKVM and even RISC0, which is a startup in this domain, they are creating a technology where you can write any code that complies to a certain architecture in computer architecture called RISC V. RISC V is a certain architecture that you can compile programs to and if you can write it to RISC V will take this code and create a proof for it using by building a ZK VM for RISC 0, sorry for RISC V architecture. So the concept of ZKVM is very, very powerful because it implements a base computational layer that you can go and build any code on top of it. Obviously because of this ease of use that it's very generic, anyone can use it, but it's not optimized. It can be, as David mentioned, it can be 100 to 1000x worse than going and implementing a specialized ZK circuit to do this functionality.
00:51:01.853 - 00:51:18.539, Speaker D: And fundamentally there is a motivation for this because there's a motivation for general ZK VM because the EVM is very unfriendly to zero knowledge proofs. It makes proving and verification very fast.
00:51:18.707 - 00:52:02.413, Speaker B: Yeah, it's very unfriendly that the most performant ZK rollups are not implementing zkvm, sorry, ZKEVM natively. They went and built a different circuit completely that is not necessarily compatible with evm and they just use a translator layer or a translation layer to accept solidity code. So from the developer point of view, the developer doesn't know anything, but writing the same solid is good. And it runs both on Ethereum native and on ZK Sync, for example. But ZK Sync Era in reality is not ZKEVM compatible. Vitalik uses a term for that which we use often between us, which is type 4 zkevm.
00:52:02.509 - 00:52:04.519, Speaker A: And you're talking about the different equivalencies, right?
00:52:04.637 - 00:52:44.823, Speaker B: Yeah, that's the topic of equivalency to how much are you compatible or natively compatible to the ZKEVM architecture. And some people are building that scroll, for example, like say no, we want to be ZKEV equivalent, not compatible like we want to be exactly like evm. Other projects like starknet and ZK Sync Era are not natively compatible to like evm. They build their own circuit and they are just trying to make it easy for developers to use this solidity the same code. They don't want the developers to go and write new code. Of course ZK Sync succeeded in that. Starknet is still trying because they have.
00:52:44.839 - 00:52:48.071, Speaker A: Their own language, which is Cairo and in Polygon zkvm.
00:52:48.223 - 00:53:00.647, Speaker B: Polygon Z also uses a trick to convert, but it's in between. It's not completely ZK Sync Era style or Scrum style futa.
00:53:00.671 - 00:53:12.183, Speaker D: So a few months ago we wrote about a bunch of applications of zk. I think we should critique it, knowing what we know today in terms of what is exactly realistic and practical today. Do you want to go through some.
00:53:12.199 - 00:54:07.587, Speaker B: Of the ideas, some of the ideas that I had with zkml? It's not ZKML in the sense that Modulus is doing. Modulus is building something that is very specific to Web3, that if you want to do a functionality using machine learning as off a chain compute, you can do it off chain compute and verify it on a chain. Is that suitable for maybe smaller models, maybe models that in the tens of millions of parameters, not billions yet. One of the ideas that I had is that this concept can actually scale to Web2, which means that now you connect to ChatGPT or you connect to OpenAI to run ChatGPT and you trust OpenAI. Whatever output you come, you give you, you trust them that they have run GPT4 at the back end or GPT 3.5 turbo or whatever models they said they run for you, you have to trust them. You have no way to other than to trust them.
00:54:07.587 - 00:54:29.209, Speaker B: Like one idea that I had, that possibly in the future we can actually have OpenAI give you the output of the model along with a proof that they actually have run the model for you. But given what we know now that we still limited by the computation and like this five to eight orders of magnitude complexity I don't think this is going to happen anytime soon.
00:54:29.377 - 00:55:26.405, Speaker C: Yeah, I can give some colors on that front. So I heard about a project called Ezekiel, but it's written E, Z K L easy zero knowledge proof in ML anyways, EZKL anyways, and they're like at the bleeding edge of trying to put ML into ZK proofs. And the approximate size that they seem to be at right now is like 2016 size ML models. So you can run some gans, you can run some simple convolutional networks like that in ZK and prove the input or the output or hide the weights and stuff like that. But that's like bleeding edge stuff. You can try to use that software. If you get stuck, you'll have to message the guy who's working on it, the Prof.
00:55:26.405 - 00:55:27.501, Speaker C: That's working on it.
00:55:27.613 - 00:55:31.877, Speaker D: Hold on. So in that case, what is exactly the use case? What do you prove?
00:55:31.981 - 00:55:55.891, Speaker C: There's a few things you can do. You can prove that something has run according to the algo that you wrote. So that's like the validity proof. You can offset the compute somebody does it and then returns you the result. And then you can verify that the result was not tampered with. So that's like not zero knowledge, but it's like verifiable. Verifiable, yeah.
00:55:55.891 - 00:56:16.165, Speaker C: You can also hide the input and say, I have a picture of a hot dog. I'm not going to show you the picture of the hot dog, but I can prove to you that it's a picture of hot dog according to this neural net. Right. Is that useful? Okay, maybe not.
00:56:16.625 - 00:56:22.793, Speaker D: No, no, I think that's extremely useful. I don't know what it is. Hold on, I'm trying to think nudes.
00:56:22.849 - 00:56:24.445, Speaker C: I'm trying to sell you nudes.
00:56:28.305 - 00:56:45.449, Speaker D: I have a piece of information. I'm not going to tell you what it is. I know some piece of information that's really important about the world, about what Putin wants to do next or something, and then I'm not going to tell you what it is, but I can prove to you that this will happen. I mean, that feels extremely powerful.
00:56:45.577 - 00:56:47.885, Speaker C: Yes. Blackmailing.
00:56:49.745 - 00:57:00.235, Speaker B: That is the only use case that can come to mind. I saw you doing something you shouldn't be doing and I have a proof of it and I will not show it to you. But you know what you are doing something like that.
00:57:01.215 - 00:57:24.585, Speaker D: Or like if you have a piece of information you want to sell to a journalist, but you don't trust the other person, the two people don't the two counterparties don't trust each other and you want money first. Well, if the journalist also doesn't trust you, why would they give you money for your information? Well, you can prove to the journalist that you're in the possession of that information and then they give you money and then in exchange you give them the information.
00:57:25.165 - 00:57:48.685, Speaker B: For example, I think the complexity here is that the model have to be trained on a specific kind of information. Like if it's a computer vision model, it has to be trained for that. If it's like text based, like information, it has to like. The complexity here is more in the machine learning side. And for each machine learning model you will have to have its own specialized circuit to be efficient. So I think that is like still hard.
00:57:48.805 - 00:57:59.899, Speaker C: Yeah, so. So EZKL translates Pytorch models into ZK circuits. That's like the goal that becomes general.
00:57:59.987 - 00:58:06.775, Speaker B: It's similar to the zke VM analogy. PyTorch is kind as a basis for anyone who touches AI.
00:58:07.115 - 00:58:26.059, Speaker C: I wouldn't say it's general because it's all about matrix multiplication. So EZQ will have done a lot of optimizations for matrix, like recursive matrix multiplications and the way they do that I don't know, but it's specialized for ML.
00:58:26.187 - 00:58:49.425, Speaker B: I don't think they will have enough 100% coverage of all the functions or methods in Pytorch. But if they can get to the majority of them, the stuff that can be used to describe convolutional neural networks or something like that, I think they will cover actually pretty big ground of the machine learning models that can be implemented. That's interesting. I didn't look into that before, so that's very interesting.
00:58:49.805 - 00:58:57.245, Speaker D: And this is completely orthogonal to blockchain. This has nothing to do with the blockchain. This is just pure ZK stuff.
00:58:57.365 - 00:59:05.725, Speaker C: Yeah, they're very complementary. But we can talk about non blockchain things, right?
00:59:05.845 - 00:59:53.223, Speaker B: Yeah, non blockchain thing. I think one of the ideas that I still believe it's doable today and not very complicated. But no one is doing it for some reason it authenticity of transformations of videos or images or stuff like that, that we agree that we can prove a video of the authenticity of a video or a picture by this signature, right? You create this podcast episode after it's edited. You Imran or you Ciao takes a full video, create a hash for the video, you sign it from your wallet down the video to authentic. Now what if I want just take one minute clip of this Video and want to prove that this one minute video is indeed a subset of the original authentic video. There is no way to do this now. And I don't think the transformation or the code to do this transformation is so complex that it cannot be proven with zk.
00:59:53.223 - 01:00:14.415, Speaker B: But so far I have seen very few projects that are trying to do this, whether it's for audio or video or images. So. But I think this is still a low hanging fruit and it has massive use cases within Web3 and outside with three. It's actually a Web2 use case, but no one is doing it that yet.
01:00:14.575 - 01:01:39.307, Speaker C: Yeah, that does seem like a lot of research work. So that's like for media, right? So let me give you an example of the same thing you said, but for something else, right? Emails are signed and they're like. And if you trust the sign, like the signature that came from some DNS server is valid, then you can create a ZK proof about this email that you got and say something that is truthful and people will believe you. So another example of the network thing, you can have your bank send you a statement of your, of your net worth, create a ZK proof hiding the actual net worth, hiding maybe some other details that you don't want to see, but the other person that receives this proof will see that, oh, bank of America has signed this message. And at line three, this number was larger than a million. So that's with email. Another thing you can do is like theoretically is have a ZK browser where everything that you receive from the web, like web pages, stuff are signed and you could take all that data and generate like statements about things that you see on the web.
01:01:39.307 - 01:02:10.755, Speaker C: So you can like if your, if your bank doesn't send you statements about your, your thing because it's unsecure, you could log into the bank website and from the HTTP requests you could technically find a subset of that, turn it into a ZK proof about whatever you want to say about yourself. You could say you're the owner of this Anon account on Twitter. You can say things about your bank statement. You can do whatever.
01:02:10.905 - 01:02:19.143, Speaker D: I just want to be able to do all that KYC bullshit without having to download my bank statement every single time and reveal the money in my bank, right?
01:02:19.279 - 01:02:45.995, Speaker B: Or even something like blad. Like blad is like have to get connection to your bank account and see. And you have the ability to see all your transactions, whatever you spend, just to get one information, which is a balance, because they want to do this deposit just by the balance. So like can we have a company that creates as they gave glad that they only will get access to this piece of information. They don't see your whole transaction history by getting access to your bank account.
01:02:46.455 - 01:03:04.335, Speaker C: So the thing here is that is that you do not need a plaid to prove about things like that anymore. Once the ZK infrastructure has been built, you can go and browse it yourself and create these ZK pros. You're like eliminating the trusted party in the middle. Does that make sense?
01:03:04.955 - 01:03:06.419, Speaker B: Makes perfect sense actually.
01:03:06.547 - 01:03:31.111, Speaker C: And also once you have generated this proof, this proof exists on its own, you don't need anybody to serve this proof or anything like that. It's a piece of document that can convince anybody of the statement that you made. You don't need an API to query, you don't need anything like that. So you can imagine it as these pieces of information floating around the web having truth statements about the world.
01:03:31.223 - 01:03:49.995, Speaker B: Yeah, and this kind of proofs have an element of privacy as well, because these proofs are verifiable, as is right as a standalone proof. You don't need input on them. Like if they are true, then proof something and that's it. So this is a very powerful concept. I think it has a name for it, right David? Like.
01:03:51.215 - 01:04:17.643, Speaker C: Well, it doesn't have a name yet, but there is a project that is working on trying to standardize the production and distribution of these proofs so that people can plug into this system more easily. It's like a protocol for people to work together with these proofs more easily. And they call it the proof carrying Data, a pcd. And it's another Xerox PARC endeavor.
01:04:17.779 - 01:04:38.167, Speaker B: So I think the use cases for this PCB is that they have way more use cases in with 2.0 in general than even Web3, because you can use it in everyday life, right? You can use a KYC Financial transaction. There is a lot of use cases here. You can use it for Tinder for High Idea as well.
01:04:38.271 - 01:04:59.105, Speaker A: So I guess closing it out, there are an incredible amount of startups that can be built on some of the infrastructure that's being built with zk. It seems like we're still in the early phases, right? Because proving times take, you know, let's say 40 seconds and the infrastructure is still being built out from a like a developer perspective, right? Yeah, I would say.
01:04:59.525 - 01:05:23.441, Speaker C: Although, although it is still, you know, performance is still a problem. Like it is possible for developers to come in and do something like proof of concepts. And once you have proof of concepts, you can go and talk to someone that's more specialized than you and they will work with you to optimize your circuits or anything like that. So the door is opening and now is the time to experiment.
01:05:23.593 - 01:05:28.601, Speaker A: Nice. Well, any other final thoughts before we close out?
01:05:28.673 - 01:06:14.471, Speaker B: I have a thought that like, and it comes back to my question to David that like ZK is a native Web3 technology, right? The concept of Web3 is that like you minimize trust between parties. And the first version for that was actually blockchain. And it seems that many people are like just tying the Web3 sector or this kind of technologies to blockchain. If it's, if it doesn't blockchain, it doesn't use crypto or something like that. And I disagree with that. I think ZK is a prime example of this trend of web3 that actually have way more implications outside web3. And if nothing comes from the web3 other than the ZK technology and that this sector has actually give birth and promote develop this technology to the world, I will be happy with what Web3 have achieved.
01:06:14.471 - 01:06:23.351, Speaker B: I still have high hopes beyond that, but kind of ZK is our web3 gift to the world, essentially. So this is kind of my high level thoughts.
01:06:23.423 - 01:06:26.595, Speaker C: I like it because it's less grifty than blockchain.
01:06:28.615 - 01:06:34.551, Speaker B: Oh, okay. This is like this sentence can be unpacked for a whole episode. Why, why do you feel this way, David?
01:06:34.583 - 01:06:44.377, Speaker C: So, so I mean like blockchain has made it very easy to anybody to launch a coin and to attract investors or people who are hoping for a.
01:06:44.521 - 01:07:04.235, Speaker B: I'm sure ZK will allow many people to launch a coin as well. Like, it's nice. Is that easy for next time? So I feel that we have a lot more to say, but like we are limited by time. Like I feel like one and a half hours is still too little to discuss zk, so we need to do more episodes in zk.
01:07:04.355 - 01:07:07.043, Speaker A: Agreed. Well, Chow, any final thoughts?
01:07:07.139 - 01:07:11.575, Speaker D: I just think polynomials and primes are great. They're the most beautiful things in the world.
01:07:14.275 - 01:07:16.651, Speaker C: It's kind of a miracle that this has happened.
01:07:16.723 - 01:07:32.575, Speaker A: But you know, great. For founders that are looking to learn more, feel free to check out our Crypto Ideas site on alliance xyz. Otherwise we'll see you guys in the next episode. Thanks. Thanks for listening to Good Game. Don't forget to subscribe. We'll see you next week.
