00:00:00.490 - 00:00:34.102, Speaker A: I've seen this before. It's about the compiler potentially. There is some issues here that I need to or some settings that I need to change. So if you know, I would appreciate a lot to let me know, maybe write it in the comments. But I wanted to mention that I always check out the pragma versions because it's common to find the projects that they are using either from different versions or end. Also they are using what is called the floating pragmas with this thing. Okay.
00:00:34.102 - 00:01:30.614, Speaker A: It's interesting that this fixes the error, but it makes sense because I think the error was saying of a higher version. So nowadays at this stage, the scripts, the robots that are running by some of the people are detecting these issues. So it's good for you to know and I'm going to mention those things. But yeah, I know this is going to be, well, I don't know, back in the time of this project if it was handled, but anyways, nowadays it's not worth to report because it's handled by those. Let's go further. Kuma access controller so this was handling other roles. I can see that in the constructor it is extending access control and we have a default admin role and Akuma manager role.
00:01:30.614 - 00:02:04.030, Speaker A: I'm wondering where they are, if I can find any more information about it. Probably they are in access control. Let's see, since we're here, let's see what we can find. By default, the admin role for all roles is that one. Which means that only accounts with this role will be able to grant or revoke other roles. Okay, I can see at least it can be changed. Apparently the set role admin a warning is also the photo admin role is also its own admin.
00:02:04.030 - 00:02:24.474, Speaker A: It has permission to grant and revoke this role. Interesting. Okay. Like only owner kind of permissions, extra precautions should be taken to secure accounts that have been granted it. Okay, so more than one account. Okay, interesting. It's initiated to zero address.
00:02:24.474 - 00:03:15.650, Speaker A: Okay, I'm not sure if I should go through this smart contract now, but let's take a quick look. Maybe we'll come through this later. But it has some modifier for only role and you specify the role and then it will probably go further and compare. He has to decode it. Access control account yeah, this smart contract seems to be taking care of those verifications. Okay, we might go further. Oh, you see this? What I mentioned, I knew that they are commonly using or it's common to find this that there are different versions used as worth reporting because like for instance, even in a private audit, it's worth reporting for sure because it's not safe.
00:03:15.650 - 00:03:46.520, Speaker A: Okay, so what we can see here is that it's granting both roles to the person or whoever is deploying this contract. Sometimes I like to go and check the test cases. Actually, look at that. Base set. Test base set up set up. It's probably going to deploy it somewhere here. But yeah, anyways, wanted to mention that as well.
00:03:46.520 - 00:04:16.254, Speaker A: I'm curious sometimes to just come and check, although I don't base it. I'm not sure about that. I will not take a look right now. But yeah, I think it's good to go and switch through the test while we're trying to understand what's happening in the protocol at the moment. Too early. Too early to check for me at least. I'm not sure what's going on, so let's try to find out more.
00:04:16.254 - 00:04:34.500, Speaker A: Let's see which other smart contract we can be checking next. Probably. Let's go. Next on the surprise, surprise is access controller. Okay, but from MCG. You know what? Let's stick with Kuma protocol. I think it makes.
00:04:34.500 - 00:04:56.934, Speaker A: Yeah, we'll do it separately. Next is KBC token. Where was it? Okay, yes, here somewhere. Here it is. Did I write something? Okay, never mind. KBC token. In this case, what we can do before going through it is what I mentioned earlier.
00:04:56.934 - 00:05:24.274, Speaker A: Let's go back to the documentation and now we can read about it before starting to analyze the code. Let's see if there is a section specific for it. If not, let's see. Maybe. What was it standing for? Yep, no key. Kib Kib maybe here we can see one is Kib token and this is KBC. Okay, it must be this one for sure.
00:05:24.274 - 00:06:07.362, Speaker A: Kumar Bond clone token KBC token yes. Let's see. When the central bank rate drops lower than the current kaiv token yield, clone bonds lower the coupon of bonds that were bought by users from Kumasoft contract. This ensures that at any point in time, there are enough heavy tokens in circulation to buy all the bonds from Kumaswap reserve. The lowest paying yield corresponds to the lowest yield between the central bank rate and the lowest coupon in the Kumasav reserve. And there is more information. Let's see.
00:06:07.362 - 00:07:10.006, Speaker A: Just reading it from top to see if there's something that catches my eye. Since the 5% bond appreciates more quickly than the kai idto the supply blah blah blah blah, a clone bond is always paired with apparent bond. I'm curious to find out what that bond in the code from the reserve and we'll have a lower from uniswap. When the bond is valued for each clone bond present, the parent bond cannot be redeemed by a user and can only be redeemed by the MCG multisig KBC token can only be issued by Kumaswap. In the buy one function, clone bond coupons are only created if the bond's face value is greater than that of the amount of kibt. Okay, let's go back to the code. I need to read more of this.
00:07:10.006 - 00:07:55.542, Speaker A: Okay, we're probably going to define this in constructor, but I can see it uses initializer, which is probably using upgradable. So this upgradable contract is a bit weird that it's. I'm not sure if I recall seeing the constructor being called. You know what, we can do something extend. I'm wondering about the constructor if it needs to be initiative. Let's see what we find. What we find here.
00:07:55.542 - 00:08:38.126, Speaker A: Okay, here you can use us. It contracts except for their constructors. Due to a requirement of the proxy based upgradability system, no constructors can be used in upgradable contracts. Okay, so that seems like an issue. Not sure what the cause the problem of having that. Let's see what can we find out more about it. Okay, there are some reasons in proxies this means that when using a contra with the open separating upgrades, you need to change its constructor into a regular function, typically named Initialize.
00:08:38.126 - 00:09:00.442, Speaker A: So we had the initialize there function, but we also had a constructor. That's what didn't look right. See we don't have here. Okay, I'm going to mark it for now. If it's an issue, we will be seeing it later. Yeah, let's do that. Let's go back.
00:09:00.442 - 00:09:41.186, Speaker A: You know what, I will also, so that you see, I would in this case mark it if I wouldn't have the answers. Let's say the report. Since we are doing an overview, I would just mark it like I would say should not add constructor. And I will be going back to that afterwards. In this case, we're just going to go to the report and we will find out there. But yeah, that's a way of keeping track of it. And this is the plugin.
00:09:41.186 - 00:10:00.002, Speaker A: What was it called? Do I have it somewhere here? Inline bookmarks, I think. Yeah, you can add audit info, audit issue, audit. Okay. And audit. That's very useful. So if you know it now, you do. So in this constructor or initialize.
00:10:00.002 - 00:10:39.414, Speaker A: We're passing probably the address or the contract address of this Kuma address provider, checking that it's not address zero or reverting. Okay, let's go further. Issue bond means a clone bond NFT to the specific address can only be called under specific conditions. Okay, mint role and probably it should be doing some verifications about it. Okay, here it is. Only kumaswap, which I understand will have that mint role. Can we take a look? Is it somewhere I was on top risk category.
00:10:39.414 - 00:11:11.550, Speaker A: Okay, that's something I don't understand yet. But anyway, some verification to make sure it has the right access, the right person. And we're minting with this apparently, yeah. Token id, token id counter. Okay. The id is basically incrementing probably from zero, thus the id that is passing and the C bond clone pond struct storing metadata. Okay, not sure, but let's go on redeem.
00:11:11.550 - 00:11:45.726, Speaker A: Okay, so one for minting, another for taking it out, right. Burning, exactly. Minting, burning, getting command address, get pond clone bond pond id bond struct storing metadata of the select bond id. Do they have any, what do they have there? What do they have here for bond? Oh, that's a lot of things. Bond, Kuma bond Kuma bond selling bonds. Okay, we're going to understand a bond. As for now, an NFT what it is, what it is.
00:11:45.726 - 00:12:30.730, Speaker A: That's what it is. But yeah. Okay, in general, we know that this class, it is extending, it's upgradable and it is minting and burning overall and it has some permissions. Let's see, what's the next contract? A clown NFT token that is issued when the Kibt yield is not high enough to buy back the original bond NFT. Okay, MCAG comma protocol again now, MCAG rate feed contract that reads the price from the MCAG central bank. Okay, let's take a look then. Let's see.
00:12:30.730 - 00:13:15.706, Speaker A: Uups upgradable open sapling. I honestly don't know that. Can I see it? Yes, an upgrade upgradability mechanism designed for UUPS proxies. What are UUPS proxies? Let's find out. Uups proxies are implemented using an ERC 1967 proxy. Note that this proxy is not by itself upgradable. It is the role of implementation to include alongside the contract's logic all the code necessary to update the implementation address that is stored at specific slot in the proxy storage space.
00:13:15.706 - 00:14:08.906, Speaker A: And if we google this ERC approxy using EIP 1967 storage slots not upgradable by default. Okay, not upgradable by default. There are two alternative ways to add upgradability to an ERC 1967 proxy, transparent upgradable proxy and uups upgradable, an upgradability mechanism to be included in the implementation contract. Okay, so I understand that this contract might be an years in 1967 or part of that proxy or maybe in this project and by adding this we're making it upgradable. Okay, what is the difference? Oh this one also had it. Okay, let's go on. Let's go on.
00:14:08.906 - 00:14:26.866, Speaker A: Yeah, we have some constants, minimum rate coupon, some decimals probably for the token. Okay. Only manager. So managing the roles. We have the same here. Okay, we have it marked in the first one. No need now to mark it again.
00:14:26.866 - 00:15:04.282, Speaker A: Initializing the initialize function of course is the one that it's running when it's deployed. There is this thing I discovered a while Ago. Wait, it has the initializer? Yeah, probably this one. I needed to extend this, this initializer, it has some checks in there. Probably was coming from this Indonesia. Is it implemented here? Did I jump it? Oh, here it is. Modifier that defines a protecting slicer.
00:15:04.282 - 00:15:26.118, Speaker A: Anyways, the thing is that those that are upgradable contracts need to be going through this logic. You can take a look that separately. But yeah, that's the thing. I learned that it's important. I actually have it in a tweet on my account but yeah. And actually made a thread about it. Anyways, let's go this there.
00:15:26.118 - 00:15:51.130, Speaker A: Let's go on. Okay. We're setting an oracle set, an MCAG aggregator for a specific risk category. So probably this was a kind of bank, right. So it might be off chain. I guess if there is the need to set an oracle there is no need for staleness check. A central bank rate is fairly updated.
00:15:51.130 - 00:16:07.230, Speaker A: Okay. Yeah. So it's probably just to check the rates. Okay. That means that we need to make sure there is no issues with the oracle. Okay. That could take us to in these cases.
00:16:07.230 - 00:16:58.946, Speaker A: Of course we're going to continue checking but when you want to go deeper you would go to solo audit and check about Oracle's exploits and so on because there are some things that you need to verify always. But we're not going to try to understand the logic here. As I say, this is not, I mentioned at the beginning we're not going the full audit here. And anyways at the beginning of an audit it's there to do an overview, know what it's around and then it's when you go deeper and try to dig deeper there everywhere, understand everything more specific get rate. Yeah. So this is probably used to get the rate from the oracle. What else we have? Get Oracle and other stuff.
00:16:58.946 - 00:17:09.506, Speaker A: Cool. One down. Let's close this. Okay. Yeah. Feed. Yeah, definitely read the price from the central bank.
00:17:09.506 - 00:17:21.530, Speaker A: Great. Oracle. It was mentioned there. What's the next? Address provider? Address provider, I've seen that before. Yeah. Address provider that stores the mappings. Okay.
00:17:21.530 - 00:17:44.980, Speaker A: Stores Kumasub and Kuma fee collector for each risk class. Okay, let's take a look. Address provider, what? Open separate. Okay. It's upgradable like potentially all of those, but we'll see. Okay, some mapping here. We'll see what this about.
00:17:44.980 - 00:18:02.374, Speaker A: Only valid address. Another check probably will be. Okay, that's nice way to not repeat the code. It's checking. Probably another function here that this address passed. It's not zero. That's a good way.
00:18:02.374 - 00:18:25.726, Speaker A: Let's go back. We've seen that before. Initialize. Okay, we're setting a BC token, I think we read somewhere that it was. This contract is handled by address provider. That's probably what's happening here. Setting the KBC token that's defined on top.
00:18:25.726 - 00:18:58.650, Speaker A: Okay. Probably reused somewhere else. We will see probably this made so that whenever it gets upgraded it will change the address. So if you would hard code it here on the top and make it a constant or similar, then yeah, it would not be ideal or might not be even possible to change it. But yeah, let's see. Kuma bond token. Okay, similar thing and Kiv token.
00:18:58.650 - 00:19:37.138, Speaker A: We can see here some other logic. I don't know that yet. Let's see if we find out later what else. Sadkuma fee collector. Okay, yeah, apparently there are some face about it for sure and some getters, usually in the getters, you want to check this part that it's a view and of course external because that way it's probably taken by other contracts for sure. Get comma swap and check risk category that was here. Yeah.
00:19:37.138 - 00:20:10.078, Speaker A: Inset comma fee collector. Okay. Market some other decoding, some other call here because we're passing bytes so we would need to take it out with Avi encode. Okay, so this contract, it's doing mainly, I think it's well, setting or defining some of the tokens that are in this Kuma protocol. Handling that. Yeah, setters and getters here. Okay, we've got that so far.
00:20:10.078 - 00:20:36.562, Speaker A: What else? Kuma fee collector, comma fee collector. Let's see. Role initialize release. You know what, let's see if we can find something about a fee collector here office. Nothing here office. Okay. Release releases the accumulated Income to the payees.
00:20:36.562 - 00:20:55.902, Speaker A: Okay, makes sense so far. Okay. We're probably getting the balance of the kib token. I keep saying kai kib token. We didn't go through it yet, right? No. Okay. But it seems it's cutting the fees I guess.
00:20:55.902 - 00:21:17.298, Speaker A: Okay. Available income zero repaired. What? Probably we're really. Oh, there is an internal function. So here it's handled some checks and then we go to the internal. If we can go directly to that so we don't lose context. I want to see it's going to be in this same class, that's for sure.
00:21:17.298 - 00:21:37.290, Speaker A: Okay. Internal helper function to release an available income tool. Uses total shares to calculate correct share. That's the address of the token. Available income that we passed before that we passed that we passed here. Available income. Okay.
00:21:37.290 - 00:22:06.022, Speaker A: If we were to improve the gas thing, we could mention this, but that's very little thing and everyone knows it anyways. So it's going through all the payees that must be defined on the top. I don't remember it. It's probably a set of addresses, those I guess that are involved in any swap probably. Let's see if I can go back where it was. Release. Okay.
00:22:06.022 - 00:22:43.540, Speaker A: And it's transferring to them, probably their shares. Total shares. This could be, when I see a division like this, first thing that comes to my mind is possibility to be divided by zero. So I wondering if at any point that can happen that would revert the transaction so we can track it a bit also in the file, what's its path. So it's obviously defined there and just privately. And it's increased when we add a payee. So it's never going to be zero.
00:22:43.540 - 00:23:13.306, Speaker A: Okay, let's go back to the release. Yeah, I guess you will not release if you never added a payee. So yeah, I guess it's probably fine anyways. And it's not like I don't know if we can remove them, but we'll see. Okay, so that's basically release doing so so far we are. Let's then go back to the beginning because we have seen the release. The first function.
00:23:13.306 - 00:23:35.618, Speaker A: Yes. Add payee. So we'll update total shares and therefore reduce the relative share of all other payees. So that means that needs to be doing some logic here. Okay, let's go on. So we can remove payees and it's external, but only manager can. Okay, so cannot be or should not be manipulated by everyone.
00:23:35.618 - 00:23:52.486, Speaker A: That's good. Let's go on. Function update pay share. Okay, updating probably reducing or decreasing. Increasing it or decreasing. Makes sense. Change page.
00:23:52.486 - 00:24:14.880, Speaker A: Okay, you can change the list. Okay, there's some logic there, but let's go on release if available. Income will execute in the internal release anyways. Okay, next. Here it is. Kib token. Here you are.
00:24:14.880 - 00:24:40.742, Speaker A: Let's see what's in here. ERC 20 permit upgradable, and of course uups upgradable like all the rest. Okay, initialize, set epoch length. Okay, not sure what's epoch minus five. Miss this rebase interval in seconds. Okay. Anyways we can set it here.
00:24:40.742 - 00:25:06.782, Speaker A: What else we have refresh yield, base on current yield and oracle reference rate. All right. And we're minting. It's overriding. Okay, timestamp refresh. Okay. Updating the balances and of course if we're minting, of course not, but we're burning as well.
00:25:06.782 - 00:25:36.498, Speaker A: Yeah, I'm not going to go through the logic, but there seems quite a lot of it. Some getters getting the total supply or transferring. This might be interesting to look closer. If the balance is less than the amount, of course don't transfer it. We are doing the actions here, so it's check interaction. Okay. Some calculations, I'm not sure what's the converting.
00:25:36.498 - 00:26:25.490, Speaker A: Okay, and is it transferring here? Where is the transfer function? Okay, I think this check, I would add it more on the top because if it's zero then you could have avoided that logic, but total base balances and then we're remitting the transfer. But I didn't see the, do you think the transfer is somewhere here? It's not. What about here? Well, I'm not sure, I don't see it, but. Yeah, might be very obvious I'm not seeing it, but let's see, I might come back to this or we'll see later. All right, let's move on. Refresh. Cumulative field updates, internal state variables after accounting for newly received tokens.
00:26:25.490 - 00:27:31.130, Speaker A: Okay. Calculate previous, calculate cumulative yield, some verifications. In general, these verifications, these checks are usually in the docs and that's what, once you go deeper in the code, you would go there, read what it's mentioned and make sure it applies in the code and it's properly noted. For now, as I mentioned, I will be doing just the overview and then go to the box. But let's see. I would expect also feedback from you guys if by any chance you feel it would be or it's not helpful enough, or you rather have a second part or something like that being more specific. But I guess since we're going to check the box later, I think this series of videos should be right to do the overview and the box check, the report check.
00:27:31.130 - 00:28:14.410, Speaker A: But again, we're just trying to get familiar with it so we can understand better the issues. We're refreshing the yield, we're getting the contract Kumaswap. I think we're going to check that later. Again, some checks that is not expired or deprecated, getting some information and verifying it. Okay, probably those are just used in here in one of the other functions I wanted to say, but yeah, calculate previous airport cumulative yield and authorized upgrade. Let's move on. Where am I here? So I think the last one, biggest is Kumaswap.
00:28:14.410 - 00:28:47.030, Speaker A: I think since we read here that's the main contract. Let's see what is there. Let's see what we find. Okay, it's extending its interface. Possible upgradable. What is a possible upgradable? Let's check because I'm not sure about that one contract model which allows children to implement an emergency stop mechanism that can be triggered by an authorized account. Okay, let's see.
00:28:47.030 - 00:29:19.070, Speaker A: This model is used through inheritance. It will make available the modifiers when not post, when post. Okay, I expect to see that in the code and note that they will not be possible by simply including this model only once the modifiers are put in place. That makes sense. Okay, let's see this kind of library, I guess formats. Let's see, let's go on. Set unique coupons.
00:29:19.070 - 00:29:45.590, Speaker A: Set awful Tokens ids. Set all expired token ids. Kuma bond token id to. Okay, that's a mapping quantity in reserve. Bond id to bond sell price. Okay, we can see when not deprecated on our modifier. When deprecated, initialize, initialize.
00:29:45.590 - 00:30:24.418, Speaker A: Okay, verification of the address. Passed this one and this one. What is this? Maximum coupons. We have them defined here. Okay, so let's see. First function here we have cell bond cells, a bond against kib token. What are we doing inside some checks? Kibt, what are we going to do with it? Reference rate.
00:30:24.418 - 00:31:19.490, Speaker A: We're getting there from the oracle I guess. Okay, minimum coupons. Basically doing some verifications at the time of the invariance, probably that everything is as it should, whereas, yeah, okay, we're minting with the cell bond, we're minting the kib tokens to the message sender and transferring it to this address, okay, to this contract, comma swap. It's keeping the tokens. All right, buy bond. So probably a lot of checks again and burning. So we sell, we mint, and if we buy we burn.
00:31:19.490 - 00:31:59.714, Speaker A: Okay, I will stay with that for now. Okay, there is a situation where it may do the transfer back to the if required clone host. This if the bond phase value is major, unrealized bond value. Unrealized bond value comes from. Okay, here it is. Required clone or not required clone. This will be important to double check this amount and make sure it's as it should because it seems very important here actually, for now.
00:31:59.714 - 00:32:43.966, Speaker A: Again, we're just skimming through it. Okay, buy pond for stablecoin buys a bond against deprecation. Stablecoin requires an approval on amount from buyer. This will also result in some stealth state for the contract on coupons and main coupon, but this is acceptable as deprecation mode is irreversible. This function also ignores an existing clone bond, which is the intended behavior as bonds will be valued per their market rate of chain. Okay, buy bond for stablecoin. We're removing the tokens from the reserve.
00:32:43.966 - 00:33:14.554, Speaker A: I'm wondering if we can read a bit more about it because didn't get much from that. One known limitation about deprecation mode is the fact that the manager role can spend the buyer's allowance in the buy bond for stablecoin function. Okay, this is the bond. Look, it's on the structure. I have probably missed it somewhere. It has all these parameters. Okay, let's go back.
00:33:14.554 - 00:33:52.226, Speaker A: Okay, yeah, as you see, we're doing the checks, we're removing it and then we're sending. Yeah, that's good. That's protected with the check how it was called. Check interaction actions, something like that for entrance wise to be protected even though there is no modifier for rentrancy. But this is a good practice. Claim bond, James Bond. Okay, claims a bond against a clone bond can only be called by Kumasov.
00:33:52.226 - 00:34:24.362, Speaker A: Claim role address. Okay, only role. So this is not for every user, but for the owners. Okay, and what are we claiming exactly? We use redeem from KBC token contract redeem was burning. Yeah. So by claiming we are burning the KBC tokens in the Kumaswap claim bond function. Okay, burning and then sending that token.
00:34:24.362 - 00:34:58.154, Speaker A: Idbond id okay, we're halfway. This contract redeem Kibt redeems kibt token against the application mode. Stablecoin redeems table coin amount is calculated as follow. Okay, do we know where is that calculation here? Okay, this is it I guess. Yeah, and it's multiplying before dividing. That should be the right way. And that's the library used.
00:34:58.154 - 00:35:32.040, Speaker A: Okay, what else? What do we do with this redeem amount we're transferring it through the deprecations tablecoin contract before burning it. We're burning the amount. Transferring redeem amount. Okay. Why this amount is in this operation? Probably it's kib token amount. So this parameter, isn't it? I hope so. All right.
00:35:32.040 - 00:36:13.250, Speaker A: Expire bond expires a bond if it has reached maturity by setting min coupon to mean allowed coupon when not deprecated, it's external. That's a bit od that it's external. If you can expire a bond, anyone can really. It's not checking who is running this. I don't know if this can be an issue here. I'm still not sure what this supposed to do but what's the main action? We're adding spare. See in this case, seems like a proper place to add another tag.
00:36:13.250 - 00:36:54.290, Speaker A: There is no access control. I'd say. Well, access control is external, maybe no role control. Let's leave it like that. No role control. Let's see later if there's actually something with this. And remember it was mentioning about the pausing and unpaused it comes from possible upgradable okay, setting fees, income and swap set deprecation stablecoin sets a new stablecoin to be accepted during deprecation mode I want to read something about the deprecation mode.
00:36:54.290 - 00:37:52.370, Speaker A: KIBT is minted and burned such that the total supply is always sufficient to buy out all the Kuma bonds nfts held in the contract. However, in extreme cases, some of the Kibt supply might become inaccessible if large amounts of KibT are hacked or lost to unknown addresses. This could result in Kuma bonds nfts being locked in the Kumaswap contract. To mitigate this scenario, the DAO can vote to put Kumaswap contract in the application mode where users can buy bonds with stable coins through voted on parameters. It's like a way out mechanism. Apparently, since there is a unique commerce subcontract for each risk category, one deprecated commerce contract for a given risk category does not impact other comma subcontracts. Okay.
00:37:52.370 - 00:38:26.522, Speaker A: And this one is activated. Okay, let's go back to the code here. We're initializing it in Kumasat. Okay, get risk category. I mean here they mentioned enable deprecation mode, but for now the idea is clear. We're enabling here. We're dealing with a deprecation mode here and some getters might be the rest of it might be getters and some other checks with some yes function parameter.
00:38:26.522 - 00:38:51.990, Speaker A: This is a callback. Okay, this callback function from ERC 721. So I guess it's normal it's not used. Okay. And yeah, it always needs to return that selector or at least. Yeah, maybe some other logic, but at least that selector sounds good. Update minimum coupon.
00:38:51.990 - 00:39:25.422, Speaker A: I'm not sure we found out what are the coupons here? The coupons of contract won't allow users to sell bonds to the contract which have a lower coupon. Is anyone explaining those coupons? Oh, well, not exactly. Okay, here, annual interest, annual interest rate paid on the bond per rate per second. Okay. Interest. Okay. And some actions unchecked.
00:39:25.422 - 00:40:01.600, Speaker A: Okay, nice. Gas optimization here with unchecked calculating fees. Something I learned about a way to improve the gas optimization of this is usually that this is more expensive than adding this, for instance, like that. This is cheaper like that. So that's another possibility. But I'm sure nowadays it's reported by the bots. I said robots earlier, but yeah, I guess bots is better probably used.
00:40:01.600 - 00:40:33.670, Speaker A: Were we at the end already? Think so, yeah. Okay, so we have all Kuma protocols. We've quite a while here already. An hour and a half, I think. Let's see. I'm wondering, it might be worth to jump to the report already. Those are in MCAG contracts are connected with the external bank thing, the Oracle and so on.
00:40:33.670 - 00:40:52.670, Speaker A: Let's see. KYC token. We could check that quickly maybe, but that's the connection with the Oracle. Most likely we have that one KYc token, Kumabon token. That's also important. Actually, you know what? Okay, let's take a look. The KYC.
00:40:52.670 - 00:41:22.710, Speaker A: Let's go to the KYC. Let's close this KYc token. Here you are. Should we read something here about KYC? KYC tokens? KYC tokens are non transferable ERC 721 tokens minted to a specific address only after the owner of that address has undergone. And now your customer. Okay, so it's literally okay. Good to know.
00:41:22.710 - 00:41:58.082, Speaker A: So definitely, it seems this protocol requires that KYC verification. Okay, that makes sense. That's why it's called KYC. For those, in case you don't know, that's where you need to identify yourself, basically by providing id and what other kind of identification? So they can assign your address to someone. Okay, let's leave it there. That's good enough information. What's happening here? Let's see.
00:41:58.082 - 00:42:18.934, Speaker A: Mapping token id to KYC data. What is this KYC data? Can I see that? It's probably a struct. Yeah. Okay, good. Let's go back. This is not upgradable, for instance. That's why we see the constructor and not initialize anymore.
00:42:18.934 - 00:43:07.758, Speaker A: Okay, we're passing the access controller address, I guess, of that contract and we have a function for minting using safe mint. Using safe mint has a trick because it has this callback. I'm not going to check it now, but I know it's probably covered but worth checking, you never know. Check for callback because safe mint has something. Can I enter that? Okay, now. Oh it's here. Anyway, safe mint has mint and has this check on ERC 702, one received.
00:43:07.758 - 00:43:55.282, Speaker A: I think we've seen that being implemented in another contract, I don't remember now but yeah, it's basically going to a callback function. It's going to enter the smart contract that called it and look for the function on ERC 721 received. And if it's not there, most likely will fail, you will revert. Okay, let's go back on track. So we're minting, we're burning, setting Uri. Okay, some getters proof approved, not used any parameter. Talking is not transferable.
00:43:55.282 - 00:44:23.026, Speaker A: So it's probably, yeah, it's overridden to make it not transferable. Okay that makes sense. Actually that's interesting to read. It makes sense for the KYC token. I'm wondering if it's not implemented, it's such token somewhere where it can be reused. KYC token most likely not, but yeah, could be interesting to google it. I want to eat now but yeah, feel free to check it might be interesting to find out.
00:44:23.026 - 00:44:49.994, Speaker A: I might do it later. We're not transferring. Okay, so we're overriding so that it's not allowed in case of being called. Okay that's good. How's the next contract from this folder? Okay, YC token, Kumabon token, let's check that one. Kumabon token. It's also ERC 721.
00:44:49.994 - 00:45:16.130, Speaker A: It's possible and implementing this interface. Okie dokie not. Okay, here there is a whitelist or blacklist, apparently more blacklist. So not blacklisted. I guess it's a whitelist throws if argument account is blacklisted. So if it's blacklist it would not continue, it would revert. Okay, got it.
00:45:16.130 - 00:45:52.474, Speaker A: Constructor defining the NFT parameters. Okay, issue bond mint bond NFT to specified address this address and we're using safe mint and we have a redeem for burning. Okay, similar probably. And is it transferable? Apparently yes, but we're still overriding it. Anyways, changing the logic. Okay, so basically it's adding this extra verification, apparently. In case it's not handled.
00:45:52.474 - 00:46:03.214, Speaker A: It's not handled. And running. Approved. The internal one. Okay, this is transferable. We've got that. It's just adding some extra information.
00:46:03.214 - 00:46:08.780, Speaker A: Sorry. Verification. Okay, so that will be it.
