00:00:00.410 - 00:00:29.874, Speaker A: Hello, guys. What's up? Today is the day that you're finally going to understand how to create your invariant test. I am that confident because after I did this study session, my understanding of invariant testing has grown 200%. I want to share it with you. The deal for this video is the following. I've got a guest that you love that will explain what invariant testing is about and how to define invariants. And before diving into the code, I I want to give you a short but necessary comparison between fussing and invariant testing.
00:00:29.874 - 00:00:52.400, Speaker A: Right after, we'll jump to write the test for an automated market maker contract. And, guys, this is the outcome that you don't want to miss. All those are invariant tests that I created from a simple amm contract, okay? So stay tuned because we'll go through those. All right, the foundry code is here for you, guys. Enjoy it.
00:00:55.760 - 00:01:53.870, Speaker B: Invariant testing in smart contracts is about repeatedly trying out different combinations of actions to make sure the contract always follows its core rules, even in unusual or unexpected situations. It's like playing a complex card game, where you shuffle and deal the cards randomly and then play them in random order. Each card represents a command or action in a smart contract. After playing each card or performing each action, you check some basic rules to make sure the game still makes sense. In foundry's context, consider each run of a test as a separate session of a card game, with each session comprising multiple rounds or calls. During each session, the game is played multiple times and different strategies or test scenarios are employed in each round. The aim is to explore various outcomes and ensure that the rules or invariants of the game are always upheld, regardless of the strategies used.
00:01:55.140 - 00:02:41.912, Speaker A: Thank you, my man. So, okay, let's go through the difference between invariant and fast testing. Invariant testing is about ensuring internal consistency and adherence to predefined logical conditions, while fast testing is about assessing how software handles unexpected and potentially invalid external inputs, with a strong emphasis on identifying security issues and vulnerabilities. So let's go through some points. Objective and focus, methodology and nature of testing. Let's start with focus and objective. So, on the invariant testing side, we have that the primary objective is to ensure that certain conditions or invariants, always hold true throughout the execution of a program, regardless of the program state or the inputs it receives.
00:02:41.912 - 00:03:54.996, Speaker A: On fast testing, it aims to uncover vulnerabilities and ensure robustness by fitting invalid, unexpected, or random data as inputs. On the methodology side, let's see, what's the difference? On invariant testing, it involves defining specific invariants in the software and then repeatedly checking these invariants at runtime to ensure they are always true. Then, on fast testing, it employs the generation of random or cell to random data, that's the so called fast, which is then used as input to the system. And the third comparison is in the nature of testing. On invariant testing side, we have that it's deterministic in nature, as it relies on specific predefined conditions that must always be met. But for testing, it's nondeterministic and more exploratories, since it involves generating a wide range of unpredictable inputs to test how the system responds to them, particularly focusing on edge cases and unexpected scenarios. Let's see now how to define invariance, shall we?
00:03:55.178 - 00:04:53.860, Speaker B: When identifying invariance, it's essential to consider the contract's fundamental purpose, how its functions interact with each other, and the broader financial or operational logic it embodies. Each function, variable and event can give insights into what should remain constant, what conditions must be met, and what the contract aims to achieve or maintain at all times. This understanding then guides the creation of invariants for testing and ensuring the contract's reliability and correctness. Learning invariant testing might get complicated, and defining those invariants from an existing code is tricky. So we are going to implement a simple AmM based contract, and before testing it, we are going to see which are its invariants and how to define them to prepare for testing them. Well, I don't want to take the credit, so mainly blowcarl is going to show you in a comprehensive way how to create the tests, introducing all relevant features of invariant testing. All yours, boss.
00:04:54.920 - 00:05:34.496, Speaker A: Alright, let's start the fun part. As you know, automated market makers are a crucial component of DeFi. And while each AMM can have its unique mechanism and features, there are several general invariants that typically apply across different AMM implementations. Here is our simple amm contract that we will use for the sole purpose of learning about invariant testing. So, taking a look, we can see that there are mainly four functions here. The add liquidity one, remove liquidity, swap token a, port token b, and get swap amount. Okay, now it's time to start defining the invariants for our simple AmM contracts.
00:05:34.496 - 00:06:25.856, Speaker A: So let's see where and how can we extract those invariants. So we will be defining, let's say in plain English, what the invariant is about, and of course we will be implementing it. So first the definition, then the implementation. And well, as you can see, I'm going to leave here in the left side the main contract, and on the right we will be analyzing them and so on. Okay, so the first one is the constant product invariant. And in this case, after any operation adding or removing liquidity or swapping tokens, the product of reserve token a and reserve token b should remain equal to constant product. What's the purpose of this invariant is to ensure that the AMM maintains its defining characteristic of a constant product market maker.
00:06:25.856 - 00:07:08.576, Speaker A: And as you can see here is the implementation in foundry where we define the variables and we are adding the assertion right there. All right, next is the reserve non negativity invariant. Here, the reserve token a and reserve token b should never become negative. This ensures the contract does not end up in a state where it owes more tokens than it holds. And there's a clear purpose here is to verify that these operations do not result in negative reserves, which would be physically and financially invisible. Here we can see the implementation with foundry. And by now you probably have already noticed that environment test is not about having too much logic in it.
00:07:08.576 - 00:08:01.860, Speaker A: It's mainly to assert that those environments are met. So that's why the main coding in those tests is the assertions. Let's go now with the third invariant, swap rate fairness. The rate at which tokens are swapped, or what we get with the get swapped amount function, should always be fair according to the current reserves. This means after a swap, the product of the reserves, adjusted for any fees, if applicable, should stay the same or very close to the constant product. And the purpose of this invariant is to ensure that the rate at which tokens are swapped is fair and consistent with the constant product formula. And in the implementation with foundry that we have here, remember to define an appropriate tolerance, and then we get the assertion after checking if the product is close to the constant.
00:08:01.860 - 00:08:34.164, Speaker A: Okay, things are getting interesting here, because at this stage I have written a handler contract to be able to add restrictions to my test. Let's first of all go through what is a handler and why I need to use it. Let me tell you the definition of what a handler contract is. A handler contract acts as an intermediary layer between my test and the simple amm contract. It's essentially another smart contract that wraps the function of the simple amm.
00:08:34.312 - 00:09:03.080, Speaker B: Good one blow, Carl. Now let's go through why we need to use a handler for key points here. Modularity, reusability, complex interactions and boundaries. First point, modularity. A handler can encapsulate specific behaviors or sequences of interactions. This is particularly useful when you have complex interactions or need to maintain certain states between calls. Second one, reusability.
00:09:03.080 - 00:09:41.300, Speaker B: You can reuse the same handler logic across different tests, or even different test suites. This can be more efficient if you have a set of standard operations you perform in multiple tests. Third, complex interactions. If your testing involves complex sequences or setups, like preparing a certain state before calling a function, a handler can abstract away these complexities from the test itself. And fourth, boundaries. Often in order to properly test your invariant and avoid false failures, you will have to specify some maximum and or minimum integers to restrict the possibilities for the fuzzer.
00:09:42.040 - 00:10:03.500, Speaker A: Cool. I hope it made some sense to you. I think it was very nice explanation, so thank you. And yes, you have been seeing here on the right side there is the simple amm handler contract. And just to say a couple of things about it. First, as you can see, we need to define with a constructor some kind of setup. So we're defining the instance of the simple amm contract and adding some liquidity.
00:10:03.500 - 00:11:11.500, Speaker A: And later, as you might notice in the three functions, add liquidity, remove liquidity, and sub token a. For token b, we're using the bound function, and that's mainly what, as the name says, to restrict also the values that can be used. And going back to our invariance, we go to the fourth one, liquidity addition and removal consistency. So adding liquidity and then removing the same amount should leave the reserves and change, ignoring any transaction fees or other external factors that might affect the reserves. So the purpose of this environment is to confirm that adding and then removing the same amount of liquidity leaves the reserves and change varying transactions fees or other factors. And here we can see the implementation with foundry, where we're basically adding liquidity, removing liquidity, checking those values and then asserting them, basically so that to make sure that the invariant matches. And here we go with our fifth invariant, no token creation or destruction.
00:11:11.500 - 00:12:15.792, Speaker A: The contract should not create or destroy tokens. The sum of the tokens in the research plus the tokens held by users should always equal the total supply of the tokens. Now, the purpose of this invariant is to ensure the contractors does not inadvertently create or destroy tokens which would violate the conservation of token supply. Now let's look at the implementation with foundry, because, well, in this case I added this calculate user health tokens function, that it was kind of figurative because I didn't implement it. And then at the end, as usually we are adding our assertions of the invariance, but stay around because there's another way of handling this function, and it's with ghost variables, and we will be handling it in another invariant in a moment. Now, invariant number six, positive liquidity. So the contract should not allow the addition of zero liquidity.
00:12:15.792 - 00:13:13.640, Speaker A: Both token a amount and token b amount in add liquidity must be greater than zero. And here the purpose is to ensure that liquidity addition is meaningful, or let's say nonzero, and aligns with the economic logic of the amm. And here we can see the implementation and we have our assert true assertion invariant number seven swap amount validation. Here the amount returned by getswap amount function must be less than or equal to the current reserve token b when swapping token a for token b. And here the purpose is to confirm that the calculated swap amount is always within the available reserves. Otherwise, if you would require more tokens and it's not available, it would fail. So yeah, let's see about the implementation with foundry here.
00:13:13.640 - 00:14:15.452, Speaker A: For the just sake of the test, I added a hard coded number in the variable for random amount token. But in this case, let's assume that we have a function or a way to just get the actual random number. And yeah, that way we are able to test that depending on the amount that we send, that there is always the right amount to return and otherwise, of course, you would fail. And let's go now with a very important invariant, and that's solvency. So after any swap, the contract must remain solvent, meaning the reserves must be sufficient to satisfy the constant product formula. And here we want to ensure that after any operation, the contract remains solvent and can fulfill its obligations according to the constant product rule. And I think here we have the implementation with foundry, and we used another hard coded random number there.
00:14:15.452 - 00:15:01.972, Speaker A: But yeah, then it's used for asserting that the validations of the invariants are accomplished. Oh wait, what's that? Oh, watch out. We have found a vulnerability in our contract. Yes, that's correct, guys. There was nothing protecting our simple amm contract of assuring solvency. And this environment test has just pointed that out. So in order to mitigate this, we will have to modify our simple amm contract and add some logic to our remove liquidity and to the swap token a for token b functions such as we see here where we are adding the requires to make sure that the reserve token a and token b is always above 500.
00:15:01.972 - 00:15:52.500, Speaker A: That way it will avoid having some issues with the solvency. Two invariants to go, guys. Here is the number nine event emission consistency, and here we ensure that every state changing function emits the correct event with accurate parameters reflecting the state change. And the purpose is to guarantee that the contract accurately reflects state changes through events which is obviously crucial for transparency and tracking. There's no implementation in foundry, as you see in this case. From my point of view, this is an invariant that will need to be done manually, and yet is as important as the rest. And last, by no means least, is the user balance consistency invariant.
00:15:52.500 - 00:16:58.700, Speaker A: So here, the balance of a user's tokens should reflect the sum of their provided liquidity, plus any tokens not deposited in the contract. This is more of an external invariant, but it's crucial for endtoend testing. And here the purpose is to ensure that the contract's operations correctly reflect on the overall token balances of users, maintaining the integrity of users holding. Now, why don't you see here the implementation? Well, spoiler alert, a new cool fasting concept is coming. Okay, so we can agree that it would be complicated, or maybe not even possible to simulate such a scenario to control the flow of added, removed and subtokens. So at this stage, it's time to bring in and start using the so called Gauss variables. Let's see what they can do for us, and how are we going to use it to test the user balance consistency invariant? So first of all, Gauss variables are essentially state variables that are used only for testing purposes.
00:16:58.700 - 00:18:22.010, Speaker A: They're not part of the actual contract logic, but are added to the contract during testing to keep track of certain states or values that are otherwise not explicitly stored in the contract. So where do we add them? Definitely not in the production version of our smart contract, as I've mentioned. So the next best thing, what is it? Is the handler we created earlier, isn't it? So we can use these ghost variables in our simple amm handler contract to track a state that is not otherwise exposed by the contract under test. And here you can see now how our contract looks after adding the ghost variables. Keep an eye on the ghost expected balance token a and token b variables that are defining here state variables in this mapping. And as you will see, we are well first of all in the constructor adding the instantiating them with 500. But then for every time the user will use any of the functions, as we can see in add liquidity, it's going to deduct from that amount for the message sender, or add in when removing liquidity or when shopping, depending on the token it's removing, and then adding it.
00:18:22.010 - 00:18:58.788, Speaker A: Also, we will need a way to retrieve the list of users addresses. So in this case, we will need to add the state variable, user addresses, and the functions below at the end of our handler. You can see we have the function get user addresses, add user address function, the internal, internal one. And then we have to check if an address is already in the list with the address exists function. Okay, that's good. We have that handler done. So let's use now the ghost variables in our test to track user balances and liquidity provided over time.
00:18:58.788 - 00:19:56.152, Speaker A: The idea here is to assert that the expected token balances tracked by the ghost variables in the handler always match the actual token balance of the users. So here is our test, and as you can see, we're using the ghost balances, and those are the ones that we are going to use to see if the expected and the actual balance is as expected. All right, so this is it, guys. So as I mentioned earlier, this was something that I did for myself to improve my invariant testing skills. And as you can see, I have gone through the invariant test on my vs code. And yeah, at the end, I have run the eight of our invariant tests because one of them, I didn't have the function implemented, and the other one is the one for the event. And here is the result.
00:19:56.152 - 00:20:26.640, Speaker A: Just wanted to show it that they all pass. And yet, this is very successful work, guys. So now you should be ready to take this idea and start applying it in your smart contracts or on those habits you're participating in, because it's going to be extremely useful. I'm sure it will help you to find some vulnerabilities. All right, guys, thanks for watching. If you liked it, consider subscribing and hitting the like button. And remember, stay tuned, stay innovative, and most importantly, stay connected.
00:20:26.640 - 00:20:28.480, Speaker A: See you next time. Bye.
