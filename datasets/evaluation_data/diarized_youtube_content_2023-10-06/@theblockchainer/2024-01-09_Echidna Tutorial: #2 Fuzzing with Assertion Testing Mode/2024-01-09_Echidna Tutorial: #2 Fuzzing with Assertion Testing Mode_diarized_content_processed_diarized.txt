00:00:00.810 - 00:00:57.850, Speaker A: Hey everyone, how's it going? Today we're going to see how to run a hidden test in assertion mode. Last lesson we were checking how to run a hidden test in property based mode. The main difference is going to be that instead of returning a boolean, we'll not be returning anything, and instead using the keyword assert. So let's leave this behind and let's start with our new contract incrementor. In this case I also took it from the repository that is provided from trail of bits. I just modified it a bit so that I can play with it. Let's see, we have this contract incrementor and we have just a simple function here that is going to take a value in the parameter of the function and it is going to use to increase the main counter, and of course it will save the new counter and then make an operation.
00:00:57.850 - 00:02:08.518, Speaker A: So we will see different ways of running the test with assertion mode. Let's go with the first one and it's by adding the assert and then the assertion that we want to check, which in our case, let me see, is new counter should be smaller or equal than counter. And let's see now let's save this and let's see how to run it. So if we remember from the previous time with a hidden dot, and then we specify the contract, in this case our core contract, so the incrementor and we need to add a flag, test mode and assertion. And like this, we specify that we want to run the test cases or the test, the code in this class or this contract like this. So surprise, we see that it fell. So that's very nice, because it's telling us here that it had to run, it could run two times the increase function and every time it passed different random value.
00:02:08.518 - 00:03:22.778, Speaker A: And that goes that eventually there would be some failure on this function. So let's see how else we could, what's the second way to test this? So for instance, maybe let's comment this. The next one will be adding, actually let me start by adding the event assertion fail, because actually let me see if we run it again, usually, yeah, there you go. So it's always running the assertion failed event. So in this case that's another way that we can assert or we can fail the test without adding the assert. So that's why we are adding, for instance, I think we can add value like that. So we have the event and now instead of having the assertion we could add the condition that the new counter is smaller or equal than counter, and in case it's true.
00:03:22.778 - 00:04:10.226, Speaker A: He would enter here and it would emit the event assertion failed amount with the amount, no, with, let's say the reason why it fell, which is the counter. There you go. So this should be doing the same. Let's now run the heat. Now let me clear first. Okay, so now we can run again and let's see the result. So it also caches the failure, and as you can see, we don't have the assert, we've saved the code, and it also gets it to fail, and it gives us the assertion fail with the number, the value that actually caused the failure.
00:04:10.226 - 00:04:58.954, Speaker A: Okay, so this is basically, those are two options, two ways of adding or having the code tested in the same function. However, usually, at least from what I've done so far, we want to have, well, if we are doing an audit or just checking someone else's code, we don't want to edit it or we're not eventually going to edit. So that's when we want to create the test file. So I already have it here. Created is the Hina incremental assert, for instance, I added the assert part because obviously we're doing the assertion based test. Let me just clean this. Okay, so we have it as before, as we started, and now we can open it.
00:04:58.954 - 00:06:00.478, Speaker A: So yeah, this is a file, but we're adding a contract. So the test file is a contract, we are importing our incremental contract and extending it. So now if we want to execute it as it is, the thing that we need to do is come here and modify the target contract to a hidden incremental assert. And if we run it, we can see actually that it is running the functions above. And okay, we have removed it, so that's why it doesn't fail. But if we bring it back, let's say in the last way that we had it, let's run it again. Let me clear, if we run it, it's failing, of course, let me run it again, because I want to show you something.
00:06:00.478 - 00:07:15.240, Speaker A: Because while it is running that function that it's failing, it is also running other things from the contract, in this case the variable, and it takes it as if it were an assertion. But I will tell you more about it and how to clean up the report. But for now, let's work on this test class on this contract test, and I'm going to modify the main contract that we had here. I had it prepared, so it's basically the same. Just modify the function a bit and we have the calculate function and we want to now go to our file for where we want to add the test and create our first function. Let's see, function, let's say, let's start with assert, and for instance counter is equal or bigger. That's basically the condition that we're checking earlier and needs to be public.
00:07:15.240 - 00:07:59.186, Speaker A: Okay, and let me add directly the code that I have to make it faster. Good. So now we have our new function as an assertion test, and we are passing, we need to pass to our increase function and amount, which we are defining here inside as local variable. And then we are doing our assertion that a new counter is smaller or equal than counter and just running the calculate. So this will only run if this doesn't revert. So let's execute it. So yeah, we use the same command as before, that the function or test has actually passed.
00:07:59.186 - 00:08:49.602, Speaker A: Why did it pass? Because now the amount that we're passing, it's fixed is 25, and that doesn't cause the assertion that we have added to fail. Now we also can notice that it's, as I say, kind of polluted with some of the function from the main contract. And yeah, I want to show you how to get rid of that. Or maybe it may be more convenient to avoid having that in case you want to send a report to someone. So in that case we need to do the following. We're not going to extend it, but we're going to deploy the contract in this contract. So for that we need the constructor and we need to deploy it there in the constructor.
00:08:49.602 - 00:09:32.130, Speaker A: Now of course we need to, let me make this a bit smaller. Now pass it here, here, and these are called like if it were a function, and here. So the difference if we save this, if we run it, is that we now only see the function that we are using for testing. Now, another interesting thing, and this was a big headache I had for quite a while. I didn't understand why my Hina tests were not actually running in assertion mode. Actually they were not visible. And let me show you what was happening first.
00:09:32.130 - 00:10:20.002, Speaker A: I had all the tests starting with a hidden, and if you run it like this and you have the assertion mode, look what happened. It's ignored. So watch out with that. Don't get confused because it might make you get a bit crazy and potentially even lose quite some amount of time. So yeah, we want to bring back the assert instead of a hidden. So so far we have noticed that in this way it actually doesn't fully work because it was actually passing when it's supposed to actually fail. So what we want to do is one of the best thing of using the assertion mode with a hidden is that we can actually it's going to be similar as when it was running it here.
00:10:20.002 - 00:11:02.814, Speaker A: By adding the parameter in the function, it is going to use a randomly generated amount and it's going to pass it here. So basically, as we saw it before, so let's run it and we can see that it passed a very big amount and that's why it keeps failing. And of course we don't have it polluted with other functions of the main contract. And there is yet another way of running the test with assertion mode. So far as you can see, we have been running it with a test mode assertion flag. So a test mode flag with the assertion. And so there is another way.
00:11:02.814 - 00:11:49.500, Speaker A: And this is basically I have here the config yaml, so you usually don't have it, so I created it. And here when you add, you need to add the test mode and assertion as it is. So the idea is that now instead of running it with this flag, you add the flag config and you add the name of your file, in this case config Yaml. And we will see that running it like that is also going to trigger the test that we've built. It's taking into consideration the parameters that we're passing here. So that's it for now, guys, thanks for watching and stay tuned for more. Take care.
