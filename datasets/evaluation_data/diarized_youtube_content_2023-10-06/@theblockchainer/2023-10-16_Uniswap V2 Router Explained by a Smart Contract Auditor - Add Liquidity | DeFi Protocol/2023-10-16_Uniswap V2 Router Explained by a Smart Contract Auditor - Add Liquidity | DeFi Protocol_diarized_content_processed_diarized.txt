00:00:00.410 - 00:00:55.998, Speaker A: Hello everyone, I'm the blockchainer and in today's video we'll deep dive into the heart of Uniswap's v two router smart contract exploring add liquidity function line by line. But there's more. After the indepth analysis of the code, I want to raise some potential risks of the protocol and impact on the users. Let's start as part of Uniswap ecosystem, the v two router plays a crucial role in facilitating liquidity provision. Our focus today, the add liquidity function is what enables users to supply assets into the liquidity pool, an essential action for the operation of the Uniswap exchange. Now let's jump into the code and dissect the add liquidity function found in the Uniswap bit to router two contract. So yeah, let's start here we have the function.
00:00:55.998 - 00:01:48.346, Speaker A: So let's start by going through what are those parameters that it requires. So we have token a and token b, which are addresses of the ERC 20 tokens that are being provided as liquidity. Then we can see the amount a desired and amount b desired, which are the desired amounts of token a and token b. The liquidity provider wants to add to the pool the amount a and amount a min and amount b mean is the minimum amounts of token a and token b the liquidity provider is willing to add to the pool. These values serve as a safeguard against price slippage between the initiation of the transaction and its execution. Then the two address is where the liquidity tokens will be sent. Typically this would be the address of the liquidity provider.
00:01:48.346 - 00:02:49.778, Speaker A: And last we have deadline, which is a timestamp, after which the transaction will revert. This is to ensure that the transaction is executed in a timely manner. We can see here also that there is a modifier ensure and this custom modifier declaring the contract is to ensure, as the name says, that the function call is still valid by checking the deadline. And next to that there are the returns, the return values where we have amount a and amount b, which are the actual amounts of token a and token b that will be deposited to the liquidity pool. And then there is the liquidity. That's the amount of liquidity tokens minted and sent to the two address. Now let's analyze the function's content, shall we? In the first line we can see the call to the internal add liquidity function.
00:02:49.778 - 00:03:21.950, Speaker A: So let's take a look inside of it, inside the internal add liquidity. It will check if a pair of those two tokens already exist. And in case it doesn't, it will create a new one. And that's inside this if condition. Then it needs to get the existing amount of the tokens, or also known as reserve a and reserve b, which we can access through uniswap v two per contract. And that's this part. And let me show you exactly inside how it looks.
00:03:21.950 - 00:04:17.902, Speaker A: Here is the getreserve function, where you might know this or not, but it actually has to sort it first. And as you can see here, it depends on which is the smaller amount or which is the bigger. And then there is the call for the pair four that is returning the reserve a and reserve b. All right, so the external function add liquidity returns amount a, amount b and liquidity. So how does it calculate it? After getting the reserves mentioned previously through insolve v two library, there are a series of checks. If the pair didn't exist and the new one was newly created, amount a and amount b returned will be amount a desired and amount b desired, which were the ones passed as parameters. And that we can see here.
00:04:17.902 - 00:05:04.474, Speaker A: If there is the condition in the if and if it is like that, then the amount that we will return are just those that we pass. There won't be any calculations or any operations. Otherwise. It will do this operation that I'm going to show you here, because it's again calling unison v two library. And there is the function quote. Let's jump into it and let me show you that after some checks it's going to multiply amount a with reserve b and divide it with reserve a value in order to get the amount b. If the amount b is smaller or equal to the amount b desired, then it will return the amount a.
00:05:04.474 - 00:05:58.170, Speaker A: Amount b will be the amount a desired and amount b optimal. Otherwise, and as we can see in this else it will return the amount a and amount b being amount a optimal and amount b desired, where amount a optimal is calculated the same way as amount b optimal. Let's go back to add liquidity main function. So far we know how amount a and amount b are calculated. Let's see now how the liquidity to return is calculated. First of all, it is going to deploy the Uniswap v two pair contract with the address of the existing or newly created pair. How does it do that? Let me show you the function pair four, which is again in the unison v two library.
00:05:58.170 - 00:07:06.694, Speaker A: As we can see here, it calculates the create to address for a pair without making any external call. This pair for function returns the address of the newly deployed contract which we will need in order to mint the tokens from this pair of tokens. When you add liquidity to a pair, the contract means lp tokens and when you remove liquidity, lp tokens get burned. Let's go back to the main function. So again, first we get the address using per four from Unisop v two library, we can see that the output of per four is going to taken us as another pair address, so that later can mint the ERC 20 tokens and calculate the liquidity to return the liquidity. And we can see here it's the address that it's going to be minted to them. In case you're wondering why it ends up being an ERC 20 inside the mint function, it's storing it like this.
00:07:06.694 - 00:08:19.238, Speaker A: It's the uint balance zero and balance one and it's as you can see, the ERC 20 token. Interesting, isn't it? Amazing guys, we have gone through how adding liquidity works under the hood on Uniswap. Now, have you ever wondered how adding liquidity affects the overall uniswap ecosystem? What benefits you get as a liquidity provider, or what potential risks exist? Let's go through these aspects. Some of the impact on the liquidity pool are the following liquidity addition the liquidity function is crucial for the process of adding funds to a liquidity pool in uniswap. When called, this function updates the reserves of the pool by adding the specified amounts of two tokens. It thereby increases the total liquidity in the pool, which is essential for enabling trades and maintaining a lower slippage in the exchange rate. Between the two tokens is the price stability, which by allowing users to add liquidity, the function contributes to price stability.
00:08:19.238 - 00:09:23.970, Speaker A: A well funded pool can absorb larger trades without a significant impact on the price. And there is the token pair availability, where the function also facilitates the availability of different token pairs on the Uniswap exchange by allowing users to create new pools or add liquidity to existing ones. Let's talk about the benefits for liquidity providers where the liquidity provider or LP liquidity provider tokens. When liquidity providers add funds to a pool via the unliquited function, they receive LP tokens in return. These tokens represent their share of the pool and can be redeemed for the underlying assets at a later time. The fees liquidity providers earn a portion of the trading fees generated from the trades that occur in their pool. The amount of fees earned is proportional of their share of the pool and the arbitrage opportunities.
00:09:23.970 - 00:09:56.102, Speaker A: Liquidity providers can potentially benefit from arbitrage opportunities that arise from price differences between Uniswap and other exchanges. Now, not everything are benefits. There are some potential risks and I want to go through them. Maybe you've heard of it. There is the impermanent loss. This is a significant risk for liquidity providers. It occurs when the price ratio of the tokens in the pool changes compared to when they were deposited.
00:09:56.102 - 00:10:56.654, Speaker A: If the price of one token rises significantly compared to the other, liquidity providers may incur a loss when they withdraw their funds from the pool. There are some smart contract risks there is always, as we can see, as we have seen, a risk of bugs in the smart contract code. Even though UNicef's code, of course, has been audited, the risk of a smart contract bug cannot be entirely eliminated. There are some regulatory risks where the regulatory environment around defi and liquidity provision is still evolving, which could introduce risk to liquidity providers. And there is the price volatility. A high price volatility can affect the amounts of assets liquidity providers receive when they decide to withdraw their liquidity. That's all for now, guys.
00:10:56.654 - 00:11:21.540, Speaker A: In the next video, I'll dive into remove liquidity function, another core feature of the units of vitroder. If you found this video helpful, please give it a thumbs up, share it with your network, and consider subscribing for more in depth analysis on blockchain technology and smart contracts. Feel free to drop any question or suggestion in the comments below. Thanks for watching.
