00:00:00.250 - 00:00:01.390, Speaker A: What is fuzzing?
00:00:01.730 - 00:00:03.866, Speaker B: Get ready for some alpha boys.
00:00:04.058 - 00:00:39.670, Speaker C: Oh, yeah, dudes, you better get ready for this journey, because from now on, the fuzzing God is with us. It's truly time to get our hands dirty, not only with foundry, but with fussing in general. That's why today, as the beginning of a fussing series, we will dive into the fascinating ocean of fuzzing in order to understand it. And before setting up our testing foundry. That's right, guys, you're getting your setup ready, and you're getting it ready today. And to start, we will learn what is the core concept of fuzzing and how applies on web three and smart contracts. All yours, Scott.
00:00:40.250 - 00:01:01.870, Speaker B: Fuzzing, or fuzz testing, is a technique where invalid, unexpected, or random data is passed into a system to discover coding errors and security loopholes. When applied to web applications, fuzzing targets common web vulnerabilities by determining data injection points to identify which entry points might be susceptible to such vulnerabilities.
00:01:02.450 - 00:01:04.506, Speaker A: What's the idea of fuzzing?
00:01:04.698 - 00:01:06.466, Speaker B: Let's give an example so we can.
00:01:06.488 - 00:01:08.850, Speaker A: Clearly understand the idea of fuzzing.
00:01:09.190 - 00:01:12.722, Speaker B: Let's say you have a program that asks for your age and you're supposed.
00:01:12.776 - 00:01:14.020, Speaker A: To type in a number.
00:01:14.470 - 00:01:24.920, Speaker B: Fuzzing would be like having a disobedient robot that instead of typing in a number like 30, types in all sorts of weird stuff like banana, a really long number, like nine, nine, nine.
00:01:27.690 - 00:01:28.006, Speaker A: Or.
00:01:28.028 - 00:01:30.898, Speaker B: Even nothing at all to see how the program reacts.
00:01:31.074 - 00:02:14.502, Speaker C: That's right. And if a program gets confused and stops working when it gets banana, then the fuzzing has found a flaw. And now, how do we bring that idea to web three? In the context of web three and smart contracts, fuzzing often takes a property based approach. It is like the robot testing a digital vending machine. In this case, the smart contract, that's supposed to only dispense a digital soda, which would apply as a cryptocurrency transaction when it receives a digital coin. This approach consists of rigorously testing this contract's logic and rules against a wide range of inputs and scenarios. These properties are also known as invariants, and their main purpose is to define how the system is expected to work.
00:02:14.502 - 00:02:45.762, Speaker C: On fast testing, the user is responsible for identifying and adding them to the test. A couple of examples of invariant property to make it easier to understand would be, for instance, that no one should be able to withdraw more of the protocol than they deposit, and that the total supply of an ERC 20 token does not change unless the function mint or burn are called hey fuzzing God, why don't you tell us why it's risky to not use fussing and how we will benefit from using it.
00:02:45.896 - 00:02:47.250, Speaker A: You got it, boss.
00:02:47.670 - 00:03:03.430, Speaker B: Let's start with an example. Imagine a DeFi platform that allows users to deposit cryptocurrency and earn interest over time. The smart contract is responsible for handling user deposits, calculating interest, and enabling withdrawals.
00:03:03.930 - 00:03:06.950, Speaker A: I'll give you two potential risks without fuzzing.
00:03:07.470 - 00:03:42.530, Speaker B: First one, without comprehensive testing, the contract might have vulnerabilities like reentrancy bugs. And second one, there could be errors in interest calculation, leading to either excessive interest payouts or not paying enough. However, applying fuzzing. First of all, it would aggressively test the contracts with a wide range of inputs, including unexpected and malformed data, to uncover hidden flaws like the reentrancy vulnerability. And second, it helps ensure that the logic for interest calculations and fund withdrawals works correctly, including edge cases.
00:03:43.110 - 00:04:07.066, Speaker C: Alright, as Janettan would say in his smart contract hacking course, it's hands on time. So let's set up for foundry Faust tests. It's time to learn and practice foundry, and I propose to follow this process to get us up and running. There are some steps that we'll go through the installation. The first steps with foundry, fast testing and invariant testing. You can get excited. Guys, it's coming.
00:04:07.066 - 00:04:31.822, Speaker C: Okay, so we will start with the installation. I'm going to leave you here the commands. So yeah, let's see. The first command to run on your terminal is this one that you can see here with a C URL. And then if you notice in the terminal, it will also point out to run Fomdri app. Now you have to install cargo to have available the rust compiler. Rust sounds familiar.
00:04:31.822 - 00:05:11.934, Speaker C: Anyways, here is a command, and the last step is going to be installing force plus cast plus ambivalent Cicel. And here is the wrong command that you have to run. Let's start with the first step with foundry, and we want to create a new project. So let's create it with foundry and play with it, because sometimes in the past you might have started, or you might be aware that you can start the project with Hardhat. So in this case, you create the foundry project and it creates its files, its default files, and the structure. So for that you need to run the forge in it. In this case we will call it safe example, as you can see here.
00:05:11.934 - 00:05:53.962, Speaker C: And now get inside a newly created project. So CD into it with this command and compile it with Forge build. Now, how do you execute foundry tests. In order to run all test cases from the repository, just run forge test. However, let's say you're working on test cases for a specific contract. In this example, let's consider we're working on this save t solved test file and you only want those to be executed. So what you can do here, so what you do is running this command with fourth style, which is passing this flag with a match path and the name of the file.
00:05:53.962 - 00:06:50.442, Speaker C: And another great feature that foundry offers while executing the test is to introduce more logs on the resources per demand, which will help you debugging into it and is control by adding a flag with two to five v's, such as you can see here in this command. And definitely the more v's you add, the more pervosity you will get in the test results. So meaning the more v's, the more information you can see here. If you check with Foundry, which is the amount of information that you get depending on the amount of vs, there's a bonus feature also that we get to have while executing tests with foundry. And it is the option to add a flag to get the gas report from the contracts function. This is the command and you can see at the end we add the gas report flag and the report will look like this. I think it's pretty fancy.
00:06:50.442 - 00:07:11.126, Speaker C: I liked it. I was very excited when I saw it the first time. So that's why I want to share it with you. I think it's time to do some fast testing. So I'm going to use the fantastic example from founders documentation or foundry's book to go through this. And here is this simple contract. The contract save with a withdraw function.
00:07:11.126 - 00:07:48.082, Speaker C: And then we want to write one unit test to make sure that the withdraw function works. And we have this separate contract for testing. And there is a small setup and the function test withdraw. There is the logic inside. So yeah, this test is simply checking that the balance from before withdrawing plus the amount transfer is the same as the balance after withdrawing. Now, who is to say that it works for all amounts and not just one ether? Here's when stateless fuzzing comes in. And stay with that name.
00:07:48.082 - 00:08:34.142, Speaker C: Stateless fuzzing forge will run any test that takes at least one parameter as a property based test. So let's rewrite it. And you can see that we add function test fuz withdraw. So by running this, we can see the forge runs the property based test, but it fails for high values of amount of the parameter amount that we're passing. And here we have the first example of fuzzing. Instead of testing one scenario by adding as a parameter the value that we need to test, it is going to use a vast amount of semi random values, and that might lead to finding a contractual vulnerability. Forge is printing as well some useful information when the test fails.
00:08:34.142 - 00:09:14.750, Speaker C: Let's explain what it is in that information. There is the runs, which refers to the number of scenarios. The faster tested. By default the faster will generate 256 scenarios. We have the greek letter mo is the mean gas used across all fast runs, and that line, the tiled or tilde, is the median gas used across all fast runs. You might find this so far pretty useful about foundry already, and I can agree with that. There's however much more potential of foundry to be explored.
00:09:14.750 - 00:10:00.670, Speaker C: Let's start with invariant testing. An invariant testing foundry is a stateful fuss test, and this is another way you're going to be hearing reading from people who refer to the same type of test. The key here is that in the same way as above, I mentioned that tests in foundry have to start with the prefix test, underscore and test fail. In order to write this type of test, you have to use the prefix invariant. And now is the time to see the stateful fussing in action. Let's see this in action by modifying a bit the contract we have used before. Here is the contract how we have it now, and here we have modified the withdraw function and added the chance to deposit ether.
00:10:00.670 - 00:10:26.770, Speaker C: The important point we want to test here is that the amount withdrawn must always be the same as the amount deposited. Yeah, we have the command here. I mean the contract with the invite and save test contract. And if I first run this test, I get the following output. You're going to like this. Here is the output. Oh yes, it passes.
00:10:26.770 - 00:11:00.394, Speaker C: But remember, always read the output, because in this case you can see that by running the invariant withdrawn deposit balance test, it gets this result. You have the rounds, calls or reverts. And that's correct. It is in fact reverting a total of 883 times. Then why the end fail? Don't worry, it is an expected result. In order to revert, we have to add the following to the foundry. Tom, file this flag.
00:11:00.394 - 00:11:38.490, Speaker C: Let's say this fail on revert. We need to switch it or to add it as true. And if you run it again now the result is different. Let's see the output. There's a super interesting thing happening here. Please notice the part with the call data and it shows the send some ether function and that is how the output tells you that the last function triggered that broke this contract's invariant. By adding a function to the contract that can be used to send ether to a different account, the invariant of withdrawing, always the same amount of deposited ether is broken.
00:11:38.490 - 00:12:20.440, Speaker C: If I comment out the function, send some ether from the contract, then the results would be the following and you can see that it's running and it works. The test result is passed. So there you have it. Fast testing is our secret weapon to keep smart contracts safe. Let's not postpone it and use this interaction to start applying this knowledge in your project or the projects you are auditing. Web three war will increase its security with more fussing I hope you enjoyed this video. If you did, just hit subscribe because there will be more coming and of course like it so that it gets to more people.
00:12:20.440 - 00:12:25.490, Speaker C: That's it. Stay tuned, stay innovative, and most importantly, stay connected.
