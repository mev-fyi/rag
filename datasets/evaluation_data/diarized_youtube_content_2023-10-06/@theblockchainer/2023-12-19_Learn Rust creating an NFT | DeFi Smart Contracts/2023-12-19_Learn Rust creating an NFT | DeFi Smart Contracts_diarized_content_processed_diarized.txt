00:00:00.330 - 00:00:41.260, Speaker A: Hello. Hey guys, what's up? I'm very excited to bring you a deeply explained way of building your NfT with Rust. Considering the fact that Rust syntax is new to most of us, I decided to make this video where I will be building the ERC 721 on my vs code, explaining every part I myself didn't understand while studying it. I am sure you are going to see a huge boost in your understanding of rust once you complete this video. Also, to make this more entertaining, we have our station AI master helping us along the way explaining some of the rust complex concepts, so I'll let her now introduce a bit of what's coming.
00:00:42.350 - 00:01:26.146, Speaker B: Hey guys, what better way to learn Rust than implementing one of our favorite smart contracts? Yes, let's learn rust while implementing our NFT. If you have solidity background, then this is a great way to learn Rust since you already understand the concept. Also, we will be referencing solidity as we advance on our contract by comparing how it looks for both solidity and rust. For those that come straight to rust, we will manage together to go through this interesting contract and its functionalities. What's our mission today? To learn rust by building an ERC 721 NFT contract using ink. And trust me, it's going to be an enlightening experience. And the second one is scale, or simple concatenated aggregate.
00:01:26.146 - 00:01:41.706, Speaker B: Little Endian is a codec for efficiently encoding and decoding data. The scale library is a crucial part of the substrate stack, and it's used for encoding and decoding data. Let's continue to add now our token ID variable and listen up, because learning time is on.
00:01:41.808 - 00:02:17.490, Speaker A: All right, so if this is your first time with rust and you don't have your environment set up, I recommend you to go to my other video. I will leave it in the description where I am guiding you, how to set it up and how to get started, and also some of the basics. So yeah, it will help you to understand this one better. So that said, let's start creating our new project. And as you can see here, I already have it created, but I did it with cargo new, and the name, which in my case is ERC 721, underscore rust. So let's do it. So let's start.
00:02:17.490 - 00:03:04.598, Speaker A: We are going to be adding the code part by part, and I will be, as mentioned earlier, explaining as much of it as I consider. So yeah, in rust code, it's organized into models, which are collections of items like functions, structs, and trades. So yeah, that's why we're going to start with a contract model declaration. Let me add it here. I will not be writing step by step like everything on the go, but I have the code aside and I will be pasting it as we go. So this is our model declaration. And now we need, as we know from other languages, some imports, and in rust we use the keyword use.
00:03:04.598 - 00:03:41.620, Speaker A: Let me add the imports and we can continue. Let's go. Yeah, so this use statement imports necessary items from libraries. The ERC 721 contract needs several items from ink and scale, and that's why we're adding those. Let's see, what exactly are they for? I was curious when I saw the mapping one. So in rust, especially when working with ink, for smart contracts development, mapping is an essential import. So it's somewhat similar to the concept of mapping in solidity, but with rust safety and type system.
00:03:41.990 - 00:04:01.578, Speaker B: And the second one is scale or simple concatenated aggregate. Little endian is a codec for efficiently encoding and decoding data. The scale library is a crucial part of the substrate stack, and it's used for encoding and decoding data. Let's continue to add now our token ID variable and listen up, because learning time is on.
00:04:01.744 - 00:04:53.942, Speaker A: So in an ERC 721 contract, each token is unique and needs a way to be distinctly identified. And this token ID serves this purpose. Now, I was curious, what is this type? Why are we defining it like that? So in rust, type is used to create an alias for another data type, in this case token ID, and it is defined as an alias of U 32. So the unint 32 integer and using type makes the code more readable and clear. When you see token ID in the contract, then it's immediately understood that this refers to the unique identifier of a token, as opposed to just seeing a generic number. Okay, let's see. We will be adding now the struct of our contract.
00:04:53.942 - 00:05:46.566, Speaker A: Let's see. So yeah, let's see what we have here. We have the attribute ink storage, and this one marks the struct that represents our contract storage. In the context of smart contracts, then using this attribute derived default is a convenient way to set up the initial state of the contract when it is deployed. For an ERC 721 contract, it signifies that initially there are no tokens, no approvals, and no ownerships recorded. This approach simplifies the constructor, the new function of the contract, and instead of manually initializing each field, you can simply return self default. We will see that in a moment when we are implementing the constructor, and it will get a new instance with the default state, some of the structure.
00:05:46.566 - 00:06:23.318, Speaker A: We have things. The parameters that we have here is the token owner, which maps token IDs to their owners. Then the token aggregate, the token approvals, which it tracks the approvals of each token, their own token amount that maps accounts to the number of tokens they own, and operator approvals that tracks operator approvals for accounts. Let's go on. And we will be adding now the error enum. So yeah, we now define an enum for error handling to manage different error cases. We have already seen what is encoded on the code.
00:06:23.318 - 00:07:50.334, Speaker A: So yeah, let me tell you a bit of this debug attribute, which implements the debug trait which allows instances of the enum to be formatted with the specific operator that we will see also later on with a question mark. And this is very useful for debugging purposes to print values of the enum in a human readable format. Then we have the partial IQ or Ec, and the partial IQ or equal allows instances of the enum to be compared for equality using the double equal or the different operators like this one or this. Yeah, and the IQ is a marker trait that indicates that the equality comparison is reflexive, symmetric and transitive. Then we have the copy and clone, which is a marker trait indicating that instances of denum can be duplicated simply by copying bits, and the clone, which provides a method to explicitly duplicate an object while copy is implicit, clone can be used explicitly. And now what do we have here? What is this long attribute? So this is a conditional compilation attribute. It means that the type info trait from the scale info crate will only be derived if the STD feature is enabled.
00:07:50.334 - 00:08:35.234, Speaker A: So here the type info is used to provide metadata about the type, which is specially useful in the context of smart contracts and off chain tooling. Now the CDFG attribute is a condition attribute macro engraft. It applies the specified attribute based on a condition. So the syntax is basically we define it with this CFG attribute, then it goes the condition, and then it goes the attribute like that. And it means that apply attribute if condition is true. Let's move on now to the event definitions. Let me add them.
00:08:35.352 - 00:08:50.466, Speaker B: Events like transfer approval and approval for all in our ERC 721 contract play a vital role in providing transparency, enabling real time tracking by external observers, and facilitating interactions with offchain applications.
00:08:50.658 - 00:09:24.686, Speaker A: Let's go now to more interesting stuff. Let's start with implementing our constructor. We have mentioned earlier that there is a nice way or different way to instantiating our variables. So let's see so the purpose of this constructor is to initialize a new instance of the contract with default values. It's a common pattern. All right, let's start now with the contract implementation, and we're starting with the constructor. We see, I have it here already.
00:09:24.686 - 00:10:04.174, Speaker A: And yet the purpose of this constructor is to initialize a new instance of the contract with default values. It is a common pattern when the default values are sufficient for the initial state of the contract. For the sake of better understanding, I want actually to show you how this looks in solidity. So let me just grab the code and I will maybe just paste it here below because it may look a bit familiar, but look at this. Just ignore that error and so on. But this is basically what it's doing. It is the constructor and it is instantiating the values in the same way.
00:10:04.174 - 00:10:47.402, Speaker A: The thing is that here with Russ we have this option and you don't need to add the specific values. So that's probably now easier to understand. And yeah, let's go on. I think it's now time to start implementing the functions of our NFT, and we're going to start with the functions for token ownership and transfers. So what I'm going to do is I'm going to add the functions balance of owner of, transfer and transfer from. So let me paste them here. And yeah, we have them balance off owner of transfer and transfer from.
00:10:47.402 - 00:11:37.546, Speaker A: So yeah, the idea that we're going to do in this video is that, yes, we have the code and we want to understand everything that is in the logic or in the implementations or the attributes or tags or anything that we are not aware of. So that when we read the code, we are aware of what's actually happening here and what it is for and so on. So let's start as you notice here with this, I'm saying attribute in this ink message, and this indicates that the function can be called externally. In other words, it's a public function that's part of the contract's interface and can be invoked by users or other contracts. Then another thing, let me highlight it here. Yeah, I noticed this. I was wondering what it is for.
00:11:37.546 - 00:12:05.602, Speaker A: So this is called an error propagation operator, and it is used for concise error handling in rust, and it is a shorthand for propagating errors up the call stack. So for now we can see that these functions are external and are not handling any logic inside them yet. So mainly calling internal functions. So yeah, we will go now through those internal functions, logic. Let's start with the balance of or zero.
00:12:05.736 - 00:12:11.606, Speaker B: This is a good example of rust safety and conciseness in handling potential option types, let's see why.
00:12:11.708 - 00:12:58.482, Speaker A: In handling potential option types, let's see why. As the function name claims, this function is designed to return the total number of tokens owned by a specific account, but also it says or zero. So let's see where is that defined and what it means. Yeah, and that's mainly in this unwrap or zero here. And this basically says, if the option is sum, give me the contained value, but if it's none, then return zero instead. It ensures that if an account doesn't have an entry in own tokens count, the function will return zero instead of causing an error or panic. So that's interesting, actually, we can see that rust handles constantly those type of errors.
00:12:58.482 - 00:13:40.206, Speaker A: The next function that we want to see is the transfer token from and the purpose of this function, it's obvious. So let's focus on some parts of the syntax that we might not know yet. I mean, we know it's transfer token from. So for those at least that are familiar with solidity, we know that we're probably going to pass some account and that we're going to transfer the tokens to. Right. However, I'm sure that looking now at the code for those that didn't see such implementation before, it might raise you quite a few questions, or at least it did to me. So when I was trying to understand this, I searched for the solutions.
00:13:40.206 - 00:14:09.954, Speaker A: I want to share them with you. The first thing is the return type. So this result. So basically, this result type in rust, it is an enum used for error handling. It has two variants, this okay here and the error. And the okay is representing success and containing a value. And the error with the error inside is representing failure and containing an error.
00:14:09.954 - 00:15:15.714, Speaker A: So yeah, here, this indicates that the function will return either success or failure. And this empty parentheses inside the okay is rust unit type, indicating that no actual value is returned on success, just an indication of success. Then another thing that I want to point out is the sum. So you can see here, for instance, is sum color. I think I have mentioned just a few moments ago already, sum or none. But let me tell you a bit more about that, because sum is a variant of the option enum in rust, and this option can either be sum or none, and it's used when a value might be present, and that would be sum or absent, and then it's none. So more specifically on our function, this, for instance, this sum color indicates that there is a valid account Id present and the same we have here for the appropriate address pass for, from, and to.
00:15:15.714 - 00:15:44.214, Speaker A: The next thing is this way of passing the emitting the events. So yet this is a method provided by ink environment that allows our contract to emit events. Let's move on with the next function. And that is going to be exists. It is a pretty simple function. Let me add it. And yeah, as the name says, it determines if a token identified by ID exists in the contract.
00:15:44.214 - 00:16:19.810, Speaker A: Think there's not much more to add here. We can see it's returning the boolean. So let's move on with the next function approved or owner. And this is a very interesting topic. There is an interesting function because we're going to learn some pretty cool stuff. At least it's cool because at least cool once you get to understand, because the first time I saw this function, I was a bit concerned of what is happening here. Just want to remind you that usually because we see it's returning a boolean, but we don't see an actual return in rust.
00:16:19.810 - 00:16:57.330, Speaker A: So just wanted to remind you that in rust, as you can see, as in solidity, we add the semicolon at the end of the lines. Right. However, in the functions with the last line, if that's the return value, let's say, or the expression, then it doesn't have the semicolon. And that's why this is a condition this is going to return, true or false. So let's start with like, let's go through these things that we might not understand. And the first thing is this line. And yeah, let's go part by part.
00:16:57.330 - 00:17:31.166, Speaker A: Let's see the account ID from zero address 32. So I already said a kind of tip there, the zero address. So this creates an account ID representing a default or zero address, which is an array of 32 bytes all set to zero. This is akin to an uninitialized or null address. Then we have it's sum, the sum that we've seen before, which wraps this zero address in an option. As from is an option account ID. So it's that type, right.
00:17:31.166 - 00:18:05.510, Speaker A: It's an account ID. And then the condition checks if from is not equal to this zero address. So yeah, most likely, like, I'm sure you already kind of visualize what I mean, but most likely you're familiar with the expression to check if an address is address zero with solidity. Let me just. I'm sure you know, but it would look so you can visualize it also, and it's easier to understand. I will just paste it here is this message sender. Message sender is not equal to address zero.
00:18:05.510 - 00:18:41.326, Speaker A: So basically, when we see in solidity a condition, let's say something like that, if message sender that. So this is the same that is happening here. It just at first might seem more complex because we are not familiar with it. And another thing to mention here is here in these two lines. But yeah, let's focus on this one. We see the owner expect, so. What's that expect? So, in rust, this line of code is asserting that there must be an owner.
00:18:41.326 - 00:19:16.766, Speaker A: So if owner is none, which shouldn't happen. If the token exists, the contract will panic with error with account ID. So this error that we can see here, and the same logic of course applies to this line, he will throw the same error. Okay, that's it for that. And then let's move two different type of functions. The token approval mechanisms and approval mechanisms allow users to approve others to transfer tokens on their behalf. Let's go through two functions, approve and set approval for all.
00:19:16.766 - 00:19:18.014, Speaker A: I will add them.
00:19:18.132 - 00:19:32.382, Speaker B: Have you noticed the rust operator? As we've seen earlier, this operator simplifies the process of checking for errors and propagating them if they occur, ensuring that the contract behaves predictably and safely in the case of failure conditions.
00:19:32.526 - 00:20:13.914, Speaker A: And let's move for the next function, and that's approve four. As you can see, I'm basically going deeper and deeper, right? Like we start from some of the external functions that we were also seeing with this attribute, the ink message, and then we are going all the time deeper. Transfer token from. And then I was checking here. Okay, we have these functions not implemented yet, so we need to implement them and understand them, obviously, so we can know what's happening and the same approve for then, or set approval for then we have approved for all and so on. And we are going like that. So now we're in approved for.
00:20:13.914 - 00:21:00.334, Speaker A: So this approved the pass account ID to transfer the specific token on behalf of the message sender. And I'm pretty sure that by now you have already noticed that you are able to understand every line in the function approve for. I mean, isn't it amazing? Because at first you didn't know why is this sum wrapping the color? Or you were not sure why it's returning. Okay, and what is that type that is being returned? So I think this is a huge progress. So you can be happy because you're going to use this knowledge later on, either to develop your own smart contracts or to review them. So let's go on next function will be approve for all. Here we have it.
00:21:00.334 - 00:21:40.530, Speaker A: And yeah, let's take a look at the main actions of the function which are insert and remove. These methods are used to manipulate operator approvals mapping which let me remind you what it was. Let's go back to the top. This is the one. So this is the mapping with account ID and account ID. And then this part is close parentheses and yeah, let's go back and here we can see insert and the parameters with both account IDs. So yeah, this is the key for the mapping and it uniquely identifies an approval relationship between an owner and an operator.
00:21:40.530 - 00:22:09.026, Speaker A: And then we have this part, the second parameter which this is the value to insert in the mapping. This close parentheses is rust unit type. And essentially it's representing no value or nothing. Good. So let's move on with token creation. Burning functions as you probably already know, minting creates new tokens and burning destroys them. And we are now implementing mint and burn functions.
00:22:09.026 - 00:22:56.294, Speaker A: Let me add them to our contract and yang here we have then the mint function and burn. So in mint we can see that mainly it's calling another internal function and then just emitting the event. So we will get deeper in the logic when we analyze in a moment the add token function. So let's focus now on burn. Let's see, so burn. What do we see here? There is this part and it caught my attention because I'm not familiar with this logic, with this implementation. So have you heard about the option to destruct yourself in rust? Well, let's see, what's the reason the function starts with this.
00:22:56.294 - 00:24:07.914, Speaker A: So essentially what's happening here is that we are extracting token owner and own tokens and on tokens account. Yeah, we're extracting token owner and on token count fields from the struct. And then with these two dots we are indicating that the other fields in the struct can be ignored. Now while this is not extremely necessary, it's a good practice to make the code more readable whenever the fields are used multiple times in function as it allows for shorter and cleaner code. So basically what this does is that instead, let me find instead of having to write every time this self dot on talking count or self and so on, then you're reducing it and making it cleaner. If you just declare this at first and then you forget at first and then you forget to add those like as you can see it's done in other cases. So yeah, let's move to another part of burn function and that's the OK, underscore or that we can see here.
00:24:07.914 - 00:24:52.746, Speaker A: This is a method on the option type, and it transforms an option into a result. And if the option is sum, it will be converted to okay, containing the value, of course. And if the option is none, it returns the an error with the error provided to the okay or function. Now, another thing happening here is so called closures, and this is a very interesting part of the burn function. And what's happening, and it's happening actually in the map. This is the closure that we're going to discuss now. So in rust, closures are defined using these bars, like whatever it's inside these bars, basically.
00:24:52.746 - 00:25:56.302, Speaker A: And the general syntax of a closure in rust is that you add the argument like argument one. It could be different arguments here or whatever, but at the moment, in this case, we just have one, and then the expression separated by space, basically those arcs, I say. Or in this case, the c are the parameters, and the expressions of the c minus one is the body of the closure. They are commonly passed as arguments to higher order functions, which are functions that take other functions as arguments and is particularly useful with iterator methods like map filter, fold, et cetera. Here, the closure is this, as I mentioned, and is passed to the map method, and it takes a parameter c, which is the current token count, and returns c minus one the new token count after burning a token. It's a consistent way to define the logic for updating the token count without needing a separate name function. That's good.
00:25:56.302 - 00:26:40.970, Speaker A: I think these two things that we have seen so far that we have analyzed the structure self enclosures are pretty cool to be aware of, and it will allow us to just understand much more what's happening inside the logic of many contracts. Let's move on and switch to utility functions that will have add token to remove token from clear approval, and that will be all of the or contract. So let's start with add token to. That's the function that we are using in the min function above that I mentioned earlier. So let me add it here and yeah, here we have it, all of it. Take a look, guys. Can you understand it?
00:26:41.120 - 00:26:58.100, Speaker B: Seriously guys, isn't it exciting that we are able to understand now the logic inside this function? We know it's destructuring the self as we have just learned. Checking if the token already exists, checking for a zero address, and updating the token count with the closure. Good job.
00:26:58.470 - 00:27:33.662, Speaker A: Well done, guys. Let's go to another function. That's the remove token from. We use it in the transfer token from function and we can see it is mainly decreasing the count for the specific address. Let me add it in a moment. Yeah, and as I said, it is decreasing the count for the specific address in this closure and the rest of the function's logic, I think we are lucky that we understand checking and adding the insert and remove that we've already analyzed. That's pretty cool guys.
00:27:33.662 - 00:28:26.282, Speaker A: The next thing, let's go with the clear approval function. Just a second, I will add it here and that will be our last function. So yeah, the clear approval function within the transfer token from function in our ERC 721 contract serves an important role in the token transfer process, especially related to resetting the approval status of a token. Once it's transferred, we have the implementation and yeah, we have it guys. So actually I will probably add the code for this NFT in the description, but yeah, this is taken from the ink directly from the ink documentation. So yeah, I was trying to learn how to implemented and wanted to share this with you. So not bad, right? What a journey.
00:28:26.282 - 00:29:32.770, Speaker A: So our exploration to building our NFT with an ERC 721 contract with Rust and ink has been a remarkable journey. Combining rust robust safety features with ink's blockchain specific functionalities. We've not only become familiar with the essentials of smart contract development in rust, such as handling modules, imports and storage structures, but also delved into the features of rust powerful error handling and even systems. Throughout this journey, we've seen how rust tape safety and inks domain specific tools come together to create a secure and efficient environment for developing sophisticated smart contracts. This experience has not only enhanced our understanding of rust in the context of blockchain technology, but also equipped us with the skills to tackle complex contract logic with confidence and precision. Now we can review our contract and see if it's actually doing the necessary checks, if it's checking for the address zero or just double check that it's properly implemented. Having this as an example.
00:29:32.770 - 00:29:59.774, Speaker A: So guys, thanks for watching. If you enjoyed this, please make sure of sharing it on your Twitter account or pass the YouTube videos to your colleagues. And yeah, so that way it can reach to more people trying to learn more about rust. And yeah, consider subscribing. If you enjoyed this. Hit the like button and see you in the next rust video, guys, and any other video. Thanks for watching.
00:29:59.774 - 00:30:08.010, Speaker A: Bye.
