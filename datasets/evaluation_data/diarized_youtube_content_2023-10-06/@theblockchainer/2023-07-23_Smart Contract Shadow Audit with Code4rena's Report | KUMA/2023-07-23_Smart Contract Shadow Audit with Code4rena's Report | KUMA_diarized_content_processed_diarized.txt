00:00:00.570 - 00:01:14.258, Speaker A: Hey, guys, how's it going? I'm blockar and I am actually excited because, well, I want to start this new series of videos for different reasons because, well, it's going to be shadow auditing, and I'm sure many of you are aware of what that is for those that are not. Shadow thing is basically getting to those past reports that we have, for instance, in code arena, and try to audit it ourselves without looking at the results. Right. So that once you check the framework, you go through the code, you make sure if you find some bugs, some issues, some different vulnerabilities. And the good thing of shadow auditing is that once you have done all you can, you have an immediate feedback. So that's when you go to, in this case, Colorina check the report, go through the issues found, and then you see what you miss or maybe what you got. Right.
00:01:14.258 - 00:02:43.460, Speaker A: And you are familiar with the framework because, well, you're supposed to get some understanding of the protocol. Of course, you have gone through the code, so you should be more aware of what is it about, instead of if you just go to code arena and you go to report and start reading the report of all the specific or all the reported audits there. So yeah, in this case, as I say, I'm choosing code arena because they have a lot of reports here. You're probably more than words of what's this? So I don't need to go through it, but as you can see, I go to reports in case, you know, and here you have all the past reports that are available already. I thought of starting with Kuma protocol. Why? Because, well, it's the first time I'm going to do this and I thought it is rather short repository, or at least the smart contracts on scope, and also the list of articles, sorry, the list of findings. Now I am doing this also recorded.
00:02:43.460 - 00:03:42.974, Speaker A: I got to be honest, I'm far from being an expert or even good at it. And I've been struggling so much to find time to audit, and I've really been wanting to do this shadow auditing for a long while. So I'm kind of understanding that I'm not the only one probably with issues, with time or with problems to focus on this. So maybe this way I can help. At the same time, I think this can be both ways. I can help those that can watch this and follow with me. And also I absolutely will need and want your feedback, any kind of improvement that I can do, because obviously you will be seeing how I'm so far auditing.
00:03:42.974 - 00:04:28.180, Speaker A: Right. So this is important for me because I have tons of things to improve, I have tons of things to learn and yeah, anyways, I think we can do this together and it might be okay. I'm here on the report side of Kuma protocol. So first we have the risk mark here, but we'll not take a look at those. We have to ignore it for now. We know where they are, but we'll come back here. I'm obviously going to go through it as the way I understand I have to do the audits the way I have maybe done the audits so far.
00:04:28.180 - 00:04:56.300, Speaker A: So don't take this as the go to way. You need to find your way, whatever fits you better. And again, I'm very open to improvements for myself because I need them, definitely. So yeah, I found that in the reports. They still share the repositories. Luckily I have it open already here. So let me change.
00:04:56.300 - 00:05:30.066, Speaker A: So yeah, here is the repository. So what we're going to do first, like new one should and like I am pretty sure lots of people recommend it, is to go through the documentation. Sorry. Let's see. Obviously this part is not for us anymore, the prices, but yeah, let's see what it says. I am going to try to read it out loud. Maybe I will not just read everything, but so that we have understanding.
00:05:30.066 - 00:06:01.774, Speaker A: So it says this repo contains source contracts and testing suits for MCH contracts and Kuma protocol. Each corresponding project directory contains documentation in Doc folder. So I see that there is a folder for Kuma protocol and MCH contracts which seem to be different things. I have them open here. I think you don't see it on screen but I have them open. I took a look at it and it seems it's two. Well honestly I still don't know.
00:06:01.774 - 00:06:31.594, Speaker A: But there are two folders and they have different type of files and smart contracts. So we will go through it actually together. Let's see here is the files in scope. Okay. They are ordering here. They are ordered from less lines to more. And you can see obviously that in this slock I think it was solid lines of code if I'm not mistaken, or maybe stand for something else.
00:06:31.594 - 00:06:56.990, Speaker A: But yeah, anyways it's good we have this here and a small description. So let's see, maybe. Let's try to find some information. Was there anything here? Okay, additional context. Okay, I'm not going to read much from this. Okay. Seen total 1634 lines, 22 smart contracts in scope.
00:06:56.990 - 00:07:09.186, Speaker A: Where else? Please read the talks. We are trying to. Yeah. Does the talking conform to the ERC 20 standard. Yes. Okay. And there is nFt.
00:07:09.186 - 00:07:31.706, Speaker A: Okay. Does it have an automate amm? No. Okay. And by this we can see that it's using foundry. That's good. And how to get quick started command. Okay, so let's jump to the docs.
00:07:31.706 - 00:08:08.220, Speaker A: Okay, so let's see Kuma protocol. Let's see what, let's read about it a bit. Crypto users are incentivized through token yields. Some projects have created significant yields. However, there is a lack of stable low risk yield generation that is transparent and verifiable. It is unclear where income is generated from and the lack of transparency and regulation are major deterrents for major institution and risk averse individuals to adopt crypto. Okay, sure.
00:08:08.220 - 00:08:27.194, Speaker A: What else? Bonds. Bonds. Bonds are financial assets that generate low risk income. Okay. They are common in traditional finance. I don't know if I should rid of that. But competitive regions and entities with decentralized systems.
00:08:27.194 - 00:09:06.698, Speaker A: The Kuma protocol aims to tokenize bonds. Okay, so bonds might be some kind of vaults, I guess, to tokenize bonds on the blockchain to create assets to generate low risk income while also utilizing the transparency and verifiability of smart contracts. Tokenizing bonds on the blockchain with publicly verifiable smart contracts enables users to hold stable, interesting bearing tokens and limits the risk exposure to off chain bonds. Okay, well, that's a lot of things there. Okay, we can see what it stands for. MCIG. It's Mimo capital ag.
00:09:06.698 - 00:09:34.498, Speaker A: The following components compromise the Kuma protocol. So you have that one, Kuma bonds nfts. Those are ERC 721, okay. That represent ownership of physical bond utility token. Kuma interest bearing bond token, that's a kibt. I'm sure we'll see that later in the code. It's an ERC 20.
00:09:34.498 - 00:10:08.122, Speaker A: For now I'm just going to read that much. We might just come back to this once we go into the code, but yeah, we will double check the information here. Kuma interest pairing subcontract. Okay. The subcontract holds all Kuma bond nfts. I'm sure that it's some interesting smart contractor, central bank, oracle rate feed keepers, keepers, monitor the kiBt, those two contracts. Kuma dao access controller.
00:10:08.122 - 00:10:53.120, Speaker A: Okay, Dao access controller for the centralized contracts of the Kuma protocol. Okay, there are two scenarios. That's interesting. Users who buy Kuma bond bonds nfts from MCH don't have to deposit them in the Kumaswap contract. The simplest user scenario is when a user buys a Kuma bonds NFT from MCAG, holds it until maturity and redeems it from MCAG after maturity. Okay, so the user buys Kuma and then redeems it. Okay, we will see that later.
00:10:53.120 - 00:11:39.340, Speaker A: This scenario might be useful for institutional investors who want a publicly verifiable ownership of a bond for auditing purposes, or those who want to keep their operations in crypto but want bond income. Okay, user scenario two. The second simplest user scenario is when a user buys a Kuma bond NFT. Wait, is that different from McG? Okay, that's the same. Okay, but not doesn't hold it, optionally holds it and sells. Okay, I understand there are different actions, we will see that in the code. But yeah, seems that generally you will be buying those NFTs from Kuma components in.
00:11:39.340 - 00:12:18.430, Speaker A: Oh, okay. There is a lot of, let's see what it says about these kiib tokens are rebase tokens minted and burned by Kumaswap. We'll find all this logic in that contract for sure. Yield collected by the Kuma bonds nfts reserve Kumaswap is distributed to Kiib tokens holders directly by increasing their wallet balance. Okay, there is a lot of logic here that doesn't make sense to read out loud, that's for sure. And we might be coming back to this later. ERC compliance and update.
00:12:18.430 - 00:13:02.040, Speaker A: Okay, it's implementing those methods that's good. However. Okay, ERC 20 token transfers with, they behave mostly like EIP 20 with exception of the available balance check and the cumulative yield refresh. A lot of things there. Balance accounting decentralized access control all access control logic for the decentralized contracts is handled by access controller. Makes sense. We have a pause function in the event where the DAO wishes to implement a failed safe mechanism in the future.
00:13:02.040 - 00:13:39.810, Speaker A: Only this Kai Bt swap row make call pause. Okay, we'll find that later. And pause. Also, centralized access controller Kumaswap allows users. You know what, let's go further and we will come back to those, there's a lot of idea. We will come back maybe to those. Once we land in those contracts, we can come here also and double check all the details so that we can understand more because it's a bit so much there to just read.
00:13:39.810 - 00:14:26.386, Speaker A: I don't think I'm going to be able to understand all of it for sure. Okay, you know what I had in mind? Something that I like to do is to check. Like I googled Kuma protocol and I could see their site. So I find it very helpful to see an interface, Ui interface of the protocol if possible, or their site actually. In general, I'd like to learn more about it or just to see what is it. In this case, it seems kind of clear at least the main functionality is swapping tokens, so I think I find it useful. So wanted to mention that, but I found these results on search.
00:14:26.386 - 00:15:25.220, Speaker A: I wanted to share that also with you. Yeah, I don't think I need to do much more. I can see anyways buy and sell NFTs. That's definitely the main functionalities. So I do have the code already cloned on my computer. So yeah, I have it here. So yeah, I wanted to mention as well that an audit, like a real audit, it's supposed to take you a lot of time because, well, you need to take usually as much time as it's offered in the public contest to audit properly, to take the most or to push yourself the most, to try to understand it to the fullest and to actually get the most.
00:15:25.220 - 00:16:02.394, Speaker A: Well, look for a high, right, high severity issue and so on. This is not going to be the case. I don't plan to spend here 7 hours or five, or probably, I guess not even three. We'll see how much. This is the first time I honestly have not even do a shadow audit on my own. Before I thought of just doing this directly with you. I wanted to mention that, that I will treat this as an overview.
00:16:02.394 - 00:16:32.134, Speaker A: I want to get familiar with the protocol before checking the findings. That way probably will be much easier to understand. I'm not saying I will understand all the issues, but I think this is going to be very helpful. Also, we'll be getting familiar with many different type of protocols. So yeah, let's do this. Let's go through the. Well, actually we need to make sure the protocols.
00:16:32.134 - 00:16:58.910, Speaker A: Sorry, the smart contracts are on scope that we're going to check. So did I have it here? Probably here. Okay, so you know what? Yeah, let's start with. Why not? Let's start with the one with less lines and let's go from there. Okay, so Kuma access controller using Kuma protocol. Let's see. Kuma protocol.
00:16:58.910 - 00:17:28.060, Speaker A: Kuma access controller. Yes, here you are. Okay. Let's read it all, even if we see something small. Okay. In general, I think I did this already, but in the instructions here, remember it was sharing the instructions. So I think I did this already, but I might not hard to run it.
00:17:28.060 - 00:18:10.646, Speaker A: You want to follow these instructions so that you see it compiles properly on your machine and so on. They usually offer this quick start command, but I can see it's cloning the repository. I already have it, so what I did, I might even have it here. No, what I did is to run what they mentioned, this one first and then for its test. I did this before, just that. And it's going to take forever it's going to do to run many of those. And I won't say the spoiler at the end, but there is a surprise anyways.
00:18:10.646 - 00:18:52.050, Speaker A: So in the meanwhile, because this, I recall is going to take a while, I wanted to mention that. Okay, I don't know why is that error, but if you know, please let me know. I've seen this before. It's about the compiler potentially. There is some issues here that I need to or some settings that I need to change. So if you know, I would appreciate a lot to let me know, maybe write it in the comments. But I wanted to mention that I always check out the pragma versions because it's common to find projects that they are using either, well, different versions or.
00:18:52.050 - 00:19:34.814, Speaker A: And also they are using what is called the floating pragmas with this thing. Okay. It's interesting that this fixes the error, but it makes sense because I think the error was saying have a higher version. So nowadays at this stage, the scripts, the robots that are running by some of the people are detecting these issues. So it's good for you to know, and I'm going to mention those things. But yeah, I know this is going to be, well, I don't know, back in the time of this project if it was handled. But anyways, nowadays it's not worth to report because it's handled by those.
00:19:34.814 - 00:20:10.702, Speaker A: Let's go further. Kuma access controller so this was handling all the roles. I can see that in the constructor it is extending access control and we have a default admin role and Akuma manager role. I'm wondering where they are or if I can find any more information about it. Probably they are in access control. Let's see, since we're here, let's see what we can find. By default, the admin role for all roles is that one.
00:20:10.702 - 00:20:36.070, Speaker A: Which means that only accounts with this role will be able to grant or revoke other roles. Okay, I can see at least it can be changed. Apparently the set role admin a warning is also the photo admin role is also its own admin. It has permission to grant and revoke this role. Interesting. Okay. Like only owner kind of permissions.
00:20:36.070 - 00:20:58.302, Speaker A: Next application should be taken to secure accounts that have been granted it. Okay. So more than one account. Okay, interesting. It's initiated to zero address. Okay, I'm not sure if I should go through this smart contract now, but let's take a quick look. Maybe we'll come through this later.
00:20:58.302 - 00:21:39.270, Speaker A: But it has some modifier for only role and you specify the role and then it will probably go further and compare. He has to decode it. Access control account. Yeah, this smart contract seems to be taking care of those verifications. Okay, we might go further. Oh, you see this? What I mentioned. I knew that they are commonly using, or it's common to find this, that there are different versions used as worth reporting because like for instance, even in a private audit, it's worth reporting for sure because it's not safe.
00:21:39.270 - 00:22:10.120, Speaker A: Okay, so what we can see here is that it's granting both roles to the person or whoever is deploying this contract. Sometimes I like to go and check the test cases. Actually look at that. Base set. Test base set up set up. It's probably going to deploy it somewhere here. But yeah, anyways, wanted to mention that as well.
00:22:10.120 - 00:22:39.854, Speaker A: I'm curious sometimes to just come and check, although I don't base it. I'm not sure about that. I will not take a look right now. But yeah, I think it's good to go and switch through the test while we're trying to understand what's happening in the protocol at the moment. Too early. Too early to check for me at least. I'm not sure what's going on, so let's try to find out more.
00:22:39.854 - 00:22:59.150, Speaker A: Let's see which other smart contract we can be checking next. Probably. Let's go. Next on the surprise, surprise is access controller. Okay, but from MCIG. You know what? Let's check with Kuma protocol. I think it makes is.
00:22:59.150 - 00:23:20.534, Speaker A: Yeah, we'll do it separately. Next is KBC token. Where was it? Okay, yes, here somewhere. Here it is. Did I write something? Okay, never mind. KBC token. In this case, what we can do before going through it is what I mentioned earlier.
00:23:20.534 - 00:23:39.490, Speaker A: Let's go back to the documentation and now we can read about it before starting to analyze the code. Let's see if there is a section specific for it. If not, let's see. Maybe. What was it standing for? Yep, no key. Kib. Kib.
00:23:39.490 - 00:24:06.838, Speaker A: Maybe here we can see one is Kib token and this is KBC. Okay, it must be this one for sure. Kumar bond cron token. KBC token. Yes. Let's see. When the central bank rate drops lower than the current Kai B token yield, clone bonds lower the coupon of bonds that were bought by users from Kumaswap contract.
00:24:06.838 - 00:25:17.578, Speaker A: This ensures that at any point in time there are enough kai tokens in circulation to buy all the bonds from Kumaswap reserve. The lowest paying yield corresponds to the lowest yield between the central bank rate and the lowest coupon in the Kumasav reserve. And there is more information. Let's see. Just reading it from top to see if there's something that catches my eye. Since the 5% bond appreciates more quickly than the kai idto the supply blah blah blah blah, a clone bond is always paired with apparent bond. I'm curious to find out what's that bond in the code from the reserve and we'll have a lower uniswap when the bond is valued for each clone bond present, the parent bond cannot be redeemed by a user and can only be redeemed by the MCAG multi Sig KBC token can only be issued by Kumaswap.
00:25:17.578 - 00:26:01.070, Speaker A: In the buy one function, clone bond coupons are only created if the bond's face value is greater than that of the amount of. Okay, let's go back to the code. I need to read more of this. Okay, we're probably going to define this in constructor, but I can see it uses initializer, which is probably using upgradable. So this upgradable contract is a bit weird that it's. I'm not sure if I recall seeing the constructor being called. You know what, we can do something extend.
00:26:01.070 - 00:26:40.686, Speaker A: I'm wondering about the constructor if it needs to be initiative constructor. Let's see what we find. What we find here. Okay, here you can use us. It contracts except for their constructors. Due to a requirement of the proxy based upgradability system, no constructors can be used in upgradable contracts. Okay, so that seems like an issue.
00:26:40.686 - 00:27:11.910, Speaker A: Not sure what the cause the problem of having that. Let's see what can we find out more about it. Okay, there are some reasons. In proxies, this means that when using a contra with the open separate upgrades, you need to change its constructor into a regular function, typically named initialize. So we had initialize there function, but we also had a constructor. That's what didn't look right. See, we don't have here.
00:27:11.910 - 00:27:57.062, Speaker A: Okay, I'm going to mark it for now. If it's an issue, we'll be seeing it later. Yeah, let's do that. Let's go back. You know what, I will also, so that you see, I would in this case mark it if I wouldn't have the answers, let's say the report. Since we are doing an overview, I would just mark it like I would say should not add constructor and I will be going back to that afterwards. In this case we're just going to go to the report and we will find out there.
00:27:57.062 - 00:28:16.982, Speaker A: But yeah, that's a way of keeping track of it. And this is the plugin. What was it called? Do I have it somewhere here? Inline bookmarks I think. Yeah, you can add audit info, audit issue audit. Okay. And audit. That's very useful.
00:28:16.982 - 00:29:02.966, Speaker A: So if you know it now, you do. So in this constructor or initialize, we're passing probably the address or the contract address of this Kuma address provider, checking that it's not address zero or reverting. Okay, let's go further. Issue bond means a clone bond NFT to the specific address can only be called under specific conditions. Okay, mint role and probably should be doing some verifications about it. Okay, here it is only kumaswap, which I understand will have that mint role. Can we take a look? Is it somewhere I was on top risk category.
00:29:02.966 - 00:29:34.258, Speaker A: Okay, that's something I don't understand yet. But anyway, some verification to make sure it has the right access, the right person. And we're minting with this apparently, yeah. Token ID, token ID counter. Okay. The ID is basically incrementing probably from zero, thus the ID that is passing and the C. Bond clone bond struct storing metadata okay, not sure, but let's go on.
00:29:34.258 - 00:29:43.014, Speaker A: Redeem. Okay, so one for minting, another for taking it out. Right. Burning. Exactly. Minting, burning. Getting.com
00:29:43.014 - 00:30:09.326, Speaker A: address get bond clone bond bond ID bond struct storing metadata of the select bond ID. Do they have any, what do they have there? What do they have here for bond? Oh, that's a lot of things. Bonds. Kuma Bond. Kuma Bond selling bonds. Okay, we're going to understand a bond. As for now, an NFD, what it is, what it is.
00:30:09.326 - 00:30:51.130, Speaker A: That's what it is. But yeah. Okay. In general, we know that this class, it is extending, it's upgradable and it is minting and burning overall and it has some permissions. Let's see what's the next contract? A clown on NFT token that is issued when the kibt yield is not high enough to buy back the original bond NFT. Okay, MCAG comma protocol again. Now, MCAG rate feed contract that reads the price from the MCAG central bank.
00:30:51.130 - 00:31:13.540, Speaker A: Okay, let's take a look then. Let's see. Uups upgradable open sapling. I honestly don't know that. Can I see it? Yes. An upgrade upgradability mechanism designed for UUPS proxies. What are UUPS proxies? Let's find out.
00:31:13.540 - 00:32:24.870, Speaker A: UUPS proxies are implemented using an ERC 1967 proxy. Note that this proxy is not by itself upgradable. It is the role of implementation to include alongside the contract's logic all the code necessary to update the implementation address that is stored at specific slot in the proxy storage space. And if we go at this ERC approximately using EIP 1967 storage slots, not upgradable by default. Okay, not upgradable by default. There are two alternative ways to add upgradability to an ERC 1967 proxy, transparent upgradable proxy and UUPs upgradable, an upgradability mechanism to be included in the implementation contract. Okay, so I understand that this contract might be an years in 1967 or part of that proxy, or maybe in this project, and by adding this we're making it upgradable.
00:32:24.870 - 00:32:45.082, Speaker A: Okay, what is the difference? Oh, this one also had it. Okay, let's go on. Let's go on. Yeah, we have some constants, minimum rate coupon, some decimals probably for the token. Okay. Only manager. So managing the roles.
00:32:45.082 - 00:33:19.286, Speaker A: We have the same here. Okay, we have it marked in the first one. I'll need how to mark it again. Initializing the initialize function, of course, is the one that it's running when it's deployed. There is this thing I discovered a while ago. Wait, it has the initializer? Yeah, probably this one. I needed to extend this, this initializer, it has some checks in there, probably was coming from this initializer.
00:33:19.286 - 00:33:49.718, Speaker A: Is it implemented here? Did I jump it? Oh, here it is. Modifier that defines a protecting slicer. Anyways, the thing is that those that are upgradable contracts need to be going through this logic. You can take a look that separately, but yeah, that's the thing. I learned that it's important. I actually have it in a tweet on my account, but yeah, and actually made a thread about it. Anyways, let's go this there.
00:33:49.718 - 00:34:19.582, Speaker A: Let's go on. Okay, we're setting an oracle set, an MCAG aggregator for a specific risk category. So probably this was a kind of bank, right? So it might be off chain, I guess if there is an oracle, there is no need for staleness check. A central bank rate is rarely updated. Okay. Yeah, so it's probably used to check the rates. Okay.
00:34:19.582 - 00:35:22.546, Speaker A: That means that we need to make sure there is no issues with the Oracle okay, that could take us to, in these cases of course we're going to continue checking but when you want to go deeper you'd go to solo audit and check about Oracle's exploits and so on because there are some things that you need to verify always. But we're not going to try to understand all the logic here. As I say, this is not, I mentioned at the beginning, we're not going the full audit here. And anyways at the beginning of an audit it's better to do an overview, know what it's around and then it's when you go deeper and try to dig deeper there, everywhere, understand everything more specific get rate. Yeah. So this is probably used to get the rate from the oracle. What else we have? Get Oracle and other stuff.
00:35:22.546 - 00:35:33.106, Speaker A: Cool. One down. Let's close this. Okay. Yeah. Feed. Yeah, definitely read the price from the central bank.
00:35:33.106 - 00:35:50.540, Speaker A: Great. Oracle, it was mentioned there. What's the next address provider? Address provider, I've seen that before. Yeah. Address provider that stores the mappings. Stores. Okay, stores kumasub and Kuma fee collector for each risk class.
00:35:50.540 - 00:36:17.240, Speaker A: Okay, let's take a look. It's upgradable like potentially all of those, but we'll see. Okay, some mapping here. We'll see. What's this about? Only valid address. Another check probably will be. Okay, that's nice way to not repeat the code.
00:36:17.240 - 00:36:30.070, Speaker A: It's checking. Probably another function here that this address passed. It's not zero. That's a good way. Let's go back. We've seen that before. Initialize.
00:36:30.070 - 00:36:53.194, Speaker A: Okay, we're setting a BC token, I think we read somewhere that it was. This contract is handled by address provider. That's probably what's happening here. Setting the KBC token that's defined on top. Okay. Probably reused somewhere else. We'll see.
00:36:53.194 - 00:37:26.954, Speaker A: Probably this made so that whenever it gets upgraded it would change the address. So if you would hard code it here on the top and make it a constant or similar, then it would not be ideal or might not be even possible to change it. But yeah, let's see. Kuma bond token. Okay, similar thing and kiv token. We can see here some other logic. I don't know that yet.
00:37:26.954 - 00:38:02.578, Speaker A: Let's see if we find out later. What else. Satkuma fee collector. Okay, apparently there are some face about it for sure and some getters, usually in the getters you want to check this part but it's a view and of course external because that way it's probably taken by other contracts for sure. Get comma swap and check risk category that was here. Yeah. Inset comma fee collector.
00:38:02.578 - 00:38:33.678, Speaker A: Okay. Some other decode in some other code here because we're passing bytes so we would need to take it out with Avi encode. Okay, so this contract, it's doing mainly, I think it's well setting or defining some of the tokens that are in this kuma protocol. Handling that. Yeah. Setters and getters here. Okay, we've got that so far.
00:38:33.678 - 00:38:50.920, Speaker A: Where else? Coma fee collector. Coma fee collector. Let's see. Role initialize release. You know what? Let's see if we can find something about the fee collector here. Office. Nothing here.
00:38:50.920 - 00:39:15.582, Speaker A: Okay. Release releases the accumulated fee income to the payees. Okay, makes sense so far. Okay. We're probably getting the balance of the kib token. I keep saying kai kib token. We didn't go through it yet, right? No.
00:39:15.582 - 00:39:36.042, Speaker A: Okay. But it seems it's cuttering the fees, I guess. Okay. Available income zero repaired. What? Probably we're really, there is an internal function. So here it's handled some checks and then we go to the internal. If we can go directly to that so we don't lose context.
00:39:36.042 - 00:40:00.910, Speaker A: I want to see it's going to be in the same class, that's for sure. Okay. Internal helper function to release an available income toolbase uses total shares to calculate correct share. That's the address of the token. Available income that we passed before that we passed that we passed here. Available income. Okay.
00:40:00.910 - 00:40:29.622, Speaker A: If we were to improve the gas thing, we could mention this, but that's very little thing and everyone knows it anyways, so it's going through all the, that must be defined on the top. I don't remember it. It's probably a set of addresses, those I guess that are involved in any swap. Probably. Let's see if I can go back where it was. Release. Okay.
00:40:29.622 - 00:41:07.060, Speaker A: And it's transferring to them probably their shares. Total shares. This could be. When I see a division like this, first thing that comes to my mind is possibility to be divided by zero. So I wondering if at any point that can happen that would revert the transaction so we can track it a bit also in the file, what's its path. So it's obviously defined there and just privately and it's increased when we add a pay. So it's never going to be zero.
00:41:07.060 - 00:41:36.858, Speaker A: Okay, let's go back to the release. Yeah, I guess you will not release if you never added a payee. So yeah, I guess it's probably fine anyways. And it's not like, well, I don't know if we can remove them, but we'll see. Okay, so that's basically release doing so so far we are. Okay, let's then go back to the beginning because we have seen the release. The first function.
00:41:36.858 - 00:42:00.466, Speaker A: Yes, add payee. So we'll update total shares and therefore reduce the relative share of all other payees. So that means that needs to be doing some logic here. Okay, let's go on. So we can remove payees and it's external, but only manager can. Okay, so should not be manipulated by everyone. That's good.
00:42:00.466 - 00:42:25.062, Speaker A: Let's go on. Function update pay share. Okay, updating probably reducing or decreasing. Increasing it or decreasing makes sense. Change payees. Okay, you can change the list. Okay, there's some logic there, but let's go on.
00:42:25.062 - 00:42:46.834, Speaker A: Release if available income will execute in the internal release anyways. Okay, next. Here it is. Kib token. Here you are. Let's see what's in here. ERC 20 permit upgradable and of course uups upgradable like all the rest.
00:42:46.834 - 00:43:13.754, Speaker A: Okay, initialize, set epoch length. Okay, not sure what's epoch. Minus five. Miss this revase intervals in seconds. Okay, anyways, we can set it here. What else? We have refresh yield base on current yield and oracle reference rate. All right.
00:43:13.754 - 00:43:34.514, Speaker A: And we're minting. It's overriding. Okay, timestamp refresh. Okay. Updating the balances and of course we're minting. Of course not, but we're burning as well. Yeah, I'm not going to go through the logic, but there seems quite a lot of it.
00:43:34.514 - 00:44:25.342, Speaker A: Some getters getting the total supply or transferring. This might be interesting to look closer if the balance is less than the amount, of course don't transfer it. We are doing the actions here, so it's check interaction. Okay. Some calculations, I'm not sure what converting. Okay, and is it transferring here? Where is the transfer function? Okay, I think this check, I would add it more on the top because if it's zero then you could have avoided that logic, but total base balances and then we remit in the transfer. But I didn't see the, do you think the transfer is somewhere here? It's not.
00:44:25.342 - 00:44:59.446, Speaker A: What about here? Well, I'm not sure, I don't see it, but yeah, might be very obvious. I'm not seeing it, but let's see, I might come back to this or we'll see later. All right, let's move on. Refresh. Cumulative yield updates. Internal state variables after accounting for newly received tokens. Okay, calculate previous, calculate cumulative yield, some verifications in general, these verifications.
00:44:59.446 - 00:45:59.600, Speaker A: These checks are usually in the docs and that's what once you go deeper in the code, you would go there, read what it's mentioned, and make sure it applies in the code and it's properly noted. For now, as I mentioned, I will be doing just the overview and then go to the box. But let's see. I would expect also feedback from you guys if by any chance you feel it would be or it's not helpful enough, or you rather have a second part or something like that being more specific. But I guess since we're going to check the box later, I think this series of videos should be right to do the overview and the box. Check the report, check. But again, we're just trying to get familiar with it so we can understand better the issues.
00:45:59.600 - 00:46:42.910, Speaker A: We're refreshing the yield, we're getting the contract Kumaswap. I think we're going to check that later. Again, some checks that is not expired or deprecated, getting some information and verifying it. Okay, probably those are just used in here in one of the other functions I wanted to say, but yeah, calculate previous airport cumulative yield and authorize upgrade. Let's move on. Where am I here? So I think the last one, biggest is Kumaswap. I think since we read here, that's the main contract.
00:46:42.910 - 00:47:13.190, Speaker A: Let's see what is there. Let's see what we find. Okay, it's extending its interface. Possible upgradable. What is possible upgradable? Let's check because I'm not sure about that one contract model which allows children to implement an emergency stop mechanism that can be triggered by an authorized account. Okay, let's see. This model is used through inheritance.
00:47:13.190 - 00:47:42.670, Speaker A: It will make available the modifiers when not post, when post. Okay, I expect to see that in the code. And note that they will not be possible by simply including this model only once the modifiers are put in place. That makes sense. Okay, let's see this kind of library, I guess formats. Let's see, let's go on. Set unique coupons.
00:47:42.670 - 00:48:35.970, Speaker A: Set awful tokens IDs set all expire token IDs Kuma bond token ID to okay, that's a mapping quantity in reserve bond Id to bond sell price. Okay, we can see when not deprecated on our modifier. When deprecated initialize. Okay, verification of the address passed this one and this one. What is this? Maximum coupons we have then defined here. Okay, so let's see. First function here we have cell bond sells a bond against kib token.
00:48:35.970 - 00:49:14.634, Speaker A: What are we doing inside some checks. Kibt. What are we going to do with it? Reference rate we're getting from the oracle, I guess. Okay. Minimum coupons. Basically doing some verifications at the time of the invariance, probably that everything is as it should. What else? Okay, we're minting with the cell bond.
00:49:14.634 - 00:49:38.230, Speaker A: We're minting the kib tokens to the message sender and transferring it to this address. Okay. To this contract. Kumaswap. It's keeping the tokens. All right, buy bond. So probably a lot of checks again and burning.
00:49:38.230 - 00:50:06.800, Speaker A: So we sell, we mint, and if we buy, we burn. Okay, I will stay with that for now. Okay, there is a situation where it may do the transfer back to the if required clone host. This if the bond phase value is major. Unrealized bond value. Unrealized bond value comes from. Okay, here it is.
00:50:06.800 - 00:50:59.290, Speaker A: Required clone or not required clone. This will be important to double check this amount and make sure it's as it should because it seems very important here actually, for now. Again, we're just skimming through it. Okay, buy pond for stablecoin buys a bond against deprecation. Stablecoin requires an approval on amount from buyer. This will also result in some stealth state for the contract on coupons and main coupon, but this is acceptable as deprecation mode is irreversible. This function also ignores an existing clone bond, which is the intended behavior as bonds will be valued per their market rate of chain.
00:50:59.290 - 00:51:30.558, Speaker A: Okay, buy bond for stablecoin. We're removing the tokens from the reserve. I'm wondering if we can read a bit more about it because didn't get much from that. One known limitation about deprecation mode is the fact that the manager role can spend the buyer's allowance in the buy bond for stablecoin function. Okay, this is the bond. Look. It's unstructured.
00:51:30.558 - 00:52:07.538, Speaker A: I have probably missed it somewhere. It has all these parameters. Okay, let's go back. Okay, yeah, as you see, we're doing the checks, we're removing it, and then we're sending. Yeah, that's good. That's protected with the check how it was it called check interaction actions, something like that for entrance wise to be protected even though there is no modifier for rentrancy. But this is a good practice.
00:52:07.538 - 00:52:35.422, Speaker A: Claim Bond, James Bond. Okay, claims a bond against a clone bond can only be called by Kumasov. Claim role, address. Okay, only role. So this is not for every user, but for the owners. Okay, and what are we claiming exactly? We use redeem from KBC token contract redeem was burning. Yeah.
00:52:35.422 - 00:53:16.854, Speaker A: So by claiming we are burning the KBC tokens in the Kumaswap claim bond function. Okay. Burning and then sending that token ID chip bond ID. Okay, we're halfway this contract redeem KIBT redeems KIBT token against the application mode. Stablecoin redeems table coin amount is calculated as follow okay, do we know where is that calculation here? Okay, this is it I guess. Yeah. And it's multiplying before dividing.
00:53:16.854 - 00:53:54.630, Speaker A: That should be the right way. And that's the library used. Okay, what else? What do we do with this redeem amount? We're transferring it through the deprecations tablecoin contract before burning it. We're burning the amount transferring redeem amount. Okay. Why this amount is in this funk in this operation, probably it's kib token amount. So this parameter, isn't it? I hope so.
00:53:54.630 - 00:54:36.790, Speaker A: All right. Expire bond expires a bond if it has reached maturity by setting min coupon to mean allowed coupon when not deprecated, it's external. That's a bit od that it's external. If you can expire a bond, anyone can really. It's not checking who is running this. I don't know if this can be an issue here. I'm still not sure what this supposed to do, but what's the main action we're adding here? See, in this case, seems like a proper place to add another tag.
00:54:36.790 - 00:55:14.350, Speaker A: There is no access control. I'd say where access control is external. Maybe no role control. Let's leave it like that. No role control. Let's see later if there's actually something with this. And remember it was mentioning about the pausing and unpaused it comes from possible upgradable okay, setting fees, income and swap set deprecation stablecoin sets a new stablecoin to be accepted during deprecation mode.
00:55:14.350 - 00:56:15.990, Speaker A: Want to read something about the deprecation mode? Kibt is minted and burned such that the total supply is always sufficient to buy out all the Kuma bonds NFTs held in the contract. However, in extreme cases, some of the KIBT supply might become inaccessible if large amounts of KIBT are hacked or lost to unknown addresses. This could result in Kuma bonds NFTs being locked in the Kumaswap contract. To mitigate this scenario, the Dao can vote to put Kumaswap contract in deprecation mode where users can buy bonds with stable coins through voted on parameters. It's like a way out mechanism apparently since there is a unique comma swap contract for each risk category. One deprecated Kumasap contract for a given risk category does not impact other comma subcontracts. Okay.
00:56:15.990 - 00:56:46.670, Speaker A: And this one is activated. Okay, let's go back to the code here. We're initializing it in Kumasat. Okay, what else get risk category? I mean, here they mentioned anything enable deprecation mode. But for now, the idea, it's clear we're enabling here. We're dealing with deprecation mode here. And some getters might be the rest of it might be getters, some other checks.
00:56:46.670 - 00:57:06.646, Speaker A: It's unused function parameter. This is a callback. Okay. This callback function from ERC 721. So I guess it's normal it's not used. Okay. And yeah, it always needs to return that selector or at least.
00:57:06.646 - 00:57:44.050, Speaker A: Yeah, maybe some other logic, but at least that selector sounds good. Update minimum coupon. I'm not sure we found out what are the coupons here? The Kumar subcontract won't allow users to sell bonds to the contract which have a lower coupon. Is anyone explaining those coupons? Oh, well, not exactly. Okay, here, annual interest. Annual interest rate paid on the bond per rate per second. Okay.
00:57:44.050 - 00:58:14.298, Speaker A: Interest. Okay. And some actions unchecked. Okay, nice. Gas optimization here with unchecked calculating fees. Something I learned about a way to improve the gas optimization of this is usually that this is more expensive than adding this, for instance, like that. This is cheaper like that.
00:58:14.298 - 00:58:37.060, Speaker A: So that's another possibility. But I'm sure nowadays it's reported by the bots. I see the robots earlier, but yeah, I guess bots is better probably used. Were we at the end already? Think so, yeah. Okay, so we have all Alcoma protocols. We've quite a while here already. An hour and a half, I think.
00:58:37.060 - 00:59:09.366, Speaker A: Let's see. I'm wondering, it might be worth to jump to the report already. Those are in MCAG contracts are connected with the external bank thing, the Oracle and so on. Let's see. KYC token. We could check that quickly maybe, but that's the connection with the Oracle. Most likely we have that one KYC token, Kumabon token.
00:59:09.366 - 00:59:31.886, Speaker A: That's so important. Actually, you know what? Okay, let's take a look. The KYC. Let's go to the KYC. Let's close this KYC token. Here you are. Should we read something here about KYC? KYC tokens? KYC tokens are non transferable.
00:59:31.886 - 01:00:16.494, Speaker A: ERC 721 tokens minted to a specific address only after the owner of that address has undergone and now your customer. Okay, so it's literally okay. Good to know. So definitely, it seems this protocol requires that KYC verification. Okay, that makes sense. That's why it's called KYC for those, in case you don't know, that's where you need to identify yourself, basically by providing ID and what other kind of identification? So they can assign your address to someone. Okay, let's leave it there.
01:00:16.494 - 01:00:33.480, Speaker A: That's good enough information. What's happening here? Let's see. Mapping token ID to KYC data. What is this Kyc data? Can I see that? It's probably a struct. Yeah. Okay, good. Let's go back.
01:00:33.480 - 01:01:19.318, Speaker A: This is not upgradable. For instance, that's why we see the constructor and not initialized anymore. Okay, we're passing the access controller address, I guess, of that contract and we have a function for minting using safe mint. Using safe mint has a trick because it has this callback. I'm not going to check it now, but I know it's probably covered. But worth checking, you never know. Check for callback because safe mint has something.
01:01:19.318 - 01:02:03.246, Speaker A: Can I enter that? Okay, now. Oh, it's here anyway, has mint and has this check on ERC 721 received. I think we've seen that being implemented in another contract. I don't remember now, but yeah, it's basically going to a callback function. It's going to enter the smart contract that called it and look for the function on ERC 721 received. And if it's not there, most likely will fail. It will revert.
01:02:03.246 - 01:02:26.506, Speaker A: Okay, let's go back on track. So we're minting, we're burning, setting Uri. Okay, some getters proof approve not used any parameter. Talking is not transferable. So it's probably, yeah, it's overridden to make it not transferable. Okay, that makes sense. Actually that's interesting to read.
01:02:26.506 - 01:02:49.278, Speaker A: It makes sense for the KYC token. I'm wondering if it's not implemented this size token somewhere where it can be reused. KYC token most likely not. But yeah, could be interesting to Google it. I want to eat now, but yeah, feel free to check it might be interesting to find out. I might do it later. We're not transferring.
01:02:49.278 - 01:03:14.460, Speaker A: Okay, so we're overriding it so that it's not allowed in case of being called. Okay, that's good. How's the next contract from this folder? Kumabon token. Let's check that one. Kumabon token. Wait, it's also ERC 721. It's possible.
01:03:14.460 - 01:03:31.230, Speaker A: And implementing this interface. Okie dokie not. Okay, here there is a whitelist or blacklist. Apparently more blacklist. So not blacklisted. I guess it's a whitelist. Throws if argument account is blacklisted.
01:03:31.230 - 01:03:57.058, Speaker A: So if it's blacklist, it would not continue, it would revert. Okay, got it. Constructor defining the NFT parameters. Okay. Issue bond mint bond NFT to specified address. This address and we're using safe mint. And we have a redeem for burning.
01:03:57.058 - 01:04:22.962, Speaker A: Okay, similar probably. And is it transferable? Apparently yes, but we're still overriding it. Anyways, changing the logic. Okay, so basically it's adding this extra verification apparently in case it's not handled. It's not handled and running approved the internal one. Okay, this is transferable. We've got that.
01:04:22.962 - 01:04:50.150, Speaker A: It's just adding some extra information. Sorry. Verification. Okay, so that will be it. Okay, that means that it's time for the report, guys. Yeah, let's go for that. I'm very curious, please let me know in the comments if this is enough of an overview.
01:04:50.150 - 01:05:15.522, Speaker A: I think. Yeah, we've been quite a while with this. We went not too deep, but we've gone through all of it. So let me know if this is enough or what do you think? Anyways, it will be extremely helpful. Yeah, let's go to find the report. So this is it. I think it is just all in the same page.
01:05:15.522 - 01:05:45.786, Speaker A: Yes. So should we start from the high risk? Yeah, why not? And here, guys, we're going to go through it. I will do my best to see if I understand it. If I do, I will try to explain it with my own words and let's try to understand it together. If I don't understand it, or I say something wrong, which there are high chances I'm just learning here. Never read this before. So yeah, let's help me, please.
01:05:45.786 - 01:06:33.522, Speaker A: At any point, I'm actually considering if this series, if this video is getting, if it's popular or liked by you guys, then eventually we could do a live session here and listen live for suggestions or help from you guys. Because actually I'm even considering having guests to help me or to study with me, basically more than to help me, which obviously yes, but it will be interesting to have guests with whom we can study and the guests from which we can learn from, especially me. But yeah, let's see. Let's go back. There was one high only. Seems so. Yes.
01:06:33.522 - 01:07:02.814, Speaker A: One high for mediums, and a ton of low and a ton of gas optimizations. Okay, let's start here. Transferring kib token to yourself increases your balance. So that's probably a lack of verification of the addresses. That's interesting. Using temporary variables to update balances is a dangerous construction. Temporary variables.
01:07:02.814 - 01:07:39.402, Speaker A: I need to see what it's referring to. If transferred to yourself, it will cause your balance to increase. Kib token of a rice transfer. See that's a problem of kib kiv kib it is probably from kuma kib token. That's a problem of overriding the functions from the open seplin. He's checking the address from. It's checking the address to, but it's only checking that it's not zero and there's no other check about the addresses.
01:07:39.402 - 01:08:05.986, Speaker A: And apparently to perform the transfer of the token, the code is as follow up. This is a proof of concept, so I understand it's okay, it's going to show. So I think this is just the same proof of concept is where you are trying to crack it. But I think for now it's just showing where it's crackable. Base balances two. Okay, new to base. Let's go here and analyze.
01:08:05.986 - 01:08:34.526, Speaker A: New to base is defined here. Okay, this is the balance new to base balance. Okay. There is some operations here and then it's assigned the base balances. It's changing the balances of the address that is receiving it or similar. Let's read it more. But I understand that you can send it from yours and send it to yourself.
01:08:34.526 - 01:09:01.434, Speaker A: Actually, yeah, I think I've seen it some places. To have the eve from needs to be different than to. Okay, so it's pointing here, what I say, right. If it's equal, this place will override the reduction above. Yeah, that's very well seen from the code above. We can see that using temporary variables. Okay, that's what is going.
01:09:01.434 - 01:09:39.878, Speaker A: Temporary variables is okay, so local variables, basically those variables disappear when the function, when it's finished. The logic inside the function, if the from and to are the same, the balance to update will override the balance from update. To simplify example, balance Alice ten and execute transfer from Alice to Alice five. Define the temporary variable. Temporary variable, Alice ten. So update the steps as follows. This makes it five and from.
01:09:39.878 - 01:10:05.270, Speaker A: I'm not sure I understood that, but this is first the from and then the two. Let's see. Locking this what it means probably after Addis transferred to herself, the balance was increased by five. Okay, the test code is as follows. Test transfer same. Mint. Okay, we're minting from Alice.
01:10:05.270 - 01:10:46.410, Speaker A: That's a random address there. Ten ethers. We're checking that Alice. Alice's balance is ten ethers and we're transferring five ethers to Alice and it increases by five with a transfer because it's here in. We can add it to kib token transfer t tests. Kib kib token. Oh my God.
01:10:46.410 - 01:11:11.934, Speaker A: Transfer KB token transfer t okay, we got it. So I can add it at the end here and run, as they say, like that. Remember three. I said there was something, a surprise at the beginning of the video. There were three failing tests. Let's run this. Hopefully it works and we can see the results.
01:11:11.934 - 01:11:30.426, Speaker A: And then we go through the mitigation. Let's see. Maybe let's not wait much, but don't know if this will work. Let's see. Recommended mitigation steps. A more general method is to use balance to balance from. Okay, so yeah, running.
01:11:30.426 - 01:11:49.418, Speaker A: But that's interesting. But I think you can solve this by adding a condition. But yeah, I guess here it is. Yeah, makes sense. That's good. This is the comments. Probably other judge.
01:11:49.418 - 01:12:03.140, Speaker A: Okay, and then they fixed it. Probably here, let's check. This is the pull request. We can see their changes. There you go. That's how they solved it. Just with.
01:12:03.140 - 01:12:17.334, Speaker A: That's what I told. That's what I was speaking out. Nice. Cannot transfer to cell and the other test case. Cool. Okay then let's go to medium risk findings. There are a few here.
01:12:17.334 - 01:12:40.394, Speaker A: So let's see. Kumabon token approved should revert if the owner of the token ID is blacklisted. Oh, it's not handled. Okay. It is still possible for a blacklisted user bond token userbound token to be approved. Okay. Only this approve only checks if message sender and two are not blacklisted.
01:12:40.394 - 01:13:07.400, Speaker A: It doesn't check if the owner of the token ID is not blacklisted. Interesting. Okay, let's take a look at Kuma bond token. Let's close this kuma bond token approval because it's not blacklisted too. And not blacklisted message on there. But the token owner, owner. Look owner of this.
01:13:07.400 - 01:13:28.474, Speaker A: That's true. Okay, let's see how, what else it says. For example, the following scenarios have blacklisted users bond token to be approved. User a have a bond token. BT one user a calls set approval for all B. True. And user B can operate on all user a bond tokens.
01:13:28.474 - 01:13:56.034, Speaker A: User A is blacklisted. User B calls to approve user C to operate on bond token. Let's see the mitigation in this case. Yeah, probably adding the probably you can define. Okay, never. But yeah, adding basically another line here with this code with the owner. Basically the address of the owner.
01:13:56.034 - 01:14:15.534, Speaker A: Nice. Okay, let's go on again. It's nice to see they are adding the test as the proof of concept to prove it. I wonder if it run the previous one. It did. It did not as much. What? Didn't match the test.
01:14:15.534 - 01:14:30.578, Speaker A: Why? Test transfer same. What did I run? I don't know. Seems the same. Okay, never mind. But this should work. Probably there's some weird thing I'm missing there. But that's okay.
01:14:30.578 - 01:15:13.534, Speaker A: Let's go on with the issues. Kumafi collector change payees executes incorrectly when new payees contains duplicate items. The payees are everyone that is involved and they were the ones to whom the fees are redirected later. Executing correctly when new payees contains duplicate items. Let's see. When calling Kuma fee collector change payees with duplicate payees new payees, the call is not reverted and the result state will be incorrect. Okay, proof of concept.
01:15:13.534 - 01:15:36.422, Speaker A: This contract does not support duplicate payees. The transaction will revert when trying to add duplicate payees. Okay, I see. But function forgets this constraint which allows duplicate payees to be passed. It's missing the verification. Jealous. That's true.
01:15:36.422 - 01:15:56.762, Speaker A: This will cause the contract to record an incorrect state and not work properly. Nice, I guess. Desk Poc. I guess the solution is to add it. Add that verification. This is the test. The mitigation should revert if they are duplicates.
01:15:56.762 - 01:16:22.742, Speaker A: So should be adding that condition. Yes, in the change fee. Do you see it somewhere? I see only contract. Okay. It's not showing the whole code, I guess, but yeah, basically it's adding that condition when we are changing the payee, we can check it on the PR for mitigation. There you go. Yeah, let's see.
01:16:22.742 - 01:16:45.306, Speaker A: Let's double check that it's in the change fee payee series. Yes. Okay, good. Let's go on. Price fit in get rate is not sufficiently validated and can return stell price. Okay, let's see how it's not sufficiently validated. Think we didn't check this contract anyways.
01:16:45.306 - 01:17:13.974, Speaker A: Well, we did. Don't remember. Okay, but see, this is something I mentioned. There's a possibility that the data from Oracle, there's an error, basically. So it's always important to make sure. So it's always a kind of flag. Not a flag as something bad, but an attention to oracles always and getting the rate from them.
01:17:13.974 - 01:17:53.780, Speaker A: So get rate only uses answer but never checks the freshness of the data. Okay. Which can lead to stealth bond pricing data stell pricing data can lead to bonds being bought and sold on Kumaswap that otherwise should not be available. This would harm kab token holders as Kumaswap might accept bond with too low of a coupon and reduce rewards. Okay, so need to have a validation of the current data. So let's see. Recommend the mitigations validate that updated at answer.
01:17:53.780 - 01:18:25.706, Speaker A: So instead of having this line, you need to also take the time. Probably it's updated that and check that it's up to date. I guess this is the way of showing it. And if so, revert if it's not up to date. The warden has shown how the system will not check for a steel price. Yeah, stell is like no longer fresh. Okay, so outdated.
01:18:25.706 - 01:18:49.350, Speaker A: Basically this issue is tricky. Okay, it is. Central bank rate updates are not expected more than a handful of times a year. That's probably why it's not high, I guess. I see there was some negotiation there, but yeah. Let's go to the next comma swap incorrectly reversed when Max coupons has been reached. Let's look at that.
01:18:49.350 - 01:19:14.030, Speaker A: Okay. If the coupons length is max coupons reverse the above lines will cause all bond sales to revert. Okay, we don't want, we don't want that. Since bonds may share the same coupon, the swap should continue to accept bonds with a coupon that already exists. Okay. One things are bonds and the other coupons. That's why that.
01:19:14.030 - 01:19:52.300, Speaker A: Okay, mitigation step. Bond should only revert if the max length has been reached and bond coupon doesn't already exist. So we need to add another condition there. So we have the coupon's length, that verification that we had. And we need to make sure that also coupon doesn't contain, because if it contains, this end will break and it will not reveal. Okay, got it. A lot of verifications there are super important, okay.
01:19:52.300 - 01:20:13.162, Speaker A: Even though this scenario is unlikely to ever happen, we have confirmed this issue. Is this issue in a test? Okay, that's probably the limit. Okay. And the discussion and the mitigation, let's see how they mitigated it. Files changed. Those are always, usually very quick. Well, at least in the spray, very quick fixes.
01:20:13.162 - 01:20:39.194, Speaker A: I mean, quick, short, at least lack of verification, right? Yeah. Okay. And some low risks. Let's go through them for this contest, for reports were submitted. Blah, blah, blah, blah, KVC. I think this, I've seen this before. For each contract, it is showing a list, right? Like zero one here.
01:20:39.194 - 01:21:03.954, Speaker A: But then it changes the letters there and it says, how many issues in this contract. Interesting way of showing as well. Let's go a bit through those improper disable of initializer. I think I've mentioned that earlier. It uses dependency with initializer contract being okay, this allow them okay. Interesting. Good to know.
01:21:03.954 - 01:21:46.080, Speaker A: The contract contains a dedicated disabled initializer function. Means meant to be invoked by contract constructor implementations in contracts and inherited, ensuring that the contract cannot be initialized or initialized in the future. Encouraged in implementation, the initializer modifier is simply added to the contracts constructor, which does not disable the initializer properly as it still permits the reinisolation to occur. Yeah, okay. I think I did mark that as a thing to check, right? Okay. Improper disable of initializer okay. It's happening in a few contracts, so it's probably going to repeat it.
01:21:46.080 - 01:22:56.846, Speaker A: A different way of raising this is raising the issue as low and adding the different places where this is happening instead of duplicating it. But yeah, I guess it's also possible to do it this way. Insufficient initial epoch sanitization set epoch length function properly evaluates that epoch length provided is not greater than no such sanitation sanitization is applied during the initialized function. We advise the initialized function to apply to same logical checks potential refactor to an internal function that both code segments utilize using those upgradable initialize always brings more attention. Needs more attention, definitely. I'm not sure about this, honestly, so I will go on discripant epoch inclusively inclusivity definitions probably some different from the documentation. Usually when you go through the documentations you need to make sure if it applies on the contract.
01:22:56.846 - 01:24:18.842, Speaker A: So most likely this kind of laws is what's called. So it's basically not following the documentation, but let's see. We advise either the assignment initialized to add epoch length in existing informant of minimum maximums in yield, the Max yield constant variable declared remains unattayzed. We advise it to be enforced in the refresh yield function by ensuring that the lower shield being set is at most equal to max yield, in which case the value of max yield should be used instead. Additional demand okay, initializer initializer improper release event let's see what happens with the event my operating an empty data entry. In such case, if funds to be distributed press in the contract, this function will incorrectly execute release, which in turn will emit fee released even for the available income. We advise the function to be invoked solely when okay is nonzero in the reference instance, as otherwise incorrect events might be emitted and be misleading, probably in existing duplicate entry prevention.
01:24:18.842 - 01:25:30.498, Speaker A: I think this is similar to what we've seen earlier. We advise to call the code to add a new if condition which causes the code to fail if it contains that pay already in existing limitation of variable fee function does not apply any sanitation on the variable fee value permitting a fee to be applied that exceeds the 100% value of the bond. We advise the variable fee input variable of set fees to be validated as less than and preferably less than a stricter value to ensure unfair fees are not applied in the protocol. Again, this is following some of the documentation. This finding also ties in with the slippage related vulnerabilities submitting a separate exhibit whereby a user could submit a transaction with a blockchain state that applies a 5% fee and the fee could change between the transaction submission. How many more okay comma swap in existing limitation of variable fee does not apply sanitation. It's always usually missing checks permitting a fee to be applied that exists 100% value of the bond.
01:25:30.498 - 01:26:37.590, Speaker A: We advise variable fee input variable offset fees to be validated as less than percentage factor and preferably less than stricter value 20% to ensure unfair fees are not applied. Sleepage related vulnerability in existing limitation of there are lots of those improper disabled of okay. We've seen that unsafe casting cast the result of that to a UN 16 variable. We advise the casting operation to be performed safely by ensuring that the calculation result does not exceed maximum value that I un variable the built in safe array so ID does not protect against casting overflows. I think it's called silent overflow. That's true, and it's allowed okay in existing sanitation of state transitions does not ensure that the previous state was the opposite of what it is being set to. We advise to be applied to prevent misuse of the function as well as misleading events.
01:26:37.590 - 01:27:54.674, Speaker A: Weak definition of owner this mint function accepts a KYC data argument that is meant to contain data permitting kYC data to be minted to an arbitrate to address when the owner of the KYC data may be someone else. We advise the mint function to permit minting of the KYC data by either enforcing two to equal the data souvenir member or by not accepting a two argument altogether. Potential approval backlist bypass with the approve the function will apply a blacklist check on the two as well as message center contextual arguments of the call. However, the actual owner of the token ID is not validated. In contrast to set approval for all, which disallows an approval to be made by a party that is in the blacklist. While the approval cannot be on by the transfer from safe transfer from functions, as they do validate the from argument, an approval being made on behalf of a blacklisted owner is an undesired trade similar to something we've seen before. We advise the code to properly apply the blacklist to the owner of the yeah, we've seen that.
01:27:54.674 - 01:28:44.210, Speaker A: Another inexisting citation of maximum answire. This library incorrect code merge implementation present on the AB have a VC code base and it's merged from. Okay, that's interesting catch. We advise the repo functions body to be wrapped in an unchecked code block replicating the original behavior of we would like to note that while presently not a vulnerability, code copied from other projects should execute in the same format. It originates from Tusha. Okay, those are the gas optimizations, but we're not going to go through those, that's for sure. So this is mainly it mitigation review probably.
01:28:44.210 - 01:29:57.386, Speaker A: Yeah, we already went through those. So guys, I think from now, as an experiment, this is all for now. So it's definitely been useful because I had to focus, like useful for me, I had to focus on what I was reading, what I was saying. Obviously we didn't go deep, but it's a study session altogether and yeah, let's see if you guys like it. Please let me know anything you didn't like, understand or what other ways we could do this together. I think it is a way that you can see for those are less experienced with auditing, some basic ways of auditing, or at least to overview the project. And for those that you watch and you are more expert than me, I'd be happy to connect with you guys and either do a real audit together or I would even love more if we could do another of these study sessions together so that more people can benefit from them actually.
01:29:57.386 - 01:30:37.750, Speaker A: And yeah, let's stay in touch. Please let me know what you think of these sessions and well stay tuned for more. Since I'm starting with the channel, then I plan to try to push different type of videos, different type of resources. Here I have my articles on medium, I have my account on Twitter. I am active in both. I will leave some links below and yeah, guys, thanks a lot for staying by. Of course.
01:30:37.750 - 01:30:44.900, Speaker A: Please subscribe. It is only the beginning and yeah, take care. Bye guys.
