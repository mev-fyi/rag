00:00:00.410 - 00:00:22.560, Speaker A: I'm here, guys. We're going to go through it. I will do my best to see if I understand it. If I do, I will try to explain it with my own words. And let's try to understand together. If I don't understand it, or I say something wrong, which there are high chances I'm just learning here. Never read this before.
00:00:22.560 - 00:01:20.914, Speaker A: So yeah, let's help me, please. At any point, I'm actually considering if this series, if this video, if it's popular or liked by you guys, then eventually we could do a live session here and listen live for suggestions or help from you guys. Because actually I'm even considering having guests to help me or to study with me, basically more than to help me, which obviously yes, but it will be interesting to have guests with whom we can study and the guests from which we can learn from, especially me. But yeah, let's see. Let's go back. There was one high only seems obvious. One high for mediums, and a ton of low and a ton of gas optimizations.
00:01:20.914 - 00:01:45.454, Speaker A: Okay, let's start here. Transferring kib token to yourself increases your balance. So that's probably a lack of verification of the addresses. That's interesting. Using temporary variables to update balances is a dangerous construction. Temporary variables. I need to see what it's referring to.
00:01:45.454 - 00:02:24.358, Speaker A: If transferred to yourself, it will cause your balance to increase. Kib token of the rice transfer. See, that's a problem of kib Kiv kib. It is probably from Kuma kib token. That's a problem of overriding the the functions from the open separate. It's checking the address from, it's checking the address to, but it's only checking that it's not zero and there's no other check about the addresses. And apparently to perform the transfer of the token, the code is as followed.
00:02:24.358 - 00:02:51.950, Speaker A: This is a proof of concept, so I understand it's okay, it's going to show. So I think this is just the same proof of concept is where you are trying to crack it. But I think for now it's just showing where it's crackable. Base balances two. Okay, new to base, let's go here and analyze. New to base is defined here. Okay, this is the balance.
00:02:51.950 - 00:03:18.998, Speaker A: New to base balance. Okay. There is some operations here, and then it's assigned the base balances. It's changing the balances of the address that is receiving it or similar. Let's read it more. But I understand that you can send it from yours and send it to yourself. Actually, yeah, I think I've seen it some places.
00:03:18.998 - 00:04:08.442, Speaker A: To have the eve from needs to be different than to. Okay, so it's pointing here, what I say, right. If it's equal, this place will override the reduction above. Yeah, that's very well seen from the code above we can see that using temporary variables. Okay, that's what is going temporary variables is. Okay, so local variables, basically those variables disappear when the function, when it's finished, the logic inside the function, if the from and to are the same, the balance to update will override the balance from update. To simplify example, balance Alice ten and execute transfer from Alice to Alice five.
00:04:08.442 - 00:04:26.150, Speaker A: Define the temporary variable. Temporary variable, Alice ten. So update the steps as follows. This makes it five and from. I'm not sure I understood that, but it is first step from and then the two. Let's see. Locking.
00:04:26.150 - 00:04:51.206, Speaker A: This is what it means. Probably after Alice transferred it to herself, the balance was increased by five. Okay, the test code is as follows. Test transfer, same mint. Okay, we're minting from Alice, address there. Ten ethers. We're checking that Alice.
00:04:51.206 - 00:05:17.746, Speaker A: Alice's balance is ten ethers and we're transferring five ethers to Alice and it increases by five with a transfer because it's here. Increasing it. Okay, I get it. Okay, nice. Here it's showing how to run it with foundry in general. We could add to. Oh look, why not? Let's do it.
00:05:17.746 - 00:05:39.450, Speaker A: We can add it to kib token transfer t tests. Kib kib token. Oh my God. Transfer KB token transfer t. Okay, we got it. So I can add it at the end here and run, as they say, like that. Remember three.
00:05:39.450 - 00:06:00.350, Speaker A: I said there was something, a surprise at the beginning of the video, there were three failing tests. Let's run this. Hopefully it works and we can see the results. And then we go through the mitigation. Let's see. Maybe, let's not wait much, but don't know if this will work. Let's see.
00:06:00.350 - 00:06:23.094, Speaker A: Recommended mitigation steps. A more general method is to use balance to balance from. Okay, so yeah, running. But. Okay, that's interesting. But I think you can solve this by adding a condition. But yeah, I guess here it is.
00:06:23.094 - 00:06:35.962, Speaker A: Yeah, makes sense. That's good. This is the comments. Probably other challenge. Okay. And then they fixed it. Probably here, let's check.
00:06:35.962 - 00:06:51.022, Speaker A: This is the pull request. We can see their changes. There you go. That's how they solved it. Just with speaking out. Nice. Cannot transfer to self and the other test case.
00:06:51.022 - 00:07:14.658, Speaker A: Cool. Okay then let's go to medium risk findings. There are a few here so let's see. Kumabon token approved should revert if the owner of the token ID is blacklisted. Oh, it's not handled. Okay. It is still possible for a blacklisted user one token userbon token to be approved.
00:07:14.658 - 00:07:49.122, Speaker A: Okay, only this approve only checks if message sender and two are not blacklisted. It doesn't check if the owner of the token ID is not blacklisted. Interesting. Okay, let's take a look to that Kuma bond token. Let's close this Kuma bond token approve one here because it's not blacklisted too and not blacklisted message on there. But the token owner, owner look owner of this. That's true.
00:07:49.122 - 00:08:18.460, Speaker A: Okay, let's see what else it says. For example, the following scenarios have registered users bond token to be approved. User a have a bond token. Bt one user a calls set approval for all B, two, and user B can operate on all user a bond tokens. User A is blacklisted. User B calls to approve user C to operate on bond token. Let's see the mitigation in this case.
00:08:18.460 - 00:08:49.958, Speaker A: Yeah, probably adding the probably you can define okay, never. But yeah, adding basically another line here with this code with the owner. Basically the address of the owner. Nice. Okay, let's go on again. It's nice to see they are adding the test as the proof of concept to prove it. I wonder if it run the previous one.
00:08:49.958 - 00:09:06.442, Speaker A: It did. It did not as much or what? Didn't match the test. Why? Test transfer same. What did I run? I don't know. Seems the same. Okay, never mind. But this should work.
00:09:06.442 - 00:09:41.698, Speaker A: Probably there's some weird thing I'm missing there. But that's okay. Let's go on with the issues. Kumafi collector change payees executes incorrectly when new payees contains duplicate items. The payees are everyone that is involved and they were the ones to whom the fees are redirected later. Executing correctly when new payees contains duplicate items. Let's see.
00:09:41.698 - 00:10:16.802, Speaker A: When calling comma fee collector change payees with duplicate payees new payees, the call is not reverted and the result state will be incorrect. Okay, proof of concept. This contract does not support duplicate payees. The transaction will revert when trying to add duplicate payees. Okay, but function forgets this constraint which allows duplicate payees to be passed. It's missing the verification. Yeah, that's true.
00:10:16.802 - 00:10:42.326, Speaker A: This will cause the contract to record an incorrect state and not work properly. Nice, I guess. Desktop Poc I guess the solution is to add it. Add that verification. This is the test the mitigation should revert if there are duplicates. So should be adding that condition. Yes, in the change fee.
00:10:42.326 - 00:11:03.074, Speaker A: Do you see it somewhere? I see only contract. Okay. It's not showing the whole code I guess, but yeah, basically it's adding that condition. When we are changing the pay. We can check it on the PR for mitigation. There you go. Yeah, let's see.
00:11:03.074 - 00:11:32.940, Speaker A: Let's double check that it's in the change fee payee series. Yes. Okay, put let's go on. Price fit in get rate is not sufficiently validated and can return stell price. Okay, let's see how it's not sufficiently validated. Think we didn't check this contract anyways or we did, don't remember. Okay, but see this is something I mentioned.
00:11:32.940 - 00:12:18.390, Speaker A: There's a possibility that the data from Oracle, there's an error basically. So it's always important to make sure. So it's always a kind of flag. I mean not a flag as something bad, but an attention to oracles always and getting the rate from them. So get rate only uses answer but never checks the freshness of the data which can lead to stealth bond pricing data. Stell pricing data can lead to bonds being bought and sold on Kumaswap that otherwise should not be available. This would harm kab token holders as Kumaswap might accept bond with too low of a coupon and reduce.
00:12:18.390 - 00:12:50.946, Speaker A: Okay, okay so need to have a validation of the current data. So let's see. Recommend the mitigations validated. The validate that updated at answer. So instead of having this you see the plus line. You need to also take the time probably it's updated at and check that it's up to date. I guess this is the way of showing it.
00:12:50.946 - 00:13:22.414, Speaker A: And if so, revert if it's not up to date. The warning has shown how the system will not check for a steel price. Yeah, stell is like no longer fresh. Okay, so outdated. Basically this issue is tricky. Okay, here is central bank rate updates are not expected more than a handful of times a year. That's probably why it's not a high, I guess I see there was some negotiation there, but yeah.
00:13:22.414 - 00:13:50.614, Speaker A: Let's go to the next commas fab incorrectly reversed when Max coupons has been reached. Let's look at that. Okay. If the coupons length is max coupons reversed, the above lines will cause all bond sales to revert. Okay, we don't want that. Since bonds may share the same coupon, the swap should continue to accept bonds with a coupon that already exists. Okay.
00:13:50.614 - 00:14:26.820, Speaker A: One things are bonds and the other coupons. That's why that, okay, mitigation step. Bonds should only revert if the max length has been reached and bond coupon doesn't already exist. So we need to add another condition there. So we have the coupon's length that verification that we had. And we need to make sure that also coupon doesn't contain, because if it contains, this end will break and it will not revolt. Okay, got it.
00:14:26.820 - 00:14:51.142, Speaker A: A lot of verifications there are super important, okay. Even though this scenario is unlikely to ever happen, we have confirmed this issue. Is this issue in a test? Okay, that's probably the limit. Okay. And the discussion and the mitigation, let's see how they mitigated it. Files changed. Those are always, usually very quick.
00:14:51.142 - 00:15:11.680, Speaker A: Well, listen, is probably very quick fixes. I mean quick, short at least, lack of verification, right? Yeah. Okay. And some low risks. Let's go through them for this contest for reports were submitted. Blah blah blah blah. Kvc I think I've seen this before.
00:15:11.680 - 00:15:44.314, Speaker A: For each contract it is showing a list, right? Like zero one here. But then it changes the letters there and it says how many issues in this contract. Interesting way of showing as well. Let's go a bit through those improper disable of initializer. Oh, I think I've mentioned that earlier. It uses dependency with initializer contract being okay, this allow them okay, interesting. Good to know.
00:15:44.314 - 00:16:26.440, Speaker A: The contract contains a dedicated disabled initializer function. Means meant to be invoked by contract constructor implementations in contract and inherited, ensuring that the contract cannot be initialized or initialized in the future. Encoded in implementation, the initializer modifier is simply added to the contract's constructor, which does not disable the initializer properly as it still permits the reinisation to occur. Yeah, okay, I think I did mark that as a thing to check, right? Okay. Improper disable of initializer. Okay. It's happening in a few contracts, so it's probably going to repeat it.
00:16:26.440 - 00:17:37.178, Speaker A: A different way of raising this is raising the issue as low and adding the different places where this is happening instead of duplicating it. But yeah, I guess it's also possible to do it this way. Initial epoch sanitization set epoch length function properly evaluates that epoch length provided is not greater than no such sanitation sanitization is applied during the initialized function. We advise the initialized function to apply to same logical checks potential refactor to an internal function that both code segments utilize. Using those upgradable initialized always brings more attention needs more attention, definitely. I'm not sure about this honestly, so I will go on discripant epoch inclusively inclusivity definitions probably there is some different from the documentation. Usually when you go through the documentations you need to make sure if it applies on the contract.
00:17:37.178 - 00:18:42.014, Speaker A: So most likely this kind of loss is how it's called. So it's basically not following the documentation. But let's see. We advise either the assignment initialized to add epox length in existing informant of minimum maximum yield the Max yield constant variable declared remains unutilized. We advise it to be enforced in the refresh yield function by ensuring that the lowest yield being set is at most equal to max yield, in which case the value of max yield should be used instead. Additional demand okay initializer initializer improper release event let's see what happens with the event my operating an empty data entry. In such case, if funds to be distributed present the contract, this function will incorrectly execute release which in turn will emit field released event for the available income.
00:18:42.014 - 00:20:03.866, Speaker A: We advise the function to be invokes only when okay is nonzero in the reference instance, as otherwise incorrect events may be emitted and be misleading, probably in existing duplicate entry prevention. I think this is similar to what we've seen earlier. We advise to call the code to add a new if condition which causes the code to fail if it contains that pay already in existing limitation of variable fee function does not apply any sanitation on the variable fee value, permitting a fee to be applied that exceeds the 100% value of the bond. We advise the variable fee input variable of set fees to be validated as less than and preferably less than a stricter value to ensure unfair fees are not applied in the protocol. Again, this is following some of the documentation. This finding also ties in with the slippage related vulnerability submitting a separate exhibit whereby a user could submit a transaction with a blockchain state that applies a 5% fee and the fee could change between the transaction submission. How many more okay comma swap in existing limitation of variable fee does not apply a sanitation.
00:20:03.866 - 00:20:58.346, Speaker A: It's always usually missing checks permitting a fee to be applied that exists 100% value of the bond. We advise variable fee input variable offset fees to be validated as less than percentage factor and preferably less than stricter value 20% to ensure unfair fees are not applied. Sleepage related vulnerability in existing limitation of both there are lots of those improper disable of okay. We've seen that unsafe casting cast the result of that to a Un 16 variable. We advise a casting operation to be performed safely by ensuring that the calculation result does not exceed maximum value that I un variable. The built in safe array does not protect against casting overflows. I think it's called silent overflow.
00:20:58.346 - 00:22:01.422, Speaker A: That's true, and it's allowed okay in. Existing sanitation of state transitions does not ensure that the previous state was the opposite of what it is being set to. We advise to be applied to prevent misuse of the function as well as misleading events. Weak definition of owner this mint function accepts a KYC data argument that is meant to contain data permitting kYC data to be minted to an arbitrator address when the owner of the KYC data may be someone else. We advise them in function to permit minting of the KYC data by either enforcing two to equal the data's owner member or by not accepting a two argument altogether. Potential approval backlist bypass with the approve, the function will apply a blacklist check on the two as well as message under contextual arguments of the call. However, the actual owner of the token ID is not validated.
00:22:01.422 - 00:23:24.542, Speaker A: In contrast to set approval for all, which disallows an approval to be made by a party that is in the blacklist. While the approval cannot be on by the transfer from safe transfer from functions as they do validate the from argument, an approval being made on behalf of a blacklisted owner is an undesired trade, similar to something we've seen before. We advise the code to properly apply the blacklist to the owner of the yeah, we've seen that. Another inexisting citation of maximum this is a library incorrect code merge implementation present on the ab have a VC code base and it's merged from okay, that's interesting catch. We advise the repo functions body to be wrapped in an unchecked code block, replicating the original behavior of we would like to note that while presently not a vulnerability, code copied from other projects should execute in the same format. It originates from tusha okay, those are the gas optimizations, but we're not going to go through those, that's for sure. So this is mainly it mitigation review, probably.
00:23:24.542 - 00:24:05.900, Speaker A: Yeah, we already went through those. So guys, I think from now, as an experiment, this is all for now. So it's definitely been useful because I had to focus like useful for me, I had to focus on what I was reading, what I was saying. Obviously we didn't go deep, but it's a study session altogether. And yeah, let's see if you guys like it. Please let me know. Anything you didn't like understand or what other ways we could do this together.
00:24:05.900 - 00:25:17.006, Speaker A: I think it is a way that you can see for those are less experienced with auditing, some basic ways of auditing, or at least to overview the project. And for those that you watch and you are more expert than me, I'd be happy to connect with you guys and either do a real audit together or I would even love more if we could do another of these study sessions together so that more people can benefit from them actually. And yeah, let's stay in touch. Please let me know what you think of these sessions and well stay tuned for more. Since I'm starting with the channel then I plan to try to push different type of videos, different type of resources here I have my articles on medium, I have my account on Twitter. I am active in both. I will leave some links below and yeah guys, thanks a lot for staying by.
00:25:17.006 - 00:25:25.300, Speaker A: Of course. Please subscribe. It is only the beginning and yeah, take care. Bye guys.
