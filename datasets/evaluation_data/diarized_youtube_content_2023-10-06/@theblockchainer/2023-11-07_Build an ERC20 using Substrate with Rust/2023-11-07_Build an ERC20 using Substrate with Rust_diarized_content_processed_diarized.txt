00:00:00.330 - 00:00:58.794, Speaker A: What if I tell you that after watching this video, you will be able to implement any smart contracting rust and have it ready to deploy to polka dot or any substratebased blockchain? Exciting, right? I'm going to be as descriptive as possible from all the code presented, providing solidity examples to help understanding what it is all about. Let's start first let's consider this simplified ER C 20 contract written in solidity. For the sake of this exercise, we will not use open separates library and such a contract looks like this implemented in rust with ink. If you're still not familiar with rust smart contracts, don't get scared. Make sure to watch the previous introductory videos to rust and ink and it will be helpful. Then just come back here and continue. We will now start adding elements to the ERC 20 rust contract, comparing them with a solid way of writing it for better understanding.
00:00:58.794 - 00:01:31.446, Speaker A: Let's start with transfer tokens functionality. We'll start by adding the transfer function to the contract. The public transfer function calls a private transfer from to function. Because this is an internal function, it can be called without any authorization checks. However, the logic for the transfer must be able to determine whether the from account has token available to transfer to the receiving to account. We will see this in detail in a moment. Now let's start with adding an error declaration to return an error.
00:01:31.446 - 00:02:19.302, Speaker A: What can we find here? The first line with the attributes. So these are the derived attributes that automatically generate trait implementations. For the error enum we have that debug tag that allows for the formatting of the error enum for output, useful for debugging. Then there is partial IG enables comparison of error enums variants for equality. Then the IG indicates that all comparisons are reflexive, symmetric and transitive, which is requirement for some collection types. Then we have the scaling code and scale decode. These trades are from parity scale codec library, which is used for encoding and decoding data in substrate based blockchains.
00:02:19.302 - 00:03:27.246, Speaker A: They allow for the encoding and decoding of the error to and from byte representations. Then we have the next line. This is a conditional compilation attribute that only applies to drive scale info type info attribute, which if the StD feature is enabled, the scale info type info trait provides type information at runtime which can be useful for various purposes like metadata inspection. Then the declaration the pub public enum error. This declares, as I said, a public enumeration named error and we have the insufficient balance parameter there. This is a variant of the error enum representing a specific error case where a balance is not sufficient to fulfill a request. By creating this error enum, you can return a result type from your functions where the error variant contains an error insufficient balance whenever there's an attempt to perform an operation that requires a balance larger than available.
00:03:27.246 - 00:04:10.494, Speaker A: Here's how you could translate the provided rust error random to solidity using custom errors. You might be familiar with this. You can see that it's declared the error insufficient balance on the top, and later on it can be used in case of using a revert for the condition. Let's move on. So let's now add a result return type to return the insufficient balance error. By defining this type alias, you create a shorthand for referring to core result types that use your error enum for error results. This makes your contract code shorter and more readable whenever you want to use this result type.
00:04:10.494 - 00:05:25.410, Speaker A: In practical terms, this allows you to write function signatures like function my function and return my type instead of having this complex thing that core result resolve my type error like it's just shorter and more readable within the context of your ERC 20 contract, this result type would be used to indicate the success or failure of contract methods with error, providing information on any errors that occurred. Okay, next it's adding the transfer public function. What can we see here? We have this arrow result that indicates this function returns a result type with an empty tuple. So this parentheses as the success type. If the function succeeds, it returns okay, and if it fails, it returns the error with errors specified and defined earlier in your contract. Then the line with lead from where it calls the self environment and color retrieves the address of the color. For example, the entity initiating the transaction and stores it in a variable named from.
00:05:25.410 - 00:06:14.274, Speaker A: Then we have the self calling the transfer from to function that calls this separate function name transfer from, as I mentioned, with the sender's address, the recipient's address, and the amount to transfer as arguments. Here's how you could translate the given ink transfer function to solidity. Potentially you are more familiar with this. We can see that in this case, since it's returning the boolean as it happens in solidity, it's just integrated in the line with the return. Okay, so next we want to add the transfer from to private function. So the function that is being called from the transfer function above. What do we have here? So first we're getting the sender's balance with the lead from balance, calling the self balance from the from address.
00:06:14.274 - 00:07:06.902, Speaker A: Then we're checking for sufficient balance. So with a condition from balance is minor than value, and then throwing an error in case it's the case. Then we are updating the sender's balance with the insert function so that later we can be getting the recipient's balance and updating it. So you can see it in the line of let two balance where it's assigned the balance of two address and also later is inserting it to that address. And at the end we have the okay as a returning success in solidity, a similar function to transfer from to could be written as an internal function. In this way. Here we can see how it's updating the balance of the from address and the two.
00:07:06.902 - 00:08:04.534, Speaker A: Now, you might have noticed there are some stars there and ampersand. What are they used for? The star operator in rust is used for referencing pointers. In this case, it's referencing a reference in the line let from balance where it's applied in the balance of from address. The star from is the referencing from reference to get the actual value that from is pointing to. In rust, when you have a reference to a value and you want to access the actual value, you need to dereference the reference using the star operator. The balance of function likely requires an account id value or address, not a reference to an account id. With the ampersand account id, by writing star from, you are providing the actual account id value to the balance of function instead of a reference to it.
00:08:04.534 - 00:08:52.130, Speaker A: Let's see this in a simplified illustration that we can see here where we have the x, which is assign the integer ten. Then the y. It's actually reference to x, and the c with the star and calling y is now the seed is now the integer value that y refers to, in this case, ten. Okay, let's move on. Now we want to add a transfer event, as we have seen in the solid version, and you may be more familiar with, every time we make an important transaction, it's more convenient, and it's convenient to actually log it. So let's see how it looks in Rust and ink. As we see here, there is this attribute ink topic.
00:08:52.130 - 00:09:34.110, Speaker A: This is used to indicate which fields of the event should be indexed. As you might remember, in solidity we have the indexed keyword for this case. So next we add this transfer event to the new constructor. As we can see, this is the logic that goes inside the constructor, and also we add the transfer event to the transfer from function so that every transaction is logging. Next we want to add the approval logic. Approving another account to spend your tokens is the first step in the third party transfer process. As a token owner, you can specify any account and any number of tokens that the designated account can transfer on your behalf.
00:09:34.110 - 00:10:48.038, Speaker A: We declare the approval event using the ink event attribute macros we can see on top of the approval struct. And then we add an error variant, which is to indicate an error if the transfer request exists, the account allowance, and we include this insufficient allowance, then we add an allowance mapping and instantiates it. We add an allowance mapping to the storage declaration for an owner and a nonowner combination to an account balance. As we can see here in solidity, the equivalent of the given rascode snippet would involve using a nested mapping or a mapping of a struct. The more common and straightforward way is to use a nested mapping. You might be more familiar with this is this mapping inside another mapping instantiate and add now the allowance mapping in the new constructor we can add it, for instance, above the self total supply balances and allowances. And here the line that we're adding creates a new variable named allowances and initialize it with a default value by calling mapping default.
00:10:48.038 - 00:11:56.702, Speaker A: Then we want to add the approve function to authorize a spender account to withdraw. The approve function allows the owner the color of the function to approve the spender to withdraw tokens on their behalf up to a specified value that's usually specified in the functions parameters. We can see here the function let's go through it. So the line with the let owner where it's getting the saving the color retrieves the address of the color or the identity, the entity initiating the transaction and stores it in a variable named owner. Then we have the self allowances insert, which updates the allowances mapping with a new allowance, and at the end the okay, which it's a variant to indicate success. Then we want to add an allowance function. What do we have here? So in this line we have the self allowance allowances get, and it attempts to retrieve the value from the allowances.
00:11:56.702 - 00:12:46.222, Speaker A: Also, we can see this function used is the unwrap or default, which is a method call on the option balance returned by get. If the option is sum like balance, it will return the balance value, the one inside the sum function, and if the option is none, for instance, if there's no allowance set for the given owner and spender, it will return a default value, which for balance would typically be zero. Let's move on to another important function. It's the transfer from logic. Let's add that to our contract. The transfer from function calls the private transfer from to function to do most of the transfer logic. It's going to get interesting guys.
00:12:46.222 - 00:13:19.010, Speaker A: The transfer from function allows a caller to transfer tokens on behalf of the from account to the two account provided the call has a sufficient allowance. Here we can see and you may recognize most of the logic we have gone through. And guys, congratulations. Now you've got your ERC 20 smart contract implemented. Let me know in the comments if you found this useful and subscribe to not miss all the content coming your way. So stay tuned, stay innovative, and most importantly, stay connected.
