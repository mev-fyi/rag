00:00:00.730 - 00:01:08.270, Speaker A: Hey guys, welcome. This is the beginning of a series of video that I want to do while I'm learning Ehna and this basically I started a few weeks ago or maybe already a month getting into fussing and Mordebrian fussing invariant tests with foundry and in this case I also thought of switching to Ehidna and start using its potential. And yeah, I want to use also for starting the tutorial or the documentation provided by Trail of beads here. As you can see, eventually we will get this, an article I wrote recently and published in Fassi where I go a bit deeper on how to create invariants and so on. But I want to start from basics, how to install and so on. And so that you can see today we want to reach to install it and to run a very simple test. So let's start, let's go here is very nicely explained and actually you can jump into the introduction.
00:01:08.270 - 00:01:47.722, Speaker A: So for those that didn't have it installed yet, just go to installation here and you have a couple of or actually three ways to install it. For macOS, if you want to do it through Docker or with a binary, you go here and take the latest one. Also let me go back here. There is a nice series of fussing workshop. It's basically videos explaining everything about Hidna. But yeah, for now, today we want to start with this. And just once you do the installation, I will leave the link to this repository on the description.
00:01:47.722 - 00:03:03.990, Speaker A: So once you go through the installation, I will just go ahead and go through this fuzzing so that for those that are not aware like what is fuzzing or what is a fuzzer, let's go through it and get some knowledge. So fuzzing is a well known technique in security committee, which involves generating more or less random inputs to find bugs in a program. Fuzzers for traditional software such as AFL or leaf fusser are known to be efficient tools for bug discovery. So that's also why we want to really start using fuzzing for our smart contracts. Well, I will not actually go through all of it, but yeah, it's about obtaining feedback from each execution and guiding input generation with it. And it basically generates random inputs with a fusser, and there are at least a couple of types of fussing is the property base and assertion base. In this case we will start with a property based fussing with an introduce.
00:03:03.990 - 00:03:50.034, Speaker A: But he's a property based fusser and property based with a hidden is. Let's say Ehina belongs to a specific family of fuzzers. Property based fussing, which is heavily inspired with quick check. And in contrast to a classic fuzzer that tries to find crashes, Ehidna aims to break user defined invariants. So that's why it has a fusser. But it's also usually referred for invariant testing in smart contracts. Invariants are solid functions that can represent an incorrect or invalid state that the contract can reach, including incorrect access control, incorrect state machine, and incorrect arithmetic.
00:03:50.034 - 00:04:24.850, Speaker A: I mean, there is a lot of things we can check with invariance anyways, so actually let's start with a test. So I have it here. As you can see, the test implemented already and checked. This is basically a very simple smart contract, just a token contract with a few functions. Okay, so I have it here the token. So I have here the contract. I just paste it.
00:04:24.850 - 00:05:09.902, Speaker A: I created a repository with foundry, so I can compile it with forge build and so on. Here I added the contract that I use and let's see a bit of it. So we will assume that this token has the following properties. Anyone can hold a maximum of 1000 tokens. The token cannot be transferred, so it is not an ERC 20 token. And which properties? Ahina properties are solid functions and a property must have no arguments return true if successful, and have its name starting with a hina. So here it's basically referring to how the function is supposed to look.
00:05:09.902 - 00:06:00.910, Speaker A: So it's supposed to have no arguments. We will see it in a moment like it's here. So no arguments in the property base. So remember that we are in property based execution with a hidna, so it has no arguments returns true if successful. So this is the, it's comparing the values and its name starts with a hinan. Again, as I've learned the hard way, this is just for property base in assertion mode will be different, but you will get there. So what will Ahina do? Ahitna will automatically generate arbitrary transactions to test the property will report any transactions that lead a property to return false or throw an error.
00:06:00.910 - 00:06:53.934, Speaker A: Then you can debug it or see deeper, like check actually in the code and try to figure out whether it's actually failing or seeing the response, and it will discard side effects when calling a property. Like if the property changes a state variable, it is discarded after the test. So this is the test that we've seen, is checking that the balance of Mr. Cinder is less or equal to 1001 thousand was the maximum that anyone can have tokens. So yeah, this is how the test is implemented. Let me go to the implementation. So this is the contract when you want to test it locally, you can actually let me modify this in order to compile.
00:06:53.934 - 00:07:31.402, Speaker A: It's better if you just add the pragma solidity. And the same with like I added a hidden token. So I named the testing file, starting with Ehidna and then the name of the contract, in this case Ehidna token. So here I have it. I import as well the contract and the pragmas already. So this is how it looks. In this case, the constructor is empty, because the token constructor, it's empty, it doesn't pass anything.
00:07:31.402 - 00:08:20.494, Speaker A: So there is a way of calling it basically because we don't need to, well, it's extending it, right? Another way. Actually it's not shown there, but you might want to define it to deploy it here in the contract. So it would be enough to come here and do the token equal new token like this. And then you can call it as well. I found this, well these are two different, I think here we are supposed to pass it as an argument like this, if I'm not mistaken. Yes. So this is another way of executing it.
00:08:20.494 - 00:09:44.434, Speaker A: I found this a bit better option because, well, especially in assertion mode cases, well, it doesn't get polluted, the results, the report, but we will get there in another video. So it's very basic, right? We had a constructor empty, if we don't need to deploy the contract here, if in this case we do, and then what we have to, like what can I say? From here, as we can see, we need to return, and it's always a boolean, and in this case just one line, because it's very simple test, but otherwise you will just need to make sure that the end is returning something. The function is supposed to start with a hidden and nothing more to say. So I actually want to show how it runs or how to run it, and I wanted to point maybe let's go back here, because in the documentation everywhere I've seen that, yes, running with Ahina contract Sol. So in this case, just specify the token Sol as we have, and in this specific way as well. However, for me this doesn't work. It for some reason gives me some error.
00:09:44.434 - 00:10:19.454, Speaker A: I didn't try it now before this video, but if I show you how it looks, he's not talking that. Sorry. It would be funny that now it would work, but it throws me an error. I have been asking around, I'm not sure why it fails. I know I'm not the only one, but yeah, it happens. So the way I found out by asking how to run it. It's basically I do a hidden dot and then contract flag.
00:10:19.454 - 00:10:55.614, Speaker A: And then it's when I specify the name of the contract which contains my test. So if I run this and I didn't make any mistake, it compiles it and then it runs it. So in this case, we can see the result. Yeah. So you can see here a few different things, and I will go through what it is in a different moment. Actually, I have gone through what it is. Everything in this article I wrote, to be more specific.
00:10:55.614 - 00:11:08.330, Speaker A: But, yeah, I think this is just an introduction so you can get started and we'll continue getting deeper in further videos. So, yeah, thanks for watching, guys, and see you in the next videos. Take care. Bye.
