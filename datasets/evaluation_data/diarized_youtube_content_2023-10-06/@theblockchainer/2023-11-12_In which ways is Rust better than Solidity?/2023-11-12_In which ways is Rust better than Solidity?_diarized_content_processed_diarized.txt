00:00:00.090 - 00:00:57.934, Speaker A: Let's compare, not compare rust solidity, but just take solidity as a baseline. I'm talking from my own experience, and when I write Ras smart contract afterwards, I'm more confident that I didn't fuck up than I write solidity smart contract. That's the basic also like a first feeling when you get when you write rust smart contract at the end. Because if rust by itself actually has so many additional security features built in and compiler is not forgiving, usually you eventually make less mistakes writing a smart contract. Even, let's say a basics. Rust provides you with the many ways of, let's say, how to handle overflows. For instance, in rust you can handle overflows in many different ways how you like it.
00:00:57.934 - 00:01:52.394, Speaker A: It also adds the additional flexibility. And also by default, as long as you compile correctly, you won't have any overflows in your rust. Like if you add overflow checks in your cargo turmal, if you added like a checked ads, you shouldn't have any problems there. And also, I would say that's a bit would say controversial. But usually if you already know Rust, if you're writing, let's say rust smart contracts, you spend a long time, I mean, not a long time, but it's harder to learn rust than solidity. And because of this barrier of entry is higher, and usually output of smart contracts is a higher quality than in solidity. In some cases, that also plays a vital role.
00:01:52.394 - 00:03:26.270, Speaker A: I would say what compiler provides you with is that you don't like one of the reasons why Rust was adopted in web two, actually in AWS and in many other places. First of all, rewrite some stuff from C plus plus to Rust is that it prevents majority of memory issues that actually one by itself, it's already a big reason why many people are just rewriting everything, because it's harder for a developer to write something stupid unless you write unsafe rust. Even in unsafe rust, if you write unsafe rust, it doesn't mean that borrow checker just turns off, it's just more permissive, I would say. And also in addition to this, because of its speed and basically execution and lower memory, it's super useful for serverless applications. We are writing currently a trust block. Our whole stack is serverless, and we are planning to change some functions from we're currently writing in node Js, basically JavaScript type sorry, typescript to rust, because execution time is going to be much lower and therefore the cost savings are going to be higher for us. So that's also another benefit of a rust of its speed and its memory footprint that I would say is super beneficial.
00:03:26.270 - 00:03:45.970, Speaker A: So, yeah, I mean, for compiler, it's great that it just prevents so many memory issues that you can have out of the box. The only drawback is sometimes compile time, but you have to live with that. But it's not a big deal to be like in some cases.
