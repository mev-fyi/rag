00:00:00.440 - 00:00:45.268, Speaker A: So I prepared a presentation about formal verification, and it's actually on GitHub as well. So if you go to GitHub.com epamos presentations, then it's there as well. So it's an HTML presentation. So I thought hard about how to structure this talk, and I kind of made a dependency graph for all the things that you might want to know in order to learn about formal verification. And it quickly occurred to me that it would be possible to fit everything into one talk. So I decided to today talk about the bottom left three, EBM, K and KBM, and save the other four for next time.
00:00:45.268 - 00:01:11.740, Speaker A: So today we're going to talk about these three. As such, the goals of the talk will be to kind of show you how the EVM works under the hood, show you how k works in a way, and then we'll put the two things together and we'll construct Kevm.
00:01:11.812 - 00:01:12.740, Speaker B: What is K?
00:01:12.892 - 00:01:29.976, Speaker A: Yeah, that's what is the contents of the talk. So. Indeed. Okay, so let's start with her.
00:01:30.000 - 00:01:32.184, Speaker B: You thought you'd be continuing the recording?
00:01:32.304 - 00:01:33.920, Speaker A: Yes, yes, we have.
00:01:34.072 - 00:01:35.404, Speaker B: It's a recording online.
00:01:35.784 - 00:02:52.914, Speaker A: Yeah, and I also. Yeah, and also when I was, when I was preparing this presentation, I wanted to make it accessible and technical, so I want to make it so that everyone can understand it. But at the same time, we go into the nitty gritty inner core of the topics. So let's begin. So the EVM stands for the Ethereum virtual machine, and a virtual machine is essentially an execution environment, in this case for Ethereum transactions. The first thing to note is that there are multiple versions of the EVM. A good rule of thumb is that all of EVM's inner workings can be constructed from the definitions of the opcodes of the virtual machine, because these immediately give rise to data structures such as word and address, and what in academia are called stores such as stack, memory storage, call stack, gas, program counter, and so on.
00:02:52.914 - 00:04:04.464, Speaker A: So let's begin with the very first version of the EVM, which was Frontier. So in frontier, which was the very first version, so it was released together with the Genesis block about three years ago. Programs, as always, are abstracted as numbers, and global implementation is a byte code. Each byte can be represented by two hexadecimal numbers, as always, zero through f. So now let's look at some of the most popular opcodes. So I actually did some python magic, and I was able to find the most popular opcodes for basically any contract in the world. So for the gno token, the most popular opcodes are push one, which just takes the next byte in the bytecode and pushes it onto the stack.
00:04:04.464 - 00:04:37.694, Speaker A: Fun fact, it's also the only opcode that interacts directly with the, with the bytecode. So it's the only opcode that has the power to ignore other, other bytes and interpret them as data instead of as opcodes. Does that make sense? Like you have a bunch of opcodes, but then if you have a push opcode, then the following bytes will not be interpreted as opcodes. They'll be interpreted as data for the push.
00:04:38.314 - 00:04:42.690, Speaker B: Maybe we need one step. What would our opcodes actually.
00:04:42.882 - 00:04:56.204, Speaker A: Oh, so opcodes are instructions of a virtual machine. I'm going to show the opcodes. I'm going to discuss it all. I just wanted to point out a few before I do that. Or do you want to say something.
00:05:00.184 - 00:05:09.072, Speaker B: About solidity? Solidity is a high level program language. You need a compiler that translates this to low level language.
00:05:09.208 - 00:05:14.724, Speaker A: This is like in a computer is.
00:05:16.424 - 00:05:17.928, Speaker B: A machine language.
00:05:18.096 - 00:05:18.632, Speaker A: Yeah.
00:05:18.728 - 00:06:11.468, Speaker B: On a very low level a computer can do the calculation is broken down to very small, very small instructions. So very, very small instructions. Adding two numbers or going, you have a bunch of data and just kind of pointer for this data and just saying something like set the pointer one step forward or you have a stack of data. So really make this one data point and then the next one is on top of it and so on. You just add another data point or fit or write on that level. It's the smallest possible instructions. Using for example, doing a sum of numbers.
00:06:11.468 - 00:06:13.996, Speaker B: It's not just one operation, you need.
00:06:14.020 - 00:06:16.236, Speaker A: To get it from memory and then.
00:06:16.260 - 00:06:21.964, Speaker B: The other parameter and then take it back to where you want to use it. So actually it's a lot of.
00:06:28.104 - 00:06:32.564, Speaker A: Cool. So yeah, just to remind one more.
00:06:36.144 - 00:06:49.372, Speaker B: Opcodes, they should be of course be represented as small as possible. So how many opcodes does Ethereum actually have? And Dominica might help you with like.
00:06:49.428 - 00:06:52.004, Speaker A: Right now, I think it's like 138.
00:06:52.044 - 00:07:27.968, Speaker B: Or something like that. Yeah. So the opcodes you have in general, you have virtual machines, Java VM, Java virtual machine and so on. They are kind of just virtual machines that have a set of opcodes where you can do normal computer programs. And the EVM Ethereum virtual machine was a virtual machine that parts kind of general stuff. So general computation. But it has a bunch of opcodes that are very specific to Ethereum.
00:07:27.968 - 00:07:30.524, Speaker B: So that is, for example, validating a signature.
00:07:31.984 - 00:07:34.016, Speaker A: I'll go through all that.
00:07:34.160 - 00:07:51.402, Speaker B: So yeah, already pointed out so that you had. Just because of the addressing scheme you can have 256. That makes different opcodes and currently like 200 something, whatever number it is already used.
00:07:51.458 - 00:07:54.450, Speaker A: So basically it means the Ethereum system.
00:07:54.522 - 00:08:05.730, Speaker B: Can, if needed, introduce just a very limited number of new opcodes, additional opcodes to enable additional stuff.
00:08:05.842 - 00:08:54.434, Speaker A: Yeah, it's also why it's very dangerous to use currently not use opcode as a placeholder for reverting. And the reason is, in the future, the opcode could gain semantics, in which case the execution would be different than the current version of VPN's. Cool. So the level is everything. Yeah. So basically, just to summarize in one sentence, maybe the EVM is the execution environment for all Ethereum transactions. And in order to execute stuff, you need to be able to set instructions, and the instructions are the outcomes.
00:08:54.434 - 00:09:28.930, Speaker A: So an instruction could be pushed. So for example, this could be a basic EM program, and then add whatever the number for add is. I don't remember. So unless I'm mistaken, 60 is push one. So it pushes zero zero. So we have, the stack is composed of zero zero, in other words, zero. Then we have 60, which is push one again and we have zero one here.
00:09:28.930 - 00:10:21.114, Speaker A: So now we have zero one on the stack, and then we do add. And what add does, it pops the top two elements of the stack and it replaces it with the sum modulo to the 256. So then we get the result to be one. Right. And then you could maybe do, you could maybe copy it into memory with some other opcode. So you could do m store eight, which just scores a single byte, and then you could do return and you could pass in the address of the memory where you stored this. Now it would be a very simple program that all it would do is every time you would call it, it would add zero and one and give you the answer.
00:10:21.114 - 00:11:20.564, Speaker A: Is that clear? Cool. So some of the most popular opcodes are push one pop, which just deletes the top element, swap one, which takes the first and two elements of the stack and swaps them, Duke two, which duplicates the second element and places it on top of the stack. So now it becomes the third element, and which we already saw the semantics of right here. It adds two numbers, modulo two. And you said these are like the most popular, so that's a really good question. Yes, for the geno token. And now the follow up question could be, are they the most popular outputs overall? So I also ran this on another contract, and that is the latest version of the notes safe, and I got a extremely similar result.
00:11:20.564 - 00:12:02.174, Speaker A: So yes, they're probably very popular now let's have a look at the other opcodes. So this was just kind of like a teaser. So I categorized the opcodes into two categories, generic that could be present in any machine, and blockchain specific that are specific to the blockchain environment. The first subcategory would be opcodes that deal with the control flow. So stop is very simple, it just halts execution successfully. Jump is very simple as well. It jumps to a different program counter.
00:12:02.174 - 00:12:36.354, Speaker A: Jump I is very simple as well. It's a conditional jump, so it pops the top element of the stack and if it's one then it jumps, and if it's zero it doesn't. You can only jump to something called the jump destination. So we also have a jump desktop code and you can also read the current program counter from the program and push it onto this stack. So that's the semantics of the first five uploads.
00:12:37.744 - 00:12:39.480, Speaker B: Program counter counting.
00:12:39.632 - 00:13:15.332, Speaker A: It's counting the program counter. So every time you execute an opcode you increase the program counter. Okay, so if we were to go through the execution of this program right here, the program counter would probably start at zero or one because mixing is appropriate. So it would start at zero. Then once it executed this opcode, it would go up to two. Once it executed this one, it goes up to two, then add will go up to three, then m store, I think takes like two variables. And it would go up to six and then return and it would go up to nine.
00:13:15.332 - 00:13:41.614, Speaker A: Right. So. Or. Sorry, actually that was not correct because mstore and return, they take arguments from the stack rather than from the bytecode. So each of these would increment it only by one. In fact, every single opcode increments it by one except for the push out code. Right, because that's the one that interprets the following bytes as data, not as outputs.
00:13:41.614 - 00:13:45.594, Speaker A: What actually does this tell us? That these are the most popular opcodes?
00:13:45.634 - 00:13:48.418, Speaker B: Is that related to specific functions of.
00:13:48.466 - 00:13:59.314, Speaker A: How gneos are used? Not really, no, because the NASA state and the genome token are extremely different contracts and yet they still have the most, pretty much the same.
00:14:04.174 - 00:15:02.040, Speaker B: So the contracts are written in higher level language. And this language here constructs like adding variables, but under the boot that is compiled, compiled down to those very very much smaller instructions. And yeah, probably you have different options how you kind of do those higher level instructions, how you break them down to those very smaller level instructions. And probably you could create another smart contract language that would use, that would kind of use different offers more. Although I assume there are just some opcodes that you will always need more and more often because they are just very very fundamental to doing anything, any.
00:15:02.072 - 00:15:10.792, Speaker C: Kind of like stack operations depending what kind of memory is used within execution. That's just generically so important.
00:15:10.928 - 00:15:11.336, Speaker A: Yeah.
00:15:11.400 - 00:15:42.854, Speaker C: If you guys want to alexei very detailed all of our contracts on the level and. But really inefficiently so they're using lots of opcodes which are not really necessary to get the same result as you actually want to based on your flippy code. So many of those are probably not really necessary, just compiling it to upload.
00:15:42.894 - 00:15:59.630, Speaker A: So analyzing this will help us to make our code more efficient or have others to use a more efficient way. Yes. Yeah, I mean in theory yes. In practice that is not usually what it's used for. It's. I would say it's used for. Yeah, one of three things.
00:15:59.630 - 00:16:16.554, Speaker A: The first one is to make it more. Make the code more efficient. The second one could be to do stuff that solidity doesn't support because solidity doesn't have support for all the functionality of the machine. And the third one could be to do formal verification.
00:16:28.014 - 00:16:39.676, Speaker B: If you write directly that would be more efficient. But it's not readable and it doesn't scale. I mean you want to do all of it forever.
00:16:39.830 - 00:16:43.904, Speaker A: Yeah, we'll have a lot of redundancy.
00:16:43.944 - 00:16:59.244, Speaker B: And code that doesn't do something useful. And maybe some things are maybe security because the compiler can have a back and put the code that you don't expect but you can read the code easily.
00:17:02.064 - 00:17:19.147, Speaker A: Yeah, I totally agree. So for example, this program that we wrote that all it does is it takes zero and one and adds it and returns it in solidity that would be one line, right? But in the opcode level it's like twelve altcoats.
00:17:19.315 - 00:17:22.339, Speaker B: Now if you wrote return 10 in.
00:17:22.371 - 00:17:51.608, Speaker A: Solidity and compiled that two bytecode, would it look like what you. No it wouldn't. And the reason is the solidity compiler is very interesting. Compiler is worse than us collectively writing the output. It's worse than usually compilers need to make assumptions, but it does make mistakes. Since you guys were so interested in the most popular opcodes. This is the entire frequency density for the gnosis.
00:17:51.608 - 00:18:15.044, Speaker A: So exactly as Stefan was saying. Stack operations are by far the most popular. And then also memory is dealt with quite a lot. M store and M load and that's pretty much it. There's very little of other opcodes. So now let's just briefly go through all of the other ones. Oops.
00:18:15.044 - 00:18:16.240, Speaker A: Right here.
00:18:16.352 - 00:18:17.324, Speaker B: There we go.
00:18:18.064 - 00:19:55.954, Speaker A: So there's a bunch of arithmetic and bit functions and predicates such as adding two numbers modulo two to the 256 is zero, which takes the top element of the stack, and if it's zero it returns true, and if it's not it returns false, returns zero. Everything is interpreted represented as zeros and ones and equality greater than and or which does exactly what you would expect them to in the real world and many other ones. There's a bunch of stack operations that we've already touched upon, such as push one through 32, which is actually 32 different opcodes, and allows you to push data onto the stack from the bytecode itself, pop, which does the opposite dupe and swap, which we've also already discussed both, also in 16 different versions. Next, we have opcodes that deal with memory. So you can read and write to memory and you can read it right to storage. And noteworthy is the sub destruct language, which it takes one element from the stack and it forwards all of the ether of the current contract to that address, and then it removes the current contract from. Well, it depends which version of the EVM.
00:19:55.954 - 00:20:47.120, Speaker A: Before it would just null it, but now it actually removes it from the state tree as well. But since we're talking about frontier here, it just nulls it. So what does it mean to null an account? It means to reset its balance. Its storage is nonce and its code. So every account in Ethereum has those four fields as well as an address. So the blockchain specific opcodes, they actually occur quite rarely. The only one that is common is Sha three, which is a very confusing name because it's actually the KeCaG 256 hash function.
00:20:47.120 - 00:22:11.734, Speaker A: It's not the shall three function, so don't get confused. But that's not. So the reason was this, that this was finalized. Sorry, the Ethereum frontier release was finalized before SHA three was finalized, the standard for the hash function. And when that changed, ethereum obviously couldn't change anymore. So then we have basically a bunch of opcodes to get information about the current transaction, about either the current block or the last 256 blocks, and to read and write to other smart contracts in the network. And finally we have opcodes that give rise to a bunch of stores that we haven't discussed yet, such as the call value of a transaction, the call data, and the return of field and the logs and gas field.
00:22:11.734 - 00:22:43.438, Speaker A: Okay, so now we have an overview of every single opcode that, that was released in 2015. I write that there are 65 opcodes because I kind of collapsed these, these, what is it? 65 opcodes into four. And also, so this gets, this gets reduced by something like, whatever. Yeah.
00:22:43.606 - 00:22:45.754, Speaker B: How do you swap an odd number?
00:22:47.294 - 00:22:49.406, Speaker A: How do you swap just like a.
00:22:49.470 - 00:22:55.734, Speaker B: Cyclic thing or you can't swap an odd number. You can't swap more than two things.
00:22:55.774 - 00:22:56.354, Speaker C: Really?
00:22:56.974 - 00:22:58.934, Speaker B: So what is swap three, for example?
00:22:59.014 - 00:23:06.614, Speaker A: Swap three. Swaps the first and the third element. Or actually, no, no, I said that wrong. Swap three. Swap the first and the fourth element.
00:23:08.194 - 00:23:15.534, Speaker C: Okay. Maybe the best way to explain this would be to open VMiX and run a very small program.
00:23:15.874 - 00:23:36.152, Speaker A: Yes. Yeah, that's, that's not a bad idea as well. So if you guys want to learn more about the EVM, one of the ways to do that. Well, I would just run k em because I think that's the best way. But you could also, although I do not know how to enter bytecode programs into remix.
00:23:36.208 - 00:23:37.352, Speaker C: Oh no, you can write.
00:23:37.408 - 00:23:43.208, Speaker A: Oh, you can write. So let's do that. So we have a contract.
00:23:43.336 - 00:23:45.404, Speaker B: What if we write your adding?
00:23:46.424 - 00:24:44.358, Speaker A: Let's write. So let's make it a function that returns an unsigned integer and its semantics will be that. All it will do is it will return one plus zero. So now let's deploy this contract and let's run the test function. So you get a transaction back and you can click on this beautiful field called debug. No, it's actually pretty cool. And then you can step through the entire execution of that function and see.
00:24:44.406 - 00:24:55.068, Speaker C: Exactly what is the translation of the 30 code into the opcodes. And then you can see how the stack and memory is changing during the execution of this function.
00:24:55.196 - 00:25:16.316, Speaker A: Right. So, yeah, so basically you can also, where's the Stefan, do you know where the, where I can see the opcode of the contract on the right side? Oh, right, right, right.
00:25:16.380 - 00:25:16.700, Speaker C: Okay.
00:25:16.732 - 00:25:40.674, Speaker A: And then there's, there's another, there's like a part up, you know, where it shows me everything. Do you know how to get there? Oh, is it? Maybe. Yes, that's what I wanted. So this is another way to see it, I think the best way, because you have like all the outputs here. So this is exactly the outputs it generated. So let's see, let's see where, where the code that we wrote is like.
00:25:40.714 - 00:25:41.734, Speaker B: Going to be there.
00:25:43.274 - 00:26:05.654, Speaker A: But I mean, it doesn't matter. As you can see, it's really, really like complicated. Right? It's so much more than it would require. Literally all it would require is this. But that's assuming that it's a fallback function. It's not a fallback. It would require a little bit more but still not much more than this.
00:26:05.654 - 00:26:36.114, Speaker A: Okay. And what you can also do is you can use the debugger to step through the entire execution. And therefore you see both what is on the stack and what is in memory. As well as all of the other stores of the Ethereum virtual machine such as the call stack. The call data and the return data. So this is actually really cool. Yeah, thanks for bringing this up.
00:26:36.114 - 00:26:55.834, Speaker A: This is the best way I think to learn about the. Cool. So let's just go back to the presentation and. Yeah that's. That's pretty much it. That's all I wanted to say about the opcodes.
00:26:59.334 - 00:27:23.304, Speaker B: So maybe you can point one more opcode. So there is when here you makes once in a while a hardcore. And the next hard fork is scheduled. Was scheduled for November. That there were some issues. Right now it's scheduled February. And there is always a discussion to use new opcodes.
00:27:23.304 - 00:27:50.800, Speaker B: So the advantage of having an opcode is that you can do things much cheaper. So in theory those opcodes that exist allow you to do everything that you can imagine. So that would be called Turing complete. So with a bunch of help codes. And you would need much less than this hundred. I guess you need like something like ten opcodes. And it's not ten opcodes.
00:27:50.800 - 00:28:29.094, Speaker B: You are you are able theoretically to describe every program that you can imagine. However if you have more opcodes it allows you to describe to do the same thing more efficiently. So one example is this hash function. You can kind of do like 20,000 steps to perform this hash function. Or you introduce one opcode that just does it. So instead of doing 20,000 steps you do just one step just defined as do this. Whatever the hash function does.
00:28:29.094 - 00:29:04.484, Speaker B: Take some data and do some calculations. And you get a hash of it. So the trade off is you could kind of have a long list of opcodes. But even for the addressing to give every opcode a name. If you have more than 256 opcodes you would need more storage to even kind of name them. There are a bunch of other compromises. So if you have very easy opcodes you can write, you can do hardware.
00:29:04.484 - 00:29:33.444, Speaker B: Computer hardware. That exactly can kind of where the hardware is running this upload on hardware. You basically wire basically hardware. In a way that can do this small instructions very efficiently. If your set of opcodes is bigger then you would kind of need to create specialized hardware. So there's trade off between specializing and being generic. And so there's always discussion around adding new opcodes or not.
00:29:33.444 - 00:30:14.962, Speaker B: So one example of opcodes that was added like year after frontier was the opcode that would allow the zero knowledge proof stuff. So the stuff we are working on with the diffusion. But then again this opcode is only good for some forms of knowledge technology. Now it's moving forward and you would kind of put me to new opcode. So that's the high level trade off. And for the next hard folks there are like one, at least one new.
00:30:14.978 - 00:30:19.254, Speaker A: Opcode and I think there's, there's five new opcodes.
00:30:20.994 - 00:30:21.978, Speaker B: Call to.
00:30:22.026 - 00:30:25.094, Speaker A: There's call to. I'm going to go through. I'm going to go through everything.
00:30:25.554 - 00:30:26.814, Speaker B: I'm going to go through.
00:30:27.994 - 00:30:32.454, Speaker A: There's, there's five. Cool. So we can one last high level.
00:30:32.954 - 00:31:44.360, Speaker B: So the approach of Ethereum is to have this one, this one virtual machine. There is in blockchain worlds there is another approach that is the approach Polkadot, for example, is choosing. They say let's have different execution environments. The EVM would be one execution environment, but let's allow different virtual machines with different sets of opcodes that are specialized for different things and try to connect them all. So we have the Polkadot network as a center just about collecting transactions, collecting data and then have all those different execution environments which are specialized. So instead of having a fight kind of on should we introduce software, shouldn't we, you just add a new execution environment with its own set. So those are kind of the high, very high level trends or discussions or tendencies where blockchain wallet could evolve.
00:31:44.360 - 00:32:18.908, Speaker B: Is that what cosmos is doing as well? Yeah, Polkadot and Cosmos are fairly similar. They have differences, but on that general scheme they say, well, let's have different blockchains or execution environments that are somewhat connected through a hub that are specialized for different, except by Ethereum is trying to easy everything for everything. I have one question regarding these more sophisticated opcodes like the hash three. Now we're sort of including this as.
00:32:18.916 - 00:32:20.664, Speaker A: An opcode so that we don't have to.
00:32:22.444 - 00:32:31.866, Speaker B: Compile it down to like 20,000 operations or something. But those 20,000 operations that are required to hash something still need to be performed somewhere.
00:32:31.980 - 00:32:34.070, Speaker A: Right? So is this just something that tells.
00:32:34.102 - 00:32:39.510, Speaker B: The machine, all right, this corresponds to these 20,000 operations. It's still being performed? No, no, no.
00:32:39.582 - 00:32:46.614, Speaker A: So it actually allows. I don't think that's how it works. Like the clients they implemented natively.
00:32:46.774 - 00:32:47.470, Speaker C: Yes.
00:32:47.622 - 00:32:51.526, Speaker B: Well, I mean, I mean, so there is a calculation being. Yeah.
00:32:51.630 - 00:32:52.314, Speaker A: Yes.
00:32:55.094 - 00:33:57.434, Speaker B: So the, the client itself itself would run in a virtual machine. So you can have a virtual machine on your computer running Linux, and within the Linux there you run this. Whether it runs or how it runs, there can be many layers of abstraction, but of course the ultimate or goal would be that, that you can run this OPV directly, but then the machine would actually have to have that functionality. But why are we, why do we need this opcode at all? Or why is it important to kind of bring it down to instead of having 10,000? Of course, having fun here, point out correctly again, that needs to be done is every of those opcodes has the cost associated to it.
00:33:57.934 - 00:34:00.742, Speaker A: So that's the guess, yeah.
00:34:00.798 - 00:34:38.154, Speaker B: So every, every of those local kind of adding costs, accessing storage plus 20 and making up those numbers. But writing storage is kind of one of the most important costly things. It costs like 20,000 instead of five or even making. It's much more expensive. Right. So in a way when you introduce a new opcode like this charm, you're subsidizing specific things. So you know those costs are necessary to make the system, to make the.
00:34:38.194 - 00:34:38.774, Speaker A: System.
00:34:40.674 - 00:35:30.504, Speaker B: Kind of immune against spam attacks. So if someone writes a malicious code that's really hard to perform and kind of would slow down the network. Therefore it's important to have those costs. However, for something like a hash function we know, well, I mean you could express this as 20,000 steps, but at the end of the day we know hash function that something computer can calculate. So we can manually say, well, we just said the cost is something very small because we can be sure that it is something that's actually not that hard, but in general give everything a price. It's hard because someone who's malicious might come up with some combination of using those very small codes to do something that's in reality much harder.
00:35:35.264 - 00:36:11.220, Speaker A: So next I was going to have a slide, but it's not on the presentation. That's what you get when you write the presentation in code. Is that buggy? So this slide was meant to be this. So there are also other ways to categorize the opcodes and the ones I chose. Examples include whether they change the state. So the only ones that change the state of the blockchain are actually the ones that change. The permanent storage memory and stack are transient storage locations.
00:36:11.220 - 00:36:49.690, Speaker A: So log s, store, call, create and self destruct. You can also categorize it by how much stack they need up. Everything from military stack operations, which would include just stuff that reads stuff very very easily. So for example, stuff jump program, counter, let's see, what else would be a null stack operation. Doesn't take any stack at all. Address balance, origin, color and gas price. These five as well as well as anything that ends with size.
00:36:49.690 - 00:37:35.640, Speaker A: Except this. Except this one because that also you need to specify which address you want to use. But for example, this one would be a unary stack operation. Doesn't take up any stack, you just call it and it gives you an answer. And then the worst case are operations that take up six elements of the stack. So an example is call and call. And I believe it's call code that take up six elements from the stack because they require you to set the address, set how much value you're transferring to that address.
00:37:35.640 - 00:38:35.026, Speaker A: Then set the memory location of the code that you want to send as part of the call. And that picks up two stack locations. And then finally if you get a return value where in the memory should you put it back? Which takes up two more stack memory stack operations. So in total there's six arguments that go into this function from the stack. And as Martin already perfectly mentioned, the opcodes are also categorized by how much gas they need, which is either a constant or a function. And that gives rise to number of equivalence classes on the opcodes which are in the geth implementation called g zero. For opcodes that don't cost any gas at all, g very low and so on.
00:38:35.026 - 00:39:18.064, Speaker A: Now you might ask what's the point of gas? Why do I need to pay it? So there's two main reasons. The first one is to prevent infinite loops. If there's a fixed amount of gas, therefore fixed amount of gas, then you will never be able to do an infinite loop. And the second is to incentivize people to optimize their code for good execution. Fast execution of the Ethereum network energy cost, for example. Yes, exactly. Which is, which is a really cool.
00:39:18.064 - 00:40:17.416, Speaker A: So let's go back to the presentation. When I said that there's all the inner workings of the EVM can be constructed from the opcodes actually live because the EVM has these things called precompiled contracts which are just contracts at the address, one, two, three and four that do a specific thing. And the EVM has been criticized for not having these as simply opcodes. And actually I don't know what the reason why they chose this implementation, but it definitely makes, for example, formal reasoning very very difficult. It just makes it more of a pain in the butt because the reason is that as we'll see in the next presentation formula, symbolic reasoning. And whenever you generate an address at random in KDBM, you always have to assume that it's not one of these four addresses. So it just makes everything more complicated.
00:40:17.416 - 00:40:47.594, Speaker A: But if some of you know the reason for this implementation, I would love to hear it. So yeah, I mean it could have been, it could have been various things. It could have been something like the fact that the opcodes were finalized, but then afterwards they wanted to also add support for these four functions. I think that's the best reason that I can figure out. Cool. So now let's talk about the other versions of the EVM very very quickly. This was the hard part.
00:40:47.594 - 00:41:26.946, Speaker A: 99% of everything is same across all the versions. So we go through the hard part. Now let's update it with recent improvements, some notation, get started. And Ethereum improvement proposal, which comes from the days of when the Internet was being born, is a proposed change to the protocol of Ethereum. And when they get included in the main chain, it's called hardcore. Note that all of the upgrades of the Ethereum virtual machine required a hardcore, but not all of the hard forks deal with Ethereum virtual machine. There are many examples where hard forks had nothing to do with Ethereum virtual machine.
00:41:26.946 - 00:42:01.744, Speaker A: They can also change balances arbitrarily, like the Dow fork. The Ethereum protocol so includes specification for the clients. So when the client specification changes, that requires a hardcore, as well as decrease the block reward and change difficulty, which have been changed multiple times. The first, actually the first hard work to impact the EVM was in March. And it was very simple. It was basically a bug fix. The two bugs in the EVM.
00:42:01.744 - 00:43:12.724, Speaker A: The first one was that. So if you were to execute, if you were to create a contract through a transaction, it would cost 21,000 gas. But if you were to uh, make a transaction to a contract that will call the create opcode that we saw earlier. So we meant to make a transaction to the create opcode, then it would cost 21,000 for this and the create opcode cost 32,000. So basically it made this too cheap because you would uh, you would save 32,000 for the create off code. So what Homestead did is it made the cost of a transaction that creates a contract naturally 53,000, which is what it is today, and introduced a new opcode called delegate opcode delegate call which was basically a bug fix to call code because that did not preserve message sender and message value when it was called, which is probably what you would want from and opcode with that semantics.
00:43:14.864 - 00:43:33.244, Speaker C: And then there were this kind of opcode is kind of useless, but because assign like a different functionality to it right now. So it's kind of. Yeah, it uses Opcode that we know will always be there, but yeah, it won't be used anymore.
00:43:34.464 - 00:44:22.944, Speaker A: Exactly. Then there were two more hardcore and they were kind of minor. They were mainly concerned with preventing the denial of service attacks that Ethereum was facing at the time of Defcon two. So it increased the cost of gas for some read and write op codes such as self destruct and external code size that required so much computation on the part of the client if they cost so little gas before. So basically, again, we'll kind of like a bug fix. Cool. I just wanted to ask whether we're going to finish at one or not.
00:44:22.944 - 00:44:28.584, Speaker A: I think I have about 20 more minutes. Okay. So this year is already.
00:44:29.324 - 00:44:30.824, Speaker B: I'm sure we can.
00:44:32.784 - 00:44:59.984, Speaker A: Yeah, 15 minutes. Yeah. Cool. Awesome. Just take a drink. So Mezan Tim introduced four new opcodes and. Yeah.
00:44:59.984 - 00:45:39.038, Speaker A: And four new precompiled contracts which enable the use of maybe CKD. Yeah, that's why I'm skipping. That's why I'm skipping the semantics of all these. And finally for completion to new. Proposed change for the EVM is for Constantinople. And five new opcodes will be, will be added to the Ethereum virtual machine. Shift left, shift right and arithmetic shift right.
00:45:39.038 - 00:45:53.462, Speaker A: I'm not sure about their semantics. There's some bit functions. Yeah. Cool. So that was actually what I consider the hardest part of the talk. And now it's going to be part. So let's talk about K.
00:45:53.462 - 00:46:37.114, Speaker A: What is K? K is a programming language to define the syntax and semantics of programming languages. Now, I don't say other programming languages because it can also define the syntax and semantics of itself. So there's two words there. The first one is syntax, and the second one is semantics. Syntax is how language looks, and semantics is what a language means. And in the previous version of the presentation I had like formal definitions of you, but then I realized I probably wouldn't have enough time, so I'm glad I dropped that out. So in k you have three different declarations.
00:46:37.114 - 00:47:57.718, Speaker A: Syntax for syntactic rules which are done using. That's what, that's what BNF stands for. For example, in this way, this says that this defines the syntax of two arithmetic operations called plus and times, and says that if you have two arithmetic expressions and you plus them together, you will also get an arithmetic expression. And we also say that times binds higher than plus and that it's. Yeah, I mean, the other type of declaration we can have is configuration, which actually defines the stores of the language using an XML notation. And finally, we can have semantic rules that rewrite terms in the various stores and actually form the whole point of what k is about. So for this presentation, I actually wrote a language in k to illustrate how k works, because I didn't find any that would be simple enough.
00:47:57.718 - 00:48:22.744, Speaker A: So I wrote my own. And it's just, it's a language that functions as a calculator. So here it is. So this is the language that functions as a calculator on integers. And it can do anything. It supports bracketing. So that is changing the order of computation.
00:48:22.744 - 00:48:40.130, Speaker A: And it supports just about everything that you might expect from the calculator, including negative and subtraction. I separated those two, so I'm not multiple execution paths.
00:48:40.282 - 00:48:42.106, Speaker C: So can you explain all those lines?
00:48:42.210 - 00:49:20.338, Speaker A: Yes, of course. So what we start here by saying that an arithmetic expression could be either an integer or it could be negative an integer, or it could be an another arithmetic expression. For example, five or minus three divided by another arithmetic expression. For example, ten or minus four. And similarly, we also define the syntax of divided times plus minus and grouping. And we give it order of preference using this. And then this.
00:49:20.338 - 00:50:06.184, Speaker A: Don't worry about it for now, actually. Don't worry about it at all. And so basically we want times n divided to bind tighter than plus and minus. And furthermore, we also have to define the semantics of these. What are these symbols? Plus and minus? What do they actually mean in our language? So we do that by saying whenever we have a variable I one minus a variable I two, it will always rewrite as I one minus int I two. And now your question is what is minus in? So it's a k built in operator on arithmetic integers.
00:50:06.804 - 00:50:09.460, Speaker B: Would you say it's like the opcode of k?
00:50:09.652 - 00:50:11.344, Speaker A: I would say exactly that.
00:50:13.244 - 00:50:14.724, Speaker B: I have a question about this.
00:50:14.804 - 00:50:18.692, Speaker A: Yes. How do you declare order of operations?
00:50:18.788 - 00:50:21.012, Speaker B: Or how is order of operations declared.
00:50:21.108 - 00:50:23.544, Speaker A: In this symbol right here?
00:50:24.844 - 00:50:28.184, Speaker B: Okay, how much opcodes does k have?
00:50:29.284 - 00:50:58.124, Speaker A: I don't know. I mean, they're not really opcodes. They're like built in stuff. And you can basically import more libraries to add more functionality. So it's like a regular programming language which allows for importing and exporting. But then basically you have to define, you have to map the opcodes of the language that you're verifying onto those native opcodes and opcodes. So that seems like something that's probably the dangerous.
00:50:58.124 - 00:51:49.388, Speaker A: Yes, you're absolutely right. There could be a bug in the way EVM is defined in kicking. So that's a valid like reservation. In fact, it's something that we'll never get over with software. There's always a possibility of a bug there. I think the difference of executing it in the EVM versus executing it in k is that in the EVM you can only do execution that is concrete, while KeVM gives rise to symbolic execution, which is what you want to do if you want to formally verify specification, which is what I'll talk about next time. Okay, I have seven more minutes left here.
00:51:49.516 - 00:52:51.954, Speaker B: Chart you an idea of what that means is concrete execution is of course your values for each variable you have value. And symbolic execution means more like assuming this variable can have any value, what is kind of, what is anything that, what are things that are in general possible. So you are trying to make very, very general statements about the program. You try to make statements about this program. No matter what the input is, no matter what the state is, no matter, no matter what happens, it will never reach the specific state. So step that we want to do is from the verification state, no matter what happens with the state, it will never reach a state where money is frozen forever. That's kind of a statement you trying to come up with primary education.
00:52:51.954 - 00:53:16.044, Speaker B: And again, the past is there is this k? Yeah, language description. And this language description is much easier to kind of create those proofs about those general statements. So the first step is to kind of map the EDM to K. And then if we have an automatic translation, then we can kind of try to.
00:53:16.744 - 00:53:18.324, Speaker C: Come up with those proofs.
00:53:18.784 - 00:53:52.252, Speaker A: You're absolutely right. So in other words, Kevm is an interpreter for the ethereum virtual machine in K. So I have six minutes left, so let's rush through this. Let's start with specifying the configuration of KDBM. So I kind of made it easy by separating out our opcodes into categories. So this gives rise. We'll definitely want some program counter.
00:53:52.252 - 00:54:48.462, Speaker A: We'll definitely want, by the way, this version that I've written here also includes the new opcodes which has delegate called. We also want the status code to know whether it's returned to something successful or something unsuccessful. We'll want a memory, will want some storage and given, and we'll want some block info. And given the fact that we have calls, we'll also want a call stack that will allow us to call other contracts and have the execution environment there be different than from the current one. And that's basically what it becomes. So this is kind of a naive implementation of VBM in K. It has, it has.
00:54:48.462 - 00:55:32.848, Speaker A: I'll go through this in 1 second. It has a status code, as we said. It has a call state, which has everything that you might need for the execution of an ethereum transaction, or I should say message call. You have a bunch of accounts that each have exactly as we said before, an address, balance code, storage and a nonce. And finally you have information about the blog and some random stuff that also has to be there. And the way we write the configuration is we always write what will it be initialized with? So most of the stuff gets initialized with zero, it's an integer. And in K, if you write dot, it means nothing.
00:55:32.848 - 00:55:58.312, Speaker A: So if you write dot map, it's an empty map. So this is, by the way, the configuration that we have here. It is a subset of the real k configuration. So if we were to write this in our K code, it would actually match the actual configuration. So it's not that far from the truth. It's a naive implementation, but it's still pretty good. This is the actual one.
00:55:58.312 - 00:56:38.406, Speaker A: So the reason the actual one is much more complicated is the KDVM is not only an execution, you can also use it as an actual evm node, which is what Cardano is doing with YLA. They are using KevM as an actual node for the Cardano blockchain. And for that you need a lot of other things in our implementation. Cool. So let's skip syntax to talk directly about semantics of KDBM. And I have a few minutes, so let's just go through it. Most of the time we don't want to be altering the configuration directly from the opcodes.
00:56:38.406 - 00:57:10.036, Speaker A: Instead we'll define helper functions that will begin with hash. This increases safety ness and modularity of our code. So let's start at the end. Let's start with ok, so when we get what define is this internal operation called dash fault. And when we get it, we want it to consume all further opcodes and help execution. And the way we do that is using this here. There are three things that you haven't seen yet.
00:57:10.036 - 00:57:45.294, Speaker A: Let's start with what you have seen rule is a semantic rule. K is a cell that this semantic rule will use. This is an internal upcode that we defined. And then this is what you haven't seen. So this is the k way of saying and then. So it's the quick k way of saying of giving time or order to operations. And then you also haven't seen this, which is everything else.
00:57:45.294 - 00:58:55.002, Speaker A: So if you have something like this, this will match every time there is a hulk on the top of the case, because it has to be on the top, and it doesn't matter what there is after it. And if that help is followed by this is the key way of saying anything of type opcode, then it will get rewritten to nothing. So in other words, it will consume all of the opcodes that are left of it, which is exactly what you would want, right? If you hold machine, well, you wouldn't want it to keep on computing stuff. So next we'll, we'll need something to be able to set the status code. So we'll define this internal code called NSC, which all it does is it holds, and it copies whatever we pass it into the status code. So now here's a question for you. Assuming a status code of, let's say, let's call it EVMC success, what should set it? And I'll give you a hint.
00:58:55.002 - 00:59:32.060, Speaker A: There's two options. Either the program finishes execution. That is, it runs through all of the bytecode, or it helps somewhere in the middle. And that's the answer as well. So either program is fully executed, I want to return successfully when we've reached the end of the bytecode, or we want to halt at a specific opcode, which opcodes should result in a successful help, do you think so? An example could be the stop opcode. All it does is halt execution. Everything was fine.
00:59:32.060 - 01:00:05.324, Speaker A: Another example could be the return opcode. Another example could be the self destruct opcode, and was the fourth one, in fact, I forgot. So let's have a look. Oh, actually those were the only three. So these are the only times in the game virtual machine where you would want to quit an execution successfully. Cool. And now I'll just give two examples very quick.
01:00:05.324 - 01:00:46.714, Speaker A: I think they'll both take 1 minute. And the first one is, how are we actually going to execute opcodes? So we're going to start with just one item in the case cell hash execute. And to give it some semantics, we're going to give it. By the way, I didn't think of this, but I think it's pretty cool. We're going to give it two semantic rules. The first one, it says that whenever this occurs to the left of it, nothing will get written to next. So what is the imperative meaning of this? This means that execute will keep putting next in front of it.
01:00:46.714 - 01:01:15.844, Speaker A: You'll put it there, and once next gets executed, we'll put another one. Once that gets executed, another one it will forever. That's its own job. It will put next to it. If there's nothing next to it. And in order for it to halt at some point, we also say that, well, if there is a halt and then there is an execute, well then the finally the execute disappears. Does that make sense? I think it's fairly snuggled, but I realized that in quite an intensive day.
01:01:15.844 - 01:01:38.948, Speaker A: So now I just want to give one example. But maybe I'll do it next time. Do you guys want to see it? Okay, so two minutes and 20 minutes, I think. Yeah, I mean I can do it next time. It's not a problem.
01:01:39.116 - 01:01:41.504, Speaker B: I think Ben and I want.
01:01:42.444 - 01:01:43.212, Speaker C: That's good.
01:01:43.308 - 01:01:45.900, Speaker B: Good with the towels at.
01:01:46.052 - 01:01:59.584, Speaker A: So I mean it's not very long. It's literally like. I can show you. It's like four slides. Let's do it.
01:01:59.624 - 01:02:00.324, Speaker B: Come on.
01:02:00.704 - 01:02:32.574, Speaker A: Okay, so basically we just defined the semantics of execute, but I also wanted to define the semantics of next. So that's going to be a little bit more complicated. What should next do? What should, what should the actual execution of an Ethereum up would be? And if we were to think about it really hard like the cave people did, this guy called Everett, and he'll be at DEFCoN as well. He thought of all this. So we can. Props. So what it should do is it should first check whether the opcode can be executed.
01:02:32.574 - 01:02:37.170, Speaker A: Next it should execute it. And next it should increment the program counter.
01:02:37.322 - 01:02:37.610, Speaker B: Right.
01:02:37.642 - 01:03:26.042, Speaker A: It's very basic expectation we would want execution of Ethereum opcodes to be like, whether it can be executed should say whether it's a valid opcode, whether our stack is large enough for the opcode and don't worry about this. And then finally it should pull the arguments from the word stack and actually put them next to the opcode. I think they should have had a different name than this one because it has, it has the same name, but they're different functions. But I think there's rooms for many improvements in KVM. And finally we should deduct gas and then actually execute the outcome. Gas is collected before the output is executed. So that was the semantics of next.
01:03:26.042 - 01:04:01.096, Speaker A: Now let's apply that. Everything we learned today to learn about to try to figure out the semantics of an actual cool opcode on the Ethereum virtual machine. So which one should we pick? So actually we're going to pick the hardest one and that's Co. Let's have a look. So how are we going to structure the semantics of the call out code? So this is the actual code. I just wanted to give you a taste of what it looks like, but we'll break it down. So this is actually not that important.
01:04:01.096 - 01:04:20.864, Speaker A: It's just how it actually looks like in code. As you can see, it's quite readable. It's much more readable than reading the go implementation. The go code. If you actually want to learn about DBM, you can either learn that you can either read the client code or you can read this. And this is much more readable. But let's break it down even further.
01:04:20.864 - 01:04:50.914, Speaker A: If we have a call, and by the way, this already assumes that we have the arguments in front of it, so we've already executed. Next, we put everything there. Then we want to do just three things. We want to check whether the call can be executed. We want to call it and then we want to return whatever answer we get. This checks the call depth and the balance is large enough. This checks whether the contract is not a pre compiled one that we're calling.
01:04:50.914 - 01:05:48.804, Speaker A: And one more thing that I forgot. And then we push the call state and we transfer whatever funds that we want to transfer and we make the call. Now, what does it mean to make the call? It means to initiate the virtual machine. So to null it, to call execute. Now we're going to use what we just learned, and we already know that execute will keep on putting next in front of it until it will receive a halt. So I'm already assuming that the execution, execution basically takes steps in this little space right here. So once we've executed all the opcodes and we finally reach the halt, then what should a halt and a return do? Now? Just one last complicated thing I'm going to say on the entire talk.
01:05:48.804 - 01:06:23.056, Speaker A: So the only problem we have right now is we, we specified halt over here, but we said that health should always. Okay, what did I want to say? So how. And yes, so we. Yes, okay, so we said that how should. Oh, it's because I didn't include the code here.
01:06:23.080 - 01:06:23.296, Speaker B: Okay.
01:06:23.320 - 01:07:11.994, Speaker A: That's why I can't find it. So I thought it was there, the one where the actual semantics of halt, do we have that? Oh, here it is. Okay, so we said that what halt does is it will consume any single opcode that is in the back of it. But if we have halt and return, we don't want it to consume stuff, we want it to actually do something. And that's where like K sorts come in. So we're going to declare return as a different sort than this. So this rule will only apply if this is an opcode which also includes KVM internal operations, but it will not apply when we have something like this.
01:07:11.994 - 01:07:56.614, Speaker A: And that's why this we can give it, we can give it different semantics. And in particular what we'll give it is we'll drop the execution environment that we're in, we'll push one. This was added in one of the hard forks. And basically that signifies that the transaction was successful, because revert now doesn't consume all the gas. So it's not enough to say whether the transaction ran out of gas to know whether it was successful or not. And finally we give a refund for whatever gas was not spent. And this is the most important thing of it all at the end is that whatever was returned from the call, we put it to local memory.
01:07:56.614 - 01:08:49.997, Speaker A: And that is the entire semantics of a call operation, from it being in the case cell to actually putting the return value back into memory of whichever account called that contract. So that was the example I wanted to show you. And that also concludes the presentation. So thank you very much. How far? Yeah, so that's a really good question. And so I was working on the formal replication of the GNO token and I thought I had verified it, but it's like this mathematical flaw in my argument that I made basically to reduce it to one sentence. The GMO was constructed with 10 million tokens.
01:08:49.997 - 01:09:34.285, Speaker A: And for that reason there is actually no overflow protection in the genome token. And that kind of messes with the K implementation of ERC 20. So I assume that there will always be 10 million tokens in my proof, but that might not be the case. I didn't prove it. So basically now I have to prove that there will always be exactly 10 million tokens ever available and therefore no workflow can ever happen, which I don't know I'm going to do. It's a pretty hard thing, but you can always, like if you don't know something to do with, with formally, then you can, you can provide a pen and pencil proof mathematical one that is much easier to construct than executable. But I'll talk about all the formal education next time.
01:09:34.285 - 01:09:52.773, Speaker A: That's why I wanted to divide it into two presentations, so that like you'll see exactly what I'm working on, the symbol of execution, these writing specifications. And we'll build on all of this that we learned. Any other questions?
01:09:54.153 - 01:10:36.654, Speaker C: Just one comment to the precompiles with opcodes. Yes, so one simple reason why they use pre compiled is because obviously there's very limited amount of opcodes, but you can have almost an arbitrary number of precompiles, arbitrary number addresses that you can use. Yeah, I think that was the main reason. And because you want to use upcodes only for things where you know they will be frequently used. And the op, like the pre compiled they introduced, they were not sure if that's actually important. So they knew like Shafi will be super important. They didn't know this about SHA 256, so they made this one pre compile.
01:10:37.834 - 01:10:39.634, Speaker A: Yeah, I think that makes total sense. Yeah.
01:10:39.714 - 01:10:41.162, Speaker C: And it's a little bit more expensive.
01:10:41.218 - 01:10:42.562, Speaker B: To use a pre compiler because you.
01:10:42.578 - 01:10:48.414, Speaker C: Have to regular overhead that you have when you take other contracts. But yeah.
01:10:54.554 - 01:10:56.138, Speaker B: To do the actual chart.
01:10:56.266 - 01:11:37.564, Speaker C: Oh, so for chart three, the SEO code for SHA 256, they are not using like Ethereum then Ethereum of codes to operate this. It's just that you need to access this, you compile, make call to this contract instead of just placing the opcode into the bytecode. And so if you use SHA 256 or EC recover in a smart contract, then what you will do, it will actually call the precompiler instead of having like an opcode or ecover or something.
01:11:38.184 - 01:11:42.264, Speaker B: You can also attend that we compile contracts.
01:11:43.084 - 01:11:45.292, Speaker A: You don't need a specific implementation in.
01:11:45.308 - 01:11:48.584, Speaker B: The balance because it's providing by code.
01:11:52.564 - 01:12:01.544, Speaker C: I don't know, I don't think that's okay. It's like not in, it's not in, not necessarily in an EVM bytecode then. Can we imagine anything?
01:12:03.004 - 01:12:04.692, Speaker A: Yeah, but imagine that you have a.
01:12:04.708 - 01:12:10.702, Speaker B: New client, the pre compiled contract. There is a byte code for that pre compiled contract, right?
01:12:10.838 - 01:12:11.086, Speaker A: Yeah.
01:12:11.110 - 01:12:13.958, Speaker C: You can truly just use this, but you could also have.
01:12:14.046 - 01:12:15.790, Speaker A: Yeah, of course the client can decide.
01:12:15.822 - 01:12:25.594, Speaker B: To implement their own pressure, but you have a hard work and you don't have resources to do it. And you have a client, you don't need to implement it, you just need to seek it.
01:12:27.654 - 01:12:30.526, Speaker A: Also if you don't can ensure that.
01:12:30.550 - 01:12:32.234, Speaker B: Your implementation is safe.
01:12:34.904 - 01:12:43.216, Speaker C: I think precompiles, actually I would have to look into that, but I think they are implemented in native client language.
01:12:43.320 - 01:13:19.242, Speaker A: Yeah. For example, as you mentioned, you can also run KeVM as a node on the Ethereum network. And here is the actual semantics of the pre compiled contracts in K. So for example shab 256, all it does once it's called, it immediately halts. And whatever is passed to it, it will just call SHA 256 on it, where Sha six is an internal k function. So K has Java and Ocaml and Haskell backends. And I'm guessing shout two visa could be implemented in one of those backends.
01:13:19.242 - 01:13:38.654, Speaker A: But you're also right I mean, it could also be the case that they will use a pre created by code as c. It could be one of. Yeah, both options are fine. Cool. So thank you very much. And where's the.
