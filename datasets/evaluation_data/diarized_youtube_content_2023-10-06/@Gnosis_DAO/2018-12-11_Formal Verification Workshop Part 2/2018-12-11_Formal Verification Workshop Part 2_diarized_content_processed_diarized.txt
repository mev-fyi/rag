00:00:01.360 - 00:00:39.814, Speaker A: So first of all, thank you very much for attending this workshop. I hope you guys will enjoy it as much as I will and learn as much as I will. So let's get started. So we're going to start with a recap of what we did last time. Ouch. That's a bit annoying. Let me fix this by running the presentation, okay? Let me first just try refreshing.
00:00:39.814 - 00:01:43.672, Speaker A: And if that doesn't work, which it didn't, let me just run the presentation locally and I'll fix it later on so you guys can see the the entire presentation online later on as well. So last time we talked about these bottom three in the dependency graph for understanding from verification. So just a very quick recap. The Ethereum virtual machine is the execution environment for Ethereum transactions. There are 140 opcodes currently that actually includes Constantinople. So in a few months there will be that many. But really there are only about 75 because log swap and dupe, as well as push have multiple versions depending on how many bytes they take in.
00:01:43.672 - 00:03:03.344, Speaker A: As an argument, we also discussed the k language, which is used to define programming languages and virtual machines in a rigorous, executable manner. To define language in k, you define its syntax using the word syntax, its semantics in terms of rewrite rules using the keyword rule, as well as its configuration using the keyword configuration. Finally, we put those two things together and we got Kevm. Kevm is the Ethereum virtual machine defined in K. And just a very high level overview, the configuration of KVM comprises pretty much of these following categories. The call state, which includes all temporary stores that are specific to the execution of the current contract, such as the stack, the memory, the program counter, the message sender, the call data, the gas, you get the point. And obviously there can be, well, not obviously, but there can be multiple call states.
00:03:03.344 - 00:04:39.768, Speaker A: If you are calling another contract, then there are also accounts which comprise the accounts that are available for you in the network. Each account is composed of its address, its code, which is zero for external accounts and non zero for contracts, its storage, which is also zero for external accounts and non zero for contracts potentially, as well as its balance nonce, and I'm pretty sure I forgot one of them, the address, the storage, the balance, the nonce, and probably one more thing. And finally, we also have access to a bunch of blog information, such as the difficulty, the Coinbase, the state route, the logs bloom, the mix hash, and on and on. So these are really the three big categories of the KEVM configuration. Today we're going to discuss the remaining four topics. So we're going to start with symbolic execution in c three, and finally get to case specifications and EDSL and how to actually write k in the real world. So let's start with symbolic execution.
00:04:39.768 - 00:05:55.464, Speaker A: Or I also wanted to say, and then once we put those four together, we'll be able to understand formal verification. And so another way, the goal of this talk is to understand how k works behind the scenes, as well as to see how k is used in practice. So let's start with symbolic execution. A program can be executed concretely with specific arguments, or symbolically, where the arguments are treated as symbols, which is just a fancy way of saying variable. So during symbolic execution, we execute the program symbolically, and yeah, we execute the program, or I should say the control flow graph of the program would be a more specific way of saying that. And branching can occur as a result of this add conditional statements such as if, while, and so on, but it can also occur elsewhere. For example, consider the EVM opcode add, or equivalently the high level solidity operator plus.
00:05:55.464 - 00:07:31.974, Speaker A: If both of the arguments ab are unconstrained EVM words, then the image or the output of the function can either be a plus b or a plus b minus two to the 256 in the case of overflow. So in that case, branching will occur during symbolic execution. And for example, for the opcode x, which does exponentiation, you can probably think that there will be an absolutely enormous amount of possibilities, and this is called path explosion. A path condition are the constraints that make the path feasible, that is, reachable. Updating the path condition is equivalent to branching, if you think about it, because the only time you can branch is when there are several possibilities, and each of those possibilities will have an updated path condition, and vice versa. The only time you can update the path condition is if there was some kind of division necessary of the set of inputs that currently comprise the path condition. And the solution to the path condition will therefore be a test input for that path.
00:07:31.974 - 00:08:37.634, Speaker A: So k framework uses symbolic execution to prove program correctness, but how does it actually prove it? So that's where z three comes in. So z three is a software built by Microsoft Research that to my knowledge, from what I've seen so far, every single EVM from verification tool uses for proving. So let's first take a step back and talk about the SAT problem. In theoretical computer science, the SAT problem is the problem of satisfiability of boolean formulas. For example, does there exist an interpretation that is a truth assignment for variables a, b, and C, such that not a or b and c is true. So actually think about it. But let me think about it right now.
00:08:37.634 - 00:10:38.574, Speaker A: Is the answer yes or no? The answer is yes because you can make a false or you can make b and c true. And the side problem is known to be mp complete, which was proved in the Cook Levin theorem. If you want a solution to a SAT problem, we use a SAT solver, which therefore runs in hyperpolynomial time. A SAT solver takes as an input conjunctive normal form boolean expression, which is just a boolean expression, that is a conjunction, that is an and of a number of clauses where each clause is either literal, not literal, or a disjunction that is an or operator of other literals or not literals. So the SAT solver takes as an input a CNF Boolean expression, and it outputs either a solution or it proves that it's unsatisfiable and does this just by brute forcing it. And the reason we use a conjunctive normal form conjunction of clauses that are each themselves disjunction is because it better corresponds to most use cases, for example, in our case path conditions, and also because there exists a polynomial time reduction from SAT to what's called three SAT, which was proved by by a guy called Karp. And three SAT is essentially the SAT problem, where each of the conjunctions has at most three literals or not a literal.
00:10:38.574 - 00:11:34.434, Speaker A: You guys know what I mean by not a literal, right? The logical naomi and then a literal. The fun fact here is that disjunctive normal form can actually be solved in polynomial time. So then that begs the question, why don't we use the DNF instead? And apart from the fact that it doesn't correspond to most of the use cases, it's that the main reason is that no algorithm actually exists to transform an arbitrary boolean formula to disjunctive normal form. And in most of the stuff that we discussed in the last two slides, finding such an algorithm would actually imply p is equal to np. So it's very likely that we'll never find it. Cool. So for form verification, we need more expressiveness than just boolean formulas.
00:11:34.434 - 00:12:43.384, Speaker A: So we use SMT solvers. An SMT solver stands for satisfiability modulo theories. Here, theory has its mathematical meaning, an axiomatic system, for example, integer arithmetic. And again, the solver output either a solution to the problem or after it brute forces them all, it will output unsat for unsatisfiable. So how do we prove properties over a set of integers. For example, let x be even prove that x squared is always divisible by four. So we can feed the variable, in this case x the constraint, in this case its parity, and the equation in this case x squared is not congruent to zero mod four into an SMT solver.
00:12:43.384 - 00:13:45.754, Speaker A: And if it outputs unsat, we actually so if it outputs unsat, it means that the negation of we want to prove is unsatisfiable. And that's just another way of saying that the condition you want to prove is always satisfied. So in that case, we proved the property. Finally, z three is just an instantiation of an SMT solver. Now by the way, off topic, if you guys want to know more about how SMT solvers actually work, there is a very good answer on Quora. I know Quora doesn't tend to be the go to place for deep tech, but this answer is actually very good. It's about two a four pages, and I can send it to you later on to get a high level overview of how SMT solvers work.
00:13:45.754 - 00:14:34.744, Speaker A: It's a little intermezzo between the two parts. High level k executes your program, symbolically branching if necessary. At some point, z three will try to prove the post condition. If it can do so. For all paths, the spec is proved. If at least one path has an irreducible term, it terminates and the spec is not proved. So essentially, form notification is formal specification, which is done manually, plus a formal proof which is automated.
00:14:34.744 - 00:16:07.104, Speaker A: So in this section, we'll connect what we've discussed to how to actually use k. A case specification usually involves exactly one spec rule. Unlike semantic rules, which specify rewrite rules, it specifies what we want to prove, in particular a precondition which comprises of the initial contents of the configuration cells. And that depends on the language you're working with working in, in this case the EVM, or more specifically KeVM, and also the post conditions, which are the desired contents of the configuration cells after the execution. And the precondition and post condition are separated by actually the rewrite sign in k, which I understand. It can be confusing because we use the same symbol for both defining programming languages and virtual machines, and also for writing specifications, and those two are very different. In some way, you could think of them as opposites, because the semantic rules are we assume, and the spec rules are what we want to prove.
00:16:07.104 - 00:17:07.302, Speaker A: But that's just the notation that we got to deal with. The pre and post conditions can also be constrained using the keywords requires for preconditions and ensures for post conditions. And together the pre and post conditions, when used for program correctness, express the intended behavior of the contract. So this has all been pretty theoretical. So let's dive into an example. Let's say we have a super simple language imp for a super simple imperative language that has a configuration comprising of two cells. The k cell holds the program that is executing and state is a map.
00:17:07.302 - 00:17:54.810, Speaker A: It's initialized with an empty map. Dot in k means empty, and then you write what type it is. So this is an empty map. And then in the future it can potentially hold values for our variables. So in this super simple imperative language, by the way, we haven't defined the language, we just defined its configuration. But let's assume you can imagine the rest. Then a possible case specification would be the program y is equal to x and after execution it will disappear because it's been executed.
00:17:54.810 - 00:18:52.690, Speaker A: We take the lines of code as they're being executed from the k cell, and most importantly the state. It will be initialized with the variable x, which has some value we call x value, and afterwards it will end with y having that same value. And a really cool thing about k is that we can also put in this little symbol right here, which actually, wait, let me try to. This little symbol right here. I can't. Okay, which in k means an anonymous variable. Anything, anything will match this variable, and it's of type map.
00:18:52.690 - 00:19:58.854, Speaker A: So essentially what this left hand side of the spec rule says is that the state will be initialized with x having some value. By the way, we put no constraints on it. So these are fully unbounded integers actually, and then there can be anything else in the map. So that's the key point here is that we will be doing the full notification symbolically over all possible initial states of the program. So that's really important, but also really really cool. And the same exact thing for the right hand side, we say that y must get this x value, but we don't care about what will happen to anything else apart from y. So, you know, probably nothing else will happen.
00:19:58.854 - 00:21:14.124, Speaker A: But basically this allows us to decrease our troubles to prove only what is important and not care about the rest. So we'll see that later on in the presentation for specifications for EVM functions. So we can also include constraints on our variables. So consider this other very simple in program Y is xmod two, and what do we want to prove happens to this after this program is executed? So the precondition will be that the program comprises of this line of code and that x has some value x value. And the post condition will be that this line of code has been executed. So we have, remember, dot is empty in k. And let's see if I did it right.
00:21:14.124 - 00:22:22.004, Speaker A: Yes, and y will have the value zero. And the reason for that is we will assume that x value is even. So the point that I'm trying to make here is that we would also have to have another specification for odd x's, because every single specification tests one case, a function. So I just wanted to illustrate that you can also constrain your preconditions here. I constrained my initial value for x, but then it's often the case that you need to write multiple specifications in order to cover all the cases. Fun fact, right now there is no automated way to prove that you actually covered all of the cases. So this is again a deeply manual thing.
00:22:22.004 - 00:23:13.598, Speaker A: And if you make a mistake in that, if you don't cover all of the possible cases in your various specifications, you will not prove program correctness. Very important. Okay, let's go a little bit deeper. So what are the different possibilities in one cell, the most popular are either static spec rules. By the way, I made this word up, static spec rule, but I think after I explained it, you will see why it makes a lot of sense. So, static spec rules are ones that don't contain the rewrite symbol. In other words, the precondition has to equal the postcondition.
00:23:13.598 - 00:23:55.534, Speaker A: So let's take a look. So examples of that are you can have, you can have, essentially, you can have three possibilities here. You can have a value type. So an example of that is, is the call data. So the call data for a function, it should remain constant throughout the entire execution of the contract. Another example would be the code for an account that shouldn't change. In fact, that can't change.
00:23:55.534 - 00:24:46.734, Speaker A: The code of a contract can never change. In ethereum here, I obviously emitted the actual code, but this would be zero x six for fc blah blah blah. Another example would be specifying a call value of zero, when, for example, we want to test the success case, the positive case for a payable function. A payable function is one that cannot accept the call value. Another example would be where we want to specify a mode for the execution, which is essentially the EVM version that we want to use. So in this case, we're using the latest version. You can also put anonymous variables.
00:24:46.734 - 00:25:48.084, Speaker A: What that means is that we actually don't care what is in that cell, we just care that it's constant. So for example, the gas price, that actually doesn't have an effect once the execution has started. And then some network information such as the hash of the last 256 blocks, balance of an account, say, and so on. Finally, we can also name the variables, so we keep them as symbolic, but we give them names. So an example of that would be naming the call value. So this would be in a failure case, in the negative case for a payable function. The reason we name variables is oftentimes to, precisely to put constraints on them.
00:25:48.084 - 00:26:43.374, Speaker A: So we can call this call value, and then we could say requires call value be greater than zero. And what that would do is that would test the negative failure case for a payable function. Then we would say that we want execution to end with revert, for example. This would be the precondition and actually also the post condition for this particular cell. Another example would be, would be the message sender, because we want to constrain it. We always want to constrain this. And the reason is that if we don't, it will end up being an unbounded integer, but we want it to be between zero and two to the 256, sorry, two to the 160 as an integer.
00:26:43.374 - 00:27:44.824, Speaker A: The most popular or the most interesting spec rules are dynamic ones. So for example in the casel, oh by the way, I should mention, remember how in, we put the entire program in the k cell, in kevm it works differently. The program will go into a cell called program, and then the k cell holds what you might call the internal opcodes of the evm of KVM. So in this case we want execution to begin with the internal opcode execute, and we want it to end with a halt. The program doesn't loop forever. And. Yeah, so that's, that's one example.
00:27:44.824 - 00:28:41.058, Speaker A: So this, this example is where we have a value type as a precondition and another value type as a postcondition. We could also have an anonymous variable as a precondition and a value type as a postcondition. An example of that would be output. Usually this is the way it's written. This in particular is the output spec for the transfer function in ERC 20, the success case. So we don't care what there was before, but we always want to return a value of one, because that's what some ERC 20 functions return in the success case. But we could also have a value type as a precondition and an anonymous variable as a postcondition.
00:28:41.058 - 00:29:52.384, Speaker A: This is very, very frequent. Examples include the program counter. We wanted to, we set it to begin at zero so that we actually execute the program from the beginning, not from the middle, but we don't really care what it ends up being, that's not part of our specification. We care more about the output, the storage, modifications, etcetera. Another example would be the word stack memory and many others where these transient non permanent stores such as the stack, the memory, and so on, that would disappear once the call is ended. Another one could be gas, because again, unless you're doing some kind of fancy gas analysis, we don't care what the gas ends up being afterwards. I should note that if it ever goes to zero or below zero, we will get an exception out of gas exception.
00:29:52.384 - 00:30:38.366, Speaker A: So that is already handled as part of the semantics of Kevm. Cool. So now let's put everything that has been talked about together, and you can have this beautiful contents. This is the contents of cell called storage for an account for specifically contract. And here we're going to say the hashed location of the storage slot for this particular variable should. And here's the precondition. Right? So here's a map.
00:30:38.366 - 00:31:43.194, Speaker A: This is a map. So it maps the storage slot to some value, and here's the value. And inside the value we see a spec rule, right, a pre and post condition separation. So it will begin with some value that we name as balance from, and it will end up with the same value minus the variable value. And you can see that the second line does pretty much the same thing, except with different symbols. So can you guys think of what function this corresponds to? So I should say that that value is passed into the function in the call data, and so is to id.
00:31:45.534 - 00:31:47.070, Speaker B: Probably transfer, right?
00:31:47.222 - 00:32:17.654, Speaker A: Yes, thank you. This will be the transfer function. Exactly. And one more really cool thing is I said that we name variables to put constraints on them. That's true, but as we can see, we also name variables to use them somewhere else in our specification. So I should have said that that's another possible use case of naming the variables, not keeping them anonymous. Cool.
00:32:17.654 - 00:33:17.784, Speaker A: And as before, we don't care at all about the rest of the storage. In other words, the rest of the storage can be whatever it wants initially and cannot change. So that brings modularity to the transfer function. The transfer function can only change these two storage slots and in this very specific way. Cool. So also I should mention that as I said, we have one spec rule for one case of a function. For very simple functions like ERC 20 functions, we usually have about, from experience about two success cases and about three failure cases.
00:33:17.784 - 00:34:18.373, Speaker A: But if we were specifying a very complex function such as one among the core functions, the dutch exchange, it's very likely that there would be maybe eleven failure cases. And the reason for that is that the number of failure cases grows with the number of asserts or requires in your code. Or equivalently the number of conditional reverts in the bytecode. Cool. So now that we've seen fragments of it, here's actually the full specification of transfer success one. So first of all, what is transfer success one? So transfer has two success cases. One is where you're transferring to yourself, and the other one is where you're transferring to a different address.
00:34:18.373 - 00:35:16.064, Speaker A: So in solidity or on the EVM level, those are not distinguished. But by the way the k matching algorithm works, we have to distinguish them. And from what I know, all form verification tools have to distinguish these two cases. It's common pattern among formal verification tools. So here it goes. We have the full eVM specification configuration as we saw it last time, one month ago, but this time we actually have the preconditions and post conditions specified in every single cell. By the way, I have again omitted the code from here, here and in the network section.
00:35:16.064 - 00:36:00.428, Speaker A: And the reason for that is that would take up a lot of space. So this is it pretty much. This is our case specification, the manual part that we have to write. And once we get that, K will do its proving pretty much, I was going to say fully, but pretty much is a more accurate word, automatically. We can also see fragments of the examples that we saw before. So everything that I gave in the previous three slides as examples, it's all over here. So I wasn't confusing you guys.
00:36:00.428 - 00:36:41.834, Speaker A: So for example, right over here, we have the storage specification, as Adam mentioned. Cool. Oh yeah. And we also have a bunch of require statements that, as we discussed, constrain our preconditions. So for example, we want all of the addresses that we use in the specification to be valid EVM addresses. Oops. Whoa.
00:36:41.834 - 00:38:19.994, Speaker A: Additionally, we want the call depth not to exceed 1023, because the call depth in the EVM is at most 1023. So if we set the call depth to be 1024, it would throw an exception immediately, even before it executed the very first opcode. And we also have to set bounds for the values that we are either passing in as call data or naming as part of the initial contents of storage. Because both the call data that we're passing in and the initial content of storage, they're EVM words. And so we have to tell K that. And what distinguishes this case from the other cases for transfer is that we are not transferring to ourselves, that the amount we are transferring doesn't exceed how much we own, and additionally that the value that will get transferred to the different person will not overflow. So these are, these are, these three assumptions are very important because they distinguish this particular spec from the four other ones for the same function.
00:38:19.994 - 00:39:47.284, Speaker A: Okay, so that was quite a lot of content already, but now we're going to go into the practical stuff. So essentially, I've cheated a little. Not everything that you saw above were actual eVM semantic rules. To make life easier for ourselves, we usually write specifications in EDSL. So EDSL stands for ethereum domain specific language, and it is used to make it easier to write common patterns which are derived either from solidity or from the application binary interface standard. So in particular, there's actually just three, and those are for some reason it didn't put it on a new line. But the first one is this one ABI cull data.
00:39:47.284 - 00:41:10.298, Speaker A: The second one is this one ABI event log, and the third one is hash location. So as you can probably see, if we didn't have access to this beautiful function, we would actually have to specify the call data in the Oops here in the specification rule as a bunch of bytes. But that is very unreadable and not very easy to work with. So instead we specify the call data as a function, and it will abi encode the parameters. So in other words, it will take the regular ABI process, it will take the hash of the signature, it will take the four bytes of that, and finally it will, it will, yes, it will make two id, it will pad it to 32 bytes and similarly for value, and it will concatenate it together and put it in our call data cell. Cool. Another one is events.
00:41:10.298 - 00:42:32.884, Speaker A: We use that here as well, because part of the strong requirement on ERC 20 is that the contract fires off an event when transfer has been executed successfully. So we are using that right over here, so we don't have to go to low level details. And finally, we are also using that right over here. So this is actually going to be equal to the, yes, it's going to be equal to the hash of the argument, comma, the story slot. So the hash of this comma zero is actually going to be the storage location for a mapping value of two id. But since we don't want to deal with that, we just write hash location. So EdSL, it makes it easier to write common patterns.
00:42:32.884 - 00:43:28.604, Speaker A: But not only that, it also allows us to use EDSL templates. So here I didn't think I could do a better job than the official k documentation. EVM specifications are written over the full KevM configuration. However, a large part of the configuration can be shared across specifications. EDSL allows capturing such common portions in the form of a template specification that can then be instantiated for each specification. So to use k, we, number one need a spec template, which will be a k file. And here's an example of the spec template for GnO ERC 20.
00:43:28.604 - 00:43:54.104, Speaker A: For the GNO token, the spec template is composed of three things, rules that are the same across all the different specifications, that is, all the different functions and all their cases. It's composed of function specific parameters.
00:43:58.364 - 00:43:58.652, Speaker B: And.
00:43:58.668 - 00:44:36.044, Speaker A: It'S also composed of program specific parameters. I think that's this one, because we always assume gas is 100,000 for gnoer C 20. Even better examples would be let's look at some good examples code. So for the entire program, we want the code to be the same. So that's a program specific parameter. And let's look at the bottom. Actually, let's go through it in order.
00:44:36.044 - 00:45:19.764, Speaker A: So k, we actually want this to always be the same. So technically it's a, it's a program specific variable, because we just write execute leads to halt output. This is function specific status code. This is even case specific. So it's technically function specific code, as we said, is program specific. So function general call data and call value are both function specific. And yeah, I mean, you kind of get the idea.
00:45:19.764 - 00:46:22.314, Speaker A: So we need a spec template. We also need the function and program parameter file. So the reason this is so interesting is this is actually the file that we are working with 99% of the time while doing from verification. So this file contains all of the functions and all of the cases that we want to verify. So for shortness, I just put two or three functions here. Three, I have total supply, I have balance of, and finally I have a favorite transfer, and it works as a regular any file. So I don't think there's much to say about it.
00:46:22.314 - 00:46:57.104, Speaker A: This route is, will get inherited from every single class. This defines what is generically true across all total supply cases. This defines the total supply case. This defines the total supply failure case. Same for balance and balance off. And finally for transfer, we also have subclasses for success because there is more than one of them. And finally we also have subclasses for failure.
00:46:57.104 - 00:47:57.614, Speaker A: And let's look at just one of them to see how it actually works. So here. So transfer what is true across all transfer cases? Well, definitely the call data, because the call data actually specifies that we're calling transfer. What is true across all transfer success cases? Well, we don't revert and it returns one and it should fire off an event. And since it's a non payable function, the call value has to be zero. And finally we have, when we're transferring to somebody else and when we're transferring to ourselves. What's true for all failure cases? Well, they don't produce log.
00:47:57.614 - 00:48:45.864, Speaker A: One of them reverts. When do we get revert? Let's have a look. When value when we are trying to give the other person more than we have. When do we get another revert? When we are trying to give ourselves more than we have. Right. And when we get an invalid instruction, when the call value exceeds zero. So when we are transferring ether to a non payable transfer function and finally we have the program generic variables or parameters.
00:48:45.864 - 00:49:52.276, Speaker A: Here we're using solidity as a compiler. The only reason this is important is to make our life easier for finding the storage locations for storage variables. That's the only time we use compiler, as far as I remember. We also need to specify the storage positions of variables that we want to use, such as balances, which is a mapping from address to un. And finally the code and the gas will always be the same. I truncated this for simplicity, but we already talked about both of them. So, everyone awake? How do we actually use k? So you start by generating all of the spec files from the any file together with the spec template.
00:49:52.276 - 00:50:34.004, Speaker A: Or let's see what I wrote. I wrote spec template plus template parameter. Any file generates k specification files and once you have generated all the k specification files, you run kprove. You run it in the following way. You run, you say kprove, then you say the spec that you want to run. Actually this should have spec k typo. Then you say where your language definition is located, and finally you say which.
00:50:34.004 - 00:51:21.814, Speaker A: Or actually I think this is where k is located. And then you say where kevm is located. So you pass in the kevm and k tools. K currently has a java backend for symbolic execution, so that's the one I'm using. Okay, so if a spec cannot be proved, we get some information. In particular, we get a bunch of steps. Now each step is a k rewrite rule.
00:51:21.814 - 00:52:16.054, Speaker A: Usually about 15 steps correspond to one EVM opcode execution for simple opcodes the reason for this is that as we saw in the previous presentation, there are a bunch of internal opcodes that EVM uses. So for example, at each opcode it will use the following internal opcodes next to actually load the next opcode. Exceptional to check whether it's an exceptional opcode. Invalid check whether it's an invalid opcode stack needed to check whether it requires more stack than we currently have. It will check whether it's a static opcode. And if we are doing a static call, then it needs to revert. Right.
00:52:16.054 - 00:53:37.748, Speaker A: You can't do non static opcodes during a static call. Then it needs to subtract the gas, which for complex opcodes can require a few dozen internal opcodes because you might have to subtract gas for the memory being used, the storage being used, etcetera, and for the actual opcode as well. And finally it executes the opcode and then also it has to increment the program counter. So there's a bunch of things that go to just one single opcode execution. Evm opcode execution. Cool, so what was I going to say? How do you actually debug k outputs? So you run k proof with options like log logcells, debug z three, etcetera. And it very often times generates a file of several hundreds of thousands of lines, even millions of lines in a couple of minutes.
00:53:37.748 - 00:54:17.592, Speaker A: Or a couple of dozen minutes. Yeah, that could improve. And then you have to find the problem. So the problem is, in my limited current experience, usually an irreduced term is the cause of a failed spec. So then you need to figure out what happened. Either your spec is not correct, in which case you have to fix the spec, your spec is correct, and k just needs a little human help. That's why I say it's not 100% automated.
00:54:17.592 - 00:55:57.754, Speaker A: There are times when case struggles and then you help it by writing a lemma or in a rare case, but the most important case, your code is not correct. You have just discovered a security vulnerability. And that's the whole point for why we do formal verification. So to make running proofs in bulk and debugging easier, I've written a script that does that. And yeah, it's pretty simple and we'll see it in the demo, which is right now. So I'm going to show you a demo. Okay, so we are going to prove that is firmly verify our favorite function, which throughout this talk has been transfer.
00:55:57.754 - 00:56:43.834, Speaker A: In particular the first success case. So here. So let's do that. So let's start by cding into the GNO directory. Finally, let's make the specification files from the spec template and the template parameter file. By the way, the contents of these two files are exactly as you have seen in the presentation. So there is nothing tricky going on here.
00:56:43.834 - 00:57:14.704, Speaker A: Bam. So if everything went correct, we got a new folder called specs. And in that we got a new folder called GnO. And here we have listwear functions. And for each function, a list of the cases, and for each case, an actual k specification rule. So quite ironically, I clicked on the one that will be verifying. So that's pretty cool.
00:57:14.704 - 00:58:01.384, Speaker A: Now let's actually run it. So to do that, I'm going to go back and I'm going to use my script, and I'm going to say I want to run files from the directory Gno. And I'm going to say that I wanted to output it in a DEC directory called Gno one because I can make a mistake. And in that case, we want to have two and three available. And finally, if I leave this open now, it will start verifying every single spec rule. Spec file. But we said we just want to do transfer success, first case, and let's see if it works.
00:58:01.384 - 00:58:44.744, Speaker A: So we don't have any options because I know it's going to work. So that's why this part is blank. Let's see who's actually remained nice. Appreciate it. So this usually takes about two minutes, so it shouldn't be very long anymore.
00:58:46.884 - 00:58:49.224, Speaker B: Okay, can I have a question in the meantime?
00:58:49.924 - 00:59:16.764, Speaker A: One sec. If we did, if we did log, it would actually take about 40 minutes. And that's when you would get the millions lines of code. But when we don't log anything, it usually takes a significantly smaller portion of time. In other words, debugging is extremely costly. But writing good specification and good code is very cheap. Yeah, Adam, hit me.
00:59:17.744 - 00:59:28.352, Speaker B: You mentioned something that you have called path explosion. All right, so you get there are cases where you can have almost infinite amount of paths, right?
00:59:28.488 - 00:59:29.204, Speaker A: Yes.
00:59:29.664 - 00:59:34.378, Speaker B: So what are the strategies to deal with these cases?
00:59:34.576 - 01:00:07.254, Speaker A: So I am a super fortunate person in that none of the contracts I verified used the x op code. Or in particular, I never actually had a path explosion. So I don't know, I never encountered this yet. Luckily for myself, I guess that K has some internal heuristics for handling this very effectively.
01:00:08.794 - 01:00:09.694, Speaker B: Okay.
01:00:11.794 - 01:00:50.594, Speaker A: So the verification is finished. So let's see if it has outputted an error log. And we do that by going to output and for checking out the logo. Okay, so we verified it. Now, what's the actual output? Nice. So we just verify that the precondition will always lead to the postcondition regardless of the value of any one of our symbolic variables, including storage. So that's pretty cool.
01:00:50.594 - 01:00:56.624, Speaker A: And that's also the end of the demo. So do you guys have any more questions?
01:00:58.284 - 01:01:33.210, Speaker B: Great. I have one more. In your opinion, what differentiates a complete form of specification from implementation of the code you are trying to verify? Like what's the difference? If you have a complete formation, you can almost use it instead of the code, right? Because what, you can use the specification in the place of the code, right, instead of the code, almost, right. Like from logical standpoint, because like that all of the rules.
01:01:33.282 - 01:02:20.444, Speaker A: Not necessarily. So I think that the k guys are working on this, at least, at least they've hinted at it being able to generate bytecode from case specifications, which would be, in my opinion, pretty revolutionary when it comes to both software development and theoretical computer science. But most in practice, it's not always very easy to equate the two. Consider a sorting algorithm. So classification would just say that it began unsorted and it ended up sorted. But there are numerous ways of how to implement that process, right.
01:02:22.144 - 01:02:40.974, Speaker B: But to check if you have actually, like, not only if all of the elements are sorted, right, but if the elements are identical to the elements you have started with. Right. To like really check everything. Right. You basically have to re implement the program in the spec.
01:02:41.394 - 01:02:49.850, Speaker A: Not really, because it's much easier to check a sorting, to check whether a list is sorted than to sort it, or.
01:02:49.922 - 01:02:56.866, Speaker B: I wouldn't say no. You can check a list is sorted, but you also have to check the elements are identical with the original list.
01:02:57.010 - 01:03:04.506, Speaker A: Right, fair enough. And I'm not sure that those two things are identical to actually sorting it.
01:03:04.610 - 01:03:12.482, Speaker B: I think so. Like, at least my mental math is intuitively, I think it's the same task.
01:03:12.618 - 01:03:36.874, Speaker A: Interesting. Yeah. Are you still on the call? What do you think? If. Yeah, I'm still on the call. My intuition is not necessarily, but at the same time, like, to verify it, you know, it has to use some search algorithm, right? Yeah, yeah, yeah. Solvers using some sort of algorithm. I would have to think about this.
01:03:36.874 - 01:03:39.794, Speaker A: It's, it's a good food for thought.
01:03:40.334 - 01:04:15.806, Speaker B: Yeah. Like my intuition is that what differentiates like formal specification from the form, like the code that it's trying to verify. Right. Is that formal specification actually checks more stuff than the code. Right. In code you have like implicit assumptions, right, about the outputs or about the relationships between inputs and outputs. But in formal verification, you actually like encode these implicit assumptions explicitly.
01:04:15.806 - 01:04:34.934, Speaker B: Right. So you actually do more computation or more checking than the code. Right. So formal specification is almost like a. Like, it should be like the implementation, but more on top of it. Right. That's my intuition at least.
01:04:35.434 - 01:04:55.892, Speaker C: Yeah, I think. Yeah, I think that this is also my intuition. I feel also it kind of like the framework kind of forces you to think about all possible cases. Whereas. Sorry, whereas if you just write, let's say regular code, it doesn't like there, you just has to work with like the couple of input parameters that you thought about and all the other cases. Well, who knows, maybe it works, maybe it doesn't.
01:04:55.948 - 01:04:56.356, Speaker A: But.
01:04:56.460 - 01:05:19.748, Speaker C: Yeah, I also don't have a better explanation, but I was also wondering. So Dom, you mentioned basically. Well, you have to write the specification, right. And obviously the specification also can have a bug. So do we now need formula vacation of the form verification specifically? It's a really good question to audit it at least.
01:05:19.916 - 01:05:33.344, Speaker A: But I think that there is, there is, there would be use, it would be useful if we had. That would check whether your different cases cover all the possible cases.
01:05:33.884 - 01:06:13.820, Speaker B: I think my answer to it is that if you don't care about efficiency. Right. Then you can like preventing bugs, it's much easier. Right. So in the, in the production code, you care about efficiency. So you can, you have to rely on implicit assumptions, but in formal verification, because you don't care about efficiency, because the formal specification is not what actually runs like in production, you have to, you can, you can encode much more things explicitly. And that, that makes it actually easier to catch bugs or to avoid bugs.
01:06:13.820 - 01:06:29.704, Speaker B: So I think that it's easier. If you don't care about efficiency, like computational efficiency, you can write back proof code more easily. I think.
01:06:32.564 - 01:06:44.084, Speaker A: Comes down to the type of execution. In regular, real world execution, we do concrete with form modification. We do it symbolically.
01:06:46.744 - 01:06:53.992, Speaker B: Well, like normal program is also a symbolical engine. Right, right.
01:06:54.128 - 01:07:02.798, Speaker A: But during execution, all the variables have specific values, at least in the EVM.
01:07:02.936 - 01:07:11.018, Speaker B: Yeah. In execution, yes. But. But if we are comparing the program and the specification. Right. These are both symbolic systems. Right.
01:07:11.018 - 01:07:12.682, Speaker B: So, yeah.
01:07:12.738 - 01:07:14.414, Speaker A: That's a really good way to look at it.
01:07:14.874 - 01:07:17.374, Speaker B: Yeah. Okay.
01:07:20.594 - 01:07:25.146, Speaker A: Cool. Any other comments or questions? Do we.
01:07:25.170 - 01:07:27.534, Speaker C: Do we need to audit the specification?
01:07:28.314 - 01:07:30.038, Speaker B: Yeah, I think so. Think so?
01:07:30.166 - 01:07:31.382, Speaker A: I think we do. I think.
01:07:31.478 - 01:07:36.022, Speaker B: But it should be. It should be. It should be easier to audit than the code.
01:07:36.158 - 01:07:36.526, Speaker C: Got it?
01:07:36.550 - 01:07:39.594, Speaker B: Yeah, I think that's. That's the point.
01:07:40.294 - 01:07:41.594, Speaker C: Okay, makes sense.
01:07:43.854 - 01:07:48.994, Speaker A: Okay, cool, guys, thanks for joining and have a great weekend.
01:07:49.654 - 01:07:50.126, Speaker C: Thank you.
01:07:50.150 - 01:07:50.874, Speaker A: You too.
01:07:51.854 - 01:07:55.634, Speaker B: Thanks for the presentation. Yeah, I learned stuff.
01:07:56.374 - 01:07:57.334, Speaker A: Thanks, Dominic. See you later.
