00:00:00.400 - 00:00:10.390, Speaker A: Thank you for that really gracious introduction, and thank you for inviting me to speak today. I'm not the lead researcher at Novi. I'm a lead researcher, I think, but.
00:00:10.502 - 00:00:12.590, Speaker B: In my view, you are the lead researcher.
00:00:12.622 - 00:00:50.494, Speaker A: But anyway, well, that's very, very nice, but the people there may differ. We've got a whole bunch of really good people and a bunch of people leading various projects. So I'm a blockchain researcher for Novi. Novi is a Facebook company that develops applications for the diem blockchain. You may have heard of the Libra blockchain. In fact, Andreas just said it, but we had a name change from Libra to Diem in December for reasons that I don't actually know what they are. Anyway, the research I'm presenting today is one of Novi's contributions to the DM blockchain.
00:00:50.494 - 00:01:34.394, Speaker A: So diem is basically infrastructure. So it's a safe, secure, and compliant payment system that empowers people and businesses around the world. And it includes digital currencies which are fully backed by reserves. Novi is a private company, it's part of Facebook, and is one of many organizations that will build applications for the diem blockchain. The first Novi application is going to be a digital wallet. So I think of this a little bit like the highway system. You've got a system of roads that lots of people share, and then you have individual companies that use the roads as part of their business.
00:01:34.394 - 00:02:31.034, Speaker A: So we initiated the formation of the road system, but the road system is governed independently of Facebook. And then we're one of the people who hope to use that road system to host our applications. So the DM association has 27 members at this time, one of whom is Novi, and they govern the diem network and the development of the Diem project. So we're 120 7th of that process. It includes global companies, venture funds, non governmental organizations, including charities, all of whom hope to be able to use currency to or the infrastructure to serve, serve the financially underserved, which is the majority of the world's population. Here's a set of pictures of people on the project who are working more or less full time on it. They are all full time Novi employees.
00:02:31.034 - 00:03:17.822, Speaker A: In addition to these people, we work very closely with the Move platform team, which develops the move programming language and the compiler and virtual machine and surrounding software. We've also had several interns in the last two summers. One of them was Imma Zhang, who's now full time after we recruited her. So in the talk, I'll give some background, then I'll talk about the move prover. I'll talk about using the prover, give some examples. I'll talk about an interaction between the move language and the move prover, which is the memory model, and then I'll wrap up. I should mention about questions that the questions I really want during the talk are as if I just introduced some concept and didn't explain what it was.
00:03:17.822 - 00:04:02.358, Speaker A: I've been mostly speaking to specialist audiences who are very familiar with formal verification. So if I bring up some concept there that isn't so clear. If somebody reminds me to explain it, that would be helpful to everybody listening to the talk. The motivation for doing formal verification at all is that the blockchain is a high assurance system, meaning the reason is that large assets are at stake, of course. But in addition to that, everything is public in the blockchain, so it's embarrassing to reverse a transaction. We don't want to have to do it to deal with some bug in our system. The blockchain may be targeted by highly motivated and well resourced adversaries, so we have to protect it especially well.
00:04:02.358 - 00:04:42.496, Speaker A: And blockchains already have a pretty bad track record. Hundreds of millions, if not billions of losses have already occurred from bugs in other blockchain systems, and we would like to not continue that tradition. The move prover is a formal verification tool for smart contracts written in move on the diem blockchain. I'll caution you that it's a work in progress, so this is not a done deal. It still has some rough edges and there are still some unsolved problems. I'm going to present it as an engineering project rather than focusing on research results. And I'll mention that the system is 100% open source.
00:04:42.496 - 00:05:31.894, Speaker A: So if you're sufficiently curious to really want to read some code or look at some specifications, you can do that because the code we're working on is out there in the repository on GitHub right now. So here are our goals. They are not necessarily things that will be achieved quickly, but it's what we're working towards. We want to allow complete specification of the functional properties of smart contracts. We want to enable fully automatic verification that implementations in move meet the specifications in the move proverbs specification language. We want the system to run only a little slower than a compiler, so verification should not be a matter of running some program overnight or even going for coffee. You ought to be sitting there for a moment trying not to go browse the web while you wait for it to finish.
00:05:31.894 - 00:06:29.210, Speaker A: And we want to be able to re verify the system after every change. So if you're programming away, you'll periodically try verifying things to catch any bugs you may have. And when you submit something to the repository, it will go through the standard testing of continuous integration, which will include formal verification before it's actually checked in to the to GitHub. So verification is a hard business, and most people who've worked in the area have a history of systems that didn't do as well as they wish. So I'm hoping this will be different, and we have good reasons for thinking it will be different. First of all, we're starting with a clean slate, so we're not taking some legacy programming language with a bunch of legacy programs and trying to figure out how to formally verify all of it. We can avoid some of the problems that people have when they're trying to verify traditional software.
00:06:29.210 - 00:07:27.354, Speaker A: For example, developers of code do not like to write specifications and are often just plain unwilling to we're trying to establish a culture of specification from the very beginning, and we already have a formal verifier for movement, which is just kind of starting out. So we're in a good place to establish a tradition of writing specifications as part of the routine development process. Programming languages in general are too complex and ill defined to formalize move as a smaller language, and while we don't have a complete formal semantics right now, we've defined it pretty carefully. We're pretty confident about the semantics. Legacy programs are too big and complex, but smart contracts in this era are not that large, so it's more tractable to try to verify them. Programmers and others usually don't care that much about bugs. This is a sad fact that I learned about in the real world, and that's true even when they should care about bugs.
00:07:27.354 - 00:08:28.352, Speaker A: In our case, we've already demonstrated by putting all this work into development that we care about the bugs. And once again, we want to establish a culture that when you're writing move programs, you're also writing specifications and verifying them. So we hope to be in a situation, in fact, we seem to be in a situation where we can co design the tools, the programming language, the programming style for move programs, and the verification methodology all together to maximize the value and the probability of success of formal specification and verification. If you take all of the complexity of a blockchain and boil it down to about the minimum you need to know to understand what we're doing here. It's very simple. Blockchain is a sequence of states with transactions that update one blockchain state to create the next blockchain state. A smart contract, in our view, is simply the code that implements a transaction.
00:08:28.352 - 00:09:13.434, Speaker A: So it reads the old state updates, it writes the new state. Transactions, as in most blockchains, are atomic, so they either run to completion or they don't change the state at all, except for consuming a little bit of currency to pay for the cost of the computation of the transaction. A blockchain state in our system looks like this. There's a collection of many, many numerical addresses. At each address you can publish a structure, in this case, a DM account. The structure can have fields, which could be other structures. In this case, it has a field called an authentication key, which is a vector of bytes, and another field, which is a sequence number, which is a 64 bit unsigned integer.
00:09:13.434 - 00:09:38.276, Speaker A: Multiple values can be published at an address. So in this example, I'm going to have a balance for a currency called xdx. Balance is a record. I'll describe the contents in a moment. Xdx is a type, and so the angle brackets indicate a type parameter. So we can have multiple balances with multiple types. This one, in the current implementation of the blockchain, every currency has its own type.
00:09:38.276 - 00:10:13.354, Speaker A: So XDx is one of the currencies. So, balance has a coin, it's called a DM object. It's parameterized by the type. So each currency is implemented using a coin, and the currency type is a parameter to the coin type. And then each coin has a value, which is the denomination of the coin, which is a 64 bit integer. As I said, you can have multiple currencies, you can have multiple published types with different type parameters. And so I'm also imagining in this example that we'll have a second balance for a second currency called XUS.
00:10:13.354 - 00:10:51.182, Speaker A: And that will, of course, have the same field, although the balance, the coin in the balance field, will be parameterized by xus instead of xds. XDX. And of course it has a value field, two, which is the denomination of the XUS coin. I'm going to pause to see if there are any questions about what I just said here, just to make sure everybody's keeping up. Can people ask questions interactively? They can, but it seems there are no question at this point. Okay, great. I'll carry on.
00:10:51.318 - 00:11:06.902, Speaker B: If there are questions, they can type in. Christoph, monitor the chat because I have big screen to see the presentation. Usually, David, questions are at the end, but if they're. I mean, since you welcome interim questions, people can. The audience can feel free to chat.
00:11:06.998 - 00:11:16.522, Speaker A: Yeah, for questions. I'd really just want to make sure I'm not they haven't said something confusing that needs to be straightened out. I'm hoping there'll be plenty of time for discussion at the end.
00:11:16.578 - 00:11:23.234, Speaker B: Easily. Our audience is quite sophisticated in the topics that they attend, so great, thank you for doing so.
00:11:23.394 - 00:11:48.194, Speaker A: So if nobody's lost, I will carry on. Nobody's lost except me, I guess. Good. So the next topic is the move language. And so I know that many of you have heard Sam, who's the designer of the move language, talk about it in much more detail. So I'm going to present the minimum that you need to know about move in order to follow the rest of the talk. So move is a programming language for implementing smart contracts on the DM blockchain.
00:11:48.194 - 00:12:21.714, Speaker A: It is designed for safety. A module can only call other modules that already exist. There are no reentrancy issues, unlike solidity, which has had horrible bugs because of this. And there's the most novel thing about move is a resource type which models physical assets which can't be lost or duplicate. It's basically duplicated. It's basically a struct where you can't create new copies or delete copies outside of the module that define the type. Move has limited expressive power, which is very helpful when you're trying to specify and verify programs.
00:12:21.714 - 00:12:47.534, Speaker A: Move compilation is pretty traditional. You start with move source code. You run it through a compiler. It produces bytecode. The bytecode is our own instruction set that we designed running on the virtual machine that we designed and implemented. The bytecode verifier is unrelated to formal verification. It's a semantic checker for type and other consistency things that runs on the byte code.
00:12:47.534 - 00:13:56.234, Speaker A: We do the same checks inside the compiler, but we do it on the bytecode because we don't want to have to trust the entire complex compiler to have semantically correct byte codes to generate semantically correct. So every change chain in the blockchain state goes through the move virtual machine. So the state is stored in a database which we call the store, that is read and written by the virtual machine. Other things can read out of the store, but the only thing that can write to the store is the virtual machine. The virtual machine executes bytecode programs which are transaction scripts derived from move source, and those transaction scripts can call functions that are stored in library modules, which is also in move bytecode language stored in a blockchain. All of the basic functionality of blockchain is implemented in smart contracts, for example the currency accounts, etcetera. So consensus is handled in other code, but the contents of the states are all managed by move programs.
00:13:56.234 - 00:14:36.194, Speaker A: So now I'll talk about the move prover. So it takes formal specifications and checks them. It uses a classic Floyd horror approach to formal verification with explicit specifications. So the specifications are separate from the code because they're intended to capture the intent of the programmer. Specifications are mathematically precise, they're written in our own specification language, which is a logical language. They are separate from the implementations, and they explicitly capture user intent. So it's a sort of independent description of what the program is supposed to do.
00:14:36.194 - 00:15:19.468, Speaker A: Formal verification automatically proves that a move program satisfies its specifications for all possible inputs and in all possible states. So our goal is really to prove correctness. This is not a bug hunting process, although we assume that it'll be good for finding bugs. And of course we've already found some specification may present the hardest problem in this process, because errors and specifications can be dangerous. False positives are bogus error reports. They're annoying, and they require debugging of the spec or the code, so they can be time consuming. The really bad problems are false negative.
00:15:19.468 - 00:16:09.674, Speaker A: It's a missed error or a missed security vulnerability coming from an error. And that's more serious because we want to find out about these things and address them. So the goal is to make it possible for users to write specifications in the most obviously correct form that they can. And so one aspect of that is we use logical quantifiers for all their exist rather freely, even though they cause some problems later in the pipeline with efficiency. Here's a diagram describing the process of running a verifier. So it takes input in the form of a byte code to be verified and abstract syntax tree for the specification. It produces boogie code, which I'll explain in a moment, and runs that code through the boogie tool.
00:16:09.674 - 00:16:46.924, Speaker A: So basically an intermediate language for verification that produces input for logical formulas to be solved by an SMT solver such as z three or cvc four. If a logical formula turns out to be incorrect, we go to some trouble to take the output of z three or c four and turn it back into something that's actually understandable for the user. In terms of user source code, that process is difficult. We're still working on it, and it's something that's neglected in a lot of verification systems. But it's crucially important for usability. It's an ongoing process. To improve this.
00:16:46.924 - 00:17:43.344, Speaker A: I'll talk about Boogie a bit. Boogie is a system developed at Microsoft research over ten years ago and under continuous development since then. It's an intermediate language for verification that bridges the semantic gap between a programming program in source code or bytecode and an SMT solver, which is logic, which is a little bit inscrutable. And so it looks like an approximately, like a simple imperative language. It has procedures, it has assignment, and it has data structures which are similar to the theories that are implemented in SMT solvers. So our problem is to translate a bytecode program into boogie, and our approach in doing so is to implement each bytecode instruction as a boogie procedure. And then a translated byte code program looks like a sequence of procedure calls to these boogie procedures.
00:17:43.344 - 00:18:29.144, Speaker A: Specifications translate into boogie code and into boogie assumptions and assertions. So now I'd like to give you a little flavor of what the input to the prover looks like. So I'll go back to an example we had before, or this is a slightly different example actually. So at address two, we have two objects that are published. These are actually objects from the real system, a DM account object and a role id object that has a field called role id, which is nonsigned. 65 role id is used for access control. So these things are important and we have a lot of properties related to them.
00:18:29.144 - 00:19:19.594, Speaker A: So, to talk about whether a resource exists or not, whether a resource is published, we have a construct in the specification language called exists. It takes the type of the object as a parameter, which in this case is DM account, and the address that we're querying, which is two. It returns a boolean, true or false, depending on whether that object is there or not. If we want to access a value that's published in the blockchain, we use this global construct which takes the type of the object as a parameter and the address as a parameter, and then returns the value of the object, in this case the entire role id. Within that we can access fields or do whatever we need to using conventional program notation. So in this case we're accessing the role id field using dot notation. So just a field of that resource.
00:19:19.594 - 00:19:57.626, Speaker A: So for specifying things, one thing we can specify is a post condition. This is classical hor logic. So I'm imagining this is a real function as of. I don't think the name has changed recently called published parent VasP credential. You don't need to know what a VAsP is, it's just a kind of account, and it takes a formal parameter called ADDR, which is an address. All our specifications are enclosed in syntactically distinct blocks from the code. In this case, we say it's a specification for the function that I just named out.
00:19:57.626 - 00:21:00.946, Speaker A: And there are two postconditions that are, these are logical properties that are intended to hold after the execution of the function. So the first one says, after you call this published Parentvasp function, that there will be a published parentvasp object at the address Addr, which was a local parameter, I'm sorry, a formal parameter to publish parentVasp credential. And then we want to talk about the contents of that object. So we use the global construct to say ensures that the function ensures that the global parent VAsp object published at that address has zero children initially. Later on children may be added. So these are conditions that must hold immediately after the function, regardless of the value of address or any of the other parameters, and regardless of what the state of the blockchain is before the function is called. Another construct that we have in the specification language is aborts, if this is a little bit novel.
00:21:00.946 - 00:21:42.714, Speaker A: So instead of runtime errors or exceptions move programs abort. So instead of stopping wherever the exception occurred, they back out to the state before the transaction. So a condition that might cause an abort is an overflow of an integer variable or an out of bounds vector access. The abort will result in no state change except for consuming a little bit of currency called gas to pay for the computation. And some programs are correct. It's supposed to abort under some conditions. So part of the correctness condition is that this program is supposed to abort if certain conditions hold.
00:21:42.714 - 00:22:25.414, Speaker A: So the verifier should not report an expected result. I'm sorry, if an abort is expected, the verifier should not report that as an error. However, if an abort is unexpected, it should be reported as an error, because that's a problem that the user needs to address. Also, if an abort is expected and does not occur, that's an error. I'll have an example of that later. So the aborts if specification is a construct that we have to capture the programmer's expectations about whether a function aborts. So I'll show an example involving access control.
00:22:25.414 - 00:23:27.444, Speaker A: So that involves a DM account and one of these role id objects I just mentioned. So there's an access control rule documented elsewhere that says that a parentvasp can only be created by an account that has a treasury compliance role. So the way we specify that is we say that the function that creates FAS accounts will abort if the published role id at the creator adder, that's a parameter to the function. Role id value is not equal to a number, which is the treasury compliance role id. So the idea is that we go and look at the address, the published role id, look up the value of this field, and if that's not equal to the magic number that is treasury compliance role id, we're going to abort. In fact, we're going to produce an error. So whoever invoke this transaction understands that they violated the requires roll move.
00:23:27.444 - 00:24:14.564, Speaker A: Sorry, requires roll rule. So this is an example where it's important to abort under particular conditions, otherwise you might violate the access control rules. So next, I'll give an example of a global specification. The most important properties in the system are often globally, which means they involve multiple functions, they involve properties of the global state, and they involve change, or usually no change over time. In other words, their temporal properties. So, for example, we have lots of global invariants in the current library, specifying the current library. These are properties that are guaranteed to be true for all time, starting with the Genesis state.
00:24:14.564 - 00:25:14.784, Speaker A: And we have what we call two state invariants, which are properties that compare the previous state and the current state after something that changes the state. Here's an example of a global invariant, so, related to role based access control, every address that has a DM account also has a role id. And so that's why that's written in our specification language is we say it's a module level spec, it's not affiliated with any particular function. It is a global invariant, and for every address where there is a DM account published at that address, there must be a role id published at the same address. I'll mention that this exists thing I should have said this before exists is also a quantifier, but that's in a totally different context. In this case, it's just a query of whether an account is published or not. An example of a two stated variant is the following.
00:25:14.784 - 00:26:18.572, Speaker A: Once a role id is stored at a particular address, it never changes. And so that's a more complex property, and I'll walk you through it. So first of all, we say it's an updated variant, which means there's one of these two stated variants. We say for every address, if there's a role id published at the address in the old state. So before we call some function, then after we call the function that there will still be a role id object published at that address. Furthermore, the value of the role underbar iD field of that role ID object at that address will be the same in the new state as it was in the old state, thus showing that the role ID didn't change at all, didn't get unpublished, and the value in the role ID field didn't change either. Okay, so now I'll talk about one of the more novel aspects of the move prover.
00:26:18.572 - 00:27:18.314, Speaker A: It's an optimization that we're able to do because of the semantics of the move language. So one of the biggest problems in verification of software is dealing with aliasing memory references that may or may not be the same. So this is just a real burden that everybody doing this, solving this problem, has to worry about. So the reasoning about it will often experience a combinational explosion of possibilities. So if you've got ten different pointers, you've got every possible combination of those pointers being pairwise equivalent or not. Every possible equivalence relation would be precise. So if we model memories as arrays, as we often do when we're doing SMT based verification of programs, you get deeply nested array store expressions which then expand out to massive if then else trees, covering all the possibilities of whether two things are equal or not.
00:27:18.314 - 00:27:52.008, Speaker A: We can avoid this disaster. So in move memory is tree structured. So a tree is a record of records of records finally bottoming out at types that don't have parts, primitive types. We can't store references into memory, so you can't get more complicated graph structures. They can only be used as local variables. We have a borrow checker which statically forbids combinations of references or manipulations of references. The result in aliasing.
00:27:52.008 - 00:29:01.924, Speaker A: So there is no aliasing effectively. So essentially there's copy semantics in move. And so we can model this in the move prover as kind of a copy in, copy out operation on parameter on functions instead of as shared memory. So suppose we have some possibly large object in the in the state, and it's got another subtree inside it, and there's a reference to that subtree, which is mutable, meaning that we can change that subtree by executing assignments to things inside t two. Suppose we have a function that takes that mutable reference, meaning this function might internally execute some code that changes t two. Then the way we implement it in our boogie translation is that we just copy that subtree into the function. The function does whatever it will to the subtree, possibly changing it, and then when the function completes, it is copied back to the original subtree, which then can see the changes.
00:29:01.924 - 00:29:57.494, Speaker A: So we can get away with this, because there's no way to write move code that can test you can tell the difference between t two staying inside t one and being changed in place, versus t two being temporarily copied into another function that changes it privately and then returns it. Nobody can see the transition that's happening in the middle of executing f. The memory model has several advantages. It's got the efficiency advantage of eliminating the combinatorial explosion that I mentioned. It also has an advantage of simplifying framing. When you're verifying software, you have to worry a lot about whether functions change things or not, because when you call a function, most of the state is not changed at all. And you'd like to avoid having to spell that out explicitly.
00:29:57.494 - 00:30:38.924, Speaker A: You'd like the system to just figure it out by this copy in, copy out thing. We have a much better handle on what memory can get changed and what doesn't get changed. It also gives you the convenience, in some sense of imperative programming with some of the advantages of functional programming. So we have the best of both worlds when we're doing verification. Finally, I'll wrap up and hopefully we'll have some time for questions. I want to acknowledge the existence of similar projects. There are in fact lots of projects to verify smart contracts on blockchain, but I'll focus on some that are most similar to what we're doing.
00:30:38.924 - 00:31:31.742, Speaker A: And the similarities, of course, are that they're devoted to verifying smart contracts and that they're based on these automatic logic solvers, the SMT solvers. So Verisol is one such program developed at Microsoft Research. It uses boogie, as do we. Solsi Verify is a program developed at SRI, which also uses boogie Sirtora. Not sure exactly what technology they're using because it's a private company with proprietary technology, but they're using the same basic approach of using an SMT solver to solve many of the problems. The main difference between what we're doing and what they're doing is that they're verifying smart contracts written in solidity for the Ethereum platform. And the issues in solidity are very different from the issues in move.
00:31:31.742 - 00:32:44.114, Speaker A: And many of the things that somebody would formally verify in solidity we don't even have to think about, because they're just checked by at an earlier stage by the move compiler. Solidity is maybe not the greatest program in language for writing safe code, which is part of the reason that blockchains have had so many problems with bugs. The current status of the project we've developed a prototype of this move prover, which can be used by experts on the move prover team and we've written extensive specifications for the move standard library, which will be used when we go public with currency. So we specified and verified all of the access control requirements which are documented in a separate document. So we had to be very specific about what accounts are allowed to do, what operations, what kinds of transactions, and that's written in English in an informal document. We've taken that entire document and translated into move specifications, and we proved that they all hold on the move implementations that exist. So we've also got a document generator that allows us to have those specifications link back to the original document requirements.
00:32:44.114 - 00:33:29.844, Speaker A: A dip is sort of like an RFP in Internet land, so it's a standard for interoperability. So we've specified and verified, we've also specified and verified the abort conditions that are documented for each transaction in order to make the transactions usable. We've described what they do, and also all the various conditions under which they'll abort. And so we are able to write those down formally and prove that the documentation is correct. We found a few bugs and now lapses in the documentation. By doing that and many, many other properties like the ones I showed you earlier in the talk. So almost everything verifies automatically, and that's improving as we make improvements in the system.
00:33:29.844 - 00:34:20.648, Speaker A: Everything has to finish, I think, in less than 40 seconds or times out, and formal verification is automatically run every time we check new code into the repository. So that presents a number of interesting challenges, including the fact that it has to be deterministic and it also has to produce the same results every time. You can't have flaky things happening in continuous integration for various reasons. In case you're curious, it's all in the repository, in the language subdirectory. This is GitHub dmdiem. You can download it and use it and compile it if you want to. It's got, of course, the move compiler, it's got the library, it's got all the specifications we wrote and the move prover, but we're not supporting it for general use yet.
00:34:20.648 - 00:34:56.765, Speaker A: So it is mostly only usable by members of the move prover team, people like me. There is a few other people who've written a few specifications and gotten them to work, but it's not that user friendly for non experts. So yeah, you might want to wait on that. The system is also rapidly evolving. So next steps. Our next challenge is to solve the problem I just mentioned, which is to make the move prover more usable by people outside the move prover group. Some expertise is probably going to be required for a while, but we know what the next problems are to make it more usable.
00:34:56.765 - 00:35:39.644, Speaker A: For example, we could write templates to take specifications that are frequently reused and packaged them up so they can be used more easily. We need to automate more of the system. So right now we have a lot of specifications that are written just for the purpose of making verification go better. They're basically specifications that are used to prove other specifications that people actually care about. We'd like to derive more of those automatically. We need much better debugging. So we'd like to be able, every time you have a problem with a specification, whether it's a bug in your code or a bug in your specification, we'd like to be able to get a specific, understandable counter example back to speed up the process of fixing those problems.
00:35:39.644 - 00:36:25.412, Speaker A: And we have a problem with non termination. So this is most annoying actually, when you make a mistake. So it's frequently the case that when there are no mistakes in the specification or the code, everything runs relatively quickly in a few seconds. But when you write a new specification or change the code a little bit, you end up introducing an error. And then instead of quickly getting a counterexample that shows you what's wrong, the prover just hangs, and then you have to do various experiments and whatever to figure out that's not really acceptable. And so we're working hard to get more predictability, completing, getting counter examples back from the system. We also need to, and this is a research problem, and I think a pretty interesting one, that hasn't had that much work on it.
00:36:25.412 - 00:36:58.652, Speaker A: We need tools to develop. We need to develop tools for checking the correctness and the completeness of specifications. So in verification, you often check the correctness of your specifications just by comparing the specification code. Because if you try to verify something, you get a problem back. It's just as frequently a problem in your specifications, in the code itself. And that is fine. It's looking at two different viewpoints of the same thing and making them consistent to eliminate problems and sometimes discover misconceptions in each of them.
00:36:58.652 - 00:37:48.430, Speaker A: The bigger problem is if your specification is incomplete, then you might be missing an error and don't know it. So we move the problem of bugs in the code into bugs in the specification, and that's better. But still, the process of linting or doing sanity checking on specifications seems to be largely undeveloped, and we'd like to work on that problem. There are many, many other improvements, and we've used the verifier prover extensively now, so we have a pretty long list of these that we've discovered the hard way just by trying to use it ourselves. Okay, in summary, move programs hit the sweet spot for formal verification. The impacts of bugs can be bad. Move programs are relatively simple, and then we're starting with a clean slate.
00:37:48.430 - 00:38:10.644, Speaker A: So that makes the problem easier. Our approach is a highly automated Floyd horror based verification move, and the DM blockchain creates some unique issues and opportunities. So it's good both for developing a practical tool and doing research, which is a mode I like to operate in. Thank you very much, and I'd like to answer any questions you may have.
00:38:11.864 - 00:38:58.394, Speaker B: David, thank you so very much for this insightful talk. It was very interesting because now it completes the vision that we have about move. Let me we have a couple of questions already, and I will invite the audience to add to these questions. And I have also some of my own. And Kirti has the first and the third question. Is there a way to transform solidity contracts to move? I mean, move is. It doesn't in particular relate to the area of verification, which is your expertise, but you being part of the Novi and move language ecosystem, it will make sense.
00:38:58.394 - 00:39:10.954, Speaker B: If you can create an automated compiler and a compiler that automatically transforms lydic context to move, then somebody can ask vice versa also.
00:39:12.374 - 00:39:58.484, Speaker A: Yeah, so we haven't tried to do that and don't plan to do it. The languages are very different, and as I mentioned, move has limited expressiveness. So there are things that you can say in solidity that might be a bit difficult to code in move. So I suppose in a theoretical sense move is turing complete, so whatever. But that's not a practical answer. I think when people are tempted to do that, unless they wrote the solidity code to be easily translated into move, I think it's probably easier just to rethink the program and rewrite it from scratch and move than to try to automatically translate it going the other direction. I suspect that is easier to do.
00:39:58.484 - 00:40:17.164, Speaker A: Once again, I've devoted very little thought to it, but solidity has more data structures. There might be some real gotchas there, so if you tried it, you might have a little more excitement than you bargained for. And I haven't thought through, through what would be involved, but I think that would be easier than going the other direction.
00:40:18.024 - 00:40:31.992, Speaker B: Okay, I see Yusuf has a question like what part? And maybe I would like to add to that question, what part do you think is the most difficult for general users so they can use the move.
00:40:32.048 - 00:41:25.494, Speaker A: Prover, it depends on how general they are. Okay, so the first barrier, and having taught many classes where I teach logic, I know this very well, is developers are much better trained in writing programs and much more tolerant of obscure programming language features than they are of logic. But I have to feel that first order logic is not that much harder than, you know, your typical functional programming language for somebody who's willing and able, able to understand the logic. I think the biggest problem we have right now is debugging. And so if you. A lot of the cases where I've learned a programming language, I've learned it by trial and error. And so if the error is, oh, you did something wrong, and this is specifically the mistake you made, you need to go check this documentation.
00:41:25.494 - 00:42:03.844, Speaker A: That's much easier to work with than something that just hangs right. If you had a compiler. There's a famous story about one of the first c compilers where if it didn't parse properly, it came back with the arrogant message, this is not a c program, and so that's pretty hard to work with. You'd really like some more constructive feedback. So that's our highest priority. Now there are all sorts of issues of expressiveness of the programming language and whatever. Right now we've got probably less than 10,000 lines of move code and an equal amount of specifications, so we haven't really stressed the boundaries.
00:42:03.844 - 00:42:11.144, Speaker A: And we're still working to be able to do the basics really well. So there are a lot of undiscovered problems as well.
00:42:11.684 - 00:42:38.028, Speaker B: So by debugging, since you brought it up, you're talking because I spent a lot of time working, that was my expertise, automated debugging for hardware. So debugging has two features. Has two basically components. First is the localization. Right. And second is the correction, how to correct something that is wrong. So localization says that this line is wrong, right.
00:42:38.028 - 00:42:53.676, Speaker B: So the move compiler doesn't have pretty much some sort of like debugging ability. Doesn't when something's wrong tell you, hey, this line is wrong because these operators do this, or I'm sure this is.
00:42:53.700 - 00:43:34.974, Speaker A: Yeah, oh, that's a. So move is different from the move prover. So we don't even execute a move program in the move prover, we just give it to the SMT solver to think about, and we can tell you if it comes back with an answer, it doesn't just time out. We can tell you which specification failed and give you a pretty good point to that. So we're totally focused on the localization problem. Now, and the problem is really more than identifying a line of code, it's identifying what was wrong with the state that caused this thing to abort. Or what was.
00:43:34.974 - 00:44:09.294, Speaker A: If it says that a post condition doesn't hold or an invariant is violated, what value in the state is wrong? Right. If we could just print out the part of the state that we changed comprehensively so somebody could see what's going on, they could often figure out the error. So that's the, you know, the other thing is, why does this property not hold? If I said for every address something is true, and you say that's false, there must be some address where it's not true. Show me that address and show me the data structures that are stored there. That's what I'm talking about with debugging.
00:44:09.714 - 00:44:31.840, Speaker B: I see. Let me stick with that point before proceeding to the next question. Actually, traditionally, solidity code is a few hundred of lines, not even a few thousand lines of code. Right. And I would suspect the same thing is for move. You're creating an escrow account. You're creating these, you're creating that.
00:44:31.840 - 00:45:12.008, Speaker B: You're not writing a driver, which is like hundreds of thousands of lines of code right. Now, the problem is that if there's a mistake in the program, the escrow account might have, like, half a billion dollar store, then you might lose the money. Right. It's different than your computer crashing or your Android crashing or so forth. Right. So what is the impact when you guys were designing the prover that the problem that you're dealing, of course, is verification? Of course, is smt you're using, but it's not as huge as in the traditional world of coding and programming. Right.
00:45:12.008 - 00:45:16.560, Speaker B: It's a much more contained problem. Right.
00:45:16.592 - 00:45:23.480, Speaker A: Yeah. The amount of code is smaller and people fairly careful potions.
00:45:23.632 - 00:45:28.604, Speaker B: Yeah. You're not talking about the whole galaxy over here. You're talking about the solar system. Right?
00:45:29.564 - 00:45:30.344, Speaker A: Yeah.
00:45:31.604 - 00:45:38.664, Speaker B: So what is the impact? Or how would you quantify or what kind of guidance would you give over there?
00:45:40.644 - 00:46:39.344, Speaker A: Well, I'm not sure exactly what you're asking, but this, for us, is a wonderful thing. It means it's possible to do all this work, get something that works, actually prove the properties that we need before we launch, and then scale up gradually as we add new, more complex applications and extensions to the move language in the future. So, frankly, my goal, I started a little, you know, the move prover project at least maybe a year after move started being designed. And so I was playing catch up early on, and my goal is not to fall behind and to keep up with the move language. So if we can grow with the move language and with the code base of move programs, I think we have a good chance for long term success if we fall behind. So there's large amounts of unspecified and unverified move code. I'd worry about the long term impact of the prover.
00:46:39.684 - 00:46:51.324, Speaker B: Okay, that was my question exactly. So Kirthy also asks a question. It's like, how are the semantics around gas handled in the move proverbial?
00:46:52.374 - 00:47:28.034, Speaker A: We ignore them. So it's a contained problem. And I think eventually we'll want to at least statically analyze programs to estimate the amount of gas they use or find an upper bound in the amount of gas, but we're ignoring gas now in the move prover. And I think the gas problem is sufficiently separate from what happens in transactions that. That it's not going to be a problem, and it hasn't been a problem yet. So we know that we're not checking gas along with everything else. And our properties don't depend on gas.
00:47:28.614 - 00:47:34.594, Speaker B: Okay, so you don't care if a contract is, like, going outrageously off dungeons when it comes?
00:47:35.254 - 00:47:58.604, Speaker A: Yeah, that would. I think that matters, and I think we would solve it by some specialized analysis. So we have had a guy and at least one intern looking at gas estimation. That's also a topic that people outside of Novi have been looking at for ethereum, and I think there's probably a decent solution. We just haven't gotten to it yet.
00:47:59.144 - 00:48:22.520, Speaker B: Okay, fair enough. So Henry asks the following. Will you dictate that all smart contracts that will execute on dim diem will go through the proverbial? Also, under what conditions do you automatically generate move code from specifications? So, actually, that's kind of interesting, because I had very, very similar questions to ask.
00:48:22.672 - 00:48:25.224, Speaker A: Yeah, let's. Let's separate the two questions.
00:48:25.304 - 00:48:26.856, Speaker B: Yeah, let's go to the first question.
00:48:26.960 - 00:49:29.382, Speaker A: So, for the first thing, I personally would like to do that. But just saying that the move programs are verified doesn't say very much unless you also know the specifications are good and complete. Not sure how to solve that problem. An interesting world would be at some future point if we have certain standard kinds of contracts. Like in ethereum, you've got ERC 20, where you could develop standard specifications, and then anybody who writes a contract that supposedly satisfies the whatever specification would have to prove that it also satisfies the formal specifications for that type of token or whatever. But that's a long way off. Right now, we're the only people writing move code and we expect at least we're the only people writing move code that goes on the Nobe blockchain, and we're expecting to gradually enlarge that group.
00:49:29.382 - 00:49:44.994, Speaker A: And so we haven't really figured out what the policies are going to be once we hopefully open up the blockchain. That's a decision of the diem association, by the way. So Novi is just 120 7th of that at the moment. So I don't know what's going to happen.
00:49:45.374 - 00:49:47.350, Speaker B: So let me ask that question anyway.
00:49:47.382 - 00:49:50.834, Speaker A: I think that would be a good policy. I missed Henry's second question.
00:49:51.134 - 00:50:21.890, Speaker B: Let me ask the first question. Actually, since you brought it up, my understanding is right now the system will be a closed permission system between the 27 people of the association. So me as Andreas or Henry as Henry, can I write a move smart contract and deploy to that blockchain? Right. So the purpose of the verification is to help the conservative members write correctly.
00:50:21.922 - 00:51:32.134, Speaker A: Well, so a lot of these policies, the long term of these policies hasn't been worked out. So as of the time we launch, the only move code is going to be code that was written by Novi to run on the blockchain. It's supporting anybody else who writes applications like wallets, which is basically all we have right now are payments and currency and setting up accounts and that kind of stuff. So there will be other wallets soon, maybe, I don't know, before Novi, I'm not sure what the timing is going to be. There are going to be other wallets using the system, but we'll be the only people writing move code for a while and then that can be opened up so other people can run contracts, which is an independent question of permission, you know, whether the blockchain is permission permissioned with respect to the validators. Right. So having the whole world running validators is a totally different question from having members of the association or the whole world or whomever, writing new applications, new smart contracts to run on the blockchain.
00:51:32.134 - 00:51:59.684, Speaker A: So anyway, so far as I know, there are no concrete plans for exactly what's going to happen. Obviously the system is engineered with the notion that there will be a wider variety of people writing smart contracts, not just knowing. And so the policy is somebody else's decision, but the engineering is targeting an open system, more contracts.
00:51:59.764 - 00:52:22.914, Speaker B: Yeah, because all these work that you're doing, it points towards that direction, to be honest. Right. All these sophistication behind move points, the direction that. Now the second part of what Henry is asking, which also had a question is like, under what conditions? Or do you have any plans to automatically generate move code from specification?
00:52:23.694 - 00:53:33.872, Speaker A: Yeah, not at this time. So my philosophy about formal verification is that it is if you're dealing with, we make a distinction between a requirements specification, which is a property that somebody else cares about, not just the developer, versus these things that I called boilerplate specifications that are used to prove more important properties. So for requirement specifications, I believe that it's useful to have somebody write them down independently of the code. So if we just wrote the specifications, automatically derive the code, we would miss the redundancy where you're comparing a specification with a code, which I'm going to stop sharing here. I don't know if you can see me, but maybe you can see me gesturing here. So one of the nice things about formal verification is you have this specification, you have the code, and you compare the two, and what you discover are discrepancies between the two. Sometimes writing the specification clarifies your thinking, and you go, oh, I have to go change my code.
00:53:33.872 - 00:54:13.070, Speaker A: Once you get it written. When you compare the two, sometimes you find a bug in your code. Frequently you find a bug in the specification. But even finding bugs in those specifications is valuable because it sometimes catches a misconception where you haven't thought something through carefully enough. So I'm not really pursuing automatically deriving move code from specifications. If you're doing that, you're sort of treating the specification like a high level programming language, right? And so the, it's, so we might end up doing that under some limited circumstance. We're definitely thinking about going in the other direction to reduce the amount of boilerplate.
00:54:13.070 - 00:54:32.974, Speaker A: So if you can take simple functions and automatically derive the post conditions for you, then, then you can use those in larger proofs. Right. Now, if you count off the number of lines of specification we have, most of it is postconditions and abort sifts. And if we could get rid of some of that, that's just a burden on the user. It's not necessarily worth thinking about if you could do it automatically.
00:54:33.634 - 00:55:25.894, Speaker B: But the question that Henry poses, because the similar question also moves, it raises two additional questions. Like one of them, both of them that I wanted to ask you, is like the high level synthesis, right? Ideally, imagine you go in a world that you want to have this system accessible to everybody. So me that on all programming I can create my own marketplace, my own company, what Shopify is pretty much doing, right? So you would like the average job to be able to write, move contracts. But the guy doesn't know the average Joe how to write move contract, doesn't even know c or even any script scripting language. So does this system. Automated high level synthesis assumes the product you generate is correct by construction. Right?
00:55:26.634 - 00:56:26.854, Speaker A: Yeah, I know what you're saying. So we haven't really been thinking. So first of all, when it comes to Ethereum and solidity, it's kind of a mistake to have the average Joe writing contracts because the average Joe can lose $100 million pretty easily. So, but if you, if you want to make the empower the average Joe, and I have nothing against empowering the average Joe, what you need to do is give the average Joe a collection of almost, you know, it's almost like configuring contracts rather than writing them from spreading. And certainly one could imagine a system where you have a very high level language. People do this, have done it for web programming for ages. Very high level language with maybe limited expressiveness, so that you can safely implement new functionality within certain bounds.
00:56:26.854 - 00:56:40.358, Speaker A: That's something that somebody may want to do for the DM blockchain. You could certainly generate move code or generate the bytecode directly, but we haven't gotten to worrying about that yet. We have more basic problems to deal with.
00:56:40.406 - 00:56:49.394, Speaker B: I understand. And the last question again comes from Kirthy. Can we expect additional type support for the move language?
00:56:50.934 - 00:57:24.666, Speaker A: Depends. You know, I expect, and I don't know if Sam would approve of my saying this, but it's just my, if you watch the development of any programming language, it takes a long time for it to settle down and a lot of people using it before they really figure out how to program in the language. And nobody gets it right the first time. So I'm expecting, as we do more applications and we get a larger user base remove that. There will be demand for more expressiveness in the language. And an obvious first place for that is new data structures. We don't have a general map type.
00:57:24.666 - 00:57:47.614, Speaker A: Now I would expect that, and my personal opinion, I would expect that one of the first things that would go in is a general maps and tables and sets and that kind of thing. And one could imagine many, many features that exist in other languages that aren't in move yet. So imagine over time the language will grow. And my hope is that the prover can keep up.
00:57:48.354 - 00:58:15.170, Speaker B: I see. And actually kit has another question. Maybe she can elaborate on it, but can we integrate move with other blockchains? Or do you guys focus only move as move to serve the DM ecosystem? Or do you also think, because like a language and verification system like that will be very helpful for many other, also public, possibly blockchains. Right?
00:58:15.242 - 00:58:58.944, Speaker A: Yeah, yeah, we think that's a great idea. We're not going to be working on it for a while because we're busy with other stuff and we could only offer limited help for other people who want to try that. I believe that there has been some discussion or experimentation with the idea of running move on Ethereum. Now the ethereum, from my personal opinion, the whole Ethereum instruction set is a bit funky too, not just solidity. So that may present some challenges. The other thing is the move blockchain. The DM blockchain is open source.
00:58:58.944 - 00:59:23.654, Speaker A: Other people could take it, modify it, repurpose it, borrow ideas and whatever. And one thing we are thinking about is how to get a clearer separation between the move platform and the blockchain itself. Right now they're rather intertwined and so some thought and effort is going into how to separate them so that the move virtual machine could be integrated into other applications.
00:59:24.434 - 00:59:32.586, Speaker B: I see. That would be very interesting and actually consider the work you guys have done very useful for the blockchain ecosystem.
00:59:32.730 - 00:59:41.730, Speaker A: So obviously we want to maximize the impact of our work. And so, yeah, in the long run we probably would like to see that.
00:59:41.762 - 00:59:53.974, Speaker B: Happen and most likely it will happen. Actually, can we reach out to the team? That's a question in case of support needed other than the one that you guys provided, GitHub.
00:59:56.394 - 01:00:33.012, Speaker A: I know you certainly can try. We're not going to make promises about. So we already have people, we have help going in the other direction. So we have people making suggestions for language improvements sometimes and we're submitting prs, although we want to offer some guidance so people don't waste their time implementing features we're not going to accept. And people reported bugs. There's somebody, I don't know who's testing their new fuzz tester on the move compiler and reporting bugs that way and whatever. We're definitely collaborating with people that way.
01:00:33.012 - 01:00:56.412, Speaker A: I think. Yeah, you can always ask and we can answer some queries and whatever. And if something, you know, if somebody had a move prover bug then, or a problem using the move prover, we might help if it was interesting enough. But right now we're busy trying to help ourselves so much. So.
01:00:56.428 - 01:00:58.372, Speaker B: So yeah. You understand? Yeah, yeah, yeah.
01:00:58.428 - 01:01:05.484, Speaker A: So we don't have a huge team and so, and we're obviously under great pressure to get this system launched.
01:01:05.644 - 01:01:06.316, Speaker B: I understand.
01:01:06.420 - 01:01:08.504, Speaker A: We don't want to take on more commitments.
01:01:09.164 - 01:01:16.708, Speaker B: How big is the verification team. I think Sam said the move language is like a dozen of people, right? That's what sample things are.
01:01:16.796 - 01:01:52.772, Speaker A: Yeah, probably including approver. So six people I showed you are working sort of full time, but not actually, it's probably five people kind of full time, except every once in a while people do other stuff. You know, I'm probably working on it 50% to 75% of the time because of other responsibilities. And Melvi and a lot of other people have similar, similar things going on. So that's a level of resources. It's better than the usual if you want to get a product out. It's better than the usual situation in academia where you don't have stable funding or the employees to do something like that.
01:01:52.772 - 01:01:57.264, Speaker A: But it's, we're not drowning in people. We don't have an army.
01:01:57.724 - 01:02:08.544, Speaker B: Yeah, I understand. So, resources. So any last questions from the audience? And thanks for everybody for participating today. Any last questions for.
01:02:09.444 - 01:02:33.246, Speaker C: I have one. David. It's not exactly about verification, but will diem treat open source software and software developed by others similarly to how Linux treats it? Because I'm just curious about like if someone puts out code and, and companies start using it and there's something wrong with the code, you know, there's issues about liability and indemnification, but there's a.
01:02:33.430 - 01:02:44.280, Speaker B: Patsy license, I believe the diem, the whole system is open source, it's Alliance Apache. So use it at your own risk, right.
01:02:44.462 - 01:03:36.738, Speaker A: Well yes. On the other hand, it's also the foundation for all the applications that members of the DM association will be running, even in the short term. So as I said, it's a high assurance system. And I quiver to think about tremble to think about a real open, really open source approach to something like that. So anyway, we have integrated other people's contributions, but we look at them very carefully and we have rejected contributions because there are things we didn't think were appropriate. I think somebody implemented reflection for move and that was an idea we really did not embrace. And so that's why I said to check before you invest a lot of time in something like that.
01:03:36.738 - 01:03:47.684, Speaker A: If you want your own private version of movement, that's fine, but it won't go into our repository unless we feel comfortable with both the technical direction and the quality.
01:03:48.864 - 01:04:00.444, Speaker C: So at least I could expect that if something goes into repository there would be some verification. It doesn't have to be automatic, but some qualification that the code is stable and they belong in your repository.
01:04:01.664 - 01:04:24.682, Speaker A: Yes. Now the legal issues, I can't really talk about. I'm just worried about the technical and financial risk. I have been thinking about the larger security issues. So we don't formally, we have a ton of rust code. We don't formally verify it. We've tried to identify what the most critical rust code is so we can put more thought into it than the rest of it, but it's really, really hard.
01:04:24.682 - 01:04:55.844, Speaker A: So rust loves to import crates from all over the place, and so keeping control of those dependencies is a significant challenge. And it's a new system, so getting it secure even without the. Well, I should mention that, you know, we're importing a lot of standard crates from Rust, and that's an open source system, and we probably don't even know everybody who's contributing to those, but we are trying to audit them fairly carefully and minimize, not, not use those kinds of crates unnecessarily.
