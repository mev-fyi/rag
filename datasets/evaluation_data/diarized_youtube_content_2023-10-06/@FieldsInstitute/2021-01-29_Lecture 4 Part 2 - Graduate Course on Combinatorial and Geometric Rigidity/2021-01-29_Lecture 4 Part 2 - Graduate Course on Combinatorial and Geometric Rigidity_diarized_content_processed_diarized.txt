00:00:00.240 - 00:00:58.390, Speaker A: Characterize generic rigidity in two dimensional space, and we characterize it as being minimal rigidity as being two free tight graphs. So I wanted to point out, I'm not going to prove, but point out alternative equivalent combinatorial characterizations. So the first one I wanted to mention is due to Henry Crapo. In 1990 he proved that g is minimally rigid in r two if and only if g has three subtrees, t one, t two, t three, such that every vertex of g is incident with exactly two of the subtrees. So this is a so called free t two characterization. So there are free trees and each vertex is incident of exactly two of the subtrees. And then, just to be careful, there is no vertex set x besides at least two, for which the subgraph of the tree induced by x is also a tree is a tree for at least two sub trees.
00:00:58.390 - 00:01:54.192, Speaker A: So this is a bit of a mouthful, but you can play about with this if you like. So it's free trees, and every vertex is in exactly two of the trees. So this is nice. And the second version is to notice that e equals 2 volts three is very close to e equals 2 volts two. And there's famous combinatorial results of tut and of Nash Williams, which tell us about graphs where it's in general, where graphs where e is kv minus k as being graphs that decompose into k edge disjoint spanning trees. I'm going to move this in case it means people can't see the corners, okay? And so if you make this observation, then maybe it's not so surprising. But the second version is that the graph is minimally rigid if and only if g plus uv.
00:01:54.192 - 00:02:43.424, Speaker A: And this uv could be a uv could be an edge that already existed. So it could be ended up be that g u v is a multigraph, or it could be a non edge either way. But this g plus uv should be the edge disjoint union of two spanning trees. But that needs to be true not just for some edge, but for all possible pairs of vertices in the graph. Okay, so these are just two alternative characterizations that are equivalent to the two free type condition. And given that we know the two free type condition is equivalent, actually proving these could be an exercise if you like. But I decided not to spend the time on it, and that's probably good since I'm now a bit further behind because of my technology.
00:02:43.424 - 00:03:48.114, Speaker A: Okay, so when you check the, the two free type condition, remember we have to check this for all x subset of v with x at least two. So we're checking. As g grows, the number of subgraphs grows exponentially. So there's a lot to check. So it might not seem at first sight like the two free type characterization gives a nice deterministic fast algorithm, but so I do want to mention a little bit about why it does, although I will leave really the details of algorithms in geometric constraint systems to Mira's course, to the overgraduate course, because we'll just have, I'll spend as much, say as much as I can in four minutes, plus maybe a bit extra on an algorithm for testing two dimensional rigidity, which really means an algorithm for testing two free tightness. Okay. Okay, so the algorithm, the credit for the algorithm initially goes to Bruce Hendrickson and Don Jacobs in 1997.
00:03:48.114 - 00:04:41.328, Speaker A: And they called this the algorithm the pebble game. And then there's a bit more recent paper by Audrey Lee St. John and Ileana Strainu in 2008 who they, look, I mentioned earlier that you have these two free sparse matrix because you can change it to various K's and L's. So they showed this algorithm also works whenever k and l are natural numbers and l is between zero and two k, strictly less than two k. Okay, so I'm going to be not hugely rigorous because I'm not an algorithms person, but I just want to give you the flavor of this algorithm. But I was hoping to spend quite a bit of time so it may not get through it all. So we want to test, we take a graph and we want to test two free sparsity or two free tightness.
00:04:41.328 - 00:05:19.764, Speaker A: So what do we do? We start with the vertex set of the graph and we put two pebbles on each vertex, so two counters on each of the vertices we can, we're going to test the edges in arbitrary order. The reason why that's good is because of the matroidal things, but I'm not going to worry about that. Just to say in the algorithm, you just pick edges in an arbitrary order and test them. When you come to some given edge, you look at the end vertices and you count the number of pebbles among the end vertices. If there's four, we're doing the two free type pebble game. So four is twice two. That's very generalized to the KL game.
00:05:19.764 - 00:05:56.834, Speaker A: If there's four pebbles exist among the end vertices of the edge, then you accept the edge e. And what that means is it will be deemed as independent. So it will be part of a nice sparse, two, three sparse subgraphs. And when you deem e to be accepted. Then you pick up one of the pebbles from one of the ends of the edge and get rid of it. And which end you choose to take the pebble from gives you a direction for the edge. So if you remove a pebble from u and e equals uv, then we have the edge equals uv becomes a directed arc from u to v.
00:05:56.834 - 00:06:35.472, Speaker A: Okay. If less than four pebbles exist, then we can't immediately accept e, but we still have a chance because we can do one other thing. We can search among the end vertices. Sorry. We can search among the rest of the graph looking for additional pebbles to move them to u or v. But we can only do this in a certain sort of way. So what, what you do, and it's going to be much clearer in examples, but we search for additional pebbles by following directed paths from u or from v, so you have to follow the directions.
00:06:35.472 - 00:07:11.084, Speaker A: If you can't follow the directions anywhere, then you can't find any more pebbles, even if lots of them exist and hence you're stuck. Okay? And I guess that's all about accepting an edge. So you can keep search, searching and searching until you've run out of possible things to search. If you get to four, you go back and you accept it and you direct the edge again and take a pebble away. But if it's not possible to get to four pebbles among the n vertices of some edge of your graph, then you reject the edge. Okay. And then after you've tested all edges and they've all been either accepted or rejected, the algorithm finishes.
00:07:11.084 - 00:07:53.086, Speaker A: So I wanted to do some quick examples. I know I'm going to run over time, but I hope people don't, don't mind that at least I can stay on my own for the video if people want to leave. Tony, before you do that, what's the end state? In the sense that if you've done everything and you've got some edges accepted or some edges rejected, what's the decision? Yes, sorry, that's what I'm trying to do with the example. So there's four finishing states that are possible. I'm going to do an example for each of the four you're going to see. I didn't formally there, but I do write it here, one, two and so on. So hopefully you will see.
00:07:53.086 - 00:08:39.938, Speaker A: But please ask again in a couple of minutes if it's not clear. So one possible end state is that the graph is two free sparse, but it's not two free tight. So that's something like this example where we know it's sparse but it doesn't have e equals 2 volts minus three. So what happens then? Well, in this case, because it's two free sparse, all edges will be accepted, but there will be more than three pebbles left. If there were exactly three pebbles left, you'll see in a moment that would be the sort of minimally rigid case. So how does the algorithm work? We start with our vertex set with two pebbles on each vertex. And then here, if you pick, say, this edge, I look at four among the neighbors, so I can pick one, get rid of it and direct the edge.
00:08:39.938 - 00:09:05.974, Speaker A: Or I could look at this edge, I can see I've got four pebbles, I can get rid of one and direct the edge. I can look at this edge, see, I've got four pebbles, get rid of one and direct the edge. And then again finally up here and get rid of this one. And so I've got more than three pebbles left. I have one at each vertex and I checked every edge. They were all accepted. So this is two free sparse but not too free tight.
00:09:05.974 - 00:09:37.588, Speaker A: So that was the case when all edges are accepted and more than three pebbles remain. Okay. And so I guess in the colors I just drew, what the final state that you saw there. The second option is you actually get two free tights. So I get two free sparse and exactly e equals 2 volts free. And so this is the case where all edges were accepted again, but now exactly three pebbles remain. So we can take the same graph we had before and add a diagonal.
00:09:37.588 - 00:10:09.094, Speaker A: So we add this one on and so we get to this as I just explained. And so now I want to test this diagonal, but I've only got one pebble here and one pebble here. So what I want to do is search along directed paths. So if I pick this vertex, I can't go this way because that's against the direction. So I have to go this way, I find this pebble and I bring that pebble to here and I change this direction. So that gives me this. Okay? And then that pebble is gone.
00:10:09.094 - 00:10:38.874, Speaker A: And so now I look at this vertex, it's got one pebble. I can't go this way against the direction, so I have to go this way, I find a pebble, take that one away, bring it to here by reversing this direction. And that's what you see here. So now I've got the four pebbles, I can put them, put the one in, get rid of one pebble from here. Now I've checked every edge was accepted and I've got exactly three pebbles left. So that's showing that the graph was two free tied. So that's the second possible end state.
00:10:38.874 - 00:11:15.134, Speaker A: What's the third one? So, same example, except I've added one more edge. Okay, so here, this is the case when exactly free pebbles remain but some edge was rejected. And what's the edge that was rejected? Well, in the example I did, it was this edge going across, because I've only got three pebbles left, so it's not possible. I can move some pebbles there and I can probably move some pebbles. Yeah, I can move some pebbles to each of these two, but I've only got three and I need four to be able to accept an edge. So the last edge was rejected. So that's three pebbles remain, but some edge was rejected.
00:11:15.134 - 00:12:01.760, Speaker A: Okay, so then there's the last case, which would be some edge was rejected and more than three pebbles remain. So this one's a bit more complicated and I'm already over when I wanted to stop. So if more than three pebbles remain and some edge was rejected, that's the case where you're not sparse. So it would be something like this was happening. But I'll let you do the examples for yourself. You're welcome to ask me if you this and with any of the other exercises if you want, but let me just finish by stating the theorem from Lee and Stranu, because it's one more thing I should comment on. So they prove the complexity of the version I just described to you is cubic in the number of vertices.
00:12:01.760 - 00:13:07.226, Speaker A: However, the real time sink, as far as I understand it, is when you have, say, 112 and you're trying to test an edge and you're going searching around to get a pebble to move to it, because you want to do a sort of depth first search among all different directed paths and try and find additional pebbles to come to it. So they also prove a speeded up version as a bit more complicated by looking at rigid components, so maximal, two, three tight subgraphs of your graph, and by working with them, there's a slightly clever version of the algorithm that runs that's quadratic instead. Okay, so I think I would like to stop there. I had planned to say a bit more, but I will come back to that another time. I will happy to answer any questions, but before that, let's let me advertise that on Monday, Lef Terrace castus will be giving the lecture in this graduate course. So he will talk about different types of rigidity and their equivalence. And so you'll have a guest lecturer who will not have the technology issues I've had today.
00:13:07.226 - 00:13:28.774, Speaker A: So hopefully. Sorry, I wish that would be the case. Yes. Yeah, fingers crossed. But yes. So if anyone has any questions, I'm happy to answer them. But otherwise left Harris will continue on Monday and then I will come back to whatever was next here, which was further recursive operations.
00:13:28.774 - 00:14:29.694, Speaker A: Whenever my next lecture is, I have a question tony. Sure. So is anything known about the orientations that wind up falling out of this process for a two, three sparse graph? So there are results about. So the, I can't remember if it's out degree or in degree. So there's standard orientation results that transfer these sort of counts in fact with k here rather than two, minus three or minus l into orientations with maximum out degree k or two in this case. So you do know that the, for example, I mean, I guess it's out degree because you think about it here, you're only going to take two pebbles off this edge. So it's going to have out degree is going to be at most two and then you're going to be reordering.
00:14:29.694 - 00:15:00.184, Speaker A: If you get any further pebble to here, you change the direction again. So the out degree should always be bounded by the two or k in general. So there are orientation results of this nature. I think the reference is Hakimi is the earliest paper on this sort of thing. I don't know if it's anything useful for the application, I guess you have in mind, but there is something on these orientations. Yes.
