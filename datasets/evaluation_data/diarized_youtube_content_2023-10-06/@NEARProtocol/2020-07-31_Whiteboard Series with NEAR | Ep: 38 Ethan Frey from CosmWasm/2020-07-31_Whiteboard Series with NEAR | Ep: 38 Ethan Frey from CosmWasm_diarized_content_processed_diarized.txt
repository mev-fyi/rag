00:00:04.410 - 00:00:20.960, Speaker A: Hello, my name is Nicola Gotti. I work at Nier and on the contract runtime and would like to introduce you Ethan Frey. Adam, tell us some words about yourself and what you're doing.
00:00:21.730 - 00:00:57.850, Speaker B: Yeah. My name is Ethan Fry. I'm the founder of Cosmos. I am coming from Cosmos if you've heard of the Cosmos IBC blockchains and worked in that 1718 some other projects around it and in 2019 got really excited about smart contracts. So started looking at that. So yeah, since summer 2019, I started a project called CoSM WASM, which is webassembly WASM smart contracts embedded in the Cosmo SDK. So it's basically all the tooling, there's go blockchain Cosmos, basically a construction kit.
00:00:57.850 - 00:01:12.610, Speaker B: And then we're embedding WASM contracts into that. So I actually can answer all the questions about tendermint and SDK as well because I spent time working that ages ago. But all I'm working now is basically runtime of that, the bindings to the contract and then the contracts themselves.
00:01:12.760 - 00:01:13.410, Speaker C: Okay.
00:01:13.560 - 00:01:28.140, Speaker A: And I think there are multiple blockchains supporting WASM contracts. So what would you say is differentiating cosmosm out of those?
00:01:29.150 - 00:02:08.786, Speaker B: Our biggest differentiator is we're not a blockchain. I think that's key. People ask us a lot to blockchain. Maybe we'll someday. But we are effectively a platform or a module to integrate into other blockchains. So what Cosmos idea is these people rejected ethereum, maximalism, everything around Ethereum and said rather than having one chain to rule them all, which was totally impossible, Ethereum in 2016 17, let's do a network of blockchains and connect them the same way the Internet scales horizontally. So that's where it comes from.
00:02:08.786 - 00:02:38.320, Speaker B: So what you have is you have a bunch of people building application specific blockchains. So the problem is writing a code. The hard fork for every upgrade is kind of tedious. You just can't upload contracts as issues. And smart contracts were a cool idea, so I added them into these. There are currently, I think, six, five, six blockchains in the Cosmo ecosystem that integrated our module into theirs, which means it runs inside of five or six blockchains currently in testnet. But yeah, it's running there.
00:02:38.320 - 00:03:00.950, Speaker B: I think neo took a different approach. They looked Ethereum and scaled it vertically. So you guys actually broke a lot of the barriers of 20 transactions a second. By making one chain, it can actually scale up to real world speed. So we've gone horizontally, a bunch of smaller chains to have decent throughput and they're connected horizontally over IBC inter blockchain communication.
00:03:02.010 - 00:03:14.070, Speaker A: Okay. And is cosmologne aiming to public blockchain only or you also want to connect private blockchains, like Facebook for example, libre?
00:03:15.390 - 00:03:42.820, Speaker B: Yeah, so that's a big question. Right now we're only looking at public blockchains because that's what we've seen. We looked at enterprise market. I think there's a huge market there actually, and in some way a business opportunity. They can use cosmosm, it's open for them to use Apache. And if someone wants to, I think we're not going that route ourselves because that's a lot of the private blockchain market requires different expertise. It's enterprise sales.
00:03:42.820 - 00:04:03.500, Speaker B: I can sell the startups, I can't sell the enterprises, I can sell the dev. So we look at that, and currently we're not looking at that. We're very happy. If someone else wants to integrate into those private chains, they're welcome to please talk to us. Okay.
00:04:05.310 - 00:04:40.210, Speaker A: If you want to integrate multiple blockchains in cosmos, I think they usually have their own runtime for execution of the contracts, including custom set of host functions. So for example, in case of webassembly, it's indeed a portable standard. So it's probably okay if you can execute the contract, but how do you emulate the behavior of the particular blockchain?
00:04:40.370 - 00:05:13.394, Speaker B: You're right, we kind of don't. We made an abstraction layer. So the funny thing is contest decay has one thing I really don't like about it, which they change. They make backwards and compatible changes like every six months. But that's a good thing too, because we have to use support in different versions. So we said quickly, on the same contract that runs in 37 should run of the class SDK, which has either minor to major changes, so we can't use their native functions directly. So we had to make an abstraction layer between that.
00:05:13.394 - 00:06:15.982, Speaker B: So what we currently do is we have abstraction for sending messages to other modules, which can be other contracts or native modules. We have an abstraction for querying other contracts or native modules. And we have a storage, local storage, and we have an API which are basically pre compiles. So what you can do is basically we offer a fixed set of functionality, which you've standardized more or less, which is bank module and staking module, a lot of their POS chains mostly. And when you call into it, takes your message from the contract, converts it into the native message format, calls into native code, takes a response and converts into the contract response. The same contract could run three different chains, possibly different versions of different staking modules, as long as they have an interface. So we define a common API, basically the change that's implemented and that's also limiting because you can expose extra.
00:06:15.982 - 00:07:10.630, Speaker B: And we added in recently about a month ago, because they're trying to integrate into a native chain that had its own swap kind of uniswap type and oracle treasury type functionality. Don't expose it. So we added a way of extending it. So basically we pass messages opaquely through our runtime. So if you want to extend your blockchain, your runtime, you can add handlers for different message types. And it's a custom message type which is basically this raw bytes we can then pass on to your blockchain, interpret it, and we allow custom messages and custom queries, which means you basically have this rust binding import a rust library, it says give you these extensions and you have the extension APIs and it also has a feature flag say okay, this contract only works in terra or only works in Regen, only works in Enigma because we're using these custom bindings. And then their blockchain handles those custom bindings.
00:07:10.630 - 00:08:06.710, Speaker B: So you can write a portable contract using the standard set which runs in all chains, or you can make use of custom features from that chain, but then you opt into them and your contract is only chain specific at that point. I can go into details on that sometime. It's a bunch of rust generics in there and then stealization and stuff. But yeah, it actually works pretty well. So we pass it basically from the wasm, cares about the format of the queries and messages, and then it takes everything to bytes, passes all the way through our virtual machine into a rust binding, into go library, into the go blockchain, through about three different packages, into the end user's code is not ours, and that then actually has a handler for these bytes to then handle them. And so basically input that both in your personal app and on the contract.
00:08:08.590 - 00:08:37.250, Speaker A: Okay, so it means you generally want to provide servers somewhat similar to what we have in a standard, like virtual machines, like in Java for example, when you can run the same Java application on multiple operating systems by commonizing their porting layer into some least common denominator.
00:08:37.910 - 00:09:10.650, Speaker B: Yeah, exactly. And you also allow using JNI to access the custom stuff with Java too. Actually, ideally if, let's say four chains, all in some version of Uniswap, I'll look for the Uniswap standard and off that in and they could all implement this unicorn standard to the same contract could use Uniswap, depending not carrying out whose kind of uniswap implementation it is and whether it's a contract native. So that's something I'd like to kind of go towards. But right now we just standardized the basic ones, which is moving tokens and staking.
00:09:12.690 - 00:09:36.274, Speaker A: Okay. Yeah, I guess the selection of the language for writing the contracts, especially in your situation, became very interesting problem. So what do you think about that? Do you believe that rust rules them all, or there should be multiple languages, or there should be some other language which is default? So what's your opinion on that?
00:09:36.392 - 00:10:04.034, Speaker B: Well, I started with Rust because the tooling, I had to learn Rust anyway for the tooling for Rust and wash is really awesome. And I actually learned rust on this project. I dabbled it before I'd written like a hobby project, but I'd never done a real project in Rust until I started working on this in the hackathon, actually coding it, luckily, with another Rust dev. But yeah, so I find rust cool. I've really grown to love rust. I think it's an awesome language, but it's not for everyone. That has a learning curve.
00:10:04.034 - 00:10:20.420, Speaker B: So I think maybe everyone will eventually get there. But I don't expect everyone to go there tomorrow. Right. And I hear a lot of people wishing to have. So I'm Cosmos SDK ecosystem. A lot of people program go and they want go. Other people talk about Javascript, not JavaScript, or they want.
00:10:20.420 - 00:11:01.262, Speaker B: Yeah, I'm actually, we were very inspired, so we saw parody first, their stuff as well. Russia saw near protocol, like, I don't know, last August or September, and saw they had assembly ship working as a first class citizen. And I was like, that's awesome. So I've tried a little about this stuff, and it's a very nice set that we guys have. I was very impressed by all the work you guys doing and taking user experience dev experience as the major point of utility. So I'm very inspired by that. So we are actually planning to add assembly script, some point and go support as well.
00:11:01.262 - 00:11:19.110, Speaker B: There's apparently a subset of go called Tiny Go, which compiles LLVM and makes WASM code. We have prototyped out minimal proof of concept. It does do a job. We'll see how much we can logically put in there. But yeah, it's definitely a plan of ours to add more languages.
00:11:22.970 - 00:12:03.780, Speaker A: But I think generally very serious distinction between languages lies in the area of automated or manual memory management. So if language semantics assumes automated memory management like Java Kotlin Javascript. Implementing it on a current WaSM runtimes could be very nontrivial. So do you believe that there is a place for languages with automated memory management in smart contract world?
00:12:04.150 - 00:12:48.654, Speaker B: Well, I think there are three ways of handling it. The first way is don't care. And you say we throw away the contract every time, right? So during one running of a contract, you probably don't claim that much memory back, right? If you run 100 times and you allocate and allocate and allocate. But unless you're really doing something weird, you probably don't keep allocating fifty k free, fifty k allocate fifty k free. Fifty k. And somehow manage to use 30 megabytes of ram by accident, because you're just in a deep loop in a washroom contract. So if you make a clean, fresh instance every time you run the contracts and throw it away at the end, it doesn't really matter, honestly, it's not WasI which actually keeps long living processes.
00:12:48.654 - 00:13:19.226, Speaker B: These run in a millisecond or two. They shouldn't use that much memory. That's the cheap answer. The second answer is, theoretically they're adding some sort of support for garbage collection memory manager in there. You could compile it in your contract itself, make it huge. You actually can have the garbage collector in your contract, right? Like you can do all that heat counting and you have that to sell. So you could kind of do that in your contract, probably hard.
00:13:19.226 - 00:13:55.480, Speaker B: Or you can wait for wasm to add support for the VM for that. Prefer, I definitely prefer having Russ and say, okay, cleans up the end. I know it's great. But I think definitely people want useful languages. They want to not worry about garbage collection. They don't want to write c, they don't want to write rust, they want to write something easy. And yeah, so I think it's our job building these runtimes and building these to figure out how to do that, and whether it is just clearing the memory out every time you run a contract, or whether it's somehow adding stubs to the garbage collection, that's our job.
00:13:57.950 - 00:15:02.540, Speaker A: Yes, actually, your first answer is very tempting, I'd say in many cases. Indeed, everybody knows that GC is not probably the most straightforward technology in software engineering. So if you can avoid it by just not doing that, it's looking deep, very much attractive. But what's interesting consequences of that action is the limitation of the nature, what the smart contract is. So it inherently became very computationally limited, so it cannot have essentially unbounded allocation and deallocation inside of its evolution. So we essentially put certain limits on a computation happening inside of a smart contract. And do you believe it's a good thing or bad thing?
00:15:03.070 - 00:15:24.740, Speaker B: Well I think it's really good. You want to limit everything in there. So I mean since a smart contract has to run on, I don't know, 20 to 100 machines in parallel and it blocks everything else. Well maybe it near doesn't maybe run in parallel. That's awesome stuff. But right now we're basically in the sequential model process one transaction, next transaction, next transaction. And since you do that you have to bound it.
00:15:24.740 - 00:16:11.780, Speaker B: We cannot have a contract running more than 510 milliseconds. Now really if we have contracts running 10 seconds doing stuff, then you have the whole blockchain for 10 seconds, which is not cool, right? So by the nature of having a sequential blockchain, this linear history, we basically have to have everything native or smart contracts. All code must fit under certain Linux. I think wasm outside of that context can do a lot, lot more. And actually the more I get into it, the more I see the potential of wasm not just in the web and not just in blockchains but everywhere. So wasi for example, system interface is like kind of this. I see the alternative of Docker in a way, right? You can have these sandbox objects which is to have a very clear interface of what calls I can use.
00:16:11.780 - 00:16:56.538, Speaker B: So it's actually really cool if you're building stuff like that, you need to have garbage collection or you need to have automatic memory management like in rust or c. So I think that case becomes really important. And so I see the kind of the binding, the conjunction of that come together in off chain workers. I know parity has that term, I use that term for them, off chain workers. So basically a blockchain triggers a task to run, a wasm task to run, it runs in parallel and it returns a result after, I don't know, one block, two blocks, three blocks. So you can do a longer task that runs in parallel to the rest of the transactions. And actually maybe you can tell me a little bit more near, because I think near allows some sort of parallelization like that as well.
00:16:56.538 - 00:17:16.920, Speaker B: But when you start allowing that parallelization and you no longer have to limit the code running time to ten milliseconds and when you say okay, this can run for 1 minute, that's fine, this code can run for 1 minute and when it's done it'll submit the result. And when all the nodes have finished running this code, they'll submit all the results back and we have them and we guarantee it's correct. Awesome stuff, great stuff.
00:17:19.070 - 00:18:36.850, Speaker A: That's exactly the direction I was heading. So if we talk about the smart contracts in the current form, then I raise two hands to support no memory management and stuff like that. But if we actually will think about stuff like smart services and essentially open web and smart services as a technology supporting that, then it probably means that what we think about like a very short time span and very primitive logic inside which is applicable to classical smart contracts, may not be really appropriate. The question is probably more like not even practical, but more strategic, in a sense. How do you believe will we need in the foreseeable future, smart services or smart applications, which run for relatively long time, need relatively significant amount of resources and be able to actually perform theoretical and bound computations?
00:18:39.270 - 00:19:15.360, Speaker B: It's a very good question. Very good question. I think I look for examples now, and I think there's things like running redis in WasA, which does you work, right, and it's also, it handles it. I think there's two levels, and the first level is like you're trying support contract platforms, try to be easy to write some code and deploy it, right. So I think one of the big goals there is to make a barrier of entry developer work to lower that amount. The barrier to entry should be really low. And we're achieving that, I think, quite a bit with.
00:19:15.360 - 00:19:45.410, Speaker B: We're achieving that quite a bit by adding other languages, by adding assembly script, adding go. If Kotlin is supporting it, that'd be awesome one day. I think a few of us have been looking at that one as well. Still in product in development, but I think that's great for making people use it. But if you say, if you want to write real services still, you're right. I think you're basically stuck with rust or c. To write real long running services and stuck with is not a bad thing, but it raises the bar of entry.
00:19:45.410 - 00:20:26.254, Speaker B: And so one really concrete example I can think of is running, for example, light clients. So if you want to run these in a browser anywhere else, that's a lot of logic, it's a lot of signature validation, a lot of math, sha hashes, trees, creating trees, subtrees. It's a lot of crazy stuff. And a lot of the code we have is available in rust. So there is like some in go and some in rust in our level. I think in yours all rust paradise love rust code as well. So this is quite available in rust and you could port that into some smart contracts, whether it's running in your browser, whether it's running in some smart service, which is sandbox.
00:20:26.254 - 00:20:51.366, Speaker B: That's awesome. And those pieces I think would have to still be written in rust for now. In the near future at least. And in the future they'll add maybe better garbage collection, better language support for other things. But I would basically say for one off, smaller things open up to everyone to try it. Use wasm and standard, and if you need to use things that are not in the standard already, I would just stick with rust for that. So I still want to make it a first language.
00:20:51.366 - 00:21:06.450, Speaker B: It's my first choice of language for coding. And I definitely think the majority of developers will probably not be on rust in six to months a year when they see an alternative. But yeah, I think I definitely want to have more rex contracts in Rust.
00:21:08.870 - 00:21:12.846, Speaker A: What was your other language before Rust? I'm just curious.
00:21:13.038 - 00:21:17.462, Speaker B: My last one is go, which is boring actually after a while. Okay.
00:21:17.596 - 00:21:20.694, Speaker A: And probably before go it was something like c or c plus plus, right?
00:21:20.812 - 00:22:13.400, Speaker B: I started with c and then we did java, like c, c plus plus as university build data structures in c, right? Do everything c and so like messing around with ulyx stuff back then late ninety s, then it was java, and then in the mid two thousand s I discovered Python Javascript, which is cool for hacking out websites because that was basically the work you were doing. Then in the late, not early ten s and quickly hit the limits. Once you started building real services on there, right, like 2012 1314, you start scaling up services rather than just little websites and you're like, this doesn't work anymore. So from there I went to go and yeah, I played with Rust, I played with Haskell. I definitely played them before. And Rust is the one that tracked me most. It had like the type system of Haskell, which I loved but not this.
00:22:13.400 - 00:22:34.286, Speaker B: Reading from disk is some weird I o monad that is like non normal operation. You can't consider it. That's really normal. You can't say interacting outside the world is not acceptable. This is such a special case. No, I think Hatch is wonderful doing math, but it definitely seems special case. Reading from ditch, not me.
00:22:34.286 - 00:22:38.640, Speaker B: Special case. So I love rust because it gave me all that power. I love the text.
00:22:40.850 - 00:23:25.870, Speaker A: Actually. My background was also mostly like c and c plus plus and other low level languages. And so for me getting used to rust was like a breeze. It's just a better c plus plus in my head. In a sense it I think indeed depend on the history on a trajectory of the person as a programmer. But I guess as for many people, the trajectory is actually start. So at least very seriously interact with web programming where it's typically like a GS or PHP for server side for them probably high level languages would be more natural.
00:23:27.330 - 00:23:28.400, Speaker C: That's agree.
00:23:29.170 - 00:24:01.510, Speaker A: Okay then, if you talk about promise of cosmos. So why do you believe in the fact that relatively limited set of primitives, I think you mentioned like send message, receive message and local storage, and that's about it. Why do you believe it's sufficient for writing nontrivial contracts?
00:24:06.190 - 00:24:53.658, Speaker B: Well, basically I think message passing, asynchronous message passing is sufficient to build everything. And in fact we can kind of reduce our entire system to asynchronous message passing if you're actually rendering them properly. They reduce synchronous message passing or like basically RPC calls and have all kinds of errors, because actually believe that messages come back in bounded times and promises actually resolve anyway. But if you go to this is back to super system design. Async's message passing is the fundamental of basically all distributed systems. The actor model has also been used heavily in building large scale systems that are supposed to be loosely coupled. And it looked inspired, not just in what did ethereum do? Because they did a great example, but you can't copy them.
00:24:53.658 - 00:25:27.666, Speaker B: I think they paved a beautiful path, ethereum, but they also did it with a bunch of assumptions. They made everything simpler, they made their way and they made their way. As we scale up to larger, more complex applications, what can we do? So being able to pass messages between contracts, information is way. And then the ACA model says, basically you have your own state, you don't order other state, you can do everything. It came to be a limit. And so the limit we hit briefly was you want to query something. So if I want to know my balance, do I have to send a message to query the balance, stop my transaction at some later time.
00:25:27.666 - 00:25:30.358, Speaker B: I store the fact I'm waiting for this message, another message comes back, and.
00:25:30.364 - 00:25:31.800, Speaker C: So it just seems too hard.
00:25:34.170 - 00:25:36.454, Speaker B: So we actually said, okay, I made an exception and we're going to allow.
00:25:36.492 - 00:25:43.238, Speaker C: Queries synchronously, but I think it's fine, which is kind of a break.
00:25:43.324 - 00:25:46.954, Speaker B: It's actually record everything on one chain. Before that it was basically much more.
00:25:46.992 - 00:25:58.702, Speaker C: Fluid, but I think it's basically what you have. You have a bunch of processes sending message back and forth, and they've built huge telecoms on that, the actor model.
00:25:58.756 - 00:25:59.760, Speaker B: That'S all it is.
00:26:02.210 - 00:26:40.906, Speaker A: Okay, but if we think about blockchains, there are typically at least two very important operations which I don't think naturally match to message passing. And one is essentially identity management, so that you need to understand under which account or address or whatever you execute your contract. And another one is the gas handling. So like attachment to execution, certain computational resource cost, and those operations are not.
00:26:41.008 - 00:26:43.530, Speaker C: Like, they're very unusual.
00:26:44.370 - 00:27:06.126, Speaker A: First is normal for computer science, but I think second one is somewhat unusual for the computer science for computation to actually attach to its computational complexity. But generally, both of them, I think, crucial for execution of smart contracts. So how do you handle such problems in Cosmo?
00:27:06.318 - 00:27:31.126, Speaker B: Well, you're right, there's a lot of things. So the first part I didn't mention all, is actually one thing we exposed. We don't expose callbacks, we expose environment object, which has the message cider sender, the contract address, the block height, the block time. One more thing, I think if any funds are sent with the message, if any native tokens are sent in the message as well. So a little bit like what is your environment?
00:27:31.158 - 00:27:32.618, Speaker C: What's your context you're called in?
00:27:32.704 - 00:27:49.454, Speaker B: It's a read only variable. The structure can read it. It's not even callbacks, just pass it as like data, uses data, parse it. And this is our context. So we give, of course, a context you're running in. That's very common concept everywhere, I think languages. So we give this context, tell you.
00:27:49.572 - 00:27:51.840, Speaker C: Who'S authorized, what user is running this.
00:27:52.690 - 00:27:56.386, Speaker B: The other gas handling it should be opaque to contracts.
00:27:56.418 - 00:27:59.974, Speaker C: They should not worry about gas handling. They run out of gas. They don't run out of gas, and.
00:28:00.012 - 00:28:31.440, Speaker B: It'S up to the caller to worry about that, and the runtime to worry about that. So I don't think contracts should have to worry about gas, and they definitely should not have. Their safety depend on the fact of whether and they can predict a gas limit for dispatching a subcall. And predictably have the gas limit of the subcalls be high enough to run correctly, but not enough to avoid reentercy. And so a large portion of ethereum contract security is based on the fact that you're basically well aware of the current gas and able to mutate limits of subcalls. When you send a message to another contract or call another contract, you limit its gas, so it can't hurt you.
00:28:32.130 - 00:28:35.710, Speaker C: Which I think is a detail. You should not have to worry about the contract developer.
00:28:35.790 - 00:28:37.202, Speaker B: So the runtime should make sure that.
00:28:37.256 - 00:28:39.074, Speaker C: The contract can't hurt you, basically.
00:28:39.272 - 00:28:54.694, Speaker A: So you believe it shall be handled like partially by just read only variables in a context and maybe partially by native for the blockchain part of the contract is about.
00:28:54.732 - 00:28:56.520, Speaker C: Right or not exactly.
00:28:57.050 - 00:29:03.254, Speaker B: Yeah. I don't know what context is to go inside there, so you could ask more context.
00:29:03.302 - 00:29:05.546, Speaker C: But if people decide they need to.
00:29:05.568 - 00:29:11.066, Speaker B: Know the app hash of the last three blocks in their environment, you probably.
00:29:11.088 - 00:29:13.420, Speaker C: Need some custom callback to that one. Right.
00:29:14.030 - 00:29:16.526, Speaker B: And they can query back in the blockchain. That's a query thing.
00:29:16.548 - 00:29:18.782, Speaker C: So you have this query, besides asking.
00:29:18.836 - 00:29:22.462, Speaker B: Messages, sending messages, you have a query which can query anything, query current state.
00:29:22.516 - 00:29:29.058, Speaker C: It'S a read only thing. So we pass these kind of standard messages, which is.
00:29:29.064 - 00:29:33.714, Speaker B: Yeah, the block heim type who send it. What was my contract? Who am I?
00:29:33.752 - 00:29:34.900, Speaker C: Right. Who am I?
00:29:36.950 - 00:29:43.506, Speaker B: And then query. Then query into whatever, anything else. And she could have a handler saying show me the last three block headers. That could be a custom query.
00:29:43.538 - 00:29:47.894, Speaker C: You add only works in your blockchain. I don't know else is really needed there.
00:29:47.932 - 00:29:51.046, Speaker B: So when I get to composition, so if you think of this composition, I.
00:29:51.068 - 00:29:54.074, Speaker C: Got into this and started building larger contracts. So we start getting things.
00:29:54.112 - 00:29:58.086, Speaker B: I have a multi sig contract that wants to call into a governance voting.
00:29:58.118 - 00:30:04.586, Speaker C: Contract that will then dispatch votes into decidus stake funds, for example. Right?
00:30:04.688 - 00:30:07.142, Speaker B: So let's say we have a staking to a contract.
00:30:07.206 - 00:30:13.438, Speaker C: And so that was owned by someone else. So all these things, they started building together recently, in the last month or.
00:30:13.444 - 00:30:16.046, Speaker B: So, two, three contracts tying together how.
00:30:16.068 - 00:30:18.480, Speaker C: They do it and.
00:30:20.530 - 00:30:37.334, Speaker B: Adding that the query thing calling back is really important to add that. So you could actually find out the state. Show me all the validators before I bounce a validator. Show me all the validators and then you can pick one of those and then do a bound to validator as one of the highest best rewards, the one I bind to.
00:30:37.372 - 00:30:37.622, Speaker C: Right.
00:30:37.676 - 00:30:40.694, Speaker B: And so your logic can be there, find the best one and immediately just.
00:30:40.732 - 00:30:44.378, Speaker C: Dispatch message, do that and that's enough, really.
00:30:44.464 - 00:30:46.006, Speaker B: I'm still working on a good framework.
00:30:46.038 - 00:30:47.274, Speaker C: To do it right now.
00:30:47.472 - 00:30:49.514, Speaker B: I do integration test at the high.
00:30:49.552 - 00:30:51.386, Speaker C: Level, at the very high level, which.
00:30:51.408 - 00:30:54.718, Speaker B: Is kind of running the blockchain altogether. So I'm trying to figure out how.
00:30:54.724 - 00:30:56.830, Speaker C: To unit test integrations like that.
00:30:56.980 - 00:30:58.778, Speaker B: That's currently, well, I have ideas that's.
00:30:58.794 - 00:31:05.758, Speaker C: Still work in progress, so it needs to happen. But I haven't found issues like the.
00:31:05.764 - 00:31:06.754, Speaker B: Most I've tried to figure out.
00:31:06.792 - 00:31:09.086, Speaker C: The current one I'm working on is callbacks.
00:31:09.278 - 00:31:13.246, Speaker B: So the way I do it is different. I should like to hear near's explanation.
00:31:13.278 - 00:31:17.166, Speaker C: A bit more here. We explicitly avoid reentrangency.
00:31:17.198 - 00:31:31.826, Speaker B: She took the actor model to avoid reentrancy because, well, 60% of all theory attacks are reentrancy. And so let's just get rid of reentrancy. So force people to think a little more firsthand. Which means reentrancy basically is my contract.
00:31:31.858 - 00:31:34.746, Speaker C: A calls contract b, but has state.
00:31:34.768 - 00:31:42.458, Speaker B: In memory, not in disk, right? And then contract b calls back into contract a reading and say off disk, which is different than state memory, right? So let's say I have 100 tokens, okay?
00:31:42.544 - 00:31:47.806, Speaker C: I lower the memory by 100, raise your balance by 100 in memory, and.
00:31:47.828 - 00:31:49.726, Speaker B: Then call some other contract, sending it to it, right?
00:31:49.748 - 00:31:54.186, Speaker C: This one calls back again, says, send my 100 tokens again and lower yours.
00:31:54.218 - 00:32:14.920, Speaker B: And it keeps doing that, and everyone sees that. And eventually just write my zero for my balance and have now incremented ten different balances each by 100 tokens, and then just have a zero in my balance. So that's reintroduce in short. So it's really tricky. And so basically the way to avoid it is save all state before you call out. So when they call into you, they only see everything saved. You'll have a different memory and state.
00:32:15.450 - 00:32:17.240, Speaker C: When someone else calls into you.
00:32:17.850 - 00:32:20.102, Speaker B: So we did the actor model, which forces that basically.
00:32:20.156 - 00:32:27.818, Speaker C: So before, when you are modifying state, you have to persist all your changes and return a message. And the message will be dispatched to.
00:32:27.824 - 00:32:30.060, Speaker B: Another module and can just change state.
00:32:30.430 - 00:32:33.258, Speaker C: So only they can't change state and.
00:32:33.264 - 00:32:35.646, Speaker B: Call into you while you're changing state. Only one thing can change state at.
00:32:35.668 - 00:32:37.680, Speaker C: A time, and you can't have a call down.
00:32:38.610 - 00:32:40.974, Speaker B: So using that model, it works pretty well.
00:32:41.012 - 00:32:51.474, Speaker C: Most things can blindly be it. And our re handling is if their message failed, revert the transaction. If it exceeded, keep the transaction. And that works pretty well. The failure mode is.
00:32:51.512 - 00:32:53.378, Speaker B: You really don't need to know what happened when you dispatch it.
00:32:53.384 - 00:32:58.260, Speaker C: You just know it worked, right? The failure mode is right here.
00:32:58.790 - 00:33:01.186, Speaker B: If contract a in the constructor contract.
00:33:01.218 - 00:33:07.366, Speaker C: A wants to create a contract b, let's say I want to create a token contract. The token contract wants to have.
00:33:07.388 - 00:33:10.486, Speaker B: I'm the minter, the code of contract, right? So I said the minter, I create.
00:33:10.508 - 00:33:13.338, Speaker C: Contract b that has a minter, right, a b.
00:33:13.424 - 00:33:14.954, Speaker B: But this token a needs to know.
00:33:14.992 - 00:33:18.026, Speaker C: Who the minter is. I can draw this awayboard better, probably.
00:33:18.208 - 00:33:20.558, Speaker B: And that's this kind of callback thing.
00:33:20.644 - 00:33:24.062, Speaker C: Yeah, I just want to say that.
00:33:24.116 - 00:33:30.430, Speaker A: Maybe to explain it better. You can use whiteboard. That's the whole point. Purpose of having whiteboard.
00:33:31.250 - 00:33:58.034, Speaker B: Cool. So let's do this now. Let's go to here. So this is actually I think a very interesting one and I'd love to see it here. So we have, I'll pick a few colors here, hopefully not too ugly. And so usually we basically just say this is, this is some sort of defi contract.
00:33:58.082 - 00:34:10.860, Speaker C: Yeah, swap contract, ever market contract. And this is some token contract. Yeah.
00:34:15.790 - 00:34:20.046, Speaker B: So usually what happens is if the DeFi contract says move money, it will.
00:34:20.068 - 00:34:30.834, Speaker C: Just say this is fine, it will go, this is what you handle properly, I guess. And it will say something like send.
00:34:30.952 - 00:34:42.822, Speaker B: Ten tokens to zero x. Right. And when it does that one, all you need to worry about is either the tokens got sent and they didn't get sent.
00:34:42.876 - 00:34:47.526, Speaker C: Right. So I'll change my balance to defi contract based on whether or not this worked.
00:34:47.548 - 00:35:00.838, Speaker B: If it doesn't work, then I revert my changes. I don't close order book. If the order couldn't be claimed, then I revert my changes here. So I change my orders here, send ten tokens and then it works or doesn't work, and I revert the whole transaction.
00:35:00.854 - 00:35:02.522, Speaker C: I don't, that's fine.
00:35:02.576 - 00:35:04.414, Speaker B: And the whole idea of message passing, it works.
00:35:04.452 - 00:35:12.458, Speaker C: I make my changes optimistically and dispatch other messages. And if anything fails, overt the whole transaction, which is actually the proper error.
00:35:12.474 - 00:35:17.794, Speaker B: Handling in like 98% of the cases. And we don't need to add more.
00:35:17.832 - 00:35:22.802, Speaker C: Too much more to it. That's fine.
00:35:22.936 - 00:35:37.432, Speaker B: And now what we look in other cases, this is actually create token contract.
00:35:37.496 - 00:35:47.890, Speaker C: Yeah. With minter. And let's say this address here is.
00:35:49.300 - 00:35:50.976, Speaker B: So we create a contract, right?
00:35:51.078 - 00:35:51.584, Speaker C: Yeah.
00:35:51.702 - 00:35:53.216, Speaker D: So we create this token contract, the.
00:35:53.238 - 00:35:55.392, Speaker C: Minter, and that's great.
00:35:55.446 - 00:35:59.476, Speaker B: But the problem is the Defi contract never knows how to get the minter address.
00:35:59.578 - 00:36:00.852, Speaker C: It needs to have the token address.
00:36:00.906 - 00:36:02.116, Speaker B: There is no address when it creates it.
00:36:02.138 - 00:36:07.396, Speaker C: Right address. So this then at some point needs.
00:36:07.418 - 00:36:14.052, Speaker B: To say, okay, now we format is we call, we got a new address here.
00:36:14.186 - 00:36:25.210, Speaker C: And then somehow they, it just got traded.
00:36:40.450 - 00:36:48.222, Speaker B: Okay, so this is a standard call. And this is one case when you really do want to have this back and forth RPC style call.
00:36:48.276 - 00:36:48.446, Speaker C: Right.
00:36:48.468 - 00:36:56.434, Speaker B: It'll be nice. So what we've done is basically callbacks. It's a little complex in this case is actually, we say, not very common.
00:36:56.552 - 00:36:57.986, Speaker D: It's not uncommon, it's not rare, but.
00:36:58.008 - 00:36:59.090, Speaker B: It'S not very common.
00:36:59.240 - 00:37:03.126, Speaker C: So we're trying to make it more optimal, but currently, basically what you have.
00:37:03.148 - 00:37:04.230, Speaker B: To do is you send a message.
00:37:04.300 - 00:37:09.734, Speaker C: Here to the coke contract saying make a contract, contract, and a callback saying.
00:37:09.772 - 00:37:11.494, Speaker B: When you're done instantiating, when you finish.
00:37:11.532 - 00:37:14.860, Speaker C: This contract, call back to me and tell me your address.
00:37:15.390 - 00:37:29.070, Speaker B: So that's basically how we're working on it and trying to make better support in the runtime for this flow. And so what that is, is basically for us the way it looks like if you want to see it is init contract.
00:37:30.770 - 00:37:39.070, Speaker C: Defi contract, returns, init contract.
00:37:40.230 - 00:38:09.690, Speaker B: Message, then token contract. So that's a flow in three steps. Do you see that, Ralph?
00:38:11.230 - 00:38:11.980, Speaker D: Yeah.
00:38:12.590 - 00:38:21.374, Speaker B: So we have this three step, it could be a promise, another way, another setup. So that's one place we pit a limits here, but basically it's just a little more work.
00:38:21.412 - 00:38:46.630, Speaker A: Yeah, I just want to say that it's a typical continuation passing style. So instead of along with the call, you pass the control flow. This is not a callback in a classical sense, it's more like a continuation. You just ask. Okay, so this is what you're going to do next. The calls doesn't have to be put in a stack. Indeed, they can be arbitrary routed.
00:38:46.630 - 00:38:49.894, Speaker A: That's pretty much what you do.
00:38:50.012 - 00:38:53.882, Speaker B: Yeah. To say, tell this address what your name is.
00:38:54.016 - 00:38:54.634, Speaker C: Okay, good.
00:38:54.672 - 00:38:55.706, Speaker B: So I'll tell the address what your name is.
00:38:55.728 - 00:39:08.170, Speaker C: I'm done. I'm going to move a second, it's trying to rain. Here's.
00:39:11.710 - 00:39:13.020, Speaker B: Okay, keep talking.
00:39:13.710 - 00:39:15.280, Speaker D: I turned the video for a second.
00:39:16.290 - 00:39:30.062, Speaker A: Oh sure. At least the computation which going on here is a very typical asynchronous computation.
00:39:30.206 - 00:39:30.900, Speaker C: Exactly.
00:39:31.750 - 00:39:44.666, Speaker A: And what you do here requires certain computation models. So these calls are not actually calls, they're more like indeed message passing in.
00:39:44.688 - 00:39:45.610, Speaker D: The continuation.
00:39:49.390 - 00:40:40.460, Speaker A: Pretty well, but maybe not so common to many programmers today. I think I know that at least 13 is some form of like coroutines in Kotlin, for example, is an example of simple CPS continuation passing style callback represented in more natural way. But I guess for distributed asynchronous systems like the blockchain, especially the network with the cosmos, what we have is very, it's not normal to be synchronous. So asynchronous is absolutely expected behavior. But it also means.
00:40:44.270 - 00:40:45.098, Speaker D: In a typical.
00:40:45.194 - 00:41:16.050, Speaker A: C or python or Java program calling is a very cheap operation. And I guess it's no longer the case for the contracts calling each other. So calling someone else can be expensive, it can fail, it can break for multiple reasons. Whenever you program, you can always be prepared that this call didn't succeed. And this probably have to be expressed in a development tools.
00:41:16.210 - 00:41:22.146, Speaker D: So yeah, we want the language to capture that. So the point is, right now we still do it synchronously.
00:41:22.178 - 00:41:24.382, Speaker C: We do this mainly for guarding reenterency.
00:41:24.546 - 00:41:36.654, Speaker D: In the local model. But with IBC you actually have these unbounded message passing. So basically every contract, an IBC basically say I will commit intent to call.
00:41:36.692 - 00:41:38.350, Speaker C: This contract on my blockchain.
00:41:38.930 - 00:41:45.646, Speaker D: That then has to relate to another blockchain process. Another blockchain result has to happen at blockchain. The message that one comes back to.
00:41:45.668 - 00:41:46.980, Speaker C: Us is really back to us.
00:41:47.350 - 00:41:49.534, Speaker D: That could take 10 seconds.
00:41:49.582 - 00:41:52.260, Speaker C: It could take three days, I don't know.
00:41:53.190 - 00:41:58.660, Speaker D: You are guaranteed to eventually get either an error or a.
00:42:00.470 - 00:42:01.358, Speaker B: Basically not guaranteed.
00:42:01.374 - 00:42:17.690, Speaker D: You're guaranteed an error or result back from it as long as other blockchain progresses. So you have a timeout for two days, for example. And you have to see the other blockchain has passed high x. The other blockchain has high x without ever processing your result. Then we know your result will never get processed. So we could just call it a failure.
00:42:18.590 - 00:42:20.474, Speaker B: So it has this and that message.
00:42:20.512 - 00:42:35.306, Speaker D: Passing is this message passing. So you return a message to be processed and then you don't just say, well, if it fails, my transaction rolls back. I actually have to hold intermediate state. It's one level more complexity. So I have maybe this message in process. I have ten different, 20 different messages.
00:42:35.338 - 00:42:37.946, Speaker C: In process and waiting for the results.
00:42:37.978 - 00:42:46.002, Speaker D: And maybe they get rolled back. So if I want to send money from you to some other thing, I say, well, your account balance is reduced in some temporary state.
00:42:46.056 - 00:42:46.414, Speaker C: Reduced.
00:42:46.462 - 00:42:51.394, Speaker D: We have this temporary callback state here. And if the other one succeeds, then.
00:42:51.432 - 00:42:53.526, Speaker C: Great, then I actually remove it.
00:42:53.548 - 00:43:08.678, Speaker D: And if I don't, then I return it back to your account because it failed. So that's another level of complexity which we will be adding in the next month. When you have IBC support is getting ready for production. We're still waiting for the underlying IBC support in the underlying SDK.
00:43:08.774 - 00:43:10.060, Speaker C: We're working on that one.
00:43:11.150 - 00:43:20.542, Speaker D: We're working that, but that will have to take the same message. So we want to build all the tooling around this concept of sending messages around and not just calling into it.
00:43:20.596 - 00:43:27.470, Speaker C: Because we need a conceptual understanding there to be able to build multi chain contracts.
00:43:27.890 - 00:43:33.442, Speaker D: I'm also very curious how you promises. You have multiple shards and you had promises over that. So I'm curious how you abstract that.
00:43:33.496 - 00:43:59.050, Speaker A: Yeah, so I think promises is rather weak form of CPS programming, which paradigms do you actually use in your SDK? Is it actually futures promises? Or maybe something closer to coroutines or maybe something closer to, I don't know, like traditional callbacks.
00:43:59.870 - 00:44:16.046, Speaker D: It's pretty raw. Return messages. So interface here if you something like this handle takes environment called dependencies environment the message, yeah, and returns basically a.
00:44:16.148 - 00:44:20.834, Speaker C: Vec of, we call them cosmos message, more or less.
00:44:20.872 - 00:44:35.142, Speaker D: That is what we have. If you're following here, this means we take the, basically depth is basically our storage access or API access. Query environment is as I mentioned, the block height, who's calling it a message is our data. We call it into it.
00:44:35.196 - 00:44:36.358, Speaker C: This is our thing.
00:44:36.444 - 00:44:49.050, Speaker D: And return a set, there's an error as a result. Actually not this, it's something result. It's actually a little more complex than this, but it can error or concede if it's deceived. It returns a list of messages.
00:44:50.910 - 00:44:51.274, Speaker C: And.
00:44:51.312 - 00:45:17.406, Speaker D: That'S all you do. So this actor model, right, turn it, and then the runtime takes messages and dispatches them in the same transaction. And those, you also dispatch other ones. It keeps running till it runs up gas somewhere along the lines or it's finished. All the messages on the stack and then it's finished. And if everyone succeeded and they've all processed it, then it goes and says, commit. This transaction is successful if anywhere along the line it runs out of gas, or one of them says, hey, I don't know how to this message, the whole transaction fails.
00:45:17.406 - 00:45:24.114, Speaker D: So you can build large systems. But yeah, of course anything failed. The bigger and bigger it is the easiest one thing to fail.
00:45:24.242 - 00:45:25.926, Speaker C: And then same thing, ethereum, we can.
00:45:25.948 - 00:45:27.910, Speaker D: Call it other contracts, it runs up gas somewhere.
00:45:31.230 - 00:46:18.200, Speaker A: I have two related questions for such a primitives. How do you expect people to reason about them? And how do you expect people to test them for complex scenarios, like for example, when only one of the messages failed and so on. I think the hardest part about such vectors would be probably correct handling of all the possible outcomes, both in reasoning part and in testing part about some systems. It's very hard to reason, and sometimes when you reason right, you cannot test it properly. That's a problem.
00:46:19.450 - 00:46:26.874, Speaker D: If one thing fails, doesn't matter, because if any fail, we wrote the whole transaction. So we make basically a snapshot of the database and you're working on a.
00:46:26.912 - 00:46:27.690, Speaker C: Cache.
00:46:29.390 - 00:46:56.340, Speaker D: Temporary database and temporary transaction, and the whole transaction gets rolled back if any of those messages fail anywhere. So you can write that message saying, I can make these changes optimistically, assuming those messages are going to all succeed because if those message fail, then what I did got rolled back. So I never handled this. Right. So that's our assumption. Our critical assumption is if anything fails, the whole thing rolls back.
00:46:57.270 - 00:47:38.994, Speaker A: Yeah, right. But how about composability? So imagine you wrote a contract which has certain set of outcomes, but it is being called from some other contract. And so as a result, even if the inner transaction is not failing, the whole transaction fails. So to make a synchronous system like that composable, so that you can actually reason about, how do I call from function a? Function b. So function b always work. Your whole system must be composable. So it's not always that.
00:47:38.994 - 00:47:47.940, Speaker A: This is like a top level call which is performed on a button click by user. It sometimes may happen as a result of some other software call.
00:47:48.550 - 00:48:04.278, Speaker D: So you're right. That's one thing you tested. So right now, the test we have is basically we launch in the blockchain, run those contracts together, and I'm working on now is integration test. Actually even in rust unit test, not even wasm, just run those and say, like, I have these five different contracts.
00:48:04.374 - 00:48:07.514, Speaker C: I want to string them together in this way, right?
00:48:07.552 - 00:48:25.822, Speaker D: I assign these contracts to the addresses, and whether this is malicious ERC 20 token contract on this address, or it's a good contract or whatever else, I can assign these addresses and then run the test on that. So that's what we're working on right now. One thing working on to allow this integration test levels to happen, easier for testability of it.
00:48:25.876 - 00:48:27.374, Speaker C: So it's not hard.
00:48:27.412 - 00:48:35.922, Speaker D: All you basically say is you set up a system with this code and this state assigned to each address. So basically an address, a contract is.
00:48:36.056 - 00:48:40.098, Speaker C: A set of bytecode and a set of state, the current state, so you.
00:48:40.104 - 00:48:50.726, Speaker D: Can initialize them all and set the current state of these ones and then run that and just have a little small mock runtime in rust so we can run it the same test as.
00:48:50.748 - 00:48:52.486, Speaker C: Their code, which would then basically take.
00:48:52.508 - 00:48:59.450, Speaker D: The messages, redispatch them, handle the errors, roll back the whole thing on failure. So I'm working on that one, and it's definitely testable.
00:49:00.030 - 00:49:03.078, Speaker C: It's hard to work with some types.
00:49:03.094 - 00:49:16.398, Speaker D: To making sure they're all nicely abstracted, but the concept is totally testable. What I feel is basically writing it, that people remember how to write it. It's not natural, I guess, if you.
00:49:16.404 - 00:49:17.614, Speaker C: Used to calling contracts, right?
00:49:17.652 - 00:49:37.366, Speaker D: If you used to calling it, it's not natural. I just want to call this thing. Why I have to return a message that does a thing. It's more of a mental, I think it's more of a buried entry than a reasoning thing. In the end, basically, I assume that all those calls at the end of it basically are just saying, do this.
00:49:37.388 - 00:49:39.654, Speaker C: If error fail effectively, what you have.
00:49:39.692 - 00:49:44.938, Speaker D: Is you just call this message and a question mark operation at the end of it is what you're doing at.
00:49:44.944 - 00:49:47.020, Speaker C: Your end of your end of your code.
00:49:47.790 - 00:49:54.060, Speaker D: So something is harder to reason about these contracts than calling them.
00:49:55.790 - 00:49:56.394, Speaker C: Because, yeah.
00:49:56.432 - 00:50:19.486, Speaker D: This same call stack everything, call stack testing is definitely harder, but you need runtime for it. And that's one thing we're working on now. There are some people have built, actually, a funny tool called simulate, which will take these contracts at addresses and then you can interactively send messages them and try it out manually. I want to make it more unit testable, very low level unit testable to get plus tax races. But yeah, so we have some tools.
00:50:19.518 - 00:50:20.838, Speaker C: On that right now.
00:50:20.924 - 00:50:27.030, Speaker D: Most of my tests are basically running in the blockchain and then running go tests against a go blockchain with these contractions installed.
00:50:28.570 - 00:50:53.146, Speaker A: And actually, a related question is about debugability of. I think it's a pain point, not only for any particular blockchain, but I think almost all blockchains suffer from hardness of debugging anything untrieverals. Do you take any special measures here in area of debugability?
00:50:53.338 - 00:51:18.626, Speaker D: I try to make everything testable in unit tests, so I use rust unit tests. So I like the context. I found out they can compile them as rust and just run them. And you have full stack case and everything's beautiful, and then you run it in integrate, you compile to wasm, and then you run that in a little runtime and suddenly you get like just VM failed when it panics. So a divide by zero error, which would be actually give you a panic in rust, will just give you vm failed, because if you divide by zero vm, it'll just kill the VM, the trap.
00:51:18.658 - 00:51:19.814, Speaker C: And then you don't get a message.
00:51:19.852 - 00:51:32.818, Speaker D: You don't know why. Right. So the panics and stuff like that inside the wasm become opaque, which is really annoying, actually. So I try to budget on those, and when you see anything like that, all you have to do is for me, I look for any unwrapped statement.
00:51:32.854 - 00:51:34.894, Speaker C: Or anything you can possibly panic and.
00:51:34.932 - 00:52:05.426, Speaker D: Just look for those and it happens. So I like having the rough testability. The other thing we do for testability is we took JSON, which is a much maligned. And actually, I personally also maligned it, but universal and human readable format. So all our messages are in that format, and the return value is too. So if you look at the MSG here and handle is basically this is just a serialized JSON. It's an object, actually parse it here, but it's passive.
00:52:05.426 - 00:52:42.226, Speaker D: The wire is JSON, and this causes message is another object that serializes JSon. So you could easily add in, and maybe I should do that as a log level into the runtime. So every time you call a contract, it says what the call is, and every redispatcher can be there. So you can log saying, I called defi contract with this set of arguments, it dispatched, create token contract with this, have arguments, get token contract was called this argument, and it called informed created on the defi contract with this EV arguments, and you can print that all out. It's not in binary, so it's pretty.
00:52:42.248 - 00:52:43.870, Speaker C: Easiest to print in log files.
00:52:44.030 - 00:53:12.300, Speaker D: So that's one thing we've definitely had for debuggerability. And I turned it off a while ago. It was definitely as early on as printing a lot of these JSON documents just straight up and reading them as I was running stuff. But since it's been stable for a while and testing of everything, I turned all of it off. But for these big composition, maybe it's interesting to turn a log level back on so people can run the blockchain with a high level log level and see all the messages going back and forth between them and recreate what happened.
00:53:16.050 - 00:54:01.130, Speaker A: Okay, that's pretty nice that you have at least this kind of development instrument. On our previous whiteboard session, we were discussing, sorry, we were discussing their runtime verification as a mechanism of solving, at least partially the debugability problem. So do you believe in any of formal verification in your system? Or maybe you already do have some additional checkers which simplify the development of smart contracts?
00:54:01.710 - 00:54:34.040, Speaker D: Form verification is beautiful. I love it. And I think right now I saw some talks from people doing that, and it's really cool stuff. Actually, it wasn't directly, but having a JSON parser in there, or a borsche parser, any parser, basically blows up the whole thing, right? So if we're passing eight byte un 64 over a call, and we can mock that out, but if we're passing large serialized office and parsing them, the verify clues is serializable parser. So I think it would make sense to take, if you have actually.
00:54:35.850 - 00:54:36.214, Speaker B: Some.
00:54:36.252 - 00:54:45.574, Speaker D: Math you could take the actual logic inside of it and formally verify some subset of that logic. Again, in rust, not in Wasm, because compiled Wasm would include all the serialization.
00:54:45.702 - 00:54:47.706, Speaker B: Stuff on top of it, and the.
00:54:47.728 - 00:54:49.834, Speaker C: Hooks and the memory management, all that stuff.
00:54:50.032 - 00:55:22.178, Speaker D: So it seemed pretty hard to formally verify the actual wasm. The rust itself is interesting, and I would definitely love to see if you could pull out just the functional parts you're doing and formally verify all of those. And maybe that's doable. I'm not sure. Last time I tried doing formal verification stuff was basically with liquid Haskell and interest, which is a very different system than rust, and that's cool. Dependent types is cool. I think it definitely can do a lot of stuff and found some interesting bugs can prove mathematical theorems.
00:55:22.178 - 00:55:35.558, Speaker D: A lot of this stuff, however, I feel is smart contracts often more business logic than math. So I can prove I have a b tree that maintains certain invariants. But proving what are the invariants of a unisoft contract?
00:55:35.654 - 00:55:40.170, Speaker C: What are the invariants of it? What must it ever fail? I'm not sure.
00:55:40.320 - 00:56:23.490, Speaker D: It will go up and down, the price will go up and down the mountain, money reserve will change. Is there an invariant? You can mathematically say this invariant must always hold true forever for this uniswap contract? And then we can guarantee that if the state is in this state and this transition happens, you'll always remain in this state, and those invariants will always be true. So I think you need to find those mathematically. And I think for many smart contracts we're developing, you don't really come from the mathematical proofs. You're not coming from mathematical objects, you're coming from some business domain, and you're trying to turn business logic into a contract, which is fine. That's basically what we're doing. Most of the stuff is building apps and business logic into contracts, and for that, formalification, for me, seems overkill.
00:56:23.490 - 00:56:59.102, Speaker D: It makes sense if you have a rocket that's going to a moon, and there's very clear mathematical proof of what you need to do everywhere. It makes sense if you have a binary tree or you have a database, possibly, which has very strong controls of what it should do, it should commit in this order. It should never fail this thing. If transactions shouldn't have two parallel rate of the same data without causing some rollback somewhere, the lock should maintained. So you can have a set of invariants that must hold true for your database. Any possible this corruption state, you should either be able to repair the corruption or be able to detect it's corrupted.
00:56:59.166 - 00:57:00.142, Speaker B: It will not blindly.
00:57:00.206 - 00:57:05.382, Speaker D: Right. There are things like that, like quick.
00:57:05.436 - 00:57:08.198, Speaker C: Test in rust, which does some cool.
00:57:08.284 - 00:57:09.766, Speaker D: Checks like that to fuzz your stuff.
00:57:09.788 - 00:57:09.974, Speaker C: Right.
00:57:10.012 - 00:57:17.130, Speaker D: Which I think is actually an interesting way of doing some large testing, which I think will cover a lot of what people want to do with formal verification.
00:57:18.270 - 00:57:18.682, Speaker C: Right.
00:57:18.736 - 00:57:27.450, Speaker D: So I think that would be cool. I'd love to have quick check tied into these basically systems of contracts.
00:57:27.530 - 00:57:27.918, Speaker A: Okay.
00:57:28.004 - 00:57:28.542, Speaker C: Yeah.
00:57:28.676 - 00:57:59.538, Speaker A: So I guess we have very interesting discussion. We try to limit ourselves to usually something approximately like 1 hour to not make people too much bored, I guess. I'd love to say thanks, Ethan, for coming. Thanks for very interesting intro, for sharing your experience with multi chain. So thanks a lot.
00:57:59.624 - 00:58:01.706, Speaker D: Thank you for having me here. It's very nice to talk.
00:58:01.808 - 00:58:06.440, Speaker C: Yeah. Close.
