00:00:04.330 - 00:00:12.602, Speaker A: Hi, everyone. This is Alex from near with me today is Ben Jones from optimism. Hi, Ben.
00:00:12.746 - 00:00:16.080, Speaker B: Hey, everyone. Hey, Alex, how are you?
00:00:16.610 - 00:00:47.420, Speaker A: Very good. And today we're going to be talking about optimistic roll ups. Ben was previously on Whiteboard Sessions. Maybe a year ago, we were talking about plasma cash flow, which was another layer two solution. But since then, optimistic roll up started getting popular. So let's talk about them. So, Ben, would you like to, I guess, introduce yourself again in case people didn't watch the previous episode and talk a little bit about what optimistic roll up are, what problems they're trying to solve, and how they.
00:00:47.790 - 00:01:04.370, Speaker B: Sure thing. Sure thing. And that's right. Yes, I am here, back to back, I guess now back at the near whiteboard to talk about more stuff. Yeah. So I'm Ben. I work at a team called optimism, and we're building a product called optimistic Ethereum.
00:01:04.370 - 00:02:00.014, Speaker B: And it's a scaling solution that, like Alex said, uses at its backbone tech called optimistic rollup. And the goal is to scale ethereum, and particularly our goal is to scale Ethereum smart contracts. So, Alex, when we were last chatting on the near channel, we were talking about something related to plasma. And plasma was a really cool, really awesome technology, but it didn't have the properties that we wanted to get true, like Ethereum style, rich state, sort of persistent dapps. And so that is what optimistic rollup sort of gives us very uniquely. And so it is a layer two scaling solution. This means that it makes an assumption that in the happy case, a lot of things won't have to go on chain, and then only in the sad case do they have to go on chain.
00:02:00.014 - 00:02:04.690, Speaker B: And so that allows you to scale up in the number of disputes, and this gives you some scale.
00:02:06.090 - 00:02:07.720, Speaker A: Cool. Let's dive in.
00:02:08.650 - 00:02:29.450, Speaker B: Sweet. Okay, so where would you like me to start in terms of framing? I could go way back and talk about layered, like optimistic execution. I could talk about a bit of history of plasma. I could dive in this particular solution, trying to think of what is the best route to take us.
00:02:29.520 - 00:02:32.320, Speaker A: Yeah, definitely. Let's talk about optimistic execution in general.
00:02:34.210 - 00:02:51.426, Speaker B: Sure. Okay, so we have a class of technologies, right? Let me just start using this lovely whiteboard here because I got to get some practice or my handwriting is going to be horrible. So we have this thing called layer two.
00:02:51.528 - 00:02:52.178, Speaker C: Right.
00:02:52.344 - 00:03:12.682, Speaker B: What a weird way to write layer two. Layer two refers to a suite of designs and applications that arguably started with payment channels, even not as early as bitcoin, and they utilize something called optimistic execution. This is one way to frame what they do.
00:03:12.736 - 00:03:12.954, Speaker C: Right.
00:03:12.992 - 00:03:29.738, Speaker B: So let's just write that. Of course, I am biased towards this particular choice of words since I work at a company with an m at the end of optimist. So I like this word a lot. But what is optimistic execution?
00:03:29.834 - 00:03:30.382, Speaker C: Right.
00:03:30.516 - 00:03:48.166, Speaker B: Well, we have this blockchain thing, right? We'll assume the readers are familiar with that. And the idea is these blockchains have a limited throughput, right? So if we have some chain argue with me about whether I'm pointing my arrows the right way.
00:03:48.268 - 00:03:48.920, Speaker C: Right.
00:03:49.290 - 00:04:09.270, Speaker B: At the end of the day, this consensus system is still a computer and of this state machine and it's replicated. And the way that we replicate it and achieve a consensus on it basically restricts us. So we can't just pump infinite things into this blockchain.
00:04:09.430 - 00:04:10.560, Speaker C: It won't work.
00:04:11.490 - 00:05:25.682, Speaker B: So what do we do? In the naive model of blockchains we can think of the blockchain as like a ledger of accounts or whatever we want to call it, right? So this is one model to think of a blockchain. And so you do your payments and you put them on the ledger and it updates who has what based on how much Alice is paying Bob or whatever. So optimistic execution is the idea that unfortunately this ledger is very limited. So instead of making it a ledger of accounts, what if we could make it a ledger of disputes? And really you might even say settlement in a general case. But it's interesting to think of this as just disputes. So the idea is perhaps instead of Alice paying Bob $5 by submitting a transaction to the ledger of accounts and saying, hey, decrease my account by $5, increase Bob's account by $5, maybe there's a scheme in which Alice can simply say, here's a little update and here's what Alice has now. And here's what Bob has now.
00:05:25.682 - 00:05:39.714, Speaker B: And you don't have to actually check me on this, but if anyone disagrees, then they can trigger an event and check it. And so this is an efficiency boost that allows you to pump more transactions through the consensus.
00:05:39.762 - 00:05:40.070, Speaker C: Right.
00:05:40.140 - 00:06:08.180, Speaker B: And one way to think about it is you don't go to court to cash a check in the real world. You go to court if the check bounces. And so we want the ability to cash a bunch of checks in a way that doesn't go through the ledger of accounts. And we use this court system that this strong property of trust that blockchains provide only when there's some sort of problem, a dispute. So does that make sense? That's sort of optimistic execution, maybe at a high level.
00:06:08.710 - 00:06:10.980, Speaker A: Yes, that makes sense. Cool.
00:06:13.190 - 00:06:26.322, Speaker B: Okay, so I guess the next thing to talk about would be to talk about maybe some specific examples of optimistic execution schemes, and I'll talk about them very briefly.
00:06:26.386 - 00:06:27.270, Speaker C: Okay, cool.
00:06:27.420 - 00:06:52.750, Speaker B: So one of them is called a state channel. As I mentioned, this is one of the earliest ones. And in a state channel, Alice and Bob commit some money into an escrow, and they sign off chain. Know it's hard to figure out the best way to draw this, but Alice and Bob are going to submit some money into an escrow.
00:06:53.990 - 00:06:54.402, Speaker C: Right.
00:06:54.456 - 00:07:15.560, Speaker B: So there's Alice, there's Bob. They put some money into an escrow. There we go. There's a money symbol. And then they do some off chain actions. And basically what happens is that's what occurs on chain. Can you see that, by the way? Did I just move it for you?
00:07:17.290 - 00:07:21.210, Speaker A: I'm moving after you, so I'm trying to keep it where you're.
00:07:21.950 - 00:07:34.842, Speaker B: Oh, thanks. Thanks so much. So let's say that Alice and Bob puts some money into an escrow. This is sort of the part that occurs on chain. And then we can do some things that are off chain.
00:07:34.906 - 00:07:35.134, Speaker C: Right.
00:07:35.172 - 00:07:50.062, Speaker B: So if we say off chain over here, so off chain, basically Alice and Bob can do these cryptographic ious, right. They send back and forth some ious.
00:07:50.206 - 00:07:50.562, Speaker C: Right.
00:07:50.616 - 00:07:58.214, Speaker B: Alice says, okay, I'm going to pay you a dollar now. And then Bob says, okay, I'll pay you $3 at a different time.
00:07:58.252 - 00:07:58.406, Speaker C: Right.
00:07:58.428 - 00:08:14.742, Speaker B: And so on and so forth. And the property is that even if there's a lot of pass back and forth, even if there's a large number of these, only one of them ever has to go back into the escrow contract.
00:08:14.886 - 00:08:15.290, Speaker C: Right.
00:08:15.360 - 00:08:20.220, Speaker B: So here, let's do. I love colors. Let's try to get some colors in here. Only one.
00:08:21.630 - 00:08:22.380, Speaker C: Right?
00:08:23.790 - 00:08:37.202, Speaker B: So in a state channel, this escrow contract only needs the most recent sort of state, right. The most recent set of affairs to be able to resolve how much money at a later point in time, Alice and Bob get out.
00:08:37.336 - 00:08:37.826, Speaker C: Right.
00:08:37.928 - 00:08:53.058, Speaker B: And so hence, we have done some scaling, right. Because Alice and Bob transacted several times, and the ledger did not make an update on the order of the number of those transactions. It made an update on the order of two, a deposit and a withdrawal.
00:08:53.234 - 00:08:53.960, Speaker C: Right.
00:08:54.890 - 00:09:42.582, Speaker B: So that's how we get scaling. And I think this is, state channels are a great example of why things like transactions per second are a little misleading. In the crypto sphere, I would say one of the most overused words in all of crypto is transactions per second. And it's really not that meaningful because right here in a system that was designed for bitcoin, right, forget all these other crazy scaling solutions. With just small, little four megabyte blocks, we can theoretically do an infinite number of transactions per second, right? Like Alice and Bob's ability to pass these ious back and forth is only bounded by things like their computational power and network latency. But they could just send $0.01 transactions back and forth all day long, right? It wouldn't be a very meaningful scaling solution, but it would be a very high number of transactions per second, right?
00:09:42.716 - 00:09:52.146, Speaker A: Yeah, that's right. Also, we have a very good episode, episode 13, where we dive very deeply into channels. Into payment channels.
00:09:52.178 - 00:10:31.190, Speaker B: Yeah, nice. So payment channels are really cool. And if you even get a little crazy, you don't have to just do a payment on this channel. You can do things like playing a chess game or a turn based application or a poker game, things of that nature. So, unfortunately, the problem with payment channels is that Alice and this escrow contract, right, where Alice and Bob put money into it, was only Alice and Bob putting money into this escrow. And so this participant set is limited.
00:10:32.890 - 00:10:33.638, Speaker C: Right.
00:10:33.804 - 00:10:42.326, Speaker B: Only Alice and Bob can trust in the payments that they're making in this channel, right?
00:10:42.508 - 00:10:43.350, Speaker A: Yep.
00:10:43.710 - 00:11:05.982, Speaker B: So what we really like in the Ethereum world is this crazy ability to have these money legos, right, where we can deploy all these crazy smart contracts, and they can talk to each other in weird ways and do crazy awesome things, right? And the problem with this is that the set of features that you can do with such a limited participant set is similarly limited.
00:11:06.046 - 00:11:06.274, Speaker C: Right?
00:11:06.312 - 00:12:09.270, Speaker B: So, for example, an auction doesn't really work with a payment channel, not at least with the same properties that an l one auction would have. So, like, auction doesn't really work, right? Doesn't really work with a payment channel. So we need something more. So optimistic roll up is a scaling solution that allows you to scale up in the number of disputes, not in the amount of computation, and it allows you to do so with pretty much identical properties to Ethereum itself. And so that's what's super exciting about it, and particularly the property is that the data availability. So let's just make a quick thing here. Oru, the data availability, right? So data availability is like, I think occasionally an overused word.
00:12:09.270 - 00:12:15.400, Speaker B: I guess what I would say is like, transaction size. Transaction data size.
00:12:18.830 - 00:12:19.578, Speaker C: Right.
00:12:19.744 - 00:12:42.880, Speaker B: This is limited by l one. And basically the reason for that is that to send a transaction into roll up and get it finalized, you send it to l one, just like you would any other transaction. The difference is that TX computation size is not.
00:12:45.270 - 00:12:45.634, Speaker C: Right.
00:12:45.672 - 00:13:24.650, Speaker B: So this is on Ethereum, your gas not limited. And so this is the property that optimistic roll up has. And yeah, we can sketch out a very naive sort of optimistic roll up chain, maybe as a starting point. So I'll scroll up. Okay, so here's the simplest possible way. Mvoru minimum viable oru. And in fact, I will hide a particular detail here, which involves sort of the stateless execution nature.
00:13:24.650 - 00:14:17.840, Speaker B: So there's stateless clients, and you get a lot of performance benefits by doing that. But actually, the minimum sort of viable version of this that I'll describe here was actually, I think we can lend credit to Vitalik in 2014. He called this a shadow chain, which is honestly, in some ways a cooler name than Oru. I kind of dig shadow chain, but I also like Oru, especially since optimism is the name of my team. Okay, so here's a simple, optimistic roll up contractor, shadow chain, right? So let's define a data structure, which is called the transition. And a transition is a tuple of TX and a state.
00:14:21.090 - 00:14:21.840, Speaker C: Right?
00:14:23.750 - 00:14:47.270, Speaker B: So a transition is a transition is a tuple of TX and state. Now, the simplest way to have a roll up chain is you have an array of transitions and anyone can call propose new trans. This is extremely simplified, but it'll get the basic idea across. Propose new transition.
00:14:50.030 - 00:14:50.634, Speaker C: Right?
00:14:50.752 - 00:15:19.538, Speaker B: And this will obviously accept a TX state. It'll accept this transition object, right? And this will append to a list of transitions, right? So I'll call t zero. It kind of sounds like time, but we'll say, how about tr zero transition zero transition one, transition two.
00:15:19.704 - 00:15:27.560, Speaker A: But this has a problem, right. If I propose a transition and while my transition is being proposed, someone else proposes transition, my state will be incorrect, right?
00:15:28.250 - 00:15:59.914, Speaker B: That is correct. Yeah, that's a totally good point. So this is like a very naive implementation. So you're absolutely right. In the scenario in which anybody can call proposed new transition, this would be a very unfortunate roll up scheme because you would have this race condition and you would probably end up with a property that only one person would be able to sort of make a valid thing proposal per block. And it would just happen to be the person who paid the most gas.
00:15:59.962 - 00:16:00.126, Speaker C: Right.
00:16:00.148 - 00:16:21.622, Speaker B: The person who wins the priority gas auction. So you're absolutely right. So one simple way to remedy that is to imagine that a single party is allowed to propose these new transitions, right? And that would be a simple way to resolve this. That single party knows the exact ordering and the states that are coming down and they can propose it.
00:16:21.676 - 00:16:22.280, Speaker C: Right.
00:16:23.530 - 00:16:55.540, Speaker B: Of course that would have a problem that what if that person went offline, right. And then that person would disappear. So a better way to do things. Well, maybe just to finish this analogy very quickly, right. There would be one other function here which would be prove fraud, right. And this function would take in an index, right. And step one of proving fraud would be check.
00:16:55.540 - 00:17:07.094, Speaker B: So we have a state transition function that also hasn't defined here, but execute tx is what we'll call that state transition function.
00:17:07.212 - 00:17:07.590, Speaker C: Right.
00:17:07.660 - 00:17:16.920, Speaker B: Execute TX, which takes in a TX and a state and it outputs a new state.
00:17:18.910 - 00:17:19.660, Speaker C: Right.
00:17:21.870 - 00:17:31.786, Speaker B: So the last thing to do after we've started putting this array of transitions on chain is, would be to prove that a transition is fraudulent.
00:17:31.898 - 00:17:32.318, Speaker C: Right.
00:17:32.404 - 00:17:56.690, Speaker B: So how would you do that? You would check that for index I? Okay, let's just use I for the simplicity of writing. So you would check that tri minus one. Oh, sorry. Actually let me rewrite that. So we would prove that. I'll scroll down a little bit. Nice.
00:17:56.690 - 00:18:07.742, Speaker B: So the first thing that you would do is you would take the state at the previous index and you would apply the if transaction to it and see if you got the correct output.
00:18:07.826 - 00:18:08.266, Speaker C: Right.
00:18:08.368 - 00:18:52.822, Speaker B: So here's what we would do. We would say check that execute TX of tri minus one state, comma tri TX is not equal to tri state, right. So there would be the basis of a fraud proof. It would say, hey, this person lied, they put down a transition and they said if you apply this TX to the head state, then you will get this new head state.
00:18:52.956 - 00:18:53.302, Speaker C: Right?
00:18:53.356 - 00:18:57.142, Speaker B: And so we can prove that this is not the case.
00:18:57.196 - 00:18:57.474, Speaker C: Right.
00:18:57.532 - 00:19:25.282, Speaker B: And maybe even we'll get a little color funky up in here. Now we're talking. Now we're going digital. Okay. And then the second thing that you do, right, would be step two, delete transition I through the end of the max. Delete the rest of them.
00:19:25.416 - 00:19:26.100, Speaker C: Right?
00:19:26.790 - 00:19:30.850, Speaker B: Okay, so that's a super simple, optimistic roll up chain.
00:19:31.510 - 00:19:38.290, Speaker A: Right? So I guess one problem here is that with every transaction we have to submit the whole state. Right, which is going to be humongous.
00:19:38.450 - 00:20:08.062, Speaker B: Exactly right, exactly right. Exactly right. So that is definitely the case is that this state is going to get very big over time. And notably, the array of transitions that we're storing here is being stored on chain. And so that would be like storing instead of the difference. Maybe you could improve by storing the difference in the state, right. But you're still storing in this super naive implementation, the entire state.
00:20:08.116 - 00:20:08.334, Speaker C: Right.
00:20:08.372 - 00:20:16.494, Speaker B: And so you're totally right. That's a no go. But it would fail because the storage costs are vastly greater. Yeah, absolutely right.
00:20:16.612 - 00:20:32.520, Speaker A: And so as we're optimizing. So one thing is to remove the state from the chain data. Right, sorry, from the ethereum state. Is there also a goal to remove transactions from the state?
00:20:34.650 - 00:21:00.590, Speaker B: That is correct. And actually, that is where the term roll up comes from, which actually came from ZK roll up. So there are basically two things. What you end up with is a hash of the transaction and a hash of the state. And in fact, of course, you can do it as an accumulator, so it doesn't have to be a linear number of hashes. You can have it be a logarithmic on chain accumulator.
00:21:01.170 - 00:21:01.920, Speaker A: Awesome.
00:21:02.390 - 00:21:39.420, Speaker B: And that's exactly right. And so the way that we get rid of. So maybe just to note this, I'll keep going down here. Oh, man, color changing is tough. There we go. To remove the TX size, what we do is we store hash of the transactions, right. Instead of storing the transactions themselves.
00:21:39.420 - 00:22:03.602, Speaker B: And this sort of hashing process, really in practice, what happens is a large number of transactions are submitted all at once, and you store a Merkel root of them, because you might have 100 transactions, but you only need one particular transaction where things were fraudulent. So you store Merkleroot, and this is colloquially known as roll up.
00:22:03.656 - 00:22:03.874, Speaker C: Right.
00:22:03.912 - 00:22:17.954, Speaker B: And so this is what's done on Zk roll up. This is what's done in optimistic roll up. And the idea is that even though we only store the hash of the transaction on chain, only the hashes in the state within the chain history is the entire transaction.
00:22:18.002 - 00:22:18.166, Speaker C: Right.
00:22:18.188 - 00:22:27.706, Speaker B: Because anyone who wants to come to the chain later on and verify needs to be able to get this transaction in the first place to verify that the hash is correct.
00:22:27.808 - 00:22:28.074, Speaker C: Right.
00:22:28.112 - 00:22:39.120, Speaker B: Otherwise it wouldn't know if it should reject the block or not. And so even though we've removed the transaction from the state, it is still there in the history. All the full nodes had it.
00:22:39.650 - 00:22:51.026, Speaker A: And it's worth mentioning, right, that the price to store something in the history of Ethereum is way cheaper than several orders of magnitude cheaper. Right?
00:22:51.128 - 00:23:09.062, Speaker B: Exactly right. Exactly right. Call data is way cheaper. A further intuition that's kind of nice there. In general, sometimes people hear roll ups and they hear, oh, well, you still have to put the transaction data on chain. That doesn't sound scalable to me.
00:23:09.116 - 00:23:09.286, Speaker C: Right.
00:23:09.308 - 00:23:52.600, Speaker B: There's sort of two reasons to think that's scalable. One is exactly what you said is that it's much cheaper to store a piece of data in the chain's history than it is to store it in the actual head state of the machine. The other reason is that Moore's law has continued following bandwidth where it's beginning to drop off on execution. So this is actually what's nice on computation, rather. So this is kind of a nice property, is that it seems like Moore's law is continuing for bandwidth, which is the only cost factor that goes into this property, the cost, whereas execution is falling off. So we keep the execution off chain, but we keep the bandwidth on chain. We can keep following Moore's law, right.
00:23:55.770 - 00:24:20.880, Speaker A: I don't know if you were going to talk about it next, but I'm trying to see how the signatures of these methods will change once we do not have the entire list of transitions, right, but rather have hashes. So if I'm proposing new transition, my transition now contains the Merkel root of the state, right? That will be the result of applying the transaction, right?
00:24:21.970 - 00:24:23.646, Speaker B: That is correct. That is correct.
00:24:23.748 - 00:24:37.606, Speaker A: And so therefore, the proof fraud will have to contain the states themselves, right? So that we can actually apply the transactions, or I guess a subset of state, which is sufficient with the witness, right?
00:24:37.788 - 00:25:13.310, Speaker B: Exactly right. A subset with a witness. And one important note there is that concept. People, often, when people are learning about that concept, there's a point, a moment in time which that concept really clicks, which is that this is very similar to what's called the stateless client in ethereum, and maybe a bit more broadly in crypto now, right? So the stateless client is the idea that nodes don't store any of the chain state, even of l one, other than an accumulation of it. And when you apply a transaction, you provide a witness to any parts of the state that you're accessing.
00:25:14.050 - 00:25:16.960, Speaker A: Okay, I'm drawing a little. Go ahead.
00:25:18.070 - 00:25:27.460, Speaker B: The other thing I would say is, funny enough, in bitcoin, this has been called utreexo, and it works almost the exact same way, but for bitcoin, utxo model.
00:25:27.910 - 00:25:52.334, Speaker A: Yeah, I see. Okay, so I'm drawing at the bottom, right? So that I have the full understanding. So assuming I can submit a set of transactions, right? So now my method, what was it called above? Let me see. It was called execute Cx propose, right? Yeah. Propose. Okay, so now my propose will take effectively a list of transactions, right?
00:25:52.452 - 00:25:53.120, Speaker B: Yes.
00:25:54.050 - 00:26:05.218, Speaker A: And a state root that I claim will become, will be the root of the state after applying these transactions, right?
00:26:05.304 - 00:26:05.602, Speaker B: Exactly.
00:26:05.656 - 00:26:06.350, Speaker A: So internally.
00:26:06.430 - 00:26:07.362, Speaker B: Exactly right.
00:26:07.496 - 00:26:22.662, Speaker A: Internally, this method will compute into the list of the transitions, right. It will append some sort of hash of transactions, right. Maybe Merkel route, maybe something else.
00:26:22.796 - 00:26:23.910, Speaker B: Yep, yep.
00:26:24.570 - 00:26:43.790, Speaker A: And the state route, I guess it's a, I'm not, I'm not that familiar with Ethereum, but my understanding that just by calling this method, the transactions are already in the history.
00:26:43.860 - 00:26:44.046, Speaker C: Right.
00:26:44.068 - 00:26:46.270, Speaker A: Because there's some sort of a call data, right?
00:26:46.340 - 00:26:48.974, Speaker B: Exactly right. It's in the call data, but only.
00:26:49.012 - 00:26:53.646, Speaker A: The hash of the transactions ends up in the state. Right?
00:26:53.748 - 00:26:54.682, Speaker B: Exactly right.
00:26:54.756 - 00:27:07.430, Speaker A: And so this part, let me also maybe change a color. And so the part that is blue, that can also be optimized to contain just some sort of accumulator, so that on itself can be some sort of.
00:27:07.500 - 00:27:09.494, Speaker B: Exactly right, I see.
00:27:09.612 - 00:27:44.798, Speaker A: So the state that occupies very little. And so now the method that is proof fraud, now it takes index, but it also takes now, in the nafe way, that would be state before, right? Yes, state after we don't really need, because we will get the state after and we can hash it. And so from here. So that is already sufficient. Well, it's not quite sufficient. We also need the transaction itself, right. Because we only have the hash of them.
00:27:44.884 - 00:27:45.410, Speaker B: That's right.
00:27:45.480 - 00:27:57.638, Speaker A: Submit index TX and the state root. And so that on itself should already be sufficient. Well, we also need some sort of witness that proves that the transaction corresponds to this hash of transactions, right?
00:27:57.724 - 00:27:58.600, Speaker B: That's right.
00:27:59.930 - 00:28:38.334, Speaker A: We need some witness that prove that. And if this is the cumulator, then we also need some witness that proves that some number, sufficient witnesses to show the transaction corresponds to the hash. And so the next optimization is that if we have, let's see. So for example, if this is the state, right? And so let's say my transaction read from this several places, and then it wrote to this couple of places, and I'm not submitting the entire state, I'm submitting these parts of state that I changed.
00:28:38.462 - 00:28:39.620, Speaker B: Right, exactly.
00:28:40.710 - 00:28:59.050, Speaker A: And Merkel proofs that they correspond to the state be, or rather, well, I'm only submitting it for the data I read. Right. But for the data, right. I still need to provide Merkel witness so that I can, so I can recompute the updated hash, right?
00:28:59.200 - 00:29:00.602, Speaker B: That's right. Yeah, exactly right.
00:29:00.656 - 00:29:07.580, Speaker A: Cool. Okay, so how far are we from having not that minimum viable, optimistic roll up with all this?
00:29:08.030 - 00:29:36.066, Speaker B: Oh, we're pretty close. We're pretty close. We did the first public demo of roll up called optimistic roll up, called Unipig. We did that at Devcon last year. There's a very separate conversation to be had about what it takes to build. So there's a big separate question here, which is this function execute TX.
00:29:36.178 - 00:29:36.454, Speaker C: Right.
00:29:36.492 - 00:29:47.606, Speaker B: What does it look like? Because to really take advantage of this solution, the applications built on top of it have to fit within this execute TX function.
00:29:47.708 - 00:29:48.310, Speaker C: Right.
00:29:48.460 - 00:30:02.282, Speaker B: And so in our case, where we're building this as a layer on top of Ethereum, it becomes a very interesting problem. Well, how do you design and execute TX function that is like application developer friendly?
00:30:02.346 - 00:30:02.574, Speaker C: Right.
00:30:02.612 - 00:30:11.966, Speaker B: Because the cool thing about this system is that because you basically have three properties, one property is that you have an available head state.
00:30:12.068 - 00:30:12.430, Speaker C: Right.
00:30:12.500 - 00:30:44.794, Speaker B: And the reason for this is because all of the transaction data is available in the chain history. And so anyone who wants to can compute the head state from the available transaction data. We have another nice property, which is that it is live, at least as live as the l one. And we have a property that it's valid because we know that we can go and submit fraud if it's invalid and correct it. So that it is. And through those three properties are basically exactly the properties of a smart contract system.
00:30:44.912 - 00:30:45.580, Speaker C: Right.
00:30:46.670 - 00:30:55.840, Speaker B: And again, that was how I started this, was by saying, look, payment channels are good for one thing, but we need another one. So a lot of the work that we've put in over the past.
00:30:57.570 - 00:30:57.886, Speaker C: How.
00:30:57.908 - 00:31:19.782, Speaker B: Many months has it been now? Five months, is building this thing called the OVM, which is a EVM container. So it allows you to run an EVM transaction as your execute TX function, which turns out to be a separate, very hard problem. So we've had roll ups without that for a while. And EVM roll ups are coming very soon.
00:31:19.836 - 00:31:20.870, Speaker C: It's very exciting.
00:31:22.250 - 00:31:27.766, Speaker A: So the roll ups you have today, what sort of virtual machine they're running?
00:31:27.868 - 00:31:40.458, Speaker B: I actually don't know if there are any optimistic roll ups running in production today. I don't think there are, but all the ones, the majority of work has been done into putting things like a state channel, I mean a payment system.
00:31:40.544 - 00:31:40.746, Speaker C: Right.
00:31:40.768 - 00:31:53.474, Speaker B: And so you build a very simple payment machine. We did a demo which used the uniswap functionality, and we simply hard coded a uniswap transition function that we had to there.
00:31:53.592 - 00:32:06.840, Speaker A: So the OVM that you guys proposing, does it interpret EVM in EVM, or is it somehow latching to the underlying EVM to. Does my question make sense?
00:32:07.450 - 00:32:09.270, Speaker B: The latter. I see.
00:32:09.420 - 00:32:11.922, Speaker A: So it is as efficient as the underlying EVM?
00:32:12.066 - 00:32:21.142, Speaker B: That's right. I mean, there's maybe a 10% efficiency loss that comes with the way that the implementation works, but it's very close to as efficient. Yes.
00:32:21.196 - 00:32:21.800, Speaker A: Nice.
00:32:24.510 - 00:32:44.574, Speaker B: Yeah. It's not as naive as, oh, Ethereum is incomplete. So we implement the EVM and Ethereum. Yeah, that turns out to be a very difficult task. So the OVM works a little bit differently. It instead just adds a container contract, which sort of enforces that another contract is running in a sandboxed environment.
00:32:44.622 - 00:32:49.822, Speaker A: I see. Cool. And so that works with the partial state, with the witnesses.
00:32:49.966 - 00:33:04.066, Speaker B: That's right. Yes. That container has an interface which is called the state manager, which is pretty much identical to how guests or PI, ethereum, implement their clients. And that can be stateless or stateful, depending on whether you're on or off chain.
00:33:04.178 - 00:33:05.414, Speaker A: Nice. Awesome.
00:33:05.612 - 00:33:06.680, Speaker B: Yeah, cool.
00:33:07.370 - 00:33:20.966, Speaker A: So also there's another topic which we sort of skipped, I guess, before, which is how do we solve the problem that there is only, like naively, it only works with a single block entity which can propose.
00:33:21.078 - 00:33:32.382, Speaker B: Yes, that's a great one. That's a great one. Yeah. So let's go to the bottom and talk about that. Yes. So I'll talk about two iterations that you can build on this system. The simplest way to remedy the problem.
00:33:32.382 - 00:33:46.498, Speaker B: So let me just draw a line and I'll start drawing below there. So the simplest way to remedy this problem of, well, who has the responsibility to submit these transactions? And why should we trust them to not halt our coins or censor our transactions?
00:33:46.594 - 00:33:47.142, Speaker C: Right.
00:33:47.276 - 00:34:41.634, Speaker B: The simplest way is to split the proposal function into two functions. So you have propose TX, where you send maybe a batch of transactions and then you say propose state route Sr. And that would be a batch of state routes, or maybe just one, maybe you append them one at a time. And that is like at its core, the way that you enable this, right? So simply by taking these two proposal functions and splitting them up and saying, okay, either you propose a transaction and that transaction is just added in whatever order that layer one added it, or you propose a state route, and that state route is a result of the transactions.
00:34:41.762 - 00:34:42.054, Speaker C: Right.
00:34:42.092 - 00:34:46.342, Speaker B: And so this is sort of what allows you to break it up. Does that make sense? Step two.
00:34:46.396 - 00:34:55.430, Speaker A: So for proposals, is the idea here that there is again, only one entity which does that, or shall it accept index at which you claiming the state route?
00:34:55.510 - 00:35:08.122, Speaker B: Yeah. So there's a lot of different models that you can go by, generally state root proposal, because it costs gas to prove fraud. State root proposal should be bonded.
00:35:08.186 - 00:35:08.414, Speaker C: Right?
00:35:08.452 - 00:36:07.300, Speaker B: So there should be some money associated with state route proposal. And so maybe you say the person who made that bond, you can make the bond be at the time that you propose the state route, you can even have a state route proposer that is the person with the highest bond, right? And so that's one note associated with state route proposal. In principle, though, it can be anyone and anyone who proposes an invalid state can be penalized. And so one important note here, right, is that an invalid state route does not affect the chain, the liveness properties of the chain, right? So let's say we have these two chains, and the top chain is a chain of TX's, right? So we have like tx zero, right. Then you can add a new one, right? And then we can add another one, and another one gets added on. Right, well, let's say over here, state route is proposed here, and then state route is proposed here, and then state route is proposed here. And it's red.
00:36:07.300 - 00:36:37.402, Speaker B: It's a bad state route proposal, right. Everyone who's honest, who's watching the transactions, knows that it's invalid and knows what the real state is going to end up being resolved to. So you can continue to add on here without any concern for the fact that this state root proposal was wrong. As long as this thing gets canceled in time, it does not affect the latency of the system. You're still just following along the transactions and the transactions are doing their thing, right?
00:36:37.456 - 00:36:51.840, Speaker A: Yeah. I guess my question was also around the fact that if proposals r doesn't take the index, right. It could happen again that I'm proposing the correct state route, but someone else proposed the state route for the same timestamp. And so my state route is appended for the.
00:36:53.170 - 00:37:27.462, Speaker B: Right. So you could add an index to it. Yeah. Okay. I think in practice there's a few practical considerations here. So one of the practical considerations is that the ability to have a party that aggregates many transactions and submits them all at once is like a very useful service provider, and it also affords some gas benefits because it can amortize some of the gas costs as well as there's other crazy things. So in the long term, what you'll be able to do is use BLS signature aggregation, and you'll be able to aggregate a bunch of users transactions to have only one signature.
00:37:27.462 - 00:37:53.154, Speaker B: And so then your roll up gets really cheap because you amortize the cost of what would normally be a 65 byte ECDSA signature. So this service provider kind of needs to be there and is very useful. So pragmatically speaking, usually we'll have that person be just one person with the property that if they go away after some amount of time anyone can propose, for example.
00:37:53.272 - 00:38:11.194, Speaker A: Yeah, that makes sense. So one thing I wanted to discuss briefly was it was slightly orthogonal to everything we discussed before. I wanted to discuss sort of the future with multiple optimistic crawlers. But if there's something else fundamental we didn't discuss yet, we should probably do that first.
00:38:11.392 - 00:38:47.938, Speaker B: Sure, yeah, I'll talk about. Well, there's a couple of other interesting things. So one interesting note is that if we stay here and look at these state routes, these state routes, they have a cost, right? They're 32 byte hashes of call data. And so there are more complex dispute games that you can build that basically allow you to optimistically skip state routes in the middle. So, for example, imagine that none of these state routes were proposed at once, and instead we propose the state route every 123456 transactions.
00:38:48.034 - 00:38:48.680, Speaker C: Right.
00:38:49.770 - 00:39:28.830, Speaker B: This does not require you to execute all six transactions. To prove that from here to here is invalid. One thing that you can do is you can initialize like a truebit style dispute game that does a bisection game that says, okay, you disagree about the state route here we, we both disagree about the state route here. Let's see if we disagree about the state route in the middle, and then we both say what we think it's going to be in the middle, and we say, okay, we agree about the middle one. So it must be one of these two guys. So what do you think for this one? And you eventually find exactly where the source of the dispute really is. So that's one other interesting optimization.
00:39:28.990 - 00:39:35.966, Speaker A: But that becomes interactive, right? Because if we have every state route, then the dispute non interactive.
00:39:36.158 - 00:40:19.694, Speaker B: It does become interactive. Yeah. And so it's definitely very nice to have a system that is non interactive, but it is something you can do. Another property that I will shout out that is unique, that is somewhat tangential, although we find it conceptually easier to think about it at the roll up level. But really you can think of it, you could implement it at the application level. Is one really nice feature about having a single sort of person who is going to roll up these transactions, is that that person has strong private knowledge about what the state is going to be, and it has knowledge of that in basically an instant latency.
00:40:19.742 - 00:40:19.954, Speaker C: Right.
00:40:19.992 - 00:41:21.590, Speaker B: As soon as it makes the decision of how it's going to post some transactions, it knows what the future state of the system will be. And so this is a nice property, because if you trust that person, and especially in some applications, it's especially useful that you can believe that this person will be sign an attributable promise that they will include your transaction and they'll go do it. And this gives you some really nice user experience. Of course, it comes with the problem of censorship that we talked about, where how do you prevent this party from, for instance, not including your transactions, and then you're unable to withdraw. And so what you can do is you can have a slow queue and a canonical transaction chain. So this is what we do in our implementation. And basically anyone can, in a permissionless way, append transactions to this slow queue.
00:41:21.930 - 00:41:22.680, Speaker C: Right?
00:41:23.130 - 00:41:26.102, Speaker A: So slow queue effectively happens to be on the layer one.
00:41:26.236 - 00:41:57.502, Speaker B: Is on the layer one. Exactly right. Exactly right. And we're building up, and maybe, let's say we're building up this canonical TX chain here. Now what you do is you implement a small time delay between the time at which a transaction was put into the slow queue. And then after this time elapses, it must be moved into the canonical transaction chain. There's no other valid action other than moving it into the canonical transaction chain.
00:41:57.502 - 00:42:31.370, Speaker B: But in the meantime, in this short period of time in which it sits in the queue, you can have one party, which we call the sequencer, and that sequencer can insert transactions in front. This allows the sequencer to continuously provide instant promises and have private knowledge of exactly what the state will be while still maintaining the censorship resistance properties via this sort of escape hatch slow queue mechanism. So you can get crazy with these sorts of designs.
00:42:32.110 - 00:42:44.350, Speaker A: Sequencer, in the worst case, they will be able to force someone to pay on chain transaction fee for their transaction.
00:42:44.850 - 00:42:49.454, Speaker B: That's right. And of course they pay an onchain, it's still a roll up transaction.
00:42:49.502 - 00:42:49.714, Speaker C: Right.
00:42:49.752 - 00:43:07.430, Speaker B: So other than this amortization cost that we were talking about, those costs will be very similar. So yeah, in the worst case they can push them into the other chain. I see, yeah. And that gives you some really nice ux for a lot of applications.
00:43:09.070 - 00:43:37.586, Speaker A: I guess another question I had is because all the transactions still end up on the Ethereum blockchain. Right. I think there are two interesting aspects of it. So one of them says that while the first optimistic crowd, which comes to Ethereum will scale quite a lot. Right. You cannot scale it. So effectively all the optimistic roll ups combined collectively will only scale it by the same factor as a single optimistic roll up.
00:43:37.586 - 00:43:44.162, Speaker A: Right. Because they all share the capacity of the Ethereum blocks and that is the bottleneck for them. Right?
00:43:44.296 - 00:43:48.018, Speaker B: Yeah. Say it again. I think it does, but I want to know precisely what the question is.
00:43:48.104 - 00:44:18.350, Speaker A: What I'm trying to say is that, for example, with the state channels, right. You mentioned at the beginning that it is, in theory, it can scale infinitely, right? So if we open 1 million state channels, it will be 1 million times more transactions per second than a single state channel. While with the optimistic roll ups, no matter how many optimistic roll ups from different entities potentially operate on Ethereum, they collectively have the same throughput as a single optimistic roll up could have on Ethereum, right?
00:44:18.500 - 00:45:11.040, Speaker B: Yes, that's correct. And I tried to allude to this earlier by saying that we should be optimistic. First of all, what are the bounds? What are those limits? Those limits are very large, right. If we look at high powered data availability sort of engines, e two, as example, the last time we did the numbers, you get like 100k TPS pretty easily, right? And I hate the word TPS, but as an approximation, and so those numbers will go very large. And in general, roll ups scale linearly with the number of shards. So as the layer one sharding improves, the roll up throughput improves, and the roll ups only the other thing that we've continued to see.
00:45:14.850 - 00:45:15.566, Speaker A: Continue to see.
00:45:15.588 - 00:45:28.550, Speaker B: What you might have liked, that the Moore's law for bandwidth has continued going up. So we can be more confident that the bandwidth of these blockchains will be increasing at a more rapid pace than the execution.
00:45:29.130 - 00:45:39.946, Speaker A: And so when you're saying it scales linearly with number of shards, effectively what you care about is how much data the shards can store, right. You don't really need the execution from the shards, right?
00:45:40.128 - 00:46:29.900, Speaker B: Correct. And that's why, again, it is tricky. TPS is so tricky. One thing, for example, that you have to prevent in this scheme is you still have to have a notion of gas, right? So, for example, it's not sufficient to use l one as the antidos for this system, because you might, for instance, submit a transaction that calls, while true, and then will just never halt. Yeah, I forgot exactly where I was going with that. But you do do gas metering instead of doing, while true, if you have a for loop that iterates over a bajillion cycles, you can do that and get a lot more throughput. That is, quote, nonlinear in some sense.
00:46:30.670 - 00:46:35.340, Speaker A: But that should be handled on the OVM level, right?
00:46:35.790 - 00:46:41.770, Speaker B: Correct, exactly right. Yeah. And again, we're lucky enough to be able to borrow that gas metering.
00:46:42.190 - 00:47:09.590, Speaker A: Very fortunate. And another interesting thing is, so assuming that for a while, optimistic roll ups are going to be running on Ethereum 1.0, right. If we do like very quick computation, it seems that. So let's say majority of computation moves to optimistic roll up, then Ethereum block size will increase dramatically. Right. So today on average, I think it's like 20 will become like 100 block.
00:47:09.590 - 00:47:17.078, Speaker A: So do you have any insight into how that can affect the chain? Will we have higher uncle rates or anything like that?
00:47:17.244 - 00:47:43.070, Speaker B: Right. Currently, Ethereum is lobbying to bring, I don't know how many months ago it was now. Could have even been closer to a year than measuring in months ago now. But Ethereum recently actually lowered the cost of call data way down, particularly to support roll ups, because it was considered and it seemed like call data was overpriced and that we weren't going to kill the uncle rate if we do this.
00:47:43.140 - 00:47:46.514, Speaker A: I see. Okay, so smart people did think about it.
00:47:46.712 - 00:48:15.750, Speaker B: Smart people did think about it, and there's even proposals to lower it further. Another obvious step that you can take is you can basically add a new opcode to the EVM, or like a new pre compile, however you want to think about it, that allows you to simply check the availability of data, and that's all that you can do. And maybe it automatically mercalizes it. And so that would allow you to not have the VM be any part of the constraint at all, and it's just pure bandwidth.
00:48:15.830 - 00:48:20.210, Speaker A: Yeah. So is there anything else important we didn't discuss about optimistic roll ups?
00:48:20.390 - 00:48:24.720, Speaker B: Oh, let me think, let me think. I think we hit the big points.
00:48:27.410 - 00:48:58.540, Speaker A: So there's one interesting topic which many proponents of ZK roll ups bring up, right. That if you have quite a bit of assets in the optimistic roll up, it might become reasonable for the miners to get involved and start censoring the disputes. Right. For sufficiently long until the dispute period ends. Right. Is it a valid concern and are there any ways to get around it?
00:48:59.070 - 00:49:56.220, Speaker B: Definitely a valid concern. So we often call this internally, like the parasitic l two argument, which is fun. The answer is in optimistic execution schemes, you can't really get around that. So you have to be careful because, and maybe a better way to phrase it is that layer two systems are an intrinsic source of MEV, of minor extractable value. Even to the extent that, like you said, you can do something called a time bandit attack, where minor extractable value can be retroactively stolen by another miner who 51% attacks the chain and moves forward. I see there's not a ton you can do about this, particularly on eth one now outside of governance concerns. So if our dispute period is going to end up being a week, if the ethereum chain was 51% attacked or censorship attacked for a week.
00:49:56.220 - 00:50:44.922, Speaker B: Would there be a governance thing where people decide to fork? Who knows? Hard to say in e 2.0 soft forks for sort of subjective realizations of censoring or attacks is going to be a part of the protocol and the social consensus around protocol, so we're helped there. With that being said, I'm a huge fan of zero knowledge proofs. If there was a zero knowledge EVM that I thought was short term viable, I would be jumping all over that. Our goal is to be very pragmatic. We're not tied to optimistic roll up because it is the scaling solution. We're tied to it because it gives a reasonable set of properties that we think are worthwhile, and it does it today.
00:50:44.922 - 00:50:56.750, Speaker B: So when zero knowledge proofs start going crazy and are way easier to develop on and so on and so forth, we totally should have more zero knowledge proofs. I'm a huge fan. Huge fan.
00:50:57.330 - 00:51:24.966, Speaker A: Awesome. And the last question I have is, in terms of optimistic roll offs appearing in production, do you think it's going to be more like a single optimistic roll off which has multiple contracts which interact with each other within a single state within a single ovm, or I don't know how to within a single container? Or do you envision it more like multiple optimistic roll ups that have a way to communicate between them? And if the latter, then how that communication will happen?
00:51:25.068 - 00:52:14.440, Speaker B: It's a really good question. And there are limitations after which verifier costs are going to get so large that if users aren't willing to accept those verifier costs, or they're not willing to accept that there exists out there one honest verifier, then you may need to spread them out. So especially in super quadratically crazy sharded systems where the amount of available data is just insane and that computation is insane, then you're going to need multiple roll up chains. In the short term. We have put a strong emphasis on making a roll up chain that supports contract deployment and supports the sort of money Lego features that we see on Ethereum. The only other thing I was going to say is those tools I actually think you guys at near are doing a great job of. I think you guys have an async await for crosshard communication or whatever.
00:52:14.440 - 00:53:21.100, Speaker B: Asynchronous communication between apps in the decentralized context is going to be super important, but it's not there yet. I don't think so. I would say that one thing that is less whiteboardy to call out is that this screen that we have right here, actually with this sequencer is related to a really cool sort of economic construction that we're working on called miva minor extractable value auctions. And basically the idea is that this sequencer's ability to order transactions, that privileged position, in addition to enabling you to give out these sort of low latency promises of what you're going to decide the state, is that prioritized position is very valuable. And normally that value goes to miners and front runners. And we're super excited that in layer two you have a nice clean way to actually be able to basically sell that right off and repurpose that to something that's much more useful, like public goods funding. Right.
00:53:21.100 - 00:53:41.886, Speaker B: I know you guys are doing cool stuff with giving out rewards to people based on the gas that their contracts used. So we think that being able to sell off the right to be sequencer is an awesome way to monetize, get rid of something that users see as a downside by turning into a good thing. That's, I guess, the only other thing I'd mention.
00:53:41.988 - 00:53:51.590, Speaker A: Yeah, cool. Okay, cool. Great. So thanks a lot for explaining the opportunity crawl ups. That was, I guess, a great episode.
00:53:52.650 - 00:53:53.400, Speaker B: Absolutely.
00:53:54.010 - 00:53:58.422, Speaker A: Hopefully not the last time we're talking in this. Awesome. Thanks.
00:53:58.476 - 00:54:01.510, Speaker B: Oh yeah. Once we have sharding, we'll have a third one.
00:54:01.580 - 00:54:02.102, Speaker C: It's great.
00:54:02.156 - 00:54:02.854, Speaker A: Awesome.
00:54:03.052 - 00:54:03.938, Speaker B: Thanks so much, Alex.
00:54:03.954 - 00:54:04.610, Speaker A: Thanks a lot. Pleasure.
