00:00:04.330 - 00:00:13.854, Speaker A: Hi, everyone. This is Ilyan, Alex from Nier, and we're today with Tim from Cello. Going to be talking about how Celo works. And. Yeah, you can introduce yourself and we can dive in. Yeah.
00:00:13.892 - 00:00:35.000, Speaker B: Great to be here. So I'm Tim Morton. I'm on the engineering team at Celo. Before this, I ran a bunch of teams at Apple running their cloud infrastructure, and I have a background in distribute systems. So when you guys start grilling me on the economics, we'll see how that goes. But, yeah, I'm going to talk about Celo. Cello is a permissionless platform to.
00:00:35.000 - 00:00:38.774, Speaker B: Should I be talking to you or the camera?
00:00:38.822 - 00:00:44.410, Speaker A: Sorry for intro. You can talk to the camera for the details. We can.
00:00:44.560 - 00:01:19.970, Speaker B: Okay, cool. So sello is a permissionless platform, making financial tools available to everybody worldwide from a mobile phone, basically predicated on the fact that low end smartphones are far more widely available and far more widely used by people than bank accounts. Like, there are 1.7 billion people without access to regular financial services. And if we can close that gap a little bit and empower some people to be able to send money between friends and pay at merchants and have access to all the things that we're used to, then that would be a great achievement.
00:01:20.570 - 00:01:21.366, Speaker A: Yeah.
00:01:21.548 - 00:01:21.990, Speaker B: Cool.
00:01:22.060 - 00:01:26.470, Speaker A: All right, do you want to describe kind of, what are the main components? And then we can dive in into.
00:01:26.540 - 00:02:23.980, Speaker B: Yeah. So one of the things that's interesting about Celo in this space is we're very much like a product company. We're focused on trying to make an end user experience, which is so seamless that you don't even really know that there is a cryptocurrency or a decentralized backend under the covers. And so we think a lot about user experience, and we think a lot about the sort of particular set of assumptions that we need to make, given that virtually all of our users will be accessing cello from a mobile device, especially like a low end mobile device. So we care about weak connectivity, how much data we're transferring, how much processing power, and that presents some interesting technical challenges. So to do that, we've sort of taken this whole stack approach. You can sort of think of cello as, like, three things.
00:02:23.980 - 00:03:25.310, Speaker B: So the bottom layer is like the blockchain. So call this, like, cello blockchain. I'll come back and describe these things in a bit more detail in a second. Then we have, like, a smart contract layer, really like most of the business logic of the stack. And then we have a seller wallet app, and obviously, most of our users sort of sit here and using their sort of devices, you can sort of think of this as like a platform in itself. There's a lot of opportunities to build other things, both directly on top of the smart contract layer. Anybody, of course, can deploy smart contracts to the platform, but also we have a couple of things to make that easier.
00:03:25.310 - 00:04:43.080, Speaker B: I guess you can sort of think of it as being like here, this is where the diagram gets a little confusing. This is like, I guess, contract kit, which is a layer to make it really easy to access the sort of first party contracts that exist in the business logic layer here. And then the wallet also uses that. And then the wallet as well exposes this thing called dapkit, which makes it easy to build essentially third party applications on the platform, like mobile apps, which maybe they need to send a payment, or maybe they just need to find out your account details so that they can do other stuff. So what you could basically dapkit allows, say, a micro lending app or some other kind of third party ecosystem app to be able to connect to your wallet, with your permission, of course, sign a transaction or get your account details. And so it makes it super simple to build apps on top. Also, behind the wallet, in terms of just stick this thing over here, there's a nice little cloud.
00:04:43.080 - 00:05:10.462, Speaker B: There are a few things we have sitting in the background, which are like centrally managed services. So the Celo protocol is like an open framework. Celo will have a foundation that governs it. And this will be not just open source, but of course open runtime and fully decentralized. The wallet, of course, are the wallet. There could be many wallets. We hope there will be.
00:05:10.462 - 00:05:52.830, Speaker B: But the wallet that us at c labs are building has a few sort of cloud services behind it to facilitate things which are really hard to do in a decentralized way. So, for example, push notifications. If I send you some money, we have a cloud service which is watching blockchain. Blockchain pushes, exactly. And so then basically talks to a service here, talks to Google or Apple or whatever, and sends a push notification to wallet saying, hey, Tim has just paid you, whatever. And so there's a couple of things there. So they're really around optimizing user experience and around performance.
00:05:52.830 - 00:06:14.580, Speaker B: But broadly, everything is decentralized. So smart contract layer is like the sort of business logic layer. I'll come back to dig into that in a second. Let's talk about. Yeah, let's get to the heart of it. So the blockchain is actually a fork of the go Ethereum client. This is an incredibly ambitious project.
00:06:14.580 - 00:07:33.310, Speaker B: There's a big, big surface area. One of the things we wanted to do was because we care a lot about user experience, was to try and get to market as quickly as possible. And so we looked around, rather than building like a blockchain from scratch ourselves, we looked to sort of build on some of the great technology that's already been built out there in the crypto space. And Ethereum was like the obvious platform of choice, just because of the length of time it's been in production, like the sort of robustness of the implementations, the fact it has a smart contract platform with a broadly supported set of developer tool chain above it, that felt like a great starting point for us. And so building on the sort of shoulders of giants, and we took the go Ethereum code base and then basically looked at what we would need to do to make this work really well from this set of assumptions that we knew that we had from the end users. So that's really about making this thing mobile first. And we recognize as well that the Ethereum community has generated tons of great ideas over the past few years, and certainly not all of them have really made their way actually back into the implementation agreed protocol spec of Ethereum.
00:07:33.310 - 00:08:05.206, Speaker B: And so there are a bunch of things that we have taken inspired by those sorts of ideas, which I can talk more about. But yeah, broadly it's around changes for usability, changes for mobile, being mobile first, and then also I think since Ethereum was arranged, the thinking in general in the space around proof of work versus proof of stake has moved on a lot. And so one of the big changes we made was proof of stake. Yeah. Was to take proof of work out.
00:08:05.228 - 00:08:12.330, Speaker A: And make proof of. Maybe let's dig into that. How did you update Ethereum to proof of stake?
00:08:12.910 - 00:08:51.474, Speaker B: How do we do that? So we started off, I remember there's a quote on, I think it is, I'm going to get this wrong, I think it is the curator recipe page for using zookeeper. So I have a lot of experience with Zookeeper, a lot of experience for my sins. I once implemented, twice actually, for my sins, implemented paxos. It's a complete pain to have to do. And I think the curator page says it quite nicely. It's like good friends don't let their friends implement zookeeper recipes. And I think the same can be applied to distributed consensus.
00:08:51.474 - 00:09:14.318, Speaker B: It's really, really gnarly. There are tons of edge cases. There are very few people in the world who really deeply understand it. Maybe you guys do. Obviously I'm selling ourselves short. I think we have gained that experience. But in order to get further faster, we sort of looked around to see whether it was a good starting point.
00:09:14.318 - 00:09:24.270, Speaker B: So we actually started with the pr that was raised as I think EIP 650, which was called Istanbul, confusingly.
00:09:24.350 - 00:09:26.900, Speaker A: Not the Istanbuls that actually happened.
00:09:27.350 - 00:10:21.634, Speaker B: That's right. Not the Istanbul that has the fork of Ethereum that's happening right now, but actually a separate implementation of a practical, byzantine fault tolerant, like consensus mechanism on the existing sort of consensus interface inside the go Ethereum client. And so luckily, the Go Ethereum client has this sort of ability to switch a lot because it supports proof of authority. It's got the ethash. Yes, there's already like a few implementations in there, and Istanbul plugged into that, but it was never merged. The code was like 18 months out of date. It was also incorrect because it's really hard to write these things.
00:10:21.634 - 00:11:20.882, Speaker B: Kudos to the original authors, they did a great job. But yeah, there were some edge cases we wanted to pick up. It was also like piggybacked on Ethereum's exist, sorry, the Ethereum client's existing gossip mechanism and a couple of other bits and pieces, which meant that from a performance perspective, they were not doing. Yeah, it ended up just basically generating way more messages than necessary. And then there were also like a few security things in there as well. So not only were there like direct security bugs, like just straight up bugs that would affect security, but there were also a few opportunities for denial of service attacks, which were sort of in the code base. So we took that code as a great starting point, and we've done a lot of work to make that a sort of byzantine fortorum consensus implementation inside the golan code base of the cello blockchain.
00:11:20.946 - 00:11:29.690, Speaker A: So pretty much using PbFT for production. What's kind of the basic parameters of that?
00:11:29.840 - 00:11:43.578, Speaker B: Yeah, let's call that PbfT down here as one of the things. So in terms of parameters, you mean like, what are we expecting in terms of number of validators or.
00:11:43.664 - 00:11:49.774, Speaker A: Yeah, what's a rotation mechanism? All those details that actually, like, before.
00:11:49.812 - 00:11:55.702, Speaker C: We jump into fun, I always have my favorite question whenever we talk about PbFT. Why not tendermint?
00:11:55.866 - 00:11:57.666, Speaker B: Yeah, great question.
00:11:57.848 - 00:12:00.770, Speaker C: What is any reason in this world not to use Go tendermint?
00:12:01.510 - 00:12:45.200, Speaker B: Right. So we did look at whatever it was called at the time, Ethermint, I think, and we talked, I think, to the people involved in that project. It was a really nice proof of concept, but the API around Tendermint was actually very, while separately, it's actually quite a nice way of plugging in blockchains into a PbfT system. It unfortunately was very tricky to integrate that into the guest code base. So that was like our sort of looking at it on our own. That was our estimation of it. And I think looking at ethermint and then talking to the folks involved in that project, they found the same thing.
00:12:45.890 - 00:12:52.542, Speaker C: Because Ilya built in 8 hours, tendermint with our runtime.
00:12:52.606 - 00:12:55.262, Speaker A: Yeah, with webassembly and all the transaction processing.
00:12:55.326 - 00:12:55.554, Speaker B: Awesome.
00:12:55.592 - 00:12:57.390, Speaker A: And then plugged in all this February, right?
00:12:57.400 - 00:13:00.162, Speaker C: So I guess, yeah, this February it was pretty mature.
00:13:00.306 - 00:13:02.390, Speaker B: Yeah, we were doing this a little bit earlier.
00:13:03.210 - 00:13:17.642, Speaker C: So Pbft. My concern with PbfT is a view change is practically impossible to write correctly. It's extremely complex. B view change is going to be barely tested because in the normal circumstances, changes don't happen.
00:13:17.696 - 00:13:18.010, Speaker B: Right.
00:13:18.080 - 00:13:26.174, Speaker C: Under normal circumstances, like in the cosmos lifetime. They had, I think at least like last time we talked to them, they had like how many? 100?
00:13:26.292 - 00:13:28.014, Speaker A: Yeah, they had 100. 100 times.
00:13:28.052 - 00:13:37.150, Speaker C: They went to the second in PbfT would have been a view change. It happened 100 times out of hundreds of thousands. Well, I'm exaggerating the total number, but it's very rare.
00:13:37.230 - 00:14:05.770, Speaker B: So the trick with, you can write sort of a pseudocode implementation of pBFT in a few hundred lines, but the devil is in the detail in the implementation. Absolutely. And Istanbul was not straight up Pbft either. But Istanbul also had the advantage that there were two other teams in the broader ecosystem who were using it, scrutinizing it and looking at it.
00:14:05.840 - 00:14:32.818, Speaker C: But I guess another kind of certain is PbfT doesn't have proven liveness. Right? To the best of my knowledge, the original certainly doesn't have proof for liveness. It has an argument, but I might be wrong, but I'm like 95% certain Pbft never actually never proved liveness. But last question before we jump into fun, there were rumors of stellar using hot stuff. Pbft is not hot stuff, right?
00:14:32.904 - 00:15:12.158, Speaker B: Pbft is not hot stuff. Yeah. So I think hot stuff is like a really interesting. So let's talk about the plan right now and then the plan going forward. So PBFT in general, BFT has limitations in terms of the scalability because the complexity, the message can blow out complexity, but it's a very proven algorithm that's been implemented a number of times in this space and outside of this space has good pedigree. From that perspective, hot stuff is really interesting. Obviously Libra have been one of the first to actually really implement it in this space.
00:15:12.158 - 00:15:42.090, Speaker B: Of course, that project is not fully live yet either. But I think at the time that we were making this decision, it was very tentative. Right. And it would be very interesting. You could imagine in the future, like swapping out PpFt for a hot stuff based implementation and getting a bunch of benefits for that. In fact, you can find that we've done a bunch of work. Like there's two tracks in which we're doing this.
00:15:42.090 - 00:15:49.898, Speaker B: One is we want to ship. As I was talking about, we're a product company. We care about our users. I've learned many times in the last.
00:15:49.984 - 00:15:53.278, Speaker A: 15, don't keep iterating. Don't you have something working?
00:15:53.364 - 00:16:17.154, Speaker B: Yeah. Don't keep improving performance. Don't keep trying to add extra features. Get to market, talk to your users, understand what matters to them. Right. And unless you can draw a really clear line from what this person here cares about down to here, then you're wasting your time. And for us, hot stuff has a bunch of really interesting potential benefits.
00:16:17.154 - 00:17:05.298, Speaker B: So we have this two track approach where this is what's on the back of the truck at the moment and this is what we're going to market with. But at the same time, we've been doing a bunch of work around an algorithm called BFtree, which aims to use hot stuff to be able to scale a permissionless approach to consensus for potentially tens or hundreds of thousands of participants where they can just join, form a sort of tree structure. And in so doing, we don't have to have a lot of the complexities of a proof of state mechanism on top of a BFT algorithm to determine who the participants in the algorithm actually are.
00:17:05.464 - 00:17:13.826, Speaker C: And so in blockchain, every block is finalized. I see. So like someone proposes a block BFT and it's final, then the next block is proposed.
00:17:13.858 - 00:17:14.166, Speaker B: That's right.
00:17:14.188 - 00:17:14.914, Speaker C: Et cetera.
00:17:15.042 - 00:17:20.802, Speaker B: Exactly. So there's no pipelining at the moment. Hot stuff is basically just pipeline pipelining.
00:17:20.866 - 00:17:23.180, Speaker A: Well, yeah, without view changes.
00:17:26.910 - 00:17:52.126, Speaker B: The other benefit of nailing this down early was that we've been able to do a ton of load testing, failure testing on very large clusters, and being able to put this through its paces in terms of many practical sort of settings and scenarios. We found a ton of issues. None of them, none of, but almost all of them were outside of the scope of the core algorithm.
00:17:52.158 - 00:17:55.650, Speaker A: It's like the issues are in networking.
00:17:56.010 - 00:18:00.774, Speaker B: That's right. It's all the auxiliary stuff, which makes a big difference.
00:18:00.812 - 00:18:03.830, Speaker C: Is there a concept of an epoch when validators don't change.
00:18:03.980 - 00:18:26.798, Speaker B: Yes, maybe before we dive more into that, let me just sort of flesh out what this thing is here. So smart contracts, obviously this is smart contracts using the regular EVM. So like any of the sort of standard tool chain that you use for development, Ethereum will just work out of the box.
00:18:26.964 - 00:18:31.918, Speaker A: So you have like account ids which are like hashes of the public keys, the usual stuff.
00:18:32.004 - 00:19:04.186, Speaker B: Exactly, yeah. And so contract kit in fact embeds web three and you can also go and do your own thing with that. But the smart contracts, of course people will add smart contracts, there's no restriction on that. But the ones that sort of are out of the box in sello fall into such three categories. So that's first which is around proof of stake and governance. So the proof of stake mechanism is entirely implemented in smart contracts. There's an on chain governance mechanism as well.
00:19:04.186 - 00:19:38.114, Speaker B: Benefit of obviously putting things in this layer rather than this layer is that you can use this on chain governance mechanism to replace it without a hard fork. Sort of a little thing up here to that point is like params, guess that's way too small to read. Sorry about that everybody at home. But for example, one of the things with that Ethereum has been like block gas limit all miners please. I saw Vitalik encouraging mining pools to.
00:19:38.152 - 00:19:42.418, Speaker A: Like well actually block limit. Block limit is something that is votable.
00:19:42.514 - 00:19:43.670, Speaker B: It's votable, but in a.
00:19:43.740 - 00:19:44.310, Speaker A: They don't just.
00:19:44.380 - 00:20:50.618, Speaker B: But it's not by the participants in it's not by like this is governance by seller gold holders, by the entire community, not by the louder. That's right. So like you've seen a situation in Ethereum where miners are holding the rest of the network, I won't say to ransom but you know what I mean, like they have control over that particular parameter. So this sort of puts these things out in the open and means that you can change a bunch of these parameters without having to hard fork or even in many cases update the client, which is quite nice. So having made this too small to be legible, I'm going to erase it here. There's a second thing which is the sort of stablecoin protocol which come back and chat about and then identity as well. So yeah, proof of stake and governance, leaving aside governance for now, proof of stake here is like the mechanism by which you decide who gets to participate in this protocol.
00:20:50.618 - 00:22:12.710, Speaker B: As you guys know, we have implemented a quite interesting proof of stake, I guess protocol. We've been thinking about the scheme that we want to use for a long time. We've been talking to a lot of people and iterating on it, trying to pick some of the best aspects of what we've seen succeed in systems like cosmos and tezos and in other systems that have had a bunch of experience in the wild, talking to a lot of folks and also introducing a bunch of our own ideas. And I actually wrote a couple of blog posts about that just last week. And we're going to be going to a sort of beta net called backlava, an incentivized testnet, where we're going to run a challenge called the great Sello stakehoff, which has obviously british connotations. But the idea of the stakehoff is really to get validated, to get some airtime for this proof of stake mechanism, to get broader input on it from the community, to get validators operational experience like running the network, and also give them the opportunity to potentially win prizes that can convert into gold on mainet. Potentially.
00:22:12.710 - 00:22:43.710, Speaker B: So let's dig into the proof of state protocol. Validators are basically elected by. Hey, let's move over here. Validators are basically elected by, here's validator. Validators are basically elected by sello gold holders or hogglers, as we would like to get them to be affectionately.
00:22:46.230 - 00:22:49.090, Speaker A: Obviously the native token is actually gold. Right?
00:22:49.240 - 00:23:03.234, Speaker B: So sello gold is the native token. Like, you can think of that as equivalent to Ethereum. It is slightly, slight tangent. One thing we've done is also make that ERC 20 compatible. So there is this like duality. You can use it via an ERC.
00:23:03.282 - 00:23:05.270, Speaker A: But you have an API. Pretty much, yeah.
00:23:05.340 - 00:23:07.426, Speaker B: But it's also like the native token.
00:23:07.538 - 00:23:09.110, Speaker C: Is it pegged to gold?
00:23:10.810 - 00:23:39.890, Speaker B: That's an interesting question around the naming. It is definitely not pegged to gold. It is definitely not pegged to gold. Yeah. So it's a native utility token of the platform. Stello gold holders are essentially the voters in the system that can select the validators, but they do so via an election mechanism in which they vote for validated groups. Obviously we have a situation whereby this is a decentralized platform.
00:23:39.890 - 00:24:21.786, Speaker B: Anyone can create any number of accounts. We can't do like one person, one user, one vote. So the only way that we in the community know how to do this right now is to have voting by balances. Yeah. And of course to prevent people vote with a balance and then transfer it to a different account and then vote with that same balance again. Essentially we require them to lock up one interesting difference with Celo compared to other networks that you're probably expecting is when Celo gold holders lock up a balance, they are not putting that balance at risk. So no matter who they vote for, that balance can't be slashed.
00:24:21.786 - 00:25:10.320, Speaker B: So we think that's an important decision because seller gold holders don't have. If you're just an average voter, if you're this person up here, you probably don't know and don't have. Yeah, you don't have the expertise or necessary the time to be able to, let alone the visibility. There's big imbalance in the information that you have about whether these guys are doing the right thing or not. And so what you do is you like, so we have a locked gold contract. You basically lock some gold in locked gold contract and then that allows you to vote. But what you're voting for is actually a validator group.
00:25:10.320 - 00:26:11.454, Speaker B: And a validator group is this sort of new concept which I don't think any other network really has, which is, I guess a wrapper around a set of validators. And now you might imagine these things coming about in two different ways. Maybe there's an entity or an organization that runs validators, maybe more like the sort of professionalized validators that you're seeing cosmos, where they may want to run more than one validator. And so they may want to run a validator group, have validators in their validator group, and potentially be able to swap these validators out if they need to, and then basically put themselves forward as a group. Alternatively, you may see validator groups that don't run validators themselves, but provide a service where they are doing things like security audits, like Kyc on validators.
00:26:11.502 - 00:26:14.834, Speaker A: So they're just like source validators and then kind of package them into.
00:26:14.952 - 00:26:36.266, Speaker B: Right. So the idea is that these things have like a reputation like name recognition, like long term persistence in the network. These are folks that you're voting for. So maybe like somewhat loose analogy is there may be like a political party whereby if you vote Democrat, maybe there are some people who vote Democrat or.
00:26:36.288 - 00:26:38.506, Speaker A: Republican or whatever, independent of who the members.
00:26:38.608 - 00:26:39.210, Speaker B: Exactly.
00:26:39.360 - 00:26:40.070, Speaker A: Because of.
00:26:40.160 - 00:26:46.320, Speaker B: Yeah, exactly. And so you're sort of relying on them to do a bunch of.
00:26:49.410 - 00:26:50.430, Speaker A: Marketing.
00:26:52.050 - 00:27:16.870, Speaker B: Maybe marketing, but I was going to say vetting. Right. So they have a reputation to preserve. They are not going to put somebody on their slate who hopefully they're going to put somebody on their slate that is actually not reputable. Right. And so they have this better ability as well to make sure that a validator is actually doing what you would expect them to, because for a validator to be elected, they need a validator group. Right.
00:27:16.870 - 00:28:04.598, Speaker B: So there is a sort of admission control system here whereby a validator basically needs to say, I want to be part of this validator group and the validator group needs to add them. And what that means is that they have the opportunity to do things like, oh, KYc, oh, let me come and do a security audit. Oh, are these things that you're actually doing? Let's look at that. And so, yeah, at the moment, probably we're going to have like five validators as a limit in a validator group. And, yeah, validator groups are the things that need to put up a stake and validators also need to put up a stake. And the validator group stake is per validator as well. So, yeah, if they have like three validators here, say v two, v three, then maybe they need to put up like three units of stake or whatever.
00:28:04.684 - 00:28:11.358, Speaker C: But it's an addition. So every validator staked and then validator group on itself also staked extra per each validator.
00:28:11.394 - 00:28:35.854, Speaker B: Absolutely. Yeah, absolutely. The stake is like the combination of this amount here and this amount here. And the way that you put up a stake is that you go through the same mechanism here. So you lock gold and then that gold. The benefit of having a unified lock gold mechanism is then that you can also use it to participate in governance. You can use it to participate in validator elections.
00:28:35.854 - 00:28:49.334, Speaker B: You can also use it as a stake for a validator group or validator. Cool. So just like coming to look at what happens next, once you've locked up, you then basically get to vote. You put a vote forward for a validator group.
00:28:49.372 - 00:28:50.774, Speaker A: So you can vote for one group.
00:28:50.892 - 00:29:20.014, Speaker B: You can actually vote for three. Originally we had one, but you can now vote for three. And the reason for this is that we recognize that the security of the system really depends on. Well, let's have a look at a normal election, right? So if this is like the distribution here of votes that are received for parties or candidates in an election. Right, like, I don't know, this is.
00:29:20.052 - 00:29:26.030, Speaker A: Not a bad country, I must say. We're coming from countries with very different distributions.
00:29:26.630 - 00:29:37.602, Speaker B: There we go, one candidate. Yeah, exactly. Anyway, so this is rank here, right? And this is votes. I love a good vote.
00:29:37.746 - 00:29:42.742, Speaker A: We're coming from a country where this is 100%. It's like this.
00:29:42.876 - 00:30:03.230, Speaker B: Nice. Right. So say you're a bad actor and you want to get a validator elected. Yeah. So that you can start doing malicious things. Of course, a lot of the security of this protocol here depends on making sure that one third of validators, no more than one third of validators are malicious. And that's critical.
00:30:03.230 - 00:30:10.714, Speaker B: The behavior of individual nodes is more important than in comparative proof of work schemes.
00:30:10.762 - 00:30:12.558, Speaker C: Of course, one third is also bad.
00:30:12.644 - 00:30:30.118, Speaker B: One third is extremely bad. Hopefully very small numbers. Anyway, so to get your validator elected, you don't need to beat this candidate here. You need to beat like number 100. Say we're going to have 100 validators. You need to have more votes than this candidate here. Right.
00:30:30.118 - 00:31:18.262, Speaker B: And so the ideal graph distribution from a security point of view would actually be much more like this. Right? So votes up here for these guys, extra. Yeah, they're like superfluous, they're wasted. They don't contribute to the security of the system, especially because from a decentralization point of view, it's important to us that we have a bunch of different organizations, individuals participating and contributing and operating validators and validator groups. And so we have this limit. And so basically, we actually limit the number of votes that a validator group can receive such that they can only receive the number of votes required to elect one more than the number of validators that they're fielding in the election. Right.
00:31:18.262 - 00:31:28.774, Speaker B: So if this one was fielding like three validators, as it is, it can only receive essentially enough votes to elect four.
00:31:28.972 - 00:31:31.500, Speaker C: But what happens if one more vote is actually coming?
00:31:31.870 - 00:31:41.614, Speaker B: We just say no. We basically say, thanks for your, thanks for your vote, please vote again. And it's not like if you already voted for it.
00:31:41.652 - 00:31:42.906, Speaker C: It's an interesting mechanic.
00:31:42.938 - 00:31:43.134, Speaker B: Right?
00:31:43.172 - 00:32:12.066, Speaker C: Because imagine there's like a bunch of people who want to vote for validator number one and validator number two. Let's use different colors. Sorry. So there's a bunch of these guys also, people who like letter number two. They generally, they hustlers, they do everything fast. And there's another group which wants to vote for number one. And let's use a square head and for number three, and if you like number two, you're slow.
00:32:12.066 - 00:32:15.014, Speaker C: There's a correlation. All of these guys voted for one.
00:32:15.052 - 00:32:18.520, Speaker B: Okay, I may be a little lost with the shapes of heads here, but, yeah. Okay, cool.
00:32:19.130 - 00:32:20.360, Speaker A: Just use numbers.
00:32:22.490 - 00:32:33.946, Speaker C: It's a very artificial example. Nothing is so concerned. But you see, if these guys all voted first, they all voted for one. You're right, two did not receive their votes. And then the votes for one are not received anymore. But only these guys are left.
00:32:33.968 - 00:32:35.194, Speaker B: They all vote for three. You're right.
00:32:35.232 - 00:32:36.190, Speaker C: And two who was also.
00:32:36.260 - 00:32:54.786, Speaker B: Yeah, so unfortunately, I don't actually believe in this concern myself, I don't think it's a problem. But I think you're right that there are some dynamics, like there are some time dynamics to the system. And this is why we. Coming back to your question, this is why we allow you to vote for three group, especially if you have a lot of sello gold. It may not be possible to find a group.
00:32:54.888 - 00:32:57.160, Speaker C: My vote will actually go to both one and two.
00:32:58.890 - 00:33:01.346, Speaker B: So two is a group or one is a validator.
00:33:01.378 - 00:33:02.342, Speaker C: Oh, it's a validator group.
00:33:02.396 - 00:33:07.846, Speaker B: Oh, yes, I see, yeah. So you can vote for up to three different groups and if any of.
00:33:07.868 - 00:33:10.614, Speaker C: The three is at capacity, my vote will be rejected.
00:33:10.662 - 00:33:34.834, Speaker B: Well, they're independent. So you say, I want to place. You have three separate votes and you can set different balance at any one time. You have a bunch of lot gold. Some of it can be non voting, and then you can take some of your non voting gold and place it for a vote for a group. And that will be accepted so long as we're below that cap. And then you can take some away and move it to a different group.
00:33:34.872 - 00:33:39.038, Speaker A: Wait, so vote is vote weighted by your gold?
00:33:39.134 - 00:33:47.270, Speaker B: Yes, vote balance, comma, group or like, let's call it value or amount or something. V group.
00:33:47.340 - 00:33:52.802, Speaker A: So the same amount you can cast on three different groups.
00:33:52.946 - 00:33:55.350, Speaker B: The same amount or different amounts.
00:33:55.770 - 00:34:04.010, Speaker A: But I'm just saying, like you can have three x. So if I have ten gold, I can vote for 30. My weight can be 30.
00:34:04.080 - 00:34:23.342, Speaker B: No, if you have ten gold, if you have ten gold locked, you can do ten gold's worth of governance voting and ten gold's worth of validator voting. And so that could be four to one group and six to another, or ten to 110 to just one group or like, maybe like three and two.
00:34:23.476 - 00:34:27.822, Speaker A: But then why do you have this limit implementation? Yeah, I can split to ten.
00:34:27.876 - 00:34:30.242, Speaker C: Split it into ten accounts, right, exactly.
00:34:30.296 - 00:34:32.898, Speaker B: Yeah. If you want to, that's fine. This is just an implementation detail.
00:34:32.984 - 00:34:33.330, Speaker A: Okay.
00:34:33.400 - 00:34:33.826, Speaker B: Yeah.
00:34:33.928 - 00:34:34.578, Speaker C: Interesting.
00:34:34.744 - 00:34:37.110, Speaker B: Yeah. Remember we've written this in solidity.
00:34:39.050 - 00:34:40.630, Speaker C: That's a weird excuse.
00:34:43.210 - 00:34:55.820, Speaker A: Yeah, I actually wanted some more, like you said. Is there also like, is this weighted by their stake or. There's like a specific amount of interesting things.
00:34:56.670 - 00:35:51.680, Speaker B: One of the things we wanted to do with this system is create good incentives for validators to contribute to the security of the system. We wanted to make sure that the rewards were interesting for professional validators who go to the effort of properly operating and monitoring hardware, having hardware in colo. Facilities with potentially hardware security modules or good security setups, cameras pointed at the cage of the data center and so on. That doesn't come cheap. But at the same time, we also recognize that costs, the infrastructure costs here are in effect taking rewards out of the pocket of the people who we're building this service for as well. Right. So we're trying to balance the concerns of different constituencies here, like having building such a big platform.
00:35:51.680 - 00:35:57.002, Speaker B: There are many different constituencies.
00:35:57.146 - 00:35:58.810, Speaker A: You're optimizing for all the parties.
00:35:58.890 - 00:36:14.658, Speaker B: Yeah, exactly. So the rewards for validators are flat. They're actually paid in sello dollars as well, because most of the costs of validators and validated groups are actually defrayed in dollars in fiat. Sorry, the stake is in gold. Absolutely.
00:36:14.824 - 00:36:20.438, Speaker A: So what is this number? Is this a governance controlled number?
00:36:20.524 - 00:36:54.080, Speaker B: Governance controlled, yeah. What was it going to be to start with? We're not sure yet. We're thinking, I mean, it's going to be comparable to the sort of stakes that you're seeing in existing networks and the rewards will be comparable and interesting. I think the other thing to note is that validates and validated groups as well as obviously once you've set this as a stake, you earn rewards. We haven't talked about this yet, but you actually earn rewards for locking up the gold here. And we do that. Let's talk about that bit.
00:36:54.080 - 00:37:47.358, Speaker B: So you lock up gold, you vote for some groups, there's an election. We run an election which is exactly the same as a proportional representation election as done in say, like the European Parliament. We use the dehont algorithm, which is the same, which I think is used to allocate seats in the House of Representatives from census data. And so it's widely used for this sort of purpose. It basically will determine, based on the votes, the set of validators that are going to be the next validator set. We have an epoch length which is one day at the end of the last block of every epoch we go through this process. You can continue to vote, you continue to lock or unlock at any time.
00:37:47.524 - 00:37:49.350, Speaker A: And just roll it into next epoch.
00:37:49.370 - 00:37:59.510, Speaker B: That's right. There's like a snapshot. And at that point you can do one thing to say is that there is like a three day unlocking period here. So you unlock, then you wait.
00:37:59.580 - 00:38:01.030, Speaker A: Sounds way too familiar.
00:38:01.450 - 00:38:22.518, Speaker B: Interesting. So we went back and forth a lot on this specific time. Like, you unlock, then you have to wait three days. The reason it's three days is because an epoch is one day. We want to make sure that if you've participated in an election that you still have skin in the game. Right. So we want to ensure that you.
00:38:22.544 - 00:38:24.714, Speaker A: Don'T just come in, do something, and then exit.
00:38:24.762 - 00:39:03.462, Speaker B: That's right. If I want to create an attack on the network by affecting the results of the validator election, by borrowing funds, maybe trying to short sello or something, then use that to purchase a lot of sello gold, and then try and swing the election by that vote. The system needs to ensure that you see the consequences in the potential value of the ramifications of your actions in terms of that, which is why we've set three days. We also want it to be short enough that it's not a huge liquidity challenge.
00:39:03.526 - 00:39:26.610, Speaker C: So say there's a nippoc and there's some sort of validators, let's say it's Ellis, Bob and Carol, and then there's voting happens, right? Is it possible that the entire validator set changes? Like could it be here, Dave, Eve and Frank, let's say. Or there's some maximum percentage of validators that can change between epochs.
00:39:27.110 - 00:39:37.906, Speaker B: The moment there isn't a maximum percentage that can change. We expect in general that the churn will be very small. But yeah, at the moment there's nothing in the algorithm to do we know.
00:39:37.928 - 00:39:42.818, Speaker C: These guys at this point, or at this point, when do we know who's going to be validating an epoch?
00:39:42.834 - 00:39:48.998, Speaker B: Like this is epoch key, literally after all transactions have been okay, so the.
00:39:49.004 - 00:40:11.642, Speaker C: Validators know they're validating 1 second before they literally have to start validating. Right. Okay, next question. Okay, that's where it gets interesting. Say Ellis, Bob and Carol here, like they were building a chain. Oh yeah. So one question is, is epoch measured in time or a number of blocks?
00:40:11.706 - 00:40:12.314, Speaker B: Number of blocks.
00:40:12.362 - 00:40:18.366, Speaker C: Number of blocks. Okay, so the epoch switches when you have like some kind one day divided by the block time of blocks.
00:40:18.478 - 00:40:21.522, Speaker B: Yeah, epoch link mod zero, whatever.
00:40:21.656 - 00:40:28.146, Speaker C: And the block must have two third plus one signatures, right? I guess, yeah.
00:40:28.168 - 00:40:48.182, Speaker A: That's definitely one question that we have definitely faced. Is that you saying these guys need to start validating 1 second after they actually know they need to validate. That means they actually need to be fully synced and know they stake to validate.
00:40:48.246 - 00:40:50.054, Speaker C: You would expect them to be fully synced.
00:40:50.102 - 00:40:55.950, Speaker B: It's just weird. The validators are running, they're basically like trying to participate.
00:40:56.530 - 00:41:04.426, Speaker A: You're assuming all of them are running all the time, and then some of them get selected actually and get rewarded and then sometimes they may not be rewarded.
00:41:04.538 - 00:41:08.770, Speaker C: And is it sample randomly from the set of people who want or is it highest?
00:41:09.110 - 00:41:57.810, Speaker B: Yes, we run this votes, right? So we run this PR election, this proportional representative, and so that chooses the set. Then we shuffle the set, because it's important that we don't want folks to be able to engineer the number of votes they get to be able to determine the order in which the proposer rotates. So then we shuffle. We have a source of on chain randomness as well, and that's what we use to shuffle. And then basically the diff of that validator set is like encoded in the extra data of the header of last block. Yeah. One of the things we've actually done, going back to the mobile first piece, one of the things we've actually done is this gives you some interesting opportunities to make the light client sync protocol a lot more efficient.
00:41:58.550 - 00:42:04.450, Speaker C: So the proposal for the PBFT, is it a fixed schedule or it's random at every block?
00:42:05.370 - 00:42:12.070, Speaker B: It's a shuffled permutation, like a random permutation within the epoch. It's deterministic.
00:42:14.250 - 00:42:16.434, Speaker C: What is the source of onchain randomness?
00:42:16.562 - 00:42:34.894, Speaker B: Basically, every validator, like a commit reveal scheme, every validator puts in, determines a random number. Sorry, Randall. Yeah, I don't know what. Randall, that means that validators have, like.
00:42:34.932 - 00:42:40.190, Speaker C: Every validator has one bit of influence, right? Because they can choose to reveal or not to reveal.
00:42:40.930 - 00:42:42.474, Speaker B: They can go offline, right?
00:42:42.532 - 00:42:50.100, Speaker C: Well, yeah. Or they can choose not to reveal. Right. It's not unbiaseable per se, right?
00:42:50.550 - 00:43:14.330, Speaker B: No, it's not perfect. Okay, cool. Yeah. And so in certain other places, in certain other situations, or certain other sort of parts of the protocol, we end up doing things like waiting a certain, like the chance that you can influence the proposer more, or the sequence of proposers for more than n consecutive blocks ends up like falling off extremely rapidly.
00:43:16.030 - 00:43:20.220, Speaker C: So the block proposer, they choose which transactions to include, right? Yes.
00:43:21.150 - 00:43:57.094, Speaker B: And then everybody else, which is true with ethereum, right? It's very hard to prove a negative. It's very hard to force somebody to include a transaction when there's no mechanism to prove that they actually did receive a transaction. The proposer does receive transaction fees. We've changed the gas pricing mechanism for, compared to what ethereum does. We use like a sort of surge pricing mechanism, which actually Vitalik proposed in an EIP, a number of years. We came up with a scheme, and then we found that Vitalik had also proposed a similar scheme. And then we were like, okay, just.
00:43:57.132 - 00:44:03.466, Speaker A: Adjustment as creates a hybrid of the amount of gas in the block gets filled. Do you just adjust price a little bit higher yeah.
00:44:03.488 - 00:44:28.654, Speaker B: So rather than stepping back over here onto my other shard of the whiteboard, shard zero. Rather than have a block like this and have transactions in the block filling up up to here and basically picking the highest price transactions first and just filling to a fixed limit, what we do is we end up setting the two x limit.
00:44:28.702 - 00:44:29.460, Speaker A: And then.
00:44:29.830 - 00:44:34.660, Speaker B: Yeah, basically we say, oh, actually this is our hard limit. Yeah.
00:44:35.350 - 00:44:38.422, Speaker A: If it's above, then you increase price. If it's below price.
00:44:38.476 - 00:45:01.998, Speaker B: Yeah. And so then we have a target which is some fraction of this. So say, like in your example, half. And so this is like basically a gas price minimum. And so we have the opportunity to burst. If there are loads of transactions that arrive in a short space of time, obviously the workload is going to end up being bursty, especially at peak time. And so you can fill up up to here.
00:45:01.998 - 00:45:14.190, Speaker B: But in that case, what happens is your gas price minimum ends up changing for the next block by a protocol determined alpha. Yeah, alpha, right. And so you do this walk whereby.
00:45:14.930 - 00:45:16.320, Speaker A: Yeah, we use the same.
00:45:18.870 - 00:45:20.430, Speaker B: Great minds think Alike.
00:45:20.590 - 00:45:32.814, Speaker C: What is the incentive for Ellis, bog and Carol to include votes which are not for them? Vote is a transaction. Right. Why would I imagine there's a validator.
00:45:32.862 - 00:45:35.782, Speaker A: Group, Ellis, Carol, and somebody votes for.
00:45:35.836 - 00:45:46.058, Speaker C: Dan and someone says, I want to vote for Dave. What is the incentive for me to include the vote? The transaction fee is probably negligibly small, but it increases my chance of not being a validator. Next, people.
00:45:46.144 - 00:46:11.778, Speaker B: I mean, you're right from the point of view that the validators, the two thirds elected validator, basically you can do anything you like when you're a sort of byzantine quorum of elected validators during the period in which you're elected. And there's sort of no way around that. Right. It's a BFT assumption that two thirds of your validators are honest.
00:46:11.864 - 00:46:17.666, Speaker C: Well, not necessarily. You can build a system where two thirds of them are reasonable effectively.
00:46:17.698 - 00:46:18.326, Speaker B: Right.
00:46:18.508 - 00:46:31.586, Speaker C: It's like my general concern when designing protocols that it could be that for me, there's a change I can introduce to my client which will not hurt me at all. For example, as a seller validator, I can make a change to my client.
00:46:31.618 - 00:46:33.734, Speaker A: Which says, does not accept any votes.
00:46:33.862 - 00:46:45.066, Speaker C: Do not vote for blocks that have votes for other validators, or do not vote yourself, which is going to hurt me a little bit, but maybe not too much. Right. Well, actually it does hurt a little bit because if I don't vote, it hurts.
00:46:45.098 - 00:47:09.942, Speaker B: No, actually, I think if you look at this. Yeah, if you look at this, there's probably going to be some distribution on the votes, right. And so the validators at the top of the distribution, they have no incentive to exclude votes that are not going to, like, you can calculate, is this vote going to push me out of the validator set? And that's going to be false for everybody except for the validator, right?
00:47:09.996 - 00:47:10.166, Speaker C: Yeah.
00:47:10.188 - 00:47:11.926, Speaker B: So you could imagine like validator not.
00:47:11.948 - 00:47:16.486, Speaker C: Proposing they already borderline there. They probably don't want to alienate people.
00:47:16.508 - 00:47:17.990, Speaker A: By not putting their votes.
00:47:19.050 - 00:47:39.870, Speaker B: And. Sorry. Remember that even if a transaction does not appear in one particular block, it's being gossiped. Exactly. Everybody. Well, two thirds need to censor it. And so because there is this transaction fee, sure, it's relatively modest, but of course you have to balance that against making it affordable for people to send transactions.
00:47:41.730 - 00:47:49.678, Speaker A: So if I as a validator don't vote or don't publish my blog, do you pretty much slash them for liveness?
00:47:49.774 - 00:47:52.514, Speaker B: Right? Yeah. So coming back to, is this take.
00:47:52.552 - 00:47:53.634, Speaker C: Slashable, by the way?
00:47:53.752 - 00:47:53.986, Speaker B: Yes.
00:47:54.008 - 00:47:57.066, Speaker C: Okay. This is slashable. It's just the votes which are not slashable.
00:47:57.198 - 00:48:41.362, Speaker B: And when you register to be a validator group or a validator, we check that you have locked gold up to of the certain required level. And when you deregister, we basically only allow you to deregister like a certain time period after you have last been elected. So there is an additional lockup period for validators and validator groups. So at the moment we're thinking that this is probably something like 60 days for validators, potentially longer for validator groups. And so what that means is that while that sort of creates this nice balance, because if you're just like a voter, then you get, why not two days as well? Why not three days?
00:48:41.416 - 00:48:42.020, Speaker D: Yeah.
00:48:46.390 - 00:49:05.394, Speaker B: This is to do with long range attacks and the consequences of basically keeping your needed. The requirement for us to keep validators to keep their keys secure after they have basically stopped being that executing launch.
00:49:05.442 - 00:49:07.366, Speaker C: Attack four days ago is easier than.
00:49:07.548 - 00:49:09.320, Speaker A: 60 days five days ago.
00:49:10.450 - 00:49:26.378, Speaker B: Yeah. So this is like the longest of these periods here. So the max of this and this plus on top of this is like essentially your objectivity window. Right. Anyway, so talking about. Oh, go on.
00:49:26.404 - 00:49:50.706, Speaker A: Yeah, no, I just wanted to understand what happens when you pretty much, I mean, there's two questions. One is like if I just don't show up. Right. Or don't approve something. And then the other question, if it's 60 days and you said you can only release only after you are not in the selection, you weren't selected how do you actually stop being selected?
00:49:50.898 - 00:50:23.026, Speaker B: So at any time you can basically leave a group. Like validators are sort of sovereign in the sense that they can leave a group. A validator group can also kick you out at any time, as you would expect. And so if you know that you're going to go down for downtime and you only have one machine, of course it's absolutely in your interest. So those changes don't take effect, of course, until the end of the end of the epoch. Nothing happens until the end of the epoch from an election point of view. So yeah, let's talk about rewards and uptime and things.
00:50:23.026 - 00:51:04.690, Speaker B: So validators and validator groups receive rewards which are basically factored from this sort of baseline fee that we would like to pay. And what we have to do then is look at cello has a fixed total supply cap, and there's a certain amount that's allocated in the genesis block, and then the rest of this is allocated over time through basically epoch rewards. So we don't have block rewards like ethereum does. We have rewards given out at the end of every epoch.
00:51:05.830 - 00:51:06.900, Speaker C: Okay, interesting.
00:51:07.830 - 00:51:10.914, Speaker A: There's no point if it's the same people, it just keeps them at the end.
00:51:10.952 - 00:51:57.202, Speaker B: Right? And so those rewards go to seller gold holders, they go to validator groups, different rewards, they go to validators, and they also go to a few other things. So we have an infrastructure fund which is basically for projects which can be disbursed by the governance proposal. So like sello, gold holders can vote to give a certain amount of money to developers or to people who are otherwise improving the network. We also have a carbon offsetting fund. So basically we want to make this whole platform and project carbon neutral. And to do that, the seller gold holders can vote to. Basically there's an address and there's an amount, and every epoch that address receives that amount.
00:51:57.202 - 00:53:02.386, Speaker B: Super simple technically, but what it means is that validators and validator, we're not relying on these guys individually to offset the sort of environmental effects of running the machines that they're doing. And then on top of that, we also have the stablecoin has a reserve. And one of the ways in which we can top up that reserve, if we feel it's under collateralized due to, is to basically divert some of the epoch rewards over to that. So that means that at any given epoch you can end up having different needs on your funds, right? Maybe you need to pay more to the reserve. Maybe all the validators had really terrible uptime and you've decided not to pay them very much or maybe fellow gold holders as well are going to get less money and I'll explain why in a sec. But this is your sort of target schedule, right. This is how much you'd like to be spending in a sort of target.
00:53:02.386 - 00:53:06.840, Speaker B: And maybe this is how much you have spent, right. And this could be actually like either.
00:53:07.710 - 00:53:14.406, Speaker A: You'Re overspending, I mean it should be monetarily increasing, right. Just double checking.
00:53:14.438 - 00:53:25.758, Speaker B: No, absolutely right. I guess when you're sort of at the whiteboard, at this angle, you're sort of, yeah, nobody's given money back to this thing. Just clarify that.
00:53:25.844 - 00:53:26.480, Speaker A: Yeah.
00:53:27.890 - 00:54:05.210, Speaker B: Okay, let's start again. So I'm always spending money, maybe I'm spending money at a slightly different gradient each time, right. So I'm either overspending or underspending, right. So I can afford to be a bit more generous or I can't afford to give out as much as we want. So we have this target adjustment. So we have, basically this is the target that we would like to hit for payments to validators, which is say this number of sello dollars. And then we adjust it up or down based on like overspend or underspend.
00:54:05.210 - 00:54:40.630, Speaker B: And so we say, okay, so actually we've been spending a ton, so we can only afford this much. And then what we do is we look at a couple of things. So the first thing we look at is like uptime. And the way we look at uptime is for every block that we are, every proposer includes in that block all of the signatures they've collected from the previous block as well. So all of the signatures, by the way, we use BLS signatures. Attitude validators have two keys. They have an ECDSA key and a BLS key.
00:54:40.630 - 00:55:07.338, Speaker B: We use BLS signatures because we can aggregate them. Overall, they're smaller improvements to the light client protocol. So what that means is that we don't need to wait around. So I guess that piece is the only piece that we have right now. So we don't wait around. As soon as you receive two f plus one commits, then that block is done. But from that point forward we'll still collect signatures.
00:55:07.338 - 00:55:31.730, Speaker B: Collect signatures from the previous block. Yeah. And so the subsequent proposer will also be doing this and will include all of those signatures. And what will happen there is that those signatures will be used for this uptime calculation. So now we use a sliding window. Currently we're thinking like ten. So long as your signature has been included in at least one of the last ten, we consider you up for that block.
00:55:31.730 - 00:55:41.080, Speaker B: So it's like a sort of simple sliding window. And the reason for that is of course like if I'm a malicious validator, just start censoring. Yeah, I would start censoring these things.
00:55:41.930 - 00:55:45.122, Speaker A: But if I missed a block, is that considered.
00:55:45.266 - 00:55:51.002, Speaker B: No. Okay, so if you missed a block, then if your signature is included in the block.
00:55:51.066 - 00:55:52.846, Speaker A: No, but I didn't produce a block at all.
00:55:52.868 - 00:55:55.582, Speaker C: You cannot produce a block in PDFC. It's just going to be a view change.
00:55:55.716 - 00:55:56.350, Speaker A: Okay.
00:55:56.500 - 00:55:59.034, Speaker B: Right. You mean like if you're meant to be the proposer.
00:55:59.162 - 00:56:01.022, Speaker A: Yeah, if I got a view change, pretty much.
00:56:01.076 - 00:56:03.118, Speaker C: But view change is expensive for the system, right?
00:56:03.204 - 00:56:22.582, Speaker B: It is. We don't penalize that right now. I mean we're not assuming, we're assuming that the reason that most honest nodes would end up being down is because of misconfiguration. Network problem like power supply failure, that sort of hardware, the usual things.
00:56:22.636 - 00:56:22.998, Speaker D: Exactly.
00:56:23.084 - 00:56:26.166, Speaker C: But the view changes. They have exponential backup, right?
00:56:26.348 - 00:56:28.150, Speaker B: They do, yeah, they do.
00:56:28.220 - 00:56:34.220, Speaker C: Like if couple of people miss their proposals, then it's like many, many seconds without a block, right?
00:56:36.670 - 00:56:55.230, Speaker B: Typically, yes. So if a proposer doesn't propose, then obviously then you do get this additional timeout. But it's not a massive delay. And obviously because we shuffle the validator, it's very hard.
00:56:55.300 - 00:56:58.690, Speaker C: What is the timeout between two blocks? Under normal circumstances?
00:56:59.590 - 00:57:22.594, Speaker B: Yeah. So currently we're set to 3 seconds plus the regular block delay. So the system has a parameter of block delay. Say hey, we want to make a block every 5 seconds. So if everyone else hasn't seen a block after 3 seconds plus that time, then that's when everyone will send renchins messages. So from that point forward we then take that, say 5 seconds off and then that's the basis from which we do exponential back off up until a certain window.
00:57:22.642 - 00:57:23.906, Speaker C: And is it actually 5 seconds?
00:57:23.938 - 00:57:42.462, Speaker B: The block production delay, I mean, TBD, that's sort of what we've been trying at the moment. We can easily handle 100 validators with that. You got a choice of do you want to increase the number of validators, include crease decentralization or do you want to increase, reduce the latency for transaction finalization for these guys? Cool.
00:57:42.516 - 00:57:45.694, Speaker A: Yeah, that's super interesting. Let's talk about the stablecoin part.
00:57:45.732 - 00:57:59.140, Speaker B: Yeah, sounds great. There's a bunch more stuff in the proof of stake thing. Of course. Have a look at our blog posts and yeah, definitely encouraging people to think they might be interested as validators to participate in a great stellar stakeholder too.
00:57:59.830 - 00:58:02.760, Speaker A: Yeah. So how does sell a dollar work?
00:58:03.530 - 00:58:16.166, Speaker B: Yeah, that's a great question. So of course, there are a whole bunch of different types of stablecoin out there. There's like fiat collateralized, crypto collateralized, and then sort of algorithmic.
00:58:16.198 - 00:58:16.918, Speaker A: Yeah. Balancing.
00:58:17.014 - 00:58:42.558, Speaker B: Right, exactly. And so celo, firstly, is like a sort of family of stablecoins, I would say it's like relatively easy through governance to propose and create new stablecoins. Right now, we've only been thinking in terms of like one approach. Yeah. And the obvious place to start is celo dollar, like a stablecoin that's pegged to the dollar. Also interested in stablecoins, which are not just necessarily pegged to regular fiat currency.
00:58:42.734 - 00:58:47.762, Speaker A: There's lots of, well, there's Sr. What's it called? SRD or something.
00:58:47.896 - 00:59:49.398, Speaker B: Yeah. So I think, I think you're talking about. Yeah, so chairman Sep Canvar did a talk at Devcon recently about that. And so, yeah, if folks are interested, they can check that out. But, yeah, so the stablecoin mechanism is backed by a reserve which sort of combines sello gold, the native utility token of the system, which is obviously decentralized, with a reserve of other crypto assets as well. And so that might be bitcoin, might be like eth, might be other things, might be other stablecoins, especially initially, we're thinking that could be very interesting to include other stablecoins, especially fiat backed stablecoins in that place. Of course, those things exist on different chains, and so it's very difficult to manage that piece of the reserve in a decentralized way, although that is absolutely our aim.
00:59:49.398 - 00:59:54.698, Speaker B: Initially, this will be done in a centralized fashion so that we have a.
00:59:54.704 - 00:59:56.394, Speaker A: Multi sig pretty much, yeah.
00:59:56.432 - 01:00:47.210, Speaker B: So we have basically holdings of these things on different chains, maybe at exchanges. We have a bunch of algorithms which look at this reserve, decide whether we want to rebalance it in terms of the various volatility or the prices of these things to maintain target ratios between them. And so this is going to be centralized to start with, heading towards being decentralized. It's sort of, even while being centralized from an implementation point of view, in practice, the sello foundation will nominate and fellow gold holders will have a say in who and how this. So we have, we have this reserve anyway, so you can see that this is already like a sort of hybrid of the sort of existing approaches.
01:00:47.950 - 01:00:56.686, Speaker A: So is this reserve, this is over cautalization reserve. So similar like maker, if you'd remove this part, this will be like a maker design, right?
01:00:56.788 - 01:01:08.318, Speaker B: Yeah. So it looks pretty similar. And of course depending on the volatility of these assets, we're going to want to change that. The balance, exactly that collateralization.
01:01:08.414 - 01:01:12.020, Speaker A: So what's your colorization ratio for seller gold, for example?
01:01:12.710 - 01:01:37.580, Speaker B: That I couldn't tell you. I guess it depends on the value of this. But there are a few things. What we basically have is like a series of oracles. We do depend on oracles, of course, to provide price signals, essentially the exchange rate between sello gold and sello dollars. Well, and the dollars, I guess regular dollars indeed, yeah.
01:01:38.430 - 01:01:40.006, Speaker A: Would have been great to have.
01:01:40.128 - 01:01:40.800, Speaker B: Yeah.
01:01:41.730 - 01:01:56.234, Speaker A: Two crypto anyway. So just quick, how do you implement that in practice? Is it just fixed set of selected entities or there's some more interesting design?
01:01:56.292 - 01:02:29.642, Speaker B: That's right. So there's nothing particularly exciting about this bit yet. We're going to be turning our eyes to think a lot more about this at the moment. The setup. So for our testnet, the setup is going to be that we run a single oracle and that it publishes price information on chain. We already have a bunch of safeguards on chain to ensure that if there were multiple price signals that we're always taking the median. We don't allow the price to move by more than a certain amount each time, a bunch of other things.
01:02:29.642 - 01:03:01.030, Speaker B: But you can imagine these things putting up stakes and getting rewards. But, yeah, that's an area which we sort of are going to be like postponed. Yeah, postponed, yeah, exactly. So these things provide an exchange rate and of course there's several ways we're going to want to be able to bolster the reserve under conditions where we see high volatility or we feel we're under collateralized. Several different ways of doing that. First is we have a stability fee.
01:03:03.930 - 01:03:19.126, Speaker A: So maybe stepping one bit back is this reserve and the issuance of dollar, who is actually responsible for it? Am I as a user pretty much can lock in some gold and get some dollar.
01:03:19.238 - 01:04:12.860, Speaker B: Exactly. Yeah. So let's talk about that bit first then that is all decentralized and we have a sort of decentralized one to one exchange. I mean, I don't know quite why I've drawn a circle, but I guess like you can have a person up here and you can have the reserve down here, you can basically purchase dollars and that increases, expands the supply and then you can also do the opposite and you can sell dollars exactly for the current price. And so this is totally unchained and totally decentralized. It does of course depend on the oracle price.
01:04:13.710 - 01:04:17.354, Speaker D: And of course if the oracle price is wrong, then there is a risk.
01:04:17.402 - 01:04:20.362, Speaker B: That you can have a, you buy it too cheap.
01:04:20.506 - 01:04:55.740, Speaker D: Yeah. And so therefore you can deplete the reserve. And so these are mechanisms here whereby we can bolster the reserve as well. And that's also valuable if we feel we're under collateralized because volatility increases. This is a sort of uniswap like mechanism whereby it sort of creates this negative feedback loop around price shifts. So if the balance of trading from one to the other shifts away from parity, then what we end up doing is increasing the price against that. So providing, making it increasingly expensive to move.
01:04:56.110 - 01:04:57.690, Speaker A: To move the surprise. Pretty much.
01:04:57.760 - 01:04:58.380, Speaker B: Exactly.
01:04:58.910 - 01:04:59.626, Speaker A: I see.
01:04:59.728 - 01:05:00.700, Speaker B: Okay, cool.
01:05:02.270 - 01:05:16.674, Speaker D: And there's a few things in here which one of which we already talked about, like epoch rewards, we can use that to do the arrow the other way around all of these things. And then also basically a tax on.
01:05:16.712 - 01:05:22.018, Speaker B: Transfers of cello gold, like essentially a.
01:05:22.024 - 01:05:25.910, Speaker D: Tobin tax which can kick in.
01:05:25.980 - 01:05:27.160, Speaker A: How does that work?
01:05:27.690 - 01:05:41.466, Speaker D: So basically it doesn't always apply, but if the reserve is very running short, then we can basically any transfer of.
01:05:41.488 - 01:05:44.954, Speaker B: Sello gold can contribute to.
01:05:45.152 - 01:05:54.474, Speaker A: So you just pump up the pretty much price or the transaction fee, but instead of spending gas, you're actually having percentage going to the reserve.
01:05:54.522 - 01:06:06.778, Speaker D: That's right, yeah. And so the stability fee is a sort of demerage fee on dollar balances. The seller dollar is really issued by.
01:06:06.804 - 01:06:09.620, Speaker A: A bank which actually wants percentage back.
01:06:10.150 - 01:06:20.790, Speaker D: I guess you can think of it as like this is a token that's for exchange. And so there's an incentive. We need incentive to keep these changes circulating, circulating high cost.
01:06:20.860 - 01:06:22.120, Speaker B: Yeah, exactly.
01:06:23.530 - 01:06:25.954, Speaker D: This is roughly the mechanism.
01:06:26.082 - 01:06:28.194, Speaker B: And so obviously part of the concern.
01:06:28.242 - 01:06:32.378, Speaker D: With this was like, well, holding a basket of crypto assets, but also, I.
01:06:32.384 - 01:06:40.154, Speaker A: Mean, how does this basket of crypto assets actually work with everything else? Right. Like, you cannot issue more bitcoin, obviously. And also like, exchanging is hard.
01:06:40.272 - 01:06:42.026, Speaker D: Yeah, you need to basically.
01:06:42.128 - 01:06:49.406, Speaker A: Okay, so you have a rebalancing where you take some gold, sell it and buy some bitcoin and ethereum and then going backwards to just provide more.
01:06:49.508 - 01:07:27.500, Speaker D: And we hope to be able to bring more of that onto the chain through cross chain links later on. Then the question is like, is this going to work in practice? We have many people far smarter than I am looking at who have phds in economics, like thinking hard about this sort of situation. We've done a ton of stability simulation analysis, which we have a white paper on, which talks a lot about the particular situation we're concerned about is if you have a basket of crypto assets and you have a rapid crash in the market.
01:07:27.870 - 01:07:29.100, Speaker A: Like we've seen.
01:07:29.550 - 01:07:30.490, Speaker D: Like we've seen.
01:07:30.560 - 01:07:31.180, Speaker B: Absolutely.
01:07:32.510 - 01:07:39.434, Speaker D: What does that do to the peg? And so we plotted a bunch of those scenarios and looked at the paths.
01:07:39.482 - 01:07:41.786, Speaker B: There, looked at the sort of mechanisms.
01:07:41.818 - 01:07:54.978, Speaker D: That we had available to us in terms of keeping the reserve. We were able to keep a peg in all of the sort of simulation paths that we looked at. And, yeah, I think that informed a.
01:07:54.984 - 01:07:56.278, Speaker B: Lot of the sort of parameters that.
01:07:56.284 - 01:08:00.454, Speaker D: We'Re going to set this thing up with and sort of starting point.
01:08:00.572 - 01:08:02.200, Speaker A: Yeah, it's pretty cool. Interesting.
01:08:03.450 - 01:08:05.720, Speaker D: And then like, identity mechanism, John.
01:08:08.170 - 01:08:08.438, Speaker B: From.
01:08:08.444 - 01:08:47.166, Speaker D: A user's perspective, there's a bunch of things you want to do, right. Firstly, you don't necessarily want to be paying in currencies which are recognized or which are volatile. You want currencies which feel familiar to you and whose value is familiar to you. And so that's where the stablecoin mechanism comes in. You want a platform where it just works from your mobile device, which is where a lot of the infrastructure that we built comes in. We also allow you to pay for transaction fees in any currency. So we've modified the sort of transaction fee payment mechanism so that validators can basically collect transaction fees.
01:08:47.198 - 01:08:52.680, Speaker A: Do they need to whitelist them or. Literally anything can work. No, I can launch my own.
01:08:55.850 - 01:09:03.174, Speaker D: It's basically governable. There's a governable whitelist of like, hey, validators, these are the currencies which you should accept.
01:09:03.302 - 01:09:06.346, Speaker A: And do they receive the currency or do they receive the doll?
01:09:06.448 - 01:09:07.510, Speaker D: They receive the currency.
01:09:07.590 - 01:09:09.338, Speaker B: Okay. They receive the currency because they need.
01:09:09.344 - 01:09:10.810, Speaker A: To go and find out how to like.
01:09:10.880 - 01:09:13.366, Speaker D: Right. So there's no dependency on the oracle.
01:09:13.398 - 01:09:14.410, Speaker B: Price at that point.
01:09:14.560 - 01:09:15.718, Speaker D: Well spotted.
01:09:15.894 - 01:09:16.378, Speaker B: Yeah.
01:09:16.464 - 01:09:20.558, Speaker D: So, and the third thing is, know, I download an app and I've got.
01:09:20.564 - 01:09:21.998, Speaker B: A bunch of contacts, I've got a.
01:09:22.004 - 01:09:42.006, Speaker D: Contact list and I want to send money and receive money from my contact list. So to do that I give the app permission. And of course the contact list has a bunch of phone numbers in it. So what we have is a mapping, basically from phone numbers to addresses. We of course want that to be secure so that nobody else can recover that.
01:09:42.188 - 01:09:42.678, Speaker B: Exactly.
01:09:42.764 - 01:10:01.802, Speaker D: Hey, I'm actually Tim. And so I think you think you're paying me and you're actually paying some attacker. And of course the security is all about new transfers, it's not about access to existing balances. So to do that we have a decentralized mechanism for verifying phone numbers.
01:10:01.856 - 01:10:02.026, Speaker B: Yeah.
01:10:02.048 - 01:10:28.390, Speaker D: So there's a couple of different pieces of this. So the first thing is that in the onboarding flow of the app, the user can request verification. They pay a small verification fee that covers the cost of sending n text messages. In fact, they can choose what n is. The client can choose what n is. But of course, for a simple user experience, that number is essentially fixed. And then what happens is like a flow.
01:10:28.390 - 01:10:30.694, Speaker D: Where am I going to draw this down here?
01:10:30.732 - 01:10:31.346, Speaker B: This is a flow.
01:10:31.378 - 01:11:19.074, Speaker D: So like you basically do a request, then you wait for blocks. If this was in block b, this ends up being in block b plus four. The reason for this is it makes it infeasibly difficult to control the randomness between this point. What you're really requesting is like you're saying, hey, I want my account to be associated with this hash, but at this point you're saying, okay, so select who's going to attest me, who's going to provide assessations. And at that point we use the randomness to basically pick four validators who are going to be in charge of getting sending sms.
01:11:19.122 - 01:11:24.006, Speaker A: And so they need to run like Twilio connect or something.
01:11:24.188 - 01:11:24.806, Speaker B: Yeah, sort of.
01:11:24.828 - 01:11:50.606, Speaker D: So it's like this attestation service. In fact, every validator in sello runs like three processes or potentially more. So like the standard setup is like there's a validator, there's a sentry. This thing hides the validator from the rest of the world. Proxies, all of their. When I say sentry, what I really mean is proxy terminology is changing. And then you also run like an.
01:11:50.628 - 01:11:53.070, Speaker A: Atheist patient service and zookeeper.
01:11:58.950 - 01:12:30.682, Speaker D: We will probably be doing like threshold validation. So there's a bunch of different nodes, b three, b two, b one, which all have a shard of the actual keys. And you need like two out of three or whatever to combine them to be able to do signatures. We'll also support multiple proxies, but the basic setup is with those three. So the assessation service, basically you find out the validators, you find out the identity of the validators who when you.
01:12:30.736 - 01:12:32.234, Speaker B: Ask them to send a text and.
01:12:32.272 - 01:12:45.826, Speaker D: They send that through to you, signed by their assessation key, you can then submit that back on chain. And that is like the thing which says, yes, the protocol believes that you have access to this phone number, this account.
01:12:45.928 - 01:12:49.890, Speaker A: So how's phone number actually recorded on chain?
01:12:50.630 - 01:13:09.074, Speaker D: So we never record the phone number itself. We record like a sorted hash and we will be changing that over to use script, I think as well. Basically there's a mapping.
01:13:09.122 - 01:13:19.180, Speaker A: So if it's a salted hash. The question I always had was, if it's a solid hash, then I need to know the salt to verify that this is you. Right, right.
01:13:20.750 - 01:13:39.490, Speaker D: Yeah, you're right that obviously all of this data is available on chain. And there is like a sort of diction. There is like a sort of attack whereby I can basically go through and find out. I can sort of rainbow for any phone.
01:13:39.560 - 01:13:40.180, Speaker A: Yeah.
01:13:41.990 - 01:13:47.560, Speaker D: Also the space of valid phone numbers is not like a very exactly large input space.
01:13:49.690 - 01:13:53.622, Speaker A: So I can, in theory, map every phone number to an address.
01:13:53.756 - 01:14:21.326, Speaker D: Yeah, in theory. One of the things we've been thinking about is how do we get around this? And so we actually have an accounts mechanism. So this is not what we have right now, but it's like something we're working on. So we have an accounts mechanism. So this is like the way that validators can record metadata about themselves. They can claim, hey, I've got access to this DNS, I've got access to this keybase account and so on. It's also the place where individual account holders can record a public key.
01:14:21.326 - 01:15:03.030, Speaker D: And so we also support encrypted comments in transactions so that I can send you a bunch of emojis to indicate that I'm paying you for coffee. And so that ends up going into using that public key to basically encrypt that comment. That same public key can, rather than basically, there's a mechanism whereby we'll be able to say, hey, actually don't send to this address. Send. All the funds should be sent to an address which you can communicate, which you can basically use this public key to go and communicate with me for. So that public key is like, hey, let's go and do some out of band communication and I'll tell you where.
01:15:03.040 - 01:15:04.010, Speaker B: To send the funds.
01:15:04.090 - 01:15:14.506, Speaker D: Okay, so that is the piece which is not yet implemented because it requires a bunch of, like, we need to figure out exactly how and where to do that communication.
01:15:14.698 - 01:15:19.794, Speaker A: So just for one sec. You said it's a salted hash. Why do you salt it?
01:15:19.832 - 01:15:24.338, Speaker D: I think it's a salted hash. I think it's a salted hash. You're pushing my.
01:15:24.424 - 01:15:39.562, Speaker A: Because if it's salted, then it's useless. If I have a phone number, I don't know the salt if it's not. The problem is that what you're trying to achieve is also the reverse of privacy. Right. Because you're trying to, like by me knowing phone number, I can find your account.
01:15:39.616 - 01:15:40.214, Speaker B: It's really tough.
01:15:40.262 - 01:15:41.638, Speaker D: Yeah, it's really tough.
01:15:41.814 - 01:15:42.522, Speaker A: All right.
01:15:42.656 - 01:16:05.454, Speaker D: In a public setting, this is like an area like privacy is going to be a significant focus for us. Like private transactions, private balances, private amounts, like making this mapping as private as possible. But there is, as you point out, this fundamental tension between what you're trying to build is a phone book and.
01:16:05.492 - 01:16:07.570, Speaker A: Then you also don't want it to be public for everyone.
01:16:07.640 - 01:16:08.740, Speaker D: Right, exactly.
01:16:11.030 - 01:16:16.910, Speaker A: We have been thinking about that as well, and we actually have some ideas how to do it. Like peer to peer gossip style.
01:16:16.990 - 01:16:18.162, Speaker D: Right. So the way that.
01:16:18.216 - 01:16:20.278, Speaker A: Yeah, that's kind of basically doing a.
01:16:20.284 - 01:16:26.920, Speaker D: Peer to peer gossip style mechanism. The era of phone books was not so bad. Right.
01:16:27.450 - 01:16:34.426, Speaker A: Well, except that that phone book did not have attached balance to how much money that person has when I actually want to track them down.
01:16:34.528 - 01:16:35.420, Speaker B: That's true.
01:16:35.790 - 01:16:40.746, Speaker D: But you can imagine that isn't to say that's the only account that this.
01:16:40.848 - 01:16:41.498, Speaker B: Exactly.
01:16:41.664 - 01:16:43.094, Speaker D: That is just their inbox.
01:16:43.222 - 01:16:43.526, Speaker B: Right.
01:16:43.568 - 01:16:50.654, Speaker D: And so one of the things that you can do from the client perspective is use that as an inbox and withdraw funds from that.
01:16:50.772 - 01:16:54.800, Speaker A: Of course, then you see all, everything that's coming in anyway.
01:16:56.610 - 01:17:00.382, Speaker D: It's a challenging problem and it's one we're spending a lot of time thinking about.
01:17:00.516 - 01:17:06.662, Speaker A: All right, cool. I mean, that's really cool stuff. And I think we're good on time, so. Yeah.
01:17:06.716 - 01:17:06.934, Speaker D: Awesome.
01:17:06.972 - 01:17:07.462, Speaker A: Thanks a lot.
01:17:07.516 - 01:17:08.998, Speaker D: Well, thanks for taking the time.
01:17:09.164 - 01:17:16.262, Speaker A: Please check out seller.org, seller.org. And yeah, the upcoming bake off. Yeah, that is a cool name.
01:17:16.316 - 01:17:16.870, Speaker D: Bake off.
01:17:16.940 - 01:17:17.800, Speaker A: Bake off.
01:17:18.410 - 01:17:18.870, Speaker B: Cool.
01:17:18.940 - 01:17:19.730, Speaker C: Well, cheers.
01:17:19.810 - 01:17:24.740, Speaker A: Cheers. Close.
