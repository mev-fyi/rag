00:00:03.370 - 00:00:08.414, Speaker A: Hi, everyone, this is Alex from Nier, and with me today is Ben Jones from Plasma group.
00:00:08.532 - 00:00:09.118, Speaker B: Hey, guys.
00:00:09.204 - 00:00:18.618, Speaker A: And we will talk today about plasma cash flow, the new flavor of plasma, and we will go into a lot of technical details. And Ben, would you like to introduce yourself and give us a quick overview?
00:00:18.714 - 00:00:46.570, Speaker B: Sure. Yeah, absolutely. So I'm Ben. I'm a part of Plasma group, which is an open source, community driven plasma implementation. So we're going to talk about something today that's been called cash flow. We kind of consider it just a plasma cache variant, and it's our specification implementation. So particularly the thing that we're going to talk about is we're going to assume that you have a bit of knowledge about plasma cache, and we're going to talk about the key difference in this particular variant that we've implemented.
00:00:46.570 - 00:01:29.130, Speaker B: And basically what it comes down to is an attempt to solve the fixed coin denomination problem. So if you remember, maybe in the plasma cash world, you have these unique coins which have a unique coin id, right? And of course, these are the things in the bottom of the merkel tree, in the block structure. And if you want to send a coin at this particular spot in the merkel tree, you can send a coin. So it's like a new color, new owner, whatever. Okay, so that's really, really cool. And it's great because plasma cache solves a lot of problems by doing this over what's called plasma MVP, which was the state of the art before. So the main thing that it solves is no mass exits.
00:01:29.130 - 00:02:26.214, Speaker B: Okay, so very, very briefly, why that's important. This is just important with plasma cash generally is in earlier versions of plasma, because coins weren't defined with this sort of non fungible id. What ended up happening was the operator could create a Utxo, sort of like out of nowhere, right? It's just like a magic poof of a Utxo. And then they could try to exit that. And this was really, really bad, because in plasma cash, when you exit, you're specifying this coin, but before you weren't really specifying anything, you were just sort of specifying this poof of a previous input. And so because of that, if anyone saw this occur within the next whatever challenge period, we'll call it a week, everyone had to get out. Okay, so plasma cash was great because by making all these coins nonfungible, you can fix that problem by making exits beyond coins, not on these sort of poofy utxos.
00:02:26.214 - 00:02:45.760, Speaker B: So there's actually really not utxos in the plasma cash model, there's just like coin transfers. Okay, great. So that was really, really good. Really, really good thing that Pisa cash introduced. Kind of bad thing that introduced was these coins have to be a fixed size. Right. They're like these discrete, non fungible things.
00:02:46.930 - 00:02:48.514, Speaker A: They don't have to be equal to each other.
00:02:48.552 - 00:02:49.042, Speaker B: Right.
00:02:49.176 - 00:02:52.018, Speaker A: It's just that you cannot split them after you move there.
00:02:52.104 - 00:03:23.002, Speaker B: Absolutely right. So in theory, these can have different denominations, and I believe there are some plasma cash implementations that do have different denominations. However, for example, in our implementation, we do still have a notion of these coins. However, they're all fixed denomination, because we solve this sort of changing denomination thing a different way. Okay, so what is it that we actually do to change that? It's a pretty simple change. It just requires thinking about very carefully to make sure that it's still secure in the context of the exit game. But it's a very simple concept.
00:03:23.002 - 00:03:51.670, Speaker B: The concept is simply that we treat transactions over ranges of coins instead of particular coins. So now here, now instead of sending just one coin, I define a transaction on a range of coins. And this is one transaction, just one single transaction. And with this transaction, we may update all of these coins simultaneously.
00:03:52.330 - 00:03:56.470, Speaker A: But how do you ensure that your coins are in a contiguous range?
00:03:57.770 - 00:04:38.550, Speaker B: So that's a very good question, and we'll hopefully get into that later. The essence of it is you have to do that separately, and that's going to involve basically atomic swaps. We've explored a few ways to do it. It seems like the best is probably voluntary atomic swaps. In essence, the idea is that if you have some coins here and some coins up here, and someone has some coins here and some coins here, it's advantageous for both of you to align all of those coins because you can treat them in one exit. Right, okay, so that's the sort of basic transaction format is just, you want to do transactions over ranges of coins. Okay, so what does that mean? There's a lot of, in previous sessions on plasma cash flow, some people have definitely talked about this as being like coin splitting or coin merging.
00:04:38.550 - 00:05:14.154, Speaker B: I want to sort of try to break down that idea with this video. It's really not about coin splitting or coin merging, it's about the coins being very, very small. So maybe a three coin transfer is a very bad transfer. Example in this case. In reality, in our implementation, we have 16 bytes worth of coins. And so that's literally like bajillions, whatever. Exactly one bajillion possible coins and you might transfer like thousands of coins, basically, the way to really imagine it is like coins on a number line, right? So that's literally how we treat these transactions.
00:05:14.154 - 00:05:37.510, Speaker B: So we say like a transaction might be on the range 100 to 100. Right. And what that means is there's like a zero here, and then out here is 100, and then out here is 200. So you can send all of these coins in just one go. And that is the really important property that we have. So it's going to be even probably in practice, way more than 100. It's going to be like you could do a million.
00:05:37.510 - 00:05:40.218, Speaker B: There's really no reason not to. Yeah.
00:05:40.384 - 00:05:51.386, Speaker A: And so now when I send, I need to send the proofs of inclusion, or whatever they called in plasma for each of those 100 coins, right?
00:05:51.408 - 00:06:21.270, Speaker B: Correct. Yes. So what you're getting at is going to be, probably end up being the meat and potatoes of this video, because what turns out to be the case is that it's very tricky to define a transaction format in this way that still allows you to have light clients. Okay, so maybe we'll erase this and go over a little bit on how light clients work in plasma cache. So along with mass exits. Yeah, maybe we'll just write it here first. Like light proofs, we call them light proofs.
00:06:21.270 - 00:06:56.702, Speaker B: Light proofs are a really important thing that you can get. Okay, so what does this mean? This means that to ensure that your particular coins are safe, instead of downloading an entire block, you may download just one branch in the block, one branch in this Merkel tree. And that allows you to have clients, which we have. Like if you go to burner plasma group, you can do full verification. And it's like a full node on these light proofs on your phone. And that's because they only have to download one branch. So even if you have the operator running this massive AWS instance, that's like a bajigillion transactions per second.
00:06:56.702 - 00:07:01.246, Speaker B: You can verify just one in about the same height. And so it's just one single inclusion.
00:07:01.278 - 00:07:03.522, Speaker A: And you're downloading it still for every block, right?
00:07:03.656 - 00:07:22.526, Speaker B: Absolutely. You are downloading it for every block. You absolutely must do that. Yeah. Okay, so light proofs were the other big thing that we do. Maybe we'll erase this and talk about what those light proofs look like in plasma cache and why they work, and that will sort of inform why the range based version is a little tricky. Okay, so I love my merkel trees, right? Aligned.
00:07:22.526 - 00:08:26.058, Speaker B: I don't know how the other viewers feel about this, but I think this is just like the best way to draw merkel trees. I'm a big fan, as I say, messing it up. Okay, so this is like we can think of as the block structure in plasma cash. So we're just going to review how plasma cash work. So at each of these things are these non fungible coins, right? So we have like zero, one, two, blah, blah, blah, right? So in normal plasma cash, the way that you do a transaction on, say, coin two, right? If we want to turn that into like a colored in square, the way that you do that is in the block at height n whatever, in this block, you must get the inclusion proof 42. That is like Alice sending to Bob, let's say. Right? Okay, so at this exact Trace along the Merkel branch, you must get a transaction, right? And of course, if there's no transaction here, then you know things that haven't been computed, right? So very simply, like that is the light proof structure.
00:08:26.058 - 00:09:00.220, Speaker B: And the whole point is that because a transaction on coin two is only valid in index two, then you don't care about any of the rest of this structure. This whole subtree you can ignore, right? This part you can ignore. You don't need the whole thing. So of course, one note in Merkel encrusion proofs, right? You need like the siblings of each node, right? So in reality, it's going to be like this guy and a guy here and a guy here, right? Corresponding to this guy and this guy and this guy. Right? Yeah. And that's how you do it up. But effectively, you can think of it as just like this branch, right? That's how I like to think about it.
00:09:00.220 - 00:09:23.550, Speaker B: Okay, does that make sense? That's plasma cache. Okay, cool. Okay, so that's wonderful. We don't have to download any of this stuff. It doesn't matter at all. Now here's where the problem comes in. The question that you have to ask yourself is what branch, what index, what leaf index in the Merkel tree, does a range go in? Right.
00:09:23.550 - 00:09:50.074, Speaker B: Because we don't want it to go in every coin that's in the range. Right? So for example, if we had a transaction, let's say we want to do a transaction over coins two, three and four, right? We want to have just one inclusion proof for that. If we had one at coin two and at coin three, at coin four, that might as well just be a transaction of coin two, three and four. So we need some way to describe ranges. So we need something that looks like something like this branch that says, okay, actually it's the range two through four, right? That's what we want to do.
00:09:50.192 - 00:10:10.126, Speaker A: But also, quick question. So in plasma cash flow, if someone sent me a range from 100 to 200, and let's say I already possessed previously, the range from 50 to 100, can I send later 50 to 110?
00:10:10.228 - 00:10:12.094, Speaker B: You absolutely may. Yes.
00:10:12.132 - 00:10:12.430, Speaker A: Awesome.
00:10:12.500 - 00:10:39.046, Speaker B: It is a quite wonderful property of the system. And so this is something interesting. This is why I mentioned before, we don't have utxos. Sort of. All of the logic here is not referencing previous transactions. It's all pretty much implicit. So it's implicit that a transaction on a particular range is spending the transaction that was like the last transaction in that particular coin, so that it's like the most recent one, then some non inclusion proofs, and then the new one.
00:10:39.046 - 00:10:47.030, Speaker B: Right? And so it's like implicit that's referencing that. So because of that, if you receive this transaction, and you receive this transaction, you may spend that immediately.
00:10:47.110 - 00:11:13.170, Speaker A: But before we go into how it is actually implemented, there's some fundamental limit as it feels to me. Imagine that I received, over the course of time, 1 billion consecutive tokens, but each of them was an individual transaction. You're saying you have some magic way for me to send all billion of them in a single transaction, so that a light client will be convinced that I'm not tricking them without downloading 1 billion proofs.
00:11:13.670 - 00:11:21.110, Speaker B: Very good. So, absolutely, you can send in one transaction though? Absolutely. The light client must check the 1 billion coin sends in the past.
00:11:21.180 - 00:11:22.278, Speaker A: Unfortunately true.
00:11:22.364 - 00:11:27.160, Speaker B: Unfortunate. Okay, so if you want to get to that point, let's snark it, right?
00:11:27.470 - 00:11:29.146, Speaker A: That's the answer to all the problems, right?
00:11:29.168 - 00:12:27.434, Speaker B: Exactly. But notably. So maybe one thing to note is that it is important that this is not a history. It doesn't intertwine histories of coins. So one interesting property that we'll see later, perhaps, is, for instance, if the range 50 to 150 is transacted, right? And then at block n plus one, we see 100 to 200 transacted, right? Let's say I eventually receive coins like 100 through 150. I do not need to know whether or not the owner in this transaction owned coins 50 to 100. And I do not need to know whether the person transacting coins 100 to 200 owned coins 150 to 100.
00:12:27.434 - 00:12:57.730, Speaker B: So this section, because I'm not receiving it, this section I don't care about. And this section, I don't care about the real worry with that. So sure, your 1 billion coins thing is a problem. The really bad thing would be if this could sort of fan out and end up like everyone downloads the full history. So we do at least have this property maintained that you only care about the transactions and the owners on the particular range of the transactions that you care about. So very interestingly, right, it could be that this transaction is both valid and invalid at the same time.
00:12:57.800 - 00:12:59.946, Speaker A: But the part that you care about is valid.
00:12:59.998 - 00:13:07.010, Speaker B: The part that you care about is valid, so you don't care. So literally, the 150 to 100 could be completely wrong. Doesn't affect your safety.
00:13:07.090 - 00:13:15.418, Speaker A: So effectively, if there is a transaction which sends tokens from 100 to 200, the validity property is per each individual.
00:13:15.584 - 00:13:39.890, Speaker B: Token, it's per token. And the way that that is manifested in practice is that the challenges that you perform are on a particular coin id, they are not on a range. So when you submit a challenge on an exit, and exit is over a range, and you say, I'm challenging that exit, but I only have to specify one invalid coin in that exit to invalidate the whole thing. And so I just specify the one and it doesn't matter.
00:13:40.040 - 00:13:40.354, Speaker A: Yeah.
00:13:40.392 - 00:13:40.690, Speaker B: Cool.
00:13:40.760 - 00:13:41.762, Speaker A: Let's see how it's done.
00:13:41.816 - 00:14:01.178, Speaker B: Cool. Okay, great. So we kind of got to it before. I think maybe we'll go to a better example than coins two through four, because that's kind of a small range. And in practice, what we want here is like much larger things. So let's do that. Okay, so basically, the problem that we're going to outline here is effectively a double spend problem.
00:14:01.178 - 00:14:29.234, Speaker B: This is effectively the naive attack on this ranged based solution. Okay, so let's see what that means. Okay, I'm just going to do like a height. Well, yeah, let's just do a height two tree. Okay, so let's say right here we have a transaction on 100 200. And by the notation that we usually use, this is like inclusive and exclusive, but whatever. Okay, so let's say that we have a transaction here on range 100 through 200.
00:14:29.234 - 00:14:55.526, Speaker B: Okay, that's great. That's what we want. However, anytime that I receive a transaction, I must be ensured not only that I am receiving a transaction, but also that there is not a double spend included at the same height. Okay, so here's the problem. What if in this block structure, let's say I just download this, right? So I see this, so I see this thing and I see this thing, but I don't see these guys, right? This is the whole structure.
00:14:55.558 - 00:14:57.894, Speaker A: Oh, you're saying like this leaf corresponds to the entire range.
00:14:57.942 - 00:15:26.350, Speaker B: So let's say that this leaf is the transaction on this range. We want the property. So maybe one thing to note there, one of the huge advantages that this scheme gives you over the simpler plasma cache. Right. It is a plasma cache variant, but one of the huge improvements is that the height of the tree is not determined by the number of coins. This is very interesting. So before in plasma cache, there was a max height of the tree defined, right, in plasma cash.
00:15:26.350 - 00:15:54.746, Speaker B: And that defined for, based on that height, that fanning out of these merkel trees defined the total number of possible coins. In this version, there's unlimited deposits. And the thing in every single one of these slots is simply one transaction, right? Very critically, just one. So what that means is that the height of the tree is not the log of the number of coins, it's the logarithm of the number of transactions, which is a really nice property. So to get that, we need one transaction per leaf.
00:15:54.938 - 00:15:57.550, Speaker A: Okay, that doesn't sound like it will work yet.
00:15:57.700 - 00:16:27.962, Speaker B: It doesn't, yes, it's very, very tricky. You're totally right. Right. So what is the problem? So obviously the attack here is, if I download this branch, right, basically what I get is I get this thing, I get this guy, and I get this guy, right? And I use that to compute the root and verify it against the root on the ethereum main chain. Okay, so what's the problem? The problem is that I haven't downloaded these guys, right? So it's a really, really problematic thing, because what if right here, there was also 100 200, right? And this was like a to b, and this was a to c, and.
00:16:28.016 - 00:16:30.380, Speaker A: I presume transactions are sorted in some way.
00:16:32.430 - 00:17:31.586, Speaker B: So the solution that we will impose will be sorting will end up being sorted. Absolutely. However, it's one thing to note here that you could theoretically implement this stuff without doing any sorting and any of this stuff, and you just would lose light client support, which is very interesting, because you remember that before we wrote the mass exit problem as being one of the problems with older versions of plasma, where if an invalid exit began, everyone else had to get out. Those older versions also didn't have light clients like plasma cache sort of like, found both the mass exit solution and light clients in one go. If we do this range thing, interestingly, we can actually get rid of mass exits, but not have support for light clients. So if you just were required to download all of these leaves and make sure that there wasn't a 100 200 transaction there, that would actually still be better because it would solve the mass exit problem. But it's not ideal because we really, really like the idea of light clients.
00:17:31.638 - 00:17:33.146, Speaker A: So what's the beautiful solution?
00:17:33.258 - 00:17:54.846, Speaker B: Okay, so the beautiful solution is that we need some way for just the information in this branch. We need a way for just that information to be sufficient to prove to the light client that no other such valid transaction on the same range. On an intersecting range. In an intersecting range. Exactly. Right. Exists over here.
00:17:54.846 - 00:18:29.630, Speaker B: Right. And so effectively, what we're going to do is we're going to do a branch validity condition, right? So we already had one of these in vanilla plasma cache. Okay? The branch validity condition is very, very simple for a transaction on range three, for a transaction of coin three, the valid branch is branch three. Right. That was a very, very simple validity condition, and that's the basis for light crime proofs. So all we need to do is do a branch validity condition for ranges. Right.
00:18:29.630 - 00:18:40.980, Speaker B: That's what we need to figure out. Right. And that really ends up being like, the key problem that you have to solve with this. Okay, so does that make sense? Questions?
00:18:41.910 - 00:18:44.114, Speaker A: Well, let's see how the branch validity works.
00:18:44.152 - 00:19:19.386, Speaker B: Okay, great. Okay, so the trick is we no longer are doing a simple merkel tree. So interestingly enough, shout out to Dan Robinson, who came up with an incredibly beautiful, even more elegant solution to this than we previously had. So in lots of ETH research posts and stuff, there's been a more contrived answer called the Merkel sum tree. What we're going to go over today is something that actually, I don't think has been written up to date, but it is a Merkel index tree, and it's a little more intuitive way to think about it, actually, a lot more intuitive way. It's very, very beautiful. Shout out to Dan.
00:19:19.386 - 00:19:53.354, Speaker B: He's amazing. Okay. But the basic idea in all of this is that a Merkel tree just ain't going to cut it. We need to add something into the Merkel tree, something extra that's going to allow us to prevent this. Now, you might consider, like separate, an entirely separate data structure that the validity condition also references both of these data structures and does it that way. I haven't really explored thoughts there, but you might even imagine that you could do some RSA accumulator magic, all the fun plasma memes, right? But the best one would be to just embed it in the block structure itself. Okay, so that's what we're going to do.
00:19:53.354 - 00:20:24.850, Speaker B: Okay, so what does that mean in practice to define an arbitrary binary tree? Right. The way that you define that is simply like the parent function of left and right. So this is the left sibling and the right sibling. Whoops. I'm saying sibling right. So in a Merkel tree, right, a Merkel tree is a binary tree where parent equals very simple. Okay, so we are going to make.
00:20:24.850 - 00:21:15.922, Speaker B: So that's like Merkel, right? This is like vanilla Merkel, right. What we are going to define is something called a Merkel index tree. Okay, so maybe one other thing to note here is that we would have to define what is the set that left and right belong to as well, in a sort of Math sense. So in practice, we would also have to say that the left and right are the 32 byte hashes that the parent resolves to. Okay, so now we're going to define a new parent function and we're going to define new data elements for the left and right. So before, maybe I'll just continue the vanilla Merkel tree thing here, right? And maybe we'll say vanilla. So this vanilla Merkel tree has a parent that's just the hash function, right? And the elements, like the nodes, we'll call them the nodes, right? Like every one of these things is a node in the Merkel tree.
00:21:15.922 - 00:21:44.240, Speaker B: So the nodes are bytes, 32 hashes. Okay, very, very simple. Most hash functions return to 32 bytes. So the hash function, the only thing that we need is that the parent indeed resolves to a node. So it requires that the hash function resolve to 32 byte hashes. And then we have the effect that we want that we can build a whole binary, recursive, beautiful thing with this data structure. Okay, so now we've got to update the nodes and we've got to update the parent.
00:21:44.240 - 00:22:19.980, Speaker B: Okay, great. So let's do this. We're going to call this index, index, Merkel, Sumtree. And so as a spoiler alert, the reason that we're going to call this index is because it's going to refer to the index of some coins. So it's actually going to refer to some coins as we go up the tree. And maybe that'll begin to start making you think about what this actually does. So very simply, now, a node is a tuple, it is a bytes 32 hash, and it is a coin id.
00:22:21.550 - 00:22:24.538, Speaker A: So now every node in the Merkel tree has a coin id.
00:22:24.624 - 00:22:35.370, Speaker B: Absolutely. And so be careful when we say has a coin id, right. It references a coin id. It's not that it has it in an ownership sense. Right, of course. But it does indeed point to a coin id.
00:22:35.440 - 00:22:39.402, Speaker A: That's one of the, like, it would be like 173, for example. It's not a range.
00:22:39.466 - 00:22:51.330, Speaker B: Exactly. It's not a range. It's just one. Exactly. It's bytes. There to a coin id. And similarly the parent, just the only thing to note on the parent is that the parent equals hash.
00:22:51.330 - 00:23:11.770, Speaker B: The parent function is the hash of the nodes. So like left and right. Note that this includes the coin ids, the coin ids as well. Right. So you're committing both to this hash and this hash. So like in practice, what you do is you take the left bytes, 32 concatenate the left coin iD, concatenate the right bytes, 32 concatenate the right coin iD. Right.
00:23:11.770 - 00:23:15.366, Speaker B: And so that's how we're going to express with that. And then, believe it or not, it's.
00:23:15.398 - 00:23:18.202, Speaker A: Simply the left coin iD.
00:23:18.256 - 00:23:31.422, Speaker B: Coin Id. This is why it's a much more beautiful. This part is very, very beautiful. Before, we were doing an addition of the coin ids effectively, and it was very, very messy. This is a lot cleaner. Yep. So that says left coin id there.
00:23:31.422 - 00:23:37.780, Speaker B: So that's going to be the property. So believe it or not, that's going to give us backlight clients. Super cool. Super cool.
00:23:38.790 - 00:23:39.794, Speaker A: Let's see how it works.
00:23:39.832 - 00:23:55.430, Speaker B: Yeah, let's do an example. Okay, so I'll clear this off here. Great. The other thing that we're going to have to do, obviously, is define a validity condition. But maybe it makes sense for me to just do an example.
00:23:55.500 - 00:23:56.440, Speaker A: One of these.
00:23:56.890 - 00:24:02.460, Speaker B: Yeah, let's do an example. Okay, so I'm going to start with the leaves because that seems smart. So let's say we have.
00:24:02.830 - 00:24:10.410, Speaker A: But also do we need to know by now what is the ordering of the ranges of the transactions?
00:24:11.650 - 00:24:43.062, Speaker B: Very interesting question. So interestingly, the validity condition will enforce a sorting. So namely the property that we must have is that as you go up the tree, the coin ids for the things that are being merged in from higher and higher up must be greater than the previous step down. So as you work your way back up the Merkel tree, the coin ids that you're pushing in must be to the right of the coin ids on the left, and they must be like increasingly to the right. And that's going to end up being the property.
00:24:43.196 - 00:24:48.710, Speaker A: Obviously, the leaf coin id is just the coin id. Right? Oh, wait, there's no coin id transactions.
00:24:49.290 - 00:25:15.540, Speaker B: Exactly. So one thing that we're going to need to figure out how to do is what we call like parsing the transactions into the bottom nodes, like turning the leaves into the bottom level of the tree, and it's actually going to end up being effectively the left of the range is what it's going to end as well. We had a much more complex thing where you had to subtract stuff. Oh, coin id. So beautiful. So beautiful. All right, so example.
00:25:15.540 - 00:25:45.594, Speaker B: Okay, so let's say maybe 00:10 let's say 1050. Let's say whatever, 5000. And then let's say like hundred, 500. Okay, let's go with that. And maybe I didn't make myself enough room here. So we'll erase the very simple merkle tree here. Okay, so we're just going to do four.
00:25:45.594 - 00:25:49.306, Speaker B: We'll just do four for now. Okay. It's maybe hopefully won't be too degenerate. We might want to add more.
00:25:49.328 - 00:25:53.462, Speaker A: But that's a valid example where there's no intersections.
00:25:53.526 - 00:26:17.430, Speaker B: This is, yes, so this is a valid example where there's no intersections. And what we're going to do later, like spoiler alert, we're going to try to change one of these to an overlapping range and we're going to show why that breaks the validity condition. So that's what we'll end up doing. Yeah. So that's in effect, the idea is that if this has a validity condition, this can't also have a validity condition. It's like one or the other, right? Absolutely. Okay, cool.
00:26:17.430 - 00:26:44.666, Speaker B: So let's get our handy dandy parent lines. Okay, cool. So this is going to be pretty easy. I'm not going to write the hashes up here, right? Because that's sort of just like we assume that we're committing things. It's a Merkel tree, whatever. Right. So the base property is that you literally, it's so simple, honestly, you take the leftmost thing in each of the ranges.
00:26:44.666 - 00:27:03.662, Speaker B: So here we're going to get zero. Here we're going to get ten. Here we're going to get 50. Here we're going to get 100. Okay. So that is our thing. And notably, this was like an actual step that we just did here where we took this transaction, which is also going to have an ascender and recipient, alice, blah, blah, blah, blah.
00:27:03.662 - 00:27:25.658, Speaker B: We turn that into just the hash of that thing and we also pull out the start. Right. So each of these are really like, we implicitly did a function here to turn these from transactions into hashes with an index, but we're just going to write the index because that's the important part. Okay, so it's very simple. Parent function is equal the hash of both of them. Right. We're going to exclude the hash and the left coin id.
00:27:25.658 - 00:27:37.406, Speaker B: Okay, so here where you take the hash, it's the left. So it's zero. Here we take the hash take the left. So it's 50, right? And here we have the hash. It's. So it's zero. Right.
00:27:37.406 - 00:28:02.102, Speaker B: It's always going to end up being zero at the top. Okay. Right. So what is the validity condition? So the validity condition states that this zero. Maybe I'll just point it out and say it in words. It's, like, a little tricky to write. This zero must be greater than or equal to this zero and this zero and this zero.
00:28:02.102 - 00:28:28.078, Speaker B: Right. Effectively, like, the transactions range must be within the bound of this zero. Right. The other property is that this ten must be less than or equal to this one and must also be less than equal to this one. In fact, even more strictly, this 50 must be greater than this ten. So this ten must be greater than equal to this. This 50 must be greater than this ten.
00:28:28.164 - 00:28:38.186, Speaker A: And there's another condition, right? So if I start from here, then this 50 must be greater or equal than this ten. Right. You need to check both.
00:28:38.308 - 00:28:58.922, Speaker B: So, notably, when you get this 50, you never actually see this ten. So maybe this is a better case. Actually, you're right. So let's look at this 50. When you download this Merkel branch, what do you get? You get this and you get this. Right? And so it'll probably be useful to do, like, an s size eight tree, because there's not, like, a lot of things going on here. But it's a good, simple example.
00:28:58.922 - 00:29:16.318, Speaker B: So the property is actually that this 50 must be actually what it is. You also get this one. And so the real property is that this 50 must be greater than, equal to this 50, and this 100 must be less than or equal to this 100.
00:29:16.404 - 00:29:17.866, Speaker A: I might be running ahead of the trend.
00:29:17.898 - 00:29:18.094, Speaker B: Right.
00:29:18.132 - 00:29:30.498, Speaker A: But let's say that this one was 55, and I, as a light client, it seems like I verified everything, and everything checks out. But there is actually an intersecting transaction, right?
00:29:30.664 - 00:29:41.906, Speaker B: Yes. So this is the beauty. Okay? That's exactly right. What we want to do is try to break this thing. Right. Okay, so what you're saying is a great way to break it. Like, the way that you break things is you make intersecting ranges.
00:29:41.906 - 00:30:03.306, Speaker B: The trick is, though, that only really breaks it if both of the ranges pass the validity condition. So let's change this to a 55 like you said, and let's do the check. So I'm going to erase these circles because we're going to get some new circles for this inclusion proof, and it's probably worth. Probably worth circling them. So hopefully that is bearably aesthetic. Right. Okay, so we're going to do this one.
00:30:03.306 - 00:30:17.218, Speaker B: So what do we get? We get this one. We get this one, right? Okay. So check it out. We get this zero, we see blah, blah, blah. So the ten is good, right? Because the ten is greater than the zero. It's greater than the ten here, right? Yes. So we also do get this one, actually.
00:30:17.218 - 00:30:36.358, Speaker B: So the ten is greater than here. Right? And then this is a valid left index sum tree where this zero indeed goes up. Right. So the ten checks out. However, the 55 does not check out. Why is that? The reason is because this 55 is greater than this 50.
00:30:36.444 - 00:30:42.540, Speaker A: But as a light client, I only then load my transaction. I have no idea that this validity check doesn't check out.
00:30:43.550 - 00:30:46.170, Speaker B: That's the beauty. Okay, we'll reset your question, maybe.
00:30:46.240 - 00:31:09.460, Speaker A: So as a light client, right? So let's say I'm a light client and I received this transaction. So someone says, I'm sending you range from 50 to 100, and it's going to be in the Merkel tree. It's going to be at the position here. And so what I assume what I'm going to do is I'm going to get this position and then load it from all the way from the past. In every block, I will download this Merkel path, right, with indexes. But I will not download this one. Right.
00:31:10.710 - 00:31:20.838, Speaker B: There's two things there. One of the things is that actually the leaf index changes every single block. So every single block you download a different binary trace to a different index. So that's one thing, but it's going.
00:31:20.844 - 00:31:22.726, Speaker A: To be the same range every time.
00:31:22.908 - 00:31:26.310, Speaker B: Well, you might have to download multiple indexes if the range was transacted.
00:31:26.650 - 00:31:28.566, Speaker A: But I'm provided with the proofs for all of them.
00:31:28.588 - 00:31:33.174, Speaker B: You're provided with the proofs. Exactly. And so the operator gives you the proofs and he says, look, this is the range you want to see.
00:31:33.212 - 00:31:39.946, Speaker A: But for the light client, in this particular block, let's say I'm receiving transaction from 50 to 100. What will be the proof?
00:31:40.098 - 00:31:53.406, Speaker B: The proof. Oh, so for 50 to 100? Yeah. So for 50 to 100, the proof will be what we circled before. It'll be this 50. So maybe I'll put that in square and we'll do like Circle Square. So you'll get this, you'll get this, you'll get this.
00:31:53.508 - 00:31:59.230, Speaker A: But then as a light client, I get this proof. I'm not aware that there's an intersecting transaction.
00:31:59.390 - 00:32:14.454, Speaker B: And that is the beauty of it. You are not aware that there's an intersecting thing here. And you don't care because you know, as soon as you see this number right here, you have a 100% guarantee that this 55 will fail the validity check.
00:32:14.492 - 00:32:16.434, Speaker A: Oh, so only a malicious actor could possibly.
00:32:16.562 - 00:32:16.902, Speaker B: Exactly.
00:32:16.956 - 00:32:17.462, Speaker A: Control that.
00:32:17.516 - 00:32:44.734, Speaker B: Even if a malicious actor does place a 55 here, the smart contract will reject it. Right. And the reason for that rejection is because this 55 is invalid because it's greater than this 50. Right. The fact that you have this 50 means that you know that anything greater than 50 here will break at that level. So even though you've only downloaded this, even though you just download this square branch, because this square branch gets you the 50. Right.
00:32:44.734 - 00:32:53.490, Speaker B: Because it does that, you have 100% guarantee that this horrible invalid stuff will be invalidated. And that is the light client property.
00:32:53.560 - 00:32:54.926, Speaker A: Yeah, I'm completely sold.
00:32:55.038 - 00:33:00.934, Speaker B: Nice. Yes. Should we go through? Maybe we can go through a more complex example, like maybe an extra.
00:33:00.972 - 00:33:04.162, Speaker A: Yeah, I think it makes sense to show more examples.
00:33:04.226 - 00:33:27.338, Speaker B: Okay, so the other thing we'll do in this example is you'll note that the range zero through a 500 was all transacted on. This was all transaction. There's no coins that weren't transacted. In practice, this isn't going to be the case. Right. There's going to be big ranges of coins where the owner doesn't want to spend the coins. And so there's going to be gaps.
00:33:27.338 - 00:33:40.020, Speaker B: And so the next example that we'll look at, we'll increase the height of this tree. We'll double the height or increment the height, and we will make some gaps. And then maybe that will be pretty informative. Cool.
00:33:42.070 - 00:33:49.730, Speaker A: And to prove that something does not exist, you provide, like, two paths, or you actually have an empty gate.
00:33:49.810 - 00:34:04.300, Speaker B: Very interestingly, we'll even show that it can be just one. It's very interesting. And it's even shared between all of the adjacent ranges that also aren't transacted. So we'll do that. We'll do that. Okay, so let's do a simple example. Let's do 00:10.
00:34:04.300 - 00:34:23.602, Speaker B: Maybe I'm going to start down a little lower and bigger so I don't kick myself in the foot here. Okay, so let's go here. We'll say 00:10 now we'll go here, we'll say let's make a gap. So we'll say 2030. Okay. Am I spacing this? All right. Three, four, five.
00:34:23.602 - 00:34:49.466, Speaker B: Okay, I need to do this smaller, honestly, don't I? So I'm just going to do that. Okay, so let's go 2030. Let's do whatever I mean, this can be literally whatever we want. So 5000, right? Let's make it thousand. 2000 maybe. I'm going to regret having to write a bunch of extra zeros up there, but.
00:34:49.488 - 00:34:52.140, Speaker A: Oh well, something invalid maybe.
00:34:52.830 - 00:34:59.980, Speaker B: Oh, that's a good idea. Yeah. So why don't we do 75? 75? Yeah, 75 to 100.
00:35:01.490 - 00:35:11.502, Speaker A: So the idea with a single range is that you actually, if I give this range, then somewhere along the way I will get 50 as the left.
00:35:11.556 - 00:35:13.134, Speaker B: Right, exactly right.
00:35:13.172 - 00:35:14.094, Speaker A: So I will know that this.
00:35:14.132 - 00:35:34.726, Speaker B: Yeah, exactly right. Exactly right. Yes, exactly. Okay, so we've only drawn eight transactions here, so it's not a full tree, but maybe I will do one more. So we have this invalid 7500 here and then I'll maybe give that a sibling and we'll call this back to a valid thing. So we'll call it like 2000, 3000. Okay, so technically there's going to be some extras here.
00:35:34.726 - 00:35:54.654, Speaker B: We're just going to draw like a truncated version, sort of ignore the subtree. Okay, so let's do that. Here we go. All right. How are my Merkel tree skills? We're doing okay. We're doing okay. Of course this is going to have a like that we haven't seen, but imagine it's there.
00:35:54.654 - 00:36:17.522, Speaker B: It's not going to matter for our examples. And then of course we have the root. Okay, how does this look? Does this look fine? Yes, we have drawn a merkle tree. Wonderful. Well, we've drawn a binary tree, I suppose. Okay, so why don't we consider some of these gaps over here? So maybe we'll choose. Think this guy's a good guy to do inclusion proof for not.
00:36:17.522 - 00:36:27.080, Speaker B: Sounds good. Sounds good. Or actually let's construct the whole part of the subtree that we have here. Let's do that. Okay, so again, zero to 1000 to ten, we take the left. 00:20 to 30. 20.
00:36:28.190 - 00:36:48.480, Speaker A: Quick question. Let's say that malicious operator created a, they just populated one of the left, one of the, how do we call them coin ids incorrectly. Then there's some sort of a challenge that will show that this is the case.
00:36:50.050 - 00:36:51.022, Speaker B: Say it again. Say it again.
00:36:51.076 - 00:37:25.206, Speaker A: So imagine that I'm a malicious operator. I'm colluding actually on this example, right as I compute the Merkel root, the Merkel tree, I will just say that the coin id here is 2000, which is incorrect. Which is a lie, which is a lie. But I will compute the proof all the way up. So it's also going to be 2000 here. And then for someone over here I will say, oh, you know what your proof is this node, right? Yeah, it's, I guess this node, this node, right? And this is this node and this node. And this one says it's 2000.
00:37:25.206 - 00:37:32.030, Speaker A: And then you as a light client, you say perfect. My, my, my transaction is correct.
00:37:32.100 - 00:37:32.286, Speaker B: Right.
00:37:32.308 - 00:37:34.750, Speaker A: So I presume there's got to be some challenge, right?
00:37:34.820 - 00:37:52.114, Speaker B: That's the trick. Well, that's the beauty of it. Because this says 2000, you are guaranteed because when this person tries to exit, right. They'll try to submit that proof to the smart contract and the smart contract will go, okay, 75. Sure. 2000. Sure.
00:37:52.114 - 00:38:14.390, Speaker B: Now we want the left node. They won't get a 75. The 75 here is 2000. They'll go ant, it's not going to work. So it's a validity condition. And in practice, like where it is in our code right now, for example, what is going to happen is the root hash is not going to be the same root hash that you end up with as the root hash of the, as the root hash that was submitted. Right.
00:38:14.390 - 00:38:36.542, Speaker B: Because the smart contracts, as it's simulating the inclusion proof, is going to put a 75 here. And because the 2000 was put here, the entire root hash is going to be wrong and so it won't be used. And so that's the beauty of it. As soon as this guy sees this 2000, he knows that even if this range does intersect this stuff, it's going to be invalidated. It's not going to be. Okay. And so he doesn't care what's there.
00:38:36.542 - 00:38:43.726, Speaker B: The operator can screw up other portions of the coin, but he knows his is good. Awesome. Of the coin range. Yeah. Okay. Yeah. So maybe we'll just finish this tree.
00:38:43.726 - 00:38:58.646, Speaker B: So we've got a 00:500 it's always zero at the top. 2000. 2000. Yeah. So this is an interesting case here where we sort of did the wrong example. Right, for this thing. I think we've actually gone over this example pretty well.
00:38:58.646 - 00:39:00.450, Speaker B: So I'll leave this as invalid here.
00:39:00.620 - 00:39:01.914, Speaker A: Let's say this is 75 now.
00:39:01.952 - 00:39:14.526, Speaker B: Yeah. Okay. We can do that. Okay. But very notably right now, what we have is a very broken tree. So for this tree only these two transactions check out. Right.
00:39:14.526 - 00:39:15.134, Speaker B: It's very interesting.
00:39:15.172 - 00:39:16.480, Speaker A: Oh, this one checks out.
00:39:17.490 - 00:39:29.442, Speaker B: Oh, you're absolutely right. Yeah, you're totally right. Yeah. So particularly the coins in the range like 50 to 75 are sort of like these proofs. They're like, I don't know what to do with this. It's sort of invalid. Right.
00:39:29.442 - 00:39:47.958, Speaker B: And that's going to be a problem for them. 100% yeah, but you're totally right. This guy will be totally pleased. And these guys may be pleased as well. Yeah, that's right. Yeah. Okay, so what do we want to do with this? Okay, so maybe we can walk through like a simple check.
00:39:47.958 - 00:40:05.166, Speaker B: So let's walk through the check of this guy and show that it's right. And then we'll walk through the checks of these guys and show that this screwed things up. Okay, so let's do this check. So let's do a triangle. And so what is this? Inclusion proof? Get this. Gets this guy. Gets this guy.
00:40:05.166 - 00:40:32.710, Speaker B: Gets this guy. And that's it. Right. The wonders of logs. Okay, so this guy, he gets this, this, and this. So what are the checks he needs to perform? The one check that needs to perform is that for the left guy, his start of his transaction right is greater than or equal to all of the indices going up. And actually he also gets this one as well.
00:40:32.710 - 00:40:45.462, Speaker B: It is required to give the thing that this is parsed to. I take it back. Actually, it can be implicitly inferred. Okay. Yeah. You don't. Yeah, it just calculates it from the 20 right there.
00:40:45.462 - 00:40:58.814, Speaker B: Okay, so the 20, he looks here. He goes, okay, great. Is my, is my, is my zero less than my 20? Yes. Okay, we're good. Sweet. Does this check out to the left thing? Yes, we're good. Okay, now he goes to this level.
00:40:58.814 - 00:41:12.014, Speaker B: He goes, okay, is my 30 less than or equal to my 50? He goes, yes. Oh, my gosh. Great. It is. So we can go here. Is this zero the same as the zero here? Yes, it is. Does the hash check out? Obviously, too, now he gets this guy.
00:41:12.014 - 00:41:30.582, Speaker B: He goes, okay, we've got a 75. So for the 75, he needs to be sure that this 75 is greater than this previous 50. So he goes, okay, 75 is greater than the 50. Oh, my gosh, we're almost there. 75 and zero. Does it go to zero? Yes, we're good. Okay, so the triangle transaction in this tree that we've constructed, the triangle is like totally happy.
00:41:30.582 - 00:41:50.846, Speaker B: He's a happy cat, can keep on transacting, do whatever you want. Right. But of course, we did insert this sneaky little guy here. So we're going to see how it breaks. Okay, so let's watch how it breaks. Okay, so let's do maybe a square for the 50 to 100. Note that this is going to be the one that really, really breaks because there's a 75 to 100 there, right, as well.
00:41:50.846 - 00:42:12.534, Speaker B: Okay, so what does the square get? The square gets this guy. He gets this guy and this guy as well, right? So very similar. Quite similar. Okay, so what does he do? So he sees, okay, I've got 50 to 100. Did my 50 turn into a 50? Yes, we're good. Did this 50 turn into this 50? Yes, we're good. 50 is less than or equal to 50.
00:42:12.534 - 00:42:25.900, Speaker B: So we're okay. Now he goes to his 100. He goes, okay, I got this guy. Is my 100 greater than or equal, less than or equal to my 1000? Yes. Oh my gosh, it is wonderful. Okay, so we go up here. He goes, okay, we got the zero here.
00:42:25.900 - 00:42:46.178, Speaker B: Is the zero less than the 50? Yes. Is the zero the one propagated up? Yes. Okay, great. Now he gets this one. He goes, okay, is our 75 greater than or equal to our 1000? And he goes, oh, no, we're not. So we see here that this is like the breaking point for this inclusion proof because of this overlap. Right.
00:42:46.178 - 00:43:02.150, Speaker B: That is what ends up happening. So because 75 is not greater than 1000, because that's not true, then this would be an invalid block. And it's an invalid block. And this person must stop signing transactions and exit their money.
00:43:02.220 - 00:43:03.720, Speaker A: It's not greater. Equal. Right.
00:43:07.130 - 00:43:29.582, Speaker B: It can be equal. It can be equal. Actually. It can be greater than equal. That's absolutely fine. Right. Okay, so this is a simple example of how it broke, right? And of course, if we were to invert our heads and imagine again like we did in the beginning, that this 75 was like the invalid thing and this was the 2000 and this was 2000, then it would be good because we would have 2000 is greater than equal to 1000.
00:43:29.582 - 00:43:43.634, Speaker B: That was the example I had before. And we would know that that invalidates all types of these things. So we're good. Okay, so that is maybe a more complex, like eight transaction tree. Does that make sense?
00:43:43.752 - 00:43:45.694, Speaker A: Yeah, I'm completely sold.
00:43:45.742 - 00:43:53.510, Speaker B: Yes, it's wonderful. Okay, so let's talk about cool properties of this. Oh, yeah. Because we were going to talk about the gaps and this is very important.
00:43:53.580 - 00:43:57.314, Speaker A: Right. Let's say that we need to prove that ten to 20 is a gap.
00:43:57.442 - 00:43:58.118, Speaker B: Exactly.
00:43:58.284 - 00:44:00.022, Speaker A: Or even better, 30 to 50, I guess.
00:44:00.076 - 00:44:35.300, Speaker B: Yeah. So let's say that I own range 30 through 50 and I want to be ensured that my money was not spent. What do I need for that? Believe it or not, it is just one branch. And that is really, really awesome. So as a matter of fact, this triangle branch, both proof is what we call a non inclusion proof for coins 30 to 50. Just as much as is an inclusion proof for coins 20 to 30. Okay, so let's think about why that is.
00:44:35.300 - 00:44:46.600, Speaker B: Okay, so when we get the triangle thing, right, what do we get? We get this guy. We get this guy and we get this guy, right? And maybe should we change this back to 2000 for now?
00:44:48.010 - 00:44:49.382, Speaker A: I think, yeah, sure.
00:44:49.516 - 00:44:54.006, Speaker B: Oh, no, because it's okay for him. It's okay for him. Yeah, it will work. Yeah, you're right. Okay. Yeah. Wonderful.
00:44:54.006 - 00:45:36.502, Speaker B: Okay, so let's say I didn't transact coins 30 through 50, right? What do I see from this? Well, the only thing that I care about is I see that this 30 is less than or equal to my 30 that I own. Right? So because this transaction ends at 30, I know that this transaction can only talk about 20 through 30. Right? So we're good on what this guy can do, right? And then we see obviously the zero and the zero and the zero. It's like a valid branch. Like, that's obviously important. And the other thing we see is we see this 50 right here. And the cool thing about this 50 is we know because of this 50, that the start of this transaction must be 50, right.
00:45:36.502 - 00:46:20.806, Speaker B: And it cannot be less than 50 is really the key property. There cannot be less than 50. So therefore, simply by getting this triangle, the same inclusion proof for the 20 through 30 spend, this single inclusion proof is both a spend of 20 through 30, and it is an unspent proof, a proof that the coins weren't committed to being spent on the range 30 through 50 here. Right? So it's like both an x here and like a check here, right? And it is the same exact sort of triangle proof that supplies you both. So that makes sense. Yeah, seems reasonable. Okay, so what is like, one really cool thing about that? One really cool thing about that is this is like a very simple example, but imagine this was a 30 and this was a 2 million.
00:46:20.806 - 00:46:55.614, Speaker B: Right? Even with that, it's just one inclusion proof. And let's say there were like 1000 owners between 32,000,000 and none of them transacted. All of them share the same single non inclusion proof. That is just this triangle transaction. And so what that means is you actually have history overlaps, which is really cool. So in plasma cash, normally every coin had a unique history that was at a unique branch. In this version, anytime a coin is unspent, if its neighbor is unspent, both of them download each other's inclusion proofs, right? So you can argue that there's dangers for that with regard to privacy.
00:46:55.614 - 00:47:15.800, Speaker B: Like maybe that's a little less private, but you can split it up and have a transaction that says 100 to 100, it's, like, empty. And that would be fine as well. So it's a really interesting property that you actually have shared. Sort of non inclusion proofs for adjacent coins that weren't transacted. Cool.
00:47:16.330 - 00:47:43.630, Speaker A: So I think the most interesting question that I have right now is, so let's say I'm a merchant, I'm a coffee shop, and I sell a lot of coffee during the day. So during the day, I got a lot of. And let's say lowest denomination is $5 and happens to be exactly the price of a late. And so I got a lot of them. How do I defragment? How do I bring all of them together to send all of them to my cold storage?
00:47:44.290 - 00:48:21.182, Speaker B: I will push back on one thing you just said, which is, let's say the lowest denomination is five. So in this model, even this 50 to 100 is way smaller numbers than we deal with in practice. So we actually encode way into our coin ids because literally what these numbers are define the size, not like the amount of transactions or anything. So, in reality, all of these constructions allow you to do a millionth of a cent pretty much at the same price as if the minimum denomination was five. Anyway, your point is still totally valid. Right. So the question is, maybe there's, like, a good way to visualize this.
00:48:21.182 - 00:48:34.894, Speaker B: Okay, so the way that I sort of visualize the plasma cash flow construction is, I imagine, like a number line. And I imagine different colors on different segments of that number line.
00:48:34.932 - 00:48:35.806, Speaker A: And color is the owner.
00:48:35.838 - 00:49:05.740, Speaker B: And the color is the owner. Exactly. Yeah. So we might have a dark purple section here and then a light section here, and then a diagonal thing. Obviously, we don't have a lot of colors, so this is the best we can do. Right, but you might have something like this, right? And so, absolutely, the thing that you need to solve in this scheme is, even though we've broken down the denominations, the coins are not adjacent, and that means that they need to be exited separately. And that's bad.
00:49:05.740 - 00:49:30.706, Speaker B: So imagine the coffee. Let's say the coffee shop owner is like a squiggly. Squiggly, right? So imagine that this is block n. And at n plus one, a bunch of people buy coffee, right? So now this guy bought some squiggly coffee here, and the rest is still his, right? And this guy bought some squiggly coffee here, but the rest is still his. It's like his change, right? Almost. Right. The next guy bought the squiggly coffee here.
00:49:30.706 - 00:49:51.338, Speaker B: Oh, God, I kind of did squiggle spice here. We'll cross hatch. There we go. And then this guy still has his leftovers here. Right? And similarly, this guy did a bit here, still has his leftovers there, right? So the problem is that now the coffee owner, the squiggly guy, owns this, owns this. Whoops. Owns this and owns this.
00:49:51.338 - 00:50:41.434, Speaker B: Right? The problem is that this, there's a few things to note about this. In theory, there's something called like a mass exit, or. How do I want to say this? Okay, so in theory, what we need to do at the smart contract level is support effectively, like arbitrary compression algorithms on the ranges of coins that you're exiting. So we have a very simple compression algorithm in effect in our current exit game, which is start and end. Right? When you exit coins 50 to 100 in plasma cash, what you do is you say, I'm exiting coin 50, I'm exit coin 51. I'm exiting coin 52. I'm exit coin 53, right? And so we technically, our exits are like a compression of that, which is very, very simple.
00:50:41.434 - 00:51:27.506, Speaker B: It's just the start and the end, right? So very, very basic compression, utilizing the structure of these coin ids as all being adjacent. So one thing that we might want to do is provide the coffee store owner the ability to begin an exit in which they sort of describe these intervals in a compressed, useful way. So the simplest way might be that the coffee owner says, well, my coffees are all $5, so I'm exiting a bunch of coffee payments and they're each $5 long. So instead of giving you the start and the end, I'm just going to give you the start. Right? And so then they just give this start and this start and this start and this start. Right? And butabing bada boom, they've cut in half because it's just starts and one length instead of start and start and start and start end. So already that's an improvement.
00:51:27.506 - 00:51:35.466, Speaker B: Right? And in general, what we're talking about here is like compression, right? And there's like massive amounts of. It's lost those compression specifically. Right.
00:51:35.488 - 00:51:49.114, Speaker A: But for the exit, can I just say, I want to exit all my coins from here up to here. So then transaction is very small. I mean, it's still like the operator will have to record each of them. But my exit transaction is tiny.
00:51:49.162 - 00:51:51.290, Speaker B: Now, in what I've just described.
00:51:51.370 - 00:51:57.890, Speaker A: Oh, no, I'm suggesting in what you described, you effectively reducing the size by a factor of two. Right, correct.
00:51:57.960 - 00:51:58.290, Speaker B: Yeah.
00:51:58.360 - 00:52:06.966, Speaker A: While I'm saying what if I just. Because for each of those tokens, right, the owner is known. Like the public key of the owner is known, right?
00:52:07.148 - 00:52:45.822, Speaker B: That is true for people with availability on the plasma chain. From the smart contract's perspective, the smart contract has no idea. So whenever you submit an exit to the smart contract, you need to specify, this is the exact set of coins that are owned right now. And you need to accept challenges if they disprove that this is the coins that are owned by whom. Right? So it's not just as simple as saying, I'm going to exit all the coins that are owned by me. Smart contract needs to know how many coins those are, and very importantly, which coins they are very, very critically. Okay, so I've just described one weird sort of compressiony thing, and to the extent that we can do on chain compression, we're going to strive to have things like that.
00:52:45.822 - 00:53:15.830, Speaker B: And this is like a general class of what has been previously called, like, mass exits. You can do all sorts of fun stuff here. You can do true bits over these numbers. You can submit a merkel root of this and have someone challenge you to reveal the merkel root and do lots of optimistic fun stuff. But the core of it is that it would be much better if we could just get all these things mixed up so that it is one contiguous range. Even if we have better compression, we want to make the data as compressible as possible. And big, long, continuous ranges are very, very compressible.
00:53:15.830 - 00:53:57.586, Speaker B: Okay, so the way to solve this, we've considered a few different ways. There's like two classes of it, but what we're calling it is defragmentation, right? We want to take all these squiggles, right? Take all these squiggles and make them one big long squiggle, right? And then we want to shift all this dark section and this skinny section and these cross hashes and these dots, we want to shift them all so that they're all pressed up against each other as well. Okay? So we're calling that defragmentation. And there's several ETH research posts on this for all listeners. Ethereaser ch eth research is an awesome form. You guys should all check out. Vitalik has some defragmentation posts on there, but the one that seems most promising is atomic swaps.
00:53:57.586 - 00:54:35.198, Speaker B: So basically the idea, like, without rewriting another example, which I will do in a second, basically the idea out loud, though, is simply have this guy swap his dark section over to here and move this sweet section over here. So it's like I'm exchanging coin one with your coin five. And even though the coins are both worth the same amount, so it's not like we're actually transacting in terms of value. We are transacting the exitability because they're non fungible in terms of their history. So maybe we'll do a much simpler example here. Right. So imagine that this coin range is owned by Alice, and then this coin range is owned by Bob.
00:54:35.198 - 00:55:03.118, Speaker B: Right? And then this coin range is owned by Alice, and then this coin range is owned by Bob. Right. Should be very clear what we want to do here. What we want to do is switch these two guys back, right. So instead, what we want to end up with is, like, this is at height n and then at height n plus one, we want to have suddenly this. Right, right. And so what has been done here? It's an atomic swap on these two things, right.
00:55:03.118 - 00:55:26.242, Speaker B: And we want to ensure for Alice. And obviously, if we're assuming these are all equal quarters, then this should all be aligned. Right. The thing that we want to ensure is for both Alice and Bob that they are safe in the event that this happens. In other words, Bob can't somehow be tricked to sending these coins to Alice without receiving Alice's coins. Right. Okay.
00:55:26.242 - 00:56:10.180, Speaker B: And one very important thing here, and this is, in general, I think, something that people very much struggle with intuitively in the cash flow interpretation, because we think of these ranges as, like, we think of the things in the Merkel tree or the transactions as being coins, really. They are like updates to the underlying coins. So when I draw these arrows here, I actually think that this is maybe a little misleading because it almost looks like you're taking these coins and you're swapping places with them. So, actually, I think that's probably a bad way to draw it and probably is, like, badly reinforcing. What you're really doing is you're keeping these coins, like here. Like they're the same coins, but you're swapping the owners, you're swapping the owners. So that's really what you want to do.
00:56:10.180 - 00:56:33.866, Speaker B: You want to take continuous ranges and maximize the continuous rangeness of each owner. And so you need atomic swaps to enable that. It's pretty easy to do an atomic swap. Well, it's nontrivial, but it's relatively easy to do an atomic swap. Basically, like, to atomic swap this range. With this range, you need inclusion proofs on both. And if both inclusion proofs are present, that's good.
00:56:33.866 - 00:57:01.426, Speaker B: So now, instead of just checking the triangle, the transaction says you got to check the triangle and the square for this guy. And you check both the triangle and the square and they swap. So our smart contracts, for example, currently support this atomic swap functionality. But the strategies as to how we're going to convince people to do this because people have to be online and sign off to agree to do it. In this case, we think it's incentive compatible because both Alice and Bob are helped by this. Right. Like their exits go down.
00:57:01.528 - 00:57:04.478, Speaker A: But the coffee shop example is more interesting. I actually not sure if the coffee.
00:57:04.494 - 00:57:07.454, Speaker B: Shop example is much harder. Okay.
00:57:07.592 - 00:57:35.146, Speaker A: But if we replicate it here. Right, so this is my coffee shop. That is definitely seen. So the coffee shop owner is the rectangles and that's like one guy, and this is the coffee shop owner, some other guy, and the coffee shop owner and some third guy. So let's assume that people are willing to help even if it doesn't benefit them much. So here the first guy will say, yeah, you know, I'm willing to help you and exchange.
00:57:35.178 - 00:57:38.538, Speaker B: And obviously $5 maybe he gets a coffee coupon.
00:57:38.634 - 00:58:01.698, Speaker A: Yeah, those guys are willing to help. And so what happens after he helps me is that his continues here and I have a continuous range. That would have been a bad idea on my end, actually, for me it would have been better to have him here and myself here because that helps me to convince this guy to exchange with me. Because for him it's still no hassle.
00:58:01.794 - 00:58:02.440, Speaker B: Exactly.
00:58:03.850 - 00:58:13.340, Speaker A: But then I'm sort of in trouble because for this person it's not beneficial to exchange with me because they will get.
00:58:13.950 - 00:58:45.060, Speaker B: Yeah, and so these problems are tough. And in general we can hypothesize a lot about what these defragmentation structures may look like. So one observation that we've made, for example, is that it's probably going to be a role of the operator to suggest these to clients. So what we want is we'll abstract all that away. When you're buying coffee, you don't have to agree with the coffee. I joked that you get a coffee coupon, but in reality you don't want ever to be buying a coffee. And then the coffee shop is like, by the way, can you switch those around?
00:58:46.410 - 00:58:47.990, Speaker A: Can operator enforce changes?
00:58:48.060 - 00:58:48.630, Speaker B: What's that?
00:58:48.700 - 00:58:50.470, Speaker A: Can the operator enforce changes?
00:58:50.620 - 00:59:19.658, Speaker B: So the operator can enforce. So it's tricky. So for the people checking this out on ETH research, we have a plasma cache defragmentation. Take two, there's three defec posts, photog. Second one talks about this and it's very tricky. You can't allow the operator to enforce this off chain. So if you indeed do the swap, it must be the case that all of that swap data is put on the main chain, so it doesn't have very good scalability.
00:59:19.658 - 01:00:25.042, Speaker B: But if you don't, the operator can swap you and withhold that he's swapping you and he can exit the things that he swapped you to and you don't have a way to challenge it. And then he exits the things that he swapped you from and he can steal. It's effectively like imagine that Bob is the operator and the operator exits this and then exits this, right? And takes both this total range when only half of it was owned by him. So to prevent that, you have to put this like the ranges being swapped have to be available on the main chain, which is kind of bad. There's maybe more complex things you do. You can define an on chain permutation and compress that permutation or something, right? But in general, it seems like atomic swaps are the way to go, because one of the things that we'll probably have here is probably in reality, there's going to be times when there's just a big long range of coins that is like a whale on this dex or whatever, and it's going to be an extra source of fee revenue if they use their liquidity to help a bunch of people just totally migrate atomic swap into them. Right.
01:00:25.042 - 01:00:34.278, Speaker B: And just totally move everything over. But it's definitely an active area of research and one that is going to be explored more in the future for sure.
01:00:34.364 - 01:00:47.994, Speaker A: Cool. Okay, I think we covered quite a bit of material. Yeah, it was good. So let's wrap up here. And I think one thing would be good to know is where can people find implementations of that, or where to go for research and stuff.
01:00:48.032 - 01:01:13.762, Speaker B: Sure, absolutely. So if you go to Plasma group, we have all the info you need. So the state of the implementation is as follows. We have a smart contract written in Viper, we have a node, an operator and helper libraries, kind of like an SDK, all written in JavaScript. So GitHub.com plasma group or go to Plasma group and we'll link to all that stuff. And we would absolutely love that.
01:01:13.762 - 01:01:32.986, Speaker B: We're absolutely trying to build a community of developers. This is like we're a nonprofit organization. It's just our goal to help promote this stuff as free public good stuff. Yeah, so that's fantastic. If you want to just try it out. It's like an NPM install for both, running up your own, spinning up your own operator which feels really cool to be making these trees on your laptop. Right.
01:01:32.986 - 01:01:33.610, Speaker B: That's really fun.
01:01:33.680 - 01:01:34.918, Speaker A: Is there a visualization?
01:01:35.094 - 01:01:46.542, Speaker B: There is a block explorer. There is a block explorer, yes. It's not as cool. I wish we had the visualization of just this. It's just kind of lists of transactions. My end goal is we're going to have amazing colorful rainbows of ranges and all that. Right.
01:01:46.542 - 01:02:05.526, Speaker B: But for now, there is a block explorer up. If you just want to try it out and transact and learn about depositing stuff, you can also go to burner Plasma group, and we've integrated the amazing Austin Griffiths burner wallet for XDI. Right on plasma. So those are all things you can try. And we super encourage you to check that out. Yeah, that's okay.
01:02:05.628 - 01:02:06.582, Speaker A: Thanks a lot for coming.
01:02:06.636 - 01:02:07.480, Speaker B: Thanks, guys.
