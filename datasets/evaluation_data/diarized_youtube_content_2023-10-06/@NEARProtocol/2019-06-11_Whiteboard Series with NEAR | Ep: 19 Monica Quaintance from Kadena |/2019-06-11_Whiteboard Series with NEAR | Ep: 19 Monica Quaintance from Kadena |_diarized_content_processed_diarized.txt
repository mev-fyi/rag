00:00:04.490 - 00:00:16.330, Speaker A: Hi, everyone. This is Alex from Nier. With me today is Monica Quentins from Cadena. We will talk today about the protocol. We'll go a lot into the technical details. Would you like to introduce yourself and give us a brief overview?
00:00:16.410 - 00:00:45.354, Speaker B: Sure. Hi, my name is Monica at Cadena. Now, my title is head of research, but really, I just do whatever needs to get done, which sometimes involves Chainweb. I was on the original Chainweb paper with Will. He's the one who dreamed up the crazy idea. But now I spend most of my time working on research and implementation details of Chainweb. Most recently, I have published a paper in euros and p about security properties of Chainweb, which we can also talk about.
00:00:45.354 - 00:00:50.720, Speaker B: That could be kind of cool. So let's dive in. Okay.
00:00:51.810 - 00:00:52.842, Speaker A: We'll need the marker.
00:00:52.906 - 00:01:07.470, Speaker B: Okay, so the whole idea of Chainweb is combining bitcoin and spvs in order to be able to have a multithreaded network.
00:01:07.550 - 00:01:08.770, Speaker A: What does SPV?
00:01:09.190 - 00:01:42.730, Speaker B: Simple payment verification. Right. Let me go in the middle. All right, so, in bitcoin, you have a block, and that block has a pointer to some previous block. Right. And when you make a new block, it contains a hash of all of previous history. And this is how you get your verifications that people can't go around and screw around with blockchain because you can't go back and modify previous transactions because they're included in every future block.
00:01:42.730 - 00:02:18.600, Speaker B: So the idea behind Chainweb came from first, instead of having just one chain, what if, in order to be able to have more transaction throughput, you had two chains, and they were both using the same native token, both using same protocol, and each chain has its own ledger. We can call them, like, a and b or something. So chain A has this whole, like, it makes a block, and then the next block contains the previous block in it. But in this case, we want them to be related to each other?
00:02:19.050 - 00:02:24.566, Speaker A: The set of accounts each of them manages, they're not intersecting its own ledger.
00:02:24.678 - 00:03:09.410, Speaker B: Chain A has its own idea of history. It has its own accounts on it. So this block in chain A will also contain a pointer to a moment in time on chain B. And you'll know that this fork of chain B, or this version of chain B, is truth on chain a. And this block on chain b contains the same one. And then, because it's two chains and we only have two of them, we're also going to have it cross back the other way. Obviously, having the same number of messages as the number of chains is not very efficient, because as you start making the number of chains bigger and bigger, you're suddenly, if you have ten chains and they're all talking to ten, all of their peers, all at the same time, you start to have the handshake problem, and that's too many messages.
00:03:09.410 - 00:03:36.210, Speaker B: So instead of just having them all talk to each other, we were like, well, you can do this idea of chains talking to each other with any arbitrary base graph. Why not come up with a base graph that's much more efficient in terms of message propagation? So there's this idea in graph theory called the degree diameter problem, which is where you want to maximize your order. So maximize the number of nodes in a graph or a number of chains in chain web, for example.
00:03:36.280 - 00:03:39.026, Speaker A: So, like, the full graph would have degree, diameter one.
00:03:39.128 - 00:03:44.702, Speaker B: So you would want to have a graph that has the minimum degree and diameter.
00:03:44.846 - 00:03:52.278, Speaker A: Oh, degree and diameter are two different values. Yes, they can. Degree is number of edges, incidental vertex. Right.
00:03:52.364 - 00:03:59.586, Speaker B: Right. It's the number of edges that touch any individual vertex or the number of messages sent by any individual chain in the chain web version.
00:03:59.618 - 00:04:01.530, Speaker A: And diameter would be the longest distance.
00:04:03.630 - 00:04:33.440, Speaker B: The longest, shortest path. Yeah. So, for example, let me try to draw this. This is called the Peterson graph. And whenever I try to freehand this graph, I screw it up, but I'm going to try it. So this is the most efficient way to propagate information between ten chains. I think I did that right.
00:04:33.440 - 00:04:46.898, Speaker B: 123123. Each node talks to three peers, but the shortest path between any two nodes is two. I think it's two hops. Might be three hops. One, two, three. Yeah, three.
00:04:47.064 - 00:04:50.180, Speaker A: Which one would be three? Oh, yeah. This two is three, right? Yes.
00:04:51.130 - 00:05:05.660, Speaker B: So this propagation of information is extremely efficient. You can have a ten chain graph, but rather than having each node broadcast nine messages, you can have each node broadcast three messages. And you know that within three blocks, everybody will have all of the information.
00:05:06.510 - 00:05:18.314, Speaker A: And so in this case, every vertex represents a separate ledger. Yes. So each of them is like an independent blockchain? Well, not quite independent, but mostly independent.
00:05:18.362 - 00:05:49.718, Speaker B: Except for the fact that this chain, like, if this is a and this is b, b is going to have to wait to generate its next block until it gets the previous block from a. So there's a little bit of like a three legged race here. We've tied a and B's legs together and they can't go too far forward without each other. But I actually consider that to be a benefit, because if something goes wrong with the network, instead of people just willynilly making transactions all over the place and letting it spiral out of control. Eventually it will halt, and you're like, okay, now we need to figure out.
00:05:49.724 - 00:05:54.282, Speaker A: What'S going, because if one chain holds within three blocks, everything will hold.
00:05:54.336 - 00:06:48.794, Speaker B: Yes. This is also how you end up with getting rebalancing on the network. So instead of having, let me draw, like, time going that way, and if you have some blocks being made here, if this is a and that's b and that's c, if for some reason, like, a moves forward and it's supposed to have this reference to b, but then b halts, a will then attempt to make this block but can't. And maybe c has the same problem. So you can see that this is sort of like a surface. And so the mining hash power will naturally pool into any chains that are not moving forward, because eventually, this will be the only thing that you can mine, and it's the one that the mining opportunity is the greatest. So you say nobody's mining this one.
00:06:48.794 - 00:07:01.422, Speaker B: The mining reward is going to be good. I'm going to switch and reallocate my hash power to b. And then eventually, if the whole network is halting, everybody will be mining b. And so it manages to unstick itself. At least that's what the simulation shows so far.
00:07:01.476 - 00:07:06.366, Speaker A: And so, from perspective of a is my. So let's say it's been for a while, right?
00:07:06.388 - 00:07:08.414, Speaker B: So a is not a person from.
00:07:08.452 - 00:07:10.254, Speaker A: Perspective of the chain a. Right?
00:07:10.292 - 00:07:10.494, Speaker B: Yes.
00:07:10.532 - 00:07:12.402, Speaker A: There's still a perspective from that chain, right?
00:07:12.456 - 00:07:38.138, Speaker B: Right. There's a chain perspective. But I don't want to conflate that with calling a, b, or c people, because sometimes we get this conflation with people that have been looking at proof of stake projects too much, and they see this and they see a validator graph. They see this and they see a minor graph. But this is not a minor graph. This is a protocol graph. In fact, we totally try to disambiguate between the protocol graph and the relationships that miners have with each other.
00:07:38.138 - 00:08:02.260, Speaker B: So we still have a validator graph. And in fact, when we're doing simulations and when we're mining in our testnet, we have a minor graph about how they connect with each other and who sends messages to whom. Totally different from how chains send messages to other chains. And once people start conflating these with people, they're like, oh, but this person is going to end up attacking this person. And you're like, these aren't people. That's not how this works.
00:08:02.870 - 00:08:18.310, Speaker A: But there are still people here, right? So let's say there's like X, Y and Z, who presently chose to have. And for simplicity, let's say that if I have hash power, which I use on multiple chains, let's say it's two different people for simplicity. Or let them call like x one.
00:08:18.380 - 00:08:25.890, Speaker B: We do say that for optimal network performance, we are expecting the majority of miners to mine the entire network.
00:08:26.050 - 00:08:31.978, Speaker A: Yeah. So let's go like x one, y one, z one, x two, y two, and like c two, for example.
00:08:32.064 - 00:08:32.314, Speaker B: Sure.
00:08:32.352 - 00:08:54.222, Speaker A: So let's say that the character is the person. Then I guess it's xa would be better. But so let's say mx one. I'm observing the chain, right? And I also have some view on the other chains, right? Are those cross links in any way affecting my fork choice rule on my chain?
00:08:54.366 - 00:08:54.930, Speaker B: Your what?
00:08:55.000 - 00:09:02.242, Speaker A: Fork choice rule. So when I'm choosing the canonical chain, are those cross links affecting my choice?
00:09:02.386 - 00:09:53.540, Speaker B: Let me take this guy out. So let me go this way again, a and B. So if a is generating blocks this way, and then b has a split. So this is now B prime. Then in this next block here, like, obviously this gets linked to that. When a needs to make its next block, it needs to make a choice, because it's going to be receiving messages from both people mining B and also people mining B prime, that both of these are valid. So then a almost immediately needs to make a choice between this link and this link.
00:09:53.540 - 00:10:09.410, Speaker B: And so a is making calls on whether B or B prime is valid. It's not just the miners on B and B prime, it's also miners on a, which means that forks in Chainweb collapse almost immediately. They don't last very long because they can't be supported.
00:10:09.490 - 00:10:34.282, Speaker A: But so let's say that what happened was that, let's say there's also c, right? And so C was also creating blocks. So this is the third block. Let's say what happened was that a, when they created the block, they endorsed this block and so did C. But on b, there is a block which the block endorsed. This one. Right? So would this block be valid?
00:10:34.346 - 00:11:00.294, Speaker B: This also exists because whoever's mining B prime is going to keep mining B prime. So at this point, you have. That looks like shit, but fuck it. So at this point, you have these two competing. But now this black has received endorsements not only from the B prime miners, but also from the A miners and the C minors. So whoever is mining B, not B prime, has, like no incentive to do so.
00:11:00.412 - 00:11:29.562, Speaker A: But those endorsements are going to be accounted for by everybody. But let's say that C also has a conflicting node, right? Like C is in the same situation and this one is actually endorsing b, right? So which of these two, one of them is effectively like from perspective of a particular minor, right? So let's say there's a minor x from perspective of X. Only one of these two is valid, right? So let's say X thinks that this one is valid.
00:11:29.626 - 00:11:29.998, Speaker B: Sure.
00:11:30.084 - 00:11:54.230, Speaker A: At this point, X has no extra information, right? The next layer doesn't exist yet, so X only sees these two nodes from perspective of X. They equally good, right? So X chooses this one, will x? And now X wants to choose which one of these do they endorse? Will x? Consider this endorsement from C Prime.
00:11:55.070 - 00:12:50.566, Speaker B: So at this point you're getting to the idea of how much of the web is X replicating at any moment. The more of the braid x is actually actively replicating, like how many nodes they have as a miner, the more information they'll have and the less confusing this will be. If you're only mining a subset, then you're going to have to start trusting the message headers that you get from other trusted parties, which is if you belong to a pool and your friend is mining a, and then your friend gives you the block like you as x will trust whatever you get from your friend. But yes, you start getting these confusing. We call them arboreta because you have lots of trees and so many trees make an arboretum. I don't know, it was Tarun's joke when we made the paper. But you can't just talk about single trees coming off because you don't have one chain.
00:12:50.566 - 00:13:02.926, Speaker B: We have multiple chains. And so yes, it does start to get that there's a lot of information that you might not have all of it as a miner, which is why we say people should really mine more of the braid rather than less.
00:13:03.028 - 00:13:22.622, Speaker A: But let's say that I as X, let's say I'm mining on all the chains and I'm pretty up to date, so this is my state, right? So I see a fork on b, I see a fork on c, and I guess no fork on a. And so you see, here's the thing, right? So let's say that from my perspective, this is canonical, right?
00:13:22.776 - 00:13:23.286, Speaker B: Sure.
00:13:23.388 - 00:13:33.720, Speaker A: Will I count the complexity, like the proof of work complexity of this block, which is not canonical from my perspective towards this block on b.
00:13:34.990 - 00:13:56.000, Speaker B: Towards this block on b. Yes, this would count towards b. But if you count the weight here, this b prime still has endorsement from a and b and c, so it still outweighs the other one.
00:13:56.610 - 00:14:08.274, Speaker A: I see. When we count the weight of the block, we add up all the endorsements from all the chains, even if those chains are not canonical from our perspective, yes.
00:14:08.312 - 00:14:28.970, Speaker B: Because any chain has the potential to become canonical. If somehow it manages to outweigh the others. It actually resolves fairly nicely in simulation. It's not as messy as it looks. Forks generate and resolve all the time in our testnet.
00:14:30.350 - 00:14:45.870, Speaker A: So now another question is. So let's say, how well does it work? So let's say we have this. I'm going to replicate the graph.
00:14:47.090 - 00:14:57.780, Speaker B: Good luck. It's not actually that hard. No, you fucked it up.
00:14:58.390 - 00:14:59.330, Speaker A: No, that's correct.
00:14:59.400 - 00:15:04.902, Speaker B: No, it's the star. It's a star in the middle. Did I draw it wrong? It's supposed to be a star in the middle.
00:15:04.956 - 00:15:05.558, Speaker A: Does it matter?
00:15:05.644 - 00:15:06.280, Speaker B: Yeah.
00:15:07.050 - 00:15:08.040, Speaker A: Like this?
00:15:10.650 - 00:15:13.878, Speaker B: I think so. Shit. All right, I'm going to have to.
00:15:13.884 - 00:15:27.226, Speaker A: Look this up, but, yeah, so let's say this is the one. I'm pretty sure it doesn't matter. So let's say that I'm a user and my.
00:15:27.328 - 00:15:39.760, Speaker B: Oh, it's the star in the middle. Because it makes it diameter two. Yes. Because it's. Yes, that's why it has to be the star. Degree three. Diameter two.
00:15:44.120 - 00:15:49.784, Speaker A: Hard to believe. Okay. But, yeah, it appears to be somebody.
00:15:49.822 - 00:15:55.576, Speaker B: Way smarter than me named Peterson, which is why the graph is named Peterson. Figured this out in, like, the 1940s. Yeah.
00:15:55.678 - 00:16:14.020, Speaker A: Okay, so let's say that I'm a user. So I'm not mining. I'm just using Kadena. And I have an account on one of the shards. What is my mode of operation? Am I only synchronizing that shard on my node, or am I still synchronizing all the shards?
00:16:14.200 - 00:16:44.250, Speaker B: So if you're just a user, you can only synchronize the one that your chain is on. And that's totally fine. You can just listen to the headers coming in from large mining pools for the rest of the information if you want to. There's no need for you to replicate any more than that. If you decide that you want to scale out what you're doing and have it belong to more chains so that you can effectively load balance your application, you can do that by cloning your application onto more than one chain, but you don't have to.
00:16:46.220 - 00:16:53.756, Speaker A: So now let's say that we actually, when Cadeno will be operating, what do you think is going to be the number of shorts it's not going to be ten, right?
00:16:53.858 - 00:17:18.100, Speaker B: So right now testnet is on 20. We just forked to a larger net. We're launching. I think we're going to launch with 20. It might be 50, I don't know. It depends on how ambitious the dev team gets. But the plan is to, as we get more adoption and the network starts to become congested and we start to see transaction pooling, then we'll fork out to larger configurations.
00:17:18.100 - 00:17:33.016, Speaker B: I mean, in theory, chain web could be arbitrarily large, but obviously bounded by normal real world bandwidth constraints. I don't really expect us to ever need a braid larger than like 10,000 chains because what would you do with.
00:17:33.038 - 00:17:48.120, Speaker A: That here, where it becomes interesting. Right. For me. So let's say I'm in the adversary. Let's say there's 100 shirts. 100 is easy to divide by. So there's 100 chains.
00:17:48.120 - 00:17:54.960, Speaker A: Right. And let's say that the diameter is something like three. I don't know what will be.
00:17:55.030 - 00:17:58.496, Speaker B: I think it has to be like four or five. By the time you get up to.
00:17:58.518 - 00:18:06.384, Speaker A: 100, the diameter is four or five. And degree, which one is capital, which one is lowercase?
00:18:06.432 - 00:18:11.840, Speaker B: I use the uppercase delta for diameter and the little d for degree.
00:18:11.920 - 00:18:15.396, Speaker A: Okay. And so degree would be something like also four or five.
00:18:15.498 - 00:18:18.432, Speaker B: Yeah, call it five, maybe degree is five.
00:18:18.586 - 00:18:26.132, Speaker A: Cool. So let's say I control 5.1% of hash power.
00:18:26.286 - 00:18:26.748, Speaker B: Okay.
00:18:26.834 - 00:18:58.900, Speaker A: Right. So should be something not sufficient to attack, right? Or like 10%. Now what I'm going to do is there is a particular person I don't like, who's known to me is only validating one shard. What I'm going to do is this person, they adjacent to this one, this one, and this one. Right. So that's degree. Degree three.
00:18:58.900 - 00:19:03.504, Speaker A: So I'm going to corrupt this chart. By corrupt, I mean, I'm going to go to the chart.
00:19:03.552 - 00:19:04.836, Speaker B: So what does corrupting mean?
00:19:04.858 - 00:19:09.240, Speaker A: So by corrupt, I mean, is I'm going to throw all my hash power to the chart. So I have 10%.
00:19:09.310 - 00:19:14.152, Speaker B: So you're going to put all of your power into mining one chain, one chart, yes.
00:19:14.286 - 00:19:39.840, Speaker A: And so on this chain, because we're saying there's 100 chains, give or take, then this chain on itself has approximately 10% or, sorry, 1%. Right. Approximately 1% of hash power. So I'm not going to throw entire, my entire power. I'm just going to throw 1.1%, like something like that on that particular chain. What I'm going to do is I'm going to create a completely invalid block.
00:19:39.840 - 00:19:57.832, Speaker A: So this is the chain that is being built. So that was valid block. Valid block. Then I created something which makes absolutely no sense. Right? So it's. Let me actually use red here's. And then they continue building.
00:19:57.832 - 00:20:18.460, Speaker A: Right. So at this point, naturally, the honest 1% will say, well, that's nonsension. Like, their client will just discard it right away. So they will continue building, and this will make no sense for them the other way around. So this is the honest chain. This is the dishonest chain. But the dishonest chain is growing a little faster.
00:20:18.460 - 00:20:46.624, Speaker A: But naturally, nobody in the remaining chains respects it. So the remaining chains endorse this one. But in this chain, I'm also going to deploy 1.1%. So this 1% honest 1.1 dishonest. And my dishonest power I will throw to continue building on top of that. So I will start endorsing them.
00:20:46.624 - 00:21:00.640, Speaker A: Right. And so, on this chain, the thing is that. And I will do it for each neighboring.
00:21:04.500 - 00:21:08.308, Speaker B: Shane has five neighbors, right?
00:21:08.394 - 00:21:13.444, Speaker A: So I'm going to throw my power, approximately 1.1% into each of the.
00:21:13.562 - 00:21:15.956, Speaker B: So you can do that. How much hash power do you have?
00:21:16.058 - 00:21:19.930, Speaker A: Well, I said ten, but let's say I have 5.5. So it's going to be 1.1.
00:21:20.300 - 00:21:22.676, Speaker B: You get to do that for five chains.
00:21:22.708 - 00:21:25.236, Speaker A: Right. So it's 5.5%, including the one chain.
00:21:25.268 - 00:21:28.184, Speaker B: That you want to do. Then you can do four of your neighbors.
00:21:28.232 - 00:21:30.268, Speaker A: Yeah. Okay, I have 6.6.
00:21:30.354 - 00:21:35.192, Speaker B: Sure. So you have one chain and all of its neighbors you've attempted to corrupt.
00:21:35.256 - 00:21:45.570, Speaker A: Right. So now what happens is that all the naturally there are.
00:21:46.020 - 00:21:51.890, Speaker B: So your second order neighbors are still going to catch your bad block, right?
00:21:52.980 - 00:22:07.576, Speaker A: The question is, right, if all my second order neighbors are mining on all the chains, that will work, right? But let's say that less than 50% of people mine on all the chains, right?
00:22:07.758 - 00:22:08.504, Speaker B: Okay, sure.
00:22:08.542 - 00:22:09.448, Speaker A: What will happen?
00:22:09.614 - 00:22:17.236, Speaker B: I mean, we think that that's not a successful way for chain web to move forward, and we think that most people are going to mine all the things, but let's say that they don't.
00:22:17.268 - 00:22:35.232, Speaker A: Well, but for now, for the sake of argument, right? So let's say that in every chain, there's approximately 1% of all the hash power, right? Because there's 100%, of which a little less than half is someone who mine on all chains, and a little more than half is someone who is only mining on some subset. On some subset, right?
00:22:35.286 - 00:22:50.484, Speaker B: So even if we end up in a place where you have overlapping subsets, you still have some portion of your second order neighbors will see this validation of the bad block and see that as bad.
00:22:50.602 - 00:22:51.124, Speaker A: Right.
00:22:51.242 - 00:23:02.120, Speaker B: And then their second order neighbors will agree with them. And then when they eventually get this piece sent around the other way, we'll not allow it to continue either.
00:23:02.190 - 00:23:26.304, Speaker A: But imagine that specifically in this chart. Let's change the assumption. Let's say that approximately 50. So I corrupted a subset, right? I corrupted particular. Well, we have a smaller graph here. Okay, so I corrupted this for. And this one as well, right?
00:23:26.422 - 00:23:26.704, Speaker B: Sure.
00:23:26.742 - 00:23:29.232, Speaker A: Or if it was 100 node graph, I would have two more, right?
00:23:29.286 - 00:23:29.504, Speaker B: Yeah.
00:23:29.542 - 00:23:47.012, Speaker A: So I crafted all the neighbors. So let's say that in all the shards, which are not one of those four, a little less than 50% are validating at least one of those four, and a little more than 50% are not. Is that a reasonable assumption?
00:23:47.076 - 00:24:05.020, Speaker B: Yeah. So then it's possible that they could just start blindly accepting the bad transaction. The security properties of chain web don't work very well if at least half the people aren't mining the entire brain.
00:24:06.960 - 00:24:20.980, Speaker A: Right, but then the next question is then, because at least half the people are mining all the chains, how is it different from all of that being one huge blockchain without shards?
00:24:21.480 - 00:24:56.930, Speaker B: So, because you have all of the tiny little blocks, you get to move them through much faster. You don't have to have the same hardware requirements per individual replica. And because of the way that the chains are interconnected, you get these really cool security properties of Chainweb. It's sort of like the interlinking of ghost, be it giving you lower block times. In Ethereum, we can achieve much lower block times because of the nature of the interconnectedness of the braid. I don't know if I can draw that. I could try.
00:24:57.700 - 00:25:11.604, Speaker A: So one of the ideas is that there's no network spikes in bitcoin. I guess if you create a block, if you create a block in bitcoin, every 10 minutes, there is a spike in network activity, right?
00:25:11.642 - 00:25:52.670, Speaker B: Yeah. Right. So if you try to, this whole thing that we were just talking about where it makes it harder to corrupt because of the way that they're connected to each other, if you wanted to corrupt this block, you'd have to then corrupt this guy and that guy and that guy. And then as the braid grows, you eventually have to be making the diameter of the entire network because of the interconnectedness of it.
00:25:53.680 - 00:26:00.668, Speaker A: So within diameter, steps within diameter, number of blocks, you need to crop the entire network. Yes, exactly.
00:26:00.834 - 00:26:47.420, Speaker B: To fork you have to do it fast in order to do a 51% attack. Effectively, if you don't make it by diameter, number of hops, you have to take over the entire web. This is the whole censorship thing that we were just talking about. So, in the security paper that Tarun and I just released on archive that's getting published in June, does an economic analysis of how expensive it is to try to do this attack. And if you're less than 51% of the hash power of the entire braid, it's much more economical for you to just mine, because you have to spend so much on hash power, and the potential rewards that you get from it are highly variable.
00:26:49.680 - 00:26:50.430, Speaker A: Cool.
00:26:55.280 - 00:26:58.576, Speaker B: Oh, you know, the thing that we haven't talked about is how you move money.
00:26:58.678 - 00:27:00.032, Speaker A: Yeah, that was my next question. Right.
00:27:00.086 - 00:27:21.076, Speaker B: Yeah. Good. This diagram kind of blows. Let me try that again. Where did it go? Oh, there it is. Okay, so let's come back to a and b again. So, if you have an account on a.
00:27:21.178 - 00:27:31.528, Speaker A: Actually, quick question on the previous set. So, the idea is that a single entity, like, let's say I'm a miner on Kadena, I will have multiple machines, each of them running one short. Right?
00:27:31.614 - 00:28:15.480, Speaker B: Right. Or you could have a machine with multiple cores, however you want to break it up hardware wise is your choice. Yeah. All right. So, a, let's say you have some money on a and you want to pay me on b. The idea here is that you would effectuate a transaction, and you would put it into this block, and then that transaction, in the smart contract layer would look like a burn and a receipt slip. And the other half of that transaction, in the smart contract layer would specify, this transaction is redeemable on chain b.
00:28:15.480 - 00:29:16.360, Speaker B: And so when the proof from a propagates to chain b, by this being included in here, you see on chain b. Okay, I have the receipt from a. I can prove that the transaction was included in a block. So now, on chain b, in this block, you can resurrect the chains that were burned on chain a. The coins that were burned on chain a. And so you can imagine if you were on c and c communicates with b and not a, that if you were paying somebody on c from a, then once you made it out two blocks, then here is where you could resurrect your coins. But since we're in proof of work land and you have to wait diameter, number of blocks for confirmation depth anyway, it's exactly the same amount of time to pay somebody on the same chain and wait for confirmation depth as it is to pay somebody on any other chain and wait for confirmation.
00:29:16.440 - 00:29:40.144, Speaker A: But you would still wait for the confirmation because you only care about that part of the transaction because this one, you can also always resubmit, right? Yes. See, I guess one question here is, okay, so it is my responsibility as a transaction receiver to submit the receipt.
00:29:40.192 - 00:29:40.404, Speaker B: Yes.
00:29:40.442 - 00:29:40.980, Speaker A: Right.
00:29:41.130 - 00:30:07.116, Speaker B: Once I've paid you, it's not my problem. It's your problem. This is why the whole trying to make sure that transactions are synchronous thing, I don't really understand. I'm totally fine with asynchronous transactions because as long as I can prove that you paid me, I can go and redeem it whenever I want. And we don't have to have some sort of uniform number of tokens in the system at all times. We can have float in between burn and receipt. It doesn't really matter to me.
00:30:07.298 - 00:30:20.304, Speaker A: So let's say that my receipt was like, it didn't get through here, yet it got accepted here. Then even if C forked out, I can still resubmit it here. Right?
00:30:20.342 - 00:30:31.830, Speaker B: Because, yeah, you can redeem your receipt whenever. And if somehow it manages to get interrupted in the middle like there's some sort of a network crash, then it's just like the payment never happened.
00:30:33.400 - 00:30:36.464, Speaker A: Oh, you're saying if a got never finalized. Effectively.
00:30:36.512 - 00:30:37.110, Speaker B: Right.
00:30:47.760 - 00:30:52.696, Speaker A: So network c has some sort of view on network a, like it has like a Merkle route.
00:30:52.728 - 00:30:53.196, Speaker B: Right, right.
00:30:53.218 - 00:31:02.480, Speaker A: That's how I'm going to be proving that the receipt exists. What prevents me from claiming the receipt twice?
00:31:03.140 - 00:31:05.036, Speaker B: It consumes the receipt.
00:31:05.148 - 00:31:18.688, Speaker A: But is it recorded on c or on a? The fact that receipt is consumed. So for every receipt, there's like a unique place in the Merkel tree.
00:31:18.784 - 00:31:27.960, Speaker B: Yes. And a says this can only be redeemed on c. And C says, I'm consuming this transaction event from a and once it's consumed, it can't be used again.
00:31:28.030 - 00:31:32.650, Speaker A: But also as a payment receiver, it's also my responsibility to submit it to b first.
00:31:34.300 - 00:31:42.892, Speaker B: No, it just happens through the consensus layer that just gets propagated. You're just waiting on c, waiting to see that the proof has come through.
00:31:43.026 - 00:31:49.136, Speaker A: So receipt is never acknowledged in any way. On b, B is only needed so that C learns about the root of it.
00:31:49.238 - 00:31:59.940, Speaker B: It's just going through the graph. And once it eventually gets out to diameter, everybody will know about the thing, but only C cares because C is the one on which you can redeem your receipt.
00:32:00.840 - 00:32:02.550, Speaker A: Cool. Okay, that makes sense.
00:32:03.400 - 00:32:16.650, Speaker B: Yeah. It's the combo of the SPV and the roots that makes chainweb work. It was putting those two things together that was the magical moment of, oh, this is actually going to work.
00:32:18.860 - 00:32:23.340, Speaker A: Cool. Shall we talk about pact?
00:32:23.840 - 00:32:27.710, Speaker B: Sure. I'm not the biggest pact expert, but I can talk.
00:32:29.120 - 00:32:31.630, Speaker A: Is there anything we didn't cover on the protocol level?
00:32:32.960 - 00:32:59.604, Speaker B: I don't think so. I think that was all of the juicy stuff. Now in Testnet, we're working on putting through a transaction simulator that is pumping a lot of transactions through and seeing what happens. It's pretty fun. Yeah, packed. So, I mean, you might want to tag Stuart in, except he's not here. You can talk to him some other time.
00:32:59.604 - 00:33:02.104, Speaker B: Since he actually wrote the lion's share.
00:33:02.142 - 00:33:06.840, Speaker A: Of pact, we can at least cover the high level details. Why pact?
00:33:08.780 - 00:34:22.208, Speaker B: So a lot of why Pact ends up sounding like, why not the, you know, neither here nor there, how you feel about the EVM. But our hypothesis is that your smart contract language should basically handle a lot of stuff for the developer that you don't want your developer having to go through and worry about something like namespace abstraction, that you should be thinking about your smart contract, not all of the elements that you wish a virtual machine had actually done for you instead. So pact, it has a super small space, it has a super small number of functions, and it handles like keysets for you. It has a very granular permission set, and so you can allow people to do different things depending on how they've authenticated their way into the smart contract. You don't put in your key. There's a function where you put in your governance function for the smart contract, and that function can be satisfied in, you name it a number of ways. If we could say the two of us and both of us have to put our key in, or there are ten people and six of them have to put their keys in.
00:34:22.208 - 00:34:27.388, Speaker B: It's really arbitrary in the way that you can handle the governance functions in pact.
00:34:27.484 - 00:34:30.172, Speaker A: Does it also govern who can update the governance function itself?
00:34:30.246 - 00:34:30.870, Speaker B: Yes.
00:34:32.200 - 00:34:34.580, Speaker A: Cool. And so pact is the language, right?
00:34:34.650 - 00:34:35.744, Speaker B: Yes, pact is the language.
00:34:35.792 - 00:34:37.380, Speaker A: Or it's also a virtual machine.
00:34:37.800 - 00:35:06.364, Speaker B: It is not a virtual machine. Pact is interpreted on the whole mess. And so you can actually put pact in pretty much anything you can put pact on. It doesn't have to be a smart contract language. We're actually talking to some people about putting it on non blockchain type of applications because of the way that the language is super flexible. You can do a whole lot of things with it. I actually had a call with Akamai they were like, we want to put pact on top of something that we made internally.
00:35:06.364 - 00:35:31.800, Speaker B: That's cool. Great. Yeah, pact is, it looks a lot like English. It doesn't look like a programming language in the way that you would sort of expect a programming language. It does have a lot of parentheses because it's a functional, yeah, it's written in Haskell, but you don't have to know any Haskell to write pact.
00:35:32.860 - 00:35:35.240, Speaker A: The big property of pact is that it's formally.
00:35:38.060 - 00:36:18.816, Speaker B: Has. So for example, pact is non Turing complete and on purpose. We don't think that recursing is something that you should do on a blockchain. It seems like a silly idea to try to calculate Dexter's algorithm shortest path from New York to LA on the blockchain. And so because the syntax tree of pact is very limited, we can unroll the whole thing and pipe it straight through into the z three solver with Smtlib. And so this is trivializing a whole lot of work that went into it. But we don't have to worry about, like when people are talking about, oh, we're going to formally verify some subset of solidity.
00:36:18.816 - 00:36:50.610, Speaker B: They've had to carve away a lot of things that we have carved away originally when we wrote pact in the first place. And so it's not just formally verified like a compiler is formally verified, it's actually, you can write user code, and then when you save, if you're tied into the formal verification system, it will verify any annotations that you've put in our own annotation language into your smart contract. So it can be like, prove that this value can never go negative, or prove that this account can only receive and can never send.
00:36:51.220 - 00:36:55.564, Speaker A: But when the contract is on the blockchain, it is just plain text packed.
00:36:55.612 - 00:37:00.228, Speaker B: Yeah, it's not the formal verification stuff you do locally on your machine, but.
00:37:00.314 - 00:37:07.124, Speaker A: Are there any concerns about performance of interpreting smart contracts? Interpreting is way more slow, right?
00:37:07.322 - 00:37:15.640, Speaker B: I mean, pact is super fast. It's very lightweight. There's not a lot going on in there in terms of crazy execution.
00:37:16.620 - 00:37:27.710, Speaker A: Cool. Another question I have is, are there any plans to have, do you think at all about how Kadena would interact with other blockchains, or is the bright future only has Kadena and nothing else?
00:37:29.200 - 00:38:12.324, Speaker B: I think the future is totally interacting with other blockchains. I would love to see that happen, because we have this idea of being a fast transaction execution layer. I would love to see a representation of other people's stuff that executes on Kadena and then exits afterwards. So like flash some sort of representation of some other non fungible asset onto Kadena and do a bunch of operations and then move it back off again. It seems like a totally reasonable way of interacting with our stuff. Also, because of the whole. We have a permission blockchain as well in our stack, our permission blockchain, scalable BFT, is also designed to connect to Chainweb.
00:38:12.324 - 00:38:50.550, Speaker B: So we have people that are writing applications written in pact that have some part of it that's on a private blockchain instance that they just spin up and some part of it that's going to be on Chainweb and that those pieces talk to each other and they talk to each other in the same way that you do any sort of off chain oracle. Like there's an API call and you send a Merkel route over an API call. But because we're in the same system and it's native, we're designing it all to automatically work with each other and be able to handle handshakes from one side to the other. And there's no reason why we wouldn't be able to extend that protocol to other people if they wanted to connect too.
00:38:50.920 - 00:39:12.616, Speaker A: But. So I guess the complexity here is that Kaduna's producing blocks significantly faster. Right. So if you want to verify blocks on the other side, like, let's say you want to have a bridge with Ethereum. Ethereum would not be able to validate blocks on Kadena. Right. So you need some sort of, they would just take a while, but it will be like the lag is going to be increasing.
00:39:12.616 - 00:39:23.490, Speaker A: Right. It's an interesting topic in general, how would you synchronize from a faster chain to a slower chain if you want a two way bridge, for example?
00:39:24.180 - 00:39:39.828, Speaker B: Yeah, I mean, you'd have to build in the lag time right into your application and expect that anytime that you're connecting back to Ethereum, that that's just going to have to take longer and to expect friction and the number of block counts between one side and the other.
00:39:39.994 - 00:39:57.804, Speaker A: Well, I guess it's a little more fundamental because Ethereum in principle cannot validate the whole chain of Cardina. Right. So even lag time will not help much. But yeah, it's just interesting topic in general, how would like connection with slower chains, which is, I guess it's very much open.
00:39:58.002 - 00:39:59.884, Speaker B: Yeah, that's an open problem.
00:40:00.082 - 00:40:33.466, Speaker A: So another thing I was thinking right now, I don't think I have a full story in my head, but let's still look at it and see if it's properly handled. So, imagine that I'm an adversary. So this axis is chains, and this is time. Right. And so we're building blocks. So let's say that I'm a malicious actor. I again, corrupted the chain.
00:40:33.466 - 00:40:56.886, Speaker A: Corrupted, meaning that I brought more hash power than they have. I created a block which I broadcasted, actually, which I never broadcasted. All right, so imagine that you are an honest. And so, let's say that the connection is the following. So these two shards connected. These two connected. These two connected.
00:40:56.886 - 00:41:00.378, Speaker A: And these two connected. But, like, not these two, for example.
00:41:00.544 - 00:41:01.018, Speaker B: Sure.
00:41:01.104 - 00:41:30.226, Speaker A: Right? And so I corrupted these three by sending more than 50% of the hash power. So if it was 100 charts, I would corrupt six again. Right. So these are corrupted. What I do is I create a block here which I don't show to anyone, and I create two blocks here which have the header of the block. But the block was never sent out. So how is it handled? Imagine you are on this chart.
00:41:30.226 - 00:41:47.418, Speaker A: Right? So this is shard a, and you're about to produce this block. And you see that there is a block in shard b, but you cannot download one of the blocks it endorses. Do I completely ignore it?
00:41:47.504 - 00:41:59.854, Speaker B: So, in this case, there's a block on b that's been created, and it points to the pass block on c. Yeah.
00:41:59.892 - 00:42:09.758, Speaker A: And so this block. Okay, some validator on a, some minor on a. Cannot retrieve this block. This just doesn't exist.
00:42:09.934 - 00:42:11.070, Speaker B: What do you mean this doesn't?
00:42:11.150 - 00:42:15.042, Speaker A: So, from perspective of a, does this block exist? This block is seen.
00:42:15.096 - 00:42:27.198, Speaker B: Yes. Yeah. This guy connects to this one. It sees that it's listening to the b message queue. And a is like, sweep. Great. We're going to make a block, but then a tries to make the next block.
00:42:27.198 - 00:42:33.660, Speaker B: And there's no block from b. But let's say there can't be anything here because there's nothing here.
00:42:34.590 - 00:42:47.390, Speaker A: But again, I have corrupted all three of this. So in all of these three, I have 1.1% of cash power. And everybody else, all the honest collectively have one. Because I saw this block.
00:42:48.290 - 00:42:50.394, Speaker B: Which block is the block that you're withholding?
00:42:50.442 - 00:42:55.790, Speaker A: So this one is withheld. Right. But I myself still see it. Right. So I can create something on top of it.
00:42:55.860 - 00:42:56.478, Speaker B: Okay.
00:42:56.644 - 00:43:00.302, Speaker A: But for that, I don't need to broadcast. This block against. This block only has a header of this block.
00:43:00.366 - 00:43:00.882, Speaker B: Got you.
00:43:00.936 - 00:43:02.180, Speaker A: Right, okay.
00:43:04.730 - 00:43:06.786, Speaker B: But this one you're withholding.
00:43:06.818 - 00:43:07.158, Speaker A: Yeah.
00:43:07.244 - 00:43:07.494, Speaker B: Okay.
00:43:07.532 - 00:43:21.274, Speaker A: And so then I'm also going to create a block here. So blue blocks are the blocks I created. Right. So this one is created by me, but it's withheld. This one is created by me. This one is created by me. And this one is created by me.
00:43:21.274 - 00:43:28.370, Speaker A: Right. And so I continue doing that. But this block was never broadcast.
00:43:28.470 - 00:44:01.080, Speaker B: So you don't broadcast this one, but you make it. But meanwhile, other people are also still mining on c, which means somebody else. Somebody else is slower going to then later make this block. Right. This guy. And they're going to broadcast that. So then when a is going to look at this one and see it and it's fine, because they're not mining this one and they're not mining the whole web.
00:44:01.080 - 00:44:14.522, Speaker B: But whoever's mining on b, that's not. You will see that there's nothing here and will then make a block here that points to this one.
00:44:14.656 - 00:44:21.914, Speaker A: I guess my question was, let's say a is actually mining on c. Right. Because not a. A is not a person. Right.
00:44:21.952 - 00:44:25.486, Speaker B: Right. A is not a person. Some person x is mining everything.
00:44:25.588 - 00:44:28.846, Speaker A: Yeah. Some person x is mining everything. And x is honest. X is not me.
00:44:28.868 - 00:44:37.854, Speaker B: Right. If X is mining on a and C and sees from a that they can't validate c, then they will not accept.
00:44:37.902 - 00:44:46.120, Speaker A: Okay, so from perspective of x, if they cannot retrieve this block, then this block does not exist. Yes. Okay. Yeah, I guess that makes sense.
00:44:47.210 - 00:44:49.158, Speaker B: This diagram is a total mess.
00:44:49.324 - 00:45:10.030, Speaker A: I think this diagram makes a lot of sense. Yeah, I think that works. Cool. Okay. I don't see any other way to break Cadino. At least not yet.
00:45:10.100 - 00:45:13.374, Speaker B: Yes. All right. Keep thinking about it.
00:45:13.492 - 00:45:16.654, Speaker A: Yeah. Is there anything else interesting we didn't cover today?
00:45:16.852 - 00:45:32.914, Speaker B: We talked about censorship. We talked about 51% attacks. I don't feel like I can talk about the nitty gritty bits of pact because I haven't worked on it. So if you want to talk about pact more in detail, you're going to have to talk this, too.
00:45:32.952 - 00:45:36.946, Speaker A: Well, I guess people can google it and read about this, right? Yeah, I guess pact is.
00:45:37.048 - 00:45:41.714, Speaker B: There's a lot of documentation on pact, and we have lots of tutorials. You can just watch the videos.
00:45:41.912 - 00:45:44.926, Speaker A: Cool. Okay. So at the end, we always ask one question which is not technical.
00:45:45.038 - 00:45:45.506, Speaker B: Okay.
00:45:45.608 - 00:45:47.034, Speaker A: Which is, when is main net?
00:45:47.152 - 00:45:48.006, Speaker B: October 30.
00:45:48.038 - 00:45:49.574, Speaker A: October 30. Oh, it's set in stone.
00:45:49.622 - 00:45:54.362, Speaker B: Yes, it's set in stone. We officially have a release date. Actually, we released the date this morning.
00:45:54.496 - 00:45:59.242, Speaker A: Nice. Awesome. Okay, cool. Thanks, everyone, for watching.
00:45:59.296 - 00:45:59.562, Speaker B: Thanks.
00:45:59.616 - 00:46:04.920, Speaker A: Until next time, our.
