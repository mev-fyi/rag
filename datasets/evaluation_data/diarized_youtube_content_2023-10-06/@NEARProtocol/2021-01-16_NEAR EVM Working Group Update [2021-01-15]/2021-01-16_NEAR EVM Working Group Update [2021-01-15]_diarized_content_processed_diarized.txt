00:00:04.730 - 00:00:07.520, Speaker A: Yeah, and we are live.
00:00:17.840 - 00:00:22.140, Speaker B: Okay, Alex, you want to start with the agenda in the discussion?
00:00:27.280 - 00:00:37.510, Speaker A: Arthur, it appears that because of some strange reason, Zoom is not working correctly on my computer. So if you are able to lead this meeting and share this stuff, then it will be good.
00:00:37.880 - 00:00:46.100, Speaker B: Okay, hold on, let me share the screen. Oh, host disabled screen sharing.
00:00:46.260 - 00:00:58.640, Speaker A: Yeah, I just made you host so you can do anything.
00:01:04.590 - 00:01:47.110, Speaker B: Okay, so today, welcome everybody, we have a little bit more people than usual. Welcome to the EVM working group's weekly public sync. Today we're going to do a little bit something different than usual. Normally we give team member updates and like this time those will be after the meeting on GitHub. So we have a weekly update discussion which you can find in the near core repository. And over there the YouTube link will be posted. Somebody can put it in there as soon as they notice it on YouTube.
00:01:47.110 - 00:02:44.150, Speaker B: And the agenda today is this. So our current goal that we are working towards, and let me edit and talk at the same time. So right now we are planning our q one objectives and key results, and we are staffing the team and allocating the work. So that's the near term objective. And the midterm objective is our deployment to testnet, which we'll talk about in a moment. Alex and I prepared a short presentation in order to help with the OKR review and planning. So let's have a look at what we did last quarter.
00:02:44.150 - 00:03:27.474, Speaker B: Let's talk about some of the important things we have to do in q one, and let's look at how we can do that. So in the last quarter we had three okrs defined usability EVM, and updated EVM and desant deployment. We didn't quite make all of these okrs. The one we did best on was usability. And thanks Mike, especially over here. This is in pretty good shape. We had defined three key results briefly.
00:03:27.474 - 00:04:15.878, Speaker B: Internal tooling should be updated to support the EVM, and that involves a number of repositories, including the Cli Javascript API, the web three provider, and that's all pretty much in nice shape. We can always do more, but when we created this earlier this week, we patterned ourselves on the back on that one. There are also substantial documentation updates. We have, I believe something like. Let's have a look. Actually here we have something like ten different pages added to the documentation. Not everything is maybe published yet.
00:04:15.878 - 00:05:37.754, Speaker B: Okay, a few are still pending, but there will be a lot of stuff here in the Ethereum compatibility section under develop in the near docs, and this is all currently targeting Betanet, because the EVM is deployed on Betanet, where we did less well, is the last key result, which was perhaps a little bit ill defined, as in it's about truffle support for existing EVM projects. And in this case, we didn't really define what we should use as the metric here, and we run out of time in measuring something useful on this. So I've assigned us a 25% grade over here because I believe they're in okay shape. So this conservative estimate, but we haven't in good measurement on the metric. We haven't a good metric and we haven't good measurements on it. So I scored us low on that. Now, on the next objective, there was the updated EBM that first of all involved updating us from the old parity Ethereum beta release that we were using at the beginning of the quarter to something more recent.
00:05:37.754 - 00:06:24.270, Speaker B: Which means this is open Ethereum. We had planned to upgrade to open Ethereum three, but we backtracked on that, given that it's a new code base and it didn't tabalaro deployment yet. So we did a number of upgrades all the way until two seven two, which is where we are currently. So that's the last part of the Ethereum release, just before the open Ethereum team took over. Now, since then we've opened discussions with the Open Ethereum team. We have more insight into their roadmaps and procedures and quality assurance and whatnot. And we are planning to upgrade soon to open Ethereum 32 actually, which will support the Berlin hard fork.
00:06:24.270 - 00:07:15.950, Speaker B: So in any case, for the adjusted objective, we did two all that work. The second key result was metatransaction support. And on this I believe that we can grade ourselves 100%. A lot of work by Bo Mike and Ilya, by the way, if anybody disagrees, feel free to speak up. And the last key result involved benchmarking. This was a little bit ill defined, and we haven't really properly begun this work, so we're going to have to put a zero there. Then we had the aspirational objective, which we did not achieve last quarter.
00:07:15.950 - 00:07:48.234, Speaker B: In other words, deployment destinate. And this we have to get done this quarter. It will not be aspirational for this quarter. But we did do many prerequisite things, not all of them captured here in the key results. Some things we did complete boarded. Great work on the gas fees. That is a larger discussion I won't go into right now.
00:07:48.234 - 00:08:34.760, Speaker B: We have a lot of test coverage, much more than we used to. We can always have more but significantly, we have, for example, the balance of tests we are now working. What we didn't even begin on is the betanet's planned bug dash. So that will be this quarter as in an incentivized period of attacking EVM on the perinet. Similarly to the previous objectives of benchmarking, we haven't really measured yet the transactions per second that we are capable of on the EVM. However we would expect to reach this target. Just need to measure that.
00:08:34.760 - 00:09:45.520, Speaker B: And yeah, we didn't deploy to this net in the last quarter. So that was the last quarter. And we learned many things from this OKR review, which has been ongoing all week, namely that we had somewhat ill defined OKRs and we had not the best metrics on all of them. It was hard to remember what exactly we meant in interpreting some of those metrics, and they were more ambiguous than they might be. So for Q one, Alex and I have done a bunch of work on that, but before that, let's have a brief digression. So much of the work over the last few weeks, or even last month, has been about aligning everybody in the same direction, because there's been a lot of differing visions for what the EVM should represent to Neo. I believe we are getting some substantial alignment now and one of the last very contentious issues.
00:09:45.520 - 00:10:30.650, Speaker B: It's not a simple answer. There are many trade offs to consider, and people have somewhat maybe entrenched in some cases, and in other cases heated views has been the choice of the base token for the EVM. So there's a whole discussion about this on the forum. Those interested can check that out. Let's load it up here. Long thread with 20 posts. So if somebody has an interest in that question, that's where you should look and perhaps participate.
00:10:30.650 - 00:11:29.610, Speaker B: Now, as it currently stands. So maybe to introduce this issue a little bit. For those who haven't read the forum post, as it currently stands, the near EVM is using NIR as in the near token, as the base currency base token of the EBM as well. This has a lot of benefits in terms of, for example, being able to call out from the EVM into the near virtual machine the beta runtime. It has a lot of elegance and simplicity to it, and it has been a popular choice in other EVM compatible chains. Well, actually, every single one I've looked at, they've done the same. They've adopted or created a utility token and in some cases also used that utility token for fundraising, as in an ICO of that utility token.
00:11:29.610 - 00:12:50.298, Speaker B: For example, moonbase with glimmer. However, there is a contrary case to be made, and that case is that from a business perspective, it would be highly preferable that we would be really genuinely 100% compatible with Ethereum. I've a little bit unpacked this here and on the forum in terms of what happens if we wanted to port something like uniswap, say so. Just looking at the Uniswap code base, digging into it, you can find. So talking now about the UI, the DAP itself, not necessarily the contracts, digging into it, you can find tons of places where f is hard coded as an assumption, as in an actual text string, f, but also fundamentally assuming that we're operating on a chain that has f. So for example, any DAP which is meant just for Ethereum, as in it hasn't been ported to a wide range of EVM chains, and that would be most of the apps right now. It's going to assume, for example, that it can get the USD exchange rate, as in the price of eth from some oracle or another.
00:12:50.298 - 00:13:26.146, Speaker B: And that would be one thing you would have to change. As I mentioned, there's a ton of hard codings of ETH as, let's say, a user interface concern. You would have to deal with that in some similar way to how we do localization in applications, as in on this chain we're going to show near. On this chain we're going to show glimmer, and over here it's something else. And then if you on f, we can actually say f. Virtually none of the apps dapps have currently been coded with that in mind. All of them have assumed a simple view of the world, as in they are running on Ethereum.
00:13:26.146 - 00:14:35.290, Speaker B: Why should they do so? That's one part of the problem, that porting something like uniswap right now would mean making it run on the near EVM would mean forking a whole bunch of repos, at least two for the user interface, and potentially more. We haven't followed the whole dependency hierarchy yet. And maintaining a long standing or indeed indefinite fork that would do a search and replace of all strings where we hard code f, it would change all the price oracles, it would deal with all the code, and there's a lot of it that assumes that there's an easy conversion to be done between f and wf, and probably more things that we haven't considered. But those for starters. And this would need to be done for every single DAP. Pretty much that you would want to port to the near UBM. That's not a good proposition.
00:14:35.290 - 00:15:31.002, Speaker B: So after a lot of internal discussion, debate, alignment, it does look like the most sensible thing for us to do from a business perspective is to adopt f as the base token for the near EVM. And how to do that is a big question which we can come to. So let's move a little forward. In order for us to be able to use ETh as the base token, we need to be able to bring it over as in one f on the near EVM should represent in some form an f on the f one chain. And some chains, for example, define a smart chain. They call this a pegged token, which might make sense as nomenclature. We've been calling it bridged assets.
00:15:31.002 - 00:15:43.380, Speaker B: As to some other chains, we can settle on something good for that. So Alex, I'll hand it over to you to present how you figured that we should do this currently.
00:15:43.750 - 00:16:12.810, Speaker A: Sure. So the next couple of slides are the principal scheme of how we can implement the bridge to the EVM. This is not final. We are just thinking of how this can be implemented. We were discussing it with Eugen yesterday. So this is what you can see here. So on the slide you can see the left hand side which represents the Ethereum blockchain, right hand side which is the near blockchain.
00:16:12.810 - 00:17:12.400, Speaker A: The blue rectangle is the bridge infrastructure that is currently there, currently deployed, and it is common for all of the connectors that are using this. The infrastructure consists of several parts. So there are some smart contracts on both blockchains that are light clients. There are provers, the smart contracts that are able to check the facts that something has happened on the other blockchain. And there are in between block relayers. And these are just services that are sending transactions to light clients with the information about the other chain. Now, this breach infrastructure is used by multiple connectors and people are and developers are able to develop their own connectors and to breach their own information.
00:17:12.400 - 00:18:13.570, Speaker A: So in this specific case, we would like to develop an ETH locker smart contract and deploy it to the Ethereum blockchain and also update the EVM precompile contract so it can also interact with it. It will go into act as a part of this bridge here. So on the slide there is a principal scheme for uploading of s for bridging s to near s or ns. So it works the following way. First, the user is calling an ETH locker account and this is going to be a payable function. So it deposits some f inside of f locker account. This account, as a second step, it emits an event and this event is mercurialized in this particular block.
00:18:13.570 - 00:19:12.146, Speaker A: Then without any interaction with the users block relayers are submitting a block into the Ethereum lite client. On near site. It gets verified. There is some kind of finality period that we need to wait for this block to be able to be used so we can use this block to prove the events that happened there. Currently it is about 25 blocks, so it's about seven minutes. Then the relayer, or actually which can be in any account in the near native blockchain. So near native account is scheduling a finalizing transaction that goes to one of the functions or one of the methods of the EVM precompile.
00:19:12.146 - 00:20:16.346, Speaker A: Within this transaction, relayer is submitting the information about the transaction that happened on the Ethereum blockchain and actually submits the proof, or the proof of the event that was emitted on the Ethereum blockchain. EVM procompile checks the proofs by calling approver contracts, which actually literally call Ethereum lite client to check the eth hash and stuff like that. And in the end, obviously everything gets back to the EVM precompile. If everything is correct, EVM precompile mints near s and deposits it to the user account. There are multiple important theme in this scheme. So first of all, there is only a single user transaction required. And this is a necessity of this scheme, because if a user, an ethereum user is not having a near account, he is not able to schedule any call on the near side actually.
00:20:16.346 - 00:21:02.550, Speaker A: So that's why there should be somebody who is scheduling this call for him. And that's why this setup should look like this. So only single user transaction happening on the Ethereum side. Potentially we can split EVM precompile and create an f minter smart contract there, which is going to just mint and burn NF. And we can do this for the separation of concerns. So we are not going to compose everything into single EVM precompile, but we need to assess whether we need to do it. Especially it depends on the other direction of the transfer.
00:21:02.550 - 00:22:16.750, Speaker A: You will see it on the next slide. Second, another thing is that the relayer, so you can see here are two different types of relayers. The first one are inside of the breach infrastructure and we are not talking right now about them, they are just working and we assume that everything is good on that side. Now we need to have a relayer that is going to finalize the user transfer. And this relayer needs to have an account in EVM, a near EVM, just because this relayer is going to provide in this step number four, his account or his address in order to be renumerated. Because in the first transaction that user schedules on the Ethereum blockchain, he specifies that there is a certain amount of NF that is going to be transferred to the party that is going to relay the finalization transaction. And this is the actual incentive for relayers to send these transactions because a relayer is going to pay some near for this finalization transaction execution.
00:22:16.750 - 00:23:23.590, Speaker A: Yeah, and the last thing that we need to figure out how to do, as you see here, EVM is a pre compiled smart contract. So it is going to be there at the very start of the network. While the bridge is designed, the way that prover and Ethereum light clients are just ordinary smart contracts, they are not there during the start. But when executing the finalization transaction, EVM precompile need to call prover, which means that EVM need to know where this contract is located. And that's why we need to have an ability to say to EVM where this breach is located. So this is something that we still need to figure out how to do. But in general, probably it can be done all good, at least with a full access key and then deleting this full access key once the bridge is deployed.
00:23:23.590 - 00:24:18.594, Speaker A: So this is the principal scheme from my point of view, personally it is really good just because from the user point of view, the bridging transaction is atomic. So you schedule one transaction and then it just happens. And also it is secure because you can see that there is no way f is not lending on any account on near, except for the user account. There is no intermediate place where we are putting f. We're directly storing it inside of EVM to the specified user account. Okay. And if we take a look at transfer back, it is a little bit more complicated because we have now two parts.
00:24:18.594 - 00:25:30.350, Speaker A: Now the user has an account on near site and the transfer obviously need to be started there. So user need to send a near transaction. But unfortunately he is not able to send a near loan transaction. So he needs to call a method of the EVM recompile to withdraw some funds. But unfortunately he's not able to do this because what we expect from user is to sign normal ethereum transactions, which are not the near transactions. What he can do is to sign something and then a relayer needs to be there to pay near fees for the user. Relayer then relays the withdrawal transaction to EVM precompile a precompile contract is able to analyze it and burn some ns from the user account and produce what is called execution outcome.
00:25:30.350 - 00:26:21.360, Speaker A: This is something that can be treated similarly to the events in Ethereum. This execution outcome is related to near light client on the Ethereum side, and then the user need to call on the Ethereum side the finalization transaction number four, which is like literally withdrawal. And it works absolutely the same way on the near side. So s locker checks the proof from the prover, a smart contract deployed inside of the breach infrastructure. And if everything's okay, ethlocker releases some f and sends it to the user account. Two user interaction points here are required. So one is on the near side, the second is on the Ethereum side.
00:26:21.360 - 00:27:29.090, Speaker A: This scheme can be upgraded with the relayer approach absolutely the same way how we have had on the previous slide. So there is a relayer on the Ethereum side that is incentivized with some s to be able to create a withdrawal transaction. So this is possible, we can do it, but it is not necessary like in the previous case. And the near side relaying is incentivized by the fact that within this EVM precompiled transaction execution actually the part of the funds is transferred again to the relayer account inside of near EVM. So principal scheme is there for sure. We need to implement this. There is a hard connection that is going to be introduced in between near EVM precompile and the bridge.
00:27:29.090 - 00:27:35.240, Speaker A: But this is something that unfortunately should be done in this case.
00:27:38.000 - 00:28:34.924, Speaker B: All right, thanks Alex. I think we need to perhaps a little bit simplify this whole section of the presentation next time we present it and take the technical details after. But in any case, thank you everybody for holding all your questions. Let's deal with those after we finish the OKR planning. So we have considered what we ought to do this quarter and what we can do, and Alex and I think it looks something like this. So the number one numero uno objective this quarter is to get EVM on Testnet with a full punch list so we don't screw anything up. And this is the outcome we would like, as in we have to deploy a compatible EVM.
00:28:34.924 - 00:29:33.890, Speaker B: The pulling hard fork is coming perhaps February, we'll see. So we need to upgrade our implementation to support all the new features in the polin hard fork, and we should be capable of running any Ethereum contract which is not using anything very strange. So that's the first key result then. We of course care very much about Devex. We have done a lot of work in the last quarter which actually wasn't captured in the original key results because we adjusted the course along the way. We've done a lot of work on having an RPC endpoint, a web three compatible RPC endpoint, which means that for an Ethereum developer to be able to deploy his projects is ultimately just a matter of changing his endpoint URL. And that's beautiful.
00:29:33.890 - 00:31:09.170, Speaker B: That's how simple it needs to be. So we haven't defined yet the metric here, but we would like something like when we work with partners, they'll be able to deploy their projects. Community members will be able to deploy their projects easily, starting with a link to the onboarding documentation for how to do all this, which should have video, photographers and the like as well, and go from zero to hey, it works in about 30 minutes in the majority of cases, parato, majority of cases for the user experience, somebody who's not a developer but the 1 million plus people who use metamask should be able to send a transaction to the EVM in a fairly short order, something like ten minutes, given that it takes, as Alex said, seven minutes to transfer the assets over the bridge. Now we'll need to coordinate, of course, with the SRE team to make sure that before we go to testnet that all of this is easy to maintain. And we had a bit of a rehearsal on all of this last week when we actually took down betonet. So we've done the postmortem on that, and it wasn't a planned outage. We've done the post mortem on that, and we'll aim to do better in the future and also improve all the procedures around us.
00:31:09.170 - 00:32:10.736, Speaker B: Performance is important. We do want to start piping the load from s one, both the various testnets and ultimately the main net into the EVM to make sure that we can handle that load. So making sure we can will be something very important this quarter before we can consider moving forward with deployments. And ultimately we need to put up a grand prize for come and hack us. Do your best or worst. Now this should be done just after everything else is complete and just before we would then actually deploy to testnet. And note that the timelines here, as in time frames, one day of stress testing, a couple of weeks of hackathon, these are the success criteria.
00:32:10.736 - 00:33:30.620, Speaker B: It doesn't mean that we don't run these things for longer, but if we can have 24 hours of piping the load from something which can be called ethereum, whether it's a testnet domainet, then that's probably a pretty good indication that we're in good shape even if we break on the second day. And for security, of course ultimately this bounty should be extended for as long as seems useful. But if we have a couple of weeks of people, enough people. So that's question for the metrics, enough people attempting to break us and we haven't suffered a major setback, then things look pretty okay. That was the first objective. Now the second objective is, let's say a cross team objective, as in we'll want to collaborate with business development on partner support and verify pickers and other teams, and with the bridge team on making sure we can actually transfer F and ERC 20 tokens. So this is pretty straightforward.
00:33:30.620 - 00:34:18.060, Speaker B: Most of our partners should succeed importing. Maybe it's better to call it deploying, given that we don't really want it to be a porting effort. We want it to be just another deployment. So they should be able to deploy their apps to testnet once that's all up and going. And they should certainly be able to bring the liquidity over once we get that far. Now of course, the third objective has to be that we go to Mainnet. Now this, I know that everybody would like to see this this quarter, but I have to at this point deem it aspirational.
00:34:18.060 - 00:35:23.392, Speaker B: So we will work hard and hire like crazy onboard everybody, but it's not very likely this quarter. I do think it can be soon after this quarter, but unlikely this quarter. So here we don't have as long of a list of key results as on the Testnet because most of those things, when they're done for Testnet, they're done for Mainnet as well. For example, EVM compatibility. When we have achieved the Berlin hard fork compatibility, it doesn't need to be repeated here. So in other words, to go to Mainnet right now, the punch list would look like something like bug Bash, hackathon, a stress test, and then ultimately the consensus problem, getting all the validators to agree that this is a good idea, which is probably a project onto itself. So that's pretty much it.
00:35:23.392 - 00:35:48.484, Speaker B: The last thing in the presentation, this is what the team looks like currently. So we have four people permanently assigned, one of them beginning next Monday. And we have four other people in supporting roles. And we appreciate you very much. We need all the support we can get. Thanks Mike. Thanks Ilian, and thanks Eugene.
00:35:48.484 - 00:36:22.284, Speaker B: Certainly. So we are hiring for both the bridge and EVM teams and we also pay a decent finders fee. So talk to me and Alex. If you know somebody who would be helpful to this endeavors. Okay, so let's take some questions. I'm sure people have them. Nobody? Come on, I know you have some questions.
00:36:22.284 - 00:36:23.390, Speaker B: Speak up.
00:36:25.920 - 00:36:32.370, Speaker C: I can give comments on the matt can go first.
00:36:34.500 - 00:36:49.704, Speaker D: Just a quick question. So in Ethereum, I think the gas ceiling is 10 million right now in our EDM. I'm not exactly sure how high we're going to allow it to go because.
00:36:49.902 - 00:36:50.650, Speaker C: Of.
00:36:53.500 - 00:37:08.620, Speaker D: The speed of the execution of the computation and then affecting block production because we have these 1 second blocks and then we have other overhead like networking and stuff. So I'm not sure if anyone can further elaborate on the performance.
00:37:09.840 - 00:37:14.110, Speaker B: I think Eugene would be good for that. And you wanted to speak in any case.
00:37:17.700 - 00:38:26.900, Speaker C: Well, right now I think we follow the same limit of 200 terra gas near gas that map to ethereum. So you cannot overspend this limit in one function call. I know you faced an issue that you run out of EVM gas just because of this limit. So I'm not sure how to address it. So if it's an issue, we may consider increasing this limit for EVM. But yeah, we have mapping from near gas to EVM gas and we have this 1000 terra gas limit that we need to respect and it will be just the same for EVM.
00:38:33.410 - 00:38:36.400, Speaker B: All right, and you wanted to ask something as well?
00:38:38.690 - 00:39:57.050, Speaker C: Yeah, so I think Alex didn't cover the proposal regarding the base near token on EVM. So to add the addition there in case we want to eventually issue transactions on EVM that are native to Nier. So EVM will not act as a pre compile, but it will actually act like a regular first party runtime on near. And that will allow us to basically issue transactions that originates from your account on EVM and then just execute it in the same block. So similar to local receipts on native runtime. So you don't need to go from one chart to another to execute it. So for this we'll need to have native near balance in your account in order to compute gas properly.
00:39:57.050 - 00:41:31.522, Speaker C: And my suggestion was to have double balances on your EVM account. So you would have needs for all the EVM logic. So when you attach a value or call functions or pretty much anything that you would expect from EVM will use Ethereum token, but then eventually we can add a pre compile to operate on native near balance, and that will allow us to essentially use both balances and later issue transactions from EVM using near gas. So you don't need to convert NIss to near on the chain or pre compile level or relied on relayers. So you will be able to communicate directly with RPC nodes and issue your transactions. For this you will need to have near balance so it has benefits in the longer term because the onboarding can be done same way as we do right now. You just transfer your ease from Ethereum and start using it through relayer network.
00:41:31.522 - 00:42:33.042, Speaker C: But then once you, for example, want to use local transactions, you convert your east to native near straight on AVM. Let's say there is like modified uniswap that converts to wrap near on EVM and then you can convert this war up near to native near on EVM as well. So you don't need to leave EVM shard in order to convert east to near and same way you can onboard from near to EVM. You have your native near, you dumped it to an EVM account and then you can issue conversion to acquire. So native onboarding will be able to do without relayer network go ahead Celia.
00:42:33.186 - 00:42:34.040, Speaker B: I'm sure.
00:42:38.190 - 00:43:59.640, Speaker E: I'm pretty against actually adding Ethereum transactions into the kind of chain for multiple reasons, but all of our underneath kind of infra that actually deals with transactions will now need to be modified to actually handle this know to route them to specific shards. There's a lot of kind of crap that needs to go into supporting those, so I feel like that premise itself seems a little bit weird to me. Before making adjustments to handle that, we should decide if we ever will actually want this. But specifically on the kind of implementation side of this, I don't think we actually need to have dual balances. Instead, we should just literally have a wrap near ERC 20 that is at a specific address, and this is how generally it works. And so all the stuff can be done pretty much using that. I don't think you need any hard coding inside EVM pretty much for that.
00:44:00.410 - 00:44:32.160, Speaker C: No, I think it's pretty critical that you can issue your own transaction because relying always on relayer network will not work in the longer term, and having separate account is also problematic. People will never want to leave metamask, and if you have the ability to issue transactions from metamask without relayer network, that goes straight to RPC eventually then.
00:44:32.610 - 00:44:48.806, Speaker E: But relayer network and RPC is the same thing. Whoever's serving RPC will just do the relaying as mean the RPC themselves is the first problem in the so you.
00:44:48.828 - 00:45:57.820, Speaker C: Can use your own validator. I'm saying without a relayer network and you don't need to have native near account. So EVM account should be enough regarding the implementation details of this, it's actually not as complicated because we'll still need to eventually do the signed transaction upgrade, which means we'll support a version to version of signed transaction. And just adding another enum there that is EVM function call is fairly simple. As for validation of this, you just do the same validation we do with receipts. Before the block starts, you charge your EVM account for necessary amount of gas, you convert it to a receipt, and then it became a local receipt in the execution. So from implementation perspective, it's not as complicated as you may think.
00:45:58.430 - 00:46:17.386, Speaker E: Routing such no, I don't understand what you're saying, because for metamask to sign a transaction, it needs to be an Ethereum transaction. So our nodes need to be able to accept only Ethereum transaction signed bytes, not signed transaction, not a near signed transaction.
00:46:17.418 - 00:46:27.934, Speaker C: But yeah, that's what I'm saying. We can accept such transaction and just wrap it into signed Ethereum transaction.
00:46:28.062 - 00:46:34.142, Speaker E: But how does you now need to modify the RPC?
00:46:34.206 - 00:46:37.262, Speaker C: Because we'll need to.
00:46:37.416 - 00:46:47.050, Speaker E: So again, I don't want to take over this meeting to discuss this. I'm challenging this assumption. We can take it offline.
00:46:51.970 - 00:47:26.486, Speaker B: Let's talk about that afterwards. It needs considerable depth. There's another question we should also find time to talk about with the both of you guys, certainly soon. Which is the question about how we're going to account for EVM storage, which already came up in the last week. As in we had a situation where the beta net EVM couldn't deploy more contracts given that it didn't have enough funds to handle the storage. I think it had like half a megabyte store at that point. And then we sent it more funds to unblock it.
00:47:26.486 - 00:47:33.420, Speaker B: But we need another solution. Any thoughts to Eugene and Neely on that we can discuss in depth later?
00:47:38.430 - 00:48:12.680, Speaker C: Yeah, I think to just drop this completely, we need to be just careful on how we measure SS store operations. So we need to estimate how much we can abuse the shard by just like filling the blocks with SS store operations and how fast the storage can grow.
00:48:16.410 - 00:48:26.970, Speaker E: So you mentioned the concern was from a chain team that the sync will take longer potentially for the EVM shark.
00:48:27.550 - 00:49:07.990, Speaker C: Well, not longer, just like out of proportion. Yeah, out of the limit that is expected. So let's say we exceed the reasonable amount of near that we pre allocated before we considered then we can never rebalance it, obviously. So it probably will have to be handled separately eventually. And sync needs to be redone to handle EVM shard. If it becomes very popular.
00:49:15.870 - 00:49:21.354, Speaker B: Okay, sounds like we need to have another sync on that as well.
00:49:21.392 - 00:49:39.806, Speaker E: Then afterwards, I think both of the things, let's create a thread first because we keep having those conversations in meetings, but then there's some people who are not in the meeting. So I think actually having collect the facts first and then kind of make decision.
00:49:39.998 - 00:49:46.130, Speaker B: Sure. Okay, where do you guys prefer, should we put this on the forum or just hear in discussions?
00:49:49.220 - 00:49:49.970, Speaker C: Whatever.
00:49:51.620 - 00:50:21.450, Speaker B: Maybe the forum makes sense. It has broader visibility in case somebody in community wants to step in. Okay. All right. Well then I would solicit any other questions and if we have none, we would actually end early and on time. I aim to run these meetings so that we begin and end like clockwork so that everybody can count on that.
00:50:24.780 - 00:51:22.552, Speaker A: I would like to really fast read the questions and answers from our YouTube stream. One person was asking the question about some kind of release dates and next. So the short answer is that the OKRs are giving some sense of it, but we obviously are going to update the roadmap and going to share it publicly. It is going to be there, you will be able to access it. It will always be in the updated state on the same link. And another question was, what's the role of the near token in EVM? And the question to this is that, well, literally a user pays f fees to the relayer who is actually relaying his ethereum transaction to near EVM. And relayer obviously need to send a near transaction, so he need to attach some near to pay for the fees.
00:51:22.552 - 00:51:46.710, Speaker A: So near token is something that is used for paying for the fees on the runtime level. And obviously the gas is burnt. All of the tokens that are paying for the gas, they are burned. So yeah, user pays eth to relayer, relayer pays near to protocol and yeah, everybody's happy.
00:51:48.760 - 00:52:36.950, Speaker B: Okay, good to hear that we are getting some questions from the community. That's very nice. We'll try to be more proactive about announcing these meetings whenever they take place and also posting links to the recording everywhere. Okay, does anybody else have something more to discuss? All right, so for team members, please post your updates. I'm creating here an update section. You can post them just in text form over there. And with that I would say thank you to everybody who participated and watched and see you again next week.
00:52:36.950 - 00:52:41.152, Speaker B: Thanks, bye.
