00:00:06.330 - 00:00:54.030, Speaker A: Okay, so we will talk today about receipts in sharded blockchain, specifically how to make receipts arrive from one blockchain, from one shard chain to another shard chain in exactly one block. So first, let's see. Let's see what the problem is. And I will use nitrate, which is near sharding design, for the example. So in nitrate, there is a main chain which produces blocks every, well, let's say a few seconds. And each of those blocks for every shard contains one or zero. We call them chunks.
00:00:54.030 - 00:01:47.270, Speaker A: So, for example, let's add these exactly four shards, and every block will contain one or zero chunks for each chart. Those chunks, they build on top of the last chunk that was produced for that chart. And so, effectively, those chunks, they kind of represent a short chain, right? So this chunk in the first shard and the third block is building on top of the chunk that was included last time for the same shard. Yeah. Okay. And so, for simplicity of this presentation, we will not look at the main chain blocks. We will just look at the shard chain, at the chunks.
00:01:47.270 - 00:02:50.300, Speaker A: And so the shard chains, they produce the shards, they produce chunks at some time intervals. And so we're going to select time interval zero, time interval one, time interval two, et cetera. So what we want to happen is, in an optimistic case, where two shards do not skip chunks, which in reality is going to be the case most of the time, assuming that the uptime is sufficient of the validators and they're not skipping bits, we want to achieve the following. That if a transaction that touches multiple shards arrives at certain heights, so let's say at height zero in one shard. So that's transaction. Then the receipt of the transaction, which effectively executes the second part of the transaction, arrives to the next shard at the very next block. That sounds like it should be very simple and doable.
00:02:50.300 - 00:03:42.060, Speaker A: But there is a challenge. There is a problem, and the problem is the following. To understand the problem, let's first see how blocks are processed and produced. And what is the actual timeline of producing a block, right? So if this axis is time, and we look at the blocks and what happens then? There's a particular moment in time or other chunks, right? Not blocks. There's a particular moment in time when the chunk for shard zero was produced. And then the question is whether the block producer or chunk producer who produced the chunk validated the transactions in the chunk before sending it out. And so, for example, in bitcoin, if you produce a block, you do validate transactions before you send the block, it has a problem.
00:03:42.060 - 00:04:30.170, Speaker A: It has a problem that if the block producer of chunk zero validated transactions before and computed the new state before sending the chunk, then it means that any other chunk producer, so let's say chunk producer one, they cannot start validating the same chunk before chunk producer of this chunk finished validating it because it wasn't sent before it was validated, right? And so these two events, the chunk producer validating a chunk, and any other recipient in the system, any other validator, for example, chunk producer for the next height validating the chunk, they end up being serialized one after another. But naturally, the chunk producer of shard one cannot produce chunk at height one until they validated the chunk at height zero.
00:04:30.700 - 00:04:35.164, Speaker B: Question. So you're drawing like there are two shards there, right?
00:04:35.362 - 00:05:08.170, Speaker A: That's one shard and two chunk producer. Sorry. So that's chunk producer one, chunk producer for height zero, and chunk producer for height one. But it's within the same shard, right? So if you do validate transactions before you send out the chunk, what ends up happening is you create a chunk, you validate it, then you send it out. The next chunk producer has to receive it, validate it before they can produce the next chunk, and then the same happens again. Right? The zero th chunk producer receives the chunk, validates it before producing the next of their own at height two. Sorry, this is one.
00:05:08.170 - 00:05:49.584, Speaker A: And so therefore the validation happens serialized twice. And validation is actually pretty expensive. It's maybe not the biggest bottleneck in the system, but it does take time and so that ideally should be removed. And so instead of that near and many other blockchains, but near specifically, which is going to be relevant, operates in a different way, where when you produce a chunk, you do very basic validation of transactions. Specifically, you only validate that the transaction issuer has money to cover the gas price, accumulates transactions in a chunk, and immediately broadcasts it. And that chunk is considered valid even if it has invalid transaction. Invalid transaction just charges the gas but remains in the chunk.
00:05:49.712 - 00:05:50.100, Speaker C: Right.
00:05:50.170 - 00:06:10.180, Speaker A: And why it is important? It is important because the chunk producer, when they broadcast the chunk, they don't know the post state route. They don't know the state route as of after applying the transactions. And so therefore, that post state route cannot be stored in the chunk. And that also means that the receipts that are going to be produced as a result of applying this chunk, they are not included in the chunk as well.
00:06:10.270 - 00:06:10.860, Speaker C: Right?
00:06:11.010 - 00:06:16.076, Speaker A: So receipts will only be known when everybody else receives the chunk and processes it.
00:06:16.178 - 00:06:16.830, Speaker C: Right?
00:06:18.080 - 00:06:54.088, Speaker A: And so this is where the challenge happens is that by the time now, let's consider another shard, right? So there's another chunk producer, let's call them chunk producer two, and they're producing in a different chunk shard. So, so that. So this is shard zero. Let's call it s zero. This is s one, also s zero, and this is shard one. So when they receive the chunk, or like some information about chunk that was produced for the shard zero, they do not know yet. They don't know the receipts, but also they cannot apply it.
00:06:54.088 - 00:07:28.724, Speaker A: Why? Because they don't see the full shard, the full chunk, in a sense that if there is 100 shards, it is invisible for every chunk producer in every shard to send the full chunk to every other shard, right? So effectively, the chunk producer in shard one will not see the full chunk from shard zero. They cannot see the full chunk from every shard. So all that they receive is they receive some header and some information with it. And so in particular, they cannot receive the receipts from this shard. But also they cannot reproduce the receipts because they cannot apply the chunk. They don't see the full chunk. Go ahead.
00:07:28.762 - 00:07:31.684, Speaker B: They don't even know whether the chunk is relevant to them, right?
00:07:31.802 - 00:08:02.568, Speaker A: They don't even know if it will have any. They do know if the chunk is relevant when the block is produced, like when the main chain block is produced. So this is the main chain block, another main chain block. By the time they receive the main chain block, they know all the chunks which are included. So at least they know that the chunk is included on the main chain. And assuming heavy load, you probably expect most of the short sending receipts to most of the shards. So the no chunk is included.
00:08:02.568 - 00:08:10.080, Speaker A: They sort of know that probably there are receipts coming from that chunk, but they don't know what the receipts are.
00:08:10.150 - 00:08:10.432, Speaker C: Right?
00:08:10.486 - 00:08:51.820, Speaker A: And so coming back to this picture, now that we discussed that problem, so what happens is in this chart, whomever is going to be producing this chunk by the time they produce chunk, they have no way of knowing the receipts as of applying this chunk, right? And that's the biggest problem. There is no way for us to do that. If we did go with the approach where the chunk is fully applied before it is sent, that problem would be solved because then the chunk producer would have known the receipts as of applying the chunk. And so whatever message they're sending to the other shard, that message would just include the receipts. But again, that becomes significantly slower.
00:08:52.500 - 00:08:53.200, Speaker C: Right.
00:08:53.350 - 00:09:37.950, Speaker A: Okay, so what can we do? We definitely cannot without some magic, as we just discussed, we definitely cannot know the receipts by the time we're creating the chunk. But also we don't need to know the receipts by the time we're creating the chunk. We need to know the receipts by the time we're executing it, right? So in reality, and so let's say this chunk produces, produces chunk one for the short one they don't need. And so later down the road, someone else is applying it. In reality, we don't need to know receipts. The receipts. At this point, when we create the chunk, we do need to know the receipts by the time we apply the chunk, right? And so does make sense.
00:09:38.960 - 00:09:39.708, Speaker C: Cool.
00:09:39.874 - 00:10:29.224, Speaker A: And so the way it is done today is the following. When a chunk producer, so in this case, one of the chunk producers of shard zero produces the chunk, we already have to distribute small parts of the chunk to every block producer in every shard. This is how data availability in nature works, right? So when they do that, they also actually, let's use one as an example. One is a better example. So by the time chunk producer created the chunk one, the very last thing they did before that is they applied chunk zero. So they received chunk zero, they had the state, they applied it, they know the new post state route, and they know all the new receipts. So when they create a new chunk chunk at height one, they do the following.
00:10:29.224 - 00:11:27.756, Speaker A: First of all, the header of this chunk will contain prestate root, which is the post state root for the previous chunk, but it will also include the receipt merkel root of all the receipts produced as of after applying zero. So we don't know yet the receipts which will be produced after applying one. But we do know receipts that will produce after applying zero. So there is a Merkel route of all those receipts. And also those receipts are sorted by the destination shard id. And so you can prove any subset of those receipts going to a single shard, and a single miracle proof. And so when they cut this little chunk into small pieces to send to every validator for data availability, together with those little pieces, they also send all the receipts relevant to the particular block producer for their shard, right? So when this little thingy goes to this chunk producer in the shard one, all the receipts that go from shard zero to shard one, as of after applying this chunk, they will be included.
00:11:27.788 - 00:11:38.404, Speaker B: In the message, why drawing arrow like this? Shouldn't it be going to chunk number two in shard or like forward?
00:11:38.522 - 00:11:49.092, Speaker A: Yes, I mean, you're drawing, yeah, it will not get included into this chunk, right? Because this chunk and this chunk, they produce concurrent.
00:11:49.156 - 00:11:50.872, Speaker C: Yes, right, so you're right.
00:11:50.926 - 00:11:53.384, Speaker A: So it goes like in time, it will land around here.
00:11:53.582 - 00:11:54.330, Speaker C: Right?
00:11:55.500 - 00:12:24.556, Speaker A: Now what's important is that when you receive a block, a particular block, and you see chunk headers in it, that block is considered orphaned. Until for every shard, and for every chunk included, you either have the full chunk, if that's some shard, you validate, or you have this little one part. If it's not a shard, you validate. And there are protections in place which protect against lazy behavior. So you cannot pretend you know it. If you pretend you know it, there's a good chance you will be slashed. There is a protection in place, so you will not an orphan the block.
00:12:24.556 - 00:12:44.036, Speaker A: You will not consider the block valid until you have those little one parts for every chunk that is included. And that also means that you have all the receipts for every shard. And those receipts are provable because there's a Merkel route here, right in the header. That header is in the block, and you have the merkel proof against that receipt.
00:12:44.068 - 00:12:47.736, Speaker B: With every part, you sent all the.
00:12:47.758 - 00:12:53.230, Speaker A: Relevant receipts for the destination person with the part that goes to that person. Yes.
00:12:53.920 - 00:12:54.428, Speaker C: Right.
00:12:54.514 - 00:13:15.410, Speaker A: And so now by the time I need to apply chunk one, I would only apply chunk one if I receive the block which has chunk one, right? So if I draw these chunks, well, unfortunately I don't use the shard id, right, so it's s zero, s zero, s zero. And this is all s one.
00:13:17.380 - 00:13:17.888, Speaker C: Right?
00:13:17.974 - 00:13:52.552, Speaker A: So this s zero one, and s one one, right? So this is the chunk one for shard zero. This is chunk one. For shard one. I will only apply this chunk when I process this block. I only process this block if it is not an orphan. It is only not an orphan if I have one part for every chunk included, including the chunk, chunk one for shard zero. And so those, by the time I'm applying this chunk, I don't know the receipt, right, so we guarantee that by the time you're applying chunk at height one, you have all the receipts from all the chunks that are included at the same height.
00:13:52.616 - 00:14:00.928, Speaker B: Can you repeat again? We apply block when we either have a full chunk for each shard or for some of them, we have only like one part, right?
00:14:01.014 - 00:14:36.472, Speaker A: So every block producer, there's a subset of shards they care about. That's the subset of shards that they validate, but there's another subset of shards way larger that they don't validate. And so you need the full chunk for every shard you fully validate, and you need just one part with the receipts for the shards that you do not validate. Either way, you will have the receipt. If you have one part, that receipt was sent to you with the Merkel proof. If you have the full chunk and you validate the shard, then naturally you applied the previous chunk. So you have the receipts locally because you computed them, right? So either way, you have all the receipts.
00:14:36.472 - 00:15:17.704, Speaker A: And so that guarantees a. That gives you one block cross shard transactions, right? Oops, sorry, this is zero, because the receipt, which was created as a result of applying this chunk, will be processed already as of the time this chunk is applied. So there is exactly one block between the first and the second hope of the transaction. And the same applies. If it sends a further crosshart transaction, it will also be applied in the very next block. And moreover, we guarantee that receipts don't get lost. This is another problem that many blockchains face today, that the sharded blockchains is that they don't have any guarantee that the receipts will be applied here.
00:15:17.704 - 00:15:47.260, Speaker A: If the receipt is not sent, if it's not part of the Merkel proof, that's a slashable behavior, because every other participant in the same shard chain, they will also apply this chunk, they will also get the receipts. They will also compute the merkel proof. If the merkel proof doesn't match the merkel proof included in the header, that's easily provable cryptographically, and that's a slashable behavior. So everybody will arrive to the same proof, every recipient and every other shard. They will check against the proof. They will know they have all the receipts, so receipts cannot get lost. Receipts have guaranteed delivery.
00:15:47.260 - 00:16:26.450, Speaker A: And the only last problem, which we're not going to discuss very deeply today, is that there is a problem that if all the shards send receipts to a single shard, that will spam the shard, right? So we're not going to go very deep into that. But this is also partially solved, because you can accumulate the receipts, but you don't have to apply all of them at once. You can put them into the queue, and then you just process the first 100 receipts that got into the queue the earliest. And then the only problem is how you prevent the queue from growing indefinitely. And I think the only way to do that is to fail transactions if the queue is full. So if by the time you apply the chunk, the destination queue for shard one is full, you will fail any transaction that tries to go to shard one.
00:16:27.540 - 00:16:28.290, Speaker C: Cool.
00:16:28.900 - 00:16:35.910, Speaker A: So that covers the receipts. You have more questions? Yes. Awesome.
00:16:37.880 - 00:16:55.332, Speaker B: This guarantee, right? I mean, that basically allows you to say that receipts are not lost when you produce block. When we either have the full chance that we care about, or we have one part of whatever we not care about. But it includes receipts.
00:16:55.396 - 00:16:56.280, Speaker A: Yes, that's correct.
00:16:56.350 - 00:17:26.264, Speaker B: Supposed to be like, this is what allows sharding. Because you care about only small of the shards. Right. And everything else, you kind of don't care. So it's like a little bit of the overhead. So I have a question when it's actually a little bit of the overhead. Because if we have a system where we have many shards and most of the transactions are crosshard transactions, let's say we have financial system, people are just sending money between each other, like 100 shards.
00:17:26.332 - 00:17:26.612, Speaker C: Right.
00:17:26.666 - 00:17:38.896, Speaker B: I mean, most of the transactions are going to be cross shard transactions, which means the content of the block, of the chunk is going to be half receipts, half transactions that just arrived.
00:17:39.008 - 00:17:39.428, Speaker C: Right.
00:17:39.514 - 00:17:50.684, Speaker A: The question is, do all of those receipts go to the same shard? Because this one part, it doesn't contain all the receipts. It only contains receipts which go to the shards that the receiving person cares about.
00:17:50.802 - 00:18:06.584, Speaker B: Right, I see. So basically, in this system, then it would be like, if I care about one shard, then on average, all the receipts accumulated from all one part that I do not care about are probably going to be on the same volume as transactions.
00:18:06.632 - 00:18:36.010, Speaker A: Yes. So if the system is not skewed, if it's well balanced, then you will be receiving as many receipts as you receive transactions, which is definitely viable. It is still a problem, though, that if you're in a short that is super popular, you might be getting way too many receipts that can be solved in many ways that we did not discuss. Like, you can limit how many receipts can go to a particular short to some constant, like three x, something like one over number of shards multiplied by three. Something like that.
00:18:36.380 - 00:18:37.850, Speaker C: Yeah. Cool.
00:18:38.780 - 00:18:44.420, Speaker A: More questions? No. Okay, so that covers our first lunch series. Thanks, everyone, for listening.
