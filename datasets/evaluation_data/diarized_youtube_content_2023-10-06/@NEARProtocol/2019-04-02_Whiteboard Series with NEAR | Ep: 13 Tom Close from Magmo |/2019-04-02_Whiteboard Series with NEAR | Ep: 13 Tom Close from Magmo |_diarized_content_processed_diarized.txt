00:00:03.290 - 00:00:11.406, Speaker A: Hi, everyone. This is Alex from near. And with me today is Tom close from Magmo. We will talk a lot about state channels today. Tom, would you like to introduce yourself?
00:00:11.508 - 00:00:22.622, Speaker B: Yeah, so, I'm Tom close. I am the founder and CEO of Magmo. Magmo is a state channel research and development team. And that's what we're going to be talking about today.
00:00:22.676 - 00:00:28.440, Speaker A: Cool. Yeah. Let's do high level overview, I guess. Where should I start, what a state channel is.
00:00:29.930 - 00:01:12.274, Speaker B: How about I start by giving, I guess, like a toy example of a state channel interaction? So, as you're probably aware, state channels are an interplay between on chain stuff and off chain behavior. So, let's start. Let's suppose we have Alice and Bob. Now, we're going to suppose that Alice and Bob want to do a lot of transactions with each other. And these transactions are going to be done very quickly, and maybe they're going to be very small in value. So, basically, it wouldn't make sense to put all of these transactions on the blockchain. So, how do Alice and Bob do this in a state channel? So I'm going to be doing something like this.
00:01:12.274 - 00:01:35.450, Speaker B: So they start off by exchanging a message with each other. So these messages are going to be numbered. So this is going to be message zero. And Alice is going to say, five and Bob. Five. Let me explain what this means in a second. Alice sends that to Bob, and it's signed by Alice.
00:01:35.450 - 00:01:52.046, Speaker B: I'm just going to save. Anything that Alice sends to Bob is signed by Alice. And anything Bob signs to Alice is signed by Bob. Okay, so this is like an opening statement. So what this is saying is, we are going to start a state channel. Alice is going to put in five. Bob is going to put in five.
00:01:52.046 - 00:02:25.446, Speaker B: And then Bob will echo that back. So he then sends agreement number one, Alice. Five bob. Five. Okay, so at this point, they're both holding a signed agreement that they've signed and a signed agreement that the other person has signed, saying that they're going to open this state channel with these conditions. So I'm going to use red for on chain stuff. So at this point, they're in a safe state to deposit some money on chain.
00:02:25.446 - 00:02:47.650, Speaker B: And I'll go through that a little bit more. Why? That's a safe state. Later. So there is this contract on chain. We call it the adjudicator. So this contract is going to hold their funds for the duration of the state channel. And it's also going to, I guess, implement the rules of the protocol about how those funds can be released.
00:02:47.650 - 00:03:28.458, Speaker B: So in this situation, what happens first is Alice deposits five. The other thing is, I'm just going to talk in terms of abstract coins throughout the whole of this. So we can do this with different ERC, 20 tokens eth or whatever, but for the whole of this discussion, we'll just talk in terms of coins because that's required. So Alice puts in five and then Bob can also put in five. So there's now ten coins in the adjudicator, and it's going to be split according to the outcome of their state channel. So now Alice and Bob can get going, like with their interaction. So say Alice wants to send one coin to Bob.
00:03:28.458 - 00:03:47.720, Speaker B: She does an update, she decrements her balance, increases Bob's balance, and then Bob sends something back and so on.
00:03:49.130 - 00:03:50.870, Speaker A: Bob always needs to confirm.
00:03:52.010 - 00:03:58.540, Speaker B: Not quite, but we can get into that later. So for the purpose of this toy example, I'm going to suppose that Bob always needs to.
00:04:03.070 - 00:04:11.546, Speaker A: So let's go through a few corner cases. What happens if, first of all, does it matter in which order they put money into the contract?
00:04:11.658 - 00:04:12.302, Speaker B: Yes, it does.
00:04:12.356 - 00:04:13.806, Speaker A: So it has to be Alice who.
00:04:13.828 - 00:04:48.202, Speaker B: Sent the initial mean. So probably good to get into that later, because you'll see exactly how that works when I explain this. I guess to give a little bit of a sneak peek of that. Now what this actually means is of the money in the contract. First Alice gets five, then Bob gets five. So this list here, this thing here actually encodes a precedence order. I guess the other thing is, I should probably say is some of this is like general state channel stuff.
00:04:48.202 - 00:05:28.866, Speaker B: Some of this is specific to nitro protocol, which is our protocol for doing state channel networks. So not all networks have this precedence thing. The reason we have it is it allows you to just store ten here in other state channel frameworks. You'll see in the adjudicator things like. So they'll track the initial balances and stuff. But I'm just going to stick with doing it this way. It has a couple of other nice properties which get into Alice has to deposit first.
00:05:28.866 - 00:06:12.660, Speaker B: Bob can only deposit when he sees Alice has deposited, otherwise it's not safe. Alice could steal his money. And there are other things you can do around that to avoid the time delay, which I can talk about later as well. Okay, so they do this many, many times. They're limited only by the speed in which they can send messages to each other and sign them, say they finish off in state. I don't know, like what should we say, 98, where Alice now has nine and Bob has one. Now they decide that they want to stop the state channel there.
00:06:12.660 - 00:06:49.390, Speaker B: What do they do? So they take the final state, and they present that to the adjudicator. So that goes into some, like, slot on the adjudicator. And it's like 98, a nine, b one. And it starts a timer. So this is like a pending thing. The reason this is pending is because it gives the other person a chance to challenge with a higher state. So you think about it like, this state is not favorable to Bob.
00:06:49.390 - 00:06:57.540, Speaker B: Bob would prefer this state. So, like, Bob could try and put this state in there. If he did, Alice would have some time to present the 98.
00:06:59.510 - 00:07:00.066, Speaker A: Before the.
00:07:00.088 - 00:07:18.434, Speaker B: State was, I guess. Let me get back on track. I'm jumping ahead. So in the happy case, and you can also optimize this, which I'll talk about later, too. Alice puts this up here. There is no higher state. And so at some point, it will time out.
00:07:18.434 - 00:07:51.890, Speaker B: When it times out, then the adjudicator sends the money back. So it sends nine to Alice, one to Bob. This becomes zero. And this is like, done. So that's the happy case. The reason the timeout there, as I was saying before, is to protect against one person cheating, because obviously the chain doesn't know how many states there are off chain, how many of these commitments they've sent back and forwards. So, like, Bob here could be like, oh, shit, I've only got one coin here, but I've got six here.
00:07:51.890 - 00:08:07.174, Speaker B: So maybe I could try and check out in this state. So he would put this in the adjudicator, and then Alice would have the timeout to respond with this state and say, actually, there's a later state, and that would cancel the challenge. And then they could continue.
00:08:07.372 - 00:08:10.762, Speaker A: And if Alice challenges, does she get nine or she gets everything.
00:08:10.896 - 00:08:26.862, Speaker B: So the way it works in our stuff is that Alice will get nine. In fact, it's not even that. Alice will cancel the challenge, and then Alice can put this in the adjudicator separately. So basically, she's just, like, refuting Bob's claim that this was the latest state.
00:08:26.916 - 00:08:30.080, Speaker A: But the contract will not allow Bob to exit with this again, right?
00:08:30.850 - 00:09:01.818, Speaker B: Probably not. We're now into optimization details. So do you store the highest number that's been challenged or, like, the highest number you've seen in the adjudicator? Probably yes, because that allows you to get rid of some states and avoid some. But, yeah, you don't have to. You could live in a world where the adjudicator doesn't do that. And every time Bob presents this, Alice presents that, and they're just locked in this game. So you probably would want that optimization, but it's not part of the protocol, as it were.
00:09:01.904 - 00:09:02.540, Speaker A: Cool.
00:09:04.190 - 00:09:29.170, Speaker B: So this is the basic pattern that you see with state channels and with payment channels. You lock up some funds on chain, you exchange some signed agreements off chain, and then at the end, there's some challenge period, and after the challenge period, you split the funds according to the final outcome of the channel.
00:09:29.320 - 00:09:31.282, Speaker A: And Bob can also initiate messages, right?
00:09:31.336 - 00:09:31.554, Speaker B: Yes.
00:09:31.592 - 00:09:34.686, Speaker A: It's not like every even message has to come from Alice.
00:09:34.878 - 00:10:20.478, Speaker B: So it actually is like that. I guess we're getting into the details now a bit, so maybe that would be a good thing to do. So, I guess one of the things I wanted to do was try and split the state channel into two parts, basically the off chain part, which I think of as getting to an outcome. So, like here, Alice and Bob got to this outcome by exchanging messages off chain. And then the second part is like, actually withdrawing the funds. So we try and separate, at least in nitro protocol, we try and separate the funding step. Everything to do with depositing money and claiming money from the operation step getting to an outcome.
00:10:20.478 - 00:10:41.254, Speaker B: And the reason we do that is because that allows us to swap out the funding. So, a weakness of the thing I've presented here so far is that this operation started this operation.
00:10:41.302 - 00:10:42.358, Speaker A: Let's start with the weakness.
00:10:42.454 - 00:11:41.358, Speaker B: Yeah, the weakness. So, the weakness of this, obviously, is, okay, Alice and Bob got to do 100 transactions off chain, but they had to start this operation with each doing an on chain transaction, and they have to finish it with an on chain transaction. And this is actually kind of quite an unusual use case. If you think about the transactions you do, every day, you do a couple of transactions with a wide number of people, rather than hundreds transactions with one person. And so this currently has a big limitation in terms of a scalability solution. But as I'll show you later, we can actually fund some channels with other channels if we separate out the funding step from the operations step. But I wanted to probably go over the operations step first and answer some of your questions about, do they always have to reply to each other? Does Bob always have to confirm that stuff? If you're happy starting?
00:11:41.444 - 00:11:42.640, Speaker A: Sure. Yeah, let's do.
00:11:43.170 - 00:11:43.920, Speaker B: Cool.
00:11:45.970 - 00:11:56.100, Speaker A: So, yeah, so the first question is. So you're saying that every even message comes from Ellis and every oath comes from Bob, right? So what if Bob wants to send money to Ellis, but it's not his turn?
00:11:56.470 - 00:12:31.310, Speaker B: So there are a couple of ways around that. Let me first go into the state format, and then you can kind of begin to see how some of this stuff works for yourself. Because that question of, like, I mean, I guess to answer that question a little bit now, in some senses, it doesn't matter if Bob wants to send money to Alice, this is like off chain collaborative behavior. So Bob wants to send money to Alice. He's like, hey, Alice, send me a message so it's my turn and I can send money to you. So you could do things like that. But there are also actually other ways you can optimize that as well, within the rules.
00:12:31.310 - 00:13:11.994, Speaker B: So let me start by digging into this state format, because this is definitely a cartoon version. You can't see everything that's happening from this version. So the state format is like pretty simple in some ways. So let me just write it out. So you have participants, which is an array of addresses. So this, in this case, this would be like, I'm going to run out of space. Can I squidge this up a bit? Because I'd like to keep that.
00:13:11.994 - 00:13:12.970, Speaker B: Can I borrow that?
00:13:13.040 - 00:13:13.660, Speaker A: Sure.
00:13:14.190 - 00:13:55.634, Speaker B: Can I borrow this thing? Okay. Thank you. Sorry, I was just going to. So you have this pens. See how part, which is an array of addresses. And this would just be like Alice and Bob. Then we have a nonce, which is a uint.
00:13:55.634 - 00:13:57.558, Speaker B: And this could just be like one.
00:13:57.644 - 00:13:58.710, Speaker A: That's this number, right?
00:13:58.780 - 00:14:20.590, Speaker B: No, this is a number that is used to identify the channel in a way that I can explain in a second. So, like, Alice and Bob could have multiple channels open. This is a number they use to distinguish channel number one from channel number two. This puts a requirement on Alice and Bob. They kind of have to remember how many channels they've had open between each other so that they don't repeat its nonce.
00:14:21.730 - 00:14:25.022, Speaker A: But do they come up with the nonce or the contract assigns them?
00:14:25.076 - 00:15:00.842, Speaker B: They come up with the nonce and it's in their interest. Like, obviously they could open a new channel with the same nonce, but then states from the previous channel will apply to the new channel and nobody's going to know what the hell's going on. So it's in their interest to jointly choose this number and each of them can say, I'm not using that number. Nobody can be forced into using a number they don't want. Got the nonce, then we've got the next thing, which is the turn number, also un. And that's this thing. So, like, we start with zero.
00:15:00.842 - 00:15:03.630, Speaker B: That's the thing that's going to label the states as we go along.
00:15:03.780 - 00:15:08.560, Speaker A: And this is all the state of a particular channel from perspective of a particular person.
00:15:10.370 - 00:15:48.060, Speaker B: What I'm writing out here is a message format. That's a message that will be sent from one to the other person. So you can think of it as like the message format, or you can think of it as like the state. You can think of this as like we're transitioning from this state to this state to this state to this state. We transition from state. When a message is sent, turn number what should I do next? Is final bool false. So this is something I haven't spoken about yet.
00:15:48.060 - 00:16:27.190, Speaker B: As you'll see later, the purpose of this is to allow collaborative closes without the timeout. So this means that I've said here that they go here, they have to wait. This is a way that they can both sign off and avoid waiting. But you have to be a little bit careful with this. Once you've signed one of these messages, there's no going back. The channel is kind of over, obviously, because then challenges are skipped. Okay, then you have the default outcome.
00:16:27.190 - 00:17:14.230, Speaker B: And this thing is weird. We're going to start off with this being just like a mapping of addresses to uns, and it's like an array of those. Basically this is what this default outcome says. And I guess this is going to be like a five, b five in our example. So this is like saying like if the channel was to stop at this point, who would get what? And this format, this is the format for a certain type of channel. When you come to building state channel networks, as far as I can tell, you need a different format. You need to add one more format and a new set of rules.
00:17:14.230 - 00:17:58.886, Speaker B: And I'm not entirely sure that's true, but it seems to be true from everything I've done that this isn't quite enough to do everything. Default outcome. Okay, then we've got an app definition, which is an address, and then we have app data, which is bytes, and then finish off with signature, which is whatever signatures are like uint, eight bytes, 32. This is a bytes, 32. So this is a classic VRS type of thing. And this is the signature of the person who's signing it.
00:17:58.988 - 00:18:03.942, Speaker A: And so if it's just, let's say it's just payment channels, then we don't need app definition, app data.
00:18:03.996 - 00:18:14.802, Speaker B: Right, because the default outcome is. Yeah, so the default outcome is almost enough. But you do need some rules about how you transition from default outcomes to another default outcome.
00:18:14.866 - 00:18:18.200, Speaker A: But if it's a payment channel. Those rules could be assumed, right?
00:18:18.730 - 00:19:01.350, Speaker B: Yes, they could, but the way we do it is they're not sure. So, like, for a payment channel, there are different ways you can code up a payment channel, which is what I was coming to here a little bit. So one rule for a payment channel might be on my turn, I can only decrease my balance and increase your balance. And that would mean that I can send you stuff without you confirming back to me, but it would mean that I can't unilaterally steal your money. So that would be a sensible definition for a payment channel. Another thing would be a sort of like consensus. There's this thing which will come onto later, which is like the consensus game where I propose a new outcome and you accept the new outcome, and then the outcome moves into this slot.
00:19:01.350 - 00:19:14.010, Speaker B: So there is a little bit of logic there. It's not quite as simple. You have to think about what transitions are you going to allow and what transitions are you not going to allow. And that's part of building these apps.
00:19:14.090 - 00:19:20.590, Speaker A: And so default outcome, that's the outcome if later down the road, I'm trying to exit.
00:19:21.010 - 00:20:07.374, Speaker B: Yeah. So one of the things about payment channels is, and state channels is a little bit risky, right? Like, you've locked up some funds up here, and the way you unlock those funds is by doing some stuff off chain with an opponent or a partner, maybe an opponent, I don't know. Let's talk about it as an opponent, because it is a slightly adversarial relationship. So at any point, my opponent could stop. So what happens if Bob just stops here? Maybe Bob doesn't want to play anymore. Maybe Bob's in a position where it's not advantageous to him to continue. Maybe Bob has computers crashed and he's lost his signing keys and he can't continue.
00:20:07.374 - 00:20:42.730, Speaker B: Maybe Bob died. I don't know. For every them, some of them malicious, some of them not malicious, Bob might not be able to sign another update. And at that point, there has to be a way to get this money back. And the way that that works is exactly how we've seen already. So Alice can launch a challenge and then it can split the funds. But that means that each state needs to have a concept of, like, if we stopped at this point in time, what would be the fair split of the funds? And we write that into the state.
00:20:42.730 - 00:20:48.746, Speaker B: And designing how this moves is an important part of designing a state channel and application.
00:20:48.928 - 00:20:59.290, Speaker A: And so even if it's general estate channel, so it's not a payment channel, right. Yeah. The resolution on the chain is still just some sort of money split.
00:20:59.450 - 00:21:00.160, Speaker B: Yes.
00:21:00.690 - 00:21:09.166, Speaker A: So if it's general estate channel, it's only the communication that is now arbitrary. But it's not like we can arbitrarily change some state of some contract.
00:21:09.278 - 00:22:03.266, Speaker B: Exactly. This is the only state. The only thing that happens on chain is these things are stored on there. And I guess I ought to say that I'm not convinced whether this restriction that a state channel always involves a fixed set of assets and the outcome is always splitting those assets, is generally true. I know there are some tricks you can play where you can trade off chain, the ability to set a value in a contract on chain or something. And in nitro protocol, we rule out those things. Whereas one of the aims of counterfactual was to do those things, to be able to do these more general things, to be able to basically off chain trade the right to change the chain in some arbitrary way.
00:22:03.266 - 00:22:39.230, Speaker B: But, yeah, we just decided to simplify that down. I think there's a wider philosophical question there about whether those things actually make sense, which I haven't been able to convince myself of one way or the other. Anyway, back to this state format. So this is the state. So let's suppose instead of this, let's actually look at an example of tictactoe. So here I'm going to have. So this represents the address of some contract on chain.
00:22:39.230 - 00:23:08.042, Speaker B: That's a library that defines the rules for tictactoe. We can talk about that in a minute. And then this app data is going to be the format that you need for tic tac toe. So it's probably going to be like a steak. And maybe we're going to pay for two coins, and it's going to be the current state of the board, maybe. And then the signature is just like Alice's signature or Bob's signature. So this is it.
00:23:08.042 - 00:23:09.770, Speaker B: This is the state format.
00:23:10.190 - 00:23:23.070, Speaker A: And so now when we do communication. So let's say Ellis, right? So we have Ellis here, Bob here. So I guess they still initiate the same way. Right? They're locking money.
00:23:23.220 - 00:23:23.920, Speaker B: Yeah.
00:23:26.690 - 00:23:48.562, Speaker A: And then he responds with the same. So at this point, let's say that was successfully settled on chain. Not settled, but started. Yeah. Set up on chain. Now, at this point, Ellie says, okay, you know, I'm going to go here. Does Bob first confirm that that happened, or Bob can immediately respond.
00:23:48.626 - 00:24:13.920, Speaker B: Bob can immediately respond. And this is like complete dependent on how this contract is written. But it makes sense. And that's nice, because you don't have to deal with the case. Like what happens if Alice moves there and Bob doesn't confirm it? And basically the moment Alice has moved, Alice has moved. So let me talk about.
00:24:15.330 - 00:24:22.960, Speaker A: But I can only exit with the message that was sent to me, right? So Bob, to exit, has to send Alice's message.
00:24:24.530 - 00:25:05.366, Speaker B: Yes and no. So anyone could provide any of these messages. If I exit with my message, then there's always a chance that you will provide another message, like you have the power to do the next message. But there are interesting games you can play with providing other people's messages and stuff. And it also depends how you kind of think about these challenges as well. So this thing that I'm explaining here with nitro protocol, Nitro is an extension of force move, which is basically this framework for building these little games. Like this set of rules that I'm about to describe you are basically force move rules.
00:25:05.366 - 00:25:41.802, Speaker B: And in force move, you think about the challenge as forcing someone to move instead of saying that the only thing that can happen in these channels that can go wrong is that you fail to move. And then the idea is like, I launched this challenge on chain, I'm forcing you to move. If you don't move, the game is over with the default outcome. And that's how all these games kind of work. And I think the specific mechanics here are specific to nitro protocol and force move. But the overall pattern is the same in any state channel application. I think has to be the same in any state channel application.
00:25:41.802 - 00:26:01.406, Speaker B: You always need an out. If someone stops responding, you always need that out. Really needs to provide the data you need as well. So the nice thing here is like, by providing the next state, I'm providing you exactly the data that I would have given to you off chain so that you can continue. I'm jumping around a bit.
00:26:01.588 - 00:26:27.538, Speaker A: What are you saying? So let's say that we're playing tic tac toe, right? And so Alice made a move, Bob made a move, and then Alice disappeared. So you're saying at this point, Bob, all the bob can do is to force Alice to make a move by on chain. But let's say that it will take like thousand more moves before the game is over. So that means 1000 transactions on chain.
00:26:27.634 - 00:26:59.010, Speaker B: No. So the way that would work is. So you're getting into the griefing scenario now? I think so the way this could work is Bob puts this on chain. Either Alice responds or she doesn't. If she doesn't respond, the game is over and Bob gets the default outcome. At that point which hopefully the game designer has designed so that Bob doesn't lose out if Alice goes away. If Alice does respond, Alice responds by putting the next move on chain.
00:26:59.010 - 00:27:27.786, Speaker B: So then Alice and Bob can continue off chain. So by responding on chain, Alice has given Bob the exact information they need to continue collaboratively off chain if they want. Of course, Alice can continue to be an asshole and challenge Bob every single time, and we can deal with that scenario later. There are a few things you can do there, but that is just kind of like a limitation of state channels. Like, basically your worst case scenario is you play everything out on chain, and there's not really a lot of getting away from that.
00:27:27.888 - 00:27:34.830, Speaker A: As an example of tic tac toe, what would be like at every particular moment? What would be the default outcome? Which is meaningful?
00:27:40.290 - 00:28:16.182, Speaker B: Right? What would be the best thing? Let me answer your question quickly. So, in Tictactoe, one way you could design it is so that failing to move is like defaulting the game, resigning from the game, the other person gets the entire stake. That would be like, one default outcome. And so what that would look like is, as Alice and Bob are sending them across, like, Alice sets the default outcome to be four six. Sorry, six four. So, like, she wins if Bob doesn't respond. Bob sets it to be four six when he responds.
00:28:16.182 - 00:28:48.166, Speaker B: And how these change are specified by the rules of the game. So maybe I should go into that a bit now, because obviously a lot of this is about what are the valid updates between here and here? And then that bit all feeds into how you can update things on chain and the on chain methods you can call and how that all sort of works, maybe. Can the camera see down here?
00:28:48.268 - 00:28:48.920, Speaker A: Sure.
00:28:49.530 - 00:29:47.360, Speaker B: Can it see there? Anyway. Okay, cool. All right, here then. So what determines valid transition? The way the framework does this is there's a single function called valid transition, and it takes a pair of states. And this says, like, is a, to be a valid transition, obviously. And what are the rules for something being a valid transition? So there are some things that have to stay the same. So the participants, the nonce, and the app definition have to be constant.
00:29:47.360 - 00:30:24.700, Speaker B: So like a dot participants equals b dot participants, et cetera. We need that. B dot, turn, num equals a dot, turn, num plus one. So the turn number must increase. We need that. A mover equals a signer. Okay, so what does that mean? So it has to be signed by the person who's making the move.
00:30:24.700 - 00:31:05.290, Speaker B: How do you calculate the person that's making the move? So for that, we specify that people must take turns so that a dot mover is equal to a dot participants. And we take the index of the turn number mod n, where n is the number of people in the channel. So this says that alice signs all the even ones, bob signs all the OD ones. This also extends, everything I'm doing here extends to n players and participant channels. If there are three of us, we just go around in a three.
00:31:06.060 - 00:31:09.496, Speaker A: So do we enforce that a is final is false?
00:31:09.688 - 00:31:32.710, Speaker B: Not yet. I'm going to. Come on. I'm still going. Sure. So then same for b. What else do I need? So then I think we are into the bits where we look at different sort of stages of the channel.
00:31:32.710 - 00:32:17.670, Speaker B: So if the turn number. No, let me. Thanks. Okay. If b is final, so transitions into is final state can't change the default outcome. And I haven't talked about its final yet, but we can come on to that in a minute. It's basically the collaborative close.
00:32:17.670 - 00:32:47.368, Speaker B: Default outcome is the same. So I think that's all you need. Else. So this is like the conclusion step of the channel. Like, this is the end game of the channel is this little bit here. Else, if the turn number is smaller than or equal to B's turn number is smaller than or equal to two n. This is like a setup phase.
00:32:47.368 - 00:33:20.010, Speaker B: And I'll talk about why it's two n. But basically, like, the first two steps of the channel are set up. And that's weird, because in that cartoon version, I didn't show you two n. I only showed you one n. But you actually need an echoing back after that, I think. So a default outcome equals B default outcome, a dot. The app data can't change in that thing either.
00:33:20.010 - 00:33:39.324, Speaker B: And we also need that. We can't go back. So I also need not a is final. So once you've gone from a final step, you can't transition back into another.
00:33:39.362 - 00:33:41.840, Speaker A: One in the first two n steps.
00:33:42.900 - 00:34:27.644, Speaker B: So, in fact, I'm going to have that condition in the final else as well, basically. Like, yeah, I mean, maybe there's a better way to write this. And then otherwise, what we need is B app definition valid. Transition a to b and not a is final. So, yeah, we've got three stages. This is like the end. This is like setup, and this is like the running step.
00:34:27.644 - 00:34:44.196, Speaker B: And in the running step, most of what we do, obviously these things have to hold, whatever. But in the running step, most of what we do is we delegate valid transition to the app definition, which in this case would be the rock. Sorry, the tic tac toe contract, which.
00:34:44.298 - 00:34:50.368, Speaker A: Definition, it only verifies that updata was transitioned properly. And the default outcome.
00:34:50.544 - 00:35:25.596, Speaker B: Yeah, so this is interesting. We're not quite sure at the moment. We just pass in the whole state, which means that you could write games that have different rules depending on what turn number you're on. And I'm not sure if that's a good thing or a bad thing. We also thought about housing some of this off so that this only looks at the default outcome and the app data. But then we found out that actually, with tictactoe, it's useful to have the turn number, because you can tell who the mover is from the turn number. And then sometimes you want to do stuff dependent on the participant.
00:35:25.596 - 00:35:27.072, Speaker B: So anyway, for the moment, it's just like.
00:35:27.126 - 00:35:31.980, Speaker A: But the contract can emulate the turn number, right? They can just put it in the updater?
00:35:32.140 - 00:35:40.740, Speaker B: Yes, obviously. Good point. I don't know. I mean, at the moment, it's just, we just chuck in the whole state and the contract has to understand this.
00:35:40.890 - 00:35:45.588, Speaker A: And so what's the intuition behind having two echoes?
00:35:45.764 - 00:36:29.670, Speaker B: So I'm trying to think what then, what bits I need to explain, to explain that. So you need to know something about how challenges work to understand that. Can I come over and grab your board? Real estate. So let's look a little bit more in depth at the adjudicator. So this is the adjudicator. So the adjudicator is basically like a system of balances. So it has address.
00:36:29.670 - 00:37:30.810, Speaker B: I haven't talked about addresses yet. So we calculate a channel address. So channel address is equal to the hash of the participants and the nonce. So we have the address and say, like, the address of this is like tictactoe number one or something. So it will store an address, a balance, I guess, the number of coins. It will store an outcome, and then it will have some way of doing a challenge, like the challenge timeout and stuff. So here we might have like, tictactoe number one, no balance, no outcome at the moment.
00:37:30.810 - 00:38:21.800, Speaker B: So this is. What was I trying to get to? I was trying to get to the setup. So how do you launch a challenge? So you launch a challenge by providing two states. And what the challenge does is it checks that these two states are a valid transition. And then if it is, it like, makes the default outcome from b pending, and then you have some time so you can respond. In fact, it's just c, you provide a state. So challenge will store this state in the contract.
00:38:21.800 - 00:38:35.710, Speaker B: I guess, really, I should have an extra column here for challenges. So like it actually stores the state. And then to respond, you provide the next state here.
00:38:37.760 - 00:38:40.210, Speaker A: That only works if n is equal to two, right?
00:38:40.580 - 00:39:13.050, Speaker B: Yes, if n is equal to three states. Yeah. So that's the general pattern. And this stuff breaks down pretty quickly if n gets reasonably large. But then state channels break down pretty quickly if n gets reasonably large. So I think it's okay. So why do we need this initial setup? So you need this initial setup because at this point, this point is like a special point.
00:39:13.050 - 00:39:37.436, Speaker B: I guess the way this looks is that you have two states, special .2 states, more states. And these things here we call a pre fund setup. And these things here are the post fund setup.
00:39:37.548 - 00:39:41.164, Speaker A: So post fund is effectively acknowledging the fact that the contract was created.
00:39:41.292 - 00:39:55.910, Speaker B: It's acknowledging the fact that you see the money up there. So it's to stop anyone from being forced into playing a game. Imagine I put my money in, you don't put your money in, and then we're into the game. And if I don't play, I lose. Because that's how the rules of games are set up.
00:39:56.520 - 00:39:59.960, Speaker A: And so that's why Alice puts money first, because she sends the first confirmation.
00:40:00.780 - 00:40:19.036, Speaker B: I mean, okay, so there are a couple of things interacting here. They need these ones before anyone puts any money in, because this is exactly what you need to launch a challenge. So, like before you've got two states, you're not safe to put any money in the contract, because if your person doesn't give you the other state, then you've lost your.
00:40:19.218 - 00:40:29.376, Speaker A: So effectively, for Alice to exit, she needs this state from Bob. So technically, Alice doesn't need her state, but she needs from everybody, she needs Bob's state.
00:40:29.478 - 00:41:36.760, Speaker B: And the reason Alice goes first is because if the outcome stops here, she will get the money back first. So it's like slightly different. We always do it this way around. I think maybe it works the other way around, I'm not exactly sure, but pretty much this is the way to do it. So the actual thing about this state here is that we're now beginning to get into theory of why this works. And one of the things that's important is knowing what the states hold to your holding mean. And really what that means is from this state, what outcome can I get on chain? Like what, what outcomes? What outcome is finalizable based on what I hold? And this point is a slightly magical point because both participants have a finalizable outcome at this point, because Alice is holding two states, she knows that the outcome can't change without her signing another state.
00:41:36.760 - 00:42:32.920, Speaker B: Bob can have the same logic, and this is actually really important when you start building up state channel networks. The logic of, like, at what point can I guarantee that the things I'm holding allow me to put something particular on chain? So, like, Bob can also, Bob knows that by withholding his signature at this point, no other outcome than this outcome is possible. So this funding point and these set up things here make this funding point a universally finalizable outcome. The other point you have, that is when you've got a finalized state. Again, I haven't told you how that works yet, but if you hold a final state and I hold in his final state, signed by the other person, then we also have a universally finalizable outcome for reasons under some assumptions. But that can go wrong. But if you follow the protocol, it can't.
00:42:33.260 - 00:42:40.716, Speaker A: So, question. So here, Bob. Bob is only putting money into the contract when they see message number three, right?
00:42:40.818 - 00:42:45.964, Speaker B: No, when he sees message number two, at this point, everyone can put money in.
00:42:46.082 - 00:42:57.388, Speaker A: But how would Bob, like, imagine Bob only sees message number two. He puts money in, he puts his five, and then Alice never responds. How does he exit?
00:42:57.404 - 00:42:58.944, Speaker B: What challenges with these two?
00:42:59.062 - 00:43:00.368, Speaker A: Challenges with these two.
00:43:00.454 - 00:43:12.790, Speaker B: And then the worst thing Alice can do is respond with this one. Maybe that's what he wanted. Maybe Alice is now alive again and they can continue. Or if that's not what he wanted, he can then challenge again with these two, because he's now got this one.
00:43:14.840 - 00:43:20.600, Speaker A: So let's go through the example. Right. So, example number one, Bob has put money Alice hasn't. Right.
00:43:20.670 - 00:43:21.956, Speaker B: So we're assuming that breaks.
00:43:21.988 - 00:43:23.690, Speaker A: I'm pretty sure. So, let's see.
00:43:25.600 - 00:43:32.300, Speaker B: I guess we also need. Shall we assume that this is the outcome at this point? This is the starting outcome.
00:43:35.280 - 00:43:36.990, Speaker A: This has to be fives, right?
00:43:37.840 - 00:43:45.020, Speaker B: Yes. Okay, let's make them fives. Yeah. If we're doing the proper protocol.
00:43:47.060 - 00:43:47.436, Speaker A: We'Re.
00:43:47.468 - 00:43:48.684, Speaker B: Diving right into the subtleties.
00:43:48.732 - 00:43:58.580, Speaker A: Now, I can convince myself that if Bob is waiting for Alice to post a message, then it seems to be safe. But you're saying Bob doesn't need to wait before he deposits money.
00:43:58.650 - 00:44:02.870, Speaker B: So Bob is holding this and he sent that.
00:44:03.640 - 00:44:06.932, Speaker A: And you're saying at this point, it's safe for both of them to put money in.
00:44:06.986 - 00:44:10.296, Speaker B: It's safe for Alice to put in money first and then for Bob to put in money.
00:44:10.318 - 00:44:14.010, Speaker A: Oh, so Bob is waiting for Alice to put money, not necessarily for her to post the.
00:44:14.620 - 00:45:02.730, Speaker B: Yeah, so they do these messages, then Alice puts in money when Bob sees that's definitely gone through, Bob can put in money. And actually probably what you'd want to do is make Bob's transfer in conditional on there being a certain amount of money from Alice in there so that you can't get real problems where Bob, because if you end up with five in the contract, which is Bob's, then Bob is screwed and Alice can just take his money because Alice gets the money first. So it's important for Bob. Yeah. So when they're holding these things, and the reason it's safe when they're holding these things is they can challenge, either of them can challenge, they know that both of them, by withholding this message, and because of these rules, they can tell that the default outcome never changes.
00:45:03.500 - 00:45:07.240, Speaker A: But Alice sends this message when she observes everybody depositing.
00:45:08.060 - 00:45:22.512, Speaker B: So Alice shouldn't, Alice shouldn't send that message until she's seen everyone's money in there. That's Alice saying like, I am okay for this game to proceed after she sent this, Alice is into the game.
00:45:22.646 - 00:45:30.480, Speaker A: But because Alice has the right to withdraw first, does she has anything to lose if she only waits for herself to deposit?
00:45:31.720 - 00:45:51.640, Speaker B: Probably not. But what if the first rule of the game was for Bob to take all the money? Alice could be forced into that. And I don't mean, I think it's important to have these because you don't know what the game developer, what the application rules are going to be.
00:45:51.790 - 00:45:58.872, Speaker A: Right. I see. And so by the step two n effectually what we know is that everybody recognized that the money were deposited.
00:45:58.936 - 00:46:00.860, Speaker B: Yes. And everyone is happy to proceed.
00:46:05.040 - 00:46:06.508, Speaker A: That, I guess makes sense.
00:46:06.674 - 00:46:51.100, Speaker B: Cool. I wonder what I should talk about next. Maybe you should do the finalized stuff. So we've got another thing here. Finalize a b. And I'm going to put stars here to say that these are states with is final is true. So like what this does, if you call finalize with two states where this is a valid transition and they both have its final true, then your outcome goes straight into the outcomes column without any timeout or anything.
00:46:51.170 - 00:46:52.716, Speaker A: And again, it's as many arguments, as.
00:46:52.738 - 00:47:03.410, Speaker B: Many participants, as many arguments as there are participants. That's how you get things into this stuff.
00:47:06.900 - 00:47:24.950, Speaker A: So if we're playing tictactoe and the game is over, if I'm a good actor, I will sign his final yes. And then it settles. Makes sense. So another question I have is, when I challenge, does my challenge have to have a higher turn number or it could be the same turn number?
00:47:29.180 - 00:47:39.370, Speaker B: I guess this is the thing that I was talking about earlier, do we also store in here the highest successful. I mean, it's really the highest successful response that you want to store.
00:47:39.760 - 00:47:51.630, Speaker A: So my question is, imagine I'm Bob, and I'm playing some game with you, and I'm making a turn, but then I realize it was a bad turn, for example. So I'm making another one, and I'm exiting with that one.
00:47:53.060 - 00:48:21.400, Speaker B: Okay, so you've gone right into the details of things. There's another method. So this is a general problem like what happens with alternative moves. And any state channel protocol has to handle that. I could always send you turn number three and then send you an alternative turn number three. And the way that works in this protocol is that you get to choose. So you can choose whether you go from three or from alternative three.
00:48:21.400 - 00:48:52.868, Speaker B: And this is actually pretty useful in a payment channel. Say, like, say in this very example, Alice sends. I mean, this is not the payment channel anymore. But if I send you six six four, and then I send you seven three, and then I send you eight two, I can rely on you assumingly picking eight two out of that. So you can actually use this alternative turn number stuff to your advantage when designing protocols. I see. If I give you multiple turns, you get to choose.
00:48:52.868 - 00:49:34.770, Speaker B: We have to have that here as well. So there's actually another method which is respond with alternative. And here you have to provide. So, like, say you challenged with, say, this was like, number four. Maybe four is not a good number because that's too low. But say this was number seven and this was number eight. So how do I respond with an alternative? Well, I'm like, okay, I think what you do is you do b, primed c.
00:49:34.770 - 00:49:57.844, Speaker B: So I give something else. This is, like, a little bit hazy. We're getting into, like, depth, but basically you need something like this. And so this has number eight, and this has number nine. So this is you saying you were at seven. I moved to eight. Now I want you to move to nine.
00:49:57.844 - 00:50:01.624, Speaker B: And this is me saying, but you also gave me this other eight, and I want to move on from that.
00:50:01.662 - 00:50:05.610, Speaker A: So from this perspective. So challenge is an exit, right?
00:50:06.460 - 00:50:07.656, Speaker B: Challenge could be an exit.
00:50:07.688 - 00:50:15.676, Speaker A: Right. And so for me, I should always challenge with B being my message, right. Because if it's not my message, you.
00:50:15.698 - 00:50:17.710, Speaker B: Mean you challenge with this first.
00:50:19.440 - 00:50:21.128, Speaker A: So let's say that I'm Alice.
00:50:21.224 - 00:50:21.688, Speaker B: Yes.
00:50:21.794 - 00:50:41.536, Speaker A: Right. And so in the channel, Bob sends me a message. And Bob says, I'm giving you all the money. It's all yours now. And then I go to here well, it only works if there's also Carol. Yeah. So let's say Amelis is also Bob.
00:50:41.536 - 00:50:42.352, Speaker A: And there's Carol.
00:50:42.416 - 00:50:43.030, Speaker B: Yeah.
00:50:47.180 - 00:50:48.680, Speaker A: No, I think it should be fine.
00:50:48.830 - 00:50:51.096, Speaker B: Okay, cool.
00:50:51.198 - 00:51:01.000, Speaker A: So what I'm trying to see if I can get screwed if I'm exiting b, which was a state on which I acted upon already. But then someone else.
00:51:01.070 - 00:51:02.484, Speaker B: Yeah, someone else can wait.
00:51:02.542 - 00:51:13.730, Speaker A: Creates an alternative state. And something on top of that. But then C should be someone who's not me. But then if C is something that's not me. Then why did they act upon a state which was not?
00:51:14.740 - 00:51:22.130, Speaker B: Yeah. At each point, if it branches out. You have the ability to bring it back to a single thing.
00:51:23.300 - 00:51:30.630, Speaker A: This should be either state that I sent. Or state which was sent directly to me. Right. If I challenge with a state which was in between.
00:51:31.240 - 00:51:58.220, Speaker B: So this is kind of interesting. I think it works. But say you're in a channel with both Alice and Carol. And you went. Then Alice went. Now Carol hasn't gone. You have to be able to challenge with the carol's previous state, your state, and then Alice's state.
00:51:58.220 - 00:52:09.504, Speaker B: Because otherwise Alice could grief you by not launching that challenge. So there are some situations like any person might need to challenge at any point. To force the next thing in the line.
00:52:09.542 - 00:52:29.720, Speaker A: Also, I guess my argument is rather. Is that if there's Alice, Bob and Carol playing, right? So Alice goes first, then Bob, then Carol. So if Carol sent me some message. And so let's say we're also doing some other actions. So let's say it's a payment channel. And Carol sent me money. I gave her Latte.
00:52:29.720 - 00:52:49.950, Speaker A: Then I know that that money is mine. Because I can exit. What I should not be doing is imagine that. Some action by Bob. So Bob sends message to Carol. There's some message from Bob to Carol. Which in some way tells me that it's good for me now to provide the service.
00:52:49.950 - 00:53:04.020, Speaker A: So that is dangerous. Because now if Bob and Carol are colluding. They can sort of remove that message. Right. Because Bob can then say, oh, that's actually not message I wanted to send. And Carol can immediately respond to his challenge.
00:53:05.320 - 00:53:23.384, Speaker B: This we. I guess we're getting back into that. Like, when are things finalizable? When do you know about? So, like the question of, like when I said this was a universally finalizable state. At each point, at various points in the channel, you have a finalizable state. You have a finalizable state. Exactly. Before you send out your next state.
00:53:23.384 - 00:54:00.292, Speaker B: Because at that point you could not sign anything else. And you could ensure that the channel finishes. And because that's always a possibility that you can always exit in your state. That's why we allow this transition to is final from any state. So instead of just, if you can achieve an outcome by just stopping and griefing everyone until the timeout goes, we let you do that outcome without doing that. So the other thing you can also do when it's your turn is just to decide to bail out of the algorithm and take the default outcome by signing in its final state.
00:54:00.426 - 00:54:15.464, Speaker A: But signing its final is not exactly the same as going offline, because if I go offline, if they try to exit and I challenge, I send them the new state, they can use that state now to proceed, right?
00:54:15.502 - 00:54:15.704, Speaker B: Yes.
00:54:15.742 - 00:54:18.730, Speaker A: Like they can unblock, I cannot stall the system.
00:54:19.180 - 00:54:22.620, Speaker B: Once you've signed is final and sent that to people, then.
00:54:22.690 - 00:54:28.168, Speaker A: Oh no, what you're saying is that if I choose not to respond, they can finalize the state. Yes. Makes sense.
00:54:28.354 - 00:55:20.400, Speaker B: Yeah. So yeah, we've got this respondable alternative as well. So you need to have this in the adjudicator to allow the possibility that basically to enforce the thing that if I send you multiple states, you get to choose. Okay, so I feel like we've covered most of the valid transition stuff. I don't know if it's useful to actually think about tic tac toe. I mean, if you think about what the rules are for something like tic tac toe, you can kind of figure it out, I guess one of the way to think about this. Yeah, maybe I should draw this, actually.
00:55:20.470 - 00:55:33.030, Speaker A: Can we get back to universally finalizable state for a second? So let's say I observe certain states, right? Universally finalizable means that either this state will be finalized or some state which is strictly better for me. Right?
00:55:33.880 - 00:55:42.688, Speaker B: Yeah. Okay, I misspoke when I said universally finalizable state. What I meant was universally finalizable outcome.
00:55:42.784 - 00:55:43.430, Speaker A: Right.
00:55:44.040 - 00:56:16.096, Speaker B: So you know it's going to be exactly that outcome. And before your turn, you have a finalizable outcome. It's not universally finalizable. It's quite unusual in a state channel to actually have universally finalizable states. But we can actually design a game called the consensus game, which is like just a game like Tictactoe, which has the property that you transition from one universally finalizable state to another. And that turns out to be very important when building networks. So you can get that property if you want it, but you have to design that into the game.
00:56:16.096 - 00:56:27.316, Speaker B: And most games you don't really want that and that's one of the strengths of having this flexibility to design your transition function and not have to have everyone double sign anything.
00:56:27.498 - 00:56:39.576, Speaker A: What's the definition of universally finalizable? That means that that state and no other state will be finalized effectively. Right. And finalizable means that that state can.
00:56:39.598 - 00:57:29.944, Speaker B: Be finalized, but so you hold a finalizable outcome if you have a strategy for getting that outcome into the adjudicator and no one can stop you. So, like, if it's your turn and you haven't signed anything and sent it to anyone yet, your one strategy to finalizing that outcome would be to challenge yourself and not respond to that challenge. Another strategy would be to sign a conclude state and then release that to the world. Because after you've signed a collude state, everyone should not collude, conclude state, or is final state, then everyone knows that you're not going to sign it or you shouldn't sign anything else. That's you saying like, I'm out. You guys can do the is final. We can just challenge on chain or whatever.
00:57:29.944 - 00:57:35.760, Speaker B: There's no way to change the outcome once you're in an is final state. And universal finalizable means that everyone holds.
00:57:35.780 - 00:57:38.040, Speaker A: That property for that outcome, for that particular outcome.
00:57:38.120 - 00:58:15.930, Speaker B: Yeah, and if you think about the definition there. So this unbeatable strategy bit, you're in one of two situations. Either like one person holds multiple, one or more finalizable outcomes. So it's possible for you to have two finalizable outcomes. If I've given you multiple moves, all of those outcomes to you are finalizable at that point in time. It might also be that you're the last person. Basically, having multiple finalizable outcomes is like having an option, I've given you this thing and you can do it.
00:58:15.930 - 00:59:10.730, Speaker B: You can have multiple finalizable outcomes, or everyone can hold the same finalizable outcome. It's impossible to have two different people holding two finalizable outcomes, because if a is finalizable for Bob, and if a and B are finalizable for Bob, and a and B are finalizable for Alice, then either of them can choose either of them, and they could. It makes. Yeah, that, and I think that is like, in some ways, that is the key logic underneath state channels. What outcomes are finalizable given the states you hold? And that's the bit that we developed a lot in the nitro protocol paper. Like, how do you reason about when you can finalize an outcome on chain, which is obviously like important?
00:59:11.500 - 00:59:16.344, Speaker A: Cool. So that's most of it for two participants, right?
00:59:16.542 - 00:59:33.532, Speaker B: Yeah. And multiple participants isn't really that much different. So I guess what we've done here. So I said there were two parts. The first bit is how these things transition off chain. And that's the bit that I guess we've just done here. Like, the one bit that we haven't looked into is this app definition.
00:59:33.532 - 01:00:30.130, Speaker B: But you can probably figure out what the app definition is for something like this. You think of these apps as state machines, I guess so, like with Tictactoe, you're doing something like you're moving from x turn to zero turn, and then you can transition from x turn to, like, x one. You can transition from zero one, or you can transition to draw. And in fact, I think only x, just because there are odd number of moves, only x can actually transition to the draw. Only o can transition to one. These can obviously transition up. You have like a starting state.
01:00:30.130 - 01:00:53.432, Speaker B: That's what you would put in the initial things. You would start with the empty board here. It has a stake. So you basically have. The way you write these apps is you think of these different states. You have to figure out how to encode those in your arbitrary bytes, up to you to pick how to do that. Then you have to enforce these things.
01:00:53.432 - 01:01:39.252, Speaker B: You have to say that from O's turn to X's turn, you have to change the balances according to this rule so that the person who stops forfeits. If you want to encode that rule, you might actually want to make this dependent. You might want to say that at the beginning of the game, stopping isn't too bad. This is kind of really interesting because of that point that you brought up, and in fact, so the Pisa team. So Patrick McCrory and Chris Buckland wrote a paper about playing battleships on the blockchain and how it was really bad, or in a state channel, because in the worst case, I can make you do every single move on chain. And so that's kind of bad. But I think there are some ways around that by designing your incentives properly.
01:01:39.252 - 01:02:22.020, Speaker B: The problem here is if I don't respond to you on chain, it's like I've lost everything. Whereas if you get to a point, like with tic tac toe, this isn't such of a problem because it's where the value of the game, it's where my perceived value of the game is different from these outcomes that I'm compelled to continue. And you can almost grief me infinitely on chain, you get into bad situations, but if you can get to points where everyone agrees on the fair value. Like in this payment channel, you can't grief someone, because if you grief me and you force me to move on chain, I can always just be like, I'll just take the money, I'll just take the fair split.
01:02:22.600 - 01:02:26.164, Speaker A: But that effectively requires you to have a value function for the game, right?
01:02:26.202 - 01:02:26.464, Speaker B: Yes.
01:02:26.522 - 01:02:33.700, Speaker A: Like, if you're playing go, like tic tac toe is easy, but if you're playing go, you know, the value function will be pretty complex.
01:02:33.780 - 01:03:05.270, Speaker B: Yes. And chess as well. But if you can kind of get it a little bit closer, then you kind of lose a maximum loss. And for something like chess, you could imagine for the first ten moves, it's fairly cheap to exit because most games are not decided in the first ten moves. Of course, that's a problem if you get into one of those situations where you actually get checkedmate in the first three moves. So it's kind of complicated designing these for these long running games. It's pretty complicated figuring out what the default outcome should be.
01:03:05.270 - 01:03:29.736, Speaker B: But a lot of games don't have this. So anything you do multiple rounds on, like, Tictactoe, we want to play ten rounds of tictactoe. After any round, there's a fair stopping thing, so you can't be griefed that much. You're limited. Like, for most little applications, you want to run an estate channel, say you want to trade some x coin for y coin or whatever. Again, you can't be infinitely griefed there. There are like three moves to something.
01:03:29.736 - 01:04:23.836, Speaker B: If we're playing like rock, paper, scissors, there's a commit reveal there. You have to be careful about the incentives to make sure that if I don't reveal, then it's like I've lost. But in there, there's like four states that you go round, and every time you come back to the start again, then that's a fair place to end the game. So I think there's kind of like some interesting research to be done here around that notion of when the game has a fair value that is easily calculatable. When can you stop? When can you get an out? If not, how long it is it till that point? Because that's like your griefing danger, as it were. Anyway, so I think that's probably enough about these games, because I guess you can probably figure out how these things work and their examples. So we've actually got this tictactoe game working, so you can actually play it in the browser and look at the contracts and stuff.
01:04:23.836 - 01:04:24.750, Speaker B: Right?
01:04:25.200 - 01:04:27.310, Speaker A: Is there anything else we want to cover.
01:04:28.960 - 01:04:34.096, Speaker B: So this is like everything about how the off chain stuff works.
01:04:34.198 - 01:04:37.890, Speaker A: You wanted to cover the exciting bit with coming up next. Which one?
01:04:39.860 - 01:05:36.180, Speaker B: What I was going to talk about next was how we can go from these off chain rules. No to state channel networks. So breaking the link between one deposit to one state channel interaction. So it's actually a lot to do with how this on chain stuff works. So say I've got this tic tac toe game here, and it's got ten in it, like Alice deposited and deposited. And somehow I've got this outcome which is like Alice gets two, Bob gets eight. Okay, so how do we actually get this to Alice and Bob? So there's another method on the adjudicator called and how to write.
01:05:36.180 - 01:06:13.486, Speaker B: And it's transfer, I guess, like from to and then amount. Okay, so I call transfer on this. So starting off once. This stuff means that you can only ever get one outcome per channel. Once a channel has an outcome, it's done. There's no way to put another outcome on chain. So once this has an outcome, we can start operating on it.
01:06:13.486 - 01:06:55.340, Speaker B: So like I can call transfer from tic tac toe to Bob amount eight, say. And the algorithm here is like, I go to tictactoe. Does it have ten in it that goes to. Does it have eight in it that goes to Bob? So if this was only like eight, the answer to that would be no, because the first two of this goes to Alice and the next six goes to Bob. But Bob's in luck because there is ten in it. So when I call this, the following thing happens. Bob's address gets eight in it.
01:06:55.340 - 01:06:59.660, Speaker B: This goes down to two that changes to zero.
01:07:01.150 - 01:07:04.222, Speaker A: And so Bob can just extract it from there.
01:07:04.276 - 01:07:25.460, Speaker B: And then we have like a withdraw function from. And then like destination or something, which allows Bob to withdraw this from his adjudicator balance into his Ethereum address. And you have to be a little bit careful about that. Has to be signed by Bob's key and all that sort of.
01:07:28.150 - 01:07:32.278, Speaker A: So it's transfer function, right? Oh, no, transfer function. Anyone can call it.
01:07:32.364 - 01:08:04.910, Speaker B: Yeah, anyone can call the transfer function. It just moves around balances in this thing here. So that's how that works, obviously. Like Alice can do the same thing. We end up with zero, Alice 20, and then Alice and Bob can withdraw these. These addresses are interesting because these addresses are different to that address. And the difference is that someone knows the private key to this address, which means that somebody can withdraw from this address with this address.
01:08:04.910 - 01:08:17.582, Speaker B: Somebody knows the channel such that the hash of the participants and the nonce go to this address, which means that people can put outcomes in this address. So you have channel addresses and people addresses.
01:08:17.646 - 01:08:21.026, Speaker A: So to an extent, it's similar to contracts and accounts on ethereum.
01:08:21.058 - 01:09:19.330, Speaker B: Yes, exactly. And that's kind of interesting that we are kind of recreating ethereum and ethereum in some way. So the question now is, what if these weren't participants? There's nothing that says these have to be participants. Like, what if, for example, this had been like ten, Alice gets two, and rock, paper, scissors gets eight, where rock, paper, scissors is another channel. So then rock, paper, scissors could get eight out of this. And then maybe at some point in the future, this becomes a two, b six, or something. So I guess this is the key insight that the outcome of channel can allocate to another channel, and that can allow you to build up state channel networks.
01:09:19.410 - 01:09:28.502, Speaker A: But initially, when tic tac toe address was created, right, there was balance, but there was also the initial outcome. So how does the initial outcome.
01:09:28.646 - 01:10:21.920, Speaker B: So the initial outcome, remember, is not on chain. And if this allocates to two rps eight, then you better hope that Alice and Bob hold the initialization for that RPS contract. And so you're beginning to see how this might get another different color. So, got a way of drawing diagrams for this. This is the adjudicator. This would be like tictactoe, and then this would allocate. So this would be a two, this would be RPS eight, and then this would eventually be a two and b six.
01:10:23.730 - 01:10:42.974, Speaker A: But what's the value? So why, how is it fundamentally better than just having RPS to be part of that, of the state transition for tictactoe? So you just have one, which is tictactoe and RPS.
01:10:43.102 - 01:11:10.170, Speaker B: So this is a stupid example. In actual fact, this wouldn't be rock, paper tictactoe. This would be something called a ledger channel. And a ledger channel is just one of these things. Looks exactly the same, but its default outcome allocates default balances to Alice and Bob, and then things to other channels. So imagine if at this point. So the whole thing we're trying to get away from is having to do an on chain transaction to fund this channel.
01:11:10.170 - 01:11:16.398, Speaker B: So imagine that. Imagine that, Alice. And let me just.
01:11:16.564 - 01:11:18.960, Speaker A: But so far, it is on chain transaction, right?
01:11:21.890 - 01:11:24.240, Speaker B: Let me just get some more space.
01:11:25.250 - 01:11:28.642, Speaker A: So this transfer call is on chain, right?
01:11:28.696 - 01:11:30.926, Speaker B: Yes, the transfer call is on chain.
01:11:31.118 - 01:11:32.498, Speaker A: So we didn't get rid of the.
01:11:32.504 - 01:11:35.762, Speaker B: On chain transaction, but we don't need the transfer call.
01:11:35.816 - 01:11:36.382, Speaker A: I see.
01:11:36.456 - 01:12:01.346, Speaker B: Okay, so imagine you start in this situation. That's the adjudicator. This is a ledger channel, and it gives, like, five, let's say. Let's say it gives ten to Alice and ten to Bob. And it's funded with 20 on chain, as it has to be. So Alice and Bob set this up, like, at the beginning of the month, whatever. They now want to play tictactoe.
01:12:01.346 - 01:12:40.006, Speaker B: So they create a tic tac toe channel. And these are actually diagrams of outcomes. So this is like tic tac toe, and the initial state is five to Alice and five to Bob. Okay, so they've set this up. They're at their funding point. This is two things in this is a universally finalizable outcome for them. We'll assume that this is also a universally finalizable outcome, because these ledger channels are going to use the consensus game that I talked about earlier, which moves you from one universally finalizable outcome to another one.
01:12:40.006 - 01:13:40.028, Speaker B: So what can they do now? So, we want to fund this off chain. So this is just like one of these things, so I can sign an update to that, which takes it to five to Alice, five to Bob, and ten to tictactoe. Okay, so this is like the outcome thing. At any point here, due to the rules of how state channels work, at any point here, if I challenge on Tictactoe that would look like this, you could end up with all these things work independently. So Tictactoe has a balance of zero, but it could still have a challenge, and it could still have an outcome of a, a four, b six, which when I, at some point in the future challenge with this one would like, I see at the end of the.
01:13:40.034 - 01:13:45.876, Speaker A: Day, I will just transfer monies first from ledger to tictactoe, and then from tictactoe to block.
01:13:46.008 - 01:14:19.480, Speaker B: And the fact that there's a threat of this happening means you don't have to do it all the time. So let me just quickly show you how that works. So we're in this situation where we've got a ledger channel, a has still got a balance held there, b has still got a balance of five. We've got this tic tac toe thing load. This is like, while we're playing the game, this is no longer in a universally finalizable outcome. Like it's oscillating between Alice and Bob. And then imagine it comes to an outcome.
01:14:19.480 - 01:15:17.230, Speaker B: So, like, I've then got this, and then tic tac toe is now it finished, like eight to Alice, two to Bob, five. Five. I can then close this channel off chain by defunding it and just like absorbing those into the going off to the rails here. So Alice gets five plus eight, which is 13, looks like a b, and then Bob gets two plus seven. So what I've done here is I've got two state channels, one running the ledger channel, one running tic tac toe. We had the money in the ledger channel. I've managed to open this tic tac toe game, fund it off chain, do everything, close it off chain as well.
01:15:17.230 - 01:15:37.020, Speaker B: And come to your other question, like, why do you even need to do this? Why not just have the rules of tictactoe in the ledger channel? Well, you can have multiple channels working independently. Yeah. So I could have tic tac toe, I could have rock, paper, scissors, I could have chess. All operating with independent updates and independent challenges.
01:15:37.180 - 01:15:41.888, Speaker A: And so ledger channel, that's a channel that is operated by some centralized entity.
01:15:42.064 - 01:15:45.888, Speaker B: No, it's just Alice and Bob maintaining.
01:15:45.904 - 01:15:47.060, Speaker A: The channel to fund.
01:15:47.210 - 01:15:56.472, Speaker B: Yes. So basically, this thing is, the job that this is playing, is deciding of this money that's held up on chain. How should it be split up?
01:15:56.526 - 01:15:56.904, Speaker A: Makes sense.
01:15:56.942 - 01:16:21.264, Speaker B: And we can change that off chain. And then the really interesting bit is like, this still has a weakness. Like, if I want to transact with you, I still need an on chain deposit with you. But you can play this same game with virtual channels. So, like, I have a connection to a hub, you have a connection to a hub. We can create a tictactoe game. We can put agreements in our arms with the hub to fund that tictactoe game.
01:16:21.264 - 01:16:32.580, Speaker B: We can play it and then we can absorb those back in again. And it's supported by this staff at any point. If we stop, we can resolve everything off chain. And that's what allows these to happen trustlessly.
01:16:34.280 - 01:16:39.120, Speaker A: And so when you say hub, it's effectively the way for two people. Virtual.
01:16:39.200 - 01:16:41.864, Speaker B: Yeah. Intermediary is better is maybe a different word.
01:16:41.902 - 01:16:47.210, Speaker A: So it's effective. Someone who relays messages between Alice and Bob signed by Alice. And.
01:16:51.820 - 01:17:16.816, Speaker B: The thing that the hub. So say this is like a hub and this is Alice and this is Bob, and they have these channels. This is really bad because this means something different to those things. But now, if Alice and Bob want to play a game between them, the thing that the hub is doing is providing the funding. So it's a bit like you're doing things with the hub instead of the.
01:17:16.838 - 01:17:20.168, Speaker A: Chain, but ultimately it's still Alice and Bob sending messages directly.
01:17:20.204 - 01:17:28.570, Speaker B: They are sending messages directly to each other. The hub doesn't know. The only thing the hub sees is the opening balances and the closing balances, much like what the chain would see in the initial thing.
01:17:30.780 - 01:17:37.080, Speaker A: But then there's also some mechanism to challenge hub. If the hub does not cooperate with the updating balances.
01:17:37.660 - 01:17:45.656, Speaker B: Yes, the challenge of the hub is just exactly the same challenges you've seen here. So this is just the ledger channel you have with the hub?
01:17:45.768 - 01:17:50.072, Speaker A: Yeah. So there's effectively some sort of app definition which you have with the hub.
01:17:50.136 - 01:18:07.300, Speaker B: The consensus game, which is like, I propose an update. You give me back that update. The hub could not play ball. But if the hub doesn't play ball, then we just put these things on chain and let it play out. And the adjudicator. And that's always the threat. That's why this stuff is safe.
01:18:07.300 - 01:18:43.372, Speaker B: The thing that I haven't shown you, which I won't show you, is the fact that you actually need something a little bit different than just these allocation outcomes. You need something called a guarantee outcome to be able to open and close these safely with the hub under some. Well, to open and close virtual channels. You need this extra sort of outcome which goes beyond this. But that really does begin to get a little bit subtle to see why this. At first you might think that this is enough, but it's not.
01:18:43.426 - 01:18:50.110, Speaker A: I think, well, let's go through the attack. So let's say this is all we have. What can go wrong?
01:18:53.360 - 01:19:08.308, Speaker B: So we need. This is enough for everything I've shown you here. The thing this is not enough for is to do a virtual channel. To do that, I would have to probably show you the virtual channel construction, which is going to take a while. So I don't know if. Do you want to.
01:19:08.474 - 01:19:09.664, Speaker A: Let's give virtual channels.
01:19:09.712 - 01:19:39.772, Speaker B: Okay. This is where it begins to get really interesting, but we're kind of out of time. I guess I'd have to go through this at different time or something. But I guess to give you a little bit of insight into why that happens. One of the rules of state channels is you can only depend on a result of a state channel if you're a party to that state channel. Like if Alice and Bob. So the place where this gets complicated, Alice and Bob have their outcome from tic tac toe.
01:19:39.772 - 01:20:12.040, Speaker B: And they send that to the hub. And the hub's got to update these things independently. The hub sort of can't trust what Alice and Bob is telling them. Because Alice and Bob could give one outcome to one arm and one outcome to the other arm. And it could be that these two arms are forced into resolving. So the way this would work, I haven't really said this, but they would each put in five. And if this came out as eight two, then the hub would rebalance 8282.
01:20:12.040 - 01:20:54.728, Speaker B: So the hub still has their ten, but it's like moved around and Alice and Bob have got their eight two. So the danger for the hub is that it's forced to resolve that and it doesn't maintain its ten. So that's the safety property you need for the hub. And that's difficult when the hub can't trust anything that comes out of Alice and Bob channel like in its final state. Sure they could put it on chain and then the hub can trust it because it knows it's never going to finalize somewhere else. But they end up having to have like a joint. So in virtual channels you actually need a joint like ABC channel, you need a three person channel to have the updates from it.
01:20:54.728 - 01:21:09.308, Speaker B: And then you need to. There are actually sort of ways you can do it with this. But this is too high level to make me interesting. But it's all in the nitro chapter on the paper if you're interested in this stuff.
01:21:09.394 - 01:21:20.930, Speaker A: Cool. Okay cool. That's quite a bit of stuff. So dant, let's spend like 1 minute on non technical stuff. So this is all live, right?
01:21:23.460 - 01:21:28.564, Speaker B: The basic games are live. We're currently working on this ledger stuff and then after that we'll work on this virtual stuff.
01:21:28.602 - 01:21:30.100, Speaker A: Okay, so virtual stuff isn't live.
01:21:30.170 - 01:21:45.944, Speaker B: The virtual stuff is not live. The ledger stuff is not yet live. But a lot of the complexity in this stuff is building the off chain software to support it. So yeah, it just inherently gets pretty complex and trying to think through all the different stuff is.
01:21:46.062 - 01:21:51.020, Speaker A: But the product is like an SDK on top of future building games or there is some sort of.
01:21:51.170 - 01:22:15.872, Speaker B: So we're really just developing a protocol and that other people can use for this for various stuff. Like you can already write these games like Tictactoe on it, they'll be like direct channels. So we'll need to do. It doesn't support this ledger channel stuff yet, but it soon will do. The stuff that we're actually building is a wallet. So your wallet will run in the browser to play the game. To play the game.
01:22:15.872 - 01:22:49.736, Speaker B: So all you need, the way it works at the moment is like if you wanted to make one of these games like Tictactoe, you create the onchain smart contract, you'd write a front end and then you would import our wallet. And the thing that wallet does for you is it stores the states, it does the signing. In the future, it will check that the valid transition function is true, so it can emulate some solidity code that it pulls down. And check that your wallet is not signing things. It responds to challenges. It allows you to launch challenges. It does basically the protocol part of it, so that you can just focus on the game part of it and that wallet.
01:22:49.736 - 01:23:23.764, Speaker B: And then the other thing that we're building is like, we already have some bots that support that protocol, but the other thing we'll be building is the hub, the intermediary that talks to that wallet. So from you, as an application developer, you won't notice whether your app is running in a virtual channel or in a ledger, sub ledger channel or in a direct channel. And the way you code your app, at some point in the future, you'll magically get an upgrade where your state channel application will run completely off chain without you making any changes to it. You'll just import an updated version of the wallet, and the wallet will speak to a hub and it will work.
01:23:23.882 - 01:23:29.228, Speaker A: Cool. Okay, awesome. So that concludes the video. Thanks for watching.
01:23:29.274 - 01:23:33.050, Speaker B: Now close.
